<?xml version="1.0"?><st-source><!-- Name: SiouX-HttpNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.BundleName: SiouX-HttpBundleStructure: a Store.BundleForParcelComment: HTTP implementation using Xtreams with emphasis on efficiency and scalability. To employ this HTTP implementation use a subclass of HttpResponder. This implementationfocuses solely on the server side. Consequently requests are only read and responses are only written, causing their implementation and behavior to be quite different.To provide maximum control over the processing of incoming requests, a request instance does not contain the actual contents of its body. Instead the body is processed directly from the socket through a streaming paradigm. Consequently, once a body stream is read once, its contents are not available anymore. This provides complete freedom in terms of what happens with the contents. It can be used to create other object, it can be copied into a an external file, it can be skipped altogether without any memory overhead, or it can indeed be completely copied into memory. When the request processing completes, the request should explicitly released, which will make sure any leftovers of the request are completely exhausted from the socket, so that the next request can be processed correctly.Response instances are constructed in memory, however again their contents do not have to be. Besides the usual String or ByteArray a response contents can be an arbitrary stream which is copied directly into the socket when the request is being sent out. Specifying a Filename as contents works analogously transmitting the file contents with minimal overhead. Finally contents can also be a block which will be invoked at response writing time with an appropriately configured stream as an argument. The block then generates the contents into this stream, which is actually built directly on top of the outgoing socket.Both requests and responses also support multipart bodies. A multipart requests body is a stream that yields request part objects whose bodies in turn are again streams. Due to the streaming nature of this solution, only one part body can be accessed at a time. Once the next part is retrieved, the bodies of the previous parts are not accessible anymore.Multipart response is built with its body being a collection of response parts. Parts can be configured with their own header entries and their contents can be any of the options described above (String, ByteArray, Filename, ReadStream, BlockClosure).For more details refer to the individual class comments.Example: (uses a sample responder from the SiouX-Examples package)	server := SiouX.Server id: 'Experiments'.	server addResponder: SiouX.Hello new; yourself.	server listenOn: 4242 for: SiouX.HttpConnection.	server startOnce started the server is ready to respond to client requests.	'http://localhost:4242/hello' asURI get.		server stop.	server release.DevelopmentPrerequisites: #(#(#any 'SiouX-Server' '') #(#any 'Xtreams-Core' '') #(#any 'Xtreams-Substreams' '') #(#any 'Xtreams-Terminals' '') #(#any 'Xtreams-Transforms' '') #(#any 'Xtreams-Compression' '') #(#any 'URISupport' ''))DisregardedPrerequisites: #(#(#name 'Xtreams-Support' #componentType #package))Parcel: nilParcelName: SiouX-HttpPrerequisiteDescriptions: #(#(#name 'SiouX-Server' #componentType #bundle) #(#name 'Xtreams-Core' #componentType #package) #(#name 'Xtreams-Substreams' #componentType #package) #(#name 'Xtreams-Terminals' #componentType #package) #(#name 'Xtreams-Transforms' #componentType #package) #(#name 'Xtreams-Compression' #componentType #package) #(#name 'URISupport' #componentType #package))PrerequisiteParcels: #(#('SiouX-Server' '') #('Xtreams-Core' '') #('Xtreams-Substreams' '') #('Xtreams-Terminals' '') #('Xtreams-Transforms' '') #('Xtreams-Compression' '') #('URISupport' '') #('Protocols-Common' '') #('Xtreams-Terminals' '') #('Xtreams-Transforms' '') #('Xtreams-Substreams' '') #('Xtreams-Xtras' '') #('SiouX-Server' '') #('URISupport' ''))Version: 8.3 - 8Date: 1:19:06 PM July 14, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jul17.2) of July 14, 2017 on July 14, 2017 at 1:19:06 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>HttpResponder</name><environment>SiouX</environment><super>SiouX.Responder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.HttpResponder</class-id><body>This class further extends the abstract responder with implementation bits that rely on the HTTP implementation from this package. Subclasses will receive SiouX.HttpRequests and have to create SiouX.HttpResponses when executing them. Subclasses are expected to implement following methods:	acceptRequest: path method: method version: version connection: connection	executeRequest: httpRequest connection: connection</body></comment><class><name>FileResponder</name><environment>SiouX</environment><super>SiouX.HttpResponder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rootDirectory pathDepth applyGzipCompression contentDispositionType </inst-vars><class-inst-vars>rootDirectory pathDepth contentDispositionType </class-inst-vars><imports>			private OS.*			</imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.FileResponder</class-id><body>This responder implements basic file upload and download service, allowing to manage files under a configured root directory. The default root directory is 'files' subdirectory of the image directory (it will be created if needed). The default URL path of this responder is 'files'. The responder supports GET, POST, PUT and DELETE methods. GET fetches the contents of the file identified by the request URL, if it is a directory it responds with a textual list of the directory contents. POST allows uploading contents of a new file identified by the request URL, any intervening directories are created as needed (up to a configured maximum depth). POST doesn't update existing files instead use PUT command to update existing files. DELETE can be used to delete existing file or directory identified by the request URL. Instance Variables	rootDirectory &lt;String&gt; root directory files will be upload/download	pathDepth &lt;Number&gt; a possible number of subdirectories to create	applyGzipCompression &lt;Boolean&gt; defines if the gzip compression should be used	contentDispositionType &lt;String&gt;  'attachment' (default) or 'inline'Class Instance Variables	rootDirectory &lt;String&gt; default root derectory files will be upload/download	pathDepth &lt;Number&gt; default number of subdirectories to create	contentDispositionType &lt;String&gt;  'attachment' (default) or 'inline'Here's a short workspace session exercising a file responder with default setup at url localhost:8888/files:	| server |	server := SiouX.Server id: 'Example Server'.	server addResponder: (SiouX.FileResponder path: '/files').	server listenOn: 8888 for: SiouX.HttpConnection.	server start.	'http://localhost:8888/files' asURI get contents.		 nil	'http://localhost:8888/files/test.txt' asURI post: 'hello'.	'http://localhost:8888/files/test.txt' asURI get contents.		'hello'	'http://localhost:8888/files/test2.txt' asURI post: 'hello2'.	'http://localhost:8888/files' asURI get contents.		'test2.txt		test.txt'	'http://localhost:8888/files/test2.txt' asURI delete.	'http://localhost:8888/files' asURI get contents.		'test.txt'	[ 'http://localhost:8888/files/test.txt' asURI post: 'hello' ] on: HttpBadRequest do: [ :ex | ex parameter contents ].		 'The file already exists: sioux/files/test.txt'	'http://localhost:8888/files/factorial.txt' asURI post: [ :out | 10 to: 20 do: [ :i | out print: i factorial; cr ] ].	'http://localhost:8888/files/factorial.txt' asURI get contents.		 '3628800		39916800		479001600		6227020800		87178291200		1307674368000		20922789888000		355687428096000		6402373705728000		121645100408832000		2432902008176640000		'And another short session exercising the same responder from a terminal using curl (this will work on *nix systems, if on Windows you will need to install curl or use another utility):	$ curl http://localhost:8888/files	factorial.txt	test.txt	$ curl --data hello http://localhost:8888/files/test.txt	The file already exists: sioux/files/test.txt	$ curl http://localhost:8888/files/test.txt	helloIf you navigate to the directory where your running image resides, e.g.:	$ cd &lt;path-to-vw-image&gt;	$ curl --data-binary @visual.im http://localhost:8888/files/visual.im	$ ls -l sioux/files/	total 82928	-rw-r--r--+ 1 jkott  staff       151 14 Apr 20:34 factorial.txt	-rw-r--r--+ 1 jkott  staff         5 14 Apr 20:26 test.txt	-rw-r--r--+ 1 jkott  staff  42450228 14 Apr 20:45 visual.im	$ curl --data hello http://localhost:8888/files/a/b/c/test.txt	$ find sioux/files	sioux/files/	sioux/files/a	sioux/files/a/b	sioux/files/a/b/c	sioux/files/a/b/c/test.txt	sioux/files/factorial.txt	sioux/files/test.txt	sioux/files/visual.im	$ curl --data hello http://localhost:8888/files/a/b/c/test.txt	The file already exists: sioux/files/a/b/c/test.txt	$ curl --request DELETE http://localhost:8888/files/a/b/c/test.txt	$ curl --request DELETE http://localhost:8888/files/a/b/c	$ curl --request DELETE http://localhost:8888/files/a/b	$ find sioux/files	sioux/files	sioux/files/a	sioux/files/factorial.txt	sioux/files/test.txt	sioux/files/visual.im	$ curl http://localhost:8888/files	a	factorial.txt	test.txt	visual.imAfter you are done, do not forget to release the server:	server release.</body></comment><class><name>StructuredFieldValue</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parameters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.StructuredFieldValue</class-id><body>Header field value can be simple or structured. A structured value consists from an initial value followed by some number of parameters (name=value pairs) seprated by semicolons. I represent a structured value. My subclasses define specific types of structured values with their specific parameters.Note that header field values are used in both requests and responses, and therefore have to know how to both parse and write themselves. Instance Variables	parameters	&lt;Dictionary key: String value: (String | Number)&gt;</body></comment><class><name>AcceptField</name><environment>SiouX</environment><super>SiouX.StructuredFieldValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.AcceptField</class-id><body>AcceptField represents the "accept" HTTP header fieldhttp://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1</body></comment><class><name>HttpResponseHeaderField</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.HttpResponseHeaderField</class-id><body>Instance Variables	name	&lt;String&gt;	value	&lt;Object&gt; </body></comment><class><name>ChunkedWriteStream</name><environment>SiouX</environment><super>Xtreams.PositionWriteSubstream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>encoded </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>SiouX-Http-Extensions</package></attributes></class><comment><class-id>SiouX.ChunkedWriteStream</class-id><body>Instance Variables	encoded	&lt;WriteStream&gt; internal, encoded destination</body></comment><class><name>EncodedStructuredFieldValue</name><environment>SiouX</environment><super>SiouX.StructuredFieldValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>tSpecials tSpecialsEncodings </class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.EncodedStructuredFieldValue</class-id><body>I represent a structured value which values can be encodedClass Instance Variables:	tSpecials &lt;String&gt;	tSpecialsEncodings &lt;ByteArray&gt;http://tools.ietf.org/html/rfc2231http://tools.ietf.org/html/rfc2231#section-77.  Modifications to MIME ABNF   The ABNF for MIME parameter values given in RFC 2045 is:   parameter := attribute "=" value   attribute := token                ; Matching of attributes                ; is ALWAYS case-insensitive.   This specification changes this ABNF to:   parameter := regular-parameter / extended-parameter   regular-parameter := regular-parameter-name "=" value   regular-parameter-name := attribute [section]   attribute := 1*attribute-char   attribute-char := &lt;any (US-ASCII) CHAR except SPACE, CTLs,                     "*", "'", "%", or tspecials&gt;   section := initial-section / other-sections   initial-section := "*0"   other-sections := "*" ("1" / "2" / "3" / "4" / "5" /                          "6" / "7" / "8" / "9") *DIGIT)   extended-parameter := (extended-initial-name "="                          extended-value) /                         (extended-other-names "="                          extended-other-values)   extended-initial-name := attribute [initial-section] "*"   extended-other-names := attribute other-sections "*"   extended-initial-value := [charset] "'" [language] "'"                             extended-other-values   extended-other-values := *(ext-octet / attribute-char)   ext-octet := "%" 2(DIGIT / "A" / "B" / "C" / "D" / "E" / "F")   charset := &lt;registered character set name&gt;   language := &lt;registered language tag [RFC-1766]&gt;   The ABNF given in RFC 2047 for encoded-words is:   encoded-word := "=?" charset "?" encoding "?" encoded-text "?="   This specification changes this ABNF to:   encoded-word := "=?" charset ["*" language] "?" encoded-text "?="</body></comment><class><name>ContentType</name><environment>SiouX</environment><super>SiouX.EncodedStructuredFieldValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type subtype </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.ContentType</class-id><body>Represents Content-Type header field valueInstance Variables	type	&lt;String&gt;	subtype	&lt;String&gt;</body></comment><class><name>HttpRequestPart</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source headers body contentType contentDisposition contentEncoding httpConnection originalSource </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.HttpRequestPart</class-id><body>I represent a part of a multipart HTTP request (Note that request is an extended version of me). A part has a has a header and a body. Header is a sequence of request header fields. Few of the header fields (generally the ones required to process the request correctly) are parsed immediately into their respective values. Rest of the fields are parsed lazily on demand. Because the contents of a part can be arbitrarily large, the body of any part is always provided as a stream. The contents of the stream are fully decoded according to the content-type and content-encoding fields. That means if the content type is textual, the stream will yield characters, otherwise it will yield bytes. A fundamental property of this implementation is that the body stream is set up directly on top of the socket, and consequently is non-positionable and can be read only once. Once read the content is no longer available, so if it's needed again it must be copied somewhere as it's being read.Instance Variables	source	&lt;ReadStream&gt; 	headers	&lt;OrderedCollection of: HttpRequestHeaderField&gt; 	body	&lt;ReadStream&gt; 	contentType	&lt;ContentType&gt; 	contentDisposition	&lt;ContentDisposition&gt; 	contentEncoding	&lt;String&gt; 	httpConnection &lt;HttpConnection&gt; the connection may include some options for the request parser. For example a connection listener has header size limitation. If request header size exceeds the specified limit the "400 Bad Request" reply will be returned. 	contentEncoding &lt;String&gt; the value of "Content-Encoding" header field	originalSource &lt;Stream&gt; is used by HTTP2 to hold HTTP2StreamShared Variables	CRCR	&lt;String&gt; constant	FieldLineContinuationCharacters	&lt;String&gt; constant; tab and space</body></comment><class><name>HttpRequest</name><environment>SiouX</environment><super>SiouX.HttpRequestPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method version transferEncoding contentLength connection url decodedPath </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.HttpRequest</class-id><body>I represent an incoming HTTP request. Everything that applies to a request part applies to a request as well, with some additions. First a request also has a method (GET, PUT...), a url and a protocol version (usually 1.1). Few additional header fields are parsed immediately for requests, for example content-length or transfer-encoding as they are needed to process the request correctly. Besides the simple body described in the superclass, a request body can have multiple parts. In the multipart case, the body is still a stream (you don't know how many parts are there until you process the entire request), but it yields the parts themselves. Because of the streaming nature of the implementation only one part is "active" at any given time. This means that you can only process the body of the currently active part, once you move to the next part, you can't go back to the previous one (although you can hold onto the parts themselves and access their headers, but not their bodies, those are already gone).Instance Variables	method	&lt;String&gt; 	version	&lt;String&gt; 	url &lt;PartialURL&gt;  request status line URL	transferEncoding	&lt;String&gt; 	contentLength	&lt;SmallInteger&gt; 	connection &lt;OrderedCollection of String&gt; the value of request "Connection" field	httpConnection &lt;HttpConnection&gt; 	decodedPath &lt;OrderedCollection&gt; decoded url pathShared Variables:	MaxBodySize &lt;Integer&gt; the default for maximum request body size. If the global is nil there is no limitation on a request body size.</body></comment><class><name>FilteringReadStream</name><environment>Xtreams</environment><super>Xtreams.ReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http-Extensions</package></attributes></class><comment><class-id>Xtreams.FilteringReadStream</class-id><body>Filters the content using the filter block. Elements for which the block answers false are filtered out.Instance Variables	filter	&lt;Object&gt; undocumented</body></comment><class><name>AcceptEncoding</name><environment>SiouX</environment><super>SiouX.AcceptField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.AcceptEncoding</class-id><body>AcceptEncoding represents the 'accept-encoding'  HTTP header.http://tools.ietf.org/html/rfc2616   -- HTTP/1.1 uses content-coding values in the Accept-Encoding (section 14.3) and Content-Encoding (section 14.11) header fields. Accept-Encoding  = 'Accept-Encoding' ':'                          1#( codings [ ';' 'q' '=' qvalue ] )       codings          = ( content-coding | '*' )http://tools.ietf.org/html/rfc7231#section-3.1.2.1 -- The "Content-Encoding" header field indicates what content codings   have been applied to the representation, beyond those inherent in the media type, and thus what decoding mechanisms have to be applied in order to obtain data in the media type referenced by the Content-Type header field.  Content-Encoding is primarily used to allow a representation's data to be compressed without losing the identity of its underlying media type.  Unlike Transfer-Encoding (Section 3.3.1 of [RFC7230]), the codings listed in Content-Encoding are a characteristic of the representation</body></comment><class><name>HttpResponsePart</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>headers body parent applyGzipCompression </inst-vars><class-inst-vars>applyGzipCompression </class-inst-vars><imports>			private OS.URLEncoder			</imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.HttpResponsePart</class-id><body>I represent a part of a multi-part HTTP response (Note that request is an extended version of me). A part has a has a header and a body. Header is a sequence of response header fields. A body of a part can be provided in a number of forms. It can be an internal collection, i.e. ByteArray or a String. It can be a read stream which will be copied directly into the socket stream when the part body is being sent out through the socket. It can be a Filename in which case the contents of the file will be sent in an efficient manner. Finally a body can be a block that will be evaluated with a write stream as its argument into which it is expected to generate the content. The stream argument will be set up as a character or byte stream according to the response content-type. Again, the block is evaluated when the body content is being sent out, not when it is assigned as the part body.Instance Variables	headers	&lt;OrderedCollection of: HttpResponseHeaderField&gt; 	body	&lt;String | ByteArray | ReadStream | Filename | BlockClosure&gt; 	parent	&lt;HttpResponse&gt; 	applyGzipCompression &lt;Boolean&gt; defines if compession should be applied to a response partClass Instance Variables	applyGzipCompression &lt;Boolean&gt; default value for applying compression optionShared Variables	FileExtensionToMimeTypeMap	&lt;Dictionary key: String value: String&gt; maps common file extensions to corresponding mime types</body></comment><class><name>HttpResponse</name><environment>SiouX</environment><super>SiouX.HttpResponsePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>code parameterCharset boundary request </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.HttpResponse</class-id><body>I represent an outgoing HTTP response. Everything that applies to a response part applies to a response as well, with some additions. First a response also has a status code (200, 404,...). Besides the simple body types described in the superclass, a response body can also have multiple parts. In this case the body is an OrderedCollection. Parts are added with #addPart: message which takes the desired content as its argument. The return value is a part instance that can further customized (with additional header fields, etc). A response that was initially created with simple body will be automatically converted to a multipart response if #addPart: is sent to it afterward.Response body will be sent out either with a specified content-length or chunked. If the total byte-length can be determined upfront with not much overhead, the content-length will be used. Otherwise the body will be chunked. The response body can be sent compressed using gzip compression. http://stackoverflow.com/questions/11641923/transfer-encoding-gzip-vs-content-encoding-gzipInstance Variables	code	&lt;Number&gt; Http status line code	parameterCharset	&lt;Object&gt; charset to use for header field parameter values	boundary	&lt;String&gt; internal, automatically generated boundary for multipart bodies	request &lt;HttpRequest&gt; the request holds client options that the response may useShared Variables	CRLF	&lt;ByteArray&gt; encoded CRLF bytes	HttpReasonPhrases	&lt;Dictionary key: Integer value: ByteArray&gt; maps codes to encoded status phrases	HttpStatusVersion	&lt;ByteArray&gt; encoded HTTP response version stamp	ServerHeader	&lt;ByteArray&gt; encoded Server header valueResponse      = Status-Line               ; Section 6.1                       *(( general-header        ; Section 4.5 http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.5                        | response-header        ; Section 6.2  http://www.w3.org/Protocols/rfc2616/rfc2616-sec6.html#sec6.1.2                        | entity-header ) CRLF)  ; Section 7.1 http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.1                       CRLF                       [ message-body ]          ; Section 7.2http://www.ietf.org/rfc/rfc2046.txt5.1.  Multipart Media Type5.1.1.  Common Syntax The boundary delimiter MUST occur at the beginning of a line, i.e.,   following a CRLF, and the initial CRLF is considered to be attached   to the boundary delimiter line rather than part of the preceding   part.  The boundary may be followed by zero or more characters of   linear whitespace. It is then terminated by either another CRLF and   the header fields for the next part, or by two CRLFs, in which case   there are no header fields for the next part.  If no Content-Type   field is present it is assumed to be "message/rfc822" in a   "multipart/digest" and "text/plain" otherwise.   The boundary delimiter line following the last body part is a   distinguished delimiter that indicates that no further body parts   will follow.  Such a delimiter line is identical to the previous   delimiter lines, with the addition of two more hyphens after the   boundary parameter value.    boundary := 0*69&lt;bchars&gt; bcharsnospace     bchars := bcharsnospace / " "     bcharsnospace := DIGIT / ALPHA / "'" / "(" / ")" /                      "+" / "_" / "," / "-" / "." /                      "/" / ":" / "=" / "?"   Overall, the body of a "multipart" entity may be specified as   follows:     dash-boundary := "--" boundary                      ; boundary taken from the value of                      ; boundary parameter of the                      ; Content-Type field.     multipart-body := [preamble CRLF]                       dash-boundary transport-padding CRLF                       body-part *encapsulation                       close-delimiter transport-padding                       [CRLF epilogue]    transport-padding := *LWSP-char                          ; Composers MUST NOT generate                          ; non-zero length transport                          ; padding, but receivers MUST                          ; be able to handle padding                          ; added by message transports.     encapsulation := delimiter transport-padding                      CRLF body-part     delimiter := CRLF dash-boundary     close-delimiter := delimiter "--"     preamble := discard-text     epilogue := discard-text     discard-text := *(*text CRLF) *text                     ; May be ignored or discarded.     body-part := MIME-part-headers [CRLF *OCTET]                  ; Lines in a body-part must not start                  ; with the specified dash-boundary and                  ; the delimiter must not appear anywhere                  ; in the body part.  Note that the                  ; semantics of a body-part differ from                  ; the semantics of a message, as                  ; described in the text.     OCTET := &lt;any 0-255 octet value&gt;</body></comment><class><name>BadRequest</name><environment>SiouX</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.BadRequest</class-id><body>BadRequest error should be raised in case of any client error. By default the responder exception printer will return the response with 400 code (Client error).For example the error is raised when the request header exceeds the header size limit. The header size limit is defined by a listener.</body></comment><class><name>ChunkedReadStream</name><environment>SiouX</environment><super>Xtreams.ReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>sourceAtEnd chunkSize messageSize bodyLimit </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>SiouX-Http-Extensions</package></attributes></class><comment><class-id>SiouX.ChunkedReadStream</class-id><body>Provides chunked content as single continuous stream of bytes. Currently cannot process a trailer if present (the Trailer header has to be absent).Chunked-Body   = *chunk                        last-chunk                        trailer                        CRLF       chunk          = chunk-size [ chunk-extension ] CRLF                        chunk-data CRLF       chunk-size     = 1*HEX       last-chunk     = 1*('0') [ chunk-extension ] CRLF       chunk-extension= *( ';' chunk-ext-name [ '=' chunk-ext-val ] )All HTTP/1.1 applications MUST be able to receive and decode the 'chunked' transfer-coding, and MUST ignore chunk-extension extensions they do not understandTrailer  = "Trailer" ":" 1#field-name An HTTP/1.1 message SHOULD include a Trailer header field in a message using chunked transfer-coding with a non-empty trailer. Doing so allows the recipient to know which header fields to expect in the trailer.If no Trailer header field is present, the trailer SHOULD NOT include any header fields. See section 3.6.1 for restrictions on the use of trailer fields in a "chunked" transfer-404https://tools.ietf.org/html/rfc7230#section-4.1Instance Variables	sourceAtEnd	&lt;Boolean&gt; internal, have we reached final null chunk	chunkSize	&lt;SmallInteger&gt; internal, size of current chunk</body></comment><class><name>ContentDisposition</name><environment>SiouX</environment><super>SiouX.EncodedStructuredFieldValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.ContentDisposition</class-id><body>Represents Content-Disposition header field value (http://tools.ietf.org/html/rfc5987).Instance Variables	type	&lt;String&gt;	disposition-typehttp://tools.ietf.org/html/rfc2616#section-3.6       content-disposition = "Content-Disposition" ":"                              disposition-type *( ";" disposition-parm )        disposition-type = "attachment" | disp-extension-token        disposition-parm = filename-parm | disp-extension-parm        filename-parm = "filename" "=" quoted-string        disp-extension-token = token        disp-extension-parm = token "=" ( token | quoted-string )   `Extension-token', `parameter' and `value' are defined according to   [RFC 822] and [RFC 1521].http://tools.ietf.org/html/rfc5987 3.2.1:     parameter     = attribute LWSP "=" LWSP value     attribute     = token     value         = token / quoted-string     quoted-string = &lt;quoted-string, defined in [RFC2616], Section 2.2&gt;     token         = &lt;token, defined in [RFC2616], Section 2.2&gt;   In order to include character set and language information, this   specification modifies the RFC 2616 grammar to be:     parameter     = reg-parameter / ext-parameter     reg-parameter = parmname LWSP "=" LWSP value     ext-parameter = parmname "*" LWSP "=" LWSP ext-value     parmname      = 1*attr-char     ext-value     = charset  "'" [ language ] "'" value-chars                   ; like RFC 2231's &lt;extended-initial-value&gt;                   ; (see [RFC2231], Section 7)     charset       = "UTF-8" / "ISO-8859-1" / mime-charset     mime-charset  = 1*mime-charsetc     mime-charsetc = ALPHA / DIGIT                   / "!" / "#" / "$" / "%" / "&amp;"                   / "+" / "-" / "^" / "_" / "`"                   / "{" / "}" / "~"                   ; as &lt;mime-charset&gt; in Section 2.3 of [RFC2978]                   ; except that the single quote is not included                   ; SHOULD be registered in the IANA charset registry     language      = &lt;Language-Tag, defined in [RFC5646], Section 2.1&gt;     value-chars   = *( pct-encoded / attr-char )     pct-encoded   = "%" HEXDIG HEXDIG                   ; see [RFC3986], Section 2.1     attr-char     = ALPHA / DIGIT                   / "!" / "#" / "$" / "&amp;" / "+" / "-" / "."                   / "^" / "_" / "`" / "|" / "~"                   ; token except ( "*" / "'" / "%" )http://tools.ietf.org/html/rfc6266#section-4.3 The parameters "filename" and "filename*" differ only in that   "filename*" uses the encoding defined in [RFC5987], allowing the use   of characters not present in the ISO-8859-1 character set   ([ISO-8859-1]).</body></comment><class><name>SetCookie</name><environment>SiouX</environment><super>SiouX.StructuredFieldValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.SetCookie</class-id><body>Represents "Set-Cookie' header field. The Set-Cookie HTTP response header is used to send cookies from the server to the user agent.Instance Variables	name	&lt;String&gt;	cookie name	value	&lt;String&gt;	cookie valueImplementation is based on:http://tools.ietf.org/html/rfc6265set-cookie-header = "Set-Cookie:" SP set-cookie-string set-cookie-string = cookie-pair *( ";" SP cookie-av ) cookie-pair       = cookie-name "=" cookie-value cookie-name       = token cookie-value      = *cookie-octet / ( DQUOTE *cookie-octet DQUOTE ) cookie-octet      = %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E                       ; US-ASCII characters excluding CTLs,                       ; whitespace DQUOTE, comma, semicolon,                       ; and backslash token             = &lt;token, defined in [RFC2616], Section 2.2&gt; cookie-av         = expires-av / max-age-av / domain-av /                     path-av / secure-av / httponly-av /                     extension-avhttp://tools.ietf.org/html/rfc6265#section-5.1.2    --  5.1.2. Canonicalized Host Names</body></comment><class><name>TE</name><environment>SiouX</environment><super>SiouX.AcceptEncoding</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.TE</class-id><body>TE represents the 'te' HTTP header.http://tools.ietf.org/html/rfc7230#section-4  ---  The TE header field in a request indicates what transfer codings, besides chunked, the client is willing to accept in response   TE = [ ( ',' / t-codings ) *( OWS ',' [ OWS t-codings ] ) ]    t-codings = 'trailers' / ( transfer-coding [ t-ranking ] )    t-ranking = OWS ';' OWS 'q=' rank     rank      = ( '0' [ '.' 0*3DIGIT ] )                / ( '1' [ '.' 0*3('0') ] )  transfer-coding    = "chunked" ; Section 4.1                        / "compress" ; Section 4.2.1                        / "deflate" ; Section 4.2.2                        / "gzip" ; Section 4.2.3                        / transfer-extensionTE: trailers, deflate;q=0.5Transfer coding names are used to indicate an encoding transformation  that has been, can be, or might need to be applied to a payload body in order to ensure "safe transport" through the network.  This differs from a content coding in that the transfer coding is a property of the message rather than a property of the representation that is being transferred.TE header turned out not to be used. Tested IE/FF/Chrome/Safari and none of them sends TE header. Instead all browsers use "Accept-Encoding" in reguests.http://stackoverflow.com/questions/11641923/transfer-encoding-gzip-vs-content-encoding-gzip</body></comment><class><name>FormData</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>request data </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.FormData</class-id><body>FormData is a wrapper for request that provides dictionary-like access to form data. The #at: accessor always returns a collection of values, the collection is empty if the argument does not match the name of any of the values. Often #at:do: may be more convenient. Note that all the values except files, will be read into memory. By default file content is discarded unless it is processed differently with message #getMultiplartFormDataFilesDo:.Instance Variables	data	&lt;OrderedCollection &lt;Association&gt;&gt;	keys are form data names, values are the multipart contents received from a HTML form.	request	&lt;HttpRequest&gt;	the request for which I am processing the form data.</body></comment><class><name>AcceptLanguage</name><environment>SiouX</environment><super>SiouX.AcceptField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.AcceptLanguage</class-id><body>AcceptLanguage represents the 'accept-language' HTTP header.</body></comment><class><name>Authorization</name><environment>SiouX</environment><super>SiouX.StructuredFieldValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scheme </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.Authorization</class-id><body>Authorization represents a value of Authorization Request Headerhttp://www.ietf.org/rfc/rfc2617.txtInstance Variables:	scheme &lt;String&gt; authentication scheme</body></comment><class><name>HttpRequestHeaderField</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name start end source isFolded </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.HttpRequestHeaderField</class-id><body>A header field has a pre-parsed name and an unparsed body. All the fields of a given header are backed by an internal copy of the header created when the request or part is set up on top of a source stream. Field body is provided as a character stream that is lazily created on top of a specific segment of the header copy.Instance Variables	name	&lt;String&gt; header field name	start	&lt;SmallInteger&gt; start of the header value in the source	end	&lt;SmallInteger&gt; end of the header value in the source	source	&lt;String&gt; the full request header	isFolded	&lt;Boolean&gt; is the header field value split into multiple lines</body></comment><class><name>Authenticate</name><environment>SiouX</environment><super>SiouX.StructuredFieldValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scheme </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.Authenticate</class-id><body>AuthenticateField represents the 'authenticate' fieldInstance Variables:	scheme	&lt;String&gt;	authentication  schemehttp://www.ietf.org/rfc/rfc2617.txt challenge   = auth-scheme 1*SP 1#auth-param</body></comment><class><name>LinkField</name><environment>SiouX</environment><super>SiouX.EncodedStructuredFieldValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>url </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.LinkField</class-id><body>The class represents Link header field which is used to express a typed relationship with another resource. https://tools.ietf.org/html/rfc5988Instance Variables:	url	&lt;PartialURL&gt;	target urlExample:Link: &lt;/app/style.css&gt;; rel=preloadHTTP/2 uses the header as indication for pushing resources with #preload relations To add a link to a response:	response := HttpResponse code: 200.	response 		preloadLink: '/app/style.css';		preloadLink: '/app/htm1.html';		preloadLink: '/app/htm2.html'.</body></comment><class><name>Cookie</name><environment>SiouX</environment><super>SiouX.StructuredFieldValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.Cookie</class-id><body>Represents Cookie header field value.  The user agent sends stored cookies to the origin server in the Cookie header.http://tools.ietf.org/html/rfc6265  cookie-header = "Cookie:" OWS cookie-string OWS   cookie-string = cookie-pair *( ";" SP cookie-pair )</body></comment><class><name>ProtocolUpgradeFilter</name><environment>SiouX</environment><super>SiouX.RequestFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>validateHostOriginBlock </inst-vars><class-inst-vars>validateHostOriginBlock </class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.ProtocolUpgradeFilter</class-id><body>Obsolete class. It will be deprecated in 9.0ProtocolVersion does connection upgrade </body></comment><class><name>ValueWithParameters</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value parameters </inst-vars><class-inst-vars></class-inst-vars><imports>			private Protocols.*			</imports><category></category><attributes><package>SiouX-Http</package></attributes></class><comment><class-id>SiouX.ValueWithParameters</class-id><body>ValueWithParameters represents a value for structured fields, for example "Accept" and "Accept-Language" fieldsInstance Variables:	parameters	&lt;Struct&gt;  parameters	value	&lt;String&gt;	value</body></comment><shared-variable><name>FileExtensionToMimeTypeMap</name><environment>SiouX.HttpResponsePart</environment><private>false</private><constant>false</constant><category>constants</category><attributes><package>SiouX-Http</package></attributes></shared-variable><shared-variable><name>ServerHeader</name><environment>SiouX.HttpResponse</environment><private>false</private><constant>false</constant><category>constants</category><initializer>HttpResponse serverHeaderFrom: HttpConnection serverHeader</initializer><attributes><package>SiouX-Http</package></attributes></shared-variable><shared-variable><name>CRLF</name><environment>SiouX.HttpResponse</environment><private>false</private><constant>false</constant><category>constants</category><initializer>#[13 10]</initializer><attributes><package>SiouX-Http</package></attributes></shared-variable><shared-variable><name>HttpReasonPhrases</name><environment>SiouX.HttpResponse</environment><private>false</private><constant>false</constant><category>constants</category><initializer></initializer><attributes><package>SiouX-Http</package></attributes></shared-variable><shared-variable><name>HttpStatusVersion</name><environment>SiouX.HttpResponse</environment><private>false</private><constant>false</constant><category>constants</category><initializer>'HTTP/1.1 ' asByteArrayEncoding: #ascii</initializer><attributes><package>SiouX-Http</package></attributes></shared-variable><shared-variable><name>ParameterCharset</name><environment>SiouX</environment><private>false</private><constant>false</constant><category>constants</category><initializer>'utf-8'</initializer><attributes><package>SiouX-Http</package></attributes></shared-variable><shared-variable><name>MaxUnchunkedNarrowString</name><environment>SiouX</environment><private>false</private><constant>false</constant><category>constants</category><initializer>1000000</initializer><attributes><package>SiouX-Http-Extensions</package></attributes></shared-variable><shared-variable><name>MaxChunkSize</name><environment>SiouX</environment><private>false</private><constant>false</constant><category>constants</category><initializer>16384</initializer><attributes><package>SiouX-Http</package></attributes></shared-variable><shared-variable><name>MaxUnchunkedWideStringSize</name><environment>SiouX</environment><private>false</private><constant>false</constant><category>constants</category><initializer>15000</initializer><attributes><package>SiouX-Http-Extensions</package></attributes></shared-variable><shared-variable><name>CRCR</name><environment>SiouX.HttpRequestPart</environment><private>false</private><constant>false</constant><category>constants</category><initializer>String with: Character cr with: Character cr</initializer><attributes><package>SiouX-Http</package></attributes></shared-variable><shared-variable><name>FieldLineContinuationCharacters</name><environment>SiouX.HttpRequestPart</environment><private>false</private><constant>false</constant><category>constants</category><initializer>String with: Character tab with: Character space</initializer><attributes><package>SiouX-Http</package></attributes></shared-variable><methods><class-id>SiouX.HttpResponder</class-id> <category>accessing</category><body package="SiouX-Http">newResponse	^HttpResponse code: 200</body></methods><methods><class-id>SiouX.HttpResponder</class-id> <category>services</category><body package="SiouX-Http">createRequestFrom: aRequestLine	| request |	request := HttpRequest url: aRequestLine url method: aRequestLine method version: aRequestLine version.	request decodedPath: aRequestLine decodedPath.	request fromConnection: aRequestLine connection.	^request</body></methods><methods><class-id>SiouX.HttpResponder class</class-id> <category>defaults</category><body package="SiouX-Http">defaultExceptionPrinterValue	^[ :exception | | code |		code := (BadRequest handles: exception) ifTrue: [ 400 ] ifFalse: [ 500 ].			(HttpResponse code: code)			contentType: 'text/plain' charset: 'utf-8';			contents: [ :stream |				stream write: exception description; cr; cr.				code = 500 ifTrue: [exception initialContext reading do: [ :frame | stream print: frame; cr ]] ];			yourself ]</body></methods><methods><class-id>SiouX.FileResponder</class-id> <category>private</category><body package="SiouX-Http">filePathFrom: urlPath nonExistentPathDo: aBlock	| filePath |	filePath := self rootDirectory.	1 to: urlPath size - 1 do: [ :index || token |		token := urlPath at: index.		filePath :=  filePath / token.		filePath asFilename exists ifFalse: [aBlock value: filePath ]]. 	^urlPath isEmpty		ifTrue: [ filePath ]		ifFalse: [ filePath / urlPath last ]</body><body package="SiouX-Http">getFilename: urlPath  context: aRequestContext	| filePath |	filePath := self 				filePathFrom: urlPath 				nonExistentPathDo: [ :fn | 					self						setNotFoundResponse: ((#ThereIsNoDirectory &lt;&lt; #www &gt;&gt; 'There is no such directory: &lt;1s&gt;') expandMacrosWith: fn)						for: aRequestContext.					^nil ]. 	filePath asFilename exists ifFalse: [		self 			setNotFoundResponse: ((#ThereIsNoFile &lt;&lt; #www &gt;&gt; 'There is no such file: &lt;1s&gt;') expandMacrosWith: filePath asString)			for: aRequestContext. 		^nil].	^filePath asFilename</body><body package="SiouX-Http">setClientErrorResponse: aUserMessage  for: aRequestContext	aRequestContext response: ((HttpResponse code: 400)									contents: aUserMessage asString;									yourself)</body><body package="SiouX-Http">setNotFoundResponse: aUserMessage for: aRequestContext	aRequestContext response: ((HttpResponse code: 404)									contents: aUserMessage asString;									yourself)</body></methods><methods><class-id>SiouX.FileResponder</class-id> <category>accessing</category><body package="SiouX-Http">applyGzipCompression	applyGzipCompression := true</body><body package="SiouX-Http">contentDispositionType	^contentDispositionType ifNil: [contentDispositionType := self class contentDispositionType ]</body><body package="SiouX-Http">contentDispositionType: aString	contentDispositionType := aString</body><body package="SiouX-Http">path	^path ifNil: [ '/files' ]</body><body package="SiouX-Http">pathDepth	^pathDepth ifNil: [ pathDepth := self class pathDepth ]</body><body package="SiouX-Http">pathDepth: aNumber	pathDepth := aNumber</body><body package="SiouX-Http">resetGzipCompression	applyGzipCompression := false</body><body package="SiouX-Http">rootDirectory	^rootDirectory ifNil: [ rootDirectory := self class rootDirectory]</body><body package="SiouX-Http">rootDirectory: aLogicalFilenameOrString	aLogicalFilenameOrString isString		ifTrue: [ rootDirectory := LogicalFilename named: aLogicalFilenameOrString ]		ifFalse: [ rootDirectory := aLogicalFilenameOrString ]</body></methods><methods><class-id>SiouX.FileResponder</class-id> <category>services</category><body package="SiouX-Http">delete: urlPath context: aRequestContext	(self getFilename: urlPath  context: aRequestContext) 		ifNotNil: [ :fn | fn delete ].</body><body package="SiouX-Http">executeRequestFor: aRequestContext	| urlPath pathTokens method |	method := aRequestContext request method.	(#('POST' 'GET' 'DELETE' 'PUT') includes: method) ifFalse: [		" 501 Not Implemented "		^aRequestContext response: (HttpResponse code: 501)].	urlPath := aRequestContext request url decodedPath. 	" Remove my path and file name"	pathTokens := self path tokensBasedOn: $/.	urlPath := urlPath copyFrom: pathTokens size + 1 to: urlPath size.	(self validatePath: urlPath context: aRequestContext) ifFalse: [^aRequestContext].	[	method = 'GET' ifTrue:  [ ^self get: urlPath context: aRequestContext].		urlPath isEmpty ifTrue: [ ^ self setClientErrorResponse: (#PathMustNotBeEmpty &lt;&lt; #www &gt;&gt; 'Path must not be empty!' ) for: aRequestContext ].		method = 'POST' ifTrue: [ ^ self post: urlPath context: aRequestContext ].		method = 'PUT' ifTrue: [ ^ self put: urlPath context: aRequestContext ].		method = 'DELETE' ifTrue:  [ ^ self delete: urlPath context: aRequestContext ].	] on: Error do: [ :error |	self setClientErrorResponse: error errorString for: aRequestContext ]</body><body package="SiouX-Http">get: urlPath context: aRequestContext	| filename content  response |	(self getFilename: urlPath context: aRequestContext) 		ifNotNil: [ :fn | filename := fn asFilename]		ifNil: [ ^nil ].	content := filename isDirectory		ifTrue: [ | list |			(list := filename directoryContents) isEmpty				ifTrue: [ '' ]				ifFalse: [ list fold: [ :a :b | a, '\' withCRs, b ] ] ]		ifFalse: [ ( aRequestContext response contentDisposition: self contentDispositionType) fileName: filename tail.				filename ].	(response := aRequestContext response) contents: content.	applyGzipCompression ifTrue: [ response applyGzipCompression].	filename modificationTimestamp ifNotNil: [ :lastModified |		response 			header: 'Last-Modified'  			value: (TimeZone default localToUniversal: (Timestamp fromSeconds: lastModified asSeconds)) ].</body><body package="SiouX-Http">post: urlPath context: aRequestContext	| filePath stream |	filePath := self 				filePathFrom: urlPath 				nonExistentPathDo: [ :fn | fn asFilename ensureDirectory ]. 	filePath asFilename exists ifTrue: [ 		self error: ((#FileAlreadyExists &lt;&lt; #www &gt;&gt; 'The file already exists: &lt;1s&gt;') expandMacrosWith: filePath asString)].		stream := aRequestContext request charset 				ifNotNil: [ :charset| filePath asFilename writing encoding: charset asSymbol ]				ifNil: [filePath asFilename writing].	[	stream write: aRequestContext request body.	] ensure: [ stream close ].	" 201 Created "	aRequestContext response: (HttpResponse code: 201).	"The newly created resource can be referenced by the URI(s) returned in the entity of the response, with the most specific URI for the resource given by a Location header field"	 aRequestContext response header: 'Location' value: aRequestContext request url asString</body><body package="SiouX-Http">put: urlPath context: aRequestContext	| filePath stream |	filePath := self 				filePathFrom: urlPath 				nonExistentPathDo: [ :fn | fn asFilename ensureDirectory ]. 	stream := aRequestContext request charset 				ifNotNil: [ :charset| filePath asFilename writing encoding: charset asSymbol ]				ifNil: [filePath asFilename writing].	[	stream write: aRequestContext request body.	] ensure: [ stream close ].	aRequestContext response: (HttpResponse code: 200).</body><body package="SiouX-Http">validatePath: urlPath context: aRequestContext	urlPath size &gt; self pathDepth ifTrue: [ 		self setClientErrorResponse: (#ExceededPathDepth &lt;&lt; #www &gt;&gt; 'Exceeded supported file path depth!') for: aRequestContext.		^false].	(urlPath anySatisfy: #isEmpty) ifTrue: [ 		self setClientErrorResponse:  (#PathMustNotContainEmptyComp &lt;&lt; #www &gt;&gt; 'Path must not contain empty components!' ) for: aRequestContext.		^false].	(urlPath anySatisfy: [ :token | token = '..' ]) ifTrue: [ 		self setClientErrorResponse: (#PathMustNotContainDots &lt;&lt; #www &gt;&gt; 'Path must not contain .. !' ) for: aRequestContext.		^false ].	^true</body></methods><methods><class-id>SiouX.FileResponder</class-id> <category>initialize-release</category><body package="SiouX-Http">initialize	super initialize.	applyGzipCompression := false</body></methods><methods><class-id>SiouX.FileResponder class</class-id> <category>accessing</category><body package="SiouX-Http">contentDispositionType	^contentDispositionType ifNil: [ contentDispositionType := self defaultContentDispositionTypeValue ]</body><body package="SiouX-Http">contentDispositionType: aString	contentDispositionType := aString</body><body package="SiouX-Http">pathDepth	pathDepth ifNil: [pathDepth := self defaultPathDepthValue].	^pathDepth</body><body package="SiouX-Http">pathDepth: aNumber	pathDepth := aNumber</body><body package="SiouX-Http">rootDirectory	"rootDirectory := nil"	rootDirectory ifNil: [rootDirectory := Server rootDirectory / self defaultRootDirectoryValue].	rootDirectory ensureDirectory.	^rootDirectory</body><body package="SiouX-Http">rootDirectory: aStringOrNilOrDirectory	rootDirectory := Server changeDirectory: self rootDirectory with: aStringOrNilOrDirectory</body><body package="SiouX-Http">rootDirectoryAsString	^self rootDirectory asString</body><body package="SiouX-Http">rootDirectoryAsString: aString	^self rootDirectory: aString</body></methods><methods><class-id>SiouX.FileResponder class</class-id> <category>defaults</category><body package="SiouX-Http">defaultContentDispositionTypeValue	^ 'attachment'</body><body package="SiouX-Http">defaultPathDepthValue	^20</body><body package="SiouX-Http">defaultRootDirectoryValue	^'files'</body></methods><methods><class-id>SiouX.StructuredFieldValue</class-id> <category>initialize-release</category><body package="SiouX-Http">from: stream	| parameterStream |	parameterStream := (stream ending: $;) slicing.	parameters := Dictionary new.	self processValue: parameterStream get.	parameterStream do: [ :parameter || name |		name := ((parameter ending: $=) filtering: WHITESPACE) rest.		self processParameterValue: name from: parameter ].	parameters isEmpty ifTrue: [ parameters := nil ]</body><body package="SiouX-Http">processValue: stream	self subclassResponsibility</body><body package="SiouX-Http">value: value	self subclassResponsibility</body></methods><methods><class-id>SiouX.StructuredFieldValue</class-id> <category>accessing</category><body package="SiouX-Http">parameters	^parameters</body><body package="SiouX-Http">parametersAt: name	^parameters ifNotNil: [ parameters at: name ifAbsent: [ nil ] ]</body><body package="SiouX-Http">parametersAt: name put: value	parameters ifNil: [ parameters := Dictionary new ].	^parameters at: name put: value</body></methods><methods><class-id>SiouX.StructuredFieldValue</class-id> <category>private</category><body package="SiouX-Http">processParameterValue: aString from: parameter	| value char name |	name := aString.	value := String new writing.	[ (char := parameter get) = SPACE ] whileTrue.	(char = $")		ifTrue: [ value write: (parameter ending: $") ]		ifFalse: [ value put: char; write: (parameter filtering: WHITESPACE) ].	value := value close; terminal.	parameters at: name put: value</body><body package="SiouX-Http">shouldBeDecoded: aString	^(aString detect: [:char | char asInteger &gt; 128] ifNone: [nil]) ~~ nil</body><body package="SiouX-Http">siouxWriteHeaderValueFor: entity on: aStream	aStream write: self value.	parameters ifNil: [^self].	parameters keysAndValuesDo: [ :name :value |		aStream put: $;.		value siouxWriteHeaderParameter: name for: self on: aStream ]</body><body package="SiouX-Http">value	^self subclassResponsibility</body><body package="SiouX-Http">writeHeaderParameter: name latinString: string on: aStream	aStream		write: name; write: '="';		write: string;		put: $"</body><body package="SiouX-Http">writeHeaderParameter: name number: number on: aStream	aStream		write: name; write: '="';		write: number printString;		put: $"</body><body package="SiouX-Http">writeHeaderParameter: name string: string on: aStream	^self writeHeaderParameter: name latinString: string on: aStream</body><body package="SiouX-Http">writeHeaderParameter: name timestamp: aTimestamp on: aStream	aStream write: name; write: '="'.	HttpResponse encodeTimestamp: aTimestamp on: aStream.	aStream put: $"</body></methods><methods><class-id>SiouX.StructuredFieldValue</class-id> <category>printing</category><body package="SiouX-Http">printOn: aStream	parameters ifNil: [^self].	parameters associations 		do: [ :assoc |			aStream 				nextPutAll: assoc key;				nextPutAll: '=';				nextPutAll: assoc value ]		separatedBy: [aStream nextPut: $; ]</body></methods><methods><class-id>SiouX.StructuredFieldValue class</class-id> <category>instance creation</category><body package="SiouX-Http">from: stream	^self new from: stream</body><body package="SiouX-Http">value: string	^self new value: string</body></methods><methods><class-id>SiouX.AcceptField</class-id> <category>accessing</category><body package="SiouX-Http">acceptableItemsFrom: aColl 	"Parse an HTTP Accept-* string and return the list of acceptable items, organized by priority"	| groupedItems |	( aColl isNil or: [ aColl isEmpty]) ifTrue: [^#()].	groupedItems := self processAcceptString: aColl.	^groupedItems at: 2</body><body package="SiouX-Http">processAcceptString: items	"Expect an http accept-style string, e.g. for accept-language		da, en-gb; q=0.8,  en;q=0.7	Return an array with two things:		a) a dictionary mapping from q (preference) values to language names 		b) a collection of all the language names acceptable"	| entriesGroupedByQ names nm qValue| 	entriesGroupedByQ := Dictionary new.	names := OrderedCollection new.	items do: [:each | 		qValue := each parameters isEmpty ifTrue: [1.0] ifFalse: [each qValue].		names add: (nm := each value asLowercase).		(entriesGroupedByQ at: qValue ifAbsentPut: [OrderedCollection new]) add: nm ].	^Array with: entriesGroupedByQ with: names.</body><body package="SiouX-Http">qValueAt: aString		^ (self valuesWith: aString) any ifNotNil: [ :value | value qValue ]</body><body package="SiouX-Http">value	^ parameters</body><body package="SiouX-Http">value: aCollection	parameters := aCollection</body><body package="SiouX-Http">valuesWith: aString	^ self value select: [ :each | each value = aString ]</body></methods><methods><class-id>SiouX.AcceptField</class-id> <category>initialize-release</category><body package="SiouX-Http">from: stream	parameters := OrderedCollection new.	self processValue: ((stream ending: $,) slicing)</body><body package="SiouX-Http">processValue: valueStream	valueStream do: [:valueWithParameters | parameters add: (ValueWithParameters from: valueWithParameters) ]</body></methods><methods><class-id>SiouX.AcceptField</class-id> <category>printing</category><body package="SiouX-Http">printOn: aStream	| writing |	writing := aStream writing.	self value		do: [ :valWithParams | 			writing write: valWithParams value.			valWithParams parametersDo: [ :key :val | 				writing put: $;.				val siouxWriteHeaderParameter: key for: self on: writing]]						separatedBy: [ writing write: ', ' ]</body></methods><methods><class-id>SiouX.AcceptField</class-id> <category>private</category><body package="SiouX-Http">siouxWriteHeaderValueFor: entity on: aStream	self value		do: [ :valWithParams | 			aStream write: valWithParams value.			valWithParams parametersDo: [ :key :val | 				aStream put: $;.				val siouxWriteHeaderParameter: key for: self on: aStream]]						separatedBy: [ aStream write: $, ]</body><body package="SiouX-Http">writeHeaderParameter: name number: number on: aStream	aStream		write: name; write: '=';		write: number printString</body></methods><methods><class-id>SiouX.HttpResponseHeaderField</class-id> <category>testing</category><body package="SiouX-Http">matches: aName	name size = aName size ifFalse: [^false]. 	name with: aName do: [ :a :b |		a = b asLowercase ifFalse: [ ^false ] ].	^true</body></methods><methods><class-id>SiouX.HttpResponseHeaderField</class-id> <category>initialize-release</category><body package="SiouX-Http">name: nameString value: valueObject	name := nameString.	value := valueObject</body><body package="SiouX-Http">value: valueObject	value := valueObject</body></methods><methods><class-id>SiouX.HttpResponseHeaderField</class-id> <category>accessing</category><body package="SiouX-Http">name	^name</body><body package="SiouX-Http">value	^value</body></methods><methods><class-id>SiouX.HttpResponseHeaderField</class-id> <category>private-writing</category><body package="SiouX-Http">writeFor: entity on: aStream	self writeNameOn: aStream.	aStream write: ': '.	value siouxWriteHeaderValueFor: entity on: aStream</body><body package="SiouX-Http">writeNameOn: aStream	"Normalize the field names by capitalizing the first character of each word"	((name reading ending: $-) slicing)		do: [ :word | aStream put: word get asUppercase; write: word ] separatedBy: [ aStream put: $- ].</body><body package="SiouX-Http">writeOn: aStream	self writeFor: nil on: aStream</body></methods><methods><class-id>SiouX.HttpResponseHeaderField</class-id> <category>printing</category><body package="SiouX-Http">printOn: aStream	name 		ifNil: [aStream nextPutAll: '&lt;unnamed header field&gt;' ] 		ifNotNil: [aStream nextPutAll: name].	aStream		nextPutAll: ': ';		print: self value</body></methods><methods><class-id>SiouX.HttpResponseHeaderField class</class-id> <category>instance creation</category><body package="SiouX-Http">name: nameString value: valueObject	^self new name: nameString value: valueObject</body></methods><methods><class-id>SiouX.ChunkedWriteStream</class-id> <category>initialize-release</category><body package="SiouX-Http-Extensions">close	encoded write: '0'; cr; cr.	super close</body><body package="SiouX-Http-Extensions">on: aDestination	super on: aDestination.	encoded := aDestination encoding: #ascii.	encoded setLineEndCRLF</body></methods><methods><class-id>SiouX.ChunkedWriteStream</class-id> <category>accessing</category><body package="SiouX-Http-Extensions">write: anInteger from: aSequenceableCollection at: startIndex	anInteger printOn: encoded base: 16.	encoded cr.	super write: anInteger from: aSequenceableCollection at: startIndex.	encoded cr.	^anInteger</body></methods><methods><class-id>SiouX.EncodedStructuredFieldValue</class-id> <category>private</category><body package="SiouX-Http">encodeTSpecialsFrom: aString	| stream newString asciiOnly |	stream := (String new: aString size) writing.	asciiOnly := true.	aString do: [ :char |		char asInteger &gt; 127 ifTrue: [ asciiOnly := false ]. 		self class translateSpecial: char on: stream ].	newString := stream close; terminal.	^asciiOnly		ifTrue: [ newString ]		ifFalse: [ ( newString asByteArrayEncoding: #utf8 ) asStringEncoding: #'iso8859-1']</body><body package="SiouX-Http">processParameterValue: aString from: parameter	| value char valueStream encoding name |	name := aString.	value := String new writing.	[ (char := parameter get) = SPACE ] whileTrue.	(char = $")		ifTrue: [ value write: (parameter ending: $") ]		ifFalse: [ value put: char; write: (parameter filtering: WHITESPACE) ].	value := value close; terminal.	" http://tools.ietf.org/html/rfc5987 	Character Set and Language Encoding for HTTPHeader Field Parameters     ext-value     = charset  ' [ language ] ' value-chars"	name last = $*		ifTrue: [ valueStream := value reading.				encoding := (valueStream ending: $') rest.				" skip language "(valueStream ending: $') rest.				value := (OS.URLEncoder new charset: encoding asSymbol) decode: valueStream rest.				name := name copyFrom: 1 to: name size - 1]		ifFalse: ["Most browsers seem to just slap the filename of uploaded files into the header in raw utf8"			(self shouldBeDecoded: value)					ifTrue: [ value :=  ( value asByteArrayEncoding: #'iso8859-1') asStringEncoding: #utf8 ]].	parameters at: name put: value</body><body package="SiouX-Http">writeHeaderParameter: name latinString: string on: aStream	aStream		write: name; write: '="';		write: (self encodeTSpecialsFrom: string);		put: $"</body><body package="SiouX-Http">writeHeaderParameter: name string: string on: aStream	string detect: [ :c | c asInteger &gt; 255 ]		ifNone: [ ^self writeHeaderParameter: name latinString: string on: aStream ].	aStream		write: name;		write: '*='; write: 'UTF-8'; put: $'; put: $';		write: (self encodeTSpecialsFrom: string)</body></methods><methods><class-id>SiouX.EncodedStructuredFieldValue class</class-id> <category>accessing</category><body package="SiouX-Http">tSpecials"http://tools.ietf.org/html/rfc2231""   attribute-char := &lt;any (US-ASCII) CHAR except SPACE, CTLs, *, ', %, or tspecials&gt;   tspecials :=  ( / ) / &lt; / &gt; / @ /                   , / ; / : / \ / &lt;&gt;                   / / [ / ] / ? / ="	tSpecials isNil ifTrue: [tSpecials := self tSpecialsDefault ]. 	^tSpecials.</body><body package="SiouX-Http">tSpecialsDefault	^' _*''%()&lt;&gt;@,::\/[]?'</body><body package="SiouX-Http">tSpecialsEncodings	tSpecialsEncodings isNil ifTrue: [tSpecialsEncodings := self tSpecialsEncodingsDefault ]. 	^tSpecialsEncodings</body><body package="SiouX-Http">tSpecialsEncodingsDefault"	| i2h |	i2h := [ :i | '0123456789ABCDEF' at: i + 1 ].	(self tSpecials reading collecting: [ :char || code |		code := char asInteger.		String with: $% with: (i2h value: (code bitShift: -4)) with: (i2h value: (code bitAnd: 16rF)) ]	) contentsSpecies: Array; rest" 	^#('%20' '%5F' '%2A' '%27' '%25' '%28' '%29' '%3C' '%3E' '%40' '%2C' '%3A' '%3A' '%5C' '%2F' '%5B' '%5D' '%3F')</body><body package="SiouX-Http">translateSpecial: char on: stream	| index |	index := self tSpecials indexOf: char.	index isZero		ifTrue: [ stream put: char ]		ifFalse: [ stream write: (self tSpecialsEncodings at: index) ]</body></methods><methods><class-id>SiouX.ContentType</class-id> <category>accessing</category><body package="SiouX-Http">boundary	^self parametersAt:  'boundary'</body><body package="SiouX-Http">boundary: string	^self parametersAt: 'boundary' put: string</body><body package="SiouX-Http">charset	^self parametersAt:  'charset'</body><body package="SiouX-Http">charset: string	^self parametersAt: 'charset' put: string</body><body package="SiouX-Http">subtype	^subtype</body><body package="SiouX-Http">type	^type</body></methods><methods><class-id>SiouX.ContentType</class-id> <category>initialize-release</category><body package="SiouX-Http">processValue: valueStream	| stream |	stream := valueStream filtering: WHITESPACE.	type := (stream ending: $/) rest.	subtype := stream rest</body><body package="SiouX-Http">value: string	| stream |	stream := string reading.	type := (stream ending: $/) rest.	subtype := stream rest.</body></methods><methods><class-id>SiouX.ContentType</class-id> <category>testing</category><body package="SiouX-Http">isMultipart	^type = 'multipart'</body></methods><methods><class-id>SiouX.ContentType</class-id> <category>private</category><body package="SiouX-Http">value	^String new writing write: type; put: $/; write: subtype; close; terminal</body></methods><methods><class-id>SiouX.ContentType</class-id> <category>printing</category><body package="SiouX-Http">printOn: aStream	aStream nextPutAll: type;		nextPut: $/;		nextPutAll: subtype;		nextPut: $;.	super printOn: aStream</body></methods><methods><class-id>SiouX.HttpRequestPart</class-id> <category>accessing</category><body package="SiouX-Http">body	^body</body><body package="SiouX-Http">charset	"3.7.1 Canonicalization and Text Defaults: When no explicit charset parameter is provided by the sender, media subtypes of the 'text' type are defined to have a default charset value of 'ISO-8859-1' when received via HTTP. Data in character sets other than 'ISO-8859-1' or its subsets MUST be labeled with an appropriate charset value. See section 3.4.1 for compatibility problems. application/x-www-form-urlencoded;charset=UTF-8"	^contentType		ifNotNil: 			[contentType charset				ifNil: [contentType type = 'text' ifTrue: [LATIN1] ifFalse: [nil]]				ifNotNil: [:cs | cs]]</body><body package="SiouX-Http">contentDisposition	^contentDisposition</body><body package="SiouX-Http">contentEncoding	^contentEncoding</body><body package="SiouX-Http">contentType	^contentType</body><body package="SiouX-Http">headers	^headers ifNil: [headers := OrderedCollection new.]</body><body package="SiouX-Http">headers: name do: action"Run action with each occurrence of a header field with specified name. Return count of occurences.	name &lt;String&gt;	action &lt;Block&gt;	^&lt;SmallInteger&gt;"	| count |	count := 0.	headers do: [ :h |		(h matches: name) ifTrue: [			count := count + 1.			action value: h ] ].	^count</body><body package="SiouX-Http">httpConnection	^httpConnection</body><body package="SiouX-Http">originalSource	^originalSource</body><body package="SiouX-Http">originalSource: aStream	originalSource := aStream.	source := aStream</body><body package="SiouX-Http">source	^source</body><body package="SiouX-Http">source: aReadStream	source := aReadStream</body></methods><methods><class-id>SiouX.HttpRequestPart</class-id> <category>private-parsing</category><body package="SiouX-Http">applyContentEncoding: encoding" http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.htmlhttp://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.11 Content-Encoding  = 'Content-Encoding' ':' 1#content-codingFor compatibility with previous implementations of HTTP, applications SHOULD consider 'x-gzip' and 'x-compress'  to be equivalent to 'gzip' and 'compress' respectively. If the content-coding of an entity in a request message is not acceptable to the origin server, the server SHOULD respond with a status code of 415 (Unsupported Media Type)."	encoding = 'gzip' ifTrue: [ body := body gzipCompressing. ^self ].	"if we don't recognize an encoding, we should send back an error with accept-encoding header"	self error: (#UnsupportedMediaType &lt;&lt; #www &gt;&gt; 'Unsupported Media Type!' )</body><body package="SiouX-Http">applyEncodings"If multiple encodings have been applied to an entity, the content codings MUST be listed in the order in which they were applied."	"Isolate the source from the body so that body can be properly closed when we're releasing the entity."	body := source closing: [ :s | ].	self headers: 'content-encoding' do: [ :ce | self applyContentEncoding: ce body rest ].</body><body package="SiouX-Http">from: aStream"This method is used only for testing HttpRequest parsing "	source := aStream.	self parseHeaders: (Protocols.HTTPv11 new readHeaderSourceFrom: source ).	self prepareBody</body><body package="SiouX-Http">parseHeaders: headerString	| lines headerSource |	headerSource := headerString reading.	lines := (headerSource ending: CR) slicing.	headers := OrderedCollection new.	lines do: [ :line || char |		char := line get.		(FieldLineContinuationCharacters includes: char)			ifTrue: [ line -= 0. headers last setEnd: headerSource position - 2 "drop the CR at the end as well" ]			ifFalse: [ | name start field |				name := (String new writing collecting: #asLowercase) put: char; write: (line ending: $:); close; terminal.				start := headerSource position.				line -= 0.				field := HttpRequestHeaderField name: name source: headerString from: start to: headerSource position - 2.  "drop the CR at the end as well" 				self processTransportField: field.				headers add: field ] ].</body><body package="SiouX-Http">prepareBody"http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.2 entity-body := Content-Encoding( Content-Type( data ) )http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.4 -- 4.4 Message Length"	self applyEncodings.	self prepareSimpleBody</body><body package="SiouX-Http">prepareSimpleBody	self charset ifNotNil: [ :charset | body := body encoding: charset asSymbol ]</body><body package="SiouX-Http">processTransportField: field	field name = 'content-type' ifTrue: [ contentType := ContentType from: field body. ^self ].	field name = 'content-disposition' ifTrue: [ contentDisposition := ContentDisposition from: field body. ^self ].	field name = 'content-encoding' ifTrue: [ contentEncoding := ((field body filtering: WHITESPACE) collecting: #asLowercase) rest. ^self ]. " gzip deflate "	^self</body></methods><methods><class-id>SiouX.HttpRequestPart</class-id> <category>printing</category><body package="SiouX-Http">printOn: aStream	headers ifNotNil: [ headers do: [ :headerx | headerx printOn: aStream. aStream cr. ]].	aStream cr.	body ifNotNil: [ body printOn: aStream ]</body></methods><methods><class-id>SiouX.HttpRequestPart</class-id> <category>initialize-release</category><body package="SiouX-Http">fromConnection: aConnection	httpConnection := aConnection.	source := aConnection readStream</body><body package="SiouX-Http">release"Release any resources associated with the body stream stack, and position the source to the end of the entity."	source ifNil: [^self].	body ifNotNil: [ body close. source -= 0 ].	body := source := httpConnection := nil</body></methods><methods><class-id>SiouX.HttpRequestPart class</class-id> <category>instance creation</category><body package="SiouX-Http">fromConnection: aConnection"	Set up a new entity to be sourced from aConnection	^&lt;Entity&gt;"	^self new 		fromConnection: aConnection;		yourself</body></methods><methods><class-id>SiouX.HttpRequestPart class</class-id> <category>private-backward compatibility</category><body package="SiouX-Http">from: aStream"This method is used only for testing HttpRequest parsing. "	^self new from: aStream</body></methods><methods><class-id>SiouX.HttpRequest</class-id> <category>accessing</category><body package="SiouX-Http">acceptEncoding"http://tools.ietf.org/html/rfc2616   -- HTTP/1.1 uses content-coding values in the Accept-Encoding (section 14.3) and Content-Encoding (section 14.11) header fields. Accept-Encoding  = 'Accept-Encoding' ':'                          1#( codings [ ';' 'q' '=' qvalue ] )       codings          = ( content-coding | '*' )"	| fields |	fields := OrderedCollection new.	self headers: 'accept-encoding' do: [:field | fields add: (AcceptEncoding from: field body) ].	^fields</body><body package="SiouX-Http">acceptLanguage"Answer a collection of Strings representing language tags.Should we have a class for AcceptLanguage or other header fields, or reuse one from the HTTP package?http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.4The Accept-Language request-header field is similar to Accept, but restricts the set of natural languages that are preferred as a response to the request. Language tags are defined in section 3.10 (http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.10).	Accept-Language = 'Accept-Language' ':'		1#( language-range [ ';' 'q' '=' qvalue ] )		language-range  = ( ( 1*8ALPHA *( '-' 1*8ALPHA ) ) | '*' )Each language-range MAY be given an associated quality value which represents an estimate of the user's preference for the languages specified by that range. The quality value defaults to 'q=1'. For example,       Accept-Language: da, en-gb;q=0.8, en;q=0.7" 	| fields |	fields := OrderedCollection new.	self headers: 'accept-language' do: [:field | fields add: (AcceptLanguage from: field body) ].	fields isEmpty ifTrue: [ ^ nil ].	^fields</body><body package="SiouX-Http">authorization	self headers: 'authorization' do: [ :field | ^ (Authorization from: field body) ].	^nil</body><body package="SiouX-Http">connection"HTTP/1.1 defines the 'close' connection option for the sender to signal that the connection will be closed after completion of the response.HTTP/1.1 applications that do not support persistent connections MUST include the 'close' connection option in every message. 	Connection = 'Connection' ':' 1#(connection-token)	connection-token  = token"	^connection ifNil: [#()]</body><body package="SiouX-Http">contentLength	^contentLength</body><body package="SiouX-Http">cookies	| cookies |	cookies := OrderedCollection new.	self headers: 'cookie' do: [ :field | cookies add: (Cookie from: field body) ].	^cookies isEmpty		ifTrue: [ nil ]		ifFalse: [ cookies ]</body><body package="SiouX-Http">decodedPath	^decodedPath ifNil: [decodedPath := self url decodedPath]</body><body package="SiouX-Http">decodedPath: aCollection	decodedPath := aCollection</body><body package="SiouX-Http">host	self headers: 'host' do: [ :field | ^field body rest  ].	^nil</body><body package="SiouX-Http">method	^method</body><body package="SiouX-Http">origin		self headers: 'origin' do: [ :field | ^field body rest asLowercase ].	^nil</body><body package="SiouX-Http">te"http://tools.ietf.org/html/rfc7230#section-4  ---  The TE header field in a request indicates what transfer codings, besides chunked, the client is willing to accept in response   TE = [ ( ',' / t-codings ) *( OWS ',' [ OWS t-codings ] ) ]    t-codings = 'trailers' / ( transfer-coding [ t-ranking ] )    t-ranking = OWS ';' OWS 'q=' rank     rank      = ( '0' [ '.' 0*3DIGIT ] )                / ( '1' [ '.' 0*3('0') ] )TE: trailers, deflate;q=0.5"	| fields |	fields := OrderedCollection new.	self headers: 'te' do: [:field | fields add: (TE from: field body) ].	^fields</body><body package="SiouX-Http">transferEncoding	^transferEncoding</body><body package="SiouX-Http">upgrade"The Upgrade general-header allows the client to specify what additional communication protocols it supports and would like to use if the server finds it appropriate to switch protocols. The server MUST use the Upgrade header field within a 101 (Switching Protocols) response to indicate which protocol(s) are being switched.  Upgrade        = Upgrade : 1#product" 	self headers: 'upgrade' do: [ :field | 		^( field body rest asLowercase tokensBasedOn: $,) collect: [ :t | t trimBlanks ] ].	^nil</body><body package="SiouX-Http">url	^url</body><body package="SiouX-Http">version	^version</body></methods><methods><class-id>SiouX.HttpRequest</class-id> <category>private-parsing</category><body package="SiouX-Http">applyEncodings	self applyTransferEncoding.	super applyEncodings</body><body package="SiouX-Http">applyTransferEncoding"https://tools.ietf.org/html/rfc7230#section-3.3.1Whenever a transfer-coding is applied to a message-body, the set of transfer-codings MUST include 'chunked', unless the message is terminated by closing the connection. When the 'chunked' transfer- coding is used, it MUST be the last transfer-coding applied to the message-body. The 'chunked' transfer-coding MUST NOT be applied more than once to a message-body. These rules allow the recipient to determine the transfer-length of the message (section 4.4). A server which receives an entity-body with a transfer-coding it does not understand SHOULD return 501 (Unimplemented), and close the connection. A server MUST NOT send transfer-codings to an HTTP/1.0 client.  "	| bodyLimit |	httpConnection ifNotNil: [bodyLimit := httpConnection requestBodyLimit. ].	self isChunked ifTrue: [		self headers: 'trailer' do: [ :h | self error: (#CanntProcessChunkedBody &lt;&lt; #www &gt;&gt;'Cannot process chunked body with a trailer!') ].		source := ChunkedReadStream on: source bodyLimit: bodyLimit.		(transferEncoding includes: 'gzip') ifTrue: [source := source gzipCompressing ].		^self ].	"For compatibility with HTTP/1.0 applications, HTTP/1.1 requests containing a message-body MUST include a valid Content-Length header field unless the server is known to be HTTP/1.1 compliant. If a request contains a message-body and a Content-Length is not given, the server SHOULD respond with 400 (bad request) if it cannot determine the length of the message, or with 411 (length required) if it wishes to insist on receiving a valid Content-Length. "	(contentLength notNil and: [ contentLength &gt; 0 ]) ifTrue: [ 		(bodyLimit notNil			and: [contentLength &gt; bodyLimit ]) ifTrue: [				^BadRequest raiseErrorString: ( #RequestContentLengthExceededSizeLimit &lt;&lt; #www &gt;&gt; 'The request Content Length exceeded the body size limit: &lt;1p&gt; bytes'  expandMacrosWith: httpConnection requestBodyLimit)].			source := source limiting: contentLength. ^self ].</body><body package="SiouX-Http">prepareBody"http://www.w3.org/Protocols/rfc2616/rfc2616-sec7.html#sec7.2 entity-body := Content-Encoding( Content-Type( data ) )http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.4 -- 4.4 Message Length"	self hasBody ifFalse: [^self].	self applyEncodings.	self isMultipart		ifTrue: [ self prepareMultipartBody ]		ifFalse: [ self prepareSimpleBody ]</body><body package="SiouX-Http">prepareMultipartBody	"Skip over the first boundary marker to the first part"	| boundary fullBody current currentSource |	(((body closing: []) encoding: #'ISO8859_1') ending: contentType boundary) -= 0; close.	"Now we'll process boundaries in binary so that the parts can be processed in binary form as well"	boundary := (ByteArray new writing encoding: #'ISO8859_1')					setLineEndCRLF;					put: CR; write: '--'; write: contentType boundary;					close; terminal.	fullBody := body.	currentSource := nil reading.	current := nil.	body := [	current ifNotNil: [ current release ].				currentSource close. 				(fullBody read: 2) = #[13 10] ifFalse: [ Incomplete raise ].				current := HttpRequestPart from: (currentSource := fullBody ending: boundary)			] reading closing: [				current release.				currentSource close ].</body><body package="SiouX-Http">prepareRequestToProcess	"Protocol version calls the method before dispatching"	self prepareBody</body><body package="SiouX-Http">processContentLength: field"If a message is received without Transfer-Encoding and with either multiple Content-Length header fields having differing field-values or a single Content-Length header field having an invalid value, then the message framing is invalid and the recipient MUST treat it as an unrecoverable error.  If this is a request message, the server MUST respond with a 400 (Bad Request) status code and then close the connection. "	contentLength 		ifNil: [ contentLength := (field body filtering: WHITESPACE) rest asNumber ]		ifNotNil: [ | newLength |			newLength := (field body filtering: WHITESPACE) rest asNumber.			contentLength ~= newLength ifTrue: [self error: (#MultipleContentLength &lt;&lt; #www &gt;&gt; 'Request includes multiple Content-Length fields with different field values')]]</body><body package="SiouX-Http">processTransferEncoding: field"https://tools.ietf.org/html/rfc7230""The Transfer-Encoding header field lists the transfer coding names corresponding to the sequence of transfer codings that have been (or will be) applied to the payload body in order to form the message body."	transferEncoding := (((field body filtering: WHITESPACE) collecting: #asLowercase) rest tokensBasedOn: $,) collect: [ :t | t trimBlanks ].	"If a Transfer-Encoding header field is present in a request and the chunked transfer coding is not the final encoding, the message body length cannot be determined reliably; the server MUST respond with the 400 (Bad Request) status code and then close the connection."	((transferEncoding size = 1 and: [transferEncoding last = 'chunked'])		or: [transferEncoding size = 2 and: [transferEncoding first = 'gzip' and: [transferEncoding last = 'chunked']]])		ifTrue: ["supported encodings " ^nil].			"Unsupported encodings"	self error: (#UnsupportedTransferEncodings &lt;&lt; #www &gt;&gt; 'Unsupported transfer encodings')</body><body package="SiouX-Http">processTransportField: field	super processTransportField: field.	field name = 'transfer-encoding' ifTrue: [ self processTransferEncoding: field. ^self ]. " chunked "	field name = 'content-length' ifTrue: [self processContentLength: field. ^self ].	field name = 'connection' ifTrue: [ 		connection := (((field body filtering: WHITESPACE) collecting: #asLowercase) rest tokensBasedOn: $,) 						collect: [ :t | t trimBlanks ].		 ^self ]. 	^self</body><body package="SiouX-Http">removeTransferFieldsContentLength: aNumber	contentLength := transferEncoding := nil.	contentLength := aNumber</body></methods><methods><class-id>SiouX.HttpRequest</class-id> <category>testing</category><body package="SiouX-Http">hasBody	(method = 'GET' or: [ method = 'HEAD' or: [method = 'DELETE']]) ifTrue: [^false].	"http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3	The presence of a message-body in a request is signaled by the inclusion of a Content-Length	or Transfer-Encoding header field in the request's message-headers. "	^(self isChunked or: [		(self isVersion10 and: [ contentLength isNil]) "body will end with the stream, HTTP 1.0 style"			or: [ contentLength notNil and: [contentLength &gt; 0 ]]])				or: [ source notNil and: [self isVersion20  "the protocol is upgraded to HTTP2" ]]</body><body package="SiouX-Http">hasTransferEncoding	^transferEncoding notNil 		and: [transferEncoding notEmpty]</body><body package="SiouX-Http">isChunked	^transferEncoding notNil and: [ transferEncoding last = 'chunked' ]</body><body package="SiouX-Http">isConnectionClose	"Note that this does the right thing even if the field is missing"	^self isVersion10		ifTrue: [ (self connection includes: 'keep-alive') not ]		ifFalse: [ self connection includes: 'close' ]</body><body package="SiouX-Http">isMultipart	^self hasBody and: [ contentType notNil and: [ contentType isMultipart ] ]</body><body package="SiouX-Http">isVersion10	^version = 'HTTP/1.0'</body><body package="SiouX-Http">isVersion11	^version = 'HTTP/1.1'</body><body package="SiouX-Http">isVersion20	^version = 'HTTP/2.0'</body></methods><methods><class-id>SiouX.HttpRequest</class-id> <category>printing</category><body package="SiouX-Http">printOn: aStream	self printStatusLineOn: aStream.	aStream cr.	super printOn: aStream</body><body package="SiouX-Http">printStatusLineOn: aStream	method ifNotNil: [aStream nextPutAll: method, ' ' ].	url ifNotNil: [ :ur |		ur printPathOn: aStream.		aStream nextPutAll: ' '].	version ifNotNil: [aStream nextPutAll: version ]</body></methods><methods><class-id>SiouX.HttpRequest</class-id> <category>web</category><body package="SiouX-Http">getFormData"This can be called only once on any given request."	^(FormData request: self) getFormData; yourself</body><body package="SiouX-Http">queryData	^(FormData request: self) getQueryData; yourself</body></methods><methods><class-id>SiouX.HttpRequest</class-id> <category>initialize-release</category><body package="SiouX-Http">method: methodString	method := methodString.</body><body package="SiouX-Http">url: aPartialUrl method: methodString version: versionString	url := aPartialUrl.	method := methodString.	version := versionString.</body><body package="SiouX-Http">version: versionString	version := versionString.</body></methods><methods><class-id>SiouX.HttpRequest</class-id> <category>deprecation</category><body package="SiouX-Http">encodedPath"Returns encoded path string as it was in the request status line "	| stream |	self deprecated: #(#version '8.3' #sunset '9.0' ).	stream := String new writeStream.	self url printEncodedPathOn: stream.	^stream contents</body><body package="SiouX-Http">path"Returns decoded path string "	| stream |	self deprecated: #(#version '8.3' #sunset '9.0' ).	stream := String new   writeStream.	self url printPathOn: stream.	^stream contents</body><body package="SiouX-Http">path: encodedPathString 	self deprecated: #(#version '8.3' #sunset '9.0' ).</body><body package="SiouX-Http">path: encodedPathString method: methodString version: versionString	self deprecated: #(#version '8.3' #sunset '9.0' #use #url:method:version: ).	url := OS.PartialURL fromString: encodedPathString. 	method := methodString.	version := versionString.</body><body package="SiouX-Http">pathString	self deprecated: #(#version '8.3' #sunset '9.0' ).	^self encodedPath</body></methods><methods><class-id>SiouX.HttpRequest class</class-id> <category>instance creation</category><body package="SiouX-Http">path: path method: method version: version	^self new url: (OS.PartialURL fromString: path) method: method version: version</body><body package="SiouX-Http">url: anUrl method: method version: version	^self new url: anUrl method: method version: version</body></methods><methods><class-id>Xtreams.FilteringReadStream</class-id> <category>initialize-release</category><body package="SiouX-Http-Extensions">contentsSpecies	^source contentsSpecies</body><body package="SiouX-Http-Extensions">filter: block	filter := block</body></methods><methods><class-id>Xtreams.FilteringReadStream</class-id> <category>accessing</category><body package="SiouX-Http-Extensions">read: total into: target at: start	| count |	count := 0.	[	[ count &lt; total ] whileTrue: [ | next |			[ filter value: (next := source get) ] whileFalse.			target at: start + count put: next.			count := count + 1 ]	] on: Incomplete do: [ :ex | (Incomplete on: target count: count at: start) raiseSignal ].	^count</body></methods><methods><class-id>Xtreams.FilteringReadStream class</class-id> <category>instance creation</category><body package="SiouX-Http-Extensions">on: stream filter: block	^(self on: stream) filter: block</body></methods><methods><class-id>SiouX.AcceptEncoding</class-id> <category>testing</category><body package="SiouX-Http">isAcceptEncoding	^true</body><body package="SiouX-Http">isTE	^false</body></methods><methods><class-id>SiouX.AcceptEncoding</class-id> <category>accessing</category><body package="SiouX-Http">acceptableEncodings	^self acceptableItemsFrom: self value.</body><body package="SiouX-Http">encodingTag: encodingCode	^ self value		detect: [ :valWithParams | valWithParams  value = encodingCode ]		ifNone: [ nil ]</body></methods><methods><class-id>SiouX.HttpResponsePart</class-id> <category>accessing</category><body package="SiouX-Http">applyGzipCompression	applyGzipCompression := true</body><body package="SiouX-Http">charset	^self contentType ifNotNil: [ :ct | 	ct charset ]</body><body package="SiouX-Http">contentDisposition	^self header: 'content-disposition'</body><body package="SiouX-Http">contentDisposition: value	^(self privateHeader: 'content-disposition' value: (ContentDisposition value: value)) value</body><body package="SiouX-Http">contentType	^self header: 'content-type'</body><body package="SiouX-Http">contentType: value	^(self privateHeader: 'content-type' value: (ContentType value: value)) value</body><body package="SiouX-Http">contentType: value charset: aString	^(self privateHeader: 'content-type' value: ((ContentType value: value) charset: aString; yourself )) value</body><body package="SiouX-Http">contents	^body</body><body package="SiouX-Http">encoding"Convert charset (if present) to the corresponding encoding identifier.3.7.1 Canonicalization and Text Defaults When no explicit charset parameter is provided by the sender, media subtypes of the 'text' type are defined to have a default charset value of 'ISO-8859-1' when received via HTTP. Data in character sets other than 'ISO-8859-1' or its subsets MUST be labeled with an appropriate charset value. See section 3.4.1 for compatibility problems.text/event-stream   The charset parameter may be provided. The parameter's value must be utf-8. This parameter serves no purpose; it is only allowed for compatibility with legacy servers.application/json  Optional parameters: n/a.  The default encoding is UTF-8.  When JSON is written in UTF-8, JSON is 8bit compatible.  When JSON is written in UTF-16 or UTF-32, the binary content-transfer-encoding must be used.application/javascript Optional parameters: charset  http://www.rfc-editor.org/rfc/rfc4329.txt  4.1 The charset parameter provides a means to specify the character encoding scheme of binary source text.  Its value MUST match the mime-charset production defined in [RFC2978], section 2.3, and SHOULD be a registered charset [CHARSETS].text/css Optional parameters: charset. http://www.ietf.org/rfc/rfc2318.txt The syntax of CSS is expressed in US-ASCII, but a CSS file can contain strings which may use any Unicode character. Any charset that is a superset of US-ASCII may be used; US-ASCII, iso-8859-X and utf-8 are recommended."	^self charset 		ifNil: [ #'utf-8' ]		ifNotNil: [ :cs | cs asSymbol ]</body><body package="SiouX-Http">header: name	self headers: name do: [ :h | ^h value ].	^nil</body><body package="SiouX-Http">header: name value: value"Update an existing header with value or add a new one."	^self privateHeader: name asLowercase value: value</body><body package="SiouX-Http">headers	^headers</body><body package="SiouX-Http">headers: name do: action"Run action with each occurrence of a header field with specified name. Return count of occurences.	name &lt;String&gt;	action &lt;Block&gt;	^&lt;SmallInteger&gt;"	| count |	count := 0.	headers do: [ :h |		(h matches: name) ifTrue: [			count := count + 1.			action value: h ] ].	^count</body><body package="SiouX-Http">parameterCharset	^parent parameterCharset</body><body package="SiouX-Http">parameterEncoding	^self parameterCharset asSymbol</body><body package="SiouX-Http">parent	^parent</body></methods><methods><class-id>SiouX.HttpResponsePart</class-id> <category>private</category><body package="SiouX-Http">privateHeader: name value: value"Update an existing header with value or add a new one."	self headers: name do: [ :h | h value: value. ^h ].	^headers add: (HttpResponseHeaderField name: name value: value)</body><body package="SiouX-Http">setBlockContents: block	self setSimpleBody: block.	self contentType ifNil: [ (self contentType: 'application/octet-stream') ]</body><body package="SiouX-Http">setByteContents: bytes	self setSimpleBody: bytes.	self contentType ifNil: [ (self contentType: 'application/octet-stream') ]</body><body package="SiouX-Http">setFilenameContents: filename	self setSimpleBody: filename.	"By default, we don't set content-disposition field. It is up to the client to use content disposition appropriate for a content type."	"(self contentDisposition: 'attachment') fileName: filename tail."	self contentType		ifNil: [self contentType: (self class guessFromExtension: filename extension)]</body><body package="SiouX-Http">setSimpleBody: anObject	body := anObject</body><body package="SiouX-Http">setStreamContents: stream	self setSimpleBody: stream.	self contentType ifNil: [ (self contentType: 'application/octet-stream') ]</body><body package="SiouX-Http">setStringContents: string charset: charset	self setSimpleBody: string.	self contentType ifNil: [ (self contentType: 'text/plain') charset: charset ]</body></methods><methods><class-id>SiouX.HttpResponsePart</class-id> <category>testing</category><body package="SiouX-Http">hasBody	^body notNil</body><body package="SiouX-Http">isPart	^true</body><body package="SiouX-Http">shouldApplyGzipContent	^self parent canGzipEncode and: [applyGzipCompression]</body></methods><methods><class-id>SiouX.HttpResponsePart</class-id> <category>printing</category><body package="SiouX-Http">printOn: aStream	self headers do: [ :headerx | headerx printOn: aStream. aStream cr. ].	aStream cr.	body printOn: aStream</body></methods><methods><class-id>SiouX.HttpResponsePart</class-id> <category>initialize-release</category><body package="SiouX-Http">contents: contents	contents ifNil: [^body := nil].	contents siouxSetContentsOn: self</body><body package="SiouX-Http">initialize	headers := OrderedCollection new.	applyGzipCompression := self class applyGzipCompression.</body><body package="SiouX-Http">parent: response	parent := response</body></methods><methods><class-id>SiouX.HttpResponsePart</class-id> <category>private-writing</category><body package="SiouX-Http">computeContentLength	self shouldApplyGzipContent ifTrue: [^nil].	^body siouxComputeContentLengthFor: self</body><body package="SiouX-Http">writeBodyBlock: block on: stream	| substream |	substream := stream closing: [].	self charset		ifNil: [ block value: substream ]		ifNotNil: [ :charset || charStream |			charStream := (substream encoding: self encoding) setLineEndCRLF; yourself.			block value: charStream.			charStream close ].	substream close</body><body package="SiouX-Http">writeBodyBytes: bytes on: stream	stream write: bytes</body><body package="SiouX-Http">writeBodyFilename: filename on: stream	| source |	source := filename reading.	[	stream write: source.	] ensure: [ source close ]</body><body package="SiouX-Http">writeBodyStream: bodyStream on: stream	self charset		ifNil: [ stream write: bodyStream ]		ifNotNil: [ :charset | 			((stream closing: []) encoding: self encoding)				setLineEndCRLF;				write: bodyStream;				close ]</body><body package="SiouX-Http">writeBodyString: string on: stream	((stream closing: []) encoding: self encoding)		setLineEndTransparent;		write: string;		close</body><body package="SiouX-Http">writeHeaderOn: aStream	| stream |	stream := ((aStream closing: []) encoding: #ISO8859_1) setLineEndCRLF.	self headers do: [ :header | header writeFor: self on: stream. stream cr ].	self shouldApplyGzipContent  ifTrue: [		(HttpResponseHeaderField name: 'content-encoding' value: 'gzip') writeFor: self on: stream. stream cr.].	stream cr; close.</body><body package="SiouX-Http">writeHeaderValueNumber: number on: aStream	aStream print: number</body><body package="SiouX-Http">writeHeaderValueString: string on: aStream	aStream write: string</body><body package="SiouX-Http">writeOn: aStream	self writeHeaderOn: aStream.	body 		siouxWriteBodyFor: self		on: (self shouldApplyGzipContent  				ifTrue: [aStream gzipBestCompressing ]				ifFalse: [aStream])</body></methods><methods><class-id>SiouX.HttpResponsePart class</class-id> <category>instance creation</category><body package="SiouX-Http">contents: contents	^self new contents: contents; yourself</body><body package="SiouX-Http">new	^super new initialize</body></methods><methods><class-id>SiouX.HttpResponsePart class</class-id> <category>private</category><body package="SiouX-Http">guessFromExtension: aString	"guesses a content type from the extension"	^self guessFromExtension: aString ifAbsent: ['application/octet-stream'].</body><body package="SiouX-Http">guessFromExtension: aString ifAbsent: aBlock"Guesses a content type from the extension. aString represents a file extension. Possible values: '.xxx', 'xxx', nil."	| ext |	aString isNil ifTrue: [^aBlock value].	ext := aString first == $.		ifTrue: [ aString copyFrom: 2 to: aString size ]		ifFalse: [ aString ].	^ FileExtensionToMimeTypeMap at: ext asLowercase ifAbsent: aBlock.</body><body package="SiouX-Http">updateFileExtensionMap " (self updateFileExtensionMap) "	| string lines stream char key values |	string := 'http://svn.apache.org/repos/asf/httpd/httpd/trunk/docs/conf/mime.types' asURI get contents.	lines := (string reading ending: Character cr) slicing.	stream := String new writing.	stream 		write: 'defaultFileExtensionMap';		cr;		write: '"The map is generated by #updateFileExtensionMap method "';		cr;		write: '^#('.	lines collect: [ :line |		char := line get.		char ~= $#			ifTrue: [				key := String new writing 						put: char; 						write: (line ending: Character tab); 						close; 						terminal.				values := (line ending: Character space ) slicing collect: [ :each | (each filtering: Character tab) rest].				values do: [ :val | 					stream						cr; 						write: '#('''; 							write: val;						write: ''' ''';						write:  key;						write: ''')' ]]].	stream cr; write: $).	self  class compile: stream contents classified:  'defaults'.	self initializeFileExtensionToMimeTypeMap.</body></methods><methods><class-id>SiouX.HttpResponsePart class</class-id> <category>class initialization</category><body package="SiouX-Http">initialize	self initializeFileExtensionToMimeTypeMap</body></methods><methods><class-id>SiouX.HttpResponsePart class</class-id> <category>defaults</category><body package="SiouX-Http">defaultFileExtensionMap"The map is generated by #updateFileExtensionMap method "^#(#('ez' 'application/andrew-inset')#('aw' 'application/applixware')#('atom' 'application/atom+xml')#('atomcat' 'application/atomcat+xml')#('atomsvc' 'application/atomsvc+xml')#('ccxml' 'application/ccxml+xml')#('cdmia' 'application/cdmi-capability')#('cdmic' 'application/cdmi-container')#('cdmid' 'application/cdmi-domain')#('cdmio' 'application/cdmi-object')#('cdmiq' 'application/cdmi-queue')#('cu' 'application/cu-seeme')#('davmount' 'application/davmount+xml')#('dbk' 'application/docbook+xml')#('dssc' 'application/dssc+der')#('xdssc' 'application/dssc+xml')#('ecma' 'application/ecmascript')#('emma' 'application/emma+xml')#('epub' 'application/epub+zip')#('exi' 'application/exi')#('pfr' 'application/font-tdpfr')#('gml' 'application/gml+xml')#('gpx' 'application/gpx+xml')#('gxf' 'application/gxf')#('stk' 'application/hyperstudio')#('ink' 'application/inkml+xml')#('inkml' 'application/inkml+xml')#('ipfix' 'application/ipfix')#('jar' 'application/java-archive')#('ser' 'application/java-serialized-object')#('class' 'application/java-vm')#('js' 'application/javascript')#('json' 'application/json')#('jsonml' 'application/jsonml+json')#('lostxml' 'application/lost+xml')#('hqx' 'application/mac-binhex40')#('cpt' 'application/mac-compactpro')#('mads' 'application/mads+xml')#('mrc' 'application/marc')#('mrcx' 'application/marcxml+xml')#('ma' 'application/mathematica')#('nb' 'application/mathematica')#('mb' 'application/mathematica')#('mathml' 'application/mathml+xml')#('mbox' 'application/mbox')#('mscml' 'application/mediaservercontrol+xml')#('metalink' 'application/metalink+xml')#('meta4' 'application/metalink4+xml')#('mets' 'application/mets+xml')#('mods' 'application/mods+xml')#('m21' 'application/mp21')#('mp21' 'application/mp21')#('mp4s' 'application/mp4')#('doc' 'application/msword')#('dot' 'application/msword')#('mxf' 'application/mxf')#('bin' 'application/octet-stream')#('dms' 'application/octet-stream')#('lrf' 'application/octet-stream')#('mar' 'application/octet-stream')#('so' 'application/octet-stream')#('dist' 'application/octet-stream')#('distz' 'application/octet-stream')#('pkg' 'application/octet-stream')#('bpk' 'application/octet-stream')#('dump' 'application/octet-stream')#('elc' 'application/octet-stream')#('deploy' 'application/octet-stream')#('oda' 'application/oda')#('opf' 'application/oebps-package+xml')#('ogx' 'application/ogg')#('omdoc' 'application/omdoc+xml')#('onetoc' 'application/onenote')#('onetoc2' 'application/onenote')#('onetmp' 'application/onenote')#('onepkg' 'application/onenote')#('oxps' 'application/oxps')#('xer' 'application/patch-ops-error+xml')#('pdf' 'application/pdf')#('pgp' 'application/pgp-encrypted')#('asc' 'application/pgp-signature')#('sig' 'application/pgp-signature')#('prf' 'application/pics-rules')#('p10' 'application/pkcs10')#('p7m' 'application/pkcs7-mime')#('p7c' 'application/pkcs7-mime')#('p7s' 'application/pkcs7-signature')#('p8' 'application/pkcs8')#('ac' 'application/pkix-attr-cert')#('cer' 'application/pkix-cert')#('crl' 'application/pkix-crl')#('pkipath' 'application/pkix-pkipath')#('pki' 'application/pkixcmp')#('pls' 'application/pls+xml')#('ai' 'application/postscript')#('eps' 'application/postscript')#('ps' 'application/postscript')#('cww' 'application/prs.cww')#('pskcxml' 'application/pskc+xml')#('rdf' 'application/rdf+xml')#('rif' 'application/reginfo+xml')#('rnc' 'application/relax-ng-compact-syntax')#('rl' 'application/resource-lists+xml')#('rld' 'application/resource-lists-diff+xml')#('rs' 'application/rls-services+xml')#('gbr' 'application/rpki-ghostbusters')#('mft' 'application/rpki-manifest')#('roa' 'application/rpki-roa')#('rsd' 'application/rsd+xml')#('rss' 'application/rss+xml')#('rtf' 'application/rtf')#('sbml' 'application/sbml+xml')#('scq' 'application/scvp-cv-request')#('scs' 'application/scvp-cv-response')#('spq' 'application/scvp-vp-request')#('spp' 'application/scvp-vp-response')#('sdp' 'application/sdp')#('setpay' 'application/set-payment-initiation')#('setreg' 'application/set-registration-initiation')#('shf' 'application/shf+xml')#('smi' 'application/smil+xml')#('smil' 'application/smil+xml')#('rq' 'application/sparql-query')#('srx' 'application/sparql-results+xml')#('gram' 'application/srgs')#('grxml' 'application/srgs+xml')#('sru' 'application/sru+xml')#('ssdl' 'application/ssdl+xml')#('ssml' 'application/ssml+xml')#('tei' 'application/tei+xml')#('teicorpus' 'application/tei+xml')#('tfi' 'application/thraud+xml')#('tsd' 'application/timestamped-data')#('plb' 'application/vnd.3gpp.pic-bw-large')#('psb' 'application/vnd.3gpp.pic-bw-small')#('pvb' 'application/vnd.3gpp.pic-bw-var')#('tcap' 'application/vnd.3gpp2.tcap')#('pwn' 'application/vnd.3m.post-it-notes')#('aso' 'application/vnd.accpac.simply.aso')#('imp' 'application/vnd.accpac.simply.imp')#('acu' 'application/vnd.acucobol')#('atc' 'application/vnd.acucorp')#('acutc' 'application/vnd.acucorp')#('air' 'application/vnd.adobe.air-application-installer-package+zip')#('fcdt' 'application/vnd.adobe.formscentral.fcdt')#('fxp' 'application/vnd.adobe.fxp')#('fxpl' 'application/vnd.adobe.fxp')#('xdp' 'application/vnd.adobe.xdp+xml')#('xfdf' 'application/vnd.adobe.xfdf')#('ahead' 'application/vnd.ahead.space')#('azf' 'application/vnd.airzip.filesecure.azf')#('azs' 'application/vnd.airzip.filesecure.azs')#('azw' 'application/vnd.amazon.ebook')#('acc' 'application/vnd.americandynamics.acc')#('ami' 'application/vnd.amiga.ami')#('apk' 'application/vnd.android.package-archive')#('cii' 'application/vnd.anser-web-certificate-issue-initiation')#('fti' 'application/vnd.anser-web-funds-transfer-initiation')#('atx' 'application/vnd.antix.game-component')#('mpkg' 'application/vnd.apple.installer+xml')#('m3u8' 'application/vnd.apple.mpegurl')#('swi' 'application/vnd.aristanetworks.swi')#('iota' 'application/vnd.astraea-software.iota')#('aep' 'application/vnd.audiograph')#('mpm' 'application/vnd.blueice.multipass')#('bmi' 'application/vnd.bmi')#('rep' 'application/vnd.businessobjects')#('cdxml' 'application/vnd.chemdraw+xml')#('mmd' 'application/vnd.chipnuts.karaoke-mmd')#('cdy' 'application/vnd.cinderella')#('cla' 'application/vnd.claymore')#('rp9' 'application/vnd.cloanto.rp9')#('c4g' 'application/vnd.clonk.c4group')#('c4d' 'application/vnd.clonk.c4group')#('c4f' 'application/vnd.clonk.c4group')#('c4p' 'application/vnd.clonk.c4group')#('c4u' 'application/vnd.clonk.c4group')#('c11amc' 'application/vnd.cluetrust.cartomobile-config')#('c11amz' 'application/vnd.cluetrust.cartomobile-config-pkg')#('csp' 'application/vnd.commonspace')#('cdbcmsg' 'application/vnd.contact.cmsg')#('cmc' 'application/vnd.cosmocaller')#('clkx' 'application/vnd.crick.clicker')#('clkk' 'application/vnd.crick.clicker.keyboard')#('clkp' 'application/vnd.crick.clicker.palette')#('clkt' 'application/vnd.crick.clicker.template')#('clkw' 'application/vnd.crick.clicker.wordbank')#('wbs' 'application/vnd.criticaltools.wbs+xml')#('pml' 'application/vnd.ctc-posml')#('ppd' 'application/vnd.cups-ppd')#('car' 'application/vnd.curl.car')#('pcurl' 'application/vnd.curl.pcurl')#('dart' 'application/vnd.dart')#('rdz' 'application/vnd.data-vision.rdz')#('uvf' 'application/vnd.dece.data')#('uvvf' 'application/vnd.dece.data')#('uvd' 'application/vnd.dece.data')#('uvvd' 'application/vnd.dece.data')#('uvt' 'application/vnd.dece.ttml+xml')#('uvvt' 'application/vnd.dece.ttml+xml')#('uvx' 'application/vnd.dece.unspecified')#('uvvx' 'application/vnd.dece.unspecified')#('uvz' 'application/vnd.dece.zip')#('uvvz' 'application/vnd.dece.zip')#('fe_launch' 'application/vnd.denovo.fcselayout-link')#('dna' 'application/vnd.dna')#('mlp' 'application/vnd.dolby.mlp')#('dpg' 'application/vnd.dpgraph')#('dfac' 'application/vnd.dreamfactory')#('kpxx' 'application/vnd.ds-keypoint')#('ait' 'application/vnd.dvb.ait')#('svc' 'application/vnd.dvb.service')#('geo' 'application/vnd.dynageo')#('mag' 'application/vnd.ecowin.chart')#('nml' 'application/vnd.enliven')#('esf' 'application/vnd.epson.esf')#('msf' 'application/vnd.epson.msf')#('qam' 'application/vnd.epson.quickanime')#('slt' 'application/vnd.epson.salt')#('ssf' 'application/vnd.epson.ssf')#('es3' 'application/vnd.eszigno3+xml')#('et3' 'application/vnd.eszigno3+xml')#('ez2' 'application/vnd.ezpix-album')#('ez3' 'application/vnd.ezpix-package')#('fdf' 'application/vnd.fdf')#('mseed' 'application/vnd.fdsn.mseed')#('seed' 'application/vnd.fdsn.seed')#('dataless' 'application/vnd.fdsn.seed')#('gph' 'application/vnd.flographit')#('ftc' 'application/vnd.fluxtime.clip')#('fm' 'application/vnd.framemaker')#('frame' 'application/vnd.framemaker')#('maker' 'application/vnd.framemaker')#('book' 'application/vnd.framemaker')#('fnc' 'application/vnd.frogans.fnc')#('ltf' 'application/vnd.frogans.ltf')#('fsc' 'application/vnd.fsc.weblaunch')#('oas' 'application/vnd.fujitsu.oasys')#('oa2' 'application/vnd.fujitsu.oasys2')#('oa3' 'application/vnd.fujitsu.oasys3')#('fg5' 'application/vnd.fujitsu.oasysgp')#('bh2' 'application/vnd.fujitsu.oasysprs')#('ddd' 'application/vnd.fujixerox.ddd')#('xdw' 'application/vnd.fujixerox.docuworks')#('xbd' 'application/vnd.fujixerox.docuworks.binder')#('fzs' 'application/vnd.fuzzysheet')#('txd' 'application/vnd.genomatix.tuxedo')#('ggb' 'application/vnd.geogebra.file')#('ggt' 'application/vnd.geogebra.tool')#('gex' 'application/vnd.geometry-explorer')#('gre' 'application/vnd.geometry-explorer')#('gxt' 'application/vnd.geonext')#('g2w' 'application/vnd.geoplan')#('g3w' 'application/vnd.geospace')#('gmx' 'application/vnd.gmx')#('kml' 'application/vnd.google-earth.kml+xml')#('kmz' 'application/vnd.google-earth.kmz')#('gqf' 'application/vnd.grafeq')#('gqs' 'application/vnd.grafeq')#('gac' 'application/vnd.groove-account')#('ghf' 'application/vnd.groove-help')#('gim' 'application/vnd.groove-identity-message')#('grv' 'application/vnd.groove-injector')#('gtm' 'application/vnd.groove-tool-message')#('tpl' 'application/vnd.groove-tool-template')#('vcg' 'application/vnd.groove-vcard')#('hal' 'application/vnd.hal+xml')#('zmm' 'application/vnd.handheld-entertainment+xml')#('hbci' 'application/vnd.hbci')#('les' 'application/vnd.hhe.lesson-player')#('hpgl' 'application/vnd.hp-hpgl')#('hpid' 'application/vnd.hp-hpid')#('hps' 'application/vnd.hp-hps')#('jlt' 'application/vnd.hp-jlyt')#('pcl' 'application/vnd.hp-pcl')#('pclxl' 'application/vnd.hp-pclxl')#('sfd-hdstx' 'application/vnd.hydrostatix.sof-data')#('mpy' 'application/vnd.ibm.minipay')#('afp' 'application/vnd.ibm.modcap')#('listafp' 'application/vnd.ibm.modcap')#('list3820' 'application/vnd.ibm.modcap')#('irm' 'application/vnd.ibm.rights-management')#('sc' 'application/vnd.ibm.secure-container')#('icc' 'application/vnd.iccprofile')#('icm' 'application/vnd.iccprofile')#('igl' 'application/vnd.igloader')#('ivp' 'application/vnd.immervision-ivp')#('ivu' 'application/vnd.immervision-ivu')#('igm' 'application/vnd.insors.igm')#('xpw' 'application/vnd.intercon.formnet')#('xpx' 'application/vnd.intercon.formnet')#('i2g' 'application/vnd.intergeo')#('qbo' 'application/vnd.intu.qbo')#('qfx' 'application/vnd.intu.qfx')#('rcprofile' 'application/vnd.ipunplugged.rcprofile')#('irp' 'application/vnd.irepository.package+xml')#('xpr' 'application/vnd.is-xpr')#('fcs' 'application/vnd.isac.fcs')#('jam' 'application/vnd.jam')#('rms' 'application/vnd.jcp.javame.midlet-rms')#('jisp' 'application/vnd.jisp')#('joda' 'application/vnd.joost.joda-archive')#('ktz' 'application/vnd.kahootz')#('ktr' 'application/vnd.kahootz')#('karbon' 'application/vnd.kde.karbon')#('chrt' 'application/vnd.kde.kchart')#('kfo' 'application/vnd.kde.kformula')#('flw' 'application/vnd.kde.kivio')#('kon' 'application/vnd.kde.kontour')#('kpr' 'application/vnd.kde.kpresenter')#('kpt' 'application/vnd.kde.kpresenter')#('ksp' 'application/vnd.kde.kspread')#('kwd' 'application/vnd.kde.kword')#('kwt' 'application/vnd.kde.kword')#('htke' 'application/vnd.kenameaapp')#('kia' 'application/vnd.kidspiration')#('kne' 'application/vnd.kinar')#('knp' 'application/vnd.kinar')#('skp' 'application/vnd.koan')#('skd' 'application/vnd.koan')#('skt' 'application/vnd.koan')#('skm' 'application/vnd.koan')#('sse' 'application/vnd.kodak-descriptor')#('lasxml' 'application/vnd.las.las+xml')#('lbd' 'application/vnd.llamagraphics.life-balance.desktop')#('lbe' 'application/vnd.llamagraphics.life-balance.exchange+xml')#('123' 'application/vnd.lotus-1-2-3')#('apr' 'application/vnd.lotus-approach')#('pre' 'application/vnd.lotus-freelance')#('nsf' 'application/vnd.lotus-notes')#('org' 'application/vnd.lotus-organizer')#('scm' 'application/vnd.lotus-screencam')#('lwp' 'application/vnd.lotus-wordpro')#('portpkg' 'application/vnd.macports.portpkg')#('mcd' 'application/vnd.mcd')#('mc1' 'application/vnd.medcalcdata')#('cdkey' 'application/vnd.mediastation.cdkey')#('mwf' 'application/vnd.mfer')#('mfm' 'application/vnd.mfmp')#('flo' 'application/vnd.micrografx.flo')#('igx' 'application/vnd.micrografx.igx')#('mif' 'application/vnd.mif')#('daf' 'application/vnd.mobius.daf')#('dis' 'application/vnd.mobius.dis')#('mbk' 'application/vnd.mobius.mbk')#('mqy' 'application/vnd.mobius.mqy')#('msl' 'application/vnd.mobius.msl')#('plc' 'application/vnd.mobius.plc')#('txf' 'application/vnd.mobius.txf')#('mpn' 'application/vnd.mophun.application')#('mpc' 'application/vnd.mophun.certificate')#('xul' 'application/vnd.mozilla.xul+xml')#('cil' 'application/vnd.ms-artgalry')#('cab' 'application/vnd.ms-cab-compressed')#('xls' 'application/vnd.ms-excel')#('xlm' 'application/vnd.ms-excel')#('xla' 'application/vnd.ms-excel')#('xlc' 'application/vnd.ms-excel')#('xlt' 'application/vnd.ms-excel')#('xlw' 'application/vnd.ms-excel')#('xlam' 'application/vnd.ms-excel.addin.macroenabled.12')#('xlsb' 'application/vnd.ms-excel.sheet.binary.macroenabled.12')#('xlsm' 'application/vnd.ms-excel.sheet.macroenabled.12')#('xltm' 'application/vnd.ms-excel.template.macroenabled.12')#('eot' 'application/vnd.ms-fontobject')#('chm' 'application/vnd.ms-htmlhelp')#('ims' 'application/vnd.ms-ims')#('lrm' 'application/vnd.ms-lrm')#('thmx' 'application/vnd.ms-officetheme')#('cat' 'application/vnd.ms-pki.seccat')#('stl' 'application/vnd.ms-pki.stl')#('ppt' 'application/vnd.ms-powerpoint')#('pps' 'application/vnd.ms-powerpoint')#('pot' 'application/vnd.ms-powerpoint')#('ppam' 'application/vnd.ms-powerpoint.addin.macroenabled.12')#('pptm' 'application/vnd.ms-powerpoint.presentation.macroenabled.12')#('sldm' 'application/vnd.ms-powerpoint.slide.macroenabled.12')#('ppsm' 'application/vnd.ms-powerpoint.slideshow.macroenabled.12')#('potm' 'application/vnd.ms-powerpoint.template.macroenabled.12')#('mpp' 'application/vnd.ms-project')#('mpt' 'application/vnd.ms-project')#('docm' 'application/vnd.ms-word.document.macroenabled.12')#('dotm' 'application/vnd.ms-word.template.macroenabled.12')#('wps' 'application/vnd.ms-works')#('wks' 'application/vnd.ms-works')#('wcm' 'application/vnd.ms-works')#('wdb' 'application/vnd.ms-works')#('wpl' 'application/vnd.ms-wpl')#('xps' 'application/vnd.ms-xpsdocument')#('mseq' 'application/vnd.mseq')#('mus' 'application/vnd.musician')#('msty' 'application/vnd.muvee.style')#('taglet' 'application/vnd.mynfc')#('nlu' 'application/vnd.neurolanguage.nlu')#('ntf' 'application/vnd.nitf')#('nitf' 'application/vnd.nitf')#('nnd' 'application/vnd.noblenet-directory')#('nns' 'application/vnd.noblenet-sealer')#('nnw' 'application/vnd.noblenet-web')#('ngdat' 'application/vnd.nokia.n-gage.data')#('n-gage' 'application/vnd.nokia.n-gage.symbian.install')#('rpst' 'application/vnd.nokia.radio-preset')#('rpss' 'application/vnd.nokia.radio-presets')#('edm' 'application/vnd.novadigm.edm')#('edx' 'application/vnd.novadigm.edx')#('ext' 'application/vnd.novadigm.ext')#('odc' 'application/vnd.oasis.opendocument.chart')#('otc' 'application/vnd.oasis.opendocument.chart-template')#('odb' 'application/vnd.oasis.opendocument.database')#('odf' 'application/vnd.oasis.opendocument.formula')#('odft' 'application/vnd.oasis.opendocument.formula-template')#('odg' 'application/vnd.oasis.opendocument.graphics')#('otg' 'application/vnd.oasis.opendocument.graphics-template')#('odi' 'application/vnd.oasis.opendocument.image')#('oti' 'application/vnd.oasis.opendocument.image-template')#('odp' 'application/vnd.oasis.opendocument.presentation')#('otp' 'application/vnd.oasis.opendocument.presentation-template')#('ods' 'application/vnd.oasis.opendocument.spreadsheet')#('ots' 'application/vnd.oasis.opendocument.spreadsheet-template')#('odt' 'application/vnd.oasis.opendocument.text')#('odm' 'application/vnd.oasis.opendocument.text-master')#('ott' 'application/vnd.oasis.opendocument.text-template')#('oth' 'application/vnd.oasis.opendocument.text-web')#('xo' 'application/vnd.olpc-sugar')#('dd2' 'application/vnd.oma.dd2+xml')#('oxt' 'application/vnd.openofficeorg.extension')#('pptx' 'application/vnd.openxmlformats-officedocument.presentationml.presentation')#('sldx' 'application/vnd.openxmlformats-officedocument.presentationml.slide')#('ppsx' 'application/vnd.openxmlformats-officedocument.presentationml.slideshow')#('potx' 'application/vnd.openxmlformats-officedocument.presentationml.template')#('xlsx' 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet')#('xltx' 'application/vnd.openxmlformats-officedocument.spreadsheetml.template')#('docx' 'application/vnd.openxmlformats-officedocument.wordprocessingml.document')#('dotx' 'application/vnd.openxmlformats-officedocument.wordprocessingml.template')#('mgp' 'application/vnd.osgeo.mapguide.package')#('dp' 'application/vnd.osgi.dp')#('esa' 'application/vnd.osgi.subsystem')#('pdb' 'application/vnd.palm')#('pqa' 'application/vnd.palm')#('oprc' 'application/vnd.palm')#('paw' 'application/vnd.pawaafile')#('str' 'application/vnd.pg.format')#('ei6' 'application/vnd.pg.osasli')#('efif' 'application/vnd.picsel')#('wg' 'application/vnd.pmi.widget')#('plf' 'application/vnd.pocketlearn')#('pbd' 'application/vnd.powerbuilder6')#('box' 'application/vnd.previewsystems.box')#('mgz' 'application/vnd.proteus.magazine')#('qps' 'application/vnd.publishare-delta-tree')#('ptid' 'application/vnd.pvi.ptid1')#('qxd' 'application/vnd.quark.quarkxpress')#('qxt' 'application/vnd.quark.quarkxpress')#('qwd' 'application/vnd.quark.quarkxpress')#('qwt' 'application/vnd.quark.quarkxpress')#('qxl' 'application/vnd.quark.quarkxpress')#('qxb' 'application/vnd.quark.quarkxpress')#('bed' 'application/vnd.realvnc.bed')#('mxl' 'application/vnd.recordare.musicxml')#('musicxml' 'application/vnd.recordare.musicxml+xml')#('cryptonote' 'application/vnd.rig.cryptonote')#('cod' 'application/vnd.rim.cod')#('rm' 'application/vnd.rn-realmedia')#('rmvb' 'application/vnd.rn-realmedia-vbr')#('link66' 'application/vnd.route66.link66+xml')#('st' 'application/vnd.sailingtracker.track')#('see' 'application/vnd.seemail')#('sema' 'application/vnd.sema')#('semd' 'application/vnd.semd')#('semf' 'application/vnd.semf')#('ifm' 'application/vnd.shana.informed.formdata')#('itp' 'application/vnd.shana.informed.formtemplate')#('iif' 'application/vnd.shana.informed.interchange')#('ipk' 'application/vnd.shana.informed.package')#('twd' 'application/vnd.simtech-mindmapper')#('twds' 'application/vnd.simtech-mindmapper')#('mmf' 'application/vnd.smaf')#('teacher' 'application/vnd.smart.teacher')#('sdkm' 'application/vnd.solent.sdkm+xml')#('sdkd' 'application/vnd.solent.sdkm+xml')#('dxp' 'application/vnd.spotfire.dxp')#('sfs' 'application/vnd.spotfire.sfs')#('sdc' 'application/vnd.stardivision.calc')#('sda' 'application/vnd.stardivision.draw')#('sdd' 'application/vnd.stardivision.impress')#('smf' 'application/vnd.stardivision.math')#('sdw' 'application/vnd.stardivision.writer')#('vor' 'application/vnd.stardivision.writer')#('sgl' 'application/vnd.stardivision.writer-global')#('smzip' 'application/vnd.stepmania.package')#('sm' 'application/vnd.stepmania.stepchart')#('sxc' 'application/vnd.sun.xml.calc')#('stc' 'application/vnd.sun.xml.calc.template')#('sxd' 'application/vnd.sun.xml.draw')#('std' 'application/vnd.sun.xml.draw.template')#('sxi' 'application/vnd.sun.xml.impress')#('sti' 'application/vnd.sun.xml.impress.template')#('sxm' 'application/vnd.sun.xml.math')#('sxw' 'application/vnd.sun.xml.writer')#('sxg' 'application/vnd.sun.xml.writer.global')#('stw' 'application/vnd.sun.xml.writer.template')#('sus' 'application/vnd.sus-calendar')#('susp' 'application/vnd.sus-calendar')#('svd' 'application/vnd.svd')#('sis' 'application/vnd.symbian.install')#('sisx' 'application/vnd.symbian.install')#('xsm' 'application/vnd.syncml+xml')#('bdm' 'application/vnd.syncml.dm+wbxml')#('xdm' 'application/vnd.syncml.dm+xml')#('tao' 'application/vnd.tao.intent-module-archive')#('pcap' 'application/vnd.tcpdump.pcap')#('cap' 'application/vnd.tcpdump.pcap')#('dmp' 'application/vnd.tcpdump.pcap')#('tmo' 'application/vnd.tmobile-livetv')#('tpt' 'application/vnd.trid.tpt')#('mxs' 'application/vnd.triscape.mxs')#('tra' 'application/vnd.trueapp')#('ufd' 'application/vnd.ufdl')#('ufdl' 'application/vnd.ufdl')#('utz' 'application/vnd.uiq.theme')#('umj' 'application/vnd.umajin')#('unityweb' 'application/vnd.unity')#('uoml' 'application/vnd.uoml+xml')#('vcx' 'application/vnd.vcx')#('vsd' 'application/vnd.visio')#('vst' 'application/vnd.visio')#('vss' 'application/vnd.visio')#('vsw' 'application/vnd.visio')#('vis' 'application/vnd.visionary')#('vsf' 'application/vnd.vsf')#('wbxml' 'application/vnd.wap.wbxml')#('wmlc' 'application/vnd.wap.wmlc')#('wmlsc' 'application/vnd.wap.wmlscriptc')#('wtb' 'application/vnd.webturbo')#('nbp' 'application/vnd.wolfram.player')#('wpd' 'application/vnd.wordperfect')#('wqd' 'application/vnd.wqd')#('stf' 'application/vnd.wt.stf')#('xar' 'application/vnd.xara')#('xfdl' 'application/vnd.xfdl')#('hvd' 'application/vnd.yamaha.hv-dic')#('hvs' 'application/vnd.yamaha.hv-script')#('hvp' 'application/vnd.yamaha.hv-voice')#('osf' 'application/vnd.yamaha.openscoreformat')#('osfpvg' 'application/vnd.yamaha.openscoreformat.osfpvg+xml')#('saf' 'application/vnd.yamaha.smaf-audio')#('spf' 'application/vnd.yamaha.smaf-phrase')#('cmp' 'application/vnd.yellowriver-custom-menu')#('zir' 'application/vnd.zul')#('zirz' 'application/vnd.zul')#('zaz' 'application/vnd.zzazz.deck+xml')#('vxml' 'application/voicexml+xml')#('wgt' 'application/widget')#('hlp' 'application/winhlp')#('wsdl' 'application/wsdl+xml')#('wspolicy' 'application/wspolicy+xml')#('7z' 'application/x-7z-compressed')#('abw' 'application/x-abiword')#('ace' 'application/x-ace-compressed')#('dmg' 'application/x-apple-diskimage')#('aab' 'application/x-authorware-bin')#('x32' 'application/x-authorware-bin')#('u32' 'application/x-authorware-bin')#('vox' 'application/x-authorware-bin')#('aam' 'application/x-authorware-map')#('aas' 'application/x-authorware-seg')#('bcpio' 'application/x-bcpio')#('torrent' 'application/x-bittorrent')#('blb' 'application/x-blorb')#('blorb' 'application/x-blorb')#('bz' 'application/x-bzip')#('bz2' 'application/x-bzip2')#('boz' 'application/x-bzip2')#('cbr' 'application/x-cbr')#('cba' 'application/x-cbr')#('cbt' 'application/x-cbr')#('cbz' 'application/x-cbr')#('cb7' 'application/x-cbr')#('vcd' 'application/x-cdlink')#('cfs' 'application/x-cfs-compressed')#('chat' 'application/x-chat')#('pgn' 'application/x-chess-pgn')#('nsc' 'application/x-conference')#('cpio' 'application/x-cpio')#('csh' 'application/x-csh')#('deb' 'application/x-debian-package')#('udeb' 'application/x-debian-package')#('dgc' 'application/x-dgc-compressed')#('dir' 'application/x-director')#('dcr' 'application/x-director')#('dxr' 'application/x-director')#('cst' 'application/x-director')#('cct' 'application/x-director')#('cxt' 'application/x-director')#('w3d' 'application/x-director')#('fgd' 'application/x-director')#('swa' 'application/x-director')#('wad' 'application/x-doom')#('ncx' 'application/x-dtbncx+xml')#('dtb' 'application/x-dtbook+xml')#('res' 'application/x-dtbresource+xml')#('dvi' 'application/x-dvi')#('evy' 'application/x-envoy')#('eva' 'application/x-eva')#('bdf' 'application/x-font-bdf')#('gsf' 'application/x-font-ghostscript')#('psf' 'application/x-font-linux-psf')#('otf' 'application/x-font-otf')#('pcf' 'application/x-font-pcf')#('snf' 'application/x-font-snf')#('ttf' 'application/x-font-ttf')#('ttc' 'application/x-font-ttf')#('pfa' 'application/x-font-type1')#('pfb' 'application/x-font-type1')#('pfm' 'application/x-font-type1')#('afm' 'application/x-font-type1')#('woff' 'application/x-font-woff')#('arc' 'application/x-freearc')#('spl' 'application/x-futuresplash')#('gca' 'application/x-gca-compressed')#('ulx' 'application/x-glulx')#('gnumeric' 'application/x-gnumeric')#('gramps' 'application/x-gramps-xml')#('gtar' 'application/x-gtar')#('hdf' 'application/x-hdf')#('install' 'application/x-install-instructions')#('iso' 'application/x-iso9660-image')#('jnlp' 'application/x-java-jnlp-file')#('latex' 'application/x-latex')#('lzh' 'application/x-lzh-compressed')#('lha' 'application/x-lzh-compressed')#('mie' 'application/x-mie')#('prc' 'application/x-mobipocket-ebook')#('mobi' 'application/x-mobipocket-ebook')#('application' 'application/x-ms-application')#('lnk' 'application/x-ms-shortcut')#('wmd' 'application/x-ms-wmd')#('wmz' 'application/x-ms-wmz')#('xbap' 'application/x-ms-xbap')#('mdb' 'application/x-msaccess')#('obd' 'application/x-msbinder')#('crd' 'application/x-mscardfile')#('clp' 'application/x-msclip')#('exe' 'application/x-msdownload')#('dll' 'application/x-msdownload')#('com' 'application/x-msdownload')#('bat' 'application/x-msdownload')#('msi' 'application/x-msdownload')#('mvb' 'application/x-msmediaview')#('m13' 'application/x-msmediaview')#('m14' 'application/x-msmediaview')#('wmf' 'application/x-msmetafile')#('wmz' 'application/x-msmetafile')#('emf' 'application/x-msmetafile')#('emz' 'application/x-msmetafile')#('mny' 'application/x-msmoney')#('pub' 'application/x-mspublisher')#('scd' 'application/x-msschedule')#('trm' 'application/x-msterminal')#('wri' 'application/x-mswrite')#('nc' 'application/x-netcdf')#('cdf' 'application/x-netcdf')#('nzb' 'application/x-nzb')#('p12' 'application/x-pkcs12')#('pfx' 'application/x-pkcs12')#('p7b' 'application/x-pkcs7-certificates')#('spc' 'application/x-pkcs7-certificates')#('p7r' 'application/x-pkcs7-certreqresp')#('rar' 'application/x-rar-compressed')#('ris' 'application/x-research-info-systems')#('sh' 'application/x-sh')#('shar' 'application/x-shar')#('swf' 'application/x-shockwave-flash')#('xap' 'application/x-silverlight-app')#('sql' 'application/x-sql')#('sit' 'application/x-stuffit')#('sitx' 'application/x-stuffitx')#('srt' 'application/x-subrip')#('sv4cpio' 'application/x-sv4cpio')#('sv4crc' 'application/x-sv4crc')#('t3' 'application/x-t3vm-image')#('gam' 'application/x-tads')#('tar' 'application/x-tar')#('tcl' 'application/x-tcl')#('tex' 'application/x-tex')#('tfm' 'application/x-tex-tfm')#('texinfo' 'application/x-texinfo')#('texi' 'application/x-texinfo')#('obj' 'application/x-tgif')#('ustar' 'application/x-ustar')#('src' 'application/x-wais-source')#('der' 'application/x-x509-ca-cert')#('crt' 'application/x-x509-ca-cert')#('fig' 'application/x-xfig')#('xlf' 'application/x-xliff+xml')#('xpi' 'application/x-xpinstall')#('xz' 'application/x-xz')#('z1' 'application/x-zmachine')#('z2' 'application/x-zmachine')#('z3' 'application/x-zmachine')#('z4' 'application/x-zmachine')#('z5' 'application/x-zmachine')#('z6' 'application/x-zmachine')#('z7' 'application/x-zmachine')#('z8' 'application/x-zmachine')#('xaml' 'application/xaml+xml')#('xdf' 'application/xcap-diff+xml')#('xenc' 'application/xenc+xml')#('xhtml' 'application/xhtml+xml')#('xht' 'application/xhtml+xml')#('xml' 'application/xml')#('xsl' 'application/xml')#('dtd' 'application/xml-dtd')#('xop' 'application/xop+xml')#('xpl' 'application/xproc+xml')#('xslt' 'application/xslt+xml')#('xspf' 'application/xspf+xml')#('mxml' 'application/xv+xml')#('xhvml' 'application/xv+xml')#('xvml' 'application/xv+xml')#('xvm' 'application/xv+xml')#('yang' 'application/yang')#('yin' 'application/yin+xml')#('zip' 'application/zip')#('adp' 'audio/adpcm')#('au' 'audio/basic')#('snd' 'audio/basic')#('mid' 'audio/midi')#('midi' 'audio/midi')#('kar' 'audio/midi')#('rmi' 'audio/midi')#('mp4a' 'audio/mp4')#('mpga' 'audio/mpeg')#('mp2' 'audio/mpeg')#('mp2a' 'audio/mpeg')#('mp3' 'audio/mpeg')#('m2a' 'audio/mpeg')#('m3a' 'audio/mpeg')#('oga' 'audio/ogg')#('ogg' 'audio/ogg')#('spx' 'audio/ogg')#('s3m' 'audio/s3m')#('sil' 'audio/silk')#('uva' 'audio/vnd.dece.audio')#('uvva' 'audio/vnd.dece.audio')#('eol' 'audio/vnd.digital-winds')#('dra' 'audio/vnd.dra')#('dts' 'audio/vnd.dts')#('dtshd' 'audio/vnd.dts.hd')#('lvp' 'audio/vnd.lucent.voice')#('pya' 'audio/vnd.ms-playready.media.pya')#('ecelp4800' 'audio/vnd.nuera.ecelp4800')#('ecelp7470' 'audio/vnd.nuera.ecelp7470')#('ecelp9600' 'audio/vnd.nuera.ecelp9600')#('rip' 'audio/vnd.rip')#('weba' 'audio/webm')#('aac' 'audio/x-aac')#('aif' 'audio/x-aiff')#('aiff' 'audio/x-aiff')#('aifc' 'audio/x-aiff')#('caf' 'audio/x-caf')#('flac' 'audio/x-flac')#('mka' 'audio/x-matroska')#('m3u' 'audio/x-mpegurl')#('wax' 'audio/x-ms-wax')#('wma' 'audio/x-ms-wma')#('ram' 'audio/x-pn-realaudio')#('ra' 'audio/x-pn-realaudio')#('rmp' 'audio/x-pn-realaudio-plugin')#('wav' 'audio/x-wav')#('xm' 'audio/xm')#('cdx' 'chemical/x-cdx')#('cif' 'chemical/x-cif')#('cmdf' 'chemical/x-cmdf')#('cml' 'chemical/x-cml')#('csml' 'chemical/x-csml')#('xyz' 'chemical/x-xyz')#('bmp' 'image/bmp')#('cgm' 'image/cgm')#('g3' 'image/g3fax')#('gif' 'image/gif')#('ief' 'image/ief')#('jpeg' 'image/jpeg')#('jpg' 'image/jpeg')#('jpe' 'image/jpeg')#('ktx' 'image/ktx')#('png' 'image/png')#('btif' 'image/prs.btif')#('sgi' 'image/sgi')#('svg' 'image/svg+xml')#('svgz' 'image/svg+xml')#('tiff' 'image/tiff')#('tif' 'image/tiff')#('psd' 'image/vnd.adobe.photoshop')#('uvi' 'image/vnd.dece.graphic')#('uvvi' 'image/vnd.dece.graphic')#('uvg' 'image/vnd.dece.graphic')#('uvvg' 'image/vnd.dece.graphic')#('sub' 'image/vnd.dvb.subtitle')#('djvu' 'image/vnd.djvu')#('djv' 'image/vnd.djvu')#('dwg' 'image/vnd.dwg')#('dxf' 'image/vnd.dxf')#('fbs' 'image/vnd.fastbidsheet')#('fpx' 'image/vnd.fpx')#('fst' 'image/vnd.fst')#('mmr' 'image/vnd.fujixerox.edmics-mmr')#('rlc' 'image/vnd.fujixerox.edmics-rlc')#('mdi' 'image/vnd.ms-modi')#('wdp' 'image/vnd.ms-photo')#('npx' 'image/vnd.net-fpx')#('wbmp' 'image/vnd.wap.wbmp')#('xif' 'image/vnd.xiff')#('webp' 'image/webp')#('3ds' 'image/x-3ds')#('ras' 'image/x-cmu-raster')#('cmx' 'image/x-cmx')#('fh' 'image/x-freehand')#('fhc' 'image/x-freehand')#('fh4' 'image/x-freehand')#('fh5' 'image/x-freehand')#('fh7' 'image/x-freehand')#('ico' 'image/x-icon')#('sid' 'image/x-mrsid-image')#('pcx' 'image/x-pcx')#('pic' 'image/x-pict')#('pct' 'image/x-pict')#('pnm' 'image/x-portable-anymap')#('pbm' 'image/x-portable-bitmap')#('pgm' 'image/x-portable-graymap')#('ppm' 'image/x-portable-pixmap')#('rgb' 'image/x-rgb')#('tga' 'image/x-tga')#('xbm' 'image/x-xbitmap')#('xpm' 'image/x-xpixmap')#('xwd' 'image/x-xwindowdump')#('eml' 'message/rfc822')#('mime' 'message/rfc822')#('igs' 'model/iges')#('iges' 'model/iges')#('msh' 'model/mesh')#('mesh' 'model/mesh')#('silo' 'model/mesh')#('dae' 'model/vnd.collada+xml')#('dwf' 'model/vnd.dwf')#('gdl' 'model/vnd.gdl')#('gtw' 'model/vnd.gtw')#('mts' 'model/vnd.mts')#('vtu' 'model/vnd.vtu')#('wrl' 'model/vrml')#('vrml' 'model/vrml')#('x3db' 'model/x3d+binary')#('x3dbz' 'model/x3d+binary')#('x3dv' 'model/x3d+vrml')#('x3dvz' 'model/x3d+vrml')#('x3d' 'model/x3d+xml')#('x3dz' 'model/x3d+xml')#('appcache' 'text/cache-manifest')#('ics' 'text/calendar')#('ifb' 'text/calendar')#('css' 'text/css')#('csv' 'text/csv')#('html' 'text/html')#('htm' 'text/html')#('n3' 'text/n3')#('txt' 'text/plain')#('text' 'text/plain')#('conf' 'text/plain')#('def' 'text/plain')#('list' 'text/plain')#('log' 'text/plain')#('in' 'text/plain')#('dsc' 'text/prs.lines.tag')#('rtx' 'text/richtext')#('sgml' 'text/sgml')#('sgm' 'text/sgml')#('tsv' 'text/tab-separated-values')#('t' 'text/troff')#('tr' 'text/troff')#('roff' 'text/troff')#('man' 'text/troff')#('me' 'text/troff')#('ms' 'text/troff')#('ttl' 'text/turtle')#('uri' 'text/uri-list')#('uris' 'text/uri-list')#('urls' 'text/uri-list')#('vcard' 'text/vcard')#('curl' 'text/vnd.curl')#('dcurl' 'text/vnd.curl.dcurl')#('scurl' 'text/vnd.curl.scurl')#('mcurl' 'text/vnd.curl.mcurl')#('sub' 'text/vnd.dvb.subtitle')#('fly' 'text/vnd.fly')#('flx' 'text/vnd.fmi.flexstor')#('gv' 'text/vnd.graphviz')#('3dml' 'text/vnd.in3d.3dml')#('spot' 'text/vnd.in3d.spot')#('jad' 'text/vnd.sun.j2me.app-descriptor')#('wml' 'text/vnd.wap.wml')#('wmls' 'text/vnd.wap.wmlscript')#('s' 'text/x-asm')#('asm' 'text/x-asm')#('c' 'text/x-c')#('cc' 'text/x-c')#('cxx' 'text/x-c')#('cpp' 'text/x-c')#('h' 'text/x-c')#('hh' 'text/x-c')#('dic' 'text/x-c')#('f' 'text/x-fortran')#('for' 'text/x-fortran')#('f77' 'text/x-fortran')#('f90' 'text/x-fortran')#('java' 'text/x-java-source')#('opml' 'text/x-opml')#('p' 'text/x-pascal')#('pas' 'text/x-pascal')#('nfo' 'text/x-nfo')#('etx' 'text/x-setext')#('sfv' 'text/x-sfv')#('uu' 'text/x-uuencode')#('vcs' 'text/x-vcalendar')#('vcf' 'text/x-vcard')#('3gp' 'video/3gpp')#('3g2' 'video/3gpp2')#('h261' 'video/h261')#('h263' 'video/h263')#('h264' 'video/h264')#('jpgv' 'video/jpeg')#('jpm' 'video/jpm')#('jpgm' 'video/jpm')#('mj2' 'video/mj2')#('mjp2' 'video/mj2')#('mp4' 'video/mp4')#('mp4v' 'video/mp4')#('mpg4' 'video/mp4')#('mpeg' 'video/mpeg')#('mpg' 'video/mpeg')#('mpe' 'video/mpeg')#('m1v' 'video/mpeg')#('m2v' 'video/mpeg')#('ogv' 'video/ogg')#('qt' 'video/quicktime')#('mov' 'video/quicktime')#('uvh' 'video/vnd.dece.hd')#('uvvh' 'video/vnd.dece.hd')#('uvm' 'video/vnd.dece.mobile')#('uvvm' 'video/vnd.dece.mobile')#('uvp' 'video/vnd.dece.pd')#('uvvp' 'video/vnd.dece.pd')#('uvs' 'video/vnd.dece.sd')#('uvvs' 'video/vnd.dece.sd')#('uvv' 'video/vnd.dece.video')#('uvvv' 'video/vnd.dece.video')#('dvb' 'video/vnd.dvb.file')#('fvt' 'video/vnd.fvt')#('mxu' 'video/vnd.mpegurl')#('m4u' 'video/vnd.mpegurl')#('pyv' 'video/vnd.ms-playready.media.pyv')#('uvu' 'video/vnd.uvvu.mp4')#('uvvu' 'video/vnd.uvvu.mp4')#('viv' 'video/vnd.vivo')#('webm' 'video/webm')#('f4v' 'video/x-f4v')#('fli' 'video/x-fli')#('flv' 'video/x-flv')#('m4v' 'video/x-m4v')#('mkv' 'video/x-matroska')#('mk3d' 'video/x-matroska')#('mks' 'video/x-matroska')#('mng' 'video/x-mng')#('asf' 'video/x-ms-asf')#('asx' 'video/x-ms-asf')#('vob' 'video/x-ms-vob')#('wm' 'video/x-ms-wm')#('wmv' 'video/x-ms-wmv')#('wmx' 'video/x-ms-wmx')#('wvx' 'video/x-ms-wvx')#('avi' 'video/x-msvideo')#('movie' 'video/x-sgi-movie')#('smv' 'video/x-smv')#('ice' 'x-conference/x-cooltalk'))</body><body package="SiouX-Http">initializeFileExtensionToMimeTypeMap	FileExtensionToMimeTypeMap := Dictionary new: 980.	self defaultFileExtensionMap do: [ :element | 		FileExtensionToMimeTypeMap at: element first put: element last].</body></methods><methods><class-id>SiouX.HttpResponsePart class</class-id> <category>accessing</category><body package="SiouX-Http">applyGzipCompression	^applyGzipCompression ifNil: [false]</body><body package="SiouX-Http">applyGzipCompression: aBoolean	applyGzipCompression := aBoolean</body></methods><methods><class-id>SiouX.HttpResponse</class-id> <category>accessing</category><body package="SiouX-Http">addPart: contents	self isMultipart ifFalse: [ (self contentType: 'multipart/mixed') boundary: self generateBoundary ].	^body add: ((HttpResponsePart contents: contents) parent: self;  yourself)</body><body package="SiouX-Http">code	^code</body><body package="SiouX-Http">code: anInteger	code := anInteger</body><body package="SiouX-Http">parameterCharset	^parameterCharset ifNil: [ ParameterCharset ]</body><body package="SiouX-Http">parameterCharset: string	parameterCharset := string</body><body package="SiouX-Http">request	^request</body><body package="SiouX-Http">request: anHttpRequest	request := anHttpRequest</body></methods><methods><class-id>SiouX.HttpResponse</class-id> <category>testing</category><body package="SiouX-Http">canGzipEncode		request ifNil: [^false].	^request acceptEncoding anySatisfy: [ :coding | 		coding acceptableEncodings includes: 'gzip']</body><body package="SiouX-Http">canGzipTE		request ifNil: [^false].	^request te anySatisfy: [ :coding | 		coding acceptableEncodings includes: 'gzip']</body><body package="SiouX-Http">isMultipart	^self contentType ifNil: [ false ] ifNotNil: [ :ct | ct isMultipart ]</body><body package="SiouX-Http">isPart	^false</body><body package="SiouX-Http">isSuccess		^code notNil and: [ code &lt; 300 ]</body><body package="SiouX-Http">shouldApplyGzipContent	^self canGzipEncode and: [applyGzipCompression]</body><body package="SiouX-Http">shouldApplyTEGzip	^self canGzipTE and: [applyGzipCompression]</body></methods><methods><class-id>SiouX.HttpResponse</class-id> <category>private-writing</category><body package="SiouX-Http">binaryBoundaryLine	^(ByteArray new writing encoding: #'ISO8859_1')		setLineEndCRLF;		put: CR; write: '--'; write: self contentType boundary;		close;		terminal</body><body package="SiouX-Http">computeContentLength	| bodies buffer allHeaders boundaries |	body ifNil: [^0].	(self shouldApplyTEGzip or: [self shouldApplyGzipContent]) ifTrue: [ ^nil ].	self isMultipart ifFalse: [ ^super computeContentLength ].	boundary := self binaryBoundaryLine.	bodies := body inject: 0 into: [ :total :part |		part computeContentLength			ifNil: [^nil]			ifNotNil: [ :length | length + total ] ].	buffer := (Buffer on: ByteArray newRecycledDefaultSize) writing.	body do: [ :part | part writeHeaderOn: buffer ].	allHeaders := buffer terminal readSize.	buffer terminal recycle.	boundaries := (body size + 1) "number of boundaries" * (boundary size + 2 "crlf")	"Technically we should also add 2 final dashes, but need to also subtract the first crlf =&gt; add 0".	^bodies + allHeaders + boundaries</body><body package="SiouX-Http">generateBoundary	^String new writing		write: '===';		print: Time microsecondClock;		write: '===';		close;		terminal</body><body package="SiouX-Http">writeHeaderValueTimestamp: aTimestamp on: aStream" http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.18 	The Http-date  it MUST be sent in RFC 1123 date format.	Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123"	^self class encodeTimestamp: aTimestamp on: aStream</body><body package="SiouX-Http">writeHeadersOn: aStream	| headerStream |	"Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF"	aStream write: HttpStatusVersion; write: (HttpReasonPhrases at: code); write: CRLF.	"Headers"	ServerHeader ifNotNil: [ aStream write: ServerHeader; write: CRLF ].	self date: Timestamp nowUTC.	headerStream := ((aStream closing: []) encoding: #ISO8859_1) setLineEndCRLF.	self headers do: [ :header | header writeFor: self on: headerStream. headerStream cr ].	^ headerStream</body><body package="SiouX-Http">writeOn: aStream	| bodyStream buffer dashes cr headerStream positioning |	headerStream := self writeHeadersOn: aStream.	bodyStream := self computeContentLength		ifNil: [| str te gzipBody |			"If we can't calculate the response length we use chunked format"			te := 'chunked'.			gzipBody := false.			"Check if the response body was required to compress using gzip. We do it only if the client accepts gzip encoding and the response #applyGzipCompression was set on "			self shouldApplyGzipContent				ifTrue: ["All browsers suggest to use content-encoding instead of TE "					(HttpResponseHeaderField name: 'content-encoding' value: 'gzip') writeFor: self on: headerStream. headerStream cr. gzipBody := true]				ifFalse: ["As it is right now there is no a browser that supports TE "					self shouldApplyTEGzip ifTrue: [te := 'gzip, ', te. gzipBody := true]].			(HttpResponseHeaderField name: 'transfer-encoding' value: te) writeFor: self on: headerStream. headerStream cr.			str := (positioning := ChunkedWriteStream on: aStream) buffering: MaxChunkSize.			gzipBody ifTrue: [str := str gzipBestCompressing].			str]		ifNotNil: [ :lengthOrBuffer || length |			length := lengthOrBuffer isInteger ifTrue: [ lengthOrBuffer ] ifFalse: [ buffer := lengthOrBuffer. buffer readSize ].			(HttpResponseHeaderField name: 'content-length' value: length) writeFor: self on: headerStream. headerStream cr.			positioning := aStream limiting: (self isMultipart ifTrue: [ length +  2 ] ifFalse: [ length ]) "to detect when the length wasn't calculated correctly"			"For multipart body we don't emit the terminating crlf for the header, because it will be emitted with the first boundary.			However that's still part of the header and therefore not part of the content-length, so we have to add extra two bytes to the limit above to compensate." ].	self isMultipart ifFalse: [		headerStream cr; close.		buffer ifNil: [ body siouxWriteBodyFor: self on: bodyStream. bodyStream flush ]			ifNotNil: [ bodyStream write: buffer reading; flush. buffer recycle ].		bodyStream close.		^positioning position ].	headerStream close.	dashes := #[45 45]. " '--' asByteArrayEncoding: #ascii "	cr := #[13 10].	"WARNING: What's written here must exactly match computeContentLength called above!"	body do: [ :part |		bodyStream write: boundary; write: cr.		part writeOn: bodyStream ].	bodyStream write: boundary; write: dashes; write: cr; close.	^positioning position</body><body package="SiouX-Http">writeOnConnection: anHttpConnection	anHttpConnection continueProcessing ifFalse: [self connectionClose].	^self writeOn: anHttpConnection writeStream</body></methods><methods><class-id>SiouX.HttpResponse</class-id> <category>private</category><body package="SiouX-Http">ensureMultipartBody	| parts |	self isMultipart ifTrue: [^self].	parts := OrderedCollection new.	body ifNotNil: [ | part |		part := HttpResponsePart new parent: self;  yourself.		headers do: [ :h |			(#('content-type' 'content-disposition') includes: h name) ifTrue: [				part headers add: h ] ].		headers removeAll: part headers.		part contents: body.		parts add: part ].	body := parts</body><body package="SiouX-Http">setSimpleBody: anObject	self isMultipart ifTrue: [ self error: (#CanntSetContentsMultipartResp &lt;&lt; #www &gt;&gt;'Cannot set simple content on a multipart response!') ].	body := anObject</body></methods><methods><class-id>SiouX.HttpResponse</class-id> <category>accessing-headers</category><body package="SiouX-Http">authenticate	^self header: 'authenticate'</body><body package="SiouX-Http">authenticate: anAuthenticate	self privateHeader: 'www-authenticate' value: anAuthenticate</body><body package="SiouX-Http">cacheControl	^self header: 'cache-control'</body><body package="SiouX-Http">cacheControl: aString	self privateHeader: 'cache-control' value: aString</body><body package="SiouX-Http">connectionClose	self privateHeader: 'connection' value: 'close'</body><body package="SiouX-Http">contentEncoding	^self header: 'content-encoding'</body><body package="SiouX-Http">contentEncoding: token	self privateHeader: 'content-encoding' value: token</body><body package="SiouX-Http">contentType: value	(value beginsWith: 'multipart/') ifTrue: [ self ensureMultipartBody ].	^super contentType: value</body><body package="SiouX-Http">date	self header: 'date'</body><body package="SiouX-Http">date: aTimestamp	self privateHeader: 'date' value: aTimestamp</body><body package="SiouX-Http">expires	^self header: 'expires'</body><body package="SiouX-Http">expires: aTimestamp	self privateHeader: 'expires' value: aTimestamp</body><body package="SiouX-Http">preloadLink: aString	headers add: (HttpResponseHeaderField name: 'link' value: ( LinkField fromString: aString))</body><body package="SiouX-Http">preloadLinksRemoveDo: aBlock	headers copy do: [ :h | 		((h matches: 'link')			and: [h value rel = 'preload'])			ifTrue: [				aBlock value: h.				headers remove: h]].</body><body package="SiouX-Http">setCookie	^self header: 'set-cookie'</body><body package="SiouX-Http">setCookie: aCookie	self privateHeader: 'set-cookie' value: 	aCookie</body><body package="SiouX-Http">transferEncoding	^self header: 'transfer-encoding'</body><body package="SiouX-Http">transferEncoding: token	self privateHeader: 'transfer-encoding' value: token</body></methods><methods><class-id>SiouX.HttpResponse</class-id> <category>printing</category><body package="SiouX-Http">printOn: aStream	self printStatusLineOn: aStream.	aStream cr.	super printOn: aStream</body><body package="SiouX-Http">printStatusLineOn: aStream	aStream 		nextPutAll: (HttpStatusVersion asStringEncoding: #ascii);		nextPutAll: ((HttpReasonPhrases at: code) asStringEncoding: #ascii)</body></methods><methods><class-id>SiouX.HttpResponse</class-id> <category>signaling</category><body package="SiouX-Http">signalReady	ResponseReady signalWith: self</body></methods><methods><class-id>SiouX.HttpResponse class</class-id> <category>class initialization</category><body package="SiouX-Http">codesToReasonPhrases	^Dictionary new		add: 100-&gt;'Continue';		add: 101-&gt;'Switching Protocols';		add: 200-&gt;'OK';		add: 201-&gt;'Created';		add: 202-&gt;'Accepted';		add: 203-&gt;'Non-Authoritative Information';		add: 204-&gt;'No Content';		add: 205-&gt;'Reset Content';		add: 206-&gt;'Partial Content';		add: 300-&gt;'Multiple Choices';		add: 301-&gt;'Moved Permanently';		add: 302-&gt;'Found';		add: 303-&gt;'See Other';		add: 304-&gt;'Not Modified';		add: 305-&gt;'Use Proxy';		add: 307-&gt;'Temporary Redirect';		add: 400-&gt;'Bad Request';		add: 401-&gt;'Unauthorized';		add: 402-&gt;'Payment Required';		add: 403-&gt;'Forbidden';		add: 404-&gt;'Not Found';		add: 405-&gt;'Method Not Allowed';		add: 406-&gt;'Not Acceptable';		add: 407-&gt;'Proxy Authentication Required';		add: 408-&gt;'Request Time-out';		add: 409-&gt;'Conflict';		add: 410-&gt;'Gone';		add: 411-&gt;'Length Required';		add: 412-&gt;'Precondition Failed';		add: 413-&gt;'Request Entity Too Large';		add: 414-&gt;'Request-URI Too Large';		add: 415-&gt;'Unsupported Media Type';		add: 416-&gt;'Requested range not satisfiable';		add: 417-&gt;'Expectation Failed';		add: 500-&gt;'Internal Server Error';		add: 501-&gt;'Not Implemented';		add: 502-&gt;'Bad Gateway';		add: 503-&gt;'Service Unavailable';		add: 504-&gt;'Gateway Time-out';		add: 505-&gt;'HTTP Version not supported';		yourself</body><body package="SiouX-Http">initialize	self serverHeader: HttpConnection serverHeader.	HttpReasonPhrases := IdentityDictionary new.	self codesToReasonPhrases keysAndValuesDo: [ :key :value || bytes |		bytes := (ByteArray new writing encoding: #ascii) print: key; space; write: value; close; terminal.		HttpReasonPhrases at: key put: bytes ].</body><body package="SiouX-Http">serverHeader: string	"Allows to set a global server header value. If nil the header will be omitted."	ServerHeader := string ifNotNil: [self serverHeaderFrom: string]</body><body package="SiouX-Http">serverHeaderFrom: string	^(ByteArray new writing encoding: #ascii)		write: 'Server: ';		write: string;		close;		terminal</body></methods><methods><class-id>SiouX.HttpResponse class</class-id> <category>instance creation</category><body package="SiouX-Http">code: aNumber	^self new		code: aNumber;		yourself</body></methods><methods><class-id>SiouX.HttpResponse class</class-id> <category>utilities</category><body package="SiouX-Http">encodeTimestamp: aTimestamp  on: stream" http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.18 	The Http-date  it MUST be sent in RFC 1123 date format.	Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123"	|   date indx d temp |	date := aTimestamp asDate.	indx := date weekdayIndex.	d := #(#Mon #Tue #Wed #Thu #Fri #Sat #Sun) at: indx.	stream 		write: d;		write: ', '.	date printOn: stream format: #(1 2 3 $  2 1).	stream write: ((temp := aTimestamp hour) &lt; 10 				ifTrue: [' 0']				ifFalse: [' ']).	temp printOn: stream.	stream write: ((temp := aTimestamp minute) &lt; 10 				ifTrue: [':0']				ifFalse: [':']).	temp printOn: stream.	stream write: ((temp := aTimestamp second) &lt; 10 				ifTrue: [':0']				ifFalse: [':']).	temp printOn: stream.	stream write: ' GMT'.</body></methods><methods><class-id>SiouX.HttpResponse class</class-id> <category>accessing</category><body package="SiouX-Http">serverHeaderValue	^HttpConnection serverHeader</body></methods><methods><class-id>SiouX.ChunkedReadStream</class-id> <category>initialize-release</category><body package="SiouX-Http-Extensions">contentsSpecies	^source contentsSpecies</body><body package="SiouX-Http-Extensions">on: aSource	super on: aSource.	sourceAtEnd := false.	chunkSize := 0.	messageSize := 0.</body><body package="SiouX-Http-Extensions">setBodyLimit: aNumberOrNil	bodyLimit := aNumberOrNil</body></methods><methods><class-id>SiouX.ChunkedReadStream</class-id> <category>accessing</category><body package="SiouX-Http-Extensions">read: anInteger into: aSequenceableCollection at: startIndex	| count amount |	count := 0.	chunkSize isZero ifTrue:		[sourceAtEnd ifTrue: [Incomplete zero raise].		chunkSize := self readHexNumber.		chunkSize isZero ifTrue:			[ source get; get. "CRLF after last chunk"			sourceAtEnd := true.			Incomplete zero raise]].	[	[	amount := (anInteger - count) min: chunkSize.			source read: amount into: aSequenceableCollection at: startIndex + count.			count := count + amount.			chunkSize := chunkSize - amount.			chunkSize isZero ifTrue: [ source get; get. "CRLF after chunk data" ].			count &lt; anInteger		] whileTrue: [			chunkSize := self readHexNumber.			chunkSize isZero ifTrue:				[ source get; get. "CRLF after last chunk"				sourceAtEnd := true.				Incomplete zero raise]]	] on: Incomplete do: [:incomplete |			chunkSize := chunkSize - incomplete count.			(Incomplete on: aSequenceableCollection count: count + incomplete count at: startIndex) raise].	^anInteger</body><body package="SiouX-Http-Extensions">readHexNumber"Read chunk-size, chunk-extension (if any) and CRLF.       chunk-size     = 1*HEX       chunk-extension= *( ';' chunk-ext-name [ '=' chunk-ext-val ] )All HTTP/1.1 applications MUST be able to receive and decode the 'chunked' transfer-coding, and MUST ignore chunk-extension extensions they do not understand"	| line total digit index stream |	line := (stream := (((source ending: #[13 10] inclusive: true) encoding: #ascii) filtering: WHITESPACE) collecting: #asLowercase) rest reading.	stream close.	total := 0.	[	digit := line get.		index := ('0123456789abcdef' indexOf: digit) - 1.		index &lt; 0	] whileFalse: [ total := (total bitShift: 4) + index ].	( digit = $; or: [ digit = CR ] ) ifFalse: [ self error: (#InvalidChunkSizeEncoding &lt;&lt; #www &gt;&gt; 'Invalid chunk size encoding!' )].	bodyLimit ifNotNil: [ :max |		messageSize := messageSize + total.		messageSize &gt; max ifTrue: [ ^BadRequest raiseErrorString: ( #ChunkedRequestExceededSizeLimit &lt;&lt; #www &gt;&gt; 'Chunked request exceeded the body size limit: &lt;1p&gt; bytes'  expandMacrosWith: max)]].	^total</body></methods><methods><class-id>SiouX.ChunkedReadStream class</class-id> <category>instance creation</category><body package="SiouX-Http-Extensions">on: aSource bodyLimit: aNumber	^self new 		setBodyLimit: aNumber;		on: aSource</body></methods><methods><class-id>SiouX.ContentDisposition</class-id> <category>testing</category><body package="SiouX-Http">isAttachment" Answer true if content disposition is 'attachments' "	^type = 'attachment'</body><body package="SiouX-Http">isFormData	^type = 'form-data'</body><body package="SiouX-Http">isInline" Answer true if content disposition is 'inline' "	^type = 'inline'</body></methods><methods><class-id>SiouX.ContentDisposition</class-id> <category>accessing</category><body package="SiouX-Http">fileName	^self parametersAt: 'filename'</body><body package="SiouX-Http">fileName: aString	self parametersAt: 'filename' put: aString</body><body package="SiouX-Http">name	^self parametersAt: 'name'</body><body package="SiouX-Http">name: aString	self parametersAt: 'name' put: aString</body><body package="SiouX-Http">size	^self parametersAt:  'size'</body><body package="SiouX-Http">type		^type</body><body package="SiouX-Http">type: aString		type := aString</body></methods><methods><class-id>SiouX.ContentDisposition</class-id> <category>initialize-release</category><body package="SiouX-Http">processValue: valueStream	type := (valueStream filtering: WHITESPACE)  rest.</body><body package="SiouX-Http">value: string	type := string</body></methods><methods><class-id>SiouX.ContentDisposition</class-id> <category>printing</category><body package="SiouX-Http">printOn: aStream	aStream nextPutAll: type.	parameters ifNotNil: [aStream nextPut: $;].	super printOn: aStream</body></methods><methods><class-id>SiouX.ContentDisposition</class-id> <category>private</category><body package="SiouX-Http">value	^type</body></methods><methods><class-id>SiouX.SetCookie</class-id> <category>initialize-release</category><body package="SiouX-Http">initialize	parameters := Protocols.Struct new</body><body package="SiouX-Http">name: nameString value: aString	name := nameString.	value := aString.</body></methods><methods><class-id>SiouX.SetCookie</class-id> <category>private</category><body package="SiouX-Http">siouxWriteHeaderValueFor: entity on: aStream	aStream 		write: name;		put: $=;		write: value.	parameters isEmpty ifTrue: [ ^self].	parameters 		associationsDo: [ :assoc |			aStream write: '; '.			(assoc value isKindOf: Boolean)				ifTrue: [aStream write: assoc key ]				ifFalse: [ assoc value siouxWriteHeaderParameter: assoc key for: self on: aStream. ]].</body><body package="SiouX-Http">value		^value</body><body package="SiouX-Http">writeHeaderParameter: nameString latinString: valueString on: aStream	"Writing latin strings on a cookie should not include enclosing quotes."	aStream		write: nameString; write: '=';		write: valueString</body><body package="SiouX-Http">writeHeaderParameter: nameString number: number on: aStream	aStream		write: nameString; write: '=';		write: number printString</body><body package="SiouX-Http">writeHeaderParameter: aString timestamp: aTimestamp on: aStream	aStream write: aString; write: '='.	HttpResponse encodeTimestamp: aTimestamp on: aStream.</body></methods><methods><class-id>SiouX.SetCookie</class-id> <category>accessing</category><body package="SiouX-Http">domain	^self parametersAt: 'Domain'</body><body package="SiouX-Http">domain: aString"   domain-av         = 'Domain=' domain-value domain-value      = &lt;subdomain&gt;&lt;subdomain&gt; ::= &lt;label&gt; | &lt;subdomain&gt; '.' &lt;label&gt;&lt;label&gt; ::= &lt;letter&gt; [ [ &lt;ldh-str&gt; ] &lt;let-dig&gt; ]&lt;ldh-str&gt; ::= &lt;let-dig-hyp&gt; | &lt;let-dig-hyp&gt; &lt;ldh-str&gt;&lt;let-dig-hyp&gt; ::= &lt;let-dig&gt; | '-'                       ; defined in [RFC1034], Section 3.5, as                       ; enhanced by [RFC1123], Section 2.1TO DO http://tools.ietf.org/html/rfc6265#section-5.1.2    --  5.1.2. Canonicalized Host Names"	self parametersAt: 'Domain' put: aString</body><body package="SiouX-Http">expires	^self parametersAt: 'Expires'</body><body package="SiouX-Http">expires: aTimestamp" expires-av        = 'Expires=' sane-cookie-date sane-cookie-date  = &lt;rfc1123-date, defined in [RFC2616], Section 3.3.1&gt;Expires=Wed, 29-Oct-2014 18:58:25 GMT Expires=Wed, 09 Jun 2021 10:18:14 GMT"	self parametersAt: 'Expires' put: aTimestamp</body><body package="SiouX-Http">httpOnly	^self parametersAt: 'HttpOnly'</body><body package="SiouX-Http">maxAge	^self parametersAt: 'Max-Age'</body><body package="SiouX-Http">maxAge: aNumber"  max-age-av        = 'Max-Age=; non-zero-digit *DIGIT  In practice, both expires-av and max-age-av are limited to dates representable by the user agent."	self parametersAt: 'Max-Age' put: aNumber</body><body package="SiouX-Http">name		^name</body><body package="SiouX-Http">path	^self parametersAt: 'Path'</body><body package="SiouX-Http">path: aString" path-av           = 'Path=' path-value path-value        = &lt;any CHAR except CTLs or ';'&gt; "	self parametersAt: 'Path' put: aString</body><body package="SiouX-Http">secure	^self parametersAt: 'Secure'</body><body package="SiouX-Http">setHttpOnly" httponly-av       = 'HttpOnly' "	self parametersAt: 'HttpOnly' put: true</body><body package="SiouX-Http">setSecure"secure-av         = 'Secure' "	self parametersAt: 'Secure' put: true</body></methods><methods><class-id>SiouX.SetCookie</class-id> <category>printing</category><body package="SiouX-Http">printOn: aStream	| str |	str := String new writing.	self siouxWriteHeaderValueFor: nil on: str.	aStream nextPutAll: str contents.</body></methods><methods><class-id>SiouX.SetCookie class</class-id> <category>instance creation</category><body package="SiouX-Http">name: nameString value: aString	^self new		name: nameString value: aString;		yourself</body><body package="SiouX-Http">new	^super new initialize</body></methods><methods><class-id>SiouX.TE</class-id> <category>testing</category><body package="SiouX-Http">isAcceptEncoding	^false</body><body package="SiouX-Http">isTE	^true</body></methods><methods><class-id>SiouX.FormData</class-id> <category>accessing</category><body package="SiouX-Http">at: aString	^(data select: [ :each | each key = aString ]) collect: #value</body><body package="SiouX-Http">at: aString do: aBlock	data do: [ :each | (each key = aString) ifTrue: [ ^aBlock value: each value ] ].	^nil</body><body package="SiouX-Http">data	^data</body></methods><methods><class-id>SiouX.FormData</class-id> <category>services</category><body package="SiouX-Http">getFormData	^ (#('GET' 'DELETE') includes: request method)		ifTrue: [self getQueryData]		ifFalse: [self getPostData]</body><body package="SiouX-Http">getMultipartFormDataFilesDo: aBlock	data := OrderedCollection new.	request body do: [ :part |		part contentDisposition			ifNil: [ self error: (#MissingContentDispOnMultipart &lt;&lt; #www &gt;&gt; 'Missing content-disposition on multipart/form-data part!' )]			ifNotNil: [ :cd |				data add: (cd fileName					ifNil: [ (cd name ifNil: [ String new ]) -&gt; (OS.URLEncoder decode: part body rest) ]					ifNotNil: [ :fn | fn -&gt; (aBlock value: part ) ]) ]].	^data</body><body package="SiouX-Http">getPostData" Returns form data from POST body "	^request isMultipart		ifTrue: [self getMultipartFormDataFilesDo: [ :part | 'skipped file processing' ] ]		ifFalse: [ request body ifNotNil: [ :body | self getUrlEncodedDataFrom: body]]</body><body package="SiouX-Http">getQueryData" Returns form data from GET query"	^self getUrlEncodedDataFrom: request url query reading</body></methods><methods><class-id>SiouX.FormData</class-id> <category>private</category><body package="SiouX-Http">getUrlEncodedDataFrom: aStream	| parameterStream |	parameterStream := (aStream ending: $&amp;) slicing.	data := parameterStream collect: [ :parameter || key |		key := parameter ending: $=.		[	(OS.URLEncoder decode: key rest) -&gt; (OS.URLEncoder decode: parameter rest)		] ensure: [ key close ] ].	parameterStream close.	^data</body></methods><methods><class-id>SiouX.FormData</class-id> <category>initialize-release</category><body package="SiouX-Http">request: anObject	request := anObject</body></methods><methods><class-id>SiouX.FormData class</class-id> <category>instance creation</category><body package="SiouX-Http">request: anHttpRequest	^self new		request: anHttpRequest;		yourself</body></methods><methods><class-id>SiouX.AcceptLanguage</class-id> <category>accessing</category><body package="SiouX-Http">acceptableLanguages	^self acceptableItemsFrom: self value.</body><body package="SiouX-Http">addLanguage: languageCode	^ self addLanguage: languageCode qValue: nil</body><body package="SiouX-Http">addLanguage: languageCode qValue: qValue	^self value add: (ValueWithParameters new		value: languageCode;		qValue: qValue;		yourself)</body><body package="SiouX-Http">languageTag: languageCode	^ self value		detect: [ :valWithParams | valWithParams  value = languageCode ]		ifNone: [ nil ]</body><body package="SiouX-Http">locales	^ Locale getLocalesWithNames: self acceptableLanguages.</body></methods><methods><class-id>SiouX.AcceptLanguage</class-id> <category>private</category><body package="SiouX-Http">writeHeaderParameter: name latinString: string on: aStream	aStream		write: name; write: '=';		write: string</body></methods><methods><class-id>SiouX.Authorization</class-id> <category>initialize-release</category><body package="SiouX-Http">from: stream	scheme := (stream ending: Character space) rest.	self parametersAt: #source put:  (stream filtering: WHITESPACE) rest.	self isBasic ifTrue: [self parseBasicAuthorization ]</body><body package="SiouX-Http">parseBasicAuthorization			|  stream contents colon input output char |	input := (self parametersAt: #source)  asByteArray readStream.	stream := EncodedStream on: input encodedBy: Protocols.Base64StreamEncoder asEncoder.	output := (ByteArray new: 64) writeStream.	[ (char := stream next) notNil ] whileTrue: [ output nextPut: char ].	contents := (output contents withEncoding: #ASCII) readStream contents.	self parametersAt: #user put: (contents copyFrom: 1 to: (colon := contents indexOf: $:) - 1).	self parametersAt: #password put: (contents copyFrom: colon + 1 to: contents size)</body></methods><methods><class-id>SiouX.Authorization</class-id> <category>printing</category><body package="SiouX-Http">printOn: aStream	scheme ifNotNil: [ aStream nextPutAll: scheme ].	parameters ifNil: [^self].	aStream nextPut: Character space.	self isBasic ifTrue: [ aStream nextPutAll: (self parametersAt: #source)].</body></methods><methods><class-id>SiouX.Authorization</class-id> <category>accessing</category><body package="SiouX-Http">password	^self parametersAt: #password</body><body package="SiouX-Http">user			^self parametersAt: #user</body></methods><methods><class-id>SiouX.Authorization</class-id> <category>testing</category><body package="SiouX-Http">isBasic	^'Basic' match: scheme</body></methods><methods><class-id>SiouX.Authorization</class-id> <category>private</category><body package="SiouX-Http">value	^scheme</body></methods><methods><class-id>SiouX.HttpRequestHeaderField</class-id> <category>printing</category><body package="SiouX-Http">printOn: aStream	aStream		nextPutAll: (name ifNil: [ '&lt;unnamed header field&gt;' ]);		nextPutAll: ': ';		nextPutAll: self body rest</body></methods><methods><class-id>SiouX.HttpRequestHeaderField</class-id> <category>testing</category><body package="SiouX-Http">matches: aName	name size = aName size ifFalse: [^false]. 	name with: aName do: [ :a :b |		a = b asLowercase ifFalse: [ ^false ] ].	^true</body></methods><methods><class-id>SiouX.HttpRequestHeaderField</class-id> <category>initialize-release</category><body package="SiouX-Http">name: nameString source: headerString from: startInteger to: endInteger	name := nameString.	source := headerString.	start := startInteger.	end := endInteger.	isFolded := false.</body><body package="SiouX-Http">setEnd: anInteger	isFolded := true.	end := anInteger</body></methods><methods><class-id>SiouX.HttpRequestHeaderField</class-id> <category>accessing</category><body package="SiouX-Http">body	| stream |	stream := (source reading += start; yourself) limiting: end - start + 1.	stream skipWhitespace. "skip initial spaces"	isFolded ifFalse: [ ^stream ].	^stream filtering: WHITESPACE</body><body package="SiouX-Http">name	^name</body></methods><methods><class-id>SiouX.HttpRequestHeaderField class</class-id> <category>instance creation</category><body package="SiouX-Http">name: nameString source: headerString from: startInteger to: endInteger"	nameString &lt;String&gt; field name, MUST be in canonical form	headerString &lt;String&gt; the entire header containing this field in the string form	startInteger &lt;SmallInteger&gt; where in the headerString does the field value start	endInteger &lt;SmallInteger&gt; where in the headerString does the field value end"	^self new name: nameString source: headerString from: startInteger to: endInteger</body></methods><methods><class-id>SiouX.Authenticate</class-id> <category>accessing</category><body package="SiouX-Http">realm: aString	self parametersAt: 'realm' put: aString</body></methods><methods><class-id>SiouX.Authenticate</class-id> <category>private</category><body package="SiouX-Http">siouxWriteHeaderValueFor: entity on: aStream	aStream write: scheme.	(self parametersAt: 'realm')		ifNotNil: [ :realm | 			aStream 				put: Character space;				write: 'realm';				put: $=;				put: $";				write: realm;				put: $" ].</body><body package="SiouX-Http">value	^scheme</body></methods><methods><class-id>SiouX.Authenticate</class-id> <category>initialize-release</category><body package="SiouX-Http">value: aString	^scheme := aString</body></methods><methods><class-id>SiouX.Authenticate class</class-id> <category>instance creation</category><body package="SiouX-Http">basic	^self new		value: 'Basic';		yourself</body><body package="SiouX-Http">basicRealm: aString	^self basic		realm: aString;		yourself</body></methods><methods><class-id>SiouX.LinkField</class-id> <category>printing</category><body package="SiouX-Http">printOn: aStream	url ifNotNil: [ 		aStream nextPut: $&lt;.		url printPathOn: aStream.		aStream nextPutAll: '&gt;;'  ].		super printOn: aStream.</body></methods><methods><class-id>SiouX.LinkField</class-id> <category>accessing</category><body package="SiouX-Http">rel"relation-types"	^self parametersAt: 'rel'</body><body package="SiouX-Http">rel: aString"relation-types"	self parametersAt: 'rel' put: aString</body><body package="SiouX-Http">url"&lt; URI-Reference &gt;"	^url</body><body package="SiouX-Http">url: aPartialURL"&lt; URI-Reference &gt;"	url := aPartialURL</body></methods><methods><class-id>SiouX.LinkField</class-id> <category>private</category><body package="SiouX-Http">value	|  stream |	stream := ByteString new writing.	stream write: $&lt; .	url printEncodedPathOn: stream.	stream write: $&gt;.	^stream contents</body></methods><methods><class-id>SiouX.LinkField class</class-id> <category>instance creation</category><body package="SiouX-Http">fromString: aString 	^self url: (OS.PartialURL fromString: aString)</body><body package="SiouX-Http">url: anURI 	^self url: anURI rel: 'preload'</body><body package="SiouX-Http">url: anURI rel: aString	^self new 		url: anURI;		rel: aString;		yourself</body></methods><methods><class-id>SiouX.Cookie</class-id> <category>initialize-release</category><body package="SiouX-Http">initialize"Although cookies are serialized linearly in the Cookie header,   servers SHOULD NOT rely upon the serialization order.  In particular,   if the Cookie header contains two cookies with the same name (e.g.,   that were set with different Path or Domain attributes), servers   SHOULD NOT rely upon the order in which these cookies appear in the   header."	parameters := Dictionary new</body><body package="SiouX-Http">processValue: valueStream	| stream cookieKey cookieValue |	stream := valueStream filtering: WHITESPACE.	cookieKey := (stream ending: $=) rest.	cookieValue := stream rest.	(cookieValue first = $" and: [cookieValue last = $"])		ifTrue: [cookieValue := cookieValue copyFrom: 2 to: cookieValue size - 1].	self parametersAt:  cookieKey  put: cookieValue</body><body package="SiouX-Http">value: value"Server doesn't set the Cookie field"</body></methods><methods><class-id>SiouX.ProtocolUpgradeFilter</class-id> <category>accessing</category><body package="SiouX-Http">host: httpRequest		httpRequest headers: 'host' do: [ :field | ^field body rest asLowercase ].	^nil</body><body package="SiouX-Http">origin: httpRequest		httpRequest headers: 'origin' do: [ :field | ^field body rest asLowercase ].	^nil</body><body package="SiouX-Http">supportedProtocols	^ #( 'HTTP/1.1' )</body><body package="SiouX-Http">upgradeToken	^ self subclassResponsibility</body><body package="SiouX-Http">validateHostOriginBlock"Servers that are not intended to process input from any web page but only for certain sites SHOULD verify the |Origin| field is an origin they expect.  If the origin indicated is unacceptable to the server, then it SHOULD respond to the WebSocket handshake with a reply containing HTTP 403 Forbidden status code."	^validateHostOriginBlock ifNil: [validateHostOriginBlock := self class validateHostOriginBlock ]</body><body package="SiouX-Http">validateHostOriginBlock: aBlock	validateHostOriginBlock := aBlock</body></methods><methods><class-id>SiouX.ProtocolUpgradeFilter</class-id> <category>testing</category><body package="SiouX-Http">isMyUpgrade: aRequest	| upgrade |	^(upgrade := aRequest upgrade) notNil		and: [ upgrade includes: self upgradeToken ]</body></methods><methods><class-id>SiouX.ProtocolUpgradeFilter</class-id> <category>services</category><body package="SiouX-Http">applyTo: aRequestContext	aRequestContext request upgrade ifNil: [ ^nil ]."The Upgrade header field only applies to the immediate connection. Therefore, the upgrade keyword MUST be supplied within a Connection header field (section 14.10) whenever Upgrade is present in an HTTP/1.1 message.http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.42"	((aRequestContext request connection includes: 'upgrade') 		and: [ self supportedProtocols includes: aRequestContext request version  ])		ifFalse: [ (aRequestContext response code: 400)					contents: (#UpgradeKeywordMustBeSupplied &lt;&lt; #www &gt;&gt; 'The upgrade keyword MUST be supplied within a Connection header field ');					signalReady ].	(self isMyUpgrade: aRequestContext request) ifFalse: [ ^nil ].	(self validateHostOriginBlock		value: aRequestContext request host		value: aRequestContext request origin		value: aRequestContext) ifFalse: [ ^self invalidHostOriginError: aRequestContext ].	self upgradeRequest: aRequestContext.</body><body package="SiouX-Http">invalidHostOriginError: aRequestContext	^ (aRequestContext response code: 403)		signalReady</body><body package="SiouX-Http">upgradeRequest: aRequestContext	self subclassResponsibility</body></methods><methods><class-id>SiouX.ProtocolUpgradeFilter class</class-id> <category>defaults</category><body package="SiouX-Http">validateHostOriginBlock	^validateHostOriginBlock ifNil: [[ :host :origin :responder | true]]</body><body package="SiouX-Http">validateHostOriginBlock: aBlock	validateHostOriginBlock := aBlock</body></methods><methods><class-id>SiouX.ProtocolUpgradeFilter class</class-id> <category>testing</category><body package="SiouX-Http">isAbstract	^self name = #ProtocolUpgradeFilter</body></methods><methods><class-id>SiouX.ProtocolUpgradeFilter class</class-id> <category>accessing</category><body package="SiouX-Http">toolListIcon	^Tools.GeneralIcons deprecationWarning</body></methods><methods><class-id>SiouX.ValueWithParameters</class-id> <category>accessing</category><body package="SiouX-Http">parameters	^parameters</body><body package="SiouX-Http">parameters: anObject	parameters := anObject</body><body package="SiouX-Http">parametersAt: aString	^ parameters at: aString ifAbsent: [ nil ]</body><body package="SiouX-Http">parametersAt: aString put: anObject	parameters at: aString put: anObject</body><body package="SiouX-Http">qValue	^ (self parametersAt: 'q' ) ifNotNil: [ :q | q asNumber ]</body><body package="SiouX-Http">qValue: aNumber	self parametersAt: 'q' put: aNumber</body><body package="SiouX-Http">value	^value</body><body package="SiouX-Http">value: anObject	value := anObject</body></methods><methods><class-id>SiouX.ValueWithParameters</class-id> <category>printing</category><body package="SiouX-Http">printOn: aStream	aStream nextPutAll: self value.	parameters keysAndValuesDo: [ :name :valx |		aStream 			nextPut: $; ;			nextPutAll: name;			nextPutAll: '='.		valx printOn: aStream ]</body></methods><methods><class-id>SiouX.ValueWithParameters</class-id> <category>parsing</category><body package="SiouX-Http">from: aStream	| parameterStream |	parameterStream := (aStream ending: $;) slicing.	value := (parameterStream get filtering: WHITESPACE) rest .	parameterStream do: [:parx |		| name |		name := ((parx ending: $=) filtering: WHITESPACE) rest.		self processParameterValue: name from: parx]</body><body package="SiouX-Http">processParameterValue: aString from: parameter	| parameterValue char name |	name := aString.	parameterValue := String new writing.	[ (char := parameter get) = SPACE ] whileTrue.	(char = $")		ifTrue: [ parameterValue write: (parameter ending: $") ]		ifFalse: [ parameterValue put: char; write: (parameter filtering: WHITESPACE) ].	parameterValue := parameterValue close; terminal.	self parameters at: name put: parameterValue</body></methods><methods><class-id>SiouX.ValueWithParameters</class-id> <category>initialize-release</category><body package="SiouX-Http">initialize	parameters := Struct new</body></methods><methods><class-id>SiouX.ValueWithParameters</class-id> <category>enumerating</category><body package="SiouX-Http">parametersDo: aBlock	self parameters keysAndValuesDo: [ :key :val | aBlock value: key value: val  ]</body></methods><methods><class-id>SiouX.ValueWithParameters class</class-id> <category>instance creation</category><body package="SiouX-Http">from: aStream	^ self new from: aStream; yourself</body><body package="SiouX-Http">new	^super new		initialize;		yourself</body></methods><methods><class-id>SiouX.RequestContext</class-id> <category>accessing</category><body package="SiouX-Http">readRequestData	^  (FormData request: self request) getFormData; yourself</body><body package="SiouX-Http">requestData	data ifNil: [ data := self readRequestData ].	^ data</body></methods><methods><class-id>Core.Object</class-id> <category>private</category><body package="SiouX-Http-Extensions">xtreamsFilteringStreamOn: stream	^Xtreams.FilteringReadStream on: stream filter: [ :each | each ~= self ]</body></methods><methods><class-id>Core.ByteString</class-id> <category>private</category><body package="SiouX-Http-Extensions">siouxSetContentsOn: responsePart	responsePart setStringContents: self charset: LATIN1</body><body package="SiouX-Http-Extensions">siouxWriteHeaderParameter: name for: entity on: aStream	entity writeHeaderParameter: name latinString: self on: aStream</body></methods><methods><class-id>Core.ByteArray</class-id> <category>private</category><body package="SiouX-Http-Extensions">siouxComputeContentLengthFor: response	^self size</body><body package="SiouX-Http-Extensions">siouxSetContentsOn: responsePart	responsePart setByteContents: self</body><body package="SiouX-Http-Extensions">siouxWriteBodyFor: entity on: stream	entity writeBodyBytes: self on: stream</body></methods><methods><class-id>OS.Filename</class-id> <category>private</category><body package="SiouX-Http-Extensions">siouxComputeContentLengthFor: response	^self fileSize</body><body package="SiouX-Http-Extensions">siouxSetContentsOn: responsePart	responsePart setFilenameContents: self</body><body package="SiouX-Http-Extensions">siouxWriteBodyFor: entity on: stream	entity writeBodyFilename: self on: stream</body></methods><methods><class-id>Core.ByteEncodedString</class-id> <category>private</category><body package="SiouX-Http-Extensions">siouxComputeContentLengthFor: response	(self size &gt; MaxUnchunkedNarrowString) ifTrue: [ ^nil ].	(response charset = LATIN1) ifFalse: [ ^super siouxComputeContentLengthFor: response ].	^self size</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>private</category><body package="SiouX-Http-Extensions">xtreamsFilteringStreamOn: stream	^Xtreams.FilteringReadStream on: stream filter: [ :each | (self includes: each) not ]</body></methods><methods><class-id>Core.Timestamp</class-id> <category>private</category><body package="SiouX-Http-Extensions">siouxWriteHeaderParameter: name for: entity on: aStream	entity writeHeaderParameter: name timestamp: self on: aStream</body><body package="SiouX-Http-Extensions">siouxWriteHeaderValueFor: entity on: aStream	entity writeHeaderValueTimestamp: self on: aStream</body></methods><methods><class-id>Core.Number</class-id> <category>private</category><body package="SiouX-Http-Extensions">siouxWriteHeaderParameter: name for: entity on: aStream	entity writeHeaderParameter: name number: self on: aStream</body><body package="SiouX-Http-Extensions">siouxWriteHeaderValueFor: entity on: aStream	entity writeHeaderValueNumber: self on: aStream</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>private</category><body package="SiouX-Http-Extensions">siouxWriteBodyFor: entity on: stream</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>private</category><body package="SiouX-Http-Extensions">siouxComputeContentLengthFor: response	^nil</body><body package="SiouX-Http-Extensions">siouxSetContentsOn: responsePart	responsePart setBlockContents: self</body><body package="SiouX-Http-Extensions">siouxWriteBodyFor: entity on: stream	entity writeBodyBlock: self on: stream</body><body package="SiouX-Http-Extensions">xtreamsFilteringStreamOn: stream	^Xtreams.FilteringReadStream on: stream filter: self</body></methods><methods><class-id>Core.MSCP1252String</class-id> <category>private</category><body package="SiouX-Http-Extensions">siouxComputeContentLengthFor: response	(self size &gt; MaxUnchunkedNarrowString) ifTrue: [ ^nil ].	(response charset = MSCP1252 ) ifFalse: [ ^super siouxComputeContentLengthFor: response ].	^self size</body><body package="SiouX-Http-Extensions">siouxSetContentsOn: responsePart	responsePart setStringContents: self charset: MSCP1252</body></methods><methods><class-id>Kernel.UserMessage</class-id> <category>private</category><body package="SiouX-Http-Extensions">siouxSetContentsOn: responsePart	self asString siouxSetContentsOn: responsePart</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>private</category><body package="SiouX-Http-Extensions">siouxComputeContentLengthFor: response	| buffer stream |	response isPart ifTrue: [ ^nil ].	self size &gt; MaxUnchunkedWideStringSize ifTrue: [ ^nil ].	buffer := Buffer on: ByteArray newRecycledDefaultSize.	stream := (buffer writing encoding: response encoding) setLineEndTransparent.	stream write: self.	^buffer</body><body package="SiouX-Http-Extensions">siouxSetContentsOn: responsePart	responsePart setStringContents: self charset: UTF8</body><body package="SiouX-Http-Extensions">siouxWriteBodyFor: entity on: stream	entity writeBodyString: self on: stream</body><body package="SiouX-Http-Extensions">siouxWriteHeaderParameter: name for: entity on: aStream	entity writeHeaderParameter: name string: self on: aStream</body><body package="SiouX-Http-Extensions">siouxWriteHeaderValueFor: entity on: aStream	entity writeHeaderValueString: self on: aStream</body></methods><methods><class-id>Xtreams.ReadStream</class-id> <category>transforming</category><body package="SiouX-Http-Extensions">filtering: criteria"	criteria &lt;Object, SequenceableCollection, Block&gt;	"	^criteria xtreamsFilteringStreamOn: self</body></methods><methods><class-id>Xtreams.ReadStream</class-id> <category>sioux</category><body package="SiouX-Http-Extensions">siouxComputeContentLengthFor: response	^nil</body><body package="SiouX-Http-Extensions">siouxSetContentsOn: responsePart	responsePart setStreamContents: self</body><body package="SiouX-Http-Extensions">siouxWriteBodyFor: entity on: stream	entity writeBodyStream: self on: stream</body></methods><methods><class-id>Core.ByteSymbol</class-id> <category>private</category><body package="SiouX-Http-Extensions">siouxComputeContentLengthFor: response	(self size &gt; MaxUnchunkedNarrowString) ifTrue: [ ^nil ].	(response charset = LATIN1) ifFalse: [ ^super siouxComputeContentLengthFor: response ].	^self size</body><body package="SiouX-Http-Extensions">siouxSetContentsOn: responsePart	responsePart setStringContents: self charset: LATIN1</body><body package="SiouX-Http-Extensions">siouxWriteHeaderParameter: name for: entity on: aStream	entity writeHeaderParameter: name latinString: self on: aStream</body></methods><methods><class-id>Core.ISO8859L1String</class-id> <category>private</category><body package="SiouX-Http-Extensions">siouxSetContentsOn: responsePart	responsePart setStringContents: self charset: LATIN1</body><body package="SiouX-Http-Extensions">siouxWriteHeaderParameter: name for: entity on: aStream	entity writeHeaderParameter: name latinString: self on: aStream</body></methods><methods><class-id>Protocols.ProtocolVersion</class-id> <category>upgrade</category><body package="SiouX-Http">upgrade: aRequestContext"The Upgrade header field only applies to the immediate connection. Therefore, the upgrade keyword MUST be supplied within a Connection header field (section 14.10) whenever Upgrade is present in an HTTP/1.1 message.http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.42"	aRequestContext request isVersion11		ifFalse: [(SiouX.HttpResponse code: 400)					contents: #CanUpgrade11Requests &lt;&lt; #www &gt;&gt; 'Can upgrade only requests with HTTP/1.1 version';					signalReady].				(aRequestContext request connection includes: 'upgrade') 		ifFalse: [ ^(aRequestContext response code: 400)					contents: (#UpgradeKeywordMustBeSupplied &lt;&lt; #www &gt;&gt; 'The upgrade keyword MUST be supplied within a Connection header field ');					signalReady ].	(self validateHostOriginBlock		value: aRequestContext request host		value: aRequestContext request origin		value: aRequestContext) ifFalse: [ ^self invalidHostOriginError: aRequestContext ].	self upgradeRequest: aRequestContext.</body><body package="SiouX-Http">upgradeConnection: aRequestContext	| newVersion |	newVersion := self class new.	newVersion settings: self settings copy.	newVersion connection: aRequestContext connection.	newVersion upgrade: aRequestContext.	^newVersion</body></methods><initialize><class-id>SiouX.HttpResponsePart</class-id></initialize><initialize><class-id>SiouX.HttpResponse</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>ByteEncodedString</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars>encoder </class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>ByteString</name><environment>Core</environment><super>Core.ByteEncodedString</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Responder</name><environment>SiouX</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>server exceptionPrinter path requestFilters url decodedPath </inst-vars><class-inst-vars>exceptionPrinter </class-inst-vars><imports>			private OS.*			</imports><category></category><attributes><package>SiouX-Server</package></attributes></class><class><name>ByteSymbol</name><environment>Core</environment><super>Core.Symbol</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>PositionWriteSubstream</name><environment>Xtreams</environment><super>Xtreams.WriteSubstream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Substreams</package></attributes></class><class><name>ISO8859L1String</name><environment>Core</environment><super>Core.ByteEncodedString</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>ReadStream</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars>source </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.BehaviorIcons			</imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>ProtocolVersion</name><environment>Protocols</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection validateHostOriginBlock writeResponseBlock settings </inst-vars><class-inst-vars>validateHostOriginBlock </class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>UserMessage</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultString key catalogID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Internationalization</category><attributes><package>UIBasics-Internationalization</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>MSCP1252String</name><environment>Core</environment><super>Core.ByteEncodedString</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>RequestFilter</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>configuration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Server</package></attributes></class><class><name>RequestContext</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>responder connection request response data properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Server</package></attributes></class></st-source>