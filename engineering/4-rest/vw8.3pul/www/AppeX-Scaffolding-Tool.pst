<?xml version="1.0"?><st-source><!-- Name: AppeX-Scaffolding-ToolNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: The package helps to create a web application from existing database tables.	How to use the tool.There are two ways to build a web aplication from an existing database. 	- using WebAppBuilder. See the WebAppBuilder class comments	- using the Create Web Application tool.Let's create a new web application from the Genealogy example using the Create Web Application tool. Load parcels:	AppeX-Examples-Scaffolding (see the package comments about sqlite.dll installation)	SiouX-Tools.If your image directory doesn't have Genealogy.sqlite database execute: AppeX.GenealogyApplication initializeDatabaseRecordsNow we have working SQLite database Genealogy.sqlite with some test records.	Creating a new application.If you create your application from a database you need first to create domain classes from a database and a descriptor system. The tool provides two options:- create domain classes from database tables and a Glorp descriptor system and then create a web application- create a web application from an existing Glorp descriptor system.Open Tools->Create Web Application dialog. Follow the following steps:1. On Specify DB connection page do:	Interface: SQLite3Connection	Enviroment: Genealogy.sqlite  <-  for SQLite database provide a filename 	Click Next2. Application Settings page provides two options: 	a. Creating descriptor system: (creates the Glorp descriptor and domain classes from DB tables)	b. Use existing descriptor system: (The Glorp ActiveRecord descriptor system and domain classes have been already created)	2a. Creating descriptor system and domain classes:		Application name: TestApp		Package: TestApp 				Namespace: TestApp		Click Next		2b. Using an existing AppeX.GenealogySchema do the following:		Application name: TestApp		Descriptor System: AppeX.GenealogySchema		Package: TestApp 				Namespace: TestApp		Click Next	3. On Responder and Client Classes Settings page do:	Change the default settings if you want to	Click Next3a. If the option Creating descriptor system was chosen the next page is Choose which tables are mapped to classes:	Select tables you would like to create Smalltalk classes from	Click Next4. On Responder Services page do:	Change defaults if you want to	The Main path will be used by a client side to send the first request	Click Create Classes button5. On Test Application page click on Test application button 	How the tool works.1. Connects to a specified database and creates a Glorp session2. Creates a package and namespace for Web application responder and client classes3. Sets the client class name, the first request path, the base url and port. The first request path is mapped to a database table. In our case we used #personage path which returns Personage table records.4. Sets the web application services. By default for each table listed in GenealogySchema descriptor system the tool provides four services:	GET - retrieves all table records and displays them using a list view	POST - updates a database record	PUT - adds a new database record	DELETE - deletes a database recordThe tools creates mapping between table names and path to access the table records.The Create Classes button creates in TestApp package two classes:	TestAppApplication - the server responder class with the services on the instance side and configuration on the class side.	TestAppClient - Javascript code 5. Testing the application uses localhost:6767/testapp#list/personage URL to open a default web browser.The tool uses AppeX-Scaffolding framework to retrieve the database records and create web pages.For more information about Active Record support read WebAppDevGuide.pdf chapter Active Record.DbIdentifier: bear73DbTrace: 495950DbUsername: vdegenDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'SiouX-Tools' '') #(#any 'ExternalWebBrowser' '') #(#any 'AppeX-Scaffolding' '') #(#any 'GlorpActiveRecord' '') #(#any 'GlorpAtlasUI' '') #(#any 'Tools-NavigationPages' ''))PackageName: AppeX-Scaffolding-ToolParcel: #('AppeX-Scaffolding-Tool')PrerequisiteDescriptions: #(#(#name 'SiouX-Tools' #componentType #package) #(#name 'ExternalWebBrowser' #componentType #package) #(#name 'AppeX-Scaffolding' #componentType #package) #(#name 'GlorpActiveRecord' #componentType #package) #(#name 'GlorpAtlasUI' #componentType #package) #(#name 'Tools-NavigationPages' #componentType #package))PrerequisiteParcels: #(#('SiouX-Tools' '') #('ExternalWebBrowser' '') #('AppeX-Scaffolding' '') #('GlorpActiveRecord' '') #('GlorpAtlasUI' '') #('Tools-NavigationPages' ''))PrintStringCache: (8.3 - 1,vdegen)Version: 8.3 - 1Date: 3:30:54 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:30:54 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WebAppWizard</name><environment>AppeX</environment><super>Tools.PageSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Scaffolding-Tool</package></attributes></class><comment><class-id>AppeX.WebAppWizard</class-id><body>The class provides pages to build a web application from Glorp active record descriptor</body></comment><class><name>AppeXSubcanvas</name><environment>AppeX</environment><super>Tools.SequenceableSubcanvas</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Scaffolding-Tool</package></attributes></class><comment><class-id>AppeX.AppeXSubcanvas</class-id><body>The class is superclass for all Scaffolding tool pages</body></comment><class><name>TestApplicationUI</name><environment>AppeX</environment><super>AppeX.AppeXSubcanvas</super><private>false</private><indexed-type>none</indexed-type><inst-vars>headerAspect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Scaffolding-Tool</package></attributes></class><comment><class-id>AppeX.TestApplicationUI</class-id><body>The last page allows to open a default web browser to test an applicationInstance Variables:	headerAspect	&lt;ValueHolder&gt;	 headerAspect</body></comment><class><name>ClientResponderUI</name><environment>AppeX</environment><super>AppeX.AppeXSubcanvas</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serverIdAspect clientNameAspect appResponderNameAspect baseUrlAspect portAspect serverIDs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Scaffolding-Tool</package></attributes></class><comment><class-id>AppeX.ClientResponderUI</class-id><body>The page sets the server and client classes options.Instance Variables:	appResponderNameAspect	&lt;ValueModel&gt;	 responder name	baseUrlAspect	&lt;ValueModel&gt;	 defines baseUrl for the application	clientNameAspect	&lt;ValueModel&gt;	client class name	portAspect	&lt;ValueModel&gt;	 port	serverIdAspect	&lt;ValueModel&gt; server Id	serverIDs	&lt;ValueHolder&gt;	  serverIDs</body></comment><class><name>ClassPathMap</name><environment>AppeX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>activeRecordClass path selected useDELETE usePOST usePUT useGET name namespace pathChangedBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Scaffolding-Tool</package></attributes></class><comment><class-id>AppeX.ClassPathMap</class-id><body>The class selects tables and services to create a web applicationInstance Variables:	activeRecordClass	&lt;Class&gt;	subclass of ActiveRecord	path		&lt;String&gt;	 path is used in HTTP request	selected	&lt;Boolean&gt;	if true services for this class will be created	useDELETE	&lt;Boolean&gt;	useDELETE option defines if DELETE active record service method is created	useGET	&lt;Boolean&gt;	useGET option defines if GET active record service method is created	usePOST	&lt;Boolean&gt;	usePOST option defines if POST active record service method is created	usePUT	&lt;Boolean&gt;	usePUT option defines if PUT active record service method is created	name &lt;String&gt; a name of ActiveRecord subclass. The subclass has not been created	namespace &lt;String&gt; a namespace where the active record sublcass will be created	pathChangedBlock &lt;BlockClosure&gt; a callback on path change</body></comment><class><name>DescriptorSystemUI</name><environment>AppeX</environment><super>AppeX.AppeXSubcanvas</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classDefinition applicationNameAspect descriptorSystemAspect activeRecordDescriptorSystems descriptorTypeAspect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Scaffolding-Tool</package></attributes></class><comment><class-id>AppeX.DescriptorSystemUI</class-id><body>The page allows setting the application name, package and namespaceInstance Variables:	activeRecordDescriptorSystems	&lt;ValueHolder&gt;	  activeRecordDescriptorSystems	applicationNameAspect	&lt;ValueModel&gt; applicationNameAspect	classDefinition	&lt;DefinitionCreationDialog&gt;	 classDefinition	descriptorSystemAspect	&lt;ValueModel&gt;	 descriptorSystemAspect	descriptorTypeAspect &lt;ValueModel&gt; radio buttons that allow selecting "Create new descriptor system" or "Use existing descriptor system" options</body></comment><class><name>WebAppBuilder</name><environment>AppeX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>login descriptorSystem classPathMap baseUrl package namespaceName namespace clientClass applicationName applicationClass clientMainPath port serverId clientName applicationClassName mappingModel createNewDescriptor </inst-vars><class-inst-vars>defaultPort applicationName applicationPackage applicationNamespace methodComment </class-inst-vars><imports>			Glorp.*			SiouX.*			</imports><category></category><attributes><package>AppeX-Scaffolding-Tool</package></attributes></class><comment><class-id>AppeX.WebAppBuilder</class-id><body>The class creates a web application classes from existing ActiveRecordSystemDescriptor. There are two classes created: a subclass of Application and subclass of ApplicationClient.Instance Variables:	applicationName	&lt;String&gt;	the application name is used a default string to create a package, namespace, server application and client classes	applicationClassName	&lt;String&gt; application responder class name	applicationClass	&lt;Class&gt;	an application responder class	baseUrl	&lt;String&gt;	the string is used to create a server path. By default is used #applicationName	classPathMap	&lt;OrderedCollection of Class&gt;	 the classes that are described by ActiveRecordSystemDescriptor. By default the collection is set to #allClassModels	clientClass	&lt;Class&gt;	a client class	clientMainPath	&lt;String&gt;	a client main path to open the wenb application. By default the main path is the first class name from #classModels	descriptorSystem	&lt;ActiveRecordDescriptorSystem&gt;	descriptor system	glorpSession	&lt;GlorpSession&gt;	glorp session	login	&lt;Glorp.Login&gt;	 login	namespace	&lt;NameSpace&gt;	 namespace	namespaceName	&lt;String&gt;	string to create a namespace. By default it is the application name	package	&lt;String&gt;	 package name. By default it is the application name	port	&lt;SmallInteger&gt; the server port	serverId		&lt;String&gt;  new or existing server id to add the responder	clientName	&lt;String&gt;	mappingModel &lt;Glorp.MappingModel&gt; is used to created a new descriptor system	createNewDescriptor &lt;Boolean&gt; if true the tool creates a new descriptor systemClass Instance Variables: 	applicationName	&lt;String&gt; the default application name	defaultPort 	&lt;Number&gt; the default port number	applicationPackage &lt;String&gt; default package	applicationNamespace &lt;String&gt; default namespaceUsage:To test the code load AppeX-Examples-Scaffolding parcel.If your image directory doesn't have Genealogy.sqlite database execute: GenealogyApplication initializeDatabaseRecordsNow we have working SQLite database Genealogy.sqlite with some test records.1. Creating a Web Application from an existing Glorp descriptor system:	builder := AppeX.WebAppBuilder new.					builder		activeRecordSystemLogin:  (Glorp.Login new										database: Glorp.SQLite3Platform new;										username: 'example';										password: String new;										connectString: 'driverTest.sqlite';										yourself);		initializeDescriptorSystem: AppeX.DriverSchema;		initializeApplicationNamed: 'Test1';		firstRequestPath: 'driver';		port: 6767;		clientMainPath;		testApplication.2. Creating a Web Application from database tables:	builder := AppeX.WebAppBuilder new.					builder		activeRecordSystemLogin:  (Glorp.Login new										database: Glorp.SQLite3Platform new;										username: 'example';										password: String new;										connectString: 'driverTest.sqlite';										yourself);		createNewDescriptor: true;		initializeApplicationNamed: 'Test2';		selectAllTables;    "or use #selectTables: #('driver' 'vehicle');"		clientMainPath: 'driver';		port: 6768;		createApplication;		testApplication.</body></comment><class><name>ResponderServicesUI</name><environment>AppeX</environment><super>AppeX.AppeXSubcanvas</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classPathMapAspect selectedRow clientMainPathAspect pathList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Scaffolding-Tool</package></attributes></class><comment><class-id>AppeX.ResponderServicesUI</class-id><body>The page allows specifying an active record servicesInstance Variables:	classPathMapAspect	&lt;SelectionInList&gt;	classPathMapAspect	selectedRow	&lt;ValueModel&gt;	 selectedRow	clientMainPathAspect	&lt;ValueModel&gt;	 the path for the first request. 	pathList &lt;ValueModel&gt; list of strings that will be used as URL path to a specified domain classes </body></comment><methods><class-id>AppeX.WebAppWizard</class-id> <category>accessing</category><body package="AppeX-Scaffolding-Tool">defaultModelClass	^WebAppBuilder</body></methods><methods><class-id>AppeX.WebAppWizard</class-id> <category>initialize-release</category><body package="AppeX-Scaffolding-Tool">initializePages	pages := Array new: 6.	pages		at: 1 put: Glorp.LoginSubcanvas;		at: 2 put: DescriptorSystemUI;		at: 3 put: ClientResponderUI;		at: 4 put: Glorp.MapTablesToClasses;		at: 5 put: ResponderServicesUI;		at: 6 put: TestApplicationUI.	^pages</body></methods><methods><class-id>AppeX.WebAppWizard</class-id> <category>actions</category><body package="AppeX-Scaffolding-Tool">back	(self widgetAt: #next)  isEnabled: true.	((pages at: pageIndex - 1) = Glorp.MapTablesToClasses		and: [self model useExistingDescriptor])		ifTrue: [pageIndex := pageIndex - 2]		ifFalse: [	pageIndex := pageIndex - 1 ].	pageIndex = 1 ifTrue: [(self widgetAt: #back)  isVisible: false].	self openSubcanvas.	pageIndex ~= pages size		ifTrue: 			[(self widgetAt: #next)  labelString: 'Next &gt;'.			 (self widgetAt: #cancel)  isVisible: true].</body><body package="AppeX-Scaffolding-Tool">next	client notNil ifTrue:		[client closeRequestFromParent ifFalse: [^nil]].	pageIndex = pages size ifTrue: [^self finish].		pageIndex &gt; 0 ifTrue:		[(self widgetAt: #back) isVisible: true].	((pages at: pageIndex + 1) = Glorp.MapTablesToClasses		and: [self model useExistingDescriptor])		ifTrue: [pageIndex := pageIndex + 2]		ifFalse: [	pageIndex := pageIndex + 1 ].	self openSubcanvas.	pageIndex = pages size ifTrue:		[(self widgetAt: #next)  labelString: self finishButtonLabel.		(self widgetAt: #cancel)  isVisible: false].</body></methods><methods><class-id>AppeX.WebAppWizard class</class-id> <category>accessing</category><body package="AppeX-Scaffolding-Tool">wizardHeader	^'Creating Web Application from Tables'</body></methods><methods><class-id>AppeX.AppeXSubcanvas class</class-id> <category>class initialization</category><body package="AppeX-Scaffolding-Tool">initialize	ApplicationModel 		visualAt: #www		put: ( SiouX.ServerIcons Browser_16x16 )</body></methods><methods><class-id>AppeX.AppeXSubcanvas class</class-id> <category>accessing</category><body package="AppeX-Scaffolding-Tool">messageCatalogID	^#www</body></methods><methods><class-id>AppeX.TestApplicationUI</class-id> <category>aspects</category><body package="AppeX-Scaffolding-Tool">headerAspect	^headerAspect</body></methods><methods><class-id>AppeX.TestApplicationUI</class-id> <category>initialize-release</category><body package="AppeX-Scaffolding-Tool">initializeAspects	headerAspect := 'Congratulations! You created a Web Application from existing database tables.If you click on Test application button the server will be created, started and the application will be opened in your default Web Browser.' asValue</body></methods><methods><class-id>AppeX.TestApplicationUI</class-id> <category>actions</category><body package="AppeX-Scaffolding-Tool">testApplication	^self model testApplication</body></methods><methods><class-id>AppeX.TestApplicationUI class</class-id> <category>accessing</category><body package="AppeX-Scaffolding-Tool">header	^#TestApplication &lt;&lt; #www &gt;&gt; 'Test Application'</body><body package="AppeX-Scaffolding-Tool">helpText	^#TestApplicationHelp &lt;&lt; #www &gt;&gt; 'The page allows testing the application. Test Application - The button starts a server and opens a default Web Browser on a new responder'</body></methods><methods><class-id>AppeX.ClientResponderUI</class-id> <category>aspects</category><body package="AppeX-Scaffolding-Tool">appResponderNameAspect	^appResponderNameAspect</body><body package="AppeX-Scaffolding-Tool">baseUrlAspect	^baseUrlAspect</body><body package="AppeX-Scaffolding-Tool">clientNameAspect	^clientNameAspect</body><body package="AppeX-Scaffolding-Tool">portAspect	^portAspect</body><body package="AppeX-Scaffolding-Tool">serverIdAspect	^serverIdAspect</body></methods><methods><class-id>AppeX.ClientResponderUI</class-id> <category>accessing</category><body package="AppeX-Scaffolding-Tool">serverIDs	^serverIDs</body></methods><methods><class-id>AppeX.ClientResponderUI</class-id> <category>actions</category><body package="AppeX-Scaffolding-Tool">changedServerId	self portAspect value: ((SiouX.Server.Registry at: self serverIdAspect value ifAbsent: [nil])							ifNotNil: [ :server | server listeners first port ]							ifNil: [self model port ])</body><body package="AppeX-Scaffolding-Tool">closeRequestFromParent		self model		baseUrl: self baseUrlAspect value;		serverId: self serverIdAspect value;		port: self portAspect value;		clientName: self clientNameAspect value;		applicationClassName: self appResponderNameAspect value.		^true</body></methods><methods><class-id>AppeX.ClientResponderUI</class-id> <category>initialize-release</category><body package="AppeX-Scaffolding-Tool">initializeAspects	appResponderNameAspect := self model applicationClassName asValue.	clientNameAspect := self model clientName asValue.	portAspect := self model port asValue.		serverIdAspect := self model serverId asValue.	serverIdAspect onChangeSend: #changedServerId to: self.		baseUrlAspect := self model baseUrl asValue.	serverIDs := SiouX.Server.Registry keys asValue.</body></methods><methods><class-id>AppeX.ClientResponderUI class</class-id> <category>accessing</category><body package="AppeX-Scaffolding-Tool">header	^#ResponderClientClassesSettings &lt;&lt; #www &gt;&gt; 'Responder and Client Classes Settings'</body><body package="AppeX-Scaffolding-Tool">helpText	^#ClientResponderUIHelp &lt;&lt; #www &gt;&gt; 'Provide Settings for Responder and Client classes.Client Name - The name to create ApplicationClient sublclass.Responder name - The name to create an Application subclass.Base URL - The path is used as a base URL to all requestsServer id - The name of the existing SiouX.Server or a new onePort - The port to start the server'</body></methods><methods><class-id>AppeX.ClassPathMap</class-id> <category>accessing</category><body package="AppeX-Scaffolding-Tool">activeRecordClass	^activeRecordClass 		ifNil:[(namespace, '.', name ) asSymbol asQualifiedReference valueOrDo: [self error: 'The classes from tables were not created']]</body><body package="AppeX-Scaffolding-Tool">activeRecordClass: aClassOrString	name := aClassOrString isString 		ifTrue: [aClassOrString]		ifFalse: [activeRecordClass := aClassOrString.				aClassOrString name]</body><body package="AppeX-Scaffolding-Tool">activeRecordClassName	^name</body><body package="AppeX-Scaffolding-Tool">namespace: aString	namespace := aString</body><body package="AppeX-Scaffolding-Tool">path	^path ifNil: [ path := self activeRecordClassName asLowercase]</body><body package="AppeX-Scaffolding-Tool">path: aString	| old |	path = aString ifTrue: [^nil].	old := path.	path := aString.	pathChangedBlock ifNotNil: [pathChangedBlock value: old value: path].</body><body package="AppeX-Scaffolding-Tool">pathChangedBlock: aBlock	pathChangedBlock := aBlock</body><body package="AppeX-Scaffolding-Tool">selected	^selected ifNil: [ selected := true]</body><body package="AppeX-Scaffolding-Tool">selected: aBoolean	selected := aBoolean</body><body package="AppeX-Scaffolding-Tool">services	| coll |	coll := OrderedCollection new.	self useGET ifTrue: [ coll add: 'GET'].	self usePOST ifTrue: [ coll add: 'POST'].	self usePUT ifTrue: [ coll add: 'PUT'].	self useDELETE ifTrue: [ coll add: 'DELETE'].	^coll</body><body package="AppeX-Scaffolding-Tool">useDELETE	^useDELETE ifNil: [ useDELETE := true ]</body><body package="AppeX-Scaffolding-Tool">useDELETE: aBoolean	useDELETE := aBoolean</body><body package="AppeX-Scaffolding-Tool">useGET	^useGET  ifNil: [ useGET := true ]</body><body package="AppeX-Scaffolding-Tool">useGET: aBoolean	useGET := aBoolean</body><body package="AppeX-Scaffolding-Tool">usePOST	^usePOST  ifNil: [ usePOST := true ]</body><body package="AppeX-Scaffolding-Tool">usePOST: aBoolean	usePOST := aBoolean</body><body package="AppeX-Scaffolding-Tool">usePUT	^usePUT  ifNil: [ usePUT := true ]</body><body package="AppeX-Scaffolding-Tool">usePUT: aBoolean	usePUT := aBoolean</body></methods><methods><class-id>AppeX.ClassPathMap class</class-id> <category>instance creation</category><body package="AppeX-Scaffolding-Tool">activeRecordClass: anActiveRecord	^self new		activeRecordClass: anActiveRecord;		yourself</body></methods><methods><class-id>AppeX.DescriptorSystemUI</class-id> <category>aspects</category><body package="AppeX-Scaffolding-Tool">activeRecordDescriptorSystems	^activeRecordDescriptorSystems</body><body package="AppeX-Scaffolding-Tool">applicationNameAspect	^applicationNameAspect</body><body package="AppeX-Scaffolding-Tool">descriptorSystemAspect	^descriptorSystemAspect</body><body package="AppeX-Scaffolding-Tool">descriptorTypeAspect	^descriptorTypeAspect</body></methods><methods><class-id>AppeX.DescriptorSystemUI</class-id> <category>actions</category><body package="AppeX-Scaffolding-Tool">applicationNameChanged	self applicationNameAspect value notEmpty ifTrue: [		self model initializeApplicationNamed: self applicationNameAspect value.		self classDefinition packageModule value: self model package.		self classDefinition namespaceModule value: self model namespaceName.				self enableNext.]</body><body package="AppeX-Scaffolding-Tool">applicationNameEntryEvent	self applicationNameAspect value notEmpty ifTrue: [		self enableNext.]</body><body package="AppeX-Scaffolding-Tool">changedNamespaceName	self classDefinition namespaceModule value notEmpty ifTrue: [		self model namespaceName: self classDefinition namespaceModule value ]</body><body package="AppeX-Scaffolding-Tool">changedPackage	self classDefinition packageModule value notEmpty ifTrue: [ 		self model package: self classDefinition packageModule value].</body><body package="AppeX-Scaffolding-Tool">closeRequestFromParent		self enableNext ifFalse: [^false].			self model initializeApplicationNamed: self applicationNameAspect value.		self useExistingDescriptorSelected ifTrue: [		self model initializeDescriptorSystem: self descriptorSystemAspect value asQualifiedReference value].		self model createNewDescriptor: self createNewDescriptorSelected.		^true</body><body package="AppeX-Scaffolding-Tool">createNewDescriptorSelected	^self descriptorTypeAspect value = #newDescriptor</body><body package="AppeX-Scaffolding-Tool">descriptorTypeChanged	(self widgetAt: #existingDescriptorList ) isEnabled: self useExistingDescriptorSelected</body><body package="AppeX-Scaffolding-Tool">enableNext	^( self applicationNameAspect value notEmpty 		and: [self createNewDescriptorSelected				or: [self useExistingDescriptorSelected and: [ self descriptorSystemAspect value notEmpty]]])		ifTrue: [self parent enableNext.			true]		ifFalse: [ self parent disableNext.			false]</body><body package="AppeX-Scaffolding-Tool">useExistingDescriptorSelected	^self descriptorTypeAspect value = #existingDescriptor</body></methods><methods><class-id>AppeX.DescriptorSystemUI</class-id> <category>accessing</category><body package="AppeX-Scaffolding-Tool">classDefinition	^classDefinition isNil		ifTrue: [classDefinition := Tools.DefinitionCreationDialog new]		ifFalse: [classDefinition]</body></methods><methods><class-id>AppeX.DescriptorSystemUI</class-id> <category>interface opening</category><body package="AppeX-Scaffolding-Tool">postBuildWith: aBuilder 	self enableNext.	self descriptorTypeChanged.</body></methods><methods><class-id>AppeX.DescriptorSystemUI</class-id> <category>initialize-release</category><body package="AppeX-Scaffolding-Tool">initializeAspects	self classDefinition packageModule value: self model package.	self classDefinition namespaceModule value: self model namespaceName.	self classDefinition packageModule entryHolder onChangeSend: #changedPackage to: self.	self classDefinition namespaceModule entryHolder onChangeSend: #changedNamespaceName to: self.		descriptorTypeAspect := #newDescriptor asValue.	descriptorTypeAspect onChangeSend: #descriptorTypeChanged to: self.		applicationNameAspect := self model applicationName asValue.	applicationNameAspect onChangeSend: #applicationNameChanged to: self.		descriptorSystemAspect := (self model descriptorSystem 		ifNil: [String new]		ifNotNil: [ :descr | descr class fullName]) asValue.	descriptorSystemAspect onChangeSend: #enableNext to: self.	activeRecordDescriptorSystems := (Glorp.ActiveRecords.ActiveRecordDescriptorSystem subclasses collect: [ :cl | cl fullName]) asValue</body></methods><methods><class-id>AppeX.DescriptorSystemUI class</class-id> <category>accessing</category><body package="AppeX-Scaffolding-Tool">header	^#DescriptorSystemUI &lt;&lt; #www &gt;&gt; 'Application Settings'</body><body package="AppeX-Scaffolding-Tool">helpText	^#DescriptorSystemUIHelp &lt;&lt; #www &gt;&gt; 'The page provides options to create a Web Application from existing database tables. The tool requires to have a Glorp  descriptor system which is the domain model of your application. For more information see GlorpGuide.pdf  chapter: Creating a Descriptor System. Application Name - The name that is used for web application HTML title. Also by default this string is used to create the application client and responder class names.Create descriptor system - If there is no a descriptor system use this option to create a subclass of ActiveRecordDescriptorSystem. The behavior of the descriptor system will model the classes in the domain model,and specify the database tables to which they should be mapped.Use exising descriptor system - Use this option is there is already a subclass of ActiveRecordDescriptorSystem. Select the class from the list.Package - The package in which the descripttor system, domain classes, client and responder classes are placed. If the package name does not exist in the system, it will be created. Namespace - The name space in which new classes that are placed. '</body></methods><methods><class-id>AppeX.WebAppBuilder</class-id> <category>accessing</category><body package="AppeX-Scaffolding-Tool">applicationClass	^applicationClass</body><body package="AppeX-Scaffolding-Tool">applicationClass: aClass	applicationClass := aClass</body><body package="AppeX-Scaffolding-Tool">applicationClassName	^applicationClassName</body><body package="AppeX-Scaffolding-Tool">applicationClassName: aString	applicationClassName :=aString</body><body package="AppeX-Scaffolding-Tool">applicationName	^applicationName ifNil: [ applicationName := self class applicationName]</body><body package="AppeX-Scaffolding-Tool">applicationName: aString	applicationName := aString</body><body package="AppeX-Scaffolding-Tool">baseUrl	^baseUrl</body><body package="AppeX-Scaffolding-Tool">baseUrl: aString	baseUrl := aString</body><body package="AppeX-Scaffolding-Tool">classPathMap	^classPathMap ifNil: [		descriptorSystem ifNotNil: [			classPathMap := descriptorSystem allClassModels collect: [ :model | 				ClassPathMap activeRecordClass: model describedClass ]]]</body><body package="AppeX-Scaffolding-Tool">classPathMap: aClassPathMap	classPathMap := aClassPathMap</body><body package="AppeX-Scaffolding-Tool">clientClass	^clientClass</body><body package="AppeX-Scaffolding-Tool">clientMainPath	^clientMainPath ifNil: [ clientMainPath := self classPathMap first path  ]</body><body package="AppeX-Scaffolding-Tool">clientMainPath: aString	clientMainPath := aString</body><body package="AppeX-Scaffolding-Tool">clientName	^clientName</body><body package="AppeX-Scaffolding-Tool">clientName: aString	clientName :=aString</body><body package="AppeX-Scaffolding-Tool">createNewDescriptor: aBoolean	createNewDescriptor := aBoolean</body><body package="AppeX-Scaffolding-Tool">descriptorSystem	^descriptorSystem</body><body package="AppeX-Scaffolding-Tool">descriptorSystem: anObject	descriptorSystem := anObject</body><body package="AppeX-Scaffolding-Tool">glorpLogin	^login</body><body package="AppeX-Scaffolding-Tool">methodComment	^self class methodComment</body><body package="AppeX-Scaffolding-Tool">namespace	^namespace</body><body package="AppeX-Scaffolding-Tool">namespace: aNamespace	namespace := aNamespace</body><body package="AppeX-Scaffolding-Tool">namespaceName	^namespaceName ifNil: [ namespaceName := self class applicationNamespace]</body><body package="AppeX-Scaffolding-Tool">namespaceName: aString	namespaceName := aString</body><body package="AppeX-Scaffolding-Tool">package	^package ifNil: [ package := self class applicationPackage ]</body><body package="AppeX-Scaffolding-Tool">package: aString	package := aString</body><body package="AppeX-Scaffolding-Tool">port		^port ifNil: [ port := self class defaultPort].</body><body package="AppeX-Scaffolding-Tool">port: aNumber 		port := aNumber</body><body package="AppeX-Scaffolding-Tool">serverId	^serverId</body><body package="AppeX-Scaffolding-Tool">serverId: aString	serverId := aString</body><body package="AppeX-Scaffolding-Tool">serverPragmasDo: aBlock	(Pragma allNamed: #server: in: self class) do: [ :pragma | aBlock value: pragma ]</body><body package="AppeX-Scaffolding-Tool">system	^nil</body><body package="AppeX-Scaffolding-Tool">useExistingDescriptor	^createNewDescriptor not</body></methods><methods><class-id>AppeX.WebAppBuilder</class-id> <category>private</category><body package="AppeX-Scaffolding-Tool">checkNamespace: aNamespace	^aNamespace isNameSpace 		ifTrue: [aNamespace]		ifFalse: 			[self error: ((#NameAlreadyExist &lt;&lt; #glorp &gt;&gt; '&lt;1s&gt; already exists and is not a NameSpace')						expandMacrosWith: aNamespace)]</body><body package="AppeX-Scaffolding-Tool">createClassesInPackage: storePackage do: aBlock	| currentPackage pkg |	^[(storePackage notNil and: [ #{Store.Policies} isDefined ])		ifTrue: 			[currentPackage := Store.Registry currentPackage. 			pkg := Store.Registry packageNamedOrCreate: storePackage.			Store.Registry currentPackage: pkg. ].	  	aBlock value	]		ensure: 				[currentPackage notNil ifTrue: [ Store.Registry currentPackage: currentPackage]]</body><body package="AppeX-Scaffolding-Tool">createInPackageDo: aBlock	SystemUtils modifySystem: 	[		self 			createClassesInPackage: self package 			do: [ aBlock value ]]</body><body package="AppeX-Scaffolding-Tool">createNamespace: nameSpaceName	| nameSpace reference |	nameSpace := Smalltalk.	(GeneralBindingReference parseString: nameSpaceName) do: 			[:token | 			reference := token asQualifiedReference.			nameSpace := reference 						ifDefinedDo: [:value | self checkNamespace: value] 						elseDo: 							[nameSpace 								defineNameSpace: token								private: false								imports: ''								category: '']].	^nameSpace</body><body package="AppeX-Scaffolding-Tool">tablesToClassesMap	| coll |	coll :=  OrderedCollection new.	self mappingModel readDatabaseTables.	self databaseTables do: [ :tb | coll add: (tb -&gt; ( Inflector new classify: tb name))].	^coll</body></methods><methods><class-id>AppeX.WebAppBuilder</class-id> <category>create classes</category><body package="AppeX-Scaffolding-Tool">createApplication	self 		generateClassesFromTables;		createClient;		createClientMethods;		createResponder;		createResponderMethods.	self applicationClass resetActiveRecordData.		self class applicationName: self applicationName.	self class applicationPackage: self package.	self class applicationNamespace: self namespaceName</body><body package="AppeX-Scaffolding-Tool">createClient	self createInPackageDo:  		[namespace ifNil: [namespace := self createNamespace: self namespaceName].		clientClass := namespace defineClass: self clientName asSymbol								superclass: #{ApplicationClient}								indexedType: #none								private: false								instanceVariableNames: #() 								classInstanceVariableNames: #() 								imports: ''								category: ''. ]</body><body package="AppeX-Scaffolding-Tool">createClientMethods	| stream |	clientClass ifNil: [^nil].	self createInPackageDo: [		(Pragma allNamed: #client: in: self class) do: [ :pragma |			stream := String new writing.			stream write: (self perform: pragma selector).				clientClass 			compile: stream contents 			classified: (pragma argumentAt: 1) ]]</body><body package="AppeX-Scaffolding-Tool">createResponder	self createInPackageDo: [		namespace ifNil: [namespace := self createNamespace: self namespaceName].		applicationClass := namespace defineClass: self applicationClassName asSymbol								superclass: #{Application}								indexedType: #none								private: false								instanceVariableNames: #() 								classInstanceVariableNames: #() 								imports: 'Glorp.*'								category: ''  ]</body><body package="AppeX-Scaffolding-Tool">createResponderMethods	"Create responder methods"	self createInPackageDo: [		self 			createApplicationClassMethods;			createApplicationServices;			createServerExtension. ]</body></methods><methods><class-id>AppeX.WebAppBuilder</class-id> <category>initialize-release</category><body package="AppeX-Scaffolding-Tool">activeRecordSystemLogin: aGlorpLogin	login := aGlorpLogin.	self mappingModel activeRecordSystemLogin: login.	createNewDescriptor := true.</body><body package="AppeX-Scaffolding-Tool">initializeApplicationNamed: aString	| clName |	applicationName := aString.	baseUrl ifNil: [baseUrl := '/', self applicationName asLowercase].	serverId ifNil: [serverId := self applicationName].	clName := SystemUtils				validateClassName: aString				confirm: [ :msg :nm | true ] 				warn: [ :msg | ].	(namespaceName isNil or: [ namespaceName = 'Smalltalk' ]) ifTrue: [namespaceName := clName].	package ifNil: [package := clName].	applicationClassName ifNil: [ applicationClassName :=  clName, 'Application'].	clientName ifNil: [clientName := clName, 'Client'].</body><body package="AppeX-Scaffolding-Tool">initializeDescriptorSystem: aClass	descriptorSystem := aClass forPlatform: login database.	classPathMap := descriptorSystem allClassModels collect: [ :model | 		ClassPathMap activeRecordClass: model describedClass ].	createNewDescriptor := false</body><body package="AppeX-Scaffolding-Tool">initializeFrom: aWebApplication" The aWebApplication is already created.  Initialize the builder to update the application	service methods and an active record descriptor system"	| pragmas |	self applicationClass: aWebApplication.	self activeRecordSystemLogin: aWebApplication newActiveRecordLogin.	self package: aWebApplication package name.	self namespace: aWebApplication environment.	createNewDescriptor := true.	(pragmas := Pragma allNamed: #server:path: in: aWebApplication class) notEmpty ifTrue: [		serverId := pragmas first argumentAt: 1].	self selectAllTables.</body><body package="AppeX-Scaffolding-Tool">updateApplication"	- generates new descriptor system	- adds new services methods (if a services exists it won't be changed)	- updates mappings active record to path map #newActiveRecordToPathMap"	| running server |	running := false.	(server := SiouX.Server.Registry at: self serverId ifAbsent: [nil])		ifNotNil: [running := server isRunning].	running ifTrue: [ server stop ].		[self		generateClassesFromTables;		createApplicationServices.	self serverPragmasDo: [ :pragma |		(pragma selector = #newActiveRecordToPathMap)			ifTrue: [ 	self createApplicationClassMethodFor: pragma]].			self applicationClass resetActiveRecordData.			] ensure: [ running ifTrue: [ server start.]]</body></methods><methods><class-id>AppeX.WebAppBuilder</class-id> <category>glorp mapping</category><body package="AppeX-Scaffolding-Tool">databaseTables	| tables |	tables := self mappingModel databaseTables.	^tables select: [ :table | table fields anySatisfy: [ :f | f name asUppercase = 'ID' ]]</body><body package="AppeX-Scaffolding-Tool">generateClassesFromTables	createNewDescriptor ifFalse: [^self].		[mappingModel 		mapTablesToClasses: self mappingModel tablesClasses		superclass: Glorp.ActiveRecords.ActiveRecord		namespace: self namespaceName		in: self package.	mappingModel generateClassesFromTables.	[self mappingModel createMappingsForActiveRecord]			on: Error			do: [:ex |				self mappingModel errorDialog: ex.				^false].		mappingModel 			generateDescriptorClass: self applicationName 			superclass: Glorp.ActiveRecords.ActiveRecordDescriptorSystem			namespace: self namespaceName.	descriptorSystem := self mappingModel descriptorClass new.	] ensure: [mappingModel system ifNotNil: [ :system | system session logout]]</body><body package="AppeX-Scaffolding-Tool">mappingModel	^mappingModel ifNil: [ mappingModel := MappingModel new]</body><body package="AppeX-Scaffolding-Tool">readDatabaseTablesLike: aString unlike: anotherString	self mappingModel readDatabaseTablesLike: aString unlike: anotherString.</body><body package="AppeX-Scaffolding-Tool">selectAllTables	self setSelectedTables: self tablesToClassesMap</body><body package="AppeX-Scaffolding-Tool">selectTables: tables	| coll |	coll :=  OrderedCollection new.	self tablesToClassesMap do: [ :assoc  | 		(tables anySatisfy: [ :tbx | tbx asUppercase = assoc key name ])			ifTrue: [ coll add: 	assoc ]].		self setSelectedTables: coll</body><body package="AppeX-Scaffolding-Tool">setSelectedTables: tablesToClassNames	self mappingModel setSelectedTables: tablesToClassNames.	classPathMap := tablesToClassNames collect: [ :assoc | (ClassPathMap activeRecordClass: assoc value) 														namespace: self namespaceName;														yourself]</body><body package="AppeX-Scaffolding-Tool">tableClasses	^self mappingModel tablesClasses</body><body package="AppeX-Scaffolding-Tool">tableNotSelectionCriteria	^self mappingModel tableNotSelectionCriteria</body><body package="AppeX-Scaffolding-Tool">tableSelectionCriteria	^self mappingModel tableSelectionCriteria</body></methods><methods><class-id>AppeX.WebAppBuilder</class-id> <category>server - methods</category><body package="AppeX-Scaffolding-Tool">createApplicationClassMethodFor: aPragma	"Create class methods"	|  stream |	stream := String new writing.	stream 		write: aPragma selector;		cr; tab;		write: (self perform: aPragma selector).		applicationClass class 		compile: stream contents 		classified: (aPragma argumentAt: 1)</body><body package="AppeX-Scaffolding-Tool">createApplicationClassMethods	"Create all class methods"	self serverPragmasDo: [ :pragma |		self createApplicationClassMethodFor: pragma].</body><body package="AppeX-Scaffolding-Tool">createApplicationServices			"Create instance methods"	self classPathMap do: [ :map | 		map selected ifTrue: [			self 				createMethodForClass: map activeRecordClass				path: map path				services: map services  ]].</body><body package="AppeX-Scaffolding-Tool">createMethodForClass: aClassModel path: pathString services: stringColl	| stream selector |	selector :=  'process', aClassModel name.	"If the method already exists do not update it!"	(applicationClass new respondsTo: selector asSymbol) ifTrue: [^nil].		stream := String new writing.	stream write: selector.	stream 		cr;tab;		write: '"', self methodComment, '"';		cr;tab.			stringColl do: [ :service |		stream			cr;tab;			write: '&lt;', service, '&gt;' ].			stream		cr;tab;		write: '&lt;activeRecord: ', pathString printString, ' class: #{', aClassModel fullName, '}&gt;';		cr;tab;		write: '"The default behavior for REST commands is implemented in #executeActiveRecordGET, #executeActiveRecordPOST, #executeActiveRecordPUT and  #executeActiveRecordDELETE blocks. To customize the implementation create methods for a specific HTTP command (for example &lt;DELETE&gt;) and implement the application specific block. As an example see GenealogyApplication class&gt;&gt;deleteLifeEvent "'.		applicationClass 		compile: stream contents		classified: 'services'</body><body package="AppeX-Scaffolding-Tool">createServerExtension	|  stream methodName |	"If there is already a server with this id don't create this extension"	(Server registry at: self serverId ifAbsent: [nil]) ifNotNil: [ ^nil ].		"Create Server extension for this server"	methodName := self applicationClassName first asLowercase asSymbol, (self applicationClassName copyFrom: 2 to: self applicationClassName size).	stream := String new writing.	stream 		write: methodName, ': aServer';		cr;tab;		write: '"', self methodComment, '"';		cr;tab;		write: '&lt;server: ', self serverId printString, '&gt;';		cr;tab;		write: 'aServer listenOn: ', self port printString, ' for: SiouX.HttpConnection'.	Server class		compile: stream contents		classified: 'configuration'.</body><body package="AppeX-Scaffolding-Tool">writeServerMethod: aBlock	| stream |	stream := String new writing.	stream 		write: '"', self methodComment, '"';		cr;tab.	aBlock value: stream.	^stream contents</body></methods><methods><class-id>AppeX.WebAppBuilder</class-id> <category>test application</category><body package="AppeX-Scaffolding-Tool">testApplication		| server responder exists |	applicationClass ifNil: [^nil].	exists := (SiouX.Server.Registry at: self serverId ifAbsent: [nil]) notNil.	(server := Server id: self serverId) start. 		responder :=  (exists 					ifTrue: [responder := self applicationClass new.							responder path: self baseUrl.							server addResponder: responder]					ifFalse: [server responders first]).				Smalltalk.ExternalWebBrowser open: ( responder siteURLFor: self port )</body></methods><methods><class-id>AppeX.WebAppBuilder class</class-id> <category>defaults</category><body package="AppeX-Scaffolding-Tool">applicationName	^applicationName ifNil: [ String new]</body><body package="AppeX-Scaffolding-Tool">applicationName: aString	applicationName := aString</body><body package="AppeX-Scaffolding-Tool">applicationPackage: aString	applicationPackage := aString</body><body package="AppeX-Scaffolding-Tool">defaultPort	^defaultPort ifNil: [ defaultPort := self defaultPortValue ]</body><body package="AppeX-Scaffolding-Tool">defaultPort: aNumber	defaultPort := aNumber</body><body package="AppeX-Scaffolding-Tool">defaultPortValue	^6767</body></methods><methods><class-id>AppeX.WebAppBuilder class</class-id> <category>accessing</category><body package="AppeX-Scaffolding-Tool">applicationNamespace	^applicationNamespace ifNil: ['Smalltalk']</body><body package="AppeX-Scaffolding-Tool">applicationNamespace: aString	applicationNamespace := aString</body><body package="AppeX-Scaffolding-Tool">applicationPackage	^applicationPackage</body><body package="AppeX-Scaffolding-Tool">methodComment	^methodComment ifNil: [ 'Generated by WebAppBuilder ', Timestamp now printString]</body><body package="AppeX-Scaffolding-Tool">methodComment: aString	methodComment := aString</body><body package="AppeX-Scaffolding-Tool">tableNotSelectionCriteria:  aString	MappingModel tableNotSelectionCriteria: aString.</body><body package="AppeX-Scaffolding-Tool">tableSelectionCriteria: aString	MappingModel tableSelectionCriteria: aString</body></methods><methods><class-id>AppeX.WebAppBuilder class</class-id> <category>instance creation</category><body package="AppeX-Scaffolding-Tool">initializeFrom: aWebApplication" Create a builder to update the application "	^self new		initializeFrom: aWebApplication;		yourself</body></methods><methods><class-id>AppeX.ResponderServicesUI</class-id> <category>aspects</category><body package="AppeX-Scaffolding-Tool">classPathMapAspect	^classPathMapAspect</body><body package="AppeX-Scaffolding-Tool">clientMainPathAspect	^clientMainPathAspect isNil		ifTrue:			[clientMainPathAspect := String new asValue]		ifFalse:			[clientMainPathAspect]</body><body package="AppeX-Scaffolding-Tool">pathList	^pathList</body></methods><methods><class-id>AppeX.ResponderServicesUI</class-id> <category>actions</category><body package="AppeX-Scaffolding-Tool">closeRequestFromParent 		self model clientMainPath: self clientMainPathAspect value.	self safelyExecute: [ self model createApplication ].	^true</body><body package="AppeX-Scaffolding-Tool">testApplication	self model testApplication</body></methods><methods><class-id>AppeX.ResponderServicesUI</class-id> <category>accessing</category><body package="AppeX-Scaffolding-Tool">selectedRow	^selectedRow isNil		ifTrue: [selectedRow := nil asValue]		ifFalse: [selectedRow]</body></methods><methods><class-id>AppeX.ResponderServicesUI</class-id> <category>interface opening</category><body package="AppeX-Scaffolding-Tool">postBuildWith: aBuilder 		(parent widgetAt: #next) setLabelString: 'Create Classes'</body></methods><methods><class-id>AppeX.ResponderServicesUI</class-id> <category>initialize-release</category><body package="AppeX-Scaffolding-Tool">collectPath	^classPathMapAspect list collect: [ :obj | obj path ]</body><body package="AppeX-Scaffolding-Tool">initializeAspects	| sorted |	classPathMapAspect :=  SelectionInListSortAware new.	classPathMapAspect selectionIndexHolder compute: [ :v | self selectedRow value: classPathMapAspect selection].	sorted := self model classPathMap asSortedCollection: [ :a :b | a activeRecordClassName &lt; b activeRecordClassName ].	classPathMapAspect list: sorted.	clientMainPathAspect := sorted first path asValue.	pathList := self collectPath asValue.	"Refresh combo box if a path has been changed"	sorted do: [ :map | 		map pathChangedBlock: [ :old :new |			clientMainPathAspect value = old ifTrue: [ clientMainPathAspect value: new ].			pathList value: self collectPath ]].</body><body package="AppeX-Scaffolding-Tool">	self halt.</body></methods><methods><class-id>AppeX.ResponderServicesUI class</class-id> <category>accessing</category><body package="AppeX-Scaffolding-Tool">header	^#ResponderServices &lt;&lt; #www &gt;&gt; 'Responder Services'</body><body package="AppeX-Scaffolding-Tool">helpText	^#ResponderServicesHelp &lt;&lt; #www &gt;&gt; 'The page maps class models to database tables and defines application services. Main path - This path with base URL defines the URL to open a first application page. For example the URL: /genealogy/personage opens the first page with the path corresponding a class model with #personage pathActive Record Class table - The table allows selecting Active Record classes and change a class path. The tool will generate Application responder services for selected classes.Create Classes - The button creates client and responder classes. '</body></methods><methods><class-id>Glorp.MappingModel</class-id> <category>accessing</category><body package="AppeX-Scaffolding-Tool">descriptorClass	^descriptorClass</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>menus</category><body package="AppeX-Scaffolding-Tool">updateWebApplication	(AppeX.WebAppBuilder initializeFrom: self nonMetaClass) 		updateApplication</body></methods><methods><class-id>AppeX.TestApplicationUI class</class-id> <category>interface specs</category><body package="AppeX-Scaffolding-Tool">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ApplicationSettings 				#defaultString: 'Application Settings' 				#catalogID: #www ) 			#min: #(#{Core.Point} 715 515 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 862 369 1577 884 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 40 0 60 0 -40 1 300 0 ) 					#name: #TextEditor1 					#flags: 4 					#model: #headerAspect 					#tabable: false 					#style: #large 					#isReadOnly: true 					#tabRequiresControl: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 40 0 310 0 180 0 335 0 ) 					#name: #TestApplicationButton 					#model: #testApplication 					#label: 					#(#{Kernel.UserMessage} 						#key: #TestApplication 						#defaultString: 'Test Application' 						#catalogID: #www ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>AppeX.ClientResponderUI class</class-id> <category>interface specs</category><body package="AppeX-Scaffolding-Tool">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ClassDefinition 				#defaultString: 'Class Definition' 				#catalogID: #www ) 			#min: #(#{Core.Point} 715 515 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 661 302 1376 817 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 133 0 -5 1 283 0 ) 					#name: #serverGroupBox 					#label: 					#(#{Kernel.UserMessage} 						#key: #Server 						#defaultString: 'Server' 						#catalogID: #www ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 50 0 120 0 69 0 ) 					#name: #clientNameLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #ClientName 						#defaultString: 'Client name:' 						#catalogID: #www ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 159 0 114 0 178 0 ) 					#name: #responderNameLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #ResponderName 						#defaultString: 'Responder name:' 						#catalogID: #www ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 219 0 70 0 238 0 ) 					#name: #serverIdLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #ServerId 						#defaultString: 'Server id:' 						#catalogID: #www ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 189 0 70 0 208 0 ) 					#name: #baseURLLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #BaseURLPath 						#defaultString: 'Base URL:' 						#catalogID: #www ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 249 0 70 0 268 0 ) 					#name: #portLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Port 						#defaultString: 'Port:' 						#catalogID: #www ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 160 0 48 0 -10 1 69 0 ) 					#name: #clientNameAspect 					#model: #clientNameAspect ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 158 0 157 0 -12 1 178 0 ) 					#name: #appResponderNameAspect 					#model: #appResponderNameAspect ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 158 0 217 0 -12 1 238 0 ) 					#name: #serverIdComboBox 					#model: #serverIdAspect 					#isReadOnly: false 					#comboList: #serverIDs ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 158 0 247 0 -12 1 268 0 ) 					#name: #port 					#model: #portAspect 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 158 0 187 0 -12 1 208 0 ) 					#name: #baseURLAspect 					#model: #baseUrlAspect ) ) ) )</body></methods><methods><class-id>AppeX.DescriptorSystemUI class</class-id> <category>interface specs</category><body package="AppeX-Scaffolding-Tool">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ApplicationSettings 				#defaultString: 'Application Settings' 				#catalogID: #www ) 			#min: #(#{Core.Point} 715 515 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 836 254 1551 769 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 200 0 -10 1 310 0 ) 					#name: #GroupBox1 					#label: 					#(#{Kernel.UserMessage} 						#key: #CreateClassesIn 						#defaultString: 'Create classess in' 						#catalogID: #www ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 25 0 200 0 50 0 ) 					#name: #appNameLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #ApplicationName 						#defaultString: 'Application name:' 						#catalogID: #www ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 260 0 25 0 -10 1 50 0 ) 					#name: #applicationName 					#model: #applicationNameAspect ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 90 0 260 0 115 0 ) 					#name: #newDescriptor 					#model: #descriptorTypeAspect 					#label: 					#(#{Kernel.UserMessage} 						#key: #CreateNewDescriptor 						#defaultString: 'Create descriptor system:' 						#catalogID: #www ) 					#select: #newDescriptor ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 120 0 260 0 145 0 ) 					#name: #existingDescriptor 					#model: #descriptorTypeAspect 					#label: 					#(#{Kernel.UserMessage} 						#key: #UseExistingDescriptor 						#defaultString: 'Use existing descriptor system:' 						#catalogID: #www ) 					#select: #existingDescriptor ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 260 0 120 0 -10 1 145 0 ) 					#name: #existingDescriptorList 					#model: #descriptorSystemAspect 					#comboList: #activeRecordDescriptorSystems ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 18 0 230 0 -22 1 300 0 ) 					#name: #classDefinition 					#flags: 0 					#majorKey: #{Tools.DefinitionCreationDialog} 					#minorKey: #locationSpecWithPackage 					#clientKey: #classDefinition ) ) ) )</body></methods><methods><class-id>AppeX.WebAppBuilder</class-id> <category>server - methods</category><body package="AppeX-Scaffolding-Tool">activeRecordDescriptorSystem	&lt;server: #'database defaults'&gt;		^self writeServerMethod: [ :stream |		stream 			write: '"Return the name of the class (termed a descriptor system) that contains a database mapping specifications needed to run an application with Glorp framework"';			cr;tab;			write: '^', descriptorSystem class fullName ].</body><body package="AppeX-Scaffolding-Tool">applicationClientClass	&lt;server: #accessing&gt;	^self writeServerMethod: [ :stream |		stream 			write: '"The class contains Javascript code"';			cr;tab;			write: '^', (clientClass ifNil: ['nil'] ifNotNil: [ clientClass name]) ].</body><body package="AppeX-Scaffolding-Tool">defaultTheme	&lt;server: #css&gt;		^self writeServerMethod: [ :stream |		stream write: '"The default theme. See subclasses of DefaultScaffoldingTheme for more options"	^AppeX.DefaultScaffoldingTheme new' ]</body><body package="AppeX-Scaffolding-Tool">headExternalLibraries	&lt;server: #html&gt;	^self writeServerMethod: [ :stream |		stream write: '"Scaffolding default external libraries. To use different libraries you need to add a new subclass of Renderer and implement subclass methods. As an example see JQueryRenderer"	"Check the latest version of JQuery libraries and update this method"	&lt;head: 10&gt;	^',	'''',Application jqueryMinTags, '''']</body><body package="AppeX-Scaffolding-Tool">htmlTitle	&lt;server: #html&gt;		^self writeServerMethod: [ :stream |		stream 			write: '&lt;htmlToken: #title&gt;';			cr;tab;			write: '^', self applicationName printString ]</body><body package="AppeX-Scaffolding-Tool">newActiveRecordLogin	&lt;server: #database&gt;		^self writeServerMethod: [ :stream |				login password ifNotNil: [				stream 					write: ' "THE METHOD IS FOR TESTING ONLY, IT HAS TO BE MODIFIED. IT INCLUDES REAL PASSWORD" ';					cr;tab.].			stream 				write: '^Glorp.Login new';				cr;tab;tab;				write: 'database: ';				write: login database class fullName, ' new;';				cr;tab;tab;				write: 'username: '.			login username printOn: stream.						login password ifNotNil: [				stream 					put: $;;					cr;tab;tab;					write: 'password: '.				login password printOn: stream ].						stream 				put: $;;				cr;tab;tab;				write: 'connectString: '.			login connectString printOn: stream.				stream 				put: $;;				cr;tab;tab;				write: 'yourself. '.]</body><body package="AppeX-Scaffolding-Tool">newActiveRecordToPathMap	&lt;server: #'database defaults'&gt;			^self writeServerMethod: [ :stream |		stream 			write: '"Mapping domain classes to URL path"';			cr;tab;			write: '^Dictionary new'.				self classPathMap do: [ :map |			map selected ifTrue: [				stream 					cr;tab;tab;					write: 'at: ', map activeRecordClass fullName, ' put: ', map path printString, ';']].				stream 			cr;tab;tab;			write: 'yourself'.]</body><body package="AppeX-Scaffolding-Tool">scaffoldingLibrary	&lt;server: #html&gt;			^self writeServerMethod: [ :stream |		stream 			write: '"Add Scaffolding library"';			cr;tab;			write: '&lt;head: 9999.30&gt;';			cr;tab;			write: '^super scaffoldingLibrary' ]</body><body package="AppeX-Scaffolding-Tool">serverConfiguration	&lt;server: #configuration&gt;		^self writeServerMethod: [ :stream |			stream 			write: '"The server configuration includes the server name and url to this application. The NoCacheRequestFilter prevents caching active record requests"';			cr; tab;			write: '&lt;server: ', self serverId printString, ' path: ', (self baseUrl asLowercase) printString, '&gt;';			cr;tab;			write: '&lt;requestFilter: #''AppeX.NoCacheRequestFilter'' configuration: ''Active Record''&gt;']</body></methods><methods><class-id>AppeX.WebAppBuilder</class-id> <category>client - methods</category><body package="AppeX-Scaffolding-Tool">buildHtml	&lt;client: 'initialize'&gt;		^'buildHtml() {//Generated by WebAppBuilder//The method is the start point for the application. 	var scaffold, response;		scaffold = new AppeX.Scaffold(this);	//The first request retuns the application database metadata. 	response = this.GET("initializeActiveRecordApplication");	response		.onSuccess(function (dataCollection) {			//The information includes list of all database tables and table attribute types. 			//The information is saved in the this.objectTypeInfos global object			// and used by the framework to create labels and data entry fields based on table column types 			scaffold.objectTypeInfos = dataCollection;			//Create and open the main application page			scaffold.openMainView();		})		.onError(function(error){			//Set renderer to display the error			scaffold.setRenderer();			scaffold.renderer				.startElement("div")				.text( error.statusText + ":" + error.response)				.finishElement();		});	}'</body><body package="AppeX-Scaffolding-Tool">mainPath	&lt;client: 'initialize'&gt;	| stream |	stream := String new writing.	stream 		write: 'mainPath() {';		cr;tab;		write: '//Generated by WebAppBuilder';		cr;tab;		write: '//The main path is used to create the first request URL. The path has to be specified in the application class&gt;&gt;newActiveRecordLogin';		cr;tab;		write: 'return ', self clientMainPath printString, ';';		cr;		put: $}.	^stream contents</body><body package="AppeX-Scaffolding-Tool">openMainView	&lt;client: 'initialize'&gt;		^'openMainView() {	//Generated by WebAppBuilder	//By default Scaffolding framework create a ListPresenter for the table specified by #mainPath()	//If you want to build your own page replace these lines with your code	var presenter;	presenter = this.scaffold.createMainPresenter();	presenter.openMainView();	}'</body></methods><methods><class-id>AppeX.WebAppBuilder class</class-id> <category>pragmas</category><body package="AppeX-Scaffolding-Tool">pragmas	&lt;pragmas: #instance&gt;	^#(#server: #client:)</body></methods><methods><class-id>AppeX.ResponderServicesUI class</class-id> <category>interface specs</category><body package="AppeX-Scaffolding-Tool">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #CreatingWebApplication 				#defaultString: 'Creating Web Application' 				#catalogID: #www ) 			#min: #(#{Core.Point} 715 515 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 648 343 1363 858 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #showHorizontalLines true #allowColumnResizing true #showVerticalLines true #rowLabelsAsButtons true #allowColumnReordering false ) 					#layout: #(#{Graphics.LayoutFrame} 5 0 70 0 -5 1 -5 1 ) 					#name: #tablePathMapDataset 					#model: #classPathMapAspect 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false #allowSorting true #allowResizing true ) 							#model: #'selectedRow selected' 							#label: '' 							#labelIsImage: false 							#width: 30 							#rendererType: #CheckBox 							#editorType: #CheckBox 							#noScroll: false 							#labelsAsButtons: true ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false #allowSorting false #allowResizing true ) 							#model: #'selectedRow activeRecordClassName' 							#label: 							#(#{Kernel.UserMessage} 								#key: #Select 								#defaultString: 'Active Record Class' 								#catalogID: #www ) 							#labelIsImage: false 							#width: 200 							#rendererType: #Text 							#editorType: #None 							#noScroll: false 							#labelsAsButtons: true ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false #allowSorting false #allowResizing true ) 							#model: #'selectedRow path' 							#label: 							#(#{Kernel.UserMessage} 								#key: #Path 								#defaultString: 'Path' 								#catalogID: #www ) 							#labelIsImage: false 							#width: 200 							#rendererType: #Text 							#editorType: #InputField 							#noScroll: false 							#labelsAsButtons: true ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selectedRow useGET' 							#label: 							#(#{Kernel.UserMessage} 								#key: #GET 								#defaultString: 'GET' 								#catalogID: #www ) 							#labelIsImage: false 							#width: 60 							#rendererType: #CheckBox 							#editorType: #CheckBox 							#noScroll: false 							#labelsAsButtons: true ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting false #labelFromApplication false ) 							#model: #'selectedRow usePOST' 							#label: 							#(#{Kernel.UserMessage} 								#key: #POST 								#defaultString: 'POST' 								#catalogID: #www ) 							#labelIsImage: false 							#width: 60 							#rendererType: #CheckBox 							#editorType: #CheckBox 							#noScroll: false 							#labelsAsButtons: true ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting false #labelFromApplication false ) 							#model: #'selectedRow usePUT' 							#label: 							#(#{Kernel.UserMessage} 								#key: #PUT 								#defaultString: 'PUT' 								#catalogID: #www ) 							#labelIsImage: false 							#width: 60 							#rendererType: #CheckBox 							#editorType: #CheckBox 							#noScroll: false 							#labelsAsButtons: true ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selectedRow useDELETE' 							#label: 							#(#{Kernel.UserMessage} 								#key: #DELETE 								#defaultString: 'DELETE' 								#catalogID: #www ) 							#labelIsImage: false 							#width: 60 							#rendererType: #CheckBox 							#editorType: #CheckBox 							#noScroll: false 							#labelsAsButtons: true ) ) 					#labelsAsButtons: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 150 0 10 0 504 0 35 0 ) 					#name: #Label1 					#label: 					#(#{Kernel.UserMessage} 						#key: #SelectClassesCreateMethods 						#defaultString: 'Select classes to create responder service methods' 						#catalogID: #www ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 40 0 150 0 65 0 ) 					#name: #Label2 					#label: 					#(#{Kernel.UserMessage} 						#key: #mainPath 						#defaultString: 'Main path:' 						#catalogID: #www ) ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 150 0 40 0 -20 1 65 0 ) 					#name: #ComboBox1 					#model: #clientMainPathAspect 					#comboList: #pathList ) ) ) )</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>menus</category><body package="AppeX-Scaffolding-Tool">updateWebApplicationFromDBMenuItem	"Update WebApplication From database"	&lt;itemInMenu: #(#classMenu) position: 70.5&gt; 	^(MenuItem labeled: 'Update Web Application')		value: #updateWebApplication;		visible: [self nonMetaClass notNil and: [self nonMetaClass includesBehavior: AppeX.Application]];		enabled: [self isClassSelected];		yourself</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus- appex</category><body package="AppeX-Scaffolding-Tool">menuItemWebAppTool	&lt;vwPrivileged&gt;	&lt;menuItemForCommand: #webAppWizard		icon: nil		nameKey: nil		menu: #(#menuBar  #tools #webdevelopment)		position: 10.1&gt;	AppeX.WebAppWizard open</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - web</category><body package="AppeX-Scaffolding-Tool">appexCreateWebAppCommand	&lt;command: #webAppWizard&gt;	^Command		label: (#CreateWebApp &lt;&lt; #menus &gt;&gt; 'Create Web Application')		group: #launcher		bindings: #()</body></methods><initialize><class-id>AppeX.AppeXSubcanvas</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SequenceableSubcanvas</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent model </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wizard-Tools</category><attributes><package>Tools-NavigationPages</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>PageSequence</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model pages pageIndex client subcanvasName modelClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wizard-Tools</category><attributes><package>Tools-NavigationPages</package></attributes></class><class><name>BrowserNavigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractBrowserNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>history future </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>MappingModel</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectedPlatform system inflector classBuilder descriptorClass databaseTables tableSelectionCriteria schema tableNotSelectionCriteria tablesClasses </inst-vars><class-inst-vars>defaultPackage defaultNamespace descriptorClassName defaultDomainSuperclassName defaultDescriptorSuperclassName tableSelectionCriteria tableNotSelectionCriteria </class-inst-vars><imports></imports><category></category><attributes><package>GlorpAtlasUI</package></attributes></class></st-source>