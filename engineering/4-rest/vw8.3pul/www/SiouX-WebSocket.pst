<?xml version="1.0"?><st-source><!-- Name: SiouX-WebSocketNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: Server WebSocket implementation  based on http://tools.ietf.org/html/rfc6455http://www.iana.org/assignments/websocket/websocket.xml#subprotocol-name If you use WSS, and the server certificate is not acceptable to the browser, you may not get any browser rendered dialog (like it happens for Web pages). This is because WebSockets is treated as a so-called "subresource", and certificate accept / security exception / whatever dialogs are not rendered for subresources.To try Web Socket demos load the AppeX-Examples package, create Examples server and open a web browser on /appex/websocket-app or /appex/websocket-chat. The WebSocketChat class comment includes an example how to run the chat demo over HTTP Secure connection.Example creating Web server with WebSocket connection:	server := Server id: 'WebSocketTest'.	server addResponder: ( responder := WSResponder new).	responder path: '/websocket-app/'.	listener := server listenOn: 8002 for: HttpConnection.	listener protocolVersions: (Array with: (WebSocket new									subprotocols: #('chat');									yourself)).	listener conectionTimeout: 2 hours.The WSResponder has to be derived from HttpResponder and implement the following methods:#receivedWSDataOn: aStream connection: wsConnection message: aMessage	In this method read the application data from aStream 	aMessage - defines the data type: text or binary	aStream - contains web socket message data. An example:	out := aMessage isText 		ifTrue: [ String new writing]		ifFalse: [ByteArray new writing].	out write: aStream.	applicationData := out contents.To process control frames implement a Responder method:#receivedWSControlFrame: aMessage connection: wsConnection	aMessage represents a control frame. The Close frame may contain a body (the 'Application data' portion of the frame) that indicates a reason for closing, such as an endpoint shutting down. Use aMessage>>data to see the close frame bodyTo send a WebSocket message to a client use WebSocketConnection send messages API:#sendTextStream:  inputStream	Sends the inputStream contents as a text message (opcode = 1). If the input stream size exceeds the payload limit the steam contents will be sent as a fragmented message. The stream  contents will be sent utf8 encoded.#sendBinaryStream: inputStream	Sends the input stream contents as a binary message (opcode = 2). If the input stream size exceeds the payload limit the steam contents will send as a fragmented message.#sendStream: inputStream opcode: anInteger statusCode: aStatusCode	Sends the input stream contents over WebSocket connection 	#opcode – defines the interpretation of the "Payload data". The opcode values are defined as a Shared Variables in WebSocketMessage class. For more information about opcode see  http://tools.ietf.org/html/rfc6455#section-5.2	#statusCode is used to provide additional information for Close Control frame.  The Close frame may contain a body (the Application data portion of the frame) that indicates a reason for closing, such as an endpoint shutting down, an endpoint having received a frame too large, or an endpoint having received a frame that does not conform to the format expected by the endpoint.  More information:  http://tools.ietf.org/html/rfc6455#section-7.4#sendMessage: aWebSocketMessage	Use this API to send small messages. The message  #data instance variable should provide the message contents and #opcode  has to define the message type. DbIdentifier: bear73DbTrace: 499835DbUsername: tkoganDbVersion: 8.3 - 2DevelopmentPrerequisites: #(#(#any 'SiouX-Http' '') #(#any 'Xtreams-Transforms' '') #(#any 'SHA' ''))PackageName: SiouX-WebSocketParcel: #('SiouX-WebSocket')PrerequisiteDescriptions: #(#(#name 'SiouX-Http' #componentType #bundle) #(#name 'Xtreams-Transforms' #componentType #package) #(#name 'SHA' #componentType #package))PrerequisiteParcels: #(#('SiouX-Http' '') #('Xtreams-Transforms' '') #('SHA' ''))PrintStringCache: (8.3 - 2,tkogan)Version: 8.3 - 2Date: 1:19:06 PM July 14, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (jul17.2) of July 14, 2017 on July 14, 2017 at 1:19:06 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>HandshakeError</name><environment>SiouX</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-WebSocket</package></attributes></class><comment><class-id>SiouX.HandshakeError</class-id><body>HandshakeError is not proceedable error raised during the server-client hadshake</body></comment><class><name>WebSocketMessage</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>code opcode final masked data </inst-vars><class-inst-vars></class-inst-vars><imports>			private Xtreams.*			</imports><category></category><attributes><package>SiouX-WebSocket</package></attributes></class><comment><class-id>SiouX.WebSocketMessage</class-id><body>WebSocketMessage represents a WebSocket message Instance Variables	data	&lt;String&gt;	message contents	code	&lt;Number&gt;	pre-defined status codes for sending a Close frame	final	&lt;Boolean&gt;	Indicates that this is the final fragment in a message. 	masked	&lt;Boolean&gt;	Defines whether the "Payload data" is masked.  If set to 1, a masking key is present in masking-key, and this is used to unmask the "Payload data" 	opcode	&lt;Integer&gt;	Defines the interpretation of the "Payload data". Usage:To create and send a text message:	message := WebSocketMessage text: 'Hello'.	wsConnection sendMessage: messagehttp://tools.ietf.org/html/rfc6455#section-5     0                              1                         2                                          3     +-+-+-+-+--------+-+--------------+----------------------------------------------+     |F|R|R|R| opcode |M| Payload len  |    Extended payload length                          |I |S|S|S|  (4)      |A|     (7)          |             (16/64)                                         |N|V|V|V|             |S|                   |   (if payload len==126/127)                        |   |1|2|3|             |K|                   |                                                                 +-+-+-+-+-------+-+----------------+ - - - - - - - - - - -  - - - - -  - - - - - - - - +     |     Extended payload length continued, if payload len == 127                           + - - - - - - - - - - - - - - -  - - - - - - +----------------------------------------------+     |                                                   |Masking-key, if MASK set to 1                     +----------------------------------------+----------------------------------------------+     | Masking-key (continued)               |          Payload Data                                    +------------------------------------------- - - - - - - - - - - - - - -  - - - - - - - - - - +     :                     Payload Data continued ...                                                     :     + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  - -  -  -  - +     |                     Payload Data continued ...                                                         +-----------------------------------------------------------------------------------------+  FIN:  1 bit      Indicates that this is the final fragment in a message.  The first      fragment MAY also be the final fragment.   Opcode:  4 bits      Defines the interpretation of the "Payload data".  If an unknown      opcode is received, the receiving endpoint MUST _Fail the      WebSocket Connection_.  The following values are defined.      *  %x0 denotes a continuation frame      *  %x1 denotes a text frame      *  %x2 denotes a binary frame      *  %x3-7 are reserved for further non-control frames      *  %x8 denotes a connection close      *  %x9 denotes a ping      *  %xA denotes a pong      *  %xB-F are reserved for further control frames   Mask:  1 bit      Defines whether the "Payload data" is masked.  If set to 1, a      masking key is present in masking-key, and this is used to unmask      the "Payload data" as per Section 5.3.  All frames sent from      client to server have this bit set to 1.</body></comment><class><name>WebSocketConnection</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessProtect message state protocolVersion responder </inst-vars><class-inst-vars></class-inst-vars><imports>			private Security.*			private SiouX.WebSocketMessage.*			</imports><category></category><attributes><package>SiouX-WebSocket</package></attributes></class><comment><class-id>SiouX.WebSocketConnection</class-id><body>WebSocketConnection implements WebSocket protocol: handshake, reading and sending WS messagesInstance Variables	accessProtect	&lt;RecursionLock&gt; procects access to socket write stream	message	&lt;WebSocketMessage&gt;		state 	&lt;Symbol&gt; current connection state	protocolVersion &lt;WebSocket&gt;	responder	&lt;Responder&gt; ImplementationSee #handshakeResponseFor: method comment for handshake details.Uses FragmentedWriteStream to encode a data on web socket connection. If a message data exceeds the payload limit the message will be sent fragmented.UsageSending messages using WebSocket connection#sendMessage: aMessage	Creates an internal stream from the message data and sends 	message := WebSocketMessage text: 'Hello'.	wsConnection sendMessage: messagesendTextStream: inputStream	Sends a stream a text message. If the stream size exceeds the payload limit the steam will send as a fragmented message. The stream will be sent utf8 encoded.		filename := 'SomeFile.txt' asFilename.		stream := filename asFilename reading.		wsConnection sendMessage: (WebSocketMessage text: 'sending ', filename asString ).		[			wsConnection sendTextStream: stream		] ensure: [stream close.].sendBinaryStream: inputStream	Sends a stream a binary message. If the stream size exceeds the payload limit the steam will send as a fragmented message.sendStream: inputStream opcode: anInteger statusCode: aStatusCode	Sends a stream over WebSocket connection. If the stream size exceeds the WebSocket connection payload limit the message will be fragmented. If opcode is #text or #close frame type the stream contents will be utf8 encoded</body></comment><class><name>DataFramingClose</name><environment>SiouX</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-WebSocket</package></attributes></class><comment><class-id>SiouX.DataFramingClose</class-id><body>DataFramingClose is raised if there is a protocol error reading frames</body></comment><class><name>WebSocket</name><environment>SiouX</environment><super>Protocols.ProtocolVersion</super><private>false</private><indexed-type>none</indexed-type><inst-vars>webSocketConnection responder </inst-vars><class-inst-vars>payloadLimit subprotocols </class-inst-vars><imports>			private Security.*			</imports><category></category><attributes><package>SiouX-WebSocket</package></attributes></class><comment><class-id>SiouX.WebSocket</class-id><body>WebSocket upgrades Http connection to WebSocketInstance Variables:	responder	&lt;Responder&gt;		webSocketConnection	&lt;WebSocketConnection&gt;	Class Instance Variables:	payloadLimit &lt;Integer&gt; default buffer size to write messages. The default is 32K	subprotocols &lt;OrderedCollection of String&gt; sub protocols by default are emptyUsage:Specifying supported protocols to upgrade in Listener:	server := Server id: 'WebSocketTest'.	server addResponder: HelloResponder new.	listener := server listenOn: 8002 for: HttpConnection.	listener protocolVersions: (Array with: WebSocket new).	server start.Specifying protocol versions in a Responder:Add to a responder the following method:MyResponder&gt;&gt;protocolVersions	^Array with: WebSocket new	server := Server id: 'WebSocketTest'.	server addResponder: MyResponder new.	listener := server listenOn: 8002 for: HttpConnection.	server start.</body></comment><class><name>FragmentedWriteStream</name><environment>SiouX</environment><super>Xtreams.PositionWriteSubstream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstFragment opcode fin </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-WebSocket</package></attributes></class><comment><class-id>SiouX.FragmentedWriteStream</class-id><body>FragmentedWriteStream class encodes and sends Web Socket messages  Instance Variables	final	&lt;SmallInteger&gt;	type of the frame	firstFragment	&lt;Boolean&gt;	flag to detect the first fragment	opcode	&lt;Integer&gt;	 opcode defines the message type	fin &lt;Number&gt; 0 or 1 defines if the fragment is final</body></comment><class><name>WebSocketFilter</name><environment>SiouX</environment><super>SiouX.ProtocolUpgradeFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>payloadLimit subprotocols </inst-vars><class-inst-vars>payloadLimit subprotocols </class-inst-vars><imports></imports><category></category><attributes><package>SiouX-WebSocket</package></attributes></class><comment><class-id>SiouX.WebSocketFilter</class-id><body>WebSocketFilter is deprecated. To upgrade to WebSocket connection use WebSocket class</body></comment><shared-variable><name>WebSocketGuid</name><environment>SiouX.WebSocketConnection</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</initializer><attributes><package>SiouX-WebSocket</package></attributes></shared-variable><shared-variable><name>WebSocketGuid</name><environment>SiouX.WebSocket</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>'258EAFA5-E914-47DA-95CA-C5AB0DC85B11'</initializer><attributes><package>SiouX-WebSocket</package></attributes></shared-variable><shared-variable><name>BinaryType</name><environment>SiouX.WebSocketMessage</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>0</initializer><attributes><package>SiouX-WebSocket</package></attributes></shared-variable><shared-variable><name>PongType</name><environment>SiouX.WebSocketMessage</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>10</initializer><attributes><package>SiouX-WebSocket</package></attributes></shared-variable><shared-variable><name>CloseType</name><environment>SiouX.WebSocketMessage</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>8</initializer><attributes><package>SiouX-WebSocket</package></attributes></shared-variable><shared-variable><name>TextType</name><environment>SiouX.WebSocketMessage</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>1</initializer><attributes><package>SiouX-WebSocket</package></attributes></shared-variable><shared-variable><name>ContinuationType</name><environment>SiouX.WebSocketMessage</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>0</initializer><attributes><package>SiouX-WebSocket</package></attributes></shared-variable><shared-variable><name>PingType</name><environment>SiouX.WebSocketMessage</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>9</initializer><attributes><package>SiouX-WebSocket</package></attributes></shared-variable><methods><class-id>SiouX.WebSocketMessage</class-id> <category>testing</category><body package="SiouX-WebSocket">hasStatusCode	^code notNil</body><body package="SiouX-WebSocket">isBinary	^self opcode = BinaryType</body><body package="SiouX-WebSocket">isClose	^self opcode = CloseType</body><body package="SiouX-WebSocket">isContolFrame	^self opcode notNil and: [ (self opcode bitAt: 8) = 1]</body><body package="SiouX-WebSocket">isControlFrame	^self opcode notNil and: [ self opcode &gt; 7 ]</body><body package="SiouX-WebSocket">isFinal	^self final</body><body package="SiouX-WebSocket">isPing	^self opcode = PingType</body><body package="SiouX-WebSocket">isPong	^self opcode = PongType</body><body package="SiouX-WebSocket">isText	^self opcode = TextType</body><body package="SiouX-WebSocket">shouldEncode	^(self isText or: [self isClose])</body></methods><methods><class-id>SiouX.WebSocketMessage</class-id> <category>accessing</category><body package="SiouX-WebSocket">code	^code</body><body package="SiouX-WebSocket">code: anInteger	code := anInteger</body><body package="SiouX-WebSocket">data	^data</body><body package="SiouX-WebSocket">final	^final ifNil: [ true ]</body><body package="SiouX-WebSocket">final: aBoolean	final := aBoolean</body><body package="SiouX-WebSocket">length	^self data 		ifNotNil: [ self data size ]		ifNil: [ 0 ]</body><body package="SiouX-WebSocket">masked	^masked ifNil: [ false ]</body><body package="SiouX-WebSocket">masked: aBoolean	masked := aBoolean</body><body package="SiouX-WebSocket">opcode	^opcode ifNil: [ TextType ]</body><body package="SiouX-WebSocket">opcode: aNumber	opcode := aNumber</body></methods><methods><class-id>SiouX.WebSocketMessage</class-id> <category>initialize-release</category><body package="SiouX-WebSocket">code: aNumber data: aData	code := aNumber.	self data: aData.</body><body package="SiouX-WebSocket">data: aData	data := aData</body><body package="SiouX-WebSocket">release	data := nil</body></methods><methods><class-id>SiouX.WebSocketMessage class</class-id> <category>creation close frame</category><body package="SiouX-WebSocket">code: anInteger data: aString"  The Close frame MAY contain a body (the Application data portion of the frame) that indicates a reason for closing, such as an endpoint shutting down, an endpoint having received a frame too large, or an endpoint having received a frame that does not conform to the format expected by the endpoint.  If there is a body, the first two bytes of the body MUST be a 2-byte unsigned integer (in network byte order) representing a status code with value /code/"	^self new		opcode: CloseType;		code: anInteger data: aString;		yourself</body><body package="SiouX-WebSocket">statusCodeInternalError" 1011 indicates that a server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request."	^self code: 1011 data: 'Internal error'</body><body package="SiouX-WebSocket">statusCodeInvalidUtf8" 1007 indicates that an endpoint is terminating the connection because it has received data within a message that was not consistent with the type of the message (e.g., non-UTF-8 [RFC3629] data within a text message)."	^self code: 1007 data: 'Invalid UTF8'</body><body package="SiouX-WebSocket">statusCodeMessageTooLarge" 1009 indicates that an endpoint is terminating the connection because it has received a message that is too big for it to process."	^self code: 1009 data: 'Message too large'</body><body package="SiouX-WebSocket">statusCodeOK" 1000 indicates a normal closure, meaning that the purpose for which the connection was established has been fulfilled."	^self code: 1000 data: 'status code OK'</body><body package="SiouX-WebSocket">statusCodePolicyViolation"  1007 indicates that an endpoint is terminating the connection because it has received data within a message that was not consistent with the type of the message (e.g., non-UTF-8 [RFC3629] data within a text message)."	^self code: 1007 data: 'Policy Violation'</body><body package="SiouX-WebSocket">statusCodeProtocolError" 1002 indicates that an endpoint is terminating the connection due to a protocol error."	^self code: 1002 data: 'Protocol Error'</body></methods><methods><class-id>SiouX.WebSocketMessage class</class-id> <category>instance creation</category><body package="SiouX-WebSocket">text	^self new		opcode: TextType;		yourself</body><body package="SiouX-WebSocket">text: aString	^self new		opcode: TextType;		data: aString;		yourself</body></methods><methods><class-id>SiouX.WebSocketConnection</class-id> <category>errors</category><body package="SiouX-WebSocket">statusCodeProtocolError	^DataFramingClose raiseRequestWith: WebSocketMessage statusCodeInternalError</body></methods><methods><class-id>SiouX.WebSocketConnection</class-id> <category>accessing</category><body package="SiouX-WebSocket">httpConnection	^protocolVersion connection</body><body package="SiouX-WebSocket">payloadLimit	^protocolVersion payloadLimit</body><body package="SiouX-WebSocket">payloadLimit: aNumber	protocolVersion payloadLimit: aNumber</body><body package="SiouX-WebSocket">readSocketStream	^self httpConnection readStream</body><body package="SiouX-WebSocket">responder	^responder</body><body package="SiouX-WebSocket">server	^ self httpConnection server</body><body package="SiouX-WebSocket">setConnected	state := #connected</body><body package="SiouX-WebSocket">subprotocols	^protocolVersion subprotocols</body><body package="SiouX-WebSocket">writeSocketStream	^self httpConnection writeStream</body></methods><methods><class-id>SiouX.WebSocketConnection</class-id> <category>read messages</category><body package="SiouX-WebSocket">receivedControlFrame: aMessage	self responder receivedWSControlFrame: aMessage connection: self.	aMessage isClose ifTrue: [ self close ].	aMessage release.</body><body package="SiouX-WebSocket">receivedMessage: aMessage stream: aStream	self responder receivedWSDataOn: aStream connection: self message: aMessage.	aMessage release</body></methods><methods><class-id>SiouX.WebSocketConnection</class-id> <category>private - read</category><body package="SiouX-WebSocket">getFragment	| aMessage stream |	aMessage := self readFragmentType.	stream := self 				prepareReadStream: ( self readPayloadLengthFor: aMessage) 				for: aMessage.	"Control frames are used to communicate state about the WebSocket.  	Control frames can be interjected in the middle of a fragmented message."	aMessage isControlFrame ifTrue: [			stream ifNotNil: [				aMessage isClose ifTrue: [ aMessage code: stream getUint16].				aMessage data: (stream encoding: #utf8) rest ].			self receivedControlFrame: aMessage.			^nil ].	"opcode = 0 indicates continuation frame and we have to have a message already"	((message isNil and: [ aMessage opcode == 0 ])			or: [ message notNil and: [ aMessage opcode ~= 0 ]]) 		ifTrue: [self statusCodeProtocolError].	message 			ifNil: [ message := aMessage ]			ifNotNil: [ message final: aMessage final].	^message isText 		ifTrue: [  stream encoding: #utf8. ]		ifFalse: [ stream ].</body><body package="SiouX-WebSocket">nextMessage		|first firstFragment  fragment lastFragment |	message := nil.	first := true.	lastFragment := false.	self getFragment		ifNotNil: [ :dataStream | | fragments |			firstFragment := dataStream.			fragments := Xtreams.StitchReadStream				on: [ 						lastFragment ifTrue: [Incomplete zero raise ].						fragment := first								ifTrue: [ first := false. 										lastFragment := message final.										firstFragment ]								ifFalse: [ 										 [ (fragment := self getFragment) isNil ] whileTrue.										lastFragment := message final.										fragment]														] reading				contentsSpecies: ByteArray.			message ifNotNil: [ 				[ self receivedMessage: message stream: fragments ] on: Incomplete do: [ :ex | ]]		].	^message</body><body package="SiouX-WebSocket">prepareReadStream: payloadLength for: aMessage	| position inputStream maskingKey |	maskingKey := Array new: 4.	1 to: 4 do: [ :indx | maskingKey at: indx put: self readSocketStream get ].	(maskingKey anySatisfy: [ :i | i &gt; 0 ]) 		ifFalse: [ aMessage masked: false.			"The server MUST close the connection upon receiving a frame that is not masked"			^self statusCodeProtocolError].	payloadLength &gt; 0 		ifTrue:  [ inputStream := self readSocketStream limiting: payloadLength.				position := 0.				aMessage masked  ifTrue: [ 					inputStream := inputStream transforming: [ :in :out | 					out put: ((maskingKey at: (position \\ 4) + 1) bitXor: in get). 					position := position + 1. ]]].	^inputStream</body><body package="SiouX-WebSocket">readFragmentType	| byte  opcode final aMessage |	byte := self readSocketStream get.	" FIN:  1 bit. Indicates that this is the final fragment in a message.  The first fragment MAY also be the final fragment."	" (byte bitAt: 8) = 1"	"RSV1, RSV2, RSV3:  1 bit each.  MUST be 0 unless an extension is negotiated that defines meanings      for non-zero values.  If a nonzero value is received and none of the negotiated extensions defines the meaning	of such a nonzero value, the receiving endpoint MUST _Fail the WebSocket Connection_."	((byte bitAt: 7) ~= 0		and: [(byte bitAt: 6) ~= 0			and: [(byte bitAt: 5) ~= 0]])		ifTrue: [^self statusCodeProtocolError ].	" Opcode:  4 bits. Defines the interpretation of the Payload data.  If an unknown opcode is received, the receiving 	endpoint MUST _Fail the WebSocket Connection_. "	opcode := (byte bitAt: 8) = 1				ifTrue: [ byte bitXor: 02r10000000]				ifFalse: [ byte ].	opcode &gt; 10 ifTrue: [self statusCodeProtocolError ].	final := (byte bitAt: 8) = 1.	"Control frames are identified by opcodes where the most significant bit of the opcode is 1. 	Currently defined opcodes for control frames include 0x8 (Close), 0x9 (Ping), and 0xA (Pong).  	Opcodes 0xB-0xF are reserved for further control frames yet to be defined."	(opcode &gt; 7 		and: [ "All control frames are final" final not]) 			ifTrue: [self statusCodeProtocolError].	"Create a temp message to hold the frame type "	aMessage := WebSocketMessage new.	aMessage final: final.	aMessage opcode: opcode.	^aMessage</body><body package="SiouX-WebSocket">readPayloadLengthFor: aMessage	| byte  payloadLengthBytesRemaining payloadLength |	byte := self readSocketStream get.	aMessage masked: (byte bitAt: 8) = 1.	payloadLength := byte bitXor: 02r10000000. 	payloadLengthBytesRemaining := 0.	payloadLength &gt; 125		ifTrue: [payloadLength = 126 "If 126, the following 2 bytes interpreted as a 16-bit unsigned integer are the payload length"					ifTrue: [payloadLength := 0.							payloadLengthBytesRemaining := 2.]					ifFalse: [ payloadLength = 127  "If 127, the following 8 bytes interpreted as a 64-bit unsigned integer"								ifTrue: [	payloadLength := 0.										payloadLengthBytesRemaining := 8.]]				].	(aMessage masked not "All frames sent from client to server have this bit set to 1"		or: [ aMessage opcode &gt; 10 "Control opcodes cannot have a payload larger than 125 bytes"			and: [payloadLengthBytesRemaining ~= 0 ]]) 				ifTrue: [  ^self statusCodeProtocolError ].	[ payloadLengthBytesRemaining &gt; 0 ]		whileTrue:  [ payloadLength := (payloadLength bitShift: 8) + self readSocketStream get.					payloadLengthBytesRemaining := payloadLengthBytesRemaining - 1. ].	(payloadLengthBytesRemaining = 0		and: [ payloadLength &lt;0 			or: [ payloadLength &gt; self payloadLimit ]])		ifTrue: [ ^DataFramingClose raiseRequestWith: WebSocketMessage statusCodeMessageTooLarge ].	^payloadLength</body><body package="SiouX-WebSocket">run	[ self nextMessage ] 		on: DataFramingClose		do: [ :ex |				"Announce the error and debug it"				self server connectionError: ex from: self httpConnection.				"Error parsing frames. Sending close frame with a code and reason"				self sendMessage: ex response. 				"Closing HTTP connection"				^self httpConnection persist: false].</body></methods><methods><class-id>SiouX.WebSocketConnection</class-id> <category>send messages</category><body package="SiouX-WebSocket">sendBinaryStream: inputStream"Sends the input stream contents as  a binary message. If the input stream size exceeds the payload limit the steam contents will send as a fragmented message."	self privateSendStream: inputStream opcode: BinaryType statusCode: nil</body><body package="SiouX-WebSocket">sendMessage: aMessage"Creates an internal stream from the message data and sends "	self 		sendStream: aMessage data reading		opcode: aMessage opcode 		statusCode: aMessage code</body><body package="SiouX-WebSocket">sendPong: aData" Sends Pong message"		"opcode 10 "	self sendMessage: ( (WebSocketMessage text: aData) 							opcode: PongType; 							yourself)</body><body package="SiouX-WebSocket">sendStream: inputStream opcode: anInteger statusCode: aStatusCode"Sends a stream over WebSocket connection #opcode - see WebSocketMessage Shared Variables for supported opcode values.#statusCode is used to provide additional information for Control frames "	self 		privateSendStream: inputStream 		opcode: anInteger 		statusCode: aStatusCode</body><body package="SiouX-WebSocket">sendTextStream: inputStream"Sends the inputStream contents as a text message. If the input stream size exceeds the payload limit the steam contents will be sent as a fragmented message. The stream contents will be sent utf8 encoded  "	self privateSendStream: inputStream opcode: TextType statusCode: nil</body></methods><methods><class-id>SiouX.WebSocketConnection</class-id> <category>private - send</category><body package="SiouX-WebSocket">privateSendStream: inputStream opcode: anInteger statusCode: aStatusCode	| fStream fs |	accessProtect critical: [ 		fs := FragmentedWriteStream on: (self writeSocketStream  closing: []) opcode: anInteger.		fStream := fs buffering: self payloadLimit.		[			aStatusCode ifNotNil: [ fStream write: aStatusCode asBigEndianByteArray ].			(anInteger = TextType or: [anInteger = CloseType]) ifTrue: [ fStream := fStream encoding: #utf8].			fStream write: inputStream. 			fs prepareToFlush.		] ensure: [ fStream close ]	]</body></methods><methods><class-id>SiouX.WebSocketConnection</class-id> <category>services</category><body package="SiouX-WebSocket">close" After both sending and receiving a Close message, an endpoint considers the WebSocket connection closed and MUST close the underlying TCP connection.  The server MUST close the underlying TCP connection immediately"	self stop</body><body package="SiouX-WebSocket">start	"I am a WebSocket connection. I start exchanging messages here. "		state := #running.	^[ 		[ self run.		self isRunning ]  			whileTrue	]	on: Error			do: [ :ex | 				"Announce the error and debug info. Disconnect"				self server responderError: ex from: self responder request: nil connection: self httpConnection.				self sendMessage: (WebSocketMessage statusCodeInternalError											data: 'Internal error: ', ex description;											yourself ).				state := #closed				]</body><body package="SiouX-WebSocket">stop	(state == #closed 		or: [	self httpConnection isOpen not ] ) ifTrue: [^nil].	"The Close frame contains an opcode of 0x8."	[self sendMessage: WebSocketMessage statusCodeOK]		on:Error		do: [ :ex |"there is no longer a connection to send a disconnect message to the client"].	state := #closed.</body></methods><methods><class-id>SiouX.WebSocketConnection</class-id> <category>initialize-release</category><body package="SiouX-WebSocket">initializeWith: aWebSocket responder: aResponder	protocolVersion := aWebSocket.	responder := aResponder.	accessProtect := RecursionLock new.	self setConnected.	"Notify the responder that the connection is ready to read and send ws messages."	self responder establishedWSConnection: self.</body></methods><methods><class-id>SiouX.WebSocketConnection</class-id> <category>testing</category><body package="SiouX-WebSocket">continueProcessing	^true</body><body package="SiouX-WebSocket">isConnected		^state = #connected.</body><body package="SiouX-WebSocket">isRunning		^state = #running</body></methods><methods><class-id>SiouX.WebSocketConnection class</class-id> <category>instance creation</category><body package="SiouX-WebSocket">initializeWith: aWebSocket responder: aResponder	^self new		initializeWith: aWebSocket responder: aResponder;		yourself</body></methods><methods><class-id>SiouX.DataFramingClose</class-id> <category>accessing</category><body package="SiouX-WebSocket">response	^parameter</body></methods><methods><class-id>SiouX.WebSocket</class-id> <category>handshake</category><body package="SiouX-WebSocket">badResponse: aString	^(HttpResponse code: 400)		contents: aString;		yourself</body><body package="SiouX-WebSocket">handshake: aRequestContext	[	"The connection is accepted and the server replies with opening handshake "		aRequestContext sendResponse: (self handshakeResponseFor: aRequestContext request ).	] on: Error do: [ :ex | 		(HandshakeError handles: ex) ifTrue: [ aRequestContext response: ex parameter].		ex pass ].</body><body package="SiouX-WebSocket">handshakeResponseFor: httpRequest"http://tools.ietf.org/html/rfc6455#section-4.1"	| httpResponse |	httpResponse := HttpResponse code: 101."5.   The request MUST contain an |Upgrade| header field whose value MUST include the websocket keyword. The WS filter has already checked it"	httpResponse header: 'Upgrade' value: self upgradeToken."6.   The request MUST contain a |Connection| header field whose value MUST include the Upgrade token."	(httpRequest connection includes:  'upgrade')		ifTrue: [httpResponse header: 'Connection' value: 'Upgrade']		ifFalse: [  ^HandshakeError signalWith: (self badResponse: 'The request  |Connection| header field  must include Upgrade keyword' ) ]."7.   The request MUST include a header field with the name  |Sec-WebSocket-Key|.  The value of this header field MUST be a nonce consisting of a randomly selected 16-byte value that has been base64-encoded (see Section 4 of [RFC4648]).  The nonce MUST be selected randomly for each connection."		httpRequest wsKey			ifNil: [ ^HandshakeError signalWith: (self badResponse: 'The request MUST include a header field with the name  |Sec-WebSocket-Key|') ]			ifNotNil: [ :key |				"concatenate key with the GUID  258EAFA5-E914-47DA-95CA-C5AB0DC85B11 in a string form.  A  SHA-1 hash (160 bits), Base64-encoded , of this concatenation is echoed in the |Sec-WebSocket-Accept| header field"				httpResponse header: 'Sec-WebSocket-Accept' value:  (SHA hash: key, self class webSocketGuid) asBase64String.			]."9.   The request MUST include a header field with the name |Sec-WebSocket-Version|.  The value of this header field MUST be 13."	httpRequest wsVersion = '13' ifFalse: [ 		 ^HandshakeError signalWith: ((self badResponse:  'The request Must include |Sec-WebSocket-Version|.  The value of this header field MUST be 13.')							header: 'Sec-WebSocket-Version' value: 13;							yourself) ].	httpRequest wsSubProtocols ifNotNil: [ :subProtocols |		self 			setSubProtocols: subProtocols 			forResponse: httpResponse ].		^httpResponse</body><body package="SiouX-WebSocket">setSubProtocols: requestProtocols forResponse: httpResponse"The request MAY include a header field with the name |Sec-WebSocket-Protocol|. If present, this value indicates one or more comma-separated subprotocol the client wishes to speak, ordered by preference.6.  If the response includes a |Sec-WebSocket-Protocol| header field and this header field indicates the use of a subprotocol that was not present in the client's handshake (the server has indicated a subprotocol not requested by the client), the client MUST _Fail the WebSocket Connection_."	| stream coll |	self subprotocols isEmpty ifTrue: [^self].	coll := OrderedCollection new.	requestProtocols do: [ :rp | (self subprotocols  includes: rp) ifTrue: [ coll add: rp]].	stream := String new writing.	coll 		do: [ :token | stream write: token]		separatedBy: [ stream put: $, ].	httpResponse header: 'Sec-WebSocket-Protocol' value: stream contents.</body></methods><methods><class-id>SiouX.WebSocket</class-id> <category>accessing</category><body package="SiouX-WebSocket">payloadLimit	^self settings at: #payloadLimit ifAbsentPut: [ self class payloadLimit ]</body><body package="SiouX-WebSocket">payloadLimit: anInteger	self class validatePayloadLimit: anInteger.	anInteger 		ifNil: [self settings removeKey: #payloadLimit ]		ifNotNil: [	self settings at: #payloadLimit put: anInteger ]</body><body package="SiouX-WebSocket">responder	^responder</body><body package="SiouX-WebSocket">responder: anObject	responder := anObject</body><body package="SiouX-WebSocket">subprotocols	^self settings at: #subprotocols ifAbsentPut: [self class subprotocols]</body><body package="SiouX-WebSocket">subprotocols: aCollection	self settings at: #subprotocols put: aCollection</body></methods><methods><class-id>SiouX.WebSocket</class-id> <category>upgrade</category><body package="SiouX-WebSocket">acceptsProtocolIdentifier: aCollection	^aCollection includes: self upgradeToken</body><body package="SiouX-WebSocket">upgradeRequest: aRequestContext		('GET' match: aRequestContext request method) 		ifFalse: [(aRequestContext response code: 400)				contents: (#CanUpgradeRequestsWithGET &lt;&lt; #www &gt;&gt; 'Can upgrade only requests with GET methods');				signalReady ].	"The server replies with opening handshake "	self handshake: aRequestContext.	"Handshake succeeded."	webSocketConnection := WebSocketConnection 							initializeWith: self 							responder: aRequestContext responder.</body><body package="SiouX-WebSocket">upgradeToken	^ 'websocket'</body></methods><methods><class-id>SiouX.WebSocket</class-id> <category>initialize-release</category><body package="SiouX-WebSocket">closingConnection	webSocketConnection ifNotNil: [ webSocketConnection stop ]</body></methods><methods><class-id>SiouX.WebSocket</class-id> <category>services</category><body package="SiouX-WebSocket">processRequest: aRequestContext	"Start processing frames"	webSocketConnection start.	connection persist: false</body></methods><methods><class-id>SiouX.WebSocket class</class-id> <category>defaults</category><body package="SiouX-WebSocket">maxPayloadLimit"Maximum payload limit; default is 33554432 bytes (32 MB) "	^32 * 1024 * 1024</body><body package="SiouX-WebSocket">payloadLimit"Maximum payload limit; default is 33554432 bytes (32 MB) "	^payloadLimit ifNil: [ Xtreams.DefaultBufferSize ]</body><body package="SiouX-WebSocket">payloadLimit: aNumber	self validatePayloadLimit: aNumber.	payloadLimit := aNumber</body><body package="SiouX-WebSocket">subprotocols	^subprotocols ifNil: [ OrderedCollection new ]</body><body package="SiouX-WebSocket">subprotocols: aCollection	subprotocols := aCollection</body><body package="SiouX-WebSocket">validatePayloadLimit: aNumber	aNumber ifNil: [^nil].	aNumber &gt; self maxPayloadLimit ifTrue: [ self error: #WebSocketPayloadExceedMax &lt;&lt; #www &gt;&gt; 'The number exceeds WebSocket max payload limit'].</body></methods><methods><class-id>SiouX.WebSocket class</class-id> <category>accessing</category><body package="SiouX-WebSocket">webSocketGuid	^WebSocketGuid</body></methods><methods><class-id>SiouX.FragmentedWriteStream</class-id> <category>initialize-release</category><body package="SiouX-WebSocket">on: aDestination opcode: anInteger	super on: aDestination.	firstFragment := true.	fin := 02r00000000. "Assume the fragment is not final "	opcode := anInteger.</body><body package="SiouX-WebSocket">prepareToFlush	"Setting final fragment "	fin := 02r10000000.</body></methods><methods><class-id>SiouX.FragmentedWriteStream</class-id> <category>accessing</category><body package="SiouX-WebSocket">number: aNumber asByteArrayOfSize: byteSize	| payloadLength length |	payloadLength := ByteArray new: byteSize withAll: 0.	length := aNumber asBigEndianByteArray.	payloadLength		replaceElementsFrom: payloadLength size - length size + 1		to: payloadLength size		withByteArray: length		startingAt: 1.	^payloadLength</body><body package="SiouX-WebSocket">payloadLength: aNumber	" Payload length:  7 bits, 7+16 bits, or 7+64 bits"	aNumber &gt;= 126		ifTrue: 			[aNumber &lt; 65536				ifTrue: 					[self destination write: 126.					^self number: aNumber asByteArrayOfSize: 2]				ifFalse: 					[self destination write: 127.					^self number: aNumber asByteArrayOfSize: 8]].	^aNumber</body><body package="SiouX-WebSocket">write: anInteger from: aSequenceableCollection at: startIndex	| byte |	byte := firstFragment		ifTrue: [ "fin  / opcode" 				"Depending on the buffer size the first frame can be the last one and fin will be 02r10000000. the opcode has to be the message type  "				firstFragment := false.				opcode bitOr: fin ]		ifFalse: [ "fin  / opcode 				opcode has to be 02r00000000. %x0 denotes a continuation frame"				02r00000000 bitOr: fin ].	"Set frame type fin/opcode "	self destination write: byte.	" Set the frame length"	self destination write: (self payloadLength: anInteger).	"Write data "	super write: anInteger from: aSequenceableCollection at: startIndex.</body></methods><methods><class-id>SiouX.FragmentedWriteStream class</class-id> <category>instance creation</category><body package="SiouX-WebSocket">on: aDestination opcode: anInteger	^self new		on: aDestination opcode: anInteger;		yourself</body></methods><methods><class-id>SiouX.WebSocketFilter</class-id> <category>accessing</category><body package="SiouX-WebSocket">payloadLimit	^payloadLimit ifNil: [ payloadLimit := self class payloadLimit ]</body><body package="SiouX-WebSocket">payloadLimit: aNumber	payloadLimit := aNumber</body><body package="SiouX-WebSocket">subprotocols	^subprotocols ifNil: [subprotocols := self class subprotocols]</body><body package="SiouX-WebSocket">subprotocols: aCollection	subprotocols := aCollection</body><body package="SiouX-WebSocket">upgradeToken	^ 'websocket'</body></methods><methods><class-id>SiouX.WebSocketFilter</class-id> <category>services</category><body package="SiouX-WebSocket">upgradeRequest: aRequestContext		(('GET' match: aRequestContext request method) 		and: [ aRequestContext request version = 'HTTP/1.1' ])		ifFalse: [(aRequestContext response code: 400)				contents: (#CanUpgradeOnlyRequestsWithGET &lt;&lt; #www &gt;&gt; 'Can upgrade only requests with GET methods and HTTP/1.1 version');				signalReady ].	WebSocketConnection upgradeRequest: aRequestContext filter: self.	aRequestContext response: nil.</body></methods><methods><class-id>SiouX.WebSocketFilter class</class-id> <category>defaults</category><body package="SiouX-WebSocket">payloadLimit"Maximum payload limit; default is 33554432 bytes (32 MB) "	^payloadLimit ifNil: [ 32 * 1024 * 1024]</body><body package="SiouX-WebSocket">payloadLimit: aNumber	payloadLimit := aNumber</body><body package="SiouX-WebSocket">subprotocols	^subprotocols ifNil: [ OrderedCollection new ]</body><body package="SiouX-WebSocket">subprotocols: aCollection	subprotocols := aCollection</body></methods><methods><class-id>SiouX.WebSocketFilter class</class-id> <category>accessing</category><body package="SiouX-WebSocket">toolListIcon	^Tools.GeneralIcons deprecationWarning</body></methods><methods><class-id>SiouX.HttpRequest</class-id> <category>accessing</category><body package="SiouX-WebSocket">wsKey		self  		headers: 'sec-websocket-key' 		do: [ :field | ^field body rest trimBlanks ].	^nil</body><body package="SiouX-WebSocket">wsSubProtocols		self  		headers: 'Sec-WebSocket-Protocol' 		do: [ :field | ^(field body rest tokensBasedOn: $,) collect: [:t | t trimBlanks ]].	^nil</body><body package="SiouX-WebSocket">wsVersion		self headers: 'sec-websocket-version' do: [ :field | ^field body rest ].	^nil</body></methods><methods><class-id>SiouX.Responder</class-id> <category>services</category><body package="SiouX-WebSocket">establishedWSConnection: wsConnection	"The message is sent right after the web socket connection finished handshake and ready to accept messages "</body><body package="SiouX-WebSocket">receivedWSControlFrame: aMessage connection: wsConnection"aMessage represents a control frame. The Close frame MAY contain a body (the 'Application data' portion of the frame) that indicates a reason for closing, such as an endpoint shutting down. Use aMessage&gt;&gt;data to see the close frame body"</body><body package="SiouX-WebSocket">receivedWSDataOn: aStream connection: wsConnection message: aMessage"Read application data from aStream aMessage - defines the data type: text or binaryAn example:	aMessage isText 		ifTrue: [ out := String new writing]		ifFalse: [self error: 'The message has to be text type'].	out write: aStream.	data := out contents."</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>ProtocolVersion</name><environment>Protocols</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection validateHostOriginBlock writeResponseBlock settings </inst-vars><class-inst-vars>validateHostOriginBlock </class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http</package></attributes></class><class><name>HttpRequest</name><environment>SiouX</environment><super>SiouX.HttpRequestPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method version transferEncoding contentLength connection url decodedPath </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><class><name>Responder</name><environment>SiouX</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>server exceptionPrinter path requestFilters url decodedPath </inst-vars><class-inst-vars>exceptionPrinter </class-inst-vars><imports>			private OS.*			</imports><category></category><attributes><package>SiouX-Server</package></attributes></class><class><name>ProtocolUpgradeFilter</name><environment>SiouX</environment><super>SiouX.RequestFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>validateHostOriginBlock </inst-vars><class-inst-vars>validateHostOriginBlock </class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><class><name>PositionWriteSubstream</name><environment>Xtreams</environment><super>Xtreams.WriteSubstream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Substreams</package></attributes></class></st-source>