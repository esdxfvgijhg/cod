<?xml version="1.0"?><st-source><!-- Name: AppeX-CoreNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: Deprecated.  Functionality has been split into  AppeX-Server and AppeX-Client.This package implements a Javascript/HTML5 web application framework, built on top of the SiouX HTTP server.An AppeX web application will usually consist of a mandatory Smalltalk server class that executes the server’s behavior in a Smalltalk image on a server host, and optional one or more Javascript classes which, although written in the Smalltalk IDE, are actually Javascript ‘class functions’ downloaded and executed by a web browser on a client machine.The AppeX web application framework is built using the SiouX HTTP server framework. For details regarding the setting up, configuring and maintaining SiouX servers and responders, please refer to documentation in the SiouX-Server package.The key classes that form the AppeX web application framework are the following:	Application	JavascriptCode	CoreCode	JavascriptClass	ApplicationClientTheir roles in the framework and their mutual relationships are briefly explained below, followed by a short "cookbook" on how to create a very simple web application using the AppeX framework.AppeX.Application	A subclass of SiouX.HttpResponder, from which it inherits its basic dispatching and request/response management behavior. It extends the dispatching mechanism by including automatic registration and lookup of services, and routing of individual HTTP requests to access commonly used types of resources such as HTML, CSS, XML, JSON, etc...	AppeX.Application is an abstract class that implements an 'application server' type of behavior. This behavior is all Smalltalk, and includes optional automatic management of session data from the client.	When writing HTML5 applications, as a minimum, developers have to create a subclass of AppeX.Application to handle server requests. The simplest kind of web application would be a single HTML page. For such applications, developers can override the default htmlDocument class method, or take advantage of AppeX’s ability to declare individual methods as HTML component builders by including a #head: or #body: pragma in a method body.	Modern web applications consist of more than a static web page. They commonly require rich client behavior or automatic management of session data residing in the client. To represent related session data on the server, AppeX uses instances of AppeX.Application subclasses. Each such instance is paired with an instance of SiouX.Session, providing transparent session tracking and data management. ApplicationClient	An abstract class that implements the 'application client' behavior. A concrete subclass will contain the Javascript code required to run a Javascript application in a web browser. ApplicationClient is a subclass of JavascriptClass (see below). If an AppeX web application requires client-side Javascript code, it will implement an ApplicationClient  subclass that is linked to the Application subclass via its applicationClientClass class method. See also ApplicationClient class comments for details. JavascriptCode	A class with 'nil' superclass, it implements abstract behavior for developing, maintaining and generating Javascript from within the Smalltalk IDE. Instances of JavascriptCode and its subclasses do not have useful Smalltalk behavior. Thus, they should never be instantiated by users. Note that the instance methods in JavascriptCode are treated as Javascript functions by the framework, and are emitted as Javascript code exactly the way they are written - no code generation is involved. This permits the AppeX framework to use any Javascript library the application requires, without the need for ‘translation’ from Smalltalk to Javascript.JavascriptClass	Subclass of JavascriptCode. This class represents a Javascript constructor function used to generate a 'class' in the web browser. The framework treats instance methods in JavascriptClass subclasses as Javascript functions and binds them to the constructor prototype on the client. Developers can write Object Oriented Javascript with class inheritance by implementing subclasses of JavascriptClass and including them in one of the Javascript libraries downloaded to the client. Effectively, JavascriptClass is equivalent to the Object class in the sense that each of its subclasses in the Smalltalk IDE are actually created as subclasses of Object on the client.  See JavascriptClass class comments for details.CoreCode	Subclass of JavascriptCode. This class generates the core javascript global objects used to build a web application. The code generated by CoreCode is emitted as AppeX.CoreCode.js and it must precede the loading of the application code itself. See CoreCode class comments for details.The following paragraphs contain a short tutorial for writing a simple 'Hello World!' web application.One of the motivations for developing the AppeX framework was to provide web developers with a seamless, transparent session management. However, not all web applications require session management. Here we describe three scenarios of how to write web applications that may or may not use sessions. The first scenario is very simple, and each subsequent scenario can build on the previous one.Scenario 1: Building a web application as a single, static HTML documentYou need a simple HTML document with some (small) parts dynamically generated. There is no session management, and no Javascript code is required to be run on the client machine. An example might be a cacheable jQuery mobile application, an HTML5 presentation created with impress.js, or a similar application where navigation occurs between the DOM elements of a single HTML document.*	Subclass Application, e.g., HelloWorld:	Smalltalk defineClass: #HelloWorld		superclass: #{AppeX.Application}		indexedType: #none		private: false		instanceVariableNames: ''		classInstanceVariableNames: ''		imports: ''		category: ''*	Implement HelloWorld class >> #applicationClientClass, to return nil. In order to ensure developers consciously decide on the type of the scenario they are building, this method must be implemented, as it is defined as subclass responsibility by the Application class.	HelloWorld class >> #applicationClientClass		^ nil*	Add class methods to HelloWorld to build the components of the HTML page. Use #head: and #body: pragmas to determine where the content should go and in which order. You can also use a #css: pragma to generate the style sheet for your HTML. The Application class comment describes the use of #head:, #body: and #htmlToken:, as well as the rest of the pragmas in more detail.	For example:	HelloWorld class >> #myBodyHelloWorld	<body: 100>	^ '<h1>Hello, World!</h1><p>Today is <b>{{weekday}}</b>.</p>'	HelloWorld class >> #getWeekday	<htmlToken: #weekday>	^ Date today weekday	HelloWorld class >> #defaultStyle	<css: 'defaultStyle.css'>	^ 'h1 {color:orange; text-align:center; }'	In the methods above, we have instructed the framework to insert an <h1> element into the <body>, and also provide access to a CSS resource (note that the #css: pragma argument must match the value of the 'href' attribute in the HTML snippet returned from Application class >> #headCssDefaultStyle). The arguments in the #head: and #body: pragmas are position indicators to allow ordering of the components within the document. And finally, the #htmlToken: pragma is used to expand the {{weekday}} template used in #myBodyHelloWorld.	At this point, if you evaluate 'HelloWorld htmlDocument', you should be able to see the full HTML document that will be generated for the client.	There is something missing: you have to add your application to a server in order to see the contents in a browser. You can do that manually with the SiouX server configuration tool, or instruct the system to do it programmatically when a new server is created. Here, we use the programmatic method:	*	Create a simple pragma configuration method for the creation of a server that will accept request for your web application. Extend the SiouX.Server class in a package of your choice, with a class method like the one below. You may have to use a port other than 8888 if it is already in use:	SiouX.Server class >> #myDemoServer: aServer		<server: 'My Server'>		aServer listenOn: 9999 for: HttpConnection*	Implement a pragma configuration method to set up a responder (an instance of HelloWorld) to be added to the server. The responder will dispatch requests with path matching the one in the path: argument of the pragma. Note that the path must start with a forward slash. An optional #position: pragma can be used in the same method to determine the relative position of the resulting responder in a server's responder collection. Where no #position: is specified, the value of zero is assumed. Lower position values come before higher values. Thus, responders declared with negative #position: values come before those without a #position: declaration, followed by those with positive #position: values. Declarations of the same #position: value will have undeterminate order.By convention, the examples provided in AppeX-Examples and other packages use #serverConfiguration method, but you can use any method name as long as it doesn't conflict with the AppeX framework. The only requirement is that the configuration method contains the #server:path: pragma.	HelloWorld class >> #serverConfiguration		<position: 100>	"this pragma is optional"		<server: 'My Server' path: '/hello-world.html'>*	Evaluate from a workspace:	(SiouX.Server id: 'My Server') startAt this point, you should be able to access this very simple application from your web browser, e.g.: http://localhost:9999/hello-world.html.Scneario 2: Building a web application content dynamically using JavascriptIn this scenario, we will use the framework to write some basic Javascript code, and have it build the page content on the fly. However, there is still no session management involved, and, like in Scenario1, all methods must be implemented on the class side of HelloWorld.*	Subclass ApplicationClient, e.g., HelloWorldClient:	Smalltalk defineClass: #HelloWorldClient		superclass: #{AppeX.ApplicationClient}		indexedType: #none		private: false		instanceVariableNames: ''		classInstanceVariableNames: ''		imports: ''		category: ''*	Change the HelloWorld class >> #applicationClientClass method to return HelloWorldClient:	applicationClientClass		^HelloWorldClient*	(optional) implement HelloWorld class >> #htmlTitle method to return a String that will be the title of the starting HTML page. It can be later changed programmatically by the Javascript code in HelloWorldClient.*	Delete the HelloWorld class >> #myBodyHelloWorld method - the content will be generated programmatically by Javascript code.*	Implement HelloWorld class method that returns the 'Hello World' greeting:		HelloWorld class >> #getGreeting			<plainText: 'getGreeting'>			^'Hello World!'*	Modify the #getWeekday you implemented in Scenario 1 to include a #plainText: pragma:		HelloWorld class >> #getWeekday			<htmlToken: #weekday>			<plainText: 'getWeekday'>			^ Date today weekday*	Implement HelloWorldClient instance method that will build the full HTML document. Note that you will write a Javascript function body (without the 'function' keyword). The JavascriptCompiler will translate the code below into an annotated method with #buildHtml selector that returns the full string of the function definition:		buildHtml() {			// Create an HTML <h1> element			var header = document.createElement("h1");			// Send a SYNCHRONOUS message named "getGreeting" to the server.			// The name of the message is the same as the #plainText: pragma argument in HelloWorldServer class >> #getGreeting method.			// On the server side, the method name and the pragma argument do not have to be the same.			var greeting =  this.messageToServer("getGreeting").object;			// Create an HTML text node and append it to the paragraph element.			header.appendChild(document.createTextNode(greeting));			// Append the header element to the document body			document.body.appendChild(header);			// Similar steps, with day of the week.			var paragraph = document.createElement("p");			var weekday = this.messageToServer("getWeekday").object;			paragraph.appendChild(document.createTextNode("Today is " + weekday + "."));			document.body.appendChild(paragraph);		}*	Refresh the browser at http://localhost:9999/hello-world.html to see a 'Hello World! greeting generated by your application.Scenario 3:In this scenario, we will add session management to your application. Note one important difference: when you write methods using one of the content generation pragmas (#html: #plainText: #css: #js: , etc), in a session-aware application these methods need to be put on the instance side of your application if they serve any session state specific data. Notice HelloWorld >> #getSessionId in the example below, and compare it with the #getGreeting and #getWeekday methods in the previous scenarios.*	Implement an INSTANCE method to return some session state. Here, we will simply return a sessionId attribute of the session:	HelloWorld >> #getSessionId	<plainText: 'getSessionId'>	^ self sessionId printString*	Append the following Javascript code to the end of the buildHtml() method in HelloWorldClient (take care to insert the code before the closing curly bracket):			// Append the session id.			paragraph = document.createElement("p");			var sessionId = this.messageToServer("getSessionId").object;			paragraph.appendChild(document.createTextNode("Session Id is " + sessionId + "."));			document.body.appendChild(paragraph);Now, if you open several tabs in your web browser, each of them should give you the same greeting and the day of the week, but each should have a different session id. As you can see, session management in AppeX is transparent to the developers. And if you leave the web browser tabs open for some time, they will notify you when the attached session expires.*	You can now stop and destroy your server:		(SiouX.Server id: 'My Server') releaseThese examples are quite simple and do not use any user interaction or session dependent behavior. The main goal is to show how a web application Client/Server class pair is created, how the service methods are implemented on the Smalltalk side, and how they are invoked from the Javascript client side.DbIdentifier: bear73DbTrace: 496508DbUsername: jkottDbVersion: 8.3 - 11DevelopmentPrerequisites: #(#(#any 'AppeX-Server' '') #(#any 'AppeX-Client' ''))DisregardedPrerequisites: #()PackageName: AppeX-CoreParcel: #('AppeX-Core')PrerequisiteDescriptions: #(#(#name 'AppeX-Server' #componentType #package) #(#name 'AppeX-Client' #componentType #package))PrerequisiteParcels: #(#('AppeX-Server' '') #('AppeX-Client' ''))PrintStringCache: (8.3 - 11,jkott)Version: 8.3 - 11Date: 3:30:53 PM June 30, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:30:53 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it></st-source>