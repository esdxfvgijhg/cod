<?xml version="1.0"?><st-source><!-- Name: SiouX-ServletNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: This package contains classes to implement Servlet support. Load SiouX-Servet-Demo to see a servlet example.DbIdentifier: bear73DbTrace: 494024DbUsername: tkoganDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'SiouX-Net-Http' '') #(#any 'WebSupport' '') #(#any 'Regex11' '') #(#any 'SiouX-Sessions' ''))PackageName: SiouX-ServletParcel: #('SiouX-Servlet')PrerequisiteDescriptions: #(#(#name 'SiouX-Net-Http' #componentType #package) #(#name 'WebSupport' #componentType #package) #(#name 'Regex11' #componentType #package) #(#name 'SiouX-Sessions' #componentType #package))PrerequisiteParcels: #(#('SiouX-Net-Http' '') #('WebSupport' '') #('Regex11' '') #('SiouX-Sessions' ''))PrintStringCache: (8.3 - 1,tkogan)Version: 8.3 - 1Date: 1:19:07 PM July 14, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jul17.2) of July 14, 2017 on July 14, 2017 at 1:19:07 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>HttpServlet</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>servletConfig </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Servlet</package></attributes></class><comment><class-id>SiouX.HttpServlet</class-id><body>This is the abstract superclass of all servlets, as specified by the Servlet specification.Instance Variables	servletConfig	&lt;ServletConfig&gt;	The ServletConfig for this servlet. See the Servlet specification for more details.</body></comment><class><name>SingleThreadModelServlet</name><environment>SiouX</environment><super>SiouX.HttpServlet</super><private>false</private><indexed-type>none</indexed-type><inst-vars>request response session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Servlet</package></attributes></class><comment><class-id>SiouX.SingleThreadModelServlet</class-id><body>This class provides an abstract superclass for servlets which implement the single thread model so that each servlet instance serves only a single request. This means that it can provide additional useful instance variables and/or methods on the servlet instance.Instance Variables	request	&lt;HttpServletRequest&gt;	the request info for this http request	response &lt;HttpServletResponse&gt;	the response for this http request	session	&lt;HttpSession&gt;	the session for this user</body></comment><class><name>LogicalURLManager</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>site catalog </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Servlet</package></attributes></class><comment><class-id>SiouX.LogicalURLManager</class-id><body>LogicalURLManager works in conjunction with WebSite and WebSiteConfiguration, maintianing the catalog of logical names and performing any necessary translation of URL path components.Instance Variables	catalog	&lt;Dictionary&gt;	a Dictionary of logical names (from configuration file)	site	&lt;Object&gt;	the associated Web site, or nil if associated with a WebSiteConfiguration</body></comment><class><name>Redirect</name><environment>SiouX</environment><super>SiouX.HttpServlet</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Servlet</package></attributes></class><comment><class-id>SiouX.Redirect</class-id><body>A servlet which redirects to a known URL set in a request attribute. Used internally for standard redirect operations, e.g. to default pages.</body></comment><class><name>HttpServletResponse</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>charSet locale bufferedStream httpResponse handler </inst-vars><class-inst-vars></class-inst-vars><imports>			private Net.*			</imports><category>Web Toolkit-SiouX-Servlet</category><attributes><package>SiouX-Servlet</package></attributes></class><comment><class-id>SiouX.HttpServletResponse</class-id><body>This class represents a response object, providing the union of the semantics of an SiouX-Servlet response and a Servlet HttpServletResponse.Instance Variables	bufferedStream	&lt;EncodedStream&gt;	If we're buffering, this is the buffer.	charSet	&lt;String&gt;	The name of the character set for our output. Defaults if nil.	handler &lt;ServletHandler&gt; The handler controlling execution of the overall request.	locale	&lt;Locale&gt;	The locale that governs formatting, character set, etc. for this response.	httpResponse	&lt;Net.HttpRespose&gt;	An internal representation of the request, on which some of the response's values are based.</body></comment><class><name>ServletHandler</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>request response session servletName servletClass servlet webSite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Servlet</package></attributes></class><comment><class-id>SiouX.ServletHandler</class-id><body>This is a subclass of HttpResponder which deals specifically with servlet requests.Instance Variables	request	&lt;HttpServletRequest&gt;	The request	response	&lt;HttpServletResponse&gt;	The response	servlet	&lt;HttpServlet&gt;	The servlet instance which we will run.	servletClass	&lt;Behavior&gt;	The servlet class	servletName	&lt;String&gt;	The name of the servlet	session	&lt;ServletSession&gt;	The session associated with this user.	webSite &lt;WebSite&gt; </body></comment><class><name>Echo</name><environment>SiouX</environment><super>SiouX.HttpServlet</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.*			</imports><category></category><attributes><package>SiouX-Servlet</package></attributes></class><comment><class-id>SiouX.Echo</class-id><body>Echo is a simple servlet to echo information received by the servlet.</body></comment><class><name>ServletConfig</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>context initParameters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Servlet</package></attributes></class><comment><class-id>SiouX.ServletConfig</class-id><body>This represents the ServletConfig, as defined in the Servlet specification. It applies to a specific web site (its application), and references the ServletContext for that application.Instance Variables	context			&lt;ServletContext&gt;	the associated ServletContext	initParameters	&lt;Dictionary&gt;	set of initialization parameters</body></comment><class><name>HttpServletRequest</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>httpRequest form query attributes handler cachedSession connection consumedPath unconsumedPath webSite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Servlet</package></attributes></class><comment><class-id>SiouX.HttpServletRequest</class-id><body>This class represents a request object, implementing the union of the semantics of the SiouX-Servlet Request object and the Servlet HttpServletRequest object.Instance Variables	attributes	&lt;Dictionary&gt;	description of attributes	form	&lt;(Dictionary of: (String | MimeEntity))&gt;	The form data (if any) passed with this request.	handler	&lt;ServletHandler&gt;	The handler governing execution of this web request.	query	&lt;(Dictionary of: String)&gt;		The query data (if any) passed with this request.	httpRequest	&lt;Net.HttpRequest&gt;	An internal representation upon which the request's variable values are based.	cachedSession &lt;Session&gt;	connection &lt;HttpConnection&gt;	consumedPath &lt;OrderedCollection of String&gt; consumed path	unconsumedPath &lt;OrderedCollection of String&gt; not processed path tokens	webSite &lt;WebSite&gt; to serve the request</body></comment><class><name>MissingServlet</name><environment>SiouX</environment><super>SiouX.HttpServlet</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Servlet</package></attributes></class><comment><class-id>SiouX.MissingServlet</class-id><body>This is a special servlet representing all servlets which could not be found. Rather than failing the lookup each time, we cache an instance of MissingServlet to efficiently report on their absence.Instance Variables	name	&lt;String&gt;	The name under which this was looked up.</body></comment><class><name>WebSiteCache</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>servletInstancesMutex servletInstances webSite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Servlet</package></attributes></class><comment><class-id>SiouX.WebSiteCache</class-id><body>This caches information for a particular web site.Instance Variables	servletInstances	&lt;(Dictionary of: HttpServlet)&gt;	 All servlet instances which have been instantiated to date. For "normal" servlets, all requests will go through the particular instance. For the badly named "single thread model" we will copy the instance.	servletInstancesMutex	&lt;Semaphore&gt;	Concurrent access protection for the collection of servlet instances.	webSite	&lt;WebSite&gt;	The site which holds this cache.</body></comment><class><name>ServletContext</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>site servletName config </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Servlet</package></attributes></class><comment><class-id>SiouX.ServletContext</class-id><body>This represents the ServletContext, as defined in the Servlet specification.	Storing data in the ServletContext, as opposed to using instance variables in the servlet	allows context to be shared by all servlets served by a single site.Instance Variables	servletName	&lt;String&gt;		config		&lt;ServletConfig&gt;	the associated ServletConfig	site			&lt;WebSite&gt;	the associated WebSite</body></comment><class><name>ServletResponder</name><environment>SiouX</environment><super>SiouX.NetHttpResponder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>virtualDirectories responseClass requestClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Servlet</package></attributes></class><comment><class-id>SiouX.ServletResponder</class-id><body>ServletResponder is a responder for Servlet applicationsInstance Variables	requestClass	&lt;HttpServletRequest&gt;	servlet request	responseClass	&lt;HttpServetResponse&gt;	servlet response	virtualDirectories	&lt;List&gt;	collection of virtual directories</body></comment><class><name>WebSiteConfiguration</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sites urlManager configFileName configParameters </inst-vars><class-inst-vars>globalConfiguration defaultEncoding shouldSetEncodingFromRequest shouldSetLocaleFromRequest allowSettingConfigFileName globalConfigFileName </class-inst-vars><imports>			private Kernel.*			private OS.*			</imports><category></category><attributes><package>SiouX-Servlet</package></attributes></class><comment><class-id>SiouX.WebSiteConfiguration</class-id><body>This represents a configuration of a particular group of web sites and associated global information.The singleton configuration instance is cached on this class.  Lazy initialization of the Application Server occurs in #siteFor: on receipt of the first request, if it is not explicitly configured by your application code before that time.  Until the Application Server is configured, any requests for the globalConfiguration will receive an error.Instance Variables	configFileName	&lt;String&gt;	the file name of the configuration file containing the global configuration information	configParameters	&lt;Dictionary&gt;	name/value pairs from the global configuration file	sites	&lt;OrderedCollection of: WebSite&gt;	the collection of web sites in this configuration	urlManager	&lt;LogicalUrlManager&gt;		the object responsible for translating replacable url path components at the global levelClass Instance Variables	globalConfiguration	&lt;WebSiteConfiguration&gt;	the cached singleton instance of WebSiteConfiguration	defaultEncoding &lt;Symbol&gt; default encoding, if not provided #'iso-8859-1'	shouldSetEncodingFromRequest &lt;Boolean&gt; by default is true	shouldSetLocaleFromRequest &lt;Boolean&gt; by default is true	allowSettingConfigFileName &lt;Boolean&gt; This handles setting the server configuration file name from the command line.	globalConfigFileName &lt;String&gt; default configuration file name</body></comment><class><name>Herald</name><environment>SiouX</environment><super>SiouX.HttpServlet</super><private>false</private><indexed-type>none</indexed-type><inst-vars>heraldBits </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.*			</imports><category></category><attributes><package>SiouX-Servlet</package></attributes></class><comment><class-id>SiouX.Herald</class-id><body>Herald 	is a simple servlet to store the Cincom Smalltalk logo for use in the Administrator's web interface.	There is a simple internal graphic which is used in the event the logo file "wtklogo.gif"	cannot be found in the current working directory.  	To use the logo file graphic in the	Administrator's web interface, copy the file to your current working directory - usually	the directory in which you start your image.	Once you have visited the Administrator's web interface, the graphic has been 	found/used, and it is stored for future reference.  If you want to copy the logo	file to your working directory (or use your own file in its place), after you have 	configured a Development image, you can clear caches and the new graphic 	will immediately be used.	A deployment image will always pick up and store the graphic on startup, since 	there are no servlets already instantiated.Instance Variables	heraldBits	&lt;ByteArray&gt;	contents of the currently used graphic</body></comment><class><name>WebSite</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name configFileName homeDirectory environment urlManager sitePolicy cache parentConfiguration sessionCache configParameters contents </inst-vars><class-inst-vars></class-inst-vars><imports>			OS.URI			private Protocols.*			</imports><category></category><attributes><package>SiouX-Servlet</package></attributes></class><comment><class-id>SiouX.WebSite</class-id><body>Class WebSite is the web site (or logical application context) within which the application server serves content to the web browser.Instance Variables	cache	&lt;WebSiteCache&gt;	cache of Java-style servlet instances in use by this web site	configFileName	&lt;String&gt;	the name of the configuration file 	configParameters	&lt;Dictionary&gt; name/value pairs from the configuration file	configurationError	&lt;Boolean&gt;	indicates whether or not the web site had a configuration error	environment	&lt;Namespace&gt;	the name space in which this application is defined	homeDirectory	&lt;Filename&gt;	the resolved Filename for the site's home directory					(may or may not actually exist)	name	&lt;String&gt;	unique web site name	parentConfiguration	&lt;WebSiteConfiguration&gt; the site's parent configuration	sessionCache	&lt;SessionCache&gt;	registry of sessions in use by this web site	sitePolicy	&lt;WebSitePolicy&gt;	manages domain and alias properties of the web site	urlManager	&lt;LogicalURLManager&gt;	handles translation of logical names in the request path	contents  &lt;SharedRegistry&gt; holds the web site keys</body></comment><class><name>WebSitePolicy</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>site domains aliases </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Servlet</package></attributes></class><comment><class-id>SiouX.WebSitePolicy</class-id><body>WebSitePolicy implements the web site's ability to respond to requests using an alias or domain. Aliases and domains are specified in the web site's configuration file, as a semi-colon delimited list. 	By default, the site's aliases include the site name.  If you specify aliases for your site, you must include the site's name if you wish to use it in a URL.Instance Variables	aliases		&lt;SequenceableCollection&gt;	collection of alternate site names	domains	&lt;SequenceableCollection&gt;	collection of applicable site domains	site			&lt;WebSite&gt;	the parent web site</body></comment><class><name>ServletSession</name><environment>SiouX</environment><super>SiouX.Session</super><private>false</private><indexed-type>none</indexed-type><inst-vars>webSite </inst-vars><class-inst-vars></class-inst-vars><imports>			private Protocols.*			</imports><category></category><attributes><package>SiouX-Servlet</package></attributes></class><comment><class-id>SiouX.ServletSession</class-id><body>This represents a Servlet session. Instance Variables	webSite	&lt;WebSite&gt;	The web site with which this data is associated.</body></comment><methods><class-id>SiouX.HttpServlet</class-id> <category>accessing</category><body package="SiouX-Servlet">getInitParameter: aString	^servletConfig getInitParameter: aString.</body><body package="SiouX-Servlet">getInitParameterNames	^servletConfig getInitParameterNames.</body><body package="SiouX-Servlet">linkNamed: urlString	^ self error: (#errNoLinkNamed &lt;&lt; #www &gt;&gt; '#linkNamed: not available from HttpServlet. Send to the request or response, or use a SingleThreadModelServlet instead.').</body><body package="SiouX-Servlet">resourcePath	^ self class fullName.</body><body package="SiouX-Servlet">servletConfig	^servletConfig.</body><body package="SiouX-Servlet">servletContext	^servletConfig servletContext.</body><body package="SiouX-Servlet">servletInfo	^''.</body><body package="SiouX-Servlet">servletName	^self servletConfig servletName.</body><body package="SiouX-Servlet">webSite	^self servletContext webSite.</body></methods><methods><class-id>SiouX.HttpServlet</class-id> <category>subclass responsibility</category><body package="SiouX-Servlet">destroy	self release</body><body package="SiouX-Servlet">doGet: aRequest response: aResponse	^aResponse code: '501'</body><body package="SiouX-Servlet">doPost: aRequest response: aResponse	^aResponse code: '501'</body><body package="SiouX-Servlet">init</body><body package="SiouX-Servlet">init: aServletConfig	servletConfig := aServletConfig.	self initialize.</body><body package="SiouX-Servlet">initialize	self init.  "In case someone implements the java-style initialize method name, call it"</body><body package="SiouX-Servlet">service: aServletRequest response: aServletResponse	| method |	method := aServletRequest method.	"A nil method shouldn't happen from a browser, but can if we're getting input from a gateway that's run standalone. To ease standalone testing, pretend it's a GET if undefined"	(method = 'GET' or: [method isNil]) ifTrue: [^self doGet: aServletRequest response: aServletResponse].	method = 'POST' ifTrue: [^self doPost: aServletRequest response: aServletResponse].	method = 'PUT' ifTrue: [^self doPut: aServletRequest response: aServletResponse].	method = 'DELETE' ifTrue: [^self doDelete: aServletRequest response: aServletResponse].	method = 'OPTIONS' ifTrue: [^self doOptions: aServletRequest response: aServletResponse].	method = 'TRACE' ifTrue: [^self doTrace: aServletRequest response: aServletResponse].	method = 'HEAD' ifTrue:	[^self doHead: aServletRequest response: aServletResponse].	aServletResponse sendError: '501' message: 'Method not implemented'.</body></methods><methods><class-id>SiouX.HttpServlet</class-id> <category>private</category><body package="SiouX-Servlet">doDelete: aRequest response: aResponse	^aResponse code: '501'</body><body package="SiouX-Servlet">doHead: aRequest response: aResponse	^aResponse code: '501'</body><body package="SiouX-Servlet">doOptions: aRequest response: aResponse	^aResponse code: '501'</body><body package="SiouX-Servlet">doPut: aRequest response: aResponse	^aResponse code: '501'</body><body package="SiouX-Servlet">doTrace: aRequest response: aResponse	^aResponse code: '501'</body></methods><methods><class-id>SiouX.HttpServlet class</class-id> <category>querying</category><body package="SiouX-Servlet">singleThreadModel	"According to the spec, normally there is only ever one instance of a particular servlet class, and it has multi-threaded access. This is why there are few useful methods on the servlet instance, and most must be directed to the request or response.    If the servlet implements the SingleThreadModel interface, then the server is allowed to create multiple instances, but by default this is false"	^false.</body></methods><methods><class-id>SiouX.SingleThreadModelServlet</class-id> <category>accessing</category><body package="SiouX-Servlet">handler	^response handler.</body><body package="SiouX-Servlet">linkNamed: urlString	^ self response linkNamed: urlString.</body><body package="SiouX-Servlet">out	^response responseStream.</body><body package="SiouX-Servlet">parameters	^request parameters.</body><body package="SiouX-Servlet">request	^request</body><body package="SiouX-Servlet">request: aRequest	request := aRequest.</body><body package="SiouX-Servlet">response	^response</body><body package="SiouX-Servlet">response: aResponse	response := aResponse.</body><body package="SiouX-Servlet">session	^session.</body><body package="SiouX-Servlet">session: aSession	session := aSession.</body><body package="SiouX-Servlet">webSite	^request webSite.</body></methods><methods><class-id>SiouX.SingleThreadModelServlet</class-id> <category>subclass responsibility</category><body package="SiouX-Servlet">doDelete	"Because we already know the request and response, we can call a simpler method with no parameters. If that method is not supplied, call the default"	^self doDelete: request response: response.</body><body package="SiouX-Servlet">doGet	"Because we already know the request and response, we can call a simpler method with no parameters. If that method is not supplied, call the default"	^self doGet: request response: response.</body><body package="SiouX-Servlet">doHead	"Because we already know the request and response, we can call a simpler method with no parameters. If that method is not supplied, call the default"	^self doHead: request response: response.</body><body package="SiouX-Servlet">doOptions	"Because we already know the request and response, we can call a simpler method with no parameters. If that method is not supplied, call the default"	^self doOptions: request response: response.</body><body package="SiouX-Servlet">doPost	"Because we already know the request and response, we can call a simpler method with no parameters. If that method is not supplied, call the default"	^self doPost: request response: response.</body><body package="SiouX-Servlet">doPut	"Because we already know the request and response, we can call a simpler method with no parameters. If that method is not supplied, call the default"	^self doPut: request response: response.</body><body package="SiouX-Servlet">doTrace	"Because we already know the request and response, we can call a simpler method with no parameters. If that method is not supplied, call the default"	^self doTrace: request response: response.</body></methods><methods><class-id>SiouX.SingleThreadModelServlet</class-id> <category>redirect</category><body package="SiouX-Servlet">redirectTo: aURI	response redirectTo: aURI.</body></methods><methods><class-id>SiouX.SingleThreadModelServlet</class-id> <category>private</category><body package="SiouX-Servlet">service: aServletRequest response: aServletResponse	| method |	request := aServletRequest.	response := aServletResponse.	session := request session.	method := aServletRequest method.	method = 'GET' ifTrue: [^self doGet].	method = 'POST' ifTrue: [^self doPost].	method = 'PUT' ifTrue: [^self doPut].	method = 'DELETE' ifTrue: [^self doDelete].	method = 'OPTIONS' ifTrue: [^self doOptions].	method = 'TRACE' ifTrue: [^self doTrace].	method = 'HEAD' ifTrue: [^self doHead].	aServletResponse sendError: '501' message: 'Method not implemented'.</body></methods><methods><class-id>SiouX.SingleThreadModelServlet class</class-id> <category>querying</category><body package="SiouX-Servlet">singleThreadModel	"According to the spec, normally there is only ever one instance of a particular servlet class, and it has multi-threaded access. This is why there are few useful methods on the servlet instance, and most must be directed to the request or response.    If the servlet implements the SingleThreadModel interface, then the server is allowed to create multiple instances, but by default this is false"	^true.</body></methods><methods><class-id>SiouX.LogicalURLManager</class-id> <category>accessing</category><body package="SiouX-Servlet">catalog	^catalog ifNil: [ catalog := Dictionary new ].</body><body package="SiouX-Servlet">parentURLManager	^ self site ifNotNil: [:s | s parentConfiguration ifNotNil: [ :cfg | cfg urlManager ] ].</body><body package="SiouX-Servlet">site	^ site</body><body package="SiouX-Servlet">site: aSite	site := aSite.</body></methods><methods><class-id>SiouX.LogicalURLManager</class-id> <category>initialize-release</category><body package="SiouX-Servlet">addInternalLogicalNames	"Add to configure siteCatalog from internal dictionary of logical names.		Retain original values from the configuration file in case of duplicate names."	self catalog 		at: 'herald' put: 'servlet/Herald';		at:  'redirectServlet' put: 'servlet/Redirect'.</body><body package="SiouX-Servlet">addInternalLogicalNames: aDictionary	"Add to siteCatalog from internal dictionary of logical names.		Retain original values from the configuration file in case of duplicate names."	aDictionary keysAndValuesDo: [ :key :val |		self catalog at: key ifAbsentPut: [ val ] ].</body><body package="SiouX-Servlet">initializeFrom: config	config keysAndValuesDo: [ :key :val |		self catalog at: key put: val ].</body></methods><methods><class-id>SiouX.LogicalURLManager</class-id> <category>actions</category><body package="SiouX-Servlet">fullyTranslateCollection: aCollection	"Return the translation, translating recursively if necessary, and splitting the result into a path collection"	|result |		result := OrderedCollection new.	aCollection do: [:each |		result addAll: (self fullyTranslateLink: each)].	^result.</body><body package="SiouX-Servlet">fullyTranslateLink: aString	"Return the translation, translating recursively if necessary, and splitting the result into a path collection"	| newName |	newName := self translateLink: aString.	newName = aString ifTrue: [^OrderedCollection with: aString].	^self splitString: newName</body><body package="SiouX-Servlet">splitString: aString	| result |	result := OrderedCollection new.	(aString tokensBasedOn: $/) do: [:each |		result addAll: (each tokensBasedOn: $\)].	^result reject: [ :each | each isEmpty ].</body><body package="SiouX-Servlet">translateLink: aString 	"If there is a translation at this or a higher level (even if it is an empty string)		return the first translation found,		otherwise return the original string."	^ self catalog at: aString		ifAbsent: 			[self parentURLManager				ifNotNil: [:parent | parent translateLink: aString]				ifNil: [aString]].</body></methods><methods><class-id>SiouX.Redirect</class-id> <category>executing</category><body package="SiouX-Servlet">doGet: aRequest response: aResponse	| url |	url := aRequest getParameter: 'url'.	url isNil ifTrue: [		aResponse write: '&lt;HTML&gt;&lt;BODY&gt;', 			((#CantRedirectMissingUrl &lt;&lt; #www &gt;&gt; 'Cannot redirect, no url provided.') asString),			 '&lt;/BODY&gt;&lt;HTML&gt;'.		^self].	aResponse redirectTo: url.</body></methods><methods><class-id>SiouX.HttpServletResponse</class-id> <category>accessing</category><body package="SiouX-Servlet">characterEncoder	"Return the name of the character encoding which is used for the output stream. Note that this is currently a Smalltalk-style encoding name, which may not correspond to the name the browser recognizes"	^self responseStream encoder encoding.</body><body package="SiouX-Servlet">contentIsText	"Return true if this is a text-type content"	^self contentType type = 'text'</body><body package="SiouX-Servlet">defaultContentType	^(Net.ContentTypeField  contentType: 'text/html') charset: self outputEncoding</body><body package="SiouX-Servlet">handler: aServletHandler	handler := aServletHandler</body><body package="SiouX-Servlet">header: aString	^httpResponse fieldAt: aString.</body><body package="SiouX-Servlet">headerAt: aString	^(self header: aString) value.</body><body package="SiouX-Servlet">httpResponse	^httpResponse</body><body package="SiouX-Servlet">request	^handler request.</body><body package="SiouX-Servlet">responseStream	^bufferedStream ifNil: [self setUpBuffer]</body><body package="SiouX-Servlet">responseStream: aStream	bufferedStream := aStream.</body><body package="SiouX-Servlet">session	^handler session.</body><body package="SiouX-Servlet">webSite	^handler webSite.</body></methods><methods><class-id>SiouX.HttpServletResponse</class-id> <category>api</category><body package="SiouX-Servlet">addCookie: aSetCookieValue"	header := SetCookieValue name: 'Customer' value: 'WILE_E_COYOTE'.	header 		secure: true;		domain: 'cincom.com';		maxAge: 0;		comment: 'some comments'."	(httpResponse fieldAt: 'set-cookie' ifAbsentPut: [ Net.SetCookieField new]) addValue: aSetCookieValue</body><body package="SiouX-Servlet">addDateHeader: aString value: aDate	httpResponse date:  aDate.</body><body package="SiouX-Servlet">addHeader: aString value: value	"Add a header with the given value to the set of headers written for this page. If this is invoked after the headers have already been sent to the client, then this will have no effect. Note that headers can have multiple values, and are case-insensitive"	(httpResponse fieldValueAt: aString asLowercase ifAbsent: [ nil ]) ifNotNil: [ :field |		httpResponse removeField: field ].	httpResponse  addField: (Net.HeaderField readFrom: (aString, ': ', value) readStream)</body><body package="SiouX-Servlet">addIntHeader: aString value: anInt	"Nothing special required. This is Smalltalk"	self addHeader: aString value: anInt printString.</body><body package="SiouX-Servlet">cacheControl	"Set this to 'Public' to allow proxy servers to cache the page, or 'Private' to prevent it. The default is Private"	^httpResponse cacheControl ifNil: [(httpResponse getFieldAt: 'cache-control') addDirective: 'Private']</body><body package="SiouX-Servlet">cacheControl: aString	"Set this to 'Public' to allow proxy servers to cache the page, or 'Private' to prevent it. The default is Private"	httpResponse cacheControl:  aString</body><body package="SiouX-Servlet">charSet	"Return the character set which will be used in the content-type header, e.g. ISO-8859-1"	^charSet.</body><body package="SiouX-Servlet">charSet: aString	"Set the character set which will be used in the content-type header, e.g. ISO-8859-1, and the encoding we will use."	charSet = aString asLowercase ifTrue: [^self].	charSet := aString asLowercase.</body><body package="SiouX-Servlet">characterEncoding	"Return the name of the character encoding which is used for the output stream. Note that this is currently a Smalltalk-style encoding name, which may not correspond to the name the browser recognizes"	^self responseStream encoding asString.</body><body package="SiouX-Servlet">containsHeader: aString	^(httpResponse fieldAt: aString) notNil</body><body package="SiouX-Servlet">contentType	^httpResponse 		fieldAt: 'content-type' 		ifAbsentPut: [ httpResponse fieldAt: 'content-type' ifAbsent: [ self defaultContentType ] ]</body><body package="SiouX-Servlet">contentType: aString	"Set the MIME content type for the result, e.g. text/html"	httpResponse 		fieldAt: 'content-type' 		put: (Net.ContentTypeField  contentType: aString)</body><body package="SiouX-Servlet">cookieAt: keyString	"Return the first cookie which has been set in this response for the given key"	^httpResponse setCookie 		ifNotNil: [ :cookie | cookie values detect: [:each | each name = keyString] ifNone: [nil]].</body><body package="SiouX-Servlet">cookieAt: keyString put: valueString 	"Add a cookie to the headers with the given key and value strings. Since multiple cookie values are allowed, this will simply add a cookie, supplementing any information which is already there for that key. We do not automatically set the domain for the cookie, but rely on the client to do so. 	If you wish to set the domain explicitly, use the addCookie: API directly.	This must be done before any headers have been written the client or there will be no effect"	(self cookieAt: keyString)		ifNil: [ self addCookie: (Net.SetCookieValue name: keyString value: valueString ) ]		ifNotNil: [ :cookie | cookie value value: valueString]</body><body package="SiouX-Servlet">cookies	"Return the collection of HttpCookie objects which are to be sent to the client"	^httpResponse fieldAt: 'set-cookie'</body><body package="SiouX-Servlet">encoding	^self charSet.</body><body package="SiouX-Servlet">encoding: aString	self charSet: aString.</body><body package="SiouX-Servlet">expires	"Return the value set for the expires header. This can be either the number of minutes from the present that it will expire, or a string or timestamp representing the absolute time"	^httpResponse expires</body><body package="SiouX-Servlet">expires: aTimestampOrStringOrArray	"Set the number of minutes after which this page should expire (this value will be written into the Expires header). This will also accept a string value or a timestamp to directly set the expiry header"	httpResponse expires: aTimestampOrStringOrArray.</body><body package="SiouX-Servlet">expiresAbsolute	"Return the absolute date/time after which this page should expire. This might be a string (representing a timestamp) or a timestamp"	| expires |	expires := httpResponse expires.	expires respondsToArithmetic ifTrue: [httpResponse expires: (Timestamp now addSeconds: (60 * expires))].	^httpResponse expires.</body><body package="SiouX-Servlet">expiresAbsolute: aTimestamp	"Set the absolute date/time after which this page should expire (in GMT)"	httpResponse expires: aTimestamp.</body><body package="SiouX-Servlet">locale	| session |	^locale isNil		ifTrue:			[session := self session.			session isNil				ifTrue: [Locale current]				ifFalse: [session locale]]		ifFalse: [locale].</body><body package="SiouX-Servlet">locale: aLocale	locale := aLocale.</body><body package="SiouX-Servlet">redirectTo: aURI 	"Tell the browser to redirect to another page. 	Note that this only sets the headers to force a redirection. 	Other output will still be displayed in the browser, and some browsers may not support redirect.	Unless this is an absolute URL, it is relative to the browser's current location."	httpResponse statusCode: '302'.	httpResponse location: aURI</body><body package="SiouX-Servlet">sendError: statusCode	self status: statusCode.</body><body package="SiouX-Servlet">sendError: statusCode message: aString	self sendError: statusCode.	self write: aString.</body><body package="SiouX-Servlet">sendRedirect: aURLString	self redirectTo: aURLString.</body><body package="SiouX-Servlet">setHeader: aString value: value	self addHeader: aString value: value</body><body package="SiouX-Servlet">status	"Return the http status which is to be sent to the client (e.g. 200, 404)"	^httpResponse code</body><body package="SiouX-Servlet">status: anInteger	"Set the http status which is to be sent to the client (e.g. 200, 404). The default value is 200, for a successful request."	httpResponse statusCode: anInteger printString.</body><body package="SiouX-Servlet">write: anObject	anObject isNil ifTrue: [^self].	self responseStreamPut: anObject.</body><body package="SiouX-Servlet">writeTag: aString	self write: '&lt;', aString, '&gt;'.</body></methods><methods><class-id>SiouX.HttpServletResponse</class-id> <category>private-headers</category><body package="SiouX-Servlet">addMissingHeader: aString value: anObject	(self headerAt: aString) isNil ifFalse: [^self].	self addHeader: aString value: anObject.</body><body package="SiouX-Servlet">allHeadersAt: aString	^httpResponse fieldsAt: aString</body><body package="SiouX-Servlet">hasHeader: aString 	^(httpResponse fieldAt: aString) notNil</body><body package="SiouX-Servlet">headers	^httpResponse header.</body><body package="SiouX-Servlet">outputEncoding	"Return a character encoding. If one has been set in the session, use it. If not, use one that the request set as acceptable, and set the session locale. If we don't have a valid request (which probably means we're a test case) just return a default"	^charSet		ifNil:			[| session |			session := self session.			session isNil				ifTrue: [WebSiteConfiguration defaultEncoding]				ifFalse: [session encoding]].</body><body package="SiouX-Servlet">setUpBuffer	| encoding |	encoding := self outputEncoding.	bufferedStream := ((ByteArray new: 500) withEncoding: encoding) 	readWriteStream.	bufferedStream lineEndConvention:  IOConstants.LineEndCRLF.	^ bufferedStream.</body></methods><methods><class-id>SiouX.HttpServletResponse</class-id> <category>streaming</category><body package="SiouX-Servlet">cr	self responseStream cr.</body><body package="SiouX-Servlet">print: anObject	anObject printOn: self responseStream.</body><body package="SiouX-Servlet">responseStreamPut: content	"Put the content into the stream. Avoid doing unnecessary sets to text mode, and if we are buffering, we may have to create new streams"	self setupStreamForContentType: content.	self responseStream nextPutAll: content.	self responseStream isBinary ifTrue: [self responseStream text].</body><body package="SiouX-Servlet">space	self responseStream space.</body></methods><methods><class-id>SiouX.HttpServletResponse</class-id> <category>initialize-release</category><body package="SiouX-Servlet">addCookieHeader	| cookieName |	cookieName := handler webSite sessionCookieName.	(self request cookieValueAt: cookieName)		ifNil: [self cookieAt: cookieName put: self session id ]</body><body package="SiouX-Servlet">forbidden: aURL	|  stream |	httpResponse code: '403'.	stream := String new writeStream. 	stream 		nextPutAll: '&lt;!DOCTYPE html&gt;';		cr;		nextPutAll: '&lt;html&gt;&lt;head&gt;&lt;title&gt;';		nextPutAll: '403';		nextPutAll: '&lt;/title&gt;&lt;/head&gt;';		cr;		nextPutAll: '&lt;body&gt;&lt;h1&gt;';		nextPutAll: 'Forbidden&lt;/h1&gt;';		nextPutAll: ((#HtmlForbiddenAccessError &lt;&lt; #www &gt;&gt; 						'Access to the requested page "&lt;1p&gt;" was forbidden.')							expandMacrosWith: aURL printString );		cr;		nextPutAll: '&lt;/body&gt;&lt;/html&gt;'.	httpResponse contents: stream contents.	^httpResponse</body><body package="SiouX-Servlet">initialize</body><body package="SiouX-Servlet">on: anHttpResponse	httpResponse := anHttpResponse</body><body package="SiouX-Servlet">setResponseContents	self setUpHeaders.	httpResponse contents: self responseStream reset.	^httpResponse</body><body package="SiouX-Servlet">setUpHeaders	httpResponse 		fieldAt: 'content-type' 		ifAbsentPut: [ httpResponse fieldAt: 'content-type' ifAbsent: [ self defaultContentType ]].	self cacheControl value first key asLowercase = 'public'		ifFalse: 			[self cacheControl: (Net.CacheControl name: 'cache-control') addNoCache.			self expires: '-1'.			self addHeader: 'Pragma' value: 'no-cache'].	self addHeader: 'MIME-version' value: '1.0'.	self session ifNotNil: [self addCookieHeader	"send the session cookie" ].</body></methods><methods><class-id>SiouX.HttpServletResponse</class-id> <category>private</category><body package="SiouX-Servlet">contents	^bufferedStream contents</body><body package="SiouX-Servlet">handler	^handler</body><body package="SiouX-Servlet">reset"For backward compatibility "</body><body package="SiouX-Servlet">server	^self request server.</body><body package="SiouX-Servlet">setupStreamForContentType: aStringOrByteArray	| stream |	stream := self responseStream.	aStringOrByteArray isString		ifTrue: [stream isBinary ifTrue: [stream text]]		ifFalse: [stream binary].</body></methods><methods><class-id>SiouX.HttpServletResponse</class-id> <category>printing</category><body package="SiouX-Servlet">printOn: aStream	httpResponse		ifNil: [super printOn: aStream]		ifNotNil: [ httpResponse printOn: aStream]</body></methods><methods><class-id>SiouX.HttpServletResponse</class-id> <category>testing</category><body package="SiouX-Servlet">isSuccess	^httpResponse isSuccess</body></methods><methods><class-id>SiouX.HttpServletResponse class</class-id> <category>instance creation</category><body package="SiouX-Servlet">new	^super new initialize</body><body package="SiouX-Servlet">on: anHttpResponse	^self new		on: anHttpResponse;		yourself</body></methods><methods><class-id>SiouX.ServletHandler</class-id> <category>accessing</category><body package="SiouX-Servlet">environment	| site |	site := self webSite.	^self webSite isNil ifTrue: [Root.Smalltalk] ifFalse: [site environment]</body><body package="SiouX-Servlet">request	^request</body><body package="SiouX-Servlet">response: aResponse	response := aResponse</body><body package="SiouX-Servlet">servlet	^servlet ifNil: [servlet := self servletInstance].</body><body package="SiouX-Servlet">servletClass	^servletClass ifNil: [servletClass := self environment										at: self servletName										ifAbsent: [MissingServlet ]]</body><body package="SiouX-Servlet">servletClass: aClass	servletClass := aClass.</body><body package="SiouX-Servlet">servletName	^servletName ifNil: [self getNameFromPath].</body><body package="SiouX-Servlet">servletName: aString	servletName := aString.</body><body package="SiouX-Servlet">session	^session.</body><body package="SiouX-Servlet">session: anHttpSession	session := anHttpSession.</body><body package="SiouX-Servlet">webSite	^webSite</body><body package="SiouX-Servlet">webSite: aWebSite	webSite := aWebSite</body></methods><methods><class-id>SiouX.ServletHandler</class-id> <category>servlet management</category><body package="SiouX-Servlet">missingServletFor: aString	^MissingServlet new name: aString.</body><body package="SiouX-Servlet">newServlet	| class instance |	class := self servletClass.	(class isNil or: [class isBehavior not]) ifTrue: [ ^self missingServletFor: self servletName ].	instance := class new.	instance init: self newServletConfig.	^instance.</body><body package="SiouX-Servlet">newServletConfig	| config |	config := ServletConfig new.	config privateServletName: self servletName.	config servletContext site: self webSite.	^config.</body><body package="SiouX-Servlet">servletInstance	| created instance |	created := false.	instance := self webSite cache		servletLookup: self servletName		ifAbsentPut: [created := true. self newServlet].	^instance.</body></methods><methods><class-id>SiouX.ServletHandler</class-id> <category>private</category><body package="SiouX-Servlet">getNameFromPath		servletClass isNil 	"Special case for internal (no path) usage."		ifFalse: [^servletName := servletClass name].	servletName := request unconsumedPath first.	request consumePathSegment.	^servletName.</body></methods><methods><class-id>SiouX.ServletHandler</class-id> <category>initialize-release</category><body package="SiouX-Servlet">initializeFor: aRequest  response: aResponse	| path |	path := aRequest unconsumedPath.	(path isEmpty not and: [path first = 'servlet']) ifTrue: [aRequest consumePathSegment].	request := aRequest.	request handler: self.	webSite := request webSite.	response := aResponse.	response handler: self.	session := webSite sessionFor: request createIfAbsent: true.	aRequest privateUnconsumedPath: (self webSite urlManager fullyTranslateCollection: aRequest unconsumedPath).	request containsUnregisteredServletRequest ifTrue: [request consumeUnregisteredServletRequest].	servlet ifNil: [		servletName ifNil: [self getNameFromPath].		servlet := self servletInstance].	self servlet class singleThreadModel ifTrue: [		servlet request: request.		servlet response: response.		servlet session: session].</body><body package="SiouX-Servlet">serveRequest: aRequest response: aResponse	self initializeFor: aRequest response: aResponse.	self servlet		service: request		response: response.	^response		setResponseContents;		httpResponse</body></methods><methods><class-id>SiouX.ServletHandler class</class-id> <category>services</category><body package="SiouX-Servlet">serveRequest: aRequest response: aResponse	^ self new		serveRequest: aRequest response: aResponse</body></methods><methods><class-id>SiouX.Echo</class-id> <category>subclass responsibility</category><body package="SiouX-Servlet">doGet: aRequest response: aResponse 	aResponse 		write: '&lt;html&gt;&lt;head&gt;&lt;title&gt;Echo&lt;/title&gt;&lt;head&gt;&lt;body&gt;' ; cr;		write: '&lt;h1&gt;Echo Information&lt;/h1&gt;'; cr.	self echo: aRequest on: aResponse responseStream. 	aResponse cr; write: '&lt;/body&gt;&lt;/html&gt;'.	^aResponse</body><body package="SiouX-Servlet">echo: aServletRequest on: aStream	| httpRequest |	httpRequest := aServletRequest httpRequest.	aStream nextPutAll: '&lt;h2&gt;Environment Variables&lt;/h2&gt;&lt;pre&gt;'; cr.	httpRequest header fieldsDo: [ :headerField | 		aStream nextPutAll: '&lt;b&gt;'.		headerField  writeNameOn: aStream.		aStream nextPutAll: '&lt;/b&gt;'.		headerField writeValueOn: aStream encoding: httpRequest headerCharset.		aStream cr.	].	aStream nextPutAll: '&lt;/pre&gt;'. 	aServletRequest formSize isZero ifFalse: [		aStream nextPutAll: '&lt;h2&gt;Form Data&lt;/h2&gt;&lt;pre&gt;'; cr.		aServletRequest form  do: [ :assoc |			aStream 				nextPutAll: '&lt;b&gt;'; 				nextPutAll: assoc key;				nextPutAll: ' =&lt;/b&gt; ';				nextPutAll: assoc value;				cr] .		aStream nextPutAll: '&lt;/pre&gt;' ].	aServletRequest querySize isZero ifFalse: [		aStream nextPutAll: '&lt;h2&gt;Query Data&lt;/h2&gt;&lt;pre&gt;'; cr.		aServletRequest query  do: [ :assoc |			aStream 				nextPutAll: '&lt;b&gt;'; 				nextPutAll: assoc key;				nextPutAll: ' =&lt;/b&gt; ';				nextPutAll: assoc value;				cr] .		aStream nextPutAll: '&lt;/pre&gt;' ].	aServletRequest connection server ifNotNil: [ :server |		aStream 			nextPutAll: '&lt;h2&gt;Service Description&lt;/h2&gt;&lt;pre&gt;'; 			cr;			nextPutAll: '&lt;b&gt;'; 			nextPutAll: 'Server name: ';			nextPutAll: '&lt;/b&gt;'; 			nextPutAll: server id; 			cr;			nextPutAll: '&lt;b&gt;'; 			nextPutAll: 'Host name: ';			nextPutAll: '&lt;/b&gt;'; 			nextPutAll: aServletRequest connection id hostName;			nextPutAll: ' ['.		aServletRequest connection id printAddressOn: aStream.		aStream nextPutAll: ':', aServletRequest connection listener port printString.		aStream nextPutAll: ']'.		aStream cr.		aStream nextPutAll: '&lt;/pre&gt;'. 	].</body></methods><methods><class-id>SiouX.ServletConfig</class-id> <category>api</category><body package="SiouX-Servlet">initParameter: aString	^initParameters at: aString ifAbsent: [nil].</body><body package="SiouX-Servlet">initParameterNames	^initParameters keys.</body><body package="SiouX-Servlet">servletContext	^context.</body><body package="SiouX-Servlet">servletName	^context servletName</body></methods><methods><class-id>SiouX.ServletConfig</class-id> <category>duplicate api with get</category><body package="SiouX-Servlet">getInitParameter: aString	^self initParameter: aString.</body><body package="SiouX-Servlet">getInitParameterNames	^self initParameterNames.</body></methods><methods><class-id>SiouX.ServletConfig</class-id> <category>initialize</category><body package="SiouX-Servlet">initialize		initParameters := Dictionary new.	context := ServletContext new.	context config: self.</body></methods><methods><class-id>SiouX.ServletConfig</class-id> <category>accessing</category><body package="SiouX-Servlet">initParameterAt: aKey put: aValue 	initParameters at: aKey put: aValue.</body><body package="SiouX-Servlet">privateServletName: aString		context servletName: aString.</body></methods><methods><class-id>SiouX.ServletConfig class</class-id> <category>instance creation</category><body package="SiouX-Servlet">new	^super new initialize.</body></methods><methods><class-id>SiouX.HttpServletRequest</class-id> <category>private</category><body package="SiouX-Servlet">acceptableCharSets	^self acceptableItemsFrom: (self header: 'Accept-Charset').</body><body package="SiouX-Servlet">acceptableItemsFrom: aColl 	"Parse an HTTP Accept-* string and return the list of acceptable items, organized by priority"	| groupedItems |	( aColl isNil or: [ aColl isEmpty]) ifTrue: [^#()].	groupedItems := self class processAcceptString: aColl.	^groupedItems at: 2</body><body package="SiouX-Servlet">acceptableLanguages	^self acceptableItemsFrom: (self header: 'Accept-Language').</body><body package="SiouX-Servlet">allValuesAt: aString from: urlData	| values |	urlData isNil ifTrue: [^#()].	values := urlData at: aString ifAbsent: [#()].	values == nil ifTrue: [^#()].	^values.</body><body package="SiouX-Servlet">anyValueAt: aString from: urlData	^urlData isNil 		ifTrue: [nil]		ifFalse: [urlData at: aString ifAbsent: [nil]].</body><body package="SiouX-Servlet">anyValueAt: aString from: urlData ifNone: aBlock	^urlData isNil 		ifTrue: [aBlock value]		ifFalse: [urlData at: aString ifAbsent: aBlock].</body><body package="SiouX-Servlet">cachedSession	^cachedSession.</body><body package="SiouX-Servlet">cachedSession: anHttpSession	cachedSession := anHttpSession</body><body package="SiouX-Servlet">privateFormDictionary	^form</body><body package="SiouX-Servlet">privateQueryDictionary	^query</body><body package="SiouX-Servlet">requestData	^self method = 'GET'		ifTrue: [self query]		ifFalse: [self form].</body></methods><methods><class-id>SiouX.HttpServletRequest</class-id> <category>query data</category><body package="SiouX-Servlet">allQueryValuesAt: aString	"Return all the query data associated with aString"	^self allValuesAt: aString from: self privateQueryDictionary.</body><body package="SiouX-Servlet">anyQueryValueAt: aString	"Return the first piece of query data associated with aString. If there are none, return nil"	^self anyValueAt: aString from: self privateQueryDictionary.</body><body package="SiouX-Servlet">anyQueryValueAt: aString ifNone: aBlock	"Return the first piece of query data associated with aString. If there are none, return nil"	^self anyValueAt: aString from: self privateQueryDictionary ifNone: aBlock.</body><body package="SiouX-Servlet">query	"Return the query data associated with this request."	^query.</body><body package="SiouX-Servlet">querySize	"Return the size of the query data"	^query ifNotNil: [ query size].</body><body package="SiouX-Servlet">queryString	"Return the query string associated with this request."	^httpRequest url query</body></methods><methods><class-id>SiouX.HttpServletRequest</class-id> <category>path</category><body package="SiouX-Servlet">consumePathSegment	| seg |	unconsumedPath isEmpty ifTrue: [^''].	seg := unconsumedPath removeFirst.	consumedPath addLast: seg.	^seg</body><body package="SiouX-Servlet">consumeUnregisteredServletRequest	"Eat everything up to and including the word servlet. Leave the class name behind so that the handler can figure out what to use"	| oldPath |	oldPath := unconsumedPath copy.	oldPath do: 			[:each | 			self consumePathSegment.			each asLowercase = 'servlet' ifTrue: [^self]].	"There was no word 'servlet', this should never have been called"	unconsumedPath := oldPath.</body><body package="SiouX-Servlet">consumedPath	^consumedPath</body><body package="SiouX-Servlet">containsUnregisteredServletRequest	| tailPrefix |	unconsumedPath size &lt; 2 ifTrue: [^false].	1 to: unconsumedPath size - 1 do: [:i |		tailPrefix := 	unconsumedPath at: i.		tailPrefix asLowercase = 'servlet' ifTrue: [^true]].	^false.</body><body package="SiouX-Servlet">contextPath	"I don't really know if this is the right semantics. Return the entire path except for the 'file name' "	| path last |	path := self pathInfo.	last := path lastIndexOf: $/ ifAbsent: [path size].	^self servletPath, (self pathInfo copyFrom: 1 to: last - 1).</body><body package="SiouX-Servlet">pathInfo"PathInfo: The part of the request path that is not part of the Context Path or theServlet Path. It is either null if there is no extra path, or is a string with a leading â/â."	^httpRequest  url path</body><body package="SiouX-Servlet">peekUnconsumedPath	unconsumedPath isEmpty ifTrue: [^''].	^unconsumedPath first.</body><body package="SiouX-Servlet">privateUnconsumedPath: aCollection	unconsumedPath := aCollection.</body><body package="SiouX-Servlet">serverBasePath	"Answer the initial path for requests or files handled by the server, 		or an empty string if there is none."self halt"	^ (self virtualDirectory ifNil: [ self SCRIPT_NAME ]) ifNil: [ '' ]."</body><body package="SiouX-Servlet">servletPath"Servlet Path: The path section that directly corresponds to the mapping whichactivated this request. This path starts with a â/â character except in the casewhere the request is matched with the â/*â or ââ pattern, in which case it is anempty string.requestURI = contextPath + servletPath + pathInfoExample:Context Path 				/catalogServlet Mapping 			Pattern: /lawn/*							Servlet: LawnServlet/catalog/lawn/index.html 	ContextPath: /catalog							ServletPath: /lawn							PathInfo: /index.html"self halt"	^webRequest SCRIPT_NAME."</body><body package="SiouX-Servlet">setupPath	consumedPath := OrderedCollection new. 	(unconsumedPath := self pathInfo) size = 0 ifTrue: [^self ].	unconsumedPath notEmpty ifTrue: [ 		unconsumedPath last isEmpty ifTrue: [ | newPath |			newPath := unconsumedPath.			[ newPath notEmpty and: [ newPath last isEmpty ] ] whileTrue: [ newPath removeLast ].			unconsumedPath := newPath collect: [:each | self stripExtraCharactersFrom: each] ]].</body><body package="SiouX-Servlet">stripExtraCharactersFrom: aString	| result |	result := aString.	result isEmpty ifTrue: [^result].	[result isEmpty not and: ['. ' includes: result last]] whileTrue: [result := result copyFrom: 1 to: result size -1].	^result.</body><body package="SiouX-Servlet">unconsumedPath	^unconsumedPath</body></methods><methods><class-id>SiouX.HttpServletRequest</class-id> <category>api</category><body package="SiouX-Servlet">charset	^self charsets first.</body><body package="SiouX-Servlet">charsets	"Return a list of acceptable charsets."	|  charsets result lower |	charsets := self acceptableCharSets.	charsets isEmpty ifTrue: [^Array with: #'iso-8859-1'].	result := OrderedCollection new.	charsets do: [:ch | 		lower := (ch allSatisfy: [ :each | each isUppercase not]) ifTrue: [ch] ifFalse: [ch asLowercase].		lower := lower asSymbol.		( (StreamEncoder encoderDirectory includesKey: lower) ifTrue: [lower] ifFalse: [nil]) ifNotNil: [ :name |			result add: name]].	^result.</body><body package="SiouX-Servlet">contentType	^httpRequest contentType.</body><body package="SiouX-Servlet">findWebSite	webSite := WebSiteConfiguration siteFor: self.	(webSite specifiesAliasFor: self) ifTrue: [self consumePathSegment].	^ webSite</body><body package="SiouX-Servlet">getRequestDispatcher: aString          "Returns a RequestDispatcher object that acts as a wrapper for the resource located at the given path."self halt"	^VisualWave.RequestDispatcher path: aString."</body><body package="SiouX-Servlet">header: aString	( httpRequest fieldAt: aString) ifNotNil: [ :h | ^h value ].	^nil</body><body package="SiouX-Servlet">headers: aString	"For the case where headers occur as multiple separate entries rather than a single entry with separated items, return the collection. I think this should already be handled in the request parsing, although maybe we should be ripping them apart again"	| result |	result := httpRequest fieldsAt: aString asUppercase.	result isEmpty ifTrue: [^nil].	^result.</body><body package="SiouX-Servlet">httpHost	"Some browsers do not provide this (although it is required in HTTP/1.1).		So we will just fall back to the SERVER_NAME and SERVER_PORT if it is missing."	(httpRequest fieldAt: 'Host')		ifNotNil: [ :f | f value ]		ifNil: [| aStream port https |			aStream := (String new: 100) writeStream.			"If we do not have HOST, we must have SERVER_NAME."			aStream nextPutAll: (connection localAddress ifNil: ['']).			port := connection listener port printString ifNil: [''].			https := self isSecure.			"Only add the port if it is not the well-known port."			((https not and: [port = '80']) or: [https and: [port = '443']]) ifFalse: [				aStream nextPutAll: ':', port ].			aStream contents]</body><body package="SiouX-Servlet">isSecure	^connection isSecure.</body><body package="SiouX-Servlet">linkNamed: urlString	| string |	string := urlString isNil ifTrue: [ '' ] ifFalse: [ urlString ].	"It might already be an absolute URL."	(#('http:/*' 'https:/*' 'ftp:/*' 'file:/*' 'mailto:/*') anySatisfy: [:each | each match: string])		ifTrue: [ ^ string ].	"A URL built from an absolute Filename is not likely to be resolved correctly."	^ (string isEmpty not and: [ string first == $/ ])		ifTrue: [ self serverAbsoluteURLString: string ]		ifFalse: [ self siteAbsoluteURLString: string ].</body><body package="SiouX-Servlet">locale	"Return an accept locale based on the accept-language and territory. "	^ Locale getLocaleWithNames: self acceptableLanguages</body><body package="SiouX-Servlet">locales	"Return a list of acceptable locales given the language and character sets. This is messy, because http separates out language and character set, but vw combines them into a single locale. Try to find one which matches both. If impossible, try just one, giving priority to the charset. If they all fail, use the default"	^ Locale getLocalesWithNames: self acceptableLanguages.</body><body package="SiouX-Servlet">pathTranslated	^self contextPath</body><body package="SiouX-Servlet">protocol	^httpRequest method</body><body package="SiouX-Servlet">remoteAddr	^connection socket getPeer</body><body package="SiouX-Servlet">remoteHost	^connection socket getPeer</body><body package="SiouX-Servlet">remoteUser	^nil.</body><body package="SiouX-Servlet">requestURI	^httpRequest url</body><body package="SiouX-Servlet">requestedSessionId	"Returns the session ID specified by the client. This may not be the same as the ID of the actual session in use. For example, if the request specified an old (expired) session ID and the server has started a new session, this method gets a new session with a new ID. If the request did not specify a session ID, this method returns null."	^(self anyCookieValueAt: handler webSite sessionCookieName).</body><body package="SiouX-Servlet">scheme	^self isSecure ifTrue: ['https'] ifFalse: ['http'].</body><body package="SiouX-Servlet">serverAbsoluteURLString: urlString	"Answer an absolute HTTP URL string 		which the browser can use to get back to this server directly."	| aStream serverName scheme |	aStream := (String new: 100) writeStream.	serverName := self httpHost.	scheme := ((#('http:/*' 'https:/*') anySatisfy: [:each | each match: serverName])		ifTrue: [ '' ]		ifFalse: [ self isSecure ifTrue: [ 'https://' ] ifFalse: [ 'http://' ] ]).	aStream 		nextPutAll: scheme;		nextPutAll: serverName;		nextPutAll: self serverBasePath.	(urlString isNil or: [ urlString isEmpty ]) ifFalse: [		aStream nextPutAll: urlString ].	^ aStream contents.</body><body package="SiouX-Servlet">serverName	^connection localAddress</body><body package="SiouX-Servlet">serverPort	^connection listener port printString</body><body package="SiouX-Servlet">siteAbsoluteURLString: urlString	"Answer an absolute HTTP URL string 		which the browser can use to get back to this server and this site directly."	| aStream alias serverName scheme |	aStream := (String new: 100) writeStream.	serverName := handler webSite preferredDomain ifNil: [ self httpHost ].	scheme := ((#('http:/*' 'https:/*') anySatisfy: [:each | each match: serverName])		ifTrue: [ '' ]		ifFalse: [ self isSecure ifTrue: [ 'https://' ] ifFalse: [ 'http://' ] ]).	aStream 		nextPutAll: scheme;		nextPutAll: serverName;		nextPutAll: self serverBasePath.	(alias := handler webSite preferredAlias) notNil ifTrue: [ 		aStream nextPutAll: '/', alias ].	(urlString isNil or: [ urlString isEmpty ]) ifFalse: [		aStream nextPutAll: '/', urlString ].	^ aStream contents.</body></methods><methods><class-id>SiouX.HttpServletRequest</class-id> <category>parameters</category><body package="SiouX-Servlet">allParameterValuesAt: aString	"Return all the parameter values associated with aString. Parameters are either form data (if present) or query data (otherwise)"	^self getParameterValues: aString.</body><body package="SiouX-Servlet">anyParameterValueAt: aString	"Return the first the parameter value associated with aString. Parameters are either form data (if present) or query data (otherwise)"	^self getParameter: aString.</body><body package="SiouX-Servlet">anyParameterValueAt: aString ifNone: aBlock	"Return the first the parameter value associated with aString. Parameters are either form data (if present) or query data (otherwise)"	^self getParameter: aString ifNone: aBlock.</body><body package="SiouX-Servlet">getParameter: aString	"Return the first the parameter value associated with aString. Parameters are either form data (if present) or query data (otherwise). Same as anyParameterValueAt:, but provided for Java naming compatibility"	^self getParameter: aString ifNone: [ nil ]</body><body package="SiouX-Servlet">getParameter: aString ifNone: aBlock	"Return the first the parameter value associated with aString. Parameters are either form data (if present) or query data (otherwise). Same as anyParameterValueAt:, but provided for Java naming compatibility"	^(self parameters detect: [ :assoc | assoc key = aString] ifNone: [aBlock value ]) value</body><body package="SiouX-Servlet">getParameterNames	"Return the names of all the parameter value associated with this request. Parameters are either form data (if present) or query data (otherwise). Same as parameterNames, but provided for Java naming compatibility"	^self parameterNames.</body><body package="SiouX-Servlet">getParameterValues: aString	"Return all of the the parameter value associated with aString. Parameters are either form data (if present) or query data (otherwise). Same as allParameterValuesAt:, but provided for Java naming compatibility"	^self parameterValues: aString.</body><body package="SiouX-Servlet">parameterNames	"Return the names of all the parameter value associated with this request. Parameters are either form data (if present) or query data (otherwise)"	^self parameters collect: [ :assoc  | assoc key ]</body><body package="SiouX-Servlet">parameterSize	"Return the number of parameters provided with this request. Parameters are either form data (if present) or query data (otherwise)"	^self parameters size</body><body package="SiouX-Servlet">parameterValues: aString	"Return the values of all the parameters associated with this request. Parameters are either form data (if present) or query data (otherwise)"	^(self parameters select: [ :assoc | assoc key = aString]) collect: [ :assoc | assoc value ]</body><body package="SiouX-Servlet">parameters	"Return the parameters to this request. Parameters are either form data (if present) or query data (otherwise)"	^self requestData</body></methods><methods><class-id>SiouX.HttpServletRequest</class-id> <category>copying</category><body package="SiouX-Servlet">postCopy	httpRequest := httpRequest copy.	query := nil.</body></methods><methods><class-id>SiouX.HttpServletRequest</class-id> <category>form</category><body package="SiouX-Servlet">allFormValuesAt: aString	"Return all the form values associated with aString"	^form ifNotNil: [form select: [ :assoc | assoc key = aString ]]</body><body package="SiouX-Servlet">anyFormValueAt: aString	"Return the first form value associated with aString. If there are none, return nil"	^self anyFormValueAt: aString ifNone: [nil]</body><body package="SiouX-Servlet">anyFormValueAt: aString ifNone: aBlock	"Return the first form value associated with aString. If there are none, return nil"	^form ifNotNil: [ form detect: [ :assoc | assoc key = aString ] ifNone: [ ^aBlock value  ]]</body><body package="SiouX-Servlet">form	"Return a collection of associations of all form data, with the name of the data as a key, and a collection of all values by that name as the value"	^form.</body><body package="SiouX-Servlet">formSize	"Return the size of the form data"	^form 		ifNotNil: [ form size ]		ifNil: [ 0 ]</body></methods><methods><class-id>SiouX.HttpServletRequest</class-id> <category>accessing</category><body package="SiouX-Servlet">attributes	attributes == nil ifTrue: [attributes := self newAttributes].	^attributes.</body><body package="SiouX-Servlet">connection	^ connection</body><body package="SiouX-Servlet">handler	^handler.</body><body package="SiouX-Servlet">handler: aServletHandler	handler := aServletHandler.</body><body package="SiouX-Servlet">httpRequest	^httpRequest</body><body package="SiouX-Servlet">httpRequest: anHttpRequest	httpRequest := anHttpRequest</body><body package="SiouX-Servlet">method	"Return the method used in this request, normally either GET or POST"	^httpRequest method.</body><body package="SiouX-Servlet">newAttributes	^Dictionary new</body><body package="SiouX-Servlet">serverHostname	"Some browsers do not provide this (although it is required in HTTP/1.1).		So we will just fall back to the SERVER_NAME and SERVER_PORT if it is missing."	"	^ self envAt: 'HTTP_HOST' 		ifAbsent: [ | aStream port https |			aStream := (String new: 100) writeStream.			If we do not have HTTP_HOST, we must have SERVER_NAME.			aStream nextPutAll: (self SERVER_NAME ifNil: ['']).			port := self SERVER_PORT ifNil: [''].			https := self isSecure.			Only add the port if it is not the well-known port.			((https not and: [port = '80']) or: [https and: [port = '443']]) ifFalse: [				aStream nextPutAll: ':', port ].			aStream contents ]."	^httpRequest host</body><body package="SiouX-Servlet">session	^handler session</body><body package="SiouX-Servlet">uri	"Return the original request URL that generated this request, including query data"	^self url.</body><body package="SiouX-Servlet">url	"Return the original request URL that generated this request, including query data"		^httpRequest  url</body><body package="SiouX-Servlet">webSite	^webSite</body><body package="SiouX-Servlet">webSite: anObject	webSite := anObject</body></methods><methods><class-id>SiouX.HttpServletRequest</class-id> <category>cookies</category><body package="SiouX-Servlet">allCookieValuesAt: aString	"Return all the cookie values associated with aString"	^(httpRequest cookie value select: [ :cookieValue | cookieValue name = aString ])		collect: [ :val | val nameValue ]</body><body package="SiouX-Servlet">anyCookieValueAt: aString	"Return the first cookie value associated with aString. If there are none, return nil"	^httpRequest cookie 		ifNotNil: [ :cookie | cookie value detect: [ :cookieVal | cookieVal key = aString ] ifNone: [ nil]]</body><body package="SiouX-Servlet">anyCookieValueAt: aString ifNone: aBlock	"Return the first cookie value associated with aString. If there are none, return nil"	| cookie |	cookie := httpRequest cookie value detect: [ :cookieValue | cookieValue name = aString ] ifNone: [ ^aBlock value ].	^cookie  nameValue</body><body package="SiouX-Servlet">cookieSize	"Return the number of different cookies associated with the request. Note that all the cookies associated with a particular key count as one, i.e. if there are 7 different cookies all named 'foo' then the cookieSize will be 1 "	^httpRequest cookie value size.</body><body package="SiouX-Servlet">cookieValueAt: aString	"Return the first cookie associated with aString"	^self anyCookieValueAt: aString.</body><body package="SiouX-Servlet">cookies	"Return a dictionary of all cookies, with the name of the cookie as a key, and a collection of all cookies by that name as the value"	^httpRequest cookie.</body></methods><methods><class-id>SiouX.HttpServletRequest</class-id> <category>initialize-release</category><body package="SiouX-Servlet">initialize: anHttpRequest connection: aConnection	connection := aConnection.	httpRequest := anHttpRequest.	form := self httpRequest postData.	query := self httpRequest queryData.	self setupPath</body></methods><methods><class-id>SiouX.HttpServletRequest</class-id> <category>printing</category><body package="SiouX-Servlet">printOn: aStream	httpRequest		ifNil: [super printOn: aStream]		ifNotNil: [ httpRequest printOn: aStream]</body></methods><methods><class-id>SiouX.HttpServletRequest class</class-id> <category>instance creation</category><body package="SiouX-Servlet">initialize: anHttpRequest connection: aConnection	^self new		initialize: anHttpRequest connection: aConnection;		yourself</body></methods><methods><class-id>SiouX.HttpServletRequest class</class-id> <category>locale processing</category><body package="SiouX-Servlet">allLocaleObjects	^Locale availableLocales collect: [:eachLocaleName| Locale named: eachLocaleName]</body><body package="SiouX-Servlet">getLocale: aString	^Locale getLocaleNamed: aString</body><body package="SiouX-Servlet">getLocaleWithNames: httpAcceptableLanguages			^Locale getLocaleWithNames: httpAcceptableLanguages</body><body package="SiouX-Servlet">getLocales: aString	^Locale getLocalesNamed: aString</body><body package="SiouX-Servlet">getLocalesMatching: languageNames allowWildcards: allowWildcards	^self allLocaleObjects select: [ :each | 		(languageNames includes: each languageAndTerritory asLowercase )			or: [(languageNames includes: each languageID)				or: [allowWildcards and: [languageNames includes: '*']]]].</body><body package="SiouX-Servlet">getLocalesMatching: languageNames withCharsets: charsetNames allowWildcards: allowWildcards 	| lang charsets  |	^self allLocaleObjects select: [:each | 		lang := (languageNames includes: each languageAndTerritory asLowercase) 				or: [(languageNames includes: each languageID) 					or: [allowWildcards and: [languageNames includes: '*']]].							charsets := (charsetNames includes: each defaultEncoding asLowercase) 					or: [	allowWildcards and: [charsetNames includes: '*']].							lang &amp; charsets].</body><body package="SiouX-Servlet">getLocalesWithNames: httpAcceptableLanguages	^Locale getLocalesWithNames: httpAcceptableLanguages</body><body package="SiouX-Servlet">getLocalesWithNames: languageCollection andCharsets: charsetCollection	|  languageNames exactMatches |	languageNames := languageCollection collect: [:each |Locale transformHTTPLocaleName: each].	exactMatches := self 		getLocalesMatching: languageNames 		withCharsets: charsetCollection 		allowWildcards: false.	exactMatches isEmpty ifFalse: [^exactMatches].		^self		getLocalesMatching: languageNames		withCharsets: charsetCollection		allowWildcards: true.</body><body package="SiouX-Servlet">processAcceptString: items	"Expect an http accept-style string, e.g. for accept-language		da, en-gb; q=0.8,  en;q=0.7	Return an array with two things:		a) a dictionary mapping from q (preference) values to language names 		b) a collection of all the language names acceptable"	| entriesGroupedByQ names nm qValue| 	entriesGroupedByQ := Dictionary new.	names := OrderedCollection new.	items do: [:each | 		qValue := each params isEmpty ifTrue: [1.0] ifFalse: [(each paramAt: 'q') asNumber].		names add: (nm := each value trimBlanks asLowercase).		(entriesGroupedByQ at: qValue ifAbsentPut: [OrderedCollection new]) add: nm ].	^Array with: entriesGroupedByQ with: names.</body><body package="SiouX-Servlet">transformHTTPLocaleName: aString"Http gives us names like da or en-gb. Transform to correspond to vw locales, which use underscores and second token as uppercase en_GB"	^Locale transformHTTPLocaleName: aString</body></methods><methods><class-id>SiouX.MissingServlet</class-id> <category>initialize-release</category><body package="SiouX-Servlet">canAnswer: aWebRequest	^false.</body><body package="SiouX-Servlet">initialize	name := ''.</body></methods><methods><class-id>SiouX.MissingServlet</class-id> <category>accessing</category><body package="SiouX-Servlet">name: aString	name := aString.</body></methods><methods><class-id>SiouX.MissingServlet</class-id> <category>services</category><body package="SiouX-Servlet">doGet: aRequest response: aResponse	"This should probably do something better emitting HTML if errors are being trapped"	self error: ((#ServletNotFound &lt;&lt; #www &gt;&gt; 'Servlet &lt;1s&gt; not found.')			expandMacrosWith: aRequest consumedPath last).</body><body package="SiouX-Servlet">doPost: aRequest response: aResponse	"This should probably do something better emitting HTML if errors are being trapped"	self error: ((#ServletNotFound &lt;&lt; #www &gt;&gt; 'Servlet &lt;1s&gt; not found.')			expandMacrosWith: name).</body></methods><methods><class-id>SiouX.WebSiteCache</class-id> <category>accessing</category><body package="SiouX-Servlet">webSite	^webSite</body><body package="SiouX-Servlet">webSite: aWebSite 	webSite := aWebSite</body></methods><methods><class-id>SiouX.WebSiteCache</class-id> <category>private - servlets</category><body package="SiouX-Servlet">servletCritical: aBlock	^self servletInstancesMutex critical: aBlock.</body><body package="SiouX-Servlet">servletInstances	servletInstances isNil ifTrue: [		servletInstances := Dictionary new].	^servletInstances.</body><body package="SiouX-Servlet">servletInstancesMutex	servletInstancesMutex isNil		ifTrue: [servletInstancesMutex := Semaphore forMutualExclusion].	^servletInstancesMutex.</body></methods><methods><class-id>SiouX.WebSiteCache</class-id> <category>servlet instances</category><body package="SiouX-Servlet">at: aString put: anInstance	"Replace the instance. PRIVATE"	^self servletCritical: [		self servletInstances 			at: aString			put: anInstance.		"Return a copy or the single instance."		(anInstance class singleThreadModel)			ifTrue: [anInstance copy]			ifFalse: [anInstance]].</body><body package="SiouX-Servlet">clearServletInstances	self servletCritical: [		self servletInstances do: [:each | self webSite trapErrorsOn: [each destroy]].		servletInstances := nil].</body><body package="SiouX-Servlet">servletLookup: aString ifAbsentPut: aBlock	^self servletCritical: [		| inst |		inst := self servletInstances 			at: aString			ifAbsentPut: aBlock.		"Return a copy or the single instance."		(inst class singleThreadModel)			ifTrue: [inst copy]			ifFalse: [inst]].</body><body package="SiouX-Servlet">smalltalkURLServletLookup: aString ifAbsentPut: aBlock	^self servletCritical: [		| inst |		inst := self servletInstances 			at: aString			ifAbsentPut: aBlock.		"Return a copy of the cached instance."		inst copy].</body></methods><methods><class-id>SiouX.WebSiteCache</class-id> <category>initialize-release</category><body package="SiouX-Servlet">release	self clearServletInstances.</body></methods><methods><class-id>SiouX.ServletContext</class-id> <category>duplicate api with get</category><body package="SiouX-Servlet">getInitParameter: aString	^self initParameter: aString.</body><body package="SiouX-Servlet">getInitParameterNames	^self initParameterNames.</body><body package="SiouX-Servlet">initParameter: aString	^config initParameter: aString.</body><body package="SiouX-Servlet">initParameterNames	^config initParameterNames.</body></methods><methods><class-id>SiouX.ServletContext</class-id> <category>private</category><body package="SiouX-Servlet">site	^site.</body><body package="SiouX-Servlet">site: aWebSite 	site := aWebSite</body></methods><methods><class-id>SiouX.ServletContext</class-id> <category>accessing</category><body package="SiouX-Servlet">config	^config</body><body package="SiouX-Servlet">config: aServletConfig	config := aServletConfig</body><body package="SiouX-Servlet">log: aString</body><body package="SiouX-Servlet">servletName	^servletName</body><body package="SiouX-Servlet">servletName: anObject	servletName := anObject</body><body package="SiouX-Servlet">webSite	^site</body></methods><methods><class-id>SiouX.ServletContext</class-id> <category>api</category><body package="SiouX-Servlet">attribute: aString	^self attribute: aString ifAbsent: [nil].</body><body package="SiouX-Servlet">attribute: aString ifAbsent: aBlock	^site  at: aString ifAbsent: aBlock.</body><body package="SiouX-Servlet">attributeAt: aString put: aValue	site  at: aString put: aValue.</body><body package="SiouX-Servlet">attributeNames	^site  attributeNames</body><body package="SiouX-Servlet">attributes	^site  contents.</body><body package="SiouX-Servlet">removeAttribute: aString	^self removeAttribute: aString ifAbsent: [].</body><body package="SiouX-Servlet">removeAttribute: aString ifAbsent: aBlock	^site removeKey: aString ifAbsent: aBlock</body><body package="SiouX-Servlet">setAttribute: aString to: aValue	site  at: aString put: aValue.</body></methods><methods><class-id>SiouX.ServletResponder</class-id> <category>accessing</category><body package="SiouX-Servlet">path	^path ifNil: [ '/servlet' ]</body><body package="SiouX-Servlet">requestClass	^requestClass ifNil: [requestClass := HttpServletRequest]</body><body package="SiouX-Servlet">requestClass: aClass	^requestClass := aClass</body><body package="SiouX-Servlet">responseClass	^responseClass ifNil: [responseClass := HttpServletResponse]</body><body package="SiouX-Servlet">responseClass: anObject	responseClass := anObject</body><body package="SiouX-Servlet">virtualDirectories	virtualDirectories isNil ifTrue: [		virtualDirectories := List new ].	^ virtualDirectories.</body><body package="SiouX-Servlet">virtualDirectories: aCollection 	virtualDirectories := aCollection</body></methods><methods><class-id>SiouX.ServletResponder</class-id> <category>services</category><body package="SiouX-Servlet">executeRequestFor: aRequestContext	|  site request |	request := self requestClass initialize: aRequestContext request connection: aRequestContext connection.	site := request findWebSite.	(site canServe: request) ifFalse: [ ^aRequestContext response forbidden: request url ].	aRequestContext response: ( ServletHandler 									serveRequest: request 									response: (self responseClass on: self newResponse)).</body></methods><methods><class-id>SiouX.WebSiteConfiguration</class-id> <category>api-sites</category><body package="SiouX-Servlet">addSite: aSite 	(self hasSite: aSite name) 		ifTrue: 			[^self error: ((#AddDuplicateSiteError &lt;&lt; #www &gt;&gt; 'Adding duplicate site "&lt;1s&gt;".&lt;n&gt;Please remove existing site first.')				expandMacrosWith: aSite name)].	aSite parentConfiguration: self.	"Put configure site first in the collection - so the Welcome Page looks better."	^ aSite isConfigure 		ifTrue: [ sites addFirst: aSite ]		ifFalse: [ sites addLast: aSite ].</body><body package="SiouX-Servlet">clearAllCaches	"Clear all of the system caches.	 This will probably disrupt activities in progress, especially the part where we dump all of the sessions."	self sitesDo: [:each | 		each clearCache.		each clearSessionCache].</body><body package="SiouX-Servlet">clearAllSessionRegistries	self sitesDo: [:each | each clearSessionCache].</body><body package="SiouX-Servlet">clearSites	sites ifNotNil: [ self sitesDo: [ :each | each release ] ].	sites := OrderedCollection new.</body><body package="SiouX-Servlet">hasSite: aSiteName	self hasSites ifFalse: [^false].	self siteNamed: aSiteName ifAbsent: [^false].	^true.</body><body package="SiouX-Servlet">hasSites	^sites notNil and: [ sites isEmpty not ].</body><body package="SiouX-Servlet">removeSite: aSite	aSite release.	^ sites remove: aSite ifAbsent: [ nil ].</body><body package="SiouX-Servlet">removeSiteNamed: aString	| removals |	removals := self sites select: [ :ea1 | ea1 name = aString ].	removals do: [ :ea2 |		self removeSite: ea2 ].	^ removals isEmpty		ifTrue: [ nil ]		ifFalse: [ removals first ].</body><body package="SiouX-Servlet">siteNamed: aString	^self siteNamed: aString ifAbsent: [nil].</body><body package="SiouX-Servlet">siteNamed: aString ifAbsent: aBlock	| coll |	coll := sites select: [ :each | each name = aString ].	^ coll isEmpty 		ifTrue: [ aBlock value ]		ifFalse: [ coll first ].</body><body package="SiouX-Servlet">sitesDo: aBlock	sites do: aBlock.</body></methods><methods><class-id>SiouX.WebSiteConfiguration</class-id> <category>accessing</category><body package="SiouX-Servlet">configFileDisplayString	"There's always a Filename, even though it may not exist."	^ self configSource asString.</body><body package="SiouX-Servlet">configFileName	^ configFileName.</body><body package="SiouX-Servlet">configFileName: configFileNameStringOrNil	"Make sure it is not an empty string."	configFileName := configFileNameStringOrNil ifNotNil: [ :aString |		aString isEmpty			ifTrue: [ nil ]			ifFalse: [ configFileNameStringOrNil ] ].</body><body package="SiouX-Servlet">configFileNameOrDefault	"This is where the primary configuration is read from.	 Once it is set, we retain the configFileName until it is explicitly cleared or changed.		See #configureFromFile: 	 It should only be set in conjunction with configuration, or when creating a headless/runtime image."	^ configFileName ifNil: [ self class defaultConfigFileName ].</body><body package="SiouX-Servlet">configFileNameString	"A display form of the raw configuration file name."	^ configFileName ifNil: [ '' ].</body><body package="SiouX-Servlet">configParameterNamed: paramName	^ self configParameters at: paramName ifAbsent: [''].</body><body package="SiouX-Servlet">configParameterNamed: paramName ifAbsent: aBlock	^ self configParameters at: paramName ifAbsent: aBlock.</body><body package="SiouX-Servlet">configParameters		^configParameters.</body><body package="SiouX-Servlet">configSource	"Answer a Filename for the global configuration file name, or the default file name.		It's still possible the Filename might not exist."	^ self privateConfigSourceOrDefault: self configFileNameOrDefault.</body><body package="SiouX-Servlet">configurationName	^ self configParameters 		at: 'name' 		ifAbsent: [ (#tagNoname &lt;&lt; #www &gt;&gt; '~no-name~') asString ].</body><body package="SiouX-Servlet">sites	sites ifNil: [ sites := OrderedCollection new ].	^sites.</body><body package="SiouX-Servlet">urlManager	^ urlManager.</body></methods><methods><class-id>SiouX.WebSiteConfiguration</class-id> <category>api-configuration</category><body package="SiouX-Servlet">allowConfiguration	^ (self siteNamed: WebSite configName) enabled.</body><body package="SiouX-Servlet">configureFromFile: aFileNameString	"If there was an error, there will be no 'sites' dictionary in the config"	| configDictionary |	self configFileName: aFileNameString.	configDictionary := self readConfiguration.	"Complete minimal setup regardless of error condition"	self initializeFrom: configDictionary.</body><body package="SiouX-Servlet">disableConfiguration	(self siteNamed: WebSite configName) disable.</body><body package="SiouX-Servlet">enableConfiguration	(self siteNamed: WebSite configName) enable.</body></methods><methods><class-id>SiouX.WebSiteConfiguration</class-id> <category>initialize-release</category><body package="SiouX-Servlet">clearConfiguration	"This does not reset the configFileName."	self release.</body><body package="SiouX-Servlet">initializeFrom: configDictionary 	"Complete minimal setup regardless of error condition"	configParameters := configDictionary at: 'configuration' ifAbsent: [Dictionary new].	self initializeUrlManagerFrom: (configDictionary at: 'global' ifAbsent: [Dictionary new]).	"If there was an error, there will be no 'sites' dictionary in the configDictionary"	self configureSites: (configDictionary at: 'sites' ifAbsent: [nil])</body><body package="SiouX-Servlet">initializeUrlManagerFrom: config	urlManager ifNotNil: [ :mgr | mgr release ].	urlManager := (self urlManagerClass new) initializeFrom: config.</body><body package="SiouX-Servlet">readConfiguration	| stream config aFilename |	aFilename := self configSource.		[stream := (aFilename withEncoding: #binary) readStream.	[config := (Net.INIScanner on: stream text) tokenizeAsDictionary] 		ensure: [stream close]] 			on: OS.OsInaccessibleError			do: 				[:ex | 				config := self class errorConfig.				ex return].	^config</body><body package="SiouX-Servlet">release	self clearSites.	urlManager ifNotNil: [ urlManager release ].</body></methods><methods><class-id>SiouX.WebSiteConfiguration</class-id> <category>actions-configuration</category><body package="SiouX-Servlet">configErrorFrom: configDictionary	"Default is false, but there must be a [configuration] and a [sites] section."	^ (((configDictionary at: 'configurationError' ifAbsent: ['false']) = 'true')		or: [ (configDictionary at: 'configuration' ifAbsent: [nil]) isNil ])			or: [ (configDictionary at: 'sites' ifAbsent: [nil]) isNil ].</body><body package="SiouX-Servlet">configureSites: siteDictionary 	| siteDict configSiteFile configSite |	self clearSites.	"Allow release processing to occur, if needed."	siteDictionary isNil ifTrue: [ ^ self  ].	siteDictionary isEmpty ifTrue: [ ^ self configureWithDefaults ].	siteDict := siteDictionary copy.	"Hold the configuration site, if any, until last."	configSiteFile := siteDict removeKey: WebSite configName ifAbsent: [ nil ].	siteDict		keysAndValuesDo: 			[:nm :ini | (self addSite: (WebSite new: nm)) configureFromFile: ini].	configSite := self addSite: (WebSite new: WebSite configName).	configSite configureFromFile: configSiteFile</body><body package="SiouX-Servlet">configureWithDefaults	(self addSite: (WebSite new: WebSite defaultName)) configureAsDefault.	(self addSite: (WebSite new: WebSite configName)) configureAsDefault.</body></methods><methods><class-id>SiouX.WebSiteConfiguration</class-id> <category>private</category><body package="SiouX-Servlet">privateConfigFileDisplayString	"The actual value, or indication that the default is being used."	^ configFileName ifNil: [ self class defaultConfigFileDisplayString ].</body><body package="SiouX-Servlet">privateConfigSourceOrDefault: aStringOrNil	"Answer a Filename for aStringOrNil, or for the internal default config file name if it is nil or empty.		Fall back to the internal examples default only in a Development environment.		A Filename is always returned, but it's still possible the Filename might not exist."	| filename nameString |	nameString := (aStringOrNil isNil or: [ aStringOrNil isEmpty ])		ifTrue: [ self class defaultConfigFileName ]		ifFalse: [ aStringOrNil ].	((filename := OS.Filename urlString: nameString) exists)		ifTrue: [ ^ filename ].	filename := OS.Filename urlString: self class examplesConfigFileName.	^ filename.</body><body package="SiouX-Servlet">siteFileName: fileNameString	"If fileNameString is not already absolute,		try to resolve the file name relative to the directory location of the global configuration file.	 It's still possible that the file might not exist."	| filename |	filename := OS.Filename fromComponents: fileNameString asURI path.	filename isAbsolute ifFalse: [ 		filename := self configSource head asFilename construct: fileNameString ].	^ filename isAbsolute		ifTrue: [ filename asString ]		ifFalse: [ fileNameString ].</body><body package="SiouX-Servlet">urlManagerClass	^LogicalURLManager</body></methods><methods><class-id>SiouX.WebSiteConfiguration class</class-id> <category>api - sites</category><body package="SiouX-Servlet">defaultSite	^self siteNamed: WebSite defaultName.</body><body package="SiouX-Servlet">removeSite: aSite	^ self globalConfiguration removeSite: aSite.</body><body package="SiouX-Servlet">removeSiteNamed: aString	^ self globalConfiguration removeSiteNamed: aString.</body><body package="SiouX-Servlet">siteFor: aWebRequest	"Lazy initialization of the ApplicationServer occurs here on receipt of the first request."	| sites owner possible |	WebSiteConfiguration hasSites		ifFalse: [ WebSiteConfiguration configureServer ].	sites := WebSiteConfiguration globalConfiguration sites.	owner := sites 		detect: [:each | each ownsRequest: aWebRequest]		ifNone: [nil].	owner isNil ifFalse: [^owner].	possible := sites 		detect: [:each | each canDealWithRequest: aWebRequest]		ifNone: [nil].	possible isNil ifFalse: [^possible].	self defaultSite ifNotNil: [ :site | ^ site ].	^ self error: (#errNoWebsiteForRequest &lt;&lt; #www &gt;&gt; 'No WebSite available to serve request.').</body><body package="SiouX-Servlet">siteNamed: aString	^ self globalConfiguration siteNamed: aString.</body><body package="SiouX-Servlet">siteNamed: aString ifAbsent: aBlock	^ self globalConfiguration siteNamed: aString ifAbsent: aBlock.</body></methods><methods><class-id>SiouX.WebSiteConfiguration class</class-id> <category>defaults</category><body package="SiouX-Servlet">cincomsmalltalkGIF	"This is the ByteArray contents of a .gif file, so it can be served internally as if it came from a file."	^(ByteArray fromPackedString: 'Q4%FNC%!^0AP@N_1@@@A@@@AA@@B@@@CA $A@@DD@@@DA0HE@P@EBP,D@0@GB PG@ HHC@THA@4FA@\IAPLJCPDKE@ KA0HME@(LB@,MB PNEPDOF TOE LPF00OB0PQG@8PC@TRGP&lt;QCPHTHQ@RC0LTH!DSD@PUH1HTDQLTD XWIP\XIP XI!TVEATWE@LZKAXXEPP[KP(ZJA\XE!LZE0T\K ,[JQ$ZF@\^LAX]F!0]F0,!MA$ GA4_GA$!GQ(!G!&lt; G X%OA,"G10#G0 &amp;OP&lt;%M0$''O!4%HQ8&amp;H!&lt;&amp;H00)PBP%H2@''H2P&amp;I@4*PPP,RBD(I@T-RP&lt;+P"D)IP .R"H*I"L*I0$/R2P+J@,0SBT,JBT-JRX.J &lt;2S0L5U!@3TB 0K@X6VB$0KR(1KR(2K (8V",3K0,9V"04L@4:V245LP&lt;;WB&lt;6L L&gt;YS@7L0T?Y#@8MCL8K0]@Y3D9MSL9LAP&gt;X@%AZCH:M#L;M0-BZSX;L3P&lt;NCT&lt;NP5CZ#\&lt;MC =MP=DZ3X&gt;N EH]@MH]QEE[C)@M3-AN@!J]31BNP)K^C!DN#5CN#9CN01L^S=DO@=M^ AR!AEN^4EFOS1HO$EGO!QP_S9JP@UT!$MIPAYQ_ !U!4ALP!!R_4UKP -V"DEMP4INP09W"QAW"$MOQDQPQQIX"0A]%TQQQ$UQQ1QY#DYRRD]SRQ![#$!TR!)\#4%UR01 &amp;T)VSA1]$D-WS@A%(41XSPA&amp;)AE"&amp;0A'')$5YS!Q#''@A()49ZS1Y$''T=[T@Q)*D=\TQ!%''%A]T !**UE^T01+*%M UP=,*0A0-UQ!U%U!U1I-+EY"V@A2-0A3.AU.+U]#VU!$VQ]/+ M4.U%%V!)0+0]5.%)&amp;V111,E-''W@16.51(WQ92,U5)W!A7/E5*W59+XAM8/U=,XVA-X&amp;E.X6I/YE91YVM0YVQ1Y&amp;U2Y6Y3ZFE5ZV]4ZVI6Z&amp;!5Z&amp;M7Z6%6Z6Q8[F)7[FU9[FY:[_???????????????????????????????????????????????????????????2G9A@DJ@O&lt;@K@@@@@A;@E@@@@#&gt;@O&lt;IFD"0(LFCBAL*WL"0(\NGD@TH#D"1(,VKFCM*7L"1(&lt;^OHDNJGD&amp;2)L&amp;SJEN*WL&amp;2)\.WLFOJ''D&amp;3),6[NGO*7L&amp;3)&lt;&gt;_PHLJGT*4*MF#RIL*W\*4*]N''TI=B@BKC @@CFCAX''XAAPXX&amp;HP82:AGC(HH[PB@T#HBA0P ''Z 7\BJH@9(J;F04LV*YM&amp;"4(GYX-:2A E#EY3+P)J4QP;;B&gt;/Z)\#[MK&amp;;Y! J0JJDU,U3I-/;+X,&amp;1+04A^8UHODP@,]S _G!&gt;DR0^/M#128%IK,-#I&lt;#B&gt;Z3((T4ZX%^U("Y5YFL#H=&gt;L5@.QX44ZM+;YE@35YW*YL6?Q %./&gt;CHQ&amp;&amp;8&amp;@Z+ZK^JQ .;7-T1V+OKL6JDJDT,FGE=]&amp;:4RG2%4H4LP3544P R]2XOBXJB]\L@%5M@" ''R0'')FEYJQC4Y,%89Y6W7''+-/YMI^?AQ-H 6/V!&amp; @/BDR^@\YDL)H(6#AV"CR0*-*BEX"\L1LA#^T"(SR\BYHBMM-CI RJG-Y&amp;GW&amp;7*]\R^[Y$8LL5;EV&amp;7XTD-; _HPIY\I4BX$1#DA7&lt;E.TJ#$M Y&lt;H,6R0 0!#Z4L@&amp;O$1=JZU,9GBQ0AIXTQZKMKB)&gt;4NVK6 P9)) ''D$+PA55PY=)U%_D!IFM.Z*ND''GSZ"R^T@#2 2J"JXCP%OG@$(N(+-YTXTQ#&gt;6#23! DFXIJ_"&lt;X)F"Y6$T(#A:6U2KGAX9YD(L@ " E1:UU/[#)''''PJP5:RG(I8J30HWSW&amp;M@:(&amp;$LH;&lt;K J$PD3Z"OKKT ^&amp;".XX *@"&amp;V24HJ$@G?8U)$6YR:[*[N]Q-/!$?B(Y266E$59QK^*N!J.QQM8L)46.6SQ0SOODCZZ(*E(T&lt;%@D8S2&lt;B9[WOUGMIX%D4%];())0FO&lt;A.L)-PDKLGB6&lt;H13114IDICCGX ,_MDJY1!!%PD++FCUBR-DLM@FJ6QP4@%%JJGYPA54D\XHWJ:@0UUE50WAB#7:N27@@+]G\DWVO"@@GX@*I^6]LI]-6=$T)[5664&amp;=?V''&gt;3CLW7I;Z[K]:$P)V"KDCP0/(THSZAR70 1T54H4PAR*@,IC^\S.2B(&amp;##EJBPQ2(PHEB] _.\4P*EML^M3(PMH)+GJ@A[&amp;7B#B;@G.^4]8''$(P+"#V7''_BJB@FSDX/0WX,MM=.?.5WZ8@B&gt;L((9-7M"A;R''F12IB:W K&lt;D#6,^A14@.3-;\NC OUX-,(3T=C@_/ME6LPC&gt;P4C&lt;&lt;;ZB!\V:&amp;XK6&lt;?OH\;1O&gt;&lt;(PI36FXF7AL\PUKQG%?0;$+624[:?&amp;^[&gt;/5OB S90_P(ZDE8&lt;N=_:VE^&lt;7Y0BP+B013%P&gt;C_;*Y@@V3NM+W 7P-,D88/B@I\9*@C--QGP4N(@Q''&gt;3\NEF Q!0M+HS6X]!L\9]NFHVBQ1_&lt;''[V1F8(H_6*@DMZF"C^;91B$(TX8O-TZE-@@^(E=Z&amp;E[0S0A],\8"A3HDP#AL@C4&lt;8/EA% 4PD6XE-7#DPS+QGE;XS0@K4Y9,O#.5CL5-@A=&gt;!!8JH@H!!SNCBV(GG!GCAM.C @DK&amp;2H&amp;B7JD=LB#HM61C P^TC1 HHTQ;CJ$&lt;QI)M#^41@4K.^DAI+(JR- GEP%SPG''TDH(8S+@4F&lt;; '' &lt;31AUE(30,PH)-BQ#E.L'',%@6,3#XP HYH+MI5;K-DPU+WGGG.H811-TAA^5.XZA(D_@EUY&amp;6X()HQP;I&lt;+92X@D\9AH[''&gt;*84XZ4OF9''F3HP,8QO%*P8;U2MD6''2NHA613QHK@D8A&gt;+L4(EJHFY&lt;*3V*&lt;DH1DT@$%8;AL^?WQOP1-" ;_YA ,G+X4GB+KP6*B2HIJ03P;T&gt;P"EWCJ^HLP(O]-S@8WL&lt;ZL!]T&lt;''H\JDY+RGG@&gt;X84(UZ).WD"R&amp;3"L$K!PRBH/&amp;%F&gt;/KH]-.J@PV'')T$/@X)V7DPIFH5,XFR&amp;U)T04BUPAV-C[#T@ .O_!L,$VS'',Z0ST6Y&amp;TII5(HB8] #NQ]" 3(JL)?0,DIZ&amp;^)R-,)4!+ZQ9_!VV]]95 Y[OZ.MN#R@D@GVL)-X,$G90,EY!CAA]\  "B%-08KEC*R%&lt;GC&gt;:$CZ^#"@$TLEA''&amp;@:*1:RI5^U @,ZD&lt;,II\CLG8U-@)&lt;*1E9=27[HNLKRC@#G54+@M#JU B4EP@V6)LNL:2T@5XHKFT/"%U:))RZO5@[B0 14NNN$XV''T2\&lt;!&amp;(P,=+OC.]]:&amp;/WB%NYC,RL^?0_J:U85=&lt;JP@MO/M?? @)_U24@ +VQ[DD^@H3?5RJX&lt;MA/]_'';UO&lt;JD!\TCD]^\]+[&lt;!)X@CMH,F54PQ-=R%I\H$CGG-E''$DDZE15(H@!5+^-X91T$DN-(7" ^PL AP;M/+94#&lt;L!ZQO_2,&lt;DFXTI;1%EZ 5C BV=@ 0:@&amp;PH\^I%.B?@2C''A[DABHFY 2&gt;&lt;I I7@AB#J0XBA&amp;=/IJW7A&amp;@\B 3 HPL84M&lt;(H&gt;''DHW"+BB;V( Y&amp;3)^R@\DCLI1*]''ST[%4YBN-JP''S^%JV?+R&amp;L:4)#_M:T9;&gt;-N C+V(Q47*T)/:5J!NMTX&amp;(&amp;*G?BL @C,b')</body><body package="SiouX-Servlet">defaultConfig	^ Dictionary new 		add: 'configuration' -&gt; (Dictionary new 			add: 'directory' -&gt; self examplesDirectoryName;			yourself);		yourself.</body><body package="SiouX-Servlet">defaultConfigFileDisplayString 	^ (#tagDefault &lt;&lt; #www &gt;&gt; '~default~') asString.</body><body package="SiouX-Servlet">defaultConfigFileName	"The general default is to look for this file in the current working directory.		This location may vary depending on your operating system, and how you started your image."		^ 'webtools.ini'.</body><body package="SiouX-Servlet">demoConfigFileName	" Use platform independent function to turn this into a Filename."	^ '$(VISUALWORKS)/web/demo/webdemo.ini'.</body><body package="SiouX-Servlet">errorConfig	^ Dictionary new 		add: 'configurationError' -&gt; 'true';		add: 'configuration' -&gt; Dictionary new;		 yourself.</body><body package="SiouX-Servlet">examplesConfigFileName	" Use platform independent function to turn this into a Filename."	^ '$(VISUALWORKS)/web/webtools.ini'.</body><body package="SiouX-Servlet">examplesDirectoryName	^ '$(VISUALWORKS)/web/examples'.</body><body package="SiouX-Servlet">unknownConfigFileDisplayString 	^ (#tagUnknown &lt;&lt; #www &gt;&gt; '~unknown~') asString.</body></methods><methods><class-id>SiouX.WebSiteConfiguration class</class-id> <category>private-tests</category><body package="SiouX-Servlet">configurationForDefault	"Create a configuration instance with only the deafult and configuration sites.	 This returns a WebSiteConfiguration instance without actually configuring the server."	"self configurationForEmpty"	| config |	(config := Dictionary new)		add: 'configuration' -&gt; Dictionary new;		add: 'sites' -&gt; OrderedCollection new;		yourself.	^ super new initializeFrom: config.</body><body package="SiouX-Servlet">configureForExplicitDefault	"Configure specifically to use the default configuration from the /web directory"	"self configureForExplicitDefault"	self configureFromFile: '$(VISUALWORKS)/web/', WebSiteConfiguration defaultConfigFileName.</body><body package="SiouX-Servlet">privateGlobalConfiguration	^ globalConfiguration.</body><body package="SiouX-Servlet">privateGlobalConfiguration: aConfiguration	globalConfiguration ifNotNil: [ :cfg | cfg release ].	globalConfiguration := aConfiguration.</body></methods><methods><class-id>SiouX.WebSiteConfiguration class</class-id> <category>api - configuration</category><body package="SiouX-Servlet">allowConfiguration	self hasSites ifFalse: [ ^ false ].	^ self globalConfiguration allowConfiguration.</body><body package="SiouX-Servlet">clearAllCaches	"This is used by system events, and must not require a cached WebSiteConfiguration."	globalConfiguration ifNotNil: [ :cfg | cfg clearAllCaches ].</body><body package="SiouX-Servlet">clearAndReconfigure	"Reconfigure from the installed global configuration file."	" self clearAndReconfigure "	WebSiteConfiguration configureServerUsing: nil.</body><body package="SiouX-Servlet">clearConfiguration	"This does not reset the cached globalConfigFileName, but it does remove the cached configuration from the image."	"self clearConfiguration"	globalConfiguration ifNotNil: [ :cfg | cfg clearConfiguration ].	globalConfiguration := nil.</body><body package="SiouX-Servlet">clearReloadAndReconfigure	"Reconfigure from the currently installed global configuration file."	"self clearReloadAndReconfigure"	WebSiteConfiguration configureServerUsing: 		[ WebSiteConfiguration traceReloadStart.		 ImageConfigurationSystem current runActivationActions.		 WebSiteConfiguration traceReloadEnd ].</body><body package="SiouX-Servlet">configureForDefault	"Configure using the WebToolkit default configuration."	"self configureForDefault"	self 	"	loadExampleParcels;"		configureFromFile: nil.</body><body package="SiouX-Servlet">configureFromFile: nilOrString 	"Initialize from a Global Configuration File.		If it doesn't exist in a Development Environment, 		we set up the internal default configuration with two sites, &lt;configure&gt; and &lt;default&gt;."	"self configureFromFile: nil"	self globalConfigFileName: nilOrString.	self configureServerUsing: nil.</body><body package="SiouX-Servlet">configureServer	"Configure (or ReConfigure) from the installed global configuration file.		Do this if you have changed the contents of your configuration files			and need to install the new values.		If you need to change the global configuration file name, see #configureFromFile:	In a Deployment environment, the Application Server does a lazy configuration		when the first request is served."	"self configureServer"	self traceServerConfigAttempt.	"If there are errors they will be shown on the transcript."	self configureServerUsing: nil.</body><body package="SiouX-Servlet">configureServerUsing: preProcessBlock 	"Common wrapper for all global configuration mechanisms."	self clearConfiguration.	"Do any preprocessing required, after logging is shut down,		but before the configuration is installed."	preProcessBlock value.	"If there are errors they will be shown on the transcript."	globalConfiguration := super new configureFromFile: self globalConfigFileName.</body><body package="SiouX-Servlet">hasSites	"Answer whether or not the cached globalConfiguration contains a collection of sites.	 If the server has been configured there will always be a site collection, even if there are configuration errors."	^ globalConfiguration		ifNil: [ false ]		ifNotNil: [ globalConfiguration hasSites ].</body><body package="SiouX-Servlet">restartGlobalConfig: configFileName 	"Write event into the current log file, just in case we are switching configuration files.	 Configure the server using the provided configuration file name."	WebSiteConfiguration configureFromFile: configFileName.</body></methods><methods><class-id>SiouX.WebSiteConfiguration class</class-id> <category>instance creation</category><body package="SiouX-Servlet">new	^ self shouldNotImplement.</body></methods><methods><class-id>SiouX.WebSiteConfiguration class</class-id> <category>settings</category><body package="SiouX-Servlet">allowSettingConfigFileName	allowSettingConfigFileName isNil ifTrue: [allowSettingConfigFileName := true].	^allowSettingConfigFileName</body><body package="SiouX-Servlet">allowSettingConfigFileName: aBoolean	allowSettingConfigFileName := aBoolean</body><body package="SiouX-Servlet">defaultEncoding	defaultEncoding isNil ifTrue: [defaultEncoding := #'iso-8859-1'].	^defaultEncoding.</body><body package="SiouX-Servlet">defaultEncoding: aSymbol	defaultEncoding := aSymbol</body><body package="SiouX-Servlet">globalConfigFileName	^ globalConfigFileName</body><body package="SiouX-Servlet">globalConfigFileName: configFileNameStringOrNil	"Make sure it is never an empty string."	globalConfigFileName := configFileNameStringOrNil ifNotNil: [ :aString |		aString isEmpty			ifTrue: [ nil ]			ifFalse: [ configFileNameStringOrNil ] ].</body><body package="SiouX-Servlet">globalConfigFileNameOrDefault	"This is where the primary configuration is read from.	 Once it is set, we retain the configFileName until it is explicitly cleared or changed.		See WebSiteConfiguration #configureFromFile: and #clearConfiguration	 It should only be set in conjunction with configuration, or when creating a headless/runtime image."	^ globalConfigFileName ifNil: [ WebSiteConfiguration defaultConfigFileName ].</body><body package="SiouX-Servlet">shouldSetEncodingFromRequest	shouldSetEncodingFromRequest isNil ifTrue: [shouldSetEncodingFromRequest := true].	^shouldSetEncodingFromRequest.</body><body package="SiouX-Servlet">shouldSetLocaleFromRequest	shouldSetLocaleFromRequest isNil ifTrue: [shouldSetLocaleFromRequest := true].	^shouldSetLocaleFromRequest.</body></methods><methods><class-id>SiouX.WebSiteConfiguration class</class-id> <category>deployment</category><body package="SiouX-Servlet">clearForDeployment	"Ensure we have an explicitly named configuration file,		even if that is the default configuration file name,		so we don't end up using the internal default configuration in case of error.	 This cached configuration file name may or may not actually be used,		depending on the -wtkcnf command line parameter."	self globalConfigFileName isNil		ifTrue: [ self globalConfigFileName: self defaultConfigFileName ].	"Remove any current configuration, including logging, so a runtime image starts fresh from configuration files."	self clearConfiguration.</body></methods><methods><class-id>SiouX.WebSiteConfiguration class</class-id> <category>tracing</category><body package="SiouX-Servlet">traceReloadEnd	| msg |	msg := #msgReloadEnd &lt;&lt; #www &gt;&gt; 'Finished reloading parcels from command line.'.	Transcript cr; show: msg.</body><body package="SiouX-Servlet">traceReloadStart	| msg |	msg := #msgReloadStart &lt;&lt; #www &gt;&gt; 'Preparing to reload parcels from command line.'.	Transcript cr; show: msg.</body><body package="SiouX-Servlet">traceServerConfigAttempt	"This event cannot be logged.  The web log file is unknown until configuration completes."	| msg |	msg := (#ServerConfigAttempt &lt;&lt; #www &gt;&gt; 'Attempting to configure web application server from: &lt;1s&gt;.')			expandMacrosWith: (self globalConfigFileName ifNil: [ self defaultConfigFileDisplayString ]).	Transcript cr; show: msg.</body></methods><methods><class-id>SiouX.WebSiteConfiguration class</class-id> <category>accessing</category><body package="SiouX-Servlet">globalConfiguration	globalConfiguration isNil ifTrue: [ 		^ self error: #ServerNotConfigured &lt;&lt; #www &gt;&gt; 'The Application Server is not yet configured.' ].	^ globalConfiguration.</body></methods><methods><class-id>SiouX.Herald</class-id> <category>defaults</category><body package="SiouX-Servlet">logoFile	^ 'wtklogo.gif'.</body></methods><methods><class-id>SiouX.Herald</class-id> <category>executing</category><body package="SiouX-Servlet">doGet: aRequest response: aResponse         | logoFile stream |         heraldBits == nil ifTrue: [                 (logoFile := (Filename defaultDirectory) construct: self logoFile) exists                         ifTrue: [ 					stream := logoFile readStream binary.					[heraldBits := stream contents] ensure: [stream close] ]                         ifFalse: [ 					heraldBits := WebSiteConfiguration cincomsmalltalkGIF] ].         aResponse contentType: 'image/gif'.         aResponse write: heraldBits.</body></methods><methods><class-id>SiouX.WebSite</class-id> <category>api - content</category><body package="SiouX-Servlet">fileIncludeURL: pathString root: rootURL	" Answer a FileURL for a FILE= include, fully resolved so content can be served.		Include file is relative to rootURL, and dot navigation ( ..\foo.bar ) is permitted.		Virtual directory not permitted.		Explicit absolute pathString not permitted."	| components |	components := self urlManager splitString: pathString.	^ self resolveFileURLPath: components fromRoot: rootURL.</body><body package="SiouX-Servlet">fileURLFromPath: path	"Answer a FileURL for the path components.		Handle 'foo/../bar' properly by constructing URL using #addComponent:		URL may be relative or absolute, or contain a virtual directory."	| url |	url := path first asLogicalFileSpecification asURI.	2 to: path size do: [ :idx | url addComponent: (path at: idx) ].	^ url.</body><body package="SiouX-Servlet">resolveAbsoluteURLPath: aCollection	| url |	url := self urlFromPath: aCollection.	^ url isAbsolute		ifTrue: [ url ]		ifFalse: [ self resolveFileURLPath: aCollection fromRoot: nil ].</body><body package="SiouX-Servlet">resolveAbsoluteURLPathString: pathString	| aCollection |	aCollection := self urlManager splitString: pathString.	^ self resolveAbsoluteURLPath: aCollection.</body><body package="SiouX-Servlet">resolveFileURLPath: aCollection fromRoot: rootURL	| filename |	filename := rootURL isNil		ifTrue: [ 			self requireDirectoryToBeSet.			self homeDirectory ]  "Avoid some expensive filename-&gt;uri-&gt;filename conversion"		ifFalse: [ rootURL asFilename ].	aCollection		do: [ :each | filename := filename construct: each ].	^ filename asURI.</body><body package="SiouX-Servlet">resolveVirtualDirectory: aString	"Get the directory name from the virtual directory site."	| aSite |	aSite := WebSiteConfiguration siteNamed: aString.	aSite isNil ifTrue: [^nil].	aSite requireDirectoryToBeSet.	^aSite homeDirectory asString</body><body package="SiouX-Servlet">urlFromPath: pathCollection 	"Answer a URL constructed from contents of path collection, or nil.		URL may be either absolute or relative (and will not be fully resolved)."		| urlString |	"We ignore all path prefixes to get to a possible Smalltalk URL."	urlString := pathCollection last.	"Note: This class imports Net.URI, so this is not the Wave class. Don't use dotted name as an optimization"	(((URI allSubclasses collect: [:each | each protocol])		reject: [:each | each isNil or: [each = '']]) asSet 			includes: (urlString readStream upTo: $:) asLowercase)		ifTrue: [ urlString asURI ]		ifFalse: [ self fileURLFromPath: pathCollection ].</body><body package="SiouX-Servlet">virtualIncludeURL: pathString	" Answer a FileURL for a VIRTUAL= include,			fully resolved so content can be served.		FileURL may be relative or virtual, and is resolved			either from the site's homeDirectory 			or from the first component translated as Virtual Directory for the site.		Dot navigation ( ../ foo.bar, or /../site/foo.bar ) is not permitted.		Explicit absolute pathString not permitted."	| components rootURL virtualDir |	components := self urlManager splitString: pathString.	(components includes: '..' )		ifTrue: [ ^ self error:  (#errInvalidVirtualInclude &lt;&lt; #dialogs &gt;&gt; 'Invalid virtual= include.') ].	virtualDir := self resolveVirtualDirectory: components first.	virtualDir notNil		ifTrue: [ 			rootURL := virtualDir asFilename asURI.			components removeFirst ]		ifFalse: [ rootURL := nil ].	^ self resolveFileURLPath: components fromRoot: rootURL.</body></methods><methods><class-id>SiouX.WebSite</class-id> <category>api - policy</category><body package="SiouX-Servlet">aliasString	^ self sitePolicy aliasString.</body><body package="SiouX-Servlet">canDealWithRequest: aWebRequest	^ self sitePolicy canDealWithRequest: aWebRequest.</body><body package="SiouX-Servlet">domainString	^ self sitePolicy domainString.</body><body package="SiouX-Servlet">ownsRequest: aWebRequest	^ self sitePolicy ownsRequest: aWebRequest.</body><body package="SiouX-Servlet">preferredAlias	^ self sitePolicy preferredAlias.</body><body package="SiouX-Servlet">preferredDomain	^ self sitePolicy preferredDomain.</body><body package="SiouX-Servlet">specifiesAliasFor: webRequest	^ self sitePolicy specifiesAliasFor: webRequest.</body></methods><methods><class-id>SiouX.WebSite</class-id> <category>accessing</category><body package="SiouX-Servlet">cache	^cache.</body><body package="SiouX-Servlet">configFileName: configFileNameString	"Set the configuration file name value from the main INI file.		Make sure this is never an empty string.		Use #configSource for the resolved Filename."	configFileName := configFileNameString ifNotNil: [ :aString |		aString isEmpty			ifTrue: [ nil ]			ifFalse: [ configFileNameString ] ].</body><body package="SiouX-Servlet">configParameterNamed: paramName	^ self configParameters at: paramName ifAbsent: [''].</body><body package="SiouX-Servlet">configParameterNamed: paramName ifAbsent: aBlock	^ self configParameters at: paramName ifAbsent: aBlock.</body><body package="SiouX-Servlet">configParameters	configParameters isNil ifTrue: [ configParameters := Dictionary new ].	^configParameters.</body><body package="SiouX-Servlet">configSource	"Answer a Filename (or nil) for the site configuration file.		We use the existing configFileName, 			relative to the directory location of the global configuration file,			if it is not already absolute.		It's still possible the Filename might not exist."	| ini fn |	(ini := configFileName) ifNil: [ ^ nil ].	"Allow either browser URL syntax or platform specific separator."	(fn := OS.Filename fromComponents: ini asURI path ) isAbsolute ifTrue: [ ^ fn ].	^self parentConfiguration ifNotNil: [ :cfg | cfg configSource head asFilename construct: ini ].</body><body package="SiouX-Servlet">defaultEncodingName	"Hard-coded for the moment, but put here so that it can fairly easily be made a setting"	"Some people have asked for iso-8859-15, which is the same as -1, but with the Euro symbol. Changing this method (and probably doing some reinitialization, especially of #defaultWebLocale) would change that"	^'ISO8859-1'.</body><body package="SiouX-Servlet">defaultPage	^ self configParameterNamed: 'home'.</body><body package="SiouX-Servlet">defaultPath	^self urlManager splitString: self defaultPage.</body><body package="SiouX-Servlet">description	^ self configParameterNamed: 'description' ifAbsent: [self defaultSiteDescription].</body><body package="SiouX-Servlet">directoryName	"Use #homeDirectory for the resolved Filename."	^ self configParameterNamed: 'directory'.</body><body package="SiouX-Servlet">disable	self configParameters at: 'enabled' put: 'false'.</body><body package="SiouX-Servlet">enable	self configParameters at: 'enabled' put: 'true'.</body><body package="SiouX-Servlet">enabled	^ (self configParameterNamed: 'enabled' ifAbsent: ['true']) = 'true'.</body><body package="SiouX-Servlet">environment	environment isNil ifTrue: [ environment := self environmentName asQualifiedReference value ].	^ environment.</body><body package="SiouX-Servlet">environmentName	"Use #environment for the resolved Namespace."	^ self configParameterNamed: 'environment' ifAbsent: [ 		self isConfigure ifTrue: [ 'SiouX' ] ifFalse: [ 'Smalltalk' ] ].</body><body package="SiouX-Servlet">hasDirectory	^self directoryName isEmpty not.</body><body package="SiouX-Servlet">homeDirectory	"Answer a Filename (or nil), from the directoryName string,		relative to the current working directory if it is not already absolute."	self directoryName isEmpty ifTrue: [ ^nil ].	"Allow either browser URL syntax or platform specific separator."	homeDirectory isNil ifTrue: [		homeDirectory := OS.Filename urlString: self directoryName ].	^ homeDirectory.</body><body package="SiouX-Servlet">name	name isNil ifTrue: [ 		name := '' ].	^ name</body><body package="SiouX-Servlet">name: aString 	name := aString.</body><body package="SiouX-Servlet">parentConfiguration	^parentConfiguration</body><body package="SiouX-Servlet">parentConfiguration: anObject	parentConfiguration := anObject</body><body package="SiouX-Servlet">registeredServletsOnly	^ (self configParameterNamed: 'registeredServlets' ifAbsent: ['false']) = 'true'.</body><body package="SiouX-Servlet">sitePolicy	^sitePolicy.</body><body package="SiouX-Servlet">urlManager	^ urlManager.</body><body package="SiouX-Servlet">urlableName	^OS.URLEncoder encode: self name.</body></methods><methods><class-id>SiouX.WebSite</class-id> <category>initialize-release</category><body package="SiouX-Servlet">configErrorFrom: configDictionary	"Default is false, but there must be a configuration section		which must define the home directory (except for the configure site)."	| config |	^ (((configDictionary at: 'configurationError' ifAbsent: ['false']) = 'true')		or: [ (config := configDictionary at: 'configuration' ifAbsent: [nil]) isNil ])			or: [ self isConfigure not and: [(config at: 'directory' ifAbsent: [nil]) isNil] ].</body><body package="SiouX-Servlet">configErrorString	^ (#tagSiteConfigurationError &lt;&lt; #www &gt;&gt; '~~ SITE CONFIGURATION ERROR ~~') asString.</body><body package="SiouX-Servlet">configureAsDefault	self initializeFrom: WebSiteConfiguration defaultConfig</body><body package="SiouX-Servlet">configureAsError	self initializeFrom: WebSiteConfiguration errorConfig</body><body package="SiouX-Servlet">configureFromFile: aFileNameString	| configDictionary |	self configFileName: aFileNameString.	configDictionary := self readSiteConfiguration.	self initializeFrom: configDictionary</body><body package="SiouX-Servlet">configureFromForm: aForm	"Any non-empty form values need to override corresponding configuration file/default values."	| config configDictionary |	self configFileName: (aForm at: 'configFileName' ifAbsent: [#(nil)]) first.	configDictionary := configFileName isNil				ifTrue: [WebSiteConfiguration defaultConfig]				ifFalse: [self readSiteConfiguration].	config := configDictionary at: 'configuration'.	aForm keysAndValuesDo: 			[:key :val |			(key asLowercase ~= 'submit' and: [key asLowercase ~= 'reset'])				ifTrue: [val first isEmpty ifFalse: [config at: key put: val first]]].	self initializeFrom: configDictionary</body><body package="SiouX-Servlet">defaultSiteDescription	self isDefault		ifTrue: [ ^ (#htmlDefaultSiteDescription &lt;&lt; #www &gt;&gt; 'Use this to get started.%&lt;br%&gt;Configure this site and set the directory where you have your script files.') asString ].	self isConfigure		ifTrue: [ ^ (#htmlConfigSiteDescription &lt;&lt; #www &gt;&gt; 'A tiny site for configuring other sites.') asString ].	^ ((#htmlGenericSiteDescription &lt;&lt; #www &gt;&gt; 'A site named &lt;1s&gt;.')			expandMacrosWith: self name) asString.</body><body package="SiouX-Servlet">initializeApplication"	application ifNotNil: [:app | app release].	application := self applicationClass new webSite: self.	WebSiteConfiguration handleEvent: 'applicationStartup' with: application"</body><body package="SiouX-Servlet">initializeCache	cache ifNotNil: [ cache release ].	cache := WebSiteCache new webSite: self.</body><body package="SiouX-Servlet">initializeFrom: configDictionary 	" The site's name must already be set.	  The configFileName is only set from Configuration Pages 		or from the Global Configuration File [sites] section. "	configParameters := configDictionary at: 'configuration'.	"Complete configuration regardless of error condition."	self resetLazyInitialized.	self initializeCache.	self initializeSitePolicy.	self initializeUrlManagerFrom: (configDictionary at: 'logical-names'				ifAbsent: [Dictionary new]).</body><body package="SiouX-Servlet">initializeSitePolicy	sitePolicy ifNotNil: [ :policy | policy release ].	sitePolicy := (self sitePolicyClass new site: self) initializeFrom: self configParameters</body><body package="SiouX-Servlet">initializeUrlManagerFrom: config	urlManager release.	urlManager := (self urlManagerClass new site: self) initializeFrom: config.	self isConfigure ifTrue: [urlManager addInternalLogicalNames].</body><body package="SiouX-Servlet">readSiteConfiguration	"Answer site configuration dictionary as read from ini file,	 	or the default error configuration dictionary if there is an error."	| config configFilename stream |	(configFilename := self configSource) isNil		ifTrue: [config := WebSiteConfiguration errorConfig]		ifFalse: 			[			[stream := (configFilename withEncoding: #default) readStream.			[config := (Net.INIScanner on: stream text) tokenizeAsDictionary]				ensure: [stream close]]					on: OS.OsInaccessibleError					do: 						[:ex |						config := WebSiteConfiguration errorConfig.						ex return]].	^config</body><body package="SiouX-Servlet">release	cache release.	urlManager release.	sitePolicy release.	self clearSessionCache.	homeDirectory := nil.	environment := nil.	contents := nil.</body><body package="SiouX-Servlet">resetFromForm: aForm	"Just set the specified configuration file, and configure."	self configureFromFile: (aForm at: 'configFileName' ifAbsent: [ #('') ]) first.</body><body package="SiouX-Servlet">resetLazyInitialized	environment := nil.	homeDirectory := nil</body></methods><methods><class-id>SiouX.WebSite</class-id> <category>testing</category><body package="SiouX-Servlet">canServe: aServletRequest	^(self registeredServletsOnly and: [ aServletRequest containsUnregisteredServletRequest ]) not.</body><body package="SiouX-Servlet">isConfigure	^ self name = self class configName.</body><body package="SiouX-Servlet">isDefault	^ self name = self class defaultName.</body></methods><methods><class-id>SiouX.WebSite</class-id> <category>api - servlet</category><body package="SiouX-Servlet">allowsUnregisteredServlets	^ self registeredServletsOnly not.</body><body package="SiouX-Servlet">classNameFromPathList: aCollection	"Return a class name based on the path list"	| aName |	aName := aCollection last.	^ ( '(x-ssp|x-servlet)\:.*' asRegex matches: aName )		ifTrue: [ aName asURI ]		ifFalse: [ aName ].</body></methods><methods><class-id>SiouX.WebSite</class-id> <category>api - files</category><body package="SiouX-Servlet">compareWithReadmesFirst: a and: b 	"Compare two strings, expected to be filenames, but anything that has the word readme in it comes first, all else up to that point being equal...  Ugh"	| bReadme restOfB aReadme restOfA firstOccurence |	a = 'readme.html' ifTrue: [^true].	b = 'readme.html' ifTrue: [^false].	aReadme := a indexOfSubCollection: 'readme' startingAt: 1.	bReadme := b indexOfSubCollection: 'readme' startingAt: 1.	(aReadme = bReadme) ifTrue: [^a &lt;= b].	firstOccurence := (aReadme max: bReadme) - 1. "get the non-zero one"	restOfA := a copyFrom: 1 to: (firstOccurence min: a size).	restOfB := b copyFrom: 1 to: (firstOccurence min: b size).	^restOfA = restOfB 		ifTrue: [aReadme ~= 0]  "We know it's only one, so if it's not A, it must be B"		ifFalse: [restOfA &lt;= restOfB].  "All else isn't equal, compare normally"</body><body package="SiouX-Servlet">requireDirectoryToBeSet	self directoryName isEmpty ifTrue: [		self isConfigure 			ifTrue: [ self error: #errNoHomeConfigure &lt;&lt; #dialogs &gt;&gt; 						'The configure site requires an absolute path.' ]			ifFalse: [ self error: ((#errNoHomeDirectory &lt;&lt; #dialogs &gt;&gt; 						'Site: &lt;1p&gt; has no home directory.') expandMacrosWith: self name) ] ].</body><body package="SiouX-Servlet">safePath: aString	"There seem to be a bunch of weird edge cases here with symbolic links and windows case-sensitivity. Ignore for now. This is plenty of weird edge cases for the moment"	"CAN YOU USE #resolvePath: ???"	| path result dir |	path := aString copyReplaceAll: '\\' with: '/'.	path := path copyReplaceAll: '//' with: '/'.	path := path copyReplaceAll: '/./' with: '/'.	"We don't handle /foo/../  properly."	path first = $/ ifTrue: [path := path copyFrom: 2 to: path size].	self requireDirectoryToBeSet.	result := self directoryName asLogicalFileSpecification construct: path.		"Disallow access outside the directory"	dir := self directoryName.	(result asString copyFrom: 1 to: dir size) = dir ifFalse: [^nil].	(result asString includes: '..') ifTrue: [^nil].	^result.</body></methods><methods><class-id>SiouX.WebSite</class-id> <category>sessions</category><body package="SiouX-Servlet">clearSessionCache	sessionCache isNil ifFalse: [		sessionCache allSessions do: [ :each | each release ].		sessionCache release ].	sessionCache := nil.</body><body package="SiouX-Servlet">initializeSessionCache	sessionCache := SessionCache new		addRule: SessionInactivityRule new;		yourself</body><body package="SiouX-Servlet">registerSession: aSession	^ self sessionCache rememberSession: aSession.</body><body package="SiouX-Servlet">removeSessionWithKey: aKey	(self sessionCache findSession: aKey) ifNotNil: [ :session | self sessionCache releaseSession: session ]</body><body package="SiouX-Servlet">sessionCache	sessionCache == nil ifTrue: [self initializeSessionCache].	^sessionCache</body><body package="SiouX-Servlet">sessionClass	| class |	class := self configParameterNamed: 'sessionClass'.	class isEmpty		ifFalse: [ ^ class asQualifiedReference value ].	class := self parentConfiguration configParameterNamed: 'sessionClass'.	(class isNil or: [ class isEmpty ])		ifTrue: [ ^ self class sessionClass ]		ifFalse: [ ^ class asQualifiedReference value ].</body><body package="SiouX-Servlet">sessionCookieName	^self sessionClass cookieName.</body><body package="SiouX-Servlet">sessionFor: aRequest createIfAbsent: aBoolean	| request |	request := aRequest.	^self		sessionFor: request		createIfAbsent: aBoolean		initializeWith: 			[:session |			session webSite: request webSite.			aRequest cachedSession: session.			WebSiteConfiguration shouldSetEncodingFromRequest ifTrue: [session encoding: request charset].			WebSiteConfiguration shouldSetLocaleFromRequest ifTrue: [session locale: request locale].			"WebSiteConfiguration handleEvent: 'sessionStartup' with: session"]</body><body package="SiouX-Servlet">sessionFor: aRequest createIfAbsent: aBoolean initializeWith: aBlock	| sessionID |	aRequest cachedSession isNil ifFalse: [^aRequest cachedSession.].	sessionID := (aRequest cookieValueAt: self sessionCookieName) 		ifNotNil: [ :cookie | cookie value].	^self		sessionWithKey: sessionID		createIfAbsent: aBoolean		initializeWith: aBlock.</body><body package="SiouX-Servlet">sessionWithKey: aKey	^self sessionWithKey: aKey createIfAbsent: true.</body><body package="SiouX-Servlet">sessionWithKey: aKey createIfAbsent: aBoolean	^self sessionWithKey: aKey createIfAbsent: aBoolean initializeWith: [:session | ].</body><body package="SiouX-Servlet">sessionWithKey: sessionId createIfAbsent: aBoolean initializeWith: aBlock 	| session existing |	existing := sessionId isNil 				ifTrue: [nil]				ifFalse: [self sessionCache findSession: sessionId].	existing notNil ifTrue: [^existing].	aBoolean ifFalse: [^nil].	sessionId == nil 		ifTrue: [session := self sessionClass newWithID]		ifFalse: [session := self sessionClass id: sessionId].	session webSite: self.	self registerSession: session.	aBlock value: session.	^session.</body></methods><methods><class-id>SiouX.WebSite</class-id> <category>private</category><body package="SiouX-Servlet">emptyPathDefault	self defaultPage isEmpty ifTrue: [		self isDefault ifTrue: [ ^ '/', self class configName, '/welcomePage' ].		self isConfigure ifTrue: [ ^ 'welcomePage' ] ].	^ self defaultPage.</body><body package="SiouX-Servlet">sitePolicyClass	^WebSitePolicy.</body><body package="SiouX-Servlet">trapErrorsOn: aBlock	aBlock on: Error do: [:ex | ex return].</body><body package="SiouX-Servlet">urlManagerClass	^SiouX.LogicalURLManager</body></methods><methods><class-id>SiouX.WebSite</class-id> <category>contents</category><body package="SiouX-Servlet">at: aKey	^self contents at: aKey.</body><body package="SiouX-Servlet">at: aKey ifAbsent: aBlock	^self contents at: aKey ifAbsent: aBlock.</body><body package="SiouX-Servlet">at: aKey ifAbsentPut: aBlock	^self contents at: aKey ifAbsentPut: aBlock.</body><body package="SiouX-Servlet">at: key ifPresent: aBlock	^self contents at: key ifPresent: (aBlock numArgs = 0 ifTrue: [[:x | aBlock value]] ifFalse: [aBlock]).</body><body package="SiouX-Servlet">at: aKey put: aValue	^self contents at: aKey put: aValue.</body><body package="SiouX-Servlet">attributeNames	^self contents keys</body><body package="SiouX-Servlet">contents	^contents ifNil: [ contents := SharedRegistry new ]</body><body package="SiouX-Servlet">includesKey: aKey	^self contents includesKey: aKey.</body><body package="SiouX-Servlet">keys	^self contents keys</body><body package="SiouX-Servlet">keysAndValuesDo: aBlock	self contents keysAndValuesDo: aBlock.</body><body package="SiouX-Servlet">removeKey: aKey	^self contents removeKey: aKey ifAbsent: [].</body><body package="SiouX-Servlet">removeKey: aKey ifAbsent: aBlock	^self contents removeKey: aKey ifAbsent: aBlock.</body></methods><methods><class-id>SiouX.WebSite</class-id> <category>caching</category><body package="SiouX-Servlet">clearCache	"Clear all cached data for this web site, 		including application variables and servlet instances,		by releasing and re-initializing both the application and the cache."	cache release.	contents :=nil.	self initializeCache.</body></methods><methods><class-id>SiouX.WebSite</class-id> <category>printing</category><body package="SiouX-Servlet">printOn: aStream	aStream 		nextPutAll: self class name;		space.	self name isNil 		ifTrue: [ aStream nextPutAll: (#tagNoname &lt;&lt; #www &gt;&gt; '~no-name~') asString ]		ifFalse: [ aStream nextPutAll: self name ].</body></methods><methods><class-id>SiouX.WebSite class</class-id> <category>constants</category><body package="SiouX-Servlet">configName	^ 'configure'.</body><body package="SiouX-Servlet">defaultEncodingName	"Hard-coded for the moment, but put here so that it can fairly easily be made a setting"	"Some people have asked for iso-8859-15, which is the same as -1, but with the Euro symbol. Changing this method (and probably doing some reinitialization, especially of #defaultWebLocale) would change that"	^'ISO8859-1'.</body><body package="SiouX-Servlet">defaultName	^ 'default'.</body><body package="SiouX-Servlet">identifierTag	^'&lt;!-- ', ((#htmlBuiltWithCincomSmalltalk &lt;&lt; #www &gt;&gt; 'Built with Cincom Smalltalk.') asString), ' http://www.cincomsmalltalk.com/main/ --&gt;'.</body></methods><methods><class-id>SiouX.WebSite class</class-id> <category>instance creation</category><body package="SiouX-Servlet">new	"The site needs a name in order to initialize properly."	^ self shouldNotImplement.</body><body package="SiouX-Servlet">new: aString	^ super new		name: aString copy.</body></methods><methods><class-id>SiouX.WebSite class</class-id> <category>private</category><body package="SiouX-Servlet">sessionClass	^ServletSession</body></methods><methods><class-id>SiouX.WebSitePolicy</class-id> <category>api</category><body package="SiouX-Servlet">canDealWithRequest: aWebRequest	"Return true if we might be the web site to take this request"	self site enabled ifFalse: [^false].	^self doesNotSpecifyDomain and: [self doesNotSpecifyAlias or: [                self specifiesAliasFor: aWebRequest]].</body><body package="SiouX-Servlet">ownsRequest: aWebRequest	"Return true if we should be the web site to take this request"	self site enabled ifFalse: [^false].	^(self specifiesDomainFor: aWebRequest) or: [		self doesNotSpecifyDomain and: [self specifiesAliasFor: aWebRequest]].</body><body package="SiouX-Servlet">preferredAlias	^ self doesNotSpecifyAlias		ifTrue: [ nil ]		ifFalse: [ aliases first ].</body><body package="SiouX-Servlet">preferredDomain	^ self doesNotSpecifyDomain		ifTrue: [ nil ]		ifFalse: [ domains first ].</body></methods><methods><class-id>SiouX.WebSitePolicy</class-id> <category>accessing</category><body package="SiouX-Servlet">aliasString	| coll stream |	coll := aliases.	stream := (String new: 100) writeStream.	coll 		do: [ :each | stream nextPutAll: each ]		separatedBy: [ stream nextPutAll: '; ' ].	^ stream contents.</body><body package="SiouX-Servlet">domainString	| coll stream |	coll := domains.	stream := (String new: 100) writeStream.	coll 		do: [ :each | stream nextPutAll: each ]		separatedBy: [ stream nextPutAll: '; ' ].	^ stream contents.</body><body package="SiouX-Servlet">setAliases: aString	"Default alias is the site name, except for the 'default' site."	| coll |	coll := (((aString tokensBasedOn: $;) collect: [ :ea1 | ea1 trimBlanks ])			reject: [ :ea2 | ea2 isEmpty ]).	coll isEmpty ifTrue: [		site isDefault			ifFalse: [ coll := OrderedCollection with: site name ] ].	aliases := OrderedCollection new.	aliases addAll: coll.</body><body package="SiouX-Servlet">setDomains: aString	| coll |	coll := (((aString tokensBasedOn: $;) collect: [ :ea1 | ea1 trimBlanks ])			reject: [ :ea2 | ea2 isEmpty ]).	domains := OrderedCollection new.	domains addAll: coll.</body><body package="SiouX-Servlet">site	^site.</body><body package="SiouX-Servlet">site: aWebSite	site := aWebSite.</body></methods><methods><class-id>SiouX.WebSitePolicy</class-id> <category>initialize</category><body package="SiouX-Servlet">initialize	domains := OrderedCollection new.	aliases := OrderedCollection new.</body><body package="SiouX-Servlet">initializeFrom: config	self setDomains: (config at: 'domains' ifAbsent: [ '' ]).	self setAliases: (config at: 'aliases' ifAbsent: [ '' ]).</body></methods><methods><class-id>SiouX.WebSitePolicy</class-id> <category>private</category><body package="SiouX-Servlet">doesNotSpecifyAlias	^aliases isEmpty.</body><body package="SiouX-Servlet">doesNotSpecifyDomain	^domains isEmpty.</body><body package="SiouX-Servlet">specifiesAliasFor: aWebRequest	"Answer true if first path component is a recognized alias."	^ aliases includes: aWebRequest peekUnconsumedPath.</body><body package="SiouX-Servlet">specifiesDomainFor: aServletRequest	"Answer true if request originated from a recognized domain."	^(domains 		detect: [:each | ('*', each) match: aServletRequest serverHostname]		ifNone: [nil]) notNil.</body></methods><methods><class-id>SiouX.WebSitePolicy class</class-id> <category>instance creation</category><body package="SiouX-Servlet">new	^super new initialize.</body></methods><methods><class-id>SiouX.ServletSession</class-id> <category>accessing</category><body package="SiouX-Servlet">at: aKey	^data at: aKey.</body><body package="SiouX-Servlet">at: aKey ifAbsent: aBlock	^data at: aKey ifAbsent: aBlock.</body><body package="SiouX-Servlet">at: aKey ifAbsentPut: aBlock	^data at: aKey ifAbsentPut: aBlock.</body><body package="SiouX-Servlet">at: aKey ifPresent: aBlock	^data at: aKey ifPresent: (aBlock numArgs = 0 ifTrue: [[:x | aBlock value]] ifFalse: [aBlock]).</body><body package="SiouX-Servlet">at: aKey put: aValue	^data at: aKey put: aValue.</body><body package="SiouX-Servlet">attributeAt: aKey	^self at: aKey.</body><body package="SiouX-Servlet">attributeAt: aKey ifAbsent: aBlock	^self at: aKey ifAbsent: aBlock.</body><body package="SiouX-Servlet">attributeAt: aKey ifAbsentPut: aBlock	^self at: aKey ifAbsentPut: aBlock.</body><body package="SiouX-Servlet">attributeAt: aKey ifPresent: aBlock	^self at: aKey ifPresent: aBlock.</body><body package="SiouX-Servlet">attributeAt: aKey put: aBlock	^self at: aKey put: aBlock.</body><body package="SiouX-Servlet">contents	^data</body><body package="SiouX-Servlet">encoding	^ super encoding ifNil: [WebSiteConfiguration defaultEncoding]</body><body package="SiouX-Servlet">includesKey: aKey	^data includesKey: aKey.</body><body package="SiouX-Servlet">keys	^data keys.</body><body package="SiouX-Servlet">keysAndValuesDo: aBlock	data keysAndValuesDo: aBlock.</body><body package="SiouX-Servlet">removeAttribute: aKey	^self removeKey: aKey.</body><body package="SiouX-Servlet">removeAttribute: aKey ifAbsent: aBlock	^self removeKey: aKey ifAbsent: aBlock.</body><body package="SiouX-Servlet">removeKey: aKey	^data removeKey: aKey ifAbsent: [].</body><body package="SiouX-Servlet">removeKey: aKey ifAbsent: aBlock	^data removeKey: aKey ifAbsent: aBlock.</body><body package="SiouX-Servlet">webSite	^webSite</body><body package="SiouX-Servlet">webSite: aWebSite	webSite := aWebSite</body></methods><methods><class-id>SiouX.ServletSession</class-id> <category>printing</category><body package="SiouX-Servlet">createdString	| aStream |	aStream := WriteStream on: (String new: 50).	aStream		nextPutAll: ((#Created &lt;&lt; #www &gt;&gt; 'created') asString);		nextPutAll: ' (';		nextPutAll: (self creationTime notNil 			ifTrue:[self creationTime printString] 			ifFalse: [((#tagUnknown &lt;&lt; #www &gt;&gt; '~unknown~') asString)]);		nextPut: $).	^ aStream contents.</body><body package="SiouX-Servlet">displayString		| writeStream |	writeStream := WriteStream on: (String new: 100).	writeStream		nextPutAll: 'Servlet Session'; 		crtab; nextPutAll: self sessionIDString;		crtab; nextPutAll: self lastAccessedString;		crtab; nextPutAll: self createdString;		cr.	^writeStream contents.</body><body package="SiouX-Servlet">reportOn: strm 	strm emphasis: #(bold large serif underline).	strm nextPutAll: 'ServletP Session'; crtab.	strm 		nextPutAll: ((#SessionDescription &lt;&lt; #www &gt;&gt; 'Session Description') asString); 		crtab; tab; nextPutAll: self sessionIDString; 		crtab; tab; nextPutAll: self lastAccessedString; 		crtab; tab; nextPutAll: self createdString; 		crtab.	self sessionReportOn: strm.	^strm contents</body><body package="SiouX-Servlet">reportString	| strm |	strm := TextStream on: (String new: 500).	self reportOn: strm.	^strm contents</body><body package="SiouX-Servlet">sessionIDString	| aStream |	aStream := WriteStream on: (String new: 50).	aStream		nextPutAll: ((#HttpSessionID &lt;&lt; #www &gt;&gt; 'Session ID = &lt;1s&gt;')			expandMacrosWith: id).	^ aStream contents.</body><body package="SiouX-Servlet">sessionReportOn: strm	|  |	strm emphasis: nil.	strm crtab; nextPutAll: ((#HttpSessionData &lt;&lt; #www &gt;&gt; 'Session Data') asString).	data isNil ifTrue: [		strm crtab; tab; nextPutAll: ((#tagNone &lt;&lt; #www &gt;&gt; '~none~') asString).		^strm contents].	data keysAndValuesDo: [:ky :val | 		strm crtab; tab. ky printOn: strm. strm nextPutAll: '-&gt;'. val printOn: strm].	^strm contents.</body></methods><methods><class-id>SiouX.ServletSession</class-id> <category>initialize-release</category><body package="SiouX-Servlet">expire	"Handle the event here, and nil out the web site so that we don't unnecessarily try and remove the session from the site's registry later, since we know that we were just removed."	super expire.	webSite := nil.</body><body package="SiouX-Servlet">initialize	super initialize.	data := SharedRegistry new.</body></methods><methods><class-id>SiouX.ServletSession</class-id> <category>comparing</category><body package="SiouX-Servlet">&lt;= aSession	^self lastUsed &lt;= aSession lastUsed.</body></methods><methods><class-id>SiouX.ServletSession class</class-id> <category>constants</category><body package="SiouX-Servlet">authorizationKey	^ '__VW_PRIVATE_LOGGED_IN_SITES'.</body><body package="SiouX-Servlet">cookieName	^'VW-WTK-sessionkey'.</body></methods><methods><class-id>OS.Filename class</class-id> <category>utilities</category><body package="SiouX-Servlet">urlString: aString	"Return the Filename (relative to current directory if not already absolute),		or nil if aString is nil or empty"	| fn |	(aString isNil or: [ aString isEmpty ]) ifTrue: [ ^ nil ].	(fn := self fromComponents: aString asURI decodedPath) isAbsolute		ifTrue: [ ^ fn ].	^ self defaultDirectory construct: (fn asString).</body></methods><methods><class-id>Core.WriteStream</class-id> <category>accessing</category><body package="SiouX-Servlet">crlf	"Append a return and lf character to the receiver."	self nextPut: Character cr.	self nextPut: Character lf.</body></methods><methods><class-id>SiouX.ServerSystem</class-id> <category>default actions</category><body package="SiouX-Servlet">setGlobalConfigFileName: fileNameStream	"This handles setting the AppServer configuration file name from the command line."	&lt;option: '-wtkcnf'&gt;	| settingNames |	"Anything previously in the caches is just garbage when the image restarts."	WebSiteConfiguration clearAllCaches.	WebSiteConfiguration allowSettingConfigFileName ifFalse: [^self].	settingNames := CommandLineInterest argumentsFrom: fileNameStream.	WebSiteConfiguration globalConfigFileName: settingNames first.</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>NetHttpResponder</name><environment>SiouX</environment><super>SiouX.Responder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>readingOptions writingOptions </inst-vars><class-inst-vars>defaultReadingOptions defaultWritingOptions </class-inst-vars><imports>			private OS.IOConstants.*			private Net.*			</imports><category></category><attributes><package>SiouX-Net-Http</package></attributes></class><class><name>Session</name><environment>SiouX</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id data status creationTime lastUsed properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Sessions</package></attributes></class><class><name>WriteStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>ServerSystem</name><environment>SiouX</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Core.*			Kernel.*			</imports><category></category><attributes><package>SiouX-Server</package></attributes></class></st-source>