<?xml version="1.0"?><st-source><!-- Name: AppeX-SupportComment: This package provides the basic functionality to write and manage Javascript code within the Smalltalk IDE.  It includes support for  bundling code into web text resources (termed libraries)  for provision to the client.DbIdentifier: bear73DbTrace: 502531DbUsername: vdegenDbVersion: 8.3 - 11PackageName: AppeX-SupportParcel: #('AppeX-Support')PrintStringCache: (8.3 - 11,vdegen)Version: 8.3 - 11Date: 3:30:53 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:30:53 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>AppeX</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			private SiouX.*			</imports><category></category><attributes><package>AppeX-Support</package></attributes></name-space><class><name>JavascriptWriter</name><environment>AppeX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars>serveFilesCombined </class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Support</package></attributes></class><comment><class-id>AppeX.JavascriptWriter</class-id><body>JavascriptWriter is a convenience class to generate Javascript code Instance Variables	stream	&lt;SequenceableCollectionWriteStream&gt;Class Instance Variables	serveFilesCombined &lt;Boolean&gt; Whether or not to combine all files and serve them as a single file to the web browser.</body></comment><class><name>FileLibrary</name><environment>AppeX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Support</package></attributes></class><comment><class-id>AppeX.FileLibrary</class-id><body>FileLibrary is an abstract class to support access to files such as Javascript or stylesheets, but it can also be used to implement custom file libraries.Subclasses must implement the following messages:	accessing		componentPaths		html</body></comment><class><name>JavascriptCompiler</name><environment>AppeX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>smalltalkSource originalSource </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Support</package></attributes></class><comment><class-id>AppeX.JavascriptCompiler</class-id><body>Javascript is the default compiler for JavascriptCode and its subclasses. It is always present in AppeX. This ensures that during runtime, Javascript code can be compiled into the image. At development time, if a Tools package is present, this class is overriden by one that implements additional behavior, such as code highlighting and code parsing.Instance Variables	originalSource	&lt;String&gt;	a String derived from a source object during compilation (String, Text or Stream)	smalltalkSource	&lt;String&gt;	originalSource converted into a form that can be compiled by the Smalltalk Compiler.</body></comment><class><name>JavascriptCode</name><environment>AppeX</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>codeCache </class-inst-vars><imports></imports><category>bootstrap</category><attributes><package>AppeX-Support</package></attributes></class><comment><class-id>AppeX.JavascriptCode</class-id><body>JavascriptCode is an abstract class with nil superclass. It is a common superclass for all the Javascript code. Its subclasses are used to generate Javascript code from their instance methods.Class Instance Variables	libraryName 	&lt;String&gt;	 	codeCache &lt;String&gt; lazy initializedImplementationAll the Smalltalk behavior is implemented as class methods, and JavascriptCode subclasses should never have to create instances.JavascriptCode knows its compilerClass. By default, it is JavascriptCompiler which installs the JS code as Smalltalk methods that return the body of a javascript function but nothing else. This is required to load and compile Javascript code when the Smalltalk IDE is not present, e.g., in a headless image. A different compiler can be installed when the image containes an IDE (see JavascriptCompiler subclasses).</body></comment><class><name>ResourcesChanged</name><environment>AppeX</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Support</package></attributes></class><comment><class-id>AppeX.ResourcesChanged</class-id><body>ResourcesChanged is an announcement about resource changes. This is to notify caches, etag registries, and other objects that may want to reset their state whenever HTML, JS, CSS or other such resources have changed.</body></comment><class><name>JavascriptComposer</name><environment>AppeX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>library </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Support</package></attributes></class><comment><class-id>AppeX.JavascriptComposer</class-id><body>The class and its subclasses specify an implementation for collecting and presenting the javascript or html code in a JavascriptLibrary.Typically this collection of javascript code is assembled in order to be passed on to a web browser.Instance Variables:	library	&lt;JavascriptLibrary &gt;	 library</body></comment><class><name>JavascriptLibrary</name><environment>AppeX</environment><super>AppeX.FileLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classes name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>bootstrap</category><attributes><package>AppeX-Support</package></attributes></class><comment><class-id>AppeX.JavascriptLibrary</class-id><body>JavascriptLibrary represents a collection of Javascript classes for the purpose of JS code generation.The value of the libraryName class instance variable in each of JavascriptCode subclasses determines which JavascriptLibrary the class belongs to. To find all the Javascript libraries and the classes they contain, evaluate 'JavascriptCode allLibraries'.Instance Variables	classes			&lt;Collection of &lt;JavascriptClass&gt;&gt;	classes that together form a JS library.	name			&lt;String&gt;	the name of a JS library</body></comment><shared-variable><name>Asterisks</name><environment>AppeX.JavascriptWriter</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>AppeX-Support</package></attributes></shared-variable><shared-variable><name>StartContentsString</name><environment>AppeX.JavascriptWriter</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>nil</initializer><attributes><package>AppeX-Support</package></attributes></shared-variable><shared-variable><name>Dashes</name><environment>AppeX.JavascriptWriter</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>AppeX-Support</package></attributes></shared-variable><shared-variable><name>EndContentsString</name><environment>AppeX.JavascriptWriter</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>nil</initializer><attributes><package>AppeX-Support</package></attributes></shared-variable><shared-variable><name>CloseBracket</name><environment>AppeX.JavascriptWriter</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>nil</initializer><attributes><package>AppeX-Support</package></attributes></shared-variable><shared-variable><name>StartInitializeString</name><environment>AppeX.JavascriptWriter</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>nil</initializer><attributes><package>AppeX-Support</package></attributes></shared-variable><shared-variable><name>SubscriptionRegistry</name><environment>AppeX.FileLibrary</environment><private>false</private><constant>false</constant><category>announcer</category><initializer></initializer><attributes><package>AppeX-Support</package></attributes></shared-variable><shared-variable><name>CompilerClass</name><environment>AppeX.JavascriptCode</environment><private>false</private><constant>false</constant><category>compiling</category><attributes><package>AppeX-Support</package></attributes></shared-variable><shared-variable><name>SubscriptionRegistry</name><environment>AppeX.JavascriptCode</environment><private>false</private><constant>false</constant><category>announcer</category><initializer></initializer><attributes><package>AppeX-Support</package></attributes></shared-variable><methods><class-id>AppeX.JavascriptWriter</class-id> <category>js generating</category><body package="AppeX-Support">writeEndContentsOfScriptWith: aClass	"Indicate the end of a GenericJavascript script"	self		write: EndContentsString, aClass fullName asQualifiedReference printString, CloseBracket;		cr</body><body package="AppeX-Support">writeInitializationCodeWith: aClass	"Emit the code contained within the javascript initialize function.  This code will be executed on load of the JavaScript resource.  	The initialize method itself will  be 'discarded', in that it will not be created and bound on the client side for further use."	|  methodSource  code startIndex|		methodSource := self sourceForJsFunction: #initialize inClass: aClass.	methodSource isNil ifTrue: [^self].	startIndex := methodSource indexOf: ${.	"remove parens from beginning and end of source, write the code on a new line"	code := methodSource copyFrom: startIndex + 1 to: methodSource size - 1.	self writeCode: code.</body><body package="AppeX-Support">writeJsClassCommentWith: aClass	"Use aWriter to write my class comments."	self		openComment;		write: '*';		tab: 2;		writeLine: aClass fullName;		writeAsteriskLine;		writeLine: aClass comment trimSeparators;		closeComment</body><body package="AppeX-Support">writeJsFunction: aSelector with: aClass	| pattern methodSource code |		methodSource := self sourceForJsFunction: aSelector inClass: aClass.	pattern := aClass jsFunctionPattern: aSelector writer: self.	code := pattern expandMacrosWith: methodSource.	self writeCode: code</body><body package="AppeX-Support">writeJsFunctionsWith: aClass	aClass jsFunctionsToBind do: 			[:eachSelector |			self writeVisualSeparatorLine.			self writeJsFunction: eachSelector with: aClass.			self cr: 2]</body><body package="AppeX-Support">writeLooseJsFunction: aSelector with: aClass	"write a function declaration for each selector. 	The function with name aSelector will be accessible within the scope of the function itself and its parent aClass)"	| methodSource  functionDeclaration|		methodSource := self sourceForJsFunction: aSelector inClass: aClass.	functionDeclaration := 'function ', methodSource.	self writeCode: functionDeclaration.</body><body package="AppeX-Support">writeLooseJsFunctionsWith: aClass	aClass jsFunctionsToBind do: 		[:eachSelector |			self cr.			self writeLooseJsFunction: eachSelector with: aClass.			]</body><body package="AppeX-Support">writeStartContentsOfScriptWith: aClass	"Indicate the start of a GenericJavascript script"	"e.g. // &lt;start: #{AppeX.HelloScript}&gt;"	self		write: StartContentsString, aClass fullName asQualifiedReference printString, CloseBracket;		cr</body><body package="AppeX-Support">writeStartInitializeOfScriptWith: aClass	"Indicate the start of the initiallize function GenericJavascript script"	self		write: StartInitializeString, aClass fullName asQualifiedReference printString, CloseBracket;		cr</body></methods><methods><class-id>AppeX.JavascriptWriter</class-id> <category>accessing</category><body package="AppeX-Support">asterisks	^self class asterisks</body><body package="AppeX-Support">dashes	^self class dashes</body><body package="AppeX-Support">javascriptNameForClass: aJavascriptClass	^ aJavascriptClass javascriptName</body><body package="AppeX-Support">sourceForJsFunction: aSelector inClass: aJavascriptClass"	Answer the source code for a function defined by aSelector in aJavascriptClass."	^ aJavascriptClass sourceForJsFunction: aSelector</body><body package="AppeX-Support">sterisks	^self class asterisks</body></methods><methods><class-id>AppeX.JavascriptWriter</class-id> <category>writing</category><body package="AppeX-Support">closeComment	self		write: self asterisks;		stepBack.	stream put: $/.	self cr</body><body package="AppeX-Support">contents	^stream contents</body><body package="AppeX-Support">cr	stream lf</body><body package="AppeX-Support">cr: count	count timesRepeat: [self cr]</body><body package="AppeX-Support">finishJsClassDefinitionFor: aJavascriptClass	self cr; tab.	stream put: $}.	self cr.	stream write: '});'.	self cr.</body><body package="AppeX-Support">openComment	stream put: $/.	self		write: self asterisks;		stepBack;		cr</body><body package="AppeX-Support">startJsClassDefinitionFor: aJavascriptClass	| superclassName |	superclassName := aJavascriptClass superclass javascriptName.	self		cr;		write: aJavascriptClass jsNamespace;		write: '.defineClass({';		cr;		tab;		write: 'superclass: ';		write: superclassName;		write: ',';		cr; tab;		write: 'constructor: ';		write: 'function ';		write: aJavascriptClass javascriptConstructorName;		write: '() {'.		aJavascriptClass shouldCallParentConstructor ifFalse: [^self].	self		cr; tab;		write: '//call the parent constructor in the context of the current object(new instance) ';		cr; tab;		write: superclassName;		write: '.apply(this,arguments);'.</body><body package="AppeX-Support">stepBack	self stepBack: 1</body><body package="AppeX-Support">stepBack: count	stream -- count</body><body package="AppeX-Support">tab	stream tab</body><body package="AppeX-Support">tab: count	stream tab: count</body><body package="AppeX-Support">write: aString	aString do: [ :char |		char = Character cr 				ifTrue: [self cr] 				ifFalse: [ stream put: char ]]</body><body package="AppeX-Support">writeAsteriskLine	self		writeAsterisks;		cr</body><body package="AppeX-Support">writeAsterisks	self write: self asterisks</body><body package="AppeX-Support">writeCode: aString	self		write: aString;		cr</body><body package="AppeX-Support">writeCodeSnippets: anArray in: anObject	anArray do: 			[:each |			self				writeVisualSeparatorLine;				writeLine: (anObject perform: each)]</body><body package="AppeX-Support">writeComment: aString	| lines strStream |	lines := OrderedCollection new.	strStream := aString readStream.	[strStream atEnd]		whileFalse: [lines add: (strStream upTo: Character cr) trimBlanks].	lines size &gt; 1		ifTrue: 			[self				openComment;				write: aString;				closeComment]		ifFalse: 			[self				write: '//  ';				write: aString].	self cr</body><body package="AppeX-Support">writeJavascriptFor: anObject	anObject writeJavascriptWith: self.	^self contents</body><body package="AppeX-Support">writeLine: aString	self		write: aString;		cr</body><body package="AppeX-Support">writeVisualSeparatorLine	self writeComment: self dashes</body></methods><methods><class-id>AppeX.JavascriptWriter</class-id> <category>initialize-release</category><body package="AppeX-Support">initialize	stream := String new writing.</body><body package="AppeX-Support">writeJavascriptWith: aJavascriptClass	self writeJsClassCommentWith: aJavascriptClass.	aJavascriptClass writeJsNamespacesWith: self.	aJavascriptClass writeJsCodeWith: self</body></methods><methods><class-id>AppeX.JavascriptWriter class</class-id> <category>accessing</category><body package="AppeX-Support">asterisks	^Asterisks</body><body package="AppeX-Support">dashes	^Dashes</body><body package="AppeX-Support">serveFilesCombined	^serveFilesCombined ifNil: [serveFilesCombined :=  false]</body><body package="AppeX-Support">serveFilesCombined: aBoolean	serveFilesCombined := aBoolean</body></methods><methods><class-id>AppeX.JavascriptWriter class</class-id> <category>instance creation</category><body package="AppeX-Support">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="AppeX-Support">writeJavascriptWith: aJavascriptClass	^self new		writeJavascriptWith: aJavascriptClass;		yourself</body></methods><methods><class-id>AppeX.JavascriptWriter class</class-id> <category>class initialization</category><body package="AppeX-Support">initialize	Asterisks := '******************************************************************************************'.	Dashes := '--------------------------------------------------------------------------------------'.	StartInitializeString := '//  &lt;startInitialize: '.	StartContentsString := '//  &lt;startContents: '.	EndContentsString := '//  &lt;endContents: '.	CloseBracket := '&gt;'.</body></methods><methods><class-id>AppeX.FileLibrary</class-id> <category>accessing</category><body package="AppeX-Support">combineClassesInto: aJavascriptLibrary"	Combine the classes I use to aJavascriptLibrary.	Answer a boolean indicating whether combining was successful.	By default, I don't have any classes to add - answer false.	JavascriptLibrary must override this method."	^ false</body><body package="AppeX-Support">htmlPart"	Answer my HTML."	^ self subclassResponsibility</body><body package="AppeX-Support">pragmaSelector"	Answer a symbol that is used as a Pragma selector when installing request action for my components.	#file: by default, but subclasses should override."	^ #file:</body><body package="AppeX-Support">resourcePaths"	Answer a collection of strings that constitue all my paths.	Some libraries have a single path - return a one-element array.	Subclss responsibility."	^ self subclassResponsibility</body></methods><methods><class-id>AppeX.FileLibrary</class-id> <category>testing</category><body package="AppeX-Support">isJavascriptLibrary	^false</body></methods><methods><class-id>AppeX.FileLibrary class</class-id> <category>initialize-release</category><body package="AppeX-Support">obsolete	self resetSubscriptionRegistry.	super obsolete</body><body package="AppeX-Support">resetSubscriptionRegistry		SubscriptionRegistry release.	SubscriptionRegistry := nil</body></methods><methods><class-id>AppeX.FileLibrary class</class-id> <category>compiling</category><body package="AppeX-Support">instanceMethodsChanged	self announce: ResourcesChanged new</body></methods><methods><class-id>AppeX.FileLibrary class</class-id> <category>announcements</category><body package="AppeX-Support">subscriptionRegistry: newRegistry 	SubscriptionRegistry := newRegistry</body><body package="AppeX-Support">subscriptionRegistryOrNil	^SubscriptionRegistry</body></methods><methods><class-id>AppeX.JavascriptCompiler</class-id> <category>public access</category><body package="AppeX-Support">annotateJavascriptMethod: aCompiledMethod	"Annotated @aCompiledMethod with message sends so that the method can be found by browsing senders."	^ aCompiledMethod withAdditionalProperties: (Array with: (Message selector: #language: argument: 'Javascript'))</body><body package="AppeX-Support">compile: textOrStream in: aContext allowReceiver: allowSelf class: aClass environment: env noPattern: noPattern notifying: aRequestor ifFail: failBlock	"	Convert textOrStream to a format that can be compiled into a Smalltalk method.	Then use the standard Compiler to do the rest of compilation.	"	| method |	self		from: textOrStream		class: aClass		context: aContext		notifying: aRequestor.	method := Compiler new				compile: smalltalkSource				in: aContext				allowReceiver: allowSelf				class: aClass				environment: env				noPattern: noPattern				notifying: aRequestor				ifFail: failBlock.	^self compiled: method</body><body package="AppeX-Support">compile: textOrStream in: aContext allowReceiver: allowSelf	class: aClass environment: env noPattern: noPattern	notifying: aRequestor ifFail: failBlock handler: aHandler	"	Convert textOrStream to a format that can be compiled into a Smalltalk method.	Then use the standard Compiler to do the rest of compilation.	"	| method |	self		from: textOrStream		class: aClass		context: aContext		notifying: aRequestor.	method := Compiler new		compile: smalltalkSource		in: aContext		allowReceiver: allowSelf		class: aClass		environment: env		noPattern: noPattern		notifying: aRequestor		ifFail: failBlock		handler: aHandler.	^self compiled: method</body><body package="AppeX-Support">compile: textOrStream in: aClass notifying: aRequestor ifFail: failBlock	"	Convert textOrStream to a format that can be compiled into a Smalltalk method.	Then use the standard Compiler to do the rest of compilation.	"	| methodNodeHolder |	self		from: textOrStream		class: aClass		context: nil		notifying: aRequestor.	methodNodeHolder := Compiler new				compile: smalltalkSource				in: aClass				notifying: aRequestor				ifFail: failBlock.	^methodNodeHolder		method: (self compiled: methodNodeHolder generate);		yourself</body><body package="AppeX-Support">environment: namespace	"Ignored"</body><body package="AppeX-Support">parseSelector: aString	"Answer a String identifying the Smalltalk selector corresponding with the name of a Javascript function at the beginning of @aString.	"	^(aString readStream upTo: $() trimBlanks</body></methods><methods><class-id>AppeX.JavascriptCompiler</class-id> <category>private</category><body package="AppeX-Support">compiled: aCompiledMethodOrNil	"	I have compiled code into @aCompiledMethod. Finish compilation. This is a hook to allow subclasses to return annotated methods.	"	^aCompiledMethodOrNil ifNotNil: [ :method |			self annotateJavascriptMethod: method]</body><body package="AppeX-Support">from: textOrStream class: ignoredClass context: ignoredContext notifying: ignored"	The original source can be a String, a Text, a Stream, or a Document. Ensure it is a String, and keep it for later use.	Assume it is NOT a Smalltalk source - build a new source that can be processed by a Smalltalk Compiler	and keep it for later use."	originalSource := ((textOrStream isKindOf: Stream)		ifTrue: [textOrStream contents]		ifFalse: [textOrStream ]) asString.	smalltalkSource := (self parseSelector: originalSource)		ifNotNil: [ :selector |			(String new writeStream)					nextPutAll: selector;					cr;					cr;					tab;					nextPut: $^;					nextPutAll: originalSource printString;					contents ]		ifNil: [ '' "I couldn't parse the selector. I can't return meaningful method source, but can't leave smalltalkSource nil."]</body></methods><methods><class-id>AppeX.JavascriptCompiler class</class-id> <category>class initialization</category><body package="AppeX-Support">preferredParserClass	^Compiler preferredParserClass</body></methods><methods><class-id>AppeX.JavascriptCode class</class-id> <category>accessing</category><body package="AppeX-Support">asJavascriptLibrary		^(JavascriptLibrary newNamed: self fullName, '.js')		addClass: self;		yourself</body><body package="AppeX-Support">coreCodeLibrary	^JavascriptLibrary named: self coreCodeLibraryName</body><body package="AppeX-Support">coreCodeLibraryName	^'AppeX.CoreCode.js'</body><body package="AppeX-Support">defaultLibraryName	"Answer the default library name (nil). Subclasses may override. Subclasses that belong to the same library should return the same name."	^self environment asJavascriptLibraryName</body></methods><methods><class-id>AppeX.JavascriptCode class</class-id> <category>testing</category><body package="AppeX-Support">isJavascriptCode	^true</body><body package="AppeX-Support">isJavascriptObject	^false</body><body package="AppeX-Support">shouldCallParentConstructor	"Answer false  Can be overriden in subclasses.  Compatibility with JavascriptObject and subclasses."	^false</body></methods><methods><class-id>AppeX.JavascriptCode class</class-id> <category>javascript generating</category><body package="AppeX-Support">javascript	"	Answer a String that is a complete Javascript representation of the class,	including the constructor and functions bound to its prototype.	Use JavascriptWriter to help with formatting, convenience behavior, etc.	"		codeCache ifNil: [codeCache := (JavascriptWriter writeJavascriptWith: self) contents ].	^codeCache</body><body package="AppeX-Support">javascriptConstructorName	^self name</body><body package="AppeX-Support">javascriptName	^self jsNamespace, '.', self javascriptConstructorName</body><body package="AppeX-Support">jsFunctionPattern: aSelector writer: aWriter	^'(function &lt;1s&gt;)();'.</body><body package="AppeX-Support">jsFunctionsToBind	| coll |	coll := self selectors sorted asOrderedCollection.	coll remove: #initialize ifAbsent: [nil].	^coll</body><body package="AppeX-Support">jsNamespace	| fullName |	fullName := self environment == Smalltalk				ifTrue: ['$t']				ifFalse: [self environment fullName].	^ fullName</body><body package="AppeX-Support">resetAllCodeCache	JavascriptCode allSubclassesDo: [ :cl | cl resetCodeCache ]</body><body package="AppeX-Support">resetCodeCache	codeCache := nil</body><body package="AppeX-Support">sourceForJsFunction: aSelector	| method |		method := self methodDictionary at: aSelector ifAbsent: [^nil].	"WARNING:  DO NOT STEP THROUGH THE NEXT LINE OF CODE OR THE IMAGE MAY CRASH"	^method valueWithReceiver: self basicNew arguments: #().</body><body package="AppeX-Support">writeJavascriptWith: aWriter	"Use aWriter to write my class comments, followed by my code."	aWriter writeJsClassCommentWith: self.	self writeJsCodeWith: aWriter</body><body package="AppeX-Support">writeJsCodeWith: aWriter	"change this to aFunctionName = function () {, so that the function can be referenced"	aWriter cr.	aWriter write: self javascriptName,' = function '.	aWriter write: self javascriptConstructorName.	aWriter write: '() {'.	aWriter writeInitializationCodeWith: self.	aWriter write: '};'.	aWriter writeJsFunctionsWith: self.	aWriter cr.</body></methods><methods><class-id>AppeX.JavascriptCode class</class-id> <category>initialize-release</category><body package="AppeX-Support">obsolete	self resetSubscriptionRegistry.	super obsolete</body><body package="AppeX-Support">resetSubscriptionRegistry		SubscriptionRegistry release.	SubscriptionRegistry := nil</body></methods><methods><class-id>AppeX.JavascriptCode class</class-id> <category>calculated</category><body package="AppeX-Support">libraryNameMinFromName: aString	"self libraryNameMinFromName: 'hi.js'"	^(aString first:(aString size - '.js' size)),  '-min.js'.</body></methods><methods><class-id>AppeX.JavascriptCode class</class-id> <category>announcements</category><body package="AppeX-Support">subscriptionRegistry: newRegistry 	SubscriptionRegistry := newRegistry</body><body package="AppeX-Support">subscriptionRegistryOrNil	^SubscriptionRegistry</body></methods><methods><class-id>AppeX.JavascriptCode class</class-id> <category>class initialization</category><body package="AppeX-Support">initialize"	The usefullness of this is someqhat questionable. The JavascriptCode class is initialized when first loaded	in the image, but not on merge. Also, the subclasses only get initialized if they actually implement #initialize,	not simply by inheriting."	self resetAllCodeCache</body></methods><methods><class-id>AppeX.JavascriptCode class</class-id> <category>compiling</category><body package="AppeX-Support">compilerClass	^CompilerClass ifNil: [ JavascriptCompiler ]</body><body package="AppeX-Support">compilerClass: aClass	CompilerClass := aClass</body><body package="AppeX-Support">generateClientMethodFor: aPragma	"no-op (compatibility with ApplicationClient).  Will be disabled except for ApplicationClient."</body><body package="AppeX-Support">instanceMethodsChanged	self resetCodeCache.	self announce: ResourcesChanged new.	"register interest in this event to delete cached minified code (JavascriptLibraries will cache minified code that can also be in files)"	JavascriptComposer withAllSubclasses do: [:eClass | eClass instanceMethodsChanged: self].</body></methods><methods><class-id>AppeX.JavascriptCode class</class-id> <category>library</category><body package="AppeX-Support">registerAsLibrary"	Register myself asJavascriptLibrary. Return the library."	^ self asJavascriptLibrary register</body></methods><methods><class-id>AppeX.JavascriptComposer</class-id> <category>accessing</category><body package="AppeX-Support">code	"	Answer a String which is the javascript to be emitted as a JS library for a collection of classes.	"	^self library classes size = 1		ifTrue: [self library classes first javascript]		ifFalse: [ | stream |			stream := String new writing.			self library classes do: [ :cl | stream write: cl javascript].			stream contents].</body><body package="AppeX-Support">htmlPartName 	^self library name</body><body package="AppeX-Support">library	^library</body><body package="AppeX-Support">library: aJavascriptLibrary	library := aJavascriptLibrary</body></methods><methods><class-id>AppeX.JavascriptComposer class</class-id> <category>instance creation</category><body package="AppeX-Support">on: aJavascriptLibrary	^self new		library: aJavascriptLibrary;		yourself</body></methods><methods><class-id>AppeX.JavascriptComposer class</class-id> <category>public</category><body package="AppeX-Support">instanceMethodsChanged: aJavascriptCodeClass	"do nothing"</body></methods><methods><class-id>AppeX.JavascriptLibrary</class-id> <category>testing</category><body package="AppeX-Support">isCore	^name = JavascriptCode coreCodeLibraryName</body><body package="AppeX-Support">isJavascriptLibrary	^true</body></methods><methods><class-id>AppeX.JavascriptLibrary</class-id> <category>accessing</category><body package="AppeX-Support">addClass: aClass	(self classes includes: aClass) ifFalse: [self classes add: aClass]</body><body package="AppeX-Support">addClasses: aCollection	aCollection do: [:e | self addClass: e]</body><body package="AppeX-Support">addClassesFrom: anotherLibrary"	Add all classes from anotherLibrary to myself."	classes := classes ifNil: [OrderedCollection new].	anotherLibrary classes do: [:eachClass |		(classes includes: eachClass) ifFalse: [ classes add: eachClass ]]</body><body package="AppeX-Support">classes	"classes := nil"	^classes ifNil: [classes := OrderedCollection new]</body><body package="AppeX-Support">classes: aCollection	classes := aCollection</body><body package="AppeX-Support">code: aCodeHandler	"	Answer a String which is the javascript to be emitted as a JS library for a collection of classes.	Example:		CoreCode javascriptLibrary code	"		^(aCodeHandler on: self)  code</body><body package="AppeX-Support">combineClassesInto: aJavascriptLibrary"	Combine the classes I use to aJavascriptLibrary.	Answer a boolean indicating whether combining was successful."	aJavascriptLibrary ifNil: [ ^ false ].	aJavascriptLibrary == self ifTrue: [ ^ false ].	aJavascriptLibrary addClassesFrom: self.	^true</body><body package="AppeX-Support">htmlPart: aCodeComposer	^ '	&lt;script src="', (self htmlPartName: aCodeComposer), '"&gt;&lt;/script&gt;'</body><body package="AppeX-Support">htmlPartName: aCodeComposer 	^(aCodeComposer on: self) htmlPartName</body><body package="AppeX-Support">name	^name</body><body package="AppeX-Support">nameMin	^JavascriptCode libraryNameMinFromName: self name.</body><body package="AppeX-Support">pragmaSelector"	Answer a symbol that is used as a Pragma selector when installing request action for my components.	Subclass responsibility."	^ #js:</body><body package="AppeX-Support">removeClass: aClass	(self classes includes: aClass) ifTrue: [self classes remove: aClass]</body><body package="AppeX-Support">resourcePaths: aCodeHandler	^ Array with: (self resourcePathsName: aCodeHandler)</body><body package="AppeX-Support">resourcePathsName: aCodeComposer	^self htmlPartName: aCodeComposer</body></methods><methods><class-id>AppeX.JavascriptLibrary</class-id> <category>initialize-release</category><body package="AppeX-Support">initialize: libraryName	name := libraryName.</body></methods><methods><class-id>AppeX.JavascriptLibrary class</class-id> <category>instance creation</category><body package="AppeX-Support">newNamed: aString	^ self new		initialize: aString;		yourself</body></methods><methods><class-id>AppeX.JavascriptLibrary class</class-id> <category>accessing</category><body package="AppeX-Support">forClass: aClass	^ (self named: aClass asJavascriptLibraryName)		classes: (Array with: aClass);		yourself</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>accessing</category><body package="AppeX-Support">asJavascriptLibraryName	^ self fullName, '.js'</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>accessing</category><body package="AppeX-Support">asJavascriptLibraryName	^ self fullName, '.js'</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>testing</category><body package="AppeX-Support">isJavascriptCode	^false</body></methods><methods><class-id>AppeX.JavascriptLibrary class</class-id> <category>configuration</category><body package="AppeX-Support">libraryPragmas	&lt;pragmas: #class&gt;		^#(#library:)</body></methods><initialize><class-id>AppeX.JavascriptWriter</class-id></initialize><initialize><class-id>AppeX.JavascriptCode</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>NameSpace</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>Announcement</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Announcements</category><attributes><package>System-Announcements</package></attributes></class></st-source>