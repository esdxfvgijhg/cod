<?xml version="1.0"?><st-source><!-- Name: SiouX-SessionsNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: This package contains code that can be used to manage HTTP sessions.OverviewThe two key classes are SessionCache and Session. A SessionCache can be freely created by an application. SessionCache provides a reentrant mechanism to cache, lookup and release Session objects. When a SessionCache is no longer in use, it should be released.Usagecache := SessionCache new.session := Session newWithID.cache rememberSession: session."..."cache findSession: session id."..."cache releaseSession: session."..."cache release.A SessionCache can be configured with various rules, instances of subclasses of SessionCachingRule.Example:cache addRule: (SessionInactivityRule withDuration: 1 minutes).Any object can register interest in a SessionCache events. As an example, consider an object that wants to be notified when sessions are cached, being pruned, or released. It would be up the object to implement the corresponding callback methods in the code snippet below:observer := <some object>cache when: SessionCached do: [ :ann | observer sessionCached: ann session ].cache when: SessionPruning do: [ :ann | observer sessionPruning: ann session ].cache when: SessionReleased do: [ :ann | observer sessionReleased: ann session ].For details about SessionCache, Session, as well as SessionCachingRule and SessionAnnouncement subclasses, see the class comments.Additional examples of SessionCache use can be found in the AppeX web application development framework.DbIdentifier: bear73DbTrace: 493314DbUsername: tkoganDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'SiouX-Server' '') #(#any 'SecurityBase' ''))PackageName: SiouX-SessionsParcel: #('SiouX-Sessions')PrerequisiteDescriptions: #(#(#name 'SiouX-Server' #componentType #bundle) #(#name 'SecurityBase' #componentType #package))PrerequisiteParcels: #(#('SiouX-Server' '') #('SecurityBase' ''))PrintStringCache: (8.3 - 1,tkogan)Version: 8.3 - 1Date: 1:19:06 PM July 14, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jul17.2) of July 14, 2017 on July 14, 2017 at 1:19:06 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SessionFilter</name><environment>SiouX</environment><super>SiouX.RequestFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sessionCache sessionClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Sessions</package></attributes></class><comment><class-id>SiouX.SessionFilter</class-id><body>SessionFilter is an abstract class for filters that know how to extract session information from an HTTP request and provide access to sessions cached in the filter's session cache.Subclasses must implement the following messages:	services		extractSessionIdFrom:Instance Variables	sessionCache	&lt;SessionCache&gt;	the session cache to be used by the filter.	sessionClass	&lt;Session class&gt;	class of the sessions to be created.UsageTo see examples of the session filter load SiouX-Examples parcel.</body></comment><class><name>SessionAnnouncement</name><environment>SiouX</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Sessions</package></attributes></class><comment><class-id>SiouX.SessionAnnouncement</class-id><body>SessionAnnouncement is an abstract announcement class for notifications about events in a SessionCache.Instance Variables	session	&lt;Session&gt;	the session on which the announcement is being sent.</body></comment><class><name>SessionPruning</name><environment>SiouX</environment><super>SiouX.SessionAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Sessions</package></attributes></class><comment><class-id>SiouX.SessionPruning</class-id><body>SessionPruning is sent when aSession is about to be pruned in aSessionCache.</body></comment><class><name>Session</name><environment>SiouX</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id data status creationTime lastUsed properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Sessions</package></attributes></class><comment><class-id>SiouX.Session</class-id><body>Session represents session data kept in a SessionCache.Instance Variables:	creationTime	&lt;Timestamp&gt;	the UTC timestamp of the session creation	data	&lt;Object&gt;	any object can serve as a session's data.	id	&lt;String&gt;	an id string uniquely identifying the session.	lastUsed	&lt;Timestamp&gt;	the UTC timestamp of when the session was last used before expiration.	locale	&lt;Locale&gt;	(optional) the locale assigned to the session.	status	&lt;Symbol&gt;	status of a session can be #active or #expired. Subclasses may define other status values.</body></comment><class><name>SessionCached</name><environment>SiouX</environment><super>SiouX.SessionAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Sessions</package></attributes></class><comment><class-id>SiouX.SessionCached</class-id><body>SessionCached is announced when aSession has been added to a SessionCache.</body></comment><class><name>ExpiredSessionError</name><environment>SiouX</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Sessions</package></attributes></class><comment><class-id>SiouX.ExpiredSessionError</class-id><body>ExpiredSessionError is raised by an expired session if someone is trying to activate it</body></comment><class><name>SessionReleased</name><environment>SiouX</environment><super>SiouX.SessionAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Sessions</package></attributes></class><comment><class-id>SiouX.SessionReleased</class-id><body>SessionReleased is announced when aSession has been released from aSessionCache.</body></comment><class><name>SessionAuthenticationFilter</name><environment>SiouX</environment><super>SiouX.RequestFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>authenticatePath </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Sessions</package></attributes></class><comment><class-id>SiouX.SessionAuthenticationFilter</class-id><body>AuthenticationFilter is abstract class for filters that provide session authenication. By default the filter ignores all requests without #sessionID. Subclasses have to override:	authenticateSession:for:Instance Variables:	authenticatePath	&lt;String&gt;	a request with this path url requires to invoke an application authentication.</body></comment><class><name>SessionIDGenerator</name><environment>SiouX</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessProtect random </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Sessions</package></attributes></class><comment><class-id>SiouX.SessionIDGenerator</class-id><body>SessionIDGenerator generates next session idInstance Variables	accessProtect	&lt;Semaphore&gt;	accessProtect	random	&lt;FastRandom&gt;	randomShared Variables	Default &lt;SessionIDGenerator&gt; default generator</body></comment><class><name>SessionCachingRule</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Sessions</package></attributes></class><comment><class-id>SiouX.SessionCachingRule</class-id><body>SessionCachingRule accepts notifications about accesses from a SessionCache. SessionCachingRule can collect info on these accesses and alter the SessionCache, perhaps removing old, unaccessed sessions, in accordance with a desired caching behavior. UsageExamples of some of the more exotic things future SessionCachingRule subclasses could do include:	- have different timeout thresholds depending on the session itself: what application, what user, what they were doing (ordering or	  just browsing, etc.)	- maintain some sort of linked data structure when notifications come in, so that purges don't require an iteration over all items	- be more aggressive according to general environment: is it a busy time of day? is the free space in the image low?	- soften the purging process by placing a tiny stub answer where the session used to be, which lives for say a day, with a personalized explanation of the timeout	- shuttle expired sessions to secondary storage, restoring them to in-image if faulted</body></comment><class><name>SessionInactivityRule</name><environment>SiouX</environment><super>SiouX.SessionCachingRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>duration </inst-vars><class-inst-vars>duration </class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Sessions</package></attributes></class><comment><class-id>SiouX.SessionInactivityRule</class-id><body>SessionInactivityRule represents caching rules that expire session after a period of inactivty.Instance Variables	duration	&lt;Duration&gt;	period of time after which sessions should expire if not active.Class Instance Variables	duration	&lt;Duration&gt;	default period of time after which sessions should expire if not active.</body></comment><class><name>SessionCache</name><environment>SiouX</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sessionRegistry accessLock rules pruningFrequency pruningTimer </inst-vars><class-inst-vars>pruningFrequency </class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Sessions</package></attributes></class><comment><class-id>SiouX.SessionCache</class-id><body>SessionCache is a generic cache to keep track of sessions in regular intervals, invoking caching rules to perform actions on the sessions being cached.Overview	The basic behavior of a SessionCache is to remember, lookup, and release sessions. Each of these actions results in a notification being sent to a collection of rules that govern the more specific caching behavior. In addition, each remember/release action is announced with SessionCached/SessionReleased announcement classes.	A SessionCache periodically performs pruning actions. Every time pruning occurs, the caching rules configured in the cache receive notification about the cache and the individual sessions being pruned. It is up to the caching rules to determine which actions should be performed on the sessions (e.g., when a session should expire), based on specific conditions implemented by the rules. When a session is being pruned, the SessionCache announces it with SessionPruning class.Instance Variables	accessLock	&lt;RecursionLock&gt;	provides serialized access to the internal state.	pruningFrequency	&lt;Duration&gt;	how often prunning of the cache occurs.	pruningTimer	&lt;Timer&gt;	timer that fires the pruning	rules	&lt;OrderedCollection&gt;		collection of SessionCachingRules	sessionRegistry	&lt;Dictionary&gt;		keys are session ids, values are instances of SessionClass Instance Variables	pruningFrequency 	&lt;Duration&gt; 	The default pruning frequency for newly created instances of SessionCache.Usage	When a session cache is created, it should be configured with caching rules governing expiration or other desired caching behavior.	Optionally, a session cache pruning frequency can be set to a value different from the default. Refer to SessionCachingRule comments and its subclasses for details.	For example:	| cache |	cache := SessionCache new		pruneEvery: 30 seconds;		addRule: (SessionInactivityRule withDuration: 10 minutes);		" etc..."		yourself	A previously configured caching rule can be removed or replaced with a different rule. When a rule is being added to a cache, it will automatically replace an existing rule of the same class. Thus, one only needs to add/remove rules:	cache removeRuleOf: SessionInactivityRule	cache addRule: (SessionInactivityRule withDuration: 1 minutes)	To add, lookup, and release sessions from the cache:	cache rememberSession: aSession	cache findSession: &lt;a session id&gt;		- typically, a session id would be a string but it may be application specific.	cache releaseSession: aSession	Interested objects may receive notifications about the caching events via announcements, for example:	cache when: SessionCached do: [ :ann | session := ann session ]	cache when: SessionPruning do: [ :ann | session := ann session ]	cache when: SessionReleased do: [ :ann | session := ann session ]</body></comment><shared-variable><name>Default</name><environment>SiouX.SessionIDGenerator</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>SiouX-Sessions</package></attributes></shared-variable><methods><class-id>SiouX.SessionFilter</class-id> <category>accessing</category><body package="SiouX-Sessions">sessionCache	^sessionCache ifNil: [ sessionCache := self defaultSessionCacheClass new ]</body><body package="SiouX-Sessions">sessionCache: aSessionCache	sessionCache := aSessionCache</body><body package="SiouX-Sessions">sessionClass	^sessionClass ifNil: [ sessionClass := self defaultSessionClass ]</body><body package="SiouX-Sessions">sessionClass: aSessionClass	sessionClass := aSessionClass</body></methods><methods><class-id>SiouX.SessionFilter</class-id> <category>services</category><body package="SiouX-Sessions">applyTo: aRequestContext"Extract a session id and find or create a new session "	^ (self extractSessionIdFrom: aRequestContext)		ifNil: [self noSessionIdPresentIn: aRequestContext]		ifNotNil: [:sessionId |			(self findSession: sessionId)				ifNil: [self noSessionFound: sessionId in: aRequestContext]				ifNotNil: [ :session | self acceptSession: session for: aRequestContext ]]</body><body package="SiouX-Sessions">cacheNewSession	^ self sessionCache rememberSession: self newSession</body><body package="SiouX-Sessions">extractSessionIdFrom: aRequestContext"The method has to return a session id or nil "	^ self subclassResponsibility</body><body package="SiouX-Sessions">findSession: sessionId	^ self sessionCache findSession: sessionId</body><body package="SiouX-Sessions">newSession	^self sessionClass newWithID</body></methods><methods><class-id>SiouX.SessionFilter</class-id> <category>defaults</category><body package="SiouX-Sessions">defaultSessionCacheClass	^ SessionCache</body><body package="SiouX-Sessions">defaultSessionClass	^ Session</body></methods><methods><class-id>SiouX.SessionFilter</class-id> <category>notifications</category><body package="SiouX-Sessions">acceptSession: session for: aRequestContext"We set the current sessionId to be accesible in the response. Subclasses can override"	ProcessEnvironment at: #webSession put: session.</body><body package="SiouX-Sessions">handleServerStarting	sessionCache ifNotNil: [ sessionCache startPruning ]</body><body package="SiouX-Sessions">handleServerStopping	sessionCache ifNotNil: [		sessionCache 			stopPruning; 			releaseAllSessions	]</body><body package="SiouX-Sessions">noSessionFound: sessionId in: aRequestContext"The request has session id but the session was not found. Create a new session by default. Subclasses can override it "	^self acceptSession: self cacheNewSession for: aRequestContext</body><body package="SiouX-Sessions">noSessionIdPresentIn: aRequestContext"The request doesn't session id. Create a new session by default. Subclasses can override it "	^self acceptSession: self cacheNewSession for: aRequestContext.</body></methods><methods><class-id>SiouX.SessionFilter class</class-id> <category>testing</category><body package="SiouX-Sessions">isAbstract	^self == SessionFilter</body></methods><methods><class-id>SiouX.SessionAnnouncement</class-id> <category>accessing</category><body package="SiouX-Sessions">session	^session</body><body package="SiouX-Sessions">session: anObject	session := anObject</body></methods><methods><class-id>SiouX.SessionAnnouncement class</class-id> <category>instance creation</category><body package="SiouX-Sessions">session: aSession	^ self new session: aSession; yourself</body></methods><methods><class-id>SiouX.Session</class-id> <category>accessing</category><body package="SiouX-Sessions">creationTime	^creationTime</body><body package="SiouX-Sessions">currentTimestamp	^Timestamp nowUTC</body><body package="SiouX-Sessions">data	^data</body><body package="SiouX-Sessions">data: anObject	data := anObject</body><body package="SiouX-Sessions">encoding	^self propertyAt: #encoding.</body><body package="SiouX-Sessions">encoding: anObject	self propertyAt: #encoding put: anObject</body><body package="SiouX-Sessions">hasEncoding	^self encoding notNil.</body><body package="SiouX-Sessions">hasLocale	^(self propertyAt: #locale ifAbsent: [nil]) notNil</body><body package="SiouX-Sessions">id	^id.</body><body package="SiouX-Sessions">id: sessionId	id := sessionId.</body><body package="SiouX-Sessions">inactivityTime	^ self currentTimestamp - self lastUsed</body><body package="SiouX-Sessions">isAuthenticated	^ self propertyAt: #isAuthenticated ifAbsentPut: [ false ]</body><body package="SiouX-Sessions">isAuthenticated: aBoolean	^ self propertyAt: #isAuthenticated put: aBoolean</body><body package="SiouX-Sessions">key	^id</body><body package="SiouX-Sessions">lastUsed	^lastUsed</body><body package="SiouX-Sessions">locale	"Return the locale to be used for this session" 	^ self propertyAt: #locale ifAbsentPut: [ Locale current]</body><body package="SiouX-Sessions">locale: aLocale	"Set the locale to be used for this session. The argument can be either a symbol which is the name of a locale, e.g. #'en_US.CP1252' or can be an actual locale object, e.g. Locale current" 	| localeObject |	localeObject := aLocale isSymbol 		ifTrue: [Locale named: aLocale]		ifFalse: [aLocale].	self propertyAt: #locale put: localeObject.</body><body package="SiouX-Sessions">propertyAt: aKey	^ self propertyAt: aKey ifAbsent: [nil]</body><body package="SiouX-Sessions">propertyAt: aKey ifAbsent: aBlock	^ properties at: aKey ifAbsent: aBlock</body><body package="SiouX-Sessions">propertyAt: aKey ifAbsentPut: aBlock	^ properties at: aKey ifAbsentPut: aBlock</body><body package="SiouX-Sessions">propertyAt: aKey put: aValue	^properties at: aKey put: aValue</body><body package="SiouX-Sessions">status	^status</body></methods><methods><class-id>SiouX.Session</class-id> <category>testing</category><body package="SiouX-Sessions">isActive	^ status == #active</body><body package="SiouX-Sessions">isExpired	^ status == #expired</body></methods><methods><class-id>SiouX.Session</class-id> <category>initialize-release</category><body package="SiouX-Sessions">initialize	super initialize.	creationTime := self touch.	status := #active.	properties := Dictionary new.</body><body package="SiouX-Sessions">release	self isExpired ifFalse: [self expire].	super release</body></methods><methods><class-id>SiouX.Session</class-id> <category>session management</category><body package="SiouX-Sessions">activate	self isExpired		ifTrue: [self expiredSessionError]		ifFalse: [ status := #active ]</body><body package="SiouX-Sessions">expire	status := #expired.</body><body package="SiouX-Sessions">expiredSessionError	ExpiredSessionError 		raiseWith: self		errorString:  ( #SessionAlreadyExpired &lt;&lt; #www &gt;&gt; 'Session Already Expired' )</body><body package="SiouX-Sessions">touch"	If I am not expired, set my 'lastUsed' variable to the current time stamp."	self isExpired ifFalse: [		lastUsed := self currentTimestamp ].	^ lastUsed</body></methods><methods><class-id>SiouX.Session</class-id> <category>printing</category><body package="SiouX-Sessions">lastAccessedString	| aStream |	aStream := WriteStream on: (String new: 50).	aStream		nextPutAll: ((#LastAccessed &lt;&lt; #www &gt;&gt; 'last accessed') asString);		nextPutAll: ' (';		print: ( lastUsed isNil 			ifTrue: [ (#tagNone &lt;&lt; #www &gt;&gt; '~none~') asString ] 			ifFalse: [ lastUsed ]);		nextPut: $).	^ aStream contents.</body><body package="SiouX-Sessions">printOn: aStream	super printOn: aStream.	aStream 		nextPutAll: ': id=';		nextPutAll: id;		nextPutAll: ', ';		nextPutAll: self lastAccessedString.</body></methods><methods><class-id>SiouX.Session class</class-id> <category>instance creation</category><body package="SiouX-Sessions">id: sessionId	^ self new		id: sessionId;		yourself</body><body package="SiouX-Sessions">newWithID	^ self id: self sessionIDGenerator next</body><body package="SiouX-Sessions">sessionIDGenerator	^SessionIDGenerator</body></methods><methods><class-id>SiouX.ExpiredSessionError</class-id> <category>accessing</category><body package="SiouX-Sessions">session	^parameter</body></methods><methods><class-id>SiouX.SessionAuthenticationFilter</class-id> <category>accessing</category><body package="SiouX-Sessions">authenticatePath	^ authenticatePath</body><body package="SiouX-Sessions">authenticatePath: aString	authenticatePath := aString</body></methods><methods><class-id>SiouX.SessionAuthenticationFilter</class-id> <category>services</category><body package="SiouX-Sessions">applyTo: aRequestContext		aRequestContext session		ifNil: ["There is no session, let it go. If it's a problem the framework dispatching will complain about missing session" ^self ]		ifNotNil: [ :session | 			session isAuthenticated ifTrue: [ ^self ].						aRequestContext request url tail = self authenticatePath ifTrue: [				"The request requires authentication "				session isAuthenticated: (self authenticateSession: session for: aRequestContext).				session isAuthenticated ifTrue: [ 	^ self createSuccessReply: aRequestContext ]].						"The session is not authenticated. Create a response with an error status  " 			self notAuthenticatedResponse: aRequestContext ].</body><body package="SiouX-Sessions">authenticateSession: aSession for: aRequestContext" Subclasses has to authenticate the request and return a boolean"	^false</body><body package="SiouX-Sessions">createSuccessReply: aRequestContext" Subclasses may override the methods to return an application specific response contents"	aRequestContext response 		contents: 'Login Successful';		signalReady</body><body package="SiouX-Sessions">notAuthenticatedResponse: aRequestContext"By default return 403. Subclasses may override to return application specific error"	"Forbidden" 	aRequestContext response 		code: 403;		contents: 'Not authenticated request';		signalReady</body></methods><methods><class-id>SiouX.SessionIDGenerator</class-id> <category>initialize-release</category><body package="SiouX-Sessions">initialize	accessProtect := Semaphore forMutualExclusion.	random := (FastRandom fromGenerator: 3 seededWith: Time millisecondClockValue) initialize.</body></methods><methods><class-id>SiouX.SessionIDGenerator</class-id> <category>accessing</category><body package="SiouX-Sessions">next	^accessProtect critical: [		(random step asBigEndianByteArray,		Timestamp now asSeconds asBigEndianByteArray,		Time millisecondClockValue asBigEndianByteArray) asHexString ]</body></methods><methods><class-id>SiouX.SessionIDGenerator class</class-id> <category>instance creation</category><body package="SiouX-Sessions">new	^super new initialize</body></methods><methods><class-id>SiouX.SessionIDGenerator class</class-id> <category>services</category><body package="SiouX-Sessions">next	"Answer the next pseudo-random key."	"self next "	^Default next</body><body package="SiouX-Sessions">uninitialize	Default := nil</body></methods><methods><class-id>SiouX.SessionIDGenerator class</class-id> <category>class initialization</category><body package="SiouX-Sessions">initialize	Default := self new</body></methods><methods><class-id>SiouX.SessionCachingRule</class-id> <category>notifications</category><body package="SiouX-Sessions">aboutToPrune: aSessionCache	"	I am being notified that aSessionCache is being pruned. Do nothing by default.	Subclasses should override to perform actions appropriate to the caching rule I represent.	"</body><body package="SiouX-Sessions">accessedSession: aSession	"	I am being notified that aSession has been accessed through cache.	Generally, that means that aSession is active and in use. Touching it will update it's 'lastUsed' attribute.	Subclasses may override.	"	aSession touch</body><body package="SiouX-Sessions">addedSession: aSession	"I am being notified that aSession has been added to a cache."	aSession touch</body><body package="SiouX-Sessions">pruningSession: aSession	"	I am being notified that aSession is being pruned. Do nothing by default.	Subclasses should override to perform actions appropriate to the caching rule I represent.	"</body><body package="SiouX-Sessions">removedSession: aSession	"I am being notified that aSession has been removed from a cache.	Do nothing by default.	"</body></methods><methods><class-id>SiouX.SessionInactivityRule</class-id> <category>accessing</category><body package="SiouX-Sessions">duration	^duration ifNil: [ self class duration ]</body><body package="SiouX-Sessions">duration: aDuration	duration := aDuration</body></methods><methods><class-id>SiouX.SessionInactivityRule</class-id> <category>notifications</category><body package="SiouX-Sessions">pruningSession: aSession	"	I am being notified that aSession is being pruned. 	"	(aSession inactivityTime &gt; self duration) ifTrue: [ aSession expire ]</body></methods><methods><class-id>SiouX.SessionInactivityRule class</class-id> <category>accessing</category><body package="SiouX-Sessions">defaultDurationValue	^ 10 minutes</body><body package="SiouX-Sessions">duration	^ duration ifNil: [ self defaultDurationValue ]</body><body package="SiouX-Sessions">duration: aDuration	duration := aDuration</body><body package="SiouX-Sessions">durationSeconds	^self duration asSeconds</body><body package="SiouX-Sessions">durationSeconds: seconds	^self duration: ( Duration fromSeconds: seconds )</body></methods><methods><class-id>SiouX.SessionInactivityRule class</class-id> <category>instance creation</category><body package="SiouX-Sessions">withDuration: aDuration	^ self new		duration: aDuration;		yourself</body></methods><methods><class-id>SiouX.SessionCache</class-id> <category>iterating</category><body package="SiouX-Sessions">do: aBlock	^ accessLock critical: [ sessionRegistry do: aBlock ]</body><body package="SiouX-Sessions">select: aBlock	^ sessionRegistry select: aBlock</body><body package="SiouX-Sessions">sessionsDo: aBlock	sessionRegistry ifNil: [ ^ self ].	sessionRegistry copy do: aBlock.</body></methods><methods><class-id>SiouX.SessionCache</class-id> <category>initialize-release</category><body package="SiouX-Sessions">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	accessLock := RecursionLock new.	rules := OrderedCollection new.	self initializeSessionRegistry.	self pruneEvery: self defaultPruningFrequency</body><body package="SiouX-Sessions">initializeSessionRegistry	sessionRegistry := Dictionary new</body><body package="SiouX-Sessions">release	self stopPruning.	self releaseAllSessions.	super release</body><body package="SiouX-Sessions">releaseAllSessions	sessionRegistry		ifNotNil: 			[sessionRegistry copy do: [:eachSession | self releaseSession: eachSession]]</body></methods><methods><class-id>SiouX.SessionCache</class-id> <category>testing</category><body package="SiouX-Sessions">isEmpty	^sessionRegistry isNil or: [sessionRegistry isEmpty]</body></methods><methods><class-id>SiouX.SessionCache</class-id> <category>session management</category><body package="SiouX-Sessions">addRule: aRule	self replaceRuleOf: aRule class with: aRule</body><body package="SiouX-Sessions">findSession: sessionId	"Find the session matching sessionId."	sessionId ifNil: [^nil].	^accessLock critical: [self basicFindSession: sessionId]</body><body package="SiouX-Sessions">pruneEvery: aDuration	pruningFrequency = aDuration ifTrue: [^self].	self stopPruning.	pruningFrequency := aDuration.	self startPruning</body><body package="SiouX-Sessions">releaseSession: aSession	" Release aSession from the cache and announce SessionReleased."	(accessLock critical: [self basicReleaseSession: aSession]) ifNil: [ ^ self ].		aSession release.	self announce: (SessionReleased session: aSession)</body><body package="SiouX-Sessions">rememberSession: aSession	"Add aSession to session registry and announce SessionCached."	accessLock critical: [self basicRememberSession: aSession].	self announce: (SessionCached session: aSession).	^ aSession</body><body package="SiouX-Sessions">removeRuleOf: aRuleClass	"Replace an existing rule whose class is aRuleClass with nil. This effectively removes it from the rules"	self replaceRuleOf: aRuleClass with: nil</body><body package="SiouX-Sessions">sessionTTL: aDuration	aDuration isZero		ifTrue: [ self removeRuleOf: SessionInactivityRule ]		ifFalse: [ self addRule: (SessionInactivityRule withDuration: aDuration) ]</body><body package="SiouX-Sessions">startPruning	accessLock critical: [self doStartPruning]</body><body package="SiouX-Sessions">stopPruning	accessLock critical: [self doStopPruning]</body></methods><methods><class-id>SiouX.SessionCache</class-id> <category>accessing</category><body package="SiouX-Sessions">allSessions	| all |	all := List new.	self do: [:each | all add: each ].	^all</body><body package="SiouX-Sessions">defaultPruningFrequency	^self class pruningFrequency</body></methods><methods><class-id>SiouX.SessionCache</class-id> <category>private</category><body package="SiouX-Sessions">basicFindSession: sessionId	^sessionRegistry		ifNotNil: [sessionRegistry			at: sessionId			ifPresent: [:session |				self rulesDo: [ :eachRule | eachRule accessedSession: session ].				session ]]</body><body package="SiouX-Sessions">basicReleaseSession: aSession	| removed |	aSession ifNil: [ ^ nil ].	removed := sessionRegistry removeKey: aSession id ifAbsent: [^ nil ].	self rulesDo: [ :eachRule | eachRule removedSession: aSession ].	^ removed</body><body package="SiouX-Sessions">basicRememberSession: aSession	sessionRegistry at: aSession id put: aSession.	self rulesDo: [ :eachRule | eachRule addedSession: aSession ]</body><body package="SiouX-Sessions">doStartPruning	pruningTimer ifNotNil: [		pruningTimer period = pruningFrequency ifTrue: [ ^self ].		self doStopPruning].	pruningTimer := Timer				after: pruningFrequency				every: pruningFrequency				do: [self prune]</body><body package="SiouX-Sessions">doStopPruning	^pruningTimer		ifNotNil: 			[pruningTimer stop.			pruningTimer := nil]</body><body package="SiouX-Sessions">prune	accessLock critical: [		self rulesDo: [ :eachRule | eachRule aboutToPrune: self ].		self sessionsDo: [ :eachSession |			self announce: (SessionPruning session: eachSession).			self rulesDo: [ :eachRule | eachRule pruningSession: eachSession ].			eachSession isExpired ifTrue: [ self releaseSession: eachSession ] ] ]</body><body package="SiouX-Sessions">replaceRuleOf: aRuleClass with: aRuleOrNil	rules		detect: [ :each | each class == aRuleClass ]		ifFound: [ :oldRule | rules remove: oldRule ].	aRuleOrNil ifNotNil: [ rules add: aRuleOrNil ]</body><body package="SiouX-Sessions">rulesDo: aBlock	rules do: aBlock</body></methods><methods><class-id>SiouX.SessionCache class</class-id> <category>accessing</category><body package="SiouX-Sessions">defaultPruningFrequencyValue	^ 1 minutes</body><body package="SiouX-Sessions">pruningFrequency	^ pruningFrequency ifNil: [ self defaultPruningFrequencyValue ]</body><body package="SiouX-Sessions">pruningFrequency: aDuration	pruningFrequency := aDuration</body></methods><methods><class-id>SiouX.RequestContext</class-id> <category>accessing</category><body package="SiouX-Sessions">session	^ self propertyAt: #session</body><body package="SiouX-Sessions">session: aSession	self propertyAt: #session put: aSession</body></methods><methods><class-id>SiouX.SessionAuthenticationFilter</class-id> <category>configuration</category><body package="SiouX-Sessions">configureDefaultAuthentication	&lt;configuration: 'Default Authentication'&gt;		self authenticatePath: '_appex_login'.</body></methods><initialize><class-id>SiouX.SessionIDGenerator</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>RequestFilter</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>configuration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Server</package></attributes></class><class><name>Announcer</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subscriptionRegistry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>System-Announcements</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Announcement</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Announcements</category><attributes><package>System-Announcements</package></attributes></class><class><name>RequestContext</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>responder connection request response data properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Server</package></attributes></class></st-source>