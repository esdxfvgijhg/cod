<?xml version="1.0"?><st-source><!-- Name: SiouX-Server-SecureNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: This package adds SSL/TLS support to Connections. To enable HTTPS on a server add a listener for HttpsConnection with desired address/port. The listener MUST be configured with proper TLSContext. At the very least the context MUST be configured with a valid server certificate and private key (refer to the X509 package for details on how to generate certificates and keys). Following example requires SiouX-Http package and uses samples from SiouX-Examples package:Usage:	(server := Server id: 'TestH2SecureServer') 		addResponder: (H2Hello path: '/').	" Create a listener for a secure connection "	listener := server listenOn: 8002 for: SiouX.HttpsConnection.	" Set TLS server context for the listener "	server		setSecureListener: listener		certificateFile: 'certificates.pem'		privateKeyFile: 'myprivatekey-rsa.key'.	" Set server names accepted by this listener. The names are used to validate 	- the TSLServerName extension from a client hello and 	- later the Host header field for HTTP/1.1 or	- :authority for HTTP/2 "	listener acceptedServerNames: #('vstwidget.cincomsmalltalk.com').	or change the default verification block (see comments for  TLSServerContext class>>defaultServerNameVerifierValue:)	listener 		acceptedServerNames: #('vstwidget.cincomsmalltalk.com') 		verifier: [:tlsConnection :receivedHosts :acceptedServers | "add application verification" ].	" Set cipher suites and the TLSAppLayerProtocolNegotiation extension to switch to HTTP/2 connection"	listener useHTTP2Protocol.To shut the server down just stop the server. Do not forget to release the server when it is no longer needed. This will also release the certificate store and its potential external resources.	server stop.	server release.	The server can force the clients to authenticate with their own certificates as well. Use Listener's tlsVerifier option for that. The value of that option is a block that receives client certificates and is required to verify that the subjects of those certificates are allowed to connect to the server, for example:	listener tlsVerifier: [ :certificate | PermittedClients includes: certificate subject commonName ]It is highly recommended to study the TLS package to understand proper use of TLS protocol. Improper configuration can cause serious vulnerabilities in the server. It is also highly desirable to use adequate TLS session caching and resumption as it critically impacts server performance. All TLS related parameters are configured through the TLSContext.DbIdentifier: bear73DbTrace: 500411DbUsername: tkoganDbVersion: 8.3 - 6DevelopmentPrerequisites: #(#(#any 'SiouX-Server' '') #(#any 'TLS' '') #(#any 'PKCS8' '') #(#any 'X509' '') #(#any 'Xtreams-Crypto' ''))DisregardedPrerequisites: #()PackageName: SiouX-Server-SecureParcel: #('SiouX-Server-Secure')PrerequisiteDescriptions: #(#(#name 'SiouX-Server' #componentType #bundle) #(#name 'TLS' #componentType #package) #(#name 'PKCS8' #componentType #package) #(#name 'X509' #componentType #package) #(#name 'Xtreams-Crypto' #componentType #package))PrerequisiteParcels: #(#('SiouX-Server' '') #('TLS' '') #('PKCS8' '') #('X509' '') #('Xtreams-Crypto' ''))PrintStringCache: (8.3 - 6,tkogan)Version: 8.3 - 6Date: 1:19:06 PM July 14, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jul17.2) of July 14, 2017 on July 14, 2017 at 1:19:06 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>HttpsConnection</name><environment>SiouX</environment><super>SiouX.HttpConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tlsConnection </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.OsTransferFaultError			</imports><category></category><attributes><package>SiouX-Server-Secure</package></attributes></class><comment><class-id>SiouX.HttpsConnection</class-id><body>I extend HttpConnection to provide HTTPS support. This is achieved by using the TLS package to tunnel the HTTP traffic through a TLS connection. Otherwise the behavior is the same as with plain HTTP connection.Instance Variables	tlsConnection	&lt;TLSConnection&gt; </body></comment><class><name>HttpsListener</name><environment>SiouX</environment><super>SiouX.HttpListener</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tlsContext tlsVerifier </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Server-Secure</package></attributes></class><comment><class-id>SiouX.HttpsListener</class-id><body>I manage configuration parameters for HttpsConnections . Instance Variables	tlsContext	&lt;TLSContext&gt; captures all TLS configuration parameters including the session cache and certificate store	tlsVerifier	&lt;BlockClosure&gt; optional client certificate verifier, if present clients will be required to authenticateUsage:	" Create a listener for a secure connection "	listener := server listenOn: 8002 for: SiouX.HttpsConnection.	" Set TLS server context for the listener "	server		setSecureListener: listener		certificateFile: 'certificates.pem'		privateKeyFile: 'myprivatekey-rsa.key'.	" Set server names accepted by this listener. The names are used to validate 	- the TSLServerName extension from a client hello and 	- later the Host header field for HTTP/1.1 or	- :authority for HTTP/2 "	listener acceptedServerNames: #('vstwidget.cincomsmalltalk.com').	" Set cipher suites and the TLSAppLayerProtocolNegotiation extension to switch to HTTP/2 connection"	listener useHTTP2Protocol.</body></comment><methods><class-id>SiouX.HttpsConnection</class-id> <category>accessing</category><body package="SiouX-Server-Secure">tlsConnection	^tlsConnection</body></methods><methods><class-id>SiouX.HttpsConnection</class-id> <category>initialize-release</category><body package="SiouX-Server-Secure">initializeStreams	super initializeStreams.	tlsConnection := listener tlsContext newConnectionReading: readStream writing: writeStream.	tlsConnection accept: listener tlsVerifier.	readStream := tlsConnection reading.	writeStream := tlsConnection writing.</body><body package="SiouX-Server-Secure">releaseStreams	| saved |	saved := tlsConnection.	tlsConnection := readStream := writeStream := nil.	saved isNil ifFalse: [ 		[saved shutdown ] on: Error do: [ :ex | "Ignore flush. Another side has already closed connection"]]</body></methods><methods><class-id>SiouX.HttpsConnection</class-id> <category>private</category><body package="SiouX-Server-Secure">privateOpen	self initializeStreams.	listener openingConnection: self.	listener protocolVersions 		detect: [ :version | version acceptsSecureUpgrade: tlsConnection tlsAppLayerProtocol  ] 		ifFound: [ :newVersion |				"Start Http2 protocol message exchange"				newVersion upgradeSecureConnection: self. 			^persist := false ]		ifNone: [	"Start Http 1.1 protocol message exchange"				self requestProcessBody]</body></methods><methods><class-id>SiouX.HttpsConnection class</class-id> <category>accessing</category><body package="SiouX-Server-Secure">listenerClass	^HttpsListener</body><body package="SiouX-Server-Secure">protocol	^'https'</body></methods><methods><class-id>SiouX.HttpsConnection class</class-id> <category>testing</category><body package="SiouX-Server-Secure">isSecure	^true</body></methods><methods><class-id>SiouX.HttpsListener</class-id> <category>accessing</category><body package="SiouX-Server-Secure">acceptedServerNames"	Returns accepted server names. See #acceptedServerNames: comments"	tlsContext ifNil: [ ^self tlsContextNilError].	^tlsContext acceptedServerNames</body><body package="SiouX-Server-Secure">acceptedServerNames: anArray"Set accepted server names. TLS	The TLSServerName extension will be added to TLSServerContext. The TLS handshake uses the collection to verify server names from a client hello.HTTP/1.1	In HTTP/1.1 the collection will be used to verify the Host header field.HTTP/2	In HTTP/2 the collection is used to verify :authority pseudo-header.	If the collection is empty (default) there is no verification at any level"	tlsContext ifNil: [ ^self tlsContextNilError].	tlsContext acceptedServerNames: anArray.</body><body package="SiouX-Server-Secure">acceptedServerNames: aCollection verifier: aBlock"A server will use these names to verify the server names from ClientHello. An application sets the server name verification in the aBlock. For an example see TLSContext class&gt;&gt;defaultServerNameVerifierValue	"	tlsContext ifNil: [ ^self tlsContextNilError].	tlsContext acceptedServerNames: aCollection verifier: aBlock</body><body package="SiouX-Server-Secure">tlsContext	^tlsContext</body><body package="SiouX-Server-Secure">tlsContext: context"	context &lt;TLSContext&gt; captures all TLS configuration parameters including the session cache and certificate store"	tlsContext := context</body><body package="SiouX-Server-Secure">tlsContextNilError	^self error: (#TLSServerContextIsNotSet &lt;&lt; #www &gt;&gt; 'TLSServerContext (#tlsContext) is not set yet') asString</body><body package="SiouX-Server-Secure">tlsVerifier	^tlsVerifier</body><body package="SiouX-Server-Secure">tlsVerifier: verifier"	verifier &lt;BlockClosure&gt; optional client certificate verifier, if present clients will be required to authenticate"	tlsVerifier := verifier</body></methods><methods><class-id>SiouX.HttpsListener</class-id> <category>initialize-release</category><body package="SiouX-Server-Secure">release	tlsContext ifNotNil: [		tlsContext release.		tlsContext certificates release.		tlsContext sessions release].	super release.</body></methods><methods><class-id>SiouX.HttpsListener</class-id> <category>persistence</category><body package="SiouX-Server-Secure">asXmlNode	| root |	root := super asXmlNode.	tlsContext ifNotNil: [ root addNode: tlsContext asXmlNode ].	^root</body><body package="SiouX-Server-Secure">importSnapshot: anElement	anElement realElements do: [ :node |		self restoreValueFrom: node data: node characterData.		anElement realElements do: [ :nd | self restoreTLSContextFrom: nd ]]</body><body package="SiouX-Server-Secure">restoreTLSContextFrom: aNode 	'tlsContext' = aNode tag type ifFalse: [ ^nil ].	(Server classFrom: aNode attributeNamed: 'class') ifNotNil: [ :tlsContextClass |		tlsContext := tlsContextClass new.		tlsContext importSnapshot: aNode ]</body></methods><methods><class-id>SiouX.HttpsListener</class-id> <category>services</category><body package="SiouX-Server-Secure">start	tlsContext ifNil: [ ^self tlsContextNilError ].	super start</body></methods><methods><class-id>SiouX.HttpsListener class</class-id> <category>accessing</category><body package="SiouX-Server-Secure">connectionClass	^HttpsConnection</body></methods><methods><class-id>SiouX.Server</class-id> <category>deprecation</category><body package="SiouX-Server-Secure">addSecureListener: aListener" SiouX-Tools extension""Add HTTPS listener with generated temporary self-signed certificate and key."	| key name certificate |	"Web Browser don't support self-signed certificates anymore"	self deprecated: #(#version '8.3' #sunset '9.0'  #use 'setSecureListener:certificateFile:privateKeyFile:').	key := PrivateKey algorithm: 'RSA' size: 2048.	name := Security.X509.Name new CN: 'SiouX Testing'; yourself.	certificate :=		Security.X509.Certificate new			serialNumber: Time microsecondClock;			issuer: name;			subject: name;			notBefore: Date today;			notAfter: (Date today addDays: 7);			publicKey: key asX509Key asPublicKey;			yourself.	certificate tbsCertificate getEmptyKeyUsage keyEncipherment: true; digitalSignature: true.	certificate signUsing: key hash: 'SHA256' padding: 'PKCS1'.	^self setSecureListener: aListener certificate: (Array with: certificate) privateKey: key</body><body package="SiouX-Server-Secure">addSecureListener: aListener certificate: chain privateKey: key		self deprecated: #(#version '8.3' #sunset '9.0'  #use 'setSecureListener:certificate:privateKey:').	^self setSecureListener: aListener certificate: chain privateKey: key</body><body package="SiouX-Server-Secure">addSecureListener: aListener certificateFile: cFile privateKeyFile: pkFile	self deprecated: #(#version '8.3' #sunset '9.0'  #use 'setSecureListener:certificateFile:privateKeyFile:').	^self setSecureListener: aListener certificateFile: cFile privateKeyFile: pkFile</body><body package="SiouX-Server-Secure">addSecureListener: aListener certificateFile: cFile privateKeyFile: pkFile password: password	self deprecated: #(#version '8.3' #sunset '9.0'  #use 'setSecureListener:certificateFile:privateKeyFile:password:').	^self setSecureListener: aListener certificateFile: cFile privateKeyFile: pkFile password: password</body></methods><methods><class-id>SiouX.Server</class-id> <category>tools</category><body package="SiouX-Server-Secure">setSecureListener: aListener certificate: chain privateKey: key" SiouX-Tools extension""Add HTTPS connection  "	| certificates  |	certificates := TLSCertificateStore newWithDefaults			known: chain first; "so that the client doesn't signal TLSUnknownCA"			certificate: chain key: key;			yourself.	aListener tlsContext: (TLSContext newServerWithCertificates: certificates).	^aListener</body><body package="SiouX-Server-Secure">setSecureListener: aListener certificateFile: cFile privateKeyFile: pkFile" SiouX-Tools extension"	^self 		setSecureListener: aListener		certificateFile: cFile 		privateKeyFile: pkFile		password: ''"Password-encrypted key files have not be sufficiently tested due to lack of test resources.(UI.SimplePasswordDialog new request: 'Password to read Private Key ' initialAnswer: '' onCancel: [''])"</body><body package="SiouX-Server-Secure">setSecureListener: aListener certificateFile: cFile privateKeyFile: pkFile password: password"	The argument @password is ignored. We need more real-world examples of encrypted privateKey files before we can reliably implement	privateKey descryption.		This method has been tested with the following case (substitute 'server' with your own name)	1) generate a private key, e.g.:		openssl genrsa -out server.key 1024	2) generate a certificate signing request to submit to a certification authority (CA). In this step, you enter the pertinent server information.		Example:		openssl req -new -key server.key -out server.csr	3) Submit the certificate request to a CA of your choice.	4) Upon receiving the certificate, you will also receive the certification chain. Commonly, this could be a zip file containing	files named server.crt and server.ca-bundle.	5) Concatenate the server.ca-bundle and server.crt file. On Linux, you could use		cat server.ca-bundle &gt; server.pem		cat server.crt &gt;&gt; server.pem	6) The server.pam file now contains the entire certification chain, and it should be the cFile argument in this method.	The server.key contains your private key an should be the pkFile argument."	| certFilename chain key stream |	certFilename := cFile asFilename.	chain := ( (#('.pem' '.crt') anySatisfy: [ :ext | ext match: certFilename extension]) 					ifTrue: [						"The PEM file must contain single chain of certificates sorted with the issuers before subjects."						chain := Security.X509.CertificateFileReader readFromFile: certFilename.						chain inject: chain first into: [ :issuer :subject |							issuer == subject ifFalse: [ subject verifyIssuedBy: issuer ].							subject ].						chain asArray reverse ] 					ifFalse: [ | bytes |						"The file must contain single certificate in binary encoding.						In this case we assume the issuer is well known CA that does not need to be sent in the handshake,						otherwise use the PEM form to provide a chain of certificates."						stream := certFilename readStream binary.						bytes := [ stream contents ] ensure: [ stream close ].						Array with: (Security.X509.Certificate fromBytes: bytes) ]).		key := (Security.X509.CertificateFileReader readFromFile: pkFile) first.	^self setSecureListener: aListener certificate: chain privateKey: key getKey</body></methods><methods><class-id>Protocols.HTTPv11</class-id> <category>services</category><body package="SiouX-Server-Secure">acceptsSecureUpgrade: aCollection	^false</body></methods><methods><class-id>Xtreams.TLSCertificateStore class</class-id> <category>persistence</category><body package="SiouX-Server-Secure"> importSnapshot: aNode	| instance |	instance := self new.	aNode realElements do: [ :node |		node tag type= 'owned' ifTrue: [ instance importOwned: node realElements].		node tag type = 'known' ifTrue: [ instance importKnown: node realElements].		node tag type = 'x509registry' ifTrue: [ instance importReqistry: node]].	^instance</body></methods><methods><class-id>Xtreams.TLSCertificateStore</class-id> <category>persistence</category><body package="SiouX-Server-Secure">addKnownNodeTo: anElement						| ind knownNode |	ind := 0.	anElement addNode: (knownNode := XML.Element tag: 'known').	known do: [ :cert |		ind := ind + 1.		self 			writeCertificate: cert 			into: ('known_', ind printString) 			addTo: knownNode  ].</body><body package="SiouX-Server-Secure">addOwnedNodeTo: anElement	|  ownedNode ind nd |	anElement addNode: (ownedNode := XML.Element tag: 'owned').	ind := 0.	owned do: [ :assoc| 		ind := ind + 1.		ownedNode addNode: (nd := XML.Element tag: 'keyCerts').		nd  addNode: (XML.Element 						tag: 'privateKey'						attributes: (Array with: (XML.Attribute name: 'type' value: assoc key type))						elements: nil ).		assoc value doWithIndex: [ :cert :i | 			self 				writeCertificate: cert 				into: ('owned_', ind printString, '_', i printString) 				addTo: nd ]].</body><body package="SiouX-Server-Secure">addTrustedNodeTo: anElement						| ind  registryNode node |	ind := 0.	anElement addNode: (registryNode := XML.Element tag: 'x509registry').	registryNode addAttribute: (XML.Attribute name: 'strict' value: self trusted isStrict printString).	trusted trustedCertificates notEmpty 		ifTrue: [ registryNode addNode: (node := XML.Element tag: 'trusted').				trusted trustedCertificates do: [ :cert |			ind := ind + 1.			self 				writeCertificate: cert 				into: ('trusted_', ind printString) 				addTo: node  ]].	ind := 0.	trusted revokedCertificates notEmpty 		ifTrue: [ registryNode addNode: (node := XML.Element tag: 'revoked').						trusted revokedCertificates do: [ :cert |					ind := ind + 1.					self 						writeCertificate: cert 						into: ('revoked_', ind printString) 						addTo: node  ]].</body><body package="SiouX-Server-Secure">asXmlNode	| root  |	root := XML.Element tag: 'tlsCertificateStore'.	root addAttribute:  (XML.Attribute name: 'class' value: self class fullName )."	owned notEmpty ifTrue: [ self addOwnedNodeTo:  root ].	known notEmpty ifTrue: [ self addKnownNodeTo:  root ].	self addTrustedNodeTo:  root."	^root</body><body package="SiouX-Server-Secure">fileContentsFrom: anElement	| val stream contents |	(val := anElement valueOfAttribute: 'filename' ifAbsent: [nil]) ifNil: [^nil].	[			stream := val asFilename readStream.			[contents := stream contents] ensure: [stream close].			] on: Error do: [ :ex | nil ].	^contents</body><body package="SiouX-Server-Secure">importKnown: nodeCollection	nodeCollection do: [ :node | known add: (self readCertificate: node) ]</body><body package="SiouX-Server-Secure">importOwned: nodeCollection	| chain contents key |	nodeCollection do: [ :node |		chain := OrderedCollection new.				node realElements do: [ :keysCerts |			keysCerts tag type = 'privateKey' ifTrue: [				"read private key somehow" 				contents := self fileContentsFrom: keysCerts.				key := PrivateKey ].			keysCerts tag type = 'certificate' ifTrue: [				chain add: (self readCertificate: keysCerts)]].				self 	certificate: chain key: key ]</body><body package="SiouX-Server-Secure">importReqistry: aNode	(aNode valueOfAttribute: 'strict' ifAbsent: [nil])		ifNotNil: [ :val | | bool |			bool := Boolean readFrom: val readStream.			bool ifTrue: [ trusted beStrict] ifFalse: [ trusted dontBeStrict]].			aNode realElements do: [ :node | 		node tag type = 'trusted' ifTrue: [ 			node realElements do: [ :nd | trusted trustedCertificates add: (self readCertificate: nd)]].		node tag type = 'revoked' ifTrue: [ 			node realElements do: [ :nd | trusted addRevoked: (self readCertificate: nd)]]]</body><body package="SiouX-Server-Secure">readCertificate: anElement	^Certificate fromString: (self fileContentsFrom: anElement)</body><body package="SiouX-Server-Secure">writeCertificate: aCert into: fString addTo: anElement						|  stream filename |	stream := (filename := fString, '_certificate.pem' ) asFilename writing.	[ stream write: aCert asPEMString ] ensure: [stream close].			anElement  addNode: (XML.Element 						tag: 'certificate'						attributes: (Array with: (XML.Attribute name: 'filename' value: filename  ))						elements: nil )</body></methods><methods><class-id>Xtreams.TLSExtension class</class-id> <category>persistence</category><body package="SiouX-Server-Secure">importSnapshot: aNode	^(aNode valueOfAttribute: 'code' ifAbsent: [nil]) ifNotNil: [ :val | self fromCode: val asNumber ].</body></methods><methods><class-id>Xtreams.TLSExtension</class-id> <category>persistence</category><body package="SiouX-Server-Secure">asXmlNode	| root |	root := XML.Element tag: 'extension'.	root 		addAttribute:  (XML.Attribute name: 'class' value: self class fullName );		addAttribute: ( XML.Attribute name: 'code' value: self code printString).	^root</body></methods><methods><class-id>Xtreams.TLSConnection</class-id> <category>testing</category><body package="SiouX-Server-Secure">isSecure	^true</body></methods><methods><class-id>Xtreams.TLSServerContext</class-id> <category>persistence</category><body package="SiouX-Server-Secure">addXmlElementsTo: anElement"Customized block: #dheParameters and #ecdheParameters are not supported"	| node   |	super addXmlElementsTo: anElement.		self supportedCertificateTypes =  self class defaultCertificateTypesValue ifFalse: [		anElement addNode: (node := XML.Element tag: 'supportedCertificateTypes' ).		self supportedCertificateTypes do: [ :type | node addNode: (self elementFor: 'type' with: type )]].		self supportedSignatureAlgorithms =  self class supportedSignatureAlgorithms ifFalse: [		anElement addNode: (node := XML.Element tag: 'supportedSignatureAlgorithms' ).		self supportedSignatureAlgorithms do: [ :algorithm | node addNode: algorithm asXmlNode]].</body><body package="SiouX-Server-Secure">importElementsFrom: aNode" Customized blocks: #dheParameters and #ecdheParameters are not persistent "	super importElementsFrom: aNode.		aNode tag type = 'supportedCertificateTypes' ifTrue: [		supportedCertificateTypes := (aNode realElements collect: [ :nd | nd characterData])].		aNode tag type = 'supportedSignatureAlgorithms' ifTrue: [		supportedSignatureAlgorithms := (aNode realElements collect: [ :nd | 			(SiouX.Server classFrom: nd attributeNamed: 'class') importSnapshot: nd])].</body></methods><methods><class-id>Xtreams.TLSSignatureAndHashAlgorithm class</class-id> <category>persistence</category><body package="SiouX-Server-Secure">importSnapshot: aNode		| hashID sigID |	(aNode valueOfAttribute: 'hash' ifAbsent: [nil]) ifNotNil: [ :val | hashID := val  ].	(aNode valueOfAttribute: 'signature' ifAbsent: [nil]) ifNotNil: [ :val | sigID := val  ].	(hashID isNil or: [ sigID isNil ]) ifTrue: [		^SiouX.Server announce: (SiouX.LoadingServerConfig new				write: (#WrongSignHashData &lt;&lt; #www &gt;&gt;'Can not create &lt;1s&gt; instance. Wrong hash &lt;2s&gt; or signature &lt;3s&gt;' expandMacrosWith:  self class name with: hashID  with: sigID );				write: aNode printString;				yourself) ].			^self hash: hashID signature: sigID</body></methods><methods><class-id>Xtreams.TLSSignatureAndHashAlgorithm</class-id> <category>persistence</category><body package="SiouX-Server-Secure">asXmlNode	| root |	root := XML.Element tag: 'algorithm'.	root 		addAttribute: (XML.Attribute name: 'class' value: self class fullName );		addAttribute: (XML.Attribute name: 'hash' value: self hashID );		addAttribute: (XML.Attribute name: 'signature' value: self signature).	^root</body></methods><methods><class-id>Xtreams.TLSCipherSuite class</class-id> <category>persistence</category><body package="SiouX-Server-Secure"> importSnapshot: aNode	^(aNode valueOfAttribute: 'name' ifAbsent: [nil]) ifNotNil: [ :val | self fromSelector: val asSymbol ].</body></methods><methods><class-id>Xtreams.TLSCipherSuite</class-id> <category>persistence</category><body package="SiouX-Server-Secure">asXmlNode	| root |	root := XML.Element tag: 'cipherSuite'.	root 		addAttribute: (XML.Attribute name: 'class' value: self class fullName);		addAttribute: (XML.Attribute name: 'name' value: self name).	^root</body></methods><methods><class-id>Xtreams.TLSCompression class</class-id> <category>persistence</category><body package="SiouX-Server-Secure">importSnapshot: aNode	^(aNode valueOfAttribute: 'code' ifAbsent: [nil]) ifNotNil: [ :val | self fromCode: val asNumber ].</body></methods><methods><class-id>Xtreams.TLSCompression</class-id> <category>persistence</category><body package="SiouX-Server-Secure">asXmlNode	^XML.Element 		tag: 'compression'		attributes: (OrderedCollection 					with: (XML.Attribute name: 'class' value: self class fullName )					with: (XML.Attribute name: 'code' value: self code printString ))		elements: nil</body></methods><methods><class-id>Xtreams.TLSContext</class-id> <category>persistence</category><body package="SiouX-Server-Secure">addXmlElementsTo: anElement"Customized block: #dheParameters and #ecdheParameters are not supported"	| node   |	self compressions = self class defaultCompressions ifFalse: [		anElement addNode: (node := XML.Element tag: 'compressions' ).		self compressions do: [ :compression | node addNode: compression asXmlNode]].											certificates ifNotNil: [ anElement addNode: certificates asXmlNode	].		self extensions = self class defaultExtensions ifFalse: [		anElement addNode: (node := XML.Element tag: 'extensions' ).		self extensions do: [ :extension | extension asXmlNode ifNotNil: [ :nd | node addNode: nd ] ]].		self suites = self class defaultSecureSuites ifFalse: [		anElement addNode: (node := XML.Element tag: 'suites' ).		self suites do: [ :suite | node addNode: suite asXmlNode]].</body><body package="SiouX-Server-Secure">asXmlNode	| root |	root := XML.Element tag: 'tlsContext'.	root addAttribute:  (XML.Attribute name: 'class' value: self class fullName ).	self maxVersion = 3 ifFalse: [			root addAttribute: (XML.Attribute name: 'maxVersion' value: self maxVersion printString )].	self minVersion = 0 ifFalse: [			root addAttribute: (XML.Attribute name: 'minVersion' value: self minVersion printString )].	self mayRenegotiate = self class defaultMayRenegotiateValue ifFalse: [		root addAttribute: (XML.Attribute name: 'mayRenegotiate' value: self mayRenegotiate printString )].	self random source class = self class defaultRandomValue source class ifFalse: [		root addAttribute: (XML.Attribute name: 'randomClass' value: self random source class fullName )	].		self addXmlElementsTo: root.	^root</body><body package="SiouX-Server-Secure">classFrom: aNode attributeNamed: aString	^(aNode valueOfAttribute: aString ifAbsent: [nil]) ifNotNil: [ :aClass | |theClass|		theClass := aClass asSymbol asQualifiedReference valueOrDo: [			^SiouX.Server announce: (SiouX.LoadingServerConfig new				write: (#UndefinedClassRef &lt;&lt; #www &gt;&gt;'Undefined class reference: &lt;1s&gt; ' expandMacrosWith:  aClass);				write: aNode printString;				yourself)].				 theClass].</body><body package="SiouX-Server-Secure">elementFor: tagString with: textValue	^(XML.Element tag: tagString) 		addNode: ( XML.Text text: textValue)</body><body package="SiouX-Server-Secure">importElementsFrom: aNode" Customized blocks: #dheParameters and #ecdheParameters are not persistent "	aNode tag type = 'compressions' ifTrue: [ 		compressions := (aNode realElements collect: [ :nd |			(SiouX.Server classFrom: aNode attributeNamed: 'class') importSnapshot: nd]) ].		aNode tag type = 'tlsCertificateStore' ifTrue: [		certificates :=  (SiouX.Server classFrom: aNode attributeNamed: 'class') importSnapshot: aNode ].		aNode tag type = 'extensions' ifTrue: [		extensions := (aNode realElements collect: [ :nd |			(SiouX.Server classFrom: nd attributeNamed: 'class') importSnapshot: nd])].		aNode tag type = 'suites' ifTrue: [		suites := (aNode realElements collect: [ :nd |			(SiouX.Server classFrom: nd attributeNamed: 'class') importSnapshot: nd])].</body><body package="SiouX-Server-Secure">importSnapshot: aNode	(aNode valueOfAttribute: 'maxVersion' ifAbsent: [nil]) ifNotNil: [ :val | maxVersion := val asNumber ].	(aNode valueOfAttribute: 'minVersion' ifAbsent: [nil]) ifNotNil: [ :val | minVersion := val asNumber ].	(aNode valueOfAttribute: 'mayRenegotiate' ifAbsent: [nil]) ifNotNil: [ :val | mayRenegotiate := Boolean readFrom: val readStream ].	( SiouX.Server classFrom: aNode attributeNamed: 'randomClass' ) ifNotNil: [ :randomClass | 		random := randomClass reading ].		aNode realElements do: [ :node | self importElementsFrom: node ]</body></methods><methods><class-id>Xtreams.TLSSignatureAlgorithms class</class-id> <category>persistence</category><body package="SiouX-Server-Secure">importSnapshot: aNode	| instance |	instance := super importSnapshot: aNode.	instance algorithms: (aNode realElements collect: [ :el | 		(SiouX.Server classFrom: el attributeNamed: 'class') importSnapshot: el ]).	^instance</body></methods><methods><class-id>Xtreams.TLSSignatureAlgorithms</class-id> <category>persistence</category><body package="SiouX-Server-Secure">asXmlNode	| root |	root := super asXmlNode.	self algorithms ifNotNil: [		self algorithms do: [ :alg | root addNode: alg asXmlNode ]].	^root</body></methods><methods><class-id>Protocols.ProtocolVersion</class-id> <category>upgrade</category><body package="SiouX-Server-Secure">upgradeSecureConnection: anHttpsConnection</body></methods><methods><class-id>Xtreams.TLSAppLayerProtocolNegotiation</class-id> <category>persistence</category><body package="SiouX-Server-Secure">asXmlNode	| root node |	root := super asXmlNode.	self preferredProtocols = self class defaultH2 ifFalse: [		root addNode: (node := XML.Element tag: 'preferredProtocols' ).		self preferredProtocols do: [ :str | 			node addNode: ((XML.Element tag: 'preferredProtocol') addNode: ( XML.Text text: str))]].	^root</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>TLSExtension</name><environment>Xtreams</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>data code </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Xtreams-TLS</category><attributes><package>TLS</package></attributes></class><class><name>TLSSignatureAlgorithms</name><environment>Xtreams</environment><super>Xtreams.TLSExtension</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>TLS</package></attributes></class><class><name>TLSContext</name><environment>Xtreams</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>random sessions certificates suites compressions extensions maxVersion minVersion dheParameters ecdheParameters mayRenegotiate </inst-vars><class-inst-vars>defaultRandom defaultSecureSuites defaultCompressions defaultExtensions defaultDHEParameters defaultECDHEParameters defaultMayRenegotiate defaultCertificateStore </class-inst-vars><imports>			private OS.OSHandle			</imports><category>Xtreams-TLS</category><attributes><package>TLS</package></attributes></class><class><name>TLSSignatureAndHashAlgorithm</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars>hash signature code name versions algorithm </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.Pragma			</imports><category></category><attributes><package>TLS</package></attributes></class><class><name>TLSServerContext</name><environment>Xtreams</environment><super>Xtreams.TLSContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serverCertificates serverNameVerifier supportedCertificateTypes supportedSignatureAlgorithms </inst-vars><class-inst-vars>defaultServerNameVerifier supportedSignatureAlgorithms defaultServerSessionCache </class-inst-vars><imports>			private OS.OSHandle			</imports><category>Xtreams-TLS</category><attributes><package>TLS</package></attributes></class><class><name>TLSCipherSuite</name><environment>Xtreams</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name code prf keyExchange cipher mac key_length block_length mac_key_length mac_length verify_data_length mode record_iv_length fixed_iv_length </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.Pragma			</imports><category>Xtreams-TLS</category><attributes><package>TLS</package></attributes></class><class><name>TLSAppLayerProtocolNegotiation</name><environment>Xtreams</environment><super>Xtreams.TLSExtension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>preferredProtocols </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>TLS</package></attributes></class><class><name>TLSCompression</name><environment>Xtreams</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name code </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Xtreams-TLS</category><attributes><package>TLS</package></attributes></class><class><name>TLSConnection</name><environment>Xtreams</environment><super>Core.Announcer</super><private>true</private><indexed-type>none</indexed-type><inst-vars>context session handshake writeLock output input socket client_random server_random write_mac_key read_mac_key write_key read_key write_iv read_iv client_verify_data server_verify_data secure_renegotiation handshakeClass tlsExtensions </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.OsTransferFaultError			private Crypto.*			Security.*			</imports><category>Xtreams-TLS</category><attributes><package>TLS</package></attributes></class><class><name>Server</name><environment>SiouX</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>listeners connections responders debugging id logs noResponderReply </inst-vars><class-inst-vars>logFactory noResponderReply configurationFileName importErrorsFilename </class-inst-vars><imports>			private Protocols.*			private OS.*			private XML.*			</imports><category></category><attributes><package>SiouX-Server</package></attributes></class><class><name>ProtocolVersion</name><environment>Protocols</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection validateHostOriginBlock writeResponseBlock settings </inst-vars><class-inst-vars>validateHostOriginBlock </class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http</package></attributes></class><class><name>HttpConnection</name><environment>SiouX</environment><super>SiouX.Connection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>persist protocolVersion </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.*			private Kernel.*			</imports><category></category><attributes><package>SiouX-Server</package></attributes></class><class><name>HttpListener</name><environment>SiouX</environment><super>SiouX.Listener</super><private>false</private><indexed-type>none</indexed-type><inst-vars>exceptionPrinter persist protocolVersions requestStatusLineLimit requestHeaderLimit requestBodyLimit acceptedServerNames </inst-vars><class-inst-vars>exceptionPrinter persist protocolVersions </class-inst-vars><imports>			OS.*			</imports><category></category><attributes><package>SiouX-Server</package></attributes></class><class><name>HTTPv11</name><environment>Protocols</environment><super>Protocols.ProtocolVersion</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http</package></attributes></class><class><name>TLSCertificateStore</name><environment>Xtreams</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>owned known trusted </inst-vars><class-inst-vars></class-inst-vars><imports>			private Smalltalk.*			private Security.X509.*			</imports><category>Xtreams-TLS</category><attributes><package>TLS</package></attributes></class></st-source>