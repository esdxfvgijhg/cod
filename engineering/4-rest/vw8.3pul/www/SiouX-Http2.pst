<?xml version="1.0"?><st-source><!-- Name: SiouX-Http2Notice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: HTTP2 server implementation based on RFC 7540. Create SiouX server with HTTP2 support over clear connection. Be aware that web browsers don't support HTTP/2 over clear connection.	server := Server id: 'Http2ServerTest'.	server addResponder: ( responder := Hello new path: '/hello'; yourself).	listener := server listenOn: 8000 for: HttpConnection.	listener protocolVersions: (Array with: HTTPv20 new).	server start.Create SiouX server with HTTP2 support over secure connection:	server := Server id: 'AppeXExamples'.	listener := server listenOn: 8003 for: SiouX.HttpsConnection.	server		addSecureListener: listener		certificateFile: 'certificates.pem'		privateKeyFile: 'privatekey-rsa.key'.	listener useHTTP2Protocol.	server start.The HTTP/2 framework uses multiple processes, so the output of log announcements to the Transcript doesn't always reflect the correct order of the announcements. Instead of logging to the Transcript, the announcements can also be collected using an AnnouncementCollector and reviewed later.	ac := AnnouncementCollector new.	ac announcements: 		Protocols.ReceivedFrameAnnouncement, 		Protocols.SentFrameAnnouncement, 		Protocols.HTTP2ErrorAnnouncement, 		Protocols.DebugAnnouncement.	ac start.	SiouX.HTTP2ServerMultiplexer announcementPrinter: ac.	ac log inspect.	ac stop.	ac resetLog.DbIdentifier: bear73DbTrace: 502929DbUsername: tkoganDbVersion: 8.3 - 25DevelopmentPrerequisites: #(#(#any 'Protocols-Http2' '') #(#any 'SiouX-Http' ''))PackageName: SiouX-Http2Parcel: #('SiouX-Http2')PrerequisiteDescriptions: #(#(#name 'Protocols-Http2' #componentType #package) #(#name 'SiouX-Http' #componentType #bundle))PrerequisiteParcels: #(#('Protocols-Http2' '') #('SiouX-Http' ''))PrintStringCache: (8.3 - 25,tkogan)Version: 8.3 - 25Date: 1:19:07 PM July 14, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (jul17.2) of July 14, 2017 on July 14, 2017 at 1:19:07 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>HTTP2WriteScheduler</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controlFrames status sendActions multiplexer sendSynch dependencyTree sendingProcess </inst-vars><class-inst-vars></class-inst-vars><imports>			private Protocols.*			</imports><category></category><attributes><package>SiouX-Http2</package></attributes></class><comment><class-id>SiouX.HTTP2WriteScheduler</class-id><body>HTTP2WriteScheduler implements scheduling DATA frames based on their dependency. Uses HTTP2Dependency to build the dependency treeInstance Variables:	dependencyTree &lt;SharedRegistry&gt; holds streams dependency tree, the key is a stream id and value is HTTP2Node object	sendActions &lt;SharedQueue&gt; synchronizes sending frames in a sending process	sendSynch &lt;Semaphore&gt; to synch sending actions	controlFrames &lt;SharedQueue&gt; holds control frames scheduled to send	multiplexer	&lt;HTTP2ServerMultiplexer&gt;		status	&lt;ByteSymbol&gt;	 status: #running or #terminated	sendingProcess &lt;Process&gt; schedules sending frames</body></comment><class><name>HTTP2WeightScheduler</name><environment>SiouX</environment><super>SiouX.HTTP2WriteScheduler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Protocols.*			</imports><category></category><attributes><package>SiouX-Http2</package></attributes></class><comment><class-id>SiouX.HTTP2WeightScheduler</class-id><body>HTTP2WeightScheduler sends DATA frames according to their stream dependency and weight. Uses HTTP2WeightNode to build the dependency tree. Also see HTTP2WeightNode class comments. The scheduler always starts from the root stream (id = 0) until it finds the first active node with the lowest sort key</body></comment><class><name>HTTP2ServerStream</name><environment>SiouX</environment><super>Protocols.HTTP2Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sendDataProcess node canHaveDependencies </inst-vars><class-inst-vars></class-inst-vars><imports>			private Protocols.*			</imports><category></category><attributes><package>SiouX-Http2</package></attributes></class><comment><class-id>SiouX.HTTP2ServerStream</class-id><body>HTTP2ServerStream implements a server flow of frames within the HTTP/2 connectionInstance Variables:	sendDataProcess &lt;Process&gt; writes a response in to HTTP2DATAWriteStream until the stream buffer is full. The stream notifies the multiplexer that the data buffer is full and waits until some DATA frames will be sent	node &lt;HTTP2Node&gt;	canHaveDependencies &lt;Boolean&gt; indicates whether the stream can have dependents.</body></comment><class><name>HTTP2Node</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependencies parentNode stream streamId weight </inst-vars><class-inst-vars></class-inst-vars><imports>			private Protocols.*			</imports><category></category><attributes><package>SiouX-Http2</package></attributes></class><comment><class-id>SiouX.HTTP2Node</class-id><body>HTTP2Node implements a node of HTTP2Stream dependency tree. A node hold information about a parent stream, its dependencies and weight. The stream will be sent only after its parent is closed. The HTTP2Node ignores the stream weight and is faster than HTTP2WeightNode. Instance Variables:	dependencies	&lt;(Collection of: HTTP2Node)&gt; dependencies: key is dependent stream id, value its weight	parentNode	&lt;HTTP2Node&gt;  parent node, the resources will be allocated for this node only when the parent stream is closed	weight &lt;Integer&gt; the stream priority weight. Default 16	stream &lt;HTTP2ServerStream&gt; after stream is closed the node sets is to nil	streamId &lt;Integer&gt; a stream idhttp://httpwg.org/specs/rfc7540.html#rfc.section.5.3.1https://hpbn.co/http2/PRIORITY frames allow a client to expresses how it would prefer to receive the responses. A stream dependency within HTTP/2 is declared by referencing the unique identifier of another stream as its parent; if omitted the stream is said to be dependent on the "root stream". Declaring a stream dependency indicates that, if possible, the parent stream should be allocated resources ahead of its dependencies.</body></comment><class><name>HTTP2WeightNode</name><environment>SiouX</environment><super>SiouX.HTTP2Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>activeQueue nodeSortKey found </inst-vars><class-inst-vars></class-inst-vars><imports>			private Protocols.*			</imports><category></category><attributes><package>SiouX-Http2</package></attributes></class><comment><class-id>SiouX.HTTP2WeightNode</class-id><body>HTTP2WeightNode implements scheduling algorithm utilizing HTTP/2 priority. The DATA frames are sent according to their stream dependency and weight. Instance Variables:	activeQueue	&lt;SortedCollection&gt; queue of active dependent nodes. A node is active until itself or any its dependencies has data to send	nodeSortKey	&lt;SmallInteger&gt;  is used for sorting the active queue	found &lt;Boolean&gt; internal flag indicating that an active stream is foundhttps://docs.google.com/presentation/d/1x3kWQncccrIL8OQmU1ERTJeq7F3rPwomqJ_wzcChvy8/edit#slide=id.gd20acb41b_0_124 To maintain “active” child streams, we use min priority queue per stream.Sort key: pseudo time; stream has earlier time gets scheduled earlyThe pseudo time t[i] for stream #i under parent stream #p is calculated as:t[i] = t_last[p] + nsent[i] * K / weight[i]t_last[p]: pseudo time of last stream popped from queue of stream #pnsent[i]: the number of bytes sent by stream #i in the last transmission (DATA frame write)weight[i]: weight of stream #iK: constant to compensate the lost bits by integer division (e.g., 256).</body></comment><class><name>HTTP2ServerMultiplexer</name><environment>SiouX</environment><super>Protocols.HTTP2Multiplexer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>activePushStreams writeScheduler writeSchedulerClass </inst-vars><class-inst-vars>writeSchedulerClass </class-inst-vars><imports>			private Protocols.*			</imports><category></category><attributes><package>SiouX-Http2</package></attributes></class><comment><class-id>SiouX.HTTP2ServerMultiplexer</class-id><body>HTTP2ServerMultiplexer implementes a multiplexer for server side. The multiplexer supports stream dependencies and prioritization.Instance Variables:	activePushStreams &lt;Integer&gt; the amount of active push streams. The number is limited by a client SETTINGS_MAX_CONCURRENT_STREAMS	writeScheduler &lt;HTTP2WriteScheduler or HTTP2WeightScheduler&gt; writes DATA frames 	writeSchedulerClass &lt;Class&gt;   HTTP2WriteScheduler or HTTP2WeightScheduler.Class Instance Variables:	writeSchedulerClass &lt;Class&gt;  HTTP2WriteScheduler or HTTP2WeightScheduler. The default is HTTP2WriteSchedulerShared Variables: 	IgnoreDependency &lt;Boolean&gt; if true the server will ignore the client stream dependencies. The default is false. </body></comment><shared-variable><name>IgnoreDependency</name><environment>SiouX.HTTP2ServerMultiplexer</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>false</initializer><attributes><package>SiouX-Http2</package></attributes></shared-variable><methods><class-id>SiouX.HTTP2WriteScheduler</class-id> <category>accessing</category><body package="SiouX-Http2">dependencyTree	^dependencyTree</body><body package="SiouX-Http2">maxFrameSize	^ multiplexer remoteSettings maxFrameSizeValue</body><body package="SiouX-Http2">nodeClass	^ HTTP2Node</body><body package="SiouX-Http2">status 	^status</body></methods><methods><class-id>SiouX.HTTP2WriteScheduler</class-id> <category>testing</category><body package="SiouX-Http2">hasFramesToSend 	^ controlFrames notEmpty		or: [ 	sendActions notEmpty]</body><body package="SiouX-Http2">isTerminated	^status = #terminated</body></methods><methods><class-id>SiouX.HTTP2WriteScheduler</class-id> <category>initialize-release</category><body package="SiouX-Http2">close	[controlFrames notEmpty or: [ sendActions notEmpty]] 		whileTrue: [ self sendFrames ].	controlFrames := nil.	sendActions := nil.	sendingProcess ifNotNil: [ 		sendingProcess terminate.		sendingProcess := nil ].</body><body package="SiouX-Http2">initialize	controlFrames := SharedQueue new.	sendActions := SharedQueue new.	dependencyTree := SharedRegistry new.	"Create root node"	self 		addNodeFor: nil 		id: 0		parent: nil		weight: nil.		sendSynch := Semaphore new.	status := #running.</body><body package="SiouX-Http2">multiplexer: aServerMultiplexer	multiplexer := aServerMultiplexer</body><body package="SiouX-Http2">terminate	status := #terminated</body></methods><methods><class-id>SiouX.HTTP2WriteScheduler</class-id> <category>dependency tree</category><body package="SiouX-Http2">addNodeFor: anHTTPServerStream id: anInteger parent: parentNode weight: wInteger"Add a new node to dependency tree. The anHTTPServerStream can be nil if the node is created by Priority frame.The anHTTP2Node is nil for the dependency tree root, the node stream id in this case is 0 "	| node newParent |	node := self nodeClass newFor: anHTTPServerStream.	node 		streamId: anInteger;		weight: wInteger.		self dependencyTree at: anInteger  put: node.		parentNode == nil ifFalse: [		newParent := parentNode canHaveDependencies					ifTrue: [ parentNode ]					ifFalse: [ parentNode parentNode ].		node parentNode: newParent .		newParent  addDependentNode: node ].	^ node</body><body package="SiouX-Http2">addNodeFor: anHTTP2ServerStream id: anInteger parentId: parentId weight: wInteger	^self 		addNodeFor: anHTTP2ServerStream 		id: anInteger		parent: (self parentFor: parentId )		weight: wInteger</body><body package="SiouX-Http2">changePriorityFor: aStream priorityFrame: aPriorityFrame	| node newParent |	newParent := self parentFor: aPriorityFrame parentStreamId.	node := aStream node.		self resetParent: newParent for: aStream node.	node weight ~= aPriorityFrame weight ifTrue: [ 		node weight: aPriorityFrame weight ].	"An exclusive flag allows for the insertion of a new level of dependencies. The exclusive flag causes the stream to become the sole dependency of its parent stream, causing other dependencies to become dependent on the exclusive stream"	(aPriorityFrame isExclusiveDependend and: [ node parentNode notNil ]) ifTrue: [		newParent dependencies copy do: [ :each | 			each ~~ node ifTrue: [							newParent removeDependentNode: each.				each parentNode: node.				node addDependentNode: each]]].	self privateChangePriorityFor: node.</body><body package="SiouX-Http2">nodeAt: aStreamId	^ self nodeAt: aStreamId ifAbsent: [nil]</body><body package="SiouX-Http2">nodeAt: aStreamId ifAbsent: aBlock	^self dependencyTree at: aStreamId ifAbsent: aBlock</body><body package="SiouX-Http2">parentFor: parentId 	^parentId ~= 0		ifTrue: [ self nodeAt: parentId ]		ifFalse: [ self rootNode ]</body><body package="SiouX-Http2">privateChangePriorityFor: node	"Do nothing for the write scheduler"</body><body package="SiouX-Http2">resetParent: parentNode for: aNode"If a stream is made dependent on one of its own dependencies, the formerly dependent stream is first moved to be dependent on the reprioritized stream's previous parent. The moved dependency retains its weight"	aNode parentNode streamId = parentNode streamId ifTrue: [ ^nil ].		aNode parentNode removeDependentNode: aNode.	aNode parentNode: parentNode.	parentNode addDependentNode: aNode.</body><body package="SiouX-Http2">rootNode	^self nodeAt: 0</body></methods><methods><class-id>SiouX.HTTP2WriteScheduler</class-id> <category>services</category><body package="SiouX-Http2">closeStreamOnError: anHTTP2Stream	anHTTP2Stream node == nil		ifTrue: [ anHTTP2Stream close ]		ifFalse: [			anHTTP2Stream node retire.			self queueNodeDependencies: anHTTP2Stream node ]</body><body package="SiouX-Http2">resetPriorityFor: anHTTP2ServerStream priorityFrame: aPriorityFrame	self queueAction: [self changePriorityFor: anHTTP2ServerStream priorityFrame: aPriorityFrame]</body><body package="SiouX-Http2">startSendingProcess	(sendingProcess := [self senderProcessBody]		forkAt: Processor systemBackgroundPriority)		name: 'Server Multiplexer Sender'.</body><body package="SiouX-Http2">stopSendingProcess	self terminate.	self sendSynchSignal.</body></methods><methods><class-id>SiouX.HTTP2WriteScheduler</class-id> <category>scheduling</category><body package="SiouX-Http2">activateRootDependent: anHTTP2Node	" Do nothing for WriteScheduler"</body><body package="SiouX-Http2">queueAction: aBlock	sendActions == nil ifTrue: [^self ].	sendActions nextPut: aBlock.			self sendSynchSignal</body><body package="SiouX-Http2">queueFrame: aFrame	controlFrames == nil ifTrue: [ ^ self].	controlFrames nextPut: aFrame.	self sendSynchSignal</body><body package="SiouX-Http2">queueNodeDependencies: anHTTP2Node	self queueAction: [		anHTTP2Node dependencies do: [ :depNode | 			depNode stream == nil ifFalse: [  				multiplexer ignoreDependency ifFalse: [					self queueStream: depNode stream  ]]]]</body><body package="SiouX-Http2">queueSendData: anHTTP2Node	anHTTP2Node isClosed ifTrue: [^ self].	self queueAction: [ self sendDATAFromActiveNode: anHTTP2Node ].</body><body package="SiouX-Http2">queueStream: anHTTP2ServerStream	| node |	node := anHTTP2ServerStream node.	(multiplexer ignoreDependency not		and: [ node notNil			and: [ node parentNode isClosed not]]) ifTrue: [ ^ self ].	self queueAction: [		anHTTP2ServerStream headerFramesDo: [ :frame | self sendFrame: frame].		anHTTP2ServerStream sendHeadersOnly			ifTrue: [ self closeStream: anHTTP2ServerStream  ]				ifFalse: [ anHTTP2ServerStream createOutputDataStream.				self activateRootDependent: node ]].</body><body package="SiouX-Http2">sendSynchSignal	sendSynch signal.</body></methods><methods><class-id>SiouX.HTTP2WriteScheduler</class-id> <category>sending</category><body package="SiouX-Http2">closeStream: anHTTP2Stream	anHTTP2Stream isClosed ifTrue: [ ^self ].	anHTTP2Stream setClosed.	anHTTP2Stream close.</body><body package="SiouX-Http2">sendDATAFromActiveNode: node	| allowed stream |	"Check one more time if anything got closed"	(node isClosed		or: [ (stream := node stream) isClosed			or: [ multiplexer isClosed ]]) ifTrue: [ ^ self ].	allowed := self maxFrameSize min: stream remoteAvailable.	allowed &lt;= 0 ifTrue: [ 		"The client is not ready back to the queue"		^ self queueSendData: node ].	stream 		getDataFrameLimited: allowed		do: [ :frame | 			self sendFrame: frame.			self sentBytes: frame dataSize from: node.			frame endOfStream ifTrue: [ 				self closeStream: stream.				self queueNodeDependencies: node.				node retire. ]		 ].</body><body package="SiouX-Http2">sendFrame: aFrame	multiplexer sendFrame: aFrame</body><body package="SiouX-Http2">sendFrames	"Sending control frames"			[controlFrames notEmpty]		whileTrue: [ self sendFrame: controlFrames next ].	"Sending stream HeadersFrame(s).	Sending DataFrame(s) for the WriteScheduler"	sendActions notEmpty		ifTrue: [ sendActions next value.  ].</body><body package="SiouX-Http2">senderProcessBody	[		sendSynch wait.		self sendFrames.		self isTerminated.	] whileFalse.</body><body package="SiouX-Http2">sentBytes: dataSize from: node</body></methods><methods><class-id>SiouX.HTTP2WriteScheduler class</class-id> <category>instance creation</category><body package="SiouX-Http2">multiplexer: aServerMultiplexer	^self new		multiplexer: aServerMultiplexer;		yourself</body><body package="SiouX-Http2">new	^super new initialize</body></methods><methods><class-id>SiouX.HTTP2WeightScheduler</class-id> <category>accessing</category><body package="SiouX-Http2">nodeClass	^ HTTP2WeightNode</body></methods><methods><class-id>SiouX.HTTP2WeightScheduler</class-id> <category>dependency tree</category><body package="SiouX-Http2">privateChangePriorityFor: anHTTP2Node		"If the new parent is closed and the node is not in the active streams move the node to active streams"	(anHTTP2Node isActive not and: [ anHTTP2Node parentNode isClosed]) ifTrue: [ anHTTP2Node moveToActive]</body></methods><methods><class-id>SiouX.HTTP2WeightScheduler</class-id> <category>sending</category><body package="SiouX-Http2">sendFrames	super sendFrames.					"Send DataFrame(s)"	self rootNode activeQueueDo: [ :node |		self sendDATAFromActiveNode: node 	].</body><body package="SiouX-Http2">sentBytes: dataSize from: node	node sentBytes: dataSize</body></methods><methods><class-id>SiouX.HTTP2WeightScheduler</class-id> <category>scheduling</category><body package="SiouX-Http2">activateRootDependent: anHTTP2Node	" If this node parent is root move the node to the root active queue.  "	anHTTP2Node parentNode isRootNode ifTrue: [ anHTTP2Node moveToActive ]</body><body package="SiouX-Http2">queueSendData: anHTTP2Node	" If the node parent has already have this node in its active queue only raise a signal "	(anHTTP2Node parentNode includesActiveNode: anHTTP2Node) ifTrue: [^ self sendSynchSignal ].	"The node parent adds this node to its active queue"		self queueAction: [anHTTP2Node moveToActive].</body></methods><methods><class-id>SiouX.HTTP2ServerStream</class-id> <category>accessing</category><body package="SiouX-Http2">-= aNumber"The method is used in HttpRequest&gt;&gt;release "</body><body package="SiouX-Http2">acceptedServerNames	^ self multiplexer connection listener acceptedServerNames</body><body package="SiouX-Http2">node	^node</body><body package="SiouX-Http2">node: anHTTP2Node	node := anHTTP2Node</body><body package="SiouX-Http2">pseudoHeaderFields	^self class requestPseudoHeaders</body></methods><methods><class-id>SiouX.HTTP2ServerStream</class-id> <category>testing</category><body package="SiouX-Http2">canAcceptData	^self isOpen</body><body package="SiouX-Http2">hasBody	^(self method = 'GET' or: [ self method = 'HEAD' or: [self method = 'DELETE']]) not</body><body package="SiouX-Http2">hasDataToSend	^outputDataStream ~~ nil 		and: [outputDataStream hasDataToSend ]</body><body package="SiouX-Http2">isReceivingHeaders	^ endOfHeaders not		and: [self isOpen or: [self isHalfClosedRemote]]</body><body package="SiouX-Http2">isReserved	^self state = #reserved_local</body></methods><methods><class-id>SiouX.HTTP2ServerStream</class-id> <category>write output</category><body package="SiouX-Http2">createOutputDataStream	|  body dashes cr boundary  |	outputDataStream == nil ifFalse: [^self].	outputDataStream := HTTP2DATAWriteStream on: self. 		sendDataProcess := [		body := httpMessage contents.		httpMessage isMultipart 			ifTrue: [	dashes := #[45 45]. " '--' asByteArrayEncoding: #ascii "				cr := #[13 10].				boundary := httpMessage binaryBoundaryLine.				body do: [ :part |					outputDataStream write: boundary; write: cr.					part writeOn: outputDataStream ].				outputDataStream 					write: boundary; 					write: dashes; 					write: cr.]			ifFalse: ["#siouxWriteBodyFor:on: closes the stream"				body siouxWriteBodyFor: httpMessage on: outputDataStream ].			outputDataStream close.	] 	fork.	self multiplexer isLogging ifTrue: [		sendDataProcess name: 'HTTP2StreamServer send data', self id printString, ' ', self multiplexer connection printString].</body><body package="SiouX-Http2">headerFramesDo: aBlock	| tempHeaders |	tempHeaders := OrderedCollection 				with: (HttpResponseHeaderField name: ':status' value: httpMessage code  )				with: (HttpResponseHeaderField name: 'date' value: Timestamp nowUTC ).	HttpResponse serverHeaderValue == nil ifFalse: [		tempHeaders add: (HttpResponseHeaderField name: 'server' value: HttpResponse serverHeaderValue)].	tempHeaders addAll: httpMessage headers.	self 		writeHeaders: tempHeaders 		do: [ :header :stream | header value siouxWriteHeaderValueFor: httpMessage on: stream]		onFrame: aBlock.			self sendHeadersOnly ifTrue: [ self setClosed ].</body><body package="SiouX-Http2">pushResourceFromLink: aLinkHeader"If the server pushes responses referenced by the header block (for instance, in Link header fields), sending a PUSH_PROMISE before sending the header block ensures that clients do not request those resources"	| stream   pushNode |	stream := self multiplexer nextPushStream.		endOfHeaders := true.	stream authority: authority.	stream queuePushPromiseFrom: aLinkHeader for: self.			pushNode := self multiplexer 			addNodeForPushed: stream 			from: id.			self multiplexer pushResourceFrom: aLinkHeader for: stream.	^pushNode</body><body package="SiouX-Http2">queuePushPromiseFrom: aLinkHeader for: aStream	| writeStream tempHeaders promise |	tempHeaders := OrderedCollection 				with: (HttpResponseHeaderField name: ':scheme'  value: aStream scheme )				with: (HttpResponseHeaderField name: ':method'  value: self pushMethod )				with: (HttpResponseHeaderField name: ':path'  value:  aLinkHeader value url pathString ).		"The server MUST include a value in the :authority pseudo-header field for which the server is authoritative (see Section 10.1)."	tempHeaders add: (HttpResponseHeaderField name: ':authority' value: self serverName).	writeStream := ByteArray new writing.					self hpackEncoder do: 		[tempHeaders do: [:header |			self hpackEncoder				writeFieldNamed: header name				value: header value				on: writeStream]].	writeStream close.		promise := PushPromiseFrame new 				streamId: aStream id;				promisedStreamId: self id;				beEndOfHeaders;				headerBlockFragment: writeStream contents;				yourself.	"Sending a PUSH_PROMISE frame creates a new stream and puts the stream into the #reserved (local)"	self setReservedLocal.	self multiplexer queueFrame: promise</body><body package="SiouX-Http2">readyToSendData"Notify the multiplexer that the data buffer is full and waits until some DATA frames will be sent "	self multiplexer streamReadyToSendData: self</body><body package="SiouX-Http2">signalMoreData"Some DATA frames has been sent. Signal to HTTP2DATAStream that it can write more data"	outputDataStream signal.</body><body package="SiouX-Http2">writeFrames	"If there are Link header fields ask multiplexer to send PUSH_PROMISE frames with the resource url.	Remove the Link field from the response headers"		self isPushed		ifTrue: [ "The response for a PUSH_PROMISE stream begins with a HEADERS frame, 			which immediately puts the stream into the half-closed (remote) state for the server"			self setHalfClosedRemote]		ifFalse: [			self multiplexer remoteSettings isPushEnabled ifTrue: [				"Check if the response has LinkField which we use to create PUSH_PROMISE frame.				Create PUSH_PROMISE frame for each LinkField and remove the field from the response"				httpMessage preloadLinksRemoveDo: [ :linkHeader | self pushResourceFromLink: linkHeader ]]].			"Timeout for waiting Window_update?"		self multiplexer queueStream: self</body></methods><methods><class-id>SiouX.HTTP2ServerStream</class-id> <category>dispatching process</category><body package="SiouX-Http2">dispatchMessage	"Headers are processed, create a body stream and dispatch the request '"		self decodeHeader.	self multiplexer protocolVersion dispatchRequest: self</body></methods><methods><class-id>SiouX.HTTP2ServerStream</class-id> <category>initialize-release</category><body package="SiouX-Http2">close	self isReleased ifTrue: [^nil].	super close.	self isPushed ifTrue: [ self multiplexer decreaseActivePushStreams].	sendDataProcess ifNotNil: 		[ sendDataProcess terminate.		sendDataProcess := nil ].</body><body package="SiouX-Http2">closeRstStreamFrame: aFrame	self multiplexer closeStream: self</body></methods><methods><class-id>SiouX.HTTP2ServerStream</class-id> <category>processing frames</category><body package="SiouX-Http2">processWINDOW_UPDATE: aNumber	super processWINDOW_UPDATE: aNumber.	self hasDataToSend  ifTrue: [ self readyToSendData ].</body></methods><methods><class-id>SiouX.HTTP2ServerStream</class-id> <category>state</category><body package="SiouX-Http2">setReservedLocal	self isClosed ifFalse: [ state := #reserved_local ]</body></methods><methods><class-id>SiouX.HTTP2ServerStream</class-id> <category>parsing headers</category><body package="SiouX-Http2">anyPseudoHeaderNil		^self anyRequestPseudoHeaderNil</body><body package="SiouX-Http2">headersDone	self hasBody ifTrue: [ self ensureInputDataStream ].</body><body package="SiouX-Http2">validateHeaders"All HTTP/2 requests MUST include exactly one valid value for the :method, :scheme, and :path pseudo-header fields, unless it is a CONNECT request. An HTTP request that omits mandatory pseudo-header fields is malformed.Malformed requests or responses that are detected MUST be treated as a stream error (Section 5.4.2) of type PROTOCOL_ERROR."		^self validateRequestHeaders</body><body package="SiouX-Http2">validateRequestHeaders	super validateRequestHeaders.	"Validate :authority pseudo-header against the listener accepted server names. If the accepted server names are empty let's skip the validation"	(self acceptedServerNames notEmpty 		and: [ authority ~~ nil			and: [(self acceptedServerNames includes: self serverName) not]]) ifTrue: [		^self streamProtocolError: (#UnrecognizedServerName &lt;&lt; #www &gt;&gt; 'Unrecognized Server Name' )	]</body></methods><methods><class-id>SiouX.HTTP2ServerStream</class-id> <category>private</category><body package="SiouX-Http2">canHaveDependencies	^canHaveDependencies ~~ false</body><body package="SiouX-Http2">setNoDependencies	canHaveDependencies := false</body></methods><methods><class-id>SiouX.HTTP2Node</class-id> <category>accessing</category><body package="SiouX-Http2">dependencies	^dependencies</body><body package="SiouX-Http2">parentNode	^parentNode</body><body package="SiouX-Http2">parentNode: anHTTP2DependencyNode	parentNode := anHTTP2DependencyNode</body><body package="SiouX-Http2">parentStream	^parentNode ifNotNil: [ parentNode stream ]</body><body package="SiouX-Http2">parentStreamId	^parentNode		ifNil: [0]		ifNotNil: [parentNode streamId]</body><body package="SiouX-Http2">stream	^stream</body><body package="SiouX-Http2">streamId	^streamId</body><body package="SiouX-Http2">streamId: anInteger	streamId := anInteger</body><body package="SiouX-Http2">weight	^weight ifNil: [ Protocols.PriorityFrame.DefaultWeight.]</body><body package="SiouX-Http2">weight: anInteger	^weight := anInteger</body></methods><methods><class-id>SiouX.HTTP2Node</class-id> <category>services</category><body package="SiouX-Http2">addDependentNode: anHTTP2Node	dependencies add: anHTTP2Node.</body><body package="SiouX-Http2">removeDependentNode: anHTTP2Node	dependencies remove: anHTTP2Node ifAbsent: [ nil ]</body><body package="SiouX-Http2">retire	stream := nil</body></methods><methods><class-id>SiouX.HTTP2Node</class-id> <category>comparing</category><body package="SiouX-Http2">= anHTTP2DependencyNode	^ self class == anHTTP2DependencyNode class and: [		self streamId = anHTTP2DependencyNode streamId		]</body><body package="SiouX-Http2">hash	^streamId hash</body></methods><methods><class-id>SiouX.HTTP2Node</class-id> <category>printing</category><body package="SiouX-Http2">printOn: aStream	aStream nextPutAll: (self isRootNode ifTrue: [  'Root '] ifFalse: [ 'Node ' ]). 	aStream nextPutAll: streamId printString.	aStream cr; nextPutAll: 'on: '.	stream printOn: aStream.			aStream 		cr;		nextPutAll: 'Dependencies: '. 			dependencies 		do: [ :n | n streamId printOn: aStream]		separatedBy: [aStream nextPut: $,].			parentNode ifNotNil: [ 		aStream 			cr;			nextPutAll: 'Parent: ';			nextPutAll: (parentNode streamId = 0 ifTrue: [ 'Root'] ifFalse: [ parentNode streamId printString ])].</body></methods><methods><class-id>SiouX.HTTP2Node</class-id> <category>testing</category><body package="SiouX-Http2">canHaveDependencies	^stream == nil		or: [ stream canHaveDependencies ]</body><body package="SiouX-Http2">hasDataToSend	^stream notNil and: [stream hasDataToSend]</body><body package="SiouX-Http2">isClosed	^ stream isNil</body><body package="SiouX-Http2">isRootNode	^ streamId isZero</body></methods><methods><class-id>SiouX.HTTP2Node</class-id> <category>initialize-release</category><body package="SiouX-Http2">initializeFrom: anHttp2Stream	dependencies := Set new.	anHttp2Stream == nil		ifTrue: [ streamId := 0 ]		ifFalse: [			stream := anHttp2Stream.			streamId := stream id.			stream node: self  ]</body></methods><methods><class-id>SiouX.HTTP2Node class</class-id> <category>instance creation</category><body package="SiouX-Http2">newFor: anHttpStream	^ self new		initializeFrom: anHttpStream;		yourself</body></methods><methods><class-id>SiouX.HTTP2WeightNode</class-id> <category>private</category><body package="SiouX-Http2">foundTrue	found := true.	parentNode ifNotNil: [  :p | p foundTrue ]</body><body package="SiouX-Http2">nodeSortKey	^nodeSortKey</body><body package="SiouX-Http2">sentBytes: anInteger"https://docs.google.com/presentation/d/1x3kWQncccrIL8OQmU1ERTJeq7F3rPwomqJ_wzcChvy8/edit#slide=id.gd20acb41b_0_124 Sort key: pseudo time; stream has earlier time gets scheduled earlyThe pseudo time t[i] for stream #i under parent stream #p is calculated as:t[i] = t_last[p] + nsent[i] * K / weight[i]t_last[p]: pseudo time of last stream popped from queue of stream #pnsent[i]: the number of bytes sent by stream #i in the last transmission (DATA frame write)weight[i]: weight of stream #iK: constant to compensate the lost bits by integer division (e.g., 256)."	nodeSortKey := self parentNode nodeSortKey + ((anInteger * 256) / self weight).</body></methods><methods><class-id>SiouX.HTTP2WeightNode</class-id> <category>accessing</category><body package="SiouX-Http2">activeQueue	^activeQueue</body></methods><methods><class-id>SiouX.HTTP2WeightNode</class-id> <category>testing</category><body package="SiouX-Http2">includesActiveNode: anHTTP2Node	^self activeQueue includes: anHTTP2Node</body><body package="SiouX-Http2">isActive 	^self activeQueue notEmpty or: [ stream notNil ]</body></methods><methods><class-id>SiouX.HTTP2WeightNode</class-id> <category>services</category><body package="SiouX-Http2">activeQueueDo: aBlock	| node  size |	self activeQueue isEmpty ifTrue: [ ^ nil ].		found := false.	size := self activeQueue size.	1 to: size do: [ :i |		node := self activeQueue removeFirst.			node isClosed not			ifTrue: [ node hasDataToSend 					ifTrue: [										nodeSortKey := node nodeSortKey.						found := true.						parentNode ifNotNil: [ :p | p foundTrue].						aBlock value: node ]]			ifFalse: [ node activeQueueDo: aBlock ].					node isActive ifTrue: [ self activeQueue add: node ].		found ifTrue: [^self ].	].</body><body package="SiouX-Http2">addActiveNode: nodeToAdd	(self activeQueue anySatisfy: [ :n | n streamId = nodeToAdd streamId]) ifFalse: [		self activeQueue add: nodeToAdd.		parentNode ifNotNil: [ :p | self moveToActive ]]</body><body package="SiouX-Http2">moveToActive	self parentNode addActiveNode: self</body></methods><methods><class-id>SiouX.HTTP2WeightNode</class-id> <category>printing</category><body package="SiouX-Http2">printOn: aStream	super printOn: aStream.	aStream nextPutAll: ', sort key: ', nodeSortKey printString</body></methods><methods><class-id>SiouX.HTTP2WeightNode</class-id> <category>initialize-release</category><body package="SiouX-Http2">initializeFrom: anHttp2Stream	activeQueue := SortedCollection sortBlock: [ :n1 :n2 | n1 nodeSortKey  &lt;= n2 nodeSortKey ].	nodeSortKey := 0.	super initializeFrom: anHttp2Stream.</body></methods><methods><class-id>SiouX.HTTP2ServerMultiplexer</class-id> <category>logging</category><body package="SiouX-Http2">type	^'S'</body></methods><methods><class-id>SiouX.HTTP2ServerMultiplexer</class-id> <category>accessing</category><body package="SiouX-Http2">server	^self connection server</body><body package="SiouX-Http2">writeScheduler	^writeScheduler ifNil: [ writeScheduler := self writeSchedulerClass multiplexer: self  ]</body><body package="SiouX-Http2">writeSchedulerClass	^writeSchedulerClass ifNil: [ writeSchedulerClass := self class writeSchedulerClass]</body><body package="SiouX-Http2">writeSchedulerClass: aClass	writeSchedulerClass := aClass</body></methods><methods><class-id>SiouX.HTTP2ServerMultiplexer</class-id> <category>services</category><body package="SiouX-Http2">closeAllStreams	self writeScheduler queueAction: [ 		self streams do: [ :str | str close]].</body><body package="SiouX-Http2">closeStream: anHTTP2Stream	self writeScheduler queueAction: [ anHTTP2Stream close ].</body><body package="SiouX-Http2">gracefulShutdownIn: aDuration"A server that is attempting to gracefully shut down a connection SHOULD send an initial GOAWAY frame with the last stream identifier set to 2^31-1 and a NO_ERROR code. This signals to the client that a shutdown is imminent and that initiating further requests is prohibited. After allowing time for any in-flight stream creation (at least one round-trip time), the server can send another GOAWAY frame with an updated last stream identifier. This ensures that a connection can be cleanly shut down without losing requests"	state = #closed ifTrue: [^nil].	state := #gracefulShutdown.	self queueFrame: (GoawayFrame noError						lastStreamID: self maximumStreamId;						yourself).	Timer 		after: aDuration		do: [ self stop ]</body><body package="SiouX-Http2">start	self server		when: ServerShutdownAnnouncement		do: [ :announcement | announcement duration ifNotNil: [ :duration | self gracefulShutdownIn: duration]]		for: self.	super start</body><body package="SiouX-Http2">stop	state = #closed ifTrue: [^nil].	self sendNoErrorGoaway.	state := #closed.	self stopSendingProcess.		self closeAllStreams.	self server unsubscribe: self.	writeScheduler close.	writeScheduler := nil.	self releaseAll.</body></methods><methods><class-id>SiouX.HTTP2ServerMultiplexer</class-id> <category>processing frames</category><body package="SiouX-Http2">processHEADERS: aHeaderFrame	| stream |	self isGracefulShutdown ifTrue: [^self].	super processHEADERS: aHeaderFrame.		stream := self findStream: aHeaderFrame streamId.	stream == nil 		ifTrue: [ stream := self newStreamFor: aHeaderFrame streamId ]		ifFalse: [ "It could be an idle stream created by PriorityFrame"			stream canAcceptTrailer ifTrue: [				aHeaderFrame endOfStream ifFalse: [					^HTTP2StreamError 						protocolError: stream id						errorString: (#ReceivedHEARESTrailerNoEOS &lt;&lt; #www &gt;&gt; 'Received HEADERS trailer without EOS flag')].				^stream trailerHeader: aHeaderFrame].						stream isOpen 				ifTrue: [ ^HTTP2StreamError 							protocolError: stream id 							errorString: (#ReceivedHEARESForOpenedStream &lt;&lt; #www &gt;&gt; 'Received another HEADERS frame for already opened stream') ]				ifFalse: [ stream isClosed ifTrue: [						^HTTP2StreamError 							streamClosedError: aHeaderFrame streamId 							errorString: (#ReceivedHEARESForClosedStream &lt;&lt; #www &gt;&gt; 'Received another HEADERS frame for already closed stream')]]].	stream setOpen.	self addDependencyNodeFor: stream using: aHeaderFrame.	stream processHEADERS: aHeaderFrame.</body><body package="SiouX-Http2">processPRIORITY: aPriorityFrame"The PRIORITY frame (type=0x2) specifies the sender-advised priority of a stream5.3.3 Reprioritizationhttp://httpwg.org/specs/rfc7540.html#rfc.section.5.3.3"	"If a PRIORITY frame is received with a stream identifier of 0x0, the recipient MUST respond with a connection error of type PROTOCOL_ERROR"	| stream |	aPriorityFrame streamId = 0 ifTrue: [		HTTP2ConnectionError protocolError: (#PriorityHas0Id &lt;&lt; #www &gt;&gt;'PRIORITY Frame has zero stream id' )].		"Validate stream depencies"	aPriorityFrame parentStreamId = aPriorityFrame streamId ifTrue: [		^HTTP2StreamError 			protocolError: aPriorityFrame streamId 			errorString: (#PriorityIdSameAsParentId &lt;&lt; #www &gt;&gt;'The PRIORITY stream id and the parent stream id are the same')].	" It can be sent in any stream state, including idle or closed streams.	The new stream doesn't change the active streams count"		(stream := self streams at: aPriorityFrame streamId ifAbsent: [ nil ]) == nil		ifTrue: [ self writeScheduler 				addNodeFor: nil				id: aPriorityFrame streamId 				parentId: aPriorityFrame parentStreamId 				weight:  aPriorityFrame weight ]		ifFalse: [ aPriorityFrame parentStreamId = stream id				ifTrue: [ "Ignore setting this stream to be the parent of itself." ^nil].			self writeScheduler resetPriorityFor: stream priorityFrame: aPriorityFrame ].</body><body package="SiouX-Http2">processPUSH_PROMISE: aFrame	"A client cannot push. Thus, servers MUST treat the receipt of a PUSH_PROMISE frame as a connection error  of type PROTOCOL_ERROR."	HTTP2ConnectionError protocolError: (#ClientCannotSendPush &lt;&lt; #www &gt;&gt; 'A client cannot send PUSH_PROMISE')</body></methods><methods><class-id>SiouX.HTTP2ServerMultiplexer</class-id> <category>testing</category><body package="SiouX-Http2">ignoreDependency	^self class ignoreDependency</body></methods><methods><class-id>SiouX.HTTP2ServerMultiplexer</class-id> <category>handling streams</category><body package="SiouX-Http2">decreaseActivePushStreams	self critical: [ activePushStreams := activePushStreams - 1]</body><body package="SiouX-Http2">http2StreamClass	^HTTP2ServerStream</body><body package="SiouX-Http2">increaseActivePushStreams	self critical: [ activePushStreams := activePushStreams + 1 ]</body><body package="SiouX-Http2">minimumStreamId	^0</body><body package="SiouX-Http2">newMessageStream	| pushId |	self increaseActivePushStreams.	^self streams 		at: (pushId := self nextStreamId)		put: (self http2StreamClass initialize: pushId with: self )</body><body package="SiouX-Http2">nextPushStream	activePushStreams + 1 &gt; self remoteSettings maxConcurrentStreamsValue ifTrue: [		"An endpoint that receives a HEADERS frame that causes its advertised SETTINGS_MAX_CONCURRENT_STREAMS limit to be exceeded MUST treat this as a stream error of type PROTOCOL_ERROR or REFUSED_STREAM. The choice of error code determines whether the endpoint wishes to enable automatic retry."		HTTP2StreamError 			refusedStreamError: self nextStreamId			errorString: (#PushStreamIdLargerRemoteMaxSetting &lt;&lt; #www &gt;&gt; 'The PUSH stream id is larger than remote settings max concurrent stream id')].	^self newMessageStream</body><body package="SiouX-Http2">validateHeaderStreamId: anInteger		super validateHeaderStreamId: anInteger.		anInteger &lt; self lastStreamID ifTrue: [		"The identifier of a newly established stream MUST be numerically greater than all streams that the initiating endpoint has opened or reserved"		HTTP2ConnectionError protocolError: (#NewStreamMustBeGreater &lt;&lt; #www &gt;&gt;'A newly established stream MUST be numerically greater than all streams')].			anInteger even ifTrue: ["5.1.1 Streams initiated by a client MUST use odd-numbered stream identifiers"		^HTTP2ConnectionError protocolError: (#StreamIdNotOdd &lt;&lt; #www &gt;&gt; 'The stream id is not odd')]</body></methods><methods><class-id>SiouX.HTTP2ServerMultiplexer</class-id> <category>write scheduling</category><body package="SiouX-Http2">addDependencyNodeFor: anHTTP2ServerStream using: aHeaderFrame	^self 		addNodeFor: anHTTP2ServerStream 		parentId: aHeaderFrame priority parentStreamId 		weight: aHeaderFrame priority weight</body><body package="SiouX-Http2">addNodeFor: anHTTP2ServerStream parentId: parentId weight: weight	^self writeScheduler 		addNodeFor: anHTTP2ServerStream 		id: anHTTP2ServerStream id		parentId: parentId		weight: weight</body><body package="SiouX-Http2">addNodeForPushed: anHTTP2ServerStream from: pushedId	^self writeScheduler		addNodeFor: anHTTP2ServerStream 		id: anHTTP2ServerStream  id		parentId: pushedId		weight: nil.</body><body package="SiouX-Http2">closeStreamOnError: anHTTP2Stream	self writeScheduler queueAction: [ 		 writeScheduler closeStreamOnError: anHTTP2Stream]</body><body package="SiouX-Http2">pushResourceFrom: aLinkHeader for: anHttp2Stream	| requestLine responder requestContext |	(requestLine := RequestLine on: self connection)		method: 'GET';		version: 'HTTP/2.0';		url: aLinkHeader value url.	responder := self connection server findResponderFor: requestLine on: self connection.	(requestContext := responder requestContextClass new) initializeFor: responder connection: self connection.	responder setRequestIn: requestContext from: requestLine.		self protocolVersion setStreamFor: requestContext from: anHttp2Stream.	requestContext dispatch.	^anHttp2Stream</body><body package="SiouX-Http2">queueFrame: aFrame	self writeScheduler queueFrame: aFrame.</body><body package="SiouX-Http2">queueStream: anHTTP2Stream	self writeScheduler queueStream: anHTTP2Stream.</body><body package="SiouX-Http2">sendGoawayOnError: aFrame	self writeScheduler queueAction: [ super sendGoawayOnError: aFrame ]</body><body package="SiouX-Http2">sendSynchSignal	self writeScheduler sendSynchSignal</body><body package="SiouX-Http2">startSendingProcess	self writeScheduler startSendingProcess</body><body package="SiouX-Http2">stopSendingProcess	self writeScheduler stopSendingProcess</body><body package="SiouX-Http2">streamReadyToSendData: anHTTP2ServerStream	self writeScheduler queueSendData: anHTTP2ServerStream node</body></methods><methods><class-id>SiouX.HTTP2ServerMultiplexer</class-id> <category>initialize-release</category><body package="SiouX-Http2">handshake	| stringPRI  text |	self startSendingProcess.	"Read the client connection preface"	stringPRI := self readStream read: ClientPreface size.	stringPRI = ClientPreface ifFalse: [ 		text := #ReceivedWrongClientPreface &lt;&lt; #www &gt;&gt; 'Received a wrong client preface'.		self stopSendingProcess.		self logAnnounceError: text.		^HTTP2ConnectionError protocolError: text].</body><body package="SiouX-Http2">initialize	super initialize.	activePushStreams := 0.</body><body package="SiouX-Http2">setStreamForInitialRequest: aRequestContext settings: aByteArray bodySource: bodyBytes	"The method is used to upgrade a plain HTTP/1.1 request to HTTP2"	"We need to create a stream with id = 1 from this RequestContext"	| stream |		remoteSettings := SettingsFrame new 					length: aByteArray size;					readPayloadFrom: aByteArray reading;					yourself. 							stream := self newStreamFor: 1.	stream 		setEndOfHeaders;		setHalfClosedRemote.		aRequestContext http2Stream: stream.	aRequestContext  connection protocolVersion: self protocolVersion.	self 		addNodeFor: stream 		parentId: 0		weight: nil.		bodyBytes ifNotNil: [		stream processDATA: (DataFrame new 							streamId: 1;							data: bodyBytes;							beEndOfStream;							yourself) ].</body></methods><methods><class-id>SiouX.HTTP2ServerMultiplexer class</class-id> <category>accessing</category><body package="SiouX-Http2">defaultWriteSchedulerClass	^ HTTP2WriteScheduler</body><body package="SiouX-Http2">ignoreDependency	^IgnoreDependency</body><body package="SiouX-Http2">ignoreDependency: aBoolean	IgnoreDependency := aBoolean</body><body package="SiouX-Http2">writeSchedulerClass	^writeSchedulerClass ifNil: [ writeSchedulerClass := self defaultWriteSchedulerClass ]</body><body package="SiouX-Http2">writeSchedulerClass: aWriteSchedulerClass	writeSchedulerClass := aWriteSchedulerClass</body></methods><methods><class-id>OS.PartialURL</class-id> <category>accessing</category><body package="SiouX-Http2">pathString	| stream |	stream := (String new: 32) writeStream.	self printEncodedPathOn: stream.	self printExtrasOn: stream.	^stream contents</body></methods><methods><class-id>SiouX.RequestContext</class-id> <category>accessing</category><body package="SiouX-Http2">http2Stream	^request ifNotNil: [ :req | req originalSource ]</body><body package="SiouX-Http2">http2Stream: anHttp2Stream	^request ifNotNil: [ :req | req originalSource: anHttp2Stream ]</body></methods><methods><class-id>SiouX.HttpsListener</class-id> <category>accessing</category><body package="SiouX-Http2">useHTTP2Protocol"A deployment of HTTP/2 over TLS 1.2 MUST disable compression. A deployment of HTTP/2 over TLS 1.2 MUST disable renegotiation.Implementations MUST support ephemeral key exchange sizes of at least 2048 bits for cipher suites that use ephemeral finite field Diffie-Hellman (DHE) [TLS12] and 224 bits for cipher suites that use ephemeral elliptic curve Diffie-Hellman (ECDHE) [RFC4492]"	tlsContext ifNil: [ ^self tlsContextNilError].	tlsContext  		suites: (TLSCipherSuite suites: #(tls12 (#ecdhe #(#sha256 #sha384))));		addExtension: Xtreams.TLSAppLayerProtocolNegotiation defaultH2.	self protocolVersions: (Array with: Protocols.HTTPv20 new)</body></methods><methods><class-id>Protocols.HTTPv20 class</class-id> <category>instance creation</category><body package="SiouX-Http2">newForSecureConnection: anHttpsConnection settings: anHttp2Settings	^ self new		newForSecureConnection: anHttpsConnection settings: anHttp2Settings;		yourself</body></methods><methods><class-id>Protocols.HTTPv20</class-id> <category>upgrade</category><body package="SiouX-Http2">acceptsProtocolIdentifier: aCollection	^aCollection includes: 'h2c'</body><body package="SiouX-Http2">acceptsSecureUpgrade: aString	^aString = 'h2'</body></methods><methods><class-id>Protocols.HTTPv20</class-id> <category>accessing</category><body package="SiouX-Http2">clientSettingsFor: aRequest"Decode client HTTP2 settings from Upgrade header field"	^(self http2SettingsFor: aRequest) 		ifNotNil: [	:field | ( field body rest withEncoding: #base64 ) readStream contents.].</body></methods><methods><class-id>Protocols.HTTPv20</class-id> <category>services</category><body package="SiouX-Http2">dispatchRequest: anHttp2Stream "Create HttpRequest from an Http2Stream frames and dispatch it"	| requestContext  |	requestContext := self requestContextFor: anHttp2Stream.	anHttp2Stream hasBody ifTrue: [requestContext request prepareRequestToProcess].	self multiplexer logAnnounce: [HTTPRequestAnnouncement stream: anHttp2Stream request: requestContext request].	requestContext dispatch</body></methods><methods><class-id>Protocols.HTTPv20</class-id> <category>accessing</category><body package="SiouX-Http2">http2SettingsFor: aRequest	aRequest headers: 'http2-settings' do: [ :field | ^field  ].	^nil</body></methods><methods><class-id>Protocols.HTTPv20</class-id> <category>initialize-release</category><body package="SiouX-Http2">initializeServerMultiplexer 	multiplexer := SiouX.HTTP2ServerMultiplexer connectionPreface: self.	^multiplexer</body></methods><methods><class-id>Protocols.HTTPv20</class-id> <category>upgrade</category><body package="SiouX-Http2">newForSecureConnection: anHttpsConnection settings: anHttp2Settings	anHttpsConnection protocolVersion: self.	settings := anHttp2Settings.	connection := anHttpsConnection.	self startServerMultiplexer</body></methods><methods><class-id>Protocols.HTTPv20</class-id> <category>private</category><body package="SiouX-Http2">parseHeadersFor: requestContext"Create HttpRequest from an Http2 stream frames and dispatch it"	|  field |		requestContext http2Stream headers do: [ :coll |		field := SiouX.HttpRequestHeaderField 					name: coll first 					source: coll last 					from: 0					to: coll last size.  		requestContext request processTransportField: field.		requestContext request headers add: field ].</body></methods><methods><class-id>Protocols.HTTPv20</class-id> <category>services</category><body package="SiouX-Http2">processRequest: aRequestContext	"Dispatch the first HTTPv11 request with Upgrade"	aRequestContext dispatch.	"Start processing frames"	multiplexer start.	connection persist: false</body></methods><methods><class-id>Protocols.HTTPv20</class-id> <category>upgrade</category><body package="SiouX-Http2">readRequestBodyFor: aRequestContext	"The method reads the first Http 1.1 request body. This request includes upgrade to HTTP2. 	We cache the request body and limit the first request to a frame max size"			| request buffer  bufferWriting source |	request := aRequestContext request.	buffer := ByteArray newRecycledDefaultSize.	bufferWriting := buffer writing limiting: self settingsFrame maxFrameSizeValue.			request applyTransferEncoding.	[	[ bufferWriting write: request source		]		on: Xtreams.Incomplete				do: [ :ex | ^SiouX.BadRequest raiseErrorString: ( #FirstPostRequestExceededSizeLimit &lt;&lt; #www &gt;&gt; 'The first POST request body size exceeded the limit: &lt;1p&gt; bytes'  expandMacrosWith: self settingsFrame maxFrameSizeValue)].		source := buffer copyFrom: 1 to: bufferWriting position.		request hasTransferEncoding ifTrue: [	request removeTransferFieldsContentLength: bufferWriting position].	] ensure: [ buffer recycle].		^source</body></methods><methods><class-id>Protocols.HTTPv20</class-id> <category>private</category><body package="SiouX-Http2">readRequestLineFrom: anHttp2Stream"Read HTTP2Stream pseudo-methods and create Http request line"	| requestLine |	requestLine := SiouX.RequestLine on: connection.	requestLine method: anHttp2Stream method.	requestLine path: anHttp2Stream path.	requestLine version: 'HTTP/2.0'.	^requestLine</body><body package="SiouX-Http2">setStreamFor: requestContext from: anHttp2Stream	requestContext request originalSource: anHttp2Stream.</body></methods><methods><class-id>Protocols.HTTPv20</class-id> <category>initialize-release</category><body package="SiouX-Http2">startServerMultiplexer 	self initializeServerMultiplexer start</body></methods><methods><class-id>Protocols.HTTPv20</class-id> <category>upgrade</category><body package="SiouX-Http2">upgradeRequest: aRequestContext"Switching to h2c "	| httpResponse  clSettings requestBodyBytes |	"Upgrade from Http1.1 to Http2 must include exactly one HTTP2-Settings header field"	(clSettings := self clientSettingsFor: aRequestContext request) ifNil: [		self error: (#RequestMustIncludeHTTP2Settings &lt;&lt; #www &gt;&gt;'A request must include exactly one HTTP2-Settings header field')].		aRequestContext request hasBody ifTrue: [		"Cache the request body to process after preface frame exchange"			requestBodyBytes := self readRequestBodyFor: aRequestContext		].	"If there is no problem notify the client that we accept the protocol switch h2c"		httpResponse := SiouX.HttpResponse code: 101.	httpResponse header: 'Upgrade' value: 'h2c'.	httpResponse header: 'Connection' value: 'Upgrade'.	aRequestContext sendResponse: httpResponse.	"Reset response to nil . 	We still need this request context to reply to the original request and we will reply using 2.0 frames "	aRequestContext response: nil.	self initializeServerMultiplexer		setStreamForInitialRequest: aRequestContext settings: clSettings bodySource: requestBodyBytes.</body><body package="SiouX-Http2">upgradeSecureConnection: anHttpsConnection	^ self class newForSecureConnection: anHttpsConnection settings: self settings copy.</body></methods><methods><class-id>Protocols.HTTPv20</class-id> <category>services</category><body package="SiouX-Http2">writeResponseBlock"Http2Stream creates and sends frames for HttpResponse"	^writeResponseBlock ifNil: [ 		writeResponseBlock := [ :requestContext | 			requestContext http2Stream 				ifNil: [ super writeResponseBlock ]				ifNotNil: [ :str | str writeFramesFrom: requestContext response ]]]</body></methods><methods><class-id>Xtreams.ReadStream</class-id> <category>accessing</category><body package="SiouX-Http2">contents	^self rest</body></methods><methods><class-id>Xtreams.ReadStream</class-id> <category>transforming</category><body package="SiouX-Http2">reset</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>RequestContext</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>responder connection request response data properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Server</package></attributes></class><class><name>PartialURL</name><environment>OS</environment><super>OS.URLwithPath</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RelativeURL</category><attributes><package>URISupport</package></attributes></class><class><name>HTTP2Multiplexer</name><environment>Protocols</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>streams streamId state hpackEncoder hpackDecoder remoteSettings protocolVersion flowControlWindow updatedSettings accessMutex lastStream activeStreams ackTimeout recyclingCenter </inst-vars><class-inst-vars>announcementPrinter </class-inst-vars><imports>			private Protocols.*			private Xtreams.*			</imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><class><name>HTTP2Stream</name><environment>Protocols</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>multiplexer headers id inputDataStream state endOfHeaders dispatchProcess flowControlWindow inputHeadersStream trailerHeader trailerHeaders contentLength inputDataSize outputDataStream httpMessage dataBytesSent method scheme authority path </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><class><name>HttpsListener</name><environment>SiouX</environment><super>SiouX.HttpListener</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tlsContext tlsVerifier </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Server-Secure</package></attributes></class><class><name>HTTPv20</name><environment>Protocols</environment><super>Protocols.ProtocolVersion</super><private>false</private><indexed-type>none</indexed-type><inst-vars>multiplexer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><class><name>ReadStream</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars>source </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.BehaviorIcons			</imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class></st-source>