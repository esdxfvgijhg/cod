<?xml version="1.0"?><st-source><!-- Name: AppeX-ToolsNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.BundleName: AppeX-ToolsBundleStructure: a Store.BundleForParcelComment: AppeX-Tools contains the tooling necessary to load JavascriptClass and its subclasses.The AppeX-Tools parcel is required for AppeX web application development, but for deployment, only AppeX-Core is necessary.TO LOAD A JAVASCRIPT SYNTAX HIGHLIGHTING THEME RESEMBLING THAT OF CHROME'S DEV TOOLS:	Manually (through the interface):		Click on the "System Menu" choice in the Smalltalk Transcript window.		Click on "Settings".		Expand "Tools" in the Settings dialog left pane.		Select "Editor" in the left pane.		In the right bottom pane, change the "Theme:" combobox selection to "Default Chrome".		Click the "Apply" button for the Settings dialog.		Note: to restore the default VisualWorks code highlighting theme, select and apply the theme "Default (Light)".	Programatically (execute in a workspace):		SourceCodeEditor defaultThemeKey: #defaultChrome.		SourceCodeEditor defaultThemeKey: #defaultLight. "restores theme that VW is shipped with"Automatic Catalog Generation for the 'AppeX-Internationalization' framework.To aid in creating a template locale specific catalog, one can execute the method "generateMessageCatalogs" against the appropriate Application subclass.e.g. Assuming you have MyApplication and MyApplicationClient classes that implement your server and client behavior, run in a workspace: MyAplication generateUserMessageCatalog.This will generate the file $VISUALWORKS\messages\visualworks\en\MyAplication.lbl.Executing this method will search the associated ApplicationClient (e.g., MyAplicationClient) for references to the function _translate, and generate a catalog file based on whatever key/ value pairs that the references provide.Note that the user can specify additional classes to be included in the search for references to _translate by specifying them in the MyAplication class method "classesForCatalog".The lbl file will have a key value structure as illustrated in the following line:currentServerTimeIs='Current local server time is'The lbl file structure, and the directory structure in which it is places,  conforms to the Message Catalog structure as described in the InternationalizationGuide.pdf.Thus the AppeX catalogs could be indexed and used within Smalltalk code in the VisualWorks IDE  as described in the InternationalizationGuide.pdf.For an specific example of using this catolog generation mechanism, load the Appex-Examples package and follow the above steps, substituting the application name 'HelloLocalized' for 'MyApplication'.DevelopmentPrerequisites: #(#(#any 'AT MetaNumerics' '') #(#any 'AppeX-Internationalization' '') #(#any 'SiouX-Tools' '') #(#any 'AppeX-Server' ''))PackageName: AppeX-ToolsParcel: nilParcelName: AppeX-ToolsPrerequisiteDescriptions: #(#(#name 'AT MetaNumerics' #componentType #package) #(#name 'AppeX-Internationalization' #componentType #package) #(#name 'SiouX-Tools' #componentType #package) #(#name 'AppeX-Server' #componentType #package))PrerequisiteParcels: #(#('AT MetaNumerics' '') #('AppeX-Internationalization' '') #('SiouX-Tools' '') #('AppeX-Server' ''))Version: 8.3 - 15Date: 3:30:54 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:30:54 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>PEG2</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category></category><attributes><package>PEGParser</package></attributes></name-space><class><name>JSFileMonitor</name><environment>AppeX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timeLastChecked timer </inst-vars><class-inst-vars>current frequency autoDeleteScriptFiles </class-inst-vars><imports></imports><category></category><attributes><package>AppeX-JSFile-Support</package></attributes></class><comment><class-id>AppeX.JSFileMonitor</class-id><body>JSFileMonitor uses a Timer to periodically execute a block of code which checks the timestamps of .js files in specified directories, and if the files are new than the timeLastChecked parses the code into the AppeX environment.Instance Variables:	timeLastChecked	&lt;Timestamp&gt; 	timer	&lt;Timer&gt;Class Instance Variables	current &lt;JSFileMonitor&gt; singleton	frequency &lt;Duration&gt;  duration to wait between checking for changes	directory &lt;NTFSFilename&gt; directory to monitor for changes	autoDeleteScriptFiles &lt;Boolean&gt; Automatically remove the script files when switching to using image methods</body></comment><class><name>ParserActor</name><environment>PEG2</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>actions start stop </inst-vars><class-inst-vars>actions </class-inst-vars><imports></imports><category></category><attributes><package>PEGParser</package></attributes></class><comment><class-id>PEG2.ParserActor</class-id><body>ParserActor is an abstract class for implementing various parser actors (see subclasses). The actors 'act' on rules expresses in a grammar by implementing methods with #action: or #action:arguments: pragmas. An actor is given as an argument to #parse:stream:actor: message sent to an instance of a PEG.Parser, which uses the actor to process expression definitions as it parses the source stream. When an instance of an actor finds an action it should execute for a definition, it will evaluate a block representing that action. See the method #process:object:start:stop: for details. Instance Variables	actions	&lt;Dictionary of: (Block)&gt;	holds a Dictionary of actions, where keys are definition nams and values are blocks to be evaluated when an action needs to be executed.	start	&lt;Integer&gt;	the start position of an action in the source stream, to be used by subclasses depending on the context of each action.	stop	&lt;Integer&gt;	the end position of an action in the source stream, to be used by subclasses depending on the context of each action.Class Instance Variables	actions &lt;Dictionary&gt; default Dictionary of actions</body></comment><class><name>JavascriptReferenceFinder</name><environment>AppeX</environment><super>PEG2.ParserActor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sends targetClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeXTools</package></attributes></class><comment><class-id>AppeX.JavascriptReferenceFinder</class-id><body>JavascriptReferenceFinder is used to find the message sends from within a Javascript function.Instance Variables	sends	&lt;Collection of: (Array)&gt;	message sends are described as arrays with the identifier being sent and its start and stop position in the source stream.</body></comment><class><name>GrammarParser</name><environment>PEG2</environment><super>Kernel.Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PEGParser</package></attributes></class><comment><class-id>PEG2.GrammarParser</class-id><body>GrammarParser is a parser used to parse a PEG grammar (i.e., subclasses of GrammarClass)</body></comment><class><name>JavascriptMinifyingWriter</name><environment>AppeX</environment><super>AppeX.JavascriptWriter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents </inst-vars><class-inst-vars>isMinifyingVars </class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Minification</package></attributes></class><comment><class-id>AppeX.JavascriptMinifyingWriter</class-id><body>JavascriptMinifyingWriter generates minified Javascript code Instance Variables	contents			&lt;String&gt; 		minified code Class Instance Variables	isMinifyingVars	&lt;Boolean&gt;	obfuscate and further minify the code by shortening variable names</body></comment><class><name>JavascriptParser</name><environment>AppeX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeXTools</package></attributes></class><comment><class-id>AppeX.JavascriptParser</class-id><body>JavascriptParser is used to parse Javascript source code.Instance Variables	selector &lt;Symbol&gt; function identifier	sourceCode &lt;String&gt; the original source to be parsed</body></comment><class><name>JavascriptMinifyingActor</name><environment>AppeX</environment><super>PEG2.ParserActor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source codeStream startStopLookupComments startStopLookupStringLiterals </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Minification</package></attributes></class><comment><class-id>AppeX.JavascriptMinifyingActor</class-id><body>The class compresses code (removing extra spaces, comments, etc).  It does not rename variables.Minifying algorithm based on the description at  http://www.crockford.com/javascript/jsmin.html,JSMin The JavaScript Minifier Douglas Crockford 2003-12-04Additional reference used: http://www.kerryr.net/pioneers/ascii3.htm, http://www.kerryr.net/pioneers/ascii2.htmInstance Variables	source						&lt;String&gt;	 			Javascript source code	nodes						&lt;Dictionary&gt;	 		nodes with special handling	scope						&lt;OrderedCollection&gt;	collection of dictionaries where each holds parameters and variables for that scope.	targetClass					&lt;Class&gt;	  			target class	oldSelector 					&lt;Symbol&gt;	arguments 					&lt;Collection&gt;	startStopLookupComments 		&lt;Dictionary&gt;			key is the start position of a comment, value is matching end position	startStopLookupStringLiterals 	&lt;Dictionary&gt;			key is the start position of a string literal, value is matching end position	codeStream 					&lt;ReadStream&gt;		contains string of code to be minified	codeStreamMinified 			&lt;ReadWriteStream&gt;	contains the string result of a minifying step</body></comment><class><name>JavascriptMethodRenameActor</name><environment>AppeX</environment><super>PEG2.ParserActor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>document isRenamingMethod oldSelector newSelector arguments startStopLookup </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeXTools</package></attributes></class><comment><class-id>AppeX.JavascriptMethodRenameActor</class-id><body>The class provides plugin for Javascript code highlighterInstance Variables	decoratingOffset	&lt;Number&gt;	decorating offset	document	&lt;Text2.Document&gt;	 document	nodes	&lt;Dictionary&gt;	 nodes with special handling	scope	&lt;OrderedCollection&gt;	collection of dictionaries where each holds parameters and variables for that scope.	targetClass	&lt;Class&gt;	  target class	theme	&lt;SourceCodeTheme&gt; theme	oldSelector &lt;Symbol&gt;	newSelector &lt;Symbol&gt;	arguments &lt;Collection&gt;	startStopLookup &lt;Dictionary&gt;	isRenamingMethod &lt;Boolean&gt;</body></comment><class><name>JavascriptParserActor</name><environment>AppeX</environment><super>PEG2.ParserActor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>document theme decoratingOffset nodes scope </inst-vars><class-inst-vars>useJavascriptSourceCodeTheme javascriptSourceCodeTheme </class-inst-vars><imports></imports><category></category><attributes><package>AppeXTools</package></attributes></class><comment><class-id>AppeX.JavascriptParserActor</class-id><body>The class provides plugin during Javascipt parsing.Currently used for Javascript syntax highlighting, and for minimizing variables.Instance Variables	decoratingOffset	&lt;Number&gt;	decorating offset	document	&lt;Text2.Document&gt;	 document	nodes	&lt;Dictionary&gt;	 nodes with special handling	scope	&lt;OrderedCollection&gt;	collection of dictionaries where each holds parameters and variables for that scope.	targetClass	&lt;Class&gt;	  target class	theme	&lt;SourceCodeTheme&gt; theme	positionVarNameLookup &lt;Dictionary&gt;	varNameMinStringLookup &lt;Dictionary&gt;	positionPropertyNameLookup &lt;Dictionary&gt;	isMinifying &lt;Boolean&gt;Class Instance Variables	useJavascriptSourceCodeTheme &lt;Boolean&gt; 	javascriptSourceCodeTheme &lt;SourceCodeTheme&gt; </body></comment><class><name>JSFileParserActor</name><environment>AppeX</environment><super>AppeX.JavascriptParserActor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classNameSourceStringsLookup currentGenericJavascriptClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-JSFile-Support</package></attributes></class><comment><class-id>AppeX.JSFileParserActor</class-id><body>Reads JavaScipt files from the file system and parses them to update (change) the sourcecode of corresponding javascript methods in AppeX/Instance Variables:	classNameSourceStringsLookup	&lt;Dictionary&gt;	key is a Smalltalk className, the sourceStrings are sourcecode defining named javascript functions which will be saved as the sourcecode for methods on the named class.	currentGenericJavascriptClass &lt;Class&gt; used for identifying which GenericJavascript class to attach "loose" code in the file to</body></comment><class><name>JavascriptPegCompiler</name><environment>AppeX</environment><super>AppeX.JavascriptCompiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>referenceFinder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeXTools</package></attributes></class><comment><class-id>AppeX.JavascriptPegCompiler</class-id><body>JavascriptPegCompiler is a replacement compiler that can be set as the compiler for JavascriptCode and its subclasses. It inherits the behavior of JavascriptCompiler but it has additional behavior. It uses a reference finder to annotate the methods compiled from Javascript code, allowing the IDE to find message senders and implementors.Instance Variables	referenceFinder	&lt;JavascriptReferenceFinder&gt;	description of referenceFinder</body></comment><class><name>GrammarReferenceFinder</name><environment>PEG2</environment><super>PEG2.ParserActor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sends </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>PEGParser</package></attributes></class><comment><class-id>PEG2.GrammarReferenceFinder</class-id><body>GrammarReferenceFinder is used to find the definition references from within a PEG grammar rule.Instance Variables	sends	&lt;Collection of: (Array)&gt;	references are described as arrays with the identifier being referenced and its start and stop position in the source stream.</body></comment><class><name>Parser</name><environment>PEG2</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>grammar stream actor buffer caches </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PEGParser</package></attributes></class><comment><class-id>PEG2.Parser</class-id><body>A general recursive-descent-parser that is built by sending messages to ParserParser.Instance Variables:	actor	&lt;ParserActor&gt;	holds an instance of a parsing actor during the parsing operation.	buffer	&lt;String&gt; holds a string during the parsing of literals.	caches	&lt;(Collection of: (Dictionary of: (Integer -&gt; Block)))&gt;	when caching is used, caches hold a collection of Dictionaries where keys are positions in the source stream and the values are blocks representing parsing expressions.	grammar	&lt;(Dictionary of: (String))&gt;	grammar is represented by a Dictionary with definition names as keys and the definitions as values.	stream	&lt;PositionableStream&gt;	the source stream that is to be parsedImplementationThe key method is the class method #bootstrap. Its body can be generated using ParserGenerator by evaluating the following code: 	GrammarGrammar parser		parse: 'Grammar'		stream: GrammarGrammar grammar		actor: PEG.ParserGenerator newIn the snippet above, 'Grammar' is the name of the top level expression. GrammarGrammar grammar returns a string describing the PEG grammar in terms of itself (it's recursive). This, to produce a working parser we have to have a working PEG grammar first.Once Parser class &gt;&gt; #bootstrap method is generated, it can be used to generate a grammar-specific parser (see GrammarClass class &gt;&gt; #parser). The parser knows how to interpret the expression definitions in the grammar instance methods. Because the subclasses of GrammarClass use GrammarParser when parsing their sources, each instance method selector represents an Identifier in the grammar.An important method in PEG.Parser is #parse:stream:actor:. A Parser grammar is populated by a subclass of GrammarClass from its method dictionary containing the rules for a given grammar. Once a parser knows its grammar, it can be given different kinds of actors to parser a source stream. The most important actors are ParserGenerator and ParserParser, as they are key to bootstrapping the entire PEG parsing mechanism.</body></comment><class><name>JavascriptVarMinifyingActor</name><environment>AppeX</environment><super>AppeX.JavascriptParserActor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>positionVarNameLookup positionPropertyNameLookup varNameMinStringLookup </inst-vars><class-inst-vars>classNameMinStringLookup </class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Minification</package></attributes></class><comment><class-id>AppeX.JavascriptVarMinifyingActor</class-id><body>The class compresses (obfuscates) Javascript code by renaming variables.Instance Variables	positionVarNameLookup			&lt;Dictionary&gt;	 	records positions of variables to be replaced	positionPropertyNameLookup		&lt;Dictionary&gt;	 	records positions of properties in order to not confuse them with variables	varNameMinStringLookup		&lt;Dictionary&gt;		records the shortened name to be used for substitution for each variable	Class Instance Variables	classNameMinStringLookup		&lt;Dictionary&gt;		records the shortened name to be used for substitution for each class name	</body></comment><class><name>ParserGenerator</name><environment>PEG2</environment><super>PEG2.ParserActor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PEGParser</package></attributes></class><comment><class-id>PEG2.ParserGenerator</class-id><body>ParserGenerator generates smalltalk code from a PEG definition that produces a parser.</body></comment><class><name>GrammarClass</name><environment>PEG2</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>grammarCache parserCache </class-inst-vars><imports></imports><category>My Classes</category><attributes><package>PEGParser</package></attributes></class><comment><class-id>PEG2.GrammarClass</class-id><body>GrammarClass an abstract class for PEG gramma classesInstance Variables	actor		&lt;Object&gt;	  actor	buffer	&lt;ByteArray&gt;	 buffer	source	&lt;ReadStream&gt;	  sourceClass Instance Variables	grammarCache &lt;&gt;	parserCache &lt;&gt;</body></comment><class><name>ParserParser</name><environment>PEG2</environment><super>PEG2.ParserActor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parser references useCache useCaseInsensitive </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PEGParser</package></attributes></class><comment><class-id>PEG2.ParserParser</class-id><body>ParserParser generates a dictionary of evaluatable blocks that parser a given PEG grammar.Instance Variables	parser	&lt;Parser&gt;	 parser	references	&lt;Dictionary&gt;	 references	useCache	&lt;Boolean&gt;	 useCacheClass Instance Variables	useCaseInsensitive &lt;Boolean&gt; </body></comment><class><name>JavascriptUserMessageActor</name><environment>AppeX</environment><super>PEG2.ParserActor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>document startStopLookup isCollectingArguments collectedArguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeXTools</package></attributes></class><comment><class-id>AppeX.JavascriptUserMessageActor</class-id><body>The class provides plugin for Javascript code highlighterInstance Variables	document	&lt;Text2.Document&gt;	 document	startStopLookup &lt;Dictionary&gt;	isCollectingArguments &lt;boolean&gt;	collectedArguments &lt;OrderedCollection&gt;</body></comment><class><name>GrammarGrammar</name><environment>PEG2</environment><super>PEG2.GrammarClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>PEGParser</package></attributes></class><comment><class-id>PEG2.GrammarGrammar</class-id><body>GrammarGrammar is a PEG description of the PEG grammar. There are no instance selectors in this class. The single class method #grammar returns a String describing the PEG grammar rules used to generate PEG parsers.</body></comment><class><name>JavascriptGrammar</name><environment>AppeX</environment><super>PEG2.GrammarClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>parserUseCache </class-inst-vars><imports></imports><category></category><attributes><package>AppeXTools</package></attributes></class><comment><class-id>AppeX.JavascriptGrammar</class-id><body>JavascriptGrammar is a PEG description of the Javascript language grammar. The selectors in JavascriptGrammar describe the language elements in terms of the Parsing Expression Grammar.Evaluate JavascriptGrammar grammar to see the JS grammar description.Useful Reference:http://www.ecma-international.org/ecma-262/5.1/Class Instance Variables	parserUseCache &lt;Boolean&gt; determines whether a parser instance should cache expressions once they have been parsed. It can speed up parsing considerably.</body></comment><class><name>JSFileComposer</name><environment>AppeX</environment><super>AppeX.JavascriptComposer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-JSFile-Support</package></attributes></class><comment><class-id>AppeX.JSFileComposer</class-id><body>JSFileComposer checks for  javascript (stored on the file system) to return in response to a resource request (typically by a web browser).If no javascript file  exists, then the superclass will compose javascript from the AppeX classes, and this composer will write the code to the file system for use by external tools, as well as returning the composed code to the requestor.</body></comment><shared-variable><name>Failure</name><environment>PEG2.Parser</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>Object new</initializer><attributes><package>PEGParser</package></attributes></shared-variable><shared-variable><name>Debugging</name><environment>AppeX.JavascriptParserActor</environment><private>false</private><constant>false</constant><category>debugging</category><initializer>false</initializer><attributes><package>AppeXTools</package></attributes></shared-variable><shared-variable><name>nodes</name><environment>AppeX.JavascriptParserActor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>AppeXTools</package></attributes></shared-variable><methods><class-id>AppeX.JSFileMonitor</class-id> <category>accessing</category><body package="AppeX-JSFile-Support">directory	^self class directory</body></methods><methods><class-id>AppeX.JSFileMonitor</class-id> <category>initialize-release</category><body package="AppeX-JSFile-Support">deleteJSFiles	|  jsFile |	"only use .js files, no subdirectories"	self directory ensureDirectory.	self directory directoryContents do: [:eString |		(jsFile := self directory / eString) extension ifNotNil: [ :ext |			ext = '.js' ifTrue: [ self class deleteJSFile: jsFile ]]].	timeLastChecked := Timestamp now.</body><body package="AppeX-JSFile-Support">startTimerEvery: anInterval parsingFiles: currentlyParsedFiles	(timer notNil and: [timer isActive]) ifTrue: [^nil].	timer := Timer every: anInterval do: [self checkJSFileUpdatesExcluding: currentlyParsedFiles]</body><body package="AppeX-JSFile-Support">stopTimer	timer ifNotNil: [ 		timer release.		timer := nil]</body></methods><methods><class-id>AppeX.JSFileMonitor</class-id> <category>updating</category><body package="AppeX-JSFile-Support">checkJSFileUpdatesExcluding: currentlyParsedFiles	"only use .js files, no subdirectories"	| jsFile  |	self directory ensureDirectory.	self directory directoryContents do: 			[:eString |			(jsFile := self directory / eString) extension				ifNotNil: 					[:ext |					ext = '.js'						ifTrue: [self updateFromJSFile: jsFile excluding: currentlyParsedFiles]]].	timeLastChecked := Timestamp now</body><body package="AppeX-JSFile-Support">updateFromJSFile: aFileName excluding: currentlyParsedFiles	"try to parse code from aFileName into the image.	answer the code parsed or nil"	"if the filename doesn't exist or has already been checked, or is being parsed, don't parse"	| codeFromFile |	aFileName exists ifFalse: [^nil].	(timeLastChecked isNil		or: [aFileName modificationTimestamp &gt; timeLastChecked]) ifFalse: [^nil].	(currentlyParsedFiles includes: aFileName) ifTrue: [^nil].	currentlyParsedFiles add: aFileName.	[codeFromFile := self class codeFromFile: aFileName.	JSFileParserActor parse: codeFromFile]		ensure: [currentlyParsedFiles remove: aFileName ifAbsent: [nil]].	^codeFromFile</body></methods><methods><class-id>AppeX.JSFileMonitor class</class-id> <category>accessing</category><body package="AppeX-JSFile-Support">autoDeleteScriptFiles	^autoDeleteScriptFiles</body><body package="AppeX-JSFile-Support">autoDeleteScriptFiles: aBoolean	autoDeleteScriptFiles := aBoolean</body><body package="AppeX-JSFile-Support">codeFromFile: aFileName	| aStream |	aStream := (aFileName asFilename reading encoding: #utf8)		setLineEndAuto;		closing: [].		^[aStream rest] ensure: [aStream close].</body><body package="AppeX-JSFile-Support">current	^current</body><body package="AppeX-JSFile-Support">current: anObject	current := anObject</body><body package="AppeX-JSFile-Support">directory	^Application scriptDirectory</body><body package="AppeX-JSFile-Support">frequency	^frequency ifNil: [ frequency := self defaultFrequency ]</body><body package="AppeX-JSFile-Support">frequency: anInterval	frequency := anInterval</body></methods><methods><class-id>AppeX.JSFileMonitor class</class-id> <category>defaults</category><body package="AppeX-JSFile-Support">defaultAutoDeleteScriptFiles	^true</body><body package="AppeX-JSFile-Support">defaultFrequency	^5 seconds</body></methods><methods><class-id>AppeX.JSFileMonitor class</class-id> <category>instance creation</category><body package="AppeX-JSFile-Support">start	self stop.	current := self new.	current startTimerEvery: self frequency parsingFiles: Set new.	^current</body><body package="AppeX-JSFile-Support">stop	JSFileParserActor initializeActions.	current ifNotNil: [		current stopTimer.		current deleteJSFiles.		current := nil ]</body></methods><methods><class-id>AppeX.JSFileMonitor class</class-id> <category>initialize-release</category><body package="AppeX-JSFile-Support">deleteFileForLibrary: aLibrary	| aJavascriptFile |	(aJavascriptFile := self directory /aLibrary name)			exists ifTrue: [ self deleteJSFile: aJavascriptFile  ]</body><body package="AppeX-JSFile-Support">deleteJSFile: aFileName		aFileName exists ifTrue: [aFileName delete].</body></methods><methods><class-id>PEG2.ParserActor</class-id> <category>initialize-release</category><body package="PEGParser">initialize	super initialize.	self initializeActions</body><body package="PEGParser">initializeActions	actions := self class actions</body><body package="PEGParser">process: name object: object start: aStart stop: aStop	| action |	action := actions at: name ifAbsent: [^object].	start := aStart. stop := aStop.	^action value: self value: object</body></methods><methods><class-id>PEG2.ParserActor class</class-id> <category>instance creation</category><body package="PEGParser">new	^super new initialize</body></methods><methods><class-id>PEG2.ParserActor class</class-id> <category>compiling</category><body package="PEGParser">instanceMethodsChanged	self initializeActions</body></methods><methods><class-id>PEG2.ParserActor class</class-id> <category>class initialization</category><body package="PEGParser">actions	^ actions ifNil: [ self initializeActions ]</body><body package="PEGParser">initializeActions	actions := Dictionary new.	(Pragma allNamed: #action:arguments: in: self)		do: [:pragma | actions at: pragma arguments first put: [: instance :object |			| arguments |			arguments := (pragma arguments at: 2) collect: [:i | i &lt;= object size ifTrue: [object at: i] ifFalse: [nil]].			instance perform: pragma selector withArguments: arguments]].	(Pragma allNamed: #action: in: self)		do: [:pragma | actions at: pragma arguments first put: [ :instance :object |			instance perform: pragma selector with: object]].		^ actions</body></methods><methods><class-id>AppeX.JavascriptReferenceFinder</class-id> <category>initialize-release</category><body package="AppeXTools">initialize	super initialize.	sends := Set new.</body></methods><methods><class-id>AppeX.JavascriptReferenceFinder</class-id> <category>accessing</category><body package="AppeXTools">sends	^sends</body><body package="AppeXTools">targetClass	^targetClass</body><body package="AppeXTools">targetClass: aClass	targetClass := aClass</body></methods><methods><class-id>PEG2.GrammarParser</class-id> <category>public access</category><body package="PEGParser">parse: sourceStream class: class environment: env noPattern: noPattern context: ctxt notifying: req builder: aBuilder saveComments: savec ifFail: aBlock	"Validate the stream"	| selector stream methodNode actor |	actor := GrammarReferenceFinder new.	(GrammarGrammar parser parse: 'Grammar' stream: sourceStream actor: actor)		ifNil: 			[Transcript				cr;				nextPutAll: sourceStream contents.			^aBlock value].	selector := self parseSelector: sourceStream contents.	stream := String new writeStream.	stream		nextPutAll: 'unnamed ^';		print: sourceStream contents.	methodNode := super				parse: stream contents readStream				class: class				environment: env				noPattern: noPattern				context: ctxt				notifying: req				builder: aBuilder				saveComments: savec				ifFail: aBlock.	methodNode		selector: selector		primitive: nil		errorCode: nil		block: methodNode block.	actor sends		do: [:each | methodNode addAttributeMessage: (Message selector: each first)].	^methodNode</body><body package="PEGParser">parseSelector: aString	| stream |	stream := aString readStream.	GrammarGrammar parser parse: 'Identifier' stream: stream actor: nil.	prevEnd := stream position.	^(aString copyFrom: 1 to: stream position) asSymbol</body><body package="PEGParser">reference: aString at: index	| actor |	actor := GrammarReferenceFinder new.	GrammarGrammar parser parse: 'Grammar' stream: aString actor: actor.	^(actor sends		detect: [:each | (each at: 2) &lt;= index and: [(each at: 3) &gt;= index]]		ifNone: [^nil]) first</body></methods><methods><class-id>PEG2.GrammarParser class</class-id> <category>accessing</category><body package="PEGParser">descriptionOfMethods	^'grammar definitions'</body><body package="PEGParser">methodTemplateFor: aProtocol	^'	&lt;-	Reference*'</body><body package="PEGParser">selectorTemplateFor: aProtocol	^#( 'Definition' )</body></methods><methods><class-id>PEG2.GrammarParser class</class-id> <category>protocol templates</category><body package="PEGParser">defaultSelectorTemplate	^#( 'Definition' )</body></methods><methods><class-id>AppeX.JavascriptMinifyingWriter</class-id> <category>writing</category><body package="AppeX-Minification">contents	^contents ifNil: [ stream contents]</body></methods><methods><class-id>AppeX.JavascriptMinifyingWriter</class-id> <category>initialize-release</category><body package="AppeX-Minification">writeJavascriptWith: aJavascriptClass	| namespaces |	namespaces := Set with: 'Smalltalk'.	aJavascriptClass writeJsNamespaces: namespaces with: self.	aJavascriptClass writeJsCodeWith: self.	contents := AppeX.JavascriptMinifyingActor new 		parse: self contents;		minifyStatementList</body></methods><methods><class-id>AppeX.JavascriptMinifyingWriter</class-id> <category>accessing</category><body package="AppeX-Minification">javascriptNameForClass: aJavascriptClass	self class isMinifyingVars ifFalse: [^super javascriptNameForClass: aJavascriptClass].	^ JavascriptVarMinifyingActor minStringForClassName: aJavascriptClass javascriptName</body><body package="AppeX-Minification">sourceForJsFunction: aSelector inClass: aJavascriptClass"	Answer the source code for a function defined by aSelector in aJavascriptClass.	I am a minifying writer, need to minify the original source."	| source |	source := super sourceForJsFunction: aSelector inClass: aJavascriptClass.	source isNil ifTrue: [^nil].	self class isMinifyingVars ifFalse: [^source].	^JavascriptVarMinifyingActor new		minifyVarsInSource: source.</body></methods><methods><class-id>AppeX.JavascriptMinifyingWriter</class-id> <category>js generating</category><body package="AppeX-Minification">writeJsFunctionsWith: aClass	(self class isMinifyingVars and: [aClass  canMinifyFunctionName]) ifTrue: [		self write: ((JavascriptVarMinifyingActor minStringForClassName: aClass javascriptName),  '=', aClass javascriptName, ';')].	super writeJsFunctionsWith: aClass.</body><body package="AppeX-Minification">writeLooseJsFunctionsWith: aClass	(self class isMinifyingVars and: [aClass  canMinifyFunctionName]) ifTrue: [		self write: ((JavascriptVarMinifyingActor minStringForClassName: aClass javascriptName),  '=', aClass javascriptName, ';')].	super writeLooseJsFunctionsWith: aClass.</body></methods><methods><class-id>AppeX.JavascriptMinifyingWriter class</class-id> <category>instance creation</category><body package="AppeX-Minification">defaultIsMinifyingVars	^true</body><body package="AppeX-Minification">isMinifyingVars	^isMinifyingVars ifNil: [isMinifyingVars :=  self defaultIsMinifyingVars]</body><body package="AppeX-Minification">isMinifyingVars: aBoolean	isMinifyingVars := aBoolean</body></methods><methods><class-id>AppeX.JavascriptParser</class-id> <category>parsing</category><body package="AppeXTools">argumentNames	^#()</body><body package="AppeXTools">arguments	^ #()</body><body package="AppeXTools">newSource		^self sourceCode</body><body package="AppeXTools">parse: definition stream: aStream actor: anActor	JavascriptGrammar parser parse: definition stream: aStream actor: anActor</body></methods><methods><class-id>AppeX.JavascriptParser</class-id> <category>accessing</category><body package="AppeXTools">selector	^selector</body><body package="AppeXTools">selector: aSymbol	selector := aSymbol</body><body package="AppeXTools">sourceCode	^sourceCode</body><body package="AppeXTools">sourceCode: aString	sourceCode := aString</body></methods><methods><class-id>AppeX.JavascriptParser</class-id> <category>renaming</category><body package="AppeXTools">modifySourceWithOldSelector: oldSelector newSelector: newSelector andArguments: arguments isRenamingMethod: aBoolean	| renameActor aDocument aDictionary newStream oldStream |	aDocument := Text2.Document fromString: self sourceCode asString.	renameActor := JavascriptMethodRenameActor new.	renameActor document: aDocument.	renameActor oldSelector: oldSelector. 	renameActor newSelector: newSelector. 	renameActor arguments: arguments.	renameActor isRenamingMethod: aBoolean.	renameActor startStopLookup: Dictionary new.	JavascriptGrammar parser		parse: 'FunctionSignatureBody'		stream: aDocument readStream		actor: renameActor.		aDictionary:=  renameActor startStopLookup.	newStream := ReadWriteStream on: String new.	oldStream := aDocument readStream.	[oldStream atEnd] whileFalse: [ | startingReplace |		startingReplace := aDictionary at: oldStream position ifAbsent: [nil].		startingReplace notNil ifTrue: [			newStream nextPutAll: newSelector.			oldStream position: oldStream position + oldSelector size.		].		newStream nextPut: oldStream next.	].	self sourceCode: newStream contents.</body><body package="AppeXTools">renameMessageSends: oldSelector newSelector: newSelector andArguments: arguments	self modifySourceWithOldSelector: oldSelector newSelector:newSelector andArguments: arguments isRenamingMethod: false</body><body package="AppeXTools">renameSelector: newSelector andArguments: arguments	self modifySourceWithOldSelector: self selector newSelector:newSelector andArguments: arguments isRenamingMethod: true</body></methods><methods><class-id>AppeX.JavascriptParser</class-id> <category>user messages</category><body package="AppeXTools"> generateUserMessageCatalogs	| aDocument userMessageActor |	aDocument := Text2.Document fromString: self sourceCode asString.	userMessageActor := JavascriptUserMessageActor new.	userMessageActor document: aDocument.	userMessageActor startStopLookup: Dictionary new.	userMessageActor isCollectingArguments: false.	userMessageActor collectedArguments: OrderedCollection new.	JavascriptGrammar parser		parse: 'FunctionSignatureBody'		stream: aDocument readStream		actor: userMessageActor.		^userMessageActor startStopLookup reject: [:e | e isEmpty]</body></methods><methods><class-id>AppeX.JavascriptParser</class-id> <category>RefactoringBrowser compatibility</category><body package="AppeXTools">acceptVisitor: aNode 		^nil</body><body package="AppeXTools">format: parseTree		^parseTree sourceCode string</body><body package="AppeXTools">formatterClass		^self class</body></methods><methods><class-id>AppeX.JavascriptParser</class-id> <category>compatibility</category><body package="AppeXTools">isLiteralNode	"called by code critic"	^false</body><body package="AppeXTools">isMessage	"called by code critic"	^false</body><body package="AppeXTools">isPrimitive	"called by code critic"	^false</body><body package="AppeXTools">lastIsReturn	"called by code critic"	^false</body><body package="AppeXTools">returnsBooleanAndOther	"called by code critic"	^false</body></methods><methods><class-id>AppeX.JavascriptParser class</class-id> <category>parsing</category><body package="AppeXTools">parseExpressionWithErrors: aStream	^ self new</body><body package="AppeXTools">parseMethodWithErrors: aString		^ self new sourceCode: aString</body></methods><methods><class-id>AppeX.JavascriptParser class</class-id> <category>accessing</category><body package="AppeXTools">parseMethod: aString onError: aBlock 	"This is called by refactoring methods.	 Keep existing behavior for now:	 Until this parser constructs a parseTree, this method must answer nil."		^nil</body></methods><methods><class-id>AppeX.JavascriptParser class</class-id> <category>compiling</category><body package="AppeXTools">parseExpression: aString onError: aBlock	"compatibility"		^Refactory.Browser.RBParser parseExpression: aString onError: aBlock</body></methods><methods><class-id>AppeX.JavascriptMinifyingActor</class-id> <category>processing</category><body package="AppeX-Minification">recordCommentPosition	(start between: 0 and: source size) ifFalse: [^self].	(stop between: 0 and: source size) ifFalse: [^self].	start &gt;= stop ifTrue: [^self].	self startStopLookupComments at: start put: stop.</body><body package="AppeX-Minification">recordStringLiteralPosition	(start between: 0 and: source size) ifFalse: [^self].	(stop between: 0 and: source size) ifFalse: [^self].	start &gt;= stop ifTrue: [^self].	self startStopLookupStringLiterals at: start put: stop.</body></methods><methods><class-id>AppeX.JavascriptMinifyingActor</class-id> <category>testing</category><body package="AppeX-Minification">isGroupA: aCharacter	"answer a boolean indicating if the character is	a non-ASCII character or by an ASCII letter or digit,	or one of these characters: GROUP A \ $ _  "		aCharacter isNil ifTrue: [^false].	^(self isGroupAA: aCharacter  "Non-Ascii, ascii character, or digit") or: ['\$_' includes: aCharacter ]</body><body package="AppeX-Minification">isGroupAA: aCharacter	"answer a boolean indicating if the character is	a non-ASCII character or by an ASCII letter or digit"		aCharacter isNil ifTrue: [^false].	^(aCharacter asInteger between: 128 and: 255 "Non-Ascii") or: [aCharacter isAlphaNumeric].</body><body package="AppeX-Minification">isGroupB: aCharacter	"answer a boolean indicating if the character is	a non-ASCII character or  an ASCII letter or digit,	or one of these characters: GROUP B \ $ _ { [ ( + - "		| anInteger  |		aCharacter isNil ifTrue:[^false].	anInteger := aCharacter asInteger.	(self isGroupAA: aCharacter) ifTrue: [^true]. "Non-Ascii, ascii character, or digit"	(#(92 36 95 123 91 40 43 45) includes:anInteger) ifTrue: [^true].	^false</body><body package="AppeX-Minification">isGroupC: aCharacter	"answer a boolean indicating if the character is	a non-ASCII character or  an ASCII letter or digit,	or one of these characters: GROUP C \ $ _ } ] ) + -  ' and doublequote"		| anInteger  |		aCharacter isNil ifTrue: [^false].	anInteger := aCharacter asInteger.	(self isGroupAA: aCharacter) ifTrue: [^true]. "Non-Ascii, ascii character, or digit"	(#(92 36 95 125 93 41 43 45) includes: anInteger) ifTrue: [^true].	^false</body></methods><methods><class-id>AppeX.JavascriptMinifyingActor</class-id> <category>accessing</category><body package="AppeX-Minification">codeStream	^codeStream</body><body package="AppeX-Minification">codeStream: anObject	codeStream := anObject</body><body package="AppeX-Minification">startStopLookupComments	^startStopLookupComments</body><body package="AppeX-Minification">startStopLookupComments: aDictionary	startStopLookupComments := aDictionary</body><body package="AppeX-Minification">startStopLookupStringLiterals	^startStopLookupStringLiterals</body><body package="AppeX-Minification">startStopLookupStringLiterals: anObject	startStopLookupStringLiterals := anObject</body></methods><methods><class-id>AppeX.JavascriptMinifyingActor</class-id> <category>minify - private</category><body package="AppeX-Minification">getNextCharWriteOn: writeStream	(startStopLookupStringLiterals at: codeStream position ifAbsent: [nil]) ifNotNil: [ :literalEnd|		writeStream write: (codeStream read: literalEnd - codeStream position)].	^codeStream next</body><body package="AppeX-Minification">minifyDo: aBlock	|  codeStreamMinified thisChar |	codeStreamMinified := String new writing.	[ 		[thisChar := self getNextCharWriteOn: codeStreamMinified.		aBlock value: 	codeStreamMinified value: thisChar		] repeat		] on: Xtreams.Incomplete		do: [ :ex | ].			^codeStreamMinified contents</body><body package="AppeX-Minification">removeLfsInStatementList	"return a new Document"	"Intermediate steps in minification will insert linefeeds in place of other characters.	Conditionally remove them here."	| previousChar |	previousChar := nil.	^self minifyDo: [ :wstream :thisChar |		(thisChar = Character lf 			and: [(self isGroupB: codeStream peek) not 				or: [	(self isGroupC: previousChar) not]])			ifFalse: [wstream put: thisChar ].			previousChar := thisChar ]</body><body package="AppeX-Minification">removeSpaceAndLfRunsInStatementList"Be  conservative in omitting linefeeds, because linefeeds are sometimes treated as semicolons. A linefeed is not omitted if it precedes a non-ASCII character or an ASCII letter or digit or one of these characters:\ $ _ { [ ( + -and if it follows a non-ASCII character or an ASCII letter or digit or one of these characters:\ $ _ } ] ) + - single quotes  double quotes"	| nextChar thisIsSpace nextIsSpace thisIsLF nextIsLF doubleSpace doubleLf |	^self minifyDo: [ :wstream :thisChar |		[nextChar := codeStream peek] on: Xtreams.Incomplete do: [ :ex | ].		thisIsSpace := thisChar = Character space.		nextIsSpace := nextChar = Character space.		thisIsLF := thisChar = Character lf.		nextIsLF := nextChar = Character lf.		doubleSpace := thisIsSpace and: [nextIsSpace].		doubleLf := thisIsLF and: [nextIsLF].		(doubleSpace or: [doubleLf])						ifFalse: [wstream write: thisChar ].	 ]</body><body package="AppeX-Minification">removeSpacesInStatementList"All runs of spaces are replaced with a single space.It omits spaces except when a space is preceded and followed by a non-ASCII character or by an ASCII letter or digit, or by one of these characters:\ $ _"	|  previousChar |	previousChar := nil.	^self minifyDo: [ :wstream :thisChar |		(thisChar = Character space 			and: [(self isGroupA: previousChar) not 				or: [	(self isGroupA: codeStream peek) not]])			ifFalse: [wstream put: thisChar ].			previousChar := thisChar.]</body><body package="AppeX-Minification">replaceCRsAndSpecialCharactersInStatementList"Replace carriage returns (cr) with linefeeds (lf). Replace all other control characters (including tab) with spaces. "	^self minifyDo: [ :wstream :thisChar |		(thisChar = Character cr or: [thisChar = Character lf]) 			ifTrue: [wstream lf]			ifFalse: [thisChar asInteger &lt;= 30 						ifTrue: [wstream space]						ifFalse: [wstream write: thisChar]]]</body><body package="AppeX-Minification">replaceCommentsWithLfOrSpaceInStatementList	" It replaces comments in the // form with linefeeds. It replaces comments in the /* */ form with spaces."	|   codeStreamMinified |	codeStreamMinified := String new writing.	[	[		(startStopLookupComments at: codeStream position ifAbsent: [nil]) 			ifNotNil: [ :commentEnd| 				(codeStream read: 2) = '/*'					ifTrue: [codeStreamMinified put: Character space]					ifFalse: [codeStreamMinified put: Character lf].						codeStream position: commentEnd]			ifNil: [codeStreamMinified put: codeStream next].				] repeat		] on: Xtreams.Incomplete		do: [ :ex | ].	^codeStreamMinified contents</body></methods><methods><class-id>AppeX.JavascriptMinifyingActor</class-id> <category>initialize-release</category><body package="AppeX-Minification">process: name object: object start: startPosition stop: stopPosition"	startPosition and stopPosition come from a Stream. When we are getting the span from a String,	we need to copy it from an index one higher than the startPosition."	| action span |	action := actions at: name ifAbsent: [^object].	start := startPosition. 	stop := stopPosition.	span := source copyFrom: (start + 1) to: stop.	action value: self value: span.	^span</body></methods><methods><class-id>AppeX.JavascriptMinifyingActor</class-id> <category>minify - api</category><body package="AppeX-Minification">minifyStatementList"adapted from  the example on http://www.crockford.com/javascript/jsmin.html  JSMin The JavaScript Minifier Douglas Crockford 2003-12-04	reference used:	 http://www.kerryr.net/pioneers/ascii3.htm,	 http://www.kerryr.net/pioneers/ascii2.htm"	"return a minified source"		self parse: self replaceCRsAndSpecialCharactersInStatementList.	self parse: self replaceCommentsWithLfOrSpaceInStatementList.	self parse: self removeSpaceAndLfRunsInStatementList.	self parse: self removeLfsInStatementList.	^self removeSpacesInStatementList.</body><body package="AppeX-Minification">parse: aString	source := aString.	self startStopLookupComments: Dictionary new.	self startStopLookupStringLiterals: Dictionary new.	"parse document and record string literal and comment positions"	JavascriptGrammar parser		parse: 'StatementList'		stream: source readStream		actor: self.			self codeStream: source  reading.</body></methods><methods><class-id>AppeX.JavascriptMinifyingActor class</class-id> <category>compiling</category><body package="AppeX-Minification">instanceMethodsChanged	super initializeActions.	JavascriptGrammar resetCaches</body></methods><methods><class-id>AppeX.JavascriptMethodRenameActor</class-id> <category>accessing</category><body package="AppeXTools">arguments	^arguments</body><body package="AppeXTools">arguments: aCollection	arguments := aCollection</body><body package="AppeXTools">document	^document</body><body package="AppeXTools">document: aDocument	document := aDocument</body><body package="AppeXTools">isRenamingMethod	^isRenamingMethod</body><body package="AppeXTools">isRenamingMethod: aBoolean	isRenamingMethod := aBoolean</body><body package="AppeXTools">newSelector	^newSelector</body><body package="AppeXTools">newSelector: aSymbol	newSelector := aSymbol</body><body package="AppeXTools">oldSelector	^oldSelector</body><body package="AppeXTools">oldSelector: aSymbol	oldSelector := aSymbol</body><body package="AppeXTools">startStopLookup	^startStopLookup</body><body package="AppeXTools">startStopLookup: aDictionary	startStopLookup := aDictionary</body></methods><methods><class-id>AppeX.JavascriptMethodRenameActor</class-id> <category>initialize-release</category><body package="AppeXTools">process: name object: object start: aStart stop: aStop	| action span |	action := actions at: name ifAbsent: [^object].	start := aStart. 	stop := aStop.	span := document copyBetween: start and: stop.	action value: self value: span.	^span</body></methods><methods><class-id>AppeX.JavascriptMethodRenameActor</class-id> <category>actions - rename</category><body package="AppeXTools">replaceOldSelectorWithNewSelector	(start between: 0 and: document size) ifFalse: [^self].	(stop between: 0 and: document size) ifFalse: [^self].	start &gt;= stop ifTrue: [^self].	self startStopLookup at: start put: stop.</body></methods><methods><class-id>AppeX.JavascriptMethodRenameActor</class-id> <category>testing</category><body package="AppeXTools">isRenamingMessageSends^self isRenamingMethod not</body></methods><methods><class-id>AppeX.JavascriptMethodRenameActor class</class-id> <category>compiling</category><body package="AppeXTools">instanceMethodsChanged	super initializeActions.	JavascriptGrammar resetCaches</body></methods><methods><class-id>AppeX.JavascriptParserActor</class-id> <category>actions</category><body package="AppeXTools">isNotFinishedParsingIdentifier	"There could be an identifier that begins with a 'false' keyword, e.g. 'doThisINotADoKeyword', or 'while_ThisIsNotReallyAKeywordEither'"		| nextChar |		document size &gt;=  (stop + 1) ifFalse: [^false].	nextChar :=  document at: stop + 1.	"check to see if we're in the middle of parsing an identifier"	^nextChar notNil and: [nextChar isAlphaNumeric or: [nextChar = $_]]</body></methods><methods><class-id>AppeX.JavascriptParserActor</class-id> <category>debugging</category><body package="AppeXTools">debug: name with: span"	A temporary method to be used for debugging of highlighting.	To turn debugging on/off, evaluate one of the following:		self debugging: true.		self debugging: false.	To be removed when it's all sorted out."	self class debugging ifFalse: [ ^ self ].		Transcript cr;		nextPutAll: (start to: stop) printString;		nextPut: $: ;		tab;		nextPutAll: name;		nextPutAll: ': ' ;		nextPutAll: span asString.</body></methods><methods><class-id>AppeX.JavascriptParserActor</class-id> <category>private</category><body package="AppeXTools">apply: aStyle 	| themeStyle |	theme == nil ifTrue: [^self].	(start between: 0 and: document size) ifFalse: [^self].	(stop between: 0 and: document size) ifFalse: [^self].	start &gt;= stop ifTrue: [^self].	themeStyle := theme match: aStyle ifAbsent: [^self].	document replaceBetween: start + decoratingOffset and: stop + decoratingOffset apply: [:style | themeStyle]</body><body package="AppeXTools">currentParameters	^ self currentScope at: #parameters ifAbsentPut: [ Set new ]</body><body package="AppeXTools">currentScope	^ scope last</body><body package="AppeXTools">currentScopeType	^ self currentScope at: #type ifAbsent: [ nil ]</body><body package="AppeXTools">currentVariables	^ self currentScope at: #variables ifAbsentPut: [ Set new ]</body><body package="AppeXTools">popScope	scope removeLast</body><body package="AppeXTools">pushScope: type	| new |	new := Dictionary new: self currentScope size.	self currentScope keysAndValuesDo: [ :key :value | new at: key put: value copy ].	new at: #type put: type.	scope add: new</body><body package="AppeXTools">recordNode: anObject	nodes at: (start to: stop) put: anObject.</body></methods><methods><class-id>AppeX.JavascriptParserActor</class-id> <category>services</category><body package="AppeXTools">decorate: aParser	| stream |	stream := document readStream.	aParser 		parse: 'FunctionSignatureBody' 		stream: stream 		actor: self</body></methods><methods><class-id>AppeX.JavascriptParserActor</class-id> <category>initialize-release</category><body package="AppeXTools">initialize: aDocument targetClass: aClass theme: aSourceCodeTheme offset: aDecoratingOffset reason: aReason	super initialize.	nodes := Dictionary new.	document := aDocument.	theme := aSourceCodeTheme.	decoratingOffset := aDecoratingOffset.	scope := OrderedCollection with: Dictionary new.</body><body package="AppeXTools">process: name object: object start: aStart stop: aStop	| action span |	"start := aStart. 	stop := aStop.	span := document copyBetween: aStart and: aStop.	self debug: name with: span."			action := actions at: name ifAbsent: [^object].	nodes at: (aStart to: aStop) ifPresent: [ :existing | ^existing].	start := aStart. 	stop := aStop.	span := document copyBetween: start and: stop.	self debug: name with: span.	action value: self value: span.	^ span</body></methods><methods><class-id>AppeX.JavascriptParserActor</class-id> <category>actions - errors</category><body package="AppeXTools">applyInvalidJavascriptError	self apply: #(#invalid #error #javascript)</body></methods><methods><class-id>AppeX.JavascriptParserActor class</class-id> <category>compiling</category><body package="AppeXTools">instanceMethodsChanged	super initializeActions.	JavascriptGrammar resetCaches</body></methods><methods><class-id>AppeX.JavascriptParserActor class</class-id> <category>instance creation</category><body package="AppeXTools">decorate: aDocument parseTree: aParseTree editor: aSourceCodeEditor offset: decoratingOffset reason: aReason"aParseTree argument can be - Javascript parser- RBMessageNode RBMessageNode is created as result of parsing Smalltalk Class DefinitionJavascript parser will parse the JS instance methods"	(aParseTree isKindOf:  Refactory.Browser.RBMessageNode) ifTrue: 		[^Refactory.Browser.SyntaxHighlightDecoration decorate: aDocument parseTree: aParseTree editor: aSourceCodeEditor offset: decoratingOffset reason: aReason].	^(self new initialize: aDocument targetClass: aSourceCodeEditor doItReceiverClass theme: aSourceCodeEditor theme offset: decoratingOffset reason: aReason)		decorate: aParseTree;		yourself</body></methods><methods><class-id>AppeX.JavascriptParserActor class</class-id> <category>debugging</category><body package="AppeXTools">debugging	^ Debugging</body><body package="AppeXTools">debugging: aBoolean"	self debugging: true.	self debugging: false."	Debugging := aBoolean</body></methods><methods><class-id>AppeX.JavascriptParserActor class</class-id> <category>testing</category><body package="AppeXTools">isForWorkspace	^ false</body></methods><methods><class-id>AppeX.JavascriptParserActor class</class-id> <category>accessing</category><body package="AppeXTools">defaultJavascriptSourceCodeTheme	^(Refactory.Browser.SourceCodeTheme defaultChrome)		source: (MessageSend receiver: Refactory.Browser.SourceCodeTheme selector: #defaultChrome).</body><body package="AppeXTools">defaultUseJavascriptSourceCodeTheme	^true</body><body package="AppeXTools">javascriptSourceCodeTheme	javascriptSourceCodeTheme ifNil: [self javascriptSourceCodeTheme: self defaultJavascriptSourceCodeTheme].	^javascriptSourceCodeTheme</body><body package="AppeXTools">javascriptSourceCodeTheme: anObject	javascriptSourceCodeTheme := anObject.	Refactory.Browser.SourceCodeEditor updateAllInstances</body><body package="AppeXTools">javascriptSourceCodeThemeKey	"Return the unique selector the default theme."	^self javascriptSourceCodeTheme source selector</body><body package="AppeXTools">javascriptSourceCodeThemeKey: aThemeKey	"Set the default theme by using the themes unique selector."	self javascriptSourceCodeTheme: ((Refactory.Browser.SourceCodeTheme perform: aThemeKey)		source: (MessageSend receiver: Refactory.Browser.SourceCodeTheme selector: aThemeKey);		yourself)</body><body package="AppeXTools">useJavascriptSourceCodeTheme	useJavascriptSourceCodeTheme ifNil: [self useJavascriptSourceCodeTheme: self defaultUseJavascriptSourceCodeTheme].	^useJavascriptSourceCodeTheme</body><body package="AppeXTools">useJavascriptSourceCodeTheme: aBoolean	useJavascriptSourceCodeTheme := aBoolean.	Refactory.Browser.SourceCodeEditor updateAllInstances</body></methods><methods><class-id>AppeX.JavascriptParserActor class</class-id> <category>calculated</category><body package="AppeXTools">sourceCodeThemeForEditor: aSourceCodeEditor	self useJavascriptSourceCodeTheme ifFalse: [^aSourceCodeEditor class defaultTheme].	^self javascriptSourceCodeTheme</body></methods><methods><class-id>AppeX.JSFileParserActor</class-id> <category>private</category><body package="AppeX-JSFile-Support">checkToAddSource	| methodSource aDocument aCollection isAssigningConstructorFunction|		self currentClass isNil ifTrue: [^self].	"isAssigningConstructorFunction e.g. AppeX.ServerClosure = function ServerClosure() {};"	isAssigningConstructorFunction := self currentClass name asString = self currentMethodName.	"We do not use assignment expressions to map functions back into Smalltalk methods on the equivalent to the constructor functions, e.g Smalltalk classes.  I.e. methods that are attached to Constructor functions using assignment expressions do NOT map back to Smalltalk methods.  (E.G.  the debug and replace functions assigned to the Javascript constructor from within the initialize method do not map back to methods in Smalltalk"	(self isAssignmentExpression and: [ isAssigningConstructorFunction not]) ifTrue: [^self].			"If the method is the Constructor function, then according to AppeX conventions anything inside the function is the initialize method."	isAssigningConstructorFunction ifTrue: [ | methodName |			methodName := 'initialize'.			methodSource := self currentClass sourceForJsFunction: methodName asSymbol.			"+ 10 to skip over ' function ', -3 to back up over Character tab, Character cr , };"			aDocument := document copyFrom: start + 10 to: stop - 3.			"replace the constructor name with 'initialize'"			aDocument				replaceBetween: 0				and: (aDocument nextWordBreakAfter: 0)				with: methodName.			"add  the AppeX ending for a method source"			aDocument insert: (String with: Character cr with: $}).			"skip an empty constructor "			(aDocument size &lt;= (methodName size + 4) and: [methodSource = nil]) ifTrue: [^self]]		ifFalse: 			[methodSource := self currentClass sourceForJsFunction: self currentMethodName asSymbol.			"+ 10 to skip over ' function ' "			aDocument := document copyFrom: start + 10 to: stop.].	aDocument string = methodSource		ifFalse: [			aCollection := self classNameSourceStringsLookup at: self currentClassName ifAbsentPut: [OrderedCollection new].			aCollection add: aDocument string.		].</body><body package="AppeX-JSFile-Support">classNameForAssignmentForAlias: classNameOrAlias	| className |		className := classNameOrAlias.	(2 to: self currentIdentifiers size - 1) do: [:idx |		className := className, '.', (self currentIdentifiers at: idx)			].	^className</body><body package="AppeX-JSFile-Support">classNameForBindForAlias: classNameOrAlias	| className |		className := classNameOrAlias.	(2 to: self currentIdentifiers size - 2) do: [:idx |		className := className, '.', (self currentIdentifiers at: idx)			].	^className</body><body package="AppeX-JSFile-Support">classNameForDefineForAlias: classNameOrAlias	| className |		className := classNameOrAlias.	(4 to: self currentIdentifiers size - 3) do: [:idx |		className := className, '.', (self currentIdentifiers at: idx)			].	^className</body><body package="AppeX-JSFile-Support">classNameFromAlias: aClassNameOrAlias	aClassNameOrAlias = 'Object' ifTrue: [^'AppeX.JavascriptObject'].		aClassNameOrAlias = 'Function' ifTrue: [^'AppeX.JavascriptFunction'].	aClassNameOrAlias = 'Array' ifTrue: [^'AppeX.JavascriptArray'].		aClassNameOrAlias = '$t' ifTrue: [^'Smalltalk.JavascriptNamespace'].		^nil</body><body package="AppeX-JSFile-Support">currentClass	| aClass aReference |		aReference := self currentClassName asSymbol asQualifiedReference.	aReference bindingOrNil isNil ifTrue:[		"currentClassName is probably the Javascript name corresponding to a built-in AppeX JavascriptObject subclass.  (e.g. Function corresponds to AppeX.JavascriptFunction).		Do not enable modification of this code from the filesystem in this version of the system. "		^nil].		aClass := self currentClassName asSymbol asQualifiedReference value.	^aClass</body><body package="AppeX-JSFile-Support">currentClassName	"Answer the current class name based on current identifiers."	| className |	className := self classNameFromAlias: self currentClassNameOrAlias.	className notNil ifTrue: [^className].	self isAssignmentExpression ifTrue: 		[^self classNameForAssignmentForAlias: self currentClassNameOrAlias].	self isBindExpression ifTrue: 		[^self classNameForBindForAlias: self currentClassNameOrAlias].	self isDefineExpression ifTrue: 		[^self classNameForDefineForAlias: self currentClassNameOrAlias].	"shouldn't get here."	^className</body><body package="AppeX-JSFile-Support">currentClassNameOrAlias	| classNameOrAlias |	self isAssignmentExpression | self isBindExpression		ifTrue: [classNameOrAlias := self currentIdentifiers first string].	self isDefineExpression		ifTrue: [classNameOrAlias := self currentIdentifiers at: 3].	^classNameOrAlias</body><body package="AppeX-JSFile-Support">currentIdentifierName		| numIdentifiers identifiers |	identifiers := self currentIdentifiers.	numIdentifiers := identifiers size.		(numIdentifiers &lt; 2) ifTrue: [^nil].	^(identifiers at: numIdentifiers - 1) string.</body><body package="AppeX-JSFile-Support">currentIdentifiers	^ self currentScope at: #identifiers ifAbsentPut: [ OrderedCollection new ]</body><body package="AppeX-JSFile-Support">currentMethodName	| methodName |	methodName := self currentIdentifiers last string.	^methodName</body><body package="AppeX-JSFile-Support">isAssignmentExpression	"answer a boolean indicating if we are assigning a funtion to property of an Object.  This could be assignment of a constructor function to property of the window (global)."	^self currentMethodName notNil				and: [self currentMethodName = self currentIdentifierName].</body><body package="AppeX-JSFile-Support">isBindExpression	"answer a boolean indicating if we are using bindMethod to attach a function to an Object"	^self currentIdentifierName = 'bindMethod'.</body><body package="AppeX-JSFile-Support">isDefineExpression	"answer a boolean indicating f we are using define to add a method (GenericJavascript)"		^self currentIdentifierName = 'value'				and: [(self currentIdentifiers at: 2) string = 'defineProperty'].</body><body package="AppeX-JSFile-Support">pushScope: type	super pushScope: type.	self currentScope at: #identifiers put: OrderedCollection new.</body></methods><methods><class-id>AppeX.JSFileParserActor</class-id> <category>compiling</category><body package="AppeX-JSFile-Support">compileBindMethods	self classNameSourceStringsLookup keysAndValuesDo: [ :eClassName :eSourceStrings |		| eClass |			eClass :=eClassName asSymbol asQualifiedReference value.		eSourceStrings do: [:eString |			eClass compile: eString classified: nil notifying: nil environment: nil.				]	]</body><body package="AppeX-JSFile-Support">parse: aString		| aDocument |		aDocument := Text2.Document fromString: aString.	self initialize: aDocument targetClass: nil theme: nil offset: 0 reason: nil.	JavascriptGrammar parser		parse: 'Program'		"parse:  'StatementList'"		"parse: 'FunctionSignatureBody'"		stream: aDocument string readStream		actor: self.	self compileBindMethods.</body></methods><methods><class-id>AppeX.JSFileParserActor</class-id> <category>accessing</category><body package="AppeX-JSFile-Support">classNameSourceStringsLookup	^classNameSourceStringsLookup</body><body package="AppeX-JSFile-Support">classNameSourceStringsLookup: aDictionary	classNameSourceStringsLookup := aDictionary</body><body package="AppeX-JSFile-Support">currentGenericJavascriptClass	^currentGenericJavascriptClass</body><body package="AppeX-JSFile-Support">currentGenericJavascriptClass: aClass	currentGenericJavascriptClass := aClass</body></methods><methods><class-id>AppeX.JSFileParserActor</class-id> <category>initialize-release</category><body package="AppeX-JSFile-Support">initialize: aDocument targetClass: aClass theme: aSourceCodeTheme offset: aDecoratingOffset reason: aReason	super initialize: aDocument targetClass: aClass theme: aSourceCodeTheme offset: aDecoratingOffset reason: aReason.	self classNameSourceStringsLookup: Dictionary new.</body></methods><methods><class-id>AppeX.JSFileParserActor class</class-id> <category>class initialization</category><body package="AppeX-JSFile-Support">initializeActions	"self initializeActions"	actions := Dictionary new.	(Pragma allNamed: #action:arguments: from: self to: self superclass)		do: [:pragma | actions at: pragma arguments first put: [: instance :object |			| arguments |			arguments := (pragma arguments at: 2) collect: [:i | i &lt;= object size ifTrue: [object at: i] ifFalse: [nil]].			instance perform: pragma selector withArguments: arguments]].	(Pragma allNamed: #action: from: self to: self superclass)		do: [:pragma | actions at: pragma arguments first put: [ :instance :object |			instance perform: pragma selector with: object]].		^ actions</body></methods><methods><class-id>AppeX.JSFileParserActor class</class-id> <category>compiling</category><body package="AppeX-JSFile-Support">instanceMethodsChanged	self initializeActions.	JavascriptGrammar resetCaches</body></methods><methods><class-id>AppeX.JSFileParserActor class</class-id> <category>instance creation</category><body package="AppeX-JSFile-Support">parse: aString		^self new parse: aString</body></methods><methods><class-id>AppeX.JavascriptPegCompiler</class-id> <category>public access</category><body package="AppeXTools">annotateMesageSends: aCompiledMethod	"Annotated @aCompiledMethod with message sends so that the method can be found by browsing senders."	| sends |	sends := referenceFinder sends				collect: [:each | Message selector: each first].	^sends notEmpty		ifTrue: [aCompiledMethod withAdditionalProperties: sends asArray]		ifFalse: [aCompiledMethod]</body><body package="AppeXTools">parseSelector: aString	"Answer a String identifying the Smalltalk selector corresponding with the name of a Javascript function at the beginning of @aString.	"	| stream position |	stream := aString readStream.	JavascriptGrammar parser		parse: 'FunctionSignature'		stream: stream		actor: nil.	stream position &gt; 0 ifFalse: [^nil].	stream := aString readStream.	JavascriptGrammar parser parse: 'SS' stream: stream actor: nil.	position := stream position.	JavascriptGrammar parser parse: 'Identifier' stream: stream actor: nil.	^(aString copyFrom: position + 1 to: stream position) trimBlanks asSymbol</body></methods><methods><class-id>AppeX.JavascriptPegCompiler</class-id> <category>private</category><body package="AppeXTools">compiled: aCompiledMethodOrNil	^aCompiledMethodOrNil ifNotNil: [ :method |		self annotateMesageSends: (super compiled: method)]</body><body package="AppeXTools">from: textOrStream class: targetClass context: ignoredContext notifying: aRequestor	super		from: textOrStream		class: targetClass		context: ignoredContext		notifying: aRequestor.	self initializeReferenceFinderForTargetClass: targetClass</body><body package="AppeXTools">initializeReferenceFinder"	This method is no longer sent. It should be deprecated?"	self deprecated: #(#version '8.3' #sunset '8.4' #use #initializeReferenceFinderForTargetClass:).	referenceFinder := JavascriptReferenceFinder new.	JavascriptGrammar parser		parse: 'FunctionSignatureBody'		stream: originalSource readStream		actor: referenceFinder.	^referenceFinder</body><body package="AppeXTools">initializeReferenceFinderForTargetClass: targetClass	referenceFinder := JavascriptReferenceFinder new.	referenceFinder targetClass: targetClass.	JavascriptGrammar parser		parse: 'FunctionSignatureBody'		stream: originalSource readStream		actor: referenceFinder.	^referenceFinder</body></methods><methods><class-id>AppeX.JavascriptPegCompiler class</class-id> <category>class initialization</category><body package="AppeXTools">initialize	"	Set myself as the compilerClass for JavascriptCode.		(self initialize)	"	JavascriptCode compilerClass: self.	"Trigger re-parsing of all 'function' methods in JavascriptClass subclasses, so that the javascript methods get annotated with their message sends."	"Note that only the instance side of JavascriptClass and subclasses have javascript code."	JavascriptCode		allSubclassesDo: [:class | class selectors do: [:selector | class recompile: selector]]</body></methods><methods><class-id>AppeX.JavascriptPegCompiler class</class-id> <category>initialize-release</category><body package="AppeXTools">obsolete	"	Reset the compilerClass for JavascriptCode.	"	JavascriptCode compilerClass: nil.	"Trigger re-parsing of all 'function' methods in JavascriptClass subclasses, so that the javascript methods get annotated with their message sends."	JavascriptCode allSubclassesDo: [:class |		class selectors do: [:selector | class recompile: selector]]</body></methods><methods><class-id>PEG2.GrammarReferenceFinder</class-id> <category>accessing</category><body package="PEGParser">sends	^sends</body></methods><methods><class-id>PEG2.GrammarReferenceFinder</class-id> <category>initialize-release</category><body package="PEGParser">initialize	super initialize.	sends := Set new</body></methods><methods><class-id>PEG2.Parser</class-id> <category>operations</category><body package="PEGParser">all: expressions	| result object position |	position := stream position.	result := Array new: expressions size.	expressions keysAndValuesDo: [:index :expression |		(object := expression value) == Failure			ifTrue: [stream position: position. ^Failure].		result at: index put: object].	^result</body><body package="PEGParser">any: expressions	| position object |	position := stream position.	expressions do: [:expression |		(object := expression value) == Failure			ifTrue:	[stream position: position]			ifFalse:	[^object]].	stream position: position.	^Failure</body><body package="PEGParser">anything	stream atEnd ifTrue: [^Failure].	^stream next</body><body package="PEGParser">caseInsensitiveliteral: literal	| position |	position := stream position.	[stream next: literal size into: buffer startingAt: 1] on: Stream incompleteNextCountSignal do: [stream position: position. ^Failure].	1 to: literal size do: [:i | (buffer at: i) asLowercase == (literal at: i) asLowercase ifFalse: [stream position: position. ^Failure]].	^literal</body><body package="PEGParser">definition: expression name: name	| object position |	position := stream position.	object := expression value.	object == Failure ifTrue: [^Failure].	actor ifNil: [^object].	^actor process: name object: object start: position stop: stream position</body><body package="PEGParser">definition: expression name: name cache: cache	| object position entry |	position := stream position.	entry := cache at: position ifAbsentPut:		[object := expression value.		(object ~~ Failure and: [actor notNil]) ifTrue:			[object := actor process: name object: object start: position stop: stream position].		stream position -&gt; object].	stream position: entry key.	^entry value</body><body package="PEGParser">excluding: intervals	| position object integer |	position := stream position.	stream atEnd ifTrue: [^Failure].	object := stream next.	integer := object asInteger.	intervals do: [:interval | (interval includes: integer) ifTrue: [stream position: position. ^Failure]].	^object</body><body package="PEGParser">explore: expression	| object position |	position := stream position.	object := expression value.	stream position: position.	^object</body><body package="PEGParser">including: intervals	| position object integer |	position := stream position.	stream atEnd ifTrue: [^Failure].	object := stream next.	integer := object asInteger.	intervals do: [:interval | (interval includes: integer) ifTrue: [^object]].	stream position: position.	^Failure</body><body package="PEGParser">literal: literal	| position |	position := stream position.	[stream next: literal size into: buffer startingAt: 1] on: Stream incompleteNextCountSignal do: [stream position: position. ^Failure].	1 to: literal size do: [:i | (buffer at: i) == (literal at: i) ifFalse: [stream position: position. ^Failure]].	^literal</body><body package="PEGParser">not: expression	| position object |	position := stream position.	object := expression value.	stream position: position.	^object == Failure		ifTrue:	[nil]		ifFalse:	[Failure]</body><body package="PEGParser">optional: expression	| object |	^(object := expression value) == Failure		ifTrue:	[nil]		ifFalse:	[object]</body><body package="PEGParser">repeat: expression min: min optional: optional	| result object position |	position := stream position.	result := OrderedCollection new: min.	min timesRepeat:		[(object := expression value) == Failure			ifTrue: [stream position: position. ^Failure].		result add: object].	optional timesRepeat:		[position := stream position.		(object := expression value) == Failure			ifTrue: [stream position: position. ^result].		result add: object.		stream position = position ifTrue: [^result]].	^result</body><body package="PEGParser">repeat: expression min: min test: test	| result object position |	position := stream position.	result := OrderedCollection new: min.	min timesRepeat:		[object := test value.		stream position: position.		object == Failure ifFalse: [^Failure].		(object := expression value) == Failure			ifTrue: [stream position: position. ^Failure].		result add: object].	[position := stream position.	test value == Failure] whileTrue:		[stream position: position.		(object := expression value) == Failure			ifTrue: [stream position: position. ^result].		result add: object.		stream position = position ifTrue: [^result]].	^result</body></methods><methods><class-id>PEG2.Parser</class-id> <category>initialize-release</category><body package="PEGParser">bufferSize: aBufferSize	buffer size &lt; aBufferSize ifTrue: [buffer := String new: aBufferSize]</body><body package="PEGParser">clear	caches do: [:each | each become: Dictionary new]</body><body package="PEGParser">initialize	grammar := Dictionary new.	buffer := String new: 1.	caches := OrderedCollection new</body></methods><methods><class-id>PEG2.Parser</class-id> <category>parsing</category><body package="PEGParser">parse: definition stream: aStream actor: anActor	| object |	actor := anActor.	stream := (aStream isKindOf: Stream) ifTrue: [aStream] ifFalse: [aStream readStream].	self clear.	object := (grammar at: definition) value.	^object == Failure		ifTrue:	[nil]		ifFalse:	[object]</body><body package="PEGParser">validate: definition stream: aStream	actor := nil.	stream := aStream readStream.	self clear.	^(grammar at: definition) value ~~ Failure</body></methods><methods><class-id>PEG2.Parser</class-id> <category>accessing</category><body package="PEGParser">caches	^caches</body><body package="PEGParser">grammar	^grammar</body></methods><methods><class-id>PEG2.Parser class</class-id> <category>instance creation</category><body package="PEGParser">bootstrap	"WARNING: This method was generated with the following code:		GrammarGrammar parser parse: 'Grammar' stream: GrammarGrammar grammar actor: PEG.ParserGenerator new	 *** This is circular. You need a working bootstrap to get a PEG parser to then generate source code to generate a PEG parser.	 *** Do not replace this method unless you are 100% sure your new parser code is correct"	| generator definitions |	definitions := OrderedCollection new.	generator := ParserParser new.	definitions add: (generator Definition: 'Grammar'				expression: (generator Sequence: ((OrderedCollection new)								add: (generator											Node: (generator Reference: 'Definition')											modifier: nil											cardinality: generator PLUS);								add: (generator											Node: generator DOT											modifier: generator NOT											cardinality: nil);								yourself))).	definitions add: (generator Definition: 'Definition'				expression: (generator Sequence: ((OrderedCollection new)								add: (generator Reference: 's');								add: (generator Reference: 'Identifier');								add: (generator Reference: 's');								add: (generator Expression: (generator Reference: 'ASSIGN')											rest: ((OrderedCollection new)													add: (Array																with: '/'																with: #()																with: (generator Reference: 'DefinitionError'));													yourself));								add: (generator Reference: 's');								add: (generator Reference: 'Expression');								add: (generator Reference: 's');								yourself))).	definitions add: (generator Definition: 'DefinitionError'				expression: (generator						Node: (generator Sequence: ((OrderedCollection new)										add: (generator													Node: (generator Reference: 'S')													modifier: generator NOT													cardinality: nil);										add: generator DOT;										yourself))						modifier: nil						cardinality: generator STAR)).	definitions add: (generator Definition: 'Expression'				expression: (generator Sequence: ((OrderedCollection new)								add: (generator Reference: 'Sequence');								add: (generator											Node: (generator													Expression: (generator Sequence: ((OrderedCollection new)																	add: (generator Reference: 'SLASH');																	add: (generator Reference: 's');																	add: (generator Reference: 'Sequence');																	yourself))													rest: ((OrderedCollection new)															add: (Array																		with: '/'																		with: #()																		with: (generator Sequence: ((OrderedCollection new)																						add: (generator Reference: 'SequenceError');																						add: (generator Reference: 's');																						yourself)));															yourself))											modifier: nil											cardinality: generator STAR);								yourself))).	definitions add: (generator Definition: 'Sequence'				expression: (generator						Node: (generator Reference: 'Node')						modifier: nil						cardinality: generator PLUS)).	definitions add: (generator Definition: 'SequenceError'				expression: (generator Reference: 'SLASH')).	definitions add: (generator Definition: 'Node'				expression: (generator						Expression: (generator Sequence: ((OrderedCollection new)										add: (generator													Node: (generator Reference: 'Prefix')													modifier: nil													cardinality: generator QUESTION);										add: (generator Reference: 'Primary');										add: (generator													Node: (generator Reference: 'Suffix')													modifier: nil													cardinality: generator QUESTION);										add: (generator Reference: 's');										yourself))						rest: ((OrderedCollection new)								add: (Array											with: '/'											with: #()											with: (generator Sequence: ((OrderedCollection new)															add: (generator																		Node: (generator Reference: 'SLASH')																		modifier: generator NOT																		cardinality: nil);															add: (generator																		Node: (generator Sequence: ((OrderedCollection new)																						add: (generator Reference: 'Identifier');																						add: (generator Reference: 's');																						add: (generator Reference: 'ASSIGN');																						yourself))																		modifier: generator NOT																		cardinality: nil);															add: (generator																		Node: (generator Reference: 'CLOSE_PAREN')																		modifier: generator NOT																		cardinality: nil);															add: (generator																		Node: (generator Reference: 'CLOSE_BRACE')																		modifier: generator NOT																		cardinality: nil);															add: (generator Reference: 'NodeError');															add: (generator Reference: 's');															yourself)));								yourself))).	definitions		add: (generator Definition: 'NodeError' expression: generator DOT).	definitions add: (generator Definition: 'Primary'				expression: (generator Expression: (generator Reference: 'Reference')						rest: ((OrderedCollection new)								add: (Array											with: '/'											with: #()											with: (generator Reference: 'Group'));								add: (Array											with: '/'											with: #()											with: (generator Reference: 'Literal'));								add: (Array											with: '/'											with: #()											with: (generator Reference: 'Range'));								add: (Array											with: '/'											with: #()											with: (generator Reference: 'DOT'));								yourself))).	definitions add: (generator Definition: 'Reference'				expression: (generator Sequence: ((OrderedCollection new)								add: (generator Reference: 'Identifier');								add: (generator Reference: 's');								add: (generator											Node: (generator Reference: 'ASSIGN')											modifier: generator NOT											cardinality: nil);								yourself))).	definitions add: (generator Definition: 'Group'				expression: (generator Sequence: ((OrderedCollection new)								add: (generator Reference: 'OPEN_PAREN');								add: (generator Reference: 's');								add: (generator Reference: 'Expression');								add: (generator Reference: 's');								add: (generator Reference: 'CLOSE_PAREN');								yourself))).	definitions add: (generator Definition: 'Prefix'				expression: (generator Expression: (generator Reference: 'AND')						rest: ((OrderedCollection new)								add: (Array											with: '/'											with: #()											with: (generator Reference: 'NOT'));								yourself))).	definitions add: (generator Definition: 'Suffix'				expression: (generator Expression: (generator Reference: 'Cardinality')						rest: ((OrderedCollection new)								add: (Array											with: '/'											with: #()											with: (generator Reference: 'QUESTION'));								add: (Array											with: '/'											with: #()											with: (generator Reference: 'STAR'));								add: (Array											with: '/'											with: #()											with: (generator Reference: 'PLUS'));								yourself))).	definitions add: (generator Definition: 'Literal'				expression: (generator						Expression: (generator Sequence: ((OrderedCollection new)										add: (generator Reference: 'QUOTE');										add: (generator													Node: (generator Reference: 'LiteralEntity')													modifier: nil													cardinality: (generator CardinalityLoop: (generator Reference: 'QUOTE')));										yourself))						rest: ((OrderedCollection new)								add: (Array											with: '/'											with: #()											with: (generator Sequence: ((OrderedCollection new)															add: (generator Reference: 'DOUBLE_QUOTE');															add: (generator																		Node: (generator Reference: 'LiteralEntity')																		modifier: nil																		cardinality: (generator																				CardinalityLoop: (generator Reference: 'DOUBLE_QUOTE')));															yourself)));								yourself))).	definitions add: (generator Definition: 'LiteralEntity'				expression: (generator Expression: (generator Reference: 'Escape')						rest: ((OrderedCollection new)								add: (Array											with: '/'											with: #()											with: generator DOT);								yourself))).	definitions add: (generator Definition: 'Range'				expression: (generator Sequence: ((OrderedCollection new)								add: (generator Reference: 'OPEN_BRACKET');								add: (generator Reference: 's');								add: (generator											Node: (generator Literal: '^')											modifier: nil											cardinality: generator QUESTION);								add: (generator											Node: (generator Reference: 'RangeSet')											modifier: nil											cardinality: (generator CardinalityLoopMin: 1													test: (generator Reference: 'CLOSE_BRACKET')));								yourself))).	definitions add: (generator Definition: 'RangeSet'				expression: (generator						Expression: (generator Sequence: ((OrderedCollection new)										add: (generator Reference: 's');										add: (generator Reference: 'LiteralEntity');										add: (generator Reference: 'DASH');										add: (generator Reference: 'LiteralEntity');										add: (generator Reference: 's');										yourself))						rest: ((OrderedCollection new)								add: (Array											with: '/'											with: #()											with: (generator Sequence: ((OrderedCollection new)															add: (generator Reference: 's');															add: (generator Reference: 'LiteralEntity');															add: (generator Reference: 's');															yourself)));								yourself))).	definitions add: (generator Definition: 'Cardinality'				expression: (generator Sequence: ((OrderedCollection new)								add: (generator Reference: 'OPEN_BRACE');								add: (generator Reference: 's');								add: (generator Expression: (generator Reference: 'CardinalityRange')											rest: ((OrderedCollection new)													add: (Array																with: '/'																with: #()																with: (generator Reference: 'CardinalityLoopMin'));													add: (Array																with: '/'																with: #()																with: (generator Reference: 'CardinalityRangeMin'));													add: (Array																with: '/'																with: #()																with: (generator Reference: 'CardinalityLoop'));													yourself));								add: (generator Reference: 's');								add: (generator Reference: 'CLOSE_BRACE');								yourself))).	definitions add: (generator Definition: 'CardinalityRangeMin'				expression: (generator Reference: 'NumLiteral')).	definitions add: (generator Definition: 'CardinalityRange'				expression: (generator Sequence: ((OrderedCollection new)								add: (generator Reference: 'NumLiteral');								add: (generator Reference: 's');								add: (generator Reference: 'COMMA');								add: (generator Reference: 's');								add: (generator Reference: 'NumLiteral');								yourself))).	definitions add: (generator Definition: 'CardinalityLoopMin'				expression: (generator Sequence: ((OrderedCollection new)								add: (generator Reference: 'NumLiteral');								add: (generator Reference: 's');								add: (generator Reference: 'COMMA');								add: (generator Reference: 's');								add: (generator Reference: 'Expression');								yourself))).	definitions add: (generator Definition: 'CardinalityLoop'				expression: (generator Reference: 'Expression')).	definitions add: (generator Definition: 'Identifier'				expression: (generator Sequence: ((OrderedCollection new)								add: (generator Range: nil											sets: ((OrderedCollection new)													add: (97 to: 122);													add: (65 to: 90);													add: (95 to: 95);													yourself));								add: (generator											Node: (generator Range: nil													sets: ((OrderedCollection new)															add: (97 to: 122);															add: (65 to: 90);															add: (48 to: 57);															add: (95 to: 95);															yourself))											modifier: nil											cardinality: generator STAR);								yourself))).	definitions add: (generator Definition: 'NumLiteral'				expression: (generator Expression: (generator Literal: 'Infinity')						rest: ((OrderedCollection new)								add: (Array											with: '/'											with: #()											with: (generator Literal: '0'));								add: (Array											with: '/'											with: #()											with: (generator Sequence: ((OrderedCollection new)															add: (generator Range: nil																		sets: ((OrderedCollection new)																				add: (49 to: 57);																				yourself));															add: (generator																		Node: (generator Range: nil																				sets: ((OrderedCollection new)																						add: (48 to: 57);																						yourself))																		modifier: nil																		cardinality: generator STAR);															yourself)));								yourself))).	definitions add: (generator Definition: 'Escape'				expression: (generator						Expression: (generator Sequence: ((OrderedCollection new)										add: (generator Reference: 'BACKSLASH');										add: (generator Range: nil													sets: ((OrderedCollection new)															add: (120 to: 120);															yourself));										add: (generator													Node: (generator Range: nil															sets: ((OrderedCollection new)																	add: (48 to: 57);																	add: (65 to: 70);																	yourself))													modifier: nil													cardinality: (generator CardinalityRangeMin: 6));										yourself))						rest: ((OrderedCollection new)								add: (Array											with: '/'											with: #()											with: (generator Sequence: ((OrderedCollection new)															add: (generator Reference: 'BACKSLASH');															add: (generator Range: nil																		sets: ((OrderedCollection new)																				add: (110 to: 110);																				add: (114 to: 114);																				add: (116 to: 116);																				add: (115 to: 115);																				add: (45 to: 45);																				add: (92 to: 92);																				add: (91 to: 91);																				add: (93 to: 93);																				add: (39 to: 39);																				add: (34 to: 34);																				yourself));															yourself)));								add: (Array											with: '/'											with: #()											with: (generator Reference: 'EscapeError'));								yourself))).	definitions add: (generator Definition: 'EscapeError'				expression: (generator Sequence: ((OrderedCollection new)								add: (generator Reference: 'BACKSLASH');								add: generator DOT;								yourself))).	definitions add: (generator Definition: 's'				expression: (generator						Node: (generator Reference: 'S')						modifier: nil						cardinality: generator STAR)).	definitions add: (generator Definition: 'S'				expression: (generator Expression: (generator								Node: (generator Reference: 'whitespace')								modifier: nil								cardinality: generator PLUS)						rest: ((OrderedCollection new)								add: (Array											with: '/'											with: #()											with: (generator Reference: 'comment'));								yourself))).	definitions add: (generator Definition: 'comment'				expression: (generator Sequence: ((OrderedCollection new)								add: (generator Reference: 'OPEN_COMMENT');								add: (generator											Node: (generator Reference: 'comment_body')											modifier: nil											cardinality: (generator													CardinalityLoop: (generator Reference: 'CLOSE_COMMENT')));								yourself))).	definitions add: (generator Definition: 'comment_body'				expression: (generator Expression: (generator Reference: 'comment')						rest: ((OrderedCollection new)								add: (Array											with: '/'											with: #()											with: generator DOT);								yourself))).	definitions add: (generator Definition: 'whitespace'				expression: (generator Range: nil						sets: ((OrderedCollection new)								add: (32 to: 32);								add: (9 to: 9);								add: (13 to: 13);								add: (10 to: 10);								yourself))).	definitions		add: (generator Definition: 'ASSIGN' expression: (generator Literal: '&lt;-')).	definitions		add: (generator Definition: 'SLASH' expression: (generator Literal: '/')).	definitions		add: (generator Definition: 'BACKSLASH' expression: (generator Literal: '\')).	definitions		add: (generator Definition: 'AND' expression: (generator Literal: '&amp;')).	definitions		add: (generator Definition: 'NOT' expression: (generator Literal: '!')).	definitions		add: (generator Definition: 'COMMA' expression: (generator Literal: ',')).	definitions		add: (generator Definition: 'QUESTION' expression: (generator Literal: '?')).	definitions		add: (generator Definition: 'STAR' expression: (generator Literal: '*')).	definitions		add: (generator Definition: 'PLUS' expression: (generator Literal: '+')).	definitions		add: (generator Definition: 'DASH' expression: (generator Literal: '-')).	definitions		add: (generator Definition: 'DOT' expression: (generator Literal: '.')).	definitions		add: (generator Definition: 'QUOTE' expression: (generator Literal: '''')).	definitions add: (generator Definition: 'DOUBLE_QUOTE'				expression: (generator Literal: '"')).	definitions add: (generator Definition: 'OPEN_BRACKET'				expression: (generator Literal: '[')).	definitions add: (generator Definition: 'CLOSE_BRACKET'				expression: (generator Literal: ']')).	definitions add: (generator Definition: 'OPEN_PAREN'				expression: (generator Literal: '(')).	definitions add: (generator Definition: 'CLOSE_PAREN'				expression: (generator Literal: ')')).	definitions add: (generator Definition: 'OPEN_BRACE'				expression: (generator Literal: '{')).	definitions add: (generator Definition: 'CLOSE_BRACE'				expression: (generator Literal: '}')).	definitions add: (generator Definition: 'OPEN_COMMENT'				expression: (generator Literal: '/*')).	definitions add: (generator Definition: 'CLOSE_COMMENT'				expression: (generator Literal: '*/')).	^generator Grammar: definitions</body><body package="PEGParser">new	^super new initialize</body></methods><methods><class-id>AppeX.JavascriptVarMinifyingActor</class-id> <category>calculated</category><body package="AppeX-Minification">minStringForVarName: varName	| aString anInteger |		anInteger := self varNameMinStringLookup keys size + 1.	aString := self varNameMinStringLookup at: varName ifAbsentPut: [self stringForVarNumber: anInteger].	^aString</body><body package="AppeX-Minification">stringForVarNumber: anInteger	"self stringForVarNumber: 27"	^self class stringForVarNumber: anInteger</body></methods><methods><class-id>AppeX.JavascriptVarMinifyingActor</class-id> <category>accessing</category><body package="AppeX-Minification">positionPropertyNameLookup	^positionPropertyNameLookup</body><body package="AppeX-Minification">positionPropertyNameLookup: aDictionary	positionPropertyNameLookup := aDictionary</body><body package="AppeX-Minification">positionVarNameLookup	^positionVarNameLookup</body><body package="AppeX-Minification">positionVarNameLookup: aDictionary	positionVarNameLookup := aDictionary</body><body package="AppeX-Minification">varNameMinStringLookup	^varNameMinStringLookup</body><body package="AppeX-Minification">varNameMinStringLookup: aString	varNameMinStringLookup := aString</body></methods><methods><class-id>AppeX.JavascriptVarMinifyingActor</class-id> <category>minify - api</category><body package="AppeX-Minification">minifyVarsInSource: aString	"return a new string"		|   codeStream codeStreamMinified varName varNameEnd propertyName minVarName |		nodes := Dictionary new.	scope := OrderedCollection with: Dictionary new.	"document is used by JavascriptParserActor"	document := Text2.Document fromString: aString.		"variable minification"	self positionVarNameLookup: Dictionary new.	self varNameMinStringLookup: Dictionary new.	self positionPropertyNameLookup: Dictionary new.	"parse document and record variable and property name positions"	JavascriptGrammar parser		"parse:  'StatementList'"		parse: 'FunctionSignatureBody'		stream: aString readStream		actor: self.	codeStream := document readStream.	codeStream reset.	codeStreamMinified := ReadWriteStream on: String new.	[codeStream atEnd] whileFalse: [ 		varName := self positionVarNameLookup at: codeStream position ifAbsent: [nil].		propertyName :=  self positionPropertyNameLookup at: codeStream position ifAbsent: [nil].		(varName notNil and: [propertyName isNil])			ifTrue: [				minVarName := self minStringForVarName: varName.				varNameEnd := codeStream position  + varName size.				codeStreamMinified nextPutAll: minVarName.				codeStream position: varNameEnd]			ifFalse: [codeStreamMinified nextPut:  codeStream next].			].	^codeStreamMinified contents.</body></methods><methods><class-id>AppeX.JavascriptVarMinifyingActor</class-id> <category>processing</category><body package="AppeX-Minification">recordPositionOfProperty: object     		self positionPropertyNameLookup at: start put: object string</body><body package="AppeX-Minification">recordPositionOfVariable: object     	| aPosition |		"document copyFrom: start + 1 to: stop + 50"	"don't record position if object is a DotIdentifier (a property not a variable)"	aPosition := start max: 1.	(document at: aPosition) = $.  ifTrue: [^self].	self positionVarNameLookup at: aPosition put: object string</body></methods><methods><class-id>AppeX.JavascriptVarMinifyingActor class</class-id> <category>class initialization</category><body package="AppeX-Minification">initializeActions	"self initializeActions"	actions := Dictionary new.	(Pragma allNamed: #action:arguments: from: self to: self superclass)		do: [:pragma | actions at: pragma arguments first put: [: instance :object |			| arguments |			arguments := (pragma arguments at: 2) collect: [:i | i &lt;= object size ifTrue: [object at: i] ifFalse: [nil]].			instance perform: pragma selector withArguments: arguments]].	(Pragma allNamed: #action: from: self to: self superclass)		do: [:pragma | actions at: pragma arguments first put: [ :instance :object |			instance perform: pragma selector with: object]].		^ actions</body></methods><methods><class-id>AppeX.JavascriptVarMinifyingActor class</class-id> <category>accessing</category><body package="AppeX-Minification">classNameMinStringLookup	classNameMinStringLookup isNil ifTrue: [self classNameMinStringLookup: Dictionary new].	^classNameMinStringLookup</body><body package="AppeX-Minification">classNameMinStringLookup: anObject	classNameMinStringLookup := anObject</body></methods><methods><class-id>AppeX.JavascriptVarMinifyingActor class</class-id> <category>calculated - minification</category><body package="AppeX-Minification">letterForNumber: anInteger	"self letterForNumber: 4"	^'abcdefghijklmnopqrstuvwxyz' at: anInteger</body><body package="AppeX-Minification">minStringForClassName: className	| aString anInteger |		anInteger := self classNameMinStringLookup keys size + 1.	aString := self classNameMinStringLookup at: className ifAbsentPut: [self stringForClassNumber: anInteger].	^aString</body><body package="AppeX-Minification">stringForClassNumber: anInteger	"self stringForClassNumber: 30"		| letters |		letters := (self stringForNumber: anInteger) asUppercase.		^'__', letters</body><body package="AppeX-Minification">stringForNumber: anInteger	"self stringForNumber: 29"		| modNumber remainder aStream  |		aStream := ReadWriteStream on: String new.	modNumber := (anInteger - 1) // 26.	remainder := (anInteger - 1) \\ 26. 	modNumber &gt; 0 		ifTrue: [ 			aStream nextPut: (self letterForNumber: modNumber).				aStream nextPut: (self letterForNumber: remainder +1).		] 		ifFalse: [			aStream nextPut: (self letterForNumber: anInteger).		].		^aStream contents</body><body package="AppeX-Minification">stringForVarNumber: anInteger	"self stringForVarNumber: 53"		^"'_'," self stringForNumber: anInteger.</body></methods><methods><class-id>PEG2.ParserGenerator</class-id> <category>private</category><body package="PEGParser">collection: aCollection	| stream |	stream := String new writing.	stream nextPutAll:  '(OrderedCollection new'.	aCollection do: [:each |		stream nextPutAll:  ' add: '.		stream nextPutAll:  each.		stream nextPutAll:  ';'].	stream nextPutAll:  ' yourself)'.	^stream contents</body></methods><methods><class-id>PEG2.GrammarClass class</class-id> <category>testing</category><body package="PEGParser">parserUseCache	^false</body><body package="PEGParser">parserUseCaseInsensitive	^false</body></methods><methods><class-id>PEG2.GrammarClass class</class-id> <category>accessing</category><body package="PEGParser">grammar	| instance |	grammarCache ifNotNil: [^grammarCache].	self == GrammarClass ifTrue: [^''].	instance := self new.	^grammarCache := self superclass grammar,		(self methodDictionary			inject: ''			into: [:grammar :method | grammar, (method valueWithReceiver: instance arguments: #()), ''])</body><body package="PEGParser">parser	| actor |	parserCache ifNotNil: [^parserCache].	actor := ParserParser new.	self parserUseCache ifTrue: [actor useCache].	self parserUseCaseInsensitive ifTrue: [actor useCaseInsensitive].	^parserCache := Parser bootstrap				parse: 'Grammar'				stream: self grammar readStream				actor: actor</body><body package="PEGParser">resetCaches	parserCache := grammarCache := nil</body></methods><methods><class-id>PEG2.GrammarClass class</class-id> <category>compiling</category><body package="PEGParser">parserClass	self resetCaches.	^GrammarParser</body></methods><methods><class-id>PEG2.ParserParser</class-id> <category>initialize-release</category><body package="PEGParser">dontUseCache	useCache := false</body><body package="PEGParser">initialize	super initialize.	useCache := false.	useCaseInsensitive := false.	parser := Parser new.	references := Dictionary new</body><body package="PEGParser">useCache	useCache := true</body><body package="PEGParser">useCaseInsensitive	useCaseInsensitive := true</body><body package="PEGParser">useCaseSensitive	useCaseInsensitive := false</body></methods><methods><class-id>AppeX.JavascriptUserMessageActor</class-id> <category>accessing</category><body package="AppeXTools">collectedArguments	^collectedArguments</body><body package="AppeXTools">collectedArguments: anObject	collectedArguments := anObject</body><body package="AppeXTools">document	^document</body><body package="AppeXTools">document: aDocument	document := aDocument</body><body package="AppeXTools">isCollectingArguments	^isCollectingArguments</body><body package="AppeXTools">isCollectingArguments: aBoolean	isCollectingArguments := aBoolean</body><body package="AppeXTools">startStopLookup	^startStopLookup</body><body package="AppeXTools">startStopLookup: aDictionary	startStopLookup := aDictionary</body></methods><methods><class-id>AppeX.JavascriptUserMessageActor</class-id> <category>initialize-release</category><body package="AppeXTools">process: name object: object start: aStart stop: aStop	| action span |	action := actions at: name ifAbsent: [^object].	start := aStart. 	stop := aStop.	span := document copyBetween: start and: stop.	action value: self value: span.	^span</body></methods><methods><class-id>AppeX.JavascriptUserMessageActor class</class-id> <category>compiling</category><body package="AppeXTools">instanceMethodsChanged	super initializeActions.	JavascriptGrammar resetCaches</body></methods><methods><class-id>PEG2.GrammarGrammar class</class-id> <category>accessing</category><body package="PEGParser">grammar^'Grammar			&lt;-	Definition+ !.Definition			&lt;-	s Identifier s (ASSIGN / DefinitionError) s Expression sDefinitionError		&lt;-	(!S .)*Expression			&lt;-	Sequence ((SLASH s Sequence) / (SequenceError s))*Sequence			&lt;-	Node+SequenceError		&lt;-	SLASHNode				&lt;-	Prefix? Primary Suffix? s					/	!SLASH !(Identifier s ASSIGN) !CLOSE_PAREN !CLOSE_BRACE NodeError sNodeError			&lt;-	.Primary				&lt;-	Reference / Group / Literal / Range / DOTReference			&lt;-	Identifier s !ASSIGNGroup				&lt;-	OPEN_PAREN s Expression s CLOSE_PARENPrefix				&lt;-	AND / NOTSuffix				&lt;-	Cardinality / QUESTION / STAR / PLUSLiteral				&lt;-	QUOTE LiteralEntity{QUOTE}					/	DOUBLE_QUOTE LiteralEntity{DOUBLE_QUOTE}LiteralEntity			&lt;-	Escape / .Range				&lt;-	OPEN_BRACKET s "^"? RangeSet{1,CLOSE_BRACKET}RangeSet			&lt;-	s LiteralEntity DASH LiteralEntity s					/	s LiteralEntity sCardinality			&lt;-	OPEN_BRACE s (CardinalityRange / CardinalityLoopMin / CardinalityRangeMin / CardinalityLoop) s CLOSE_BRACECardinalityRangeMin	&lt;-	NumLiteralCardinalityRange	&lt;-	NumLiteral s COMMA s NumLiteralCardinalityLoopMin	&lt;-	NumLiteral s COMMA s ExpressionCardinalityLoop		&lt;-	ExpressionIdentifier				&lt;-	[a-zA-Z_] [a-zA-Z0-9_]*NumLiteral			&lt;-	"Infinity" / "0" / [1-9] [0-9]*Escape				&lt;-	BACKSLASH [x] [0-9A-F]{6}					/	BACKSLASH [nrts\-\\\[\]\''\"]					/	EscapeErrorEscapeError			&lt;-	BACKSLASH .s					&lt;-	S*S					&lt;-	whitespace+					/	commentcomment			&lt;-	OPEN_COMMENT comment_body{CLOSE_COMMENT}comment_body		&lt;-	comment					/	.whitespace			&lt;-	[\s\t\n\r]ASSIGN				&lt;-	"&lt;-"SLASH				&lt;-	"/"BACKSLASH		&lt;-	"\\"AND				&lt;-	"&amp;"NOT				&lt;-	"!"COMMA				&lt;-	","QUESTION			&lt;-	"?"STAR				&lt;-	"*"PLUS				&lt;-	"+"DASH				&lt;-	"-"DOT				&lt;-	"."QUOTE				&lt;-	"''"DOUBLE_QUOTE	&lt;-	''"''OPEN_BRACKET	&lt;-	"["CLOSE_BRACKET	&lt;-	"]"OPEN_PAREN		&lt;-	"("CLOSE_PAREN		&lt;-	")"OPEN_BRACE		&lt;-	"{"CLOSE_BRACE		&lt;-	"}"OPEN_COMMENT	&lt;-	"/*"CLOSE_COMMENT	&lt;-	"*/"'</body></methods><methods><class-id>AppeX.JavascriptGrammar</class-id> <category>grammar</category><body package="AppeXTools">AMP 						&lt;- "&amp;"</body><body package="AppeXTools">ASTERISK 					&lt;- [*]</body><body package="AppeXTools">AT 							&lt;- "@"</body><body package="AppeXTools">BACKSLASH 				&lt;- "\\"</body><body package="AppeXTools">BREAK 						&lt;- "break"</body><body package="AppeXTools">BooleanLiteral 				&lt;- "true" / "false"</body><body package="AppeXTools">CASE 						&lt;- "case"</body><body package="AppeXTools">CATCH 						&lt;- "catch"</body><body package="AppeXTools">CLOSE 						&lt;- ")"</body><body package="AppeXTools">CLOSECURLY 				&lt;- "}"</body><body package="AppeXTools">CLOSESQUARE 				&lt;- "]"</body><body package="AppeXTools">COLON 						&lt;- ":"</body><body package="AppeXTools">COMMA 					&lt;- ","</body><body package="AppeXTools">CONTINUE 					&lt;- "continue"</body><body package="AppeXTools">CR 							&lt;- "\x00000D"</body><body package="AppeXTools">CharacterClassEscape 		&lt;- [dDsSwW]</body><body package="AppeXTools">ControlEscape 				&lt;- [fnrtv]</body><body package="AppeXTools">ControlLetter 				&lt;- [a-zA-Z]</body><body package="AppeXTools">DEFAULT 					&lt;- "default"</body><body package="AppeXTools">DELETE 					&lt;- "delete"</body><body package="AppeXTools">DO 							&lt;- "do"</body><body package="AppeXTools">DOLLAR 					&lt;- "$"</body><body package="AppeXTools">DOT 						&lt;- "."</body><body package="AppeXTools">DOUBLEQUOTE 				&lt;- "\""</body><body package="AppeXTools">DecimalDigit 				&lt;- [0123456789]</body><body package="AppeXTools">DecimalDigits 				&lt;- [0123456789]*</body><body package="AppeXTools">DivPunctuator 				&lt;- "/" / "/="</body><body package="AppeXTools">ELSE 						&lt;- "else"</body><body package="AppeXTools">EMPTY 						&lt;- ""</body><body package="AppeXTools">EQUAL 						&lt;- "="</body><body package="AppeXTools">EXCLAMATION 				&lt;- "!"</body><body package="AppeXTools">EndOfSource 				&lt;- !.</body><body package="AppeXTools">ExponentIndicator 			&lt;- [eE]</body><body package="AppeXTools">FF 							&lt;- [\x00000C]</body><body package="AppeXTools">FINALLY 					&lt;- "finally"</body><body package="AppeXTools">FOR 						&lt;- "for"</body><body package="AppeXTools">FORWARDSLASH 			&lt;- "/"</body><body package="AppeXTools">FUNCTION 					&lt;- "function"</body><body package="AppeXTools">HexDigit 					&lt;- [0123456789abcdefABCDEF]</body><body package="AppeXTools">IF 							&lt;- "if"</body><body package="AppeXTools">IN 							&lt;- "in"</body><body package="AppeXTools">INFINITY 					&lt;- "Infinity"</body><body package="AppeXTools">INSTANCEOF 				&lt;- "instanceof"</body><body package="AppeXTools">LF 							&lt;- "\x00000A"</body><body package="AppeXTools">MINUS 						&lt;- "-"</body><body package="AppeXTools">MultiLineComment 			&lt;- "/*" .{"*/"}</body><body package="AppeXTools">NEW 						&lt;- "new"</body><body package="AppeXTools">NonZeroDigit 				&lt;- [123456789]</body><body package="AppeXTools">NullLiteral 					&lt;- "null"</body><body package="AppeXTools">OPEN 						&lt;- "("</body><body package="AppeXTools">OPENCURLY 				&lt;- "{"</body><body package="AppeXTools">OPENSQUARE 				&lt;- "["</body><body package="AppeXTools">PERCENT 					&lt;- "%"</body><body package="AppeXTools">PLUS 						&lt;- "+"</body><body package="AppeXTools">PatternCharacter 			&lt;- [^$\\.*+?()\[\]{}|]</body><body package="AppeXTools">QUESTION 					&lt;- "?"</body><body package="AppeXTools">RETURN 					&lt;- "return"</body><body package="AppeXTools">SEMICOLON 				&lt;- ";"</body><body package="AppeXTools">SINGLEQUOTE 				&lt;- "'"</body><body package="AppeXTools">SPACE 						&lt;- " "</body><body package="AppeXTools">SWITCH 					&lt;- "switch"</body><body package="AppeXTools">SingleEscapeCharacter 		&lt;- [\'\"\\bfnrtv]</body><body package="AppeXTools">SingleLineComment 			&lt;- "//" .{[\x00000A\x00000D]}</body><body package="AppeXTools">TAB 						&lt;- [\t]</body><body package="AppeXTools">THIS 						&lt;- "this"</body><body package="AppeXTools">THROW 					&lt;- "throw"</body><body package="AppeXTools">TILDE 						&lt;- "~"</body><body package="AppeXTools">TRY 						&lt;- "try"</body><body package="AppeXTools">TYPEOF 					&lt;- "typeof"</body><body package="AppeXTools">UNDERSCORE 				&lt;- "_"</body><body package="AppeXTools">VAR 						&lt;- "var"</body><body package="AppeXTools">VERTICALBAR 				&lt;- "|"</body><body package="AppeXTools">VOID 						&lt;- "void"</body><body package="AppeXTools">VT 							&lt;- "\x00000B"</body><body package="AppeXTools">WHILE 						&lt;- "while"</body><body package="AppeXTools">WITH 						&lt;- "with"</body><body package="AppeXTools">WhiteSpace 					&lt;- [\s\t\x00000B\x00000C]/* LineTerminator 				&lt;- LF / CR / LS / PS */</body><body package="AppeXTools">uriAlpha 					&lt;- [a-zA-Z]</body></methods><methods><class-id>AppeX.JavascriptGrammar class</class-id> <category>class initialization</category><body package="AppeXTools">parserUseCache	^ parserUseCache ifNil: [parserUseCache := true]</body><body package="AppeXTools">parserUseCache: aBoolean"	self parserUseCache: true.	self parserUseCache: false."	parserUseCache := aBoolean</body></methods><methods><class-id>AppeX.JavascriptGrammar class</class-id> <category>compiling</category><body package="AppeXTools">instanceMethodsChanged	self resetCaches</body></methods><methods><class-id>AppeX.JavascriptGrammar class</class-id> <category>accessing</category><body package="AppeXTools">resetCaches	parserUseCache := nil.	super resetCaches</body></methods><methods><class-id>AppeX.JSFileComposer</class-id> <category>accessing</category><body package="AppeX-JSFile-Support">code	|  filename contents |		filename := self codeFilename.	filename exists ifFalse: [		contents := super code.		self writeLibraryCode:  contents].	"just re-fetch the code without checking the timestamp"	contents := JSFileMonitor codeFromFile: filename.	JSFileParserActor parse: contents.	^contents</body><body package="AppeX-JSFile-Support">codeFilename 	^JSFileMonitor directory / self library name</body><body package="AppeX-JSFile-Support">writeLibraryCode: aString		|  aStream fn |		(fn := self codeFilename ) head asFilename ensureDirectory.	aStream :=  fn writing encoding: #utf8. "will overwrite current contents, will create file if absent"	aStream setLineEndLF.	[		aStream write: aString	] ensure: [aStream close].</body></methods><methods><class-id>AppeX.JSFileComposer class</class-id> <category>public</category><body package="AppeX-JSFile-Support">deleteFilesFor: aJavascriptCodeClass		"Delete all application libraries that use the code class"	(JavascriptLibrary librariesContaining: aJavascriptCodeClass) do: [:eLibrary | 		JSFileMonitor deleteFileForLibrary: eLibrary	]</body><body package="AppeX-JSFile-Support">instanceMethodsChanged: aJavascriptCodeClass	Application codeComposer = self 		ifTrue: [self deleteFilesFor: aJavascriptCodeClass]</body></methods><methods><class-id>AppeX.Application class</class-id> <category>user messages</category><body package="AppeXTools">buildCatalog	^self buildCatalogFor: self classesForCatalog.</body><body package="AppeXTools">buildCatalogAssociationsFor: classCollection	| aBrowserEnvironment classSelectorsLookup  catalogAssociations |	aBrowserEnvironment := Refactory.Browser.BrowserEnvironment new.	classSelectorsLookup := (aBrowserEnvironment referencesTo: #_translate) classSelectors.	catalogAssociations := SortedCollection sortBlock:  [:a :b | a key &lt; b key].	classSelectorsLookup keysAndValuesDo: [:eClassName :eSelectorCollection | | eClass eClassAssociationCollection|		eClass := aBrowserEnvironment classForName: eClassName.		(classCollection includes: eClass) 			ifTrue: [				eClassAssociationCollection := self categoryEntriesForClass: eClass andSelectors: eSelectorCollection.				catalogAssociations addAll: eClassAssociationCollection.			]				 	].	^catalogAssociations</body><body package="AppeXTools">buildCatalogFor: classCollection	| catalogName catalogAssociations catalogNameAssociationsLookup |	catalogName := self catalogName.		catalogAssociations := self buildCatalogAssociationsFor: classCollection.	catalogNameAssociationsLookup := Dictionary new.	catalogNameAssociationsLookup at: catalogName put: catalogAssociations.	^catalogNameAssociationsLookup</body><body package="AppeXTools">buildCatalogs	"If sent to Application, returns catalogs separately for each class.  	If sent to a subclass of application, returns a single catalog for all supporting classes in that application."	| aBrowserEnvironment classSelectorsLookup catalogNameAssociationsLookup |	aBrowserEnvironment := Refactory.Browser.BrowserEnvironment new.	classSelectorsLookup := (aBrowserEnvironment referencesTo: #_translate) classSelectors.	catalogNameAssociationsLookup := Dictionary new.	classSelectorsLookup keysAndValuesDo: [:eClassName :eSelectorCollection | | eClass eCatalogName eClassAssociationCollection eCollection|		eClass := aBrowserEnvironment classForName: eClassName.		eCatalogName := self defaultCatalogNameForClass: eClass. 		eClassAssociationCollection := self categoryEntriesForClass: eClass andSelectors: eSelectorCollection.		eCollection := catalogNameAssociationsLookup at: eCatalogName ifAbsentPut: [SortedCollection sortBlock:  [:a :b | a key &lt; b key]].		eCollection addAll: eClassAssociationCollection.	 	].	^catalogNameAssociationsLookup</body><body package="AppeXTools">categoryEntriesForClass: aClass andSelectors: aSelectorCollection	 	|  associationCollection |			associationCollection := SortedCollection sortBlock: [:a :b | a key &lt; b key ].		aSelectorCollection do: [:eSelector | |eParseTree eDictionary|			eParseTree := aClass parseTreeFor: eSelector.			eDictionary := eParseTree generateUserMessageCatalogs.			eDictionary do: [:eArgumentsCollection | | eKey eValue eMessageAssociation|				eKey := eArgumentsCollection first. 				eArgumentsCollection size &gt; 1 ifTrue: [eValue := eArgumentsCollection last].				eMessageAssociation := Association key: eKey value: eValue.				associationCollection add: eMessageAssociation.			].					].		^associationCollection</body></methods><methods><class-id>AppeX.Application class</class-id> <category>accessing</category><body package="AppeXTools">codeComposerType	self codeComposer =  JavascriptComposer ifTrue: [^#useImageCode ]. 	self codeComposer =  JSFileComposer ifTrue: [^#useJSFile].</body><body package="AppeXTools">codeComposerType: aSelector	self perform: aSelector</body></methods><methods><class-id>AppeX.Application class</class-id> <category>user messages</category><body package="AppeXTools">generateUserMessageCatalog		"This is a method for regenerating a Single catalog for a class (and potentially its associated classesForCatalog)."	"HelloLocalized generateUserMessageCatalog"	|  catalogNameAssociationsLookup |	catalogNameAssociationsLookup := self buildCatalog.	self ensureFilesReady. "for now just ensure the directory exists"	self writeCatalogs: catalogNameAssociationsLookup   "in this case, we will be writing a single catalog"</body><body package="AppeXTools">generateUserMessageCatalogForClasses: classCollection	"This is a method for regenerating a Single catalog for a class or collection of classes"	"GenealogyApplication generateUserMessageCatalog"	|  catalogNameAssociationsLookup |	catalogNameAssociationsLookup := self buildCatalogFor: classCollection.	self ensureFilesReady. "for now just ensure the directory exists"	self writeCatalogs: catalogNameAssociationsLookup</body><body package="AppeXTools">generateUserMessageCatalogs	"This is a method for regenerating ALL catalogs"	"self generateUserMessageCatalogs"	"GenealogyApplication generateUserMessageCatalogs"	|  catalogNameAssociationsLookup |	self ensureFilesReady. "for now just ensure the directory exists"	catalogNameAssociationsLookup := self buildCatalogs.	self writeCatalogs: catalogNameAssociationsLookup</body></methods><methods><class-id>AppeX.Application class</class-id> <category>accessing</category><body package="AppeXTools">includesAction: aPragma in: aDictionary"	Answer a boolean indicating whether aDictionary or one of its children includes a Pragma with the same selector	as @aPragma. This assumes the 'requestActions' structure where dictionary values only include instances of	Pragma or Dictionary but no other types of objects."	aDictionary keysAndValuesDo: [ :eachKey :eachValue |		(eachValue isKindOf: Dictionary)			ifTrue: [ (self includesAction: aPragma in: eachValue) ifTrue: [ ^ true ]]			ifFalse: [ eachValue selector = aPragma selector ifTrue: [ ^ true ]]].	^ false</body><body package="AppeXTools">useJSFile 	AppeX.JavascriptCode resetAllCodeCache.	self codeComposer:  JSFileComposer.	self scriptDirectory ensureDirectory.	JSFileMonitor start</body></methods><methods><class-id>AppeX.Application class</class-id> <category>user messages</category><body package="AppeXTools">writeCatalogs: aDictionary		"Write out the catalog or catalogs represented by aDictionary of catalog names and the key-value user message pairs they are associated with."	"Files and directories will be created or replaced as required, and warnings will be written to the Transcript of duplicate user message definitions."	aDictionary keysAndValuesDo: [:eCatalogName :eAssociationCollection | | eFilename eStream printedWithValue printedAsStub eStubCollection ePairCollection|		eFilename := self userMessageDirectory / (eCatalogName, '.lbl').		Transcript cr; cr; show: 'Writing catalog: ', eFilename asString.		eStream := eFilename asFilename writing encoding: #utf8. "will overwrite current contents, will create file if absent"		[		eStream write: 'encoding: #UTF_8';		cr;		write: 'catalog: ', eCatalogName;		cr.		printedWithValue := Dictionary new.		printedAsStub := OrderedCollection new.		eStubCollection := eAssociationCollection select: [:eKeyValuePair | eKeyValuePair value isNil].		ePairCollection := eAssociationCollection select: [:eKeyValuePair | eKeyValuePair value notNil].		ePairCollection do: [ :eAssociation | | eKey eValue alreadyPrintedValue |			eKey := eAssociation key.			eValue := eAssociation value.			alreadyPrintedValue := printedWithValue at: eKey ifAbsent: [nil].			(alreadyPrintedValue notNil)				ifTrue: [					 alreadyPrintedValue ~= eValue 						ifTrue: [							Transcript cr; show: 'Warning!  Conflicting definitions detected for user localized string with key: ', eKey printString.]]				ifFalse: [					eStream cr; 					write: eKey;					write: '=', eValue printString. "add single quotes"].			printedWithValue at: eKey put: eValue.		].		eStubCollection do: [ :eAssociation | | eKey shouldPrintStub |			eKey := eAssociation key.			shouldPrintStub := (printedWithValue includes: eKey) not and: [(printedAsStub includes: eKey) not].			shouldPrintStub ifTrue: [						eStream cr; 							write: eKey;							write: '=', eKey printString. "add single quotes"						printedAsStub add: eKey.			]							]		] ensure: [eStream close]	]</body></methods><methods><class-id>Tools.Pragma</class-id> <category>printing</category><body package="AppeXTools">printOn: aStream"	JK: I am not happy about this method's presence, but at least let's keep it in AppeX-Tools."	super printOn: aStream.	aStream nextPutAll: '&gt;&gt;'.	self selector printOn: aStream</body></methods><methods><class-id>Refactory.Browser.ChangeMethodNameRefactoring</class-id> <category>private</category><body package="AppeXTools">implementors	implementors isNil 		ifTrue: [implementors := self model allImplementorsOf: oldSelector.				implementors := (self  isJavascriptCode					ifTrue: [implementors select: [:e | e realClass isJavascriptCode]]						ifFalse: [implementors reject: [:e | e realClass isJavascriptCode]])						].	^implementors</body></methods><methods><class-id>Refactory.Browser.ChangeMethodNameRefactoring</class-id> <category>transforming</category><body package="AppeXTools">isJavascriptCode	^class realClass isJavascriptCode</body><body package="AppeXTools">javascriptRenameImplementors"	Based on the Smalltalk implementation of #renameImplementors with a slight change in accessing the parse tree."	self implementors do: 			[:each | 			| parseTree |			"The next line is different from #renameImplementors"			parseTree := each realClass parseTreeFor: oldSelector.			parseTree isNil 				ifTrue: [self refactoringError: (#CouldNotParseSourceCode &lt;&lt; #browser &gt;&gt; 'Could not parse source code.')].			self implementorsCanBePrimitives 				ifFalse: 					[parseTree isPrimitive 						ifTrue: 							[self refactoringError: ((#x1p1sIsPrimitive &lt;&lt; #browser &gt;&gt; '&lt;1p&gt;''s implementation of #&lt;2s&gt; is a primitive') 										expandMacrosWith: each										with: oldSelector)]].			self modifyImplementorParseTree: parseTree in: each.			(each methodFor: oldSelector) compileTree: parseTree]</body><body package="AppeXTools">javascriptRenameMessageSends	(self model allReferencesTo: oldSelector) do: 			[:eRBMethod |			| parseTree |			eRBMethod parseTree isNil				ifTrue: 					["parseTree will be nil for only(?) Javascript methods"					parseTree := eRBMethod modelClass realClass								parseTreeFor: eRBMethod selector.					parseTree						renameMessageSends: oldSelector						newSelector: newSelector						andArguments: #().					eRBMethod compileTree: parseTree]].</body><body package="AppeXTools">transform	"If my class is a Javascript class, I have to use a different implementation to rename	implementors and message sends."		self isJavascriptCode		ifTrue: [			self javascriptRenameImplementors.			self javascriptRenameMessageSends ]		ifFalse: [						self renameImplementors.			self renameMessageSends		].	self removeRenamedImplementors</body></methods><methods><class-id>AppeX.JavascriptCode class</class-id> <category>browserUI</category><body package="AppeXTools">createSubclassResponsibilityStubsFor: aBrowserNavigator	| methods |	methods := aBrowserNavigator subclassResponsibilityMethodsIn: self.	methods isEmpty ifTrue: [^self].	methods do:		[:each |		aBrowserNavigator performChange: 			(Refactory.Browser.AddMethodChange				compile: (self subclassResponsibilityImplementationStubFor: each in: self)				in: self				classified: each protocol)]</body><body package="AppeXTools">finishCreatingClassFrom: aCreateClassDialog for: aBrowserNavigator	aCreateClassDialog shouldDefineSubclassResponsibilities ifTrue:		[self createSubclassResponsibilityStubsFor: aBrowserNavigator.		aBrowserNavigator createSubclassResponsibilityStubsInNewClass: self class].</body></methods><methods><class-id>AppeX.JavascriptCode class</class-id> <category>RefactoringBrowser</category><body package="AppeXTools">parseTreeFor: aSymbol 	| aParser |		aParser := JavascriptParser parseMethodWithErrors: (self sourceCodeAt: aSymbol).	aParser selector: aSymbol.	^aParser</body></methods><methods><class-id>AppeX.JavascriptCode class</class-id> <category>compiling</category><body package="AppeXTools">sourceCodeTemplate	"Answer an expression to be edited and evaluated in order to	define methods in this class."	^ 'a_javascript_function_name(arguments){// Javascript code goes here}'</body></methods><methods><class-id>AppeX.JavascriptCode class</class-id> <category>browserUI</category><body package="AppeXTools">subclassResponsibilityImplementationStubFor: aMethodDefinition in: aClass	| source pattern comment errorText |	source := aMethodDefinition sourceCode.	pattern := source copyFrom: 1 to: ((source indexOf: ${) min: source size).	"comment := #SubclassResponsibilityStubComment &lt;&lt; #browser &gt;&gt; ' *** This method was defined by &lt;1p&gt; as a subclass responsibility.&lt;n&gt;&lt;t&gt;Replace its body with a proper implementation. *** ' "	comment := ' *** This method was defined by &lt;1p&gt; as a subclass responsibility.&lt;n&gt;&lt;t&gt;// Replace its body with a proper implementation. *** '		expandMacrosWith: aMethodDefinition implementingClass.	errorText := #SubclassResponsibilityStubNotReimplemented &lt;&lt; #browser &gt;&gt; 'Subclass responsibility stub not reimplemented'.	^'&lt;1s&gt;&lt;n&gt;&lt;t&gt;//&lt;2s&gt;&lt;n&gt;&lt;n&gt;&lt;t&gt;this.debug(''&lt;3s&gt;'');&lt;n&gt;}'		expandMacrosWith: pattern		with: comment		with: errorText</body></methods><methods><class-id>Refactory.Browser.SourceCodeTheme class</class-id> <category>schemes</category><body package="AppeXTools">defaultChromeColors^#(	16r000000 16r202020 16r303030 16r505050  	"shades of grey"		16rb0b0b0 16rd0d0d0 16re0e0e0 16rff00ff		"fuschia"		16r007400 16r1c00cf 16rba6e30 16rc41a16      "green blue orange red"		16r4b0082 16r2e0854 16rbc0dac 16r7d26cd)    	"indigosvg indigo purple purple3"</body></methods><methods><class-id>Refactory.Browser.SourceCodeTheme class</class-id> <category>accessing</category><body package="AppeXTools">javascriptThemes	"Return instances of the receiver for all javascriptTheme definitions."		^(Pragma allNamed: #javascriptTheme in: self class) collect: [:pragma |		(self perform: pragma selector)			source: (MessageSend receiver: pragma methodClass selector: pragma selector);			yourself]</body></methods><methods><class-id>Refactory.Browser.SourceCodeTheme class</class-id> <category>templates</category><body package="AppeXTools">light16Chrome: hexcodes16 default: defaultStyle	"Return a set of document styles for standard style selectors templated off of a chrome colour scheme of 16 colours, arranged to create a 'light' looking theme mimicking the Chrome browser's default JavaScript highlighting.  This style strikes a balance between keeping the JavaScript highlighting close to the Chrome browser's default JavaScript highlighting, and in keeping the Javascript highlighting close to a reasonable Smalltalk hightlighing scheme.  For example, it is reasonable to highlight local variables in Smalltalk, and therefore reasonable to give identical highlighting to temporary variables in javascript (even though temporary javascript variables are not highlighted by default in the Chrome browser)."	| colors color default  aDictionary  fuschia green blue orange red indigo purple purple3 black |	colors := hexcodes16 collect: [:each | self hexColorValue: each].	(default := defaultStyle copy)		"backgroundColor: (colors at: 8);" "this would give a light grey background"		color: (colors at: 3);		annotationBackgroundColor: (ColorValue hue: (colors at: 8) hue saturation: (colors at: 8) saturation brightness: (colors at: 8) brightness / 1.1).	color := [:index | default copy color: (colors at: index + 1); intern].  	"keeping index + 1 for consistency with previous templates"	black := color value: 0.	fuschia := color value: 7.	green := color value: 8.	blue := color value: 9.	orange := color value: 10.	red := color value: 11.	indigo := color value: 13.	purple := color value: 14.	purple3 := color value: 15.	aDictionary := Dictionary new.	aDictionary		at: #(comment) put: green;  							"javascript  '//' quoted, smalltalk double quoted text"		at: #(string) put: red; 									"string literal"		at: #(constant numeric ) put: blue; 						"number"		at: #(reservedword javascript) put: purple; 				"javascript return, if, etc."		at: #(dotidentifier javascript) put: black; 					"javascript property, e.g. this.whatever or this.whatever()"		at: #(entity name function javascript) put: black; 			"javascript function declaration e.g. install(){}"		at: #(meta selector) put: purple; 						"javascript 'var'"		at: #(variable language this) put: purple;   				"javascript 'this'" 		at: #(variable language self smalltalk) put: purple;  			"smalltalk 'self'"		at: #(variable language super smalltalk) put: purple; 		"smalltalk 'super'"		at: #(keyword return smalltalk) put: purple;				"smalltalk ^"		at: #(entity name class) put: orange; 					"smalltalk class"		at: #(constant symbol) put: red;							"smalltalk symbol"		at: #(variable temporary javascript) put: purple3;			"javascript local variable"		at: #(variable temporary smalltalk) put: purple3;			"smalltalk local variable"		at: #(variable parameter temporary smalltalk) put: purple3; 	"smalltalk local variable declaration"		at: #(variable) put: indigo;								"smalltalk and javascript parameter"		at: #(keyword missing) put: (black copy adornment: #dashedUnderline; intern);		at: #(invalid error) put: self defaultErrorStyle;		at: #(invalid error javascript) put: (self defaultStyle copy adornmentColor: ColorValue red; adornment: #underline; intern);		at: #(invalid warning) put: self defaultWarningStyle;		at: #(markup breakpoint) put: self defaultBreakpointStyle;		at: #(markup breakpoint disabled) put: self defaultDisabledBreakpointStyle;		at: #(marker) put: fuschia.								"test marker"		"Below are notes for overriding style specifications aimed at a more colorful Smalltalk highlighting"		"at: #(variable temporary javascript) put: (color value: 1);		at: #(entity name function javascript) put: (color value: 1);				at: #(variable parameter function javascript) put: (color value: 1);		at: #(variable javascript) put: (color value: 1);		at: #(constant boolean javascript) put: (color value: 1)."        	^aDictionary</body></methods><methods><class-id>AppeX.JavascriptLibrary</class-id> <category>printing</category><body package="AppeXTools">printOn: aStream		aStream nextPutAll: ' ', self name</body></methods><methods><class-id>Refactory.Browser.SourceCodeEditor</class-id> <category>initialize-release</category><body package="AppeXTools">defaultTheme	self parserClass = AppeX.JavascriptParser ifTrue: [^AppeX.JavascriptParserActor sourceCodeThemeForEditor: self].	^self class defaultTheme</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>menus</category><body package="AppeXTools">appexAction	"	If the currently selected method includes an AppeX action pragma, answer the pragma.	Otherwise, answer nil.	"	| class |	self definition ifNil: [ ^ nil ].	self definition isForSharedVariable ifTrue: [ ^ nil ].	class := self definition method mclass instanceBehavior.	"Do not allow generation for Application class itself, only subclasses"	class == AppeX.Application ifTrue: [ ^ nil ].	(class includesBehavior: AppeX.Application) ifFalse: [ ^ nil ].	^(Pragma allInMethod: self definition method)		detect: [:each |			class includesAction: each in: class requestActions]		ifNone: [nil]</body><body package="AppeXTools">generateCatalog		|  anApplicationClass classCollection|		classCollection := self nonMetaClasses.		anApplicationClass := classCollection detect: [:eClass | eClass includesBehavior: AppeX.Application] ifNone: [nil].	anApplicationClass isNil		ifTrue: [			AppeX.Application generateUserMessageCatalogForClasses: classCollection.			^self			].	anApplicationClass generateUserMessageCatalog.</body></methods><methods><class-id>Refactory.Browser.RBMethod</class-id> <category>testing</category><body package="AppeXTools">refersToSymbol: aSymbol 	| searcher |		(LanguageServices default languageForClass: class realItem ifAbsent: [#unknown]) == #javascript		ifTrue: [			"this is a javascript method"			^(class realItem whichSelectorsReferTo: aSymbol) includes: self selector].	searcher := ParseTreeSearcher new.	searcher		matches: aSymbol printString do: [:node :answer | true];		matches: '`#literal'			do: [:node :answer | answer or: [self literal: node value containsReferenceTo: aSymbol]].	(RBScanner isSelector: aSymbol) 		ifTrue: 			[searcher 				matches: '`@object ' , (ParseTreeSearcher buildSelectorString: aSymbol)				do: [:node :answer | true]].	^searcher executeTree: self parseTree initialAnswer: false</body></methods><methods><class-id>AppeX.Application class</class-id> <category>accessing</category><body package="AppeX-JSFile-Support">useImageCode				self codeComposer: JavascriptComposer.		JSFileMonitor stop</body></methods><methods><class-id>AppeX.JavascriptCode class</class-id> <category>javascript generating</category><body package="AppeX-Minification">cacheAllMinifiedCode	JavascriptCode allSubclassesDo: [ :cl | cl cacheMinifiedCode ]</body><body package="AppeX-Minification">cacheMinifiedCode	codeCache := (JavascriptMinifyingWriter  writeJavascriptWith: self ) contents</body></methods><methods><class-id>AppeX.JavascriptCode class</class-id> <category>testing</category><body package="AppeX-Minification">canMinifyFunctionName	^ true</body></methods><methods><class-id>PEG2.ParserActor class</class-id> <category>pragmas</category><body package="PEGParser">pragmas	&lt;pragmas: #instance&gt;	^#( action: action:arguments: )</body></methods><methods><class-id>AppeX.JavascriptReferenceFinder</class-id> <category>rules</category><body package="AppeXTools">DotIdentifier: identifierName	&lt;action: 'DotIdentifier' arguments: #( 2 )&gt;	sends add: (Array with: identifierName asSymbol with: start + 1 with: stop).	^ Array with: $. with: identifierName</body><body package="AppeXTools">Identifier: identifier	&lt;action: 'Identifier' arguments: #( 2 )&gt; 		(targetClass inheritsFrom: JavascriptCode)		ifFalse: [			sends add: (Array with: identifier asSymbol with: start + 1 with: stop).		].	^ identifier</body><body package="AppeXTools">IdentifierName: first rest: rest	&lt;action: 'IdentifierName' arguments: #( 1 2 )&gt; 	| stream |	stream := (String new: rest size + 1) writeStream.	stream		nextPut: first;		nextPutAll: rest.	^ stream contents</body><body package="AppeXTools">IdentifierStart: anObject	&lt;action: 'IdentifierStart'&gt;	((anObject isKindOf: Collection) and: [ anObject first = '\' ]) ifTrue: [		"This should be a unicode character. "		^ anObject last ].	" Otherwise, anObject should be a character. Return it. "	^ anObject</body><body package="AppeXTools">StringLiteral: collection	&lt;action: 'StringLiteral' arguments: #( 2 )&gt; 	| string |	collection ifNil: [ ^ collection ].	string := String withAll: (collection collect: [ :each |		| character |		character := each at: 2.		character class = Character ifFalse: [ ^ collection ].		(character isLetter			or: [ character isDigit			or: [ '#-_/' includes: character ]]) ifTrue: [ character ] ifFalse: [ ^ collection ]]).	sends add: (Array with: string asSymbol with: start + 1 with: stop).	^ collection</body><body package="AppeXTools">UnicodeEscapeSequence: firstHex second: secondHex third: thirdHex fourth: fourthHex	&lt;action: 'UnicodeEscapeSequence' arguments: #( 2 3 4 5 )&gt;	| stream |	stream := (String with: firstHex with: secondHex with: thirdHex with: fourthHex) readStream.	^ Character value: (Integer readFrom: stream radix: 16)</body></methods><methods><class-id>AppeX.JavascriptMinifyingActor</class-id> <category>actions</category><body package="AppeX-Minification">acceptComment: object	&lt;action: 'Comment'&gt;	self recordCommentPosition</body><body package="AppeX-Minification">acceptStringLiteral: object	&lt;action: 'StringLiteral'&gt;	self recordStringLiteralPosition</body></methods><methods><class-id>AppeX.JavascriptMethodRenameActor</class-id> <category>actions</category><body package="AppeXTools">acceptFunctionDeclarationIdentifier: object	&lt;action: 'FunctionDeclarationIdentifier'&gt;		self isRenamingMethod ifTrue: [		self replaceOldSelectorWithNewSelector.	]</body><body package="AppeXTools">acceptIdentifierName: object	&lt;action: 'IdentifierName'&gt;		(self isRenamingMessageSends and: [object asString = self oldSelector asString])  ifTrue: [		self replaceOldSelectorWithNewSelector.		].</body></methods><methods><class-id>AppeX.JavascriptParserActor</class-id> <category>actions</category><body package="AppeXTools">acceptBooleanLiteral: object	&lt;action: 'BooleanLiteral'&gt;	self apply: #(constant boolean javascript)</body><body package="AppeXTools">acceptCloseBlock: object	&lt;action: 'CloseBlock'&gt;		self currentScopeType = #block ifFalse: [ ^ self ].	self recordNode: object.	self popScope.	( #( #do #for #while #with ) includes: self currentScopeType) ifTrue: [ self popScope ]</body><body package="AppeXTools">acceptCloseFunction: object	&lt;action: 'CloseFunction'&gt;		self currentScopeType = #function ifFalse: [ ^ self ].	self recordNode: object.	self popScope</body><body package="AppeXTools">acceptComment: object	&lt;action: 'Comment'&gt;	self apply: #(comment javascript)</body><body package="AppeXTools">acceptDO: object	&lt;action: 'DO'&gt;		self isNotFinishedParsingIdentifier ifTrue: [^self].	self recordNode: object.	self pushScope: #do</body><body package="AppeXTools">acceptDotIdentifier: object	&lt;action: 'DotIdentifier'&gt;	self apply: #(dotidentifier javascript)</body><body package="AppeXTools">acceptEndOfStatement: object	&lt;action: 'EndOfStatement'&gt;		self currentScopeType = #while ifTrue: [		self popScope ]</body><body package="AppeXTools">acceptFOR: object	&lt;action: 'FOR'&gt;	self recordNode: object.	"self pushScope: #for"</body><body package="AppeXTools">acceptForClause: object	&lt;action: 'ForClause'&gt;	"do not pushScope for just FOR, since it will push for forEach"	self pushScope: #for</body><body package="AppeXTools">acceptFormalParameterName: object	&lt;action: 'FormalParameterName'&gt;	self currentParameters add: object.	self apply: #(variable parameter function javascript).</body><body package="AppeXTools">acceptFunctionDeclarationIdentifier: object	&lt;action: 'FunctionDeclarationIdentifier'&gt;		self apply: #(entity name function javascript )</body><body package="AppeXTools">acceptIF: object	&lt;action: 'IF'&gt;	self apply: #(reservedword javascript)</body><body package="AppeXTools">acceptIdentifierName: object	&lt;action: 'IdentifierName'&gt;	(self currentParameters includes: object) ifTrue: [		^self apply: #(variable parameter function javascript) ].	(self currentVariables includes: object) ifTrue: [		^self apply: #(variable temporary javascript) ].	self apply: #(entity name function javascript).</body><body package="AppeXTools">acceptKeyword: object	&lt;action: 'Keyword'&gt;	self apply: #(reservedword javascript)</body><body package="AppeXTools">acceptNullLiteral: object	&lt;action: 'NullLiteral'&gt;	self recordNode: object.	self apply: #(constant language nil javascript)</body><body package="AppeXTools">acceptNumericLiteral: object	&lt;action: 'NumericLiteral'&gt;	self apply: #(constant numeric javascript)</body><body package="AppeXTools">acceptOpenBlock: object	&lt;action: 'OpenBlock'&gt;		self recordNode: object.	self pushScope: #block</body><body package="AppeXTools">acceptOpenFunction: object	&lt;action: 'OpenFunction'&gt;		self recordNode: object.	self pushScope: #function</body><body package="AppeXTools">acceptRETURN: object	&lt;action: 'RETURN'&gt;	self apply: #(reservedword javascript)</body><body package="AppeXTools">acceptSEMICOLON: object	&lt;action: 'SEMICOLON'&gt;	self apply: #(punctuation endOfStatement  )</body><body package="AppeXTools">acceptSWITCH: object	&lt;action: 'SWITCH'&gt;	self isNotFinishedParsingIdentifier ifTrue: [^self].	self recordNode: object.	self pushScope: #switch</body><body package="AppeXTools">acceptStringLiteral: object	&lt;action: 'StringLiteral'&gt;	self apply: #(string javascript)</body><body package="AppeXTools">acceptTHIS: object	&lt;action: 'THIS'&gt;	self recordNode: object.	self apply: #(variable language this javascript)</body><body package="AppeXTools">acceptVAR: object	&lt;action: 'VAR'&gt;	self recordNode: object.	self apply: #(meta selector javascript)</body><body package="AppeXTools">acceptVariableIdentifier: object	&lt;action: 'VariableIdentifier'&gt;	self currentVariables add: object.	self apply: #(variable temporary javascript).</body><body package="AppeXTools">acceptWHILE: object	&lt;action: 'WHILE'&gt;	self isNotFinishedParsingIdentifier ifTrue: [^self].	self recordNode: object.	self pushScope: #while</body><body package="AppeXTools">acceptWITH: object	&lt;action: 'WITH'&gt;	self isNotFinishedParsingIdentifier ifTrue: [^self].	self recordNode: object.	self pushScope: #with</body></methods><methods><class-id>AppeX.JavascriptParserActor</class-id> <category>actions - errors</category><body package="AppeXTools">acceptCloseBlockError: object	&lt;action: 'CloseBlockError'&gt;	self applyInvalidJavascriptError</body><body package="AppeXTools">acceptCloseFunctionError: object	&lt;action: 'CloseFunctionError'&gt;	self applyInvalidJavascriptError</body><body package="AppeXTools">acceptCloseListError: object	&lt;action: 'CloseListError'&gt;	self applyInvalidJavascriptError</body><body package="AppeXTools">acceptForClauseError: object	&lt;action: 'ForClauseError'&gt;	self applyInvalidJavascriptError</body><body package="AppeXTools">acceptNoStatementError: object	&lt;action: 'NoStatementError'&gt;	self applyInvalidJavascriptError</body><body package="AppeXTools">acceptObjectLiteralError: object	&lt;action: 'ObjectLiteralError'&gt;	self applyInvalidJavascriptError</body><body package="AppeXTools">acceptOpenFunctionError: object	&lt;action: 'OpenFunctionError'&gt;	self applyInvalidJavascriptError</body><body package="AppeXTools">acceptOpenListError: object	&lt;action: 'OpenListError'&gt;	self applyInvalidJavascriptError</body><body package="AppeXTools">acceptProgramError: object	&lt;action: 'ProgramError'&gt;	self applyInvalidJavascriptError</body><body package="AppeXTools">acceptWhileClauseError: object	&lt;action: 'WhileClauseError'&gt;	self applyInvalidJavascriptError</body></methods><methods><class-id>AppeX.JSFileParserActor</class-id> <category>actions</category><body package="AppeX-JSFile-Support">acceptEndOfStatement: object	&lt;action: 'EndOfStatement'&gt;		self currentIdentifiers removeAll.	super acceptEndOfStatement: object</body><body package="AppeX-JSFile-Support">acceptFunctionDeclaration: object	&lt;action: 'FunctionDeclaration'&gt;	"accept a declaration that is NOT a part of on assignement, i.e. accept:	function myFunction () {}	as opposed to:	aFunction = function myFunction () {};	This method is necessary for parsing the functions for non-closure GenericJavascript, e.g. for AppeX.HelloScript	"	| aCollection aDocument className aClass numIdentifiers methodName methodSource classNameOrAlias startCodeIndex firstIdentifiers aReference |	"don't care about deep function declarations (within a method)"	scope size &gt; 2 ifTrue: [^self].		numIdentifiers := self currentIdentifiers size.		(numIdentifiers &gt; 0) ifTrue:  [methodName := self currentIdentifiers last string].	firstIdentifiers := scope first at: #identifiers.	classNameOrAlias :=  firstIdentifiers first string.	className := classNameOrAlias.	(2 to: firstIdentifiers size - 1) do: [:idx |		className := className, '.', (firstIdentifiers at: idx)					].		aReference := className asSymbol asQualifiedReference.	aReference bindingOrNil isNil 		ifTrue: [			self currentIdentifiers removeAll.			self currentGenericJavascriptClass isNil 				ifTrue: [^self] 				ifFalse: [					aClass := self currentGenericJavascriptClass.					className := aClass fullName.				].		]		ifFalse: [aClass := aReference value].	methodSource := aClass sourceForJsFunction: methodName asSymbol.	startCodeIndex := (object indexOfSubCollection: 'function' startingAt: 1) + 'function' size + 1.	aDocument := (object copyFrom: startCodeIndex to: object size) trimBlanks.	aDocument string =  methodSource 		ifFalse: [			aCollection := self classNameSourceStringsLookup at: className ifAbsentPut: [OrderedCollection new].			aCollection add: aDocument.		].	self currentIdentifiers removeAll.</body><body package="AppeX-JSFile-Support">acceptFunctionExpression: object	&lt;action: 'FunctionExpression'&gt;		"don't care about deep assignments or binds (within a method)"	scope size &gt; 2 ifTrue: [^self].	"If no identifiers, then this is an anonymous function (probably getting assigned to a variable).  Not interested in anonymous functions."	"Also not interested in an identifier for a function that is not assigned as the property of an Object (i.e. the function is a property of the global object). "	self currentIdentifiers size &lt; 2 ifTrue: [^self].	"if this is not an assignment, bind, or define expression, return"	self isAssignmentExpression | self isBindExpression		| self isDefineExpression ifFalse: [^self].	self checkToAddSource.	self currentIdentifiers removeAll</body><body package="AppeX-JSFile-Support">acceptIdentifierName: object	&lt;action: 'IdentifierName'&gt;	(self currentParameters includes: object) ifTrue: [		^self apply: #(variable parameter function javascript) ].	(self currentVariables includes: object) ifTrue: [		^self apply: #(variable temporary javascript) ].		self currentIdentifiers add: object.	self apply: #(entity name function javascript).</body><body package="AppeX-JSFile-Support">acceptSingleLineComment: aCommentDocument	&lt;action: 'SingleLineComment'&gt;		"Check to update the initialize functions of GenericJavascript subclasses.	Check to begin checking to update the 'loose functions' of GenericJavascript subclasses, the actual check to update will happen in acceptFunction:"		| aFullClassName aReference startCodeIndex endCodeIndex methodName methodSource  aCollection aClass methodDocument aReferenceString |	"stop attaching functions to the GenericJavascript subclass as soon as the start initialize marker is reached."	(aCommentDocument beginsWith: AppeX.JavascriptWriter.StartInitializeString) ifTrue: [^self currentGenericJavascriptClass: nil].	"also stop attaching functions to the GenericJavascript subclass stop contents marker is reached (this would only be needed if there was no StartInitialize marker.)"	(aCommentDocument beginsWith: AppeX.JavascriptWriter.EndContentsString) ifTrue: [^self currentGenericJavascriptClass: nil].	"only check the initialize code and set flag to begin checking to update loose functions when the start contents marker is reached"	(aCommentDocument beginsWith: AppeX.JavascriptWriter.StartContentsString) not ifTrue: [^self].	"the comment will end with the fully qualified reference printString, e.g. #{AppeX.HelloScript}"	aReferenceString := aCommentDocument copyBetween: AppeX.JavascriptWriter.StartContentsString size and: aCommentDocument string size -1.	"extract the full class name from aReferenceString"	aFullClassName := aReferenceString copyFrom: 3 to: aReferenceString size - 2.	aReference := aFullClassName asQualifiedReference.	aReference bindingOrNil isNil ifTrue: [^self]. 	aClass := aReference value.	"record that we are currently parsing code for aClass"	self currentGenericJavascriptClass: aClass.		"From here down, extract the code for the initialize method from the document, and record it for updating in the image if necessary"	"the code for the initialize method lies between the start initialize comment and the end contents comment.  calculate the indexes. "	startCodeIndex := (document string indexOfSubCollection: AppeX.JavascriptWriter.StartInitializeString startingAt: 1) + AppeX.JavascriptWriter.StartInitializeString size + aReferenceString size.	endCodeIndex := (document string indexOfSubCollection: AppeX.JavascriptWriter.EndContentsString, aReferenceString startingAt: 1) -1.	"writeStartInitializeOfScriptWith: inserts a cr into the document that do not correspond to the Smalltalk methodSource, so 1 must be added to startCodeIndex"	"writeInitializationCodeWith: ends with writeCode:, which appends a cr to the document, which does not correspond to methodSource "	methodDocument := document copyFrom: startCodeIndex + 1 to: endCodeIndex - 1.	methodName := 'initialize'.	"Build a string in the same format as the initialize method source code"	methodDocument insertAt: 0 with: methodName, '() {'.	"add  the AppeX ending for a method source"	methodDocument insert: '}'.	methodSource := aClass sourceForJsFunction: methodName asSymbol.	methodDocument string = methodSource		ifFalse: [			aCollection := self classNameSourceStringsLookup at: aFullClassName ifAbsentPut: [OrderedCollection new].			aCollection add: methodDocument string.		].</body></methods><methods><class-id>PEG2.GrammarReferenceFinder</class-id> <category>terminals</category><body package="PEGParser">Reference: identifier	&lt;action: 'Reference' arguments: #( 1 )&gt;	^sends add: (Array with: identifier asSymbol with: start with: stop)</body></methods><methods><class-id>PEG2.GrammarReferenceFinder</class-id> <category>lexical</category><body package="PEGParser">Identifier: first rest: rest	&lt;action: 'Identifier' arguments: #( 1 2 )&gt;	| stream |	stream := (String new: rest size + 1) writeStream.	stream nextPut: first.	rest notEmpty ifTrue: [stream nextPutAll: rest].	^stream contents</body></methods><methods><class-id>AppeX.JavascriptVarMinifyingActor</class-id> <category>actions</category><body package="AppeX-Minification">acceptFormalParameterName: object	&lt;action: 'FormalParameterName'&gt;	self currentParameters add: object.	self recordPositionOfVariable: object</body><body package="AppeX-Minification">acceptIdentifierName: object	&lt;action: 'IdentifierName'&gt;	(self currentParameters includes: object) ifTrue: [		^self recordPositionOfVariable: object.	 ].	(self currentVariables includes: object) ifTrue: [		^self recordPositionOfVariable: object.	].</body><body package="AppeX-Minification">acceptPropertyName: object	&lt;action: 'PropertyName'&gt;		self recordPositionOfProperty: object.</body><body package="AppeX-Minification">acceptVariableIdentifier: object	&lt;action: 'VariableIdentifier'&gt;	self currentVariables add: object.	self recordPositionOfVariable: object</body></methods><methods><class-id>PEG2.ParserGenerator</class-id> <category>lexical</category><body package="PEGParser">Escape: backslash character: character hexes: hexes	&lt;action: 'Escape' arguments: #( 1 2 3 )&gt;	backslash = '\' ifTrue:		[character = $s ifTrue: [^Character space].		character = $t ifTrue: [^Character tab].		character = $n ifTrue: [^Character cr].		character = $r ifTrue: [^Character lf].		character = $x ifTrue: [^('16r', (String withAll: hexes)) asNumber asCharacter]].	^character</body><body package="PEGParser">Identifier: first rest: rest	&lt;action: 'Identifier' arguments: #( 1 2 )&gt;	| stream |	stream := (String new: rest size + 3) writeStream.	stream nextPut: $'.	stream nextPut: first.	rest notEmpty ifTrue: [stream nextPutAll: rest].	stream nextPut: $'.	^stream contents</body><body package="PEGParser">NumLiteral: digit rest: digits	&lt;action: 'NumLiteral' arguments: #( 1 2 )&gt;	| number |	number := String new writeStream.	number nextPut: digit.	digits isEmpty ifFalse: [number nextPutAll: digits].	^number contents</body><body package="PEGParser">RangeSet: first to: second	&lt;action: 'RangeSet' arguments: #( 2 4 )&gt;	second ifNil: [^(Interval from: first asInteger to: first asInteger) printString].	^(Interval from: first asInteger to: second asInteger) printString</body></methods><methods><class-id>PEG2.ParserGenerator</class-id> <category>cardinality</category><body package="PEGParser">Cardinality: cardinality	&lt;action: 'Cardinality' arguments: #( 3 )&gt;	^cardinality</body><body package="PEGParser">CardinalityLoop: test	&lt;action: 'CardinalityLoop'&gt;	^'(generator CardinalityLoop: ', test, ')'</body><body package="PEGParser">CardinalityLoopMin: min test: test	&lt;action: 'CardinalityLoopMin' arguments: #( 1 5 )&gt;	^'(generator CardinalityLoopMin: ', min, ' test: ', test, ')'</body><body package="PEGParser">CardinalityRange: min max: max	&lt;action: 'CardinalityRange' arguments: #( 1 5 )&gt;	^'(generator CardinalityRangeMin: ', min, ' max: ', max, ')'</body><body package="PEGParser">CardinalityRangeMin: min	&lt;action: 'CardinalityRangeMin'&gt;	^'(generator CardinalityRangeMin: ', min, ')'</body><body package="PEGParser">PLUS	&lt;action: 'PLUS' arguments: #()&gt;	^'generator PLUS'</body><body package="PEGParser">QUESTION	&lt;action: 'QUESTION' arguments: #()&gt;	^'generator QUESTION'</body><body package="PEGParser">STAR	&lt;action: 'STAR' arguments: #()&gt;	^'generator STAR'</body></methods><methods><class-id>PEG2.ParserGenerator</class-id> <category>structural</category><body package="PEGParser">Definition: identifier expression: expression	&lt;action: 'Definition' arguments: #( 2 6 )&gt;	^'(generator Definition: ', identifier, ' expression: ', expression, ')'</body><body package="PEGParser">Expression: first rest: rest	&lt;action: 'Expression' arguments: #( 1 2 )&gt;	rest isEmpty ifTrue: [^first].	^'(generator Expression: ', first, ' rest: ', (self collection: (rest collect: [:each | '(Array with: ''/'' with: #() with: ', each last, ')'])), ')'</body><body package="PEGParser">Grammar: definitions	&lt;action: 'Grammar' arguments: #( 1 )&gt;	| stream |	stream := String new writeStream.	stream		tab; nextPutAll: '| generator definitions |'; cr;		tab; nextPutAll: 'definitions := OrderedCollection new.'; cr;		tab; nextPutAll: 'generator := PEG.ParserParser new.'; cr.	definitions do: [:source | stream tab; nextPutAll: 'definitions add: '; nextPutAll: source; nextPutAll: '.'; cr].	stream tab; nextPutAll: '^generator Grammar: definitions'.	^stream contents</body><body package="PEGParser">Group: expression	&lt;action: 'Group' arguments: #( 3 )&gt;	^expression</body><body package="PEGParser">Node: primary modifier: modifier cardinality: cardinality	&lt;action: 'Node' arguments: #( 2 1 3 )&gt;	(modifier isNil and: [cardinality isNil]) ifTrue: [^primary].	^'(generator Node: ', primary,		' modifier: ', (modifier ifNil: ['nil'] ifNotNil: [modifier]),		' cardinality: ', (cardinality ifNil: ['nil'] ifNotNil: [cardinality]), ')'</body><body package="PEGParser">Sequence: nodes	&lt;action: 'Sequence'&gt;	nodes size = 1 ifTrue: [^nodes first].	^'(generator Sequence: ', (self collection: nodes), ')'</body></methods><methods><class-id>PEG2.ParserGenerator</class-id> <category>terminals</category><body package="PEGParser">DOT	&lt;action: 'DOT' arguments: #()&gt;	^'generator DOT'</body><body package="PEGParser">Literal: characters	&lt;action: 'Literal' arguments: #( 2 )&gt;	| stream |	stream := String new writeStream.	stream nextPutAll: '(generator Literal: '''.	characters do: [:each |		each = $' ifTrue: [stream nextPut: $'].		stream nextPut: each].	stream nextPutAll: ''')'.	^stream contents</body><body package="PEGParser">Range: excluding sets: sets	&lt;action: 'Range' arguments: #( 3 4 )&gt;	^'(generator Range: ', (excluding ifNil: ['nil'] ifNotNil: [excluding]), ' sets: ', (self collection: sets), ')'</body><body package="PEGParser">Reference: identifier	&lt;action: 'Reference' arguments: #( 1 )&gt;	^'(generator Reference: ', identifier, ')'</body></methods><methods><class-id>PEG2.ParserGenerator</class-id> <category>modifiers</category><body package="PEGParser">AND	&lt;action: 'AND' arguments: #()&gt;	^'generator AND'</body><body package="PEGParser">NOT	&lt;action: 'NOT' arguments: #()&gt;	^'generator NOT'</body></methods><methods><class-id>PEG2.ParserParser</class-id> <category>lexical</category><body package="PEGParser">Escape: backslash character: character hexes: hexes	&lt;action: 'Escape' arguments: #( 1 2 3 )&gt;	backslash = '\' ifTrue:		[character = $s ifTrue: [^Character space].		character = $t ifTrue: [^Character tab].		character = $n ifTrue: [^Character cr].		character = $r ifTrue: [^Character lf].		character = $x ifTrue: [^('16r', (String withAll: hexes)) asNumber asCharacter]].	^character</body><body package="PEGParser">Identifier: first rest: rest	&lt;action: 'Identifier' arguments: #( 1 2 )&gt;	| stream |	stream := (String new: rest size + 1) writeStream.	stream nextPut: first.	rest notEmpty ifTrue: [stream nextPutAll: rest].	^stream contents</body><body package="PEGParser">NumLiteral: digit rest: digits	&lt;action: 'NumLiteral' arguments: #( 1 2 )&gt;	| number |	digit = 'Infinity' ifTrue: [^Infinity positive].	digit = $0 ifTrue: [^0].	number := String new writeStream.	number nextPut: digit.	digits isEmpty ifFalse: [number nextPutAll: digits].	^number contents asNumber</body><body package="PEGParser">RangeSet: first to: second	&lt;action: 'RangeSet' arguments: #( 2 4 )&gt;	second ifNil: [^Interval from: first asInteger to: first asInteger].	^Interval from: first asInteger to: second asInteger</body></methods><methods><class-id>PEG2.ParserParser</class-id> <category>cardinality</category><body package="PEGParser">Cardinality: cardinality	&lt;action: 'Cardinality' arguments: #( 3 )&gt;	^cardinality</body><body package="PEGParser">CardinalityLoop: test	&lt;action: 'CardinalityLoop'&gt;	^[:expression | [parser repeat: expression min: 0 test: test]]</body><body package="PEGParser">CardinalityLoopMin: min test: test	&lt;action: 'CardinalityLoopMin' arguments: #( 1 5 )&gt;	^[:expression | [parser repeat: expression min: min test: test]]</body><body package="PEGParser">CardinalityRange: min max: max	&lt;action: 'CardinalityRange' arguments: #( 1 5 )&gt;	| optional |	optional := max - min.	^(min isZero and: [max = 1])		ifTrue:	[ [:expression | [parser optional: expression]] ]		ifFalse:	[ [:expression | [parser repeat: expression min: min optional: optional]] ]</body><body package="PEGParser">CardinalityRangeMin: min	&lt;action: 'CardinalityRangeMin'&gt;	^[:expression | [parser repeat: expression min: min optional: 0]]</body><body package="PEGParser">PLUS	&lt;action: 'PLUS' arguments: #()&gt;	^[:expression | [parser repeat: expression min: 1 optional: Infinity positive]]</body><body package="PEGParser">QUESTION	&lt;action: 'QUESTION' arguments: #()&gt;	^[:expression | [parser optional: expression]]</body><body package="PEGParser">STAR	&lt;action: 'STAR' arguments: #()&gt;	^[:expression | [parser repeat: expression min: 0 optional: Infinity positive]]</body></methods><methods><class-id>PEG2.ParserParser</class-id> <category>terminals</category><body package="PEGParser">DOT	&lt;action: 'DOT' arguments: #()&gt;	^[parser anything]</body><body package="PEGParser">Literal: characters	&lt;action: 'Literal' arguments: #( 2 )&gt;	| literal |	literal := String withAll: characters.	parser bufferSize: literal size.	^useCaseInsensitive		ifTrue:	[[parser caseInsensitiveliteral: literal]]		ifFalse:	[[parser literal: literal]]</body><body package="PEGParser">Range: excluding sets: sets	&lt;action: 'Range' arguments: #( 3 4 )&gt;	sets isEmpty ifTrue: [		^excluding			ifNil:	[self DOT]			ifNotNil:	[ [parser not: [parser anything]] ]].	^excluding		ifNil:	[ [parser including: sets] ]		ifNotNil:	[ [parser excluding: sets] ]</body><body package="PEGParser">Reference: identifier	&lt;action: 'Reference' arguments: #( 1 )&gt;	^references at: identifier ifAbsentPut: [Object new]</body></methods><methods><class-id>PEG2.ParserParser</class-id> <category>structural</category><body package="PEGParser">Definition: identifier expression: expression	&lt;action: 'Definition' arguments: #( 2 6 )&gt;	| cache |	useCache ifFalse: [ ^identifier -&gt; [parser definition: expression name: identifier] ].	parser caches add: (cache := Dictionary new).	^identifier -&gt; [parser definition: expression name: identifier cache: cache]</body><body package="PEGParser">Expression: first rest: rest	&lt;action: 'Expression' arguments: #( 1 2 )&gt;	| sequences |	rest isEmpty ifTrue: [^first].	sequences := (Array with: first), (rest collect: [:each | each last]).	^[parser any: sequences]</body><body package="PEGParser">Grammar: definitions	&lt;action: 'Grammar' arguments: #( 1 )&gt;	| defines |	defines := Dictionary new.	defines addAll: definitions.	references keysAndValuesDo: [:name :dummy | dummy become: (defines at: name ifAbsent: [dummy])].	parser grammar addAll: references.	defines keysAndValuesDo: [:name :definition | definition class == Object ifFalse: [parser grammar at: name put: definition]].	^parser</body><body package="PEGParser">Group: expression	&lt;action: 'Group' arguments: #( 3 )&gt;	^expression</body><body package="PEGParser">Node: primary modifier: modifier cardinality: cardinality	&lt;action: 'Node' arguments: #( 2 1 3 )&gt;	| expression |	expression := primary.	cardinality ifNotNil: [expression := cardinality value: expression].	modifier ifNotNil: [expression := modifier value: expression].	^expression</body><body package="PEGParser">Sequence: nodes	&lt;action: 'Sequence'&gt;	nodes size = 1 ifTrue: [^nodes first].	^[parser all: nodes]</body></methods><methods><class-id>PEG2.ParserParser</class-id> <category>modifiers</category><body package="PEGParser">AND	&lt;action: 'AND' arguments: #()&gt;	^[:expression | [parser explore: expression]]</body><body package="PEGParser">NOT	&lt;action: 'NOT' arguments: #()&gt;	^[:expression | [parser not: expression]]</body></methods><methods><class-id>AppeX.JavascriptUserMessageActor</class-id> <category>actions</category><body package="AppeXTools">acceptArguments: object	&lt;action: 'Arguments'&gt;	self isCollectingArguments ifTrue: [		"self startStopLookup  at: start put: object" "this would just give a string"		self startStopLookup  at: start put: self collectedArguments.		self collectedArguments: OrderedCollection new.		self isCollectingArguments: false.	].</body><body package="AppeXTools">acceptIdentifierName: object	&lt;action: 'IdentifierName'&gt;		object string = '_translate' ifTrue: [		self isCollectingArguments: true.		].</body><body package="AppeXTools">acceptStringLiteral: object	&lt;action: 'StringLiteral'&gt;		self isCollectingArguments ifTrue: [ | eStringNoQuotes |		eStringNoQuotes:= (object copyFrom: 2 to: object size - 1) string .			self collectedArguments add: eStringNoQuotes.	].</body></methods><methods><class-id>AppeX.JavascriptGrammar</class-id> <category>grammar</category><body package="AppeXTools">AdditiveExpression 			&lt;- MultiplicativeExpression (SS (PLUS / MINUS) SS MultiplicativeExpression)*</body><body package="AppeXTools">Alternative 					&lt;- (SS Term)*</body><body package="AppeXTools">ArgumentList 				&lt;- AssignmentExpression (SS COMMA SS AssignmentExpression)*</body><body package="AppeXTools">Arguments 					&lt;- OPEN SS (ArgumentList SS)? CLOSE</body><body package="AppeXTools">ArrayLiteral 					&lt;- OPENSQUARE SS ElementList? (COMMA Elision)? SS (COMMA SS)? CLOSESQUARE</body><body package="AppeXTools">Assertion 					&lt;- "^" / DOLLAR / BACKSLASH [bB]</body><body package="AppeXTools">AssignmentExpression 		&lt;- LeftHandSideExpression SS AssignmentOperator SS AssignmentExpression							/ ConditionalExpression</body><body package="AppeXTools">AssignmentExpressionNoIn 	&lt;- LeftHandSideExpression SS AssignmentOperator SS AssignmentExpressionNoIn							/ ConditionalExpressionNoIn</body><body package="AppeXTools">AssignmentOperator 			&lt;- EQUAL / "*=" / "/=" / "%=" / "+=" / "-=" / "&lt;&lt;=" / "&gt;&gt;=" / "&gt;&gt;&gt;=" / "&amp;=" / "^=" / "|="</body><body package="AppeXTools">Atom 						&lt;- PatternCharacter							/ DOT							/ BACKSLASH AtomEscape							/ CharacterClass							/ OPEN (QUESTION (COLON / EQUAL / EXCLAMATION))? Disjunction CLOSE</body><body package="AppeXTools">AtomEscape 				&lt;- DecimalEscape							/ CharacterEscape							/ CharacterClassEscape</body><body package="AppeXTools">BRACKET					&lt;- OPEN / OPENCURLY / OPENSQUARE / CLOSE / CLOSECURLY / CLOSESQUARE</body><body package="AppeXTools">BackslashSequence 			&lt;- BACKSLASH NonTerminator</body><body package="AppeXTools">BitwiseANDExpression 		&lt;- EqualityExpression (SS AMP SS EqualityExpression)*</body><body package="AppeXTools">BitwiseANDExpressionNoIn 	&lt;- EqualityExpressionNoIn (SS AMP SS EqualityExpressionNoIn)*</body><body package="AppeXTools">BitwiseORExpression 		&lt;- BitwiseXORExpression (SS VERTICALBAR SS BitwiseXORExpression)*</body><body package="AppeXTools">BitwiseORExpressionNoIn 	&lt;- BitwiseXORExpressionNoIn (SS VERTICALBAR SS BitwiseXORExpressionNoIn)*</body><body package="AppeXTools">BitwiseXORExpression 		&lt;- BitwiseANDExpression (SS "^" SS BitwiseANDExpression)*</body><body package="AppeXTools">BitwiseXORExpressionNoIn 	&lt;- BitwiseANDExpressionNoIn (SS "^" SS BitwiseANDExpressionNoIn)*</body><body package="AppeXTools">Block 						&lt;- OpenBlock SS (StatementList SS)? CloseBlock</body><body package="AppeXTools">BreakStatement 				&lt;- BREAK !IdentifierPart WSNT Identifier?</body><body package="AppeXTools">CallExpression 				&lt;- MemberExpression SS Arguments ( SS								(Arguments								/ OPENSQUARE SS Expression SS CLOSESQUARE								/ DotIdentifier) )*</body><body package="AppeXTools">CaseBlock 					&lt;- OPENCURLY SS (CaseClauses SS)? (DefaultClause SS (CaseClauses SS)?)? CLOSECURLY</body><body package="AppeXTools">CaseClause 					&lt;- CASE SS Expression SS COLON SS StatementList?</body><body package="AppeXTools">CaseClauses 				&lt;- CaseClause (SS CaseClause)*</body><body package="AppeXTools">Catch 						&lt;- CATCH SS OPEN SS Identifier SS CLOSE SS Block</body><body package="AppeXTools">CharacterClass 				&lt;- OPENSQUARE "^"? ClassRanges CLOSESQUARE</body><body package="AppeXTools">CharacterEscape 			&lt;- ControlEscape							/ "c" ControlLetter							/ HexEscapeSequence							/ UnicodeEscapeSequence							/ IdentityEscape</body><body package="AppeXTools">CharacterEscapeSequence 	&lt;- SingleEscapeCharacter							/ NonEscapeCharacter</body><body package="AppeXTools">ClassAtom 					&lt;- MINUS							/ ClassAtomNoDash</body><body package="AppeXTools">ClassAtomNoDash 			&lt;- !(BACKSLASH / CLOSESQUARE / MINUS) .							/ BACKSLASH ClassEscape</body><body package="AppeXTools">ClassEscape 				&lt;- DecimalEscape							/ [b]							/ CharacterEscape							/ CharacterClassEscape/* The following are not part of the ECMAScript grammar. They are added for clarity and simplicity of the above grammar rule definitions. */</body><body package="AppeXTools">ClassRanges 				&lt;- NonemptyClassRanges?</body><body package="AppeXTools">CloseBlock					&lt;- CLOSECURLY / CloseBlockError</body><body package="AppeXTools">CloseBlockError				&lt;- .{CLOSECURLY / EndOfSource}</body><body package="AppeXTools">CloseFunction				&lt;- CLOSECURLY / CloseFunctionError</body><body package="AppeXTools">CloseFunctionError			&lt;- .{CLOSECURLY / EndOfSource}</body><body package="AppeXTools">CloseList 					&lt;- CLOSE / CloseListError</body><body package="AppeXTools">CloseListError 				&lt;- .{CLOSE / EndOfSource}</body><body package="AppeXTools">Comment 					&lt;- MultiLineComment 							/ SingleLineComment</body><body package="AppeXTools">ConditionalExpression 		&lt;- LogicalORExpression (SS QUESTION SS AssignmentExpression SS COLON SS AssignmentExpression)?</body><body package="AppeXTools">ConditionalExpressionNoIn 	&lt;- LogicalORExpressionNoIn (SS QUESTION SS AssignmentExpressionNoIn SS COLON SS AssignmentExpressionNoIn)?</body><body package="AppeXTools">ContinueStatement 			&lt;- CONTINUE !IdentifierPart WSNT Identifier?</body><body package="AppeXTools">DecimalEscape 				&lt;- DecimalIntegerLiteral !DecimalDigit</body><body package="AppeXTools">DecimalIntegerLiteral 		&lt;- NonZeroDigit DecimalDigits?							/ [0]</body><body package="AppeXTools">DecimalLiteral 				&lt;- DecimalIntegerLiteral (DOT DecimalDigits?)? ExponentPart?							/ DOT DecimalDigits ExponentPart?							/ DecimalIntegerLiteral ExponentPart?</body><body package="AppeXTools">DefaultClause 				&lt;- DEFAULT SS COLON SS StatementList?</body><body package="AppeXTools">Disjunction 					&lt;- Alternative (SS VERTICALBAR SS Alternative)*</body><body package="AppeXTools">DoStatement					&lt;- DO StatementOrError WhileClause EndOfStatement</body><body package="AppeXTools">DotIdentifier		&lt;- DOT IdentifierName</body><body package="AppeXTools">DoubleStringCharacter 		&lt;- !(DOUBLEQUOTE / BACKSLASH / LineTerminator) .							/ BACKSLASH EscapeSequence							/ BACKSLASH LineTerminator</body><body package="AppeXTools">DoubleStringCharacters 		&lt;- DoubleStringCharacter+</body><body package="AppeXTools">ElementList 					&lt;- Elision? SS AssignmentExpression (COMMA Elision? SS AssignmentExpression)*</body><body package="AppeXTools">Elision 						&lt;- SS COMMA (SS COMMA)*</body><body package="AppeXTools">EmptyStatement 				&lt;- SEMICOLON SS</body><body package="AppeXTools">EndOfStatement 				&lt;- SS (EndOfSource / !CLOSECURLY SEMICOLON / &amp;CLOSECURLY SEMICOLON? )</body><body package="AppeXTools">EqualityExpression 			&lt;- RelationalExpression (SS ("===" / "!==" / "==" / "!=" ) SS RelationalExpression)*</body><body package="AppeXTools">EqualityExpressionNoIn 		&lt;- RelationalExpressionNoIn (SS ( "===" / "!===" / "==" / "!=" ) SS RelationalExpressionNoIn)*</body><body package="AppeXTools">EscapeCharacter 			&lt;- SingleEscapeCharacter							/ DecimalDigit							/ [xu]</body><body package="AppeXTools">EscapeSequence 			&lt;- CharacterEscapeSequence							/ HexEscapeSequence							/ UnicodeEscapeSequence							/ [0] !DecimalDigit</body><body package="AppeXTools">ExponentPart 				&lt;- ExponentIndicator SignedInteger</body><body package="AppeXTools">Expression 					&lt;- AssignmentExpression (SS COMMA SS AssignmentExpression)*</body><body package="AppeXTools">ExpressionNoIn 				&lt;- AssignmentExpressionNoIn (SS COMMA SS AssignmentExpressionNoIn)*/* Statements: */</body><body package="AppeXTools">ExpressionStatement 			&lt;- !(OPENCURLY / FunctionKeyword) Expression EndOfStatement</body><body package="AppeXTools">Finally 						&lt;- FINALLY SS Block/* Iteration statements */</body><body package="AppeXTools">ForClause					&lt;- FOR !IdentifierPart SS RestOfForClause</body><body package="AppeXTools">ForClauseError				&lt;- OPEN SS CLOSE / .{SEMICOLON / BRACKET / EndOfSource}</body><body package="AppeXTools">ForConditions				&lt;- ForConditionsVAR / ForConditionsLeft / ForConditionsNoIn</body><body package="AppeXTools">ForConditionsLeft			&lt;- LeftHandSideExpression SS IN SS Expression</body><body package="AppeXTools">ForConditionsNoIn			&lt;- ExpressionNoIn? SS SEMICOLON SS Expression? SS SEMICOLON SS Expression?								/* Functions and Programs */</body><body package="AppeXTools">ForConditionsVAR			&lt;- VarKeyword SS (								VariableDeclarationNoIn SS IN SS Expression								/ VariableDeclarationListNoIn SS SEMICOLON SS Expression? SS SEMICOLON SS Expression?)</body><body package="AppeXTools">ForStatement				&lt;- ForClause StatementOrError</body><body package="AppeXTools">FormalParameter 					&lt;- !(ReservedWord (WhiteSpace / Punctuator)) FormalParameterName</body><body package="AppeXTools">FormalParameterList 			&lt;- FormalParameter (SS COMMA SS FormalParameter)*</body><body package="AppeXTools">FormalParameterName 				&lt;- IdentifierStart IdentifierPart*</body><body package="AppeXTools">FunctionBody 				&lt;- SourceElements?</body><body package="AppeXTools">FunctionDeclaration 			&lt;- SS FunctionKeyword WhiteSpace+ Identifier SS FunctionDefinition</body><body package="AppeXTools">FunctionDeclarationIdentifier 					&lt;- !(ReservedWord (WhiteSpace / Punctuator)) IdentifierName</body><body package="AppeXTools">FunctionDefinition 			&lt;- SS OpenList SS FormalParameterList? SS CloseList SS OpenFunction SS FunctionBody SS CloseFunction</body><body package="AppeXTools">FunctionExpression 			&lt;- SS FunctionKeyword (WhiteSpace+ Identifier)? SS FunctionDefinition</body><body package="AppeXTools">FunctionKeyword 			&lt;- FUNCTION !IdentifierPart</body><body package="AppeXTools">FunctionSignature			&lt;- SS Identifier SS OpenList SS FormalParameterList? SS CloseList</body><body package="AppeXTools">FunctionSignatureBody		&lt;- SS FunctionDeclarationIdentifier SS FunctionDefinition</body><body package="AppeXTools">HexEscapeSequence 		&lt;- [x] HexDigit HexDigit</body><body package="AppeXTools">HexIntegerLiteral 			&lt;- [0] [xX] HexDigit+</body><body package="AppeXTools">Identifier 					&lt;- !(ReservedWord (WhiteSpace / Punctuator)) IdentifierName</body><body package="AppeXTools">IdentifierName 				&lt;- IdentifierStart IdentifierPart*</body><body package="AppeXTools">IdentifierPart 				&lt;- IdentifierStart							/ DecimalDigit</body><body package="AppeXTools">IdentifierStart 				&lt;- [A-Za-z$_]							/ BACKSLASH UnicodeEscapeSequence</body><body package="AppeXTools">IdentityEscape 				&lt;- !IdentifierPart .</body><body package="AppeXTools">IfStatement 					&lt;- IF SS OPEN SS Expression SS CLOSE SS Statement (SS ELSE SS Statement)?</body><body package="AppeXTools">Initialiser 					&lt;- EQUAL SS AssignmentExpression</body><body package="AppeXTools">InitialiserNoIn 				&lt;- EQUAL SS AssignmentExpressionNoIn</body><body package="AppeXTools">IterationStatement 			&lt;- DoStatement / WhileStatement / ForStatement</body><body package="AppeXTools">Keyword 					&lt;- RETURN / BREAK / CASE / CATCH / CONTINUE / DEFAULT / DELETE / DO							/ ELSE / FINALLY / FOR / FUNCTION / IF / IN / INSTANCEOF							/ NEW / SWITCH / THIS / THROW / TRY / TYPEOF							/ VAR / VOID / WHILE / WITH</body><body package="AppeXTools">LabelledStatement 			&lt;- Identifier SS COLON SS Statement</body><body package="AppeXTools">LeftHandSideExpression 		&lt;- CallExpression							/ NewExpression</body><body package="AppeXTools">LineTerminator 				&lt;- LF / CR</body><body package="AppeXTools">Literal 						&lt;- NullLiteral							/ BooleanLiteral							/ StringLiteral							/ NumericLiteral							/ RegularExpressionLiteral</body><body package="AppeXTools">LogicalANDExpression 		&lt;- BitwiseORExpression (SS "&amp;&amp;" SS BitwiseORExpression)*</body><body package="AppeXTools">LogicalANDExpressionNoIn 	&lt;- BitwiseORExpressionNoIn (SS "&amp;&amp;" SS BitwiseORExpressionNoIn)*</body><body package="AppeXTools">LogicalORExpression 		&lt;- LogicalANDExpression (SS "||" SS LogicalANDExpression)*</body><body package="AppeXTools">LogicalORExpressionNoIn 	&lt;- LogicalANDExpressionNoIn (LogicalORExpressionNoIn SS "||" SS LogicalANDExpressionNoIn)*</body><body package="AppeXTools">MemberExpression 			&lt;- (PrimaryExpression / FunctionExpression) (SS								(OPENSQUARE SS Expression SS CLOSESQUARE / DotIdentifier))*							/ NEW SS NewExpression							/ NEW SS MemberExpression SS Arguments</body><body package="AppeXTools">MultiplicativeExpression 		&lt;- UnaryExpression (SS (ASTERISK / FORWARDSLASH / PERCENT) SS UnaryExpression)*</body><body package="AppeXTools">NewExpression 				&lt;- MemberExpression							/ NEW SS NewExpression</body><body package="AppeXTools">NoStatementError			&lt;- .{EndOfSource / StartOfStatement}</body><body package="AppeXTools">NonEscapeCharacter 		&lt;- !(EscapeCharacter / LineTerminator) .</body><body package="AppeXTools">NonTerminator 				&lt;- !LineTerminator .</body><body package="AppeXTools">NonemptyClassRanges 		&lt;- ClassAtom (NonemptyClassRangesNoDash / MINUS ClassAtom ClassRanges)</body><body package="AppeXTools">NonemptyClassRangesNoDash 	&lt;- ClassAtom							/ ClassAtomNoDash (NonemptyClassRangesNoDash / MINUS ClassAtom ClassRanges)</body><body package="AppeXTools">NumericLiteral 				&lt;- DecimalLiteral							/ HexIntegerLiteral</body><body package="AppeXTools">ObjectLiteral 				&lt;- OPENCURLY SS PropertyNameAndValueList? (COMMA SS)? CLOSECURLY SS / ObjectLiteralError</body><body package="AppeXTools">ObjectLiteralError			&lt;- OPENCURLY .{CLOSECURLY}</body><body package="AppeXTools">OpenBlock					&lt;- OPENCURLY</body><body package="AppeXTools">OpenFunction 				&lt;- OPENCURLY / OpenFunctionError</body><body package="AppeXTools">OpenFunctionError 			&lt;- .{OPENCURLY / EndOfSource}</body><body package="AppeXTools">OpenList 					&lt;- OPEN / OpenListError</body><body package="AppeXTools">OpenListError 				&lt;- .{OPEN / EndOfSource}</body><body package="AppeXTools">Pattern 						&lt;- Disjunction</body><body package="AppeXTools">PostfixExpression 			&lt;- LeftHandSideExpression (WSNT ("++" / "--"))?</body><body package="AppeXTools">PrimaryExpression 			&lt;- ArrayLiteral							/ ObjectLiteral							/ OPEN SS Expression SS CLOSE							/ Identifier							/ Literal							/ THIS</body><body package="AppeXTools">Program 					&lt;- SourceElements SS EndOfSource / ProgramError</body><body package="AppeXTools">ProgramError 				&lt;- .{EndOfSource}</body><body package="AppeXTools">PropertyAssignment  &lt;- (PropertyName SS [:] SS PropertyValue SS)</body><body package="AppeXTools">PropertyName 				&lt;- Identifier							/ StringLiteral							/ NumericLiteral							/ ReservedWord</body><body package="AppeXTools">PropertyNameAndValueList 	&lt;-  PropertyAssignment (COMMA SS PropertyAssignment)*</body><body package="AppeXTools">PropertyValue				&lt;- AssignmentExpression (SS [,] SS PropertyNameAndValueList)?</body><body package="AppeXTools">Punctuator 					&lt;- "{" / "}" / "(" / ")" / "[" / "]" / "." / SEMICOLON / "," / "&lt;" / "&gt;" / "&lt;=" / "&gt;="							/ "==" / "!=" / "===" / "!==" / "+" / "-" / "*" / PERCENT / "++" / "--" / "&lt;&lt;" / "&gt;&gt;"							/ "&gt;&gt;&gt;" / AMP / VERTICALBAR / "^" / EXCLAMATION / TILDE / (AMP AMP) / "||" / QUESTION / COLON / EQUAL							/ "+=" / "-=" / "*=" / "%=" / "&lt;&lt;=" / "&gt;&gt;=" / "&gt;&gt;&gt;=" / "&amp;=" / "|=" / "^="</body><body package="AppeXTools">Quantifier 					&lt;- QuantifierPrefix QUESTION?</body><body package="AppeXTools">QuantifierPrefix 				&lt;- ASTERISK							/ PLUS							/ QUESTION							/ OPENCURLY SS DecimalDigits (SS COMMA (SS DecimalDigits)?)? SS CLOSECURLY</body><body package="AppeXTools">RegularExpressionBody 		&lt;- RegularExpressionFirstChar RegularExpressionChars</body><body package="AppeXTools">RegularExpressionChar 		&lt;- BackslashSequence							/ !(BACKSLASH / FORWARDSLASH) NonTerminator</body><body package="AppeXTools">RegularExpressionChars 		&lt;- RegularExpressionChar*</body><body package="AppeXTools">RegularExpressionFirstChar 	&lt;- BackslashSequence							/ !(ASTERISK / BACKSLASH / FORWARDSLASH) NonTerminator</body><body package="AppeXTools">RegularExpressionFlags 		&lt;- IdentifierPart*/* Number Conversions */</body><body package="AppeXTools">RegularExpressionLiteral 		&lt;- FORWARDSLASH RegularExpressionBody FORWARDSLASH RegularExpressionFlags</body><body package="AppeXTools">RelationalExpression 		&lt;- ShiftExpression (SS ("&lt;=" / "&gt;=" / "&lt;" / "&gt;" / INSTANCEOF / IN) SS ShiftExpression)*</body><body package="AppeXTools">RelationalExpressionNoIn 	&lt;- ShiftExpression (SS ("&lt;=" / "&gt;=" / "&lt;" / "&gt;" / INSTANCEOF ) SS ShiftExpression)*</body><body package="AppeXTools">ReservedWord 				&lt;- (BooleanLiteral							/ NullLiteral							/ Keyword) !IdentifierPart</body><body package="AppeXTools">RestOfForClause				&lt;- OPEN SS ForConditions SS CLOSE / ForClauseError</body><body package="AppeXTools">RestOfWhileClause			&lt;- OPEN SS Expression SS CLOSE / WhileClauseError</body><body package="AppeXTools">ReturnStatement 				&lt;- RETURN !IdentifierPart WSNT Expression?</body><body package="AppeXTools">SS 							&lt;- ([\s\t\x00000A\x00000B\x00000C\x00000D] / Comment)*</body><body package="AppeXTools">ShiftExpression 				&lt;- AdditiveExpression (SS ("&lt;&lt;" / "&gt;&gt;&gt;" / "&gt;&gt;" ) SS AdditiveExpression)*</body><body package="AppeXTools">SignedInteger 				&lt;- (PLUS / MINUS)? DecimalDigits</body><body package="AppeXTools">SingleStringCharacter 		&lt;- !(SINGLEQUOTE / BACKSLASH / LineTerminator) .							/ BACKSLASH EscapeSequence 							/ BACKSLASH  LineTerminator</body><body package="AppeXTools">SingleStringCharacters 		&lt;- SingleStringCharacter+</body><body package="AppeXTools">SourceElement 				&lt;- FunctionDeclaration / Statement/* Universal Resource Identifier Character Classes */</body><body package="AppeXTools">SourceElements 				&lt;- SourceElement+</body><body package="AppeXTools">StartOfStatement				&lt;- OPENCURLY / VarKeyword / FOR / DO / WITH / SWITCH / THROW / TRY / BRACKET / WHILE / IF / CONTINUE / BREAK / RETURN</body><body package="AppeXTools">Statement 					&lt;- SS !CLOSECURLY (Block							/ VariableStatement							/ EmptyStatement							/ IfStatement							/ IterationStatement							/ ContinueStatement							/ BreakStatement							/ ReturnStatement							/ WithStatement							/ LabelledStatement							/ SwitchStatement							/ ThrowStatement							/ ExpressionStatement							/ TryStatement)</body><body package="AppeXTools">StatementList 				&lt;- Statement+</body><body package="AppeXTools">StatementOrError				&lt;- Statement / NoStatementError</body><body package="AppeXTools">StrDecimalLiteral 			&lt;- (PLUS / MINUS)? StrUnsignedDecimalLiteral</body><body package="AppeXTools">StrNumericLiteral 			&lt;- StrDecimalLiteral							/ HexIntegerLiteral</body><body package="AppeXTools">StrUnsignedDecimalLiteral 	&lt;- INFINITY							/ DecimalDigits (DOT DecimalDigits)? ExponentPart?							/ DOT DecimalDigits ExponentPart?/* Expressions: */</body><body package="AppeXTools">StrWhiteSpace 				&lt;- StrWhiteSpaceChar StrWhiteSpace?/* This is according to EcmaScript grammar. NBSP, USP, LS &amp; PS - what are their definitions?StrWhiteSpaceChar 			&lt;- TAB / SPACE / NBSP / FF / VT / CR / LF / LS / PS / USP */</body><body package="AppeXTools">StrWhiteSpaceChar 			&lt;- TAB / SPACE  / FF / VT / CR / LF</body><body package="AppeXTools">StringLiteral 					&lt;- DOUBLEQUOTE DoubleStringCharacters? DOUBLEQUOTE							/ SINGLEQUOTE SingleStringCharacters? SINGLEQUOTE</body><body package="AppeXTools">StringNumericLiteral 			&lt;- StrWhiteSpace? (StrNumericLiteral StrWhiteSpace?)?</body><body package="AppeXTools">SwitchStatement 				&lt;- SWITCH SS OPEN SS Expression SS CLOSE SS CaseBlock</body><body package="AppeXTools">Term 						&lt;- Assertion / Atom Quantifier?</body><body package="AppeXTools">ThrowStatement 				&lt;- THROW WSNT Expression EndOfStatement</body><body package="AppeXTools">TryStatement 				&lt;- TRY SS Block SS (Catch SS Finally / Catch / Finally)</body><body package="AppeXTools">UnaryExpression 			&lt;- PostfixExpression							/ ( DELETE / VOID / TYPEOF / "++" / "--" / PLUS / MINUS / TILDE / EXCLAMATION ) SS UnaryExpression</body><body package="AppeXTools">UnicodeEscapeSequence 	&lt;- [u] HexDigit HexDigit HexDigit HexDigit</body><body package="AppeXTools">VarKeyword 			&lt;- VAR !IdentifierPart</body><body package="AppeXTools">VariableDeclaration 			&lt;- VariableIdentifier SS Initialiser?</body><body package="AppeXTools">VariableDeclarationList 		&lt;- VariableDeclaration (SS COMMA SS VariableDeclaration)*</body><body package="AppeXTools">VariableDeclarationListNoIn 	&lt;- VariableDeclarationNoIn (SS COMMA SS VariableDeclarationNoIn)*</body><body package="AppeXTools">VariableDeclarationNoIn 		&lt;- VariableIdentifier SS InitialiserNoIn?</body><body package="AppeXTools">VariableIdentifier 					&lt;- !(ReservedWord (WhiteSpace / Punctuator)) IdentifierName</body><body package="AppeXTools">VariableStatement 			&lt;- VarKeyword SS VariableDeclarationList EndOfStatement</body><body package="AppeXTools">WSNT 						&lt;- (!LineTerminator (WhiteSpace / Comment))*</body><body package="AppeXTools">WhileClause					&lt;- SS WHILE !IdentifierPart SS RestOfWhileClause</body><body package="AppeXTools">WhileClauseError			&lt;- OPEN SS CLOSE / .{BRACKET / EndOfSource}</body><body package="AppeXTools">WhileStatement				&lt;- WhileClause StatementOrError</body><body package="AppeXTools">WithStatement 				&lt;- WITH SS OPEN SS Expression SS CLOSE Statement</body><body package="AppeXTools">uri 							&lt;- uriCharacters?</body><body package="AppeXTools">uriCharacter 					&lt;- uriReserved							/ uriUnescaped							/ uriEscaped</body><body package="AppeXTools">uriCharacters 				&lt;- uriCharacter+</body><body package="AppeXTools">uriEscaped 					&lt;- PERCENT HexDigit HexDigit</body><body package="AppeXTools">uriMark 						&lt;- MINUS / UNDERSCORE / DOT / EXCLAMATION / TILDE / ASTERISK / SINGLEQUOTE / OPEN / CLOSE/* Regular Expressions: */</body><body package="AppeXTools">uriReserved 					&lt;- SEMICOLON / FORWARDSLASH / QUESTION / COLON / AT / AMP / EQUAL / PLUS / DOLLAR / COMMA</body><body package="AppeXTools">uriUnescaped 				&lt;- uriAlpha							/ DecimalDigit							/ uriMark</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - web</category><body package="AppeXTools">appexCacheMinifiedCommand	&lt;command: #webAppCacheMinifiedCode&gt;	^Command		label: (#WebAppCacheMinifiedCode &lt;&lt; #menus &gt;&gt; 'Cache Minified Code')		group: #launcher		bindings: #()</body><body package="AppeXTools">appexResetCacheCode	&lt;command: #webAppResetCacheCode&gt;	^Command		label: (#WebAppResetCodeCache &lt;&lt; #menus &gt;&gt; 'Reset Minified Code Cache')		group: #launcher		bindings: #()</body></methods><methods><class-id>Tools.ListIconLibrary class</class-id> <category>resources</category><body package="AppeXTools">javascript16x16	"UIMaskEditor new openOnClass: self andSelector: #javascript"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 6 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5075 4689 2087)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3276 3115 1830)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7644 6970 2537)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2441 2376 1670)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4272 4015 1991)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3019 2890 1766)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5428 5043 2184)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7387 6745 2473)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1670 1702 1541)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7548 6874 2505)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3758 3533 1895)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7612 6938 2537)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4272 3983 1959)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7677 7034 2537)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6841 6263 2409)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3469 3308 1863)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1638 1670 1541)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2216 2184 1638)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6070 5589 2280)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4721 4400 2055)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2376 2312 1670)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6167 5653 2280)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4304 4015 1991)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6745 6167 2376)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3726 3501 1895)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7227 6617 2473)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4882 4529 2087)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1606 1638 1541)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3533 3340 1863)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2601 2537 1702)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4529 4240 2023)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2666 2601 1734)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7580 6938 2505)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5621 5203 2184)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2858 2730 1734)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3758 3565 1895)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3854 3629 1895)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3340 3180 1830)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7709 7034 2537)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1991 1991 1606)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5846 5396 2248)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2569 2505 1702)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5942 5460 2248)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3501 3308 1863)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7291 6649 2473)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4593 4272 2023)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7516 6874 2505)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3726 3533 1895)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7677 7002 2537)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5332 4914 2152)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3469 3308 1830)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2537 2473 1702)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X^@BXWI@&lt;!I"X&amp;I"X&amp;I"X&amp;G100ECL2DQ$&amp;I"X&amp;I"X&amp;I!&lt;\K!,VCP\&amp;I"X&amp;I"X&amp;I"X_GBXJF2H(I"X&amp;I"X&amp;I"X&amp;G10&amp;@#D)F0X&amp;I"X&amp;I HNI!4\LB(0B0L+I"X&amp;I"XLI2LHD1TPAQ HKRX&amp;I"X&amp;K@PAG $&amp;D"&lt;%F"@&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I"X&amp;I @a'))</body><body package="AppeXTools">javascript16x16mask	"Tools.UIMaskEditor new openOnClass: self andSelector: #javascript16x16mask"	&lt;resource: #image&gt;	^(Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 31 255 0 0 63 255 0 0])</body></methods><methods><class-id>Refactory.Browser.LanguageServices</class-id> <category>javascript</category><body package="AppeXTools">javascriptCompilationErrorHandlerClass	&lt;language: #javascript category: #compilationErrorHandlerClass&gt;	^SourceCodeErrorHandler</body><body package="AppeXTools">javascriptCompilerClass	&lt;language: #javascript category: #compilerClass&gt;	^AppeX.JavascriptPegCompiler</body></methods><methods><class-id>Refactory.Browser.LanguageServices</class-id> <category>javascript - editor plugins</category><body package="AppeXTools">javascriptEditorAutocomplete	&lt;language: #javascript category: #editorPlugins priority: 1&gt;	^SmalltalkAutocomplete</body><body package="AppeXTools">javascriptEditorAutoIndent	&lt;language: #javascript category: #editorPlugins&gt;	^SmalltalkAutoIndent</body><body package="AppeXTools">javascriptEditorAutoquote	&lt;language: #javascript category: #editorPlugins&gt;	^SmalltalkAutoQuote</body></methods><methods><class-id>Refactory.Browser.LanguageServices</class-id> <category>javascript - editor decorations</category><body package="AppeXTools">javascriptEditorSyntaxHighlightDecoration	&lt;language: #javascript category: #editorDecorations priority: 1&gt;	^AppeX.JavascriptParserActor</body></methods><methods><class-id>Refactory.Browser.LanguageServices</class-id> <category>javascript</category><body package="AppeXTools">javascriptParserClass	&lt;language: #javascript category: #parserClass&gt;	^AppeX.JavascriptParser</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-webDev</category><body package="AppeXTools">appexRootDirectory	&lt;setting: #(webDev rootDirectory)  position: 20&gt;	^(DirectorySetting on: AppeX.Application aspect: #rootDirectory)		label: #AppeXRootDirectory &lt;&lt; #www &gt;&gt; 'Root Directory';		default: AppeX.Application defaultRootDirectory;		helpText: #AppeXRootDirectoryHelp &lt;&lt; #www &gt;&gt; 'The web development root directory'</body><body package="AppeXTools">appexScriptDirectory	&lt;setting: #(webDev scriptDir)  position: 130&gt;	^(DirectorySetting on: AppeX.Application aspect: #scriptDirectory)		label: #AppeXScriptDirectory &lt;&lt; #www &gt;&gt; 'Script Directory';		default: AppeX.Application defaultScriptDirectory;		helpText: #AppeXScriptDirectoryHelp &lt;&lt; #www &gt;&gt; 'The directory includes Javascript files.'</body><body package="AppeXTools">javascriptAutoDeleteScriptFiles	&lt;setting: #(webDev javascript javascriptAutoDeleteScriptFiles) position: 60&gt; 	^(BooleanSetting on: AppeX.JSFileMonitor aspect: #autoDeleteScriptFiles)		default: AppeX.JSFileMonitor defaultAutoDeleteScriptFiles;		label: #autoDeleteScriptFiles &lt;&lt; #labels &gt;&gt; 'Delete script files when switching to Image methods.';		helpText: 'Uncheck this box to prevent the .js files from being deleted when switching away from using script files.'</body><body package="AppeXTools">javascriptIsMinifyingVars	&lt;setting: #(webDev javascript javascriptIsMinifyingVars) position: 40&gt; 	^(BooleanSetting on: AppeX.JavascriptMinifyingWriter aspect: #isMinifyingVars)		default: AppeX.JavascriptMinifyingWriter defaultIsMinifyingVars;		label: #minifyJavascriptVars &lt;&lt; #labels &gt;&gt; 'Use shortened variable names when minifying';		helpText: 'Shorten variable and class names during minification (i.e. use uglification for greater code compression)'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="AppeXTools">javascriptPage	&lt;settingsPage: #(webDev javascript)&gt;		| useJavascriptThemeModule sourceCodeThemeModule |	useJavascriptThemeModule  := BooleanSettingModule 		on: (self settingWithId: #(#webDev #javascript #javascriptUseJavascriptSourceCodeTheme)).			sourceCodeThemeModule  := EnumerationSettingModule 		on: (self settingWithId: #(#webDev #javascript #javascriptSourceCodeTheme)).		^ModularSettingsPage new		label: #JavaScript &lt;&lt; #labels &gt;&gt; 'JavaScript';		icon: (ListIconLibrary visualFor: #javascript);		addAllSettings: (self settingsWithPrefix: #(#webDev #javascript)			except: #(#javascriptUseJavascriptSourceCodeTheme #javascriptSourceCodeTheme));		addModule: useJavascriptThemeModule;		addModule: sourceCodeThemeModule;		when: useJavascriptThemeModule valueHolder valueSatisfies: [:v | v = true] enable: sourceCodeThemeModule;		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-webDev</category><body package="AppeXTools">javascriptServeFilesCombined	&lt;setting: #(webDev javascript javascriptServeFilesCombined) position: 50&gt; 	^(BooleanSetting on: AppeX.JavascriptWriter aspect: #serveFilesCombined)		default: true;		label: #serveFilesCombined &lt;&lt; #labels &gt;&gt; 'Serve the JavaScript scripts as a combined file';		helpText: 'Combine all the JavaScript files and serve them as a combined file at runtime.'</body><body package="AppeXTools">javascriptSourceCodeTheme	&lt;setting: #(webDev javascript javascriptSourceCodeTheme) position: 80&gt; 	| themes keys labels |	(themes := Refactory.Browser.SourceCodeTheme javascriptThemes) sort: [:a :b | a name &lt;= b name].	keys := themes collect: [:each | each source selector].	labels := themes collect: [:each | each name].	^((EnumerationSetting keys: keys choices: keys labels: labels)		on: AppeX.JavascriptParserActor aspect: #javascriptSourceCodeThemeKey)		default: #defaultChrome;		label: #JavascriptSourceCodeTheme &lt;&lt; #browser &gt;&gt; 'Javascript Theme';		helpText: #JavascriptSourceCodeThemeHelpText &lt;&lt; #browser &gt;&gt; 'Specifies a colour theme for the source code editor for Javascript.'</body><body package="AppeXTools">javascriptSourceCodeThemeGap	&lt;setting: #(webDev javascript  sourceCodeThemeGap) position: 69&gt;	^SettingsPageSeparator new</body><body package="AppeXTools">javascriptUseJavascriptSourceCodeTheme	&lt;setting: #(webDev javascript javascriptUseJavascriptSourceCodeTheme) position: 70&gt; 	^(BooleanSetting on: AppeX.JavascriptParserActor aspect: #useJavascriptSourceCodeTheme)		default: AppeX.JavascriptParserActor defaultUseJavascriptSourceCodeTheme;		label: #useJavascriptSourceCodeTheme &lt;&lt; #labels &gt;&gt; 'Use the Javascript syntax highlighting theme';		helpText: 'Check this box to syntax highlight Javascript code according to the theme selected on this page rather than the theme selected on the Tools Editor page.'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="AppeXTools">webDevelopmentPage	&lt;settingsPage: #(webDev)&gt;	^ModularSettingsPage new 		label: #WebDevelopment &lt;&lt; #www &gt;&gt; 'Web Development';		icon: (SiouX.ServerIcons visualFor: #Browser_16x16);		settings: (self settingsWithPrefix: #(webDev))</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-webDev</category><body package="AppeXTools">webDevSourceComposerChoices	&lt;setting: #(webDev javascript composerChoices) position: 10&gt;	^((EnumerationSetting 		choices: #(#useImageCode #useJSFile )		labels: (				Array 					with: (#UseCodefromImage &lt;&lt; #webservices &gt;&gt; 'Image methods') 					with: (#UseJSCodeFromFile &lt;&lt; #webservices &gt;&gt; 'Script files')))	on: AppeX.Application aspect: #codeComposerType)		label: #SupplyJSFrom &lt;&lt; #webservices &gt;&gt; 'Supply Javascript code from:';		default: #useImageCode;		helpText: #SupplyJSFromHelpText &lt;&lt; #webservices &gt;&gt; 'Select one of the options: Image methods - the js response will include a JavaScript text created from an ApplicationClient methodsScript File - the development option. The js response will include a .js file contents from the script directory';		yourself</body></methods><methods><class-id>Refactory.Browser.SourceCodeTheme class</class-id> <category>themes</category><body package="AppeXTools">defaultChrome	&lt;theme&gt;	&lt;javascriptTheme&gt;	^self new		name: 'Default Chrome';		author: 'Anon';		website: 'http://dummysite.com';		styles: (self light16Chrome: self defaultChromeColors default: self defaultStyle)</body></methods><methods><class-id>Refactory.Browser.SourceCodeTheme class</class-id> <category>pragmas</category><body package="AppeXTools">javascriptPragmas	&lt;pragmas: #class&gt;	^#(javascriptTheme)</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>menus</category><body package="AppeXTools">appexGenerateClientMethod	&lt;itemInMenu: #(#selectorMenu) position: 105.51&gt;		| updater action label enabled clientClass actionSelector |	updater := [		action := self appexAction.		clientClass := action ifNotNil: [			[action methodClass instanceBehavior applicationClientClass]				on: Error				do: [ :ex | nil ] ].		actionSelector := action ifNotNil: [ action selector ].		label := clientClass ifNotNil: [ 'Generate ', clientClass name, '.', actionSelector ].		enabled := action notNil ].	^(MenuItem labeled: [ label ])		hidden: [			updater value.			action isNil or: [ clientClass isNil ] ];		enablement: [ enabled ];		value: [ clientClass generateClientMethodFor: action ];		yourself</body><body package="AppeXTools">generateCatalogMenuItem	"Generate catalog"	&lt;itemInMenu: #(#classMenu) position: 70.5&gt; 	^(MenuItem labeled: 'Generate Catalog')		value: #generateCatalog;		"visible: [self nonMetaClass includesBehavior: AppeX.Application];"		visible: [true];		enabled: [self isClassSelected];		yourself</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus- appex</category><body package="AppeXTools">menuItemCacheMinifiedCode	&lt;vwPrivileged&gt;	&lt;menuItemForCommand: #webAppCacheMinifiedCode		icon: nil		nameKey: nil		menu: #(#menuBar  #tools #webdevelopment)		position: 30.1&gt;	AppeX.JavascriptCode cacheAllMinifiedCode</body><body package="AppeXTools">menuItemResetCacheCode	&lt;vwPrivileged&gt;	&lt;menuItemForCommand: #webAppResetCacheCode		icon: nil		nameKey: nil		menu: #(#menuBar  #tools #webdevelopment)		position: 30.5&gt;	AppeX.JavascriptCode resetAllCodeCache</body></methods><initialize><class-id>AppeX.JavascriptPegCompiler</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>JavascriptLibrary</name><environment>AppeX</environment><super>AppeX.FileLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classes name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>bootstrap</category><attributes><package>AppeX-Support</package></attributes></class><class><name>RBMethod</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class compiledMethod source selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Model</category><attributes><package>Browser-Refactorings</package></attributes></class><class><name>BrowserNavigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractBrowserNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>history future </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>Pragma</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>message methodDefinition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>LanguageServices</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>languages </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category></category><attributes><package>Browser-Support</package></attributes></class><class><name>JavascriptComposer</name><environment>AppeX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>library </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Support</package></attributes></class><class><name>ChangeMethodNameRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.MethodRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>newSelector oldSelector permutation implementors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><class><name>JavascriptWriter</name><environment>AppeX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars>serveFilesCombined </class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Support</package></attributes></class><class><name>Parser</name><environment>Kernel</environment><super>Kernel.Scanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder requestor oldLanguage newLanguage extendedLanguage parseNode failBlock endTemps targetClass environment topEnvironment bindingRefs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class><class><name>JavascriptCompiler</name><environment>AppeX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>smalltalkSource originalSource </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Support</package></attributes></class><class><name>SourceCodeEditor</name><environment>Refactory.Browser</environment><super>UI.DocumentView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>decorations plugins theme evaluator needsRedecoration warning parseTree parserClass acceptAnimationCancel language errorHandlerClass timingStatistics compilerClass </inst-vars><class-inst-vars>defaultTheme compilationPragmas evaluationPragmas enablement </class-inst-vars><imports>			private Text2.*			</imports><category></category><attributes><package>Browser-SourceCodeUI</package></attributes></class></st-source>