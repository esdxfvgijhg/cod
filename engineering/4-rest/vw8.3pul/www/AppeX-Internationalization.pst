<?xml version="1.0"?><st-source><!-- Name: AppeX-InternationalizationNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: This package extends Appex with a Client Side Javascript/HTML5 Internationalization/Localization framework.I.  Overview and Usage:In place of hardcoded display strings  in Javascript code, the developer substitutes in their code a call of the form:_translate("Key", "DefaultValue"),  where "Key" is the string one wants to translate to a display value and "DefaultValue" is optional.  If DefaultValue is provided in the code above, it will have two effects:1. The DefaultValue will be used for display if the Key is not present in the current locale catalog.2. the DefaultValue will be used to provide the value of the key-value pair during Automatic Catalog Generation,as described below.At runtime, the  web client downloads the locale appropriate (e.g. English, French, etc) catalog, and when executed in the web client the _translate function looks up the aapropriate display value for the Key provided. II. Steps to Internationalize/Localize your AppeX Application:• Replace each literal string in the ApplicationClient code with a _translate function that will look up the locale-specific string at runtime.• Create the message catalogs and save them to the appropriate directories.You can perform and re-perform these steps in either order, and you can build the catalogs incrementally as you add client code to your web application.III.  Automatic Catalog Generation - Refer to the package 'AppeX-Tools'IV.  How the  AppeX Web Client uses catalogs at runtime.	The client makes a request  of "_appex_catalogForLanguage" to the server, and supplies as a string argument the locale desired.	The client is returned the appropriate catalog, which it caches in memory and uses as the localization catalog for future Javascript calls to _translate.	Optional: The HelloLocalized example demonstrates how the catalogs can be cached in session storage when using Session based  applications,			and how a locale can be set in the Server session of the ApplicationV: Implementation: New And Extended Classes	Application 		Class side extensions for generating and serving user message catalogs	ApplicationClient		Instance side extensions (Javascript code to be run on the client) for requesting, caching, and accessing user message catalogs	UserMessageCatalog		New class encapsulating the script that initializes the $t_catalogs client side dictionary for holding downloaded catalogs.Refer to the package 'AppeX-Tools'  for comments and code supporting the generation of usermessage catalogs, notably JavascriptUserMessageActor, a new class for parsing Javascript client code and generating catalogs based on calls to _translate.	DbIdentifier: bear73DbTrace: 496982DbUsername: vdegenDbVersion: 8.3 - 5DevelopmentPrerequisites: #(#(#any 'AppeX-Server' ''))PackageName: AppeX-InternationalizationParcel: #('AppeX-Internationalization')PrerequisiteDescriptions: #(#(#name 'AppeX-Server' #componentType #package))PrerequisiteParcels: #(#('AppeX-Server' ''))PrintStringCache: (8.3 - 5,vdegen)Version: 8.3 - 5Date: 3:30:53 PM June 30, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:30:53 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>UserMessageCatalog</name><environment>AppeX</environment><super>AppeX.JavascriptLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>applicationClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Internationalization</package></attributes></class><comment><class-id>AppeX.UserMessageCatalog</class-id><body>UserMessageCatalog represents a JavascriptLibrary that downloads the user message catalogs into the web browser as a separate JSON-formatted object.</body></comment><methods><class-id>AppeX.UserMessageCatalog</class-id> <category>accessing</category><body package="AppeX-Internationalization">applicationClass	^applicationClass</body><body package="AppeX-Internationalization">applicationClass: aClass	applicationClass := aClass</body><body package="AppeX-Internationalization">classes 	^OrderedCollection with: self</body><body package="AppeX-Internationalization">code: aCodeHandler"	(UserMessageCatalog forClass: HelloLocalized) code: Application codeComposer"	^self javascript</body><body package="AppeX-Internationalization">javascript	"Need to have javascript api for including the catalog in another javascriptLibrary (in order to serve combined files)"	| aDictionary aJSONString aScript|		aDictionary := self applicationClass userMessagesLookup.	aJSONString := Xtreams.JSON encode: aDictionary.	aScript := '$t._catalogs = {};	$t._catalogs[''', Locale current languageID, '''] = ', aJSONString, ';'.	^aScript</body></methods><methods><class-id>AppeX.UserMessageCatalog class</class-id> <category>instance creation</category><body package="AppeX-Internationalization">forClass: aClass	^self named: aClass asCatalogsLibraryName</body></methods><methods><class-id>AppeX.Application class</class-id> <category>user messages</category><body package="AppeX-Internationalization">asCatalogsLibraryName	^ self fullName, '_catalogsScript.js'</body><body package="AppeX-Internationalization">catalogName	"can override in subclasses"	^self name asString.</body><body package="AppeX-Internationalization">classesForCatalog	"self classesForCatalog"	"Answer the collection of classes which will be scanned to produce the user message catalogs for this application.	Override in subclasses if necessary"	self applicationLibrary ifNil: [^nil].	^self applicationLibraryClasses</body><body package="AppeX-Internationalization">defaultCatalogNameForClass: aClass	^(self classesForCatalog includes: aClass) 	 	ifTrue: [self name asString]		ifFalse: [aClass name asString]</body><body package="AppeX-Internationalization">ensureFilesReady	"self ensureFilesReady"	| directory |		directory := self userMessageDirectory.	directory asFilename ensureDirectory.</body><body package="AppeX-Internationalization">userMessageCatalog	"self userMessageCatalog"	"requires CoreCode already installed"		^ UserMessageCatalog forClass: self</body><body package="AppeX-Internationalization">userMessageDirectory	"self userMessageDirectory"	^self userMessagesRootDirectory / (Locale current languageID)</body><body package="AppeX-Internationalization">userMessagesLookup		 ^self userMessagesLookupForLanguage: Locale current languageID</body><body package="AppeX-Internationalization">userMessagesRootDirectory	| value |	^(value := IndexedFileMessageCatalog directoriesModel value) notEmpty 		ifTrue: [ value first asFilename]		ifFalse: [OS.Filename currentDirectory directory / 'messages' / 'visualworks' ]</body><body package="AppeX-Internationalization">catalogForLanguage	&lt;POST&gt;	&lt;jsonStream: '_appex_catalogForLanguage'&gt;		| language |		language := self currentRequestArguments.	^self userMessagesLookupForLanguage: language</body><body package="AppeX-Internationalization">userMessagesLookupForLanguage: languageTag	"self userMessagesLookup"	&lt;jsonStream: 'userMessagesLookup'&gt;		| aFilename file answer applicationFileName encodingToken encodingFromFile readStream lineStream | 		answer := Dictionary new.	applicationFileName := self name   asString, '.lbl'.	"this path should be platform independent, and dynamically based on curent locality (en, fr, etc)"	aFilename := self userMessagesRootDirectory / languageTag / applicationFileName.	aFilename exists ifFalse: [^answer].		encodingToken := 'encoding:'.	encodingFromFile := nil.	file := aFilename reading.	readStream := file encoding: #utf8. "default, may be changed when 'encoding:' is encountered in the file."	[ 	[file atEnd]			whileFalse: [				| line tryMessage key value |				tryMessage := true.				line := (readStream ending: Character cr) rest trimSeparators.				lineStream := line reading.				(encodingFromFile isNil and: [line beginsWith: encodingToken]) ifTrue: [					lineStream += encodingToken size.					"Symbol reading must occur from a classic readStream:"					encodingFromFile := Symbol readFrom: lineStream rest readStream.					"Continue reading from the file with the new encoding"					readStream := file encoding: encodingFromFile.					tryMessage := false.					].				(tryMessage and: [(line indexOf: $=) &gt; 0])  ifTrue: [					key := (lineStream ending: $= ) rest.					"String reading must occur from a classic readStream:"					value := String readFrom: lineStream rest readStream.						answer at: key put: value ]] 	] ensure: [ file close ].	^answer</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>JavascriptLibrary</name><environment>AppeX</environment><super>AppeX.FileLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classes name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>bootstrap</category><attributes><package>AppeX-Support</package></attributes></class></st-source>