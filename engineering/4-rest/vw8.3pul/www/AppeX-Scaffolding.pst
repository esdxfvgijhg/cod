<?xml version="1.0"?><st-source><!-- Name: AppeX-ScaffoldingNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: The package provides a JavaScript framework that helps to create web pages for ActiveRecords.DbIdentifier: bear73DbTrace: 496321DbUsername: tkoganDbVersion: 8.3 - 4DevelopmentPrerequisites: #(#(#any 'AppeX-Tools' '') #(#any 'AppeX-ActiveRecord' '') #(#any 'AppeX-Server' '') #(#any 'AppeX-Client' ''))PackageName: AppeX-ScaffoldingParcel: #('AppeX-Scaffolding')PrerequisiteDescriptions: #(#(#name 'AppeX-Tools' #componentType #bundle) #(#name 'AppeX-ActiveRecord' #componentType #package) #(#name 'AppeX-Server' #componentType #package) #(#name 'AppeX-Client' #componentType #package))PrerequisiteParcels: #(#('AppeX-Tools' '') #('AppeX-ActiveRecord' '') #('AppeX-Server' '') #('AppeX-Client' ''))PrintStringCache: (8.3 - 4,tkogan)Version: 8.3 - 4Date: 3:30:53 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:30:53 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DefaultScaffoldingTheme</name><environment>AppeX</environment><super>AppeX.Theme</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Scaffolding</package></attributes></class><comment><class-id>AppeX.DefaultScaffoldingTheme</class-id><body>DefaultScaffoldingTheme encapsulates the typical style sheet information that might be required in a scaffolded AppeX application, i.e., one that uses ActiveRecord and Presenter framework.Subclasses may override.</body></comment><class><name>DomainObject</name><environment>AppeX</environment><super>AppeX.JavascriptObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Scaffolding</package></attributes></class><comment><class-id>AppeX.DomainObject</class-id><body>The class represents a JavaScript object corresponding an instance of ActiveRecord. The ActiveRecord relations are decoded as instances of a JavaScript Relation object.Example: The server encodes an ActiveRecord.There are two ActiveRecord classes,  Person and Address. Person has a one-to-one relation with Address.Example of an encoded JSON string for an instance of Person that the server sends to the client:'{"id": 1,   "name": "Smith", "#address": {"path": "address",      //encoded address, where the "path" value is a url to retrieve an address record			"relations": [{"1000 Nowhere": 1}]}}'  //"relations" is a collection of  objects containing printString and address id's for this person									 //"1000 Nowhere" - is #printString for Address with id = 1This string is parsed on the client to create an instance of  DomainObject.</body></comment><class><name>Renderer</name><environment>AppeX</environment><super>AppeX.JavascriptObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Scaffolding</package></attributes></class><comment><class-id>AppeX.Renderer</class-id><body>Renderer is a super class that defines a renderer protocol. The Renderer creates and maintains HTML elements stack.Subclasses must implement the following messages:	accessing		getVal	building		addClass		removeClass		setAttribute		setId		text		val	callbacks		onChange		onClick	initialize-release		emptyContainer		newElementImplementation.A renderer maintains elements stack. A Presenter has to start a new element, add element attributes and subelements and finish the element.For example:	this.renderer		.startElement("table")  // the table element is created and pushed to the top of the stack		.addClass("object-table");  //the element attributes are added		this.buildHeaderRow();     //the header and rows are added to the table	this.buildContentRows();	this.renderer.finishElement();  //the table element is removed from the stack</body></comment><class><name>JQueryRenderer</name><environment>AppeX</environment><super>AppeX.Renderer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Scaffolding</package></attributes></class><comment><class-id>AppeX.JQueryRenderer</class-id><body>JQueryRenderer uses JQuery library to manipulate with HTML elements. </body></comment><class><name>GenericPresenter</name><environment>AppeX</environment><super>AppeX.JavascriptObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Scaffolding</package></attributes></class><comment><class-id>AppeX.GenericPresenter</class-id><body>GenericPresenter is an abstract class that represents common Presenter behavior. Based on an ActiveRecord Schema information a Presenter knows how build a web page. The Presenter delegates manipulating HTML elemets to a Renderer. Subclasses must implement the following messages:	accessing		presenterType	open main view		openMainView()</body></comment><class><name>ObjectPresenter</name><environment>AppeX</environment><super>AppeX.GenericPresenter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Scaffolding</package></attributes></class><comment><class-id>AppeX.ObjectPresenter</class-id><body>ObjectPresenter is a common Javascript superclass for viewing and editing (DetailPresenter &amp; EditPresenter)</body></comment><class><name>EditPresenter</name><environment>AppeX</environment><super>AppeX.ObjectPresenter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Scaffolding</package></attributes></class><comment><class-id>AppeX.EditPresenter</class-id><body>EditPresenter builds a web page to edit an ActiveRecord. The editor can add a new ActiveRecord (sending PUT request) or update an existing one (sending POST request). By default the EditPresenter has buttons to add existing ActiveRecord relations and new ones.</body></comment><class><name>BoldScaffoldingTheme</name><environment>AppeX</environment><super>AppeX.DefaultScaffoldingTheme</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Scaffolding</package></attributes></class><comment><class-id>AppeX.BoldScaffoldingTheme</class-id><body>BoldScaffoldingTheme implements styling with a larger font.</body></comment><class><name>Relation</name><environment>AppeX</environment><super>AppeX.JavascriptObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Scaffolding</package></attributes></class><comment><class-id>AppeX.Relation</class-id><body>The class represents a JavaScript object corresponding to an ActiveRecord relation. The server encodes only the following information for a relation: the relation path( or url to retrieve the relation object), the relation object id,  and the print presentation of the target of the relation.</body></comment><class><name>Scaffold</name><environment>AppeX</environment><super>AppeX.JavascriptObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Scaffolding</package></attributes></class><comment><class-id>AppeX.Scaffold</class-id><body>Scaffolding class is a bridge between the ApplicationClient and the classes forming the scaffolding framework.</body></comment><class><name>ListPresenter</name><environment>AppeX</environment><super>AppeX.GenericPresenter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Scaffolding</package></attributes></class><comment><class-id>AppeX.ListPresenter</class-id><body>ListPresenter builds a web page to display an ActiveRecord collection. Implementation.By default the first attribute is built as a link to open DetailPresenter for a selected record. Override the function: #attributeNameForLink() to change the default.By default the editor creates a button to add a new ActiveRecord</body></comment><class><name>DetailPresenter</name><environment>AppeX</environment><super>AppeX.ObjectPresenter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Scaffolding</package></attributes></class><comment><class-id>AppeX.DetailPresenter</class-id><body>DetailPresenter builds a web page to display the details of an  ActiveRecord. By default the page includes an Edit button for switching to edit mode. </body></comment><class><name>SelectionPresenter</name><environment>AppeX</environment><super>AppeX.GenericPresenter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Scaffolding</package></attributes></class><comment><class-id>AppeX.SelectionPresenter</class-id><body>SelectionPresenter bulds a page for an ActiveRecord selection.ImplementationBy default the editor requests all records for a specified url. The records are requested in a form {"id" "#webPrint"} where #id is an ActiveRecord id and #webPrint is a message that returns an ActiveRecord print string</body></comment><class><name>TinyScaffoldingTheme</name><environment>AppeX</environment><super>AppeX.DefaultScaffoldingTheme</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Scaffolding</package></attributes></class><comment><class-id>AppeX.TinyScaffoldingTheme</class-id><body>TinyScaffoldingTheme implements styling with a small font.</body></comment><methods><class-id>AppeX.Application class</class-id> <category>accessing</category><body package="AppeX-Scaffolding">scaffoldingClasses"	(self scaffoldingClasses)"	^ self scaffoldingLibrary classes</body><body package="AppeX-Scaffolding">scaffoldingLibrary"	(self scaffoldingLibrary)"	^JavascriptLibrary named: 'AppeX.ScaffoldingLibrary.js'</body></methods><methods><class-id>AppeX.DefaultScaffoldingTheme</class-id> <category>accessing</category><body package="AppeX-Scaffolding">decorations"Answer a String that is the main style of the theme. Return an empty string by default. Subclasses may override."	&lt;styleSheet: 10&gt;	^'button {	background-color: rgba(127, 127, 127, 0.1);	border: thin dotted transparent;	border-radius: 4px;}button:hover {	cursor: pointer;	background-color: rgba(127, 127, 127, 0.3);}.header-row {	font-weight: bold;}.highlight {	color: #990000;	background-color: #FFCC00 !important;}.centered {	text-align: center;}table {   border: thin dotted lightgrey;}tr#title-row {   color: darkblue;   text-transform:capitalize;}tr#title-row td{   border: none;}.type-table-class {    border: 1px solid black;}.selected-type {	background-color: #B298E5;}.selected-object {	background-color: wheat;}.disabled{    background-color: #DDD;    color: #999;}input[readonly] {    border: none;    outline: none;    background-color: transparent;    font-family: inherit;    font-size: inherit;}header.top {	background-color: white;	padding-bottom: 1px; /* to give the h1 margin the background color */}footer.bottom {	background-color: white;	font-size: xx-small;}.breadcrumb-span:before  {	 content: " / "}'</body><body package="AppeX-Scaffolding">responsiveDecorations"Answer a String that contains the structural styling of Scaffolding elements."	&lt;styleSheet: 10.1&gt;	^''</body><body package="AppeX-Scaffolding">responsiveStructure"Answer a String that contains the structural styling of Scaffolding elements."	&lt;styleSheet: 0.1&gt;	^'@media (max-width: 1024px) {	body {		width: calc(100% - 20px);		margin: 10px;	}}@media (min-width: 1025px) {	body {		width: 100%;		max-width: 1024px;		margin: auto;		margin-top: 2em;		margin-bottom: 1em;	}}'</body><body package="AppeX-Scaffolding">structure"Answer a String that contains the structural styling of Scaffolding elements."	&lt;styleSheet: 0&gt;	^'button {	margin: 2px;	padding: 0.2em 1em;}.actions.bottom {	text-align: right;}.float-left {	float: left;}.float-right {	float: right;}.clear-float {	clear: both;}.hidden {	display: none;}.centered {	text-align: center;}.appex-table {	width: 100%;}.appex-td {	vertical-align: top;	padding-top: 4px;}.relation {	margin-bottom: 3px;	background-color: rgba(255, 255, 255, 0.25);}footer.bottom {	text-align: right;	padding-top: 0.5em;}'</body><body package="AppeX-Scaffolding">validation"Answer a String that defines validation style CSS."	&lt;styleSheet: 20&gt;	^'.appex-input.invalid {	border-color: Tomato;	background-color: lemonchiffon;}.validation {	color: Red;	text-shadow: 0px 0px 3px yellow;	font-size: small;}'</body></methods><methods><class-id>AppeX.DomainObject</class-id> <category>initialize-release</category><body package="AppeX-Scaffolding">decodeObject(objectData){		var self = this,		eValue,		ekey;	for (var key in objectData) { 		eValue = objectData[key];		if (key.slice(0, 1) === "#") {			ekey  = key.slice(1);			if (eValue === null) {				self[ekey] = null;			} else {				this.decodeRelation(ekey, eValue);			}		} else {			this[key] = eValue;		}	};}</body><body package="AppeX-Scaffolding">decodeRelation(key, value) {	// key: e.g., ""#address"	// value: e.g., {path: person', relations: ["street": 1, "street2": 2 ] }	var	self = this,		ePrintAndKey,		id,		printString,		relationTypeInfo;	relationTypeInfo = this._objectTypeInfo[key];	this[key] = new AppeX.Relation(relationTypeInfo);	if (value.relations) {		for (i = 0; i &lt; value.relations.length; i++) { 			ePrintAndKey = value.relations[i];			printString = Object.keys(ePrintAndKey)[0];			id = ePrintAndKey[printString];			this[key].add(printString, id);		}	}	}</body><body package="AppeX-Scaffolding">getObjectType() {	return (this._objectTypeInfo &amp;&amp; this._objectTypeInfo.path)  || "Object";}</body><body package="AppeX-Scaffolding">getObjectTypeInfo() {	return this._objectTypeInfo || "Object";}</body><body package="AppeX-Scaffolding">initialize(objectData, objectTypeInfo) {		if (objectTypeInfo) {		this._objectTypeInfo = objectTypeInfo;	}	this.decodeObject(objectData);}</body></methods><methods><class-id>AppeX.DomainObject</class-id> <category>actions</category><body package="AppeX-Scaffolding">copyObject() {	var	attributeValue,		copy;			copy = new this.constructor(null, this._objectTypeInfo);	for (var eName in this ) {		attributeValue = this[eName];		if (attributeValue instanceof AppeX.Relation) {			copy[eName] = attributeValue.copyObject();		} else {			copy[eName] = attributeValue;		}	}	return copy;}</body><body package="AppeX-Scaffolding">differencesFrom(anotherObject) {	var	differences = {},		eAttributeValue,		i,		j,		eRelation;		for (var attributeName in this) {		eAttributeValue = this[attributeName];		if (eAttributeValue instanceof AppeX.Relation) {			if (!eAttributeValue.isEquivalent(anotherObject[attributeName])) {				differences[attributeName] = [];				for (j = 0; j &lt; eAttributeValue.relations.length; j++) {					differences[attributeName].push(eAttributeValue.relations[j].id);				}			}		} else {			if (eAttributeValue !== anotherObject[attributeName]) {				differences[attributeName] = eAttributeValue;			}		}	}	return differences;}</body></methods><methods><class-id>AppeX.Renderer</class-id> <category>building</category><body package="AppeX-Scaffolding">addClass(classValue) {	// Set the "class" attribute to.  Has to return the renderer. "return this;"	this.subclassResponsibility( "addClass" );	}</body><body package="AppeX-Scaffolding">appendElement(elementName, aFunction) {	// A convenience method for cases where we don't want to go through the 'startElement', 'finishElement'	// because it's extra code that is not required (for example: &lt;br&gt;, &lt;hr&gt;)	// Optional aFunction can be used to decorate the element in a callback function. Usefulness is questionable.	this.startElement(elementName);	if (aFunction) {		aFunction(this.getCurrentElement());	};	this.finishElement();}</body><body package="AppeX-Scaffolding">getAttribute(name) {	//gets the specified attribute value in the current element."	this.subclassResponsibility( "getAttribute" );}</body><body package="AppeX-Scaffolding">innerHtml(aString) {	// Insert html into the current element.	this.subclassResponsibility( "innerHtml" );	return this;}</body><body package="AppeX-Scaffolding">removeClass(classValue) {	//remove "class" attribute from the current element.  Has to return the renderer. "return this;"	this.subclassResponsibility( "getVal" );	}</body><body package="AppeX-Scaffolding">setAttribute(name, value) {	//sets the specified attribute value in the current element. Has to return the renderer. "return this;"	this.subclassResponsibility( "setAttribute" );}</body><body package="AppeX-Scaffolding">setId(idValue) {	// Set the "id" attribute to.  Has to return the renderer. "return this;"	this.subclassResponsibility( "setId" );	}</body><body package="AppeX-Scaffolding">text(aString) {	// Adds text to the current element.  Has to return the renderer. "return this;"	this.subclassResponsibility( "text" );}</body><body package="AppeX-Scaffolding">val(aString) {	//Sets the current element value.  Has to return the renderer. "return this;"	this.subclassResponsibility( "val" );}</body></methods><methods><class-id>AppeX.Renderer</class-id> <category>callbacks</category><body package="AppeX-Scaffolding">getCurrentHtmlElement() {	// By default, the HTML element is identical to the currentElement.	// Subclasses may have to override if 'currentElement' is library specific.	return this.getCurrentElement();}</body><body package="AppeX-Scaffolding">onChange(aFunction) {	var	input = this.getCurrentHtmlElement(),		handler;			handler = function (event) {		aFunction(event.target);	};		input.addEventListener("change", handler);	return this;}</body><body package="AppeX-Scaffolding">onClick(aFunction) {	//Sets the function to the current element for onClick event.  Has to return the renderer. "return this;"	this.subclassResponsibility( "onClick" );}</body></methods><methods><class-id>AppeX.Renderer</class-id> <category>accessing</category><body package="AppeX-Scaffolding">find(aSelector) {	//Get the descendants of each element in the current set of matched elements, filtered by a selector	this.subclassResponsibility( "find" );}</body><body package="AppeX-Scaffolding">getCurrentElement(){	return this.elementStack[this.elementStack.length - 1];;}</body><body package="AppeX-Scaffolding">getVal(anElement) {	this.subclassResponsibility( "getVal" );}</body></methods><methods><class-id>AppeX.Renderer</class-id> <category>initialize-release</category><body package="AppeX-Scaffolding">appendTo(parent, child) {	//Sets the function to the current element for onChance event.  Has to return the renderer. "return this;"	this.subclassResponsibility( "appendTo" );}</body><body package="AppeX-Scaffolding">emptyContainer(containerId) {	//remove all elements from a specified container.  Has to return the renderer. "return this;"	this.subclassResponsibility( "emptyContainer" );}</body><body package="AppeX-Scaffolding">finishElement() {	this.elementStack.pop();	return this;}</body><body package="AppeX-Scaffolding">initialize(element) {	this.elementStack = [];	this.pushElement(element);	this.container = this.getCurrentElement();}</body><body package="AppeX-Scaffolding">newElement(tagName) {	//creates a new element with the specified tag.  Has to return the renderer. "return this;"	this.subclassResponsibility( "newElement" );	}</body><body package="AppeX-Scaffolding">pushElement(element) {	this.elementStack.push(element);}</body><body package="AppeX-Scaffolding">startElement(tagName) {	//Creates a new element and adds it to the stack 	var newElement = this.newElement(tagName);	this.appendTo(this.getCurrentElement(), newElement);	this.pushElement(newElement);	// For future CSS prettification, it might be useful to add an 'appex' class to each new element.	this.addClass("appex-" + tagName);	return this;	}</body></methods><methods><class-id>AppeX.JQueryRenderer</class-id> <category>building</category><body package="AppeX-Scaffolding">addClass(classValue) {	// Set the "class" attribute to 	this.getCurrentElement().addClass(classValue);	return this;	}</body><body package="AppeX-Scaffolding">innerHtml(aString) {	this.getCurrentElement().html(aString);	return this;}</body><body package="AppeX-Scaffolding">removeClass(classValue) {	this.getCurrentElement().removeClass(classValue);	return this;	}</body><body package="AppeX-Scaffolding">setAttribute(name, value) {	this.getCurrentElement().attr(name, value);	return this;}</body><body package="AppeX-Scaffolding">setId(idValue) {	// Set the "id" attribute to 	this.getCurrentElement().attr("id", idValue);	return this;	}</body><body package="AppeX-Scaffolding">setReadOnly(aBoolean) {	this.getCurrentElement().attr('readonly', aBoolean);	return this;	}</body><body package="AppeX-Scaffolding">text(aString) {	this.getCurrentElement().text(aString);	return this;}</body><body package="AppeX-Scaffolding">val(aString) {	this.getCurrentElement().val(aString);	return this;}</body></methods><methods><class-id>AppeX.JQueryRenderer</class-id> <category>callbacks</category><body package="AppeX-Scaffolding">getCurrentHtmlElement() {	// In JQuery, get the underlying HTML element for the current JQ wrapper.	return this.getCurrentElement().get()[0];}</body><body package="AppeX-Scaffolding">onClick(aFunction) {	this.getCurrentElement().click(aFunction);	return this;}</body></methods><methods><class-id>AppeX.JQueryRenderer</class-id> <category>initialize-release</category><body package="AppeX-Scaffolding">appendTo(parent, newElement) {	newElement.appendTo(parent);}</body><body package="AppeX-Scaffolding">emptyContainer(containerId) {	return $("#" + containerId).empty();}</body><body package="AppeX-Scaffolding">newElement(tagName) {	return $("&lt;" + tagName + "&gt;");	}</body><body package="AppeX-Scaffolding">pushElement(element) {	this.elementStack.push($(element));}</body></methods><methods><class-id>AppeX.JQueryRenderer</class-id> <category>accessing</category><body package="AppeX-Scaffolding">find(aSelector) {	//Get the descendants of each element in the current set of matched elements, filtered by a selector, jQuery object, or element.	return this.getCurrentElement().find(aSelector);}</body><body package="AppeX-Scaffolding">getAttribute(name) {	return this.getCurrentElement().attr(name);}</body><body package="AppeX-Scaffolding">getVal(anElement) {	return $(anElement).val();}</body></methods><methods><class-id>AppeX.GenericPresenter</class-id> <category>accessing</category><body package="AppeX-Scaffolding">acceptPath(path) {	if (this.acceptedPaths().length === 0) {		return true;	}	return this.acceptedPaths().indexOf(path) &gt; -1;}</body><body package="AppeX-Scaffolding">acceptedPaths() {	return [];}</body><body package="AppeX-Scaffolding">createNewObject(attributeNames, path) {	var object = {},		eAttributeName,		objectTypeInfo,		newDomainObject;	for (i = 0; i &lt; attributeNames.length; i++ ) {		eAttributeName = attributeNames[i];		object[eAttributeName] = undefined;		}	objectTypeInfo = this.scaffold.getObjectTypeInfo(path);	newDomainObject = new AppeX.DomainObject(object, objectTypeInfo);	return newDomainObject;}</body><body package="AppeX-Scaffolding">cssClassName() {	// Provide the CSS class name to be added/removed to my container.	// Default is to return my JS class name.	// Subclasses may override.		return this.getClassName()}</body><body package="AppeX-Scaffolding">detailPresenterClass(){	return AppeX.DetailPresenter;}</body><body package="AppeX-Scaffolding">editPresenterClass(){	return AppeX.EditPresenter;}</body><body package="AppeX-Scaffolding">footerForPath() {	var methodName = "footerFor_" + this.path;	if(!!this[methodName]) {		return this[methodName]();	}	return this.scaffold.footerForPath(this);}</body><body package="AppeX-Scaffolding">getAttributeNames(path) {	var objectTypeInfo,		names,		idIndex;	objectTypeInfo = this.scaffold.getObjectTypeInfo(path);	names = Object.keys(objectTypeInfo);	idIndex = names.indexOf("id");	if (idIndex &gt; -1) {		names.splice(idIndex, 1);	}	return names;}</body><body package="AppeX-Scaffolding">getListeners(type) {	// Possibly a candidate to move to JavascriptClass?	this._listeners = this._listeners || {};	return this._listeners[type] = this._listeners[type] || [];}</body><body package="AppeX-Scaffolding">labelForAttributeName(attributeName) {	var methodName = "labelFor_" + attributeName;	if(!!this[methodName]) {		return this[methodName]();	}	return this.scaffold.labelForPathAndAttributeName(this.path, attributeName);}</body><body package="AppeX-Scaffolding">listPresenterClass(){	return AppeX.ListPresenter;}</body><body package="AppeX-Scaffolding">presenterType() {	this.subclassResponsibility( "presenterType" );}</body><body package="AppeX-Scaffolding">scaffoldingContainerId() {// By default, return the scaffoldingContainerId from my application.// Subclasses may override.	return this.scaffold.scaffoldingContainerId();	}</body><body package="AppeX-Scaffolding">selectionPresenterClass(){	return AppeX.SelectionPresenter;}</body></methods><methods><class-id>AppeX.GenericPresenter</class-id> <category>open main view</category><body package="AppeX-Scaffolding">closeAndReturn() {	this.triggerEvent("return");	this.closeView();	return this;}</body><body package="AppeX-Scaffolding">closeView() {	var containerId,		presenter;		containerId = this.scaffoldingContainerId();	this.scaffold.popView(containerId);	presenter = this.scaffold.topView(containerId);		this.resetCssClasses();	this.renderer.emptyContainer(containerId);	if (presenter) {		presenter.buildView();	}}</body><body package="AppeX-Scaffolding">collectCssClasses() {	// Add css classes for each of classes in my superclass chain, most generic to most specific.	var	cssClasses = [],		currentClass = this.constructor;	// Build a list of classes up to but not including Object.	while(currentClass !== Object) {		cssClasses.unshift(currentClass.prototype.cssClassName());		currentClass = currentClass.Superclass;	};		return cssClasses;}</body><body package="AppeX-Scaffolding">getBreadcrumbText() {// Answer the title details.// Subclasses may override.	return this.getTitleDetails();}</body><body package="AppeX-Scaffolding">getTitleAction() {// Answer the title of this presenter. Subclasses are responsible.	return this.subclassResponsibility("getTitleAction");}</body><body package="AppeX-Scaffolding">getTitleDetails() {// Answer the details of the title. Normally, this is the path of the Active Record object(s)// Subclasses may override.	return this.path;}</body><body package="AppeX-Scaffolding">openDetailView(object, path) {	var presenter;		presenter = this.scaffold.getPresenter(path, "detail");	this.openPresenter(presenter, object, path);	return presenter;}</body><body package="AppeX-Scaffolding">openEditView(object, path) {	var	presenter;	presenter = this.scaffold.getPresenter(path, "edit");	this.openPresenter(presenter, object, path);	return presenter;}</body><body package="AppeX-Scaffolding">openListView(objects) {	var	presenter;		presenter = this.scaffold.getPresenter(path, "list");	return this.openPresenter(presenter, objects, this.path);}</body><body package="AppeX-Scaffolding">openMainView() {	this.subclassResponsibility( "openMainView" );}</body><body package="AppeX-Scaffolding">openPresenter(presenter, object, path) {	// object may be a single object or an array of objects, depending on presenterClass.	var self = this;	this.resetCssClasses();	presenter.parent = this;	presenter.openMainView(object, path);	presenter.onReturn(function() {		self.returningFrom(presenter);	});	return presenter;}</body><body package="AppeX-Scaffolding">resetCssClasses() {	// Remove css classes for each of classes in my superclass chain, most specific to most generic.	var	cssClasses = this.collectCssClasses();	this.renderer.removeClass(this.path);	while(cssClasses.length &gt; 0) {		var currentClass = cssClasses.shift();		this.renderer.removeClass(currentClass);	}}</body><body package="AppeX-Scaffolding">returningFrom(childPresenter){// I am returning from childPresenter. I need to update my status. Subclasses may override.	this.changes = childPresenter.changes;}</body><body package="AppeX-Scaffolding">setCssClasses() {	// Add css classes for each of classes in my superclass chain, most generic to most specific.	var	cssClasses = this.collectCssClasses();	// add classes in reverse to my renderer.	while(cssClasses.length !== 0) {		var currentClass = cssClasses.shift();		this.renderer.addClass(currentClass);	}	this.renderer.addClass(this.path);}</body><body package="AppeX-Scaffolding">setRenderer() {// Delegate the renderer setup to the application client.	this.renderer = this.scaffold.setRenderer(		this.scaffoldingContainerId(),		this	);	return this.renderer;}</body><body package="AppeX-Scaffolding">updateWindowLocationHash() {	var hash = this.windowLocationHash();	if (hash.length == 0) {		window.location.hash="";	} else {		window.location.hash="#" + hash;	}}</body><body package="AppeX-Scaffolding">windowLocationHash() {	// By default, it's empty	return "";}</body></methods><methods><class-id>AppeX.GenericPresenter</class-id> <category>button labels</category><body package="AppeX-Scaffolding">buttonLabelAddNew() {	return "Add new...";}</body><body package="AppeX-Scaffolding">buttonLabelCancel() {	return "Cancel";}</body></methods><methods><class-id>AppeX.GenericPresenter</class-id> <category>build simple data types</category><body package="AppeX-Scaffolding">buildBooleanType(attributeName, attributeValue) {	this.renderer.startElement("input");	this.renderer.setAttribute("disabled", "disabled");	this.renderer.setAttribute("readonly", "readonly");	this.convertInputToCheckbox(attributeValue);	this.renderer.onClick(function (input) {		return false;  //prevent toggling without changing appearance	});	this.renderer.finishElement();}</body><body package="AppeX-Scaffolding">buildCellDataAccordingToType(attributeName, attributeType, attributeValue) {		switch (attributeType) {		case "String": 			this.buildStringType(attributeName, attributeValue);		break;		case "Number": 			this.buildNumberType(attributeName, attributeValue);		break;		case "Date": 			this.buildDateType(attributeName, attributeValue);		break;		case "Time": 			this.buildTimeType(attributeName, attributeValue);		break;		case "Timestamp": 			this.buildTimestampType(attributeName, attributeValue);		break;		case "Boolean": 			this.buildBooleanType(attributeName, attributeValue);		break;		default: 			this.buildDefaultType(attributeName, attributeValue);		break;		};		}</body><body package="AppeX-Scaffolding">buildCellDataForSimpleType(attributeName, object) {	var objectTypeInfo,		attributeValue,		attributeType,		methodName;			objectTypeInfo = this.scaffold.getObjectTypeInfo(this.path);	attributeValue = object[attributeName];	attributeType = objectTypeInfo[attributeName].type;		// if we implement a custom method for attributeName input, we have to call it here and return.	methodName = "buildCellDataFor_" + attributeName;	if (!!this[methodName]) {		this[methodName](attributeValue);		return;	}		this.buildCellDataAccordingToType(attributeName, attributeType, attributeValue);}</body><body package="AppeX-Scaffolding">buildDateType(attributeName, attributeValue) {	this.renderer.text(attributeValue);}</body><body package="AppeX-Scaffolding">buildDefaultType(attributeName, attributeValue){	this.renderer.text(attributeValue);	}</body><body package="AppeX-Scaffolding">buildNumberType(attributeName, attributeValue) {	this.renderer.text(attributeValue);}</body><body package="AppeX-Scaffolding">buildStringType(attributeName, attributeValue) {	this.renderer.text(attributeValue); //if not using input tag}</body><body package="AppeX-Scaffolding">buildTimeType(attributeName, attributeValue) {	this.renderer.text(attributeValue);}</body><body package="AppeX-Scaffolding">buildTimestampType(attributeName, attributeValue) {	this.renderer.text(attributeValue);}</body><body package="AppeX-Scaffolding">convertInputToCheckbox(attributeValue) {	this.renderer.setAttribute("type", "checkbox");	if (attributeValue === true) {		this.renderer.setAttribute("checked", "checked");	}}</body></methods><methods><class-id>AppeX.GenericPresenter</class-id> <category>actions</category><body package="AppeX-Scaffolding">openObjectView(domainObject, aURL) {	this.subclassResponsibility( "openObjectView" );}</body><body package="AppeX-Scaffolding">viewObject(attributeName, relationId, object) {	var self = this,		relation,		object,		aURL,		args = {};			relation =  object[attributeName];	aURL = relation.path();	args.input = {};	args.input.id = relationId;		this.client		.GET(aURL, args)		.onSuccess(function (data) {			var domainObject;			$t.debug("Get " + aURL + " success");			domainObject = self.newDomainObjectFrom(data[0], aURL);			self.openObjectView(domainObject, aURL, attributeName);		});}</body></methods><methods><class-id>AppeX.GenericPresenter</class-id> <category>building</category><body package="AppeX-Scaffolding">buildAttributeCell(attributeName, object) {	this.renderer		.startElement("td")		.addClass("data")		.startElement("div");	this.buildCellData(attributeName, object);	this.renderer		.finishElement()	// finish &lt;div&gt;		.finishElement()	// finish &lt;td&gt;}</body><body package="AppeX-Scaffolding">buildBottomActions() {	this.buildDefaultActions("bottom");}</body><body package="AppeX-Scaffolding">buildCellData(attributeName, object) {	if (this.isDomainObject(attributeName)) {		this.renderer.addClass("relations");		this.buildCellDataForRelations(attributeName, object);	} else {		this.renderer.addClass("simple");		this.buildCellDataForSimpleType(attributeName, object);	};			}</body><body package="AppeX-Scaffolding">buildContentRows() {	this.subclassResponsibility( "buildContentRows" );}</body><body package="AppeX-Scaffolding">buildContents() {	this.renderer		.startElement("table")		.addClass("object-table");		this.buildHeaderRow();	this.buildContentRows();	this.renderer.finishElement();}</body><body package="AppeX-Scaffolding">buildDefaultActionButtons() {	return this;}</body><body package="AppeX-Scaffolding">buildDefaultActions(cssClass) {	if (this.defaultActionPlacement() !== cssClass) {		return this;	}	this.renderer		.startElement("div")		.addClass("actions")		.addClass(cssClass);	this.buildDefaultActionButtons();	this.renderer.finishElement();	return this;}</body><body package="AppeX-Scaffolding">buildFooter(){	this.renderer		.startElement("footer")		.addClass("bottom")		.innerHtml(this.footerForPath())		.finishElement();	return this;}</body><body package="AppeX-Scaffolding">buildHeader() {// Build a header for this presenter. 	var title;		title = this.getTitle();	document.title = title;		this.renderer		.startElement("header")		.addClass("top");	if (this.scaffold.shouldBuildBreadCrumbs()) {		this.buildBreadcrumbs();	}	this.renderer		.startElement("h2")		.addClass("title")		.innerHtml(title)		.finishElement()	// finish &lt;h2&gt;		.finishElement()	// finish &lt;header&gt;}</body><body package="AppeX-Scaffolding">buildHeaderRow(){	// Do nothing by default.	// Subclasses may override.}</body><body package="AppeX-Scaffolding">buildRowCells(attributeName, object) {		this.renderer.addClass(attributeName);		this.buildLabelCell(attributeName);	this.buildAttributeCell(attributeName, object);}</body><body package="AppeX-Scaffolding">buildTopActions() {	return this.buildDefaultActions("top");}</body><body package="AppeX-Scaffolding">buildView() {	this.setCssClasses();	this.buildHeader();	this.buildTopActions();	this.buildContents();	this.buildBottomActions();	this.buildFooter();	this.updateWindowLocationHash();}</body><body package="AppeX-Scaffolding">defaultActionPlacement() {	// Answer "top" or "bottom" as an indicator of where actions should be placed.	// By default, actions should be rendered below content, at the bottom.	// Some presenters may override.		return "bottom";}</body><body package="AppeX-Scaffolding">getTitle() {	// Get title for this presenter. Let's build it from two parts - action and details.	// This allows us to do titles such as 'Edit' + 'Smith Family'	return this.getTitleAction() + " " + this.getTitleDetails();}</body></methods><methods><class-id>AppeX.GenericPresenter</class-id> <category>initializing</category><body package="AppeX-Scaffolding">initialize() {	this.changes = null;}</body></methods><methods><class-id>AppeX.GenericPresenter</class-id> <category>callbacks</category><body package="AppeX-Scaffolding">onReturn(callback) {	var	self = this,		type = "return",		listeners,		listener;	listeners = this.getListeners(type);	listener = function (event) {		var	index;					callback();		// I can process a 'return' event only once. Remove the listener.		index = listeners.indexOf(listener);		listeners.splice(index, 1);		self.removeEventListener(type, listener);	};	this.addEventListener(type, listener);	listeners.push(listener);}</body></methods><methods><class-id>AppeX.GenericPresenter</class-id> <category>build relation data types</category><body package="AppeX-Scaffolding">buildAnchorForRelation(attributeName, relation, object) {	var self = this;	this.renderer		.startElement("a")		.addClass(attributeName)		.text(relation.print)		.setAttribute("href", "javascript:")		.onClick(function (event) {			self.viewObject(attributeName, relation.id, object)		})		.finishElement();			}</body><body package="AppeX-Scaffolding">buildCellDataForRelation(attributeName, relation, index, object) {	this.buildAnchorForRelation(attributeName, relation, object);		}</body><body package="AppeX-Scaffolding">buildCellDataForRelations(attributeName, object) {	var self = this,		attributeValue,		idCollection;					attributeValue = object[attributeName];	if (!attributeValue) {		return;	}	idCollection = attributeValue.relations;		for (i = 0; i &lt; idCollection.length; i++) {		this.renderer			.startElement("div")			.addClass("relation");		this.buildCellDataForRelation(attributeName, idCollection[i], i, object);		this.renderer.finishElement();	}			}</body></methods><methods><class-id>AppeX.GenericPresenter</class-id> <category>building - breadcrumbs</category><body package="AppeX-Scaffolding">buildAnchorForBreadcrumb(view) {	var self = this;	this.renderer		.startElement("a")		.text(view.getBreadcrumbText())		.setAttribute("href", "javascript:")		.onClick(function (event) {			//navigate back up the stack to find the proper object			self.closeToView(view);		})		.finishElement();			}</body><body package="AppeX-Scaffolding">buildBreadcrumbCellDataWithViewAndAnchor(view, anchorBoolean) {	if (anchorBoolean) {		this.buildAnchorForBreadcrumb(view);	} else {		this.renderer.addClass("simple");		this.renderer.text(view.getBreadcrumbText()); 	};			}</body><body package="AppeX-Scaffolding">buildBreadcrumbCellWithViewAndAnchor(view, anchorBoolean) {	this.renderer.startElement("span");	this.buildBreadcrumbCellDataWithViewAndAnchor(view, anchorBoolean);	this.renderer.finishElement()	// finish &lt;span&gt;}</body><body package="AppeX-Scaffolding">buildBreadcrumbRow(){	this.buildBreadcrumbRowCells();}</body><body package="AppeX-Scaffolding">buildBreadcrumbRowCells(object, rowIndex) {	var views = this.scaffold.getViewStack(this.scaffoldingContainerId()),		len = views.length;	if (len === 1) {		return; //already on home page	}	for (var i = 0; i &lt; views.length; i++) {		if (i !== 0) {			//add a separator			this.renderer				.startElement("span")				.addClass("breadcrumb-span")				//.text(" / ")				.finishElement();		}		//build a link for all but the current view		this.buildBreadcrumbCellWithViewAndAnchor(views[i], i !== views.length - 1);	}}</body><body package="AppeX-Scaffolding">buildBreadcrumbs() {	this.renderer.startElement("div");	this.buildBreadcrumbRow();	this.renderer.finishElement();}</body><body package="AppeX-Scaffolding"> closeToView(view) {	var containerId,		presenter,		views,		length,		eView;			containerId = this.scaffoldingContainerId();	views = this.scaffold.getViewStack(containerId),	len = views.length;	for (var i = 0; i &lt; len; i++) {		eView =  this.scaffold.topView(containerId);		if (eView !== view ) {			this.scaffold.popView(containerId);		} else {			break;		}	}			this.resetCssClasses();	this.renderer.emptyContainer(containerId);	eView.buildView();	}</body></methods><methods><class-id>AppeX.GenericPresenter</class-id> <category>user messages</category><body package="AppeX-Scaffolding">_translate(key, defaultString, catalogId) {	return this.client._translate(key, defaultString, catalogId);}</body></methods><methods><class-id>AppeX.GenericPresenter</class-id> <category>calculated</category><body package="AppeX-Scaffolding">newDomainObjectFrom(anObjectData, objectType) {		var objectTypeInfo = this.scaffold.getObjectTypeInfo(objectType);	return new AppeX.DomainObject(anObjectData, objectTypeInfo);}</body></methods><methods><class-id>AppeX.GenericPresenter</class-id> <category>testing</category><body package="AppeX-Scaffolding">isCollection(anAttributeName) {	var objectTypeInfo;	objectTypeInfo = this.scaffold.getObjectTypeInfo(this.path) ;		if (objectTypeInfo[anAttributeName] === undefined) { 		return false;  //this attribute was added by client, not defined by schemaInfo	}	return objectTypeInfo[anAttributeName]['isCollection']}</body><body package="AppeX-Scaffolding">isDomainObject(anAttributeName) {	var objectTypeInfo;	objectTypeInfo = this.scaffold.getObjectTypeInfo(this.path) ;		if (objectTypeInfo[anAttributeName] === undefined) { 		return false;  //this attribute was added by client, not defined by schemaInfo	}	return !!objectTypeInfo[anAttributeName]['path']}</body></methods><methods><class-id>AppeX.ObjectPresenter</class-id> <category>open main view</category><body package="AppeX-Scaffolding">buildContentRows(){	var odd=true,		rowClass;	for (var i = 0; i &lt; this.attributeNames.length; i++ ) {		rowClass = odd ? "odd" : "even";		this.renderer			.startElement("tr")			.addClass("content-row")			.addClass(rowClass);		this.buildRowCells(this.attributeNames[i], this.object);			this.renderer.finishElement();		odd = !odd;	}}</body><body package="AppeX-Scaffolding">buildLabelCell(attributeName){	this.renderer		.startElement("td")		.addClass("label");	this.buildLabelText(attributeName);	this.renderer.finishElement();	// finish &lt;td&gt;}</body><body package="AppeX-Scaffolding">buildLabelText(attributeName) {	var labelText = this.labelForAttributeName(attributeName);	this.renderer		.startElement("div")		.text(labelText)		.finishElement()	// finish &lt;div&gt;}</body><body package="AppeX-Scaffolding">openMainView(object, path) {	this.path = path;	this.setObject(object);	this.attributeNames = this.getAttributeNames(this.path);	this.setRenderer();	this.buildView();}</body><body package="AppeX-Scaffolding">setObject(object) {	this.object = object;	return this;}</body></methods><methods><class-id>AppeX.EditPresenter</class-id> <category>actions</category><body package="AppeX-Scaffolding">accept() {	var args = {},		invalidInputs,		invalidTextStrings,		validationTextArea,		validationText = "";							//validation	validationTextArea = this.renderer.find("#validation-errors");	this.addClassTo('hidden', validationTextArea);	invalidTextStrings = this.validationOnAccept();	this.validateAllUnvalidatedAttributes();	for (i = 0; i &lt; this.unvalidatedAttributes.length; i++) {		invalidTextStrings.push("Must correct " + this.unvalidatedAttributes[i]);	}	for (i = 0; i &lt; invalidTextStrings.length ; i++) {		if (i &gt; 0) {			validationText = validationText + " \r"		}		validationText = validationText + invalidTextStrings[i];	}	if (validationText) {		this.setElementText(validationTextArea, validationText);		this.removeClassFrom('hidden', validationTextArea);		return;	}	//submitting request	args.input = this.createRequestArguments();	if (Object.keys(args).length === 0) {		return this.cancel();	}		if (this.object.id) {		this.acceptPost(args);	} else {		this.acceptPut(args);	};}</body><body package="AppeX-Scaffolding">acceptPost(args) {	var self = this;	args.input.id = this.object.id;	args.output = ["#self", "#webPrint"];	this.client		.POST(this.path, args)		.onSuccess(function (updatedObjects) {			$t.debug("POST " + self.path + " success");			self.object = self.newDomainObjectFrom(updatedObjects[0]["#self"], self.path);			$t.replace(self.memento, self.object);			self.changes = updatedObjects[0];			self.closeAndReturn();		});}</body><body package="AppeX-Scaffolding">acceptPut(args) {	var self = this;	if (this.output !== null) {		args.output = this.output;	};	this.client		.PUT(this.path, args)		.onSuccess(function (updatedObjects) {			$t.debug("PUT " + self.path + " success");			self.changes = updatedObjects;			self.closeAndReturn();		});}</body><body package="AppeX-Scaffolding">addExistingRelation(attributeName) {	// Open a selection view with a list of object from which a selection can be made.	// if we implement a custom method for attributeName input, we have to call it here and return.	var objectTypeInfo,		attributeType,		methodName;			methodName = "addExistingRelation_" + attributeName;	if (!!this[methodName]) {		this[methodName](attributeName);		return;	}		objectTypeInfo = this.scaffold.getObjectTypeInfo(this.path);	attributeType = objectTypeInfo[attributeName];		this.selectExistingRelations(attributeName, null, attributeType.path);}</body><body package="AppeX-Scaffolding">addNewRelation(attributeName) {	var	self = this,		objectTypeInfo,		attributeTypeInfo,		attributeNames,		newObject,		editor,		output;					objectTypeInfo = this.scaffold.getObjectTypeInfo(this.path);	attributeTypeInfo = objectTypeInfo[attributeName];	attributeNames = this.getAttributeNames(attributeTypeInfo.path);	newObject = this.createNewObject(attributeNames, attributeTypeInfo.path);	output = ["id", "#webPrint" ];	editor = this.openEditRelationView(newObject, attributeTypeInfo.path, output);	editor.onReturn(function () {		var aRelationInfo;		if (editor.changes) {			aRelationInfo = editor.changes[0];			self.addToAttributeNameRelationInfo(attributeName, aRelationInfo);		} 	});}</body><body package="AppeX-Scaffolding">addToAttributeNameRelationInfo(attributeName, relationInfo) {	var	relation;			relation = this.setRelationForAttributeName(attributeName);	if (!relation.isCollection()) {		//1-1 relation, so replacing any relationInfo that is already there		relation.relations = [];	}	relation.add(relationInfo["#webPrint"], relationInfo.id);	}</body><body package="AppeX-Scaffolding">cancel() {	this.closeView();}</body><body package="AppeX-Scaffolding">createRequestArguments() {	return this.object.differencesFrom(this.memento);}</body><body package="AppeX-Scaffolding">openObjectView(domainObject, url, attributeName) {	var self = this,		editor;			editor = this.openEditView(domainObject, url);	editor.onReturn(function() {		var aRelation;		if (!editor.changes) {			return;		}		aRelation = self.object[attributeName];		aRelation.removeById(domainObject.id);			aRelation.add(editor.changes["#webPrint"], domainObject.id);		});}</body><body package="AppeX-Scaffolding">selectExistingRelations(attributeName, inputArgs, path) {	// Open a selection view with a list of object from which a selection can be made.	var	presenter,		attributeType,		self = this;	presenter = this.openSelectionView(attributeName, inputArgs, path, this.object);	presenter.onReturn(function() {		var eSelectedObject,			selectedObjects,			i;			if (!presenter.changes) {			return;		}		selectedObjects = presenter.changes;		// Add the selectedObjects to the collection of objects held in attributeName		for (i = 0; i &lt; selectedObjects.length; i++) {			eSelectedObject = selectedObjects[i];			eSelectedObject['#webPrint'] = eSelectedObject.print;		}		self.updateRelations(attributeName, selectedObjects);		});}</body><body package="AppeX-Scaffolding">setRelationForAttributeName(attributeName) {	var	relation,		attributeTypeInfo;			attributeTypeInfo = this.scaffold.getObjectTypeInfo(this.path)[attributeName];	relation = this.object[attributeName] || new AppeX.Relation(attributeTypeInfo);	this.object[attributeName] = relation;	return relation;}</body><body package="AppeX-Scaffolding">updateObject(attributeName, newValue) {	this.object[attributeName] = newValue;}</body><body package="AppeX-Scaffolding">updateRelations(attributeName, data) {	var eItem,		relation;			relation = this.setRelationForAttributeName(attributeName); 	relation.relations = [];	for ( i = 0; i &lt; data.length; i++) {		eItem = data[i];		relation.add(eItem["#webPrint"], eItem.id);	}}</body></methods><methods><class-id>AppeX.EditPresenter</class-id> <category>accessing</category><body package="AppeX-Scaffolding">presenterType() {	return "edit"}</body></methods><methods><class-id>AppeX.EditPresenter</class-id> <category>build simple data types</category><body package="AppeX-Scaffolding">buildBooleanType(attributeName, attributeValue) {	var	self = this;	this.convertInputToCheckbox(attributeValue);	this.renderer.onChange(function (input) {		self.updateObject(attributeName, input.checked);	})}</body><body package="AppeX-Scaffolding">buildCellDataForSimpleType(attributeName) {	var self = this,		objectTypeInfo,		attributeValue,		attributeType,		methodName,		customValidationMethodName,		isNullable;			// Todo add dynamic customization for attributeValue		objectTypeInfo = this.scaffold.getObjectTypeInfo(this.path);	attributeValue = this.object[attributeName];	attributeType = objectTypeInfo[attributeName].type;	isNullable = this.isNullable(attributeName);	if (!isNullable) {		this.renderer.addClass("required");	}		// if we implement a custom method for attributeName input,  call it here and return.	methodName = "buildCellDataFor_" + attributeName;	if (!!this[methodName]) {		this[methodName](attributeValue);		return;	}		this.renderer		.startElement("input")		.setId(this.getInputIdForAttribute(attributeName));	this.inputElements[attributeName] = this.renderer.getCurrentElement();			this.buildCellDataAccordingToType(attributeName, attributeType, attributeValue);		this.renderer.onChange(function (input) { 		self.validateInput(input, attributeName, attributeType) ;	});	this.renderer.finishElement();		this.checkToBuildValidationDivForAttributeName(attributeName);}</body><body package="AppeX-Scaffolding">buildDateType(attributeName, attributeValue){	var	self = this;	this.renderer		.setAttribute("type", "text")		.addClass("date")		.val(attributeValue)		.onChange(function(input) {			self.updateObject(attributeName, input.value);		});}</body><body package="AppeX-Scaffolding">buildDefaultType(attributeName, attributeValue){	var	self = this;	this.renderer		.val(attributeValue)		.onChange(function(input) {			self.updateObject(attributeName, input.value);		})}</body><body package="AppeX-Scaffolding">buildNumberType(attributeName, attributeValue) {	var	self = this;	this.renderer		.val(attributeValue)		.setAttribute("type", "number")		.onChange(function(input) {				var anHtmlElement, aNumber;				anHtmlElement = self.getHtmlElementFor(input);				aNumber = parseFloat(anHtmlElement.value); 				self.updateObject(attributeName, aNumber);		});}</body><body package="AppeX-Scaffolding">buildRadioButtonFor(attributeName, attributeLabel, attributeValue, checkedValue) {		var self = this;		this.renderer.startElement("input");		this.renderer		.setAttribute("type", "radio")		.setAttribute("name", attributeName)		.setAttribute("value", checkedValue)		.onChange(function (input) {			if (input.checked) {				self.updateObject(attributeName, checkedValue);			}		});	if (!!attributeValue) {			if (attributeValue.toLowerCase() === checkedValue) {			this.renderer.setAttribute("checked", "checked");		}	}	this.renderer.finishElement();		this.renderer		.startElement("span")		.text(attributeLabel)		.finishElement();}</body><body package="AppeX-Scaffolding">buildStringType(attributeName, attributeValue) {	var self = this;	this.renderer		.setAttribute("type", "text")		.addClass("text")		.val(attributeValue)		.onChange(function(input) {			self.updateObject(attributeName, input.value); 		});}</body><body package="AppeX-Scaffolding">buildTimeType(attributeName, attributeValue){	var	self = this;	this.renderer		.val(attributeValue)		.onChange(function(input) {			self.updateObject(attributeName, input.value);		});}</body><body package="AppeX-Scaffolding">buildTimestampType(attributeName, attributeValue){	var	self = this;	this.renderer		.val(attributeValue)		.onChange(function(input) {			self.updateObject(attributeName, input.value);		})}</body><body package="AppeX-Scaffolding">getAcceptButtonId() {	return this.path + "-accept-button";}</body><body package="AppeX-Scaffolding">getAddExistingButtonIdForAttribute(attributeName) {	return this.path + "-" + attributeName + "-add-existing-button";}</body><body package="AppeX-Scaffolding">getAddNewButtonIdForAttribute(attributeName) {	return this.path + "-" + attributeName + "-add-new-button";}</body><body package="AppeX-Scaffolding">getInputIdForAttribute(attributeName) {	return this.path + "-" + attributeName + "-input";}</body></methods><methods><class-id>AppeX.EditPresenter</class-id> <category>validation</category><body package="AppeX-Scaffolding">attributesNotRequiringBasicValidation() {	//override to exempt attributes from basic validation	return [];		}</body><body package="AppeX-Scaffolding">buildValidationArea() {	this.renderer		.startElement("div")		// This is a special div with "preformatted wrapping" white space handling.		// We don't want external stylesheets to override this, let's include the style right here.		.setAttribute("style", "white-space: pre-wrap")		.setId("validation-errors")		.addClass('hidden')		.addClass('error')		.addClass('validation');	this.renderer.finishElement();}</body><body package="AppeX-Scaffolding">checkForCustomValidation(input, attributeName) {	var customValidationMethodName =  "validate_" + attributeName,		validationText ="";	if (this[customValidationMethodName]) {		validationText = this[customValidationMethodName](input);	}	return validationText;		}</body><body package="AppeX-Scaffolding">checkIsNullableValidation(attributeName) {	var isNullable,		attributeValue,		hasNoValue,		validationText ="";			attributeValue = this.object[attributeName];	isNullable = this.isNullable(attributeName);	hasNoValue = !attributeValue || (attributeValue &amp;&amp; attributeValue.relations &amp;&amp; attributeValue.relations.length === 0);  //check for empty Relation	if (!isNullable &amp;&amp; hasNoValue) {		validationText = "required";	}	return validationText;		}</body><body package="AppeX-Scaffolding">checkToBuildValidationDivForAttributeName(attributeName) {		this.renderer		.startElement("div")		.text("Validation errors go here.")		.setId(this.getInputIdForAttribute(attributeName) + '-error')		.addClass("hidden")		.addClass("error")		.addClass("validation")		.finishElement();	}</body><body package="AppeX-Scaffolding">disableAccept() {	var aButton = this.getAcceptButton();	this.setAttrFor("disabled", "disabled", aButton)	}</body><body package="AppeX-Scaffolding">enableAccept() {	var aButton = this.getAcceptButton();	this.setAttrFor("disabled", false, aButton)	}</body><body package="AppeX-Scaffolding">getAcceptButton() {		return window.document.getElementById(this.getAcceptButtonId());}</body><body package="AppeX-Scaffolding">hideInvalidFor(attributeName) {	var 	inputId,		errorId,		inputElement,		errorElement;	inputId = this.getInputIdForAttribute(attributeName);	inputElement = window.document.getElementById(inputId);	this.removeClassFrom("invalid", inputElement);	errorId = inputId + "-error";	errorElement = window.document.getElementById(errorId);	this.addClassTo('hidden', errorElement);}</body><body package="AppeX-Scaffolding">requiresBasicValidation(attributeName) {	return this.attributesNotRequiringBasicValidation().indexOf(attributeName) === -1;		}</body><body package="AppeX-Scaffolding">showInvalidFor(attributeName, validationText) {	var 	inputId,		errorId,		inputElement,		errorElement;	inputId = this.getInputIdForAttribute(attributeName);	inputElement = window.document.getElementById(inputId);	this.addClassTo('invalid', inputElement);	errorId = inputId + "-error";	errorElement = window.document.getElementById(errorId);	this.removeClassFrom("hidden", errorElement);	this.setElementText(errorElement, validationText);}</body><body package="AppeX-Scaffolding">updateAcceptButton() {	if (this.unvalidatedAttributes.length &gt; 0) {		this.disableAccept();	} else {		this.enableAccept();	}	}</body><body package="AppeX-Scaffolding">updateAttributeWithValidationText(attributeName, validationText) {	var anIndex;		anIndex = this.unvalidatedAttributes.indexOf(attributeName);		if (!validationText) {		this.hideInvalidFor(attributeName);		if (anIndex &gt; -1) {			this.unvalidatedAttributes.splice(anIndex, 1);		}	} else {		this.showInvalidFor(attributeName, validationText);		if (anIndex === -1) {			this.unvalidatedAttributes.push(attributeName);		}	}}</body><body package="AppeX-Scaffolding">updateValidationTextArea() {	if (this.unvalidatedAttributes.length &gt; 0) {		this.disableAccept();	} else {		this.enableAccept();	}	}</body><body package="AppeX-Scaffolding">validateAllUnvalidatedAttributes() {	var	i,		eAttributeName,		eAttributeType,		eInput,		objectTypeInfo,		anArrayCopy;			objectTypeInfo = this.scaffold.getObjectTypeInfo(this.path);	anArrayCopy = this.unvalidatedAttributes.slice();	for (i = 0; i &lt; anArrayCopy.length; i++) {		eAttributeName =  anArrayCopy [i];		eAttributeType = objectTypeInfo[eAttributeName].type;		eInput = this.inputElements[eAttributeName];		if (eInput) {			this.validateInput(eInput, eAttributeName, eAttributeType); //may remove elements from unvalidatedAttributes		} else {			this.validateObjectValue(eAttributeName);		}	}}</body><body package="AppeX-Scaffolding">validateInput(input, attributeName, attributeType) {	var basicValidationMethodName,		basicValidationMethod,		knownSelectors,		validationText;		 knownSelectors = [		"validateType_String",		"validateType_Number",		"validateType_Time"	];		if (this.requiresBasicValidation(attributeName)) {		basicValidationMethodName = "validateType_" + attributeType;		basicValidationMethod = this[basicValidationMethodName];		if (basicValidationMethod) {			validationText = this[basicValidationMethodName](input);		}	}	if (!validationText) {		validationText = this.checkForCustomValidation(input, attributeName);	}	if (!validationText) {		validationText = this.checkIsNullableValidation(attributeName);	}	this.updateAttributeWithValidationText(attributeName, validationText);	this.updateAcceptButton();}</body><body package="AppeX-Scaffolding">validateObjectValue(attributeName) {	var validationText;		validationText = this.checkIsNullableValidation(attributeName);	this.updateAttributeWithValidationText(attributeName, validationText);	this.updateAcceptButton();}</body><body package="AppeX-Scaffolding">validateType_Number(input, min, max) {	var aString,		aNumber,		anHtmlElement,		validationText = "";		this.removeClassFrom('invalid', input);	anHtmlElement = this.getHtmlElementFor(input);	//anHtmlElement.valueAsNumber not fully supported in IE, .value supported diffferently by browser	if(isNaN(anHtmlElement.value) || isNaN(parseFloat(anHtmlElement.value))) {		isValid = false;		this.addClassTo('invalid', input);		validationText = "Value must be a number";		return validationText;	} 	aNumber = parseFloat(anHtmlElement.value); 	if ((min &amp;&amp; aNumber &lt; min) || (max &amp;&amp; aNumber &gt; max)) {		validationText = "Value must be between " + min + " and " + max + ".";		this.addClassTo('invalid', input);	}	return validationText;}</body><body package="AppeX-Scaffolding">validateType_String(input, minLength, maxLength) {	var aString,	validationText = "";		this.removeClassFrom('invalid', input);	aString = this.renderer.getVal(input);	if (aString.length &lt; minLength || aString.length &gt; maxLength) {		validationText = "String length must be between " + minLength + " and " + maxLength + ".";		this.addClassTo('invalid', input);	} 	return validationText;}</body><body package="AppeX-Scaffolding">validateType_Time(input, min, max) {	var aString,		anArray,		hour,		minute,		second,		validationText = "";		this.removeClassFrom('invalid', input);	aString = this.renderer.getVal(input).trim();	anArray = aString.split(':');	if (anArray.length !== 3) {		this.addClassTo('invalid', input);		validationText = "Time must be in the format 'xx:xx:xx' where the x's are numbers";		return validationText;	}; 		hour = parseInt(anArray[0]);	if (isNaN(hour) || hour &lt; 0 || hour &gt; 24) {		this.addClassTo('invalid', input);		validationText = "Hour must be a number between 00 and 24";		return validationText;	};	minute = parseInt(anArray[1]);	if (isNaN(minute) || anArray[1].trim().length !==2 || minute &lt; 0 || minute &gt; 60) {		this.addClassTo('invalid', input);		validationText = "Minute must be a number between 00 and 60";		return validationText;	};	second = parseInt(anArray[1]);	if (isNaN(second) || anArray[1].trim().length !==2 || second &lt; 0 || second &gt; 60) {		this.addClassTo('invalid', input);		validationText = "Second must be a number between 00 and 60";		return validationText;	};	return validationText;}</body><body package="AppeX-Scaffolding">validationOnAccept() {	//return the result of additional checks that are performed only on accept 		return [];}</body></methods><methods><class-id>AppeX.EditPresenter</class-id> <category>validation - renderer</category><body package="AppeX-Scaffolding">addClassTo(aClassName, anElement) {	this.renderer.pushElement(anElement);	this.renderer.addClass(aClassName);	this.renderer.finishElement();}</body><body package="AppeX-Scaffolding">getHtmlElementFor(anElement) {	var anHtmlElement;	this.renderer.pushElement(anElement);	anHtmlElement = this.renderer.getCurrentHtmlElement();	this.renderer.finishElement();	return anHtmlElement;}</body><body package="AppeX-Scaffolding">removeClassFrom(aClassName, anElement) {	this.renderer.pushElement(anElement);	this.renderer.removeClass(aClassName);	this.renderer.finishElement();}</body><body package="AppeX-Scaffolding">setAttrFor(attrName, attrValue, anElement) {	this.renderer.pushElement(anElement);	this.renderer.setAttribute(attrName, attrValue);	this.renderer.finishElement();}</body><body package="AppeX-Scaffolding">setElementText(anElement, aString) {	this.renderer.pushElement(anElement);	this.renderer.text(aString);	this.renderer.finishElement();}</body></methods><methods><class-id>AppeX.EditPresenter</class-id> <category>open main view</category><body package="AppeX-Scaffolding">buildAcceptButton() {	var self = this;		this.renderer		.startElement("button")		.text(this.buttonLabelAccept())		.addClass("accept")		.setId(this.getAcceptButtonId())		.onClick(function (event) { self.accept() })		.finishElement();			return this;}</body><body package="AppeX-Scaffolding">buildCancelButton() {	var self = this;			this.renderer		.startElement("button")		.text(this.buttonLabelCancel())		.addClass("cancel")		.onClick(function (event) { self.cancel() })		.finishElement();	return this;}</body><body package="AppeX-Scaffolding">buildDefaultActionButtons() {	this.buildAcceptButton();	this.buildCancelButton();	this.buildValidationArea();	return this;}</body><body package="AppeX-Scaffolding">buildLabelText(attributeName) {	var labelText = this.labelForAttributeName(attributeName);	this.renderer		.startElement("label")		.setAttribute("for", this.getInputIdForAttribute(attributeName))		.text(labelText)		.finishElement();}</body><body package="AppeX-Scaffolding">buildView() {	this.callSuper("buildView", []);	//must be done after buildView	//this.unvalidatedAttributes = Object.keys(this.inputElements);	this.unvalidatedAttributes = this.attributeNames.slice();	this.validateAllUnvalidatedAttributes();	this.updateAcceptButton();		}</body><body package="AppeX-Scaffolding">getBreadcrumbText() {// Answer the title.// Subclasses may override.	return this.getTitle();}</body><body package="AppeX-Scaffolding">getTitleAction() {// Answer the title of this presenter. Subclasses are responsible.	if (this.memento.id) {		return 'Update'	} else {		return 'Create'	}}</body><body package="AppeX-Scaffolding">getTitleDetails() {// Answer the details of the title. Normally, this is the this first of the attribute names of the Active Record object(s)// Subclasses may override.	if(!this.memento.id) {		return "a new " + this.path;	}	if(this.attributeNames.length &gt; 0) {		return this.memento[this.attributeNames[0]];	} else {		return "a " + this.path;	}}</body><body package="AppeX-Scaffolding">openEditRelationView(object, path, output) {	var presenter;	presenter = this.scaffold.getPresenter(path, "edit");	presenter.output = output;	this.openPresenter(presenter, object, path);	return presenter;}</body><body package="AppeX-Scaffolding">openSelectionView(attributeName, inputArgs, path, object) {	var	presenter,		attributeType,		aRelation;		attributeType = this.scaffold.getObjectTypeInfo(this.path)[attributeName];	presenter = this.scaffold.getPresenter(path, "select");	presenter.setRelationType(attributeType.isCollection);	aRelation = object[attributeName] || new AppeX.Relation();	presenter.setPreviousSelections(aRelation);	return this.openPresenter(presenter, inputArgs, path);}</body><body package="AppeX-Scaffolding">setObject(original) {	this.memento = original;	this.object = original.copyObject();	this.objectTypeInfo = this.scaffold.getObjectTypeInfo(this.path);	return this;}</body><body package="AppeX-Scaffolding">windowLocationHash(){		var hash = this.object.id || "new";	return "edit/" + this.path + "/" + hash;}</body></methods><methods><class-id>AppeX.EditPresenter</class-id> <category>button labels</category><body package="AppeX-Scaffolding">buttonLabelAccept() {	return "Accept";}</body><body package="AppeX-Scaffolding">buttonLabelAddNew(attributeName) {	var attributeType = this.scaffold.getObjectTypeInfo(this.path)[attributeName];	if (attributeType.isCollection ){		return "Add new...";	} else {		return "Create new...";	}}</body><body package="AppeX-Scaffolding">buttonLabelSelectExisting(attributeName) {	return "Select existing...";}</body></methods><methods><class-id>AppeX.EditPresenter</class-id> <category>build relation data types</category><body package="AppeX-Scaffolding">buildActionsForRelation(attributeName) {	var self = this;	// Wrap buttons in a &lt;div&gt;	this.renderer		.startElement("div")		.addClass("actions");			//Add New and Add Existing Buttons	this.renderer		.startElement("button")		.setId(this.getAddNewButtonIdForAttribute(attributeName))		.text(this.buttonLabelAddNew(attributeName))		.addClass("add")		.addClass("new")		.onClick(function (event) { self.addNewRelation(attributeName) })		.finishElement();				this.renderer		.startElement("button")		.setId(this.getAddExistingButtonIdForAttribute(attributeName))		.text(this.buttonLabelSelectExisting(attributeName))		.addClass("add")		.addClass("existing")		.onClick(function (event) { self.addExistingRelation(attributeName) })		.finishElement();				this.renderer.finishElement();		// &lt;div&gt;								}</body><body package="AppeX-Scaffolding">buildCellDataForRelations(attributeName) {		var 	isNullable;	//Add New and Add Existing Buttons	this.buildActionsForRelation(attributeName);				isNullable = this.isNullable(attributeName);		if (!isNullable) {		this.renderer.addClass("required");	}		this.callSuper("buildCellDataForRelations", [attributeName, this.object]);	this.checkToBuildValidationDivForAttributeName(attributeName);}</body></methods><methods><class-id>AppeX.EditPresenter</class-id> <category>initializing</category><body package="AppeX-Scaffolding">initialize() {	this.inputElements = {};}</body></methods><methods><class-id>AppeX.EditPresenter</class-id> <category>testing</category><body package="AppeX-Scaffolding">isNullable(attributeName) {	var objectTypeInfo;			objectTypeInfo = this.scaffold.getObjectTypeInfo(this.path);	return objectTypeInfo[attributeName].isNullable !== false;	}</body></methods><methods><class-id>AppeX.BoldScaffoldingTheme</class-id> <category>accessing</category><body package="AppeX-Scaffolding">decorations"Answer a String that is the main style of the theme. Return an empty string by default. Subclasses may override."	&lt;styleSheet: 10&gt;	^ super decorations, 'body {	font-family: sans-serif;}.actions {	background-color: rgba(170, 170, 170, 0.2);}button {	color: white;	background-color: rgba(0, 0, 127, 0.5);	border-radius: 5px;}button:hover {	background-color: rgba(0, 0, 127, 0.8);}button.accept {	font-weight: bold;}.actions button {	font-size: large;}.ListPresenter .odd {	background-color: rgba(85, 85, 85, 0.1);}.ListPresenter .even {	background-color: rgba(170, 170, 170, 0.1);}.appex-table .actions {	background-color: transparent;}.appex-table button {	font-size: x-small;}.appex-input {	font-size: initial;	border: 1px dotted rgba(127,127,127,0.2);	padding: 2px;}.appex-input.text {	width: 99%;}.appex-input.invalid {	background-color: lemonchiffon;	box-shadow: red 0px 0px 5px -1px inset;}.relations button {	background-color: transparent;}.relations button:hover {	color: DarkBlue;}.EditPresenter {	background-color: LightSalmon;}.EditPresenter .object-table {	background-color: rgba(255, 255, 255, 0.5);}.SelectionPresenter {	background-color: LightSalmon;}.SelectionPresenter .object-table {	background-color: rgba(255, 255, 255, 0.5);}'</body><body package="AppeX-Scaffolding">responsiveDecorations"Answer a String that contains the structural styling of Scaffolding elements."	&lt;styleSheet: 10.1&gt;	^'@media (min-width: 801px) {	body {		font-size: 120%;	}}'</body><body package="AppeX-Scaffolding">structure"Answer a String that contains the structural styling of Scaffolding elements."	&lt;styleSheet: 0&gt;	^ super structure, '.appex-table {	border-spacing: 0px;}.actions {	text-align: left;	padding: 1em 0.5em 1em;}.actions button {	margin-left: 0.5em;}.relations .actions {	text-align: left;	padding: 0px;}.appex-td button {	margin: 2px 0.5em 2px 0px;}.GenericPresenter .object-table .label {	width: 30%;	padding: 0.25em;}.GenericPresenter .object-table .data {	padding: 0.25em;}'</body></methods><methods><class-id>AppeX.Relation</class-id> <category>testing</category><body package="AppeX-Scaffolding">isCollection() {	return !!this._objectTypeInfo.isCollection}</body></methods><methods><class-id>AppeX.Relation</class-id> <category>actions</category><body package="AppeX-Scaffolding">add(print, id) {	var newObject = { print: print, id: id };	this.relations.push(newObject);}</body><body package="AppeX-Scaffolding">contains(aRelationInfo) {	var eRelationId;	for ( i = 0; i &lt; this.relations.length; i++ ) {		eRelationId =  this.relations[i].id;		if (eRelationId === aRelationInfo.id) {			return true;		}	}	return false;}</body><body package="AppeX-Scaffolding">copyObject() {	var	relationIndex,		copy;			copy = new this.constructor(this._objectTypeInfo);	for (relationIndex = 0; relationIndex &lt; this.relations.length; relationIndex++) {		copy.relations.push(this.relations[relationIndex]);	}	return copy;}</body><body package="AppeX-Scaffolding">getById(anId) {	var eRelationInfo;	for ( i = 0; i &lt; this.relations.length; i++ ) {		eRelationInfo = this.relations[i];		if (eRelationInfo.id === anId) {			return eRelationInfo;		}	}	return null;}</body><body package="AppeX-Scaffolding">isEquivalent(anotherRelation) {	var	i;	if (!anotherRelation) {		return false;	}	if (this.relations.length !== anotherRelation.relations.length) {		return false;	}	for (i = 0; i &lt; this.relations.length; i++) {		if (this.relations[i].id !== anotherRelation.relations[i].id) {			return false;		}	}	return true;}</body><body package="AppeX-Scaffolding">removeById(id) {	var eRelationId,		newArray = [];	for ( i = 0; i &lt; this.relations.length; i++ ) {		eRelationId =  this.relations[i].id;		if (eRelationId !== id) {			newArray.push(this.relations[i]);		}	}	this.relations = newArray;}</body><body package="AppeX-Scaffolding">removeByIndex(index) {	return this.relations.splice(index, 1);}</body><body package="AppeX-Scaffolding">replace(ind, print, id){	this.relations[ind] =  { print: print, id: id };}</body><body package="AppeX-Scaffolding">update( print, id){	if (this.isCollection()) {		this.add(print, id);	} else {		this.replace (0, print, id);	}}</body><body package="AppeX-Scaffolding">updateWebPrint(changed){	var aRelationInfo = this.getById(changed["#self"].id);	if (!aRelationInfo) {		return;	}	aRelationInfo.print = changed["#webPrint"];}</body></methods><methods><class-id>AppeX.Relation</class-id> <category>initialize-release</category><body package="AppeX-Scaffolding">initialize(objectTypeInfo){			if (objectTypeInfo) {		this._objectTypeInfo = objectTypeInfo;	}	this.relations = [];}</body></methods><methods><class-id>AppeX.Relation</class-id> <category>accessing</category><body package="AppeX-Scaffolding">getObjectTypeInfo() {	return this._objectTypeInfo || "Object";}</body><body package="AppeX-Scaffolding">path() {	return (this._objectTypeInfo &amp;&amp; this._objectTypeInfo.path) || "Object";}</body></methods><methods><class-id>AppeX.Scaffold</class-id> <category>presenters</category><body package="AppeX-Scaffolding">createMainPresenter() {	var path = this.mainPath();	return this.getPresenter(path, "list");}</body><body package="AppeX-Scaffolding">findPresenterClass(path, presenterType) {// For example: 'main', 'list'	var	aClass,		subclasses,		eClass,		key = path + "-" + presenterType;			aClass = AppeX.GenericPresenter;	subclasses = aClass.allSubclasses();	for (i = 0; i &lt; subclasses.length; i++ ) {		eClass = subclasses[i];		if (eClass.prototype.presenterType() === presenterType) {			aClass = eClass;			break;		}	};	if (aClass === AppeX.GenericPresenter) {		$t.debug("need to create subclass of GenericPresenter to handle " + presenterType);		return null;	};	subclasses = aClass.subclasses;	//if a more specialized presenter exists for the path, use it 	for (i = 0; i &lt; subclasses.length; i++ ) {		eClass = subclasses[i];		if (eClass.prototype.acceptPath(path)) {			aClass = eClass;			break;		}	};	this.presenterTable[key] = aClass;	return aClass;}</body><body package="AppeX-Scaffolding">getPresenter(path, presenterType) {// For example: 'main', 'list'	var	aClass,		presenter,		key = path + "-" + presenterType;		this.presenterTable = this.presenterTable || {};	if (!this.presenterTable[key]) {		aClass = this.findPresenterClass(path, presenterType);	} else {		aClass = this.presenterTable[key];	}		// at this point, reference is the class (the constructor function) of the presenter.	presenter = new aClass();	presenter.scaffold = this;	presenter.path = path;	presenter.client = this.client;	return presenter;}</body><body package="AppeX-Scaffolding">getViewStack(containerId) {	if (!this.viewStacks) {		this.viewStacks = {};	}		if (!this.viewStacks[containerId]) {		this.viewStacks[containerId] = [];	}	return this.viewStacks[containerId];}</body><body package="AppeX-Scaffolding">openMainView() {// If client defines its own opening behavior, do it.// Otherwise, delegate to the main presenter.	this.client.openMainView		? this.client.openMainView()		: this.createMainPresenter().openMainView();	}</body><body package="AppeX-Scaffolding">popView(containerId) {	return this.getViewStack(containerId).pop();}</body><body package="AppeX-Scaffolding">pushView(view, containerId) {	this.getViewStack(containerId).push(view);}</body><body package="AppeX-Scaffolding">topView(containerId) {	var stack;		stack = this.getViewStack(containerId);	if (stack.length === 0) {		return null;	}	return stack[stack.length - 1];}</body></methods><methods><class-id>AppeX.Scaffold</class-id> <category>initialize</category><body package="AppeX-Scaffolding">initialize(client){	this.client = client;	client.scaffold = this;	return this;}</body><body package="AppeX-Scaffolding">mainPath() {	// Subclasses should override with a correct path for the main view.	return this.client.mainPath		? this.client.mainPath()		: this.client.subclassResponsibility( "mainPath" );}</body></methods><methods><class-id>AppeX.Scaffold</class-id> <category>labels</category><body package="AppeX-Scaffolding">defaultFooterText(aPresenter) {// Answer the default text to be shown in this application's footer. Override to provide your own.	return "Built with AppeX Scaffolding, powered by Cincom Smalltalk&amp;trade;";}</body><body package="AppeX-Scaffolding">footerForPath(aPresenter) {	var methodName = "footerFor_" + aPresenter.path; 	if(!!this.client[methodName]) {		return this.client[methodName]();  //e.g. footerFor_personage()	}	return this.defaultFooterText(aPresenter)}</body><body package="AppeX-Scaffolding">labelForPathAndAttributeName(path, attributeName) {	var methodName = "labelFor_" + path  + "_" + attributeName; 	if(!!this.client[methodName]) {		return this.client[methodName]();  //e.g. labelFor_personage_dayOfBirth()	}	return attributeName.charAt(0).toUpperCase() + attributeName.slice(1); //e.g. "DayOfBirth"}</body></methods><methods><class-id>AppeX.Scaffold</class-id> <category>renderers</category><body package="AppeX-Scaffolding">getRendererClass() {	return AppeX.JQueryRenderer;	}</body><body package="AppeX-Scaffolding">scaffoldingContainerId() {// Return a string that uniquely identifies the id of the element in which I build my views.// The default is simply 'scaffolding-container'. Subclasses of ApplicationClient may implement their own.	return this.client.scaffoldingContainerId		? this.client.scaffoldingContainerId()		: "scaffolding-container";}</body><body package="AppeX-Scaffolding">setRenderer(aContainerId, aView) {// aContainerId and aView are optional.// if aContainerId is not provided, we use the default scaffoldingContainerId.// if aView is present, we will push it on to the view stack.	var	container,		containerId,		rendererClass;	containerId = aContainerId || this.scaffoldingContainerId(); 			container = document.getElementById(containerId);	rendererClass = this.getRendererClass();					this.renderer = new rendererClass(container);	this.renderer.emptyContainer(containerId);	if (aView) {		this.pushView(aView, containerId);	};		return this.renderer;}</body></methods><methods><class-id>AppeX.Scaffold</class-id> <category>building</category><body package="AppeX-Scaffolding">shouldBuildBreadCrumbs() {	//override in ApplicationClient subclasses if you want don't want to see breadcrumbs	return this.client.shouldBuildBreadCrumbs		? this.client.shouldBuildBreadCrumbs()		: true}</body></methods><methods><class-id>AppeX.Scaffold</class-id> <category>schema info</category><body package="AppeX-Scaffolding">getObjectTypeInfo(path) {	return this.objectTypeInfos[path];}</body></methods><methods><class-id>AppeX.ListPresenter</class-id> <category>build content</category><body package="AppeX-Scaffolding">attributeNameForLink() {	return this.attributeNames[0];}</body><body package="AppeX-Scaffolding">buildContentRows(){	var odd=true,		rowClass;	for (var i = 0; i &lt; this.objects.length; i++ ) {		rowClass = odd ? "odd" : "even";		this.renderer			.startElement("tr")			.addClass("content-row")			.addClass(rowClass);				this.buildRowCells(this.objects[i], i);		this.renderer.finishElement();		odd = !odd;	}}</body><body package="AppeX-Scaffolding">buildRowCells(object, rowIndex) {	var 	self = this;	for (var i = 0; i &lt; this.attributeNames.length; i++) {		this.buildAttributeCell(this.attributeNames[i], object, rowIndex);	}	if (!self.deleteObject) {		return;	}	// If I implement 'deleteObject' method, I will build an extra cell with a button to delete the object.	// Because deleting rows from the database can be tricky, depending on the context in which	// objects are viewed and the relational constraints between different tables,	// it is the responsibility of a subclass to implement 'deleteObject' that is approriate for the application.	// See AppeX-Examples-Scaffolding package for examples of 'deleteObject' method.	this.renderer		.startElement("td")		.addClass("delete-column")		.startElement("button")		.text(this.buttonLabelDelete())		.addClass("delete")		.onClick(function (event) { self.deleteObject(object) })		.finishElement()	// finish &lt;button&gt;		.finishElement();	// finish&lt;td&gt;}</body><body package="AppeX-Scaffolding">createLinkForObjectWithText(object, text) {	var self = this;	this.renderer		.startElement("a")		.addClass("detail-presenter-link")		.text(text)		.setAttribute("href", "javascript:")		.onClick(function (event) { self.viewObject(object); })		.finishElement();}</body><body package="AppeX-Scaffolding">setCellData(attributeName, object){	var self = this,		attributeMethod,		attributeValue,		i,		eText;	attributeMethod = "attributeValue_" + attributeName;	if (this[attributeMethod]) {		attributeValue = this[attributeMethod](object)	} else {		attributeValue = object[attributeName];	};	if (attributeValue instanceof AppeX.Relation) {		for (i = 0 ; i &lt; attributeValue.relations.length; i++ ) {			eText = attributeValue.relations[i].print;			this.renderer		  		.startElement("div")				.text(eText)				.finishElement();		}		return;	}		this.renderer.startElement("div");	if (this.attributeNameForLink() === attributeName ) {		this.createLinkForObjectWithText(object, attributeValue);	}	else {		if (this[attributeMethod]) {			this.renderer.text(attributeValue);		} else {			var objectTypeInfo = this.scaffold.getObjectTypeInfo(this.path);			var attributeType = objectTypeInfo[attributeName].type;			this.buildCellDataAccordingToType(attributeName, attributeType, attributeValue);		}	}	this.renderer.finishElement();		}</body></methods><methods><class-id>AppeX.ListPresenter</class-id> <category>build header</category><body package="AppeX-Scaffolding">buildHeaderCellForAttribute(attributeName) {	this.renderer		.startElement("th")		.setId(attributeName + "-header")		.text(this.labelForAttributeName(attributeName))		.finishElement()}</body><body package="AppeX-Scaffolding">buildHeaderRow() {	this.renderer		.startElement("tr")		.addClass("header-row");	this.buildHeaderRowCells();	this.renderer.finishElement();}</body><body package="AppeX-Scaffolding">buildHeaderRowCells() {	for (var i = 0; i &lt; this.attributeNames.length; i++ ) {		this.buildHeaderCellForAttribute(this.attributeNames[i]);	}}</body></methods><methods><class-id>AppeX.ListPresenter</class-id> <category>accessing</category><body package="AppeX-Scaffolding">presenterType() {	return "list"}</body><body package="AppeX-Scaffolding">setDomainObjectsFrom(objectData, objectType) {	var i,		eObjectData,		eDomainObject;	this.objects = [];	for (i = 0; i &lt; objectData.length; i++ ) {		eObjectData = objectData[i];		eDomainObject = this.newDomainObjectFrom(eObjectData, objectType);		this.objects.push(eDomainObject);	}}</body></methods><methods><class-id>AppeX.ListPresenter</class-id> <category>open main view</category><body package="AppeX-Scaffolding">buildAddNewButton() {	var self = this;		this.renderer		.startElement("button")		.text(this.buttonLabelAddNew())		.setId("button-new")		.addClass("add")		.addClass("new")		.onClick(function (event) { self.openNewObject(); })		.finishElement();		return this;}</body><body package="AppeX-Scaffolding">getTitleAction() {// Answer the title of this presenter. Subclasses are responsible.	return 'List of'}</body><body package="AppeX-Scaffolding">getTitleDetails() {// Answer the details of the title. Normally, this is the path of the Active Record object(s)// Subclasses may override.	return this.path + " objects"}</body><body package="AppeX-Scaffolding">openMainView() {	var self = this;				this.client		.GET(this.path)		.onSuccess(function (objectData) {			$t.debug("Get " + self.path + " success");			self.setObjectsAndAttributeNames(objectData);			self.setRenderer();			self.buildView();		});}</body><body package="AppeX-Scaffolding">setObjectsAndAttributeNames(objectData){	this.setDomainObjectsFrom(objectData, this.path);	this.attributeNames = this.getAttributeNames(this.path);}</body><body package="AppeX-Scaffolding">windowLocationHash(){	return "list/" + this.path;}</body></methods><methods><class-id>AppeX.ListPresenter</class-id> <category>building</category><body package="AppeX-Scaffolding">buildAttributeCell(attributeName, object, rowIndex){	var objectId;		objectId = object.id || rowIndex + 1;		this.renderer		.startElement("td")		.addClass(attributeName)		.setId(attributeName + "-" + objectId);	this.buildCellData(attributeName, object);	this.renderer.finishElement();}</body><body package="AppeX-Scaffolding">buildCellData(attributeName, object){	var self = this,		attributeMethod,		attributeValue,		i,		eText;	attributeMethod = "attributeValue_" + attributeName;	if (this[attributeMethod]) {		attributeValue = this[attributeMethod](object)	} else {		attributeValue = object[attributeName];	};	if (attributeValue instanceof AppeX.Relation) {		for (i = 0 ; i &lt; attributeValue.relations.length; i++ ) {			eText = attributeValue.relations[i].print;			this.renderer		  		.startElement("div")				.text(eText)				.finishElement();		}		return;	}		this.renderer.startElement("div");	if (this.attributeNameForLink() === attributeName ) {		this.createLinkForObjectWithText(object, attributeValue);	}	else {		if (this[attributeMethod]) {			this.renderer.text(attributeValue);		} else {			var objectTypeInfo = this.scaffold.getObjectTypeInfo(this.path);			var attributeType = objectTypeInfo[attributeName].type;			this.buildCellDataAccordingToType(attributeName, attributeType, attributeValue);		}	}	this.renderer.finishElement();		}</body><body package="AppeX-Scaffolding">buildDefaultActionButtons() {	this.buildAddNewButton();	return this;}</body><body package="AppeX-Scaffolding">buildView() {// If things have changed since the last time I built, I need to refresh my objects.	if (this.changes) {		this.refreshView();	} else {		this.callSuper("buildView", []);	}}</body><body package="AppeX-Scaffolding">defaultActionPlacement() {	// Answer "top" or "bottom" as an indicator of where actions should be placed.	// In ListPresenter, actions are rendered above content, at the top.	// Some presenters may override.		return "top";}</body><body package="AppeX-Scaffolding">refreshView() {	var self = this;				this.client		.GET(this.path)		.onSuccess(function (objectData) {			$t.debug("Get " + self.path + " success");			self.changes = null;			self.setObjectsAndAttributeNames(objectData);			self.buildView();		});}</body></methods><methods><class-id>AppeX.ListPresenter</class-id> <category>button labels</category><body package="AppeX-Scaffolding">buttonLabelDelete() {	return "Delete";}</body></methods><methods><class-id>AppeX.ListPresenter</class-id> <category>actions</category><body package="AppeX-Scaffolding">openNewObject() {	var self = this,		templateObject,		newObjects,		editor;		templateObject = this.createNewObject( this.attributeNames);	editor = this.openEditView(templateObject, this.path);	editor.onReturn(function () {		if (editor.changes) {			var eObjectData,				eDomainObject,				newObjects = editor.changes;			for (i = 0; i &lt; newObjects.length; i++ ) {				eObjectData = newObjects[i];				eDomainObject = self.newDomainObjectFrom(eObjectData, self.path);				self.objects.push(eDomainObject);			}		}	});}</body><body package="AppeX-Scaffolding">viewObject(object) {	this.openDetailView(object, this.path);	}</body></methods><methods><class-id>AppeX.DetailPresenter</class-id> <category>accessing</category><body package="AppeX-Scaffolding">presenterType() {	return "detail"}</body></methods><methods><class-id>AppeX.DetailPresenter</class-id> <category>open main view</category><body package="AppeX-Scaffolding">buildCloseButton() {	var self = this;	this.renderer		.startElement("button")		.text(this.buttonLabelClose())		.addClass("close")		.onClick(function(event) {			if (self.changes) {				self.closeAndReturn();			} else {				self.closeView();			}		})		.finishElement();		return this;}</body><body package="AppeX-Scaffolding">buildDefaultActionButtons() {	this.buildEditButton();	this.buildDeleteButton();	this.buildCloseButton();	return this;}</body><body package="AppeX-Scaffolding">buildDeleteButton() {	var self = this;	if (!this.deleteObject) {		return this;	}	// If I implement 'deleteObject' method, I will build an extra cell with a button to delete the object.	// Because deleting rows from the database can be tricky, depending on the context in which	// objects are viewed and the relational constraints between different tables,	// it is the responsibility of a subclass to implement 'deleteObject' that is approriate for the application.	// See AppeX-Examples-Scaffolding package for examples of 'deleteObject' method.	this.renderer		.startElement("button")		.text(this.buttonLabelDelete())		.addClass("delete")		.onClick(function(event) {self.deleteObject()})		.finishElement();	return this;}</body><body package="AppeX-Scaffolding">buildEditButton() {	var self = this;	this.renderer		.startElement("button")		.text(this.buttonLabelEdit())		.addClass("edit")		.onClick(function(event) {self.edit()})		.finishElement();	return this;}</body><body package="AppeX-Scaffolding">getTitleAction() {// Answer the title of this presenter. Subclasses are responsible.	return 'View'}</body><body package="AppeX-Scaffolding">getTitleDetails() {// Answer the details of the title. Normally, this is the this first of the attribute names of the Active Record object(s)// Subclasses may override.	if(this.attributeNames.length &gt; 0) {		return this.object[this.attributeNames[0]];	} else {		return "a " + this.path;	}}</body><body package="AppeX-Scaffolding">windowLocationHash(){	return "view/" + this.path + "/" + this.object.id;}</body></methods><methods><class-id>AppeX.DetailPresenter</class-id> <category>actions</category><body package="AppeX-Scaffolding">edit() {	return this.openEditView(this.object, this.path);}</body><body package="AppeX-Scaffolding">openObjectView(domainObject, aURL, attributeName) {	var self = this,		presenter;			presenter = this.openDetailView(domainObject, aURL);	presenter.onReturn(function () {		if (presenter.changes) {			self.object[attributeName].updateWebPrint(presenter.changes);		} 	});}</body><body package="AppeX-Scaffolding">openRelation(path, id) {	var self = this,		object,		args = {};		args.input = {};	args.input.id = id;		this.client		.GET(path, args)		.onSuccess(function (data) {			var domainObject;			$t.debug("Get " + path + " success");			domainObject = self.newDomainObjectFrom(data[0], path);			self.openDetailView(domainObject, path);		});}</body></methods><methods><class-id>AppeX.DetailPresenter</class-id> <category>button labels</category><body package="AppeX-Scaffolding">buttonLabelClose() {	return "Close";}</body><body package="AppeX-Scaffolding">buttonLabelDelete() {	return "Delete...";}</body><body package="AppeX-Scaffolding">buttonLabelEdit() {	return "Edit...";}</body></methods><methods><class-id>AppeX.SelectionPresenter</class-id> <category>build content</category><body package="AppeX-Scaffolding">buildContentRows(){	var odd=true,		rowClass;	for (var i = 0; i &lt; this.object.relations.length; i++ ) {		rowClass = odd ? "odd" : "even";		this.renderer			.startElement("tr")			.addClass("content-row")			.addClass(rowClass);				this.buildRowCells(this.object.relations[i], i);		this.renderer.finishElement();			odd = !odd;	}}</body><body package="AppeX-Scaffolding">buildRowCells(object, rowIndex) {	this.buildWebPresentationCell(object, rowIndex);	this.buildSelectionCell(object, rowIndex);}</body><body package="AppeX-Scaffolding">buildSelectionCell(object, rowIndex){	// Build the table row cell that contains a selection element for object.	this.renderer.startElement("td");	this.buildSelectionElement(object, rowIndex);	this.renderer.finishElement();}</body><body package="AppeX-Scaffolding">buildSelectionElement(object, rowIndex){	var	self = this,		button;	if (this.isCollection ) {		button = "checkbox";	} else {		button = "radio";	}	this.renderer		.startElement("input")		.setId(this.path + "-select-" + (rowIndex + 1))		.setAttribute("type", button)		.setAttribute("value", object.id)		.setAttribute("name", this.path)	//group for radiobuttons		.onClick(function(event){			self.toggleSelection(object);		});	if(this.previousSelections.contains(object)) {		this.renderer.setAttribute("checked", "checked");		this.toggleSelection(object);	}			this.renderer.finishElement();}</body><body package="AppeX-Scaffolding">buildWebPresentationCell(object, rowIndex){	// Print the selection presentation of object.	this.renderer		.startElement("td")		.text(object.print)		.addClass("appex-print")		.finishElement();}</body><body package="AppeX-Scaffolding">toggleSelection(object){	var 	index;		if (this.isCollection ) {		index = this.selections.indexOf(object);		if (index == -1) {			this.selections.push(object);		} else {			this.selections.splice(index, 1);		}	} else {		this.selections = [object];	}}</body></methods><methods><class-id>AppeX.SelectionPresenter</class-id> <category>initialize - release</category><body package="AppeX-Scaffolding">initialize(){	this.selections = [];}</body></methods><methods><class-id>AppeX.SelectionPresenter</class-id> <category>accessing</category><body package="AppeX-Scaffolding">presenterType() {	return "select"}</body><body package="AppeX-Scaffolding">setPreviousSelections(aRelation){		this.previousSelections = aRelation;}</body><body package="AppeX-Scaffolding">setRelationType(boolean){		this.isCollection = !!boolean;}</body></methods><methods><class-id>AppeX.SelectionPresenter</class-id> <category>open main view</category><body package="AppeX-Scaffolding">buildCancelButton() {	var self = this;		this.renderer		.startElement("button")		.text(this.buttonLabelCancel())		.addClass("cancel")		.onClick(function (event) {			self.closeAndReturn(); 		})		.finishElement();	return this;}</body><body package="AppeX-Scaffolding">buildContents() {	if (this.object.relations.length === 0) {			this.renderer			.startElement("div")			.text(this.selectionsEmptyText())			.addClass("selections-empty")			.finishElement();				return;	}	this.callSuper("buildContents");}</body><body package="AppeX-Scaffolding">buildSelectButton() {	var self = this;		if (this.object.relations.length !== 0) {			this.renderer			.startElement("button")			.text(this.buttonLabelSelect())			.addClass("select")			.onClick(function (event) {				self.changes = self.selections;				self.closeAndReturn(); 			})			.finishElement();	};	return this;}</body><body package="AppeX-Scaffolding">getTitleAction() {// Answer the title of this presenter. Subclasses are responsible.	return 'Select'}</body><body package="AppeX-Scaffolding">getTitleDetails() {// Answer the details of the title. Normally, this is the path of the Active Record object(s)// Subclasses may override.	return "from " + this.path + " objects"}</body><body package="AppeX-Scaffolding">openMainView(inputArgs, path) {	var self = this,		args = {};			if(inputArgs) 	{			args.input = inputArgs;	};	args.output = ["id", "#webPrint" ];			this.client		.GET(path, args)		.onSuccess(function (objects) {			var attributeTypeInfo,				eObject,				i;			$t.debug("Get " + path + " success");			attributeTypeInfo = self.scaffold.getObjectTypeInfo[self.path];			self.object = new AppeX.Relation(attributeTypeInfo);			for (i = 0; i &lt; objects.length; i++) {				eObject = objects[i];				self.object.add(eObject["#webPrint"], eObject.id);			}			self.setRenderer();			self.buildView();		});}</body><body package="AppeX-Scaffolding">selectionsEmptyText() {	return "There are no available selections fitting the specified criteria.";}</body><body package="AppeX-Scaffolding">windowLocationHash(){	return "select/" + this.path;}</body></methods><methods><class-id>AppeX.SelectionPresenter</class-id> <category>button labels</category><body package="AppeX-Scaffolding">buttonLabelSelect() {	return "OK";}</body></methods><methods><class-id>AppeX.SelectionPresenter</class-id> <category>building</category><body package="AppeX-Scaffolding">buildDefaultActionButtons() {	this.buildSelectButton();	this.buildCancelButton();	return this;}</body></methods><methods><class-id>AppeX.TinyScaffoldingTheme</class-id> <category>accessing</category><body package="AppeX-Scaffolding">decorations"Answer a String that is the main style of the theme. Return an empty string by default. Subclasses may override."	&lt;styleSheet: 10&gt;	^ super decorations, 'body {	font-family: sans-serif;	font-size: 0.8em;}.actions {	background-color: rgba(170, 170, 170, 0.3);}button {	font-size: small;	background-color: rgba(255, 255, 255, 0.85);	border: thin dotted rgba(0, 0, 127, 0.15);	border-radius: 3px;}button:hover {	background-color: rgba(127, 127, 128, 0.8);	color: white;}.odd {	background-color: rgba(85, 85, 85, 0.1);}.even {	background-color: rgba(170, 170, 170, 0.1);}.appex-table .actions {	background-color: transparent;}.appex-table button {	font-size: x-small;}.appex-input {	font-size: initial;	border: 1px dotted rgba(127,127,127,0.2);	padding: 2px;}.appex-input.text {	width: 99%;}.appex-input.invalid {	background-color: lemonchiffon;	box-shadow: red 0px 0px 5px -1px inset;}.relations button.add {	background-color: rgba(255, 255, 255, 0.05);}.relations button.delete {	background-color: transparent;}.relations button.add:hover {	background-color: rgba(127, 127, 128, 0.8);	color: white;}.relations button.delete:hover {	background-color: rgba(127, 127, 128, 0.8);	color: white;}.EditPresenter {	background-color: LightSkyBlue;}.EditPresenter .object-table {	background-color: rgba(255, 255, 255, 0.5);}'</body><body package="AppeX-Scaffolding">structure"Answer a String that contains the structural styling of Scaffolding elements."	&lt;styleSheet: 0&gt;	^ super structure, '.appex-table {	border-spacing: 0px;}.actions {	text-align: left;	padding: 1em 0.5em 1em;}.actions button {	margin-left: 0.5em;}.relations .actions {	text-align: left;	padding: 0px;}.appex-td button {	margin: 2px 0.5em 2px 0px;}.GenericPresenter .object-table .label {	width: 30%;	padding: 0.25em;}.GenericPresenter .object-table .data {	padding: 0.25em;}'</body></methods><methods><class-id>AppeX.Application class</class-id> <category>html</category><body package="AppeX-Scaffolding">scaffoldingContainer	&lt;body: 55&gt;	^'&lt;div id="scaffolding-container" &gt;&lt;/div&gt;'</body></methods><methods><class-id>AppeX.JavascriptLibrary class</class-id> <category>configuration</category><body package="AppeX-Scaffolding">scaffoldingLibrary	&lt;library: 'AppeX.ScaffoldingLibrary.js'&gt;		^self new  		addClass: Scaffold;		addClass: Relation;		addClass: DomainObject;		addClass: Renderer;		addClass: JQueryRenderer;		addClass: GenericPresenter;		addClass: ListPresenter;		addClass: ObjectPresenter;		addClass: DetailPresenter;		addClass: EditPresenter;		addClass: SelectionPresenter;			yourself.</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>JavascriptObject</name><environment>AppeX</environment><super>AppeX.JavascriptCode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>bootstrap</category><attributes><package>AppeX-Client</package></attributes></class><class><name>Theme</name><environment>AppeX</environment><super>AppeX.FileLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>styleSheetSelectors </inst-vars><class-inst-vars>styleSheetDefinitions </class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Server</package></attributes></class></st-source>