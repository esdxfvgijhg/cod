<?xml version="1.0"?><st-source><!-- Name: AppeX-ActiveRecordNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: The package provides a framework that simplifies creating a web application that involves access to database tables.To see the framework demos load AppeX-Examples-Scaffolding package. The demo classes will be used as examples to explain creating a web application with a database access.The AppeX-ActiveRecord framework uses Glorp Active Record framework to read, write or update objects as rows in database tables. The framework uses the following HTTP methods to impements database operations:- - - - - - - - - - - - - - - - - - HTTP method		DB Operation- - - - - - - - - - - - - - - - - - PUT				Creates a new recordPOST			Updates recordsDELETE			Deletes recordsGET				Read (retrieves) recordsA web application with DB access will have three main classes: an application that subclassed from AppeX.Application, a client class subclassed from AppeX.ApplicationClient and a descriptor system for active record objects that is a subclass of Glorp.ActiveRecords.ActiveRecordDescriptorSystem.The Driver demo has three main classes:DriverApplication - implements a server that provides DB operationsDriverClient  - implements a Javascript clientDriverSchema - the descriptor system that describes two tables: DRIVER and VEHICLE. A web application defines active record services with the #activeRecord:class: pragma. The pragma parameters are an url and the binding reference to a class derived from Glorp.ActiveRecords.ActiveRecord.A GlorpSession must be registered in the ProcessEnvironment via the ActiveRecord setSession: setter method. This is necessary to use the ActiveRecord API, such as <aClass> findAll. It is up to the application to ensure that #currentGlorpSession: is sent early in a request dispatch if the ActiveRecord API is used. The #activeRecord:class: service does this by default, but any other service intending to use ActiveRecord must send #currentGlorpSession: explicitly.ActiveRecord usage:DriverApplication>>processDriver	<GET>	<PUT>	<POST>	<DELETE>	<activeRecord: 'driver' class: #{AppeX.Driver}>	Active record service pragmas.The 'driver' string defines an URL path that will be used to find this service.The #{AppeX.Driver} binding reference defines the active record class  that provides API to execute queries to DRIVER table.In addition to #activeRecord:class: pragma the service method can define DB operations that can be performed on this active record.  Specifying HTTP methods <GET>, <PUT>, <POST> and <DELETE> means that this service allows to retrieve, create, update and delete rows from DRIVER table. If there is no HTTP method defined in the method the framework uses <GET> method as a default action and doesn't allow any other operations.	Encoding active record objects as JSON stringsThe instances of an active record classes are passed to a client encoded as JSON strings. Instance variables that represent relations are encoded with URL string and active record id.For example encoding an instance of Driver class where #vehicle is an instance of Vehicle is going to be:car1 := Vehicle new make: 'Honda'; model: 'SUV'; mileage: 1000; yourself.car2 := Vehicle new make: 'Chevrolet'; model: 'Camaro'; mileage: 1000; yourself.driver := Driver new 		name: 'John'; 		address: '123 Street';		isProfessionalDriver: false;		vehicles: (OrderedCollection  with: car1 with: car2); 		yourself.Encoded as JSON string and sent to a client: '{"id": 1, "name": "John", "address": "123 Street", "isProfessionalDriver": false, "#vehicles": {"path": "driver", "relations": [{"Honda SUV mileage: 1000": 1}, {"Chevrolet Camaro mileage: 1000": 2}]}}'To retrive the vehicle data a client should send the request: "GET vehicle?arguments={"input": {"id":1}}"	Executing DB queriesWhen a server receives a request with active record operation it does the following:- uses  the request method and the url path to find a service pragma. The Http request 'GET driver HTTP1.1' uses 'driver GET' string to find DriverApplication class>>processDriver service method.- using class parameter from the pragma <activeRecord:class:>  and request data parameters to find an active record. The following methods are default implementation to retrieve DB objects for different operations:	#activeRecordDELETERequest: aClass - finds instances of an active record ( aClass parameter ) to delete. If the request url doesn't have a query the method returns all instances of the active record class. If the url query specifies one or more id the methods returns a collection of object matching these ids.	#activeRecordGETRequest: aClass - finds and returns one or more active record objects. 	#activeRecordPOSTRequest: aClass - finds active record objects, starts Glorp unit of work, updates active records with new data from the request JSON data. Returns updated active record objects. If the request parameters don't include #id the ActiveRecordError error is raised.	#activeRecordPUTRequest: aClass  - creates a new instance from aClass parameter, decodes the request JSON data in to this instance and returns the instance. If the request parameters include active record #id the ActiveRecordError error is raised. - the active record objects are passed to the application service method. The application service method can defined a custom block for executing DB query. If the application service doesn't retun a block the default blocks are used to finish an active record operation. The execution blocks have two parameters: Glorp session and active record objects.	#executeActiveRecordDELETE - deletes active record objects	#executeActiveRecordGET - returns active record objects	#executeActiveRecordPOST - commits a unit of work 	#executeActiveRecordPUT  - commits a unit of work - the result of an execution block is encoded a JSON string and returned in HTTP response.Example:DriverApplication uses a few service methods to execute DB queries.The #processDriver method uses default execution blocks to retrieve, update, create or delete DB records.DriverApplication class>>processDriver	<GET>	<PUT>	<POST>	<activeRecord: 'driver' class: #{AppeX.Driver}>	Database login.Expected that an application provides Glorp login and creates a Glorp session. There a few ways to set a Glorp session.- Implement #newActiveRecordLogin and #activeRecordSystemDescriptor and use Application class>>setDefaultGlorpSession method to set a session specified in #newActiveRecordLogin method.- Use #initializeGlorpSession: aLogin with specified Glorp.Login. For example:	aLogin :=  Login new				database: SQLite3Platform new;				username: 'user name';				password: 'password';				connectString: 'driverTest.sqlite'.								DriverApplication initializeGlorpSession: aLogin.- Use Application class>glorpSession: aSession to set a session.A Glorp session can be also defined for an instance of Application by overriding Application>>glorpSession methodDbIdentifier: bear73DbTrace: 495124DbUsername: vdegenDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'GlorpActiveRecord' '') #(#any 'Xtreams-Transforms' '') #(#any 'AppeX-Client' '') #(#any 'AppeX-Server' ''))PackageName: AppeX-ActiveRecordParcel: #('AppeX-ActiveRecord')PrerequisiteDescriptions: #(#(#name 'GlorpActiveRecord' #componentType #package) #(#name 'Xtreams-Transforms' #componentType #package) #(#name 'AppeX-Client' #componentType #package) #(#name 'AppeX-Server' #componentType #package))PrerequisiteParcels: #(#('GlorpActiveRecord' '') #('Xtreams-Transforms' '') #('AppeX-Client' '') #('AppeX-Server' ''))PrintStringCache: (8.3 - 1,vdegen)Version: 8.3 - 1Date: 3:30:53 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:30:53 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ActiveRecordError</name><environment>AppeX</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-ActiveRecord</package></attributes></class><comment><class-id>AppeX.ActiveRecordError</class-id><body>The error is raised when to report problems decoding Json string in to Active record object</body></comment><methods><class-id>AppeX.Application class</class-id> <category>accessing</category><body package="AppeX-ActiveRecord">activeRecordContext	^ ProcessEnvironment current at: #activeRecordContext ifAbsent: [ self ]</body></methods><methods><class-id>AppeX.Application class</class-id> <category>dispatching</category><body package="AppeX-ActiveRecord">activeRecordDELETERequest: aClass"	Process a DELETE request where URL query defines a glorp query on an ActiveRecord class specified by bindingReference."	^self currentRequestArguments isEmpty 		ifTrue: [ aClass findAll ]		ifFalse: [self findInstancesOf: aClass]</body></methods><methods><class-id>AppeX.Application class</class-id> <category>database defaults</category><body package="AppeX-ActiveRecord">activeRecordDescriptorSystem 	^self subclassResponsibility</body></methods><methods><class-id>AppeX.Application class</class-id> <category>dispatching</category><body package="AppeX-ActiveRecord">activeRecordGETRequest: aClass"	Process a GET request.	The URL query parameters define a glorp query on an ActiveRecord class specified by bindingReference."	| queryParameters input |		queryParameters := self currentRequestArguments.	^(queryParameters isEmpty 		or: [(input := queryParameters at: #input ifAbsent: [nil]) isNil			or: [input isEmpty]])		ifTrue: [ aClass findAll ]		ifFalse: [(self decodeActiveRecordOf: aClass from: queryParameters) find realObjects]</body><body package="AppeX-ActiveRecord">activeRecordPOSTRequest: aClass"	Process a POST request which will update existing records.	The form data parameters define a glorp query on an ActiveRecord class specified by bindingReferece.	#id for POST could a collection, remove it from arguments since we have already retrived object with ids from DB"	| dict parameters |	dict := self currentRequestArguments.	parameters := dict at: #input ifAbsent: [ ^ActiveRecordError raiseErrorString: (#POSTRequestRequiresIDInput &lt;&lt; #www &gt;&gt; 'The POST service requires #id value in  #input aguments')].	parameters removeKey: #id.	^(self findInstancesOf: aClass) do: [ :object | 		object bePersistent.		self decodeActiveRecord: object from: dict ].</body><body package="AppeX-ActiveRecord">activeRecordPUTRequest: aClass"	Process a PUT request which will create a new record.	The query parameters form data parameters define a glorp query on an ActiveRecord class specified by bindingReferece."	| arguments  input|	arguments := self currentRequestArguments.	input := arguments at: #input ifAbsent: [ActiveRecordError raiseErrorString: (#MissingInputArg &lt;&lt; #www &gt;&gt; 'The request is missing #input arguments in query parameters')].	input at: #id ifPresent: [ :id |		(aClass find: id) ifNotNil: [^ActiveRecordError raiseErrorString: (#PUTDoesNotAcceptInputId &lt;&lt; #www &gt;&gt; 'The PUT service does not accept #input arguments with any specified #id. Use POST service instead' )]].		^self decodeActiveRecordOf: aClass from: arguments.</body></methods><methods><class-id>AppeX.Application class</class-id> <category>accessing</category><body package="AppeX-ActiveRecord">activeRecordToPathMap	^self settings at: #activeRecordToPathMap ifAbsent: [nil]</body><body package="AppeX-ActiveRecord">activeRecordToPathMap: aDictionary	self settings at: #activeRecordToPathMap put: aDictionary</body></methods><methods><class-id>AppeX.Application class</class-id> <category>database defaults</category><body package="AppeX-ActiveRecord">attrDescriptorFor: anInstVar attrModel: glorpAttr  class: aClass session: glorpSession	| attrDescriptor field |	glorpAttr ifNil: [^nil].	attrDescriptor := Struct new.	glorpAttr isReadable ifFalse: [attrDescriptor at: #canRead put: glorpAttr isReadable].	glorpAttr isWritable ifFalse: [ attrDescriptor at: #canWrite put: glorpAttr isWritable].	glorpAttr isCollectionAttribute ifTrue: [ attrDescriptor at: #isCollection put: glorpAttr isCollectionAttribute].	((glorpSession descriptorFor: aClass) mappingForAttributeNamed: anInstVar asSymbol )		ifNil: [attrDescriptor at: #type put: glorpAttr type name ]		ifNotNil: [ :mapping | 				mapping isRelationship					ifTrue: [ field := mapping mappedFields first.						field isNullable ifFalse: [attrDescriptor at: #isNullable put: mapping field isNullable].						field  isUnique ifTrue: [attrDescriptor at: #isUnique put: mapping field isUnique].						attrDescriptor at: #path put: ((self activeRecordToPathMap at: #initialMap) at: glorpAttr type) ]					ifFalse: [mapping field isNullable ifFalse: [attrDescriptor at: #isNullable put: mapping field isNullable].						mapping field isUnique ifTrue: [attrDescriptor at: #isUnique put: mapping field isUnique].						"JS supports simple types as string/number/boolean   /time/date/timestamp						we need to convert all Smalltalk types from  glorpAttr type to these types "						attrDescriptor at: #type put: glorpAttr type javascriptType.						glorpAttr type name = #String ifTrue: [attrDescriptor at: #size put: mapping field type width  ]]].	^attrDescriptor</body></methods><methods><class-id>AppeX.Application class</class-id> <category>accessing</category><body package="AppeX-ActiveRecord">beActiveRecordContext	 ProcessEnvironment current at: #activeRecordContext put: self</body><body package="AppeX-ActiveRecord">clientSchemaInfo	|  pathSchemaInfo |	^self activeRecordToPathMap ifNotNil: [ :dict |		pathSchemaInfo := Dictionary new.		dict keysAndValuesDo: [ :key :value | pathSchemaInfo at: (value at: #path) put: (value at: #schemaInfo) ].		pathSchemaInfo]</body></methods><methods><class-id>AppeX.Application class</class-id> <category>glorp session</category><body package="AppeX-ActiveRecord">currentGlorpSession"	Use the default ActiveRecord session accessor which queries ProcessEnvironment for the #glorpSession value.	See also comment in #currentGlorpSession: setter method."	^ Glorp.ActiveRecords.ActiveRecord getSession</body><body package="AppeX-ActiveRecord">currentGlorpSession: aGlorpSession"	Register aGlorpSession in the ProcessEnvironment via the ActiveRecord setter method.	This is necessary to use the ActiveRecord API, such as &lt;aClass&gt; findAll.	It is up to the application to ensure this method is sent early in a request dispatch if the ActiveRecord API is used.	The #activeRecord:class: service does this by default, but any other service intending to use ActiveRecord must do this explicitly."	Glorp.ActiveRecords.ActiveRecord setSession: aGlorpSession</body></methods><methods><class-id>AppeX.Application class</class-id> <category>json encoding</category><body package="AppeX-ActiveRecord">decodeActiveRecord: anActiveRecord  from: aDictionary"	anArray is expected to contain key/value pairs holding anActiveRecord variable names and the values they should be set to."	(aDictionary at: #input ifAbsent: [^anActiveRecord]) keysAndValuesDo: [ :key :value |		key notEmpty ifTrue: [			| index |			index := anActiveRecord class instVarIndexFor: key asString.			index isZero ifFalse: [				| mapping  |				mapping := anActiveRecord descriptor mappingForAttributeNamed: key asSymbol.				anActiveRecord 					instVarAt: index 					put: ( mapping decodeActiveRecord: value in: self currentGlorpSession)]]].	^ anActiveRecord</body><body package="AppeX-ActiveRecord">decodeActiveRecordOf: aClass from: aDictionary"	anArray is expected to contain key/value pairs holding instance variable names and the values they should be set to."	^self decodeActiveRecord: (aClass basicNew session: self currentGlorpSession; yourself)  from: aDictionary</body><body package="AppeX-ActiveRecord">encodeActiveRecord: anActiveRecord	^  anActiveRecord asJsonString</body><body package="AppeX-ActiveRecord">encodeActiveRecord: anActiveRecord asJSONOn: stream "Write the receiver in JSON format to the stream. Usually that means emitting a JSON object. The default behavior is to follow the class shape. If this is being customized for a specific class, it is imperative that the pattern below is followed, where the putObjectWith: message is sent to the stream to handle all the object formatting and the block argument action is used to emit each key/value pair."	| object |	^stream putObjectWith: [ :emitKeyValue |		anActiveRecord class jsonInstVarNames do: [ :nm |			object := anActiveRecord instVarNamed: nm.			(anActiveRecord descriptor mappingForAttributeNamed: nm asSymbol)				ifNil: [ emitKeyValue value: nm value: object ]				ifNotNil: [ :mapping | 					emitKeyValue 						value: (mapping jsonKey: nm)						value: (mapping 								encodeActiveRecord: anActiveRecord 								value: object 								application: self) ]]]</body></methods><methods><class-id>AppeX.Application class</class-id> <category>executing DB query</category><body package="AppeX-ActiveRecord">executeActiveRecordDELETE	^[ :glorpSession :activeRecords | 		glorpSession deleteAll: activeRecords.		activeRecords ]</body><body package="AppeX-ActiveRecord">executeActiveRecordGET" The default block for retrieving active records "	^[ :glorpSession :activeRecords | activeRecords ]</body><body package="AppeX-ActiveRecord">executeActiveRecordPOST" The default block for updating an active record "	^[ :glorpSession :activeRecords |		glorpSession hasUnitOfWork ifTrue: [ glorpSession commitUnitOfWork ].		activeRecords]</body><body package="AppeX-ActiveRecord">executeActiveRecordPUT" The default block for creating a new active record "	^[ :glorpSession :activeRecord |		glorpSession inUnitOfWorkDo: [ glorpSession register: activeRecord ].		activeRecord]</body></methods><methods><class-id>AppeX.Application class</class-id> <category>dispatching</category><body package="AppeX-ActiveRecord">findInstancesOf: aClass" Find an active record by its id "	|  ids |	ids := (self currentRequestArguments at: #input)			at: #id 			ifAbsent: [ ^ActiveRecordError raiseErrorString: (#RequestInputRequireID &lt;&lt; #www &gt;&gt; 'The request #input aguments require #id value to find an active record') ].					ids isSequenceable ifFalse: [ids := OrderedCollection with: ids].	^self currentGlorpSession		read: aClass 		where: [ :each | each id in: ids ]</body></methods><methods><class-id>AppeX.Application class</class-id> <category>glorp session</category><body package="AppeX-ActiveRecord">glorpSession	^self settings at: #glorpSession ifAbsent: [nil]</body><body package="AppeX-ActiveRecord">glorpSession: aSession	^self settings at: #glorpSession put: aSession</body></methods><methods><class-id>AppeX.Application class</class-id> <category>database defaults</category><body package="AppeX-ActiveRecord">initializeActiveRecordToPathMapFor: aGlorpSession	| dictionary model clDict |	dictionary := Dictionary new.	self settings at: #activeRecordToPathMap put: dictionary.	"The initial map in not cached and created every time we need path for a class. Let's cache it temporarily before we collect all schema info"	dictionary at: #initialMap put: self newActiveRecordToPathMap.		self newActiveRecordToPathMap keysAndValuesDo: [ :aClass :path |		(model := aGlorpSession system classModelFor:   aClass)  			ifNil: [^ActiveRecordError raiseErrorString: (#SchemaDescriptorDoesnotIncludeClass &lt;&lt; #www &gt;&gt; 'The schema descriptor does not include the class model description: &lt;1s&gt;' expandMacrosWith: aClass name)].		"if the model doesn't include #id attribute it could be a relation table mapping. Skip it"		(model attributes anySatisfy: [:attr | attr name = #id ]) ifTrue: [ 			dictionary at: aClass put: ( clDict := Dictionary new at: #path put: path; yourself).			clDict at: #schemaInfo put: ( self schemaInfoFor: aClass model: model session: aGlorpSession)]].	"Remove the temp map"	dictionary removeKey: #initialMap.</body></methods><methods><class-id>AppeX.Application class</class-id> <category>glorp session</category><body package="AppeX-ActiveRecord">initializeGlorpSession: aLogin			| system |	system := self activeRecordDescriptorSystem forPlatform: aLogin database.	self glorpSession: (system sessionForLogin: aLogin).	self glorpSession login.	^self glorpSession</body></methods><methods><class-id>AppeX.Application class</class-id> <category>accessing</category><body package="AppeX-ActiveRecord">login	^self settings at: #login ifAbsentPut: [self newActiveRecordLogin ]</body><body package="AppeX-ActiveRecord">login: aGlorpLogin	self settings at: #login put: aGlorpLogin</body></methods><methods><class-id>AppeX.Application class</class-id> <category>database defaults</category><body package="AppeX-ActiveRecord">newActiveRecordLogin	^self subclassResponsibility</body><body package="AppeX-ActiveRecord">newActiveRecordToPathMap"Subclasses have to provide the map.""It is used to encode Glorp proxies as JSON objects for replies. The method returns a dictionary where keys are ActiveRecord classes and values are url path tokens.For example: The map for Driver Demo returns:	^Dictionary new		at: Driver put: 'driver';		at: Vehicle put: 'vehicle';		yourself			The Driver records sent to a client will be encoded as JSON string:'{'id': {'type': 'Number'}, 'name': {'type': 'String', 'size': 20}, 'address': {'type': 'String', 'size': 40}, 'isProfessionalDriver': {'type': 'Boolean'}, 'vehicles': {'path': 'vehicle', 'isCollection': true}}'The line: 'vehicles': {'path': 'vehicle', 'isCollection': true} represents Glorp proxy encoding where the 'path': 'vehicle' is used the retrieve Vehicle objects from a sever"	^self subclassResponsibility</body></methods><methods><class-id>AppeX.Application class</class-id> <category>accessing</category><body package="AppeX-ActiveRecord">pathFor: anActiveRecord	^self activeRecordToPathMap 		ifNotNil: [	:map | (map at: anActiveRecord ifAbsent: [^nil]) at: #path ]</body></methods><methods><class-id>AppeX.Application class</class-id> <category>database defaults</category><body package="AppeX-ActiveRecord">resetActiveRecordData		self settings removeKey: #activeRecordToPathMap ifAbsent: [nil].	self glorpSession ifNotNil: [ :s | s logout ].	self settings removeKey: #glorpSession ifAbsent: [nil].</body></methods><methods><class-id>AppeX.Application class</class-id> <category>responding</category><body package="AppeX-ActiveRecord">respondWithActiveRecord: collOrObject"The returns a result of processing an active record request.A request may include the following options:#input - active record query paramaters#output - response parameters.If #output parameters are not provided the method returns an active record collection as Json stringIf #output parameters are specified they can be:#self - return the active record#xxx - execute the #xxx method for the active record object and return its resultFor example specifying #output as  #('#self' '#webPrint') for a Person object will reply the following string:[	{		'#self': 		{'id': 1, 'name': 'Smith', '#address': {'path': 'address', 'relations': [{'1000 Any Street': 1}]}}, 		'#webPrint':	'Smith'	}]If a request doesn't include #output parameters the reply for Person object is going to be:[	{		'id': 1, 'name': 'Smith', '#address': {'path': 'address', 'relations': [{'1000 Any Street': 1}]}	}		]"	| returnParameters coll struct |	coll := collOrObject isSequenceable 		ifTrue: [collOrObject]		ifFalse: [OrderedCollection with: collOrObject].				returnParameters := self currentRequestArguments 						at: #output 						ifAbsent: [ ^self respondWithJson: coll ].	returnParameters ifNil: [^nil].	^self respondWithJson: (coll collect: [ :object |		struct := Struct new.		returnParameters do: [ :param |			struct at: param put: (param first = $# 								ifTrue: [									param = '#self'										ifTrue: [object]										ifFalse: [object perform: (param copyFrom: 2 to: param size) asSymbol]]								ifFalse: [object instVarNamed: param])].		  struct]).</body></methods><methods><class-id>AppeX.Application class</class-id> <category>database defaults</category><body package="AppeX-ActiveRecord">schemaInfoFor:  aClass model: aModel session: glorpSession	|  glorpAttr modelDescriptor   |	modelDescriptor := Protocols.Struct new.	aClass jsonInstVarNames do: [:instVar | 		glorpAttr := aModel attributes detect: [:attr | attr name = instVar asSymbol].		(self 			attrDescriptorFor: instVar 			attrModel: glorpAttr  			class: aClass 			session: glorpSession) ifNotNil: [ :attrDescriptor |				modelDescriptor add: ( instVar asSymbol -&gt; attrDescriptor )]].		^modelDescriptor</body></methods><methods><class-id>AppeX.Application class</class-id> <category>glorp session</category><body package="AppeX-ActiveRecord">setDefaultGlorpSession	^ self initializeGlorpSession: self login</body></methods><methods><class-id>AppeX.Application</class-id> <category>database</category><body package="AppeX-ActiveRecord">activeRecordDELETERequest: aClass"	Process a request that contains information about the method (GET, PUT, POST, UPDATE)	and the query parameters to execute a glorp query on an ActiveRecord class specified by bindingReferece."		^ self class activeRecordDELETERequest: aClass</body><body package="AppeX-ActiveRecord">activeRecordGETRequest: aClass"	Process a request that contains information about the GET method 	and the query parameters to execute a glorp query on an ActiveRecord class specified by bindingReference."	^ self class activeRecordGETRequest: aClass</body><body package="AppeX-ActiveRecord">activeRecordPOSTRequest: aClass"	Process a request that contains information about the method (GET, PUT, POST, DELETE)	and the query parameters to execute a glorp query on an ActiveRecord class specified by bindingReferece."		^ self class activeRecordPOSTRequest: aClass</body><body package="AppeX-ActiveRecord">activeRecordPUTRequest: aClass"	Process a request that contains information about the method (GET, PUT, POST, UPDATE)	and the query parameters to execute a glorp query on an ActiveRecord class specified by bindingReferece."		^ self class activeRecordPUTRequest: aClass</body></methods><methods><class-id>AppeX.Application</class-id> <category>accessing</category><body package="AppeX-ActiveRecord">activeRecordToPathMap	^self class activeRecordToPathMap</body></methods><methods><class-id>AppeX.Application</class-id> <category>active record encoding</category><body package="AppeX-ActiveRecord">beActiveRecordContext	ProcessEnvironment current at: #activeRecordContext put: self</body><body package="AppeX-ActiveRecord">encodeActiveRecord: anActiveRecord	^ self class encodeActiveRecord: anActiveRecord</body><body package="AppeX-ActiveRecord">encodeActiveRecord: anActiveRecord asJSONOn: stream 	^self class encodeActiveRecord: anActiveRecord asJSONOn: stream</body></methods><methods><class-id>AppeX.Application</class-id> <category>executing DB query</category><body package="AppeX-ActiveRecord">executeActiveRecordDELETE	^self class executeActiveRecordDELETE</body><body package="AppeX-ActiveRecord">executeActiveRecordGET	^self class executeActiveRecordGET</body><body package="AppeX-ActiveRecord">executeActiveRecordPOST	^self class executeActiveRecordPOST</body><body package="AppeX-ActiveRecord">executeActiveRecordPUT	^self class executeActiveRecordPUT</body></methods><methods><class-id>AppeX.Application</class-id> <category>glorp session</category><body package="AppeX-ActiveRecord">glorpSession	^ self class glorpSession</body><body package="AppeX-ActiveRecord">glorpSession: aSession	^ self class glorpSession: aSession</body></methods><methods><class-id>AppeX.Application</class-id> <category>session - responding</category><body package="AppeX-ActiveRecord">respondWithActiveRecord: anObject	^self class respondWithActiveRecord: anObject</body></methods><methods><class-id>AppeX.Application</class-id> <category>database</category><body package="AppeX-ActiveRecord">setDefaultGlorpSession"	By default, I will let my class to set glorp my session. Subclasses may override."	^ self class setDefaultGlorpSession</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecord class</class-id> <category>json encoding</category><body package="AppeX-ActiveRecord">jsonHierarchyRoot	^ActiveRecord</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecord</class-id> <category>appex - encoding</category><body package="AppeX-ActiveRecord">streamingWriteJSONOn: stream"	To avoid potential conflict with other overrides, let's make this an AppeX-specific method."	^AppeX.Application activeRecordContext  encodeActiveRecord: self asJSONOn: stream</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecord</class-id> <category>printing</category><body package="AppeX-ActiveRecord">webPrint	^self printString</body></methods><methods><class-id>Core.Timestamp</class-id> <category>private</category><body package="AppeX-ActiveRecord">streamingWriteJSONOn: aStream	|   date temp stream |	stream := String new writing.	date := self asDate.	date printOn: stream.	stream write: ((temp := self hours) &lt; 10 				ifTrue: [' 0']				ifFalse: [' ']).	temp printOn: stream.	stream write: ((temp := self minutes) &lt; 10 				ifTrue: [':0']				ifFalse: [':']).	temp printOn: stream.	stream write: ((temp := self seconds) &lt; 10 				ifTrue: [':0']				ifFalse: [':']).	temp printOn: stream.	stream write: ' GMT'.	aStream putString:  stream contents.</body></methods><methods><class-id>Core.Number class</class-id> <category>appex - active record</category><body package="AppeX-ActiveRecord">javascriptType	^'Number'</body></methods><methods><class-id>Core.Behavior</class-id> <category>appex - active record</category><body package="AppeX-ActiveRecord">javascriptType	^self name asString</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>appex - encoding</category><body package="AppeX-ActiveRecord">decodeActiveRecord: aValue in: aSession	^ aValue</body><body package="AppeX-ActiveRecord">encodeActiveRecord: anActiveRecord value: anObject application: anApplication	^anObject</body><body package="AppeX-ActiveRecord">jsonKey: aString		^aString</body></methods><methods><class-id>Glorp.DirectMapping</class-id> <category>appex - encoding</category><body package="AppeX-ActiveRecord">decodeActiveRecord: aValue in: aSession	converter ifNotNil: [		converter name = #date ifTrue: [ ^Date readFrom: aValue readStream].		converter name = #time ifTrue: [ ^Time readFrom: aValue readStream].		converter name = #timestamp ifTrue: [ ^Timestamp readFrom: aValue readStream]].		^ aValue</body></methods><methods><class-id>Core.Time</class-id> <category>private</category><body package="AppeX-ActiveRecord">streamingWriteJSONOn: aStream	| stream |	stream := String new writing.	stream write: (self hours &lt; 10 				ifTrue: [' 0']				ifFalse: [' ']).	self hours printOn: stream.	stream write: (self minutes &lt; 10 				ifTrue: [':0']				ifFalse: [':']).	self minutes printOn: stream.	stream write: (self seconds &lt; 10 				ifTrue: [':0']				ifFalse: [':']).	self seconds printOn: stream.	aStream putString: stream contents.</body></methods><methods><class-id>Protocols.Struct</class-id> <category>private</category><body package="AppeX-ActiveRecord">streamingWriteJSONOn: stream	^stream putDictionary: self</body></methods><methods><class-id>Glorp.OneToOneMapping</class-id> <category>appex - encoding</category><body package="AppeX-ActiveRecord">encodeActiveRecord: anActiveRecord value: anObject application: anApplication		"Must use == nil in case anObject is a Proxy. "	anObject == nil ifTrue: [ ^ nil ].	^super encodeActiveRecord: anActiveRecord value: (Array with: anObject) application: anApplication</body></methods><methods><class-id>Glorp.RelationshipMapping</class-id> <category>appex - encoding</category><body package="AppeX-ActiveRecord">decodeActiveRecord: idValue in: aSession	| recordId |	recordId := idValue isSequenceable				ifTrue: [idValue notEmpty ifTrue: [idValue first] ifFalse: [^nil ]]				ifFalse: [idValue].	 	^aSession 		readOneOf: self attribute type 		where: [ :each | each id = recordId ]</body><body package="AppeX-ActiveRecord">encodeActiveRecord: anActiveRecord value: objectCollection	| id relations print|	relations := OrderedCollection new.	objectCollection do: [ :obj |		 id :=  obj isGlorpProxy 			ifTrue: [obj parameters values first ]			ifFalse: [obj id].		print := ( self webPresentationFor: obj) ifNotNil: [ :anObject | anObject ] ifNil: [''].		relations add: print -&gt; id.		].	^relations</body><body package="AppeX-ActiveRecord">encodeActiveRecord: anActiveRecord value: objectCollection application: anApplication	| dict|	"Must use == nil in case anObject is a Proxy. "	(objectCollection isNil or: [ objectCollection isEmpty]) ifTrue: [ ^ nil ].	dict := Dictionary new.	dict at: #path put: (anApplication pathFor: self basicReferenceClass).	dict at: #relations put: (self encodeActiveRecord: anActiveRecord value: objectCollection).	^dict</body><body package="AppeX-ActiveRecord">jsonKey: aString		^'#', aString</body><body package="AppeX-ActiveRecord">webPresentationFor: anObject 	| value |	value :=  anObject isGlorpProxy 			ifTrue: [anObject getValue ]			ifFalse: [anObject ].	^value perform: #webPrint</body></methods><methods><class-id>Core.Date</class-id> <category>private</category><body package="AppeX-ActiveRecord">streamingWriteJSONOn: aStream	aStream putString: self printString</body></methods><methods><class-id>Core.CharacterArray class</class-id> <category>appex - active record</category><body package="AppeX-ActiveRecord">javascriptType	^'String'</body></methods><methods><class-id>Glorp.ToManyMapping</class-id> <category>appex - encoding</category><body package="AppeX-ActiveRecord">decodeActiveRecord: anArray in: aSession	^aSession 		read: self attribute type 		where: [ :each | each id in: anArray ]</body></methods><methods><class-id>AppeX.Application class</class-id> <category>dispatching</category><body package="AppeX-ActiveRecord">activeRecord: pragma class: bindingReference"	Use #activeRecord:class: pragma to return a JSON-serializable object.	The 'content-type' will be set to 'application/json'.	bindingReference - is a class that will represent an active record to perform DB query on	The default HTTP method for the  #activeRecord:class: pragma is GET"	&lt;serviceType: #GET&gt;	| aClass result activeRecords|	^self dispatchPragma: pragma		with: [:receiver |			receiver beActiveRecordContext.			aClass := bindingReference valueOrDo: [ 				^ActiveRecordError raiseErrorString: (#UndefinedBindingReference &lt;&lt; #www &gt;&gt; 'Undefined BindingReference: &lt;1s&gt; in services: &lt;2s&gt;' expandMacrosWith:  bindingReference printString with: pragma message selector) ].			"Make sure a glorp session is set by the receiver"			receiver glorpSession ifNil: [ 				receiver setDefaultGlorpSession.				receiver glorpSession ifNil: [ ^ActiveRecordError raiseErrorString: (#GlorpSessionNotInitialized &lt;&lt; #www &gt;&gt; 'Glorp Session is not initialized' )]].			"Set the current glorp session to be used by ActiveRecord framework."			self currentGlorpSession: receiver glorpSession.			"All methods below must access a glorp session using 'self currentGlorpSession' "			"Decode an active record from JSON parameters"			activeRecords :=  receiver perform: ('activeRecord',  self currentRequest method, 'Request:') asSymbol with: aClass.			"See if there is a custom block for processing an active record"			result := receiver perform: pragma selector.			(result isKindOf: BlockClosure) ifFalse: [				"Use a default block to perform DB operation"				result := receiver perform: ('executeActiveRecord', self currentRequest method ) asSymbol].			"Encode the processing block result as JSON string"			 self respondWithActiveRecord: (result cull: receiver glorpSession cull: activeRecords)]</body></methods><methods><class-id>AppeX.Application class</class-id> <category>services</category><body package="AppeX-ActiveRecord">commitUnitOfWork	&lt;plainText: 'glorp_commitUnitOfWork'&gt;		self currentGlorpSession commitUnitOfWork.</body><body package="AppeX-ActiveRecord">initializeActiveRecordApplication	&lt;GET&gt;	&lt;jsonStream: 'initializeActiveRecordApplication' &gt;	self glorpSession ifNil: [self setDefaultGlorpSession ].	self activeRecordToPathMap ifNil: [self initializeActiveRecordToPathMapFor: self glorpSession ].	^self clientSchemaInfo</body><body package="AppeX-ActiveRecord">requireUnitOfWork	&lt;plainText: 'glorp_beginUnitOfWork'&gt;		self currentGlorpSession requireUnitOfWork</body><body package="AppeX-ActiveRecord">rollbackUnitOfWork	&lt;plainText: 'glorp_rollbackUnitOfWork'&gt;		self currentGlorpSession rollbackUnitOfWork.</body></methods><methods><class-id>AppeX.Application</class-id> <category>services</category><body package="AppeX-ActiveRecord">commitUnitOfWork	&lt;plainText: 'glorp_commitUnitOfWork'&gt;		self glorpSession commitUnitOfWork.</body><body package="AppeX-ActiveRecord">initializeActiveRecordApplication	&lt;GET&gt;	&lt;jsonStream: 'initializeActiveRecordApplication' &gt;			^self class initializeActiveRecordApplication</body><body package="AppeX-ActiveRecord">requireUnitOfWork	&lt;plainText: 'glorp_beginUnitOfWork'&gt;		self glorpSession requireUnitOfWork</body><body package="AppeX-ActiveRecord">rollbackUnitOfWork	&lt;plainText: 'glorp_rollbackUnitOfWork'&gt;		self glorpSession rollbackUnitOfWork.</body></methods><methods><class-id>AppeX.NoCacheRequestFilter</class-id> <category>configuration</category><body package="AppeX-ActiveRecord">forActiveRecord	&lt;configuration: 'Active Record'&gt;		self addService: #activeRecord:class:</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Application</name><environment>AppeX</environment><super>SiouX.HttpResponder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clientSubscriptions session eventStream </inst-vars><class-inst-vars>settings requestActions subscriptionRegistry codeComposer combinedJavascriptLibrary </class-inst-vars><imports>			private Tools.Pragma			private Xtreams.*			private SiouX.*			private Protocols.*			</imports><category></category><attributes><package>AppeX-Server</package></attributes></class><class><name>ActiveRecord</name><environment>Glorp.ActiveRecords</environment><super>Glorp.PersistentObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecord</category><attributes><package>GlorpActiveRecord</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Mapping</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>descriptor attribute debugRead debugWrite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>DirectMapping</name><environment>Glorp</environment><super>Glorp.Mapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>field converter shouldProxy query </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>RelationshipMapping</name><environment>Glorp</environment><super>Glorp.Mapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>query join usesLinkTable shouldProxy linkTableJoin targetTableJoin reverseJoin shouldUseFilteredRead rowMapKeyConstructorBlock controlsTables isExclusive linkFields proxyAction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>Struct</name><environment>Protocols</environment><super>Protocols.ProtoObject</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>name lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Protocols-Common</category><attributes><package>Protocols-Common</package></attributes></class><class><name>ToManyMapping</name><environment>Glorp</environment><super>Glorp.RelationshipMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>orderBy shouldWriteTheOrderField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>NoCacheRequestFilter</name><environment>AppeX</environment><super>SiouX.RequestFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>services </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Server</package></attributes></class><class><name>OneToOneMapping</name><environment>Glorp</environment><super>Glorp.RelationshipMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class></st-source>