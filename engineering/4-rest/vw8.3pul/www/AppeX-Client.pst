<?xml version="1.0"?><st-source><!-- Name: AppeX-ClientComment: This package contains the classes comprising AppeX's class-based object oriented JavaScript framework.  Included in this framework:JavascriptObject - the root of the inheritence hierarchy, extends the JavaScript built-in-object Object in the web browserApplicationClient - maps to a constructor function used to a singleton in the web browser.  This singleton is the central point of communication to the web server, and is automatically configured to used several of the server-side AppeX frameworks, such as application sessions, localization, etc.Extensions to some other built in JavaScript objects, and  definitions for some  new  JavaScript objects.DbIdentifier: bear73DbTrace: 496318DbUsername: tkoganDbVersion: 8.3 - 6DevelopmentPrerequisites: #(#(#any 'AppeX-Support' '') #(#any 'AppeX-Server' ''))PackageName: AppeX-ClientParcel: #('AppeX-Client')PrerequisiteDescriptions: #(#(#name 'AppeX-Support' #componentType #package) #(#name 'AppeX-Server' #componentType #package))PrerequisiteParcels: #(#('AppeX-Support' '') #('AppeX-Server' ''))PrintStringCache: (8.3 - 6,tkogan)Version: 8.3 - 6Date: 3:30:53 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:30:53 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>JavascriptObject</name><environment>AppeX</environment><super>AppeX.JavascriptCode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>bootstrap</category><attributes><package>AppeX-Client</package></attributes></class><comment><class-id>AppeX.JavascriptObject</class-id><body>JavascriptObject is an abstract class for all Javascript classes. On the client (i.e., a web browser), this would be represented by Object constructor function. Javascript functions are implemented as instance methods in JavascriptObject and its subclasses.ImplementationInstance methods in JavascriptObject itself are bound directly to the Object.prototype in the client, resulting in all objects in the Javascript space inheriting the method functions implemented here. Thus, JavascriptObject represents the root of a JS class hierarchy, giving developers power and flexibility in extending or modifying the behavior implemented by the existing JS engines.Consider the methods, #getClassName and #getFullClassName implemented here. They will be bound as functions to Object.prototype on the client. Any object on the client will now understand the 'getClassName()' and 'getFullClassName()' messages. As all standard JS classes are implemented as global functions, there will be no difference between the results of the two on default JS objects. However, for objects that are 'instances' of Javascript 'classes' generated by this framework, the 'getFullClassName()' message will respond with a String representing the name of the generated JS class in the Smalltalk namespace hierarchy.UsageDevelopers can create 'subclasses' of JavascriptObject constructor function the same way they are used to in the VisualWorks IDE - by creating a subclass of JavascriptObject. All instance methods of such subclass represent Javascript functions on the client, and must be written in the form&lt;functionName&gt; (&lt;optional arguments&gt;) {	... Javascript code here ...}All class methods of JavascriptObject subclasses must be regular Smalltalk class methods. No class-side Javascript code is required or generated for the client.See subclasses of JavascriptObject for examples.</body></comment><class><name>DebuggingOptions</name><environment>AppeX</environment><super>AppeX.JavascriptObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Client</package></attributes></class><comment><class-id>AppeX.DebuggingOptions</class-id><body>DebuggingOptions encapsulates a set of options that may be used for application debugging. The options are: log, trace, debug, and alert.</body></comment><class><name>ApplicationClient</name><environment>AppeX</environment><super>AppeX.JavascriptObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>javascriptLibrary </class-inst-vars><imports></imports><category>bootstrap</category><attributes><package>AppeX-Client</package></attributes></class><comment><class-id>AppeX.ApplicationClient</class-id><body>ApplicationClient is a common superclass for all Javascript applications. Its responsibility is to know its library name on the class side, and implement all the javascript behavior on the instance side.ImplementationAn ApplicationClient Javascript class will understand the method 'install()' that should be called from a script loaded by the HTML generated by the ApplicationServer (see the default HTML template returned from ApplicationServer class &gt;&gt; #htmlBodyTemplate). The 'install()' method sets the 'application' property in the Javascript '$t' global variable, establishes a session link to the server, and dynamically builds the HTML elements inside the HTML template. It also opens an EventSource object that serves as a channel to push server event notifications to the client. This is used in the framework to maintain the link to a server session represented by an instance of ApplicationServer subclass, and to notify the client about session status changes, such as session expiration.Only a single application client can be installed in an HTML page using AppeX.UsageWhen writing web applications, developers must subclass ApplicationClient as the client counterpart to the subclass of ApplicationServer that handles the server requests. The server class must also implement a class method named #applicationClientClass that will return the ApplicationClient subclass with the Javascript code.In a rare case where the ApplicationServer only serves static files and Javascript client code is required, no ApplicationClient subclass needs to be present, and the #applicationClientClass method should return nil.See classes in the AppeX-Examples package for examples of proper use of ApplicationClient subclasses.</body></comment><class><name>ServerResponse</name><environment>AppeX</environment><super>AppeX.JavascriptObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>bootstrap</category><attributes><package>AppeX-Client</package></attributes></class><comment><class-id>AppeX.ServerResponse</class-id><body>ServerResponse is a Javascript class used to wrap the data received from a ServerRequest.UsageThe following applies to Javascript code in a client:When an ApplicationClient javascript object sends a message to the server by using messageToServer or asyncMessageToServer method, the returned object is a ServerResponse. You can set onError and onSuccess handler functions, and query a response's attributes named 'data' and 'object'. Depending on the content-type field of the underlying XHR respoonse, 'data' and 'object' may or may not be the same.Example:	var response = $t.application.asyncMessageToServer("somePath", "someArgument");	response		.onError( function(error) { console.log("Error:", error) })		.onSuccess( function() { console.log("Success:", response });Note that onError and onSuccess functions work in both synchronous and asynchronous messaging.</body></comment><class><name>JavascriptArray</name><environment>AppeX</environment><super>AppeX.JavascriptObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Client</package></attributes></class><comment><class-id>AppeX.JavascriptArray</class-id><body>JavascriptArray contains functions to extend the built in Array object in JavaScript.</body></comment><class><name>JavascriptFunction</name><environment>AppeX</environment><super>AppeX.JavascriptObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Client</package></attributes></class><comment><class-id>AppeX.JavascriptFunction</class-id><body>JavascriptFunction contains functions to extend the built in Function object in JavaScript.</body></comment><class><name>JavascriptNamespace</name><environment>Smalltalk</environment><super>AppeX.JavascriptObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Client</package></attributes></class><comment><class-id>JavascriptNamespace</class-id><body>Corresponds to (i.e. creates) the Namespace JavaScript class</body></comment><class><name>ServerRequest</name><environment>AppeX</environment><super>AppeX.JavascriptObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>bootstrap</category><attributes><package>AppeX-Client</package></attributes></class><comment><class-id>AppeX.ServerRequest</class-id><body>ServerRequest is a Javascript class used to wrap a server request into a single object, hiding the complexity of setting up and processing status changes in an AJAX request.UsageIn Javascript code, you can use something like:var response = (new $t.AppeX.ServerRequest(&lt;url&gt;)).deliver();However, this would normally not be necessary, as the method function AppeX.ApplicationClient.messageToServer() does all the work of setting up a ServerRequest, delivering it to the server, and returning a response object.</body></comment><class><name>EventSourceEmulator</name><environment>AppeX</environment><super>AppeX.JavascriptObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Client</package></attributes></class><comment><class-id>AppeX.EventSourceEmulator</class-id><body>EventSourceEmulator is needed for those browsers that don't support is natively, e.g., Internet Explorer.The core library checks if the web browser native JS engine includes EventSource, and if not, it uses this class as a substitute.See EventSourceEmulator class &gt;&gt; #eventSourceCheck</body></comment><shared-variable><name>JavascriptClass</name><environment>AppeX</environment><private>false</private><constant>true</constant><category>Deprecated</category><initializer>"This variable is deprecated and is slated to be removed in release 8.3" JavascriptObject</initializer><attributes><package>AppeX-Client</package></attributes></shared-variable><methods><class-id>AppeX.JavascriptObject class</class-id> <category>javascript generating</category><body package="AppeX-Client">javascriptName	^self == JavascriptObject		ifTrue: ['Object']		ifFalse: [self jsNamespace, '.', self javascriptConstructorName]</body><body package="AppeX-Client">javascriptProperties"	Each JavascriptClass can define the default properties that will be emitted as part of the class constructor.	Answer an array of symbols that will be used as property names during instance initialization.	By default, answer an empty array."	^ #()</body><body package="AppeX-Client">jsFunctionPattern: aSelector writer: aWriter	^(aWriter javascriptNameForClass: self) , '.bindMethod(function &lt;1s&gt;);'.</body><body package="AppeX-Client">writeJsCodeWith: aWriter	self == JavascriptObject ifTrue: [		aWriter			cr;			write: '	Object.ClassName = "Object";';			cr;			cr.	] ifFalse: [		aWriter writeJsClassDefinitionWith: self 	].	aWriter writeJsFunctionsWith: self.</body><body package="AppeX-Client">writeJsNamespaces: visited with: aWriter	| path |	"don't need to ensure $t.AppeX yet."	self = JavascriptObject ifTrue: [^self].	path := ''.	(self environment fullyQualifiedReferenceFrom: Smalltalk) path do: 			[:each |			path := path , each.			(visited includes: path)				ifFalse: 					[aWriter						write: '$t.ensureNamespace("' , path , '");';						cr.					visited add: path]]		separatedBy: [path := path , '.']</body><body package="AppeX-Client">writeJsNamespacesWith: aWriter	| path visited |	"don't need to ensure $t.AppeX yet."	self = JavascriptObject ifTrue: [^self].	visited := Set with: 'Smalltalk'.	path := ''.	(self environment fullyQualifiedReferenceFrom: Smalltalk) path do: 			[:each |			path := path , each.			(visited includes: path)				ifFalse: 					[aWriter						write: '$t.ensureNamespace("' , path , '");';						cr.					visited add: path]]		separatedBy: [path := path , '.']</body></methods><methods><class-id>AppeX.JavascriptObject class</class-id> <category>testing</category><body package="AppeX-Client">allSubclassesUsingDefineClass	^self allSubclasses reject: [:e | e isPredefinedInJavascript |  (e = JavascriptNamespace) ]</body><body package="AppeX-Client">isCoreClass	"	Answer a boolean indicating whether I belong to the AppeX core library.	Default answer is false. Core classes MUST override.	"	^ self == JavascriptObject</body><body package="AppeX-Client">isJavascriptObject	"	Answer a boolean	"	^true</body><body package="AppeX-Client">isPredefinedInJavascript	"	Answer a boolean indicating whether I  correspond to an existing JavaScript object.	e.g. JavascriptFunction, JavascriptObject, and JavascriptArray correspond to Function, Object, and Array of the JavascriptLanguage	Default answer is false. 	"	^self == JavascriptObject</body><body package="AppeX-Client">shouldCallParentConstructor	"answer boolean indicating whether or not the JavaScript constructor function for this object should also apply the superclass	constructor (initialization code) to new instances"	^self superclass ~= JavascriptObject</body></methods><methods><class-id>AppeX.JavascriptObject class</class-id> <category>accessing</category><body package="AppeX-Client">defaultLibraryName	"	If I am the ApplicationClient class, I belong to AppeX.CoreCode.js. Otherwise, I belong to a Javascript file named like myself, with '.js' as file extension.	Subclasses may override.	"	^self isCoreClass		ifTrue: [self coreCodeLibraryName]		ifFalse: [self fullName, '.js']</body></methods><methods><class-id>AppeX.DebuggingOptions class</class-id> <category>testing</category><body package="AppeX-Client">isCoreClass	^ true</body></methods><methods><class-id>AppeX.ApplicationClient class</class-id> <category>testing</category><body package="AppeX-Client">isCoreClass	"	Answer a boolean indicating whether I belong to the AppeX core library.	Default answer is false. ApplicationClient is a core class, but its subclasses are not.	"	^ self == ApplicationClient</body></methods><methods><class-id>AppeX.ApplicationClient class</class-id> <category>javascript generating</category><body package="AppeX-Client">javascriptProperties"	Answer the default properties an applicationClient should have."	^ #(#eventChannel #serverEvents #session #sessionKey #url )</body></methods><methods><class-id>AppeX.ApplicationClient class</class-id> <category>compiling</category><body package="AppeX-Client">generateClientMethodFor: aPragma	| javascript path methodSignature template arguments pragmaSignature |	methodSignature := String new writeStream.	aPragma method printNameOn: methodSignature inClass: nil.	methodSignature := methodSignature contents.	path := aPragma argumentAt: 1.	pragmaSignature := '&lt;', ('&lt;1s&gt; ''&lt;2s&gt;''' expandMacrosWith: aPragma keyword with: path), '&gt;'.	template := '&lt;1s&gt;(){/** This method was generated from pragma &lt;2s&gt; in method &lt;4s&gt;.* You can modify the code according to your application needs, or regenerate it as follows:*	- Navigate to &lt;4s&gt;.*	- Click on the item labeled "Generate &lt;5s&gt;.&lt;1s&gt;" in the method menu.*/	var response = this.asyncMessageToServer("&lt;3s&gt;", arguments);	response.onSuccess(		function(object) {			/* write your own success handler here */		}	);	return response;}'.	arguments := OrderedCollection new		add: aPragma selector;		add: pragmaSignature;		add: path;		add: methodSignature;		add: self name;		yourself.		javascript := template expandMacrosWithArguments: arguments.		self compile: javascript classified: 'auto-generated'</body></methods><methods><class-id>AppeX.ApplicationClient class</class-id> <category>library</category><body package="AppeX-Client">javascriptLibrary	^ javascriptLibrary ifNil: [ javascriptLibrary := self registerAsLibrary ]</body><body package="AppeX-Client">registerAllLibraries"	Have all my subclasses register themselves in JavascriptLibrary registry.	(ApplicationClient registerAllLibraries)"	"Ensure JavascriptLibrary registry is fully initialized."	JavascriptLibrary registry.	ApplicationClient allSubclasses do: [ :each | each registerAsLibrary ]</body></methods><methods><class-id>AppeX.ServerResponse class</class-id> <category>testing</category><body package="AppeX-Client">isCoreClass	^ true</body></methods><methods><class-id>AppeX.JavascriptArray class</class-id> <category>javascript generating</category><body package="AppeX-Client">javascriptName		^'Array'</body><body package="AppeX-Client">writeJsCodeWith: aWriter	aWriter writeInitializationCodeWith: self.	aWriter writeJsFunctionsWith: self.</body><body package="AppeX-Client">writeJsNamespaces: visited with: aWriter	"no-op"</body><body package="AppeX-Client">writeJsNamespacesWith: aWriter	"no-op"</body></methods><methods><class-id>AppeX.JavascriptArray class</class-id> <category>testing</category><body package="AppeX-Client">isCoreClass	^true</body><body package="AppeX-Client">isPredefinedInJavascript	^true</body></methods><methods><class-id>AppeX.JavascriptFunction class</class-id> <category>javascript generating</category><body package="AppeX-Client">javascriptName		^'Function'</body><body package="AppeX-Client">writeJsCodeWith: aWriter	aWriter writeInitializationCodeWith: self.	aWriter writeJsFunctionsWith: self.</body><body package="AppeX-Client">writeJsNamespaces: visited with: aWriter	"no-op"</body><body package="AppeX-Client">writeJsNamespacesWith: aWriter	"no-op"</body></methods><methods><class-id>AppeX.JavascriptFunction class</class-id> <category>testing</category><body package="AppeX-Client">isCoreClass	^true</body><body package="AppeX-Client">isPredefinedInJavascript	^true</body></methods><methods><class-id>JavascriptNamespace class</class-id> <category>javascript generating</category><body package="AppeX-Client">javascriptConstructorName		^'Namespace'</body><body package="AppeX-Client">javascriptName		^self jsNamespace, '.Namespace'</body><body package="AppeX-Client">jsFunctionsToBind	| unsorted sorted |	unsorted := self selectors.	"just make sure defineClass is first"	sorted := (unsorted reject: [:e | e == #defineClass]) asOrderedCollection addFirst: #defineClass; yourself.	^sorted.</body><body package="AppeX-Client">writeJsCodeWith: aWriter	aWriter writeInitializationCodeWith: self.	aWriter writeJsFunctionsWith: self.</body></methods><methods><class-id>JavascriptNamespace class</class-id> <category>testing</category><body package="AppeX-Client">isCoreClass	^true</body></methods><methods><class-id>AppeX.ServerRequest class</class-id> <category>testing</category><body package="AppeX-Client">isCoreClass	^ true</body></methods><methods><class-id>AppeX.EventSourceEmulator class</class-id> <category>accessing</category><body package="AppeX-Client">eventSourceCheck	^ '// Emulate the EventSource API for browsers that do not support it.// Requires an XMLHttpRequest that sends readystatechange events whenever// there is new data written to a long-lived HTTP connection. Note that// this is not a complete implementation of the API: it does not support the// readyState property, the close() method, nor the open and error events.// Also event registration for message events is through the onmessage // property only--this version does not define an addEventListener method.	if (window.EventSource === undefined) {		// If EventSource is not defined,		window.EventSource = $t.AppeX.EventSourceEmulator;	}'</body><body package="AppeX-Client">eventSourceConstants	^ '	$t.AppeX.EventSourceEmulator.CONNECTING = 0;	$t.AppeX.EventSourceEmulator.OPEN = 1;	$t.AppeX.EventSourceEmulator.CLOSED = 2;'</body></methods><methods><class-id>AppeX.EventSourceEmulator class</class-id> <category>javascript generating</category><body package="AppeX-Client">writeJsCodeWith: aWriter	super writeJsCodeWith: aWriter.	aWriter		cr;		write: self eventSourceConstants;		cr;		write: self eventSourceCheck;		cr.</body></methods><methods><class-id>AppeX.EventSourceEmulator class</class-id> <category>testing</category><body package="AppeX-Client">isCoreClass	^ true</body></methods><methods><class-id>AppeX.JavascriptWriter</class-id> <category>js generating</category><body package="AppeX-Client">writeJsClassDefinitionWith: aClass	| initializer |	self startJsClassDefinitionFor: aClass.	aClass 		methodDictionary at: #initialize		ifPresent: 			[:initializeMethod |			"Warning...stepping through this code may crash your image."			initializer := initializeMethod valueWithReceiver: aClass basicNew						arguments: #()].	aClass class methodDictionary 		at: #javascriptProperties 		ifPresent: [ :method | | properties |			properties := aClass javascriptProperties.			properties isEmpty ifFalse: [				self					cr; tab;					write: '// Initialize default properties:' ].				properties do: [ :each |				self					cr; tab;					write: 'this.';					write: each;					write: ' = null;']].		(initializer notNil and: [initializer notEmpty])		ifTrue: 			[self				cr; tab;				write: '// Send the initialize() method to the constructed object:';				cr; tab;				write: '(function ';				write: initializer;				write: ').apply(this, arguments);'].	self finishJsClassDefinitionFor: aClass</body></methods><methods><class-id>AppeX.JavascriptLibrary class</class-id> <category>compiling</category><body package="AppeX-Client">classMethodsChanged	super classMethodsChanged.	Registry := nil</body></methods><methods><class-id>AppeX.JavascriptObject</class-id> <category>javascript - EventTarget</category><body package="AppeX-Client">addEventListener(type, listener, useCapture) {// Simulate the EventTarget API	return this.eventTarget().addEventListener(type, listener, useCapture || false);}</body><body package="AppeX-Client">callSuper(aFunctionName, args) {	var definingClass,		superclass,		aFunction;		//find the class the function is defined in (not necessarily the class it is called from)	if (this.constructor.prototype.hasOwnProperty(aFunctionName)) {		definingClass = this.constructor;	}	superclass = this.constructor.Superclass;	while (!definingClass) {		if (superclass.prototype.hasOwnProperty(aFunctionName)) {			definingClass = superclass;		} 		superclass = superclass.Superclass;	}		//since calling super, skip over the implementation in the defining class and use a superclass implementation, but bound to this	aFunction = definingClass.Superclass.prototype[aFunctionName];	return aFunction.apply(this, args);}</body><body package="AppeX-Client">dispatchEvent(event) {// Simulate the EventTarget API	return this.eventTarget().dispatchEvent(event);}</body><body package="AppeX-Client">removeEventListener(type, listener, useCapture) {// Simulate the EventTarget API	return this.eventTarget().removeEventListener(type, listener, useCapture || false)}</body><body package="AppeX-Client">triggerEvent(type, detail){	var event;	event = document.createEvent("CustomEvent");	event.initCustomEvent(type, true, true, detail);	this.dispatchEvent(event);}</body></methods><methods><class-id>AppeX.JavascriptObject</class-id> <category>javascript - Object.prototype</category><body package="AppeX-Client">eventTarget() {// Simulate the object's ability to implement EventTarget API.	return this._eventTarget = this._eventTarget || document.createTextNode('eventTarget');}</body><body package="AppeX-Client">getClassName() {	return this.constructor.name;}</body><body package="AppeX-Client">getFullClassName() {	return $t.getFullClassName(this);}</body><body package="AppeX-Client">subclassResponsibility(methodName) {	$t.debug(this, " must implement " + methodName);}</body></methods><methods><class-id>AppeX.DebuggingOptions</class-id> <category>accessing</category><body package="AppeX-Client">applyOptions(object, arrayOfArguments) {// Use my options to notify the user with the arguments passed.	var label;	if(object) {		label = object.getClassName();	}	else { 		label = "AppeX System"	}	if (this.log) {		console.log("%c %s Log ", "color:darkBlue; background:lightGrey; font-size: larger", label);		if(object) {			console.log(object);		}		for (var i = 0; i &lt; arrayOfArguments.length; i++) {			var argument = arrayOfArguments[i];			if (typeof argument === 'object') {				console.dir(argument);			} else {				console.log(argument)			}		}	}		if (this.trace) {		console.log("%c %s Trace ", "color:red; background:lightGrey; font-size: larger", label);		if(object) {			console.log(object);		}		if (console.trace) { 			console.trace.apply(console, arrayOfArguments);		} else {			console.log.apply(console, arrayOfArguments);		}	}	if (this.debugger) {		debugger;	}	}</body><body package="AppeX-Client">off() {	this.log = false;	this.trace = false;	this.debugger = false;}</body><body package="AppeX-Client">option(option, boolean) {// Set or get a debugging option	var	index,		levels = ["log", "trace", "debugger"];	if (boolean === undefined) {		return this[option];	}	index = levels.indexOf(option);	if (index != -1) {		this[option] = boolean;	}	return this[option];}</body></methods><methods><class-id>AppeX.DebuggingOptions</class-id> <category>initialize-release</category><body package="AppeX-Client">initialize() {	this.off();}</body></methods><methods><class-id>AppeX.ApplicationClient</class-id> <category>server events</category><body package="AppeX-Client">cancelInterestInAllEvents()  {// Cancel interest in all previously registered events.	if (!this.serverEvents) {		return this;	}		var		i,		eventNames = Object.keys(this.serverEvents);	for (var eachEvent in eventNames) {		this.cancelInterestInEvent(eventNames[eachEvent]);	};	return this;	}</body><body package="AppeX-Client">cancelInterestInEvent(eventName)  {// If I haven't done that before, I will post a client event notifying server// that I am no longer interested in @eventName.// Then I remove @eventName from my serverEvents.	var self = this;	if (this.serverEvents &amp;&amp; this.serverEvents[eventName]) {		this.postClientEvent("cancelInterestInEvent", eventName);		this.serverEvents[eventName].forEach(function(listener){			self.eventChannel.source.removeEventListener (eventName,listener)		});		delete this.serverEvents[eventName]	}}</body><body package="AppeX-Client">closeEventChannel() {	$t.debug("Closing Event Channel");	this.eventChannel.source.close();	this.cancelInterestInAllEvents();	delete this.eventChannel.source;	delete this.eventChannel;	delete this.serverEvents;	return this;}</body><body package="AppeX-Client">createEventChannel() {// Create the eventChannel object to which a source will be attached later.	this.eventChannel = {		postUrl: "_appex_postClientEvent"	};	return this;}</body><body package="AppeX-Client">createEventSource(path) {// Create a new EventSource with @url as a base and my sessionId in the query string.	return new EventSource(this.url + path + "?" + this.sessionQuery());}</body><body package="AppeX-Client">handleEventSourceError(eventSource,event) {// An error occurred on @eventSource. A likely cause would be a network error or server shutdown.// By default, just log it to the console.	console.log("EventSource error occurred: ", eventSource, event);	return this;}</body><body package="AppeX-Client">handleServerMessage(messageEvent) {	// Process a generic server message. No event: has been specified in the response.	// I do nothing but subclasses may override.	$t.debug("Server message event:", messageEvent);}</body><body package="AppeX-Client">handleServerShutdown(duration) {	// this is a default server shutdown handler.	this.closeEventChannel();				alert ("Server is shutting down in "+ duration + " seconds");	return this}</body><body package="AppeX-Client">handleSessionExpired(session) {	// this is a default 'session expired' handler.	// I am no longer interested in 'SessionExpired' event (no point).	// If I establish a new session, I have to re-register interest again.	this.cancelInterestInEvent('SessionExpired');	this.closeEventChannel();	this.removeItemFromStorage("appex_session", sessionStorage);		this.showSessionExpired(this.session);	return this}</body><body package="AppeX-Client">handleSessionNotFound(data) {	alert("Session not found: " + data);	this.closeEventChannel();}</body><body package="AppeX-Client">handleSessionReady() {	this.cancelInterestInEvent("SessionReady");	this.buildHtml();}</body><body package="AppeX-Client">openEventChannel() {	var self = this;	var eventSource = this.createEventSource( "_appex_getServerEvents" );	eventSource.onmessage = function(event) {		self.handleServerMessage(event);	};	eventSource.onerror = function(event) {		self.handleEventSourceError(eventSource,event);	};	this.eventChannel.source = eventSource;	this.eventChannel.triggerEvent("EventSourceReady");	return this;}</body><body package="AppeX-Client">registerInterestInEvent(eventName)  {// If I haven't done that before, I will post a client event notifying server// that I am interested in @eventName.// Then I add @eventName property to my serverEvents with counter set to zero.	this.serverEvents = this.serverEvents || {};	if (!this.serverEvents[eventName]) {		this.postClientEvent("registerInterestInEvent", eventName);		this.serverEvents[eventName] = [];	}}</body><body package="AppeX-Client">registerServerEvents() {	this.registerSessionReady();	this.registerSessionExpired();	this.registerSessionNotFound();	this.registerServerShutdown();	return this;}</body><body package="AppeX-Client">registerServerShutdown() {	var self = this;	this.onServerEvent(		'ServerShutdown',		function(data) {			self.handleServerShutdown(data);		}	);	return this;}</body><body package="AppeX-Client">registerSessionExpired() {	var self = this;	this.onServerEvent(		'SessionExpired',		function(data) {			self.handleSessionExpired(data);		}	);	return this;}</body><body package="AppeX-Client">registerSessionNotFound() {	var self = this;	this.onServerEvent(		'SessionNotFound',		function(data) {			self.handleSessionNotFound(data);		}	);	return this;}</body><body package="AppeX-Client">registerSessionReady() {	var self = this;	this.onServerEvent(		"SessionReady",		function(event) {			self.handleSessionReady();		}	);	return this;}</body></methods><methods><class-id>AppeX.ApplicationClient</class-id> <category>CRUD</category><body package="AppeX-Client">DELETE(path, parameters) {// 'delete' is a Javascript reserved word. I have to be named with capital letters.	return this.asyncMessageToServer(		path,		parameters,		{ method: 'DELETE' }	);}</body><body package="AppeX-Client">GET(path, parameters) {		return this.asyncMessageToServer(		path,		parameters,		{ method: 'GET' }	);}</body><body package="AppeX-Client">POST(path, parameters) {	return this.asyncMessageToServer(		path,		parameters,		{ method: 'POST' }	);}</body><body package="AppeX-Client">PUT(path, parameters) {	return this.asyncMessageToServer(		path,		parameters,		{ method: 'PUT' }	);}</body></methods><methods><class-id>AppeX.ApplicationClient</class-id> <category>initialize</category><body package="AppeX-Client">buildHtml() {// The main function for building the HTML.// Do nothing by default.// Subclasses will want to override.	return this;}</body><body package="AppeX-Client">initialize(options) {// Keep my url so I know where to send my message.// Set the options that may have been passed to the constructor function,	if (document.baseURI) {		this.url = document.baseURI; 	} else {		//the full baseURI would be as below for IE		this.url = document.location.protocol + "//" + document.location.host + document.location.pathname + '/';	}	this.queryParameters = this.getQueryParameters();	this.hashPath = this.getHashPath();	$t.replace(this, options);}</body><body package="AppeX-Client">initializeUrl() {	// Keep my url so I know where to send my message.	var elements = document.getElementsByTagName("base");	var url = elements.length		? elements[elements.length - 1].href		: document.URL;	this.url = url;}</body><body package="AppeX-Client">install(options) {// Install the application, then process the installQueue.	this.installApplication(options);	this.buildHtml();	this.postInstall();}</body><body package="AppeX-Client">installApplication(options) {// Install myself as the sole application.// Set whatever options I may have received.	$t.application = this;	this.constructor.application = this;	$t.replace(this, options);	return this;}</body><body package="AppeX-Client">postInstall() {// Hook to do post-install actions. Do nothing by default.	var 	self = this;	document.body.addEventListener(		"unload",		function(event) {			self.uninstall();		}	);	return this;}</body><body package="AppeX-Client">uninstall() {// Tear down things that need to be torn down when the window gets closed, reloaded, or navigated away.	this.closeEventChannel();}</body></methods><methods><class-id>AppeX.ApplicationClient</class-id> <category>client storage</category><body package="AppeX-Client">getItemFromStorage(key, storage) {	// Get an item under the @key from the browser @storage.	// @storage can be sessionStorage or localStorage.	// return an Object or null	var string = storage.getItem(key);	return string &amp;&amp; JSON.parse(string);}</body><body package="AppeX-Client">removeItemFromStorage(key, storage) {	// Get an item under the @key from the browser @storage, then remove it.	// @storage can be sessionStorage or localStorage.	var item = this.getItemFromStorage(key, storage);	storage.removeItem(key);	return item;}</body><body package="AppeX-Client">storeItemInStorage(key, item, storage) {	// Store an item under the @key in the browser @storage.	// @storage can be sessionStorage or localStorage.	storage.setItem(key, JSON.stringify(item));}</body></methods><methods><class-id>AppeX.ApplicationClient</class-id> <category>API</category><body package="AppeX-Client">asyncMessageToServer(path, messageArguments, messageOptions) {// Force the message to be sent asynchronously.	var	self = this,		response;		var arguments = messageArguments || [];	var options = messageOptions || {};	options.async = true;	response = this.messageToServer(path, arguments, options);	response.onError(function(error) {		self.errorAsyncRequestFailed(path, error);	});		return response;}</body><body package="AppeX-Client">messageToServer(path, messageArguments, messageOptions) {	/* Extract the callback options from messageArguments,	* determine the type of message (synchrnous, asynchronous),	* and invoke the function appropriate for the message.	*/	var options = messageOptions || {};	var argumentArray = messageArguments || [];	var method = options.method ||  "POST";	method = method.toUpperCase();	var asynchronous = (options.async == true);	var data = {};	if (this.sessionKey) {		var sessionKey = this.sessionKey;		data[sessionKey] = this[sessionKey];	}	var jsonArgs = JSON.stringify(argumentArray);	$t.debug("Sending Request Path:", path);	$t.debug("Sending Request Arguments:", argumentArray, jsonArgs);	if (jsonArgs != "{}" &amp;&amp; jsonArgs != "[]") {		data.arguments = jsonArgs;	}	$t.debug("Sending Request DATA:", data);	return this.serverRequest(method, path, data, asynchronous);}</body><body package="AppeX-Client">onServerEvent(eventName, callback) {// Register interest in @eventName with the server.// Add an event listener to my eventChannel source, and return the listener function.	var		self = this,		listener,		addInterestInSource;	// First, register interest on the server itself:	this.registerInterestInEvent(eventName);	// Keep track of the listener function for a removal when no longer interested.		listener = function(event) {		callback(JSON.parse(event.data), event);	};	this.serverEvents[eventName].push(listener);		if(this.eventChannel.source) {		// EventSource has been set up, simply run the function.		this.eventChannel.source.addEventListener (eventName,listener);	} else {		// Create a callback function in which I run the addInterestInSource.		sourceReadyHandler = function(e) {			// Don't forget to remove the event listener itself when invoked, to prevent a possibility of multiple callbacks.			self.eventChannel.removeEventListener("EventSourceReady", sourceReadyHandler);			self.eventChannel.source.addEventListener (eventName,listener);			};		// Now register the callback function.		this.eventChannel.addEventListener("EventSourceReady", sourceReadyHandler)	}	return listener;}</body><body package="AppeX-Client">postClientEvent(eventName, data) {// Post event with @eventName to the server.// This allows the server to notify its other clients about// the event having occurred here.	var self = this,		response;	response =  this.asyncMessageToServer(		this.eventChannel.postUrl,		{			eventName: eventName,			data: data		}	)	.onError(function (error) {		self.postClientEventError(error);	})	.onSuccess(function () {		self.postClientEventSuccess(response);	});	return response;}</body><body package="AppeX-Client">postClientEventError(error) {	$t.debug('Log error by default.  Override postClientEventError in subclasses. ' + error.response);}</body><body package="AppeX-Client">postClientEventSuccess(response) {	//by default do nothing.  Override in subclasses	$t.debug("Client Event Success:", response);}</body><body package="AppeX-Client">syncMessageToServer(path, messageArguments, messageOptions) {	/* Force the message to be sent synchronously. */	var arguments = messageArguments || [];	var options = messageOptions || {};	options.async = false;	return this.messageToServer(path, arguments, options).object;}</body></methods><methods><class-id>AppeX.ApplicationClient</class-id> <category>debugging</category><body package="AppeX-Client">_debugger(boolean) {	return this._debugging("debugger", boolean);}</body><body package="AppeX-Client">_debugging(option, boolean) {// Get or set a debugging option named @option.// If boolean is undefined, it's a 'get', otherwise 'set'.// If boolean is undefined and I haven't set my debugging options, the return value will be false.	if (boolean === undefined) {		if (!this._debuggingOptions) {			return false;		}	}	this._debuggingOn();	return this._debuggingOptions.option(option, boolean);}</body><body package="AppeX-Client">_debuggingOff() {	this._debuggingOptions &amp;&amp; this._debuggingOptions.off();}</body><body package="AppeX-Client">_debuggingOn() {	this._debuggingOptions = this._debuggingOptions || new AppeX.DebuggingOptions();}</body><body package="AppeX-Client">_log(boolean) {	return this._debugging("log", boolean);}</body><body package="AppeX-Client">_trace(boolean) {	return this._debugging("trace", boolean);}</body><body package="AppeX-Client">debug() {// If I have set up debugging options, use them to do logging, debugging, etc.	var options = this._debuggingOptions;	if (options) {		options.applyOptions(this, arguments);	}}</body></methods><methods><class-id>AppeX.ApplicationClient</class-id> <category>session management</category><body package="AppeX-Client">getSessionFromStorage() {	var storedSession = this.getItemFromStorage("appex_session", window.sessionStorage);	$t.debug("Session item:", storedSession);	var session = {};	if (storedSession) {		$t.replace(session, storedSession);	}	return session;}</body><body package="AppeX-Client">installSession(options) {	// If I am linking a session, I need to add session options to myself.	// Typically, that would be "sessionKey" session parameter but the application may add others.	// See Application class&gt;&gt;bodyInstallApplication for sample construction of sender	var	self = this,		session,		response;			this.installApplication(options);	session = this.getSessionFromStorage();	response = this.linkSession(session);	response		.onError(function(error){			console.error("Session link primitive failed", session, error)		})		.onSuccess(function() {			$t.debug("Install Session. Server Response for _appex_linkSession:", response);			self.installSessionSuccess(session, response.object);			self.postInstall();		});	return this;}</body><body package="AppeX-Client">installSessionSuccess(session, data) {	var self = this;	this.updateSessionData(session, data);	this.createEventChannel();	this.registerServerEvents();	this.openEventChannel();	return this;}</body><body package="AppeX-Client">linkSession(session) {	return this.primitiveToServer("_appex_linkSession", session, {async: true});}</body><body package="AppeX-Client">sessionQuery() {	if (!this.session) return null;	var sessionKey = this.session.sessionKey;	return sessionKey + "=" + this[sessionKey];}</body><body package="AppeX-Client">showSessionExpired(session) {	alert ("Session expired.");	return this}</body><body package="AppeX-Client">updateSessionData(session, data) {// Update a @session object from @data.	$t.replace(session, data);	$t.debug("Update Session:", session);	this.storeItemInStorage("appex_session", session, window.sessionStorage);	// For easy access, store the value of 'sessionId' in myself.	this[session.sessionKey] = session[session.sessionKey];	this.session = session;	return this;}</body></methods><methods><class-id>AppeX.ApplicationClient</class-id> <category>private</category><body package="AppeX-Client">primitiveToServer(message, primitiveArguments, optionsArg) {// Primitive are like messages except they go directly to the subclass of ApplicationServer which serves the application.// A primitive will have a string specifying the message, arguments, and ajax options (i.e.,method, sync/async, etc.)// A primitive is session independent (no prior session establishment is necessary)	$t.debug("Sending PRIMITIVE to server:", message, primitiveArguments, optionsArg);	var	options,		method;			options = optionsArg || {};	method = options.method ||  "POST";	method = method.toUpperCase();	var asynchronous = !(options.async == false);	var data = {		"arguments": JSON.stringify(primitiveArguments)	};	return this.serverRequest(method, message, data, asynchronous);}</body><body package="AppeX-Client">serverRequest (method, path, data, asynchronous) {	/* Build a generic ajax message that will handle both synchronous and asynchronous requests,	* on any browser(?).  Tested on Chrome, Firefox, IE.	*/	var application = this;	var url = this.url;	var returnData = {};	//add trailing slash if missing	if (url[url.length-1] != "/") { url += "/" };	url += path;	var request = new AppeX.ServerRequest(url, data, method, asynchronous);	$t.debug("Sending Server Request",request);	request.deliver();	$t.debug("Received Server Response", request.response);	return request.response;}</body></methods><methods><class-id>AppeX.ApplicationClient</class-id> <category>accessing - url</category><body package="AppeX-Client">getHashPath() {// Get the current document location hash string and parse it into an Array that represents the hash.	var	hash = document.location.hash,		components;		if(hash.length === 0) {		return [];	}		hash = hash.split("#");	// Ignore all but the last. The hash string must have only a single hash sign, and we are only interested in what comes after it.	// e.g., "#list/someValue" -&gt; ["", "list/someValue" ]	hash = hash[hash.length - 1];	// Split the hash into path components, and return it.	// e.g., ["list", "someValue"]	components = hash.split("/");	for (var i = 0; i &lt; components.length; i++) {		components[i] = decodeURIComponent(components[i]);	}	return components;}</body><body package="AppeX-Client">getQueryParameters() {// Get the current document location search string and parse it into an object with keys and values.	var	search = document.location.search,		query,		pairs,		eachPair,		eachKey,		eachValue,		parameters = {};		if(search.length === 0) {		return parameters;	}		query = search.split("?");	// Ignore all but the last. The query string must have only a single questionmark, and we are only interested in what comes after it.	// e.g., "?id=123&amp;key=value" -&gt; ["", "id=123&amp;key=value" ]	query = query[query.length - 1];	// Split the query into key/value pairs.	// e.g., ["id=123", "key=value"]	pairs = query.split("&amp;");		for (var i = 0; i &lt; pairs.length; i++) {		// Split each pair into key and value.		// e.g., ["id", "123"]		eachPair = pairs[i].split("=");		eachKey = decodeURIComponent(eachPair[0]);		eachValue = decodeURIComponent(eachPair[1]);		parameters[eachKey] = eachValue;	}	return parameters;}</body></methods><methods><class-id>AppeX.ApplicationClient</class-id> <category>themes</category><body package="AppeX-Client">setTheme(url) {	// Set the href of the #appex-theme-css element to @url.	// This will cause the theme link CSS to be reloaded and the page re-styled according to the new style sheet.	var 	link = document.getElementById("appex-theme-css");		if (!link) {		return;	}		link.href = url;}</body></methods><methods><class-id>AppeX.ApplicationClient</class-id> <category>error handling</category><body package="AppeX-Client">errorAsyncRequestFailed(path, error) {	$t.debug("Request Failed. Response:", path, error.response);}</body></methods><methods><class-id>AppeX.ApplicationClient</class-id> <category>user messages</category><body package="AppeX-Client">_setLanguage(aString, aCallback) {// aString is the code of the language to be set, e.g., 'en'// aCallback is an optional anonymous function to be executed after the language has been successfully set.	var self = this,		aCatalogFromStorage,		response;		//first check if the catalog is already present in memory	if ($t._catalogs[aString]) {		this._language = aString;		//put the name of the current language in sesssion storage		this.storeItemInStorage('appex_language', this._language, window.sessionStorage);			aCallback &amp;&amp; aCallback();		return;	} else {		//if the catalog for the language is not in memory, try to retrieve the data from session storage		aCatalogFromStorage = this.getItemFromStorage('appex_' + aString, window.sessionStorage);		if (aCatalogFromStorage) {			this._language = aString;			//cache the catalog data retrieved from storage in memory			$t._catalogs[this._language] = aCatalogFromStorage;			//put the name of the current language in sesssion and local storage			this.storeItemInStorage('appex_language', this._language, window.sessionStorage);				this.storeItemInStorage('appex_language', this._language, window.localStorage);				aCallback &amp;&amp; aCallback();			return;		}	}		response = this.asyncMessageToServer("_appex_catalogForLanguage", aString)		.onError( function (error) { console.log("Error:", error) })		.onSuccess( function (data) { 			self._language = aString;			$t._catalogs[self._language] = data;			//put the current language in session and local storage			self.storeItemInStorage('appex_language', self._language, window.sessionStorage);			self.storeItemInStorage('appex_language', self._language, window.localStorage);			//put the corresponding catalog in session storage				self.storeItemInStorage('appex_' + self._language, data, window.sessionStorage);						aCallback &amp;&amp; aCallback();	 });	}</body><body package="AppeX-Client">_translate(key, defaultString, catalogId) {	//The only required parameter is 'key'.	//If there is a catalog value for 'key', then that value will be returned.	//If there is no catalog value for 'key', but a 'defaultString' is supplied, the 'defaultValue' will be returned.	//If there is no catalog entry for 'key', and no 'defaultString' is supplied, then the 'key' itself will be returned.	//In summary, one of the following three possible values will be returned, in order of preference:	//1. value looked up in catalog 2.supplied default string 3.key.		var aCatalog;	//in first cut ignore catalogId	aCatalog =  $t._catalogs[this._language || 'en'];	return aCatalog[key] || defaultString || key;	}</body></methods><methods><class-id>AppeX.ServerResponse</class-id> <category>API</category><body package="AppeX-Client">onError(callbackFunction) {	// if I am not done, push callbackFunction on the error callbacks queue.	// Otherwise, process callbackFunction immediately if I am in error.	// Always return myself to allow method chaining.	if (!this.isDone) {			this.callbacks.onError = callbackFunction;			return this;	} else if (this.isError) {		this.processCallbacks(callbackFunction);	}	return this;}</body><body package="AppeX-Client">onSuccess(callbackFunction) {	// if I am not done, push callbackFunction on the sucess callbacks queue.	// Otherwise, process callbackFunction immediately if isSuccess.	// Always return myself to allow method chaining.	if (!this.isDone) {			this.callbacks.onSuccess = callbackFunction;			return this;	} else if (this.isSuccess) {		this.processCallbacks(callbackFunction);	}	return this;}</body></methods><methods><class-id>AppeX.ServerResponse</class-id> <category>private - processing</category><body package="AppeX-Client">addContentHandler(rule, handler) {	// Add the rule/handler pair to my content handlers. This would allow cusome content handling	// beyond what the standard handlers will be.	// @rule:	//	a function that will receive my contentType in the argument and will return a boolean	// 	indicating whether the rule is a match.	// @handler:	//	a function that will be applied to myself when @rule returns true.	this._contentHandlers.push([rule, handler]);}</body><body package="AppeX-Client">initializeContentHandlers() {	this._contentHandlers = [];	return this;}</body><body package="AppeX-Client">processCallbacks(callback) {	// depending on the status, process the right callback.	if (! this.isDone) {		throw new Error("The processCallbacks function must not be called before the response is done.");		return;	}	// if callback is defined, evaluate it.	// if callback is not defined, find which callback should be executed and re-enter this function with	// the proper callback in argument.	if (callback !== undefined) {		return callback(this.object);	}		// execute the generic version	if (this.isSuccess) {		return this.callbacks.onSuccess(this.object);	}	if (this.isError) {		return this.callbacks.onError(this.object);	}}</body><body package="AppeX-Client">processData() {	if (this.data === null) {		return this;	}	var handlers = this._contentHandlers;	for(i = 0;  i&lt; handlers.length;  i++) {		var pair = handlers[i];		var match = pair[0].call(this,this.contentType);		if (match) {			pair[1].call(this, this);			break;		}	}	this.object = this.object || this.data;	this.isDone = true;	return this;}</body><body package="AppeX-Client">setupDefaultContentHandlers() {	// Define the default content handlers.	// If an application wants to use custom content handlers for a response,	// it should call &lt;response&gt;.initializeContentHandlers()	// followed by a sequence of &lt;response&gt;.addContentHandler(rule, handler) calls to define its own.	// the rules are evaluated on a 'first win' basis, so the order is important here.	// For example, if a catch-all rule for text is used but 'text/html' is handled differently,	// the rule for 'text/html' must come before 'text/*'.	this.addContentHandler(		function(contentType) {			return contentType == undefined		},		function(response) {			response.object = response.data;			return response;		}	);	this.addContentHandler(		function(contentType) {			return contentType.match(/^text/);		},		function(response) {			response.object = response.data;			return response;		}	);	this.addContentHandler(		function(contentType) {			return contentType == "application/json";		},		function(response) {			response.object = JSON.parse(response.data);			return response;		}	);	this.addContentHandler(		function(contentType) {			return true;		},		function(response) {			response.object = response.data;			return response;		}	);	return this;}</body></methods><methods><class-id>AppeX.ServerResponse</class-id> <category>initialize-release</category><body package="AppeX-Client">initialize(aRequest) {	this.request = aRequest;	this.callbacks = {		"onSuccess": function() {},		"onError": function(error) {			console.error(error, aRequest);		}	};	this.initializeContentHandlers();	this.setupDefaultContentHandlers();}</body></methods><methods><class-id>AppeX.JavascriptArray</class-id> <category>javascript - initialization</category><body package="AppeX-Client">initialize(){		Array.ClassName = "Array";}</body></methods><methods><class-id>AppeX.JavascriptArray</class-id> <category>javascript  </category><body package="AppeX-Client">eachDo(aFunction) {	for (var i = 0; i &lt; this.length; i++) {		aFunction(this[i]);	}}</body></methods><methods><class-id>AppeX.JavascriptFunction</class-id> <category>javascript - initialization</category><body package="AppeX-Client">initialize() {	Function.ClassName = "Function";		Object.defineProperty(Function.prototype,		"functionName",		{value: function functionName() {			var aName,				aString,				afterKeyword;			aName = this.name;			if (aName) {				return aName;			}			aString = this.toString();  			afterKeyword = aString.substr("function ".length);  			aName = afterKeyword.split("(")[0].trim();  			return aName;		}	});		Object.defineProperty(Function.prototype,		"bindMethod",		{value: function bindMethod(aFunction) {			Object.defineProperty(				this.prototype,				aFunction.functionName(),				{value: aFunction, enumerable: false, writable: true});			return aFunction;		}	});	}</body></methods><methods><class-id>AppeX.JavascriptFunction</class-id> <category>javascript</category><body package="AppeX-Client">_subclass(specification, namespace) {	// Define a function that creates a subclass of a Javascript constructor function	// from a specification in a given Namespace.	var theClass,		className,		superclass,		protoSuper,		protoThis;			theClass = specification.constructor;	className = theClass.functionName();	superclass = this;	protoSuper = Object.create(superclass.prototype);	protoThis = Object.create(theClass.prototype);	protoSuper = $t.replace(protoSuper, protoThis);	theClass.prototype = protoSuper;	theClass.subclasses = [];	Object.defineProperty(theClass.prototype, "constructor", {value: theClass, enumerable: false, writable: false});	Object.defineProperty(theClass, "ClassName", {value: className, enumerable: false, writable: false});	Object.defineProperty(theClass, "Superclass", {value: superclass, enumerable: false, writable: false});	Object.defineProperty(namespace, className, {value: theClass, enumerable: false, writable: false});	superclass.subclasses = superclass.subclasses || [];	superclass.subclasses.push(theClass);	if (namespace.constructor.ClassName == "Namespace") {		Object.defineProperty(theClass, "Namespace", {value: namespace, enumerable: false, writable: false});		namespace[specification.className] = theClass;	};	return theClass;}</body><body package="AppeX-Client">allSubclasses() {	var classCollection,		i,		eSubclass;				classCollection = this.subclasses.slice(0);	for (i = 0; i &lt;  classCollection.length; i++) {		eSubclass = classCollection[i];		classCollection = classCollection.concat(eSubclass.subclasses);			}	return classCollection;}</body><body package="AppeX-Client">fullName() {			var prefix = this.Namespace ? (this.Namespace.fullName() + ".") : "";	var className = this.ClassName ? this.ClassName : "&lt;unknown&gt;";	return prefix + className}</body><body package="AppeX-Client">getNamespace() {	return this.Namespace ? this.Namespace :  {}}</body></methods><methods><class-id>JavascriptNamespace</class-id> <category>javascript</category><body package="AppeX-Client">defineClass(specification) {		var superclass = specification.superclass || Object;	return superclass._subclass(specification, this);}</body><body package="AppeX-Client">defineNamespace(aName) {	var namespace = this[aName];	if (namespace instanceof $t.Namespace) return namespace;	namespace = new $t.Namespace(aName);	this[aName] = namespace;	namespace.parent = this;	if (this === $t) {		window[aName] = namespace;	}	return namespace;}</body><body package="AppeX-Client">ensureNamespace(aName) {	var path = aName.split(".");	var currentNamespace = this;	while (path.length &gt; 0) {		var eachName = path.shift();		currentNamespace = currentNamespace.defineNamespace(eachName);	}	return currentNamespace;}</body><body package="AppeX-Client">getFullClassName(anObject) {	var theName = anObject.constructor.fullName ? anObject.constructor.fullName() : anObject.constructor.name;	return theName.replace("$t.", "");	}</body></methods><methods><class-id>JavascriptNamespace</class-id> <category>javascript - initialization</category><body package="AppeX-Client">initialize() {	//execute the code in an anonymous function 	(function () {		var namespaceConstructor = function (aName) {			this.name = aName;		};		namespaceConstructor.ClassName = "Namespace";		$t = new namespaceConstructor("Smalltalk");		$t.Namespace = namespaceConstructor;			$t.debug = function debug() {			$t._debuggingOptions = $t._debuggingOptions || new AppeX.DebuggingOptions();			if (arguments.length !== 0) {				$t._debuggingOptions.applyOptions(null, arguments);			}		};			$t.replace = function replace(target, source) {			// replace the properties in the target with those in the source (as in extjs apply or jquery extend)			// return the target			if (!source) { return target };			for (var key in source) { target[key] = source[key] };			return target;		};		})();	}</body></methods><methods><class-id>AppeX.ServerRequest</class-id> <category>processing</category><body package="AppeX-Client">deliver() {	// Deliver the request to the server.	// Find which one of the delivery functions should be invoked.	var deliveryFunction = this._deliveryMap[this.method];	this.httpRequest = new XMLHttpRequest();	this.response = new $t.AppeX.ServerResponse(this);	deliveryFunction.apply(this, [this.url, this.data]);	return this.response;}</body><body package="AppeX-Client">encodeFormData(data) {	// Encode the properties of an object as if thery were name/value pairs from	// an HTML form, using application/x-www-form-urlencoded format.	if (!data) return "";	var pairs = [];	$t.debug("Encoding Form Data:", data);	for (var name in data) {		if (!data.hasOwnProperty(name)) continue;		if (typeof data[name] === "function") continue;		var value = data[name].toString();		name = encodeURIComponent(name).replace("%20", "+");		value = encodeURIComponent(value).replace("%20", "+");		pairs.push(name + "=" + value);	};	$t.debug("Encoded Form Data:", pairs);	return pairs.join("&amp;");}</body><body package="AppeX-Client">ensureCallback(readyState, httpStatus) {	var callbacks = (this._callbacks[readyState] = this._callbacks[readyState] || {});	return callbacks[httpStatus] = callbacks[httpStatus] || [];}</body><body package="AppeX-Client">processCallbacks(readyState, status) {	var self = this;	// Process the higher-level callbacks that operate on my response data.	this.ensureCallback(readyState, status);	var readyStateCallbacks = self._callbacks[readyState];	var statusCallbacks = readyStateCallbacks[status] || [];	statusCallbacks.forEach(		function(callback) {			self.processReadyStateChange(callback);		}	)}</body><body package="AppeX-Client">processReadyStateChange(callback) {	// At this point, all low level callback processing is done by me.	// I let the registered callbacks operate on my response and its data.	// It is assumed that callback knows for which readyState/status it has been registered	// because I don't care any more what these are.	$t.debug(this, "Processing response CALLBACK:", callback);	callback(this.response);	}</body><body package="AppeX-Client">request_DONE(httpRequest) {	// XMLHttpRequest.DONE has been detected.	$t.debug("XMLHttpRequest.DONE. Creating ServerResponse object from XMLHttpRequest:", httpRequest);	var response = this.response; /* a ServerResponse */	response.isReceiving = true;	response.httpStatus = httpRequest.status;	response.contentType = httpRequest.getResponseHeader("Content-Type");	response.data = httpRequest.response;	response.isReceiving = false;	if (httpRequest.status === 200) {		response.isSuccess = true;	} else if (httpRequest.status &gt;= 400) {		response.isError = true;		response.data = {			status: httpRequest.status,			statusText: httpRequest.statusText,			response: httpRequest.response		}	}	response.processData();	response.isDone = true;	response.processCallbacks();}</body><body package="AppeX-Client">request_HEADERS_RECEIVED(httpRequest) {	// Nothing special to do here. Placeholder for future enhancements.}</body><body package="AppeX-Client">request_LOADING(httpRequest) {	// Nothing special to do here. Placeholder for future enhancements.}</body><body package="AppeX-Client">request_OPENED(httpRequest) {	// Nothing special to do here. Placeholder for future enhancements.}</body><body package="AppeX-Client">request_UNSENT(httpRequest) {	// Nothing special to do here. Placeholder for future enhancements.}</body><body package="AppeX-Client">sendRequest(httpRequest, data) {	$t.debug("Sending XMLHttpRequest:", httpRequest, data);	httpRequest.send(data);}</body><body package="AppeX-Client">setupCallbacks(httpRequest) {	// save the current context to use inside the callback function.	var self = this;		httpRequest.onreadystatechange = function() {		// First, process the Http request and set some internal values from it.		$t.debug("Processing XMLHttpRequest.readyState:", httpRequest.readyState);		switch(httpRequest.readyState) {			case XMLHttpRequest.UNSENT: 				self.request_UNSENT(httpRequest);				break;			case XMLHttpRequest.OPENED:				self.request_OPENED(httpRequest);				break;			case XMLHttpRequest.HEADERS_RECEIVED:				self.request_HEADERS_RECEIVED(httpRequest);				break;			case XMLHttpRequest.LOADING:				self.request_LOADING(httpRequest);				break;			case XMLHttpRequest.DONE:				self.request_DONE(httpRequest);				break;		};		// Next, process the higher-level callbacks that operate on my response data.		self.processCallbacks(httpRequest.readyState, httpRequest.status);	};}</body></methods><methods><class-id>AppeX.ServerRequest</class-id> <category>delivery functions</category><body package="AppeX-Client">doDeleteData(url, data) {	// This is the 'DELETE' delivery function.	// Encode my data as a query string to include as part of the URL.	var request = this.httpRequest;	request.open("DELETE", url + "?" + this.encodeFormData(data), this.asynchronous);	if (this.asynchronous) {		this.setupCallbacks(request);	}	this.sendRequest(request, null);	if (!this.asynchronous) {		this.request_DONE(request);	}}</body><body package="AppeX-Client">doGetData(url, data) {	// This is the 'GET' delivery function.	// Encode my data as a query string to include as part of the URL.	var request = this.httpRequest,		query = this.encodeFormData(data);	if (query.length &gt; 0) {		query = "?" + query;	}	request.open("GET", url + query, this.asynchronous);	if (this.asynchronous) {		this.setupCallbacks(request);	}	this.sendRequest(request, null);	if (!this.asynchronous) {		this.request_DONE(request);	}}</body><body package="AppeX-Client">doPostData(url, data) {	// This is the 'POST' delivery function.	// data is sent as x-www-form-urlencoded.	var request = this.httpRequest;	request.open("POST", url, this.asynchronous);	if (this.asynchronous) {		this.setupCallbacks(request);	}	request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");	this.sendRequest(request, this.encodeFormData(data));	if (!this.asynchronous) {		this.request_DONE(request);	}}</body><body package="AppeX-Client">doPutData(url, data) {	// This is the 'PUT' delivery function.	// data is sent as x-www-form-urlencoded.	var request = this.httpRequest;	request.open("PUT", url, this.asynchronous);	if (this.asynchronous) {		this.setupCallbacks(request);	}	request.setRequestHeader("Content-Type", "application/x-www-form-urlencoded;charset=utf-8");	this.sendRequest(request, this.encodeFormData(data));	if (!this.asynchronous) {		this.request_DONE(request);	}}</body></methods><methods><class-id>AppeX.ServerRequest</class-id> <category>initialize-release</category><body package="AppeX-Client">initialize(url, data, method, asynchronous) {	// Initialize the receiver. Make sure I have valid data and method.	// Set up a deliveryMap to map between HTTP methods and functions	// that should be invoked when asked to deliver the data.	// Set up a container object for callbacks.	this.url = url;	this.data = data || {};	this.method = method || "POST";	this.method = this.method.toUpperCase();	this.asynchronous = !(asynchronous === false);	this._deliveryMap = {		"GET" : this.doGetData,		"POST" : this.doPostData,		"PUT" : this.doPutData,		"DELETE" : this.doDeleteData	};	this._callbacks = {};	return this;}</body></methods><methods><class-id>AppeX.EventSourceEmulator</class-id> <category>javascript - private</category><body package="AppeX-Client">connect() {	// This is how we establish a connection	this.type = null;	this.xhr.open("GET", this.url);	this.xhr.setRequestHeader("Cache-Control", "no-cache");	if (this.lastEventId) {		this.xhr.setRequestHeader("Last-Event-ID", this.lastEventId);	}	this.xhr.send();}</body><body package="AppeX-Client">createEvent(eventType, data) {// Create a new MessageEvent object for eventType and data.	var event = document.createEvent("MessageEvent");	var origin = this.url;	var source = this;	var bubbles = false;	var cancelable = false;		event.initMessageEvent(		eventType,		bubbles,		cancelable,		data,		origin,		this.lastEventId,		source);	return event;}</body><body package="AppeX-Client">processData() {// Each time data arrives, process it and trigger the onmessage handler// This function handles the details of the Server-Sent Events protocol	if (!this.type) {		// Check the response type if we haven"t already		this.type = this.xhr.getResponseHeader("Content-Type");		if (this.type !== "text/event-stream") {			return this.close();		}	}	var eventName = "message";		// The default type field of our event objects	var data = "";					// Holds message data	// Keep track of how much we"ve received and get only the	// portion of the response that we haven"t already processed.	var chunk = this.xhr.responseText.substring(this.charsReceived);	this.charsReceived = this.xhr.responseText.length;	// Break the chunk of text into lines and iterate over them.	var lines = chunk.replace(/(\r\n|\r|\n)$/, "").split(/\r\n|\r|\n/);	// Read lines and process the keys from the data stream.	for(var i = 0; i &lt; lines.length; i++) {		var line = lines[i];		var pos = line.indexOf(":");		var name;		var value="";		if (pos == 0) continue;	// Ignore comments		if (pos &gt; 0) {				// field name:value			name = line.substring(0,pos);			value = line.substring(pos+1);			if (value.charAt(0) == " ") {				value = value.substring(1);			}		} else {			name = line;			// field name only		}		switch(name) {			case "event":		eventName = value; break;			case "data":		data += value + "\n"; break;			case "id":		this.lastEventId = value; break;			case "retry":		this.retryDelay = parseInt(value) || 3000; break; 			default: break;  	// Ignore any other line		}		// A blank line means send the event		if (line === "") {			// If no data, try next. 			if (data === "") continue;			// Chop trailing newline if there is one			if (data.charAt(data.length-1) == "\n") {				data = data.substring(0, data.length-1);			};			// Create a new event and dispatch it.			var event = this.createEvent(eventName, data);			eventName == 'message' &amp;&amp; this.onmessage &amp;&amp; this.onmessage(event);			this.dispatchEvent(event);			data = "";			continue;		}	}}</body><body package="AppeX-Client">reconnect() {// If the connection closes normally, wait a second and try to restart	if (this.aborted) return;				// Don't reconnect after an abort	if (this.xhr.status &gt;= 300) return;	// Don't reconnect after an error	// Wait a bit, then reconnect	var self = this;	setTimeout(		function() { 			self.connect() 		},		this.retryDelay	);}</body></methods><methods><class-id>AppeX.EventSourceEmulator</class-id> <category>javascript</category><body package="AppeX-Client">initialize(url) {	// Initialize newly created object.	this.type = null; 				// To check property response type.	this.lastEventId = ""; 			// For resyncing with the server	this.retryDelay = 3000; 		// Delay between connection attempts	this.aborted = false;			// Set true to give up on connecting	Object.defineProperty(		this,		"url",		{ value: url, writable: false, enumerable: true, configurable: false }	);	// Store this for callbacks:	var self = this;	// Create an XHR object	var xhr = this.xhr = new XMLHttpRequest(); 	this.readyState = EventSource.CONNECTING;	// Initial state,	// Define an event handler for it	xhr.onreadystatechange = function() {		switch(xhr.readyState) {			// It is safe to use EventSource. We only run this code if EventSource exists - i.e., this.constructor.			// When the request opens (XHR.OPENED)			case 1:				self.readyState = EventSource.OPEN;				self.charsReceived = 0; //for reconnect after readystate done 				break;			// When a chunk of data arrives (XHR.LOADING)			case 3:				self.processData();				break;			// When the request closes (XHR.DONE)									case 4:				self.readyState = EventSource.CONNECTING;				self.reconnect();				break;		}	};	// And after a slight delay to allow things settle down, establish a long-lived connection through it	setTimeout(function() { self.connect() }, 300 /* milliseconds */ );}</body></methods><methods><class-id>AppeX.EventSourceEmulator</class-id> <category>javascript - EventSource</category><body package="AppeX-Client">close() {	this.aborted = true;	this.xhr.abort();	this.readyState = EventSource.CLOSED;}</body></methods><methods><class-id>AppeX.JavascriptLibrary class</class-id> <category>configuration</category><body package="AppeX-Client">appeXCore	&lt;library: 'AppeX.CoreCode.js'&gt;		^self new  		"Extend Function with bindMethod first."  		addClass: JavascriptFunction; 		"Then extend  other existing JavaScript language objects."		addClass: JavascriptObject;		addClass: JavascriptArray; 		"Then define Namespace and its functions before defining other new Javascript classes."		addClass: JavascriptNamespace;		"After this ordering does not matter"		addClass: ServerRequest;		addClass: ServerResponse;		addClass: EventSourceEmulator;		addClass: DebuggingOptions;		addClass: ApplicationClient;		yourself.</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>JavascriptWriter</name><environment>AppeX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars>serveFilesCombined </class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Support</package></attributes></class><class><name>JavascriptCode</name><environment>AppeX</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>codeCache </class-inst-vars><imports></imports><category>bootstrap</category><attributes><package>AppeX-Support</package></attributes></class></st-source>