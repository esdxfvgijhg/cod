<?xml version="1.0"?><st-source><!-- Name: AppeX-ServerComment: This package provides an object-oriented Javascript framework with an "application client" class already set up for communication with the server.Most of the AppeX examples were built using  this framework.DbIdentifier: bear73DbTrace: 502879DbUsername: tkoganDbVersion: 8.3 - 15DevelopmentPrerequisites: #(#(#any 'SiouX-Server' '') #(#any 'SiouX-Http' '') #(#any 'SiouX-Sessions' '') #(#any 'AppeX-Support' '') #(#any 'CiphersBase' '') #(#any 'SiouX-Http2' ''))PackageName: AppeX-ServerParcel: #('AppeX-Server')PrerequisiteDescriptions: #(#(#name 'SiouX-Server' #componentType #bundle) #(#name 'SiouX-Http' #componentType #bundle) #(#name 'SiouX-Sessions' #componentType #package) #(#name 'AppeX-Support' #componentType #package) #(#name 'CiphersBase' #componentType #package) #(#name 'SiouX-Http2' #componentType #package))PrerequisiteParcels: #(#('SiouX-Server' '') #('SiouX-Http' '') #('SiouX-Sessions' '') #('AppeX-Support' '') #('CiphersBase' '') #('SiouX-Http2' ''))PrintStringCache: (8.3 - 15,tkogan)Version: 8.3 - 15Date: 3:30:53 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:30:53 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ApplicationSession</name><environment>AppeX</environment><super>SiouX.Session</super><private>false</private><indexed-type>none</indexed-type><inst-vars>applications </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Server</package></attributes></class><comment><class-id>AppeX.ApplicationSession</class-id><body>ApplicationSession represents an AppeX session that can be reused in multiple 'pages' - Application subclasses that together form a complex web application.Instance Variables:	applications	&lt;Dictionary&gt;	instances of Application subclasses holding different aspects a single session's state.</body></comment><class><name>WebEvent</name><environment>AppeX</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sessionId eventName data eventId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Server</package></attributes></class><comment><class-id>AppeX.WebEvent</class-id><body>WebEvent is an abstract class that represents events that occur in the ApplicationClient or ApplicationServer and need to be sent to the other side.Instance Variables	data	&lt;Object&gt;	arbitrary object. It must by JSON-serializable.	eventId	&lt;Integer&gt;	auto-generated number uniquely identifying each event.	eventName	&lt;Symbol&gt;	the name of the event.	sessionId	&lt;String | nil&gt;	the sessionId of the session in which the event was first created. May be nil if an event is not tied to any session in particular.UsageThis is an abstract class with two subclasses, ClientEvent and ServerEvent. A number of instance creation convenience methods can be used to create an event, as in the following examples:	ClientEvent eventName: #MyClientEvent	ServerEvent eventName: #MyServerEvent data: &lt;anObject&gt;	ClientEvent sesionId: '1234567890' eventName: #MyClientEvent	ServerEvent sessionId: '1234567890' eventName: #MyClientEvent data: &lt;anObject&gt;</body></comment><class><name>ClientEvent</name><environment>AppeX</environment><super>AppeX.WebEvent</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Server</package></attributes></class><comment><class-id>AppeX.ClientEvent</class-id><body>ClientEvent represents events that occur in an ApplicationClient and have been received by an ApplicationServer via a JSON message send.ImplementationClientEvent is a subclass of WebEvent from which it inherits almost all its behavior.Usage*  A ClientEvent is created when a Javascript client sends the message '_appex_postClientEvent' to an ApplicationServer subclass or its instance. In this message, a ClientEvent is also converted to a ServerEvent with the same name which is then broadcast to clients who have expresses interest in events of that name. See Application class &gt;&gt; #postClientEvent for implemenation.* Developers can create their own client events based on messages received from a client. See WebEvent class methods. A typical way to create and propagate client events would be as follows:	event := ClientEvent				sessionId: &lt;sessionId&gt;				eventName: &lt;aSymbol&gt;				data: &lt;anObject&gt;.	&lt;class or instance&gt; announceClientEvent: event.</body></comment><class><name>ETagRequestFilter</name><environment>AppeX</environment><super>SiouX.RequestFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>etags patterns </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Server</package></attributes></class><comment><class-id>AppeX.ETagRequestFilter</class-id><body>ETagRequestFilter is a request filter that may be added to an application responder to enable client-side resource caching through the use of 'ETag' response header as per RFC 7232: https://tools.ietf.org/html/rfc7232Instance Variables:	etags	&lt;Dictionary&gt;	etag values cached by a resource's path relative to the application	patterns	&lt;OrderedCollection&gt;	URL patterns for which etag caching is allowed.</body></comment><class><name>AppeXSessionFilter</name><environment>AppeX</environment><super>SiouX.SessionFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>linkSessionPath </inst-vars><class-inst-vars>linkSessionPath </class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Server</package></attributes></class><comment><class-id>AppeX.AppeXSessionFilter</class-id><body>AppeXSessionFilter implements session lookup and linking for AppeX applications.Instance Variables:	linkSessionPath	&lt;String&gt;	defines the path of an HTTP request that links or establishes a new session. The path is relative to the application responder path.Implementation:Instances of AppeXSessionFilter will be automatically created on the fly if an application detects that an instance-side service method is present. By default, the sessionCache of an AppeXSessionFilter is set by the application the filter is attached to. The method Application class &gt;&gt; #newSessionFilter is responsible for creating the filter and setting its sessionCache. If an Application class shares its sessionCache with others, the same instance of sessionCache will also be shared among the instances of AppeXSessionFilter. As a consequence, multiple responders may each have a unique AppeXSessionFilter but their sessionCache may all be shared.Alternatively, an AppeXSessionFilter can be set up in a configuration method using the #requestFilter:configuration: pragma.</body></comment><class><name>Application</name><environment>AppeX</environment><super>SiouX.HttpResponder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clientSubscriptions session eventStream </inst-vars><class-inst-vars>settings requestActions subscriptionRegistry codeComposer combinedJavascriptLibrary </class-inst-vars><imports>			private Tools.Pragma			private Xtreams.*			private SiouX.*			private Protocols.*			</imports><category></category><attributes><package>AppeX-Server</package></attributes></class><comment><class-id>AppeX.Application</class-id><body>Application is an abstract class to be subclassed to implement domain-specific web applications. Most of the web application framework is implemented here, with additional code in RequestContext, SessionCache and the Javascript client code in ApplicationClient.Instance Variables	clientSubscriptions	&lt;Set&gt;	set of event names that a client is interested in receiving. It is used to minimize the network traffic, so only events that a client has expressed interest in will be sent down the wire.	eventStream	&lt;EventStream | nil&gt;	for 'session instances', this will hold the EventStream used for sending event notifications to the client. 	session	&lt;Session | nil&gt;	when a 'session instance' of Application gets initialized, the corresponding session is held here. It's nil for 'responder instances'.Class Instance Variables	requestActions 	&lt;Dictionary&gt;	maps request paths to actions (pragmas) used by the dispatcher to generate content.	settings			&lt;Dictionary&gt;	holds the following application default settings: 						sessionCache &lt;SessionCache&gt; where all sessions for an application are managed						sessionTTL &lt;Duration&gt; new session are created with a Duration that determines 									the amount of time after which a session expires if no activity is detected 									by the server. Default value is 10 minutes.						documentRoot &lt;String&gt;	 path to the directory where static files are stored for 									the application. Default is local working directory.						eventStreamRetry &lt;Integer&gt;	number of milliseconds sent to an EventSource 									request in a retry: argument. Default value is 500.	subscriptionRegistry &lt;SubscriptionRegistry&gt; to support announcer API on the class side.	codeComposer &lt;JavascriptComposer&gt;  implements assembling javascript code	combinedJavascriptLibrary &lt;JavascriptLibrary&gt;	when not nil, the combinedJavascriptLibrary will contain all the classes									from all the other javascript libraries used in an application. No other AppeX javascript library code will be emitted.		Instance Method Tags	Request handler pragmas:		#html: #js: #plainText: #css: #json: #xml: #eventStream: #file:Class Method Tags	Request handler pragmas:		#html: #js: #plainText: #css: #json: #xml: #eventStream: #file:	HTML building pragmas:		#head: #body:	HTML token pragmas:		#htmlToken:ImplementationInstances of Application subclasses represent two possible uses:'Responder instances' are created for the purpose of letting a server dispatch an HTTP request to a responder based on the request's parameters. This behavior is inherited from HttpResponder.'Session instances' are created for the purpose of maintaining the state of a session as represented by a running JavascriptApplication inside a browser. In this case, instances of Application subclasses represent unique web application sessions, and are kept in each class 'sessionCache' class instance variable. The AppeX web application framework provides automatic session management, giving developers flexibility on how to write web request handling code.A declarative approach is used to implement request handler methods in Application subclasses. By declaring one of the predefined pragmas (see below), a method is registered as a request handler for a particular request identified by the path relative to the ApplicationResponder configured for the application (see ApplicationResponder class comments).Both class and instance methods can be used to write the request handlers. The choice depends on whether the request handler is session-specific or not. To implement session-neutral application behavior, developers should write only class methods. For session-specific request handlers that require access to state properties of a given web session, developers should write instance methods.When an Application subclass receives a dispatchRequest message from a Responder, it looks up an action corresponding to the reuqest path relative to the responder path. A Dictionary of requestActions is cached in 'requestActions' class instance variable. The requestActions initialization alogrithm finds all methods (instance &amp; class) that use one of the requestHandlerPragmas declared in Application class &gt;&gt; #requestHandlerPragmas method. The default pragmas are #html: #js: #plainText: #css: #json: #xml: #eventStream: and #file:.Each has a corresponding implementation method (e.g., #html:) and a response method (e.g., #respondWithHtml: ). An example may help to illustrate the dispatch mechanism:Say you have an Application subclass named MyApp*	Implement MyApp class &gt;&gt; #myRequestHandler as follows:		myRequestHandler			&lt;plainText: 'my-request'&gt;			^ 'My Response'	This will result in #myRequestHandler method tagged with a Pragma with #plainText: keyword and #myRequestHandler selector.*	The dispatch algorithm finds a Pragma with #plainText: keyword associated with 'my-request' key in the requestActions dictionary. The #plainText: method is invoked which will send a message #dispatchPragma:with: to itself with a block in the argument (see senders of #dispatchPragma:with:)*	The #dispatchPragma:with: method determines whether the receiver should be the class itself, or an instance. Handlers that are session-neutral must be implemented class methods. If the request handlers need to access session-specific data, they should be implemented as instance methods. In the example above, #myRequestHandler is a class method, hence the receiver will be MyApp class itself.*	The #dispatchPragma:with: evaluates the received block with the correct receiver in the block argument. The receiver then performs the pragma selector (#myRequestHandler).*	The result is passed on to the method #respondWithPlainText:, which set the current response contentType header and the content. The response is then returned to the responder and the server to send it back to the client.Usage*	Subclass to write your own application server implementation (e.g., MyApp).*	Implement #applicationClientClass class method to indicate which class holds the Javascript client code for your web application.*	Implement request handler methods tagged one of the request handler pragmas. For session-specific behavior, implement request handlers as instance methods. For session-neutral behavior, implement request handlers as class methods.*	Implement a pragma configuration method to create, configure and attach an ApplicationResponder to an instance of Server, for example:	MyApp class &gt;&gt; #myAppResponder	myAppResponder		&lt;server: 'some server name' path: 'my-app-path'&gt;*	Select the #myAppResponder method in the Refactoring Browser, right-click to bring up the menu, then click "Add 'my-app-path' to some server name server". This activates the responder, and the application is now ready to be tested from a web browser.*	Alternatively, click the 'Configure Web Servers' icon in the Launcher tool bar, select the server to which the responder should be attached, and and click 'Add...' in the responder list to activate the responder you have configured.</body></comment><class><name>ServerEvent</name><environment>AppeX</environment><super>AppeX.WebEvent</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Server</package></attributes></class><comment><class-id>AppeX.ServerEvent</class-id><body>ServerEvent represents events that occur in an ApplicationServer and need to be signalled to the client via an EventStream.ImplementationServerEvent is a subclass of WebEvent from which it inherits almost all its behavior.Usage*	A ServerEvent is created automatically by ApplicationServer when a ClientEvent is announced (see ApplicationServer class &gt;&gt; #announceClientEvent:).*	If you require your own server events, you simply announce them in a way similar to the following:	event := ServerEvent				sessionId: &lt;sessionId&gt;				eventName: &lt;aSymbol&gt;				data: &lt;anObject&gt;.	&lt;class or instance&gt; announceServerEvent: event.* Instances of ServerEvent can be written to an EventStream:	anEventStream put: (ServerEvent eventName: 'SomeEvent')*	Note that if you announce server events, in order for them to be sent to the client, you also need to register the interest in that event's name on the client, using the AppeX.ApplicationClient.onServerEvent() method function. Browse senders of #onServerEvent for examples.</body></comment><class><name>EventStreamResponse</name><environment>SiouX</environment><super>SiouX.HttpResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Server</package></attributes></class><comment><class-id>SiouX.EventStreamResponse</class-id><body>EventSourceResponse will be instantiated when 'text/event-stream' response is required.</body></comment><class><name>EventStream</name><environment>AppeX</environment><super>Xtreams.WriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lock connection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Server</package></attributes></class><comment><class-id>AppeX.EventStream</class-id><body>EventStream is a WriteStream used to write events to a response stream created for 'text/event-stream' content type according to Server-Sent Events (SSE) specification (http://www.w3.org/TR/2009/WD-eventsource-20091029/).Typically, an EventStream will be created by the AppeX framework when a request handler method with #eventStream: pragma is declared by the application. The method should then return a block with one argument, which will be the instance of EventStream on which events are written. A default eventStream is used to send event notifications to a client (see implementors of #getServerEvents), but applications may define their own.Instance variables:	lock &lt;RecursionLock&gt;	connection &lt;HttpConnection&gt;ImplementationEventStream API includes methods that correspond with the tokens to be written out to the response stream as per the SSE spec.They are	#eventName: (event: in the spec)	#eventId: (id: in the spec)	#comment: (: in the spec)	#retry:	#data:A higher-level API method #put: encapsulates the above methods in a single message with a ServerEvent in argument.Usage	EventStream can be used to write individual tokens, or whole events.	Example 1:	((EventStream on: ByteArray new writing)		retry: 5000;		eventName: 'MyServerEvent';		data: 'event data';		data: 'more event data';		postEvent;		terminal) asString	Example 2:	((EventStream on: ByteArray new writing)		put: (ServerEvent eventName: 'MyServerEvent' data: 'my data');		" Event stream ignores ServerEvent sessionId attribute: "		put: (ServerEvent sessionId: 'some-long-event-id-string-that-is-ignored' eventName: 'MyServerEvent' data: 'my data');		terminal) asString</body></comment><class><name>Theme</name><environment>AppeX</environment><super>AppeX.FileLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>styleSheetSelectors </inst-vars><class-inst-vars>styleSheetDefinitions </class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Server</package></attributes></class><comment><class-id>AppeX.Theme</class-id><body>Theme is an abstract style sheet library from which all style theme libraries should inherit their behavior.Subclasses must implement the following messages:	accessing		themeName</body></comment><class><name>NoCacheRequestFilter</name><environment>AppeX</environment><super>SiouX.RequestFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>services </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Server</package></attributes></class><comment><class-id>AppeX.NoCacheRequestFilter</class-id><body>NoCacheRequestFilter ensures that the specified services set HTTP response headers to no caching.</body></comment><shared-variable><name>RootDirectory</name><environment>AppeX.Application</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>AppeX-Server</package></attributes></shared-variable><shared-variable><name>ScriptDirectory</name><environment>AppeX.Application</environment><private>false</private><constant>false</constant><category>defaults</category><initializer></initializer><attributes><package>AppeX-Server</package></attributes></shared-variable><shared-variable><name>Registry</name><environment>AppeX.JavascriptLibrary</environment><private>false</private><constant>false</constant><category>registry</category><attributes><package>AppeX-Server</package></attributes></shared-variable><shared-variable><name>NextId</name><environment>AppeX.WebEvent</environment><private>false</private><constant>false</constant><category>event tracking</category><initializer>0</initializer><attributes><package>AppeX-Server</package></attributes></shared-variable><shared-variable><name>NextIdMutex</name><environment>AppeX.WebEvent</environment><private>false</private><constant>false</constant><category>event tracking</category><initializer>Semaphore forMutualExclusion</initializer><attributes><package>AppeX-Server</package></attributes></shared-variable><methods><class-id>AppeX.ApplicationSession</class-id> <category>accessing</category><body package="AppeX-Server">addApplication: anApplication	^ applications add: anApplication</body><body package="AppeX-Server">application"	This is a 'less prefered' method to access the application.	Use #applicationAt: instead."	^ self applicationFor: Application currentRequestContext responder</body><body package="AppeX-Server">applicationFor: responderOrClass	| class |	class := responderOrClass applicationClass.	^ applications		detect: [ :each | each class = class ]		ifNone: [ nil ]</body><body package="AppeX-Server">applications	^applications</body><body package="AppeX-Server">ensureApplicationFor: responderOrClass"	If I don't have an application for responderOrClass,	I have to create a new one and link it to myself."	(self applicationFor: responderOrClass) ifNil: [		responderOrClass applicationClass new linkSession: self.		].</body></methods><methods><class-id>AppeX.ApplicationSession</class-id> <category>initialize-release</category><body package="AppeX-Server">initialize	super initialize.	applications := Set new</body></methods><methods><class-id>AppeX.WebEvent</class-id> <category>accessing</category><body package="AppeX-Server">data	^data</body><body package="AppeX-Server">data: anObject	data := anObject</body><body package="AppeX-Server">eventId	^ eventId</body><body package="AppeX-Server">eventName	^eventName</body><body package="AppeX-Server">eventName: aSymbol	eventName := aSymbol asSymbol</body><body package="AppeX-Server">sessionId	^sessionId</body><body package="AppeX-Server">sessionId: anObject	sessionId := anObject</body></methods><methods><class-id>AppeX.WebEvent</class-id> <category>printing</category><body package="AppeX-Server">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	sessionId printOn: aStream.	aStream nextPutAll: ', '.	eventName printOn: aStream.	aStream nextPutAll: ', '.	eventId printOn: aStream.	aStream nextPutAll: ', '.	data printOn: aStream.	aStream nextPut: $) .</body></methods><methods><class-id>AppeX.WebEvent</class-id> <category>testing</category><body package="AppeX-Server">isClientEvent	^ false</body><body package="AppeX-Server">isServerEvent	^ false</body></methods><methods><class-id>AppeX.WebEvent</class-id> <category>initialize-release</category><body package="AppeX-Server">initialize	super initialize.	eventId := self class nextEventId</body></methods><methods><class-id>AppeX.WebEvent class</class-id> <category>instance creation</category><body package="AppeX-Server">eventName: eventName	^ self sessionId: nil eventName: eventName data: nil</body><body package="AppeX-Server">eventName: eventName data: data	^ self sessionId: nil eventName: eventName data: data</body><body package="AppeX-Server">new	^ super new initialize</body><body package="AppeX-Server">sessionId: sessionId eventName: eventName	^ self sessionId: sessionId eventName: eventName data: nil</body><body package="AppeX-Server">sessionId: sessionId eventName: eventName data: anObject	^ self new		sessionId: sessionId;		eventName: eventName;		data: anObject;		yourself</body></methods><methods><class-id>AppeX.WebEvent class</class-id> <category>event tracking</category><body package="AppeX-Server">nextEventId	^ NextIdMutex critical: [ NextId := NextId + 1]</body></methods><methods><class-id>AppeX.ClientEvent</class-id> <category>converting</category><body package="AppeX-Server">asServerEvent	^ ServerEvent sessionId: sessionId eventName: eventName data: data</body></methods><methods><class-id>AppeX.ClientEvent</class-id> <category>testing</category><body package="AppeX-Server">isClientEvent	^ true</body></methods><methods><class-id>AppeX.ETagRequestFilter</class-id> <category>accessing</category><body package="AppeX-Server">etags	^etags ifNil: [ etags := Dictionary new ]</body><body package="AppeX-Server">etags: anObject	etags := anObject</body><body package="AppeX-Server">patterns	^patterns ifNil: [ patterns := OrderedCollection new ]</body></methods><methods><class-id>AppeX.ETagRequestFilter</class-id> <category>initialize-release</category><body package="AppeX-Server">reset	etags := nil</body></methods><methods><class-id>AppeX.ETagRequestFilter</class-id> <category>services</category><body package="AppeX-Server">addPattern: patternString	self patterns add: patternString</body><body package="AppeX-Server">addToResponder: aResponder"The filter adds itself to the responder filter collection. Use this method to set your filter position"	aResponder class when: ResourcesChanged send: #reset to: self.	JavascriptCode when: ResourcesChanged send: #reset to: self.	FileLibrary when: ResourcesChanged send: #reset to: self.		^ super addToResponder: aResponder</body><body package="AppeX-Server">applyTo: aRequestContext	"	For GET or HEAD requests, check the cached request actions."	"Only GET and HEAD requests may use etag."	| relativePath request action  |	(#('GET' 'HEAD') includes: (request := aRequestContext request) method)		ifFalse: [^self].	aRequestContext appexAction ifNil: [^self].	relativePath := aRequestContext request decodedPath last.	(self patterns anySatisfy: [:each |		each key = aRequestContext appexAction keyword		and: [each value match: relativePath]])		ifFalse: [^self].	action := self etags at: relativePath				ifAbsent: 					[| etag |					etag := self class newEtag.					aRequestContext response header: 'etag' value: etag.					self etags at: relativePath put: etag -&gt; aRequestContext appexAction.					^self].	request headers: 'if-none-match'		do: 			[:header |			| etag |			etag := header body rest.			(action key = etag and: [action value == aRequestContext appexAction])				ifTrue: 					["Etag and actionPragma have not changed. Return a 'not-modified' response."					(aRequestContext response)						code: 304;						header: 'etag' value: etag;						signalReady]				ifFalse: 					["The actionPragma or the etag is no longer valid. Set the action key as the response's new etag."					aRequestContext response header: 'etag' value: action key].			^self].	" There was no etag present in the request. Set the action key as the response's new etag."	aRequestContext response header: 'etag' value: action key</body><body package="AppeX-Server">removeFromResponder: aResponder"The filter removes itself from the responder filter collection."	super removeFromResponder: aResponder.		aResponder class unsubscribe: self.	JavascriptCode unsubscribe: self.	FileLibrary unsubscribe: self</body></methods><methods><class-id>AppeX.ETagRequestFilter class</class-id> <category>accessing</category><body package="AppeX-Server">newEtag"	Answer a new random etag value.	(self newEtag)"	^ Security.DSSRandom autogeneratedSeed asHexString</body></methods><methods><class-id>AppeX.AppeXSessionFilter</class-id> <category>accessing</category><body package="AppeX-Server">linkSessionPath	^linkSessionPath ifNil: [ linkSessionPath := self class linkSessionPath]</body><body package="AppeX-Server">linkSessionPath: anObject	linkSessionPath := anObject</body></methods><methods><class-id>AppeX.AppeXSessionFilter</class-id> <category>notifications</category><body package="AppeX-Server">acceptSession: aSession for: aRequestContext	aRequestContext session: aSession</body><body package="AppeX-Server">noSessionFound: sessionId in: aRequestContext	^ aRequestContext responder class responseNotFound</body><body package="AppeX-Server">noSessionIdPresentIn: aRequestContext"	If no session id was present, the request is going to an application class.	No action required."	^ self</body></methods><methods><class-id>AppeX.AppeXSessionFilter</class-id> <category>testing</category><body package="AppeX-Server">isAppeXSessionFilter	^ true</body></methods><methods><class-id>AppeX.AppeXSessionFilter</class-id> <category>services</category><body package="AppeX-Server">applyTo: aRequestContext"Extract a session id and find or create a new session when a request path is #linkSessionPath"	| actionPragma |		aRequestContext request url tail  = self linkSessionPath ifTrue: [		^ self handleLinkSessionFor: aRequestContext responder ].	actionPragma := aRequestContext appexAction.	actionPragma ifNotNil: [		actionPragma methodClass isMeta ifTrue: [		" I don't care about using a session, the requested services is implemented on the class side."		^ self ]].		super applyTo: aRequestContext</body><body package="AppeX-Server">establishSessionFor: aResponder	| instance session |	instance := aResponder class newSession: self sessionClass.	session := instance session.	self sessionCache rememberSession: session.	^ session</body><body package="AppeX-Server">extractSessionIdFrom: aRequestContext"	Extract the sessionId from aSessionContext's requestData.	If not found, answer nil."	aRequestContext requestData at: aRequestContext responder sessionKey do: [ :sessionId | ^ sessionId].	^ nil</body><body package="AppeX-Server">handleLinkSessionFor: aResponder	| arguments session clientSessionKey clientSessionId data |	arguments := aResponder currentRequestArguments.	clientSessionKey := arguments at: #sessionKey ifAbsent: [aResponder sessionKey].	"If we don't have a sessionId, we have to establish a new session.	If a sessionId does not match an active session/instance, we also have to establish a new one."	session := (arguments at: clientSessionKey asSymbol ifAbsent: [nil])		ifNil: [self establishSessionFor: aResponder]		ifNotNil: [:sessionId |			clientSessionId := sessionId.			(self findSession: sessionId) ifNil: [self establishSessionFor: aResponder]].	session ensureApplicationFor: aResponder.	session touch.	data := self sessionData: session for: aResponder id: clientSessionId.	(aResponder respondWithJson: data) signalReady</body><body package="AppeX-Server">sessionData: aSession for: aResponder id: clientSessionId	"	Answer the sessionData for @aSession.	If it's nil, it is equivalent to a session with 'expired' status.	If @aSessionId is nil, it means @anApplicationServer status is 'new'.	"	| answer status application |	answer := Dictionary new.	status := aSession				ifNil: [#expired]				ifNotNil: 					[application := aSession applicationFor: aResponder.					aSession isExpired						ifTrue: [#expired]						ifFalse: [clientSessionId = aSession id ifTrue: [#active] ifFalse: [#new]]].	answer at: #status put: status.	application		ifNotNil: 			[answer				at: #sessionKey put: application sessionKey asString;				at: application sessionKey put: application sessionId;				yourself].	status = #expired		ifFalse: 			[answer at: #started put: application creationTime printString.			application sessionTTL				ifNotNil: [:ttl | answer at: #ttl put: ttl asSeconds printString].			application expirationTime				ifNotNil: [:time | answer at: #expires put: time printString]].	^answer</body></methods><methods><class-id>AppeX.AppeXSessionFilter</class-id> <category>defaults</category><body package="AppeX-Server">defaultSessionClass	^ ApplicationSession</body></methods><methods><class-id>AppeX.AppeXSessionFilter class</class-id> <category>defaults</category><body package="AppeX-Server">linkSessionPath	^linkSessionPath ifNil: [ linkSessionPath := self linkSessionPathDefault ]</body><body package="AppeX-Server">linkSessionPath: aString	linkSessionPath := aString</body><body package="AppeX-Server">linkSessionPathDefault	^ '_appex_linkSession'</body></methods><methods><class-id>AppeX.Application</class-id> <category>accessing</category><body package="AppeX-Server">applicationClass	^ self class applicationClass</body><body package="AppeX-Server">requestActions	^ self class requestActions</body><body package="AppeX-Server">role	^ session		ifNil: [ #responder ]		ifNotNil: [ #session ]</body></methods><methods><class-id>AppeX.Application</class-id> <category>session - services</category><body package="AppeX-Server">establishedWSConnection: wsConnection	self class establishedWSConnection: wsConnection</body><body package="AppeX-Server">executeRequestFor: aRequestContext	^ self class dispatchRequest: aRequestContext</body><body package="AppeX-Server">getServerEvents	"	This is the default event responding request handler.	Wait until a next event occurs. If there are events that have accumulated	since the last time this method has run, do not wait and return right away.	"	^ [ :anEventStream | self setEventStream: anEventStream ]</body><body package="AppeX-Server">receivedWSControlFrame: aMessage connection: wsConnection	self class receivedWSControlFrame: aMessage connection: wsConnection</body><body package="AppeX-Server">receivedWSDataOn: aStream connection: wsConnection message: aMessage	self class receivedWSDataOn: aStream connection: wsConnection message: aMessage</body></methods><methods><class-id>AppeX.Application</class-id> <category>session - accessing</category><body package="AppeX-Server">connection	^self class currentConnection</body><body package="AppeX-Server">creationTime	^ self session creationTime</body><body package="AppeX-Server">currentRequest	^self class currentRequest</body><body package="AppeX-Server">currentRequestArguments	^self class currentRequestArguments</body><body package="AppeX-Server">currentRequestContext	^self class currentRequestContext</body><body package="AppeX-Server">currentRequestData	^self class currentRequestData</body><body package="AppeX-Server">currentRequestPath	^self class currentRequestPath</body><body package="AppeX-Server">currentResponse	^self class currentResponse</body><body package="AppeX-Server">expirationTime	^ self sessionTTL ifNotNil: [ :ttl | self session lastUsed + ttl ]</body><body package="AppeX-Server">responder	^self class responder</body><body package="AppeX-Server">session	^ session</body><body package="AppeX-Server">sessionId	^session ifNotNil: [ session id ]</body><body package="AppeX-Server">sessionKey	"Return the sessionKey defined by my class."	^ self class sessionKey</body><body package="AppeX-Server">sessionTTL	"	Answer the 'time to live' duration. Default is to get it from the class.	Subclasses may override.	"	^ self class sessionTTL</body></methods><methods><class-id>AppeX.Application</class-id> <category>session - responding</category><body package="AppeX-Server">respondWithAuthenticate: anObject"	If no error occurred during authentication and we reached this point,	we assume that the session is authenticated.	By default, we will return a JSON representation of the authentication result.	Subclasses may override."	self session isAuthenticated: true.	^ self respondWithJson: anObject</body><body package="AppeX-Server">respondWithCss: aString	^self class respondWithCss: aString</body><body package="AppeX-Server">respondWithEventStream: aBlock	^self class respondWithEventStream: aBlock</body><body package="AppeX-Server">respondWithFile: aFilename	^self class respondWithFile: aFilename</body><body package="AppeX-Server">respondWithFileType: filenameExtension contents: filenameOrContents	^self class respondWithFileType: filenameExtension contents: filenameOrContents</body><body package="AppeX-Server">respondWithHtml: aString	^self class respondWithHtml: aString</body><body package="AppeX-Server">respondWithJavascript: anObject	^self class respondWithJavascript: anObject</body><body package="AppeX-Server">respondWithJson: anObject	^self class respondWithJson: anObject</body><body package="AppeX-Server">respondWithJsonStream: anObject	^self class respondWithJsonStream: anObject</body><body package="AppeX-Server">respondWithPlainText: aString	^self class respondWithPlainText: aString</body><body package="AppeX-Server">respondWithXml: aString	^self class respondWithXml: aString</body></methods><methods><class-id>AppeX.Application</class-id> <category>session - initialize-release</category><body package="AppeX-Server">ensureClientSubscriptions	clientSubscriptions := clientSubscriptions ifNil: [Set new]</body><body package="AppeX-Server">initializeSession: sessionClass	self ensureClientSubscriptions.	self linkSession: sessionClass newWithID.	^session</body><body package="AppeX-Server">linkSession: aSession	session := aSession		addApplication: self;		yourself</body></methods><methods><class-id>AppeX.Application</class-id> <category>session - events</category><body package="AppeX-Server">announceClientEvent: aClientEvent	"	I am announcing aClientEvent. Since I am the one announcing it, I will also process it.	Then I ask my class to announce it to propagate @aClientEvent to other sessions.	"	self ensureClientSubscriptions.	self processClientEvent: aClientEvent.	self class announceClientEvent: aClientEvent</body><body package="AppeX-Server">announceServerEvent: aServerEvent	self class announceServerEvent: aServerEvent</body><body package="AppeX-Server">postServerEvent: aServerEvent	"For client events that are originated in other sessions (instances of ApplicationServer),	put a corresponding ServerEvent to my eventStream.	How it works:	A number of other clients exist in other web sessions - each client C(x) is linked with a server S(x).	If client C(0) posts an event, it is received as a ClientEvent CE in server S(0).	Server S(0) asks its class to convert CE to a ServerEvent (SE) and let all its session instances	to post SE on their eventStream.	All the server instances S(x) receive a #postServerEvent: message (this method).	If a client C(x) subscribes to the eventName of SE, the name will be included in clientSubscriptions.	SE is put on the eventStream if it has not been reset because of a reconnect	or because the original connection has been closed.	"	(clientSubscriptions notNil		and: [(clientSubscriptions includes: aServerEvent eventName) 			or: ["In the case of Internet Explorer, the SessionReady event may 				be posted here before registerInterestInEvent has added it to clientSubscriptions.				(This was causing the web pages to not display when first visited in IE.)				Regardless of registered interest, the client should always be notified of SessionReady."				aServerEvent eventName = #SessionReady]])			ifTrue: 				[[eventStream ifNotNil: [eventStream put: aServerEvent]] on: Error					do: 						[:ex |						"Writing out aServerEvent would fail if the network connection is broken.				There is nothing we can do but stop writing subsequent events.				Reset eventStream to nil and let the framework do the rest."						eventStream := nil].				(aServerEvent eventName = #SessionExpired					and: [aServerEvent sessionId = self sessionId])						ifTrue: 							["This must be the last event I have sent back to the client."							eventStream								ifNotNil: 									[eventStream close.									eventStream := nil]]].	self announce: aServerEvent asServerEvent</body><body package="AppeX-Server">processClientEvent: aClientEvent"	aClientEvent has been received from a client. Process it here, but only if it belongs to my session."	aClientEvent sessionId = self sessionId ifFalse: [ ^ self ].		aClientEvent eventName = #registerInterestInEvent ifTrue: [		clientSubscriptions add: aClientEvent data asSymbol ].	aClientEvent eventName = #cancelInterestInEvent ifTrue: [		clientSubscriptions remove: aClientEvent data ifAbsent: [] ]</body></methods><methods><class-id>AppeX.Application</class-id> <category>session - private</category><body package="AppeX-Server">setEventStream: newEventStream"	Check if I already have an eventStream from a previous EventSource connection from the client.	If so, I have to close it before continuing.	Register interest in myself for newEventStream to signal a semaphore every time I announce a new ServerEvent.	Continue processing as long as the 'eventSource' instance variable holds an instance of EventSource	that is identical to newEventSource."	| semaphore |	eventStream ifNotNil: [ :oldEventStream |		"Set eventStream to nil to prevent writing of events to it from other processes, and immediately close it."		eventStream := nil.		[oldEventStream close]			on: Error			do: [:ex |				"Because of the long-lived nature of 'text/event-stream' types of responses,				errors may be the 'broken pipe' kind that we cannot do anything about anyway.				Ignore errors while closing oldEventStream" ]	].	semaphore := Semaphore new.	self		when: ServerEvent		send: #signal		to: semaphore.	[		newEventStream retry: self class eventStreamRetry.	"milliseconds"		"Now that newEventStream is ready, set eventStream to be the newEventStream."		eventStream := newEventStream.		self postServerEvent: (ServerEvent eventName: #SessionReady).		"		As long as eventStream is newEventStream, continue waiting on the semaphore.		If the connection drops or is closed, the client will try to reconnect.		Reconnection or an error writing to existing eventStream will set it to nil or another		instance of EventStream, indicating that I should stop processing and exit from the loop.		"		[			semaphore wait.			eventStream == newEventStream ] whileTrue	] ensure: [self unsubscribe: semaphore]</body></methods><methods><class-id>AppeX.Application</class-id> <category>testing</category><body package="AppeX-Server">isSessionRequired	^self class isSessionRequired</body></methods><methods><class-id>AppeX.Application</class-id> <category>services</category><body package="AppeX-Server">checkForSessionFilter	| required |	required := self isSessionRequired.	self requestFilters		detect: [:each | each isAppeXSessionFilter]		ifFound: [:filter | required ifFalse: [self requestFilters remove: filter]]		ifNone: 			[required ifTrue: [self requestFilters addFirst: self class sessionFilter]]</body><body package="AppeX-Server">setRequestIn: context from: aRequestLine	super setRequestIn: context from: aRequestLine.	self checkForSessionFilter.		context appexAction: (self class actionFor: context).</body></methods><methods><class-id>AppeX.Application</class-id> <category>printing</category><body package="AppeX-Server">printDetailOn: aStream	self role == #responder ifTrue: [ ^ super printDetailOn: aStream ].	self sessionId ifNotNil: [ :sessionId |		aStream			nextPut: $[;			nextPutAll: sessionId;			nextPut: $]		]</body></methods><methods><class-id>AppeX.Application</class-id> <category>notifications</category><body package="AppeX-Server">handleServerShutdown: anAnnouncement"If anAnnouncement has a duration for graceful shutdown, I will announce the server eventso that client can do whatever it is necessary to clean up."	(anAnnouncement duration notNil		and: [anAnnouncement duration isZero not]) ifTrue: [		self announceServerEvent: (ServerEvent 								sessionId: self sessionId 								eventName: #ServerShutdown 								data: anAnnouncement duration asSeconds )].	"If I am a session instance, I expire and reset my session and set my server to nil so that a proper cleanup can take place."	session ifNotNil: [		session expire.		session := nil ]</body><body package="AppeX-Server">subscribeToServerAnnouncements	super subscribeToServerAnnouncements.	server ifNotNil: [		server			when: ServerShutdownAnnouncement			do: [:announcement | self handleServerShutdown: announcement]			for: self.]</body></methods><methods><class-id>AppeX.Application</class-id> <category>initialize-release</category><body package="AppeX-Server">release"I am being released.Post a SessionExpired server event, and make sure my eventChanel and my session are set free."	session ifNotNil: [		self postServerEvent: (ServerEvent sessionId: self sessionId eventName: #SessionExpired).		session data: nil ].	eventStream ifNotNil: [ eventStream close ].	eventStream := session := clientSubscriptions := nil.	super release</body></methods><methods><class-id>AppeX.Application class</class-id> <category>html</category><body package="AppeX-Server">htmlBodyTemplate	"	Answer the default HTML body template. If an application doesn't require anything other than to run	the installation script, this method does not need to be overriden.	( self htmlBodyTemplate )	"	| body |	body := String new writing.	body		cr;		write: '&lt;body class="appex ';		write: self name;		write: '"&gt;'.	self writeHtmlParts: #body: on: body.	body		write: '&lt;/body&gt;';		cr.	^body contents</body><body package="AppeX-Server">htmlHeadTemplate	"Answer the default template for HTML &lt;head&gt; element.	( self htmlHeadTemplate )	"	| head |	head := String new writing.	head		cr;		write: '&lt;head&gt;'.	self writeHtmlParts: #head: on: head.	head		write: '&lt;/head&gt;';		cr.	^head contents</body><body package="AppeX-Server">htmlTemplate	"Answer a string that is used to build the html for the client. Subclasses may override to include any special	links in the header or startup scripts.	The templates would typically use the following template tokens:		{{languageCode}}		{{characterSet}}		{{baseURI}}		{{title}}		{{application}}.	See senders of #htmlToken:	"	^'&lt;!DOCTYPE html&gt;&lt;html lang="{{languageCode}}" {{manifestAttribute}}&gt;' , self htmlHeadTemplate, self htmlBodyTemplate , '&lt;/html&gt;'</body><body package="AppeX-Server">requiresCoreLibrary	"answer a boolean"	^ self applicationClientClass notNil</body></methods><methods><class-id>AppeX.Application class</class-id> <category>accessing</category><body package="AppeX-Server">applicationClass"	But I a AM the application classs! Answer self."	^ self</body><body package="AppeX-Server">applicationClientClass	"Answer the class that implements the client side behaviour complementing myself."	^self subclassResponsibility</body><body package="AppeX-Server">applicationLibraryClasses	self applicationLibrary isNil ifTrue: [^nil].	^self applicationLibrary classes</body><body package="AppeX-Server">codeComposer	"codeComposer := nil"	codeComposer ifNil: [ self codeComposer: JavascriptComposer ].	^codeComposer</body><body package="AppeX-Server">codeComposer: aJavascriptComposer	self = Application ifTrue: [		self allSubclassesDo: [:eApplicationClass | eApplicationClass codeComposer: aJavascriptComposer]	].	codeComposer := aJavascriptComposer</body><body package="AppeX-Server">combinedJavascriptLibrary: aJavascriptLibrary"	self combinedJavascriptLibrary: nil"	combinedJavascriptLibrary := aJavascriptLibrary</body><body package="AppeX-Server">currentConnection	^ self currentRequestContext ifNotNil: [ :context | context connection ]</body><body package="AppeX-Server">currentRequest	^ self currentRequestContext ifNotNil: [ :context | context request ]</body><body package="AppeX-Server">currentRequestArguments	^(self currentRequestData 		ifNotNil: [ :requestData |			requestData 				at: 'arguments'				do: 	[:jsonString | | stream |					stream := jsonString reading marshaling: JSON.					[stream get] ensure: [stream close]]]		) ifNil: [ Dictionary new ]</body><body package="AppeX-Server">currentRequestBaseUrl"	Answer the path that may be used as the baseUrl for all the resources required by this application.	It may not include queries or fragments, and it must end with a path delimiter character."	| stream contents |	self currentRequest ifNil: [ ^ '/'].	stream := String new writeStream.	self currentRequestUrl printEncodedPathOn: stream.		contents := stream contents.	^(contents at: contents size ) = $/		ifTrue: [contents]		ifFalse: [contents, '/']</body><body package="AppeX-Server">currentRequestContext	^ RequestContext current</body><body package="AppeX-Server">currentRequestData	^ self currentRequestContext requestData</body><body package="AppeX-Server">currentRequestDataAt: aString ifAbsent: aBlock	self currentRequestData at: aString do: [ :val | ^val].	^aBlock value</body><body package="AppeX-Server">currentRequestDeserializedFormData	| data |	data := Dictionary new.	self currentRequestArguments		do: [:each | data at: (each at: #name) asSymbol put: (each at: #value)].	^data</body><body package="AppeX-Server">currentRequestUrl	^ self currentRequestContext ifNotNil: [ :context | context request url ]</body><body package="AppeX-Server">currentResponse	^ self currentRequestContext ifNotNil: [ :context | context response ]</body><body package="AppeX-Server">documentRoot	^self settings at: #documentRoot ifAbsentPut: [ self defaultDocumentRoot ]</body><body package="AppeX-Server">documentRoot: pathString	self settings at: #documentRoot  put: pathString</body><body package="AppeX-Server">eventStreamRetry	^self settings at: #eventStreamRetry ifAbsentPut: [ self defaultEventStreamRetry ]</body><body package="AppeX-Server">eventStreamRetry: milliseconds	self settings at: #eventStreamRetry put: milliseconds</body><body package="AppeX-Server">htmlTokenMap	^self settings at: #htmlTokenMap ifAbsentPut: [self initializeHtmlTokenMap]</body><body package="AppeX-Server">requestActions	^ requestActions ifNil: [self initializeRequestActions].</body><body package="AppeX-Server">responder	^ self currentRequestContext ifNotNil: [ :context | context responder ]</body><body package="AppeX-Server">responderPath	^ self responder		ifNotNil: [ : responder | responder path ]		ifNil: [ '' ]</body><body package="AppeX-Server">rootDirectory	RootDirectory ifNil: [ RootDirectory := Server rootDirectory / self defaultRootDirectory ].	RootDirectory ensureDirectory.	^RootDirectory</body><body package="AppeX-Server">rootDirectory: aStringOrNilOrDirectory	RootDirectory := Server changeDirectory: self rootDirectory with: aStringOrNilOrDirectory</body><body package="AppeX-Server">rootDirectoryAsString	^self rootDirectory asString</body><body package="AppeX-Server">rootDirectoryAsString: aString	self rootDirectory: aString</body><body package="AppeX-Server">scriptDirectory	"ScriptDirectory := nil"		ScriptDirectory ifNil: [ScriptDirectory := self rootDirectory asAbsoluteFilename / self defaultScriptDirectory].	^ScriptDirectory</body><body package="AppeX-Server">scriptDirectory: aStringOrNilOrDirectory	aStringOrNilOrDirectory ifNil: [^nil].	(ScriptDirectory := aStringOrNilOrDirectory asFilename ) ensureDirectory.</body><body package="AppeX-Server">server	^ self responder ifNotNil: [ :responder | responder server ]</body><body package="AppeX-Server">setEventStreamResponse	^ self currentRequestContext		response: (EventStreamResponse code: 200);		response</body><body package="AppeX-Server">settings	^settings ifNil: [settings := Dictionary new ]</body><body package="AppeX-Server">theme	^ self settings at: #theme ifAbsentPut: [ self defaultTheme  ]</body><body package="AppeX-Server">theme: aThemeClass	self settings at: #theme put: aThemeClass</body></methods><methods><class-id>AppeX.Application class</class-id> <category>private</category><body package="AppeX-Server">dispatchPragma: aPragma with: aBlock	"Find the receiver from aPragma. It should be myself or a session-bound instance of myself,	depending on where aPragma's method is implemented (class or instance method).	If there is no suitable receiver, return with responseNotFound."	| methodClass |	methodClass := aPragma methodClass.	"If methodClass is in my metaclass superclass chain, I am the receiver."	(self class includesBehavior: methodClass) ifTrue: [^aBlock value: self].	"	If method class is in my superclass chain, a session-bound instance of self is the receiver.	By default, update the lastUsed attribute of the instance. If this should not be bypassed,	the request handler method should be implemented on the class side, and use 'self processRequestInSession: [&lt;some code&gt;]'	without the updateLastUsed bit.	"	(self includesBehavior: methodClass) ifTrue: [ 		^aBlock value: (self currentRequestContext session applicationFor: self)].	"I couldn't find a receiver, respond with 404 - Not Found"	^self responseNotFound</body><body package="AppeX-Server">expandHtmlTemplate: aString	"Take aString and expand it to resolve the tokens in it to their actual values.	Because HTML uses '&lt;' and '&gt;' characters, I cannot use the usual #expandMacrosWith: API.	Instead, I will use '{{'  and '}}' to mark the token boundaries (see https://github.com/janl/mustache.js).	We use a rather inefficient #copyReplaceAll:with: to build the resulting HTML.	However, this is not frequesntly used (only once per session?)"	| workingCopy |	workingCopy := aString.	self htmlTokenMap keysAndValuesDo: 			[:eachToken :eachBlock |			| token |			token := '{{' , eachToken , '}}'.			workingCopy := workingCopy copyReplaceAll: token with: eachBlock value].	^workingCopy</body><body package="AppeX-Server">extractLibraryContentFrom: anObject with: aBlock	"	Extract the library content from anObject. If it's a JavascriptLibrary, avaluate aBlock with anObject in argument.	"	anObject isString ifTrue: [ ^ anObject ].	(anObject isKindOf: FileLibrary) ifTrue: [ ^ aBlock cull: anObject ].	(anObject isKindOf: Collection) ifTrue: [		| stream |		stream := String new writing.		anObject do: [ :each |			(aBlock cull: each) ifNotNil: [:content | stream write: content ] ].		^ stream contents		].	^ anObject</body><body package="AppeX-Server">htmlParts: headOrBody	"	Answer a collection of Pragmas ordered by the value of the first argument.	@headOrBody is one of the #head: or #body: pragma names that are used to declare	parts of the corresponding html sections.	See the senders of #head: or body: to understand how it's done.	( self htmlParts: #head: )	( self htmlParts: #body: )	"	| pragmas class symbols stop |	class := self class.	stop := Application superclass class.	pragmas := OrderedCollection new.	symbols := Set new.	[ (Pragma allNamed: headOrBody in: class) do: [ :each |		(symbols includes: each selector) ifFalse: [			pragmas add: each.			symbols add: each selector ]].		class := class superclass.		class = stop ] whileFalse.			^ pragmas sorted: [:pragmaA :pragmaB |		(pragmaA arguments first) &lt;= (pragmaB arguments first)].</body><body package="AppeX-Server">osPath: aString	^ aString copy replaceAll: $/ with: Filename separator</body><body package="AppeX-Server">processRequestInSession: aBlock	^self findRequestedSession		ifNil: [self responseNotFound]		ifNotNil: aBlock</body><body package="AppeX-Server">requireSessionInstancesFor: aDictionary	aDictionary do: [ :each |		(each isKindOf: Dictionary)			ifTrue: [ (self requireSessionInstancesFor: each ) ifTrue: [ ^ true ] ]			ifFalse: [ (each methodClass includesBehavior: Application) ifTrue: [ ^ true ] ] ].	^ false</body><body package="AppeX-Server">writeHtmlPart: headOrBody from: eachPragma on: aStream	(self perform: eachPragma selector) ifNotNil:  [:part |		| reference content |		content := self extractLibraryContentFrom: part with: [ :library |			self ensureRequestActionForLibrary: library from: eachPragma methodDefinition ].		(content isNil or: [content isEmpty]) ifTrue: [ ^ self ].		reference := headOrBody , eachPragma arguments first printString.		aStream			cr;			write: '&lt;!-- BEGIN ';			write: reference;			write: ' - ';			write: eachPragma methodDefinition printString;			write: ' --&gt;'.		content first = Character cr ifFalse: [ aStream cr ].		aStream write: content.		content last = Character cr ifFalse: [ aStream cr ].		aStream			write: '&lt;!-- END ';			write: reference;			write: ' --&gt;';			cr]</body><body package="AppeX-Server">writeHtmlParts: headOrBody on: aStream	(self htmlParts: headOrBody) do: [:eachPragma |		self writeHtmlPart: headOrBody from: eachPragma on: aStream]</body></methods><methods><class-id>AppeX.Application class</class-id> <category>private-events</category><body package="AppeX-Server">doAnnounceServerEvent: aServerEvent	"	Announce @aServerEvent to all session instances.	If @aServerEvent has data and sessionId, and data doesn't yet have an element specifying the session key,	put the sessionKey in the data so that the client can now which session is @aServerEvent coming from."	aServerEvent data ifNotNil: [:data |		(data isKindOf: Dictionary) ifTrue: [			aServerEvent sessionId ifNotNil: [:sessionId |				data at: self sessionKey ifAbsentPut: [sessionId]				]			]		].	self sessionInstancesDo: [:each | each postServerEvent: aServerEvent].</body></methods><methods><class-id>AppeX.Application class</class-id> <category>dispatching - web socket</category><body package="AppeX-Server">establishedWSConnection: wsConnection</body><body package="AppeX-Server">receivedWSControlFrame: aMessage connection: wsConnection</body><body package="AppeX-Server">receivedWSDataOn: aStream connection: wsConnection message: aMessage</body></methods><methods><class-id>AppeX.Application class</class-id> <category>compiling</category><body package="AppeX-Server">classMethodsChanged	self resetAllMaps.	self announce: ResourcesChanged new</body><body package="AppeX-Server">instanceMethodsChanged	self		resetAllMaps;		resetIsSessionRequired.		self announce: ResourcesChanged new</body><body package="AppeX-Server">requiredRecognizedPragmas	"AR 75137:  I call #serviceTypePragmas, which has pragmas and so calls me when being compiled.  During loading from Store, I may be compiled first, #serviceTypePragmas second  The guard clause prevents me from calling #serviceTypePragmas  while it is being compiled."	(self class includesSelector: #serviceTypePragmas) ifFalse:		[^super requiredRecognizedPragmas].	^super requiredRecognizedPragmas, self serviceTypePragmas</body></methods><methods><class-id>AppeX.Application class</class-id> <category>responding</category><body package="AppeX-Server">respondWithCss: anObject"text/css Optional parameters: charset. http://www.ietf.org/rfc/rfc2318.txt The syntax of CSS is expressed in US-ASCII, but a CSS file can contain strings which may use any Unicode character. Any charset that is a superset of US-ASCII may be used; US-ASCII, iso-8859-X and utf-8 are recommended."	| contents |		contents := self extractLibraryContentFrom: anObject with: [ :library | library css ].	^(self currentResponse)		contentType: 'text/css' charset: 'utf-8';		contents: contents;		yourself</body><body package="AppeX-Server">respondWithEventStream: aBlock	"The request should be coming from an HTML5 EventSource object. It expects data in a specific format.	Content-type must be 'text/event-stream'.	Cache-control must be 'no-cache'.	The response must be in the form	The best way to handle the request is to set the response contents to be a stream starting with the 'data: token,	followed by what the application wants to write on the stream, followed by an empty line.text/event-stream   The charset parameter may be provided. The parameter's value must be utf-8. This parameter serves no purpose; it is only allowed for compatibility with legacy servers.	"	| connection |	connection := self currentRequestContext connection.		^(self setEventStreamResponse)		contents: [:responseStream |			| eventStream |			eventStream := (EventStream on: responseStream) connection: connection.			aBlock value: eventStream.			[ eventStream close ] on: Error do: [ :ex |				"Ignore errors while closing the eventStream. Typically, this would only occur if we cannot				write to the connection socket because of a broken pipe (connection closed by client).				There is nothing we can do, let's just get out of here. " ]];		yourself</body><body package="AppeX-Server">respondWithFile: aFilename	"Respond with the contents of a file specified by aFilename.	The file must be found at a path relative to my documentRoot, in a subdirectory given by the current responder's path.	Example:		documentRoot = '/docroot'		responder path = '/examples/myapp'		aFilename = Filename named: 'somepath/someFile.txt'	I will respond with the contents of '/docroot/examples/myapp/somePath/someFile.txt'.	"	| fullPathFilename |	fullPathFilename := aFilename isAbsolute		ifTrue: [ aFilename ]		ifFalse: [			self documentRoot asFilename / (self osPath: self responderPath) / aFilename ].	fullPathFilename exists ifFalse: [ ^ self responseNotFound ].	^self respondWithFileType: aFilename extension contents: fullPathFilename</body><body package="AppeX-Server">respondWithFileType: filenameExtension contents: filenameOrContents	|  response contentType |	response := self currentResponse.	contentType := response class  guessFromExtension: filenameExtension.	('text/*' match: contentType)		ifTrue: [ response contentType: contentType charset: 'utf-8']		ifFalse: [ response contentType: contentType ].	^ response		contents: filenameOrContents;		yourself</body><body package="AppeX-Server">respondWithHtml: aString	^(self currentResponse)		contentType: 'text/html' charset: 'utf-8';		contents: aString;		yourself</body><body package="AppeX-Server">respondWithJavascript: javascript"application/javascript Optional parameters: charset  http://www.rfc-editor.org/rfc/rfc4329.txt  4.1 The charset parameter provides a means to specify the character encoding scheme of binary source text.  Its value MUST match the mime-charset production defined in [RFC2978], section 2.3, and SHOULD be a registered charset [CHARSETS]."	| contents requestedLibrary requestPath |	requestPath := self currentRequestUrl tail.	requestedLibrary := javascript isString		ifTrue: [ javascript]		ifFalse: [			"javascript can be a single library or a collection of libraries."			(javascript isKindOf: Collection)				ifTrue: [					"Find the library matching the request path."					javascript detect: [:each | 						(each htmlPartName: self codeComposer) = requestPath ] ifNone: [ ^ self responseNotFound ] ]				ifFalse: [					javascript ] ].	contents := self extractLibraryContentFrom: requestedLibrary with: [ :library | library code: self codeComposer ].	^(self currentResponse)		contentType: 'application/javascript' charset: 'utf-8';		contents: contents;		yourself</body><body package="AppeX-Server">respondWithJson: anObject	"application/json  Optional parameters: n/a.  The default encoding is UTF-8.  When JSON is written in UTF-8, JSON is 8bit compatible.  When JSON is written in UTF-16 or UTF-32, the binary content-transfer-encoding must be used."	| contents |	contents := ((ByteArray new writing encoding: #'utf-8') marshaling: JSON) put: anObject; close; terminal.	^(self currentResponse)		contentType: 'application/json';		contents: contents;		yourself</body><body package="AppeX-Server">respondWithJsonStream: anObject	"application/json  Optional parameters: n/a.  The default encoding is UTF-8.  When JSON is written in UTF-8, JSON is 8bit compatible.  When JSON is written in UTF-16 or UTF-32, the binary content-transfer-encoding must be used.The Http response body encoding will be done directly on a socket stream. If any marshaling errors happens while writing a body on a socket stream the connection will be closed immediately and a client may complain about wrong chunked format. Turn on debug option on the server to detect the error."	| contents |		contents := anObject				ifNotNil: [ [:socketStream | (((socketStream closing: []) encoding: #'utf-8') marshaling: JSON) put: anObject; close ] ] 				ifNil: ['null'].	^(self currentResponse)		contentType: 'application/json';		contents: contents;		yourself</body><body package="AppeX-Server">respondWithPlainText: anObject	^self currentResponse		contentType: 'text/plain' charset: 'utf-8';		contents: anObject;		yourself</body><body package="AppeX-Server">respondWithXml: aString	^(self currentResponse)		contentType: 'text/xml' charset: 'utf-8';		contents: aString;		yourself</body><body package="AppeX-Server">responseForbidden	^(self currentResponse)		code: 403;		yourself</body><body package="AppeX-Server">responseNotFound	^(self currentResponse)		code: 404;		yourself</body></methods><methods><class-id>AppeX.Application class</class-id> <category>initialize-release</category><body package="AppeX-Server">ensureRequestActionForLibrary: aLibrary from: aMethodDefinition"	If I am using a combined JavascriptLibrary but aLibrary is not the combined one, I must add all my classes to it and return.	If aLibrary IS the combined one, follow the regular logic for aLibrary in the absence of combined one."	| pragmaSelector |	"if serving files combined, or if there is no applicationLibrary, then combinedJavascriptLibrary will return nil and we will exit with nil"	(aLibrary combineClassesInto: self combinedJavascriptLibrary) ifTrue: [ ^ nil ].		pragmaSelector := aLibrary pragmaSelector.	(aLibrary resourcePaths: self codeComposer) do: [ :eachPath |		| pragma |		pragma := Pragma new				message: (Message selector: pragmaSelector arguments: (Array with: eachPath))				methodDefinition: aMethodDefinition.		self installRequestActionForPragma: pragma ].	^ aLibrary htmlPart: self codeComposer</body><body package="AppeX-Server">initializeHtmlTokenMap"	AppeX.Application withAllSubclasses do: [ :each | each -&gt; each initializeHtmlTokenMap ]"	^(Pragma		allNamed: #htmlToken:		from: self class		to: Application class) inject: Dictionary new			into: [:map :pragma |				map at: (pragma argumentAt: 1) ifAbsentPut: [[self perform: pragma selector ]].				map]</body><body package="AppeX-Server">initializeRequestActions"	AppeX.Application withAllSubclasses do: [ :each | each initializeRequestActions ].	AppeX.Application initializeRequestActions."	requestActions := Dictionary new.	self serviceTypePragmas do: 			[:keyword |			self				initializeRequestActions: keyword				from: self class				to: Application class.			self initializeRequestActions: keyword from: self to: Application].	^ requestActions</body><body package="AppeX-Server">initializeRequestActions: keyword from: aClass to: aSuperclass	"	Initialize request actions from all pragmas named @keyword through through the class hierarchy	chain between @aClass and @aSuperclass.	( ApplicationServer classMethodsChanged )	"	(Pragma allNamed: keyword from: aClass to: aSuperclass) do: [:pragma | self installRequestActionForPragma: pragma]</body><body package="AppeX-Server">installRequestActionForPragma: pragma	| tokens current requestMethodTags serviceMethodPragma leaf |	current := self requestActions.	tokens := pragma arguments first tokensBasedOn: $/.	requestMethodTags := Set new.	(Pragma allInMethod: pragma method) do: [ :each |		(self requestMethodPragmas includes: each keyword) ifTrue: [ requestMethodTags add: each keyword ]].	serviceMethodPragma := (Pragma allNamed: #serviceType: from: self class to: Application class)		detect: [ :each | each selector = pragma keyword ]		ifNone: [ nil ].	requestMethodTags isEmpty ifTrue: [serviceMethodPragma ifNotNil: [:p | requestMethodTags add: p arguments first ]].	1 to: tokens size - 1		do: 			[:i |			| token |			token := tokens at: i.			current := current at: token ifAbsentPut: [Dictionary new]].	"Put the found pragma into current only if none is there already.		Since we traverse up the superclass chain, this allows to 'override' a pragma		defined in a superclass. "	leaf := tokens last.	requestMethodTags isEmpty		ifTrue: [ current at: leaf ifAbsentPut: [pragma]]		ifFalse: [ requestMethodTags do: [ :tag | current at: (leaf, ' ', tag) trimBlanks ifAbsentPut: [pragma] ]]</body><body package="AppeX-Server">obsolete	self resetSessionFilter.	self resetMaps.	self resetSettings.	self resetSubscriptionRegistry.	super obsolete</body><body package="AppeX-Server">resetAllMaps"	self resetAllMaps"	Application withAllSubclasses do: [:eachClass | eachClass resetMaps ]</body><body package="AppeX-Server">resetIsSessionRequired"	Reset the #isSessionRequired setting."	self settings removeKey: #isSessionRequired ifAbsent: [ nil ]</body><body package="AppeX-Server">resetMaps"	Reset my requestActions and htmlTokenMap so they can be lazy initialized again."	self settings removeKey: #htmlTokenMap ifAbsent: [].	requestActions := nil</body><body package="AppeX-Server">resetSettings	settings := nil</body><body package="AppeX-Server">resetSubscriptionRegistry	subscriptionRegistry release.	subscriptionRegistry := nil.</body></methods><methods><class-id>AppeX.Application class</class-id> <category>dispatching</category><body package="AppeX-Server">actionFor: aRequestContext	"	Return an action pragma or nil if not found.	"	| action path method |	action := self requestActions.	"Getting of currentRequestPathTokens could be further refactored to get from aRequestContext."	path := aRequestContext appexActionPath.	"Cache current request method so we don't have to get it in each iteration."	method := aRequestContext request method.	path isEmpty		ifTrue: [action := action at: method ifAbsent: [^ nil ]]		ifFalse: 			[			[| token firstLook secondLook |			token := path removeFirst.			path isEmpty				ifTrue: [					"If I have consumed the path already, I definitely want to see if path/method is there, indicating a Pragma in the action dictionary."					firstLook := token, ' ', method.					secondLook := token ]				ifFalse: [					"Otherwise, it's possible that we'll be drilling into a sub-path, and we want to check the path alone."					firstLook := token.					secondLook := token, ' ', method ].			action := action at: firstLook ifAbsent: [ action at: secondLook ifAbsent: [^nil] ].			action class == Pragma or: [path isEmpty]			] whileFalse].		^ action</body><body package="AppeX-Server">dispatchRequest: aRequestContext	"	Dispatch the request stored in the current RequestContext stored in the Process environment.	Find which of my requestActions should handle the request, and perform that action.	If none is found, returrn with a 'not found' response.	"	^ aRequestContext appexAction		ifNil: [ self responseNotFound ]		ifNotNil: [ :action |			| arguments |			arguments := (Array with: action), (action arguments allButFirst: 1).			self perform: action keyword withArguments: arguments ]</body></methods><methods><class-id>AppeX.Application class</class-id> <category>announcements</category><body package="AppeX-Server">subscriptionRegistry: aSubscriptionRegistry	subscriptionRegistry := aSubscriptionRegistry</body><body package="AppeX-Server">subscriptionRegistryOrNil	^subscriptionRegistry</body></methods><methods><class-id>AppeX.Application class</class-id> <category>defaults</category><body package="AppeX-Server">defaultDocumentRoot	^ Filename findDefaultDirectory</body><body package="AppeX-Server">defaultEventStreamRetry	"Answer the default number of milliseconds sent to an EventSource request in a retry: argument."	^ 500</body><body package="AppeX-Server">defaultRootDirectory	^'appex'</body><body package="AppeX-Server">defaultScriptDirectory	^'scripts'</body><body package="AppeX-Server">defaultSessionTTL	^10 minutes</body></methods><methods><class-id>AppeX.Application class</class-id> <category>session management</category><body package="AppeX-Server">findRequestedSession	^self findSession: self requestedSessionId</body><body package="AppeX-Server">findSession: sessionId	^ self sessionCache findSession: sessionId</body><body package="AppeX-Server">initializeSessionFilter	| sessionFilter cache |		sessionFilter := self sessionFilterClass new.	(cache := sessionFilter sessionCache) when: SessionReleased do: [ :ann | self sessionReleased: ann session ].	cache sessionTTL: self sessionTTL.	^ sessionFilter</body><body package="AppeX-Server">newSession: sessionClass	^ self new		initializeSession: sessionClass;		server: self server;		yourself</body><body package="AppeX-Server">requestedSessionId	^self sessionKey ifNotNil: [ :sessionKey |		self currentRequestDataAt: sessionKey asString ifAbsent: [ nil ] ].</body><body package="AppeX-Server">resetSessionFilter	"Reset my session filter.	Evaluate:		self resetSessionFilter	-- OR --		Application withAllSubclasses do: [ :each | each resetSessionFilter ]	"	self settings at: #sessionFilter ifPresent: [ :filter | self settings removeKey: #sessionFilter ]</body><body package="AppeX-Server">sessionCache	^self sessionFilter sessionCache</body><body package="AppeX-Server">sessionFilter	^self settings at: #sessionFilter ifAbsentPut: [self initializeSessionFilter]</body><body package="AppeX-Server">sessionFilter: aSessionFilter	^ aSessionFilter		ifNotNil: [ self settings at: #sessionFilter put: aSessionFilter ]		ifNil: [ self settings removeKey: #sessionFilter ifAbsent: [] ]</body><body package="AppeX-Server">sessionFilterClass	^AppeXSessionFilter</body><body package="AppeX-Server">sessionInstancesDo: aBlock	^ self sessionsDo: [ :session |		(session applicationFor: self) ifNotNil: [ :instance | aBlock value: instance ] ]</body><body package="AppeX-Server">sessionKey	"	Answer the key used to get a session id.	Default key is #sessionId. It will be included in each request url query	packaged by an ApplicationClient (e.g., /some-request?sessionId='xxxx').	If a subclass wants to use a different key to identify sessions, it may override this method.	"	^ 'sessionId'</body><body package="AppeX-Server">sessionOptions	^ Dictionary new		at: #sessionKey put: self sessionKey;		yourself</body><body package="AppeX-Server">sessionReleased: aSession	"When aSession is released from SessionCache, I check if its data is of myself.	In that case, I want to release the instance as well. "	(aSession applicationFor: self) ifNotNil: [ :application |  application release ]</body><body package="AppeX-Server">sessionTTL	"Answer the session 'time to live' duration. If none is set, use the default value."	^self settings at: #sessionTTL ifAbsentPut: [ self defaultSessionTTL]</body><body package="AppeX-Server">sessionTTL: aDuration	"	Example:		self sessionTTL: 10 minutes	"	self sessionTTL = aDuration ifTrue: [ ^ self ].	self settings at: #sessionTTL put: aDuration.	(self settings at: #sessionCache ifAbsent: [nil]) ifNotNil: [ :cache | cache sessionTTL: self sessionTTL ]</body><body package="AppeX-Server">sessionsDo: aBlock	^ self sessionCache do: aBlock</body><body package="AppeX-Server">sessionsSelect: aBlock	^ self sessionCache select: aBlock</body><body package="AppeX-Server">shareSessionCacheWith: aClassOrCollection	| classes |	classes := aClassOrCollection isSequenceable		ifTrue: [aClassOrCollection]		ifFalse: [Array with: aClassOrCollection].			classes do: [ :eachClass | eachClass sessionFilter: self sessionFilter ]</body></methods><methods><class-id>AppeX.Application class</class-id> <category>class initialization</category><body package="AppeX-Server">clearCombinedLibraries	self withAllSubclasses do: [:eClass | eClass combinedJavascriptLibrary: nil]</body><body package="AppeX-Server">initialize"	Ensure Locale is properly hooked up to avoid meaningless values of 'lang' attribute in the HTML document."	codeComposer := JavascriptComposer.	Locale initialHookup</body></methods><methods><class-id>AppeX.Application class</class-id> <category>services</category><body package="AppeX-Server">faviconIcoBytes"	The base64 encoded contents of Cincom Smalltalk 'favicon.ico' file, downloaded from http://www.cincomsmalltalk.com/	| file contents |	filename := 'Molecule.ico' asFilename.	contents := filename contentsOfEntireBinaryFile.	contents asBase64String"	^ ByteArray fromBase64String: 'AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAGEPAABhDwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAs4gvKriPRce7lFLjtIk3eqtlL0CrYDAmAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALeNP7XUuJn/4cu5/8KeZf+vdy1ArmYvBQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC8llK96tjK/+3f1f/Dn2n/tIgsNwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALKHLBayiC4CAAAAALOHKw2mgzw6rZ+Grs+ueOjVtor8vaFv+4+EbzoAAAAAAAAAAAAAAAAAAAAAtYksG7aNPri7k1Hsto5CxbOJMSu+mVe9zK6F/8GlcX2xhy0Ys4QiLdzSvV6Vlp3RY2JijWRiYVMAAAAAAAAAALaKNKfIpnv/2cCn/8ysh/+2jUDEz7CA4+TRv/+1iTZ8AAAAAAAAAAB6eHYkhIGB/aShn/+EgYD/f31+pJCNi7a8m2b/4Mmx//Pp4v/awan/upNQ8bWLNzS6kkRutYovDQAAAAAAAAAAXl1dTa6qqf/V0tH/lZOS/46If6fS0MxYxKVswOLLsv/r3ND/17yf/7ePRMsAAAAAAAAAAAAAAAAAAAAAAAAAAG5ucy+Wk5H/tLS2/5OQkP+ujlnGvZtUDrOKNR/Bm1fDzq599MSgYc+ziTIyAAAAAAAAAAAAAAAAs4cqJqmEODign6KwmJujVHtqSW/Wwan/3sWp/7CEKkwAAAAAsIYqArCEKR6vhCoHAAAAAAAAAAAAAAAAs4kzab6YXPbAmmH/wKFoyQAAAAAAAAAAxZ5Vj8CbWJmxhy4OAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsYcsBryWU+Tgyrf/5dHC/76WV/qyhCQjAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALCFKQTEn2DT69vO/+bUxf++mFr4soYsGgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAs4kyPcShYtDIpWzctow4XwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//9RBP//VATn/wAAw/8AAMP////D8f//POD//zwA///8IP///DH///s////jP///w////8P////n/////////w=='</body></methods><methods><class-id>AppeX.Application class</class-id> <category>testing</category><body package="AppeX-Server">isSessionRequired	"	Answer a Boolean indicating whether I require the creation of instances to fullfill requests specified in my requestActions.	If any of the requestActions contains a Pragma whose methodClass is Application or a subclass (not a metaclass),	that indicates I will need session instances.	"	^ self settings		at: #isSessionRequired		ifAbsentPut: [ self requireSessionInstancesFor: self requestActions ]</body></methods><methods><class-id>AppeX.Application class</class-id> <category>events</category><body package="AppeX-Server">announceClientEvent: aClientEvent	"Convert @aClientEvent to a ServerEvent instance.	Announce it to all sessions."	self announceServerEvent: aClientEvent asServerEvent.</body><body package="AppeX-Server">announceServerEvent: aServerEvent	"	Announce @aServerEvent to all session instances.	If @aServerEvent has data and sessionId, and data doesn't yet have an element specifying the session key,	put the sessionKey in the data so that the client can now which session is @aServerEvent coming from."	self doAnnounceServerEvent: aServerEvent.	self announce: aServerEvent</body></methods><methods><class-id>AppeX.Application class</class-id> <category>css</category><body package="AppeX-Server">defaultTheme	"Return the defaultTheme. Normally, a defaultTheme is undefined, but if an application needs one, it should override this message. "	^ nil</body></methods><methods><class-id>AppeX.Application class</class-id> <category>deprecation</category><body package="AppeX-Server">actions: actions do: aBlock"	Examples:			self			actions: self requestActions			do: [ :key :pragma | key -&gt; pragma ]		self			actions: self requestActions			do: [ :key :pragma | Transcript cr; nextPutAll: key; tab; nextPutAll: (pragma keyword, pragma arguments first) ]		self			actions: GenealogyApplication requestActions			do: [ :key :pragma | (pragma keyword = #activeRecord:class: ) ifTrue: [^ Transcript cr; nextPutAll: ('Found ', key, ' ', pragma keyword, ' ', pragma arguments printString)] ]"		(actions class == Dictionary) ifTrue: [ ^ self actions: '/' -&gt; actions do: aBlock ].	(actions value class == Pragma) ifTrue: [ ^ aBlock cull: actions key cull: actions value ].	^ actions value associations collect: [ :each | self actions: each do: aBlock ].</body><body package="AppeX-Server">currentRequestPath	|  path |	path := '/'.	self currentRequest ifNotNil: [:request | path := request decodedPath ].	path isEmpty ifFalse: [ 		path first = $/ ifFalse: [ path := '/', path]].	^path</body><body package="AppeX-Server">currentRequestPathTokens	"Answer the current request path relative to the responder path."	^ (self currentRequestServicePath tokensBasedOn: $/) reject: [ :each | each isEmpty ]</body><body package="AppeX-Server">currentRequestServicePath	"Answer the current request path relative to the responder path without query or fragment."	| requestPath |	requestPath := self currentRequestPath allButFirst: self responderPath size.	requestPath := requestPath copyUpTo: $?.	^ requestPath copyUpTo: $#</body></methods><methods><class-id>AppeX.ServerEvent</class-id> <category>testing</category><body package="AppeX-Server">asServerEvent	^ self</body><body package="AppeX-Server">isServerEvent	^ true</body></methods><methods><class-id>SiouX.EventStreamResponse</class-id> <category>private-writing</category><body package="AppeX-Server">writeOn: aStream	| headerStream |	[		headerStream := self writeHeadersOn: aStream.		headerStream cr; close.		body value: aStream.		aStream close	] on: Error do: [ :ex |		"There is nothing we can do. The pipe is broken."		ex return ].	"We only use the resulting number for logging.	Since EventStream is a long-lived connection and the number is not relevant, we return zero."	^ 0</body></methods><methods><class-id>SiouX.EventStreamResponse</class-id> <category>initialize-release</category><body package="AppeX-Server">initialize	super initialize.	self		contentType: 'text/event-stream';		cacheControl: 'no-cache'</body></methods><methods><class-id>AppeX.EventStream</class-id> <category>API</category><body package="AppeX-Server">comment: aString"	If @aString is multi-line, split it into lines. Write out a ':' followed by each line."	| lines |	lines := (aString tokensBasedOn: Character cr) collect: [ :each | each trimBlanks ].	lines do: [ :each |		self			write: ': ';			write: each;			write: Character cr ]</body><body package="AppeX-Server">data: anObject	| data |	data := anObject ifNil: [ Dictionary new ].	self		write: 'data: ';		write: data asJsonString;		write: Character cr</body><body package="AppeX-Server">eventId: anObject	| eventId |	eventId := anObject isString		ifTrue: [ anObject ]		ifFalse: [ anObject asJsonString ].		self		write: 'id: ';		write: eventId;		write: Character cr</body><body package="AppeX-Server">eventName: eventName	self		write: 'event: ';		write: eventName;		write: Character cr</body><body package="AppeX-Server">postEvent	self write: Character cr.		connection ifNotNil: [ :conn | conn protocolVersion flushEventStream: self ]</body><body package="AppeX-Server">retry: milliseconds	"Write a 'retry:' value to the underlying stream."	self		write: 'retry: ';		write: milliseconds asJsonString;		write: Character cr</body></methods><methods><class-id>AppeX.EventStream</class-id> <category>accessing</category><body package="AppeX-Server">connection	^connection</body><body package="AppeX-Server">connection: anHttpConnection	connection := anHttpConnection.		"See #setNoDependencies comments."	self setNoDependencies.</body><body package="AppeX-Server">put: aServerEvent	^ self critical: [ super put: aServerEvent ]</body><body package="AppeX-Server">write: anInteger from: aSequenceableCollection at: startIndex	startIndex to: startIndex + anInteger - 1 do: [:index |		| object |		object := aSequenceableCollection at: index.		(object isKindOf: ServerEvent)			ifTrue: [				self					eventName: object eventName;					eventId: object eventId printString;					data: object data;					postEvent.				"uncomment to invoke onmessage on client EventSource identifying the previous event sent."				"self data:object eventName;					postEvent"]			ifFalse: [ destination write: 1 from: aSequenceableCollection at: index] ].	^anInteger</body></methods><methods><class-id>AppeX.EventStream</class-id> <category>initialize-release</category><body package="AppeX-Server">close	connection		ifNil: [ super close ]		ifNotNil: [ connection close. connection := nil ].</body><body package="AppeX-Server">contentsSpecies	^Array</body><body package="AppeX-Server">on: aStream	lock := RecursionLock new.	^ super on: (aStream encoding: #'utf-8') setLineEndTransparent; yourself</body></methods><methods><class-id>AppeX.EventStream</class-id> <category>private</category><body package="AppeX-Server">critical: aBlock	^ lock critical: aBlock</body><body package="AppeX-Server">setNoDependencies	"It is a hack for some web browsers (e.g.: Google Chrome), that create an event stream and set Http2 streams dependent on the event stream. The event stream is long lived and will block its dependents forever. "	connection protocolVersion isHTTPv20 ifTrue: [self http2DataStream setNoDependencies ]</body></methods><methods><class-id>AppeX.Theme</class-id> <category>accessing</category><body package="AppeX-Server">css"	Answer the CSS defined by all my styleSheetSelectors"	| css openComment closeComment commentLine |	css := String new writing.	openComment := '/*'.	closeComment := '*/'.	commentLine := '*******************************************'.	css		write: openComment;		write: commentLine;		cr;		write: 'AppeX Theme: ';		write: self class fullName;		cr;		write: commentLine;		write: closeComment;		cr.	self styleSheetDefinitions do: [ :eachPragma |		css			cr;			write: openComment;			write: commentLine;			cr;			write: eachPragma methodClass fullName;			write: '&gt;&gt;';			write: eachPragma selector;			cr;			write: commentLine;			write: closeComment;			cr;			write: (self perform: eachPragma selector);			cr].		^ css contents</body><body package="AppeX-Server">htmlPart: aCodeHandler"	Answer my HTML code.	(DefaultScaffoldingTheme new htmlPart)"	^ '&lt;link id="appex-theme-css" rel="stylesheet" href="', (self themePath: aCodeHandler), '"&gt;'</body><body package="AppeX-Server">pragmaSelector"	Answer a symbol that is used as a Pragma selector when installing request action for my components.	Subclass responsibility."	^ #css:</body><body package="AppeX-Server">resourcePaths: aCodeHandler"	Answer a collection of strings that represent all my style sheet paths.	(DefaultScaffoldingTheme new resourcePaths)"	^ Array with: (self themePath: aCodeHandler)</body><body package="AppeX-Server">styleSheetDefinitions"	Answer an Array of selectors that determine the order and content of stylesheets to be generated for this theme.	Subclasses may override."	^ self class styleSheetDefinitions</body><body package="AppeX-Server">themePath: aCodeHandler	^ self class fullName, '.css'</body></methods><methods><class-id>AppeX.Theme class</class-id> <category>accessing</category><body package="AppeX-Server">styleSheetDefinitions	^ styleSheetDefinitions ifNil: [ styleSheetDefinitions := self initializeStyleSheetDefinitions ]</body></methods><methods><class-id>AppeX.Theme class</class-id> <category>initialize-release</category><body package="AppeX-Server">initializeStyleSheetDefinitions"	Answer an OrderedCollection of selectors implementing the individual sections of the theme stylesheet.	Make sure no duplicates occur, and that subclass declaration of #styleSheet: takes precedence over the same	selector declaration in superclass.	(self initializeStyleSheets)"	| pragmas answer |	answer := OrderedCollection new.	pragmas := Pragma allNamed: #styleSheet: from: self to: Theme.	pragmas do: [ :eachPragma |		| eachSelector |		eachSelector := eachPragma selector.		(answer anySatisfy: [ :included | included selector = eachSelector ]) ifFalse: [				answer add: eachPragma ] ].	^ answer sorted: [ :a :b | a arguments first &lt;= b arguments first ].</body><body package="AppeX-Server">resetAllStyleSheetDefinitions	Theme withAllSubclasses do: [ :each | each resetStyleSheetDefinitions ]</body><body package="AppeX-Server">resetStyleSheetDefinitions	styleSheetDefinitions := nil</body></methods><methods><class-id>AppeX.Theme class</class-id> <category>compiling</category><body package="AppeX-Server">instanceMethodsChanged	self resetAllStyleSheetDefinitions.	super instanceMethodsChanged</body></methods><methods><class-id>AppeX.NoCacheRequestFilter</class-id> <category>services</category><body package="AppeX-Server">applyTo: aRequestContext"	If the appexAction is notNil and the keyword is #activeRecord:class:, set the response headers accordingly."	aRequestContext appexAction ifNotNil: [ :actionPragma |		(self services includes: actionPragma keyword) ifTrue: [			aRequestContext response				cacheControl: 'no-cache, no-store, must-revalidate';				expires: Timestamp nowUTC ] ]</body></methods><methods><class-id>AppeX.NoCacheRequestFilter</class-id> <category>accessing</category><body package="AppeX-Server">addService: serviceType	self services add: serviceType</body><body package="AppeX-Server">services	^ services ifNil: [ services := OrderedCollection new ]</body></methods><methods><class-id>AppeX.JavascriptLibrary class</class-id> <category>initialize-release</category><body package="AppeX-Server">initializeRegistry"	Initialize the current registry from all #library: pragmas used in myself.	Then do the same thing for my subclasses, recursively."	(Pragma allNamed: #library: in: self class) do: [:eachPragma |		(self perform: eachPragma selector)			initialize: (eachPragma argumentAt: 1);			register].	self subclasses do: [:each | each initializeRegistry].</body></methods><methods><class-id>AppeX.JavascriptLibrary class</class-id> <category>accessing</category><body package="AppeX-Server">librariesContaining: aClass	^self registry select: [:eLibrary | eLibrary classes includes: aClass]</body></methods><methods><class-id>AppeX.JavascriptLibrary class</class-id> <category>instance creation</category><body package="AppeX-Server">named: aString	^self registry at: aString ifAbsent: [nil]</body></methods><methods><class-id>AppeX.JavascriptLibrary class</class-id> <category>accessing</category><body package="AppeX-Server">registry"(self registry)"	Registry ifNil: [		Registry := Dictionary new.		Application clearCombinedLibraries.		JavascriptLibrary initializeRegistry.].		^Registry</body></methods><methods><class-id>AppeX.JavascriptLibrary</class-id> <category>accessing</category><body package="AppeX-Server">code	"	convenience	"		^self code: Application codeComposer</body><body package="AppeX-Server">register	self class registry at: self name put: self</body></methods><methods><class-id>Protocols.HTTPv20</class-id> <category>services</category><body package="AppeX-Server">flushEventStream: anEventStream	self multiplexer flushEventStream: anEventStream</body></methods><methods><class-id>SiouX.HTTP2ServerMultiplexer</class-id> <category>services</category><body package="AppeX-Server">flushEventStream: anEventStream	anEventStream http2DataStream readyToSendFrame</body></methods><methods><class-id>Protocols.HTTPv11</class-id> <category>services</category><body package="AppeX-Server">flushEventStream: anEventStream	anEventStream flush</body></methods><methods><class-id>SiouX.RequestContext</class-id> <category>accessing</category><body package="AppeX-Server">appexAction	^ self propertyAt: #appexAction</body><body package="AppeX-Server">appexAction: actionPragma	self propertyAt: #appexAction put: actionPragma</body><body package="AppeX-Server">appexActionPath	| path baseSize |	"Root request /. The partial url holds the root in #path as #('' '') "	(request url path size = 2 		and: [request url path last isEmpty]) 		ifTrue: [^OrderedCollection new].			"Find the base url size to remove from the request path"		baseSize :=  (responder url path size = 2 					and: [responder url path last isEmpty]) 					ifTrue: [ 1 ] 					ifFalse: [responder url path size ].						path := request decodedPath allButFirst: baseSize.	(path notEmpty and: [path first isEmpty]) ifTrue: [path remove: path first].	^path</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="AppeX-Server">asJsonString	^Xtreams.JSON encode: self</body></methods><methods><class-id>SiouX.RequestFilter</class-id> <category>testing</category><body package="AppeX-Server">isAppeXSessionFilter	^ false</body></methods><methods><class-id>AppeX.ETagRequestFilter</class-id> <category>configuration</category><body package="AppeX-Server">defaultConfiguration	&lt;configuration: 'Default ETag'&gt;		self		addPattern: #html: -&gt; '*';		addPattern: #javascript: -&gt; '*';		addPattern: #css: -&gt; '*';		addPattern: #file: -&gt; '*.html';		addPattern: #file: -&gt; '*.js';		addPattern: #file: -&gt; '*.css'</body></methods><methods><class-id>AppeX.Application</class-id> <category>*seaside2</category><body package="AppeX-Server">inspectorFields	&lt;inspectorFields&gt;	^#{Tools.Trippy.TextAttribute}		ifDefinedDo: [ :class |			[ Array with: (class  label: 'role' text: self role asString)			] on: Error do: [ #() ] ]		elseDo: [ Array new ]</body></methods><methods><class-id>AppeX.Application class</class-id> <category>html</category><body package="AppeX-Server">applicationLibrary	"	answer a new library specific to this application (as opposed to the coreLibrary), or nil if none is required.	Use a large position index to indicate this should always be at the end of the &lt;head&gt; section."	&lt;head: 9999.2&gt;	(JavascriptLibrary named: self asJavascriptLibraryName)  ifNotNil: [ :eLib | ^eLib].	"If applicationClientClass is present, call #javascriptLibrary indirectly,	to avoid circular prerequisites between AppeX-Server and AppeX-Client packages."	^self applicationClientClass ifNotNil: [ :clientClass | clientClass perform: #javascriptLibrary ]</body><body package="AppeX-Server">bodyInstallApplication	&lt;body: 100&gt;	^self applicationClientClass ifNotNil: [		| stream |		stream := String new writing.		stream			cr; tab;			write: '&lt;script&gt;';			write: '(new {{applicationName}}())'.		self isSessionRequired			ifTrue: [				stream					write: '.installSession(';					write: self sessionOptions asJsonString;					write: ');' ]			ifFalse: [				stream					write: '.install();' ].		stream			write: '&lt;/script&gt;';			cr.		stream contents ]</body><body package="AppeX-Server">cacheManifest	"A hook for cacheManifest to be included in the &lt;html&gt; tag.	By virtue of including &lt;appCache:&gt; pragma here, the manifest is reachable by the dispatcher.	Return nil if no app cache manifest is present, otherwise its contents.	Default is nil. Subclasses interested in caching the application must override.	This should be the only selector every to be used with the &lt;appCache:&gt; pragma.	Any method selector other than #cacheManifest will be ignored by the dispatch mechanism.	The argument ('manifest.appcache') must match the value of the 'manifest' attribute set in the #manifestAttribute method.	"	&lt;appCache: 'manifest.appcache'&gt;	^ nil</body><body package="AppeX-Server">coreLibrary	"Use a large position index to indicate this should always be at the end of the &lt;head&gt; section. 	I only require the core library if I also have JavascriptObjects to support in the browser."	&lt;head: 9999.1&gt;	self requiresCoreLibrary ifFalse: [^nil].	^JavascriptCode coreCodeLibrary</body><body package="AppeX-Server">headCssDefaultStyle	&lt;head: 100.2&gt;	^ self defaultStyle ifNotNil: ['	&lt;link rel="stylesheet" href="defaultStyle.css" /&gt;'	]</body><body package="AppeX-Server">headCssDefaultTheme	&lt;head: 100.1&gt;	^ self theme</body><body package="AppeX-Server">headResponsiveViewport	&lt;head: 1&gt;	^'	&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;'</body><body package="AppeX-Server">headStart	"Use 0 position to indicate this should always be at the start of the &lt;head&gt; section."	&lt;head: 0&gt;	^'	&lt;!-- always have baseURI, charset, and title --&gt;	&lt;base href="{{baseURI}}"&gt;	&lt;meta charset="{{characterSet}}"&gt;	&lt;title&gt;{{title}}&lt;/title&gt;	&lt;link rel="icon"  href="{{baseURI}}favicon.ico" /&gt;'</body><body package="AppeX-Server">htmlApplicationName	&lt;htmlToken: #applicationName&gt;	^ self applicationClientClass		ifNil: [ self htmlTitle ]		ifNotNil: [ :clientClass | clientClass javascriptName ]</body><body package="AppeX-Server">htmlBaseURI	&lt;htmlToken: #baseURI&gt;	^ self currentRequestBaseUrl</body><body package="AppeX-Server">htmlCharacterSet	"I use UTF-8 as the default HTML character set."	&lt;htmlToken: #characterSet&gt;	^'utf-8'</body><body package="AppeX-Server">htmlDocument	"Take the htmlTemplate and expand it to resolve the tokens in it to their actual values."	&lt;GET&gt;	&lt;html: ''&gt;	^self expandHtmlTemplate: self htmlTemplate</body><body package="AppeX-Server">htmlLanguageCode	"Set the languageCode from my current locale. Application subclasses may override."	&lt;htmlToken: #languageCode&gt;	^Locale current languageID</body><body package="AppeX-Server">htmlTitle	&lt;htmlToken: #title&gt;	^self fullName</body><body package="AppeX-Server">manifestAttribute	"	Check if I should include cache manifest in my HTML, and if so, return the value of the manifest attribute.	Otherwise, answer an empty string.	"	&lt;htmlToken: #manifestAttribute&gt;	^self cacheManifest		ifNil: [ '' ]		ifNotNil: [ 'manifest="', self responderPath, '/manifest.appcache"'			"The 'manifest.appcache' must match the appCache: argument in the cacheManifest method." ]</body></methods><methods><class-id>AppeX.Application class</class-id> <category>accessing</category><body package="AppeX-Server">combinedJavascriptLibrary"	self combinedJavascriptLibrary.	self combinedJavascriptLibrary: nil."	&lt;head: 9999.99&gt;	self applicationLibrary ifNil: [ ^ nil ].	^JavascriptWriter serveFilesCombined		ifTrue: [ combinedJavascriptLibrary := combinedJavascriptLibrary ifNil: [JavascriptLibrary newNamed: (self fullName, '-all.js' )] ]		ifFalse: [ combinedJavascriptLibrary := nil ]</body></methods><methods><class-id>AppeX.Application class</class-id> <category>dispatching</category><body package="AppeX-Server">appCache: pragma	"	Use #appCache: pragma to return a response with the contents of a CACHE MANIFEST file.	This requestHandler method is different than others. It ignores all arguments in @pragma.	Instead, we always use the result of the cacheManifest method to set the contents of the response.	Only the #cacheManifest method should ever use the &lt;appCache:&gt; pragma. Any other method will be ignored.	"	&lt;serviceType: #GET&gt;	^self cacheManifest		ifNil: [			self responseNotFound ]		ifNotNil: [ :manifest | self currentResponse			contentType: 'text/cache-manifest';			contents: manifest			yourself ]</body><body package="AppeX-Server">authenticate: pragma"	A special service that indicates that an application requires session authentication.	This service may only be defined on the instance side.	There should only be one authenticate: service in an application.	Use #authenticate: pragma to return a JSON-serializable object.	The 'content-type' will be set to 'application/json'.	Examples:		&lt;authenticate: 'authenticationPath'&gt;		^ &lt;anObject&gt;		&lt;anObject&gt; may be application specific representation of the authentication result.	Browse hierarchy senders of authenticate: for more examples."	&lt;serviceType: #POST&gt;	^self processRequestInSession: [:session |			| receiver |			session touch.			receiver := session applicationFor: self.			receiver respondWithAuthenticate: (receiver perform: pragma selector)]</body><body package="AppeX-Server">css: pragma	"Use #css: pragma to generate a CSS definition for a resource accessed at the url ending with the path	matching the pragma argument.	Example:		&lt;css: 'default.css'&gt;		^ '.some-style {font-family: Verdana}'	Browse hierarchy senders of css: for more examples.	"	&lt;serviceType: #GET&gt;	^self dispatchPragma: pragma		with: [:receiver | receiver respondWithCss: (receiver perform: pragma selector)]</body><body package="AppeX-Server">eventStream: pragma	"	Use #eventStream: pragma to return a block for streaming a respons for a resource accessed at the url ending with the path	matching the pragma argument.	The request should be coming from an HTML5 EventSource object. It expects data in a specific format.	Example:		&lt;eventStream: 'eventStream'&gt;		^ [ :stream | stream data: 'some data' ]	Browse hierarchy senders of eventStream: for more examples.	See also #respondWithEventStream: comments.	"	&lt;serviceType: #GET&gt;	^self dispatchPragma: pragma		with: [:receiver | receiver respondWithEventStream: (receiver perform: pragma selector)]</body><body package="AppeX-Server">file: pragma"	Use #file: pragma to return a response with the contents of a file stored on the server file system.	The file must be accessible at a path that is the concatenation of the documentRoot,	the responder path, and the path specified by the #file: pragma argument.	Examples:		&lt;file: 'somefile.txt'&gt;		&lt;file: 'somefile.txt'&gt;		^ 'This is the contents of somefile.txt'		&lt;file: somefile.txt'&gt;		^ Filename named: 'otherfile.xxx'	Browse hierarchy senders of file: for more examples."	&lt;serviceType: #GET&gt;	^self dispatchPragma: pragma		with: [:receiver |			| contents filename |			contents := receiver perform: pragma selector.			contents isString ifTrue: [^ receiver respondWithPlainText: contents ].			filename := (self osPath: pragma arguments first) asFilename.			contents class = ByteArray ifTrue: [ ^ receiver respondWithFileType: filename extension contents: contents ].			(contents isKindOf: Filename)				ifTrue: [ receiver respondWithFile: contents ]				ifFalse: [ receiver respondWithFile: filename ]]</body><body package="AppeX-Server">html: pragma"	Use #html: pragma to return an HTML document in the response.	Examples:		&lt;html: 'somefile.html'&gt;		^ '&lt;!DOCTYPE html&gt;			&lt;html lang=en' &gt;			&lt;head&gt;				&lt;title&gt;'My HTML file'&lt;/title&gt;			&lt;/head&gt;			&lt;body&gt;				&lt;p&gt;This is its content&lt;/p&gt;			&lt;/body&gt;			&lt;/html&gt;		'		&lt;file: somefile.html'&gt;		^ Filename named: 'otherfile.html'	Browse hierarchy senders of html: for more examples."	&lt;serviceType: #GET&gt;	^self dispatchPragma: pragma		with: [:receiver | receiver respondWithHtml: (receiver perform: pragma selector)]</body><body package="AppeX-Server">js: pragma"	Use #js: pragma to return a Javascript document in the response. The 'content-type' will be set to 'application/javascript'.	Examples:		&lt;js: 'script.js'&gt;		^ 'console.log(''This is my script'');		'		&lt;file: script.js'&gt;		^ Filename named: 'otherscript.js'	Browse hierarchy senders of js: for more examples."	&lt;serviceType: #GET&gt;	^self dispatchPragma: pragma		with: [:receiver | receiver respondWithJavascript: (receiver perform: pragma selector) ]</body><body package="AppeX-Server">json: pragma"	Use #json: pragma to return a JSON-serializable object.	The 'content-type' will be set to 'application/json'.	Examples:		&lt;json: 'data.json'&gt;		^ Dictionary new			at: #data1 put: 'Data One';			at: #data2 put: true;			yourself	Browse hierarchy senders of json: for more examples."	&lt;serviceType: #POST&gt;	^self dispatchPragma: pragma		with: [:receiver | receiver respondWithJson: (receiver perform: pragma selector)]</body><body package="AppeX-Server">jsonStream: pragma"	Use #jsonStream: pragma to return a JSON-serializable object. An object will be encoded directly on a socket stream.	The 'content-type' will be set to 'application/json'.	Examples:		&lt;jsonStream: 'data.json'&gt;		^ Dictionary new			at: #data1 put: 'Data One';			at: #data2 put: true;			yourself	Browse hierarchy senders of jsonStreaming: for more examples."	&lt;serviceType: #POST&gt;	^self dispatchPragma: pragma		with: [:receiver | receiver respondWithJsonStream: (receiver perform: pragma selector)]</body><body package="AppeX-Server">plainText: pragma"	Use #plainText: pragma to return a plain text in the response.	The 'content-type' will be set to 'text/plain' and 'charset' to 'utf-8'.	Examples:		&lt;plainText: 'some-text'&gt;		^ 'This is a plain text response.'		&lt;plainText: 'some-text'&gt;		^ Filename named: 'file.txt'	Browse hierarchy senders of plainText: for more examples."	&lt;serviceType: #POST&gt;	^self dispatchPragma: pragma		with: [:receiver | receiver respondWithPlainText: (receiver perform: pragma selector)]</body><body package="AppeX-Server">xml: pragma"	Use #xml: pragma to return an XML document in the response.	The 'content-type' will be set to 'text/xml' and 'charset' to 'utf-8'.	Examples:		&lt;xml: 'somedata.xml'&gt;		^ '&lt;?xml version=''1.0'' encoding=''UTF-8''?&gt;			&lt;data&gt;XML data&lt;/data&gt;'		&lt;xml: 'somedata.xml'&gt;		^ Filename named: 'otherdata.xml'	Browse hierarchy senders of xml: for more examples."	&lt;serviceType: #POST&gt;	^self dispatchPragma: pragma		with: [:receiver | receiver respondWithXml: (receiver perform: pragma selector)]</body></methods><methods><class-id>AppeX.Application class</class-id> <category>pragmas</category><body package="AppeX-Server">htmlPartPragmas	&lt;pragmas: #class&gt;	^#( #head: #body:)</body><body package="AppeX-Server">htmlTokenPragmas	&lt;pragmas: #class&gt;	^#(#htmlToken:)</body><body package="AppeX-Server">requestMethodPragmas	&lt;pragmas: #class&gt;	&lt;pragmas: #instance&gt;	^#( #GET #PUT #POST #DELETE )</body><body package="AppeX-Server">serviceTypeDeclarationPragmas"	Answer the pragmas used to determine which methods can be used to declare serviceTypes.	Tag each declared serviceType with a #serviceType pragma."	&lt;pragmas: #class&gt;	^# (#serviceType:)</body><body package="AppeX-Server">serviceTypePragmas"	Instead of hard-coding pragma names, derive them from methods that use &lt;serviceType&gt; tag.	Answer a collection of symbols that can be used to declare service method.	Subclasses may override to return a smaller or larger set of supported service types,	and define their own.	For each pragma keyword I return, a class method with the same name must be implemented,	and it must accept a Pragma as the argument."	&lt;pragmas: #class&gt;	&lt;pragmas: #instance&gt;	"For compatibility with previous versions, return an Array of unique selectors."	^((Pragma allNamed: #serviceType: from: self class to: Application class) collect: #selector) asSet sorted</body></methods><methods><class-id>AppeX.Application class</class-id> <category>services</category><body package="AppeX-Server">faviconIco"	The base64 encoded contents of Cincom Smalltalk 'favicon.ico' file, downloaded from http://www.cincomsmalltalk.com/	| file contents |	filename := 'Molecule.ico' asFilename.	contents := filename contentsOfEntireBinaryFile.	contents asBase64String"	&lt;file: 'favicon.ico'&gt;	^self faviconIcoBytes</body><body package="AppeX-Server">getServerEvents"	Handle only events associated with sessions.	Try to find the requested session and dispatch the request to it.	Otherwise, write a #SessionNotFound event to the eventStream and return."	&lt;eventStream: '_appex_getServerEvents'&gt;	self findRequestedSession ifNotNil: [ :session |		^ (session applicationFor: self) getServerEvents ].	^ [ :eventStream |		eventStream retry: self eventStreamRetry "milliseconds".		eventStream put: (ServerEvent eventName: #SessionNotFound data: self requestedSessionId) ]</body><body package="AppeX-Server">handlePostClientEvent	"	This is the default event posting request handler.	The request is ultimately going to be handled by an instance,	but for event signalling, we need to find the session instance	without updating the session itself, se we need to bypass the regular	dispatch mechanism and only forward the request to the session instance	if there is one found.	"	&lt;jsonStream: '_appex_postClientEvent'&gt;	| receiver event arguments |	arguments := self currentRequestArguments.	receiver := self findRequestedSession ifNil: [ self ] ifNotNil: [ :session | session applicationFor: self ].	event := ClientEvent				sessionId: self requestedSessionId				eventName: (arguments at: #eventName ifAbsent: [#unknown]) asSymbol				data: (arguments at: #data ifAbsent: [#()]).	receiver announceClientEvent: event.	^#eventId -&gt; event eventId</body></methods><methods><class-id>AppeX.Application class</class-id> <category>css</category><body package="AppeX-Server">defaultStyle	"Return the defaultStyle. Normally, a defaultStyle is undefined, but if an application needs one, it should override this message. "	&lt;css: 'defaultStyle.css'&gt;	^ nil</body></methods><methods><class-id>AppeX.Theme</class-id> <category>accessing</category><body package="AppeX-Server">decorations"	A placeholder for a style that a subclass may define.	For a very simple theme, all you may want to do is override this method.	However, more complicated themes will want to break styling into separate parts	for structure, fonts, colors, etc. See some theme examples."	&lt;styleSheet: 0&gt;		^ '// This is an empty section.// You may want to implement ', self class fullName, ' &gt;&gt; #style to define your own default style.'</body></methods><methods><class-id>AppeX.Theme class</class-id> <category>pragmas</category><body package="AppeX-Server">styleSheetPragmas"	Answer the #styleSheet: pragmas used by this class."	&lt;pragmas: #instance&gt;	^ #(#styleSheet:)</body></methods><methods><class-id>AppeX.NoCacheRequestFilter</class-id> <category>configuration</category><body package="AppeX-Server">forActiveRecord	&lt;configuration: 'Active Record'&gt;		self addService: #activeRecord:class:</body></methods><initialize><class-id>AppeX.Application</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>HTTP2ServerMultiplexer</name><environment>SiouX</environment><super>Protocols.HTTP2Multiplexer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>activePushStreams writeScheduler writeSchedulerClass </inst-vars><class-inst-vars>writeSchedulerClass </class-inst-vars><imports>			private Protocols.*			</imports><category></category><attributes><package>SiouX-Http2</package></attributes></class><class><name>FileLibrary</name><environment>AppeX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Support</package></attributes></class><class><name>JavascriptLibrary</name><environment>AppeX</environment><super>AppeX.FileLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classes name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>bootstrap</category><attributes><package>AppeX-Support</package></attributes></class><class><name>Announcement</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Announcements</category><attributes><package>System-Announcements</package></attributes></class><class><name>RequestFilter</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>configuration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Server</package></attributes></class><class><name>SessionFilter</name><environment>SiouX</environment><super>SiouX.RequestFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sessionCache sessionClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Sessions</package></attributes></class><class><name>RequestContext</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>responder connection request response data properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Server</package></attributes></class><class><name>HTTPv11</name><environment>Protocols</environment><super>Protocols.ProtocolVersion</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http</package></attributes></class><class><name>WriteStream</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars>destination </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.BehaviorIcons			</imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class><class><name>HttpResponder</name><environment>SiouX</environment><super>SiouX.Responder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><class><name>NoCacheRequestFilter</name><environment>AppeX</environment><super>SiouX.RequestFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>services </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>AppeX-Server</package></attributes></class><class><name>HttpResponse</name><environment>SiouX</environment><super>SiouX.HttpResponsePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>code parameterCharset boundary request </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Http</package></attributes></class><class><name>HTTPv20</name><environment>Protocols</environment><super>Protocols.ProtocolVersion</super><private>false</private><indexed-type>none</indexed-type><inst-vars>multiplexer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><class><name>Session</name><environment>SiouX</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id data status creationTime lastUsed properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Sessions</package></attributes></class></st-source>