<?xml version="1.0"?><st-source><!-- Name: SiouX-ServerNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.BundleName: SiouX-ServerBundleStructure: a Store.BundleForParcelComment: This is the core package of the SiouX framework providing basic HTTP server infrastructure. It allows multiple instances of a Server coexist and be active in the same image (as long as they don't collide with their listening port allocations). The Server instances are managed through a global Server.Registry. When an instance is created it is automatically registered with an ID, that is either explicitly specified or auto-generated. There can be only one server with given ID at a time. Server activity is controlled with #start/#stop messages. When a Server instance is to be discarded it must be sent the #release message which removes it from the registry.A Server has one or more Listeners listening for incoming Connections. An established Connection waits for incoming requests, which are then passed to the Server for execution. A Server is configured with one or more Responders. With each incoming request the Server asks its responders to execute it, one by one in their registered order. A Responder can reject a request in which case the next Responder is given the opportunity. This iteration ends with the first Responder that responds to the request.Example: (requires SiouX-Http package and uses a sample responder from the SiouX-Examples package)	| server |	server := SiouX.Server id: 'Experiments'.	server listenOn: 4242 for: SiouX.HttpConnection.	server addResponder: SiouX.Hello new.	server when: SiouX.ConnectionAnnouncement do: [ :ann | Transcript cr; print: ann ].	server start.	[ 'http://localhost:4242/hello' asURI get ] ensure: [ server stop ].	server releaseThere is also a more declarative way to define a Server configuration. A server and its listeners can be declared with an extension class method on the Server class adorned with the #server: pragma. The SiouX-Examples package declares a predefined server identified as 'Examples', the method looks like this:	Server class>>examples: server			<server: 'Examples'>		server listenOn: 8888 for: HttpConnectionResponders are configured separately to allow multiple responders to be configured independently with the same server. The Responder configuration methods use #server:path: pragma. The Hello responder from SiouX-Examples is declared as follows:	configureExamples			<server: 'Examples' path: '/hello'>This declaration means that when this responder is activated it will be registered with the server 'Examples' and its url path is '/hello'. Responder declaration method can optionally take an argument in which case it will also be invoked with the Responder instance as the argument, allowing the method to further configure the responder instance as appropriate.The package SiouX-Tools provides server management tools for controlling activation of servers and responders.When saving an image during development time, all servers will be stopped before the image snapshot, and will have to be restarted manually by the developer when needed. This is to avoid leaving Server instances and associated objects such as session caches in an inconsistent state.However, if you 'Save and Quit' a development image, if the 'Auto Restart' option is selected in the Web Server page of System Settings, the next time you start the image, all servers running before the snapshot will automatically be restarted.For more details on the various components, please, refer to the individual class comments.DevelopmentPrerequisites: #(#(#any 'Protocols-Common' '') #(#any 'Protocols-Http' '') #(#any 'Xtreams-Terminals' '') #(#any 'Xtreams-Transforms' '') #(#any 'Xtreams-Substreams' '') #(#any 'URISupport' ''))DisregardedPrerequisites: #(#(#name 'Xtreams-Core' #componentType #package) #(#name 'Xtreams-Support' #componentType #package))Parcel: nilParcelName: SiouX-ServerPrerequisiteDescriptions: #(#(#name 'Protocols-Common' #componentType #package) #(#name 'Protocols-Http' #componentType #package) #(#name 'Xtreams-Terminals' #componentType #package) #(#name 'Xtreams-Transforms' #componentType #package) #(#name 'Xtreams-Substreams' #componentType #package) #(#name 'URISupport' #componentType #package))PrerequisiteParcels: #(#('Protocols-Common' '') #('Protocols-Http' '') #('Xtreams-Terminals' '') #('Xtreams-Transforms' '') #('Xtreams-Substreams' '') #('URISupport' '') #('Protocols-Common' ''))Version: 8.3 - 12Date: 1:19:06 PM July 14, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jul17.2) of July 14, 2017 on July 14, 2017 at 1:19:06 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>SiouX</name><environment>Smalltalk</environment><private>false</private><imports>			private Tools.Pragma			private Xtreams.*			private Core.*			</imports><category></category><attributes><package>SiouX-Server</package></attributes></name-space><class><name>Listener</name><environment>SiouX</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>server address socket process connectionCount reuseAddress backlogSize listenerPriority connectionPriority connectionTimeout lowerConnectionLimit upperConnectionLimit maxAcceptDelay suspend </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.*			</imports><category></category><attributes><package>SiouX-Server</package></attributes></class><comment><class-id>SiouX.Listener</class-id><body>A Listener manages a single entry point identified by an IPSocketAddress. When the Listener is started it creates a listening socket that is then bound to this address. A process is also spawned which listens on this socket for incoming TCP connection requests and creates instances of Connection in response. A new Connections is first activated with message #open. A successfully open Connection is finally handed over to the Server and the listening process goes back to listening for next connection request.The Listener is also notified when a Connection is closed. That allows the Listener to keep count of currently active connections that were accepted through its listening socket. The #connectionCount is used to implements a throttling mechanism that allows controlling the rate of accepting new connections. When the connection count reaches #lowerConnectionLimit, the listener process starts introducing a delay into the accept loop, thus slowing down the rate of acceptance. The delay gets progressively longer up to the specified #maxAcceptDelay if the connection count keeps climbing. When the connection count reaches #upperConnectionLimit, the listener process is suspended entirely until the count drops back below the limit. The listener announces crossing these thresholds with several ListenerAnnouncements that can be used to monitor its state.Instance Variables	server	&lt;Server&gt; server for which I'm listening	address	&lt;IPSocketAddress&gt; address bound to the listening socket	socket	&lt;SocketAccessor&gt; socket listening for incoming connections	process	&lt;Process&gt; listener process	connectionCount	&lt;SmallInteger&gt; count of currently active Connections accepted by this listener	reuseAddress	&lt;Boolean&gt; should the SO_REUSEADDR option be set on the socket	backlogSize	&lt;SmallInteger&gt; size of the TCP listening backlog	listenerPriority	&lt;SmallInteger&gt; listener process priority	connectionPriority	&lt;SmallInteger&gt; connection process priority	connectionTimeout	&lt;Duration&gt; how long can a connection idle before it is closed by the server	lowerConnectionLimit	&lt;SmallInteger&gt; when connectionCount crosses this threshold, we'll start throttling the acceptance rate	upperConnectionLimit	&lt;Object&gt;  when connectionCount crosses this threshold, we'll suspend the listener process	maxAcceptDelay	&lt;Duration&gt; maximum delay when throttling connection acceptance	suspend	&lt;Boolean&gt; internal implementation flag used in suspension of the listener processShared Variables	BacklogSize	&lt;SmallInteger&gt; default TCP listening backlog size	ConnectionPriority	&lt;SmallInteger&gt; default connection process priority	ConnectionTimeout	&lt;Duration&gt; default connection timeout value	ListenerPriority	&lt;SmallInteger&gt; default listener process priority	LowerConnectionLimit	&lt;SmallInteger&gt; default lower limit on number of concurrent connections	MaxAcceptDelay	&lt;Duration&gt; default maximum accept throtling delay	ReuseAddress	&lt;Boolean&gt; default SO_REUSEADDR value	UpperConnectionLimit	&lt;SmallInteger&gt; default upper limit on number of concurrent connections</body></comment><class><name>HttpListener</name><environment>SiouX</environment><super>SiouX.Listener</super><private>false</private><indexed-type>none</indexed-type><inst-vars>exceptionPrinter persist protocolVersions requestStatusLineLimit requestHeaderLimit requestBodyLimit acceptedServerNames </inst-vars><class-inst-vars>exceptionPrinter persist protocolVersions </class-inst-vars><imports>			OS.*			</imports><category></category><attributes><package>SiouX-Server</package></attributes></class><comment><class-id>SiouX.HttpListener</class-id><body>I provide additional configuration options for HttpConnections.Instance Variables	exceptionPrinter	&lt;BlockClosure&gt; used to print exception into the response stream	persist &lt;Boolean&gt; if the option is true the connection should remain open after current response is sent	protocolVersions &lt;Collection of ProtocolVersion&gt; supported Http versions	requestStatusLineLimit &lt;Number&gt; request status line maximum length. If the request status line number of bytes exceeds this number the error response will be returned: 414 'Request-URI Too Large'	requestHeaderLimit &lt;Number&gt; the maximum amount of bytes for all request headers. The default is 1024 * 100. If the header size exceeds the specified number the connection will be closed and returned 400 Bad Request response	requestBodyLimit &lt;Integer&gt; number of bytes limited a request body. By default there is no limit	requestStatusLineLimit &lt;Number&gt; request status line maximum length. If the request status line number of bytes exceeds this number the error response will be returned: 414 'Request-URI Too Large'	acceptedServerNames &lt;OrderedCollection of String&gt; server names acceptabled by a connection. The names are used to validate Host header field. By default the collection is empty and there is no a request Host header field validation. Class Instance Variables	exceptionPrinter	&lt;BlockClosure&gt; used to print exception into the response stream	persist &lt;Boolean&gt; default for persist option	protocolVersions &lt;Collection of ProtocolVersion&gt; default for supported Http versionsShared Variables	RequestStatusLineLimit &lt;Integer&gt; default maximum request status line length 	RequestHeaderLimit &lt;Integer&gt; default maximum amount of bytes for all request headers	RequestBodyLimit &lt;Integer&gt; default maximum amount of bytes for the request body. By default there is no limit</body></comment><class><name>ServerAnnouncement</name><environment>SiouX</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ServerAnnouncement</class-id><body>Abstract superclass of all announcements generated by the server.</body></comment><class><name>ListenerAnnouncement</name><environment>SiouX</environment><super>SiouX.ServerAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>listener </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ListenerAnnouncement</class-id><body>Abstract superclass for Listener related events.Instance Variables	listener	&lt;Listener&gt; </body></comment><class><name>ConnectionAcceptanceResumed</name><environment>SiouX</environment><super>SiouX.ListenerAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ConnectionAcceptanceResumed</class-id><body>Announces that a listener is starting to accept new connections again after being suspended (the connection count dropped below upperConnectionLimit). Note that the handlers of these announcements will run within the individual listener processes.</body></comment><class><name>ConnectionAnnouncement</name><environment>SiouX</environment><super>SiouX.ServerAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ConnectionAnnouncement</class-id><body>These are connection related announcements. Note that the handlers of these announcements will run within the individual connection processes.Instance Variables	connection	&lt;Connection&gt;</body></comment><class><name>RequestAnnouncement</name><environment>SiouX</environment><super>SiouX.ConnectionAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>request </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.RequestAnnouncement</class-id><body>Abstract superclass of announcements related to request processing.Instance Variables	request	&lt;Request&gt; </body></comment><class><name>ResponseAnnouncement</name><environment>SiouX</environment><super>SiouX.RequestAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>response </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ResponseAnnouncement</class-id><body>Abstract superclass of announcements related to response sending.Instance Variables	response	&lt;HttpResponse&gt;	response</body></comment><class><name>ResponsePrepared</name><environment>SiouX</environment><super>SiouX.ResponseAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>responder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ResponsePrepared</class-id><body>Announces that a responder has finished preparing a response and it is about to be sent.Instance Variables	responder	&lt;Responder&gt;</body></comment><class><name>ListenerRemoved</name><environment>SiouX</environment><super>SiouX.ListenerAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ListenerRemoved</class-id><body>ListenerAdded is announced when a Listener has been removed from a server.</body></comment><class><name>ListenerFailed</name><environment>SiouX</environment><super>SiouX.ListenerAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>exception </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ListenerFailed</class-id><body>These announcements are generated when listener errors are handled.  Note that the handlers of these announcements will run within the individual listener processes.Instance Variables	exception	&lt;Exception&gt;</body></comment><class><name>StreamLogger</name><environment>SiouX</environment><super>Protocols.AnnouncementLogger</super><private>false</private><indexed-type>none</indexed-type><inst-vars>file stream bufferSize timeZone </inst-vars><class-inst-vars>fileName rootDirectory </class-inst-vars><imports>			private OS.OSHandle			private Xtreams.*			private OS.*			</imports><category></category><attributes><package>SiouX-Loggers</package></attributes></class><comment><class-id>SiouX.StreamLogger</class-id><body>The abstract logger can be set up with a file name to log into. In this case the logger will open/close the file automatically as needed. Alternatively it can be configured with a pre-configured textual write stream in which case the stream provider is responsible for managing (i.e. opening/closing) the stream. This mode can be used for emitting the common log format output onto a Transcript or standard out, for example.Instance Variables	file	&lt;Filename&gt; external file to collect log records	stream	&lt;WriteStream&gt; output stream to log announcement	bufferSize	&lt;Number&gt; default buffer size	timeZone	&lt;String&gt; time zoneClass Instance Variables	fileName	&lt;Filename&gt; default log file name	rootDirectory &lt;Filename&gt; the log files location. The directory is relative to the server root directoryImplementationBy default the log records are collected in a buffer (default size 32K) first for performance reasons. The buffer is lazily flushed in to the file when the buffer fills up. This opens up the possibility that if the server crashes the last contents of the buffer can be lost. The alternative is to flush each log record separately, however that can significantly increase the amount of time consumed by the logger.UsageTo create a log use the following API:log: aServer - creates a log with default file name. The file will be located in the rootDirectory and the file name is created as (self fileName, '-', aServer id, '.log'). log: aServer file: aFilename - creates a log with specified file namelog: aServer stream: aStream - creates a log with specified streamTo start or stop the log:	log := CommonLog log: aServer.	[log start.	"... client sends requests"	] ensure: [ log stop ].	"... review the log file"	log file  file contentsOfEntireFile inspect.Creating a log for a server do not add this log to the server logs automatically. To be able to start or stop a log using server API #logging you need to add the log to the server.	aServer addLog: aLog.To start all server log:	aServer logging: true.</body></comment><class><name>StatusLog</name><environment>SiouX</environment><super>SiouX.StreamLogger</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>statusCollector </class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Loggers</package></attributes></class><comment><class-id>SiouX.StatusLog</class-id><body>The class provides information on server activity and performance. It allows a server administrator to find out how well their server is performing. The log uses ServerStatusCollector to monitor a server for a specified time period, collect statistics and then prints the collected data. Class Instance Variables	statusCollector	&lt;StatusCollector&gt; a class that collects statisticsUsage	| server logger |	server := Server id: 'StreamLoggerTest'.	server listenOn: 8000 for: SiouX.HttpConnection.	server addResponder: Hello new.	server start.	"Create a log. The log will be craeted with default file name:  sioux-logs\status-StreamLoggerTest.log"	logger := ServerStatusLog log: server frequency: 1 minutes.	"Start collecting statistics every minute "	logger start.	10 timesRepeat: [ 'http://localhost:8000/'  asURI get].	logger stop.	logger file contentsOfEntireFile inspect.	server release.</body></comment><class><name>ConnectionAcceptanceUnthrottled</name><environment>SiouX</environment><super>SiouX.ListenerAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ConnectionAcceptanceUnthrottled</class-id><body>Announces that a listener is now accepting new connections at full speed again (connection count dropped below lowerConnectionLimit).  Note that the handlers of these announcements will run within the individual listener processes.</body></comment><class><name>ServerShutdownAnnouncement</name><environment>SiouX</environment><super>SiouX.ServerAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>duration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ServerShutdownAnnouncement</class-id><body>Server will be shutdown in period of time specified by #duration.Instance Variables	duration	&lt;Duration&gt;	 an interval of time before server shutdown</body></comment><class><name>BadRequestAnnouncement</name><environment>SiouX</environment><super>SiouX.RequestAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>description </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.BadRequestAnnouncement</class-id><body>Announced when a request doesn't comply with the HTTP specificationInstance Variables:	description	&lt;String&gt;	the problem description </body></comment><class><name>ServerStartingAnnouncement</name><environment>SiouX</environment><super>SiouX.ServerAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ServerStartingAnnouncement</class-id><body>Announced when a server starts all listeners</body></comment><class><name>ListenerStopped</name><environment>SiouX</environment><super>SiouX.ListenerAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ListenerStopped</class-id><body>ListenerStopped  is annonced when a Listener has been stopped</body></comment><class><name>StatusCollector</name><environment>SiouX</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requests responses connectionCounts bytesSent timer frequency announcements server accessProtect isLogging </inst-vars><class-inst-vars>frequency </class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Loggers</package></attributes></class><comment><class-id>SiouX.StatusCollector</class-id><body>The class subscribes to ConnectionOpened,  ConnectionClosed, RequestReceived, ResponseSent announcements, collects server statistics and prints it in the following format:Instance Variables	requests	&lt;Number&gt; a number of requests	responses	&lt;Number&gt; a number of responses	connectionCounts	&lt;Number&gt; a number of connections	bytesSent	&lt;Number&gt; a number of bytes sent since last update	timer	&lt;Timer&gt; timer sends ServerStatusUpdate announcement every period defined by #frequency.	frequency	&lt;Duration&gt; a period of time to collect statistics	announcements	&lt;AnnouncementSet&gt; which announcements should we subscribed to	server	&lt;Server&gt; a monitored server	accessProtect	&lt;RecursionLock&gt; protects the resource to log announcements	isLogging	&lt;Boolean&gt; defines is the logger in on or offClass Instance Variables	frequency	&lt;Duration&gt; default period to collect statisticsImplementationThe server statistics are printed in the following format:##Start:  [05/Sep/2013:15:50:54 -0400] ##Monitor interval: 1 minutes=======================================================================================	Connections	Requests	Responses			Pending			Rate		Bytes Sent (K)=======================================================================================15:50 0000		00000			00000			0000			0000			0000000015:51 0001		00050			00050			0000			0001			00000021##Stop:  [05/Sep/2013:15:51:45 -0400] </body></comment><class><name>Connection</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id listener socket requestProcess writeStream readStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Server</package></attributes></class><comment><class-id>SiouX.Connection</class-id><body>A Connection implements a particular protocol, e.g. HTTP. When it is open a background process is started that waits for incoming Requests, passes them to the Server for execution and then sends the resulting Responses back to the other side. A Connection is closed either as dictated by the protocol or explicitly when the Server is being stopped.Instance Variables	id	&lt;IPSocketAccess&gt; peer address used to identify the connection	listener	&lt;Listener&gt; 	socket	&lt;SocketAccessor&gt; 	requestProcess	&lt;Process&gt; 	writeStream	&lt;WriteStream&gt; write pipe of the socket	readStream	&lt;ReadStream&gt; read pipe of the socket</body></comment><class><name>HttpConnection</name><environment>SiouX</environment><super>SiouX.Connection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>persist protocolVersion </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.*			private Kernel.*			</imports><category></category><attributes><package>SiouX-Server</package></attributes></class><comment><class-id>SiouX.HttpConnection</class-id><body>I am a connection for the HTTP protocol version 1.1 (server side). There are multiple protocol implementation available, provided by additional packages. SiouX-Http provides an implementation exploiting the Xtreams framework. SiouX-Net-Http provides an implementation using the Net framework.Instance Variables	persist	&lt;Boolean&gt; internal flag indicating if the connection should remain open after current response is sent	protocolVersion &lt;ProtocolVersion&gt; Http 1.1 or 2.0Shared Variables	ServerHeader	&lt;String&gt; value for the Server header field</body></comment><class><name>RequestFilter</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>configuration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Server</package></attributes></class><comment><class-id>SiouX.RequestFilter</class-id><body>RequestFilter represents a filter that can be applied to a Request in the context of a specific Responder. The request filters enable applications to process incoming requests in a flexible and configurable manner. Subclasses must implement the following messages:	#applyTo:  aRequestContextInstance Variables	configuration 	&lt;Symbol&gt;  a symbol that represent unary selectors which, when		sent to an instance, can recreate a particular filter configuration.Implementation:A filter can refuse to accept the request and set the RequestContext response to error response. A filter can  processes the request and send a response. To send a response from a filter use HttpResponse&gt;&gt;signalReady. UsageTo configure a request filter use annotated methods with &lt;configuration:&gt; pragmas. For example:  To set LocaleFilter from SiouX-Examples with language codes such as 'en' create a method:LocaleFilter&gt;&gt;acceptEnLanguage	&lt;configuration: 'Accept English Language'&gt;	self allow: 'en'.To create create a request filter with specified configuration and add it to a responder:filter := RequestFilter fromConfiguration: 'Accept English Language'.responder addRequestFilter: filter.or:responder requestFilter: #'SiouX.LocaleFilter' configuration:  'Accept English Language'</body></comment><class><name>Server</name><environment>SiouX</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>listeners connections responders debugging id logs noResponderReply </inst-vars><class-inst-vars>logFactory noResponderReply configurationFileName importErrorsFilename </class-inst-vars><imports>			private Protocols.*			private OS.*			private XML.*			</imports><category></category><attributes><package>SiouX-Server</package></attributes></class><comment><class-id>SiouX.Server</class-id><body>A Server has one or more Listeners listening for incoming Connections. Server also maintains a registry of currently active Connections. Finally, Server is also configured with one or more Responders that execute incoming requests. The order in which the Responders are registered reflects their assigned priority. A Responder will only get a chance to handle a Request if all the previous Responders rejected it first.Server generates announcements at various interesting points like connection opening/closing, request reception or response transmission. Note that these announcements usually happen in the context of the background process of the corresponding Connection and therefore should be re-entrant. Also note that while a connection process executes an announcement handler, the connection isn't handling requests, so the handler should generally be finished rather quickly. Any larger workload should be off-loaded to other processes.Since a server involves a number of background processes, any errors are generally handled and suppressed. To allow debugging these exceptions the debugging flag is consulted at appropriate places to allow the debugger to open on an exception instead of handling it. Note that this can sometimes interfere with proper operation of the respective protocol, therefore this flag should never be used for deployment.An instance of a Server must be registered in the Registry upon creation, and released when it's no longer active.Instance Variables	listeners	&lt;OrderedCollection of: Listener&gt; 	connections	&lt;SharedRegistry key: IPSocketAddress value: Connection&gt; 	responders	&lt;OrderedCollection of: Responder&gt; 	debugging	&lt;Boolean&gt; 	id	&lt;String&gt; server id used as a key in the server registry	logs &lt;Collection of AnnouncementLogger&gt; The log can be set or created by class instance variable #logFactory. Sending #logging: true adds the server to the log announcers and starts sending server announcements to the log . Sending #logging: false will remove the server from the log announcers and stops sending server announcements to the log. 	noResponderReply &lt;BlockClosure&gt; the block is called to create an Http response if there is no responder found to process a request Class Instance Variables	logFactory &lt;BlockClosure&gt; by default the block produces CommonLog with the file name as &lt;serverID&gt;.log	autoRestart &lt;Boolean&gt;  This setting controls how the server reacts to image startup, whether it should automatically start or not.	noResponderReply &lt;BlockClosure&gt; the default block to create no responder reply	configurationFileName &lt;String&gt; the default file name to save the server configuration. 	importErrorsFilename &lt;String&gt; the file with this name is created if there are errors while loading server configuration from xml file. By default the name is "ErrorsLoadingServerConfiguration.log"Shared Variables	Registry	&lt;Dictionary key: String value: Server&gt; manages all active servers	RootDirectory &lt;Filename&gt; the server root directory 	ConfigDirectory &lt;Filename&gt; configuration files directory is relative to the server root directory	LogDirectory &lt;Filename&gt; the logs directory is relative to the server root directory	</body></comment><class><name>RequestReceived</name><environment>SiouX</environment><super>SiouX.RequestAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.RequestReceived</class-id><body>Announces that a server received a request</body></comment><class><name>ResponseSendingFailed</name><environment>SiouX</environment><super>SiouX.ResponseAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>exception </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ResponseSendingFailed</class-id><body>Announces that writing a response into a socket connection has failed. The connection will be closed.Instance Variables	exception	&lt;Exception&gt;</body></comment><class><name>ServerSystem</name><environment>SiouX</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Core.*			Kernel.*			</imports><category></category><attributes><package>SiouX-Server</package></attributes></class><comment><class-id>SiouX.ServerSystem</class-id><body>ServerSystem activates and captures the suspension state of Web servers on image snapshot. On image shutdown running servers will be stopped and on startup the servers will be restarted if ServerSystem.AutoRestart option is set on.Shared Variables	AutoRestart &lt;Boolean&gt;  This setting controls how the server reacts to image startup, whether it should automatically start or not.	ActiveServers &lt;OrderedCollection&gt; active servers</body></comment><class><name>ConnectionAcceptanceThrottled</name><environment>SiouX</environment><super>SiouX.ListenerAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ConnectionAcceptanceThrottled</class-id><body>Announces that a listener is starting to throttle the rate of acceptaning new connections (the lowerConnectionLimit has been reached).  Note that the handlers of these announcements will run within the individual listener processes.</body></comment><class><name>ListenerStarted</name><environment>SiouX</environment><super>SiouX.ListenerAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ListenerStarted</class-id><body>ListenerStarted is annonced when a Listener has been started </body></comment><class><name>ListenerAdded</name><environment>SiouX</environment><super>SiouX.ListenerAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ListenerAdded</class-id><body>ListenerAdded is annonced when a Listener has been added to a server.</body></comment><class><name>ErrorLog</name><environment>SiouX</environment><super>SiouX.StreamLogger</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.OSHandle			private Xtreams.*			</imports><category></category><attributes><package>SiouX-Loggers</package></attributes></class><comment><class-id>SiouX.ErrorLog</class-id><body>The class logs server errors. The error log includes the error stackUsage	logger := ErrorLog log: server.	logger start.	[Net.HttpClient get: 'http://localhost:8000/error'] on: Net.HttpServerError do: [ :ex |].	logger stop.	logger file contentsOfEntireFile inspectA log example:##Start:  [10/Sep/2013:15:41:44 -0400] [10/Sep/2013:15:41:44 -0400] 127.0.0.1:8000 "GET /error HTTP/1.1" RequestExecutionFailed: Responder error ---------------- Start Exception stack -------------------SiouX.Hello(Object)&gt;&gt;error:SiouX.Hello&gt;&gt;executeRequest:connection:[] in SiouX.Hello(SiouX.Responder)&gt;&gt;dispatchRequest:method:version:connection:BlockClosure&gt;&gt;on:do:SiouX.Hello(SiouX.Responder)&gt;&gt;dispatchRequest:method:version:connection:optimized [] in SiouX.Server&gt;&gt;dispatchRequest:method:version:connection:</body></comment><class><name>ConnectionAcceptanceSuspended</name><environment>SiouX</environment><super>SiouX.ListenerAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ConnectionAcceptanceSuspended</class-id><body>Announces that a listener is stopping to accept new connections (due to reaching the upperConnectionLimit).  Note that the handlers of these announcements will run within the individual listener processes.</body></comment><class><name>LoadingServerConfig</name><environment>SiouX</environment><super>SiouX.ServerAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.LoadingServerConfig</class-id><body>LoadingServerConfig announcements are generated when Server handles errors while loading a configuration file.  Instance Variables	stream	&lt;Stream&gt;	stream includes error description</body></comment><class><name>ResponseReady</name><environment>SiouX</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Server</package></attributes></class><comment><class-id>SiouX.ResponseReady</class-id><body>ResponseReady is a Notification exception that is to be signalled when a response has been built and no more processing is necessary.</body></comment><class><name>ServerAdded</name><environment>SiouX</environment><super>SiouX.ServerAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>server </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ServerAdded</class-id><body>ServerAdded will be announced when a Server is added to the system.Instance Variables:	server	&lt;Server&gt;	description of server</body></comment><class><name>RequestLine</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method path version connection decodedPath url </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.*			</imports><category></category><attributes><package>SiouX-Server</package></attributes></class><comment><class-id>SiouX.RequestLine</class-id><body>RequestLine represents parsed Http request status lineInstance Variables	connection	&lt;HttpConnection&gt;		method	&lt;String&gt;	Http method	path	&lt;String&gt;	request url path	version	&lt;String&gt;	Http version	decodedPath &lt;String&gt; decoded path</body></comment><class><name>Responder</name><environment>SiouX</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>server exceptionPrinter path requestFilters url decodedPath </inst-vars><class-inst-vars>exceptionPrinter </class-inst-vars><imports>			private OS.*			</imports><category></category><attributes><package>SiouX-Server</package></attributes></class><comment><class-id>SiouX.Responder</class-id><body>Responder receives a callback with the contents of an incoming request status line (method, url path, protocol version) and decides if it wants to handle it or not. If it is not interested, it returns false from the callback and the request goes to the next Responder in line. If the Responder decides to handle a request, it takes over the connection (for that request only), reads the request in, executes it and sends a response back. This class is abstract, but it lays out the basic structure of this process. Note that a Responder may be handling requests from multiple Connections concurrently, therefore any request specific state MUST be handled in a thread safe manner, specifically Responder instance variables ARE NOT thread-safe unless specific precautions are taken. See the comments in the various subclass responsibility methods for more details.Instance Variables	server	&lt;Server&gt; 	exceptionPrinter	&lt;BlockClosure&gt; generates an error response for given exception	path	&lt;String&gt; the url path prefix for this responder (used to match against the incoming request)	requestFilters &lt;RequestFilter&gt; a collection of filters that can be applied to a Request in the context of a specific Responder Class Instance Variables	exceptionPrinter	&lt;Object&gt; generates an error response for given exception (default printer)	contextClass &lt;RequestContext&gt; a default request context class </body></comment><class><name>RequestStatusLineTooLarge</name><environment>SiouX</environment><super>SiouX.RequestAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>statusLine </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.RequestStatusLineTooLarge</class-id><body>The announcement is sent when request status line size exceeds the number specified by Listener.RequestStatusLineLimitInstance Variables	statusLine	&lt;String&gt; a request status line </body></comment><class><name>ResponderAnnouncement</name><environment>SiouX</environment><super>SiouX.ServerAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>responder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ResponderAnnouncement</class-id><body>The class is superclass for responder announcementsInstance Variables	responder	&lt;Responder&gt;	description of responder</body></comment><class><name>ResponderRemoved</name><environment>SiouX</environment><super>SiouX.ResponderAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ResponderRemoved</class-id><body>ResponderAdded is announced when a Responder has been removed from a server.</body></comment><class><name>ResponseSent</name><environment>SiouX</environment><super>SiouX.ResponseAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>size </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ResponseSent</class-id><body>Announces that a response was sent successfully.Instance Variables	size	&lt;SmalltaInteger&gt; response body size in bytes</body></comment><class><name>ConnectionClosed</name><environment>SiouX</environment><super>SiouX.ConnectionAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ConnectionClosed</class-id><body>Announces that a connection is closed.</body></comment><class><name>CommonLog</name><environment>SiouX</environment><super>SiouX.StreamLogger</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestTimestamps </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.OSHandle			private Xtreams.*			</imports><category></category><attributes><package>SiouX-Loggers</package></attributes></class><comment><class-id>SiouX.CommonLog</class-id><body>This class implements the 'Common Log Format', also known as the 'NCSA Common log format', which is a popular text file log format used by a number of web servers. Instance Variables	requestTimestamps	&lt;IdentityDictionary key: HttpRequest value: Timestamp&gt; tracks when requests are received.ImplementationThe common log file format logs one line for each completed request, where the line has following structure:	    remotehost ident authuser [date] "request" status bytesThe individual fields of the line have following meaning:remotehost - Remote hostname or IP address if DNS hostname is not available ident - The remote logname of the user (RFC#931)authuser - The username the client used to authenticate itself. [date] - Date and time of the request. %d/%b/%Y:%H:%M:%S %z"request" - The request line exactly as it came from the client. status - The HTTP response status code returned to the client. bytes - The byte length of the response (without the header)Here's a sample line of a log, a hyphen "-" in place of a field is used to indicate missing information:127.0.0.1 - frank [10/Oct/2000:13:55:36 -0700] "GET /apache_pb.gif HTTP/1.0" 200 2326For more information about the format see:http://www.w3.org/Daemon/User/Config/Logging.html#common-logfile-formathttp://en.wikipedia.org/wiki/Common_Log_Formathttp://httpd.apache.org/docs/2.2/logs.html#commonUsageConsider creating a server with the logger:	(server := Server new)		listenOn: 8000 for: HttpConnection;		addResponder: Hello new.	logger := CommonLog announcers: server.	logger file: 'myServer.log' asFilename.	[	logger start.		server start.....	] ensure: [		logger stop.		server release.]A log example:##Start: [11/Sep/2013:11:33:24 -0400]127.0.0.1:52474 - - [11/Sep/2013:11:33:24 -0400] "GET / HTTP/1.1" 200 47##Stop: [11/Sep/2013:11:33:24 -0400]</body></comment><class><name>ResponderNotFound</name><environment>SiouX</environment><super>SiouX.ConnectionAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>request </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ResponderNotFound</class-id><body>A responder for a request was not found, a "not found" response (404) was sent.Instance Variables	request	&lt;HttpRequest&gt; </body></comment><class><name>ServerStoppingAnnouncement</name><environment>SiouX</environment><super>SiouX.ServerAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ServerStoppingAnnouncement</class-id><body>Announced when a server stops all listeners</body></comment><class><name>RequestHeaderExceededSizeLimit</name><environment>SiouX</environment><super>SiouX.RequestAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.RequestHeaderExceededSizeLimit</class-id><body>Announced when a request header size exceeds a limit. The default limit is defined by the listener setting #requestHeaderLimitDefault as 1024 * 100</body></comment><class><name>ResponderAdded</name><environment>SiouX</environment><super>SiouX.ResponderAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ResponderAdded</class-id><body>ResponderAdded is announced when a Responder has been added to a server.</body></comment><class><name>ServerRemoved</name><environment>SiouX</environment><super>SiouX.ServerAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>server </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ServerRemoved</class-id><body>ServerRemoved will be announced when a Server is removed from the system.Instance Variables:	server	&lt;Server&gt;	description of server</body></comment><class><name>StatusUpdate</name><environment>SiouX</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>statistics </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Loggers</package></attributes></class><comment><class-id>SiouX.StatusUpdate</class-id><body>The class is an announcement with server staticticsInstance Variables	statistics	&lt;Dictionary&gt; server statistics</body></comment><class><name>ConnectionFailed</name><environment>SiouX</environment><super>SiouX.ConnectionAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>exception </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ConnectionFailed</class-id><body>These announcements are generated for non-specific connection errors. The connection will be closed after this.Instance Variables	exception	&lt;Error&gt; error</body></comment><class><name>RequestContext</name><environment>SiouX</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>responder connection request response data properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Server</package></attributes></class><comment><class-id>SiouX.RequestContext</class-id><body>RequestContext represents a collection of objects that need to work together in a single request/response cycle.Instance Variables	connection	&lt;HttpConnection | WebSocketConnection&gt;	a connection object for which the context is created	data	&lt;Object&gt;	variable to store arbitrary data by responders etc. 	request	&lt;SiouX.HttpRequest | Net.HttpRequest&gt;	the request object	responder	&lt;Responder&gt;	a responder that created the context	response	&lt;SiouX.HttpResponse | Net.HttpResponse&gt;	the response object	properties &lt;Dictionary&gt;</body></comment><class><name>RequestExecutionFailed</name><environment>SiouX</environment><super>SiouX.RequestAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>responder exception </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.RequestExecutionFailed</class-id><body>Announced when execution of a request failed to produce a response (an error response will be generated automatically by the configured exceptionPrinter).Instance Variables	responder	&lt;Responder&gt; 	exception	&lt;Exception&gt; </body></comment><class><name>ConnectionOpened</name><environment>SiouX</environment><super>SiouX.ConnectionAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SiouX-Announcements</package></attributes></class><comment><class-id>SiouX.ConnectionOpened</class-id><body>Announces that a connection was opened.</body></comment><shared-variable><name>ActiveServers</name><environment>SiouX.ServerSystem</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>OrderedCollection new</initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>AutoRestart</name><environment>SiouX.ServerSystem</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>true</initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>ConfigDirectory</name><environment>SiouX.Server</environment><private>false</private><constant>false</constant><category>registry</category><initializer></initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>LogDirectory</name><environment>SiouX.Server</environment><private>false</private><constant>false</constant><category>registry</category><initializer></initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>Registry</name><environment>SiouX.Server</environment><private>false</private><constant>false</constant><category>registry</category><initializer>Dictionary new</initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>RootDirectory</name><environment>SiouX.Server</environment><private>false</private><constant>false</constant><category>registry</category><initializer></initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>MySubscriptions</name><environment>SiouX.Server</environment><private>false</private><constant>false</constant><category>registry</category><initializer></initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>ConnectionTimeout</name><environment>SiouX.Listener</environment><private>false</private><constant>false</constant><category>configuration</category><initializer>nil</initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>BacklogSize</name><environment>SiouX.Listener</environment><private>false</private><constant>false</constant><category>configuration</category><initializer>nil</initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>MaxAcceptDelay</name><environment>SiouX.Listener</environment><private>false</private><constant>false</constant><category>configuration</category><initializer>100 milliseconds</initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>UpperConnectionLimit</name><environment>SiouX.Listener</environment><private>false</private><constant>false</constant><category>configuration</category><initializer>nil</initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>ListenerPriority</name><environment>SiouX.Listener</environment><private>false</private><constant>false</constant><category>configuration</category><initializer>nil</initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>LowerConnectionLimit</name><environment>SiouX.Listener</environment><private>false</private><constant>false</constant><category>configuration</category><initializer>nil</initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>ReuseAddress</name><environment>SiouX.Listener</environment><private>false</private><constant>false</constant><category>configuration</category><initializer>true</initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>ConnectionPriority</name><environment>SiouX.Listener</environment><private>false</private><constant>false</constant><category>configuration</category><initializer>nil</initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>LATIN1</name><environment>SiouX</environment><private>false</private><constant>false</constant><category>constants</category><initializer>'ISO-8859-1'</initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>WHITESPACE</name><environment>SiouX</environment><private>false</private><constant>true</constant><category>constants</category><initializer>String with: Character space with: Character tab</initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>MSCP1252</name><environment>SiouX</environment><private>false</private><constant>false</constant><category>constants</category><initializer>'windows-1252'</initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>CR</name><environment>SiouX</environment><private>false</private><constant>true</constant><category>constants</category><initializer>Character cr</initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>UTF8</name><environment>SiouX</environment><private>false</private><constant>false</constant><category>constants</category><initializer>'utf-8'</initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>SPACE</name><environment>SiouX</environment><private>false</private><constant>true</constant><category>constants</category><initializer>Character space</initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>ServerErrors</name><environment>SiouX</environment><private>false</private><constant>false</constant><category>constants</category><initializer>ListenerFailed , ResponderNotFound , ResponseSendingFailed	, RequestExecutionFailed , ConnectionFailed	, RequestStatusLineTooLarge</initializer><attributes><package>SiouX-Announcements</package></attributes></shared-variable><shared-variable><name>TAB</name><environment>SiouX</environment><private>false</private><constant>true</constant><category>constants</category><initializer>Character tab</initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>RequestHeaderLimit</name><environment>SiouX.HttpListener</environment><private>false</private><constant>false</constant><category>configuration</category><initializer>nil</initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>RequestBodyLimit</name><environment>SiouX.HttpListener</environment><private>false</private><constant>false</constant><category>configuration</category><initializer>nil</initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>RequestStatusLineLimit</name><environment>SiouX.HttpListener</environment><private>false</private><constant>false</constant><category>configuration</category><initializer>nil</initializer><attributes><package>SiouX-Server</package></attributes></shared-variable><shared-variable><name>ServerHeader</name><environment>SiouX.HttpConnection</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>SiouX-Server</package></attributes></shared-variable><methods><class-id>SiouX.Listener</class-id> <category>private</category><body package="SiouX-Server">connectionDelayFor: anInteger"When approaching the limit, slow down the rate at which we accept. The closer we get to the maximum, the longer we wait, grouped into buckets.So, for example, if our upper limit is 200, our lower limit is 100, our maximum delay is 10ms, and we have just created our 125th connection, then we will wait for 2.5ms."	| maxHeadroom delay headroom headroomPercentage |	headroom := self upperConnectionLimit - anInteger.	maxHeadroom := self upperConnectionLimit		- self lowerConnectionLimit.	headroomPercentage := (1 - (headroom asFloat / maxHeadroom asFloat)).	delay := (1 max: (self maxAcceptDelay asMilliseconds * headroomPercentage) rounded ) milliseconds.	^delay.</body><body package="SiouX-Server">handleConnection: aSocket 		[	(self connectionClass on: aSocket listener: self) open	] ifCurtailed: [ aSocket close ]</body><body package="SiouX-Server">handleListenerError: anError	server listenerError: anError from: self.	"This is a somewhat crude measure but seems to help for Wave servers.	We need to be at least as good, so let's emulate that for now."	(OsNoResourcesError handles: anError) ifTrue: [		(Delay forMilliseconds: 250) wait ]</body><body package="SiouX-Server">listenerProcessBody	[	self isRunning	] whileTrue: [		[	(self connectionClass on: socket accept listener: self) open		]	on: Error			do: [ :ex |				self handleListenerError: ex ].		suspend ifTrue: [			process suspend.			suspend := false ] ]</body><body package="SiouX-Server">resumeListenerProcess		"We have to make sure that the process is suspended otherwise #resume signals a primitive failure.	This is never sent from the listener process so	Processor activeProcess ~= listenerProcess is not necessary"	self isSuspended ifTrue: [		suspend := false.		process resume ]</body><body package="SiouX-Server">startListenerProcess	process ifNil: [		suspend := false.		process := [ self listenerProcessBody ] forkAt: self listenerPriority ]</body><body package="SiouX-Server">stopListenerProcess	process ifNotNil: [		Processor activeProcess = process ifFalse: [			"If stop runs from a listener event we don't want to terminate ourselves.			Let stop close the socket and the listener process will exit normally on next iteration."			process terminate ].		process := nil ]</body><body package="SiouX-Server">suspendListenerProcess	"This is invoked from the listener process itself during the process of adding a new connection.	We can't suspend the process until the connection addition is complete, so let's just raise a flag	to suspend the process at a more appropriate point"	suspend := true</body><body package="SiouX-Server">throttleConnectionAcceptance	"Once we get to into the limit zone, we'll gradually start slowing down the accept rate up to the maxAcceptDelay	based on how close we are to the upper limit"	self maxAcceptDelay isZero ifFalse: [ | duration |		duration := self connectionDelayFor: connectionCount.		(Delay for: duration) wait ]</body></methods><methods><class-id>SiouX.Listener</class-id> <category>testing</category><body package="SiouX-Server">isRunning	^socket notNil</body><body package="SiouX-Server">isSuspended	^process notNil and: [ process isSuspended ]</body></methods><methods><class-id>SiouX.Listener</class-id> <category>accessing</category><body package="SiouX-Server">address	^address</body><body package="SiouX-Server">address: ipAddress"Note that changing the address will not take effect until the listener is restarted.	ipAddress &lt;IPSocketAddress&gt; address to bind the listening socket to"	address := ipAddress</body><body package="SiouX-Server">connectionClass	^self class connectionClass</body><body package="SiouX-Server">connectionCount	^connectionCount</body><body package="SiouX-Server">hostAddress	| stream | 	stream := WriteStream on: String new.	address hostAddress do: [ :x | stream print: x ] separatedBy: [ stream nextPut: $. ].	^stream contents</body><body package="SiouX-Server">hostAndPortString	| stream |	stream := WriteStream on: String new.	self printHostAndPortOn: stream.	^stream contents</body><body package="SiouX-Server">port		^address port</body><body package="SiouX-Server">server	^server</body></methods><methods><class-id>SiouX.Listener</class-id> <category>connection notifications</category><body package="SiouX-Server">closingConnection: aConnection	| nr |	(nr := connectionCount + 1) &gt;= self lowerConnectionLimit		ifTrue: [ 	nr = self upperConnectionLimit ifTrue: [					"We've just resumed acceptance of connections"					server announce: (ConnectionAcceptanceResumed listener: self) ]. ]		ifFalse: [ nr = self lowerConnectionLimit ifTrue: [					"We're stopping to throttle connection acceptance."					server announce: (ConnectionAcceptanceUnthrottled listener: self) ] ].	server closingConnection: aConnection listener: self.</body><body package="SiouX-Server">decrementConnectionCount"This always runs in the context of some connection process, it is IMPORTANT that it is protected by the connection registry."	connectionCount := connectionCount - 1.	self resumeListenerProcess</body><body package="SiouX-Server">incrementConnectionCount"This always runs in the context of some connection process, it is IMPORTANT that it is protected by the connection registry."	connectionCount := connectionCount + 1.	(connectionCount = self upperConnectionLimit) ifTrue: [ self suspendListenerProcess  ]</body><body package="SiouX-Server">openingConnection: aConnection	| nr |	(nr := connectionCount + 1) &lt; self upperConnectionLimit		ifTrue: [ nr &lt; self lowerConnectionLimit				ifFalse: [	 					connectionCount = self lowerConnectionLimit ifTrue: [						"We're starting to throttle connection acceptance"						server announce: (ConnectionAcceptanceThrottled listener: self) ]. 					self throttleConnectionAcceptance ] ] 		ifFalse: [			"We're suspending connection acceptance"			server announce: (ConnectionAcceptanceSuspended listener: self) ].	server openingConnection: aConnection listener: self.</body></methods><methods><class-id>SiouX.Listener</class-id> <category>initialize-release</category><body package="SiouX-Server">on: ipAddress server: aServer	address := ipAddress. 	server := aServer.	connectionCount := 0.</body><body package="SiouX-Server">release	self stop.	server ifNotNil: [		server removeListener: self.		server := nil ].	super release.</body></methods><methods><class-id>SiouX.Listener</class-id> <category>accessing-listener options</category><body package="SiouX-Server">backlogSize	^backlogSize ifNil: [ self class backlogSize ]</body><body package="SiouX-Server">backlogSize: size"	size &lt;SmallInteger&gt; size of the TCP listening backlog"	backlogSize := size</body><body package="SiouX-Server">listenerPriority	^listenerPriority ifNil: [ self class listenerPriority ]</body><body package="SiouX-Server">listenerPriority: priority"	priority &lt;SmallInteger&gt; listener process priority"	listenerPriority := priority</body><body package="SiouX-Server">reuseAddress	^reuseAddress ifNil: [ ReuseAddress ]</body><body package="SiouX-Server">reuseAddress: should"Note that changing the flag will not take effect until the listener is restarted.	should &lt;Boolean&gt; should the SO_REUSEADDR option be set on the socket"	reuseAddress := should</body></methods><methods><class-id>SiouX.Listener</class-id> <category>accessing-connection options</category><body package="SiouX-Server">connectionPriority	^connectionPriority ifNil: [ self class connectionPriority ]</body><body package="SiouX-Server">connectionPriority: priority"	priority &lt;SmallInteger&gt; connection process priority"	connectionPriority := priority</body><body package="SiouX-Server">connectionTimeout	^connectionTimeout ifNil: [ self class connectionTimeout ].</body><body package="SiouX-Server">connectionTimeout: timeout"	timeout &lt;Duration&gt; how long can a connection idle before it is closed by the server"	connectionTimeout := timeout</body><body package="SiouX-Server">lowerConnectionLimit	^lowerConnectionLimit ifNil: [ self class lowerConnectionLimit ]</body><body package="SiouX-Server">lowerConnectionLimit: limit"	limit &lt;SmallInteger&gt; when connectionCount crosses this threshold, we'll start throttling the acceptance rate"	lowerConnectionLimit := limit</body><body package="SiouX-Server">maxAcceptDelay	^maxAcceptDelay ifNil: [ self class maxAcceptDelay ]</body><body package="SiouX-Server">maxAcceptDelay: delay"	delay &lt;Duration&gt; maximum delay when throttling connection acceptance"	maxAcceptDelay := delay</body><body package="SiouX-Server">upperConnectionLimit	^upperConnectionLimit ifNil: [ self class upperConnectionLimit ]</body><body package="SiouX-Server">upperConnectionLimit: limit"	limit &lt;Object&gt; when connectionCount crosses this threshold, we'll suspend the listener process"	upperConnectionLimit := limit</body></methods><methods><class-id>SiouX.Listener</class-id> <category>persistence</category><body package="SiouX-Server">addXmlElementsTo: anElement		#('connectionTimeout' 'maxAcceptDelay' ) do: [ :parameter | 		 (self instVarNamed: parameter) ifNotNil: [ :value |			 anElement addNode: 					((XML.Element tag: parameter asString) addNode: ( XML.Text text: value asMilliseconds printString))]]. 	#('reuseAddress' 'backlogSize' 'listenerPriority' 'connectionPriority' 'lowerConnectionLimit' 'upperConnectionLimit' 'requestHeaderLimit'  'requestStatusLineLimit')  		do: [ :parameter | 			(self instVarNamed: parameter ) ifNotNil: [ :value |			 anElement addNode: ((XML.Element tag: parameter asString) addNode: ( XML.Text text: value printString)) ]].</body><body package="SiouX-Server">asXmlNode	| root |	root := XML.Element 		tag: 'listener' 		elements: nil.	root addAttribute:  (XML.Attribute name: 'class' value: self class fullName ).	root addAttribute: (XML.Attribute name: 'hostAddress' value: self hostAddress ).	root addAttribute: (XML.Attribute name: 'port' value: self port printString ).	root addAttribute: (XML.Attribute name: 'running' value: self isRunning printString ).	self addXmlElementsTo: root.	^root</body><body package="SiouX-Server">importSnapshot: anElement	anElement realElements do: [ :node |		self restoreValueFrom: node data: node characterData ]</body><body package="SiouX-Server">restoreValueFrom: aNode data: data	|  value |	'reuseAddress' = aNode tag type ifTrue: [ value := Boolean readFrom: data readStream ].	(#('connectionTimeout' 'maxAcceptDelay' ) includes: aNode tag type)		ifTrue: [value := Duration fromMilliseconds: data asNumber ].	(#('backlogSize' 'listenerPriority' 'connectionPriority' 'lowerConnectionLimit' 'upperConnectionLimit' 'requestHeaderLimit'  'requestStatusLineLimit' ) includes: aNode tag type)		ifTrue: [ value := data asNumber ].	value ifNotNil: [ self instVarNamed: aNode tag type put: value ]</body></methods><methods><class-id>SiouX.Listener</class-id> <category>services</category><body package="SiouX-Server">start	self isRunning ifTrue: [ ^self ].	socket := SocketAccessor			family: address domainCode			type: SocketAccessor SOCK_STREAM.	socket otReuseAddress: self reuseAddress.	[	socket			bindTo: address;			listenFor: self backlogSize.		address port isZero ifTrue: [			address := socket getName ].		self startListenerProcess	] ifCurtailed: [ socket close. socket := nil ].	self server listenerStarted: self.</body><body package="SiouX-Server">stop	self isRunning ifFalse: [ ^self ].	[		self stopListenerProcess.		socket ifNotNil: [			socket close.			socket := nil.		self server listenerStopped: self.].	] on: Error		do: 			[:ex |			(Error new)				messageText: (#Listener1sFailedToStop &lt;&lt;#www &gt;&gt;'Listener at [&lt;1s&gt;] failed to stop!'							expandMacrosWith: self hostAndPortString);				parameter: self;				raise].</body></methods><methods><class-id>SiouX.Listener</class-id> <category>printing</category><body package="SiouX-Server">printHostAndPortOn: aStream	| hp |	hp := socket ifNil: [ address ifNil: [^self] ] ifNotNil: [ socket getName ].	hp printBytesOn: aStream.</body><body package="SiouX-Server">printOn: aStream	aStream		nextPutAll: 'Listen on: ', self connectionClass name;		nextPut: $[;		print: connectionCount;		nextPut: $];		space.	self printHostAndPortOn: aStream.	self isRunning ifTrue: [aStream nextPut: $*]</body></methods><methods><class-id>SiouX.Listener class</class-id> <category>instance creation</category><body package="SiouX-Server">on: ipAddress server: aServer	^self new on: ipAddress server: aServer</body></methods><methods><class-id>SiouX.Listener class</class-id> <category>accessing</category><body package="SiouX-Server">connectionClass	^self subclassResponsibility</body><body package="SiouX-Server">connectionPriorityHelp	^#connectionPriorityHelp &lt;&lt; #www &gt;&gt;'There is a connection process created for each established connection. The connection process reads incoming requests from the connection socket, builds a Http Request from it (further parsing form some header fields and such). Finally it spawns a worker process that will "execute" the incoming Http Request.Tuning this priority (relative to worker process and listener process priorities) allows to put emphasis on different aspects of the request processing. If it is more important to accept new connections than serve the existing ones, then the listener priority should be higher. If you want requests being processed faster than new ones being received, then worker priority needs to go up, etc. Note however that it is very easy to starve other activities if you give too much priority to something that takes a lot of effort. You need to tune the priorities to the particular needs of your specific application, the load patterns that you expect, the amount of effort it takes to complete each request, etc. It may take several attempts to get it right.When this setting is changed, the new value applies only to new connections established after that point.'</body><body package="SiouX-Server">connectionTimeoutHelp	^#connectionTimeoutHelp &lt;&lt; #www &gt;&gt; 'How long should we wait before terminating an idle connection. The value is in milliseconds.'</body><body package="SiouX-Server">listenerBacklogHelp	^#listenerBacklogHelp &lt;&lt; #www &gt;&gt; 'The size of the TCP listening backlog. What should the listener backlog be? This determines (depending on how the operating system treats it) the maximum number of incoming socket connections waiting for an accept'</body><body package="SiouX-Server">listenerPriorityHelp	^#listenerPriorityHelp &lt;&lt; #www &gt;&gt; 'The server runs a single listener process. The listener process waits for incoming connection requests, and accepts them establishing a new connection. It then creates a new Transport object with a dedicated server process which will manage the newly established connection. Tuning this priority (relative to server process and worker process priorities) allows to put emphasis on different aspects of request processing.'</body><body package="SiouX-Server">lowerConnectionLimitHelp	^#lowerConnectionLimitHelp &lt;&lt; #www &gt;&gt; 'This setting specifies the lower threshold on the number of concurrent connections. When the number reaches this value, the server starts considering itself to be getting overloaded. Above this value it will start slowing down the rate at which new connections are accepted by delaying the listener after each accept, ultimately reaching the maximum delay listed in the settings. If the server reaches the maximum number of connections, it will shut off the listener entirely and not resume it until the number of connections drops below this setting. For example if the maximum limit was 100 and we set this to 90, then when we reach 100 simultaneous connections, all new connections would be held until we had closed 10 of the active connections, reaching the lower connection limit of 90.'</body><body package="SiouX-Server">maximumAcceptanceDelayHelp	^#maximumAcceptanceDelayHelp &lt;&lt; #www &gt;&gt; 'As the load on the server (the number of concurrent connections) increases above the lower connection limit we start delaying acceptance of new connections. This delay increases linearly as we approach the maximum number of connections. Note that the resolution of the timers available on the server operating system may affect the actual delays. The value is in milliseconds.'</body><body package="SiouX-Server">upperConnectionLimitHelp	^#upperConnectionLimitHelp &lt;&lt; #www &gt;&gt; 'This is the maximum number of connections we will allow simultaneously. Note that some operating systems may limit us to a maximum of 1024, regardless of this setting. The more work your processes are likely to do for each incoming request, the lower you''re likely to want this setting'</body></methods><methods><class-id>SiouX.Listener class</class-id> <category>default values</category><body package="SiouX-Server">backlogSizeDefault	^128</body><body package="SiouX-Server">connectionPriorityDefault	^Processor userSchedulingPriority - 10</body><body package="SiouX-Server">connectionTimeoutDefault	^5 minutes</body><body package="SiouX-Server">listenerPriorityDefault	^Processor userInterruptPriority - 10</body><body package="SiouX-Server">lowerConnectionLimitDefault	^900</body><body package="SiouX-Server">maxAcceptDelayDefault	^100 milliseconds</body><body package="SiouX-Server">upperConnectionLimitDefault	^1000</body></methods><methods><class-id>SiouX.Listener class</class-id> <category>defaults</category><body package="SiouX-Server">backlogSize	^BacklogSize ifNil: [ BacklogSize := self backlogSizeDefault ]</body><body package="SiouX-Server">backlogSize: aNumber	BacklogSize := aNumber</body><body package="SiouX-Server">connectionPriority	^ConnectionPriority ifNil: [ConnectionPriority := self connectionPriorityDefault ]</body><body package="SiouX-Server">connectionTimeout	^ConnectionTimeout ifNil: [ ConnectionTimeout := self connectionTimeoutDefault ]</body><body package="SiouX-Server">connectionTimeout: aDuration	ConnectionTimeout := aDuration</body><body package="SiouX-Server">connectionTimeoutMs	^self connectionTimeout asMilliseconds</body><body package="SiouX-Server">connectionTimeoutMs: aMilliseconds	self connectionTimeout: (Duration fromMilliseconds: aMilliseconds )</body><body package="SiouX-Server">listenerPriority	^ListenerPriority ifNil: [ListenerPriority := self listenerPriorityDefault ]</body><body package="SiouX-Server">listenerPriority: aNumber	ListenerPriority := aNumber</body><body package="SiouX-Server">lowerConnectionLimit	^LowerConnectionLimit ifNil: [ LowerConnectionLimit := self lowerConnectionLimitDefault]</body><body package="SiouX-Server">lowerConnectionLimit: aNumber	LowerConnectionLimit := aNumber</body><body package="SiouX-Server">maxAcceptDelay	^MaxAcceptDelay  ifNil: [ MaxAcceptDelay := self maxAcceptDelayDefault ]</body><body package="SiouX-Server">maxAcceptDelay: aDuration	MaxAcceptDelay := aDuration</body><body package="SiouX-Server">maxAcceptDelayMs	^self maxAcceptDelay asMilliseconds</body><body package="SiouX-Server">maxAcceptDelayMs: aMilliseconds	^self maxAcceptDelay: (Duration fromMilliseconds: aMilliseconds )</body><body package="SiouX-Server">upperConnectionLimit	^UpperConnectionLimit ifNil: [ UpperConnectionLimit := self upperConnectionLimitDefault]</body><body package="SiouX-Server">upperConnectionLimit: aNumber	UpperConnectionLimit := aNumber</body></methods><methods><class-id>SiouX.HttpListener</class-id> <category>accessing</category><body package="SiouX-Server">acceptedServerNames	^acceptedServerNames ifNil: [acceptedServerNames := #()]</body><body package="SiouX-Server">acceptedServerNames: anArray	acceptedServerNames := anArray</body><body package="SiouX-Server">exceptionPrinter	^exceptionPrinter ifNil: [ self class exceptionPrinter ]</body><body package="SiouX-Server">exceptionPrinter: aBlock	exceptionPrinter := aBlock</body><body package="SiouX-Server">persist	^persist ifNil: [ self class persist ]</body><body package="SiouX-Server">persist: aBoolean	persist := aBoolean</body><body package="SiouX-Server">protocolVersions	^protocolVersions ifNil: [ protocolVersions := self class protocolVersions ]</body><body package="SiouX-Server">protocolVersions: anArray	protocolVersions := anArray</body></methods><methods><class-id>SiouX.HttpListener</class-id> <category>accessing-listener options</category><body package="SiouX-Server">requestBodyLimit	^requestBodyLimit ifNil: [ self class requestBodyLimit ]</body><body package="SiouX-Server">requestBodyLimit: aNumber	requestBodyLimit := (aNumber = 0 ifTrue: [nil ] ifFalse: [aNumber])</body><body package="SiouX-Server">requestHeaderLimit	^requestHeaderLimit ifNil: [ self class requestHeaderLimit ]</body><body package="SiouX-Server">requestHeaderLimit: aNumber 	requestHeaderLimit := aNumber</body><body package="SiouX-Server">requestStatusLineLimit	^requestStatusLineLimit ifNil: [ self class requestStatusLineLimit ]</body><body package="SiouX-Server">requestStatusLineLimit: aNumber 	requestStatusLineLimit := aNumber</body></methods><methods><class-id>SiouX.HttpListener class</class-id> <category>accessing</category><body package="SiouX-Server">connectionClass	^HttpConnection</body><body package="SiouX-Server">requestBodyLimitHelp	^#RequestBodySizeLimitHelp &lt;&lt; #www &gt;&gt; 'This is the maximum number of bytes that the request body can have. If it is not defined or 0 there is no size limitation. '</body><body package="SiouX-Server">requestHeaderLimitHelp	^#RequestHeaderLimitHelp &lt;&lt; #www &gt;&gt; 'This is the maximum number of bytes that the request header can have.'</body><body package="SiouX-Server">requestStatusLineLimitHelp	^#RequestStatusLineLimitHelp &lt;&lt; #www &gt;&gt; 'This is the maximum number of bytes that the request status line can have.'</body></methods><methods><class-id>SiouX.HttpListener class</class-id> <category>defaults</category><body package="SiouX-Server">exceptionPrinter	^exceptionPrinter ifNil: [ self defaultExceptionPrinterValue ]</body><body package="SiouX-Server">exceptionPrinter: aBlock	exceptionPrinter := aBlock</body><body package="SiouX-Server">persist	^persist ifNil: [ self defaultPersistValue ]</body><body package="SiouX-Server">persist: aBoolean	persist := aBoolean</body><body package="SiouX-Server">protocolVersions	^protocolVersions ifNil: [ protocolVersions := Array new ]</body><body package="SiouX-Server">protocolVersions: anArray	^protocolVersions := anArray</body><body package="SiouX-Server">requestBodyLimit	^RequestBodyLimit</body><body package="SiouX-Server">requestBodyLimit: aNumber	RequestBodyLimit := (aNumber = 0 ifTrue: [nil ] ifFalse: [aNumber])</body><body package="SiouX-Server">requestHeaderLimit	^RequestHeaderLimit ifNil: [RequestHeaderLimit := self requestHeaderLimitDefault ]</body><body package="SiouX-Server">requestHeaderLimit: aNumber	RequestHeaderLimit := aNumber</body><body package="SiouX-Server">requestStatusLineLimit	^RequestStatusLineLimit ifNil: [RequestStatusLineLimit := self requestStatusLineLimitDefault ]</body><body package="SiouX-Server">requestStatusLineLimit: aNumber	RequestStatusLineLimit := aNumber</body></methods><methods><class-id>SiouX.HttpListener class</class-id> <category>default values</category><body package="SiouX-Server">defaultExceptionPrinterValue	^[ :exception :stream |		stream write: exception description; cr; cr.		exception initialContext reading do: [ :frame | stream print: frame; cr ] ]</body><body package="SiouX-Server">defaultPersistValue	^true</body><body package="SiouX-Server">requestHeaderLimitDefault	^1024 * 100</body><body package="SiouX-Server">requestStatusLineLimitDefault	^1024 * 8</body></methods><methods><class-id>SiouX.ServerAnnouncement</class-id> <category>testing</category><body package="SiouX-Announcements">exception	"Only some of my subclasses have exception. I return nil."	^ nil</body></methods><methods><class-id>SiouX.ListenerAnnouncement</class-id> <category>accessing</category><body package="SiouX-Announcements">listener	^listener</body></methods><methods><class-id>SiouX.ListenerAnnouncement</class-id> <category>initialize-release</category><body package="SiouX-Announcements">listener: aListener	listener := aListener</body></methods><methods><class-id>SiouX.ListenerAnnouncement class</class-id> <category>instance creation</category><body package="SiouX-Announcements">listener: aListener	^self new listener: aListener</body></methods><methods><class-id>SiouX.ConnectionAnnouncement</class-id> <category>accessing</category><body package="SiouX-Announcements">connection	^connection</body><body package="SiouX-Announcements">listener	^connection listener</body></methods><methods><class-id>SiouX.ConnectionAnnouncement</class-id> <category>initialize-release</category><body package="SiouX-Announcements">connection: aConnection	connection := aConnection</body></methods><methods><class-id>SiouX.ConnectionAnnouncement</class-id> <category>printing</category><body package="SiouX-Announcements">printOn: aStream	super printOn: aStream.	connection printOn: aStream</body></methods><methods><class-id>SiouX.ConnectionAnnouncement class</class-id> <category>instance creation</category><body package="SiouX-Announcements">connection: aConnection	^self new connection: aConnection</body></methods><methods><class-id>SiouX.RequestAnnouncement</class-id> <category>accessing</category><body package="SiouX-Announcements">request	^request</body></methods><methods><class-id>SiouX.RequestAnnouncement</class-id> <category>initialize-release</category><body package="SiouX-Announcements">request: anHttpRequest	request := anHttpRequest</body></methods><methods><class-id>SiouX.RequestAnnouncement</class-id> <category>log extensions</category><body package="SiouX-Loggers">logRequestStatusLineOn: aStream"The extension is used by CommonLog and ErrorLog"	self request 		ifNotNil: [ :req | 			aStream put: $".			req printStatusLineOn: aStream.  "The request line from the client is given in double quotes. "			aStream put: $" ]		ifNil: [ aStream put: $- ].</body><body package="SiouX-Loggers">logResponseCodeOn: aStream"The extension is used by CommonLog "	"Skip response "	aStream  write: $-.	"Skip response size " 	aStream put: $-</body></methods><methods><class-id>SiouX.RequestAnnouncement class</class-id> <category>instance creation</category><body package="SiouX-Announcements">request: anHttpRequest connection: aConnection	^(self connection: aConnection)		request: anHttpRequest;		yourself</body></methods><methods><class-id>SiouX.ResponseAnnouncement</class-id> <category>accessing</category><body package="SiouX-Announcements">response	^response</body><body package="SiouX-Announcements">response: anObject	response := anObject</body><body package="SiouX-Announcements">responseCode	response ifNil: [^'-'].	^response code isString 		ifTrue: [response code ] 		ifFalse: [ response code printString ]</body></methods><methods><class-id>SiouX.ResponseAnnouncement</class-id> <category>log extensions</category><body package="SiouX-Loggers">logResponseCodeOn: aStream	response 		ifNil: [ aStream put: $- ]		ifNotNil: [ aStream 					space;					write: self responseCode; "This is the status code that the server sends back to the client"					space ].	"The last part indicates the size of the object returned to the client, not including the response headers. If no content was returned to the client, this value will be - " 	self size 		ifNil: [ aStream put: $- ]		ifNotNil: [ :size | aStream print: size ].</body></methods><methods><class-id>SiouX.ResponsePrepared</class-id> <category>accessing</category><body package="SiouX-Announcements">responder	^responder</body></methods><methods><class-id>SiouX.ResponsePrepared</class-id> <category>initialize-release</category><body package="SiouX-Announcements">request: aRequest response: aResponse responder: aResponder	request := aRequest.	response := aResponse.	responder := aResponder</body></methods><methods><class-id>SiouX.ResponsePrepared</class-id> <category>printing</category><body package="SiouX-Announcements">printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' prepared '.	response printStatusLineOn: aStream</body></methods><methods><class-id>SiouX.ResponsePrepared class</class-id> <category>instance creation</category><body package="SiouX-Announcements">request: request response: response responder: responder connection: aConnection	^(self connection: aConnection)		request: request response: response responder: responder;		yourself</body></methods><methods><class-id>SiouX.ListenerFailed</class-id> <category>accessing</category><body package="SiouX-Announcements">exception	^exception</body><body package="SiouX-Announcements">exception: anObject	exception := anObject</body></methods><methods><class-id>SiouX.ListenerFailed</class-id> <category>printing</category><body package="SiouX-Announcements">printOn: aStream	exception 		ifNil: [ super printOn: aStream ]		ifNotNil: [ aStream nextPutAll: exception description ]</body></methods><methods><class-id>SiouX.ListenerFailed class</class-id> <category>instance creation</category><body package="SiouX-Announcements">exception: anException listener: aListener	^self new		exception: anException;		listener: aListener;		yourself</body></methods><methods><class-id>SiouX.StreamLogger</class-id> <category>services</category><body package="SiouX-Loggers">flush	accessProtect critical: [ self stream flush ]</body></methods><methods><class-id>SiouX.StreamLogger</class-id> <category>private</category><body package="SiouX-Loggers">createNewFilename	| nm ind newFile coll |	nm := (file asString tokensBasedOn: $.) first.	(coll := nm tokensBasedOn: $_) size = 1		ifTrue: [ 	ind := 0 ]		ifFalse: [ ind := coll last asNumber + 1 ].	[nm := coll first, '_', ind printString.	(newFile := (nm, '.log')  asFilename) exists]		whileTrue: [ ind := ind +1 ].	^newFile</body><body package="SiouX-Loggers">initializeStream	file ifNil: [ self error: (#CanntInitializeLoggerStream &lt;&lt; #www &gt;&gt;'Can''t initialize the logger stream')].	[stream :=  file appending 				buffering: self bufferSize; 				encoding: #utf8.	] on: OsInaccessibleError do: [ :ex | 			file := self createNewFilename.			ex  retry].</body><body package="SiouX-Loggers">logNewLine	"Using the ByteString trick on a binary file stream requires us to handle line-end convention manually."	(OSHandle currentOS = #win32) ifTrue: [ self stream cr; lf ] ifFalse: [ self stream lf ].</body><body package="SiouX-Loggers">printNumber: aNumber paddingSize: paddingSize	| padding |	(padding := paddingSize - aNumber printString size) &gt; 0		ifTrue: [ 	padding timesRepeat: [ self stream put: $0 ] ].	self stream print: aNumber.</body><body package="SiouX-Loggers">printTime: aTimestamp	self printNumber: aTimestamp hour paddingSize: 2.	self stream	put: $:.	self	printNumber: aTimestamp minute paddingSize: 2.	self stream	put: $:.	self	printNumber: aTimestamp second paddingSize: 2.</body><body package="SiouX-Loggers">printTimestamp: aTimestamp"[10/Oct/2000:13:55:36 -0700] (%t)    The time that the request was received. The format is:    [day/month/year:hour:minute:second zone]    day = 2*digit    month = 3*letter    year = 4*digit    hour = 2*digit    minute = 2*digit    second = 2*digit    zone = (`+' | `-') 4*digit "	| month |	month := aTimestamp asDate monthName asString.	month := month copyFrom:1 to: 3.	self stream put: $[.	self printNumber: aTimestamp day paddingSize: 2.	self stream		put: $/ ;		write: month;		put: $/ ;		print: aTimestamp year;		put: $:.	self printTime: aTimestamp.	self stream 		space;		write: timeZone;		put: $].</body><body package="SiouX-Loggers">safelyUpdate: aBlock	| running |	(running := self isLogging) ifTrue: [self stop].	aBlock value.	running ifTrue: [self start]</body><body package="SiouX-Loggers">timeZoneString	| hours streamx |	streamx := String new writing.	hours := Core.TimeZone default secondsFromUniversal / (60 * 60).	hours negative 		ifTrue: [streamx put: $-]		ifFalse: [streamx put: $+].	hours abs &lt; 10 ifTrue: [streamx put: $0].	streamx print: hours abs; write: '00'.	^streamx contents</body></methods><methods><class-id>SiouX.StreamLogger</class-id> <category>accessing</category><body package="SiouX-Loggers">bufferSize		^bufferSize ifNil: [ bufferSize := DefaultBufferSize ]</body><body package="SiouX-Loggers">bufferSize: aNumber		bufferSize := aNumber</body><body package="SiouX-Loggers">file	^file</body><body package="SiouX-Loggers">file: aStringOrFilename"The parameter expected to be a full path "	file := aStringOrFilename asFilename</body><body package="SiouX-Loggers">newFilename: aString"The parameter expected to be a file name without path.If the logger is running it will be stopped, the stream is closed and the file name changed "	self safelyUpdate: [		file := file 			ifNotNil: [file directory / aString ]			ifNil: [ self class rootDirectory / aString]		]</body><body package="SiouX-Loggers">stream	^stream</body><body package="SiouX-Loggers">stream: aStream	stream := aStream</body></methods><methods><class-id>SiouX.StreamLogger</class-id> <category>printing</category><body package="SiouX-Loggers">printOn: aStream	file 		ifNotNil: [ aStream nextPutAll: self class name, ' write to: "', file asString, '"' ]		ifNil: [ super printOn: aStream.			announcers ifNotNil: [ 				aStream nextPutAll: ' for: #( '.				announcers do: [ :ann | 					aStream nextPutAll: '#', ann id.					aStream nextPut: Character space].				aStream nextPutAll: ')'.]]</body></methods><methods><class-id>SiouX.StreamLogger</class-id> <category>initialize-release</category><body package="SiouX-Loggers">addAnnouncer: anAnnouncer		^self announcers add: anAnnouncer</body><body package="SiouX-Loggers">initialize 	super initialize.	timeZone := self timeZoneString.</body><body package="SiouX-Loggers">removeAnnouncer: anAnnouncer		^self announcers remove: anAnnouncer ifAbsent: []</body></methods><methods><class-id>SiouX.StreamLogger</class-id> <category>logging</category><body package="SiouX-Loggers">startLogging"The logger stream can be provided or initialized from the provided file. By default the stream is buffered stream and it will be flushed when the buffer reach #bufferSize. We recreate the buffered stream every time when the logger starts. On close the logger closes the buffred stream and recycle the buffer.Be aware if the server crushes the last buffer can be lost. You may consider to set the stream differently flushing each log record" 		(self stream isNil and: [ self file notNil ]) ifTrue: [ self initializeStream ].	self logNewLine.	self stream write: '#Start: '.	self printTimestamp: Timestamp now.	self logNewLine.	self flush.	super startLogging</body><body package="SiouX-Loggers">stopLogging	super stopLogging.	self stream ifNil: [ ^nil ].		self stream write: '#Stop: '.	self printTimestamp: Timestamp now.	self logNewLine.	self flush.	self file ifNotNil: [ 		stream ifNotNil: [ stream close. stream := nil]]</body></methods><methods><class-id>SiouX.StreamLogger</class-id> <category>persistence</category><body package="SiouX-Loggers">asXmlNode	| root |	root := XML.Element 			tag: 'logger' 			elements: nil.	root addAttribute:  (XML.Attribute name: 'class' value: self class fullName ).	root addAttribute: (XML.Attribute name: 'logging' value: self isLogging printString ).	file ifNotNil: [file asString isEmpty ifTrue: [self halt].	root addAttribute:  (XML.Attribute name: 'file' value: file asString )].	bufferSize ifNotNil: [ root addAttribute: (XML.Attribute name: 'bufferSize' value: bufferSize printString )].	^root</body><body package="SiouX-Loggers">importSnapshot: aNode server: aServer	(aNode valueOfAttribute: 'file'  ifAbsent: [nil])		ifNotNil: [ :loggerFile | loggerFile notEmpty ifTrue: [ file := loggerFile asFilename ]].	(aNode valueOfAttribute: 'bufferSize'  ifAbsent: [nil])		ifNotNil: [ :loggerBufferSize | bufferSize := (Number readFrom: loggerBufferSize readStream ) ].	(aNode valueOfAttribute: 'logging'  ifAbsent: [nil])		ifNotNil: [ :loggerRunning | loggerRunning = 'true' ifTrue: [self start]].</body></methods><methods><class-id>SiouX.StreamLogger class</class-id> <category>accessing</category><body package="SiouX-Loggers">fileName	^fileName ifNil: [ fileName := (self rootDirectory / self defaultFileName) asFilename  ]</body><body package="SiouX-Loggers">fileName: aStringOrFilename	fileName := aStringOrFilename asFilename</body><body package="SiouX-Loggers">fileNamePrefix	^self fileName tail</body><body package="SiouX-Loggers">fileNamePrefix: aString	 fileName := (self rootDirectory / aString) asFilename</body><body package="SiouX-Loggers">rootDirectory"rootDirectory := nil"	rootDirectory ifNil: [ rootDirectory := Server logDirectory / self defaultFileName].	rootDirectory ensureDirectory.	^rootDirectory</body><body package="SiouX-Loggers">rootDirectory: aStringOrNilOrDirectory	rootDirectory := Server changeDirectory: self rootDirectory with: aStringOrNilOrDirectory</body><body package="SiouX-Loggers">rootDirectoryAsString	^self rootDirectory asString</body><body package="SiouX-Loggers">rootDirectoryAsString: aString	self rootDirectory: aString</body></methods><methods><class-id>SiouX.StreamLogger class</class-id> <category>default values</category><body package="SiouX-Loggers">defaultFileName	^self name asString</body><body package="SiouX-Loggers">defaultRootDirectoryValue	^Server defaultLogDirectory</body></methods><methods><class-id>SiouX.StreamLogger class</class-id> <category>instance creation</category><body package="SiouX-Loggers">log: aServer"Create a log with default file name. The file will be located in the rootDirectory and the file name is created as (self fileName, '-', aServer id, '.log')  " 	^self 		log: aServer 		file: (self fileNameFor: aServer)</body><body package="SiouX-Loggers">log: aServer file: aFilename"Create a log with specified file name "	^self new		addAnnouncer: aServer;		file: aFilename;		yourself</body><body package="SiouX-Loggers">log: aServer stream: aStream"Create a log with specified stream "	^self new		addAnnouncer: aServer;		stream: aStream;		yourself</body></methods><methods><class-id>SiouX.StreamLogger class</class-id> <category>private</category><body package="SiouX-Loggers">fileNameFor: aServer	| baseName |	baseName := self fileName asString.	^[(baseName, '-', aServer id, '.log' ) asFilename] 		on: Error 		do: [ :ex | ex return: (baseName, '.log' ) asFilename ].</body></methods><methods><class-id>SiouX.StreamLogger class</class-id> <category>accessing class hierarchy</category><body package="SiouX-Loggers">abstractRoot	^StreamLogger</body></methods><methods><class-id>SiouX.StreamLogger class</class-id> <category>private - tools</category><body package="SiouX-Loggers">addLogger: aLogger  from: aDictionary for: aServer	aServer logs 		detect: [ :log | log class name = aLogger class name ] 		ifNone: [ 	aServer addLog: aLogger.				aLogger addAnnouncer: aServer.].</body><body package="SiouX-Loggers">safeUpdateLogger: aLogger from: aDictionary for: aServer"To update the file name the logger will be stopped and the existing stream will be flushed and closed.After the update the logger will be restarted"	| fn |	aLogger file tail ~= (fn := aDictionary at: #filename ) 		ifTrue: [aLogger newFilename: fn].</body><body package="SiouX-Loggers">updateLogger: aLogger from: aDictionary for: aServer"The aDictionary #action parameter can be #add/remove or nil. If it is nil we assume that the aLogger already exists"	(aDictionary at: #action) = #remove		ifTrue: [ aLogger stop.				aLogger removeAnnouncer: aServer. 				^aServer removeLog: aLogger ].	(aDictionary at: #action) = #add ifTrue: [ self addLogger: aLogger from: aDictionary for: aServer ].	self safeUpdateLogger: aLogger from: aDictionary for: aServer.			(aDictionary at: #shouldStop)		ifTrue: [aLogger stop ]		ifFalse: [ aLogger  start].</body></methods><methods><class-id>SiouX.StatusLog</class-id> <category>accessing</category><body package="SiouX-Loggers">announcements	^announcements ifNil: [ announcements := StatusUpdate ]</body><body package="SiouX-Loggers">frequency	^self statusCollector frequency</body><body package="SiouX-Loggers">statusCollector	^self announcers first</body></methods><methods><class-id>SiouX.StatusLog</class-id> <category>services</category><body package="SiouX-Loggers">log: aServerStatusUpdate	aServerStatusUpdate statistics ifNotNil: [ :dict | 		self statusCollector logStatistics: dict using: self.		self flush ]</body><body package="SiouX-Loggers">stop	self isLogging ifFalse: [^self].	accessProtect critical: [		self announcers do: [ :ann | ann  stop ].		(Delay forMilliseconds: 100) wait.		isLogging := false. 		self stopLogging. ]</body></methods><methods><class-id>SiouX.StatusLog</class-id> <category>logging</category><body package="SiouX-Loggers">startLogging	super startLogging.	self statusCollector printHeaderUsing: self.	self statusCollector start.</body><body package="SiouX-Loggers">stopLogging	self statusCollector stop.	super stopLogging.</body></methods><methods><class-id>SiouX.StatusLog</class-id> <category>initialize-release</category><body package="SiouX-Loggers">addAnnouncer: anAnnouncer	self addAnnouncer: anAnnouncer frequency: self class statusCollector frequency</body><body package="SiouX-Loggers">addAnnouncer: anAnnouncer frequency: aDuration		self announcers isNotEmpty ifTrue: [self announcers removeFirst].	^self announcers add: ( self class statusCollector on: anAnnouncer frequency: aDuration)</body></methods><methods><class-id>SiouX.StatusLog</class-id> <category>persistence</category><body package="SiouX-Loggers">asXmlNode	| root |	root := super asXmlNode.	root addAttribute:  (XML.Attribute name: 'announcer' value: self statusCollector server id ).	root addAttribute: (XML.Attribute name: 'frequency' value: self frequency asSeconds printString ).	root addAttribute: (XML.Attribute name: 'statusCollectorClass' value: self statusCollector class fullName ). 	^root</body><body package="SiouX-Loggers">importSnapshot: aNode server: aServer	| frequency collector |	(aNode valueOfAttribute: 'frequency'  ifAbsent: [nil])		ifNotNil: [ :freq | frequency := (Number readFrom: freq readStream ) ].	(aNode valueOfAttribute: 'statusCollectorClass'  ifAbsent: [nil]) ifNotNil: [ :classCollector | 		collector :=  classCollector asSymbol asQualifiedReference 						valueOrDo: [^self announce: (LoadingServerConfig new												write: (#UndefinedStatusCollectorRef &lt;&lt;#www &gt;&gt; 'Undefined StatusCollector class reference: &lt;1s&gt;' expandMacrosWith:  classCollector);												write: aNode printString;												yourself)] ].	collector ifNil: [collector := self class statusCollector].	 	self announcers: (collector on: aServer).		frequency ifNotNil: [ self statusCollector frequency: (Duration fromSeconds: frequency) ].	super importSnapshot: aNode server: aServer</body></methods><methods><class-id>SiouX.StatusLog class</class-id> <category>default values</category><body package="SiouX-Loggers">defaultFileName	^'status'</body><body package="SiouX-Loggers">statusCollector	^statusCollector ifNil: [ statusCollector := StatusCollector ]</body><body package="SiouX-Loggers">statusCollector: aClass	statusCollector := aClass</body></methods><methods><class-id>SiouX.StatusLog class</class-id> <category>instance creation</category><body package="SiouX-Loggers">announcers: aServer	^self new announcers: (self statusCollectorFor: aServer)</body><body package="SiouX-Loggers">announcers: aServer frequency: aDuration	^self new announcers: (self statusCollectorFor: aServer frequency: aDuration )</body><body package="SiouX-Loggers">log: aServer file: aFilename frequency: aDuration	^self new		announcers: (self statusCollectorFor: aServer frequency: aDuration );		file: aFilename;		yourself</body><body package="SiouX-Loggers">log: aServer frequency: aDuration	^self new		announcers: (self statusCollectorFor: aServer frequency: aDuration );		file: (self fileNameFor: aServer);		yourself</body><body package="SiouX-Loggers">log: aServer stream: aStream frequency: aDuration	^self new		announcers: (self statusCollectorFor: aServer frequency: aDuration );		stream: aStream;		yourself</body></methods><methods><class-id>SiouX.StatusLog class</class-id> <category>accessing</category><body package="SiouX-Loggers">statusCollectorFor: aServer	^self statusCollector on: aServer</body><body package="SiouX-Loggers">statusCollectorFor: aServer frequency: aDuration	^self statusCollector on: aServer frequency: aDuration</body></methods><methods><class-id>SiouX.StatusLog class</class-id> <category>private - tools</category><body package="SiouX-Loggers">addLogger: aLogger from: aDictionary for: aServer	(aServer logs detect: [ :lg | lg = aLogger ] ifNone: [nil])		ifNil: [aServer addLog: aLogger.			aLogger addAnnouncer: aServer frequency: (aDictionary at: #frequency)]</body><body package="SiouX-Loggers">helpText	^#ServerStatusHelp &lt;&lt; #www &gt;&gt;'ServerStatusLog provides information on server activity and performance. It allows a server administrator to find out how well their server is performing. The log uses ServerStatusCollector to monitor a server for a specified time period and collect statistics and then prints the collected data as a table.Frequency - entry field allows to set the number of munites to collect the server data'</body><body package="SiouX-Loggers">safeUpdateLogger: aLogger from: aDictionary for: aServer	| newFilename frequency |	newFilename := aDictionary at: #filename.	frequency := aDictionary at: #frequency.	(aLogger file tail ~= newFilename		or: [aLogger frequency ~= frequency])		ifTrue: [aLogger safelyUpdate: [					aLogger file tail ~= newFilename ifTrue: [ aLogger newFilename: newFilename].					aLogger frequency ~= frequency						ifTrue: [aLogger announcers removeFirst.							aLogger announcers add: (aLogger class statusCollectorFor: aServer frequency: frequency)]]].</body></methods><methods><class-id>SiouX.ServerShutdownAnnouncement</class-id> <category>accessing</category><body package="SiouX-Announcements">duration	^duration</body><body package="SiouX-Announcements">duration: aDuration	duration := aDuration</body></methods><methods><class-id>SiouX.BadRequestAnnouncement</class-id> <category>printing</category><body package="SiouX-Announcements">printOn: aStream	super printOn: aStream.	description ifNotNil: [ aStream nextPutAll: ' reason: ', description ]</body></methods><methods><class-id>SiouX.BadRequestAnnouncement</class-id> <category>accessing</category><body package="SiouX-Announcements">description	^description</body><body package="SiouX-Announcements">description: aString	description := aString</body></methods><methods><class-id>SiouX.StatusCollector</class-id> <category>accessing</category><body package="SiouX-Loggers">announcements	^announcements ifNil: [ announcements := ConnectionOpened,  ConnectionClosed, RequestReceived, ResponseSent  ]</body><body package="SiouX-Loggers">bytesSent	^bytesSent</body><body package="SiouX-Loggers">connectionCounts	^connectionCounts</body><body package="SiouX-Loggers">frequency	^frequency</body><body package="SiouX-Loggers">frequency: aDuration	frequency := aDuration</body><body package="SiouX-Loggers">requests	^requests</body><body package="SiouX-Loggers">requests: anObject	^requests := anObject</body><body package="SiouX-Loggers">responses	^responses</body><body package="SiouX-Loggers">server		^server</body></methods><methods><class-id>SiouX.StatusCollector</class-id> <category>services</category><body package="SiouX-Loggers">getStatistics		requests ifNil: [ ^nil].	^Dictionary new		at: #pending put: (requests - responses);		at: #rate put: ( (responses * 1000 / frequency asMilliseconds ) rounded);		at: #requests put: requests;		at: #responses put: responses;		at: #bytesSent put: (bytesSent/1024) rounded;		at: #listenerConnectionCount put: connectionCounts;		yourself</body><body package="SiouX-Loggers">log: anAnnouncement	(anAnnouncement class = ConnectionOpened or: [anAnnouncement class = ConnectionClosed ])		ifTrue: [self updateConnectionCounts ].	anAnnouncement class = RequestReceived ifTrue: [ requests := requests + 1].	anAnnouncement class = ResponseSent ifTrue: [		responses := responses + 1. 		anAnnouncement size ifNotNil: [ :bytes | bytesSent := bytesSent + bytes ]].</body><body package="SiouX-Loggers">start	isLogging ifTrue: [^self].	accessProtect critical: [		isLogging := true.		self startLogging ]</body><body package="SiouX-Loggers">stop	isLogging ifFalse: [^self].	accessProtect critical: [		isLogging := false.		self stopLogging ]</body></methods><methods><class-id>SiouX.StatusCollector</class-id> <category>printing</category><body package="SiouX-Loggers">logStatistics: aDictionary using: aStreamLogger	"Log the statistics previously captured in #getStatistics using aStreamLogger"	|  tm stream |	aDictionary ifNil: [^nil].	stream := aStreamLogger stream.	tm := Timestamp now.	aStreamLogger printNumber: tm hour paddingSize: 2.	stream	put: $:.	aStreamLogger printNumber: tm minute paddingSize: 2.	stream space.	(aDictionary at: #listenerConnectionCount ) keysAndValuesDo: [ :listener :connections |		aStreamLogger printNumber: connections  paddingSize: 4. ].	stream tab: 2.	aStreamLogger	printNumber: (aDictionary at: #requests)  paddingSize: 5.	stream	tab: 3.	aStreamLogger	printNumber: (aDictionary at: #responses)  paddingSize: 5.	stream tab: 3.	aStreamLogger	printNumber: (aDictionary at: #pending)  paddingSize: 4.	stream	tab: 3.	aStreamLogger	printNumber: (aDictionary at: #rate)  paddingSize: 4.	stream	tab: 3.	aStreamLogger	printNumber: (aDictionary at: #bytesSent)  paddingSize: 8.	aStreamLogger logNewLine.</body><body package="SiouX-Loggers">printHeaderUsing: aStreamLogger	| separatorLine stream |	separatorLine := '======================================================================================='.	stream := aStreamLogger stream.	stream write: '#Frequency: ' , self frequency printString.	aStreamLogger logNewLine.	stream write: separatorLine.	aStreamLogger logNewLine.	stream		tab;		write: 'Connections';		tab;		write: 'Requests';		tab;		write: 'Responses';		tab: 3;		write: 'Pending';		tab: 3;		write: 'Rate';		tab: 2;		write: 'Bytes Sent (K)'.	aStreamLogger logNewLine.	stream write: separatorLine.	aStreamLogger logNewLine</body><body package="SiouX-Loggers">printOn: aStream	super printOn: aStream.	server ifNotNil: [ aStream nextPutAll: ' on: ', server id ]</body></methods><methods><class-id>SiouX.StatusCollector</class-id> <category>initialize-release</category><body package="SiouX-Loggers">initialize	super initialize.	isLogging := false.	accessProtect := RecursionLock new.</body><body package="SiouX-Loggers">on: aServer frequency: aDuration	server := aServer.	frequency := aDuration.	self resetData.</body><body package="SiouX-Loggers">release	super release.	^self stopLogging.</body><body package="SiouX-Loggers">resetData	bytesSent := requests := responses := 0.	connectionCounts := self collectConnectionCounts.</body></methods><methods><class-id>SiouX.StatusCollector</class-id> <category>private</category><body package="SiouX-Loggers">collectConnectionCounts	^ IdentityDictionary withAll: (self server listeners collect: [:listener | listener -&gt; listener connectionCount ])</body><body package="SiouX-Loggers">privateLog: ann	accessProtect critical: [ self log: ann ]</body><body package="SiouX-Loggers">restartTimer	timer ifNotNil: [ timer release ].	timer := Timer 				every: frequency 				do: [ self server isRunning ifTrue: [ self announceStatistics ]].</body><body package="SiouX-Loggers">updateConnectionCounts	self collectConnectionCounts keysAndValuesDo: [:eachListener :eachCount |		connectionCounts			at: eachListener			put: ((connectionCounts at: eachListener ifAbsent: [0]) max: eachCount)]</body></methods><methods><class-id>SiouX.StatusCollector</class-id> <category>logging</category><body package="SiouX-Loggers">announceStatistics	self announce: ( StatusUpdate on: self getStatistics ).	accessProtect critical: [self resetData]</body><body package="SiouX-Loggers">startLogging	self server		when: self announcements		do: [ :ann | self privateLog: ann ]		for: self.	self restartTimer</body><body package="SiouX-Loggers">stopLogging	timer ifNotNil: [ timer release].	server ifNotNil: [server unsubscribe: self.].	requests ifNotNil: [ self announceStatistics ].	^super release</body></methods><methods><class-id>SiouX.StatusCollector class</class-id> <category>accessing</category><body package="SiouX-Loggers">frequency	^frequency ifNil: [ frequency := self defaultFrequency ]</body><body package="SiouX-Loggers">frequency: aDuration	frequency := aDuration</body></methods><methods><class-id>SiouX.StatusCollector class</class-id> <category>default values</category><body package="SiouX-Loggers">defaultFrequency	^5 minutes</body></methods><methods><class-id>SiouX.StatusCollector class</class-id> <category>instance creation</category><body package="SiouX-Loggers">on: aServer 	^(self new)		on: aServer frequency: self frequency;		yourself</body><body package="SiouX-Loggers">on: aServer frequency: aSeconds	^(self new)		on: aServer frequency: aSeconds;		yourself</body></methods><methods><class-id>SiouX.Connection</class-id> <category>accessing</category><body package="SiouX-Server">id	^id</body><body package="SiouX-Server">listener	^listener</body><body package="SiouX-Server">localAddress	^socket getName</body><body package="SiouX-Server">protocol	^self class protocol</body><body package="SiouX-Server">readStream		^readStream</body><body package="SiouX-Server">remoteAddress	^id</body><body package="SiouX-Server">server	^listener ifNotNil: [ :l | l server ]</body><body package="SiouX-Server">socket	^socket</body><body package="SiouX-Server">writeStream		^writeStream</body></methods><methods><class-id>SiouX.Connection</class-id> <category>initialize-release</category><body package="SiouX-Server">initializeId	id := socket getPeer</body><body package="SiouX-Server">initializeStreams	self subclassResponsibility</body><body package="SiouX-Server">on: aSocket listener: aListener	socket := aSocket.	listener := aListener.	self initializeId.</body><body package="SiouX-Server">releaseStreams	self subclassResponsibility</body></methods><methods><class-id>SiouX.Connection</class-id> <category>private</category><body package="SiouX-Server">finallyClose: aSocket"We need to wrap the final stage of closing a connection in an exception handler.When the listener announces the closing of a connection, an error may happen in a user code handling of the announcement.Further, if a connection has been closed by the client and we are trying to flush data, a 'broken pipe' error may occur on the socket.In the same spirit, closing @aSocket could produce a low-level IO error if the connection has been closed or there is a network problem.For all these scenarios, a connection error needs to be handled by the server."		[		listener ifNotNil: [ listener closingConnection: self ].		self releaseStreams.		aSocket close	]		on: Error		do: [:ex | self server ifNotNil: [ :s | s connectionError: ex from: self]]</body><body package="SiouX-Server">privateOpen	self initializeStreams.	listener openingConnection: self.	self requestProcessBody</body><body package="SiouX-Server">requestProcessBody	self subclassResponsibility</body><body package="SiouX-Server">stopRequestProcess	requestProcess ifNil: [ ^self ].	"If this runs from within the request process itself we don't want to terminate ourselves.	This assumes the process is already in its final steps and will terminate naturally."	requestProcess == Processor activeProcess ifFalse: [ requestProcess terminate ].	requestProcess := nil</body></methods><methods><class-id>SiouX.Connection</class-id> <category>testing</category><body package="SiouX-Server">isOpen	^socket notNil</body><body package="SiouX-Server">isSecure	^self class isSecure</body></methods><methods><class-id>SiouX.Connection</class-id> <category>printing</category><body package="SiouX-Server">printOn: aStream	aStream nextPutAll: self protocol; space.	id ifNotNil: [ id printBytesOn: aStream].	self isOpen ifTrue: [ aStream nextPut: $* ]</body></methods><methods><class-id>SiouX.Connection</class-id> <category>services</category><body package="SiouX-Server">close	self stopRequestProcess.	socket ifNotNil: [ :s |		socket := nil.		self finallyClose: s ]</body><body package="SiouX-Server">open	requestProcess := [			Processor activeProcess name: id printString.			[				[					self privateOpen				] on: Error do: [:ex | self server connectionError: ex from: self. ] 						] ensure: [ self close ]												] forkAt: listener connectionPriority</body></methods><methods><class-id>SiouX.Connection class</class-id> <category>instance creation</category><body package="SiouX-Server">on: socket listener: aListener	^self new on: socket listener: aListener</body></methods><methods><class-id>SiouX.Connection class</class-id> <category>accessing</category><body package="SiouX-Server">listenerClass	^self subclassResponsibility</body><body package="SiouX-Server">protocol	^self subclassResponsibility</body></methods><methods><class-id>SiouX.Connection class</class-id> <category>testing</category><body package="SiouX-Server">isSecure	^false</body></methods><methods><class-id>SiouX.HttpConnection</class-id> <category>initialize-release</category><body package="SiouX-Server">initializeStreams	"we should probably put a timeout on the writing end as well, for the cases when client simply doesn't read a large response,	but we need to make sure that the write wait works as expected on all relevant platforms."	writeStream := socket writing buffering: DefaultBufferSize.	readStream := socket reading: listener connectionTimeout.</body><body package="SiouX-Server">on: aSocket listener: aListener	super on: aSocket listener: aListener.	persist := aListener persist.	protocolVersion := Protocols.HTTPv11 on: self.</body><body package="SiouX-Server">releaseStreams	[readStream close.	writeStream close	] on: Error 	do: [ :ex | "Ignore write stream buffer flush, another side has already closed the connection"]</body></methods><methods><class-id>SiouX.HttpConnection</class-id> <category>private</category><body package="SiouX-Server">badRequestError: aString	self 		sendError: aString 		reason:  '400 Bad Request'.	self server badRequestError: aString connection: self.	self error: (#BadRequestError &lt;&lt; #www &gt;&gt; 'Bad Request: ', aString)</body><body package="SiouX-Server">continueProcessing	^persist</body><body package="SiouX-Server">persist: aBoolean	persist := aBoolean</body><body package="SiouX-Server">processNextRequest	|  requestContext   |	requestContext  := protocolVersion requestContextFor: self.		[	"If there is Upgrade field check if we can upgrade the connection"		self upgrade: requestContext.		requestContext request hasBody ifTrue: [ requestContext request prepareRequestToProcess ].		protocolVersion processRequest: requestContext	]		on: Error, ResponseReady		do: [ :ex | "Upgrade handshake and request body limitation errors"			requestContext response isSuccess ifTrue: [				"There is still default response. Let's set default error response. "				requestContext  response: (requestContext responder exceptionPrinter value: ex)].				"If the protocol version is nill it means 			the connection has been already closed and there is no way to send a response"			protocolVersion ifNotNil: [ protocolVersion sendResponseFor: requestContext ].			self persist: false  ]</body><body package="SiouX-Server">requestHeaderExceededSizeLimit	| message |	message := #RequestHeaderExceededSizeLimit &lt;&lt; #www &gt;&gt; 'The request header size exceeded the limit: &lt;1p&gt; bytes'  expandMacrosWith: self requestHeaderLimit.	self 		sendError: message		reason:  '413 Request Entity Too Large'.	self server requestHeaderExceededSizeLimit: self.	self error: message</body><body package="SiouX-Server">requestProcessBody	[			[ self continueProcessing ] whileTrue: [self processNextRequest.]			] on: Incomplete, Timeout do: [ :ex |		"Either the connection was closed on te other end or		the inactivity timeout expired." ]</body><body package="SiouX-Server">requestStatusLineTooLarge: requestStatusLine	self 		sendError: 'Request-URI Too Large: ', requestStatusLine, '...' 		reason:  '414 Request-URI Too Large'.	self server requestStatusLineTooLarge: requestStatusLine connection: self.	self error: (#RequestStatusLineTooLarge &lt;&lt; #www &gt;&gt; 'Request Status Line too large')</body><body package="SiouX-Server">sendError: bodyString reason: reasonString	|  encoded |	encoded := ((writeStream closing: []) encoding: #utf_8) setLineEndCRLF.	[	"Status-Line = HTTP-Version SP Status-Code SP Reason-Phrase CRLF"		encoded write: 'HTTP/1.1 '; write:  reasonString; cr;			write: 'Server: '; write: self serverHeader; cr;			write: 'Content-Type: text/plain; charset=utf-8'; cr;			write: 'Connection: close'; cr;			cr;			write: bodyString asString.			encoded flush.	] ensure: [ encoded close ].</body><body package="SiouX-Server">upgrade: aRequestContext	| nextVersion upgrade |	(upgrade := aRequestContext request upgrade) ifNil: [ ^self ].		"Upgrade: if the client requested and the server supports the upgrade.	Check the listener first and then the responder"	nextVersion := listener protocolVersions 					detect: [ :protVersion | protVersion acceptsProtocolIdentifier: upgrade ] 					ifNone: [ aRequestContext responder protocolVersions 								detect: [ :protVersion | protVersion acceptsProtocolIdentifier: upgrade ]								ifNone: [nil]].					nextVersion class == protocolVersion class ifTrue: [ ^self ].				nextVersion  ifNotNil: [protocolVersion := nextVersion upgradeConnection: aRequestContext ]</body></methods><methods><class-id>SiouX.HttpConnection</class-id> <category>accessing</category><body package="SiouX-Server">acceptedServerNames	^self listener acceptedServerNames</body><body package="SiouX-Server">protocolVersion	^protocolVersion</body><body package="SiouX-Server">protocolVersion: anHttpVersion	protocolVersion := anHttpVersion</body><body package="SiouX-Server">requestBodyLimit	^self listener requestBodyLimit</body><body package="SiouX-Server">requestHeaderLimit	^self listener requestHeaderLimit</body><body package="SiouX-Server">serverHeader	^self class serverHeader</body></methods><methods><class-id>SiouX.HttpConnection</class-id> <category>testing</category><body package="SiouX-Server">isPersistent	"	Answer the value of persist. Although doing the same as #continueProcessing, the semantic is different.	Perhaps we should change #continueProcessing to use 'self isPersistent'.	"	^ persist</body></methods><methods><class-id>SiouX.HttpConnection</class-id> <category>services</category><body package="SiouX-Server">close	protocolVersion ifNotNil: [ 		protocolVersion closingConnection.		protocolVersion := nil ].	super close.</body></methods><methods><class-id>SiouX.HttpConnection class</class-id> <category>accessing</category><body package="SiouX-Server">listenerClass	^HttpListener</body><body package="SiouX-Server">protocol	^'http'</body><body package="SiouX-Server">serverHeader	^ServerHeader</body><body package="SiouX-Server">serverHeader: aString		| val |	val := aString isEmpty ifTrue: [ nil ] ifFalse: [ aString].	ServerHeader := val.</body></methods><methods><class-id>SiouX.HttpConnection class</class-id> <category>class initialization</category><body package="SiouX-Server">initialize	self serverHeader: 'SiouX'.</body></methods><methods><class-id>SiouX.RequestFilter</class-id> <category>printing</category><body package="SiouX-Server">printOn: aStream	aStream nextPutAll: self description</body></methods><methods><class-id>SiouX.RequestFilter</class-id> <category>persistence</category><body package="SiouX-Server">asXmlNode	| root  |	root := XML.Element 		tag: 'requestFilter' 		elements: nil.	root addAttribute:  (XML.Attribute name: 'class' value: self class fullName ).	configuration ifNotNil: [ :str | root addAttribute:  (XML.Attribute name: 'configuration' value: str )].	^root</body><body package="SiouX-Server">importSnapshot: aNode" Import subclass options"</body></methods><methods><class-id>SiouX.RequestFilter</class-id> <category>configuration</category><body package="SiouX-Server">configuration: aString	configuration := aString</body></methods><methods><class-id>SiouX.RequestFilter</class-id> <category>accessing</category><body package="SiouX-Server">configuration	^ configuration</body><body package="SiouX-Server">description	"Provide the filter description as you want to have it in tool UI. By default it is the class full name "		^configuration 		ifNotNil: [ self class name, ' configuration:', configuration]		ifNil: [self class name ]</body></methods><methods><class-id>SiouX.RequestFilter</class-id> <category>services</category><body package="SiouX-Server">addToResponder: aResponder"The filter adds itself to the responder filter collection. Use this method to set your filter position"	aResponder addFilter: self</body><body package="SiouX-Server">applyTo: aRequestContext	"By default does nothing. Add your implementation in a subclass. 	If the filter refuses to accept the request it sets the RequestContext response to error response and raises exception.	If the filter processes the request and is ready to send a response the response can be sent using HttpResponse&gt;&gt;signalReady "	^self subclassResponsibility</body><body package="SiouX-Server">removeFromResponder: aResponder"The filter removes itself from the responder filter collection."	aResponder removeFilter: self</body></methods><methods><class-id>SiouX.RequestFilter</class-id> <category>notifications</category><body package="SiouX-Server">handleServerStarting"	A server starts. Default is do nothing."</body><body package="SiouX-Server">handleServerStopping"	A server stops. Default is do nothing."</body></methods><methods><class-id>SiouX.RequestFilter class</class-id> <category>instance creation</category><body package="SiouX-Server">fromConfiguration: aString	"	Answer an instance of one of my subclasses, configured by a pragma (&lt;configuration:&gt;) with aString argument  	If no class has been found, I respond with nil.	"	self withAllSubclasses do: [ :eachClass |		(self from: eachClass configuration: aString) ifNotNil: [ :instance | ^instance]].	^nil</body><body package="SiouX-Server">new	^ super new initialize</body></methods><methods><class-id>SiouX.RequestFilter class</class-id> <category>configuration</category><body package="SiouX-Server">configurations	"	Answer an array of string/pragma which describe the configuration options for my instances.	To be used by configuration tools.	Evaluate:		self withAllSubclasses collect: [ :each | each -&gt; each configurationOptions ]	"	^ (Pragma allNamed: #configuration: in: self) collect: [ :eachPragma | eachPragma arguments first -&gt; eachPragma ]</body></methods><methods><class-id>SiouX.RequestFilter class</class-id> <category>testing</category><body package="SiouX-Server">isAbstract	^self == RequestFilter</body></methods><methods><class-id>SiouX.RequestFilter class</class-id> <category>private</category><body package="SiouX-Server">from: aClass configuration: aString	"	Answer an instance of one of my subclasses, configured by a pragma (&lt;configuration:&gt;) with aString argument  	If no class has been found, I respond with nil.	"	|  instance  |	(aClass configurations detect: [ :assoc | assoc key = aString ] ifNone: [nil])			ifNotNil: [ :assoc |					instance := aClass new.					instance perform: assoc value selector.					instance configuration: aString.					^instance  ].	^nil</body></methods><methods><class-id>SiouX.Server</class-id> <category>initialize-release</category><body package="SiouX-Server">addListener: addressString port: port connection: aConnection	^self addListener: addressString port: port connection: aConnection onError: nil</body><body package="SiouX-Server">addListener: addressString port: port connection: aConnectionClass onError:  aBlock	| ipAddress |	ipAddress := self addressFrom: addressString port: port.	(self findListenerOn: ipAddress for: aConnectionClass) ifNotNil: [aBlock value].	^self listenOn: ipAddress  for: aConnectionClass.</body><body package="SiouX-Server">deregister	"	I am being removed from the registry. Announce it to the world.	"	Registry removeKey: self id ifAbsent: [ ^ self ].	self class announce: (ServerRemoved server: self).</body><body package="SiouX-Server">initialize: aString	id := aString.	listeners := OrderedCollection new.	logs := OrderedCollection new.	responders := OrderedCollection new.	debugging := false.	self initializeConnections</body><body package="SiouX-Server">initializeConnections	connections := SharedRegistry new.</body><body package="SiouX-Server">register"Register myself as the server at my id. If another instance is already registered, unregister it first."	Registry		at: self id		ifPresent: [ :existing |			"If I am the same instance as the one already register, no point of going further. Return self."			existing == self ifTrue: [ ^self ].			"Otherwise, make sure whoever is there under my id get deregistered so I can be put in its place."			existing deregister ].	"All is clear to put myself in the registry."	Registry at: self id put: self.	"Finally, announce to the world that I have been added."	self class announce: (ServerAdded server: self).</body><body package="SiouX-Server">release	self stop.	self deregister.		"Use responders and listeners copies because during their release,	they will be removed from the original collection."	responders copy do: [ :responder | responder release. ].	listeners copy do: [ :listener | listener release ].	super release.</body></methods><methods><class-id>SiouX.Server</class-id> <category>testing</category><body package="SiouX-Server">isLogging	^logs anySatisfy: [ :lg | lg isLogging ]</body><body package="SiouX-Server">isRunning	^(listeners anySatisfy: #isRunning) or: [ connections size &gt; 0 ]</body></methods><methods><class-id>SiouX.Server</class-id> <category>services</category><body package="SiouX-Server">addListener: aListener	listeners add: aListener.	self announce: (ListenerAdded listener: aListener).	^aListener</body><body package="SiouX-Server">addLog: anAnnouncementLogger	logs add: anAnnouncementLogger.	^anAnnouncementLogger</body><body package="SiouX-Server">addResponder: aResponder	"	Attempt to add @aResponder. If I already have one like that, return the existing responder.	Otherwise add @aResponder, announce it to the world, and return @aResponder.	"	^responders		detect: [:each | each isSameAs: aResponder]		ifNone: [			aResponder server: self.			aResponder subscribeToServerAnnouncements.			responders add: aResponder.			self announce: (ResponderAdded responder: aResponder).			aResponder]</body><body package="SiouX-Server">addressFrom: addressString port: aNumber	^ IPSocketAddress defaultServerAddressType 			hostAddress: (ByteArray withAll: ((addressString tokensBasedOn: $.) collect: [ :x | x asNumber ]))  			port: aNumber.</body><body package="SiouX-Server">debug	debugging := true</body><body package="SiouX-Server">debug: aBoolean"Turn debugging mode on/off. Generally it means that the various background processes will open a debugger when there's an unexpected error instead of suppressing it."	debugging := aBoolean</body><body package="SiouX-Server">findListenerOn: ipAddress for: connectionClass	"If a listener already listens on this IP address for the specified connection class, I shouldn't add a new one. Return the existing listener instead."	listeners do: [:each |		(each address = ipAddress		and: [ each connectionClass = connectionClass ])			ifTrue: [ ^ each ] ].	"No matching ipAddress/connection class has been found."			^ nil</body><body package="SiouX-Server">listenOn: ipAddressOrPort for: connectionClass	| ipAddress  |	ipAddress := ipAddressOrPort isInteger				ifTrue: [IPSocketAddress defaultServerAddressType thisHostPort: ipAddressOrPort]				ifFalse: [ipAddressOrPort].	"	If a listener already listens on this IP address, I shouldn't add a new one. Return the existing listener instead	except when I should listen on any port (port = 0)	"	ipAddress port isZero ifFalse: [(self findListenerOn: ipAddress for: connectionClass)		ifNotNil: [:existing | ^existing]].		^self addListener: (connectionClass listenerClass on: ipAddress server: self).</body><body package="SiouX-Server">logging: aBoolean"Turn logging mode on/off. The default log is defined as CommonLog. Use Server class&gt;&gt;logFactory: to reset the default "	aBoolean		ifTrue: [logs isEmpty ifTrue: [ self addLog: ( self class createLogFor: self )].				logs do: [ :lg | self startLog: lg ]]		ifFalse: [logs do: [ :lg | self stopLog: lg ]]</body><body package="SiouX-Server">removeListener: aListener	(listeners includes: aListener) ifTrue: [		listeners remove: aListener.		self announce: (ListenerRemoved listener: aListener)].	^ aListener</body><body package="SiouX-Server">removeLog: anAnnouncementLogger	logs remove: anAnnouncementLogger ifAbsent: [ ^ nil ].</body><body package="SiouX-Server">removeResponder: aResponder	responders remove: aResponder ifAbsent: [ ^ nil ].	self unsubscribe: aResponder.	self announce: (ResponderRemoved responder: aResponder).	^ aResponder</body><body package="SiouX-Server">start	"It might be nice to have the ability to continue starting listeners even if one fails.	Maybe a warning that if resumed will continue, otherwise stop."	self serverStartingAnnouncement.	listeners do: [:listener | listener start]</body><body package="SiouX-Server">startLog: aLog	aLog announcers detect: [ :lgx | lgx == self ] ifNone: [ aLog announcers add: self ].	aLog isLogging		ifTrue: [aLog startLogging:  self ]		ifFalse: [ aLog start ]</body><body package="SiouX-Server">stop" Hard shutdown " 	self stop: nil</body><body package="SiouX-Server">stop: aDuration"Graceful  shutdown "		self serverShutdownIn: aDuration.	aDuration ifNotNil: [ (Delay for: aDuration) wait].	self serverStoppingAnnouncement.	self		stopListeners;		closeConnections.	self logging: false</body><body package="SiouX-Server">stopLog: aLog	aLog ifNil: [^nil].	aLog announcers size = 1		ifTrue: [ aLog stop ]		ifFalse: [ aLog announcers remove: self ifAbsent: [].				aLog stopLogging: self. ].</body></methods><methods><class-id>SiouX.Server</class-id> <category>accessing</category><body package="SiouX-Server">connections	^connections</body><body package="SiouX-Server">debugging	^debugging</body><body package="SiouX-Server">debugging: aBoolean"Turn debugging mode on/off. Generally it means that the various background processes will open a debugger when there's an unexpected error instead of suppressing it."	^debugging := aBoolean</body><body package="SiouX-Server">id	^id</body><body package="SiouX-Server">listeners	^listeners</body><body package="SiouX-Server">log	^logs first</body><body package="SiouX-Server">logs	^logs</body><body package="SiouX-Server">logs: anAnnouncementLoggerOrCollection	anAnnouncementLoggerOrCollection isSequenceable		ifTrue: [ 	logs addAll: anAnnouncementLoggerOrCollection ]		ifFalse: [ logs add: anAnnouncementLoggerOrCollection ]</body><body package="SiouX-Server">noResponderReply	^noResponderReply ifNil: [ noResponderReply :=  self class noResponderReply ]</body><body package="SiouX-Server">noResponderReply: aBlock 	noResponderReply :=aBlock</body><body package="SiouX-Server">responders	^responders</body></methods><methods><class-id>SiouX.Server</class-id> <category>notifications</category><body package="SiouX-Server">badRequestError: aString connection:  aConnection	"Note that the announcement handlers will run within the connection process."		self announce: (BadRequestAnnouncement new 						connection: aConnection;						description: aString asString;						yourself).</body><body package="SiouX-Server">closingConnection: aConnection listener: listener	connections		removeKey: aConnection id		ifAbsent: [ ]		ifPresent: [ :connection | listener decrementConnectionCount ].	"Note that the announcement handlers will run within the connection process."	self announce: (ConnectionClosed connection: aConnection).</body><body package="SiouX-Server">connectionError: anError from: connection	"Note that the announcement handlers will run within the connection process."	self announce: (ConnectionFailed exception: anError connection: connection).	debugging ifTrue: [ anError pass ].</body><body package="SiouX-Server">listenerError: anError from: listener	"Note that the announcement handlers will run within the listener process."	self announce: (ListenerFailed exception: anError listener: listener).	debugging ifTrue: [ anError pass ].</body><body package="SiouX-Server">listenerStarted: aListener	self announce: (ListenerStarted listener: aListener).</body><body package="SiouX-Server">listenerStopped: aListener	self announce: (ListenerStopped listener: aListener).</body><body package="SiouX-Server">noResponderFor: anHttpRequest  on: aConnection	self noResponderReply value: anHttpRequest value: aConnection.	self announce: (ResponderNotFound request: anHttpRequest connection: aConnection).	aConnection persist: false.	self error: 'Connection closed'</body><body package="SiouX-Server">openingConnection: aConnection listener: listener	connections		at: aConnection id		put: aConnection		do: [ listener incrementConnectionCount ].	self announce: (ConnectionOpened connection: aConnection).</body><body package="SiouX-Server">preparedResponse: response responder: responder request: request connection: connection	self announce: (ResponsePrepared request: request response: response responder: responder connection: connection ).</body><body package="SiouX-Server">receivedRequest: aRequestLine	"Note that the announcement handlers will run within the connection process."	self announce: (RequestReceived request: aRequestLine connection: aRequestLine connection).</body><body package="SiouX-Server">requestHeaderExceededSizeLimit:  aConnection	"Note that the announcement handlers will run within the connection process."		self announce: (RequestHeaderExceededSizeLimit new 						connection: aConnection;						yourself).</body><body package="SiouX-Server">requestStatusLineTooLarge: aRequestStatusLine connection: connection	"Note that the announcement handlers will run within the connection process."	self announce: (RequestStatusLineTooLarge new 						statusLine: aRequestStatusLine;						connection: connection;						yourself).</body><body package="SiouX-Server">responderError: anError from: responder request: request connection: aConnection	self announce: (RequestExecutionFailed exception: anError responder: responder request: request connection: aConnection) .	debugging ifTrue: [ anError pass ].</body><body package="SiouX-Server">responseTransmissionError: error response: response request: request connection: connection	"Note that the announcement handlers will run within the connection process."	self announce: (ResponseSendingFailed responseError: error response: response request: request connection: connection).	debugging ifTrue: [ error pass ].</body><body package="SiouX-Server">sentResponse: response request: request connection: connection size: size	"Note that the announcement handlers will run within the connection process."	self announce: (ResponseSent request: request response: response connection: connection size: size).</body><body package="SiouX-Server">serverShutdownIn: aDuration"Graceful  shutdown "		self announce: (ServerShutdownAnnouncement new duration: aDuration; yourself).</body><body package="SiouX-Server">serverStartingAnnouncement	self announce: ServerStartingAnnouncement new.</body><body package="SiouX-Server">serverStoppingAnnouncement	self announce: ServerStoppingAnnouncement new.</body></methods><methods><class-id>SiouX.Server</class-id> <category>printing</category><body package="SiouX-Server">printAddressOn: aStream	listeners		do: [ :listener | listener printHostAndPortOn: aStream ]		separatedBy: [ aStream nextPutAll: ', ' ]</body><body package="SiouX-Server">printOn: aStream	aStream nextPutAll: id, ' '.	self printAddressOn: aStream</body></methods><methods><class-id>SiouX.Server</class-id> <category>persistence</category><body package="SiouX-Server">asXmlNode	| root |	root := XML.Element 		tag: 'server' 		elements: nil.	root addAttribute:  (XML.Attribute name: 'class' value: self class fullName ).	root addAttribute:  (XML.Attribute name: 'id' value: self id ).	root addAttribute: (XML.Attribute name: 'debugging' value: self debugging printString ).		self logs do: [ :lg | root addNode: lg asXmlNode ].	self listeners do: [ :listener | root addNode: listener asXmlNode ].	self responders do: [ :responder | responder asXmlNode ifNotNil: [ :node | root addNode: node ]].	^root</body><body package="SiouX-Server">importListenerSnapshots: node 				| ipAddress port listener  |	node tag type ~= 'listener' ifTrue: [^nil].	(self class classFrom: node attributeNamed: 'class') ifNotNil: [ :listenerCl |		ipAddress := node valueOfAttribute: 'hostAddress'  ifAbsent: [nil].		port := node valueOfAttribute: 'port'  ifAbsent: [nil].		( ipAddress notNil and: [port notNil ]) ifTrue: [ 			listener := self 						addListener: ipAddress 						port: port asNumber						connection: listenerCl  connectionClass.			listener importSnapshot: node.			(node valueOfAttribute: 'running'  ifAbsent: [nil]) ifNotNil: [ :bool | bool = 'true' ifTrue: [ listener start]]]]</body><body package="SiouX-Server">importLoggerSnapshots: node 				| logger  |	node tag type ~= 'logger' ifTrue: [^nil].	(self class classFrom: node attributeNamed: 'class') ifNotNil: [ :loggerCl |		self addLog: (logger := loggerCl new).		logger importSnapshot: node server: self]</body><body package="SiouX-Server">importResponderSnapshots: node 				| responder  |	node tag type ~= 'responder' ifTrue: [^nil].	(self class classFrom: node attributeNamed: 'class') ifNotNil: [ :responderCl|		self addResponder: (responder := responderCl new).		responder importSnapshot: node]</body><body package="SiouX-Server">save" Saves the server configuration in to a file as XML Document"	self class 		saveTo: self class configurationFileName 		id: id</body><body package="SiouX-Server">writeOn: aStream	self class writeOn: aStream id: self id</body></methods><methods><class-id>SiouX.Server</class-id> <category>configuration</category><body package="SiouX-Server">configure	| pragma |	pragma := (self class configurationPragmaFor: self id) ifNil: [^self].	self class perform: pragma selector with: self.	(Responder allConfigurationsForServer: self) do: [ :each |		each key addResponderTo: self from: each value ].</body></methods><methods><class-id>SiouX.Server</class-id> <category>private</category><body package="SiouX-Server">closeConnections	| failed |	failed := OrderedCollection new.	connections do: [ :connection |		[ connection close ] on: Error do: [ :ex | self halt. failed add: connection -&gt; ex ] ].	self initializeConnections.	failed notEmpty ifTrue: [		Error new			messageText: (#Connection1sFailedClosing &lt;&lt; #www &gt;&gt;'&lt;1p&gt; connection failed closing!' expandMacrosWith: failed size);			parameter: failed;			raise ]</body><body package="SiouX-Server">findResponderFor: anHttpLine on: aConnection	| responder |	self receivedRequest: anHttpLine.	responder := responders		detect: [ :each | each acceptRequest: anHttpLine ]		ifNone: [ ^ self noResponderFor: anHttpLine on: aConnection ].	^ responder</body><body package="SiouX-Server">stopListeners	| failed |	failed := OrderedCollection new.	listeners		do: [:listener | [listener stop] on: Error do: [:ex | failed add: listener -&gt; ex]].	failed notEmpty		ifTrue: 			[Error new				messageText: (#Listeners1sFailedStop &lt;&lt; #www &gt;&gt; '&lt;1p&gt; listeners failed to stop!'							expandMacrosWith: failed size);				parameter: failed;				raise]</body></methods><methods><class-id>SiouX.Server class</class-id> <category>accessing</category><body package="SiouX-Server">changeDirectory: oldDir with: aStringOrNilOrDirectory	|  newComps  fn |	aStringOrNilOrDirectory ifNil: [^nil].	((fn :=aStringOrNilOrDirectory asFilename) exists 		and: [fn isDirectory])			ifTrue: [ ^fn ].	newComps := aStringOrNilOrDirectory tokensBasedOn: Filename separator.	fn := (LogicalFilename fromComponents: newComps) asFilename.	fn ensureDirectory.	^fn</body><body package="SiouX-Server">configDirectory"ConfigDirectory := nil"	ConfigDirectory ifNil: [ ConfigDirectory := self rootDirectory / self defaultConfigDirectory ].	ConfigDirectory ensureDirectory.	^ConfigDirectory</body><body package="SiouX-Server">configDirectory: aStringOrNilOrDirectory	ConfigDirectory := self changeDirectory: self configDirectory with: aStringOrNilOrDirectory</body><body package="SiouX-Server">configDirectoryAsString"self configDirectoryAsString"	^self configDirectory asString</body><body package="SiouX-Server">configDirectoryAsString: aString	^self configDirectory: aString</body><body package="SiouX-Server">configurationFileName	^configurationFileName ifNil: [ self defaultConfigurationFileName ]</body><body package="SiouX-Server">configurationFileName: aString	configurationFileName := aString</body><body package="SiouX-Server">createLogFor: aServer	^self logFactory value: aServer</body><body package="SiouX-Server">generateId"Generate a server id based on the current timestamp.	(Server generateId)"	^String new writing		write: name;		write: ( TimestampPrintPolicy print: Timestamp now using: '_yyyy-mm-dd_hh-mm-ss');		contents.</body><body package="SiouX-Server">isActive: serverId	^ self registry includesKey: serverId</body><body package="SiouX-Server">logDirectory"LogDirectory := nil"	LogDirectory ifNil: [ LogDirectory := self rootDirectory / self defaultLogDirectory ].	LogDirectory ensureDirectory.	^LogDirectory</body><body package="SiouX-Server">logDirectory: aStringOrNilOrDirectory	LogDirectory := self changeDirectory: self logDirectory with: aStringOrNilOrDirectory</body><body package="SiouX-Server">logDirectoryAsString	^self logDirectory asString</body><body package="SiouX-Server">logDirectoryAsString: aString	self logDirectory: aString</body><body package="SiouX-Server">logFactory	^logFactory ifNil: [ logFactory := self defaultLogFactory ]</body><body package="SiouX-Server">logFactory: aBlock	logFactory := aBlock</body><body package="SiouX-Server">noResponderReply	^noResponderReply ifNil: [ noResponderReply := self noResponderReplyDefault ]</body><body package="SiouX-Server">noResponderReply: aBlock 	noResponderReply := aBlock</body><body package="SiouX-Server">registry	^Registry</body><body package="SiouX-Server">resetRootDirectory	RootDirectory := nil</body><body package="SiouX-Server">rootDirectory"RootDirectory := nil"	RootDirectory ifNil: [ RootDirectory := self defaultRootDirectory asFilename ].	RootDirectory ensureDirectory. 	^RootDirectory</body><body package="SiouX-Server">rootDirectory: aStringOrNilOrDirectory	RootDirectory := aStringOrNilOrDirectory asFilename.	RootDirectory ensureDirectory</body><body package="SiouX-Server">rootDirectoryAsString	^self rootDirectory asString</body><body package="SiouX-Server">rootDirectoryAsString: aString	self rootDirectory: aString</body></methods><methods><class-id>SiouX.Server class</class-id> <category>configuration</category><body package="SiouX-Server">autoRestart	^ServerSystem autoRestart</body><body package="SiouX-Server">autoRestart: aBoolean	ServerSystem autoRestart: aBoolean</body><body package="SiouX-Server">classConfiguring: serverId	"	Lookup the class configuring server with serverId.	( Server classConfiguring: 'Default' )	"	^ Server withAllSubclasses		detect: [ :eachClass | (eachClass configurationPragmaFor: serverId) notNil ]		ifNone: [ self ]</body><body package="SiouX-Server">configurationPragmaFor: serverId	" Answer the first pragma in my superclass chain that configures serverId. "	^(Pragma		allNamed: #server:		from: self class		to: Server class)			detect: [:each | each arguments first = serverId]			ifNone: [nil]</body></methods><methods><class-id>SiouX.Server class</class-id> <category>creation</category><body package="SiouX-Server">new	^ self id: nil</body></methods><methods><class-id>SiouX.Server class</class-id> <category>instance creation</category><body package="SiouX-Server">id: id	| serverId class |	serverId := id ifNil: [self generateId].	"To avoid infinite recursion, return as soon as existing server is found."	self registry at: serverId ifPresent: [ :existing | ^ existing].	"Create a new server, configure and register it."	class := self classConfiguring: serverId.	^ (class newId: serverId)		configure;		register;		yourself</body><body package="SiouX-Server">newId: id	^ super new		initialize: id;		yourself</body></methods><methods><class-id>SiouX.Server class</class-id> <category>defaults</category><body package="SiouX-Server">defaultConfigDirectory	^'config'</body><body package="SiouX-Server">defaultConfigurationDirectory	^'config'</body><body package="SiouX-Server">defaultConfigurationFileName	^'WebServerConfiguration.xml'</body><body package="SiouX-Server">defaultLogDirectory	^'logs'</body><body package="SiouX-Server">defaultLogFactory	^[ :server |  CommonLog log: server  ]</body><body package="SiouX-Server">defaultRootDirectory	^'sioux'</body><body package="SiouX-Server">noResponderReplyDefault	^[ :request :connection |		connection			sendError: ( 'Resource Not Found: ', request method, ' ', request url printString, ' ', request version) 			reason:   '404 Not Found'.	]</body></methods><methods><class-id>SiouX.Server class</class-id> <category>announcements</category><body package="SiouX-Server">subscriptionRegistry: newRegistry 	MySubscriptions := newRegistry</body><body package="SiouX-Server">subscriptionRegistryOrNil	^MySubscriptions</body></methods><methods><class-id>SiouX.Server class</class-id> <category>persistence</category><body package="SiouX-Server">classFrom: aNode attributeNamed: aString	^(aNode valueOfAttribute: aString ifAbsent: [nil]) ifNotNil: [ :aClass | |theClass|		theClass := aClass asSymbol asQualifiedReference valueOrDo: [			^self announce: (LoadingServerConfig new				write: (#UndefinedClassRef &lt;&lt; #www &gt;&gt;'Undefined class reference: &lt;1s&gt; ' expandMacrosWith:  aClass);				write: aNode printString;				yourself)].				 theClass].</body><body package="SiouX-Server">importErrorsFilename	^importErrorsFilename ifNil: ['ErrorsLoadingServerConfiguration.log']</body><body package="SiouX-Server">importErrorsFilename: aString	importErrorsFilename := aString</body><body package="SiouX-Server">importServer: classId id: id from: node"Import &lt;server&gt; node settings "	| server |	self registry at: id ifPresent: [ :oldServer |		self announce: (LoadingServerConfig new			write: (#ServerId1sAlreadyExists &lt;&lt; #www &gt;&gt; 'The Server id: &lt;1s&gt; already exists. The old server is released and new one created from the configuration file' expandMacrosWith: id );			yourself).		oldServer release.	].	server := (classId asSymbol asQualifiedReference 				valueOrDo: [^self announce: (LoadingServerConfig new												write: (#UndefinedServerClassRef &lt;&lt;#www &gt;&gt; 'Undefined Server class reference: &lt;1s&gt;' expandMacrosWith:  classId);												write: node printString;												yourself)]				) newId: id.	node realElements do: [ :el |		server			importLoggerSnapshots: el;			importResponderSnapshots: el;			importListenerSnapshots: el ].	(node valueOfAttribute: 'debugging'  ifAbsent: [nil]) ifNotNil: [ :bool | bool = 'true' ifTrue: [ server debug ]].	server register</body><body package="SiouX-Server">importServerFrom: aNode"Import &lt;server&gt; node"	| id |	aNode tag type = 'server' ifFalse: [ ^nil].	(aNode valueOfAttribute: 'class'  ifAbsent: [nil]) ifNotNil: [ :serverClass |		id := aNode 				valueOfAttribute: 'id'  				ifAbsent: [ self announce: (LoadingServerConfig new											write: (#ServerSettingNoIdIncluded &lt;&lt; #www &gt;&gt;'The server settings do not include #id attribute');											write: aNode printString;											yourself).						nil].		id ifNotNil: [ self importServer: serverClass id: id from: aNode ]]</body><body package="SiouX-Server">importSnapshots: aNode"Installs server settings from an XML Node.All insttallion errors will be reported in to Transcript and the external file with name #errorLoadingSnapshotsFilename.The seetings with errors will be skipped "	| logger logStream logContents fileStream |	logger := AnnouncementPrinter announcers: Server.	logStream := String new writing.	logger out: logStream.	logger announcements: LoadingServerConfig.	logger start.	[		aNode realElements do: [ :node | self importServerFrom: node ].	] ensure: [		(logContents := logStream contents) notEmpty			ifTrue: [Transcript cr; show: 'ERRORS LOADING SERVER CONFIGURATION '.					Transcript show: logContents.					fileStream := self importErrorsFilename asFilename writing.					fileStream write: Timestamp now printString.					[ fileStream write: logStream contents  ] ensure: [fileStream close]].		logStream close.		logger stop ].	^(logContents notNil and: [logContents isEmpty]) ifTrue: [ nil ] ifFalse: [ logContents ]</body><body package="SiouX-Server">load"Reads and installs server settings. The settings are an XML Document "	^self loadFrom: self configurationFileName</body><body package="SiouX-Server">loadFrom: aFilename"Reads and installs server settings from a specified file. The settings are an XML Document "	| stream  |	stream := (aFilename asFilename withEncoding: #'UTF_8') readStream.	^[self readSettingsFrom: stream ] ensure: [ stream close ].</body><body package="SiouX-Server">readSettingsFrom: aStream"Reads and installs server settings from a stream. The settings are an XML Document "	^self importSnapshots: (			((XMLParser on: aStream) validate: false; scanDocument) root	)</body><body package="SiouX-Server">save"Save all registered servers in to an extental file. The settings are saved as XML Document and can be loaded using #load method  "	self saveTo: self configurationFileName id: nil</body><body package="SiouX-Server">saveTo: aFilename"Save all registered servers in to a specified extental file. The settings are saved as XML Document and can be loaded using #loadFrom: method  "	self saveTo: aFilename id: nil</body><body package="SiouX-Server">saveTo: aFilename id: aSymbol"Save a specified server with id (aSymbol)  in to a specified extental file. The settings are saved as XML Document and can be loaded using #loadFrom: method  "	| stream |	stream := (aFilename asFilename withEncoding: #'UTF_8') writeStream.	[ self writeOn: stream id: aSymbol ]		ensure: [ stream close]</body><body package="SiouX-Server">writeOn: aStream"Save all registered servers in to a specified stream. The settings are saved as XML Document and can be loaded using #readSettingsFrom: method"	self writeOn: aStream id: nil</body><body package="SiouX-Server">writeOn: aStream id: aSymbol"Save server(s) in to a specified stream. The settings are saved as XML Document and can be loaded using #readSettingsFrom: method"	| document root servers |	aStream nextPutAll: '&lt;?xml version="1.0"?&gt;'; cr.	document := Document new.	root := Element 	tag: 'servers'.	servers := aSymbol ifNil: [ self registry values ] ifNotNil: [OrderedCollection with: ( self id: aSymbol )].	servers do: [ :srv | root addNode: srv asXmlNode ].	document addNode: root.	document printOn: aStream.</body></methods><methods><class-id>SiouX.RequestReceived</class-id> <category>printing</category><body package="SiouX-Announcements">printOn: aStream	super printOn: aStream.	aStream space.	request printStatusLineOn: aStream</body></methods><methods><class-id>SiouX.ResponseSendingFailed</class-id> <category>accessing</category><body package="SiouX-Announcements">exception	^exception</body><body package="SiouX-Announcements">exception: anObject	exception := anObject</body><body package="SiouX-Announcements">request	^request</body><body package="SiouX-Announcements">request: anObject	request := anObject</body><body package="SiouX-Announcements">size	^ nil</body></methods><methods><class-id>SiouX.ResponseSendingFailed</class-id> <category>printing</category><body package="SiouX-Announcements">printOn: aStream	exception 		ifNil: [ super printOn: aStream ]		ifNotNil: [ aStream nextPutAll: exception description ]</body></methods><methods><class-id>SiouX.ResponseSendingFailed</class-id> <category>initialize-release</category><body package="SiouX-Announcements">responseError: anException response: httpResponse request: httpRequest connection: aConnection	exception := anException.	response := httpResponse.	request := httpRequest.	connection := aConnection</body></methods><methods><class-id>SiouX.ResponseSendingFailed class</class-id> <category>instance creation</category><body package="SiouX-Announcements">responseError: exception response: httpResponse request: httpRequest connection: aConnection	^self new		responseError: exception response: httpResponse request: httpRequest connection: aConnection;		yourself</body></methods><methods><class-id>SiouX.ServerSystem</class-id> <category>accessing</category><body package="SiouX-Server">autoRestart	^self class autoRestart</body><body package="SiouX-Server">registry	^Server registry</body></methods><methods><class-id>SiouX.ServerSystem</class-id> <category>default actions</category><body package="SiouX-Server">pauseAction	super pauseAction.	^self stopActiveServers</body><body package="SiouX-Server">resetActiveServers	ActiveServers := nil</body><body package="SiouX-Server">resumeAction	"	I am resuming after a snapshot. There is nothing for me to do other than reset ActiveServers."	self resetActiveServers</body><body package="SiouX-Server">setUp"	I am starting up after an image safe or during an explicit activation.	If AutoRestart is enabled, start active servers. Once done, reset active servers no matter what."	super setUp.	self autoRestart ifTrue: [ self startActiveServers ].	self resetActiveServers</body><body package="SiouX-Server">startActiveServers"	If ActiveServers have been set before a snapshot or by activating myself explicitly,	start the servers.	"	ActiveServers ifNotNil: [ :servers |		servers do: [:value | value start]]</body><body package="SiouX-Server">stopActiveServers"	Stop all the active servers, but only if they are not already known and stopped."	ActiveServers ifNotNil: [ ^ self ].	ActiveServers := OrderedCollection new.	self autoRestart ifFalse: [^nil].	self registry keysAndValuesDo: 			[:key :value |			value isRunning				ifTrue: 					[value stop.					ActiveServers add: value]]</body></methods><methods><class-id>SiouX.ServerSystem</class-id> <category>prerequisites</category><body package="SiouX-Server">prerequisiteSystems	^Array		with: KernelSystem		with: TimerSystem		with: RuntimeSystem.</body></methods><methods><class-id>SiouX.ServerSystem class</class-id> <category>configuration</category><body package="SiouX-Server">autoRestart	^AutoRestart</body><body package="SiouX-Server">autoRestart: aBoolean	^AutoRestart := aBoolean</body></methods><methods><class-id>SiouX.ErrorLog</class-id> <category>accessing</category><body package="SiouX-Loggers">announcements	^announcements ifNil: [ announcements := ServerErrors ]</body></methods><methods><class-id>SiouX.ErrorLog</class-id> <category>services</category><body package="SiouX-Loggers">log: anAnnouncement	self printTimestamp: Timestamp now.	self stream space.	(anAnnouncement isKindOf: ConnectionAnnouncement)		ifTrue: [ 	anAnnouncement connection socket				ifNotNil: [ :socket | socket  getName printBytesOn: self stream]]		ifFalse: [self stream write: 'Listener failed'].	self stream space.	(anAnnouncement isKindOf: RequestAnnouncement) ifTrue: [		anAnnouncement logRequestStatusLineOn: self stream.		(anAnnouncement isKindOf: ResponseSendingFailed) ifTrue: [ 			self stream 				space;				write: anAnnouncement responseCode]].	self stream 		space;		write: anAnnouncement class name; 		put: $:;		space.	anAnnouncement printOn: self stream.	anAnnouncement exception ifNotNil: [ :exception |		self logNewLine.		self stream  write: '---------------- Start Exception stack -------------------'.		self logNewLine.		self stream write: exception initialContext printStack.		self stream  write: '---------------- End Exception stack -------------------'.		self logNewLine. ].	self logNewLine.</body></methods><methods><class-id>SiouX.ErrorLog class</class-id> <category>default values</category><body package="SiouX-Loggers">defaultFileName	^'errors'</body></methods><methods><class-id>SiouX.ErrorLog class</class-id> <category>tools</category><body package="SiouX-Loggers">helpText	^#ErrorLogHelp &lt;&lt; #www &gt;&gt; 'ErrorLog logs server errors. The error log includes error description and the error stack.'</body></methods><methods><class-id>SiouX.LoadingServerConfig</class-id> <category>accessing</category><body package="SiouX-Announcements">stream	^stream ifNil: [ stream := String new writing ]</body><body package="SiouX-Announcements">write: aString	self stream cr; write: aString</body></methods><methods><class-id>SiouX.LoadingServerConfig</class-id> <category>printing</category><body package="SiouX-Announcements">printOn: aStream	aStream 		nextPutAll: self stream contents;		cr;		nextPutAll: '---------------------';		cr</body></methods><methods><class-id>SiouX.ResponseReady</class-id> <category>accessing</category><body package="SiouX-Server">response	^self parameter</body></methods><methods><class-id>SiouX.ServerAdded</class-id> <category>accessing</category><body package="SiouX-Announcements">server	^server</body><body package="SiouX-Announcements">server: anObject	server := anObject</body></methods><methods><class-id>SiouX.ServerAdded class</class-id> <category>instance creation</category><body package="SiouX-Announcements">server: aServer	^ self new		server: aServer;		yourself</body></methods><methods><class-id>SiouX.RequestLine</class-id> <category>printing</category><body package="SiouX-Server">printOn: aStream	self printStatusLineOn: aStream</body><body package="SiouX-Server">printStatusLineOn: aStream	method ifNotNil: [aStream nextPutAll: method, ' ' ].	path ifNotNil: [ 		self url printPathOn: aStream.		aStream nextPutAll: ' '  ].	version ifNotNil: [aStream nextPutAll: version ]</body></methods><methods><class-id>SiouX.RequestLine</class-id> <category>accessing</category><body package="SiouX-Server">connection	^ connection</body><body package="SiouX-Server">decodedPath	^decodedPath ifNil: [ decodedPath := self url decodedPath ]</body><body package="SiouX-Server">encodedPath	^path</body><body package="SiouX-Server">method	^method</body><body package="SiouX-Server">method: aString	method := aString</body><body package="SiouX-Server">path	^path</body><body package="SiouX-Server">path: aString	path := aString</body><body package="SiouX-Server">url 	^url ifNil: [ url := PartialURL fromEncodedString: path ]</body><body package="SiouX-Server">url: anURI	url := anURI</body><body package="SiouX-Server">version	^version</body><body package="SiouX-Server">version: aString	version := aString</body></methods><methods><class-id>SiouX.RequestLine</class-id> <category>initialize-release</category><body package="SiouX-Server">initialize: aConnection	connection := aConnection.</body></methods><methods><class-id>SiouX.RequestLine class</class-id> <category>instance creation</category><body package="SiouX-Server">on: aConnection	^ self new		initialize: aConnection;		yourself</body></methods><methods><class-id>SiouX.Responder</class-id> <category>accessing</category><body package="SiouX-Server">addRequestFilter: aRequestFilterOrNil	^ aRequestFilterOrNil ifNotNil: [ :filter | filter addToResponder: self ]</body><body package="SiouX-Server">decodedPath	^decodedPath ifNil: [ decodedPath := self url decodedPath ]</body><body package="SiouX-Server">defaultPath	^ '/'</body><body package="SiouX-Server">description"Currently the description string is used for configuration and monitor tools. The method returns additional specific to the responder information"	^(self class comment reading ending: $. inclusive: true) rest</body><body package="SiouX-Server">exceptionPrinter	^exceptionPrinter ifNil: [ self class exceptionPrinter ]</body><body package="SiouX-Server">exceptionPrinter: aBlock	exceptionPrinter := aBlock</body><body package="SiouX-Server">newResponse	^self subclassResponsibility</body><body package="SiouX-Server">path	^path ifNil: [ self defaultPath ]</body><body package="SiouX-Server">path: aString	path := aString.	url := decodedPath := nil</body><body package="SiouX-Server">protocolVersions	^#()</body><body package="SiouX-Server">server	^server</body><body package="SiouX-Server">server: aServer	server == aServer ifTrue: [^self].	server := aServer.</body><body package="SiouX-Server">url	^url ifNil: [ url := PartialURL fromString: self path ]</body></methods><methods><class-id>SiouX.Responder</class-id> <category>testing</category><body package="SiouX-Server">isSameAs: aResponder	"	Answer a Boolean indicating that I am the same responder as aResponder.	Use to prevent adding multiple reponders doing the same thing to the same server.	Subclasses may override.	"	^aResponder == self		or: [aResponder class == self class			and: [aResponder path = self path ]]</body></methods><methods><class-id>SiouX.Responder</class-id> <category>persistence</category><body package="SiouX-Server">asXmlNode	| root |	root := XML.Element 		tag: 'responder' 		elements: nil.	root addAttribute:  (XML.Attribute name: 'class' value: self class fullName ).	path ifNotNil: [ 		path  isString ifFalse: [ self error: (#PathNotStringImplementXMLNode &lt;&lt; #www &gt;&gt; 'If path is not a string you should implement #asXmlNode for the responder' )].		root addAttribute: (XML.Attribute name: 'path' value: path ) ].	self requestFilters do: [ :f | root addNode: f asXmlNode ].	^root</body><body package="SiouX-Server">importRequestFilter: aNode	| filterCl config |	aNode tag type = 'requestFilter' ifFalse: [^self].	(aNode valueOfAttribute: 'class'  ifAbsent: [nil]) ifNotNil: [ :filterClass |		filterCl := filterClass asSymbol asQualifiedReference valueOrDo: [			^Server announce: (LoadingServerConfig new								write: (#UndefinedReqFilterClassRef &lt;&lt; #www &gt;&gt; 'Undefined request filter class reference:&lt;1s&gt; ' expandMacrosWith:  filterClass);								write: aNode printString;								yourself)].		config := aNode valueOfAttribute: 'configuration'  ifAbsent: [nil].						(self requestFilter: filterClass configuration: config) ifNotNil: [ :f | f importSnapshot: aNode]]</body><body package="SiouX-Server">importResponderOptions: aNode	"Import subclass options "</body><body package="SiouX-Server">importSnapshot: aNode	(aNode valueOfAttribute: 'path'  ifAbsent: [nil])		ifNotNil: [ :responderPath | path := responderPath ].	aNode realElements do: [ :el |		self importRequestFilter: el.		self importResponderOptions: el.	].</body></methods><methods><class-id>SiouX.Responder</class-id> <category>configuration</category><body package="SiouX-Server">configureFrom: aPragma"Configure the responder from pragmas. For example add request filetrs from pragmas &lt;requestFilter: #WebSocketFilter configuration: 'Test Configuration'"  	aPragma method attributeMessages do: [ :message |		" The #position: pragma has been deprecated but we need to keep it for backward compatibility. "		(#(#server:path: #position:) includes: message selector) ifFalse: [			self perform: message selector withArguments: message arguments ] ]</body><body package="SiouX-Server">requestFilter: filterName"Create a request filter and add it to request filter collection "	^ self requestFilter: filterName configuration: nil</body><body package="SiouX-Server">requestFilter: filterName configuration: aSelector"Create a request filter for a specified configuration as it is defined by &lt;configuration&gt; pragma and add the filter to request filter collection"	| cl |	cl := filterName asSymbol asQualifiedReference valueOrDo: [ self error: (#NotExistingRequestFilterClass &lt;&lt; #www &gt;&gt; 'Not existing Request Filter class' )].	(cl inheritsFrom: RequestFilter ) ifFalse: [self error: ( #ClassIsNotRequestFilter &lt;&lt; #www &gt;&gt;'The filter class is not inherited from RequestFilter')].	^self addRequestFilter: (aSelector						ifNil: [ cl new]						ifNotNil: [ cl  fromConfiguration: aSelector ])</body><body package="SiouX-Server">server: aServer path: aPath"	I am being configured to be added to aServer and aPath."	self path: aPath.	self server: aServer</body></methods><methods><class-id>SiouX.Responder</class-id> <category>services</category><body package="SiouX-Server">acceptRequest: aRequestLine"This is the very first step in a sequence that decides whether the responder will handle the incoming request or not. None of the following steps will be invoked unless this method answers true.Subclasses may override.	^&lt;Boolean&gt;	will handle the request or not?"	self path = self defaultPath ifTrue: [ " The default path accepts all requests "^true].	^ aRequestLine decodedPath beginsWith: self decodedPath</body><body package="SiouX-Server">applyRequestFilters: aRequestContext	self requestFilters do: [ :filter | 		filter applyTo: aRequestContext ]</body><body package="SiouX-Server">createRequestFrom: aRequestLine	^self subclassResponsibility</body><body package="SiouX-Server">dispatchRequest: aRequestContext	"This is the callback that the responder receives from the server when there is an incoming request on a connection. Only the first line of the request header is actually read, the rest of the processing is left to the responder should it decide to handle the request. This is a skeletal implementation of basic request processing of a request. Subclasses have to fill in the missing details in the methods called from here."	[self processRequest: aRequestContext ]			on: Error			do: 				[:ex |				server					responderError: ex					from: self					request: aRequestContext  request					connection: aRequestContext  connection.				"If the context has an error response leave it as it is "				aRequestContext  response isSuccess					ifTrue: 						["There is still default response. Let's set default error response. "						aRequestContext  response: (self exceptionPrinter value: ex)]].	^self sendResponse: aRequestContext.</body><body package="SiouX-Server">executeRequestFor: aProtocolContext	"In the absence of specific behavior, I do nothing. Subclasses should override."</body><body package="SiouX-Server">processRequest:  aProtocolContext	[		self applyRequestFilters: aProtocolContext.		self executeRequestFor: aProtocolContext.			]	on: ResponseReady		do: [ :ex |			"			If, during the previous block, a 'ResponseReady' notification has been signalled, there is no point in continuing,			and we return with the assumption that the context has the response so it can send it back to the client.			"			aProtocolContext response: ex response.			ex return ].</body><body package="SiouX-Server">requestContextClass	^RequestContext</body><body package="SiouX-Server">sendResponse: aRequestContext	aRequestContext protocolVersion sendResponseFor: aRequestContext</body><body package="SiouX-Server">setRequestIn: context from: aRequestLine	context request: (self createRequestFrom: aRequestLine)</body></methods><methods><class-id>SiouX.Responder</class-id> <category>request filters</category><body package="SiouX-Server">addFilter: aRequestFilter	self requestFilters add: aRequestFilter.</body><body package="SiouX-Server">removeFilter: aRequestFilter	self requestFilters remove: aRequestFilter</body><body package="SiouX-Server">requestFilters	^requestFilters ifNil: [ requestFilters := OrderedCollection new ]</body></methods><methods><class-id>SiouX.Responder</class-id> <category>printing</category><body package="SiouX-Server">printDetailOn: aStream	aStream nextPutAll: ' path: ', self path.</body><body package="SiouX-Server">printOn: aStream	super printOn: aStream.	self printDetailOn: aStream</body></methods><methods><class-id>SiouX.Responder</class-id> <category>notifications</category><body package="SiouX-Server">handleServerStarting	self requestFilters do: [:filter | filter handleServerStarting]</body><body package="SiouX-Server">handleServerStopping	self requestFilters do: [:filter | filter handleServerStopping]</body><body package="SiouX-Server">subscribeToServerAnnouncements	server		ifNotNil: 			[server				when: ServerStartingAnnouncement				send: #handleServerStarting				to: self.			server				when: ServerStoppingAnnouncement				send: #handleServerStopping				to: self]</body></methods><methods><class-id>SiouX.Responder</class-id> <category>initialize-release</category><body package="SiouX-Server">release	server ifNotNil: [		server removeResponder: self.		server := nil ].	super release.</body></methods><methods><class-id>SiouX.Responder class</class-id> <category>defaults</category><body package="SiouX-Server">defaultExceptionPrinterValue	^self subclassResponsibility</body></methods><methods><class-id>SiouX.Responder class</class-id> <category>accessing</category><body package="SiouX-Server">exceptionPrinter	^exceptionPrinter ifNil: [ self defaultExceptionPrinterValue ]</body><body package="SiouX-Server">exceptionPrinter: aBlock	^exceptionPrinter := aBlock</body></methods><methods><class-id>SiouX.Responder class</class-id> <category>configuration</category><body package="SiouX-Server">addResponderTo: aServer from: pragma	^aServer addResponder: (self createResponderFrom: pragma for: aServer).</body><body package="SiouX-Server">allConfigurationsForServer: aServer	| configurations |	configurations := SortedCollection sortBlock: [ :a :b | self isPragma: a value configuredBefore: b value ].	self allSubclassesDo: [ :eachClass |		(eachClass configurationPragmasForServer: aServer) do: [ :eachPragma |			configurations add: eachClass -&gt; eachPragma ] ].	^ configurations</body><body package="SiouX-Server">configurationPragmasForServer: aServer	^(Pragma allNamed: #server:path: in: self class)		select: [:each | each arguments first = aServer id]</body><body package="SiouX-Server">configureResponder: aResponder from: pragma for: aServer	"	Classes can configure @responder in methods with or without the responder in the argument.	If @pragma method is a unary message, ignore the responder.	Otherwise, assume the method takes exactly one argument, the responder.	"	| arguments |	arguments := pragma selector isKeyword		ifTrue:  [pragma selector keywords size = 1			ifTrue: [Array with: aResponder]			ifFalse: [ Array with: aResponder with: aServer ]]		ifFalse: [ #() ].	pragma methodClass instanceBehavior		perform: pragma selector		withArguments: arguments.	aResponder configureFrom: pragma</body><body package="SiouX-Server">createResponderFrom: pragma for: aServer	| responder arguments |		arguments := (pragma keyword = #server:path:)		ifTrue: [Array with: aServer with: pragma arguments last]		ifFalse: [pragma arguments].	responder := self perform: pragma keyword withArguments: arguments.	self configureResponder: responder from: pragma for: aServer.	^ responder</body><body package="SiouX-Server">server: aServer path: aPath"	Create a new instance of self with server and path set."	^ self new		server: aServer path: aPath;		yourself</body></methods><methods><class-id>SiouX.Responder class</class-id> <category>private - configuration</category><body package="SiouX-Server">isPragma: pragmaA configuredBefore: pragmaB	|  pathA pathB shorterSize |	pathA := pragmaA argumentAt: 2.	pathB := pragmaB argumentAt: 2.	pathA = '/' ifTrue: [ ^false].	pathB = '/' ifTrue: [ ^true].	pathA := (Net.PartialURL fromString: pathA) path.	pathB := (Net.PartialURL fromString: pathB) path.	shorterSize := pathA size min: pathB size.	"Go through the matching path components and compare one by one. Strict inequality wins right away."	1 to: shorterSize do: [ :index |		| componentA componentB |		componentA := pathA at: index.		componentB := pathB at: index.		"Check for terminal or multiple '/'. "		(componentA isEmpty and: [ componentB notEmpty ]) ifTrue: [ ^ false].		(componentA notEmpty and: [ componentB isEmpty ]) ifTrue: [ ^ true].		(componentA &lt; componentB) ifTrue: [ ^ true ].		(componentA &gt; componentB) ifTrue: [ ^ false ].		].	"All path components up to here were matching. Only one of the two paths may be deeper than the other.	The deeper path must come first."	^pathA size &gt;= pathB size</body><body package="SiouX-Server">respondersFor: aServer	| responders pragmas responder |	responders := OrderedCollection new.	(pragmas := self configurationPragmasForServer: aServer) notEmpty ifTrue: [		pragmas do: [ :pragma | 			responder := self createResponderFrom: pragma for: aServer.			aServer responders 					detect: [ :each | each isSameAs: responder] 					ifNone: [ responders add: responder  ]]].	^responders</body></methods><methods><class-id>SiouX.Responder class</class-id> <category>instance creation</category><body package="SiouX-Server">path: aString"	Answer a new instance of myself with path set to aString."	^ self new		path: aString;		yourself</body></methods><methods><class-id>SiouX.RequestStatusLineTooLarge</class-id> <category>printing</category><body package="SiouX-Announcements">printOn: aStream	super printOn: aStream.	aStream space.	aStream nextPutAll: statusLine</body></methods><methods><class-id>SiouX.RequestStatusLineTooLarge</class-id> <category>accessing</category><body package="SiouX-Announcements">statusLine	^statusLine</body><body package="SiouX-Announcements">statusLine: aString	statusLine := aString</body></methods><methods><class-id>SiouX.RequestStatusLineTooLarge</class-id> <category>log extensions</category><body package="SiouX-Loggers">logRequestStatusLineOn: aStream	aStream put: $".	aStream write: self statusLine .  "The request line from the client is given in double quotes. "	aStream put: $"</body><body package="SiouX-Loggers">logResponseCodeOn: aStream	aStream 		space;		write: '414'; "This is the status code that the server sends back to the client"		space.	"The last part indicates the size of the object returned to the client, not including the response headers. If no content was returned to the client, this value will be - " 	aStream write: '0'</body></methods><methods><class-id>SiouX.ResponderAnnouncement</class-id> <category>accessing</category><body package="SiouX-Announcements">responder	^responder</body><body package="SiouX-Announcements">responder: anObject	responder := anObject</body></methods><methods><class-id>SiouX.ResponderAnnouncement class</class-id> <category>instance creation</category><body package="SiouX-Announcements">responder: aResponder	^self new		responder: aResponder;		yourself</body></methods><methods><class-id>SiouX.ResponseSent</class-id> <category>accessing</category><body package="SiouX-Announcements">size	^size</body></methods><methods><class-id>SiouX.ResponseSent</class-id> <category>initialize-release</category><body package="SiouX-Announcements">request: aRequest response: aResponse size: anInteger	request := aRequest.	response := aResponse.	size := anInteger.</body></methods><methods><class-id>SiouX.ResponseSent</class-id> <category>printing</category><body package="SiouX-Announcements">printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' sent '.	response printStatusLineOn: aStream</body></methods><methods><class-id>SiouX.ResponseSent class</class-id> <category>instance creation</category><body package="SiouX-Announcements">request: request response: response connection: aConnection size: anInteger	^(self connection: aConnection)		request: request response: response size: anInteger;		yourself</body></methods><methods><class-id>SiouX.ConnectionClosed</class-id> <category>printing</category><body package="SiouX-Announcements">printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' closed'.</body></methods><methods><class-id>SiouX.CommonLog</class-id> <category>services</category><body package="SiouX-Loggers">log: anAnnouncement	| timestamp |	(anAnnouncement class = RequestReceived) 		ifTrue: [ ^requestTimestamps at: anAnnouncement request put: Timestamp now ].	timestamp := requestTimestamps removeKey: anAnnouncement request ifAbsent: [ Timestamp now ].	self logSentResponse: anAnnouncement timestamp: timestamp</body></methods><methods><class-id>SiouX.CommonLog</class-id> <category>logging</category><body package="SiouX-Loggers">startLogging	requestTimestamps := IdentityDictionary new.	super startLogging</body><body package="SiouX-Loggers">stopLogging	super stopLogging.	requestTimestamps := nil.</body></methods><methods><class-id>SiouX.CommonLog</class-id> <category>accessing</category><body package="SiouX-Loggers">announcements	^announcements ifNil: [ announcements := RequestReceived, ResponseSent, ResponseSendingFailed, RequestStatusLineTooLarge ]</body></methods><methods><class-id>SiouX.CommonLog</class-id> <category>private</category><body package="SiouX-Loggers">logSentResponse: anAnnouncement timestamp: timestamp	anAnnouncement connection id printBytesOn: self stream. "This is the IP address of the client (remote host) which made the request to the server."	self stream 		space;		write: '-'; "The hyphen in the output indicates that the requested piece of information is not available. In this case, the information that is not available is the RFC 1413 identity of the client determined by identd on the clients machine. This information is highly unreliable and should almost never be used except on tightly controlled internal networks."		space;		write: '-'. "This is the userid of the person requesting the document as determined by HTTP authentication. If the status code for the request (see below) is 401, then this value should not be trusted because the user is not yet authenticated. If the document is not password protected, this part will be -."	self stream space.	self printTimestamp: timestamp.	self stream space.		anAnnouncement logRequestStatusLineOn: self stream.	anAnnouncement logResponseCodeOn: self stream.	self logNewLine.	"Whenever there are no pending requests, use that as an opportunity to flush to disk.	Otherwise, 'cat &lt;logfile&gt;'  won't show anything until logging is stopped, making logs inaccessible from a command line."	requestTimestamps isEmpty ifTrue: [ self stream flush ]</body></methods><methods><class-id>SiouX.CommonLog class</class-id> <category>default values</category><body package="SiouX-Loggers">defaultFileName	^'common'</body></methods><methods><class-id>SiouX.CommonLog class</class-id> <category>tools</category><body package="SiouX-Loggers">helpText	^#CommonLogHelp &lt;&lt; #www &gt;&gt;'This logger implements the ''Common Log Format'', also known as the ''NCSA Common log format'', which is a popular text file log format used by a number of web servers. The common log file format logs one line for each completed request, where the line has following structure:	    remotehost ident authuser [date] "request" status bytes'</body></methods><methods><class-id>SiouX.ResponderNotFound</class-id> <category>printing</category><body package="SiouX-Announcements">printOn: aStream	super printOn: aStream.	request ifNotNil: [ request printStatusLineOn: aStream ]</body></methods><methods><class-id>SiouX.ResponderNotFound</class-id> <category>accessing</category><body package="SiouX-Announcements">request	^request</body><body package="SiouX-Announcements">request: anObject	request := anObject</body></methods><methods><class-id>SiouX.ResponderNotFound class</class-id> <category>instance creation</category><body package="SiouX-Announcements">request: aRequestLine connection: aConnection	^(self connection: aConnection)		request: aRequestLine;		yourself</body></methods><methods><class-id>SiouX.ServerRemoved</class-id> <category>accessing</category><body package="SiouX-Announcements">server	^server</body><body package="SiouX-Announcements">server: anObject	server := anObject</body></methods><methods><class-id>SiouX.ServerRemoved class</class-id> <category>instance creation</category><body package="SiouX-Announcements">server: aServer	^ self new		server: aServer;		yourself</body></methods><methods><class-id>SiouX.StatusUpdate</class-id> <category>accessing</category><body package="SiouX-Loggers">statistics	^statistics</body><body package="SiouX-Loggers">statistics: aDictionary	statistics := aDictionary</body></methods><methods><class-id>SiouX.StatusUpdate class</class-id> <category>instance creation</category><body package="SiouX-Loggers">on: aDictionary		^self new		statistics: aDictionary;		yourself</body></methods><methods><class-id>SiouX.ConnectionFailed</class-id> <category>accessing</category><body package="SiouX-Announcements">exception	^exception</body><body package="SiouX-Announcements">exception: anObject	exception := anObject</body></methods><methods><class-id>SiouX.ConnectionFailed</class-id> <category>printing</category><body package="SiouX-Announcements">printOn: aStream	exception 		ifNil: [ super printOn: aStream ]		ifNotNil: [ aStream nextPutAll: exception description ]</body></methods><methods><class-id>SiouX.ConnectionFailed class</class-id> <category>instance creation</category><body package="SiouX-Announcements">exception: anException connection: aConnection	^self new		exception: anException;		connection: aConnection;		yourself</body></methods><methods><class-id>SiouX.RequestContext</class-id> <category>accessing</category><body package="SiouX-Server">connection	^connection</body><body package="SiouX-Server">connection: anHttpConnection	connection := anHttpConnection</body><body package="SiouX-Server">data	^ data</body><body package="SiouX-Server">data: anObject	data := anObject</body><body package="SiouX-Server">properties	^properties ifNil: [ properties := Dictionary new ]</body><body package="SiouX-Server">propertyAt: aKey	^ self propertyAt: aKey ifAbsent: [nil]</body><body package="SiouX-Server">propertyAt: aKey ifAbsent: aBlock	^ self properties at: aKey ifAbsent: aBlock</body><body package="SiouX-Server">propertyAt: aKey put: aValue	^ self properties at: aKey put: aValue</body><body package="SiouX-Server">protocolVersion	^connection protocolVersion</body><body package="SiouX-Server">request	^request</body><body package="SiouX-Server">request: anObject	request := anObject</body><body package="SiouX-Server">responder	^responder</body><body package="SiouX-Server">responder: anObject	responder := anObject</body><body package="SiouX-Server">response	^response ifNil: [		response := responder ifNotNil: [ responder newResponse ]]</body><body package="SiouX-Server">response: aResponse	response := aResponse</body></methods><methods><class-id>SiouX.RequestContext</class-id> <category>services</category><body package="SiouX-Server">dispatch	responder dispatchRequest: self</body><body package="SiouX-Server">installInProcessEnvironment	ProcessEnvironment at: #currentRequestContext put: self.</body><body package="SiouX-Server">removeFromProcessEnvironment	ProcessEnvironment localRemoveKey: #currentRequestContext</body><body package="SiouX-Server">sendResponse	self protocolVersion sendResponseFor: self</body><body package="SiouX-Server">sendResponse: aResponse	self response: aResponse.	self sendResponse</body></methods><methods><class-id>SiouX.RequestContext</class-id> <category>initialize-release</category><body package="SiouX-Server">initializeFor: aResponder connection: aConnection	responder := aResponder.	connection := aConnection.	self installInProcessEnvironment.</body></methods><methods><class-id>SiouX.RequestContext class</class-id> <category>instance creation</category><body package="SiouX-Server">for: aResponder connection: aConnection	^ self new		initializeFor: aResponder connection: aConnection;		yourself</body></methods><methods><class-id>SiouX.RequestContext class</class-id> <category>accessing</category><body package="SiouX-Server">current	^ ProcessEnvironment at: #currentRequestContext</body></methods><methods><class-id>SiouX.RequestExecutionFailed</class-id> <category>printing</category><body package="SiouX-Announcements">printOn: aStream	exception 		ifNil: [ super printOn: aStream ]		ifNotNil: [ aStream nextPutAll: exception description ]</body></methods><methods><class-id>SiouX.RequestExecutionFailed</class-id> <category>accessing</category><body package="SiouX-Announcements">exception	^exception</body><body package="SiouX-Announcements">exception: anObject	exception := anObject</body><body package="SiouX-Announcements">responder	^responder</body><body package="SiouX-Announcements">responder: anObject	responder := anObject</body></methods><methods><class-id>SiouX.RequestExecutionFailed class</class-id> <category>instance creation</category><body package="SiouX-Announcements">exception: anException responder: responder request: request connection: aConnection	^self new		exception: anException;		connection: aConnection;		request: request;		responder: responder;		yourself</body></methods><methods><class-id>SiouX.ConnectionOpened</class-id> <category>printing</category><body package="SiouX-Announcements">printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' opening'.</body></methods><methods><class-id>Protocols.AnnouncementLogger class</class-id> <category>accessing class hierarchy</category><body package="SiouX-Loggers">abstractRoot	^AnnouncementLogger</body></methods><methods><class-id>Protocols.AnnouncementLogger class</class-id> <category>tools</category><body package="SiouX-Loggers">helpText	^String new</body></methods><methods><class-id>Protocols.AnnouncementLogger class</class-id> <category>testing</category><body package="SiouX-Loggers">isAbstract	^self == self abstractRoot</body></methods><methods><class-id>Protocols.AnnouncementLogger class</class-id> <category>accessing</category><body package="SiouX-Loggers">loggers	^self allSubclasses select: [ :cl | cl isAbstract not]</body></methods><methods><class-id>SiouX.RequestFilter class</class-id> <category>configuration</category><body package="SiouX-Server">configurationPragmas	"Answer an array of pragma keywords used to configure filters. "	&lt;pragmas: #instance&gt;	^ #( #configuration: )</body></methods><methods><class-id>SiouX.Server class</class-id> <category>persistence</category><body package="SiouX-Server">pragmas	&lt;pragmas: #class&gt;	^#(server:)</body></methods><methods><class-id>SiouX.Responder class</class-id> <category>pragmas</category><body package="SiouX-Server">configurationPositionPragma"The #position: pragma is deprecated and kept for backward compatibility only.Initially the responders is sorted alphabetically by the path string with the root path â/â as the last one "	&lt;pragmas: #class&gt;	self deprecated: #(#version '8.3' #sunset '8.4' ).	^ #(  #position: )</body><body package="SiouX-Server">configurationPragmas	&lt;pragmas: #class&gt;	^ #( #server:path: #requestFilter: #requestFilter:configuration: )</body></methods><methods><class-id>Core.CommandLineInterest class</class-id> <category>command line options</category><body package="SiouX-Server">webServerConfigFileName: aTokenStream	&lt;triggerAtSystemEvent: #returnFromSnapshot option: '-wwwconfig'&gt;	SiouX.Server loadFrom: aTokenStream next</body></methods><methods><class-id>Protocols.ProtocolVersion</class-id> <category>services</category><body package="SiouX-Server">acceptsProtocolIdentifier: aCollection	^false</body><body package="SiouX-Server">dispatchRequest: requestContext</body></methods><methods><class-id>Protocols.ProtocolVersion</class-id> <category>upgrade</category><body package="SiouX-Server">invalidHostOriginError: aRequestContext	^ (aRequestContext response code: 403)		signalReady</body></methods><methods><class-id>Protocols.ProtocolVersion</class-id> <category>private</category><body package="SiouX-Server">parseHeadersFor: requestContext	^self subclassResponsibility</body></methods><methods><class-id>Protocols.ProtocolVersion</class-id> <category>services</category><body package="SiouX-Server">processRequest: aRequestContext	^self subclassResponsibility</body></methods><methods><class-id>Protocols.ProtocolVersion</class-id> <category>private</category><body package="SiouX-Server">readRequestLineFrom: aConnectionOrStream	^self subclassResponsibility</body></methods><methods><class-id>Protocols.ProtocolVersion</class-id> <category>services</category><body package="SiouX-Server">requestContextFor: aConnectionOrStream		| responder requestContext requestLine |	requestLine := self readRequestLineFrom: aConnectionOrStream.	responder := connection server findResponderFor: requestLine on: connection. 	(requestContext := responder requestContextClass new) initializeFor: responder connection: connection.	responder setRequestIn: requestContext from: requestLine.	self setStreamFor: requestContext from: aConnectionOrStream.		self parseHeadersFor: requestContext.	^requestContext</body><body package="SiouX-Server">sendResponseFor: aRequestContext	| bodySize request response  |		request := aRequestContext request.	response := aRequestContext response.	[ connection server		preparedResponse: response		responder: nil		request: request		connection: connection.	bodySize := self writeResponseBlock value: aRequestContext.	request ifNotNil: [request release].	 connection server		sentResponse:  response		request: request		connection: connection		size: bodySize]			on: Error			do: 				[:ex |				connection persist: false.				 connection server					responseTransmissionError: ex					response: response					request: request					connection: self.				ex pass].	^true</body></methods><methods><class-id>Protocols.ProtocolVersion</class-id> <category>private</category><body package="SiouX-Server">setStreamFor: requestContext from: aConnectionOrStream</body></methods><methods><class-id>Protocols.ProtocolVersion</class-id> <category>upgrade</category><body package="SiouX-Server">upgradeRequest: aRequestContext	self subclassResponsibility</body></methods><methods><class-id>Protocols.ProtocolVersion</class-id> <category>services</category><body package="SiouX-Server">writeResponseBlock	^writeResponseBlock ifNil: [ 		writeResponseBlock := [ :requestContext | | bodySize |			bodySize := requestContext response writeOnConnection: connection.			"The connection writeStream may have been reset if the connection was closed during writing.			Flush only if the writeStream is still present."			connection writeStream ifNotNil: [:writeStream | writeStream flush].			bodySize ]	]</body></methods><methods><class-id>Protocols.HTTPv11</class-id> <category>services</category><body package="SiouX-Server">acceptsProtocolIdentifier: aCollection	^true</body><body package="SiouX-Server">dispatchRequest: requestContext		requestContext dispatch</body></methods><methods><class-id>Protocols.HTTPv11</class-id> <category>private</category><body package="SiouX-Server">parseHeadersFor: anRequestContext"http://httpwg.org/specs/rfc7230.html#header.hostA client MUST send a Host header field in all HTTP/1.1 request messages.A server MUST respond with a 400 (Bad Request) status code to any HTTP/1.1 request message that lacks a Host header field and to any request message that contains more than one Host header field or a Host header field with an invalid field-value"	anRequestContext request parseHeaders: self readHeaderSource.	self validateHostHeaderFor: anRequestContext request.	connection persist: (connection isPersistent and: [anRequestContext request isConnectionClose not]).</body></methods><methods><class-id>Protocols.HTTPv11</class-id> <category>services</category><body package="SiouX-Server">processRequest: aRequestContext	self dispatchRequest: aRequestContext</body></methods><methods><class-id>Protocols.HTTPv11</class-id> <category>private</category><body package="SiouX-Server">readHeaderSource"This reads entire header content into a String. The code is trying to avoid making multiple String instances in the process."	^[		self readHeaderSourceFrom: connection readStream			]	on: Xtreams.Incomplete		do: [ :ex |			connection persist: false.			connection requestHeaderExceededSizeLimit ].</body><body package="SiouX-Server">readHeaderSourceFrom: aStream"This reads entire header content into a String. The code is trying to avoid making multiple String instances in the process."	| buffer bufferWriting headerSource stream  |	buffer := ByteString newRecycledDefaultSize.	bufferWriting := buffer writing.	connection ifNotNil: [ bufferWriting := bufferWriting  limiting: connection requestHeaderLimit].	stream := (aStream ending: #[13 10 13 10]) encoding: #'ISO8859_1'.	[			bufferWriting write: stream; put: SiouX.CR.		headerSource := buffer copyFrom: 1 to: bufferWriting position.	] ensure: [ 			stream close.		buffer recycle].	^headerSource</body><body package="SiouX-Server">readRequestLineFrom: anHttpConnection	| stream line buffer bufferWriting requestLine |	stream := (anHttpConnection readStream ending: #[13 10]) encoding: #'ISO8859_1'.	buffer := ByteString newRecycledDefaultSize.	[ 	bufferWriting := buffer writing limiting: connection listener requestStatusLineLimit.		[ bufferWriting write: stream] 			on: Xtreams.Incomplete			do: [ :ex | 				connection persist: false.				^connection listener requestStatusLineLimit &gt;= ex count					ifTrue: [connection requestStatusLineTooLarge: (buffer copyFrom: 1 to: bufferWriting position)]					ifFalse: [ ex pass ] ].		line := (buffer copyFrom: 1 to: bufferWriting position) reading	] ensure: [ stream close.			buffer recycle] .	requestLine := SiouX.RequestLine on: anHttpConnection.	[requestLine method: (line ending: SiouX.SPACE) rest.	line skipWhitespace.	requestLine path:  (line ending: SiouX.SPACE) rest.	line skipWhitespace.	requestLine version: line rest	] ensure: [ line close ].	^requestLine</body></methods><methods><class-id>Protocols.HTTPv11</class-id> <category>upgrade</category><body package="SiouX-Server">upgrade: aRequestContext</body><body package="SiouX-Server">upgradeRequest: aRequestContext	"No upgrade"</body></methods><methods><class-id>Protocols.HTTPv11</class-id> <category>private</category><body package="SiouX-Server">validateHostHeaderFor: aRequest"http://httpwg.org/specs/rfc7230.html#header.hostA client MUST send a Host header field in all HTTP/1.1 request messages.A server MUST respond with a 400 (Bad Request) status code to any HTTP/1.1 request message that lacks a Host header field and to any request message that contains more than one Host header field or a Host header field with an invalid field-value"	|  hosts |		hosts := aRequest headers select: [ :h | h name = 'host'].	hosts size &gt; 1 ifTrue: [		connection badRequestError: (#RequestIncludesExtraHost &lt;&lt; #www &gt;&gt; 'The request includes the Host header field more than once')].	hosts size = 0 ifTrue: [		connection badRequestError:  (#MissingHostHeader &lt;&lt; #www &gt;&gt;'The request is missing the Host header field')].		"If HttpListener doesn't provide accepted server names for verification the request Host field let''s skip it"	connection acceptedServerNames notEmpty ifTrue: [		(connection acceptedServerNames includes: (aRequest host tokensBasedOn: $:) first) ifFalse: [			connection badRequestError:  (#WrongHostHeader &lt;&lt; #www &gt;&gt;'The request Host header field is wrong')]].</body></methods><methods><class-id>Xtreams.ReadStream</class-id> <category>sioux</category><body package="SiouX-Server">skipWhitespace	[ SiouX.WHITESPACE includes: self get ] whileTrue.	self -- 1</body></methods><initialize><class-id>SiouX.HttpConnection</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ProtocolVersion</name><environment>Protocols</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection validateHostOriginBlock writeResponseBlock settings </inst-vars><class-inst-vars>validateHostOriginBlock </class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http</package></attributes></class><class><name>Announcer</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subscriptionRegistry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>System-Announcements</package></attributes></class><class><name>Subsystem</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state canActivate prerequisites </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class><class><name>AnnouncementLogger</name><environment>Protocols</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isLogging accessProtect announcements announcers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Common</package></attributes></class><class><name>Announcement</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Announcements</category><attributes><package>System-Announcements</package></attributes></class><class><name>ReadStream</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars>source </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.BehaviorIcons			</imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>HTTPv11</name><environment>Protocols</environment><super>Protocols.ProtocolVersion</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http</package></attributes></class></st-source>