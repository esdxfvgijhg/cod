<?xml version="1.0"?><st-source><!-- Name: HashesBaseNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: This package collects generic components and base class extensions that are useful for various hash algorithm implementations. It also defines the essential APIs that the implementations are expected to support.DbIdentifier: bear73DbTrace: 469302DbUsername: tkoganDbVersion: 8.2 - 0DevelopmentPrerequisites: #(#(#package 'SecurityBase' ''))PackageName: HashesBaseParcel: #('HashesBase')PrerequisiteParcels: #(#('SecurityBase' ''))PrintStringCache: (8.2 - 0,tkogan)Version: 8.2 - 0Date: 12:06:17 PM July 28, 2017 --><time-stamp>From VisualWorksÂ®, 8.3 of July 28, 2017 on July 28, 2017 at 12:06:17 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>MessageDigest</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Hashes</category><attributes><package>HashesBase</package></attributes></class><comment><class-id>Security.MessageDigest</class-id><body>This is the abstract superclass of message digests. It defines common API with two level structure. The higher level (protocol 'services') is simpler, providing methods to perform a digest computation on a byte object using single message. These messages provide the digest as a return value. The lower level API (protocol 'services-basic') requires several messages to complete the digest computation, but provides more flexibility. It allows to compute a "running digest" on data that is not all available at the same time. It's derived from the usual Update/Final API scheme, except in our case the "Final" phase is embedded into the call for obtaining the digest value, #digest. That makes for a simpler API, and even allows to support intermediate calls for digest value before all the data was processed.Subclasses must implement:	instance protocol:		copy		updateWithNext:from:		updateWith:from:to:		blockSize		updateWith:		messageLength		digestInto:startingAt:		updateFrom:		digestSize</body></comment><class><name>HMAC</name><environment>Security</environment><super>Security.MessageDigest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ihash ohash ipad opad </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Hashes</category><attributes><package>HashesBase</package></attributes></class><comment><class-id>Security.HMAC</class-id><body>This is an implementation of HMAC as described in RFC 2104, http://www.ietf.org/rfc/rfc2104.txt.MACs (Message authentication codes) are used to provide integrity of messages. A MAC digest prevents an attacker from altering contents of protected messages without being detected. MACs are often characterized as a 'hash function with a secret key', as such they are usually built on top of secure hash functions like MD5 and SHA. HMAC is one such MAC function. The API sticks to the 'hash with a key' definition, it includes all the public messages of MessageDigests, plus the additional (required) #setKey: message. There are predefined instance creation messages that preinitialize the instance with the undelying hash function (MD5 or SHA) and optionally with the key as well. Note that it is required to set the key before any data can be processed by the HMAC. Here's an example:	(HMAC MD5: 'secret key' asByteArray)		hash: 'Try changing this without knowing the secret key!'Instance Variables:	ihash	&lt;Hash&gt;	inner hash function	ohash	&lt;Hash&gt;	outer hash function	ipad	&lt;ByteArray&gt;	inner pad cache, (ByteArray new: 64 withAll: 16r36) bitXor: key	opad	&lt;ByteArray&gt;	outer pad cache, (ByteArray new: 64 withAll: 16r5C) bitXor: key</body></comment><class><name>Hash</name><environment>Security</environment><super>Security.MessageDigest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block position total </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Hashes</category><attributes><package>HashesBase</package></attributes></class><comment><class-id>Security.Hash</class-id><body>This is the abstract superclass of hash algorithms. It implements common aspects of the two supported hash functions MD5 and SHA. It fleshes out the generic "compression function" aspect (buffer management and block processing) and the common aspects of the MD4 class of hash functions (message length encoding and digest value assembly).Subclasses must implement:	instance protocol:		storeLength		backupRegisters		restoreRegisters:		processBlock		writeDigestInto:startingAt:		readBlock	class protocol:		blockSize		digestSizeInstance Variables:	block	&lt;ByteArray&gt;	a message block buffer of size self blockSize	position	&lt;SmallInteger&gt;	number of bytes currently in the buffer	total	&lt;Integer&gt;	number of already processed blocks</body></comment><methods><class-id>Security.MessageDigest</class-id> <category>services-basic</category><body package="HashesBase">copy"Allows to clone the algorithm instance to proceed with the hash computation in multiple directions"	^self subclassResponsibility</body><body package="HashesBase">digest"Return the digest value for the data provided so far"	| result |	result := ByteArray new: self digestSize.	self digestInto: result startingAt: 1.	^result</body><body package="HashesBase">digestInto: aByteArray startingAt: start"Write the current digest value into aByteArray at index start"	^self subclassResponsibility</body><body package="HashesBase">messageLength"Returns current length of the message in bits"	^self subclassResponsibility</body><body package="HashesBase">reset"Reset the hash function to its initial state"</body><body package="HashesBase">updateFrom: aReadStream"Update the hash function with all the available data from aReadStream"	^self subclassResponsibility</body><body package="HashesBase">updateWith: aByteArray"Update the hash function with the data from aByteArray"	^self subclassResponsibility</body><body package="HashesBase">updateWith: aByteArray from: start to: end"Update the hash function with the block of data  from position start to position end in aByteArray"	^self subclassResponsibility</body><body package="HashesBase">updateWithNext: count from: aReadStream"Update the hash function with count bytes from aReadStream"	^self subclassResponsibility</body></methods><methods><class-id>Security.MessageDigest</class-id> <category>services</category><body package="HashesBase">hash: aByteArrayOrString"Return the digest value for aByteArrayOrString"	^self reset;		updateWith: aByteArrayOrString asByteArray;		digest</body><body package="HashesBase">hash: aByteArrayOrString from: start to: end"Returns the digest value for the block of data from position start to position end in aByteArray"	^self reset;		updateWith: aByteArrayOrString asByteArray from: start to: end;		digest</body><body package="HashesBase">hashFrom: aReadStream"Return the digest value for the available data in aReadStream"	^self reset;		updateFrom: aReadStream;		digest</body><body package="HashesBase">hashNext: anInteger from: aReadStream"Returns digest value for count bytes from aReadStream"	^self reset;		updateWithNext: anInteger from: aReadStream;		digest</body></methods><methods><class-id>Security.MessageDigest</class-id> <category>accessing</category><body package="HashesBase">blockSize"The size of data chunks being processed at once (bytes)"	^self subclassResponsibility</body><body package="HashesBase">digestSize"The size of resulting hash value (bytes)"	^self subclassResponsibility</body><body package="HashesBase">hashSize"The size of resulting hash value (bytes)"	^self digestSize</body></methods><methods><class-id>Security.HMAC</class-id> <category>accessing</category><body package="HashesBase">blockSize	^ohash blockSize</body><body package="HashesBase">digestSize	^ihash digestSize</body></methods><methods><class-id>Security.HMAC</class-id> <category>initialize-release</category><body package="HashesBase">setHash: aHash	ihash := aHash.	ohash := aHash copy</body><body package="HashesBase">setKey: aByteArray	| key |	aByteArray size &lt; self digestSize ifTrue: [ | resumeValue |		resumeValue := Warning raiseRequestWith: aByteArray errorString: 'Key is very short. Continue ?'.		(resumeValue isNil or: [ resumeValue ]) ifFalse: [^self] ].	key := aByteArray size &gt; self blockSize			ifTrue: [ ihash hash: aByteArray ]			ifFalse: [ aByteArray ].	ipad := ByteArray new: ihash blockSize withAll: 16r36.	opad := ByteArray new: ohash blockSize withAll: 16r5C.	key keysAndValuesDo: [ :i :b |		ipad at: i put: ((ipad at: i) bitXor: b).		opad at: i put: ((opad at: i) bitXor: b) ].	self reset</body></methods><methods><class-id>Security.HMAC</class-id> <category>printing</category><body package="HashesBase">printOn: aStream	aStream		nextPutAll: 'HMAC-';		nextPutAll: ihash class name</body></methods><methods><class-id>Security.HMAC</class-id> <category>services-basic</category><body package="HashesBase">copy"Allows to clone the algorithm instance to proceed with the hash computation in multiple directions"	^self class new		setIHash: ihash copy		oHash: ohash copy		iPad: ipad copy		oPad: opad copy;		yourself</body><body package="HashesBase">digestInto: aByteArray startingAt: start	self checkKey.	ihash digestInto: aByteArray startingAt: start.	ohash reset;		updateWith: opad;		updateWith: aByteArray from: start to: start + ihash digestSize - 1;		digestInto: aByteArray startingAt: start</body><body package="HashesBase">messageLength"Returns current length of the message in bits"	self checkKey.	^ihash messageLength - (ihash blockSize * 8)</body><body package="HashesBase">reset	self checkKey.	ihash reset;		updateWith: ipad</body><body package="HashesBase">updateFrom: aReadStream	self checkKey.	^ihash updateFrom: aReadStream</body><body package="HashesBase">updateWith: aByteArray	self checkKey.	^ihash updateWith: aByteArray</body><body package="HashesBase">updateWith: aByteArray from: start to: end	self checkKey.	^ihash updateWith: aByteArray from: start to: end</body><body package="HashesBase">updateWithNext: count from: aReadStream	self checkKey.	^ihash updateWithNext: count from: aReadStream</body></methods><methods><class-id>Security.HMAC</class-id> <category>private</category><body package="HashesBase">checkKey	ipad isNil ifTrue: [		self error: 'Cannot use HMAC without setting the key!' ]</body><body package="HashesBase">setIHash: iHash oHash: oHash iPad: iPad oPad: oPad"Used to initialize a clone"	ihash := iHash.	ohash :=  oHash.	ipad := iPad.	opad :=  oPad</body></methods><methods><class-id>Security.HMAC class</class-id> <category>instance creation</category><body package="HashesBase">hash: aHash	^self new		setHash: aHash;		yourself</body></methods><methods><class-id>Security.Hash</class-id> <category>deprecated</category><body package="HashesBase">byteHash: aStringOrByteArray 	^self hash: aStringOrByteArray</body><body package="HashesBase">byteHash: aByteArrayOrString from: start to: end	^self hash: aByteArrayOrString from: start to: end</body><body package="HashesBase">byteHashNext: anInteger inStream: aStream	^self hashNext: anInteger from: aStream</body><body package="HashesBase">byteHashStream: aStream	^self hashFrom: aStream</body><body package="HashesBase">integerHash: aByteArrayOrString	^(self hash: aByteArrayOrString) asBigEndianInteger</body><body package="HashesBase">integerHash: aByteArrayOrString from: start to: end	^(self hash: aByteArrayOrString from: start to: end) asBigEndianInteger</body><body package="HashesBase">integerHashNext: anInteger inStream: aStream	^(self hashNext: anInteger from: aStream) asBigEndianInteger</body><body package="HashesBase">integerHashStream: aStream	^(self hashFrom: aStream) asBigEndianInteger</body></methods><methods><class-id>Security.Hash</class-id> <category>accessing</category><body package="HashesBase">blockSize"The size of data chunks being processed at once (bytes)"	^self class blockSize</body><body package="HashesBase">digestSize"The size of resulting hash value (bytes)"	^self class digestSize</body></methods><methods><class-id>Security.Hash</class-id> <category>private-algorithm</category><body package="HashesBase">processBlock	self subclassResponsibility</body><body package="HashesBase">readBlock"read in the message block"	self subclassResponsibility</body><body package="HashesBase">resetBuffer	position := 0.	total := 0.</body><body package="HashesBase">updateWithBlock	self processBlock.	total := total + 1.</body></methods><methods><class-id>Security.Hash</class-id> <category>private-digest</category><body package="HashesBase">backupRegisters"This has to match with #restoreRegisters:"	^self subclassResponsibility</body><body package="HashesBase">doublePaddedDigestInto: aByteArray startingAt: start	| backup bufferBackup wroteOne |	backup := self backupRegisters.	wroteOne := false.	position &lt; 64 ifTrue: [		block at: position + 1 put: 16r80. wroteOne := true.		position + 2 to: self blockSize do: [ :i | block at: i put: 0 ] ].	self processBlock.	bufferBackup := block.	block := ByteArray new: self blockSize.	(wroteOne		ifTrue: [1]		ifFalse: [block at: 1 put: 16r80. 2]	)	to: self blockSize - 8		do: [ :i | block at: i put: 0 ].	self storeLength.	self processBlock.	self writeDigestInto: aByteArray startingAt: start.	block := bufferBackup.	self restoreRegisters: backup</body><body package="HashesBase">enoughRoomToPad	^self blockSize - 9 &gt;= position</body><body package="HashesBase">restoreBuffer: aByteArray total: blockCount position: blockPosition	block replaceFrom: 1 to: block size with: aByteArray.	total := blockCount.	position := blockPosition</body><body package="HashesBase">restoreRegisters: anArrayOfRegisters"This has to match with #backupRegisters"	self subclassResponsibility</body><body package="HashesBase">singlePaddedDigestInto: aByteArray startingAt: start	| backup |	backup := self backupRegisters.	block at: position + 1 put: 16r80.	position + 2 to: (self blockSize - 8) do: [ :i | block at: i put: 0 ].	self storeLength.	self processBlock.	self writeDigestInto: aByteArray startingAt: start.	self restoreRegisters: backup.</body><body package="HashesBase">storeLength	self subclassResponsibility</body><body package="HashesBase">writeDigestInto: aByteArray startingAt: start	self subclassResponsibility</body></methods><methods><class-id>Security.Hash</class-id> <category>services-basic</category><body package="HashesBase">copy"Allows to clone the algorithm instance to proceed with the hash computation in multiple directions"	| new |	new := self class new.	new restoreRegisters: self backupRegisters.	new restoreBuffer: block total: total position: position.	^new</body><body package="HashesBase">digestInto: aByteArray startingAt: start"Write the current digest value into aByteArray at index start"	self enoughRoomToPad		ifTrue: [ self singlePaddedDigestInto: aByteArray startingAt: start ]		ifFalse: [ self doublePaddedDigestInto: aByteArray startingAt: start ]</body><body package="HashesBase">messageLength"Returns current length of the message in bits"	^(total * self blockSize + position) bitShift: 3</body><body package="HashesBase">reset"Reset the hash function to its initial state"	self resetBuffer</body><body package="HashesBase">updateFrom: aReadStream"Update the hash function with all the available data from aReadStream"	| blockSize left count |	blockSize := self blockSize.	left := blockSize - position.	"Try to finish current buffer"	count := aReadStream nextAvailable: left into: block startingAt: position + 1.	count &lt; left ifTrue: [ position := position + count. ^self ].	self updateWithBlock.	"Process as many full buffers as you can"	[	count := aReadStream nextAvailable: blockSize into: block startingAt: 1.		count &lt; blockSize	] whileFalse: [		self updateWithBlock ].	"Buffer the leftover"	position := count</body><body package="HashesBase">updateWith: aByteArray"Update the hash function with the data from aByteArray"	^self updateWithNext: aByteArray size from: aByteArray readStream</body><body package="HashesBase">updateWith: aByteArray from: start to: end"Update the hash function with the block of data  from position start to position end in aByteArray"	| blockSize left count pastEnd stop from |	blockSize := self blockSize.	"Try to finish current block"	left := blockSize - position.	pastEnd := end + 1.	count := pastEnd - start.	count &lt; left ifTrue: [		block replaceFrom: position + 1 to: position + count with: aByteArray startingAt: start.		position := position + count.		^self ].	block replaceFrom: position + 1 to: blockSize with: aByteArray startingAt: start.	self updateWithBlock.	from := start + left.	"Do as many full buffers as possible"	stop := pastEnd - blockSize.	[ from &gt; stop ] whileFalse: [		block replaceFrom: 1 to: blockSize with: aByteArray startingAt: from.		self updateWithBlock.		from := from + blockSize ].	"Buffer the leftover"	position := pastEnd - from.		block replaceFrom: 1 to: position with: aByteArray startingAt: from.</body><body package="HashesBase">updateWithNext: count from: aReadStream"Update the hash function with count bytes from aReadStream"	| blockSize left |	blockSize := self blockSize.	"Try to finish current block"	left := blockSize - position.	count &lt; left ifTrue: [		aReadStream next: count into: block startingAt: position + 1.		position := position + count.		^self ].	aReadStream next: left into: block startingAt: position + 1.	self updateWithBlock.	"Note that we're changing the meaning of 'left' here. Hope that's OK."	left := count - left.	"Do as many full buffers as possible"	[ left &gt; blockSize ] whileTrue: [		aReadStream next: blockSize into: block startingAt: 1.		self updateWithBlock.		left := left - blockSize ].	"Buffer the leftover"	aReadStream next: left into: block startingAt: 1.	position := left</body></methods><methods><class-id>Security.Hash</class-id> <category>initialize-release</category><body package="HashesBase">initialize	block := ByteArray new: self blockSize</body></methods><methods><class-id>Security.Hash class</class-id> <category>services</category><body package="HashesBase">hash: aByteArrayOrString	^self new hash: aByteArrayOrString</body><body package="HashesBase">hash: aByteArrayOrString from: start to: end	^self new hash: aByteArrayOrString from: start to: end</body><body package="HashesBase">hashFrom: aReadStream	^self new hashFrom: aReadStream</body><body package="HashesBase">hashNext: anInteger from: aReadStream	^self new hashNext: anInteger from: aReadStream</body></methods><methods><class-id>Security.Hash class</class-id> <category>deprecated</category><body package="HashesBase">byteHash: aByteArrayOrString 	^self new byteHash: aByteArrayOrString</body><body package="HashesBase">byteHash: aByteArrayOrString from: start to: end	^self new byteHash: aByteArrayOrString from: start to: end</body><body package="HashesBase">byteHashNext: anInteger inStream: aStream	^self new byteHashNext: anInteger inStream: aStream</body><body package="HashesBase">byteHashStream: aPositionableStream	^self new byteHashStream: aPositionableStream</body><body package="HashesBase">integerHash: aByteArrayOrString	^self new integerHash: aByteArrayOrString</body><body package="HashesBase">integerHash: aByteArrayOrString from: start to: end	^self new integerHash: aByteArrayOrString from: start to: end</body><body package="HashesBase">integerHashNext: anInteger inStream: aStream	^self new integerHashNext: anInteger inStream: aStream</body><body package="HashesBase">integerHashStream: aPositionableStream	^self new integerHashStream: aPositionableStream</body></methods><methods><class-id>Security.Hash class</class-id> <category>accessing</category><body package="HashesBase">blockSize	^self subclassResponsibility</body><body package="HashesBase">digestSize	^self subclassResponsibility</body></methods><methods><class-id>Security.Hash class</class-id> <category>instance creation</category><body package="HashesBase">new	^super new initialize</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>