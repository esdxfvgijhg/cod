<?xml version="1.0"?><st-source><!-- Name: SecurityBaseNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: This package declares the Security namespace and collects various generally useful extensions supporting the security frameworks.DbIdentifier: bear73DbTrace: 503490DbUsername: jkottDbVersion: 8.3 - 2PackageName: SecurityBaseParcel: #('SecurityBase')ParcelName: SecurityBasePrintStringCache: (8.3 - 2,jkott)Version: 8.3 - 2Date: 12:06:17 PM July 28, 2017 --><time-stamp>From VisualWorks®, 8.3 of July 28, 2017 on July 28, 2017 at 12:06:17 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Security</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>SecurityBase</category><attributes><package>SecurityBase</package></attributes></name-space><comment><name-space-id>Security</name-space-id><body> </body></comment><class><name>ThirtyTwoBitRegister</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hi low </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Hashes</category><attributes><package>SecurityBase</package></attributes></class><comment><class-id>Security.ThirtyTwoBitRegister</class-id><body>Increases efficiency of computations on 32-bit numbers by avoiding overflow into the large intergers. Works by splitting the 32-bit value in half to which are guaranteed to fit into the SmallInteger range.Instance Variables:	hi	&lt;SmallInteger&gt; the more significant half of the register	low	&lt;SmallInteger&gt; the less significant half of the register</body></comment><class><name>EuclidAlgorithm</name><environment>Security</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>a b u v gcd </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Security-Ciphers</category><attributes><package>SecurityBase</package></attributes></class><comment><class-id>Security.EuclidAlgorithm</class-id><body>Euclid Algorithm is used to compute the greatest commond divisor (GCD) of two integers. For more details consult Knuth volume 2.The Modular inverse problem is difficult to solve sometimes there is a solution and sometimes not. In general a**-1 = x (mod n) has a unique solution  is a and n are relatively prime. if a and n are not relatively prime, then the equation has no solution. If n is prime then every number 1 to n-1 is relatively prime to n and has exactly one inverse to the modulo n in that range.This class also implements extended Euclid algorithm, solving as + bt = gcd(a,b). For any two integers a and b, there are numbers s and t such that as + bt = gcd(a,b). In other words, gcd(a,b) is a linear combination of a and b. gcd(a,b) is the least positive combination of the two integers. a and b themselves are expressed as trivial combinations: a = 1·a + 0·b and b = 0·a + 1·b. Starting with these two, an extension of Euclid's algorithm finds s and t whose existence was so far only established in a formal way. Write the two linear combinations in a column and apply one step of Euclid's algorithm to the left-hand side. Assuming a = bp + r. Multiply the second equation by p and subtract it from the first equation:a = 1·a + 0·bb = 0·a + 1·br = 1·a + (-p)·bApply the same procedure to the last two equations. Continue in this manner until Euclid's algorithm on the left stops. On the right, there will be the linear combination we are after. Let check this with an example: let a = 2322, b = 654. I adopt the usual convention of solving linear equations and omit all the terms in a linear combination but the left-hand side and the two coefficients on the right. The results are placed into a table with the fourth column being equal to p (from a = bp + r, which changes on each step. Multiply three numbers to the left of p by p and subtract them from the numbers directly above them. Record the results on the next line.)left side  *a   *b   p  2322 1 0  654 0 1 3 360 1 -3 1 294 -1 4 1 66 2 -7 4 30 -9 32 2 6 20 -71 5 0    Therefore, 20·2322 - 71·654 = 6. Note that 20 and 71 are coprime. This is the case for any s ant t such that as + bt = gcd(a,b) because, otherwise, we would be able to divide the whole equation by their common factor. The right side, gcd(a,b), would also be divided by that number which would give a positive linear combination of a and b smaller than gcd(a,b). But we know that this is impossible. Division by gcd(a,b), in our case, leads to 20·387 - 71·109 = 1. Wherefrom, 71/387 and 20/109 are consecutive fractions in the Farey series of order 387.The algorithm, as described above, is a real extension of Euclid's algorithm in the sense that without removing any of the operations needed for the latter it only adds 2 multiplications and 2 subtractions on every step. Furthermore, these operations in no way affect the progress of Euclid's algorithm proper. Which proves that the extended algorithm terminates together with the common algorithm.Indeed, assume the extended algorithm has furnished s,t, and g such that as + bt = g. We can easily check whether or not g|a and g|b. Unless there was an error, this would imply g|gcd(a,b). Moreover, once g is expressed as a linear combination of a and b we know that gcd(a,b)|g. Therefore, indeed g = gcd(a,b). It thus appears that by finding s and t the algorithm actually proves its own correctness.ReferencesA.Engel, Exploring Mathematics with Your Computer, MAA, 1993 H.Davenport, The Higher Arithmetic, Harper&amp;Brothers, NY R.Graham, D.Knuth, O.Potashnik, Concrete Mathematics, 2nd edition, Addison-Wesley, 1994. D.Knuth, The Art of Computer Programming, v1,2.  Instances are extended Euclid algorithms. Given a, b two integers, they compute the GCD of them and another two integers, s, t, such that: (a gcd: b) = (s * a) + (t * b).Instance Variables:	a	&lt;Integer&gt; input	b	&lt;Integer&gt; input	u	&lt;Integer&gt; quotient	v	&lt;Integer&gt; quotient	gcd	&lt;Integer&gt; result</body></comment><methods><class-id>Security.ThirtyTwoBitRegister</class-id> <category>accessing</category><body package="SecurityBase">byte1	^hi bitShift: -8</body><body package="SecurityBase">byte2	^hi bitAnd: 255</body><body package="SecurityBase">byte3	^low bitShift: -8</body><body package="SecurityBase">byte4	^low bitAnd: 255</body><body package="SecurityBase">hi	^ hi</body><body package="SecurityBase">hi: anInteger	 hi := anInteger</body><body package="SecurityBase">hi: anInteger1 low: anInteger2	 hi := anInteger1.	low := anInteger2</body><body package="SecurityBase">low	^ low</body><body package="SecurityBase">low: anInteger	 low := anInteger</body></methods><methods><class-id>Security.ThirtyTwoBitRegister</class-id> <category>operations</category><body package="SecurityBase">+= aThirtyTwoBitRegister	"Replace my contents with the sum of the given register and my current contents."	low := low + aThirtyTwoBitRegister low.	hi := (hi + aThirtyTwoBitRegister hi			+ (low &gt; 16rFFFF ifTrue: [1] ifFalse: [0] )		) bitAnd: 16rFFFF.	low := low bitAnd: 16rFFFF</body><body package="SecurityBase">&lt;&lt; shift 	| tl |	shift &gt; 16		ifTrue: 			[hi := (low bitShift: shift - 16)						bitAnd: 65535.			low := 0]		ifFalse: 			[tl := low bitShift: shift - 16.			low := (low bitShift: shift)						bitAnd: 65535.			hi := ((hi bitShift: shift)						bitAnd: 65535)						+ tl]</body><body package="SecurityBase">= aThirtyTwoBitRegister	"fixed for AR 47784 because the runtime package breaks with this etc. fastEqual: is implemeted to do the comparision with out the extra cycle of having to check the class name."        ^ self class == aThirtyTwoBitRegister class                and: [hi = aThirtyTwoBitRegister hi and: [low =aThirtyTwoBitRegister low]].</body><body package="SecurityBase">&gt;&gt; shift	low := low bitAnd: 16rffff.	low := ((hi bitShift: 16 - shift ) bitAnd: 16rFFFF) bitOr: (low bitShift: shift negated).	hi :=(hi bitShift: shift negated).</body><body package="SecurityBase">addIn: a32BitRegister"There's +=, but I want consistent naming and there's no good binary equivalent for xor"	low := low + a32BitRegister low.	hi := (hi + a32BitRegister hi			+ (low &gt; 16rFFFF ifTrue: [1] ifFalse: [0])		) bitAnd: 16rFFFF.	low := low bitAnd: 16rFFFF</body><body package="SecurityBase">bitAnd: aThirtyTwoBitRegister	hi := hi bitAnd: aThirtyTwoBitRegister hi.	low := low bitAnd: aThirtyTwoBitRegister low.</body><body package="SecurityBase">bitInvert	hi := hi bitXor: 16rFFFF.	low := low bitXor: 16rFFFF.</body><body package="SecurityBase">bitOr: aThirtyTwoBitRegister	hi := hi bitOr: aThirtyTwoBitRegister hi.	low := low bitOr: aThirtyTwoBitRegister low.</body><body package="SecurityBase">bitXor: aThirtyTwoBitRegister	hi := hi bitXor: aThirtyTwoBitRegister hi.	low := low bitXor: aThirtyTwoBitRegister low.</body><body package="SecurityBase">fastEqual: aThirtyTwoBitRegister"Put here as a result of AR 47784 to have an = that doesn't have to do a class name comparison everytime "	^(hi = aThirtyTwoBitRegister hi) and:[ low = aThirtyTwoBitRegister low]</body><body package="SecurityBase">leftRotateBy: bits	| count |	count := bits \\ 32.	count &gt; 16		ifTrue: [ | left right newHi |			left := count - 16.			right := left - 16.			newHi := (self specialLeftShift: low by: left) bitOr: (hi bitShift: right).			low := (self specialLeftShift: hi by: left) bitOr: (low bitShift: right).			hi := newHi]		ifFalse: [ |  left right newHi |			left := count.			right := left - 16.			newHi := (self specialLeftShift: hi by: left) bitOr: (low bitShift: right).			low := (self specialLeftShift: low by: left) bitOr: (hi bitShift: right).			hi := newHi]</body><body package="SecurityBase">rightRotateBy: bits	^self leftRotateBy: 32 - bits</body><body package="SecurityBase">set: a32BitRegister	hi := a32BitRegister hi.	low := a32BitRegister low</body><body package="SecurityBase">xorIn: a32BitRegister"Again added just for more consistent naming"	low := low bitXor: a32BitRegister low.	hi := hi bitXor: a32BitRegister hi</body></methods><methods><class-id>Security.ThirtyTwoBitRegister</class-id> <category>conversions</category><body package="SecurityBase">asInteger	"Answer the integer value"	| int |	int := LargePositiveInteger basicNew: 4.	int basicAt: 3 put: (hi bitAnd: 16rff).	int basicAt:4 put: ((hi bitShift: 0 - 8) bitAnd: 16rff).	int basicAt: 1 put: (low bitAnd: 16rff).	int basicAt:2 put: ((low bitShift: 0 - 8) bitAnd: 16rff).	^int	"^ (hi bitShift: 16) + low"</body><body package="SecurityBase">load: anInteger	"Set my contents to the value of given integer."	low := anInteger bitAnd: 16rFFFF.	hi := (anInteger bitShift: -16) bitAnd: 16rFFFF."	self asInteger = anInteger		ifFalse: [self error: 'out of range: ', anInteger printString]."</body><body package="SecurityBase">loadFrom: aByteArray at: index	"Load my 32-bit value from the four bytes of the given ByteArray starting at the given index. Consider the first byte to contain the most significant bits of the word (i.e., use big-endian byte ordering)."	hi := ((aByteArray at: index) bitShift: 8) + ( aByteArray at: index + 1).	low := ((aByteArray at: index + 2) bitShift: 8) + ( aByteArray at: index + 3).</body><body package="SecurityBase">reverseLoadFrom: aByteArray at: index	"Load my 32-bit value from the four bytes of the given ByteArray starting at the given index. Consider the first byte to contain the most significant bits of the word (i.e., use little-endian byte ordering)."	hi := ((aByteArray at: index+ 3) bitShift: 8) + ( aByteArray at: index + 2).	low := ((aByteArray at: index + 1) bitShift: 8) + ( aByteArray at: index ).</body><body package="SecurityBase">reverseStoreTo: aByteArray at: index"Little-endian"	aByteArray		at: index put: (low bitAnd: 255);		at: index + 1 put: (low bitShift: -8);		at: index + 2 put: (hi bitAnd: 255);		at: index + 3 put: (hi bitShift: -8)</body><body package="SecurityBase">storeTo: aByteArray at: index"Big-endian"	aByteArray		at: index put: (hi bitShift: -8);		at: index + 1 put: (hi bitAnd: 255);		at: index + 2 put: (low bitShift: -8);		at: index + 3 put: (low bitAnd: 255)</body></methods><methods><class-id>Security.ThirtyTwoBitRegister</class-id> <category>printing</category><body package="SecurityBase">printOn: aStream	"Print my contents in hex put an R in front to show that it is a register being printed."	aStream nextPutAll: (#RegisterPrefix &lt;&lt; #security &gt;&gt; 'R:') asString.	self asInteger printOn: aStream base: 16.	aStream nextPutAll: (#DecimalPrefix &lt;&lt; #security &gt;&gt; 'D:') asString.	self asInteger printOn: aStream base: 10.</body></methods><methods><class-id>Security.ThirtyTwoBitRegister</class-id> <category>private</category><body package="SecurityBase">specialLeftShift: aWord by: aShift	"Limit the results to the bottom 16 bits.  Ensure the bitShift: primitive succeeds in 32 bit images.  aShift must be between 0 and 16"	| mask |	aShift = 0 ifTrue: [^aWord].	aShift == 16 ifTrue: [^0].	mask := #(32767 16383 8191 4095 2047 1023 511 255 127 63 31 15 7 3 1) at: aShift.	^(aWord bitAnd: mask) bitShift: aShift</body></methods><methods><class-id>Security.ThirtyTwoBitRegister</class-id> <category>services</category><body package="SecurityBase">wipe	low := hi := 0</body></methods><methods><class-id>Security.ThirtyTwoBitRegister class</class-id> <category>instance creation</category><body package="SecurityBase">new	"Answer a new instance whose initial contents is zero."	^ super new load: 0</body></methods><methods><class-id>Security.EuclidAlgorithm</class-id> <category>accessing</category><body package="SecurityBase">firstCoefficient	^u</body><body package="SecurityBase">gcd	^gcd</body><body package="SecurityBase">secondCoefficient	^ v</body><body package="SecurityBase">with: numberA with: numberB	a := numberA.	b := numberB</body></methods><methods><class-id>Security.EuclidAlgorithm</class-id> <category>private</category><body package="SecurityBase">doBasicAlgorithm	| u1 a1 b1 q r |	u := 1. u1 := 0. a1 := a. b1 := b.	[b1 = 0]		whileFalse: 			[q := a1 // b1.			r := a1 - (b1 * q).			u1 := u - (q * (u := u1)).			a1 := b1.			b1 := r].	gcd := a1.	v := b = 0			ifTrue: [b]			ifFalse: [gcd - (u * a) // b]</body></methods><methods><class-id>Security.EuclidAlgorithm class</class-id> <category>instance creation</category><body package="SecurityBase">with: a with: b	^ self new with: a with: b</body></methods><methods><class-id>Core.LargeNegativeInteger</class-id> <category>security</category><body package="SecurityBase">asBigEndianByteArray"Convert receiver to a byte array of apropriate size in network (a.k.a big endian) format.Not supported for negative integers."	^self errorConvertingNegativeIntegerToBytes</body><body package="SecurityBase">asBigEndianByteArrayPaddedTo: numberOfBytes"Encode the receiver in the network (aka big endian) order. Pad the byte array in the beginning to size anInteger.anInteger bytes has to be enough to store the receiver. The receiver is expected to be non-negative."	^self errorConvertingNegativeIntegerToBytes</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>security</category><body package="SecurityBase">asBigEndianByteArray"Convert receiver to a byte array of apropriate size in network (a.k.a big endian) format.Not supported for negative integers."	| remainder bytes |	self negative ifTrue: [ self errorConvertingNegativeIntegerToBytes ].	remainder := self.	bytes := ByteArray new: self digitLength.	bytes size to: 1 by: -1 do: [ :i |		bytes at: i put: (remainder bitAnd: 255).		remainder := remainder bitShift: -8 ].	^bytes</body></methods><methods><class-id>Core.ByteArray</class-id> <category>security</category><body package="SecurityBase">asBigEndianInteger"Interpret the receiver as an unsigned integer in big-endian format. This is the reverse of #asBigEndianByteArray."	^(self reverse changeClassTo: LargePositiveInteger) compressed</body></methods><methods><class-id>Core.LargePositiveInteger</class-id> <category>security</category><body package="SecurityBase">asBigEndianByteArray"Convert receiver to a byte array of apropriate size in network (a.k.a big endian) format.Not supported for negative integers."	| answer top |	top := self basicSize + 1.	answer := ByteArray new: top - 1.	1 to: top - 1 do: [:i |		answer at: i put: (self basicAt: top - i)].	^answer</body><body package="SecurityBase">asBigEndianByteArrayPaddedTo: numberOfBytes"Encode the receiver in the network (aka big endian) order. Pad the byte array in the beginning to size anInteger.anInteger bytes has to be enough to store the receiver. The receiver is expected to be non-negative."	| answer top pad |	self basicSize &gt; numberOfBytes ifTrue: [ self errorInsufficientSpaceForIntegerToBytesConversion ].	top := self basicSize + 1.	pad := numberOfBytes - top + 1.	answer := ByteArray new: numberOfBytes.	1 to: top - 1 do: [:i |		answer at: pad + i put: (self basicAt: top - i)].	^answer</body></methods><methods><class-id>Core.Integer</class-id> <category>security</category><body package="SecurityBase">% anInteger"	An attempt to define '%' operator similar to that in C language. It appears to work the same as rem:.	In case it turns out not to, this implementation has to change to address signing conventions."	^ self rem: anInteger</body><body package="SecurityBase">asBigEndianByteArray	^ self subclassResponsibility</body><body package="SecurityBase">asBigEndianByteArrayPaddedTo: anInteger"Encode the receiver in the network (aka big endian) order. Pad the byte array in the beginning to size anInteger.anInteger bytes has to be enough to store the receiver. The receiver is expected to be non-negative."	| ba counter number |	self negative ifTrue: [ self errorConvertingNegativeIntegerToBytes ].	ba := ByteArray new: anInteger.	counter := anInteger.	number := self.	[number &gt; 0] whileTrue: [		counter = 0 ifTrue: [ self errorInsufficientSpaceForIntegerToBytesConversion ].		ba at: counter put: (number bitAnd: 255).		counter := counter - 1.		number := number bitShift: -8 ].	^ba</body><body package="SecurityBase">dividedBy: anInteger modulo: aModulus "	This uses the modular inverse:		(X * Y) mod C = 1. Then X = Y^-1 (mod C), and Y = X^-1 (mod C).		(A / B) mod C = (A mod C * (B^1) (mod C)) mod C.	(5 dividedBy: 4 modulo: 3)	(2 dividedBy: 4 modulo: 3)	(2 dividedBy: -4 modulo: 3)	(2 dividedBy: 1 modulo: 3)"	^ self * (anInteger inverseModulo: aModulus)</body><body package="SecurityBase">doubleAndAdd: multiplicand"	Implement the 'double and add' algorithm for multiplication. Multiplicand should be any object that supports the following messages:	#double, #+, #isZero	and class messages:	#zero."	| total |	(self isZero or: [ multiplicand isZero ]) ifTrue: [ ^ multiplicand zero ].	self = 1 ifTrue: [ ^ multiplicand ].	total := multiplicand zero.	self highBit to: 1 by: -1 do: [ :bit | | mask maskedBits |		mask := 0 bitSet: bit.		maskedBits := self bitAnd: mask.		total := total doubled.		maskedBits = 0 ifFalse: [			total := total + multiplicand ] ].	^ total</body><body package="SecurityBase">doubled	^ 2 * self</body><body package="SecurityBase">errorConvertingNegativeIntegerToBytes	self error: (#errCantConvertNegativeNumbers &lt;&lt; #security &gt;&gt; 'Cannot convert negative integer into a big-endian byte array').</body><body package="SecurityBase">errorInsufficientSpaceForIntegerToBytesConversion	self error: (#InsufficientSize &lt;&lt; #security &gt;&gt; 'Not enough room for the whole number').</body><body package="SecurityBase">inverseModulo: aModulus "	This will use the Extended Euclidean algorithm to calculate an inverse of myself modulo aModulus.	Calculate y such that	(y * x) mod: m = 1.	Then y is an inverse of x modulo m.	https://en.wikipedia.org/wiki/Modular_multiplicative_inverse	(3 inverseModulo: 7)	(5 inverseModulo: 7)	(5 inverseModulo: 13)"	| i j y2 y1 y quotient remainder |		i := aModulus.	j := self * self sign.	y2 := 0.	y1 := 1.		[ j &gt; 0 ] whileTrue: [		quotient := i // j.		remainder := i % j.		y := y2 - (y1 * quotient).		i := j.		j := remainder.		y2 := y1.		y1 := y ].		^ (self sign * y2) % aModulus</body><body package="SecurityBase">minus: anInteger modulo: aModulus "	This uses the modular addition: (A - B) mod C = ((A mod C) - (B mod C)) mod C	(5 minus: 4 modulo: 3)	(2 minus: 4 modulo: 3)	(2 minus: 1 modulo: 3)"	^ (self &lt; aModulus or: [ anInteger &lt; aModulus ])		ifTrue: [ (self - anInteger) % aModulus ]		ifFalse: [ ((self % aModulus) - (anInteger % aModulus)) % aModulus ]</body><body package="SecurityBase">plus: anInteger modulo: aModulus "	This uses the modular addition: (A + B) mod C = ((A mod C) + (B mod C)) mod C	(1 plus:1 modulo: 3)	(1 plus: 4 modulo: 3)	(4 plus: 4 modulo: 3)"	^ (self &lt; aModulus or: [ anInteger &lt; aModulus ])		ifTrue: [ (self + anInteger) % aModulus ]		ifFalse: [ ((self % aModulus) + (anInteger % aModulus)) % aModulus ]</body><body package="SecurityBase">raisedTo: anExponent modulo: aModulus "This will perform following computation (a raisedTo: b) \\ n. We're using a binary square and multiply method to avoid excessively large intermediate results."	^anExponent asBigEndianByteArray "bit-endian"		inject: 1		into: [ :total :byte |			#(128 64 32 16 8 4 2 1)				inject: total				into: [ :subtotal :mask || square |					square := subtotal * subtotal \\ aModulus.					(byte bitAnd: mask) == 0						ifTrue: [ square ]						ifFalse: [ square * self \\ aModulus ] ] ]</body><body package="SecurityBase">times: anInteger modulo: aModulus "	This uses the modular multiplication: (A * B) mod C = ((A mod C) * (B mod C)) mod C	(5 times: 4 modulo: 3)	(2 times: 4 modulo: 3)	(2 times: 1 modulo: 3)"	^ (self &lt; aModulus and: [ anInteger &lt; aModulus ])		ifTrue: [ (self * anInteger) % aModulus ]		ifFalse: [ ((self % aModulus) * (anInteger % aModulus)) % aModulus ]</body><body package="SecurityBase">zero	^ self class zero</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SmallInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars>minVal maxVal maxBits maxBytes </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>LargePositiveInteger</name><environment>Core</environment><super>Core.LargeInteger</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>LargeNegativeInteger</name><environment>Core</environment><super>Core.LargeInteger</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class></st-source>