<?xml version="1.0"?><st-source><!-- Name: Grease-CoreComment: The main package of the Grease compatibility layer.DbIdentifier: bear73DbTrace: 493797DbUsername: tkoganDbVersion: 3.2.0 - JohanBrichau.97 2DevelopmentPrerequisites: #(#(#any 'Grease-Namespace' '') #(#any 'Grease-VisualWorks-Extensions' ''))Id: 868988c3-e68d-41f6-8932-c172c82904faNamespace: GreasePackageName: Grease-CoreParcel: #('Grease-Core')ParcelName: Grease-CorePrerequisiteDescriptions: #(#(#name 'Grease-Namespace') #(#name 'Grease-VisualWorks-Extensions' #componentType #package))PrerequisiteParcels: #(#('Grease-Namespace' '') #('Grease-VisualWorks-Extensions' ''))PrintStringCache: (3.2.0 - JohanBrichau.97 2,tkogan)Url: http://smalltalkhub.com/mc/Seaside/Grease11/main/Grease-Core-JohanBrichau.97.mczVersion: 3.2.0 - JohanBrichau.97 2Date: 3:31:26 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:31:26 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>GRObject</name><environment>Grease</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core</category><attributes><package>Grease-Core</package></attributes></class><comment><class-id>Grease.GRObject</class-id><body>A common superclass that ensures consistent initialization behaviour on all platforms and provides #error: methods that signal an instance of WAPlatformError.Packages that are using Seaside-Platform should normally subclass GRObject instead of Object.</body></comment><class><name>GRCodec</name><environment>Grease</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><comment><class-id>Grease.GRCodec</class-id><body>A codec defines how Seaside communicates without the outside world and how outside data is converted into the image (decoding) and back outside the image (encoding). The codec is essentially a stream factory that provides wrappers around standard streams. All streams do support binary mode for non-converted transfer.</body></comment><class><name>GRNullCodec</name><environment>Grease</environment><super>Grease.GRCodec</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><comment><class-id>Grease.GRNullCodec</class-id><body>The null codec always returns the original streams. It assumes that the outside world uses the same encoding as the inside world. This is highly efficient as no transformation is applied to the data, but has its drawbacks.</body></comment><class><name>GRDelayedSend</name><environment>Grease</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver message </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Utilities</category><attributes><package>Grease-Core</package></attributes></class><comment><class-id>Grease.GRDelayedSend</class-id><body>A GRDelayedSend is a future message send of a message to an object. Some of the arguments can be predefined. Instances are intended to be interchangeable with blocks.This class should conform the ANSI (block) valuable protocol. Unlike a block, a GRDelayedSend is not a closure so doesn't hold onto the method context. GRDelayedSend provides similar, but portable, functionality to Pharo's MessageSend.This is an abstract class. Use the methods in the 'instance-creation' protocol on the class side to create intances.Instance Variables	receiver:		&lt;Object&gt;	selector:		&lt;Symbol&gt;receiver	- the object receiving the messageselector	- the message selector sent to the receiver</body></comment><class><name>GRDelegatingStream</name><environment>Grease</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><comment><class-id>Grease.GRDelegatingStream</class-id><body>A GRDelegatingStream is a wrapper around a write stream and defines common behavior.Instance Variables	stream:		&lt;WriteStream&gt;stream	- a WriteStream</body></comment><class><name>GRCodecStream</name><environment>Grease</environment><super>Grease.GRDelegatingStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><comment><class-id>Grease.GRCodecStream</class-id><body>GRCodecStream is the abstract base class for codec streams</body></comment><class><name>GRInflector</name><environment>Grease</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><comment><class-id>Grease.GRInflector</class-id><body>The Inflector transforms words from singular to plural.</body></comment><class><name>GRPrinter</name><environment>Grease</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><class><name>GRUnitPrinter</name><environment>Grease</environment><super>Grease.GRPrinter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>integerPrinter fractionPrinter units base </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><class><name>GRError</name><environment>Grease</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Exceptions</category><attributes><package>Grease-Core</package></attributes></class><comment><class-id>Grease.GRError</class-id><body>This class provides consistent initialization and exception signaling behaviour across platforms. All platforms must provide the ANSI-standard signaling protocol on this class. #signal: can therefore be safely called on any subclass.Packages that are using Seaside-Platform should usually subclass GRError instead of Error.</body></comment><class><name>GRUnsupportedEncodingError</name><environment>Grease</environment><super>Grease.GRError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><class><name>GRSignPrinter</name><environment>Grease</environment><super>Grease.GRPrinter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>negativePrinter positivePrinter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><class><name>GRSmallDictionary</name><environment>Grease</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>size keys values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Collections</category><attributes><package>Grease-Core</package></attributes></class><comment><class-id>Grease.GRSmallDictionary</class-id><body>I am an implementation of a dictionary. Compared to other dictionaries I am very efficient for small sizes, speed- and space-wise. I also mantain the order in which elements are added when iterating. My implementation features some ideas from the RefactoringBrowser.</body></comment><class><name>GRNotification</name><environment>Grease</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Exceptions</category><attributes><package>Grease-Core</package></attributes></class><comment><class-id>Grease.GRNotification</class-id><body>This class provides consistent initialization and exception signaling behaviour across platforms. All platforms must provide the ANSI-standard signaling protocol on this class. #signal: can therefore be safely called on any subclass.Packages that are using Seaside-Platform should usually subclass GRNotification instead of Notification.</body></comment><class><name>GRDeprecatedApiNotification</name><environment>Grease</environment><super>Grease.GRNotification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>details </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Exceptions</category><attributes><package>Grease-Core</package></attributes></class><comment><class-id>Grease.GRDeprecatedApiNotification</class-id><body>This notification is signaled whenever a deprecated message is sent.see WAObject&gt;&gt;#greaseDeprecatedApi:details: </body></comment><class><name>GRPluggablePrinter</name><environment>Grease</environment><super>Grease.GRPrinter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><class><name>GRInvalidArgumentCount</name><environment>Grease</environment><super>Grease.GRError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Utilities</category><attributes><package>Grease-Core</package></attributes></class><comment><class-id>Grease.GRInvalidArgumentCount</class-id><body>Signaled whenever a message is sent with the incorrect number of arguments.</body></comment><class><name>GRCountingStream</name><environment>Grease</environment><super>Grease.GRDelegatingStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core</category><attributes><package>Grease-Core</package></attributes></class><comment><class-id>Grease.GRCountingStream</class-id><body>A GRCountingStream counts how many elements have been added to it. This is necessary because the underlying stream may inflate the number of elements in the stream.Instance Variables:	count	&lt;Integer&gt;		count  - number of elements added to this stream</body></comment><class><name>GRDelayedSendMessage</name><environment>Grease</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Utilities</category><attributes><package>Grease-Core</package></attributes></class><comment><class-id>Grease.GRDelayedSendMessage</class-id><body>GRDelayedSendMessage is an abstract base for objects that provide currying functionality for GRDelayedSend</body></comment><class><name>GRUnboundMessage</name><environment>Grease</environment><super>Grease.GRDelayedSendMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Utilities</category><attributes><package>Grease-Core</package></attributes></class><comment><class-id>Grease.GRUnboundMessage</class-id><body>A delayed send that has none of the arguments defined in advance.</body></comment><class><name>GRPackage</name><environment>Grease</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name description dependencies license url </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core</category><attributes><package>Grease-Core</package></attributes></class><comment><class-id>Grease.GRPackage</class-id><body>I am a platform independent package representation. I know my name, description, my dependencies, the license and the repository URL. Packages are declared by creating a class side extension method that answers a configured package instance. The expression    GRPackage packagesanswers the collection of the complete package graph.</body></comment><class><name>GROrdinalizePrinter</name><environment>Grease</environment><super>Grease.GRPrinter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><class><name>GRNumberPrinter</name><environment>Grease</environment><super>Grease.GRPrinter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>characters base delimiter digits infinite nan padding accuracy precision separator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><comment><class-id>Grease.GRNumberPrinter</class-id><body>A GRNumberPrinter prints numbers (integers and floats) in various formats in a platform independent way.Instance Variables	accuracy:	&lt;UndefinedObject|Float&gt;	base:		&lt;Integer&gt;	delimiter:	&lt;UndefinedObject|Character&gt;	digits:		&lt;UndefinedObject|Integer&gt;	infinite:		&lt;UndefinedObject|String&gt;	nan:			&lt;UndefinedObject|String&gt;	padding:	&lt;UndefinedObject|Character&gt;	precision:	&lt;Integer&gt;	separator:	&lt;UndefinedObject|Character&gt;</body></comment><class><name>GRPlatform</name><environment>Grease</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core</category><attributes><package>Grease-Core</package></attributes></class><comment><class-id>Grease.GRPlatform</class-id><body>The abstract platform implementation. Each platform should provide a subclass implementing any abstract methods and overriding any other methods as necessary.Default implementations should be provided here when possible/useful but default implementations MUST be valid on ALL PLATFORMS so it is rarely practical. VA Smalltalk flags sends of uknown messages so even these must be known to exist on all platforms.Common cases where default implementations *are* appropriate are where there is a standard implementation that is valid on all platforms but one or more platforms have an additional, optimized implementation that should be used instead.All classes and methods used by methods of this class should be either:  + included in the Seaside-Platform package;  + defined by the ANSI Smalltalk standard; or  + (not ideal) referenced via 'Smalltalk at: #ClassName'.</body></comment><class><name>GRMappedPrinter</name><environment>Grease</environment><super>Grease.GRPrinter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>next block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><class><name>GRSequentialPrinter</name><environment>Grease</environment><super>Grease.GRPrinter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><class><name>GRNullCodecStream</name><environment>Grease</environment><super>Grease.GRCodecStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><comment><class-id>Grease.GRNullCodecStream</class-id><body>A WANullCodecStream is a WriteStream on a String on which you can both put binary and character data without encoding happening.Instance Variables	stream:		&lt;WriteStream&gt;stream	- a WriteStream on a String</body></comment><class><name>GROrderedMultiMap</name><environment>Grease</environment><super>Grease.GRSmallDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Collections</category><attributes><package>Grease-Core</package></attributes></class><comment><class-id>Grease.GROrderedMultiMap</class-id><body>I am an implementation of an ordered multi-map. I allow multiple values to be associated with the same key and maintain the order of addition. #at: and its derivatives all operate on the first matching key, while #allAt: returns the complete list of values for a key in the order they were added.</body></comment><class><name>GRVersion</name><environment>Grease</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>major minor revision stageLabel stageNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core</category><attributes><package>Grease-Core</package></attributes></class><comment><class-id>Grease.GRVersion</class-id><body>I model version numbers. I am comparable and I define a natural order.</body></comment><class><name>GRStringPrinter</name><environment>Grease</environment><super>Grease.GRPrinter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>trim length pad character </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><class><name>GRInvalidUtf8Error</name><environment>Grease</environment><super>Grease.GRError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><comment><class-id>Grease.GRInvalidUtf8Error</class-id><body>A WAInvalidUtf8Error signals that the input is not valid UTF-8.</body></comment><class><name>GRBoundMessage</name><environment>Grease</environment><super>Grease.GRDelayedSendMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Utilities</category><attributes><package>Grease-Core</package></attributes></class><comment><class-id>Grease.GRBoundMessage</class-id><body>A delayed send that has some or all of the arguments defined in advance. Additionally supplied arguments will be added, if possible, to these when the object is evaluate.Instance Variables	arguments:		&lt;Array&gt;arguments	- the predefined arguments</body></comment><shared-variable><name>NumbersToCharactersUppercase</name><environment>Grease.GRNumberPrinter</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Grease-Core</package></attributes></shared-variable><shared-variable><name>NumbersToCharactersLowercase</name><environment>Grease.GRNumberPrinter</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Grease-Core</package></attributes></shared-variable><shared-variable><name>InflectionRules</name><environment>Grease.GRInflector</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Grease-Core</package></attributes></shared-variable><shared-variable><name>Uninflected</name><environment>Grease.GRInflector</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Grease-Core</package></attributes></shared-variable><shared-variable><name>Current</name><environment>Grease.GRPlatform</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Grease-Core</package></attributes></shared-variable><methods><class-id>Grease.GRObject</class-id> <category>initialization</category><body package="Grease-Core">initialize</body></methods><methods><class-id>Grease.GRObject</class-id> <category>error handling</category><body package="Grease-Core">error: aString	^ self class error: aString</body></methods><methods><class-id>Grease.GRObject class</class-id> <category>error handling</category><body package="Grease-Core">defaultErrorClass	^ GRError</body><body package="Grease-Core">error: aString	^ self defaultErrorClass signal: aString</body></methods><methods><class-id>Grease.GRObject class</class-id> <category>instance creation</category><body package="Grease-Core">new	^ self basicNew initialize</body></methods><methods><class-id>Grease.GRCodec</class-id> <category>convenience</category><body package="Grease-Core">decode: aString	| readStream writeStream |	readStream := self decoderFor: aString readStream.	writeStream := GRPlatform current writeCharacterStreamOn: (String new: aString size).	[ readStream atEnd ]		whileFalse: [ writeStream nextPutAll: (readStream next: 1024) ].	^ writeStream contents</body><body package="Grease-Core">encode: aString	| writeStream |	writeStream := self encoderFor: (GRPlatform current		writeCharacterStreamOn:  (String new: aString size)).	writeStream nextPutAll: aString.	^ writeStream contents</body></methods><methods><class-id>Grease.GRCodec</class-id> <category>accessing</category><body package="Grease-Core">name	"Answer a human readable string of the receivers encoding policy."	self subclassResponsibility</body><body package="Grease-Core">url	"Answer a codec that is responsible to encode and decode URLs. In most cases an UTF-8 codec is the only valid choice, but subclasses might decide to do something else."	self subclassResponsibility</body></methods><methods><class-id>Grease.GRCodec</class-id> <category>printing</category><body package="Grease-Core">printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' name: '; print: self name</body></methods><methods><class-id>Grease.GRCodec</class-id> <category>conversion</category><body package="Grease-Core">decoderFor: aReadStream	"Wrap aReadStream with an decoder for the codec of the receiver. Answer a read stream that delegates to and shares the state of aReadStream." 		self subclassResponsibility</body><body package="Grease-Core">encoderFor: aWriteStream	"Wrap aWriteStream with an encoder for the codec of the receiver. Answer a write stream that delegates to and shares the state of aWriteStream."		self subclassResponsibility</body></methods><methods><class-id>Grease.GRCodec class</class-id> <category>instance creation</category><body package="Grease-Core">forEncoding: aString	"Answer a new codec instance for the given encoding name. Raise an WAUnsupportedEncodingError if the encoding name is not supported by this image."	self allSubclassesDo: [ :each | 		(each supportsEncoding: aString)			ifTrue: [ ^ each basicForEncoding: aString ] ].	^ self unsupportedEncoding: aString</body></methods><methods><class-id>Grease.GRCodec class</class-id> <category>private</category><body package="Grease-Core">basicForEncoding: aString	"Create the actual instance."	self subclassResponsibility</body><body package="Grease-Core">unsupportedEncoding: aString	"Signal an unsupported encoding."	^ GRUnsupportedEncodingError signal: 'unsupported encoding: ' , aString</body></methods><methods><class-id>Grease.GRCodec class</class-id> <category>accessing</category><body package="Grease-Core">allCodecs	"Answer all codecs supported in this system. This is a collection of codec instances."	^ self subclasses		inject: self codecs asArray		into: [ :result :each | result , each allCodecs ]</body><body package="Grease-Core">codecs	"Answer a collection of possible codecs of the receiver. To be overridden by concrete subclasses."	^ #()</body></methods><methods><class-id>Grease.GRCodec class</class-id> <category>testing</category><body package="Grease-Core">supportsEncoding: aString	"Answer whether the the given encoding name is supported by this codec class."	self subclassResponsibility</body></methods><methods><class-id>Grease.GRNullCodec</class-id> <category>accessing</category><body package="Grease-Core">name	^ GRNullCodec codecName</body><body package="Grease-Core">url	"The selfish method. Let's do it with ourselves."		^ self</body></methods><methods><class-id>Grease.GRNullCodec</class-id> <category>conversion</category><body package="Grease-Core">decoderFor: aReadStream 	"wrap to avoid String vs ByteArray issues"	^ GRNullCodecStream on: aReadStream</body><body package="Grease-Core">encoderFor: aWriteStream 	"wrap to avoid String vs ByteArray issues"	^ GRNullCodecStream on: aWriteStream</body></methods><methods><class-id>Grease.GRNullCodec</class-id> <category>convenience</category><body package="Grease-Core">decode: aString	"Overridden for efficiency."	^ aString</body><body package="Grease-Core">encode: aString	"Overridden for efficiency."	^ aString</body></methods><methods><class-id>Grease.GRNullCodec class</class-id> <category>private</category><body package="Grease-Core">basicForEncoding: aString	^ self new</body></methods><methods><class-id>Grease.GRNullCodec class</class-id> <category>accessing</category><body package="Grease-Core">codecName	^ '(none)'</body><body package="Grease-Core">codecs	^ Array with: self new</body></methods><methods><class-id>Grease.GRNullCodec class</class-id> <category>testing</category><body package="Grease-Core">supportsEncoding: aString	^ aString isNil</body></methods><methods><class-id>Grease.GRDelayedSend</class-id> <category>accessing</category><body package="Grease-Core">argumentCount	"Answer the number of arguments that must be provided to the receiver when sending it."		^ message argumentCount</body><body package="Grease-Core">fixCallbackTemps	"For polymorphism with BlockContext&gt;&gt;#fixCallbackTemps."</body></methods><methods><class-id>Grease.GRDelayedSend</class-id> <category>initialization</category><body package="Grease-Core">initializeWithReceiver: anObject message: aDelayedSendMessage	self initialize.	receiver := anObject.	message := aDelayedSendMessage</body></methods><methods><class-id>Grease.GRDelayedSend</class-id> <category>evaluating</category><body package="Grease-Core">value	^ self valueWithArguments: #()</body><body package="Grease-Core">value: anObject	^ self valueWithArguments: (Array with: anObject)</body><body package="Grease-Core">value: aFirstObject value: aSecondObject	^ self valueWithArguments: (Array with: aFirstObject with: aSecondObject)</body><body package="Grease-Core">valueWithArguments: anArray	^ message valueFor: receiver withArguments: anArray</body><body package="Grease-Core">valueWithPossibleArguments: anArray	^ message valueFor: receiver withPossibleArguments: anArray</body></methods><methods><class-id>Grease.GRDelayedSend</class-id> <category>printing</category><body package="Grease-Core">printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' receiver: '; print: receiver.	aStream nextPut: $ .	message printOn: aStream</body></methods><methods><class-id>Grease.GRDelayedSend class</class-id> <category>instance creation</category><body package="Grease-Core">empty	^ self receiver: nil selector: #yourself</body><body package="Grease-Core">new	^ self empty</body><body package="Grease-Core">receiver: anObject selector: aSymbol 	^ self basicNew 		initializeWithReceiver: anObject			message: (GRUnboundMessage selector: aSymbol);		yourself</body><body package="Grease-Core">receiver: anObject selector: aSymbol argument: aParameter	^ self receiver: anObject selector: aSymbol arguments: (Array with: aParameter)</body><body package="Grease-Core">receiver: anObject selector: aSymbol arguments: anArray 	^ self basicNew 		initializeWithReceiver: anObject			message: (GRBoundMessage selector: aSymbol arguments: anArray);		yourself</body></methods><methods><class-id>Grease.GRDelegatingStream</class-id> <category>accessing</category><body package="Grease-Core">contents	^ stream contents</body><body package="Grease-Core">flush	stream flush</body><body package="Grease-Core">position	^ stream position</body><body package="Grease-Core">reset	"Reset the stream"	stream reset</body><body package="Grease-Core">size	^ stream size</body></methods><methods><class-id>Grease.GRDelegatingStream</class-id> <category>testing</category><body package="Grease-Core">atEnd	^ stream atEnd</body><body package="Grease-Core">isStream	^ true</body></methods><methods><class-id>Grease.GRDelegatingStream</class-id> <category>streaming</category><body package="Grease-Core">crlf	self nextPut: Character cr; nextPut: Character lf</body><body package="Grease-Core">next	self subclassResponsibility</body><body package="Grease-Core">next: anInteger	self subclassResponsibility</body><body package="Grease-Core">nextPut: aCharacter	self subclassResponsibility</body><body package="Grease-Core">nextPutAll: aString	self subclassResponsibility</body><body package="Grease-Core">print: anObject	anObject printOn: self</body><body package="Grease-Core">space	self nextPut: Character space</body><body package="Grease-Core">tab	self nextPut: Character tab</body></methods><methods><class-id>Grease.GRDelegatingStream</class-id> <category>initialization</category><body package="Grease-Core">initializeOn: aStream	self initialize.	stream := aStream</body></methods><methods><class-id>Grease.GRDelegatingStream class</class-id> <category>instance creation</category><body package="Grease-Core">on: aStream	^ self basicNew initializeOn: aStream</body></methods><methods><class-id>Grease.GRInflector class</class-id> <category>initialization</category><body package="Grease-Core">initialize	Uninflected := #('bison' 'bream' 'breeches' 'britches' 'carp' 'chassis' 'clippers' 'cod' 'contretemps' 'corps' 'debris' 'deer' 'diabetes' 'djinn' 'eland' 'elk' 'equipment' 'fish' 'flounder' 'gallows' 'graffiti' 'headquarters' 'herpes' 'high-jinks' 'homework' 'information' 'innings' 'ities' 'itis' 'jackanapes' 'mackerel' 'measles' 'mews' 'money' 'mumps' 'news' 'ois' 'pincers' 'pliers' 'pox' 'proceedings' 'rabies' 'rice' 'salmon' 'scissors' 'sea-bass' 'series' 'shears' 'sheep' 'species' 'swine' 'trout' 'tuna' 'whiting' 'wildebeest').	InflectionRules := #(('man' 'en' 2) ('child' 'ren' 0) ('cow' 'kine' 3) ('penis' 'es' 0) ('sex' 'es' 0) ('person' 'ople' 4) ('octopus' 'es' 0) ('quiz' 'zes' 0) ('ox' 'en' 0) ('louse' 'ice' 4) ('mouse' 'ice' 4) ('matrix' 'ices' 2) ('vertix' 'ices' 2) ('vertex' 'ices' 2) ('indix' 'ices' 2) ('index' 'ices' 2) ('x' 'es' 0) ('ch' 'es' 0) ('ss' 'es' 0) ('sh' 'es' 0) ('ay' 's' 0) ('ey' 's' 0) ('iy' 's' 0) ('oy' 's' 0) ('uy' 's' 0) ('y' 'ies' 1) ('alf' 'ves' 1) ('elf' 'ves' 1) ('olf' 'ves' 1) ('arf' 'ves' 1) ('nife' 'ves' 2) ('life' 'ves' 2) ('wife' 'ves' 2) ('sis' 'es' 2) ('tum' 'a' 2) ('ium' 'a' 2) ('buffalo' 'es' 0) ('tomato' 'es' 0) ('buffalo' 'es' 0) ('bus' 'es' 0) ('alias' 'es' 0) ('status' 'es' 0) ('octopus' 'i' 2) ('virus' 'i' 2) ('axis' 'es' 2) ('s' '' 0))</body></methods><methods><class-id>Grease.GRInflector class</class-id> <category>accessing</category><body package="Grease-Core">pluralize: aString	| string |	string := aString asLowercase.	Uninflected do: [ :each |		(string endsWithSubCollection: each)			ifTrue: [ ^ aString ] ].	InflectionRules do: [ :rule |		(string endsWithSubCollection: rule first)			ifTrue: [ ^ (aString allButLast: rule third) , rule second ] ].	^ aString , 's'</body></methods><methods><class-id>Grease.GRPrinter</class-id> <category>utilities</category><body package="Grease-Core">pad: aString center: aCharacter to: anInteger	"Pad to the center of aString with aCharacter to at least anInteger characters."	| result index |	anInteger &lt;= aString size		ifTrue: [ ^ aString ].	index := (anInteger - aString size) // 2.	result := (String new: anInteger) atAllPut: aCharacter.	result		replaceFrom: index + 1		to: index + aString size		with: aString		startingAt: 1.	^ result</body><body package="Grease-Core">pad: aString left: aCharacter to: anInteger	"Pad to the left side of aString with aCharacter to at least anInteger characters."	| result |	anInteger &lt;= aString size		ifTrue: [ ^ aString ].	result := (String new: anInteger) atAllPut: aCharacter.	result		replaceFrom: anInteger - aString size + 1		to: anInteger		with: aString		startingAt: 1.	^ result</body><body package="Grease-Core">pad: aString right: aCharacter to: anInteger	"Pad to the right side of aString with aCharacter to at least anInteger characters."	| result |	anInteger &lt;= aString size		ifTrue: [ ^ aString ].	result := (String new: anInteger) atAllPut: aCharacter.	result		replaceFrom: 1		to: aString size		with: aString		startingAt: 1.	^ result</body></methods><methods><class-id>Grease.GRPrinter</class-id> <category>printing</category><body package="Grease-Core">print: anObject	^ String streamContents: [ :stream | self print: anObject on: stream ]</body><body package="Grease-Core">print: anObject on: aStream	"Subclasses override this method to produce some output."</body></methods><methods><class-id>Grease.GRPrinter</class-id> <category>operators</category><body package="Grease-Core">, aPrinter 	^ GRSequentialPrinter new , self , aPrinter</body></methods><methods><class-id>Grease.GRPrinter class</class-id> <category>factory-http</category><body package="Grease-Core">cookieTimestamp	"Netscape's original proposal defined an Expires header that took a date value in a fixed-length variant format in place of Max-Age: Wdy, DD-Mon-YY HH:MM:SS GMT"	^ GRMappedPrinter		block: [ :timestamp | timestamp asUTC ]		next: self abbreviatedWeekName , ', ' , self paddedDay , '-' , self abbreviatedMonthName , '-' , self paddedYear , ' ' , self isoTime , ' GMT'</body><body package="Grease-Core">httpDate	"Answers a printer that formats dates for HTTP1.1 (RFC 2616)"	^ self rfc1123</body><body package="Grease-Core">isoDate	"Ansers a printer that formats dates according to ISO(YYYY-MM-DD) E.g. 2003-12-24"	^ self paddedYear , $- , self paddedMonth , $- , self paddedDay</body><body package="Grease-Core">isoTime	"Ansers a printer that formats time according to ISO(HH:MM:SS) E.g. 12:23:34"		^ self paddedHour24 , $: , self paddedMinute , $: , self paddedSecond</body><body package="Grease-Core">rfc1123	"Answers a printer that formats dates for HTTP1.1 (RFC 1123). Eg.	Sun, 06 Nov 1994 08:49:37 GMT "		^ GRMappedPrinter 		block: [ :date | 			"For the purposes of HTTP, GMT is exactly equal to UTC (Coordinated Universal Time)"			date asUTC ]		next: GRSequentialPrinter new , self abbreviatedWeekName , ', ' , self paddedDay , Character space , self abbreviatedMonthName , Character space , self paddedYear , Character space , self isoTime , ' GMT'</body><body package="Grease-Core">rfc822	"Answers a printer that formats dates according to RFC 822 (email). Eg.	Sun, 31 Aug 2008 19:41:46 +0200"	^ self abbreviatedWeekName , ', ' , self paddedDay , Character space , self abbreviatedMonthName , Character space , self paddedYear , Character space , self isoTime , Character space , self offsetSign , self absOffsetHoursPadded , self absOffsetMinutesPadded</body><body package="Grease-Core">rfc822WithTimeZone: aString	"Answers a privter that formats dates according to RFC 822 (email) with the given time zone String. Eg.	Sun, 31 Aug 2008 19:41:46 &lt;aString&gt;"	^ self abbreviatedWeekName , ', ' , self paddedDay , Character space , self abbreviatedMonthName , Character space , self paddedYear , Character space , self isoTime , Character space , aString</body></methods><methods><class-id>Grease.GRPrinter class</class-id> <category>parts-date</category><body package="Grease-Core">abbreviatedMonthName	^ self monthName: #('Jan' 'Feb' 'Mar' 'Apr' 'May' 'Jun' 'Jul' 'Aug' 'Sep' 'Oct' 'Nov' 'Dec')</body><body package="Grease-Core">abbreviatedWeekName	^ self weekName: #('Sun' 'Mon' 'Tue' 'Wed' 'Thu' 'Fri' 'Sat')</body><body package="Grease-Core">absOffsetHoursPadded	^ GRMappedPrinter 		block: [ :date | date offset hours abs ]		next: (self numberWithAtLeastDigits: 2)</body><body package="Grease-Core">absOffsetMinutesPadded	^ GRMappedPrinter 		block: [ :date | date offset minutes abs ]		next: (self numberWithAtLeastDigits: 2)</body><body package="Grease-Core">fullMonthName	^ self monthName: #('January' 'February' 'March' 'April' 'May' 'June' 'July' 'August' 'September' 'October' 'November' 'December')</body><body package="Grease-Core">fullWeekName	^ self weekName: #('Sunday' 'Monday' 'Tuesday' 'Wednesday' 'Thursday' 'Friday' 'Saturday')</body><body package="Grease-Core">monthName: anArray 	^ GRPluggablePrinter on: [ :date | anArray at: date monthIndex ]</body><body package="Grease-Core">offsetSign	^ GRMappedPrinter 		block: [ :date | date offset ]		next: (GRSignPrinter new				positivePrinter: $+;				negativePrinter: $-;				yourself)</body><body package="Grease-Core">paddedCentury	^ GRMappedPrinter 		block: [ :date | date year \\ 100 ]		next: (self numberWithAtLeastDigits: 2)</body><body package="Grease-Core">paddedDay	^ GRMappedPrinter 		block: [ :date | date dayOfMonth ]		next: (self numberWithAtLeastDigits: 2)</body><body package="Grease-Core">paddedMonth	^ GRMappedPrinter 		block: [ :date | date monthIndex ]		next: (self numberWithAtLeastDigits: 2)</body><body package="Grease-Core">paddedYear	^ GRMappedPrinter 		block: [ :date | date year ]		next: (self numberWithAtLeastDigits: 4)</body><body package="Grease-Core">unpaddedCentury	^ GRMappedPrinter 		block: [ :date | date year \\ 100 ]		next: GRNumberPrinter new</body><body package="Grease-Core">unpaddedDay	^ GRMappedPrinter 		block: [ :date | date dayOfMonth ]		next: GRNumberPrinter new</body><body package="Grease-Core">unpaddedMonth	^ GRMappedPrinter 		block: [ :date | date monthIndex ]		next: GRNumberPrinter new</body><body package="Grease-Core">unpaddedYear	^ GRMappedPrinter 		block: [ :date | date year ]		next: GRNumberPrinter new</body><body package="Grease-Core">weekName: anArray 	^ GRPluggablePrinter on: [ :date | anArray at: date dayOfWeek ]</body></methods><methods><class-id>Grease.GRPrinter class</class-id> <category>parts-time</category><body package="Grease-Core">paddedHour12	^ GRMappedPrinter 		block: [ :time | (time hour - 1) \\ 12 + 1 ]		next: (self numberWithAtLeastDigits: 2)</body><body package="Grease-Core">paddedHour24	^ GRMappedPrinter 		block: [ :time | time hour ]		next: (self numberWithAtLeastDigits: 2)</body><body package="Grease-Core">paddedMinute	^ GRMappedPrinter 		block: [ :time | time minute ]		next: (self numberWithAtLeastDigits: 2)</body><body package="Grease-Core">paddedSecond	^ GRMappedPrinter 		block: [ :time | time second ]		next: (GRNumberPrinter new				padding: $0;				digits: 2)</body><body package="Grease-Core">unpaddedHour12	^ GRMappedPrinter 		block: [ :time | (time hour - 1) \\ 12 + 1 ]		next: GRNumberPrinter new</body><body package="Grease-Core">unpaddedHour24	^ GRMappedPrinter 		block: [ :time | time hour ]		next: GRNumberPrinter new</body><body package="Grease-Core">unpaddedMinute	^ GRMappedPrinter 		block: [ :time | time minute ]		next: GRNumberPrinter new</body><body package="Grease-Core">unpaddedSecond	^ GRMappedPrinter 		block: [ :time | time second ]		next: GRNumberPrinter new</body></methods><methods><class-id>Grease.GRPrinter class</class-id> <category>factory-currency</category><body package="Grease-Core">swissCurrency	^ GRSequentialPrinter new , 'CHF ' , GRSignPrinter new , (GRNumberPrinter new			separator: $';			precision: 2;			accuracy: 0.05;			yourself)</body><body package="Grease-Core">usCurrency	^ GRSignPrinter new , $$ , (GRNumberPrinter new			separator: $,;			precision: 2;			yourself)</body></methods><methods><class-id>Grease.GRPrinter class</class-id> <category>parts-units</category><body package="Grease-Core">binaryFileSize	^ GRUnitPrinter base: 1024 units: #('byte' 'bytes' 'KiB' 'MiB' 'GiB' 'TiB' 'PiB' 'EiB' 'ZiB' 'YiB')</body><body package="Grease-Core">decimalFileSize	^ GRUnitPrinter base: 1000 units: #('byte' 'bytes' 'kB' 'MB' 'GB' 'TB' 'PB' 'EB' 'ZB' 'YB')</body><body package="Grease-Core">numberWithAtLeastDigits: anInteger	^ GRNumberPrinter new		padding: $0;		digits: anInteger;		yourself</body></methods><methods><class-id>Grease.GRUnitPrinter</class-id> <category>initialization</category><body package="Grease-Core">initialize	super initialize.	self integerPrinter: (GRNumberPrinter new		precision: 0;		yourself).	self fractionPrinter: (GRNumberPrinter new		precision: 1;		yourself)</body></methods><methods><class-id>Grease.GRUnitPrinter</class-id> <category>printing</category><body package="Grease-Core">print: anObject on: aStream	anObject = 1		ifTrue: [ ^ self print: anObject unit: units first on: aStream ].	units allButFirst		inject: anObject asFloat		into: [ :value :each |			value &lt; base				ifFalse: [ value / base ]				ifTrue: [ ^ self print: value unit: each on: aStream ] ]</body><body package="Grease-Core">print: aNumber unit: aString on: aStream	(units first = aString or: [ units second = aString ])		ifTrue: [ integerPrinter print: aNumber on: aStream ]		ifFalse: [ fractionPrinter print: aNumber on: aStream ].	aStream nextPut: $ ; nextPutAll: aString</body></methods><methods><class-id>Grease.GRUnitPrinter</class-id> <category>accessing</category><body package="Grease-Core">base: anInteger	base := anInteger</body><body package="Grease-Core">fractionPrinter: aPrinter	fractionPrinter := aPrinter</body><body package="Grease-Core">integerPrinter: aPrinter	integerPrinter := aPrinter</body><body package="Grease-Core">units: anArray	units := anArray</body></methods><methods><class-id>Grease.GRUnitPrinter class</class-id> <category>instance creation</category><body package="Grease-Core">base: anInteger units: anArray	^ self new 		base: anInteger;		units: anArray;		yourself</body></methods><methods><class-id>Grease.GRSignPrinter</class-id> <category>accessing</category><body package="Grease-Core">negativePrinter: aPrinter	"The printer to be used when the number is negative."		negativePrinter := aPrinter</body><body package="Grease-Core">positivePrinter: aPrinter	"The printer to be used when the number is zero or positive."		positivePrinter := aPrinter</body></methods><methods><class-id>Grease.GRSignPrinter</class-id> <category>initialization</category><body package="Grease-Core">initialize	super initialize.	self negativePrinter: $-.	self positivePrinter: nil</body></methods><methods><class-id>Grease.GRSignPrinter</class-id> <category>printing</category><body package="Grease-Core">print: anObject on: aStream 	anObject negative		ifTrue: [ negativePrinter print: anObject on: aStream ]		ifFalse: [ positivePrinter print: anObject on: aStream ]</body></methods><methods><class-id>Grease.GRSmallDictionary</class-id> <category>private</category><body package="Grease-Core">errorKeyNotFound	self error: 'Key not found'</body><body package="Grease-Core">findIndexFor: aKey	1 to: size do: [ :index |		(keys at: index) = aKey			ifTrue: [ ^ index ] ].	^ 0</body><body package="Grease-Core">grow	| newKeys newValues |	newKeys := Array new: 2 * size.	newValues := Array new: 2 * size.	1 to: size do: [ :index |		newKeys at: index put: (keys at: index).		newValues at: index put: (values at: index) ].	keys := newKeys.	values := newValues</body><body package="Grease-Core">privateAt: aKey put: aValue	size = keys size ifTrue: [ self grow ].	keys at: (size := size + 1) put: aKey.	^ values at: size put: aValue</body><body package="Grease-Core">removeIndex: index	| value |	value := values at: index.	index to: size - 1 do:			[ :i | 			keys at: i put: (keys at: i + 1).			values at: i put: (values at: i + 1) ].	keys at: size put: nil.	values at: size put: nil.	size := size - 1.	^ value</body></methods><methods><class-id>Grease.GRSmallDictionary</class-id> <category>testing</category><body package="Grease-Core">includesKey: aKey	"Answer whether the receiver has a key equal to aKey."	^ (self findIndexFor: aKey) ~= 0</body><body package="Grease-Core">isCollection	^ true</body><body package="Grease-Core">isEmpty	^ size = 0</body></methods><methods><class-id>Grease.GRSmallDictionary</class-id> <category>accessing</category><body package="Grease-Core">add: anAssociation	self at: anAssociation key put: anAssociation value.	^ anAssociation</body><body package="Grease-Core">addAll: aDictionary	aDictionary keysAndValuesDo: [ :key :value | self add: key -&gt; value ].	^ aDictionary</body><body package="Grease-Core">associations	"Answer a Collection containing the receiver's associations."	| result |	result := WriteStream on: (Array new: self size).	self associationsDo: [ :assoc | result nextPut: assoc ].	^ result contents</body><body package="Grease-Core">at: aKey	"Answer the value associated with aKey. Raise an exception, if no such key is defined."	^ self at: aKey ifAbsent: [ self errorKeyNotFound ]</body><body package="Grease-Core">at: aKey ifAbsent: aBlock	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined."	| index |	index := self findIndexFor: aKey.	^ index = 0		ifFalse: [ values at: index ]		ifTrue: [ aBlock value ]</body><body package="Grease-Core">at: aKey ifAbsentPut: aBlock	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined and store the return value."	| index |	index := self findIndexFor: aKey.	^ index = 0		ifFalse: [ values at: index ]		ifTrue: [ self privateAt: aKey put: aBlock value ]</body><body package="Grease-Core">at: aKey ifPresent: aBlock	"Lookup aKey in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."	| index |	index := self findIndexFor: aKey.	^ index = 0 ifFalse: [ aBlock value: (values at: index) ]</body><body package="Grease-Core">at: aKey put: aValue	"Set the value of aKey to be aValue."	| index |	index := self findIndexFor: aKey.	^ index = 0		ifFalse: [ values at: index put: aValue ]		ifTrue: [ self privateAt: aKey put: aValue ]</body><body package="Grease-Core">removeKey: aKey	"Remove aKey from the receiver, raise an exception if the element is missing."	^ self removeKey: aKey ifAbsent: [ self errorKeyNotFound ]</body><body package="Grease-Core">removeKey: aKey ifAbsent: aBlock	"Remove aKey from the receiver, evaluate aBlock if the element is missing."	| index |	index := self findIndexFor: aKey.	index = 0 ifTrue: [ ^ aBlock value ].	^ self removeIndex: index</body><body package="Grease-Core">size	^ size</body></methods><methods><class-id>Grease.GRSmallDictionary</class-id> <category>enumerating</category><body package="Grease-Core">associationsDo: aBlock	self keysAndValuesDo: [ :key :value | aBlock value: key -&gt; value ]</body><body package="Grease-Core">do: aBlock	1 to: size do: [ :index | aBlock value: (values at: index) ]</body><body package="Grease-Core">keys	^ keys copyFrom: 1 to: size</body><body package="Grease-Core">keysAndValuesDo: aBlock	1 to: size do: [ :index | aBlock value: (keys at: index) value: (values at: index) ]</body><body package="Grease-Core">keysDo: aBlock	1 to: size do: [ :each | aBlock value: (keys at: each) ]</body><body package="Grease-Core">values	^ values copyFrom: 1 to: size</body></methods><methods><class-id>Grease.GRSmallDictionary</class-id> <category>initialization</category><body package="Grease-Core">initialize: anInteger	self initialize.	size := 0.	keys := Array new: anInteger.	values := Array new: anInteger</body></methods><methods><class-id>Grease.GRSmallDictionary</class-id> <category>printing</category><body package="Grease-Core">printOn: aStream	super printOn: aStream.		aStream nextPut: $(.	self size &lt;= 100		ifTrue: [			| first |			first := true.			self keysAndValuesDo: [ :key :value |				"keysAndValuesDo:separatedBy: would be nice"				first					ifTrue: [ first := false ]					ifFalse: [ aStream space ].				aStream					print: key;					nextPutAll: '-&gt;';									print: value ] ]		ifFalse: [			aStream				nextPutAll: 'size ';				print: self size ].	aStream nextPut: $)</body></methods><methods><class-id>Grease.GRSmallDictionary</class-id> <category>copying</category><body package="Grease-Core">postCopy	super postCopy.	keys := keys copy.	values := values copy</body></methods><methods><class-id>Grease.GRSmallDictionary class</class-id> <category>instance creation</category><body package="Grease-Core">new	^ self new: 3</body><body package="Grease-Core">new: anInteger	^ self basicNew initialize: anInteger; yourself</body><body package="Grease-Core">withAll: aDictionary	^ (self new: aDictionary size)		addAll: aDictionary;		yourself</body></methods><methods><class-id>Grease.GRDeprecatedApiNotification</class-id> <category>accessing</category><body package="Grease-Core">details	^ details</body><body package="Grease-Core">details: anObject	details := anObject</body></methods><methods><class-id>Grease.GRPluggablePrinter</class-id> <category>printing</category><body package="Grease-Core">print: anObject on: aStream	aStream nextPutAll: (block value: anObject)</body></methods><methods><class-id>Grease.GRPluggablePrinter</class-id> <category>initialization</category><body package="Grease-Core">initialize	super initialize.	self block: [ :value | String new ]</body></methods><methods><class-id>Grease.GRPluggablePrinter</class-id> <category>accessing</category><body package="Grease-Core">block: aBlock	block := aBlock</body></methods><methods><class-id>Grease.GRPluggablePrinter class</class-id> <category>instance creation</category><body package="Grease-Core">on: aBlock	^ self new block: aBlock</body></methods><methods><class-id>Grease.GRCountingStream</class-id> <category>streaming</category><body package="Grease-Core">next	self shouldNotImplement</body><body package="Grease-Core">next: anInteger	self shouldNotImplement</body><body package="Grease-Core">nextPut: aCharacter	stream nextPut: aCharacter.	count := count + 1</body><body package="Grease-Core">nextPutAll: aString	stream nextPutAll: aString.	count := count + aString size</body></methods><methods><class-id>Grease.GRCountingStream</class-id> <category>accessing</category><body package="Grease-Core">count	^ count</body><body package="Grease-Core">reset	super reset.	count := 0</body></methods><methods><class-id>Grease.GRCountingStream</class-id> <category>initialization</category><body package="Grease-Core">initialize	super initialize.	count := 0</body></methods><methods><class-id>Grease.GRDelayedSendMessage</class-id> <category>printing</category><body package="Grease-Core">printOn: aStream	aStream nextPutAll: 'selector: '; print: selector</body></methods><methods><class-id>Grease.GRDelayedSendMessage</class-id> <category>initialization</category><body package="Grease-Core">initializeWithSelector: aSymbol	self initialize.	selector := aSymbol</body></methods><methods><class-id>Grease.GRDelayedSendMessage</class-id> <category>delegation</category><body package="Grease-Core">argumentCount	"Answer the number of arguments that must be provided when sending this message."		self subclassResponsibility</body><body package="Grease-Core">valueFor: receiver withArguments: anArray	"Send the message to receiver with the arguments in anArray. Answer the result.	Signal an error if the number of arguments does not match the selector."		^ self basicPerformFor: receiver withArguments: (self mergeArguments: anArray)</body><body package="Grease-Core">valueFor: receiver withPossibleArguments: anArray	"Send the message to receiver with as many of the arguments in anArray as possible. Answer the result.	Error if not enough arguments are available for the selector."	| allArguments |	allArguments := self mergeArguments: anArray.		^ allArguments size &lt; selector numArgs		ifTrue: [ self invalidArgumentCount ]		ifFalse: [ self basicPerformFor: receiver withArguments: (allArguments first: selector numArgs) ]</body></methods><methods><class-id>Grease.GRDelayedSendMessage</class-id> <category>private</category><body package="Grease-Core">basicPerformFor: receiver withArguments: anArray	^ anArray size = selector numArgs		ifTrue: [ receiver perform: selector withArguments: anArray ]		ifFalse: [ self invalidArgumentCount ]</body><body package="Grease-Core">invalidArgumentCount	GRInvalidArgumentCount signal</body><body package="Grease-Core">mergeArguments: anArray	self subclassResponsibility</body></methods><methods><class-id>Grease.GRDelayedSendMessage class</class-id> <category>instance creation</category><body package="Grease-Core">new	^ self selector: #yourself</body><body package="Grease-Core">selector: aSymbol	^ self basicNew		initializeWithSelector: aSymbol;		yourself</body></methods><methods><class-id>Grease.GRUnboundMessage</class-id> <category>delegation</category><body package="Grease-Core">argumentCount	^ selector numArgs</body></methods><methods><class-id>Grease.GRUnboundMessage</class-id> <category>private</category><body package="Grease-Core">mergeArguments: anArray	^ anArray</body></methods><methods><class-id>Grease.GRPackage</class-id> <category>accessing-repositories</category><body package="Grease-Core">greaseUrl	^ 'http://smalltalkhub.com/mc/Seaside/Grease11/main'</body><body package="Grease-Core">seasideAddonsUrl	^ 'http://smalltalkhub.com/mc/Seaside/Seaside30Addons/main'</body><body package="Grease-Core">seasideLGPLUrl	^ 'http://smalltalkhub.com/mc/Seaside/Seaside30LGPL/main'</body><body package="Grease-Core">seasideUrl	^ 'http://smalltalkhub.com/mc/Seaside/Seaside31/main'</body></methods><methods><class-id>Grease.GRPackage</class-id> <category>accessing</category><body package="Grease-Core">description	"Answer a short description of the package."	^ description</body><body package="Grease-Core">description: aString	description := aString</body><body package="Grease-Core">license	"Answer the current license of this package, by default MIT is used."	^ license</body><body package="Grease-Core">license: aSymbol	license := aSymbol</body><body package="Grease-Core">name	"Answer the name of the package. This string should be useable to identify the platform specific native package object, e.g. the Monticello package name."	^ name</body><body package="Grease-Core">name: aString	name := aString</body><body package="Grease-Core">url	"Answer the base-URL of the package. This string is only meaningful for platforms that can directly access Monticello repositories."	^ url isSymbol		ifTrue: [ self perform: url ]		ifFalse: [ url ]</body><body package="Grease-Core">url: aStringOrSymbol	"Set the base-URL of the package, or a symbol referring to a method in this class that answers the URL. This setting is only meaningful for platforms that can directly access Monticello repositories."	url := aStringOrSymbol</body></methods><methods><class-id>Grease.GRPackage</class-id> <category>dependencies</category><body package="Grease-Core">addDependency: aString	dependencies add: aString</body><body package="Grease-Core">allDependencies	"Answer all dependencies on which this package depends."	^ self addDependenciesTo: OrderedCollection new</body><body package="Grease-Core">dependencies	"Return a collection of package names on which this package depends."	^ dependencies</body><body package="Grease-Core">resolveWith: aDictionary	dependencies := dependencies 		collect: [ :each |			aDictionary at: each ifAbsent: [				"if Foo-Pharo-Bar fails try Foo-Pharo20-Bar and Foo-Pharo30-Bar"				(each indexOfSubCollection: '-Pharo-' startingAt: 1) ~= 0 ifTrue: [ 					"try -Pharo20-"					aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo20-') ifAbsent: [						"try -Pharo30-"						aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo30-') ifAbsent: [							"try -Pharo40-"							aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo40-') ifAbsent: [								"try -Pharo50-"								aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo50-') ifAbsent: [									self error: self name printString , ' depends on unknown package ' , each printString ] ] ] ] ] ] ]</body></methods><methods><class-id>Grease.GRPackage</class-id> <category>printing</category><body package="Grease-Core">printOn: aStream	super printOn: aStream.	aStream nextPut: $(; nextPutAll: self name; nextPut: $)</body></methods><methods><class-id>Grease.GRPackage</class-id> <category>initialization</category><body package="Grease-Core">initialize	super initialize.	dependencies := OrderedCollection new.	license := #MIT</body></methods><methods><class-id>Grease.GRPackage</class-id> <category>testing</category><body package="Grease-Core">isLGPL	^ self license = #LGPL</body><body package="Grease-Core">isMIT	^ self license = #MIT</body></methods><methods><class-id>Grease.GRPackage</class-id> <category>private</category><body package="Grease-Core">addDependenciesTo: aCollection	(aCollection includes: self) ifFalse: [		self dependencies			do: [ :each | each addDependenciesTo: aCollection ].		aCollection add: self ].	^ aCollection</body></methods><methods><class-id>Grease.GRPackage class</class-id> <category>querying</category><body package="Grease-Core">grPackages	"Answer a list of all registered packages. A package is registered by adding a class extension to the receiving class answering an instance of the receiving class."	| packages package |	packages := Dictionary new.	self class selectors do: [ :each |		(each numArgs = 0 and: [ each ~= #grPackages ]) ifTrue: [ 			package := self perform: each.			packages at: package name put: package ] ].	packages do: [ :each | each resolveWith: packages ].	^ packages values</body></methods><methods><class-id>Grease.GRPackage class</class-id> <category>accessing</category><body package="Grease-Core">greaseCore	^ self new		name: 'Grease-Core';		description: 'The main package of the Grease compatibility layer.';		url: #greaseUrl;		yourself</body></methods><methods><class-id>Grease.GROrdinalizePrinter</class-id> <category>printing</category><body package="Grease-Core">print: anObject on: aStream	aStream nextPutAll: (self ordinalize: anObject integerPart)</body></methods><methods><class-id>Grease.GROrdinalizePrinter</class-id> <category>private</category><body package="Grease-Core">ordinalize: anInteger	^ (anInteger \\ 100 between: 11 and: 13)		ifTrue: [ 'th' ]		ifFalse: [ 			#('st' 'nd' 'rd')				at: anInteger \\ 10 				ifAbsent: [ 'th' ] ]</body></methods><methods><class-id>Grease.GRNumberPrinter</class-id> <category>printing</category><body package="Grease-Core">print: aNumber on: aStream	aNumber isNaN		ifTrue: [ ^ self printNaN: aNumber on: aStream ].	aNumber isInfinite 		ifTrue: [ ^ self printInfinite: aNumber on: aStream ].	precision = 0		ifTrue: [ self printInteger: aNumber on: aStream ]		ifFalse: [ self printFloat: aNumber on: aStream ]</body><body package="Grease-Core">printFloat: aNumber on: aStream	| multiplier rounded |	multiplier := base raisedTo: precision.	rounded := aNumber roundTo: (accuracy ifNil: [ multiplier reciprocal ]).	self printInteger: rounded on: aStream.	delimiter isNil		ifFalse: [ aStream nextPut: delimiter ].	self printFraction: rounded fractionPart abs * multiplier on: aStream</body><body package="Grease-Core">printFraction: aNumber on: aStream	| result |	result := self		pad: (self digitsOf: aNumber rounded base: base)		left: $0 to: precision.	separator isNil		ifFalse: [ result := self separate: result left: separator ].	aStream nextPutAll: result</body><body package="Grease-Core">printInfinite: aNumber on: aStream	infinite isNil		ifFalse: [ aStream nextPutAll: infinite ]</body><body package="Grease-Core">printInteger: aNumber on: aStream	| result |	result := self digitsOf: aNumber integerPart base: base.	separator isNil		ifFalse: [ result := self separate: result right: separator ].	(digits isNil or: [ padding isNil ])		ifFalse: [ result := self pad: result left: padding to: digits ].	aStream nextPutAll: result</body><body package="Grease-Core">printNaN: anInteger on: aStream	nan isNil		ifFalse: [ aStream nextPutAll: nan ]</body></methods><methods><class-id>Grease.GRNumberPrinter</class-id> <category>initialization</category><body package="Grease-Core">initialize	super initialize.	self lowercase.	self base: 10.	self delimiter: $..	self infinite: 'Infinite'.	self nan: 'NaN'.	self padding: $ .	self precision: 0</body></methods><methods><class-id>Grease.GRNumberPrinter</class-id> <category>accessing</category><body package="Grease-Core">accuracy: aFloat	"Round towards the nearest number that is a multiple of aFloat."		accuracy := aFloat</body><body package="Grease-Core">base: anInteger	"The numeric base to which the number should be printed."	base := anInteger</body><body package="Grease-Core">characters: aString	"The characters to be used to convert a number to a string."	characters := aString</body><body package="Grease-Core">delimiter: aCharacter	"The delimiter to separate the integer and fraction part of the number."	delimiter := aCharacter</body><body package="Grease-Core">digits: anInteger	"The number of digits to be printed in the integer part."	digits := anInteger</body><body package="Grease-Core">infinite: aString	"The string that should be displayed if the number is positive or negative infinity."		infinite := aString</body><body package="Grease-Core">nan: aString	"The string that should be displayed if the number is not a number."		nan := aString</body><body package="Grease-Core">padding: aCharacter	"The padding for the integer part."	padding := aCharacter</body><body package="Grease-Core">precision: anInteger	"The number of digits to be printed in the fraction part."		precision := anInteger</body><body package="Grease-Core">separator: aCharacter	"Separator character to be used to group digits."	separator := aCharacter</body></methods><methods><class-id>Grease.GRNumberPrinter</class-id> <category>actions</category><body package="Grease-Core">lowercase	"Use lowercase characters for numbers of base 10 and higher."	self characters: NumbersToCharactersLowercase</body><body package="Grease-Core">uppercase	"Use uppercase characters for numbers of base 10 and higher."		self characters: NumbersToCharactersUppercase</body></methods><methods><class-id>Grease.GRNumberPrinter</class-id> <category>utilities</category><body package="Grease-Core">digitsOf: aNumber base: aBaseInteger	"Answer the absolute digits of aNumber in the base aBaseInteger."	| integer stream next |	integer := aNumber truncated abs.	integer = 0 ifTrue: [ ^ '0' ].	stream := WriteStream on: (String new: 10).	[ integer &gt; 0 ] whileTrue: [		next := integer quo: aBaseInteger.		stream nextPut: (characters 			at: 1 + integer - (next * aBaseInteger)).		integer := next ].	^ stream contents reverse</body><body package="Grease-Core">separate: aString left: aCharacter	"Separate from the left side every 3 characters with aCharacter."			| size stream |	size := aString size.	stream := WriteStream on: (String new: 2 * size).	1 to: size do: [ :index |		(index ~= 1 and: [ index \\ 3 = 1 ])			ifTrue: [ stream nextPut: aCharacter ].		stream nextPut: (aString at: index) ].	^ stream contents</body><body package="Grease-Core">separate: aString right: aCharacter	"Separate from the right side every 3 characters with aCharacter."			| size stream |	size := aString size.	stream := WriteStream on: (String new: 2 * size).	1 to: size do: [ :index |		(index ~= 1 and: [ size - index \\ 3 = 2 ])			ifTrue: [ stream nextPut: aCharacter ].		stream nextPut: (aString at: index) ].	^ stream contents</body></methods><methods><class-id>Grease.GRNumberPrinter class</class-id> <category>initialization</category><body package="Grease-Core">initialize	NumbersToCharactersLowercase := '0123456789abcdefghijklmnopqrstuvwxyz'.	NumbersToCharactersUppercase := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'</body></methods><methods><class-id>Grease.GRPlatform</class-id> <category>exceptions</category><body package="Grease-Core">deprecationExceptionSet	"Answer the exception set that should considered besides WADeprecation."	^ ExceptionSet new</body><body package="Grease-Core">openDebuggerOn: anError	self subclassResponsibility</body><body package="Grease-Core">stackDepth	self subclassResponsibility</body></methods><methods><class-id>Grease.GRPlatform</class-id> <category>file library</category><body package="Grease-Core">asMethodReturningByteArray: aByteArrayOrString named: aSymbol	"Generates the source of a method named aSymbol that returns aByteArrayOrString as a ByteArray"	self subclassResponsibility</body><body package="Grease-Core">compile: aString into: aClass classified: aSymbol	"The trick here is to be as silently a possible so that the package is not marked dirty when running WAFileLibrary test.	This also makes running tests much faster."	self subclassResponsibility</body><body package="Grease-Core">contentsOfFile: aString binary: aBoolean	self subclassResponsibility</body><body package="Grease-Core">convertToSmalltalkNewlines: aString	"Convert any line endings (CR, CRLF, LF) to the default platform newline."		aString isNil 		ifTrue: [ ^ nil ].	^ String streamContents: [ :writeStream |		| readStream |		readStream := aString readStream.		[ readStream atEnd ] whileFalse: [			| next |			next := readStream next.			next = Character cr				ifTrue: [					readStream peek = Character lf						ifTrue: [ readStream skip: 1 ].					writeStream nextPutAll: self newline ]				ifFalse: [					next = Character lf						ifTrue: [ writeStream nextPutAll: self newline ]						ifFalse: [ writeStream nextPut: next ] ] ] ]</body><body package="Grease-Core">directoriesIn: aPathString	"Answer a collection of absolute paths for all the directories (no files) in the directory given by aPathString	must not include directory names that start with ."	self subclassResponsibility</body><body package="Grease-Core">ensureExistenceOfFolder: aString	"Create a folder named aString in the image directory."	self subclassResponsibility</body><body package="Grease-Core">fileExists: aString	self subclassResponsibility</body><body package="Grease-Core">fileStreamOn: aString do: aBlock binary: aBoolean	self subclassResponsibility</body><body package="Grease-Core">filesIn: aPathString	"Answer a collection of absolute paths for all the files (no directories) in the directory given by aPathString	must not include file names that start with ."	self subclassResponsibility</body><body package="Grease-Core">localNameOf: aFilename	"Answer the local name of a file identified by an absolute file path.		Eg.	If the platform is Windwos and aFilename is 'C:\Windows\win32.dll' then it would answer 'win32.dll'.	If the platform is Unix and aFilename is '/usr/bin/vim' then it would answer 'vim'."	self subclassResponsibility</body><body package="Grease-Core">newline	"Answer a String with the default newline character of this platform."		self subclassResponsibility</body><body package="Grease-Core">pathSeparator	"Answer the path separator as a String, eg. '/' on Unix and '\' on Windows."	self subclassResponsibility</body><body package="Grease-Core">removeSelector: aSymbol from: aClass	self subclassResponsibility</body><body package="Grease-Core">write: aStringOrByteArray toFile: aFileNameString inFolder: aFolderString	"Write aStringOrByteArray to a file named aFileNameString in the folder aFolderString."	self subclassResponsibility</body></methods><methods><class-id>Grease.GRPlatform</class-id> <category>startup</category><body package="Grease-Core">addToShutDownList: anObject	"Add anObject to the shutdown-list of the system. On shutdown the message #shutDown will be sent to anObject."	self subclassResponsibility</body><body package="Grease-Core">addToStartUpList: anObject	"Add anObject to the startup-list of the system. On startup the message #startUp will be sent to anObject."	self subclassResponsibility</body><body package="Grease-Core">removeFromShutDownList: anObject	"Remove anObject from the shutdown list in the system."	self subclassResponsibility</body><body package="Grease-Core">removeFromStartUpList: anObject	"Remove anObject from the startup list in the system."	self subclassResponsibility</body></methods><methods><class-id>Grease.GRPlatform</class-id> <category>processes</category><body package="Grease-Core">isProcessTerminated: aProcess	"Return a boolean indicating whether aProcess has been terminated."		self subclassResponsibility</body><body package="Grease-Core">terminateProcess: aProcess	"Permanently terminate the process, unwinding first to execute #ensure: and #ifCurtailed: blocks."		self subclassResponsibility</body></methods><methods><class-id>Grease.GRPlatform</class-id> <category>factory</category><body package="Grease-Core">newRandom	"Answers the random number generator to be used to create session and continuation keys. Make sure it is seeded. They only methods that will be sent to it are:	  #nextInt: - should answer a random integer in the interval [1, anInteger]	  #randomFrom: - should answer a random element from the given collection		Make sure that both methods are safe under heavy concurrent load.		Used by Gemstone/S traditional Randoms which cannot be persisted.	Used by Squeak to use a secure random when avaiable."	self subclassResponsibility</body><body package="Grease-Core">readWriteByteStream	"Return a ReadWriteStream on a ByteArray that stores integers 0..255		^ReadWriteStream on: ByteArray new	"	^ self subclassResponsibility</body><body package="Grease-Core">readWriteCharacterStream	"Return a ReadWriteStream on a String that stores characters		^ReadWriteStream on: String new	"	^ self subclassResponsibility</body><body package="Grease-Core">reducedConflictDictionary	"used by Gemstone/S reduced conflict classes that can be used to avoid transaction conflicts"	^ Dictionary</body><body package="Grease-Core">semaphoreClass	"used by Gemstone/S traditional Semaphores which cannot be persisted"	self subclassResponsibility</body><body package="Grease-Core">weakDictionaryOfSize: aNumber	self subclassResponsibility</body><body package="Grease-Core">writeCharacterStreamOn: aString	"String based write stream"	^ WriteStream on: aString</body></methods><methods><class-id>Grease.GRPlatform</class-id> <category>cryptography</category><body package="Grease-Core">secureHashFor: aString	self subclassResponsibility</body></methods><methods><class-id>Grease.GRPlatform</class-id> <category>version info</category><body package="Grease-Core">label	"Answer a descriptive label string for the platform implementation"		self subclassResponsibility</body><body package="Grease-Core">version	"Answer the Grease version"	^ (GRVersion major: 1 minor: 1 revision: 10)		yourself</body><body package="Grease-Core">versionString	^ String streamContents: [ :stream |		stream			nextPutAll: (self version greaseString);			nextPutAll: ' (';			nextPutAll: (self label);			nextPut: $) ]</body></methods><methods><class-id>Grease.GRPlatform</class-id> <category>transactions</category><body package="Grease-Core">doTransaction: aBlock	"for Gemstone/S compatibility	http://gemstonesoup.wordpress.com/2007/05/10/porting-application-specific-seaside-threads-to-gemstone/	use when modifying an object from an outside thread"	^ aBlock value</body></methods><methods><class-id>Grease.GRPlatform</class-id> <category>encoding</category><body package="Grease-Core">base64Decode: aString	"Base64 decode the given String and answer the result as a String."	self subclassResponsibility</body></methods><methods><class-id>Grease.GRPlatform</class-id> <category>bindings</category><body package="Grease-Core">bindingOf: aClass	"Answer the binding of aClass.	The binding is the literal that get compiled into the method.	We need the binding to be updated when the class is changed.	The binding has to respond to #value.		This is mostly an issue on GemStone/S because when we hold on	to a class directly we will end up holding on to an old class version.		Dialects with namespaces will need to override this.		On VisualWorks this should like this	^ aClass fullyQualifiedReference"	^ Smalltalk associationAt: aClass name</body></methods><methods><class-id>Grease.GRPlatform class</class-id> <category>registration</category><body package="Grease-Core">current	^ Current</body><body package="Grease-Core">current: aPlatform	Current := aPlatform</body><body package="Grease-Core">select	GRPlatform current: self new</body><body package="Grease-Core">unselect	GRPlatform current class = self ifTrue: [ GRPlatform current: nil ]</body></methods><methods><class-id>Grease.GRMappedPrinter</class-id> <category>accessing</category><body package="Grease-Core">block: aBlock	block := aBlock</body><body package="Grease-Core">next: aPrinter	next := aPrinter</body></methods><methods><class-id>Grease.GRMappedPrinter</class-id> <category>initialization</category><body package="Grease-Core">initialize	super initialize.	self block: [ :value | value ]</body></methods><methods><class-id>Grease.GRMappedPrinter</class-id> <category>printing</category><body package="Grease-Core">print: anObject on: aStream	next print: (block value: anObject) on: aStream</body></methods><methods><class-id>Grease.GRMappedPrinter class</class-id> <category>instance creation</category><body package="Grease-Core">block: aBlock next: aPrinter	^ self new 		block: aBlock;		next: aPrinter;		yourself</body></methods><methods><class-id>Grease.GRSequentialPrinter</class-id> <category>operators</category><body package="Grease-Core">, aConverter	parts add: aConverter</body></methods><methods><class-id>Grease.GRSequentialPrinter</class-id> <category>printing</category><body package="Grease-Core">print: anObject on: aStream 	parts do: [ :each | each print: anObject on: aStream ]</body></methods><methods><class-id>Grease.GRSequentialPrinter</class-id> <category>initialization</category><body package="Grease-Core">initialize	super initialize.	parts := OrderedCollection new</body></methods><methods><class-id>Grease.GRNullCodecStream</class-id> <category>streaming</category><body package="Grease-Core">next	^ stream next</body><body package="Grease-Core">next: anInteger	^ stream next: anInteger</body><body package="Grease-Core">nextPut: aCharacterOrByte	aCharacterOrByte isCharacter		ifTrue: [ stream nextPut: aCharacterOrByte ]		ifFalse: [ stream nextPut: (Character codePoint: aCharacterOrByte) ]</body><body package="Grease-Core">nextPutAll: aStringOrByteArray	aStringOrByteArray isString		ifTrue: [ stream nextPutAll: aStringOrByteArray ]		ifFalse: [			1 to: aStringOrByteArray size do: [ :index |				stream nextPut: (Character codePoint: (aStringOrByteArray at: index)) ] ]</body></methods><methods><class-id>Grease.GROrderedMultiMap</class-id> <category>accessing</category><body package="Grease-Core">add: anAssociation	self privateAt: anAssociation key put: anAssociation value.	^ anAssociation</body><body package="Grease-Core">allAt: aKey	^ Array streamContents: [ :stream |		1 to: size do: [ :index |			(keys at: index) = aKey				ifTrue: [ stream nextPut: (values at: index) ] ] ]</body><body package="Grease-Core">allAt: aKey ifAbsent: absentBlock	| results |	results := self allAt: aKey.	^ results isEmpty		ifTrue: [ absentBlock value ]		ifFalse: [ results ]</body><body package="Grease-Core">at: aKey add: aValue	"Add an association between aKey and aValue. Do not replace existing	values with the same key."		^ self privateAt: aKey put: aValue</body><body package="Grease-Core">removeKey: aKey ifAbsent: aBlock	"Remove aKey from the receiver, evaluate aBlock if the element is missing."	"This is inefficient and could be optimized."	| removed |	removed := Array streamContents: [ :stream |		| index |		[ (index := self findIndexFor: aKey) = 0 ] whileFalse: [			stream nextPut: (self removeIndex: index) ] ].	^ removed isEmpty		ifTrue: [ aBlock value ]		ifFalse: [ removed ]</body></methods><methods><class-id>Grease.GRVersion</class-id> <category>accessing</category><body package="Grease-Core">major	^ major</body><body package="Grease-Core">major: anInteger	major := anInteger</body><body package="Grease-Core">minor	^ minor</body><body package="Grease-Core">minor: anInteger	minor := anInteger</body><body package="Grease-Core">revision	^ revision</body><body package="Grease-Core">revision: anInteger	revision := anInteger</body><body package="Grease-Core">stage	^ stageLabel</body><body package="Grease-Core">stage: aSymbol number: anInteger	stageLabel := aSymbol.	stageNumber := anInteger</body><body package="Grease-Core">stageNumber	^ stageNumber</body></methods><methods><class-id>Grease.GRVersion</class-id> <category>testing</category><body package="Grease-Core">isAlpha	^ stageLabel = #alpha</body><body package="Grease-Core">isBeta	^ stageLabel = #beta</body><body package="Grease-Core">isFinal	^ stageLabel isNil</body><body package="Grease-Core">isReleaseCandidate	^ stageLabel = #rc</body></methods><methods><class-id>Grease.GRVersion</class-id> <category>comparing</category><body package="Grease-Core">&lt; otherVersion	(major &lt; otherVersion major) ifTrue: [ ^ true ].	(otherVersion major &lt; major) ifTrue: [ ^ false ].	((minor ifNil: [ 0 ]) &lt; (otherVersion minor ifNil: [ 0 ])) ifTrue: [ ^ true ].	((otherVersion minor ifNil: [ 0 ]) &lt; (minor ifNil: [ 0 ])) ifTrue: [ ^ false ].	((revision ifNil: [ 0 ]) &lt; (otherVersion revision ifNil: [ 0 ])) ifTrue: [ ^ true ].	((otherVersion revision ifNil: [ 0 ]) &lt; (revision ifNil: [ 0 ])) ifTrue: [ ^ false ].	(stageLabel = otherVersion stage) ifTrue: [		^ ((stageNumber ifNil: [ 1 ]) &lt; (otherVersion stageNumber ifNil: [ 1 ])) ].	stageLabel isNil ifTrue: [ ^ false ].	otherVersion stage isNil ifTrue: [ ^ true ].	^ stageLabel &lt; otherVersion stage</body><body package="Grease-Core">&lt;= otherVersion	^ (self &gt; otherVersion) not</body><body package="Grease-Core">= otherVersion	^ (major = otherVersion major) and: [		((minor ifNil: [ 0 ]) = (otherVersion minor ifNil: [ 0 ])) and: [		((revision ifNil: [ 0 ] ) = (otherVersion revision ifNil: [ 0 ])) and: [		(stageLabel = otherVersion stage) and: [		(stageNumber ifNil: [ 1 ]) = (otherVersion stageNumber ifNil: [ 1 ]) ] ] ] ]</body><body package="Grease-Core">&gt; otherVersion	^ otherVersion &lt; self</body><body package="Grease-Core">&gt;= otherVersion	^ (self &lt; otherVersion) not</body><body package="Grease-Core">hash	^ (major hash bitXor: minor hash) bitXor: revision hash</body></methods><methods><class-id>Grease.GRVersion</class-id> <category>convenience</category><body package="Grease-Core">beAlpha	self beAlpha: nil</body><body package="Grease-Core">beAlpha: anInteger	self stage: #alpha number: anInteger</body><body package="Grease-Core">beBeta	self beBeta: nil</body><body package="Grease-Core">beBeta: anInteger	self stage: #beta number: anInteger</body><body package="Grease-Core">beFinal	self stage: nil number: nil</body><body package="Grease-Core">beReleaseCandidate	self beReleaseCandidate: nil</body><body package="Grease-Core">beReleaseCandidate: anInteger	self stage: #rc number: anInteger</body></methods><methods><class-id>Grease.GRVersion</class-id> <category>converting</category><body package="Grease-Core">greaseString	^ String streamContents: [ :stream |		stream nextPutAll: major greaseString.		stream nextPut: $..		stream nextPutAll: (minor ifNil: [ 0 ]) greaseString.		revision isNil ifFalse: [			stream nextPut: $..			stream nextPutAll: revision greaseString ].		stageLabel isNil ifFalse: [			stream nextPutAll: stageLabel greaseString.			stageNumber isNil ifFalse: [ stream nextPutAll: stageNumber greaseString ] ] ]</body></methods><methods><class-id>Grease.GRVersion</class-id> <category>initialization</category><body package="Grease-Core">initializeWithMajor: majorInteger minor: minorInteger revision: revisionInteger	self initialize.	major := majorInteger.	minor := minorInteger.	revision := revisionInteger</body></methods><methods><class-id>Grease.GRVersion class</class-id> <category>instance creation</category><body package="Grease-Core">major: majorInteger	^ self major: majorInteger minor: nil</body><body package="Grease-Core">major: majorInteger minor: minorInteger	^ self major: majorInteger minor: minorInteger revision: nil</body><body package="Grease-Core">major: majorInteger minor: minorInteger revision: revisionInteger	^ self basicNew		initializeWithMajor: majorInteger minor: minorInteger revision: revisionInteger;		yourself</body><body package="Grease-Core">new	^ self major: 1</body></methods><methods><class-id>Grease.GRStringPrinter</class-id> <category>trimming</category><body package="Grease-Core">trimBoth	"Trim to the left and to the right."	trim := #trimBoth</body><body package="Grease-Core">trimLeft	"Trim to the left and to the right."	trim := #trimLeft</body><body package="Grease-Core">trimNone	"Do not trim the input."	trim := nil</body><body package="Grease-Core">trimRight	"Trim to the left and to the right."	trim := #trimRight</body></methods><methods><class-id>Grease.GRStringPrinter</class-id> <category>printing</category><body package="Grease-Core">print: anObject on: aStream 	| string |	string := anObject greaseString.	trim isNil		ifFalse: [ string := string perform: trim ].	length isNil ifFalse: [		length &lt; string size 			ifTrue: [ string := string copyFrom: 1to: length ].		(pad isNil or: [ character isNil ])			ifFalse: [ string := self perform: pad with: string with: character with: length ] ].	aStream nextPutAll: string</body></methods><methods><class-id>Grease.GRStringPrinter</class-id> <category>padding</category><body package="Grease-Core">padCenter	"Pad to the center."		pad := #pad:center:to:</body><body package="Grease-Core">padLeft	"Pad to the left."		pad := #pad:left:to:</body><body package="Grease-Core">padNone	"Do not pad the input."		pad := nil</body><body package="Grease-Core">padRight	"Pad to the right."		pad := #pad:right:to:</body></methods><methods><class-id>Grease.GRStringPrinter</class-id> <category>accessing</category><body package="Grease-Core">character: aCharacter	"The character to pad the string with."		character := aCharacter</body><body package="Grease-Core">length: anInteger	"The maximal size of the string, or the size to pad to."	length := anInteger</body></methods><methods><class-id>Grease.GRStringPrinter</class-id> <category>initialization</category><body package="Grease-Core">initialize	super initialize.	self character: $ ; length: nil.	self trimNone; padNone</body></methods><methods><class-id>Grease.GRBoundMessage</class-id> <category>private</category><body package="Grease-Core">mergeArguments: anArray	^ arguments , anArray</body></methods><methods><class-id>Grease.GRBoundMessage</class-id> <category>printing</category><body package="Grease-Core">printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' arguments: '; print: arguments</body></methods><methods><class-id>Grease.GRBoundMessage</class-id> <category>initialization</category><body package="Grease-Core">initializeWithSelector: aSymbol arguments: anArray	self initializeWithSelector: aSymbol.	arguments := anArray asArray</body></methods><methods><class-id>Grease.GRBoundMessage</class-id> <category>delegation</category><body package="Grease-Core">argumentCount	^ selector numArgs - arguments size</body></methods><methods><class-id>Grease.GRBoundMessage class</class-id> <category>instance creation</category><body package="Grease-Core">selector: aSymbol	^ self selector: aSymbol arguments: #()</body><body package="Grease-Core">selector: aSymbol arguments: anArray	^ self basicNew		initializeWithSelector: aSymbol arguments: anArray;		yourself</body></methods><methods><class-id>Core.Integer</class-id> <category>*grease-core</category><body package="Grease-Core">greaseInteger	^ self</body><body package="Grease-Core">pluralize: aSingularString 	^ self 		pluralize: aSingularString		with: (GRInflector pluralize: aSingularString)</body><body package="Grease-Core">pluralize: aSingularString with: aPluralString	^ self printString , ' ' , (self abs = 1 ifTrue: [ aSingularString ] ifFalse: [ aPluralString ])</body></methods><methods><class-id>Core.String</class-id> <category>*grease-core</category><body package="Grease-Core">excerpt: aString	"Answer an excerpt of the receiver that matches the first occurence of aString. If aString isn't found, nil is answered."		^ self excerpt: aString radius: 100</body><body package="Grease-Core">excerpt: aString radius: anInteger	"Answer an excerpt of the receiver that matches the first occurence of aString. The radius anInteger expands the excerpt on each side of the first occurrence by the number of characters defined in radius. If aString isn't found, nil is answered."		^ self excerpt: aString radius: anInteger ellipsis: '...'</body><body package="Grease-Core">excerpt: aString radius: anInteger ellipsis: anEllipsisString	"Answer an excerpt of the receiver that matches the first occurence of aString. The radius anInteger expands the excerpt on each side of the first occurrence by the number of characters defined in radius. If aString isn't found, nil is answered."	| index start stop |	(index := self indexOfSubCollection: aString) = 0		ifTrue: [ ^ nil ].	start := index - anInteger max: 1.	stop := index + anInteger + aString size - 1 min: self size.	^ (start &gt; 1 ifTrue: [ anEllipsisString ] ifFalse: [ '' ]) ,		(self copyFrom: start to: stop) ,	  	(stop &lt; self size ifTrue: [ anEllipsisString ] ifFalse: [ '' ])</body><body package="Grease-Core">greaseInteger	"Convert the receiver to an integer, answer nil if this is not a number."	| number stream negated char |	number := nil.	stream := self readStream.	negated := stream peek = $-.	negated ifTrue: [ stream next ].	[ stream atEnd not and: [ (char := stream next) isDigit ] ] whileTrue: [		number := (number isNil  ifTrue: [ 0 ]ifFalse: [ 10 * number ])			+ (char greaseInteger - $0 greaseInteger) ].	^ (number isNil or: [ negated not ]) 		ifFalse: [ number negated ]		ifTrue: [ number ]</body><body package="Grease-Core">pluralize	^ GRInflector pluralize: self</body><body package="Grease-Core">print: anObject on: aStream	aStream nextPutAll: self</body><body package="Grease-Core">truncate	"Truncate the receiver to 30 characters."		^ self truncate: 30</body><body package="Grease-Core">truncate: anInteger	"Truncate the receiver to anInteger characters."		^ self truncate: anInteger ellipsis: '...'</body><body package="Grease-Core">truncate: anInteger ellipsis: aString	"Truncate the receiver to anInteger characters and append aString as ellipsis if necessary."	^ anInteger &lt; self size		ifTrue: [ (self copyFrom: 1 to: anInteger) , aString ]		ifFalse: [ self copy ]</body></methods><methods><class-id>Core.Number</class-id> <category>*grease-core</category><body package="Grease-Core">greaseInteger	"Answer an integer of the receiver, in our case we simply truncate the number."	^ self truncated</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>*grease-core</category><body package="Grease-Core">print: anObject on: aStream</body></methods><methods><class-id>Core.Object</class-id> <category>*grease-core</category><body package="Grease-Core">greaseDeprecatedApi: apiString details: detailsString 	GRDeprecatedApiNotification new		details: detailsString;		signal: apiString</body></methods><methods><class-id>Core.Character</class-id> <category>*grease-core</category><body package="Grease-Core">print: anObject on: aStream	aStream nextPut: self</body></methods><initialize><class-id>Grease.GRInflector</class-id></initialize><initialize><class-id>Grease.GRNumberPrinter</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>