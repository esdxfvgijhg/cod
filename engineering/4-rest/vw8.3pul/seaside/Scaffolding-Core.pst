<?xml version="1.0"?><st-source><!-- Name: Scaffolding-CoreNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: Scaffolding-Core provides a set of reusable Create, Read, Update and Delete WAComponents for Seaside which reflect off of Glorps ActiveRecord.OverviewThis package provides a set of conventions and practices that can simplify and reduce the work involved in hooking up a Seaside WAComponent to a Glorp.ActiveRecord class for querying, searching, creating, updating and deleting records from the database.There are three classes provided for users of this package to subclass from:	GenericListUI -  provides a list page of records for the target active record class	GenericGridUI -  provides a grid page of records for the target active record class	GenericViewUI -  provides a view page of a single record for the target active record class	GenericEditUI -  provides an edit page for a single record for the target active record class.Some of the classes also provide alternate ways to view or interact with the information from the active record class, for example a JSON view or an ATOM view, so see each of the above classes for more details on how they work and how to customize them. UsageThe idea is to create a subclass of one or all of the GenericUI subclasses for each of your ActiveRecord subclasses, at least the ones you want to have UIs for. The naming of the subclass is used to identify which ActiveRecord you want to edit. For example, if we have a Person active record subclass, we can create subclasses PersonListUI, PersonViewUI and PersonEditUI from the generics, GenericListUI, GenericGridUI GenericViewUI and GenericEditUI. The names of the classes will match back to Person and the UIs will then customize themselves based on the descirptor system in use.ArchitectureThe different GenericUI subclasses will reflect off the active record classes mappings from the active descriptor system to produce a standard Create, Read, Update and Delete sort of application. Each mapping describes a field on the class that can be displayed to the user. Subclasses can override this list or reorder it.The mappings are used differently depending on the kind of subclass. For example, a list ui will use the mappings as the columns for the results that are found; the view will show a records mappings as a sort of report view; and the edit page will show the mappings as label-value with edit widgets to modify the page where the edit widget is a reflection of the mapping type and attribute type read from the database.DbIdentifier: bear73DbTrace: 492627DbUsername: jkottDbVersion: 3.2.0 - 1DevelopmentPrerequisites: #(#(#any 'Glorp' '') #(#any 'GlorpActiveRecord' '') #(#any 'Scaffolding-Namespace' '') #(#any 'Seaside-Core' '') #(#any 'Seaside-VisualWorks-Core' '') #(#any 'Seaside-Session' '') #(#any 'Seaside-Glorp' '') #(#any 'Seaside-Canvas' '') #(#any 'Seaside-Component' '') #(#any 'Grease-VisualWorks-Core' '') #(#any 'Seaside-Flow' '') #(#any 'Seaside-VisualWorks-Flow' '') #(#any 'Seaside-Tools-Core' '') #(#any 'Seaside-RenderLoop' '') #(#any 'Seaside-DynamicCompiler' '') #(#any 'Atom-Core' ''))ExplicitPrerequisites: #('SymbolValue' 'Seaside-DynamicCompiler')IgnoredPrerequisites: #()Library: truePackageName: Scaffolding-CoreParcel: #('Scaffolding-Core')PrerequisiteDescriptions: #(#(#name 'Glorp' #componentType #bundle) #(#name 'GlorpActiveRecord') #(#name 'Scaffolding-Namespace' #componentType #package) #(#name 'Seaside-Core' #componentType #package) #(#name 'Seaside-VisualWorks-Core' #componentType #package) #(#name 'Seaside-Session' #componentType #package) #(#name 'Seaside-Glorp') #(#name 'Seaside-Canvas' #componentType #package) #(#name 'Seaside-Component' #componentType #package) #(#name 'Grease-VisualWorks-Core' #componentType #package) #(#name 'Seaside-Flow' #componentType #package) #(#name 'Seaside-VisualWorks-Flow' #componentType #package) #(#name 'Seaside-Tools-Core' #componentType #package) #(#name 'Seaside-RenderLoop' #componentType #package) #(#name 'Seaside-DynamicCompiler' #componentType #package) #(#name 'Atom-Core' #componentType #package))PrerequisiteParcels: #(#('Glorp' '') #('GlorpActiveRecord' '') #('Scaffolding-Namespace' '') #('Seaside-Core' '') #('Seaside-VisualWorks-Core' '') #('Seaside-Session' '') #('Seaside-Glorp' '') #('Seaside-Canvas' '') #('Seaside-Component' '') #('Grease-VisualWorks-Core' '') #('Seaside-Flow' '') #('Seaside-VisualWorks-Flow' '') #('Seaside-Tools-Core' '') #('Seaside-RenderLoop' '') #('Seaside-DynamicCompiler' '') #('Atom-Core' ''))PrintStringCache: (3.2.0 - 1,jkott)Version: 3.2.0 - 1Date: 3:31:32 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:31:32 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>XmlRenderCanvas</name><environment>Scaffolding</environment><super>Seaside.WAXmlCanvas</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Scaffolding-Core</package></attributes></class><comment><class-id>Scaffolding.XmlRenderCanvas</class-id><body>XmlRenderCanvas is used to render XML documents.</body></comment><class><name>GenericUI</name><environment>Scaffolding</environment><super>Seaside.WAComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>renderFormat </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Scaffolding-Core</package></attributes></class><comment><class-id>Scaffolding.GenericUI</class-id><body>GenericUI is the abstract superclass of the subclassable GenericListUI, GenericViewUI and GenericEditUI.OverviewThis class provides common behavior between the three Generic*UI classes. It adds a new concept to Seaside, that of the renderFormat - for the subclasses need not actually render HTML as their final output for a request.This class also sets up the interaction to Glorp, configuring the installed class to use Seaside-Glorp for its database access.Instance Variables:	renderFormat	&lt;ByteSymbol&gt;	the format to render as the request, eg: #Html, #Json, #Xml, #Atom or #Unknown</body></comment><class><name>GenericCollectionUI</name><environment>Scaffolding</environment><super>Scaffolding.GenericUI</super><private>false</private><indexed-type>none</indexed-type><inst-vars>paginator </inst-vars><class-inst-vars>defaultPageSize </class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Scaffolding-Core</package></attributes></class><comment><class-id>Scaffolding.GenericCollectionUI</class-id><body>GenericCollectionUI provides a subclassable generic ActiveRecord list for Seaside.OverviewThis class hooks up to an active record subclass and provides a set of common behaviors for viewing a collection of records from the database. It is subclassed by GenericGridUI and GenericListUI which both display a collection of object: one as a grid, the other as a list. Instance Variables:	paginator Class Instance Variables:	defaultPageSize &lt;Number&gt; a default number of records per page</body></comment><class><name>GenericRenderHandler</name><environment>Scaffolding</environment><super>Seaside.WARequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Scaffolding-Core</package></attributes></class><comment><class-id>Scaffolding.GenericRenderHandler</class-id><body>GenericRenderHandler is used to handle rendering requests for scaffolding classes.</body></comment><class><name>XmlRenderHandler</name><environment>Scaffolding</environment><super>Scaffolding.GenericRenderHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Scaffolding-Core</package></attributes></class><comment><class-id>Scaffolding.XmlRenderHandler</class-id><body>XmlRenderHandler is used to handle XML requests for scaffolding classes.</body></comment><class><name>GenericEditUI</name><environment>Scaffolding</environment><super>Scaffolding.GenericUI</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object editors showActions errors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Scaffolding-Core</package></attributes></class><comment><class-id>Scaffolding.GenericEditUI</class-id><body>GenericEditUI provides a subclassable generic ActiveRecord edit view for Seaside.OverviewThis class hooks up to an active record subclass and provides a set of common behaviors for editing a record from the database or a new record yet to be inserted into the database. The component, by default, will use the mappings of the active record class to provide a list of labels and editors, with each row assigned to one of the mapped instance variables.The rendering functions of the class are customizable using a set of method patterns and conventions described below in the Usage section. There are also several editors that can be reused. The class also provides method patterns for checking validation rules before committing an object to the database.UsageThis class will match up to an ActiveRecord subclass based on name. The assumed pattern is this: if you have an active record class named Groceries, then you can make a subclass GroceriesEditUI from GenericEditUI and it will figure out how to match up automatically. If you do not wish to name your subclass using this pattern, you can override the method #objectClass and optionally #objectClassName on the class side of your subclass.You should implement an #initialize method on the class side to register the class an entry point in Seaside. The method should simply call the super method, eg:initialize	super initializeThis will pickup the default entry point mappings for GenericListUI that adds the following entry point patterns:	/&lt;name of application&gt;/&lt;name of active record class&gt;/new.html	/&lt;name of application&gt;/&lt;name of active record class&gt;/&lt;id of record&gt;/edit.htmlIf these entry points are not desireable, then implement the #initialize method in your own custom manner.The subclasses also pick up multiple ways to override the default html rendering. The default renderer includes CSS patterns that can be used to customize the look and feel as well.The first overridable method is the mappings that are used when displaying the results. To change which instance variables are shown, override the method #variableNames. You can also override this method if you wish to re-order the columns that are renderer. Alternatively, you can exclude variables based on their name by implementing a method using the following pattern:	shouldRender&lt;Variable name&gt;		^falseAn example of this in action would be:	shouldRenderBirthday		^falseYou can completely override the entire rendering mechanism of this subclass by implementing #renderHtmlContentOn: although that is a rather extreme case because you lose all the CSS, actions and regular rendering routines that you inherit.The next overridable method is the titles of each label, which come from the variable names and are pretty-printed in a "human readable" form from their instance variable form. Overriding this method will also remove the CSS styling that is automatically added, but that may be the point of the override. The pattern for overriding the label rendering is similar to overriding the shouldRender* behavior. The patterns are as follows:	renderLabel&lt;Variable name&gt;On: html	renderLabel&lt;Variable name&gt;For: id on: htmlAn example in action would be:	renderLabelFullnameFor: id on: html		html span class: #wacky; with: [self renderTextInputEditor: #fullname id: id on: html]It is worth noting that another way to override the labels for the page is to use internationalization. The generic rendering method uses message catalogs based on the variables name, so you can add a message catalog to change the label too - see the documentation on message catalogues for more information on how to do this.The last overridable method is the editor of each variable. By default the editor is matched from the type of the variable described in the database mappings. This information can come directly from the database column that the instance variable is mapped too, but may also be customized. One of the reasons you might want to customize this rendering is because the editor provided is inappropriate for your user interface. You can override this default rendering behavior by implementing one of the following method patterns:	renderEdit&lt;Variable name&gt;On: html	renderEdit&lt;Variable name&gt;: id on: htmlAn example of one of these patterns in action would be:	renderEditFullname: id on: html		html inputField			id: id;			on: #fullname of: objectThere are numerous provided editor messages that you can reuse that are used by the default mapping editor - they are for different data types and may be useful to you:	renderBooleanEditor: variableName id: id on: html	renderDateEditor: variableName id: id on: html	renderNumericEditor: variableName id: id on: html	renderObjectEditor: variableName type: dataType id: id on: html	renderObjectsEditor: variableName type: dataType id: id on: html	renderSelectEditor: variableName list: pickValues id: id on: html	renderTextAreaEditor: variableName id: id on: html	renderTextInputEditor: variableName id: id on: html	renderTimeEditor: variableName id: id on: html	renderTimeWithoutSecondsEditor: variableName id: id on: html	renderTimestampEditor: variableName id: id on: html	renderUploadEditor: variableName id: id on: htmlYou can also override the #title method in your subclasses to change the default page title for subclasses, although the title is also internationalized like the column titles.In each of the generic rendering methods, the variable name being rendered is used as the a CSS class inside a hierarchy of CSS classes; an example of a running hierarchy might look like this:	&lt;div class="action"&gt;...actions...&lt;/div&gt;	&lt;div class="details"&gt;		...more tags...		&lt;tr class="oddRow genderRow"&gt;			&lt;td class="labels genderLabel"&gt;				&lt;label&gt;...gender label...&lt;/label&gt;			&lt;/td&gt;			&lt;td class="values genderCell"&gt;				&lt;input value="...gender value..."&gt;&lt;/input&gt;			&lt;/td&gt;		&lt;/tr&gt;		&lt;tr class="evenRow firstNameRow"&gt;			&lt;td class="labels firstNameLabel"&gt;				&lt;label&gt;...firstName label...&lt;/label&gt;			&lt;/td&gt;			&lt;td class="values firstNameCell"&gt;				&lt;input value="...firstName value..."&gt;&lt;/input&gt;			&lt;/td&gt;		&lt;/tr&gt;		...more tags...This allows easy CSS overrides for each label or value based on the fine grain or coarse grain. For example, to make every label be bold, you could add the following method to your subclass:	label { font-weight: bold }If you wanted to narrow it down to a specific variable, you could implement a method like the following in your subclass:	label.gender { font-weight: bold }If you wanted to make sure it only affected view pages, you could prefix the CSS with the name of the class or GenericEditUI, eg:	.GenericEditUI label.gender { font-weight: bold }or	.PersonEditUI label.gender { font-weight: bold }You can also bring styling to the page from a WAFileLibrary subclass by implementing the method #updateRoot: in one of two ways. The first way you could override it is to pull in a specific piece of CSS from a WAFileLibrary subclass, eg:	updateRoot: anHtmlRoot		super updateRoot: anHtmlRoot.		anHtmlRoot stylesheet url: MyFileLibrary / #mySpecifiCssThe second way you could do it is to include the whole file library subclasses default selectors on to your page, eg:	updateRoot: anHtmlRoot		super updateRoot: anHtmlRoot.		MyFileLibrary default updateRoot: anHtmlRootWhen the action #save is called to save the object to the database, or approve the changes and return to the view that called us, validation rules are first executed to decide if the changes are valid. If they aren't valid, errors are reported to the user of the page and the save action is cancelled.By default the validation rules are reflected off of the database, eg: mandatory or data type validation. You can implement your own validation for a variable based on a message pattern, such as the following:	validate&lt;Variable name&gt;	validate&lt;Variable name&gt;: theValueThe method should setup an error in the errors collection if the validation of that variable has failed, otherwise it should do nothing, an example might be:	validateAge: theAge		theAge &gt;= 16 ifTrue: [^self].		errors at: #age put: 'You''re not old enough'.The standard errors use message catalogues to internationalize their display result and you should consider doing the same too to avoid extra work later if you decide to deliver your application in a different language.An overridden validation method will replace the default validations, so you may want to still do mandatoriness validation, in which case you can either write that code yourself or call one of the existing validation methods:	validateMapping: variableName	validateMandatory: variableName	validateDatatype: variableName type: dataTypeImplementationMethods on this class can either be written as Smalltalk code or as CSS code. The CSS will be gathered up as part of the #style method when rendering the page.LimitationsIt is not considered good style to inline styling on an individual WAComponent subclass unless that styling is critical to a specific layout required by the application. Generally, CSS should be put on a WAFileLibrary subclass or in an external file.Not all kinds of database types have editors and when they don't, the renderNoEditor:id:on: method is called which simply renders out the text "No editor available". In this circumstance, you must override the variables editor method to render your own custom editor.Instance Variables:	object	&lt;ActiveRecord&gt;	the object we're editing	showActions &lt;Boolean &gt; if false the action buttons won't be displayed.	editors &lt;OrderedCollection&gt;  editors of each variable	errors  &lt;Dictionary&gt;</body></comment><class><name>JsonRoot</name><environment>Scaffolding</environment><super>Seaside.WARoot</super><private>false</private><indexed-type>none</indexed-type><inst-vars>charSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Scaffolding-Core</package></attributes></class><comment><class-id>Scaffolding.JsonRoot</class-id><body>JsonRoot is a document root for JSON documents.</body></comment><class><name>GenericGridUI</name><environment>Scaffolding</environment><super>Scaffolding.GenericCollectionUI</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>numberOfColumns numberOfRows variableName </class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Scaffolding-Core</package></attributes></class><comment><class-id>Scaffolding.GenericGridUI</class-id><body>GenericGridUI provides a subclassable generic ActiveRecord list for Seaside.OverviewThis class hooks up to an active record subclass and provides a set of common behaviors for viewing a collection of records from the database in a grid (a table). The component, by default, will create a table of results, with each cell in the table displaying a specified attribute of the active record object.The rendering functions of the class are customizable using a set of method patterns and conventions described below in the Usage section. When a grid is displayed, it includes a dropdown list with the displayable vairable names for the class of objects the grid UI renders. By default, the grid shows the values of the first attribute on the list. By selecting another variable name, the user can change the values of that variable instead.UsageThis class will match up to an ActiveRecord subclass based on name. The assumed pattern is this: if you have an active record class named Groceries, then you can make a subclass GroceriesGridUI from GenericGridUI and it will figure out how to match up automatically. If you do not wish to name your subclass using this pattern, you can override the method #objectClass and optionally #objectClassName on the class side of your subclass.You should implement an #initialize method on the class side to register the class an entry point in Seaside. The method should simply call the super method, eg:initialize	super initializeThis will pickup the default entry point mappings for GenericGridUI that adds the following entry point patterns:	/&lt;name of application&gt;/&lt;name of active record class&gt;-grid.htmlIf these entry points are not desireable, then implement the #initialize method in your own custom manner.The subclasses also pick up multiple ways to override the default html rendering. The default renderer includes CSS patterns that can be used to customize the look and feel as well.The first overridable method is the mappings that are used when displaying the results. To change which instance variables are shown, override the method #variableNames. You can also override this method if you wish to re-order the columns that are renderer. Alternatively, you can exclude variables based on their name by implementing a method using the following pattern:	shouldRender&lt;Variable name&gt;		^falseAn example of this in action would be:	shouldRenderBirthday		^falseYou can completely override the entire rendering mechanism of this subclass by implementing #renderHtmlContentOn: although that is a rather extreme case because you lose all the CSS, actions and regular rendering routines that you inherit.You can also override the #title method in your subclasses to change the default page title for subclasses, although the title is also internationalized like the column titles.In each of the generic rendering methods, the variable name being rendered is used as a CSS class inside a hierarchy of CSS classes; an example of a running hierarchy might look like this:	&lt;div class="action"&gt;...actions...&lt;/div&gt;	&lt;div class="details"&gt;		...more tags...		&lt;tr class="gridRow oddRow"&gt;			&lt;td class="gridCell oddColumn gender"&gt;&lt;span&gt;...gender value...&lt;/span&gt;&lt;/td&gt;			&lt;td class="gridCell evenColumn gender"&gt;&lt;span&gt;...gender value...&lt;/span&gt;&lt;/td&gt;			...more tags...		&lt;/tr&gt;		&lt;tr class="gridRow evenRow"&gt;			&lt;td class="gridCell oddColumn gender"&gt;&lt;span&gt;...gender value...&lt;/span&gt;&lt;/td&gt;			&lt;td class="gridCell evenColumn gender"&gt;&lt;span&gt;...gender value...&lt;/span&gt;&lt;/td&gt;			...more tags...		&lt;/tr&gt;This allows easy CSS overrides for each cell in the grid for each variable name.You can also bring styling to the page from a WAFileLibrary subclass by implementing the method #updateRoot: in one of two ways. The first way you could override it is to pull in a specific piece of CSS from a WAFileLibrary subclass, eg:	updateRoot: anHtmlRoot		super updateRoot: anHtmlRoot.		anHtmlRoot stylesheet url: MyFileLibrary / #mySpecifiCssThe second way you could do it is to include the whole file library subclasses default selectors on to your page, eg:	updateRoot: anHtmlRoot		super updateRoot: anHtmlRoot.		MyFileLibrary default updateRoot: anHtmlRootImplementationMethods on this class can either be written as Smalltalk code or as CSS code. The CSS will be gathered up as part of the #style method when rendering the page.LimitationsIt is not considered good style to inline styling on an individual WAComponent subclass unless that styling is critical to a specific layout required by the application. Generally, CSS should be put on a WAFileLibrary subclass or in an external file.Class Instance Variables:	numberOfColumns	&lt;Integer&gt; number of columns to display	numberOfRows	&lt;Integer&gt; number of rows to display	variableName	&lt;Symbol&gt; object variable to display</body></comment><class><name>JsonSystemConfiguration</name><environment>Scaffolding</environment><super>Seaside.WASystemConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Scaffolding-Core</package></attributes></class><comment><class-id>Scaffolding.JsonSystemConfiguration</class-id><body>JsonSystemConfiguration configures instances of JsonRenderHandler.</body></comment><class><name>GenericViewUI</name><environment>Scaffolding</environment><super>Scaffolding.GenericUI</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Scaffolding-Core</package></attributes></class><comment><class-id>Scaffolding.GenericViewUI</class-id><body>GenericViewUI provides a subclassable generic ActiveRecord view for Seaside.OverviewThis class hooks up to an active record subclass and provides a set of common behaviors for viewing a record from the database. The component, by default, will use the mappings of the active record class to provide a list of labels and values, with each row assigned to one of the mapped instance variables.The class also provides a non-html output in the form of XML and Json.The rendering functions of the class are customizable using a set of method patterns and conventions described below in the Usage section.UsageThis class will match up to an ActiveRecord subclass based on name. The assumed pattern is this: if you have an active record class named Groceries, then you can make a subclass GroceriesViewUI from GenericViewUI and it will figure out how to match up automatically. If you do not wish to name your subclass using this pattern, you can override the method #objectClass and optionally #objectClassName on the class side of your subclass.You should implement an #initialize method on the class side to register the class an entry point in Seaside. The method should simply call the super method, eg:initialize	super initializeThis will pickup the default entry point mappings for GenericListUI that adds the following entry point patterns:	/&lt;name of application&gt;/&lt;name of active record class&gt;/&lt;id of record&gt;.html	/&lt;name of application&gt;/&lt;name of active record class&gt;/&lt;id of record&gt;.json	/&lt;name of application&gt;/&lt;name of active record class&gt;/&lt;id of record&gt;.xmlIf these entry points are not desireable, then implement the #initialize method in your own custom manner.The subclasses also pick up multiple ways to override the default html rendering. The default renderer includes CSS patterns that can be used to customize the look and feel as well.The first overridable method is the mappings that are used when displaying the results. To change which instance variables are shown, override the method #variableNames. You can also override this method if you wish to re-order the columns that are renderer. Alternatively, you can exclude variables based on their name by implementing a method using the following pattern:	shouldRender&lt;Variable name&gt;		^falseAn example of this in action would be:	shouldRenderBirthday		^falseYou can completely override the entire rendering mechanism of this subclass by implementing #renderHtmlContentOn: although that is a rather extreme case because you lose all the CSS, actions and regular rendering routines that you inherit.The next overridable method is the titles of each label, which come from the variable names and are pretty-printed in a "human readable" form from their instance variable form. Overriding this method will also remove the CSS styling that is automatically added, but that may be the point of the override. The pattern for overriding the label rendering is similar to overriding the shouldRender* behavior. The pattern is as follows:	renderLabel&lt;Variable name&gt;On: html		html text: 'My new label'An example in action would be:	renderLabelFullnameOn: html		html text: 'Persons full name:'It is worth noting that another way to override the labels for the page is to use internationalization. The generic rendering method uses message catalogs based on the variables name, so you can add a message catalog to change the label too - see the documentation on message catalogues for more information on how to do this.The last overridable method is the value of each variable. By default the value is printed as plain text, broken up to make any bits of text that look like a URL to become links and if the URL looks like a link to an image, to inline that image. If there are character-returns in the text, then new lines will be inserted in to the rendered output too. You can override this default rendering behavior by implementing a method with the following pattern:	renderObject&lt;Variable name&gt;: theValue on: htmlAn example of one of these patterns in action would be:	renderValueFullname: fullname on: html		html span class: #wacky; with: fullname reverseYou can also override the #title method in your subclasses to change the default page title for subclasses, although the title is also internationalized like the column titles.In each of the generic rendering methods, the variable name being rendered is used as the a CSS class inside a hierarchy of CSS classes; an example of a running hierarchy might look like this:	&lt;div class="action"&gt;...actions...&lt;/div&gt;	&lt;div class="details"&gt;		...more tags...		&lt;tr class="oddRow genderRow"&gt;			&lt;td class="labels genderLabel"&gt;				&lt;label&gt;...gender label...&lt;/label&gt;			&lt;/td&gt;			&lt;td class="values genderCell"&gt;				&lt;span&gt;...gender value...&lt;/span&gt;			&lt;/td&gt;		&lt;/tr&gt;		&lt;tr class="evenRow firstNameRow"&gt;			&lt;td class="labels firstNameLabel"&gt;				&lt;label&gt;...firstName label...&lt;/label&gt;			&lt;/td&gt;			&lt;td class="values firstNameCell"&gt;				&lt;span&gt;...firstName value...&lt;/span&gt;			&lt;/td&gt;		&lt;/tr&gt;			...more tags...This allows easy CSS overrides for each label or value based on the fine grain or coarse grain. For example, to make every label be bold, you could add the following method to your subclass:	label { font-weight: bold }If you wanted to narrow it down to a specific variable, you could implement a method like the following in your subclass:	label.gender { font-weight: bold }If you wanted to make sure it only affected view pages, you could prefix the CSS with the name of the class or GenericViewUI, eg:	.GenericViewUI label.gender { font-weight: bold }or	.PersonViewUI label.gender { font-weight: bold }You can also bring styling to the page from a WAFileLibrary subclass by implementing the method #updateRoot: in one of two ways. The first way you could override it is to pull in a specific piece of CSS from a WAFileLibrary subclass, eg:	updateRoot: anHtmlRoot		super updateRoot: anHtmlRoot.		anHtmlRoot stylesheet url: MyFileLibrary / #mySpecifiCssThe second way you could do it is to include the whole file library subclasses default selectors on to your page, eg:	updateRoot: anHtmlRoot		super updateRoot: anHtmlRoot.		MyFileLibrary default updateRoot: anHtmlRootImplementationMethods on this class can either be written as Smalltalk code or as CSS code. The CSS will be gathered up as part of the #style method when rendering the page.LimitationsIt is not considered good style to inline styling on an individual WAComponent subclass unless that styling is critical to a specific layout required by the application. Generally, CSS should be put on a WAFileLibrary subclass or in an external file.Instance Variables	object	&lt;ActiveRecord&gt;	the object we're viewing</body></comment><class><name>GenericListUI</name><environment>Scaffolding</environment><super>Scaffolding.GenericCollectionUI</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Scaffolding-Core</package></attributes></class><comment><class-id>Scaffolding.GenericListUI</class-id><body>GenericListUI provides a subclassable generic ActiveRecord list for Seaside.OverviewThis class hooks up to an active record subclass and provides a set of common behaviors for viewing a list of records from the database. The component, by default, will use the mappings of the active record class to provide a table of results, with each column assigned to one of the mapped instance variables.The class also provides a non-html output in the form of an Atom feed which points to each result to a matching GenericViewUI subclass for Html, XML and Json results.The rendering functions of the class are customizable using a set of method patterns and conventions described below in the Usage section.UsageThis class will match up to an ActiveRecord subclass based on name. The assumed pattern is this: if you have an active record class named Groceries, then you can make a subclass GroceriesListUI from GenericListUI and it will figure out how to match up automatically. If you do not wish to name your subclass using this pattern, you can override the method #objectClass and optionally #objectClassName on the class side of your subclass.You should implement an #initialize method on the class side to register the class an entry point in Seaside. The method should simply call the super method, eg:initialize	super initializeThis will pickup the default entry point mappings for GenericListUI that adds the following entry point patterns:	/&lt;name of application&gt;/&lt;name of active record class&gt;.html	/&lt;name of application&gt;/&lt;name of active record class&gt;.atomIf these entry points are not desireable, then implement the #initialize method in your own custom manner.The subclasses also pick up multiple ways to override the default html rendering. The default renderer includes CSS patterns that can be used to customize the look and feel as well.The first overridable method is the mappings that are used when displaying the results. To change which instance variables are shown, override the method #variableNames. You can also override this method if you wish to re-order the columns that are renderer. Alternatively, you can exclude variables based on their name by implementing a method using the following pattern:	shouldRender&lt;Variable name&gt;		^falseAn example of this in action would be:	shouldRenderBirthday		^falseYou can completely override the entire rendering mechanism of this subclass by implementing #renderHtmlContentOn: although that is a rather extreme case because you lose all the CSS, actions and regular rendering routines that you inherit.The next overridable method is the titles of each column, which come from the variable names and are pretty-printed in a "human readable" form from their instance variable form. Overriding this method will also remove the CSS styling that is automatically added, but that may be the point of the override. The pattern for overriding the header rendering is similar to overriding the shouldRender* behavior. The pattern is as follows:	renderHeading&lt;Variable name&gt;On: html		html text: 'My new heading'An example in action would be:	renderHeadingFullnameOn: html		html text: 'Persons full name'It is worth noting that another way to override the headings for the page is to use internationalization. The generic rendering method uses message catalogs based on the variables name, so you can add a message catalog to change the label too - see the documentation on message catalogues for more information on how to do this.The last overridable method is the contents of each cell, eg: each value for each record in each column. By default the value for each cell is sent #displayString and that is all unless it is the first column, in which case it will be transformed in to an anchor that links to the GenericViewUI that matches this class for the record in the row. You can override this default rendering behavior by implementing a method with one of the following patterns:	renderObject&lt;Variable name&gt;: theValue on: html	renderObject&lt;Variable name&gt;: theObject value: theValue on: html	renderObject&lt;Variable name&gt;: theValue index: theVariableIndex on: html	renderObject&lt;Variable name&gt;: theObject index: theVariableIndex value: theValue on: htmlAn example of one of these patterns in action would be:	renderObjectGender: gender on: html		html span title: 'The gender of the person'; with: genderYou can also override the #title method in your subclasses to change the default page title for subclasses, although the title is also internationalized like the column titles.In each of the generic rendering methods, the variable name being rendered is used as a CSS class inside a hierarchy of CSS classes; an example of a running hierarchy might look like this:	&lt;div class="action"&gt;...actions...&lt;/div&gt;	&lt;div class="details"&gt;		...more tags...		&lt;th class="oddColumn gender"&gt;&lt;span&gt;...gender heading...&lt;/span&gt;&lt;/th&gt;		&lt;th class="evenColumn firstName"&gt;&lt;span&gt;="firstName"&gt;...firstName heading...&lt;/span&gt;&lt;/th&gt;		...more tags...		&lt;tr class="oddRow"&gt;			&lt;td class="oddColumn gender&gt;&lt;span&gt;...gender value...&lt;/span&gt;&lt;/td&gt;			&lt;td class="evenColumn firstName&gt;&lt;span&gt;...firstName value...&lt;/span&gt;&lt;/td&gt;			... more tags...		&lt;/tr&gt;		&lt;tr class="evenRow"&gt;			&lt;td class="oddColumn gender&gt;&lt;span&gt;...gender value...&lt;/span&gt;&lt;/td&gt;			&lt;td class="evenColumn firstName&gt;&lt;span&gt;...firstName value...&lt;/span&gt;&lt;/td&gt;			... more tags...		&lt;/tr&gt;This allows easy CSS overrides for each column, row, cell or heading based on the fine grain or coarse grain. For example, to make every heading be bold, you could add the following method to your subclass:	th { font-weight: bold }If you wanted to narrow it down to a specific column, you could implement a #style method with a style like the following in your subclass:	td .gender { font-weight: bold }You can also bring styling to the page from a WAFileLibrary subclass by implementing the method #updateRoot: in one of two ways. The first way you could override it is to pull in a specific piece of CSS from a WAFileLibrary subclass, eg:	updateRoot: anHtmlRoot		super updateRoot: anHtmlRoot.		anHtmlRoot stylesheet url: MyFileLibrary / #mySpecifiCssThe second way you could do it is to include the whole file library subclasses default selectors on to your page, eg:	updateRoot: anHtmlRoot		super updateRoot: anHtmlRoot.		MyFileLibrary default updateRoot: anHtmlRootImplementationMethods on this class can either be written as Smalltalk code or as CSS code. The CSS will be gathered up as part of the #style method when rendering the page.LimitationsIt is not considered good style to inline styling on an individual WAComponent subclass unless that styling is critical to a specific layout required by the application. Generally, CSS should be put on a WAFileLibrary subclass or in an external file.</body></comment><class><name>XmlSystemConfiguration</name><environment>Scaffolding</environment><super>Seaside.WASystemConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Scaffolding-Core</package></attributes></class><class><name>JsonRenderHandler</name><environment>Scaffolding</environment><super>Scaffolding.GenericRenderHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Scaffolding-Core</package></attributes></class><comment><class-id>Scaffolding.JsonRenderHandler</class-id><body>JsonRenderHandler is used to handle JSON requests for scaffolding classes.</body></comment><class><name>PatternDispatcher</name><environment>Scaffolding</environment><super>Seaside.WADispatcher</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Scaffolding-Core</package></attributes></class><comment><class-id>Scaffolding.PatternDispatcher</class-id><body>PatternDispatcher is a specializer Seaside Dispatcher that matches URLs that are defined with a * in them, to allow for pluggable url parameters in part of the path.UsageWADispatcher current register: (PatternDispatcher named: '*')</body></comment><class><name>JsonRenderCanvas</name><environment>Scaffolding</environment><super>Seaside.WAXmlCanvas</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Scaffolding-Core</package></attributes></class><comment><class-id>Scaffolding.JsonRenderCanvas</class-id><body>JsonRenderCanvas is used to render JSON documents.</body></comment><class><name>AtomRenderHandler</name><environment>Scaffolding</environment><super>Scaffolding.GenericRenderHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Scaffolding-Core</package></attributes></class><comment><class-id>Scaffolding.AtomRenderHandler</class-id><body>AtomRenderHandler is similar to that of Atom.AtomRenderHandler, except that it uses Scaffolding.AtomSystemConfiguration which uses a different collection rootComponents in its configuration (and one that works, too).</body></comment><class><name>AtomSystemConfiguration</name><environment>Scaffolding</environment><super>Atom.AtomSystemConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Scaffolding-Core</package></attributes></class><comment><class-id>Scaffolding.AtomSystemConfiguration</class-id><body>AtomSystemConfiguration overrides the superclass to return different set of possible root classes.</body></comment><methods><class-id>Scaffolding.GenericUI</class-id> <category>performing</category><body package="Scaffolding-Core">perform: selector ifMessageNotUnderstood: aBlock	^(self respondsTo: selector)		ifTrue:	[self perform: selector]		ifFalse:	[aBlock value]</body><body package="Scaffolding-Core">perform: selector with: object1 ifMessageNotUnderstood: aBlock	^(self respondsTo: selector)		ifTrue:	[self perform: selector with: object1]		ifFalse:	[aBlock value]</body><body package="Scaffolding-Core">perform: selector with: object1 with: object2 ifMessageNotUnderstood: aBlock	^(self respondsTo: selector)		ifTrue:	[self perform: selector with: object1 with: object2]		ifFalse:	[aBlock value]</body><body package="Scaffolding-Core">perform: selector with: object1 with: object2 with: object3 ifMessageNotUnderstood: aBlock	^(self respondsTo: selector)		ifTrue:	[self perform: selector with: object1 with: object2 with: object3]		ifFalse:	[aBlock value]</body><body package="Scaffolding-Core">perform: selector with: object1 with: object2 with: object3 with: object4 ifMessageNotUnderstood: aBlock	^(self respondsTo: selector)		ifTrue:	[self perform: selector withArguments: (Array with: object1 with: object2 with: object3 with: object4)]		ifFalse:	[aBlock value]</body></methods><methods><class-id>Scaffolding.GenericUI</class-id> <category>updating</category><body package="Scaffolding-Core">ensureTableExists	self isValid ifFalse: [self error: 'Missing table for ', self objectClassName].</body><body package="Scaffolding-Core">notFound	" The rendering format does not match any we know how to render, so display the NotFound page. "	self requestContext responseGenerator notFound; respond</body><body package="Scaffolding-Core">updateRoot: anHtmlRoot	" Update the root of the page, but if we have an unknown render method, show them the NotFound page. "	| style |	super updateRoot: anHtmlRoot.	style := self aggregatePragmas: #css.	style isNotEmpty ifTrue: [anHtmlRoot addStyle: style].	(self respondsTo: self renderFormatMethod) ifFalse: [^self notFound].	anHtmlRoot title: self title.</body></methods><methods><class-id>Scaffolding.GenericUI</class-id> <category>accessing</category><body package="Scaffolding-Core">objectClass	" Return the ActiveRecord subclass that we're going to act on. By default, assume it's in our own namespace and we're named after it. "	^self class objectClass</body><body package="Scaffolding-Core">objectClassName	" Return the name of the ActiveRecord subclass we're acting on. "	^self class objectClassName</body><body package="Scaffolding-Core">objectEditClass	" Return the class that would act as the editing view for our object. "	| objectClass |	objectClass := self objectClass.	^GenericEditUI allSubclasses detect: [:e | e objectClass = objectClass]</body><body package="Scaffolding-Core">objectViewClass	" Return the class that would act as the readonly view for our object. "	| objectClass |	objectClass := self objectClass.	^GenericViewUI allSubclasses detect: [:e | e objectClass = objectClass]</body><body package="Scaffolding-Core">renderFormatMethod	" Return the render method to use for our current renderFormat. "	renderFormat ifNil: [^#renderHtmlContentOn:].	^('render', renderFormat, 'ContentOn:') asSymbol</body><body package="Scaffolding-Core">rendererClass	renderFormat ifNil: [ ^ super rendererClass ].	^ self rendererClassMap at: renderFormat ifAbsent: [ super rendererClass ]</body><body package="Scaffolding-Core">rendererClassMap	^ Dictionary new		at: 'Atom' put: AtomRenderCanvas;		at: 'Xml' put: XmlRenderCanvas;		at: 'Json' put: JsonRenderCanvas;		yourself</body><body package="Scaffolding-Core">title	" Return the title of our page. "	^self subclassResponsibility</body><body package="Scaffolding-Core">variableNames	" Return the variables to use in this subclass. By default use all from our ActiveRecord class that are mapped, but filter them with shouldRender* methods. "	^self objectClass variableNames select: [:each |		self perform: ('shouldRender', each copyAsCapitalized) asSymbol ifMessageNotUnderstood: [true]]</body></methods><methods><class-id>Scaffolding.GenericUI</class-id> <category>rendering html</category><body package="Scaffolding-Core">renderActionsOn: html	" Render the actions for our object(s). "	self subclassResponsibility</body><body package="Scaffolding-Core">renderDetailsOn: html	" Render the details of our object(s). "	self subclassResponsibility</body><body package="Scaffolding-Core">renderHtmlContentOn: html	" Render the HTML version of our class. "	html div		class: #pageContainer;		class: self class viewClassName, ' ', self class name, ' ', self class objectClassName;		with: [			html div				class: #pageHeader;				with: [ self renderPageHeaderOn: html ].			html div				class: #pageContent;				with: [ self renderPageContentOn: html ].			html div				class: #pageSideBar;				with: [ self renderPageSideBarOn: html ].			html div				class: #pageFooter;				with: [ self renderPageFooterOn: html ] ]</body><body package="Scaffolding-Core">renderPageContentOn: html	" Render the HTML version of our class. "	html form		id: 'form';		multipart;		with:			[html div class: #actions; with: [self renderActionsOn: html].			html div class: #details; with: [self renderDetailsOn: html]]</body><body package="Scaffolding-Core">renderPageFooterOn: html	" Render page footer on html "	| year |	year := Date today year printString.	html		span: 'Generated by WebVelocity';		html: '&amp;reg;';		span: ', copyright ';		html: '&amp;copy;';		span: year, ' Cincom Systems, Inc.'</body><body package="Scaffolding-Core">renderPageHeaderOn: html	" Render page header on html. Subclasses may override to render nothing. "	html heading		level: 3;		with: self title</body><body package="Scaffolding-Core">renderPageSideBarOn: html	" Render page side bar on html "</body><body package="Scaffolding-Core">renderUnknownContentOn: html	^ self renderHtmlContentOn: html</body></methods><methods><class-id>Scaffolding.GenericUI</class-id> <category>request processing</category><body package="Scaffolding-Core">initialRequest: aRequest	" From the request, figure out what kind of rendering format we're going to respond with, eg: Html, Json, Xml, Atom, etc... "	super initialRequest: aRequest.	self setRenderFormatFrom:  aRequest.</body><body package="Scaffolding-Core">setRenderFormatFrom:  aRequest	" From the request, figure out what kind of rendering format we're going to respond with, eg: Html, Json, Xml, Atom, etc... "	| extension |	extension := aRequest url path last copyFileExtension.	extension ifNil: [^renderFormat := #Unknown].	extension isEmpty ifTrue: [^renderFormat := #Unknown].	renderFormat := extension asLowercase copyAsCapitalized</body></methods><methods><class-id>Scaffolding.GenericUI</class-id> <category>private</category><body package="Scaffolding-Core">columnClassFor: index	^ index even ifTrue: [ #evenColumn ] ifFalse: [ #oddColumn ]</body><body package="Scaffolding-Core">rowClassFor: index	^ index even ifTrue: [ #evenRow ] ifFalse: [ #oddRow ]</body></methods><methods><class-id>Scaffolding.GenericUI</class-id> <category>rendering</category><body package="Scaffolding-Core">glorpSession		^ self session glorpSession		ifNil: [ self error: 'The database does not appear to be correctly configured. Please verify your database setup and try again.']		ifNotNil: [ :glorpSession | [ glorpSession login ] on: Error do: [ :ex | ex pass ]. glorpSession ].</body><body package="Scaffolding-Core">renderContentOn: html	" Render our content, but switch the rendering mode based on the renderFormat. If the renderFormat is not set, try to set it. "	[self  glorpSession ]		on: Error		do: [ :ex | 			^ html heading				level: 3;				style: 'color: red';				with: ( 'Database login error: &lt;1s&gt;' expandMacrosWith:  ex errorString) ].	self ensureTableExists.	self perform: self renderFormatMethod with: html</body></methods><methods><class-id>Scaffolding.GenericUI</class-id> <category>testing</category><body package="Scaffolding-Core">isValid	" Return whether the object class we're working with is going to work with the currently connected database. "	| descriptor table |	descriptor := self session glorpSession descriptorFor: self objectClass.	table := descriptor table ifNil: [^false].	^table schema notEmpty or: [ table platform supportsSchemas not ]</body></methods><methods><class-id>Scaffolding.GenericUI class</class-id> <category>accessing</category><body package="Scaffolding-Core">objectClass	" Return the ActiveRecord subclass that we're going to act on. By default, assume it's in our own namespace and we're named after it. "	^self environment at: self objectClassName asSymbol ifAbsent:		[self error: self name, ' attempted to use the class ', self objectClassName, ' which does not exist']</body><body package="Scaffolding-Core">objectClassName	" Return the name of the ActiveRecord subclass we're acting on. "	^self subclassResponsibility</body><body package="Scaffolding-Core">objectName	" Return the humanized name of the objects we're working on. "	| objectName |	objectName := Glorp.Inflector new pluralize: self objectClassName.	objectName at: 1 put: objectName first asLowercase.	^objectName</body><body package="Scaffolding-Core">viewClassName	" Return the name of the generic subclass that we're based off of. "	^self subclassResponsibility</body></methods><methods><class-id>Scaffolding.GenericUI class</class-id> <category>binary storage</category><body package="Scaffolding-Core">postLoad: packageOrParcel	" I know each of my concrete subclasses needs to be initialized.	Some scaffolding classes implement #initialize method. It should be called as part of postLoad."	self initialize</body></methods><methods><class-id>Scaffolding.GenericUI class</class-id> <category>testing</category><body package="Scaffolding-Core">canBeRoot	^ self isAbstractUIClass not</body></methods><methods><class-id>Scaffolding.GenericCollectionUI</class-id> <category>actions</category><body package="Scaffolding-Core">createObject	" Workflow: Create a new object and redirect the user to the edit page for that object. When its done, if it was saved, record it and commit to the database. "	| object |	object := self newObject.	object bePersistent.	(self call: (self objectEditClass on: object)) ifFalse: [^object rollbackUnitOfWork].	object commitUnitOfWork</body><body package="Scaffolding-Core">gotoPage: pageIndex	self paginator pageIndex: pageIndex.</body><body package="Scaffolding-Core">newObject	" Return a new instance of our objectClass. "	^self objectClass new</body><body package="Scaffolding-Core">viewObject: object	" Workflow: Call the readonly view for our object. "	self call: (self objectViewClass on: object)</body></methods><methods><class-id>Scaffolding.GenericCollectionUI</class-id> <category>rendering html</category><body package="Scaffolding-Core">firstPageLabel	^ '&lt;&lt;'.</body><body package="Scaffolding-Core">lastPageLabel	^ '&gt;&gt;'.</body><body package="Scaffolding-Core">nextPageLabel	^ '&gt;'</body><body package="Scaffolding-Core">previousPageLabel	^ '&lt;'.</body><body package="Scaffolding-Core">renderActionsOn: html	html button		class: #new;		callback: [self createObject];		with: 'New'</body><body package="Scaffolding-Core">renderDetailsOn: html	" Render the details for our objects. By default, create a table of results. "	html table		style: 'width: 100%';		cellpadding: 0; cellspacing: 0;		with: [			self				renderTableHeaderOn: html;				renderTableBodyOn: html ]</body><body package="Scaffolding-Core">renderGotoFirstPageOn: html		html anchor			class: #firstPage;			callback: [ self gotoPage: 1 ];			with: self firstPageLabel</body><body package="Scaffolding-Core">renderGotoLastPageOn: html		html anchor			class: #lastPage;			callback: [ self gotoPage: self paginator pageCount ];			with: self lastPageLabel</body><body package="Scaffolding-Core">renderGotoNextPageOn: html		html anchor			class: #nextPage;			callback: [ self gotoPage: self paginator pageIndex + 1 ];			with: self nextPageLabel</body><body package="Scaffolding-Core">renderGotoPage: pageIndex on: html	html anchor		class: #gotoPage;		callback: [ self gotoPage: pageIndex ];		with: pageIndex printString</body><body package="Scaffolding-Core">renderGotoPreviousPageOn: html		html anchor			class: #previousPage;			callback: [ self gotoPage: self paginator pageIndex - 1 ];			with: self previousPageLabel</body><body package="Scaffolding-Core">renderHeading: variableName on: html	" Render one of the headings for a column. "	| inflector |	inflector := Glorp.Inflector new.	self		perform: ('renderHeading', variableName copyAsCapitalized, 'On:') asSymbol		with: html		ifMessageNotUnderstood:			[html span				with: (variableName asSymbol &lt;&lt; self class environment name  &gt;&gt; (inflector humanize: (inflector underscore: variableName))) asString ]</body><body package="Scaffolding-Core">renderHeadingsOn: html	" Render the headings for each column. "	html tableRow with:		[self variableNames keysAndValuesDo: [ :index :variableName  |			html tableHeading				class: (self columnClassFor: index);				class: variableName;				with: [self renderHeading: variableName on: html]]]</body><body package="Scaffolding-Core">renderObject: object index: rowIndex on: html	" Render an object as a row in the table. "	html tableRow		class: (self rowClassFor: rowIndex);		with: [			self variableNames keysAndValuesDo: [:variableIndex :variableName |				| value |				value := object instVarNamed: variableName.				html tableData					class: (self columnClassFor: variableIndex);					class: variableName;					with: [self renderObject: object variable: variableName index: variableIndex value: value on: html]]]</body><body package="Scaffolding-Core">renderObject: object variable: variableName index: variableIndex value: value on: html	" Render an object in to one of the row cells. "	self		perform: ('renderObject', variableName copyAsCapitalized, ':on:') asSymbol		with: value with: html		ifMessageNotUnderstood:	[self		perform: ('renderObject', variableName copyAsCapitalized, ':value:on:') asSymbol		with: object with: value with: html		ifMessageNotUnderstood:	[self		perform: ('renderObject', variableName copyAsCapitalized, ':index:on:') asSymbol		with: value with: variableIndex with: html		ifMessageNotUnderstood:	[self		perform: ('renderObject', variableName copyAsCapitalized, ':index:value:on:') asSymbol		with: object with: variableIndex with: value with: html		ifMessageNotUnderstood:	[variableIndex = 1		ifTrue:			[html anchor				callback: [self viewObject: object];				withOverflowSafeText: value displayString]		ifFalse:			[html span withOverflowSafeText: value displayString]]]]]</body><body package="Scaffolding-Core">renderObjectsOn: html	" Render all the object results to the table. "	self objects		keysAndValuesDo: [:rowIndex :object | self renderObject: object index: rowIndex on: html]</body><body package="Scaffolding-Core">renderPageContentOn: html	" Render the HTML version of our class. "	html form		id: 'form';		multipart;		with:			[html div class: #actions; with: [self renderActionsOn: html].			html div class: #details; with: [self renderDetailsOn: html].			html div class: #pages; with: [self renderPageNavigationOn: html]]</body><body package="Scaffolding-Core">renderPageNavigationOn: html	| pageCount pageIndex |	(pageCount := self paginator pageCount) = 1 ifTrue: [^nil ].	pageIndex := self paginator pageIndex.	pageIndex &gt; 1 ifTrue: [ self		renderGotoFirstPageOn: html;		renderGotoPreviousPageOn: html ].		(1 max: pageIndex - 5) to: ((1 min: pageIndex + 5) max: pageCount) do: [ :index |		index = pageIndex			ifTrue: [				html span					class: #currentPage;					with: index printString ]			ifFalse: [ self renderGotoPage: index on: html ] ].	pageIndex &lt; pageCount ifTrue: [ self		renderGotoNextPageOn: html;		renderGotoLastPageOn: html ]</body><body package="Scaffolding-Core">renderTableBodyOn: html	html tableBody with: [self renderObjectsOn: html]</body><body package="Scaffolding-Core">renderTableHeaderOn: html	" Render a table header on html. "	html tableHead with: [self renderHeadingsOn: html].</body></methods><methods><class-id>Scaffolding.GenericCollectionUI</class-id> <category>accessing</category><body package="Scaffolding-Core">objects	" Return all the objects for our objectClass. "	^self paginator objects</body><body package="Scaffolding-Core">pageSize	^self class defaultPageSize</body><body package="Scaffolding-Core">pageSize: anObject	self class defaultPageSize: anObject</body><body package="Scaffolding-Core">paginator	^paginator</body></methods><methods><class-id>Scaffolding.GenericCollectionUI</class-id> <category>initialize-release</category><body package="Scaffolding-Core">initialize	super initialize.	self initializePaginator</body><body package="Scaffolding-Core">initializePaginator	paginator := self paginatorClass for: self objectClass session: self session databaseSession.	paginator pageSize: self pageSize</body><body package="Scaffolding-Core">paginatorClass	^Glorp.ActiveRecords.ActiveRecordPaginator</body></methods><methods><class-id>Scaffolding.GenericCollectionUI class</class-id> <category>accessing</category><body package="Scaffolding-Core">defaultPageSize	^defaultPageSize ifNil: [defaultPageSize := self defaultPageSizeValue]</body><body package="Scaffolding-Core">defaultPageSize: aNumber	defaultPageSize := aNumber</body><body package="Scaffolding-Core">defaultPageSizeValue	^10</body><body package="Scaffolding-Core">objectClassName	('*', self viewClassNameSuffix match: self name) ifFalse: [^self name].	^self name allButLast: self viewClassNameSuffix size</body><body package="Scaffolding-Core">viewClassName	^'Generic', self viewClassNameSuffix</body><body package="Scaffolding-Core">viewClassNameSuffix	^ self subclassResponsibility</body></methods><methods><class-id>Scaffolding.GenericRenderHandler</class-id> <category>private</category><body package="Scaffolding-Core">createDocumentRoot	^ self documentRootClass new		charSet: self charSet;		yourself</body><body package="Scaffolding-Core">mimeType	" Don't forget to override. "	^ WAMimeType main: 'application' sub: 'xml'</body><body package="Scaffolding-Core">renderCanvasClass	^ self subclassResponsibility</body><body package="Scaffolding-Core">setContentType: aResponse	aResponse contentType: (self mimeType charset: self charSet)</body></methods><methods><class-id>Scaffolding.GenericRenderHandler</class-id> <category>configuration</category><body package="Scaffolding-Core">charSet	^ self preferenceAt: #charSet</body><body package="Scaffolding-Core">defaultConfiguration	^ super defaultConfiguration		addParent: self systemConfigurationClass instance;		yourself</body><body package="Scaffolding-Core">systemConfigurationClass	^ self subclassResponsibility</body></methods><methods><class-id>Scaffolding.GenericRenderHandler</class-id> <category>accessing</category><body package="Scaffolding-Core">documentRootClass	^ self preferenceAt: #documentRootClass</body><body package="Scaffolding-Core">documentRootClass: aClass	^ self preferenceAt: #documentRootClass put: aClass</body><body package="Scaffolding-Core">rootClass	^ self preferenceAt: #rootComponentClass</body></methods><methods><class-id>Scaffolding.GenericRenderHandler</class-id> <category>initialization</category><body package="Scaffolding-Core">clear</body><body package="Scaffolding-Core">initialize	super initialize.	self addFilter: WAExceptionFilter new</body></methods><methods><class-id>Scaffolding.GenericRenderHandler</class-id> <category>handling</category><body package="Scaffolding-Core">handleFiltered: aRequestContext	aRequestContext		push: self sessionClass new		while: [ self handleInSession: aRequestContext ]</body><body package="Scaffolding-Core">handleInSession: aRequestContext	| document context canvas root rootComponent |	self setContentType: aRequestContext response.	document := aRequestContext newDocument.	root := self createDocumentRoot.	document open: root.	context := WARenderContext new document: document.		[	canvas := self renderCanvasClass context: context.	WACurrentRequestContext use: aRequestContext during: [		rootComponent := self rootClass new.		(WAInitialRequestVisitor request: aRequestContext request) start: rootComponent.		canvas render: rootComponent ].	document close	] ensure: [context destroy].	aRequestContext respond</body><body package="Scaffolding-Core">sessionClass	" Answer the session class I am using. Ideally, this should be settable through a system configuration, but a hard-coded value for generic scaffolding render handlers should suffice. "	^ WASession</body></methods><methods><class-id>Scaffolding.GenericRenderHandler</class-id> <category>*seaside-session</category><body package="Scaffolding-Core">isApplication	" My subclasses are light-weight applications. Answer true. "	^ true</body></methods><methods><class-id>Scaffolding.XmlRenderHandler</class-id> <category>private</category><body package="Scaffolding-Core">mimeType	^WAMimeType main: 'application' sub: 'xml'</body><body package="Scaffolding-Core">renderCanvasClass	^ XmlRenderCanvas</body></methods><methods><class-id>Scaffolding.XmlRenderHandler</class-id> <category>configuration</category><body package="Scaffolding-Core">systemConfigurationClass	^ XmlSystemConfiguration</body></methods><methods><class-id>Scaffolding.XmlRenderHandler class</class-id> <category>accessing</category><body package="Scaffolding-Core">description	^'XML document'</body></methods><methods><class-id>Scaffolding.GenericEditUI</class-id> <category>accessing</category><body package="Scaffolding-Core">children	" We may be adding editors to the page that are complex WAComponents instead of straight tags, so we can use the @editors variable to store those for the callbacks. "	^editors</body><body package="Scaffolding-Core">mappingFor: variableName	" Return the database mapping object for a variableName. "	^object descriptor mappingForAttributeNamed: variableName asSymbol</body><body package="Scaffolding-Core">object	^object</body><body package="Scaffolding-Core">object: anObject	object := anObject</body></methods><methods><class-id>Scaffolding.GenericEditUI</class-id> <category>initialize-release</category><body package="Scaffolding-Core">initialize	super initialize.	errors := Dictionary new.	showActions := true.	editors := OrderedCollection new</body></methods><methods><class-id>Scaffolding.GenericEditUI</class-id> <category>rendering html editors</category><body package="Scaffolding-Core">renderBooleanEditor: variableName id: id on: html	" Render a Boolean editor. "	html checkbox		id: id;		class: variableName;		callback: [:value | object instVarNamed: variableName put: value];		value: (object instVarNamed: variableName)</body><body package="Scaffolding-Core">renderDateEditor: variableName id: id on: html	" Render a date editor. "	html div		class: variableName;		class: #dateInput;		with:			[html dateInput				id: id;				callback: [:value | object instVarNamed: variableName put: value];				value: (object instVarNamed: variableName)]</body><body package="Scaffolding-Core">renderNoEditor: variableName id: id on: html	" Warn the developer that we could not identify a matching editor for the field. "	html span		class: variableName;		with: variableName, ' -- no editor'</body><body package="Scaffolding-Core">renderNumericEditor: variableName id: id on: html	" Render a numerical editor. "	html textInput		class: variableName;		callback: [:value |			| stream |			stream := value readStream.			stream skipSeparators.			" Make sure we've got something that looks like a number, otherwise set it to nil so that validation rules can handle the failure later "			('-0123456789' includes: stream next)				ifTrue:	[object instVarNamed: variableName put: value asNumber]				ifFalse:	[object instVarNamed: variableName put: nil]];		value: (object instVarNamed: variableName)</body><body package="Scaffolding-Core">renderObjectEditor: variableName type: type id: id on: html	" Render an object editor by finding the types editClass and then dropping it inside us as a reusable component. "	| value editor |	value := (object instVarNamed: variableName) ifNil: [object instVarNamed: variableName put: type new].	editor := (GenericEditUI editorClassFor: type) on: value.	editor hideActions.	editors add: editor.	html div		class: variableName;		with: editor</body><body package="Scaffolding-Core">renderObjectsEditor: variableName type: type id: id on: html	" Render an objects editor by listing out the current objects and providing the ability to hook up to an existing object. For editing new objects inline, make the mapping exclusive. "	| values |	values := (object instVarNamed: variableName) ifNil: [#()].	html div		class: variableName;		with:			[html div class: #addValue; with: [html button				class: #add;				callback: [self addNewRelationship: variableName type: type];				with: 'Add'].			values do: [:each |				html div class: #showValue; with:					[html button						class: #edit;						callback: [self editRelationship: variableName value: each];						with: 'Edit'.					html space.					html button						class: #remove;						callback: [self removeRelationship: variableName value: each];						with: 'Remove'.					html space.					html text: each displayString]]]</body><body package="Scaffolding-Core">renderSelectEditor: variableName list: list id: id on: html	" Render a selection editor for a @list of objects. "	html select		id: id;		list: list;		class: variableName;		callback: [:value | object instVarNamed: variableName put: value];		selected: (object instVarNamed: variableName)</body><body package="Scaffolding-Core">renderTextAreaEditor: variableName id: id maxLength: maxLength on: html	" Render a text editor. "	html textArea		id: id;		class: variableName;		attributeAt: 'maxlength' put: maxLength;		callback: [:value | object instVarNamed: variableName put: value];		value: (object instVarNamed: variableName)</body><body package="Scaffolding-Core">renderTextAreaEditor: variableName id: id on: html	" Render a text editor. "	html textArea		id: id;		class: variableName;		callback: [:value | object instVarNamed: variableName put: value];		value: (object instVarNamed: variableName)</body><body package="Scaffolding-Core">renderTextInputEditor: variableName id: id maxLength: maxLength on: html	" Render a string editor. "	html textInput		id: id;		class: variableName;		maxLength: maxLength;		callback: [:value | object instVarNamed: variableName put: value];		value: (object instVarNamed: variableName)</body><body package="Scaffolding-Core">renderTextInputEditor: variableName id: id on: html	" Render a string editor. "	html textInput		id: id;		class: variableName;		callback: [:value | object instVarNamed: variableName put: value];		value: (object instVarNamed: variableName)</body><body package="Scaffolding-Core">renderTimeEditor: variableName id: id on: html	" Render a time editor. "	html div		class: variableName;		class: #timeInput;		with:					[html timeInput				id: id;				withSeconds;				callback: [:value | object instVarNamed: variableName put: value];				value: (object instVarNamed: variableName)]</body><body package="Scaffolding-Core">renderTimeWithoutSecondsEditor: variableName id: id on: html	" Render a time editor without the seconds field. "	html timeInput		id: id;		class: variableName;		callback: [:value | object instVarNamed: variableName put: value];		value: (object instVarNamed: variableName)</body><body package="Scaffolding-Core">renderTimestampEditor: variableName id: id on: html	" Render a timestamp editor. "	html div		class: variableName;		class: #dateTimeInput;		with:			[html dateInput				id: id;				callback: [:value |					(object instVarNamed: variableName) ifNil: [object instVarNamed: variableName put: Timestamp now].					(object instVarNamed: variableName) year: value year; monthIndex: value monthIndex; day: value dayOfMonth];				value: ((object instVarNamed: variableName) ifNotNil: [:timestamp | timestamp asDate]).			html space.			html timeInput				id: id;				withSeconds;				callback: [:value |					(object instVarNamed: variableName) ifNil: [object instVarNamed: variableName put: Timestamp now].					(object instVarNamed: variableName) hour: value hours; minute: value minutes; second: value seconds];				value: ((object instVarNamed: variableName) ifNotNil: [:timestamp | timestamp asTime])]</body><body package="Scaffolding-Core">renderUploadEditor: variableName id: id on: html	" Render a rudimnetary upload editor - you should probably make your own one of these to store the @file object appropriately. "	html fileUpload		class: variableName;		callback: [:file | file ifNotNil: [object instVarNamed: variableName put: file contents]]</body></methods><methods><class-id>Scaffolding.GenericEditUI</class-id> <category>actions</category><body package="Scaffolding-Core">accept	self validate ifFalse: [^self].	self answer: true.	"If we're here, that means we weren't wrapped up and we therefore had no one to answer to -- so it's up to us to commit the changes"	object commitUnitOfWork</body><body package="Scaffolding-Core">addNewRelationship: variableName type: type	" Workflow: Add a new Type and redirect the user to the edit page of that type. If they save on that page, then we add the new object to our variableName's collection. "	| value component |	value := type new.	component := (GenericEditUI editorClassFor: type) on: value.	(self call: component) ifFalse: [^self].	(object instVarNamed: variableName) ifNil: [object instVarNamed: variableName put: OrderedCollection new].	(object instVarNamed: variableName) add: value</body><body package="Scaffolding-Core">cancel	" We need to roll back before we answer false. "	object rollback.	self answer: false.	"If we're here, that means we weren't wrapped up and we therefore had no one to answer to -- so it's up to us to commit the changes"	object rollbackUnitOfWork</body><body package="Scaffolding-Core">editRelationship: variableName value: value	" Workflow: Redirect the user to the edit page for value. "	| component |	component := (GenericEditUI editorClassFor: value class) on: value.	self call: component</body><body package="Scaffolding-Core">hideActions	" Setup the page so it will not show actions, thus allowing it to be embedded inside another page sensibly. "	showActions := false</body><body package="Scaffolding-Core">refresh	" Refresh our object from the database. "	object refresh</body><body package="Scaffolding-Core">removeRelationship: variableName value: value	" Remove an object from variableName's collection. "	(object instVarNamed: variableName) remove: value ifAbsent: []</body><body package="Scaffolding-Core">showActions	" Setup the page so it will show actions (the default). "	showActions := true</body></methods><methods><class-id>Scaffolding.GenericEditUI</class-id> <category>validation</category><body package="Scaffolding-Core">invalidTypeErrorFor: variable type: type	^ #invalidTypeError &lt;&lt; self class environment name  &gt;&gt; 'Wrong Format'</body><body package="Scaffolding-Core">mandatoryErrorFor: variable	^#mandatoryError &lt;&lt; self class environment name  &gt;&gt; 'Required'</body><body package="Scaffolding-Core">validate	" Check that our object is acceptable for writing to the database. "	errors := Dictionary new.	self variableNames do: [:variableName | self validate: variableName].	^errors isEmpty</body><body package="Scaffolding-Core">validate: variableName	" Check that a field of our object is valid for writing to the database. "	self		perform: ('validate', variableName copyAsCapitalized) asSymbol		ifMessageNotUnderstood:	[self		perform: ('validate', variableName copyAsCapitalized, ':') asSymbol		with: (object instVarNamed: variableName)		ifMessageNotUnderstood:	[self validateMapping: variableName]]</body><body package="Scaffolding-Core">validateCollectionDatatype: variable type: type	" Check that @variable field is the right type to be written to the database. "	(object instVarNamed: variable) do: [:each |		(each isKindOf: type) ifFalse: [^errors at: variable put: (self invalidTypeErrorFor: variable type: type)]]</body><body package="Scaffolding-Core">validateDatatype: variable type: type	" Check that @variable field is the right type to be written to the database. "	((object instVarNamed: variable) isKindOf: type)		ifFalse: [errors at: variable put: (self invalidTypeErrorFor: variable type: type)]</body><body package="Scaffolding-Core">validateMandatory: variable	" Chec that @variable was filled in on our object, as it is mandatory. "	| value |	value := object instVarNamed: variable.	(value isNil or: [value isSequenceable and: [value isEmpty]]) ifTrue:		[errors at: variable put: (self mandatoryErrorFor: variable)]</body><body package="Scaffolding-Core">validateMapping: variableName	| mapping |	(mapping := self mappingFor: variableName) ifNil: [^self].	mapping isRelationship		ifTrue:	[self validateRelationshipMapping: mapping variableName: variableName]		ifFalse:	[self validateObjectMapping: mapping variableName: variableName]</body><body package="Scaffolding-Core">validateObjectMapping: mapping variableName: variableName	| field |	self validateDatatype: variableName type: mapping attribute type.	field := nil.	(mapping respondsTo: #field) ifTrue: [field := mapping field].	field ifNil: [^self].	field isNullable ifFalse: [self validateMandatory: variableName]</body><body package="Scaffolding-Core">validateRelationshipMapping: mapping variableName: variableName	| field |	mapping isToManyRelationship		ifTrue:			[self validateDatatype: variableName type: mapping collectionType.			self validateCollectionDatatype: variableName type: mapping attribute type]		ifFalse:			[self validateDatatype: variableName type: mapping attribute type].	field := mapping join allTargetFields first.	field isNullable ifFalse: [self validateMandatory: variableName]</body></methods><methods><class-id>Scaffolding.GenericEditUI</class-id> <category>updating</category><body package="Scaffolding-Core">updateRoot: anHtmlRoot	" Check that we have an object, otherwise show the NotFound page. "	object ifNil: [^self notFound].	super updateRoot: anHtmlRoot</body></methods><methods><class-id>Scaffolding.GenericEditUI</class-id> <category>rendering html</category><body package="Scaffolding-Core">renderActionsOn: html	" Render the actions for our object. "	html button		class: #accept;		callback: [self accept];		with: 'Accept'.	object isInDatabase ifTrue:		[html button			class: #refresh;			callback: [self refresh];			with: 'Refresh'].	html button		class: #cancel;		callback: [self cancel];		with: 'Cancel'.</body><body package="Scaffolding-Core">renderDetailsOn: html	" Render the details of our object for editing. "	(html table)		cellpadding: 0;		cellspacing: 0;		with: 				[self variableNames keysAndValuesDo: 						[:rowIndex :variableName |						errors at: variableName							ifPresent: [:error | self renderError: error on: html].						(html tableRow)							class: (self rowClassFor: rowIndex);							class: variableName , 'Row';							with: 									[| editorId |									editorId := html nextId.									(html tableData)										class: #labels;										class: variableName , 'Label';										with: [self renderLabel: variableName for: editorId on: html].									(html tableData)										class: #values;										class: variableName , 'Cell';										with: [self renderEditor: variableName id: editorId on: html]]]]</body><body package="Scaffolding-Core">renderEditor: variableName id: id on: html	" Render an editor for one of our objects fields. "	self		perform: ('renderEdit', variableName copyAsCapitalized, 'On:') asSymbol		with: html		ifMessageNotUnderstood:	[self		perform: ('renderEdit', variableName copyAsCapitalized, ':on:') asSymbol		with: id with: html		ifMessageNotUnderstood:	[self renderMappingEditor: variableName id: id on: html]]</body><body package="Scaffolding-Core">renderError: error on: html	" Render a validation error raised during #save. "	html tableRow		class: #errors;		with:			[html tableData.			html tableData with: error]</body><body package="Scaffolding-Core">renderLabel: label for: id on: html	" Render the label for one of our objects fields. "	| inflector |	inflector := Glorp.Inflector new.	self		perform: ('renderLabel', label copyAsCapitalized, 'On:') asSymbol		with: html		ifMessageNotUnderstood:	[self		perform: ('renderLabel', label copyAsCapitalized, 'For:on:') asSymbol		with: id with: html		ifMessageNotUnderstood:			[html label				for: id;				with: ( label asSymbol &lt;&lt; self class environment name &gt;&gt; (inflector humanize: (inflector underscore: label))) asString]]</body><body package="Scaffolding-Core">renderMappingEditor: variableName id: id on: html	" Render a generic editor based on the mappings data type read from the database. "	| mapping |	mapping := self mappingFor: variableName.	mapping ifNil: [^self renderNoEditor: variableName id: id on: html].	mapping renderEditorFor: self variable: variableName id: id on: html</body><body package="Scaffolding-Core">renderPageContentOn: html	" We override renderHtmlContentOn: so that our form can accept file uploads. "	html form		id: 'form';		multipart;		with:			[showActions				ifTrue:					[html div class: #actions; with: [self renderActionsOn: html].					html div class: #details; with: [self renderDetailsOn: html]]				ifFalse: [self renderDetailsOn: html]]</body><body package="Scaffolding-Core">title	object id ifNil: [^((#editNewPageTitle  &lt;&lt; self class environment name &gt;&gt; ('Edit - new &lt;1s&gt;')) expandMacrosWith: object class name) asString].	^((#editPageTitle  &lt;&lt; self class environment name &gt;&gt; ('Edit - (&lt;1p&gt;): &lt;2s&gt;')) expandMacrosWith: object id with: object displayString) asString</body></methods><methods><class-id>Scaffolding.GenericEditUI</class-id> <category>request processing</category><body package="Scaffolding-Core">initialRequest: aRequest	" Extract our object from the url. If we can't, create a new object instead. "	| id |	super initialRequest: aRequest.	aRequest url asURI path last = 'new.html' ifTrue: [^object := self objectClass new bePersistent].	id := (aRequest url asURI path last: 2) first asNumber.	id &lt;= 0 ifTrue: [^object := self objectClass new].	object := self objectClass find: id</body></methods><methods><class-id>Scaffolding.GenericEditUI class</class-id> <category>instance creation</category><body package="Scaffolding-Core">on: object	^self new object: object</body></methods><methods><class-id>Scaffolding.GenericEditUI class</class-id> <category>accessing</category><body package="Scaffolding-Core">editorClassFor: aClass	self allSubclassesDo: [:each | each objectClass == aClass ifTrue: [^each]].	^GenericEditUI</body><body package="Scaffolding-Core">objectClassName	('*EditUI' match: self name) ifFalse: [^self name].	^self name allButLast: 'EditUI' size</body><body package="Scaffolding-Core">viewClassName	^'GenericEditUI'</body></methods><methods><class-id>Scaffolding.JsonRoot</class-id> <category>accessing</category><body package="Scaffolding-Core">charSet	charSet isNil ifTrue: [		charSet := self class defaultCharSet ].	^charSet</body><body package="Scaffolding-Core">charSet: anObject	charSet := anObject</body></methods><methods><class-id>Scaffolding.JsonRoot class</class-id> <category>accessing</category><body package="Scaffolding-Core">defaultCharSet	^'utf-8'</body></methods><methods><class-id>Scaffolding.GenericGridUI</class-id> <category>accessing</category><body package="Scaffolding-Core">maxNumberOfColumns	^self class maxNumberOfColumns</body><body package="Scaffolding-Core">maxNumberOfRows	^self class maxNumberOfRows</body><body package="Scaffolding-Core">numberOfColumns	^self class numberOfColumns</body><body package="Scaffolding-Core">numberOfColumns: anInteger	self class  numberOfColumns: anInteger.	self initializePaginator</body><body package="Scaffolding-Core">numberOfRows	^self class numberOfRows</body><body package="Scaffolding-Core">numberOfRows: anInteger	self class  numberOfRows: anInteger.	self initializePaginator</body><body package="Scaffolding-Core">objectsInGroups	| grouped |	grouped := OrderedCollection new.	self objects inject: 0 into: [ :cellCounter :eachObject |		cellCounter = 0 ifTrue: [ grouped add: (Array new: self numberOfColumns) ].		grouped last at: (cellCounter + 1) put: eachObject.		cellCounter + 1 \\  self numberOfColumns ].	^ grouped</body><body package="Scaffolding-Core">pageSize	^self numberOfColumns * self numberOfRows</body><body package="Scaffolding-Core">pageSize: anObject</body><body package="Scaffolding-Core">variableIndex	^ self variableNames indexOf: self variableName</body><body package="Scaffolding-Core">variableName	self class variableName ifNil: [self class variableName: self variableNames first ].	^self class variableName</body><body package="Scaffolding-Core">variableName: aString	self class variableName: aString</body></methods><methods><class-id>Scaffolding.GenericGridUI</class-id> <category>rendering html</category><body package="Scaffolding-Core">renderHeadingsOn: html	html div  style: 'margin: 1%'; with: [		html text: 'Variable: '.		html select			addAll: self variableNames;		selected: self variableName;		callback: [ :value | self variableName: value ];		onChange: 'document.getElementById("form").submit()' .		html space.		html text: '   Number of rows: '.		html select			addAll: (1 to: self maxNumberOfRows);			selected: self numberOfRows;			callback: [ :value | self numberOfRows: value ];			onChange: 'document.getElementById("form").submit()'.		html space.		html text: '  columns: '.		html select			addAll: (1 to: self maxNumberOfColumns);			selected: self numberOfColumns;			callback: [ :value | self numberOfColumns: value ];			onChange: 'document.getElementById("form").submit()' ].</body><body package="Scaffolding-Core">renderObject: anObject inCell: aPoint on: html	" Render all the object results to the table. "	| rowIndex cellIndex objectIndex |	cellIndex := aPoint x.	rowIndex := aPoint y.	objectIndex := (rowIndex - 1) * self numberOfColumns + cellIndex.	html tableData		class: #gridCell;		class: (self columnClassFor: cellIndex);		class: self variableName;		with: [			anObject isNil ifFalse: [				html anchor				callback: [ self call: (self objectViewClass on: anObject) ];				with: [						self							renderObject: anObject							variable: self variableName							index: objectIndex							value: (anObject instVarNamed: self variableName)							on: html ] ] ]</body><body package="Scaffolding-Core">renderObjectsOn: html	" Render all the object results to the table. "	self objectsInGroups keysAndValuesDo: 			[:rowIndex :eachRow |			(html tableRow)				class: #gridRow;				class: (self rowClassFor: rowIndex);				with: 						[eachRow keysAndValuesDo: 								[:cellIndex :object |								self									renderObject: object									inCell: cellIndex @ rowIndex									on: html]]]</body><body package="Scaffolding-Core">title	^( #gridPageTitle &lt;&lt; self class environment name &gt;&gt; self class objectName copyAsCapitalized) asString</body></methods><methods><class-id>Scaffolding.GenericGridUI class</class-id> <category>accessing</category><body package="Scaffolding-Core">defaultPageSizeValue	^20</body><body package="Scaffolding-Core">maxNumberOfColumns	^4</body><body package="Scaffolding-Core">maxNumberOfRows	^10</body><body package="Scaffolding-Core">numberOfColumns	^numberOfColumns ifNil: [numberOfColumns := self maxNumberOfColumns]</body><body package="Scaffolding-Core">numberOfColumns: aNumber	numberOfColumns := aNumber</body><body package="Scaffolding-Core">numberOfRows	^numberOfRows ifNil: [numberOfRows := self maxNumberOfRows]</body><body package="Scaffolding-Core">numberOfRows: anInteger	numberOfRows := anInteger</body><body package="Scaffolding-Core">variableName	^variableName</body><body package="Scaffolding-Core">variableName: anObject	variableName := anObject</body><body package="Scaffolding-Core">viewClassNameSuffix	^'GridUI'</body></methods><methods><class-id>Scaffolding.JsonSystemConfiguration</class-id> <category>accessing</category><body package="Scaffolding-Core">documentRootClasses	^ JsonRoot withAllSubclasses</body><body package="Scaffolding-Core">rootComponents	^(GenericViewUI allSubclasses select: [ :each | each canBeRoot ])		asSortedCollection: [ :a :b | a name &lt;= b name ]</body></methods><methods><class-id>Scaffolding.JsonSystemConfiguration</class-id> <category>ancestry</category><body package="Scaffolding-Core">parents	^ Array with: WARequestHandlingConfiguration instance</body></methods><methods><class-id>Scaffolding.JsonSystemConfiguration</class-id> <category>description</category><body package="Scaffolding-Core">describeOn: config	(config list: #rootComponentClass)		label: 'Root Component';		options: [ self rootComponents ].	(config string: #charSet)		label: 'Charater Set';		comment: 'The character set reported to the client. You may additionally need to configure your server that this is also the character set used by your server.';		default: 'utf-8'.	(config list: #documentRootClass)		label: 'Document Root Class';		comment: 'The class that is used as a root for the document.';		options: [ self documentRootClasses ];		default: JsonRoot.	config at: #documentClass put: WAUnescapedDocument</body></methods><methods><class-id>Scaffolding.GenericViewUI</class-id> <category>accessing</category><body package="Scaffolding-Core">object	^object</body><body package="Scaffolding-Core">object: anObject	object := anObject</body></methods><methods><class-id>Scaffolding.GenericViewUI</class-id> <category>rendering html</category><body package="Scaffolding-Core">renderActionsOn: html	" Render the actions for our object. "	html button		class: #edit;		callback: [self editObject];		with: 'Edit'.	html button		class: #delete;		callback: [self delete];		with: 'Delete'.	html button		class: #close;		callback: [self close];		with: 'Close'.</body><body package="Scaffolding-Core">renderDetailsOn: html	" Render the details of our object in a table. "	(html table)		cellpadding: 0;		cellspacing: 0;		with: 				[self variableNames keysAndValuesDo: 						[:index :variableName |						| value |						value := object instVarNamed: variableName.						(html tableRow)							class: (self rowClassFor: index);							class: variableName , 'Row';							with: 									[(html tableData)										class: #labels;										class: variableName , 'Label';										with: [self renderLabel: variableName on: html].									(html tableData)										class: #values;										class: variableName , 'Cell';										with: [self renderObject: value variable: variableName on: html]]]]</body><body package="Scaffolding-Core">renderLabel: label on: html	" Render the label for one of our objects fields. "	| inflector |	inflector := Glorp.Inflector new.	self		perform: ('renderLabel', label copyAsCapitalized, 'On:') asSymbol		with: html		ifMessageNotUnderstood:			[html label				with: ( label asSymbol &lt;&lt; self class environment name &gt;&gt; (inflector humanize: (inflector underscore: label))) asString ]</body><body package="Scaffolding-Core">renderObject: anObject variable: variableName on: html	" Render the value of one of our objects fields. "	self		perform: ('renderObject', variableName copyAsCapitalized, ':on:') asSymbol		with: anObject with: html		ifMessageNotUnderstood:	["renderValue*:on: is from WV1.0 and should be removed in the future as a deprecation in favor of renderObject*:on:"	self		perform: ('renderValue', variableName copyAsCapitalized, ':on:') asSymbol		with: anObject with: html		ifMessageNotUnderstood:	[(anObject isSequenceable and: [anObject isCharacters not])		ifTrue:			[anObject isEmpty ifTrue: [^html span style: 'color: gray'; with: 'none'].			^anObject				do: [:each | self renderObject: each variable: variableName on: html]				separatedBy: [ html span with: ', ' ] ].	html span		with:			[anObject isCharacters				ifTrue:	[html withOverflowSafeText: anObject]				ifFalse:	[html text: anObject]]]]</body><body package="Scaffolding-Core">title	^( #viewPageTitle &lt;&lt; self class environment name &gt;&gt; object displayString ) asString</body></methods><methods><class-id>Scaffolding.GenericViewUI</class-id> <category>request processing</category><body package="Scaffolding-Core">initialRequest: aRequest	" Extract our record from the url. "	| id |	super initialRequest: aRequest.	id := aRequest url asURI path last copyWithoutFileExtension asNumber.	id &lt;= 0 ifTrue: [^self].	object := self objectClass find: id</body></methods><methods><class-id>Scaffolding.GenericViewUI</class-id> <category>updating</category><body package="Scaffolding-Core">updateRoot: anHtmlRoot	" If we have no object, then show the NotFound page. "	object ifNil: [^self notFound].	super updateRoot: anHtmlRoot</body></methods><methods><class-id>Scaffolding.GenericViewUI</class-id> <category>actions</category><body package="Scaffolding-Core">close	" Workflow: Return back to our calling view. "	self answer</body><body package="Scaffolding-Core">delete	" Workflow: Mark the object to be deleted, commit and return back to our calling component. "	object delete.	object commitUnitOfWork.	self close</body><body package="Scaffolding-Core">editObject	" Workflow: Call the edit view for this object. If it wants to save the object, mark it as saved and commit the unit of work, otherwise, rollback this workflow completely. "	(self call: (self objectEditClass on: object))		ifTrue:	[object commitUnitOfWork]		ifFalse:	[object rollbackUnitOfWork]</body></methods><methods><class-id>Scaffolding.GenericViewUI</class-id> <category>rendering xml</category><body package="Scaffolding-Core">renderXmlContentOn: html	" Render our object as generic xml. "	object ifNil: [^self].	object renderAsXmlRootTag: object class name on: self requestContext response stream</body></methods><methods><class-id>Scaffolding.GenericViewUI</class-id> <category>rendering json</category><body package="Scaffolding-Core">renderJsonContentOn: jsonCanvas	" Render our object as generic json. "	object ifNil: [^self].	object renderAsJsonRootOn: self requestContext response stream</body></methods><methods><class-id>Scaffolding.GenericViewUI class</class-id> <category>instance creation</category><body package="Scaffolding-Core">on: object	^self new object: object</body></methods><methods><class-id>Scaffolding.GenericViewUI class</class-id> <category>accessing</category><body package="Scaffolding-Core">objectClassName	('*ViewUI' match: self name) ifFalse: [^self name].	^self name allButLast: 'ViewUI' size</body><body package="Scaffolding-Core">viewClassName	^'GenericViewUI'</body></methods><methods><class-id>Scaffolding.GenericListUI</class-id> <category>rendering html</category><body package="Scaffolding-Core">title	^( #listPageTitle &lt;&lt; self class environment name &gt;&gt; self class objectName copyAsCapitalized) asString</body></methods><methods><class-id>Scaffolding.GenericListUI</class-id> <category>rendering atom</category><body package="Scaffolding-Core">atomAuthorName	^'Seaside-Scaffolding'</body><body package="Scaffolding-Core">renderAtomContent: object on: atom	" Render @object to an atom feed with links back in to the system for xml, html and json. "	atom entry with:		[atom id with: 'urn:', object class name, ':', object id printString.		atom updated with: Timestamp now printAsRFC3339String.		atom title type: 'text'; with: object.		atom content type: 'text/xml'; src: (self atomXmlLinkHrefFor: object).		atom content type: 'text/html'; src: (self atomHtmlLinkHrefFor: object).		atom content type: 'text/json'; src: (self atomJsonLinkHrefFor: object)]</body><body package="Scaffolding-Core">renderAtomContentOn: atom	" Render our objects as an Atom feed. "	atom feed with: 			[atom title with: self title.			atom updated with: Timestamp now printAsRFC3339String.			atom id with: self application url.			atom author with: [atom name with: self atomAuthorName].			atom link				type: 'application/atom+xml';				rel: 'self';				href: self application url.			self objects do: [:each | self renderAtomContent: each on: atom]]</body></methods><methods><class-id>Scaffolding.GenericListUI</class-id> <category>private</category><body package="Scaffolding-Core">atomHtmlLinkHrefFor: object	" Return a full absolute URL in to our system for the @object as a HTML link. "	^ (self atomLinkHrefBaseFor: object), '.html'</body><body package="Scaffolding-Core">atomJsonLinkHrefFor: object	" Return a full absolute URL in to our system for the @object as a Json link. "	^ (self atomLinkHrefBaseFor: object), '.json'</body><body package="Scaffolding-Core">atomLinkHrefBaseFor: object	" Return a base of the URL the @object. "	| url |	url := self application url pathString.	url := url allButLast: '.atom' size.	^url, '/', object id printString</body><body package="Scaffolding-Core">atomXmlLinkHrefFor: object	" Return a full absolute URL in to our system for the @object as an XML link. "	^ (self atomLinkHrefBaseFor: object), '.xml'</body></methods><methods><class-id>Scaffolding.GenericListUI class</class-id> <category>accessing</category><body package="Scaffolding-Core">viewClassNameSuffix	^'ListUI'</body></methods><methods><class-id>Scaffolding.XmlSystemConfiguration</class-id> <category>accessing</category><body package="Scaffolding-Core">documentRootClasses	^ WAXmlRoot  withAllSubclasses</body><body package="Scaffolding-Core">rootComponents	^(GenericViewUI allSubclasses select: [ :each | each canBeRoot ])		asSortedCollection: [ :a :b | a name &lt;= b name ]</body></methods><methods><class-id>Scaffolding.XmlSystemConfiguration</class-id> <category>ancestry</category><body package="Scaffolding-Core">parents	^ Array with: WARequestHandlingConfiguration instance</body></methods><methods><class-id>Scaffolding.XmlSystemConfiguration</class-id> <category>description</category><body package="Scaffolding-Core">describeOn: config	(config list: #rootComponentClass)		label: 'Root Component';		options: [ self rootComponents ].	(config string: #charSet)		label: 'Charater Set';		comment: 'The character set reported to the client. You may additionally need to configure your server that this is also the character set used by your server.';		default: 'utf-8'.	(config list: #documentRootClass)		label: 'Document Root Class';		comment: 'The class that is used as a root for the document.';		options: [ self documentRootClasses ];		default: WAXmlRoot.	config at: #documentClass put: WAXmlDocument</body></methods><methods><class-id>Scaffolding.JsonRenderHandler</class-id> <category>configuration</category><body package="Scaffolding-Core">systemConfigurationClass	^ JsonSystemConfiguration</body></methods><methods><class-id>Scaffolding.JsonRenderHandler</class-id> <category>private</category><body package="Scaffolding-Core">mimeType	^WAMimeType main: 'application' sub: 'json'</body><body package="Scaffolding-Core">renderCanvasClass	^ JsonRenderCanvas</body></methods><methods><class-id>Scaffolding.JsonRenderHandler class</class-id> <category>accessing</category><body package="Scaffolding-Core">description	^'JSON data'</body></methods><methods><class-id>Scaffolding.PatternDispatcher</class-id> <category>handling</category><body package="Scaffolding-Core">handleFiltered: aRequestContext	| requestUrl baseUrl relativePath |	(self name includes: $*) ifFalse: [ "I don't have a pattern in my name, do as my superclass does. "		^ super handleFiltered: aRequestContext ].	" The rest is *almost* like the superclass, except I user #matchingRelativeTo: to look up the relative path. "	requestUrl := aRequestContext request url.	requestUrl path isEmpty 		ifTrue: [ ^ self handleFiltered: aRequestContext named: self defaultName ].	baseUrl := WAUrl new.	baseUrl addAllToPath: self path.	" Use #matchingRelativeTo: instead of #relativeTo: "	relativePath := baseUrl matchingRelativeTo: requestUrl.	self handleFiltered: aRequestContext named: (relativePath isEmpty 		ifTrue: [ self defaultName ]		ifFalse: [ relativePath first ])</body></methods><methods><class-id>Scaffolding.AtomRenderHandler</class-id> <category>configuration</category><body package="Scaffolding-Core">systemConfigurationClass	^ Scaffolding.AtomSystemConfiguration</body></methods><methods><class-id>Scaffolding.AtomRenderHandler</class-id> <category>private</category><body package="Scaffolding-Core">mimeType	^ WAMimeType main: 'application' sub: 'atom+xml'</body><body package="Scaffolding-Core">renderCanvasClass	^ AtomRenderCanvas</body></methods><methods><class-id>Scaffolding.AtomRenderHandler</class-id> <category>accessing</category><body package="Scaffolding-Core">rootClass	" My system configuration uses #rootClass attribute, not #rootComponentClass. "	^ self preferenceAt: #rootClass</body></methods><methods><class-id>Scaffolding.AtomRenderHandler class</class-id> <category>accessing</category><body package="Scaffolding-Core">description	^'Atom feed'</body></methods><methods><class-id>Scaffolding.AtomSystemConfiguration</class-id> <category>accessing</category><body package="Scaffolding-Core">documentRootClasses	^ WAXmlRoot  withAllSubclasses</body><body package="Scaffolding-Core">rootComponents	^(GenericListUI allSubclasses select: [ :each | each canBeRoot ])		asSortedCollection: [ :a :b | a name &lt;= b name ]</body></methods><methods><class-id>Scaffolding.AtomSystemConfiguration</class-id> <category>description</category><body package="Scaffolding-Core">describeOn: config	super describeOn: config.	(config list: #documentRootClass)		label: 'Document Root Class';		comment: 'The class that is used as a root for the document.';		options: [ self documentRootClasses ];		default: WAXmlRoot.</body></methods><methods><class-id>Core.Integer</class-id> <category>printing</category><body package="Scaffolding-Core">renderAsXmlTag: tag on: stream	stream nextPutAll: '&lt;', tag, ' type="integer"&gt;'.	stream nextPutAll: self printString.	stream nextPutAll: '&lt;/', tag, '&gt;'</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Scaffolding-Core">renderAsJsonOn: stream	self javascriptOn: stream</body><body package="Scaffolding-Core">renderAsXmlTag: tag on: stream	stream nextPutAll: '&lt;', tag, ' type="', self class name, '"&gt;'.	stream nextPutAll: self printString.	stream nextPutAll: '&lt;/', tag, '&gt;'</body></methods><methods><class-id>Core.Collection</class-id> <category>printing</category><body package="Scaffolding-Core">renderAsXmlTag: tag on: stream	| plural single |	plural := Glorp.Inflector default pluralize: tag.	single := Glorp.Inflector default singularize: tag.	stream nextPutAll: '&lt;', plural, '&gt;'.	self do: [:each | each renderAsXmlTag: single on: stream].	stream nextPutAll: '&lt;/', plural, '&gt;'</body></methods><methods><class-id>Glorp.GlorpTimeStampType</class-id> <category>user interface</category><body package="Scaffolding-Core">renderEditorFor: component variable: variableName id: id on: html	component renderTimestampEditor: variableName id: id on: html</body></methods><methods><class-id>Glorp.GlorpAbstractStringType</class-id> <category>user interface</category><body package="Scaffolding-Core">aLinesWorthOfCharacters	^300</body><body package="Scaffolding-Core">renderEditorFor: component variable: variableName id: id on: html	(self width notNil and: [self width &gt; self aLinesWorthOfCharacters])		ifTrue:	[component renderTextAreaEditor: variableName id: id maxLength: self width on: html]		ifFalse:	[component renderTextInputEditor: variableName id: id maxLength: self width on: html]</body></methods><methods><class-id>Glorp.GlorpClobType</class-id> <category>user interface</category><body package="Scaffolding-Core">renderEditorFor: component variable: variableName id: id on: html	component renderTextAreaEditor: variableName id: id maxLength: self width on: html</body></methods><methods><class-id>Seaside.WAHtmlCanvas</class-id> <category>public</category><body package="Scaffolding-Core">text: aStringOrNil withMaxWordLength: aNumber	aStringOrNil ifNil: [^aStringOrNil].	self withLineBreaks: (aStringOrNil asString asMaxWordLength: aNumber)</body><body package="Scaffolding-Core">withOverflowSafeText: aStringOrNil	"Renders text ensuring word breaks when words are too long."	^ self		text: aStringOrNil		withMaxWordLength: 25</body></methods><methods><class-id>Glorp.GlorpDatabaseType</class-id> <category>user interface</category><body package="Scaffolding-Core">renderEditorFor: component variable: variableName id: id on: html	component renderNoEditor: variableName id: id on: html</body></methods><methods><class-id>Glorp.GlorpDateType</class-id> <category>user interface</category><body package="Scaffolding-Core">renderEditorFor: component variable: variableName id: id on: html	component renderDateEditor: variableName id: id on: html</body></methods><methods><class-id>Glorp.GlorpAbstractNumericType</class-id> <category>user interface</category><body package="Scaffolding-Core">renderEditorFor: component variable: variableName id: id on: html	component renderNumericEditor: variableName id: id on: html</body></methods><methods><class-id>Glorp.GlorpBooleanType</class-id> <category>user interface</category><body package="Scaffolding-Core">renderEditorFor: component variable: variableName id: id on: html	component renderBooleanEditor: variableName id: id on: html</body></methods><methods><class-id>Glorp.DirectMapping</class-id> <category>user interface</category><body package="Scaffolding-Core">renderEditorFor: component variable: variableName id: id on: html	field type renderEditorFor: component variable: variableName id: id on: html</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>user interface</category><body package="Scaffolding-Core">renderEditorFor: component variable: variableName id: id on: html	component renderNoEditor: variableName id: id on: html</body></methods><methods><class-id>Seaside.WAAdmin class</class-id> <category>registration</category><body package="Scaffolding-Core">register: anEntryPointClass atPattern: aString in: aDispatcher	" Modeled after register: anEntryPointClass at: aString in: aDispatcher except aString can be a pattern, and we use PatternDispatcher in the registration.	"	| path dispatcher |	path := aString findTokens: '/'.	dispatcher := path allButLast		inject: aDispatcher		into: [ :result :each |			result handlers				at: each				ifAbsent: [ result register: Scaffolding.PatternDispatcher new at: each] ].	^ dispatcher register: anEntryPointClass new at: path last</body></methods><methods><class-id>Glorp.GlorpTimeType</class-id> <category>user interface</category><body package="Scaffolding-Core">renderEditorFor: component variable: variableName id: id on: html	component renderTimeEditor: variableName id: id on: html</body></methods><methods><class-id>Glorp.GlorpTextType</class-id> <category>user interface</category><body package="Scaffolding-Core">renderEditorFor: component variable: variableName id: id on: html	component renderTextAreaEditor: variableName id: id maxLength: self width on: html</body></methods><methods><class-id>Glorp.GlorpBlobType</class-id> <category>user interface</category><body package="Scaffolding-Core">renderEditorFor: component variable: variableName id: id on: html	component renderUploadEditor: variableName id: id on: html</body></methods><methods><class-id>Glorp.OneToOneMapping</class-id> <category>user interface</category><body package="Scaffolding-Core">renderEditorFor: component variable: variableName id: id on: html	self isExclusive		ifTrue:	[component renderObjectEditor: variableName type: self attribute type id: id on: html]		ifFalse:	[component renderSelectEditor: variableName list: self attribute type findAll id: id on: html]</body></methods><methods><class-id>Seaside.WATagBrush</class-id> <category>convenience</category><body package="Scaffolding-Core">withOverflowSafeText: aString	"Renders text ensuring word breaks when words are too long."	self with: [canvas withOverflowSafeText: aString]</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="Scaffolding-Core">asMaxWordLength: aNumber	"	Split any word that is longer than aNumber of characters and insert a space. This is to prevent long texts from overflowing	html elements.	Evaluate:		'somereallylongtext' asMaxWordLength: 10		'zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz' asMaxWordLength: 25		'hello world, how are you, zzzzz yyyyy iiiiiiiiii wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww ssssss rrrrr' asMaxWordLength: 25	"	| stream counter lastChar |	aNumber &lt; 1 ifTrue: [ ^ self ].	stream := self writeStream on: (self class new: 0).	counter := 0.	lastChar := nil.	self do: [ :eachChar |		counter := eachChar isSeparator ifTrue: [ 0 ] ifFalse: [ counter + 1 ].		(counter &gt; aNumber and: [ lastChar isSeparator not ]) ifTrue: [			stream nextPut: (lastChar := Character space).			counter := 0 ].		stream nextPut: (lastChar := eachChar) ].	^ stream contents</body><body package="Scaffolding-Core">copyAsCapitalized	^self copy		at: 1 put: self first asUppercase;		yourself</body><body package="Scaffolding-Core">copyFileExtension	| index |	index := self lastIndexOf: $..	index isZero ifTrue: [^nil].	^self copyFrom: index + 1 to: self size</body><body package="Scaffolding-Core">copyWithoutFileExtension	| index |	index := self lastIndexOf: $..	index isZero ifTrue: [^self].	^self copyFrom: 1 to: index - 1</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>printing</category><body package="Scaffolding-Core">renderAsXmlTag: tag on: stream	stream nextPutAll: '&lt;', tag, '&gt;'.	stream nextPutAll: self.	stream nextPutAll: '&lt;/', tag, '&gt;'</body></methods><methods><class-id>Glorp.ToManyMapping</class-id> <category>user interface</category><body package="Scaffolding-Core">renderEditorFor: component variable: variableName id: id on: html	component renderObjectsEditor: variableName type: self attribute type id: id on: html</body></methods><methods><class-id>Seaside.WAUrl</class-id> <category>converting</category><body package="Scaffolding-Core">matchingRelativeTo: anUrl	"Answer a path element collection relative from the receiver to anUrl.	Like #relativeTo: , except we use pattern matching instead of equality "		| currentPath argumentPath resultingPath |	currentPath := self path copy.	argumentPath := anUrl path copy.	[ currentPath notEmpty and: [ argumentPath notEmpty and: [ currentPath first match: argumentPath first ] ] ] whileTrue: [		currentPath removeFirst.		argumentPath removeFirst ].	resultingPath := OrderedCollection new.	currentPath size 		timesRepeat: [ resultingPath add: '..' ].	resultingPath addAll: argumentPath.	^ resultingPath</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecord class</class-id> <category>hints</category><body package="Scaffolding-Core">variableNames	^self allInstVarNames asOrderedCollection		removeAll: Glorp.ActiveRecords.ActiveRecord allInstVarNames;		yourself</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecord</class-id> <category>printing</category><body package="Scaffolding-Core">renderAsJsonOn: stream	stream nextPutAll: '{'.	stream nextPutAll: 'class: '.	self class name renderAsJsonOn: stream.	stream nextPutAll: ', '.	stream nextPutAll: 'id: ', id printString.	stream nextPutAll: '}'</body><body package="Scaffolding-Core">renderAsJsonRootOn: stream	stream nextPutAll: '{'.	stream nextPutAll: '"class": '.	self class name renderAsJsonOn: stream.	stream nextPutAll: ', '.	#('id'), self class variableNames do: [:name |		name renderAsJsonOn: stream.		stream nextPutAll: ': '.		(self instVarNamed: name) renderAsJsonOn: stream]		separatedBy: [stream nextPutAll: ', '].	stream nextPutAll: '}'</body><body package="Scaffolding-Core">renderAsXmlRootTag: tag on: stream	stream nextPutAll: '&lt;', tag, ' id="', id printString, '" xmlns="http://www.cincomsmalltalk.com/2008/04/objects"&gt;'.	self class variableNames do: [:name | (self instVarNamed: name) renderAsXmlTag: name on: stream].	stream nextPutAll: '&lt;/', tag, '&gt;'</body><body package="Scaffolding-Core">renderAsXmlTag: tag on: stream	stream nextPutAll: '&lt;', tag, ' id="', id printString, '"/&gt;'</body></methods><methods><class-id>Seaside.WAComponent class</class-id> <category>class initialization</category><body package="Scaffolding-Core">abstractUIClasses	" Answer a collection of abstract UI classes that should not be registered as applications. "	^ OrderedCollection new		add: Seaside.WAComponent;		add: Seaside.WATask;		add: Scaffolding.GenericUI;		add: Scaffolding.GenericCollectionUI;		add: Scaffolding.GenericGridUI;		add: Scaffolding.GenericListUI;		add: Scaffolding.GenericEditUI;		add: Scaffolding.GenericViewUI;		yourself</body><body package="Scaffolding-Core">isAbstractUIClass	^ self abstractUIClasses includes: self</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>WARequestHandler</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filter parent configuration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><class><name>GlorpDatabaseType</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>platform selector typeString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpTimeType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>Mapping</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>descriptor attribute debugRead debugWrite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>GlorpTimeStampType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpAbstractStringType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>width queryType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpTextType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractStringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>WAUrl</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scheme user password host port path slash queryFields fragment pathParameters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WARoot</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>context </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document</category><attributes><package>Seaside-Core</package></attributes></class><class><name>OneToOneMapping</name><environment>Glorp</environment><super>Glorp.RelationshipMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>GlorpBooleanType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabaseTypes</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>WAXmlCanvas</name><environment>Seaside</environment><super>Seaside.WATagCanvas</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Canvas</category><attributes><package>Seaside-Canvas</package></attributes></class><class><name>WAComponent</name><environment>Seaside</environment><super>Seaside.WAPresenter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>decoration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Component</category><attributes><package>Seaside-Component</package></attributes></class><class><name>ActiveRecord</name><environment>Glorp.ActiveRecords</environment><super>Glorp.PersistentObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecord</category><attributes><package>GlorpActiveRecord</package></attributes></class><class><name>WASystemConfiguration</name><environment>Seaside</environment><super>Seaside.WAConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>description </inst-vars><class-inst-vars>instance </class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><class><name>AtomSystemConfiguration</name><environment>Atom</environment><super>Seaside.WASystemConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atom-Core</package></attributes></class><class><name>GlorpDateType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>DirectMapping</name><environment>Glorp</environment><super>Glorp.Mapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>field converter shouldProxy query </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>WAHtmlCanvas</name><environment>Seaside</environment><super>Seaside.WATagCanvas</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Canvas</category><attributes><package>Seaside-Canvas</package></attributes></class><class><name>GlorpAbstractNumericType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>WATagBrush</name><environment>Seaside</environment><super>Seaside.WABrush</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Canvas</category><attributes><package>Seaside-Canvas</package></attributes></class><class><name>GlorpClobType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractStringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>WADispatcher</name><environment>Seaside</environment><super>Seaside.WARequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultName handlers </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><class><name>ToManyMapping</name><environment>Glorp</environment><super>Glorp.RelationshipMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>orderBy shouldWriteTheOrderField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>GlorpBlobType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>queryType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabaseTypes</category><attributes><package>GlorpDatabaseTypes</package></attributes></class></st-source>