<?xml version="1.0"?><st-source><!-- Name: Seaside-REST-CoreComment: Write RESTful web services using SeasideDbIdentifier: bear73DbTrace: 492594DbUsername: jkottDbVersion: 3.2.0 - JohanBrichau.60 1DevelopmentPrerequisites: #(#(#any 'Seaside-Namespace' '') #(#any 'Seaside-Core' '') #(#any 'Seaside-VisualWorks-Core' ''))Id: 848e2398-8d61-414c-99e0-fd55b60a89ffNamespace: SeasidePackageName: Seaside-REST-CoreParcel: #('Seaside-REST-Core')ParcelName: Seaside-REST-CorePrerequisiteParcels: #(#('Seaside-Namespace' '') #('Seaside-Core' '') #('Seaside-VisualWorks-Core' ''))PrintStringCache: (3.2.0 - JohanBrichau.60 1,jkott)Url: http://smalltalkhub.com/mc/Seaside/Seaside32/main/Seaside-REST-Core-JohanBrichau.60.mczVersion: 3.2.0 - JohanBrichau.60 1Date: 3:31:28 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:31:28 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WAMatch</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WAPPathMatch</name><environment>Seaside</environment><super>Seaside.WAMatch</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WAPlaceholderPathMatch</name><environment>Seaside</environment><super>Seaside.WAPPathMatch</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceIndex targetIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WAFullPlaceholderPathMatch</name><environment>Seaside</environment><super>Seaside.WAPlaceholderPathMatch</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WARoute</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method selector produces consumes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><comment><class-id>Seaside.WARoute</class-id><body>I am a message that can be sent if I match a request. Message arguments can be taken from the request.Instance Variables:	method		&lt;String&gt;	selector	&lt;Symbol&gt;	produces 	&lt;WAMatch&gt;	consumes 	&lt;WAMatch&gt;		method	- The HTTP method on which to follow this route, eg. 'GET'selector	- The selector to perform, eg. #index	produces	- The MIME type this route produces (Content-Type HTTP header)	consumes	- The MIME type this route accepts (Accept HTTP header)</body></comment><class><name>WAComplexRoute</name><environment>Seaside</environment><super>Seaside.WARoute</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pathMatches parameterMatches isOverlyComplex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WAMimeTypeMatch</name><environment>Seaside</environment><super>Seaside.WAMatch</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WAMainMimeTypeMatch</name><environment>Seaside</environment><super>Seaside.WAMimeTypeMatch</super><private>false</private><indexed-type>none</indexed-type><inst-vars>main </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WARestfulConfiguration</name><environment>Seaside</environment><super>Seaside.WASystemConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Handler</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WARestfulHandler</name><environment>Seaside</environment><super>Seaside.WARequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>routes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Handler</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WAParameterMatch</name><environment>Seaside</environment><super>Seaside.WAMatch</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WAPlaceholderParameterMatch</name><environment>Seaside</environment><super>Seaside.WAParameterMatch</super><private>false</private><indexed-type>none</indexed-type><inst-vars>index </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WAWildcardMimeTypeMatch</name><environment>Seaside</environment><super>Seaside.WAMimeTypeMatch</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WARestfulFilter</name><environment>Seaside</environment><super>Seaside.WARequestFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>routes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Handler</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WARestfulComponentFilter</name><environment>Seaside</environment><super>Seaside.WARestfulFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Handler</category><attributes><package>Seaside-REST-Core</package></attributes></class><comment><class-id>Seaside.WARestfulComponentFilter</class-id><body>WARestfulComponentFilter has not been documented yet. The class comment should describe the purpose of the class, its collaborations and its variables.I am the fault of Norbert.</body></comment><class><name>WAByMethodRoutes</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fixedContainers flexibleContainers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><comment><class-id>Seaside.WAByMethodRoutes</class-id><body>A WAByMethodRoutes is a collection of routes first organized by HTTP method and then by number of URL path elements. It allows users to look up possible routes for a given HTTP request.See also WARouteResult and WARouteContainer.Instance Variables	routes:		&lt;Dictionary&lt;String, SortedCollection&lt;WARouteContainer&gt;&gt;routes	- the routes keyed by HTTP method, sorted by number of path elements</body></comment><class><name>WASimpleRoute</name><environment>Seaside</environment><super>Seaside.WARoute</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><comment><class-id>Seaside.WASimpleRoute</class-id><body>I match only on an exact number of path elements and no URL parameters. The path elements are turned into message arguments.Instance Variables:	count	&lt;Integer&gt;		count	- The exact number of path elements that have to be present.</body></comment><class><name>WASubMimeTypeMatch</name><environment>Seaside</environment><super>Seaside.WAMimeTypeMatch</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sub </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WAOrPathMatch</name><environment>Seaside</environment><super>Seaside.WAPPathMatch</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WARouteBuilder</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>compiled method path produces consumes variableQuery </inst-vars><class-inst-vars>configuration </class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><comment><class-id>Seaside.WARouteBuilder</class-id><body>I am a builder for building WARoute instances from a CompiledMethod.Instance Variables:	compiled	&lt;CompiledMethod&gt;	method		&lt;String&gt;	path		&lt;String&gt;	produces	&lt;WAWildcardMimeTypeMatch|WAMimeTypeMatch&gt;	consumes	&lt;Collection&lt;WAWildcardMimeTypeMatch|WAMimeTypeMatch&gt;&gt;Class Instance Variables:	configuration	&lt;Collection&gt;</body></comment><class><name>WACompositeMimeTypeMatch</name><environment>Seaside</environment><super>Seaside.WAMatch</super><private>false</private><indexed-type>none</indexed-type><inst-vars>matches </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WAPrefixPlaceholderPathMatch</name><environment>Seaside</environment><super>Seaside.WAPlaceholderPathMatch</super><private>false</private><indexed-type>none</indexed-type><inst-vars>prefix </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WARouteContainer</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pathElementCount routes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><comment><class-id>Seaside.WARouteContainer</class-id><body>A WARouteContainer is a collection of routes that all accept the same number of path elements ordered by priority.Instance Variables	pathElementCount:		&lt;Integer&gt;	routes:		&lt;SortedCollection&lt;WARoute&gt;&gt;pathElementCount	- the number of path elements that any of the routes in this container acceptsroutes	- the routes ordered by priority</body></comment><class><name>WAFullMimeTypeMatch</name><environment>Seaside</environment><super>Seaside.WAMimeTypeMatch</super><private>false</private><indexed-type>none</indexed-type><inst-vars>main sub </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WASortedAccepts</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accepts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WAExactPathMatch</name><environment>Seaside</environment><super>Seaside.WAPPathMatch</super><private>false</private><indexed-type>none</indexed-type><inst-vars>element </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WARouteResult</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>route elements parameters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><comment><class-id>Seaside.WARouteResult</class-id><body>I am the result of a route look up. I contain all the information required to "execute" the result.Instance Variables:	route	&lt;WARoute&gt;	elements	&lt;Collection&lt;String&gt;&gt;	parameters	&lt;WARequestFields&gt;		route	the found route	elements	the unconsumed path elements of the request	parameters	the query fields of the request</body></comment><class><name>WASuffixPlaceholderPathMatch</name><environment>Seaside</environment><super>Seaside.WAPlaceholderPathMatch</super><private>false</private><indexed-type>none</indexed-type><inst-vars>suffix </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WAArgumentNotFoundError</name><environment>Seaside</environment><super>Seaside.WAError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WAMultiPlaceholderPathMatch</name><environment>Seaside</environment><super>Seaside.WAPlaceholderPathMatch</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WAExactParameterMatch</name><environment>Seaside</environment><super>Seaside.WAParameterMatch</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WAVariableQueryRoute</name><environment>Seaside</environment><super>Seaside.WAComplexRoute</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Route</category><attributes><package>Seaside-REST-Core</package></attributes></class><comment><class-id>Seaside.WAVariableQueryRoute</class-id><body>I match only on an exact number of path elements regardless of the query fields in the url.I allow the creation of routes where the query fields are unknown beforehand, like when doing filtering, partial reads, etc.You can access the query fields sending #queryFields to the aWARequest</body></comment><methods><class-id>Seaside.WAMatch class</class-id> <category>private</category><body package="Seaside-REST-Core">argument: aString notFoundInd: aCollectionOfStrings	WAArgumentNotFoundError signal: 'argument "', aString, '" was not found in ', aCollectionOfStrings greaseString</body><body package="Seaside-REST-Core">targetIndexOf: aString arguments: aCollectionOfStrings	aString do: [ :each |		each isDigit ifFalse: [			| index |			index := aCollectionOfStrings indexOf: aString.			index isZero ifTrue: [				self argument: aString notFoundInd: aCollectionOfStrings ].			^ index ] ].	^ aString asNumber</body></methods><methods><class-id>Seaside.WAPPathMatch</class-id> <category>printing</category><body package="Seaside-REST-Core">printOn: aStream 	super printOn: aStream.		aStream		nextPutAll: ' (argumentCount: '; print: self argumentCount;		nextPutAll: ' matchesJustOneElement: '; print: self matchesJustOneElement;		nextPutAll: ' priority: '; print: self priority;		nextPut: $)</body></methods><methods><class-id>Seaside.WAPPathMatch</class-id> <category>testing</category><body package="Seaside-REST-Core">matches: aString	self subclassResponsibility</body><body package="Seaside-REST-Core">matchesJustOneElement	^ true</body></methods><methods><class-id>Seaside.WAPPathMatch</class-id> <category>accessing</category><body package="Seaside-REST-Core">argumentCount	self subclassResponsibility</body><body package="Seaside-REST-Core">priority	self subclassResponsibility</body></methods><methods><class-id>Seaside.WAPPathMatch</class-id> <category>public</category><body package="Seaside-REST-Core">mapArgumentsWithElements: aCollection into: anArray	self mapArgumentsWithElements: aCollection into: anArray usingOffset: 0</body><body package="Seaside-REST-Core">mapArgumentsWithElements: aCollection into: anArray usingOffset: anInteger	self subclassResponsibility</body></methods><methods><class-id>Seaside.WAPPathMatch class</class-id> <category>private</category><body package="Seaside-REST-Core">matchClassFor: aString	aString isEmpty ifTrue: [ ^ WAExactPathMatch  ].	aString first = ${		ifTrue: [			| index |			index := aString indexOf: $} startingAt: 2.			index = aString size				"{name}"				ifTrue: [ ^ WAFullPlaceholderPathMatch ].			index isZero				"{name}suffix"				ifFalse: [ ^ WASuffixPlaceholderPathMatch ] ].	"prefix{name}"	(aString last = $}		and: [ (aString indexOf: ${) isZero not ])			ifTrue: [ ^ WAPrefixPlaceholderPathMatch ].	"[option1|option2]"	(aString first = $[		and: [ aString last = $]		and: [ aString includes: $| ] ])			ifTrue: [ ^ WAOrPathMatch ].	"*name*"	(aString first = $*		and: [ aString last = $* ])			ifTrue: [ ^ WAMultiPlaceholderPathMatch ].	^ WAExactPathMatch</body></methods><methods><class-id>Seaside.WAPPathMatch class</class-id> <category>instance creation</category><body package="Seaside-REST-Core">fromString: aString index: anInteger arguments: aCollectionOfStrings	^ (self matchClassFor: aString)		fromString: aString index: anInteger arguments: aCollectionOfStrings</body></methods><methods><class-id>Seaside.WAPlaceholderPathMatch</class-id> <category>accessing</category><body package="Seaside-REST-Core">argumentCount	^ 1</body><body package="Seaside-REST-Core">sourceIndex	^ sourceIndex</body><body package="Seaside-REST-Core">targetIndex	^ targetIndex</body></methods><methods><class-id>Seaside.WAPlaceholderPathMatch</class-id> <category>initialization</category><body package="Seaside-REST-Core">initializeWithSourceIndex: anFirstInteger targetIndex: aSecondInteger	self initialize.	sourceIndex := anFirstInteger.	targetIndex := aSecondInteger</body></methods><methods><class-id>Seaside.WAFullPlaceholderPathMatch</class-id> <category>accessing</category><body package="Seaside-REST-Core">priority	^ 2</body></methods><methods><class-id>Seaside.WAFullPlaceholderPathMatch</class-id> <category>public</category><body package="Seaside-REST-Core">mapArgumentsWithElements: aCollection into: anArray usingOffset: anInteger	anArray		at: targetIndex		put: (aCollection at: sourceIndex + anInteger)</body></methods><methods><class-id>Seaside.WAFullPlaceholderPathMatch</class-id> <category>testing</category><body package="Seaside-REST-Core">matches: aString	^ true</body></methods><methods><class-id>Seaside.WAFullPlaceholderPathMatch class</class-id> <category>instance creation</category><body package="Seaside-REST-Core">fromString: aString index: anInteger arguments: aCollectionOfStrings	^ self		source: anInteger		target: (self			targetIndexOf: (aString copyFrom: 2 to: aString size - 1)			arguments: aCollectionOfStrings)</body><body package="Seaside-REST-Core">source: anFirstInteger target: aSecondInteger	^ self basicNew initializeWithSourceIndex: anFirstInteger targetIndex: aSecondInteger</body></methods><methods><class-id>Seaside.WARoute</class-id> <category>printing</category><body package="Seaside-REST-Core">printOn: aStream	super printOn: aStream.	aStream 		nextPutAll: ' (method: '; print: self method;		nextPutAll: ' selector: '; print: self selector;		nextPutAll: ' produces: '; print: self seasideMimeType;		nextPutAll: ' consumes: '; print: consumes;		nextPut: $)</body></methods><methods><class-id>Seaside.WARoute</class-id> <category>testing</category><body package="Seaside-REST-Core">consumes: aMimeType	^ consumes matches: aMimeType</body><body package="Seaside-REST-Core">matchesFlexibleNumberOfPathElements	self subclassResponsibility</body><body package="Seaside-REST-Core">matchesParameters: aDictionary	self subclassResponsibility</body><body package="Seaside-REST-Core">matchesPath: aCollectionOfStrings	self subclassResponsibility</body><body package="Seaside-REST-Core">produces: aCollectionOfAccept	^ aCollectionOfAccept anySatisfy: [ :each | produces matches: each value ]</body></methods><methods><class-id>Seaside.WARoute</class-id> <category>accessing</category><body package="Seaside-REST-Core">argumentCount	self subclassResponsibility</body><body package="Seaside-REST-Core">consumes	^ consumes</body><body package="Seaside-REST-Core">consumesPriorityFor: aMimeType	^ consumes priorityFor: aMimeType</body><body package="Seaside-REST-Core">method	^ method</body><body package="Seaside-REST-Core">pathElementCount	self subclassResponsibility</body><body package="Seaside-REST-Core">priority	self subclassResponsibility</body><body package="Seaside-REST-Core">producesPriorityFor: aMimeType	^ produces priorityFor: aMimeType</body><body package="Seaside-REST-Core">seasideMimeType	"Answer the value of the content-type header according to the value of &lt;consumes: &gt;.	Answer nil for missing values."	^ produces seasideMimeType</body><body package="Seaside-REST-Core">selector	^ selector</body></methods><methods><class-id>Seaside.WARoute</class-id> <category>initialization</category><body package="Seaside-REST-Core">initializeWithMethod: aString selector: aSymbol produces: aProducesMimeTypeMatch consumes: aConsumesMimeTypeMatch 	self initialize.	method := aString.	selector := aSymbol.	produces := aProducesMimeTypeMatch.	consumes := aConsumesMimeTypeMatch</body></methods><methods><class-id>Seaside.WARoute</class-id> <category>public</category><body package="Seaside-REST-Core">mapArgumentsWithElements: anStringArray parameters: aDictionary into: anArray	self subclassResponsibility</body><body package="Seaside-REST-Core">sendSelectorWith: anArrayOfArguments to: anObject	^ anObject perform: selector withArguments: anArrayOfArguments</body></methods><methods><class-id>Seaside.WARoute class</class-id> <category>instance creation</category><body package="Seaside-REST-Core">copy: aSymbol	^ WASimpleRoute method: 'COPY' selector: aSymbol</body><body package="Seaside-REST-Core">delete: aSymbol	^ WASimpleRoute method: 'DELETE' selector: aSymbol</body><body package="Seaside-REST-Core">delete: aString selector: aSymbol	^ WAComplexRoute		method: 'DELETE'		selector: aSymbol		pattern: aString</body><body package="Seaside-REST-Core">get: aSymbol	^ WASimpleRoute method: 'GET' selector: aSymbol</body><body package="Seaside-REST-Core">get: aString selector: aSymbol	^ WAComplexRoute		method: 'GET'		selector: aSymbol		pattern: aString</body><body package="Seaside-REST-Core">httpMethodNames	^ #(		COPY		DELETE		GET		MOVE		POST		PUT	)</body><body package="Seaside-REST-Core">move: aSymbol	^ WASimpleRoute method: 'MOVE' selector: aSymbol</body><body package="Seaside-REST-Core">post: aSymbol	^ WASimpleRoute method: 'POST' selector: aSymbol</body><body package="Seaside-REST-Core">post: aString selector: aSymbol	^ WAComplexRoute		method: 'POST'		selector: aSymbol		pattern: aString</body><body package="Seaside-REST-Core">put: aSymbol	^ WASimpleRoute method: 'PUT' selector: aSymbol</body><body package="Seaside-REST-Core">put: aString selector: aSymbol	^ WAComplexRoute		method: 'PUT'		selector: aSymbol		pattern: aString</body></methods><methods><class-id>Seaside.WAComplexRoute</class-id> <category>accessing</category><body package="Seaside-REST-Core">argumentCount	| count |	count := 0.	pathMatches do: [ :each |		count := count + each argumentCount ].	parameterMatches do: [ :each |		count := count + each argumentCount ].	^ count</body><body package="Seaside-REST-Core">pathElementCount	^ pathMatches size</body><body package="Seaside-REST-Core">priority	^ pathMatches inject: 0 into: [ :sum :each |		sum + each priority ]</body></methods><methods><class-id>Seaside.WAComplexRoute</class-id> <category>private</category><body package="Seaside-REST-Core">buildPathMatchesFrom: aUrl arguments: aCollectionOfStrings	| index |	index := 0.	^ aUrl path collect: [ :each |		index := index + 1.		WAPPathMatch fromString: each index: index arguments: aCollectionOfStrings ]</body><body package="Seaside-REST-Core">isOverlyComplex	^ isOverlyComplex</body><body package="Seaside-REST-Core">matchesModeratelyComplex: aCollectionOfStrings		pathMatches size = aCollectionOfStrings size		ifFalse: [ ^ false ].	pathMatches with: aCollectionOfStrings do: [ :match :each |		(match matches: each)			ifFalse: [ ^ false ] ].	^ true</body><body package="Seaside-REST-Core">matchesOverlyComplex: aCollectionOfStrings	| collectionIndex |	pathMatches size &gt; (aCollectionOfStrings size + 1)		ifTrue: [ ^ false ].		collectionIndex := 1.	pathMatches keysAndValuesDo: [ :index :each |		each matchesJustOneElement			ifTrue: [				(each matches: (aCollectionOfStrings at: collectionIndex))					ifFalse: [ ^ false ].				collectionIndex := collectionIndex + 1 ]			ifFalse: [				| matchEnd |				matchEnd := aCollectionOfStrings size - (pathMatches size - index).				collectionIndex to: matchEnd do: [ :submatchIndex |					(each matches: (aCollectionOfStrings at: submatchIndex))						ifFalse: [ ^ false ] ].				collectionIndex := matchEnd + 1 ] ].	^ true</body></methods><methods><class-id>Seaside.WAComplexRoute</class-id> <category>testing</category><body package="Seaside-REST-Core">matchesFlexibleNumberOfPathElements	^ self isOverlyComplex</body><body package="Seaside-REST-Core">matchesParameters: aDictionary	parameterMatches size = aDictionary size		ifFalse: [ ^ false ].	parameterMatches keysAndValuesDo: [ :name :match |		| value |		value := aDictionary at: name ifAbsent: [ ^ false ].		(match matchesName: name value: value)			ifFalse: [ ^ false ] ].	^ true</body><body package="Seaside-REST-Core">matchesPath: aCollectionOfStrings	^ self isOverlyComplex		ifTrue: [ self matchesOverlyComplex: aCollectionOfStrings  ]		ifFalse: [ self matchesModeratelyComplex: aCollectionOfStrings ]</body></methods><methods><class-id>Seaside.WAComplexRoute</class-id> <category>printing</category><body package="Seaside-REST-Core">printOn: aStream	super printOn: aStream.	aStream 		nextPutAll: ' (pathMatches: '; print: pathMatches;		nextPutAll: ' parameterMatches: '; print: parameterMatches;		nextPutAll: ' isOverlyComplex: '; print: self isOverlyComplex;		nextPut: $)</body></methods><methods><class-id>Seaside.WAComplexRoute</class-id> <category>public</category><body package="Seaside-REST-Core">mapArgumentsWithElements: anArrayOfStrings parameters: aDictionary into: anArray	| offset |	offset := 0.	pathMatches do: [ :each |		each matchesJustOneElement ifFalse: [			offset := anArrayOfStrings size - pathMatches size ].		each mapArgumentsWithElements: anArrayOfStrings into: anArray usingOffset: offset ].	parameterMatches do: [ :each |		each mapArgumentsWithParameters: aDictionary into: anArray ]</body></methods><methods><class-id>Seaside.WAComplexRoute</class-id> <category>initialization</category><body package="Seaside-REST-Core">initializeQueryFieldParameters: queryFields arguments: aCollectionOfStrings	queryFields		keysAndValuesDo: [ :key :value | parameterMatches at: key put: (WAParameterMatch name: key value: value arguments: aCollectionOfStrings) ]</body><body package="Seaside-REST-Core">initializeWithMethod: aString selector: aSymbol url: aUrl arguments: aCollectionOfStrings produces: aProducesMimeTypeMatch consumes: aConsumesMimeTypeMatch	self		initializeWithMethod: aString		selector: aSymbol		produces: aProducesMimeTypeMatch		consumes: aConsumesMimeTypeMatch.	pathMatches := self buildPathMatchesFrom: aUrl arguments: aCollectionOfStrings.	parameterMatches := Dictionary new.	self initializeQueryFieldParameters: aUrl queryFields arguments: aCollectionOfStrings.	isOverlyComplex := pathMatches anySatisfy: [ :each | each matchesJustOneElement not ]</body></methods><methods><class-id>Seaside.WAComplexRoute class</class-id> <category>examples</category><body package="Seaside-REST-Core">example	^ self		get: '/{3}/_all_docs?startkey={1}&amp;limit={2}'		selector: #getAllDocumentsStartingAt:limitedTo:inDatabase:</body></methods><methods><class-id>Seaside.WAComplexRoute class</class-id> <category>instance creation</category><body package="Seaside-REST-Core">method: aMethodString selector: aSymbol pattern: aPatternString	^ self		method: aMethodString		selector: aSymbol		url: (WAUrl absolute: aPatternString)		arguments: #()		produces: WAWildcardMimeTypeMatch new		consumes: WAWildcardMimeTypeMatch new</body><body package="Seaside-REST-Core">method: aMethodString selector: aSymbol pattern: aPatternString arguments: aCollectionOfStrings produces: aProducesMimeTypeMatch consumes: aConsumesMimeTypeMatch 	^ self		method: aMethodString		selector: aSymbol		url: (WAUrl absolute: aPatternString)		arguments: aCollectionOfStrings		produces: aProducesMimeTypeMatch		consumes: aConsumesMimeTypeMatch</body><body package="Seaside-REST-Core">method: aString selector: aSymbol url: aUrl arguments: aCollectionOfStrings produces: aProducesMimeTypeMatch consumes: aConsumesMimeTypeMatch	^ self basicNew		initializeWithMethod: aString		selector: aSymbol		url: aUrl		arguments: aCollectionOfStrings		produces: aProducesMimeTypeMatch		consumes: aConsumesMimeTypeMatch</body></methods><methods><class-id>Seaside.WAMimeTypeMatch</class-id> <category>testing</category><body package="Seaside-REST-Core">matches: aMimeType	self subclassResponsibility</body></methods><methods><class-id>Seaside.WAMimeTypeMatch</class-id> <category>accessing</category><body package="Seaside-REST-Core">priority	self subclassResponsibility</body><body package="Seaside-REST-Core">priorityFor: aMimeType	self subclassResponsibility</body><body package="Seaside-REST-Core">seasideMimeType	"Works only for exact matches."	^ nil</body></methods><methods><class-id>Seaside.WAMimeTypeMatch class</class-id> <category>instance creation</category><body package="Seaside-REST-Core">fromMimeType: aMimeType	^ aMimeType main = '*'		ifTrue: [			aMimeType sub = '*'				ifTrue: [ WAWildcardMimeTypeMatch new ]				ifFalse: [ WASubMimeTypeMatch					sub: aMimeType sub ] ]		ifFalse: [			aMimeType sub = '*'				ifTrue: [ WAMainMimeTypeMatch					main: aMimeType main ]				ifFalse: [ WAFullMimeTypeMatch					main: aMimeType main					sub: aMimeType sub ] ]</body><body package="Seaside-REST-Core">fromString: aString	^ self fromMimeType: (WAMimeType fromString: aString)</body></methods><methods><class-id>Seaside.WAMainMimeTypeMatch</class-id> <category>testing</category><body package="Seaside-REST-Core">matches: aMimeType	^ aMimeType main = '*' or: [ aMimeType main = main ]</body></methods><methods><class-id>Seaside.WAMainMimeTypeMatch</class-id> <category>accessing</category><body package="Seaside-REST-Core">priority	^ 2</body><body package="Seaside-REST-Core">priorityFor: aMimeType	^ aMimeType main = main			ifTrue: [ self priority ]			ifFalse: [ -1 ]</body></methods><methods><class-id>Seaside.WAMainMimeTypeMatch</class-id> <category>initialization</category><body package="Seaside-REST-Core">initializeWithMain: aMainString	self initialize.	main := aMainString</body></methods><methods><class-id>Seaside.WAMainMimeTypeMatch</class-id> <category>printing</category><body package="Seaside-REST-Core">printOn: aStream	super printOn: aStream.	aStream 		nextPutAll: ' (mimeType: '; print: (WAMimeType main: main sub: '*');		nextPutAll: ' priority: '; print: self priority;		nextPut: $)</body></methods><methods><class-id>Seaside.WAMainMimeTypeMatch class</class-id> <category>instance creation</category><body package="Seaside-REST-Core">main: aMainString	^ self basicNew initializeWithMain: aMainString</body></methods><methods><class-id>Seaside.WARestfulHandler</class-id> <category>private</category><body package="Seaside-REST-Core">createRoutes	"Creates a collection of routes for the receiver. Override this method in subclasses to explicitely create the routes instead of using the default implementation that builds the routes using annotated methods (pragmas)."	^ GRPlatform current createRoutesFrom: self class to: WARestfulHandler</body><body package="Seaside-REST-Core">isImplemented: aString	^ WARoute httpMethodNames includes: aString</body><body package="Seaside-REST-Core">routeForContext: aRequestContext ifAbsent: aNiladicBlock	^ (WAByMethodRoutes routes: self routes)		routeForContext: aRequestContext		consume: self shouldConsumePath		ifAbsent: aNiladicBlock</body><body package="Seaside-REST-Core">shouldCacheRoutes	"Answer a boolean if the routes should be cached by the receiver."	^ false</body><body package="Seaside-REST-Core">shouldConsumePath	"Answer whether the request path should be consumed if a route is found."	^ true</body></methods><methods><class-id>Seaside.WARestfulHandler</class-id> <category>handling</category><body package="Seaside-REST-Core">executeResult: aRouteResult	| requestContext |	requestContext := self requestContext.	requestContext respond: [ :response |		| mimeType |		mimeType := aRouteResult seasideMimeType.		mimeType isNil			ifTrue: [				response					document: (aRouteResult sendMessageTo: self) ]			ifFalse: [				mimeType isBinary ifFalse: [					"defensive copy because we modify"					mimeType := mimeType copy.					mimeType charset: requestContext charSet ].				response					document: (aRouteResult sendMessageTo: self)					mimeType: mimeType ] ]</body><body package="Seaside-REST-Core">handleFiltered: aRequestContext	self executeResult: (self		routeForContext: aRequestContext		ifAbsent: [ self noRouteFound: aRequestContext ])</body><body package="Seaside-REST-Core">noRouteFound: aRequestContext	aRequestContext responseGenerator		notFound;		respond</body></methods><methods><class-id>Seaside.WARestfulHandler</class-id> <category>accessing</category><body package="Seaside-REST-Core">routes	"Answer a collection of routes for the receiver."	^ self shouldCacheRoutes		ifTrue: [  routes ifNil: [ routes := self createRoutes ] ]		ifFalse: [			"Issue 785			even assign when they should not be cached to better support recaching"			routes := self createRoutes ]</body></methods><methods><class-id>Seaside.WAParameterMatch</class-id> <category>accessing</category><body package="Seaside-REST-Core">argumentCount	self subclassResponsibility</body></methods><methods><class-id>Seaside.WAParameterMatch</class-id> <category>testing</category><body package="Seaside-REST-Core">matchesName: aNameString value: aValueString	self subclassResponsibility</body></methods><methods><class-id>Seaside.WAParameterMatch</class-id> <category>initialization</category><body package="Seaside-REST-Core">initializeWithName: aString	self initialize.	name := aString</body></methods><methods><class-id>Seaside.WAParameterMatch</class-id> <category>public</category><body package="Seaside-REST-Core">mapArgumentsWithParameters: aDictionary into: anArray	self subclassResponsibility</body></methods><methods><class-id>Seaside.WAParameterMatch class</class-id> <category>instance creation</category><body package="Seaside-REST-Core">name: aKeyString value: aValueString arguments: aCollectionOfStrings 	^ ((self isPattern: aValueString)		ifTrue: [ WAPlaceholderParameterMatch ]		ifFalse: [ WAExactParameterMatch ]) name: aKeyString value: aValueString arguments: aCollectionOfStrings</body></methods><methods><class-id>Seaside.WAParameterMatch class</class-id> <category>private</category><body package="Seaside-REST-Core">isPattern: aString	^ aString isEmpty not		and: [ aString first = ${		and: [ aString last = $} ] ]</body></methods><methods><class-id>Seaside.WAPlaceholderParameterMatch</class-id> <category>accessing</category><body package="Seaside-REST-Core">argumentCount	^ 1</body><body package="Seaside-REST-Core">index	^ index</body></methods><methods><class-id>Seaside.WAPlaceholderParameterMatch</class-id> <category>testing</category><body package="Seaside-REST-Core">matchesName: aNameString value: aValueString	^ name = aNameString</body></methods><methods><class-id>Seaside.WAPlaceholderParameterMatch</class-id> <category>initialization</category><body package="Seaside-REST-Core">initializeWithName: aString index: anInteger	self initializeWithName: aString.	index := anInteger</body></methods><methods><class-id>Seaside.WAPlaceholderParameterMatch</class-id> <category>public</category><body package="Seaside-REST-Core">mapArgumentsWithParameters: aDictionary into: anArray	anArray at: index put: (aDictionary at: name)</body></methods><methods><class-id>Seaside.WAPlaceholderParameterMatch class</class-id> <category>instance creation</category><body package="Seaside-REST-Core">name: aString index: anInteger	^ self basicNew initializeWithName: aString index: anInteger</body><body package="Seaside-REST-Core">name: aNameString value: aValueString arguments: aCollectionOfStrings	^ self		name: aNameString		index: (self			targetIndexOf: (aValueString copyFrom: 2 to: aValueString size - 1)			arguments: aCollectionOfStrings)</body></methods><methods><class-id>Seaside.WAWildcardMimeTypeMatch</class-id> <category>accessing</category><body package="Seaside-REST-Core">priority	^ 1</body><body package="Seaside-REST-Core">priorityFor: aMimeType	^ self priority</body></methods><methods><class-id>Seaside.WAWildcardMimeTypeMatch</class-id> <category>testing</category><body package="Seaside-REST-Core">matches: aMimeType	^ true</body></methods><methods><class-id>Seaside.WAWildcardMimeTypeMatch</class-id> <category>printing</category><body package="Seaside-REST-Core">printOn: aStream	super printOn: aStream.	aStream 		nextPutAll: ' (mimeType: '; print: (WAMimeType main: '*' sub: '*');		nextPutAll: ' priority: '; print: self priority;		nextPut: $)</body></methods><methods><class-id>Seaside.WARestfulFilter</class-id> <category>handling</category><body package="Seaside-REST-Core">executeResult: aRouteResult	| requestContext |	requestContext := self requestContext.	requestContext respond: [ :response |		| mimeType |		mimeType := aRouteResult seasideMimeType.		mimeType isNil			ifTrue: [				response					document: (aRouteResult sendMessageTo: self) ]			ifFalse: [				mimeType isBinary ifFalse: [					"defensive copy because we modify"					mimeType := mimeType copy.					mimeType charset: requestContext charSet ].				response					document: (aRouteResult sendMessageTo: self)					mimeType: mimeType ] ]</body><body package="Seaside-REST-Core">noRouteFound: aRequestContext	super handleFiltered: aRequestContext</body></methods><methods><class-id>Seaside.WARestfulFilter</class-id> <category>private</category><body package="Seaside-REST-Core">createRoutes	"Creates a collection of routes for the receiver. Override this method in subclasses to explicitely create the routes instead of using the default implementation that builds the routes using annotated methods (pragmas)."	^ GRPlatform current createRoutesFrom: self class to: WARestfulFilter</body><body package="Seaside-REST-Core">isImplemented: aString	^ WARoute httpMethodNames includes: aString</body><body package="Seaside-REST-Core">routeForContext: aRequestContext ifAbsent: aNiladicBlock	^ (WAByMethodRoutes routes: self routes)		routeForContext: aRequestContext		consume: self shouldConsumePath		ifAbsent: aNiladicBlock</body><body package="Seaside-REST-Core">shouldCacheRoutes	"Answer a boolean if the routes should be cached by the receiver."	^ false</body><body package="Seaside-REST-Core">shouldConsumePath	"Answer whether the request path should be consumed if a route is found."	^ false</body></methods><methods><class-id>Seaside.WARestfulFilter</class-id> <category>processing</category><body package="Seaside-REST-Core">handleFiltered: aRequestContext	self executeResult: (self		routeForContext: aRequestContext		ifAbsent: [ self noRouteFound: aRequestContext ])</body></methods><methods><class-id>Seaside.WARestfulFilter</class-id> <category>accessing</category><body package="Seaside-REST-Core">routes	"Answer a collection of routes for the receiver."	^ self shouldCacheRoutes		ifTrue: [  routes ifNil: [ routes := self createRoutes ] ]		ifFalse: [			"Issue 785			even assign when they should not be cached to better support recaching"			routes := self createRoutes ]</body></methods><methods><class-id>Seaside.WARestfulComponentFilter</class-id> <category>public</category><body package="Seaside-REST-Core">startSessionWithRoot: aComponent	| context |	context := self requestContext.	context rootComponent: aComponent.	self next handleFiltered: context</body></methods><methods><class-id>Seaside.WARestfulComponentFilter</class-id> <category>processing</category><body package="Seaside-REST-Core">handleFiltered: aRequestContext	(self hasSession: aRequestContext)		ifTrue: [			"evetually let the application handle the request"			self next handleFiltered: aRequestContext ]		ifFalse: [			"search for a route"			super handleFiltered: aRequestContext ]</body></methods><methods><class-id>Seaside.WARestfulComponentFilter</class-id> <category>private</category><body package="Seaside-REST-Core">hasSession: aRequestContext	| handler key |	handler := self handler.	key := handler trackingStrategy keyFromContext: aRequestContext.	^ key notNil and: [		"make sure the session is not expired"		(handler cache at: key ifAbsent: [ nil ]) notNil ]</body></methods><methods><class-id>Seaside.WAByMethodRoutes</class-id> <category>private</category><body package="Seaside-REST-Core">addRoute: aRoute to: aDictionary	| methodRoutes subRoutes |	methodRoutes := aDictionary		at: aRoute method		ifAbsentPut: [ Dictionary new ].	subRoutes := methodRoutes at: aRoute pathElementCount ifAbsentPut: [ OrderedCollection new ].	subRoutes add: aRoute</body><body package="Seaside-REST-Core">buildContainers: aDictionary	| result |	result := Dictionary new.	aDictionary keysAndValuesDo: [ :method :subroutes |		| methodRoutes |		methodRoutes := result			at: method			ifAbsentPut: [				SortedCollection sortBlock: [ :a :b |					a pathElementCount &lt;= b pathElementCount ] ].		subroutes do: [ :each |			methodRoutes add: (WARouteContainer routes: each) ] ].	^ result</body><body package="Seaside-REST-Core">fixedRoutesForContext: aRequestContext	| elementCount routesForMethod |	elementCount := aRequestContext consumer peekToEnd size.	routesForMethod := fixedContainers at: aRequestContext request method ifAbsent: [ ^ nil ].	^ routesForMethod		detect: [ :each |			each pathElementCount = elementCount ]		ifNone: [ nil ]</body><body package="Seaside-REST-Core">flexibleRoutesForContext: aRequestContext	| elementCount routesForMethod startIndex endIndex |	elementCount := aRequestContext consumer peekToEnd size.	startIndex := nil.	routesForMethod := flexibleContainers at: aRequestContext request method ifAbsent: [ ^ nil ].	routesForMethod keysAndValuesDo: [ :index :each |		(each pathElementCount &gt;= (elementCount - 1) and: [ startIndex isNil ])			ifTrue: [ startIndex := index ].		(each pathElementCount &gt; elementCount and: [ endIndex notNil ])			ifTrue: [ endIndex := index ] ].	startIndex isNil		ifTrue: [ ^ nil ].	endIndex isNil		ifTrue: [ endIndex := routesForMethod size ].	^ routesForMethod copyFrom: startIndex to: endIndex</body><body package="Seaside-REST-Core">mergedRoutesForContext: aRequestContext	| routes fixed flexibles |	routes := OrderedCollection new.	fixed := self fixedRoutesForContext: aRequestContext.	fixed isNil ifFalse: [		routes add: fixed ].	flexibles := self flexibleRoutesForContext: aRequestContext.	flexibles isNil ifFalse: [		routes addAll: flexibles ].	routes isEmpty		ifTrue: [ ^ nil ].	routes size = 1		ifTrue: [ ^ routes first ].	^ WARouteContainer routes: (routes gather: [ :each | each routes ])</body><body package="Seaside-REST-Core">privateRouteForContext: aRequestContext ifAbsent: aNiladicBlock	| routeContainer parameters elements |	routeContainer := self mergedRoutesForContext: aRequestContext.	routeContainer isNil		ifTrue: [ ^ aNiladicBlock value ].	parameters := aRequestContext request url queryFields.	elements := aRequestContext consumer peekToEnd.	^ WARouteResult		route: (routeContainer			routeForElements: elements			parameters: parameters			contentType: aRequestContext request contentType 			accept: aRequestContext request accept			ifAbsent: [ ^ aNiladicBlock value ])		elements: elements		parameters: parameters</body></methods><methods><class-id>Seaside.WAByMethodRoutes</class-id> <category>initialization</category><body package="Seaside-REST-Core">initializeWithRoutes: aCollectionOfRoutes	| standardRouteBuilder flexibleRouteBuilder |	self initialize.	standardRouteBuilder := Dictionary new.	flexibleRouteBuilder := Dictionary new.	aCollectionOfRoutes do: [ :each |		each matchesFlexibleNumberOfPathElements			ifTrue: [ self addRoute: each to: flexibleRouteBuilder ]			ifFalse: [ self addRoute: each to: standardRouteBuilder ] ].	fixedContainers := self buildContainers: standardRouteBuilder.	flexibleContainers := self buildContainers: flexibleRouteBuilder</body></methods><methods><class-id>Seaside.WAByMethodRoutes</class-id> <category>public</category><body package="Seaside-REST-Core">routeForContext: aRequestContext consume: aBoolean ifAbsent: aNiladicBlock	| found result |	found := true.	result := self		privateRouteForContext: aRequestContext		ifAbsent: [			found := false.			aNiladicBlock value ].	(found and: [ aBoolean ]) ifTrue: [		"we found something this means we consume the entire path"		aRequestContext consumer upToEnd ].	^ result</body></methods><methods><class-id>Seaside.WAByMethodRoutes class</class-id> <category>instance creation</category><body package="Seaside-REST-Core">routes: aCollectionOfRoutes	^ self basicNew initializeWithRoutes: aCollectionOfRoutes</body></methods><methods><class-id>Seaside.WASimpleRoute</class-id> <category>accessing</category><body package="Seaside-REST-Core">argumentCount	^ self pathElementCount</body><body package="Seaside-REST-Core">pathElementCount	^ count</body><body package="Seaside-REST-Core">priority	^ self pathElementCount</body></methods><methods><class-id>Seaside.WASimpleRoute</class-id> <category>public</category><body package="Seaside-REST-Core">mapArgumentsWithElements: anStringArray parameters: aDictionary into: anArray	1 to: self argumentCount do: [ :index |		anArray at: index put: (anStringArray at: index) ]</body></methods><methods><class-id>Seaside.WASimpleRoute</class-id> <category>initialization</category><body package="Seaside-REST-Core">initializeWithMethod: aString count: anInteger selector: aSymbol produces: aProducesMimeTypeMatch consumes: aConsumesMimeTypeMatch 	self initializeWithMethod: aString selector: aSymbol produces: aProducesMimeTypeMatch consumes: aConsumesMimeTypeMatch .	count := anInteger</body></methods><methods><class-id>Seaside.WASimpleRoute</class-id> <category>testing</category><body package="Seaside-REST-Core">matchesFlexibleNumberOfPathElements	^ false</body><body package="Seaside-REST-Core">matchesParameters: aDictionary	^ aDictionary isEmpty</body><body package="Seaside-REST-Core">matchesPath: aCollectionOfStrings	^ self pathElementCount = aCollectionOfStrings size</body></methods><methods><class-id>Seaside.WASimpleRoute class</class-id> <category>instance creation</category><body package="Seaside-REST-Core">method: aString selector: aSymbol	^ self		method: aString		selector: aSymbol		produces: WAWildcardMimeTypeMatch new		consumes: WAWildcardMimeTypeMatch new</body><body package="Seaside-REST-Core">method: aString selector: aSymbol produces: aProducesMimeTypeMatch consumes: aConsumesMimeTypeMatch	"Can't send #count: in VAST"	| count |	count := 0.	aSymbol do: [ :each |		each = $: 			ifTrue: [ count := count + 1 ] ].	^ self basicNew		initializeWithMethod: aString		count: count		selector: aSymbol		produces: aProducesMimeTypeMatch		consumes: aConsumesMimeTypeMatch</body></methods><methods><class-id>Seaside.WASubMimeTypeMatch</class-id> <category>accessing</category><body package="Seaside-REST-Core">priority	^ 2</body><body package="Seaside-REST-Core">priorityFor: aMimeType	^ aMimeType sub = sub			ifTrue: [ self priority ]			ifFalse: [ -1 ]</body></methods><methods><class-id>Seaside.WASubMimeTypeMatch</class-id> <category>testing</category><body package="Seaside-REST-Core">matches: aMimeType	^ aMimeType sub = '*' or: [ aMimeType sub = sub ]</body></methods><methods><class-id>Seaside.WASubMimeTypeMatch</class-id> <category>printing</category><body package="Seaside-REST-Core">printOn: aStream	super printOn: aStream.	aStream 		nextPutAll: ' (mimeType: '; print: (WAMimeType main: '*' sub: sub);		nextPutAll: ' priority: '; print: self priority;		nextPut: $)</body></methods><methods><class-id>Seaside.WASubMimeTypeMatch</class-id> <category>initialization</category><body package="Seaside-REST-Core">initializeWithSub: aSubString	self initialize.	sub := aSubString</body></methods><methods><class-id>Seaside.WASubMimeTypeMatch class</class-id> <category>instance creation</category><body package="Seaside-REST-Core">sub: aSubString	^ self basicNew initializeWithSub: aSubString</body></methods><methods><class-id>Seaside.WAOrPathMatch</class-id> <category>testing</category><body package="Seaside-REST-Core">matches: aString	^ elements includes: aString</body></methods><methods><class-id>Seaside.WAOrPathMatch</class-id> <category>accessing</category><body package="Seaside-REST-Core">argumentCount	^ 0</body><body package="Seaside-REST-Core">priority	^ 3</body></methods><methods><class-id>Seaside.WAOrPathMatch</class-id> <category>public</category><body package="Seaside-REST-Core">mapArgumentsWithElements: aCollection into: anArray usingOffset: anInteger	"ignore"</body></methods><methods><class-id>Seaside.WAOrPathMatch</class-id> <category>initialization</category><body package="Seaside-REST-Core">inititializeWith: aString	self initialize.	elements := aString substrings: '|'.	"cut off leading $[ from first"	elements at: 1 put: (elements first allButFirst).	"cut off trailing $] from first"	elements at: elements size put: (elements last allButLast)</body></methods><methods><class-id>Seaside.WAOrPathMatch class</class-id> <category>instance creation</category><body package="Seaside-REST-Core">fromString: aString	^ self basicNew inititializeWith: aString</body><body package="Seaside-REST-Core">fromString: aString index: anInteger arguments: aCollectionOfStrings	^ self fromString: aString</body></methods><methods><class-id>Seaside.WARouteBuilder</class-id> <category>private</category><body package="Seaside-REST-Core">create	^ path isNil		ifTrue: [ self createSimpleRoute ]		ifFalse: [ 			variableQuery				ifTrue: [ self createVariableQueryRoute ]				ifFalse: [ self createComplexRoute ] ]</body><body package="Seaside-REST-Core">createComplexRoute	^ WAComplexRoute		method: method selector: compiled selector pattern: path		arguments: (GRPlatform current argumentNamesOf: compiled)		produces: produces		consumes: (self createMimeTypeMatch: consumes)</body><body package="Seaside-REST-Core">createMimeTypeMatch: aCollection	^ aCollection isEmpty		ifTrue: [ WAWildcardMimeTypeMatch new ]		ifFalse: [			aCollection size = 1				ifTrue: [ aCollection first ]				ifFalse: [ WACompositeMimeTypeMatch matches: aCollection ] ]</body><body package="Seaside-REST-Core">createSimpleRoute	^ WASimpleRoute		method: method		selector: compiled selector		produces: produces		consumes: (self createMimeTypeMatch: consumes)</body><body package="Seaside-REST-Core">createVariableQueryRoute	^ WAVariableQueryRoute		method: method		selector: compiled selector		pattern: path		arguments: (GRPlatform current argumentNamesOf: compiled)		produces: produces		consumes: (self createMimeTypeMatch: consumes)</body></methods><methods><class-id>Seaside.WARouteBuilder</class-id> <category>initialization</category><body package="Seaside-REST-Core">initializeOn: aCompiledMethod	self initialize.	compiled := aCompiledMethod.	method := 'GET'.	variableQuery := false.	path := aCompiledMethod selector greaseString.	consumes := OrderedCollection new.	produces := WAWildcardMimeTypeMatch new</body></methods><methods><class-id>Seaside.WARouteBuilder class</class-id> <category>initialization</category><body package="Seaside-REST-Core">initialize	configuration := IdentitySet new.	(Pragma allNamed: #configuration in: self)		do: [ :pragma | configuration add: pragma selector ]</body></methods><methods><class-id>Seaside.WARouteBuilder class</class-id> <category>public</category><body package="Seaside-REST-Core">createRoutesFor: aClass	^ self createRoutesFrom: aClass to: aClass</body><body package="Seaside-REST-Core">createRoutesFrom: aClass to: aSuperClass	| current seen routes |	current := aClass.	seen := IdentitySet new.	routes := OrderedCollection new.	[ current notNil ] whileTrue: [ 		current selectorsAndMethodsDo: [ :selector :method |			(seen includes: selector) ifFalse: [				| pragmas |				pragmas := method pragmas					select: [ :pragma | configuration includes: pragma keyword ].				pragmas isEmpty ifFalse: [					routes add: (pragmas						inject: (self on: method)						into: [ :builder :pragma | builder perform: pragma keyword withArguments: pragma arguments ])							create ].				seen add: selector ] ].		current = aSuperClass			ifTrue: [ ^ routes ].		current := current superclass ].	^ routes</body></methods><methods><class-id>Seaside.WARouteBuilder class</class-id> <category>instance creation</category><body package="Seaside-REST-Core">on: aCompiledMethod	^ self basicNew initializeOn: aCompiledMethod</body></methods><methods><class-id>Seaside.WACompositeMimeTypeMatch</class-id> <category>accessing</category><body package="Seaside-REST-Core">priorityFor: aMimeType	| matched |	matched := matches select: [ :each | each matches: aMimeType ].	matched isEmpty		ifTrue: [ ^ -1 ].	matched sort: [ :a :b |		a priority &lt;= b priority ].	^ matched last priority</body><body package="Seaside-REST-Core">seasideMimeType	"We don't know which one to take."	^ nil</body></methods><methods><class-id>Seaside.WACompositeMimeTypeMatch</class-id> <category>initialization</category><body package="Seaside-REST-Core">initializeWithMatches: aCollection	self initialize.	matches := aCollection</body></methods><methods><class-id>Seaside.WACompositeMimeTypeMatch</class-id> <category>testing</category><body package="Seaside-REST-Core">matches: aMimeType	^ matches anySatisfy: [ :each | each matches: aMimeType ]</body></methods><methods><class-id>Seaside.WACompositeMimeTypeMatch class</class-id> <category>instance creation</category><body package="Seaside-REST-Core">matches: aCollection	^ self basicNew initializeWithMatches: aCollection</body></methods><methods><class-id>Seaside.WAPrefixPlaceholderPathMatch</class-id> <category>accessing</category><body package="Seaside-REST-Core">priority	^ 3</body></methods><methods><class-id>Seaside.WAPrefixPlaceholderPathMatch</class-id> <category>testing</category><body package="Seaside-REST-Core">matches: aString	^ (aString size &gt; prefix size)		and: [ aString beginsWithSubCollection: prefix ]</body></methods><methods><class-id>Seaside.WAPrefixPlaceholderPathMatch</class-id> <category>public</category><body package="Seaside-REST-Core">mapArgumentsWithElements: aCollection into: anArray usingOffset: anInteger	| value |	value := aCollection at: sourceIndex + anInteger.	anArray		at: targetIndex		put: (value copyFrom: prefix size + 1 to: value size)</body></methods><methods><class-id>Seaside.WAPrefixPlaceholderPathMatch</class-id> <category>initialization</category><body package="Seaside-REST-Core">initializeWithSourceIndex: anFirstInteger targetIndex: aSecondInteger prefix: aString	self initializeWithSourceIndex: anFirstInteger targetIndex: aSecondInteger.	prefix := aString</body></methods><methods><class-id>Seaside.WAPrefixPlaceholderPathMatch class</class-id> <category>instance creation</category><body package="Seaside-REST-Core">fromString: aString index: anInteger arguments: aCollectionOfStrings	| prefix |	prefix := aString copyUpTo: ${.	^ self		source: anInteger		target: (self			targetIndexOf: (aString copyFrom: prefix size + 2 to: aString size - 1)			arguments: aCollectionOfStrings)		prefix: prefix</body><body package="Seaside-REST-Core">source: anFirstInteger target: aSecondInteger prefix: aString	^ self basicNew		initializeWithSourceIndex: anFirstInteger		targetIndex: aSecondInteger		prefix: aString</body></methods><methods><class-id>Seaside.WARouteContainer</class-id> <category>private</category><body package="Seaside-REST-Core">compare: a and: b byAccept: aSortedCollectionOfAccept	^ self compare: a and: b using: aSortedCollectionOfAccept</body><body package="Seaside-REST-Core">compare: a and: b byContentType: aMimeType thenByAccept: aSortedCollectionOfAccept	| aPriority bPriority |	aPriority := a consumesPriorityFor: aMimeType.	bPriority := b consumesPriorityFor: aMimeType.	^ aPriority ~= bPriority		ifTrue: [ aPriority &lt; bPriority ifTrue: [ -1 ] ifFalse: [ 1 ] ]		ifFalse: [			aSortedCollectionOfAccept isEmpty				ifTrue: [ 0 "both are equal" ]				ifFalse: [ self compare: a and: b byAccept: aSortedCollectionOfAccept ] ]</body><body package="Seaside-REST-Core">compare: a and: b using: aSortedCollectionOfAccept	aSortedCollectionOfAccept acceptsDo: [ :accepts |		| aPriority bPriority |		aPriority := -1.		bPriority := -1.		accepts do: [ :each |			aPriority := aPriority max: (a producesPriorityFor: each).			bPriority := bPriority max: (b producesPriorityFor: each) ].		aPriority ~= bPriority			ifTrue: [				^ aPriority &lt; bPriority ifTrue: [ -1 ] ifFalse: [ 1 ] ] ].	^ 0 "both are equal"</body><body package="Seaside-REST-Core">compareByPathThenContentType: aMimeType thenByAccept: aSortedCollectionOfAccept	^ [ :a :b |		| aPathPriority bPathPriority |		aPathPriority := a priority.		bPathPriority := b priority.		(aPathPriority ~= bPathPriority or: [ aMimeType isNil and: [ aSortedCollectionOfAccept isNil ] ])			ifTrue: [ aPathPriority &lt; bPathPriority ifTrue: [ -1 ] ifFalse: [ 1 ] ]			ifFalse: [				aMimeType isNil					ifTrue: [ self compare: a and: b byAccept: aSortedCollectionOfAccept ]					ifFalse: [ self compare: a and: b byContentType: aMimeType thenByAccept: aSortedCollectionOfAccept ] ] ]</body><body package="Seaside-REST-Core">sortByPathThenContentType: aMimeType thenByAccept: aSortedCollectionOfAccept	| block |	block := self compareByPathThenContentType: aMimeType thenByAccept: aSortedCollectionOfAccept.	^ [ :a :b |		(block value: a value: b) = 1 ]</body></methods><methods><class-id>Seaside.WARouteContainer</class-id> <category>public</category><body package="Seaside-REST-Core">addRoute: aRoute	^ routes add: aRoute</body><body package="Seaside-REST-Core">addRoutes: aCollectionOfRoutes	aCollectionOfRoutes do: [ :each |		self addRoute: each ]</body><body package="Seaside-REST-Core">pathElementCount	^ pathElementCount</body><body package="Seaside-REST-Core">routeForElements: aCollection parameters: aDictionary contentType: aMimeType accept: aCollectionOfAccept ifAbsent: anAbsentBlock	| result sortedAccept |	result := (routes select: [ :each |			(each matchesPath: aCollection)				and: [ (each matchesParameters: aDictionary)				and: [ (aMimeType isNil or: [ each consumes: aMimeType ])				and: [ aCollectionOfAccept isNil or: [ each produces: aCollectionOfAccept ] ] ] ] ]) asArray.	result isEmpty		ifTrue: [ ^ anAbsentBlock value ].	result size = 1		ifTrue: [ ^ result first ].	sortedAccept := WASortedAccepts accepts: aCollectionOfAccept.	result sort: (self sortByPathThenContentType: aMimeType thenByAccept: sortedAccept).		"when the first and second highest priority match have the same priority we have an conflict"	^ ((self compareByPathThenContentType: aMimeType thenByAccept: sortedAccept) value: result first value: result second) = 0		ifTrue: [ anAbsentBlock value ]		ifFalse: [ result first ]</body><body package="Seaside-REST-Core">routes	^ routes</body></methods><methods><class-id>Seaside.WARouteContainer</class-id> <category>initialization</category><body package="Seaside-REST-Core">initializeWith: anInteger	self initialize.	pathElementCount := anInteger.	routes := SortedCollection sortBlock: [ :a :b |		a priority &gt; b priority ]</body></methods><methods><class-id>Seaside.WARouteContainer class</class-id> <category>instance creation</category><body package="Seaside-REST-Core">pathElementCount: anInteger	^ self basicNew initializeWith: anInteger</body><body package="Seaside-REST-Core">routes: aCollectionOfRoutes	^ (self pathElementCount: aCollectionOfRoutes first pathElementCount)		addRoutes: aCollectionOfRoutes;		yourself</body></methods><methods><class-id>Seaside.WAFullMimeTypeMatch</class-id> <category>testing</category><body package="Seaside-REST-Core">matches: aMimeType	^ (aMimeType main = '*'		or: [ aMimeType main = main ])		and: [			aMimeType sub = '*'				or: [ aMimeType sub = sub ] ]</body></methods><methods><class-id>Seaside.WAFullMimeTypeMatch</class-id> <category>initialization</category><body package="Seaside-REST-Core">initializeWithMain: aMainString sub: aSubString	self initialize.	main := aMainString.	sub := aSubString</body></methods><methods><class-id>Seaside.WAFullMimeTypeMatch</class-id> <category>accessing</category><body package="Seaside-REST-Core">priority	^ 3</body><body package="Seaside-REST-Core">priorityFor: aMimeType	^ (aMimeType main = main		and: [ aMimeType sub = sub ])			ifTrue: [ self priority ]			ifFalse: [ -1 ]</body><body package="Seaside-REST-Core">seasideMimeType	^ WAMimeType main: main sub: sub</body></methods><methods><class-id>Seaside.WAFullMimeTypeMatch</class-id> <category>printing</category><body package="Seaside-REST-Core">printOn: aStream	super printOn: aStream.	aStream 		nextPutAll: ' (mimeType: '; print: self seasideMimeType;		nextPutAll: ' priority: '; print: self priority;		nextPut: $)</body></methods><methods><class-id>Seaside.WAFullMimeTypeMatch class</class-id> <category>instance creation</category><body package="Seaside-REST-Core">main: aMainString sub: aSubString	^ self basicNew initializeWithMain: aMainString sub: aSubString</body></methods><methods><class-id>Seaside.WASortedAccepts</class-id> <category>testing</category><body package="Seaside-REST-Core">isEmpty	^ accepts isEmpty</body></methods><methods><class-id>Seaside.WASortedAccepts</class-id> <category>initialization</category><body package="Seaside-REST-Core">acceptsDo: aOneArgumentBlock	| sortedKeys |	sortedKeys := accepts keys sorted: [ :a :b | a &gt; b ].	sortedKeys do: [ :each |		aOneArgumentBlock value: (accepts allAt: each) ]</body><body package="Seaside-REST-Core">initializeWithAccepts: aCollectionOfAccepts	self initialize.	accepts := GROrderedMultiMap new.	aCollectionOfAccepts isNil ifFalse: [		aCollectionOfAccepts do: [ :each |			accepts at: each quality add: each value ] ]</body></methods><methods><class-id>Seaside.WASortedAccepts class</class-id> <category>instance creation</category><body package="Seaside-REST-Core">accepts: aCollectionOfAccepts	^ self basicNew initializeWithAccepts: aCollectionOfAccepts</body></methods><methods><class-id>Seaside.WAExactPathMatch</class-id> <category>accessing</category><body package="Seaside-REST-Core">argumentCount	^ 0</body><body package="Seaside-REST-Core">priority	^ 3</body></methods><methods><class-id>Seaside.WAExactPathMatch</class-id> <category>testing</category><body package="Seaside-REST-Core">matches: aString	^ element = aString</body></methods><methods><class-id>Seaside.WAExactPathMatch</class-id> <category>initialization</category><body package="Seaside-REST-Core">inititializeWith: aString	self initialize.	element := aString</body></methods><methods><class-id>Seaside.WAExactPathMatch</class-id> <category>public</category><body package="Seaside-REST-Core">mapArgumentsWithElements: aCollection into: anArray usingOffset: anInteger	"ignore"</body></methods><methods><class-id>Seaside.WAExactPathMatch class</class-id> <category>instance creation</category><body package="Seaside-REST-Core">fromString: aString	^ self basicNew inititializeWith: aString</body><body package="Seaside-REST-Core">fromString: aString index: anInteger arguments: aCollectionOfStrings	^ self fromString: aString</body></methods><methods><class-id>Seaside.WARouteResult</class-id> <category>public</category><body package="Seaside-REST-Core">sendMessageTo: anObject	| arguments |	arguments := Array new: route argumentCount.	route mapArgumentsWithElements: elements parameters: parameters into: arguments.	^ route		sendSelectorWith: arguments		to: anObject</body></methods><methods><class-id>Seaside.WARouteResult</class-id> <category>accessing</category><body package="Seaside-REST-Core">elements	^ elements</body><body package="Seaside-REST-Core">route	^ route</body><body package="Seaside-REST-Core">seasideMimeType	"Answer the value of the content-type header according to the value of &lt;consumes: &gt;.	Answer nil for missing values."	^ route seasideMimeType</body></methods><methods><class-id>Seaside.WARouteResult</class-id> <category>initialization</category><body package="Seaside-REST-Core">initializeWithRoute: aRoute elements: anArray parameters: aDictionary	self initialize.	route := aRoute.	elements := anArray.	parameters := aDictionary</body></methods><methods><class-id>Seaside.WARouteResult class</class-id> <category>instance creation</category><body package="Seaside-REST-Core">route: aRoute elements: anArray parameters: aDictionary	^ self basicNew initializeWithRoute: aRoute elements: anArray parameters: aDictionary</body></methods><methods><class-id>Seaside.WASuffixPlaceholderPathMatch</class-id> <category>testing</category><body package="Seaside-REST-Core">matches: aString	^ (aString size &gt; suffix size)		and: [ aString endsWithSubCollection: suffix ]</body></methods><methods><class-id>Seaside.WASuffixPlaceholderPathMatch</class-id> <category>accessing</category><body package="Seaside-REST-Core">priority	^ 3</body></methods><methods><class-id>Seaside.WASuffixPlaceholderPathMatch</class-id> <category>initialization</category><body package="Seaside-REST-Core">initializeWithSourceIndex: anFirstInteger targetIndex: aSecondInteger suffix: aString	self initializeWithSourceIndex: anFirstInteger targetIndex: aSecondInteger.	suffix := aString</body></methods><methods><class-id>Seaside.WASuffixPlaceholderPathMatch</class-id> <category>public</category><body package="Seaside-REST-Core">mapArgumentsWithElements: aCollection into: anArray usingOffset: anInteger	| value |	value := aCollection at: sourceIndex + anInteger.	anArray		at: targetIndex		put: (value copyFrom: 1 to: value size - suffix size)</body></methods><methods><class-id>Seaside.WASuffixPlaceholderPathMatch class</class-id> <category>instance creation</category><body package="Seaside-REST-Core">fromString: aString index: anInteger arguments: aCollectionOfStrings	| suffix |	suffix := aString copyAfter: $}.	^ self		source: anInteger		target: (self			targetIndexOf: (aString copyFrom: 2 to: aString size - suffix size - 1)			arguments: aCollectionOfStrings)		suffix: suffix</body><body package="Seaside-REST-Core">source: anFirstInteger target: aSecondInteger suffix: aString	^ self basicNew		initializeWithSourceIndex: anFirstInteger		targetIndex: aSecondInteger		suffix: aString</body></methods><methods><class-id>Seaside.WAMultiPlaceholderPathMatch</class-id> <category>testing</category><body package="Seaside-REST-Core">matches: aString	^ true</body><body package="Seaside-REST-Core">matchesJustOneElement	^ false</body></methods><methods><class-id>Seaside.WAMultiPlaceholderPathMatch</class-id> <category>public</category><body package="Seaside-REST-Core">mapArgumentsWithElements: aCollection into: anArray usingOffset: anInteger	anArray		at: targetIndex		put: (aCollection copyFrom: sourceIndex to: sourceIndex + anInteger)</body></methods><methods><class-id>Seaside.WAMultiPlaceholderPathMatch</class-id> <category>accessing</category><body package="Seaside-REST-Core">priority	^ 1</body></methods><methods><class-id>Seaside.WAMultiPlaceholderPathMatch class</class-id> <category>instance creation</category><body package="Seaside-REST-Core">fromString: aString index: anInteger arguments: aCollectionOfStrings	^ self		source: anInteger		target: (self			targetIndexOf: (aString copyFrom: 2 to: aString size - 1)			arguments: aCollectionOfStrings)</body><body package="Seaside-REST-Core">source: anFirstInteger target: aSecondInteger	^ self basicNew initializeWithSourceIndex: anFirstInteger targetIndex: aSecondInteger</body></methods><methods><class-id>Seaside.WAExactParameterMatch</class-id> <category>testing</category><body package="Seaside-REST-Core">matchesName: aNameString value: aValueString	^ name = aNameString and: [ value = aValueString ]</body></methods><methods><class-id>Seaside.WAExactParameterMatch</class-id> <category>public</category><body package="Seaside-REST-Core">mapArgumentsWithParameters: aDictionary into: anArray	"ignore"</body></methods><methods><class-id>Seaside.WAExactParameterMatch</class-id> <category>accessing</category><body package="Seaside-REST-Core">argumentCount	^ 0</body></methods><methods><class-id>Seaside.WAExactParameterMatch</class-id> <category>initialization</category><body package="Seaside-REST-Core">initializeWithName: aNameString value: aValueString	self initializeWithName: aNameString.	value := aValueString</body></methods><methods><class-id>Seaside.WAExactParameterMatch class</class-id> <category>instance creation</category><body package="Seaside-REST-Core">name: aNameString value: aValueString arguments: aCollectionOfStrings 	^ self basicNew initializeWithName: aNameString value: aValueString</body></methods><methods><class-id>Seaside.WAVariableQueryRoute</class-id> <category>as yet unclassified</category><body package="Seaside-REST-Core">initializeQueryFieldParameters: queryFields arguments: aCollectionOfStrings	"Query field parameters are variable in the receiver, so they're not initialized."</body><body package="Seaside-REST-Core">matchesParameters: aDictionary	"Receiver will always match parameters, because they're variable."	^ true</body></methods><methods><class-id>Seaside.WARouteBuilder</class-id> <category>configuration methods</category><body package="Seaside-REST-Core">copy	&lt;configuration&gt;		self method: 'COPY'</body><body package="Seaside-REST-Core">delete	&lt;configuration&gt;		self method: 'DELETE'</body><body package="Seaside-REST-Core">get	&lt;configuration&gt;		self method: 'GET'</body><body package="Seaside-REST-Core">move	&lt;configuration&gt;		self method: 'MOVE'</body><body package="Seaside-REST-Core">post	&lt;configuration&gt;		self method: 'POST'</body><body package="Seaside-REST-Core">put	&lt;configuration&gt;		self method: 'PUT'</body></methods><methods><class-id>Seaside.WARouteBuilder</class-id> <category>configuration</category><body package="Seaside-REST-Core">consumes: aString	&lt;configuration&gt;		consumes add: (WAMimeTypeMatch fromString: aString)</body><body package="Seaside-REST-Core">method: aString	&lt;configuration&gt;		method := aString asUppercase</body><body package="Seaside-REST-Core">path: aString	&lt;configuration&gt;		path := aString</body><body package="Seaside-REST-Core">produces: aString	&lt;configuration&gt;		produces := WAMimeTypeMatch fromString: aString</body><body package="Seaside-REST-Core">variableQuery: aBoolean	&lt;configuration&gt;	variableQuery := aBoolean</body></methods><methods><class-id>Grease.GRPlatform</class-id> <category>*seaside-rest-core</category><body package="Seaside-REST-Core">argumentNamesOf: aCompiledMethod	"Answer the argument names of a method as a sequenceable collection of strings. The default implementation does not support this call."	^ #()</body><body package="Seaside-REST-Core">createRoutesFor: aClass	^ WARouteBuilder createRoutesFor: aClass</body><body package="Seaside-REST-Core">createRoutesFrom: aClass to: aSuperClass	^ WARouteBuilder createRoutesFrom: aClass to: aSuperClass</body></methods><methods><class-id>Grease.GRPackage class</class-id> <category>*seaside-rest-core</category><body package="Seaside-REST-Core">seasideRestCore	^ self new		name: 'Seaside-REST-Core';		description: 'Write RESTful web services using Seaside';		addDependency: 'Seaside-Core';		url: #seasideUrl;		yourself</body></methods><initialize><class-id>Seaside.WARouteBuilder</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>WAObject</name><environment>Seaside</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WASystemConfiguration</name><environment>Seaside</environment><super>Seaside.WAConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>description </inst-vars><class-inst-vars>instance </class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WARequestFilter</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>next </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Filter</category><attributes><package>Seaside-Core</package></attributes></class><class><name>GRPlatform</name><environment>Grease</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core</category><attributes><package>Grease-Core</package></attributes></class><class><name>WARequestHandler</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filter parent configuration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAError</name><environment>Seaside</environment><super>Grease.GRError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Exceptions</category><attributes><package>Seaside-Core</package></attributes></class></st-source>