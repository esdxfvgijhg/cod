<?xml version="1.0"?><st-source><!-- Name: Grease-VisualWorks-ExtensionsComment: This package contains Seaside specific extensions to base VisualWorks classes to make them compatible with Grease code on other platforms.DbIdentifier: bear73DbTrace: 493799DbUsername: tkoganDbVersion: 3.2.0 - 2DevelopmentPrerequisites: #(#(#any 'Xtreams-Transforms' ''))PackageName: Grease-VisualWorks-ExtensionsParcel: #('Grease-VisualWorks-Extensions')PrerequisiteDescriptions: #(#(#name 'Xtreams-Transforms' #componentType #package))PrerequisiteParcels: #(#('Xtreams-Transforms' ''))PrintStringCache: (3.2.0 - 2,tkogan)Version: 3.2.0 - 2Date: 3:31:25 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:31:25 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><shared-variable><name>BOM</name><environment>Core.Character</environment><private>false</private><constant>false</constant><category>*seaside</category><initializer>Character value: 16rFEFF</initializer><attributes><package>Grease-VisualWorks-Extensions</package></attributes></shared-variable><methods><class-id>Core.Fraction</class-id> <category>testing</category><body package="Grease-VisualWorks-Extensions">isFraction	^true</body></methods><methods><class-id>Core.LinkedList class</class-id> <category>instance creation</category><body package="Grease-VisualWorks-Extensions">new: size streamContents: aBlock	^ self withAll: (super new: size streamContents: aBlock)</body></methods><methods><class-id>Core.LinkedList class</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">streamSpecies	^ Array</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">commentStamp: aString prior: aNumber"Ignore"	self error: 'Unsupported format. Remove ''commentStamp'' chunk and the chunk immediately following from the source file.'</body><body package="Grease-VisualWorks-Extensions">methodsFor: protocol stamp: aString	^ self methodsFor: protocol</body></methods><methods><class-id>Core.SequenceableCollection class</class-id> <category>instance creation</category><body package="Grease-VisualWorks-Extensions">new: newSize streamContents: blockWithArg	| stream |	stream := WriteStream on: (self streamSpecies new: newSize).	blockWithArg value: stream.	^ stream contents</body><body package="Grease-VisualWorks-Extensions">streamContents: blockWithArg	^ self new: 100 streamContents: blockWithArg</body></methods><methods><class-id>Core.SequenceableCollection class</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">streamSpecies	"I return the class that is used for streaming. If override consider overriding #new:streamContents:"	^ self</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>copying</category><body package="Grease-VisualWorks-Extensions">allButFirst	^self allButFirst: 1</body><body package="Grease-VisualWorks-Extensions">allButLast	^self allButLast: 1</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">at: anInteger ifAbsent: absentBlock	(anInteger between: 1 and: self size) ifFalse: [^absentBlock value].	^self at: anInteger</body><body package="Grease-VisualWorks-Extensions">atRandom	^self atRandom: Random new</body><body package="Grease-VisualWorks-Extensions">atRandom: aRandom	^self at: (aRandom next * self size) floor + 1</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>testing</category><body package="Grease-VisualWorks-Extensions">beginsWithSubCollection: aCollection	aCollection isEmpty ifTrue: [^self isEmpty].	^self beginsWith: aCollection</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>copying</category><body package="Grease-VisualWorks-Extensions">copyAfter: anElement	| index |	(index := self indexOf: anElement) isZero ifTrue: [^''].	^self copyFrom: index + 1 to: self size</body><body package="Grease-VisualWorks-Extensions">copyAfterLast: anElement	| index |	(index := self lastIndexOf: anElement) isZero ifTrue: [^''].	^self copyFrom: index + 1 to: self size</body><body package="Grease-VisualWorks-Extensions">copyUpToLast: anElement	"Answer a copy of the receiver from index 1 to the last occurrence of 	anElement, not including anElement."	^ self first: (self lastIndexOf: anElement ifAbsent: [^ self copy]) - 1</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>testing</category><body package="Grease-VisualWorks-Extensions">endsWithSubCollection: aCollection	aCollection isEmpty ifTrue: [^self isEmpty].	^self endsWith: aCollection</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>converting</category><body package="Grease-VisualWorks-Extensions">findTokens: aCollection	| stream tokens |	aCollection isSequenceable ifFalse: [^self tokensBasedOn: aCollection].	stream := self readStream.	tokens := OrderedCollection new.	(self first: aCollection size) = aCollection ifTrue: [stream skip: aCollection size].	[stream atEnd] whileFalse: [tokens addLast: (stream upToAndSkipThroughAll: aCollection)].	^tokens</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">fourth	^self at: 4</body><body package="Grease-VisualWorks-Extensions">indexOfSubCollection: aCollection	^self indexOfSubCollection: aCollection startingAt: 1</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>converting</category><body package="Grease-VisualWorks-Extensions">reversed	^self reverse</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">second	^self at: 2</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>converting</category><body package="Grease-VisualWorks-Extensions">substrings: aCollection	| tokens start |	tokens := OrderedCollection new.	start := 1.	self keysAndValuesDo: [:index :character |		(aCollection includes: character) ifTrue:			[start &lt; index ifTrue: [tokens add: (self copyFrom: start to: index - 1)].			start := index + 1]].	start &lt;= self size ifTrue: [tokens add: (self copyFrom: start to: self size)].	^tokens</body><body package="Grease-VisualWorks-Extensions">subStrings: aCollection	self deprecated: #(#version '3.2' #sunset '3.3' #use #substrings:).	^ self substrings: aCollection</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">third	^self at: 3</body></methods><methods><class-id>Core.Set</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">atRandom: aRandom	| index element |	self isEmpty ifTrue: [^self any].	index := (aRandom next * self basicSize) floor + 1.	[element := self basicAt: index.	element isNil] whileTrue:		[index := index + 1.		index &gt; self basicSize ifTrue: [index := 1]].	^element</body></methods><methods><class-id>Core.Set</class-id> <category>copying</category><body package="Grease-VisualWorks-Extensions">restoreFromSnapshot: anObject	super restoreFromSnapshot: anObject snapshotCopy</body><body package="Grease-VisualWorks-Extensions">snapshotCopy	^self copy</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">className	^self class name</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Grease-VisualWorks-Extensions">greaseString	^self printString</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Grease-VisualWorks-Extensions">isArray	^false</body><body package="Grease-VisualWorks-Extensions">isBlock	^false</body><body package="Grease-VisualWorks-Extensions">isCharacter	^false</body><body package="Grease-VisualWorks-Extensions">isCollection	^false</body><body package="Grease-VisualWorks-Extensions">isDictionary	^false</body><body package="Grease-VisualWorks-Extensions">isEmptyOrNil	^self isNil</body><body package="Grease-VisualWorks-Extensions">isMessageSend	^false</body><body package="Grease-VisualWorks-Extensions">isNumber	^false</body></methods><methods><class-id>Core.Object</class-id> <category>*pharo-fixup</category><body package="Grease-VisualWorks-Extensions">pharoName	^self printString</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Grease-VisualWorks-Extensions">printStringLimitedTo: aLimit	^self printString first: aLimit</body></methods><methods><class-id>Core.Object</class-id> <category>copying</category><body package="Grease-VisualWorks-Extensions">restoreFromSnapshot: anObject	| selfVars objectVars minimum maximum |	selfVars := self class allInstVarNames.	objectVars := anObject class allInstVarNames.	minimum := selfVars size min: objectVars size.	maximum := selfVars size max: objectVars size.	1 to: minimum do: [:index | (selfVars at: index) = (objectVars at: index) ifTrue: [self instVarAt: index put: (anObject instVarAt: index)]].	minimum + 1 to: maximum do: [:index | self instVarAt: index put: nil].	minimum := self basicSize min: anObject basicSize.	maximum := self basicSize max: anObject basicSize.	1 to: minimum do: [:index | self basicAt: index put: (anObject basicAt: index)].	minimum + 1 to: maximum do: [:index | self basicAt: index put: nil].</body><body package="Grease-VisualWorks-Extensions">snapshotCopy	^self shallowCopy</body></methods><methods><class-id>Core.Stream</class-id> <category>character writing</category><body package="Grease-VisualWorks-Extensions">crlf	self nextPut: Character cr; nextPut: Character lf</body></methods><methods><class-id>Core.Stream</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">greaseUpToAll: aCollection	^self upToAndSkipThroughAll: aCollection</body></methods><methods><class-id>Core.Timestamp class</class-id> <category>instance creation</category><body package="Grease-VisualWorks-Extensions">date: aDate time: aTime	^self fromDate: aDate andTime: aTime</body></methods><methods><class-id>Core.Timestamp</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">asUTC	"I don't know which Timezone I am in, so I just return self."	^self</body><body package="Grease-VisualWorks-Extensions">dayOfWeek	^self asDate dayOfWeek</body><body package="Grease-VisualWorks-Extensions">dayOfWeekName	^self asDate weekday</body><body package="Grease-VisualWorks-Extensions">monthName	^self asDate monthName</body></methods><methods><class-id>Core.Timestamp</class-id> <category>printing</category><body package="Grease-VisualWorks-Extensions">printAsIso8601On: aStream	aStream policy dateAndTimePolicy		print: self		on: aStream		policyNamed: #iso8601.</body></methods><methods><class-id>Core.Date class</class-id> <category>general inquiries</category><body package="Grease-VisualWorks-Extensions">daysInMonthNumber: monthNumber forYear: yearInteger	^(self		newDay: 1		monthNumber: monthNumber		year: yearInteger) daysInMonth</body></methods><methods><class-id>Core.Date class</class-id> <category>instance creation</category><body package="Grease-VisualWorks-Extensions">year: year month: month day: day	^self newDay: day monthNumber: month year: year</body></methods><methods><class-id>Core.Date</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">dayOfWeek	| weekdayIndex |	weekdayIndex := self weekdayIndex.	weekdayIndex = 7 ifTrue: [^1].	^weekdayIndex + 1</body><body package="Grease-VisualWorks-Extensions">next"	In Pharo, Date is a subclass of Timespan, which implements the #next message.	'Date today next' returns tomorrow's date.	In VisualWorks, we return a new Date instance with one added day to the receiver instance."	^ self addDays: 1</body></methods><methods><class-id>Core.Array</class-id> <category>testing</category><body package="Grease-VisualWorks-Extensions">isArray	^true</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="Grease-VisualWorks-Extensions">capitalized	^(self first: 1) asUppercase, (self allButFirst: 1)</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>comparing</category><body package="Grease-VisualWorks-Extensions">caseInsensitiveLessOrEqual: aCharacterArray	self size &lt; aCharacterArray size ifTrue: [^true].	^self equivalentTo: aCharacterArray ignoreCase: true</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="Grease-VisualWorks-Extensions">greaseString	^ self isEmpty		ifTrue: [ self asString ]		ifFalse: [ "Ignore the BOM character if it's at the beginning"			((self at: 1) = (Character.BOM))				ifTrue: [ (self copyFrom: 2 to: self size) asString ]				ifFalse: [ self asString ] ]</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>testing</category><body package="Grease-VisualWorks-Extensions">includesSubString: aCollection	^(self indexOfSubCollection: aCollection) &gt; 0</body><body package="Grease-VisualWorks-Extensions">includesSubstring: aString caseSensitive: caseSensitive	caseSensitive ifFalse: [^self asLowercase includesSubString: aString asLowercase].	^self includesSubString: aString</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="Grease-VisualWorks-Extensions">trimBoth	"Trim separators from both sides of the receiving string."		^ self trimBoth: [ :char | char isSeparator ]</body><body package="Grease-VisualWorks-Extensions">trimBoth: aBlock	"Trim characters satisfying the condition given in aBlock from both sides of the receiving string."	^ self trimLeft: aBlock right: aBlock</body><body package="Grease-VisualWorks-Extensions">trimLeft	"Trim separators from the left side of the receiving string."		^ self trimLeft: [ :char | char isSeparator ]</body><body package="Grease-VisualWorks-Extensions">trimLeft: aBlock	"Trim characters satisfying the condition given in aBlock from the left side of the receiving string."		^ self trimLeft: aBlock right: [ :char | false ]</body><body package="Grease-VisualWorks-Extensions">trimLeft: aLeftBlock right: aRightBlock	"Trim characters satisfying the condition given in aLeftBlock from the left side and aRightBlock from the right sides of the receiving string."	| left right |	left := 1.	right := self size.		[ left &lt;= right and: [ aLeftBlock value: (self at: left) ] ]		whileTrue: [ left := left + 1 ].			[ left &lt;= right and: [ aRightBlock value: (self at: right) ] ]		whileTrue: [ right := right - 1 ].			^ self copyFrom: left to: right</body><body package="Grease-VisualWorks-Extensions">trimRight	"Trim separators from the right side of the receiving string."		^ self trimRight: [ :char | char isSeparator ]</body><body package="Grease-VisualWorks-Extensions">trimRight: aBlock	"Trim characters satisfying the condition given in aBlock from the right side of the receiving string."	^ self trimLeft: [ :char | false ] right: aBlock</body></methods><methods><class-id>Core.Number</class-id> <category>converting</category><body package="Grease-VisualWorks-Extensions">day	^self sign days</body></methods><methods><class-id>Core.Number</class-id> <category>truncation and round off</category><body package="Grease-VisualWorks-Extensions">fractionPart	"Added for ANSI compatibility"	^self - self integerPart</body></methods><methods><class-id>Core.Number</class-id> <category>converting</category><body package="Grease-VisualWorks-Extensions">hour	^self sign hours</body></methods><methods><class-id>Core.Number</class-id> <category>truncation and round off</category><body package="Grease-VisualWorks-Extensions">integerPart	"Added for ANSI compatibility"	^self truncated</body></methods><methods><class-id>Core.Number</class-id> <category>testing</category><body package="Grease-VisualWorks-Extensions">isFraction	^false</body><body package="Grease-VisualWorks-Extensions">isInfinite	^false</body><body package="Grease-VisualWorks-Extensions">isNumber	^true</body></methods><methods><class-id>Core.Number</class-id> <category>converting</category><body package="Grease-VisualWorks-Extensions">minute	^self sign minutes</body><body package="Grease-VisualWorks-Extensions">second	^self sign seconds</body></methods><methods><class-id>Core.Number</class-id> <category>durations</category><body package="Grease-VisualWorks-Extensions">weeks	^Duration weeks: self</body></methods><methods><class-id>Core.KeyedCollection</class-id> <category>testing</category><body package="Grease-VisualWorks-Extensions">isDictionary	^true</body></methods><methods><class-id>Core.ReadStream</class-id> <category>converting</category><body package="Grease-VisualWorks-Extensions">greaseBeUtf8Encoding"	POTENTIALLY VERY DANGEROUS!	Manipulating collection directly should be done very carefully, possibly only if the current position is zero."	self contentsSpecies == ByteArray ifTrue: [ ^ self ].	self position = 0 ifFalse: [ self error: 'I can convert to use a ByteArray only when I am at the beginning!'].	collection := collection asByteArrayEncoding: #UTF8.	^ self</body></methods><methods><class-id>Core.MessageSend</class-id> <category>testing</category><body package="Grease-VisualWorks-Extensions">isMessageSend	^true</body></methods><methods><class-id>Core.MessageSend</class-id> <category>evaluating</category><body package="Grease-VisualWorks-Extensions">value: anObject	^self valueWithArguments: (Array with: anObject)</body><body package="Grease-VisualWorks-Extensions">value: aObject value: bObject	^self valueWithArguments: (Array with: aObject with: bObject)</body><body package="Grease-VisualWorks-Extensions">value: aObject value: bObject value: cObject	^self valueWithArguments: (Array with: aObject with: bObject with: cObject)</body><body package="Grease-VisualWorks-Extensions">valueWithArguments: arguments	^receiver perform: selector withArguments: arguments</body><body package="Grease-VisualWorks-Extensions">valueWithPossibleArguments: arguments	^self valueWithArguments: ((args, arguments) copyFrom: 1 to: selector numArgs)</body></methods><methods><class-id>Core.OrderedCollection class</class-id> <category>instance creation</category><body package="Grease-VisualWorks-Extensions">new: size streamContents: aBlock	^ self withAll: (super new: size streamContents: aBlock)</body></methods><methods><class-id>Core.OrderedCollection class</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">streamSpecies	^ Array</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>copying</category><body package="Grease-VisualWorks-Extensions">restoreFromSnapshot: anObject	super restoreFromSnapshot: anObject snapshotCopy</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">pragmas	^ Pragma allInMethod: self</body></methods><methods><class-id>Core.LimitedPrecisionReal</class-id> <category>testing</category><body package="Grease-VisualWorks-Extensions">isInfinite	^self isInfinity</body></methods><methods><class-id>Core.Message</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">argumentCount	^selector numArgs - args size</body></methods><methods><class-id>Core.Message</class-id> <category>private</category><body package="Grease-VisualWorks-Extensions">fixCallbackTemps</body></methods><methods><class-id>Core.Time class</class-id> <category>instance creation</category><body package="Grease-VisualWorks-Extensions">hour: hour minute: minute second: second	^self new hours: hour minutes: minute seconds: second</body><body package="Grease-VisualWorks-Extensions">millisecondsSince: startMilliseconds	" Answer the number of milliseconds that have elapsed since the startMilliseconds value. "	^self millisecondClockValue - startMilliseconds</body></methods><methods><class-id>Core.Time</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">hour	^hours</body><body package="Grease-VisualWorks-Extensions">minute	^minutes</body><body package="Grease-VisualWorks-Extensions">second	^seconds</body></methods><methods><class-id>Core.Interval class</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">streamSpecies	^ Array</body></methods><methods><class-id>Core.Interval</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">any	self isEmpty ifTrue: [^self emptyCollectionError].	^super any</body></methods><methods><class-id>Core.Interval</class-id> <category>converting</category><body package="Grease-VisualWorks-Extensions">sorted	^self asOrderedCollection sorted</body><body package="Grease-VisualWorks-Extensions">sorted: aBlock	^self asOrderedCollection sorted: aBlock</body></methods><methods><class-id>Core.Integer</class-id> <category>truncation and round off</category><body package="Grease-VisualWorks-Extensions">&lt;&lt; shiftAmount	"left shift"	shiftAmount &lt; 0 ifTrue: [self error: 'negative arg'].	^self bitShift: shiftAmount</body><body package="Grease-VisualWorks-Extensions">&gt;&gt; shiftAmount	"right shift"	shiftAmount &lt; 0 ifTrue: [self error: 'negative arg'].	^self bitShift: 0 - shiftAmount</body><body package="Grease-VisualWorks-Extensions">integerPart	^self</body></methods><methods><class-id>Core.Integer</class-id> <category>printing</category><body package="Grease-VisualWorks-Extensions">printPaddedWith: aCharacter to: aLength	^self printPaddedWith: aCharacter to: aLength base: 10</body><body package="Grease-VisualWorks-Extensions">printPaddedWith: aCharacter to: aLength base: aBase	| stream |	stream := String new writeStream.	self printOn: stream paddedWith: aCharacter to: aLength base: aBase.	^stream contents</body><body package="Grease-VisualWorks-Extensions">printStringBase: base	^self printStringRadix: base</body></methods><methods><class-id>Core.ReadWriteStream</class-id> <category>private</category><body package="Grease-VisualWorks-Extensions">ascii	collection changeClassTo: ByteString</body><body package="Grease-VisualWorks-Extensions">binary	collection changeClassTo: ByteArray</body></methods><methods><class-id>Core.Symbol class</class-id> <category>instance creation</category><body package="Grease-VisualWorks-Extensions">new: size streamContents: aBlock	^ (super new: size streamContents: aBlock) asSymbol</body></methods><methods><class-id>Core.Symbol class</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">streamSpecies	^ String</body></methods><methods><class-id>Core.Symbol</class-id> <category>converting</category><body package="Grease-VisualWorks-Extensions">asMutator	^(self copyWith: $:) asSymbol</body><body package="Grease-VisualWorks-Extensions">capitalized	^super capitalized asSymbol</body></methods><methods><class-id>Core.Symbol</class-id> <category>testing</category><body package="Grease-VisualWorks-Extensions">isUnary	^(self isInfix or: [self includes: $:]) not</body></methods><methods><class-id>Core.Symbol</class-id> <category>converting</category><body package="Grease-VisualWorks-Extensions">sorted	^self asOrderedCollection sorted</body><body package="Grease-VisualWorks-Extensions">sorted: aBlock	^self asOrderedCollection sorted: aBlock</body></methods><methods><class-id>Core.Behavior</class-id> <category>*pharo-fixup</category><body package="Grease-VisualWorks-Extensions">pharoName	^ self name</body></methods><methods><class-id>Core.Behavior</class-id> <category>private</category><body package="Grease-VisualWorks-Extensions">startUp</body></methods><methods><class-id>Core.WriteStream</class-id> <category>converting</category><body package="Grease-VisualWorks-Extensions">greaseBeUtf8Encoding"	POTENTIALLY VERY DANGEROUS!	Manipulating collection directly should be done very carefully, possibly only if the current position is zero."	self contentsSpecies == ByteArray ifTrue: [ ^ self ].	self position = 0 ifFalse: [ self error: 'I can convert to use a ByteArray only when I am at the beginning!'].	collection := collection asByteArrayEncoding: #UTF8.	^ self</body></methods><methods><class-id>Core.Association</class-id> <category>testing</category><body package="Grease-VisualWorks-Extensions">asDeferred	" Seaside requires Association to answer true to #isVariableBinding.	VisualWorks makes a test if a literal isVariableBinding in CompiledCode&gt;&gt;initializeLiteralAt:put:	If a literal isVariableBinding, it is also supposed to understand #asDeferred, hence this method.	However, it should not *really* become a DeferredBinding, it should remain an Association.	Another test in CompiledCode&gt;&gt;initializeLiteralAt:put: is whether a literal isDeferred, and this is the opportunity	for an Association to return false.	"	^ self</body><body package="Grease-VisualWorks-Extensions">isDeferred	" Seaside requires Association to answer true to #isVariableBinding.	VisualWorks makes a test if a literal isVariableBinding in CompiledCode&gt;&gt;initializeLiteralAt:put:	Another test in CompiledCode&gt;&gt;initializeLiteralAt:put: is whether a literal isDeferred, and this is the opportunity	for an Association to return false - hence this method	"	^ false</body><body package="Grease-VisualWorks-Extensions">isVariableBinding	^true</body></methods><methods><class-id>Core.String class</class-id> <category>instance creation</category><body package="Grease-VisualWorks-Extensions">cr	"Answer a string containing a single carriage return character."	^self with: Character cr</body><body package="Grease-VisualWorks-Extensions">crlf	^String with: Character cr with: Character lf</body><body package="Grease-VisualWorks-Extensions">crlfcrlf	^self crlf , self crlf</body><body package="Grease-VisualWorks-Extensions">lf	"Answer a string containing a single carriage return character."	^self with: Character lf</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="Grease-VisualWorks-Extensions">asUnsignedInteger	"Returns the first integer it can find or nil."	| start stream |	start := self findFirst: [ :char | char isDigit ].	start isZero ifTrue: [ ^ nil ].	stream := self readStream position: start - 1.	^ Integer readFrom: stream</body></methods><methods><class-id>Core.String</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">findString: aString	^self findString: aString startingAt: 1</body><body package="Grease-VisualWorks-Extensions">indexOf: aCharacter startingAt: start	^(self		nextIndexOf: aCharacter		from: start		to: self size) ifNil: [0]</body></methods><methods><class-id>Core.String</class-id> <category>copying</category><body package="Grease-VisualWorks-Extensions">padLeftTo: length with: char	^ (String new: (length - self size max: 0) withAll: char) , self.</body><body package="Grease-VisualWorks-Extensions">padRightTo: length with: char	^ self, (String new: (length - self size max: 0) withAll: char)</body></methods><methods><class-id>Core.ArrayedCollection class</class-id> <category>instance creation</category><body package="Grease-VisualWorks-Extensions">with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject	"Answer a new instance of ArrayedCollection, containing the four 	arguments as the elements."	| newCollection |	newCollection := self new: 5.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	newCollection at: 3 put: thirdObject.	newCollection at: 4 put: fourthObject.	newCollection at: 5 put: fifthObject.	^newCollection</body><body package="Grease-VisualWorks-Extensions">with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject with: sixthObject	"Answer a new instance of me, containing only the 6 arguments as elements."	| newCollection |	newCollection := self new: 6.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	newCollection at: 3 put: thirdObject.	newCollection at: 4 put: fourthObject.	newCollection at: 5 put: fifthObject.	newCollection at: 6 put: sixthObject.	^newCollection</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">globals	^self == Smalltalk ifTrue: [self] ifFalse: [Smalltalk globals]</body></methods><methods><class-id>Core.PositionableStream</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">skipTo: aCharacter	self skipUpTo: aCharacter.	self atEnd ifFalse: [self skip: 1]</body></methods><methods><class-id>Core.Dictionary</class-id> <category>testing</category><body package="Grease-VisualWorks-Extensions">isDictionary	^true</body></methods><methods><class-id>Core.Dictionary</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">keysSortedSafely	"Answer a SortedCollection containing the receiver's keys."	| sortedKeys |	sortedKeys := SortedCollection new: self size.	sortedKeys sortBlock:		[:x :y |  "Should really be use &lt;obj, string, num&gt; compareSafely..."		((x isString and: [y isString])			or: [x isNumber and: [y isNumber]])			ifTrue: [x &lt; y]			ifFalse: [x class == y class				ifTrue: [x printString &lt; y printString]				ifFalse: [x class name &lt; y class name]]].	self keysDo: [:each | sortedKeys add: each].	^ sortedKeys reSort</body></methods><methods><class-id>Core.Duration class</class-id> <category>class initialization</category><body package="Grease-VisualWorks-Extensions">days: anInteger	^self fromMilliseconds: anInteger * 86400000</body><body package="Grease-VisualWorks-Extensions">hours: anInteger	^self fromMilliseconds: anInteger * 3600000</body><body package="Grease-VisualWorks-Extensions">milliseconds: millisecondsCount	^self fromMilliseconds: millisecondsCount</body><body package="Grease-VisualWorks-Extensions">minutes: anInteger	^self fromMilliseconds: anInteger * 60000</body><body package="Grease-VisualWorks-Extensions">seconds: secondsCount	^self fromSeconds: secondsCount</body><body package="Grease-VisualWorks-Extensions">weeks: anInteger	^self fromMilliseconds: anInteger * 604800000</body></methods><methods><class-id>Core.Duration</class-id> <category>converting</category><body package="Grease-VisualWorks-Extensions">asMilliSeconds	^self asMilliseconds</body></methods><methods><class-id>Core.FixedPoint</class-id> <category>converting</category><body package="Grease-VisualWorks-Extensions">greaseString	| converter |	converter := Grease.GRSignPrinter new, (Grease.GRNumberPrinter new precision: self scale).	^ converter print: self</body></methods><methods><class-id>Core.Random</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">nextInt: anInteger	"Answer a random integer in the interval [1, anInteger]."	anInteger strictlyPositive ifFalse: [ self error: 'Range must be positive' ].	^ (self next * anInteger) truncated + 1</body><body package="Grease-VisualWorks-Extensions">randomFrom: aCollection	^aCollection atRandom: self</body></methods><methods><class-id>Core.SortedCollection</class-id> <category>converting</category><body package="Grease-VisualWorks-Extensions">sorted	^self asOrderedCollection sorted</body><body package="Grease-VisualWorks-Extensions">sorted: aBlock	^self asOrderedCollection sorted: aBlock</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">anyOne	^self any</body></methods><methods><class-id>Core.Collection</class-id> <category>converting</category><body package="Grease-VisualWorks-Extensions">asByteArray	" This method assumes the collection is full of integers between 0..255 "	^ByteArray withAll: self</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">atRandom	^self atRandom: Random new</body><body package="Grease-VisualWorks-Extensions">atRandom: aRandom	^self subclassResponsibility</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="Grease-VisualWorks-Extensions">count: aBlock	| count |	count := 0.	self do: [:each | (aBlock cull: each) ifTrue: [count := count + 1]].	^count</body><body package="Grease-VisualWorks-Extensions">difference: aCollection	"Answer the set theoretic difference of two collections."	^ self reject: [:each | aCollection includes: each]</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="Grease-VisualWorks-Extensions">ifEmpty: aBlock	"Evaluate the given block with the receiver as argument, answering its value if the receiver is empty, otherwise answer the receiver."	"Note that the fact that this method returns its argument in case the receiver is not empty allows one to write expressions like the following ones: self classifyMethodAs: (myProtocol ifEmpty: ['As yet unclassified'])"	^self isEmpty ifTrue: [^aBlock value] ifFalse: [self]</body><body package="Grease-VisualWorks-Extensions">isCollection	^true</body><body package="Grease-VisualWorks-Extensions">isEmptyOrNil	^self isEmpty</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="Grease-VisualWorks-Extensions">noneSatisfy: aBlock	^self allSatisfy: [:each | (aBlock value: each) not]</body></methods><methods><class-id>Core.Collection</class-id> <category>copying</category><body package="Grease-VisualWorks-Extensions">restoreFromSnapshot: anObject	super restoreFromSnapshot: anObject.	self rehash</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="Grease-VisualWorks-Extensions">valuesDo: aBlock	self keysAndValuesDo: [:key :value | aBlock value: value]</body></methods><methods><class-id>Core.Point</class-id> <category>converting</category><body package="Grease-VisualWorks-Extensions">greaseString	^x printString, '@', y printString</body></methods><methods><class-id>Core.Float class</class-id> <category>constants access</category><body package="Grease-VisualWorks-Extensions">infinity	^self positiveInfinity</body></methods><methods><class-id>Core.Character</class-id> <category>converting</category><body package="Grease-VisualWorks-Extensions">asUnicode	^self asInteger</body><body package="Grease-VisualWorks-Extensions">greaseInteger	^self asInteger</body><body package="Grease-VisualWorks-Extensions">greaseString	^String with: self</body></methods><methods><class-id>Core.Character</class-id> <category>testing</category><body package="Grease-VisualWorks-Extensions">isCharacter	^true</body></methods><methods><class-id>Core.Character</class-id> <category>converting</category><body package="Grease-VisualWorks-Extensions">to: aCharacter	| string |	string := String new writeStream.	self asInteger to: aCharacter asInteger do: [:charPoint | string nextPut: charPoint asCharacter].	^string contents</body></methods><methods><class-id>Core.Bag</class-id> <category>copying</category><body package="Grease-VisualWorks-Extensions">restoreFromSnapshot: anObject	super restoreFromSnapshot: anObject snapshotCopy</body><body package="Grease-VisualWorks-Extensions">snapshotCopy	^self copy</body></methods><methods><class-id>Core.Bag</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">sortedCounts	| counts |	counts := SortedCollection sortBlock: [:a :b | a key &lt; b key].	self valuesAndCountsDo: [:value :count | counts add: count -&gt; value].	^counts</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>accessing</category><body package="Grease-VisualWorks-Extensions">argumentCount	^self numArgs</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>private</category><body package="Grease-VisualWorks-Extensions">fixCallbackTemps</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>testing</category><body package="Grease-VisualWorks-Extensions">isBlock	^true</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>evaluating</category><body package="Grease-VisualWorks-Extensions">valueWithPossibleArguments: arguments	^self cullWithArguments: arguments</body></methods><methods><class-id>Core.Object class</class-id> <category>Seaside</category><body package="Grease-VisualWorks-Extensions">seasidePragmas"	Certain Seaside methods need to be overriden or modified in VisualWorks.	To make the tracking of such methods easier, it is suggested to use the #SeasideOverride: pragma."	&lt;pragmas: #instance&gt;	&lt;pragmas: #class&gt;		^ #(#SeasideOverride)</body></methods><methods><class-id>Core.Object</class-id> <category>*pharo-fixup</category><body package="Grease-VisualWorks-Extensions">pharoValue"	Pharo implements and heavily uses the #value method on Object.	This seems to be a gross violation of the #value semantic as traditionally defined by	classes such as Association and ValueHolder.	Here we replace it with 'pharoValue' to indicate the source of this implementation, and	override in only those classes that seem to be used throughout Grease and Seaside."	&lt;SeasideOverride&gt;	^self</body></methods><methods><class-id>Core.Association</class-id> <category>*pharo-fixup</category><body package="Grease-VisualWorks-Extensions">pharoValue	&lt;SeasideOverride&gt;	^value</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>LimitedPrecisionReal</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>powersOfTwo </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>PositionableStream</name><environment>Core</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection position readLimit writeLimit policy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>WriteStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Point</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>Random</name><environment>Core</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>seed </inst-vars><class-inst-vars>defaultGeneratorClass </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Message</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector args </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Duration</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>period scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Core</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Bag</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Interval</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>start stop step </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>KeyedCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>SortedCollection</name><environment>Core</environment><super>Core.OrderedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>sortBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>NameSpace</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>MessageSend</name><environment>Core</environment><super>Core.Message</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Association</name><environment>Core</environment><super>Core.LookupKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>ReadStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Fraction</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ReadWriteStream</name><environment>Core</environment><super>Core.WriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>FixedPoint</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class></st-source>