<?xml version="1.0"?><st-source><!-- Name: Seaside-VisualWorks-AdaptorsNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: This package simplifies Seaside server setup by creating and providing tools to manage a global server instance. The server should get created and started automatically right after this package finishes loading. Currently supported two types of SeasideServer: HTTP and HTTPS. The default server is HTTP.HTTP - The server will use the regular buffered response and persistent connections (allowing multiple request/response exchanges over the same connection.HTTPS - The server will use HTTPS connection. Load Seaside-VisualWorks-SecureAdaptors parcel to set HTTPS connection. Seaside-VisualWorks-Adaptors-Development parcel provides Seaside Settings to create a listener on HTTPS connection.Use Reverse Proxies to run behind an external web server, e.g. Apache or IIS.Once everything is loaded, you should see a notification about the server starting in the Transcript. You can access the server right away at the following URL:	http://localhost:7777/The server can be managed through the Seaside menu in the Launcher. It can be tuned through the standard Settings mechanisms.The server can be accessed programatically as 'SeasideServer current'.If you need to debug issues you can turn on the Debug Mode option in the Seaside menu which will allow any errors to open a debugger instead of trying to suppress them and continue. The simple logging facility provided in the Seaside menu might be useful for debugging as well.	How to start serversHttp server	server := SeasideServer createServer.	server addListener: '0.0.0.0' port: 7777.	server start.The URL to hit with a web browser would then be: http://localhost:7777If you need to debug issues try	server debug: true.If you'd like to see a log of everything that's happening on the server try	SeasideServer startTranscriptLog.DbIdentifier: bear73DbTrace: 492587DbUsername: jkottDbVersion: 3.2.0 - 1DevelopmentPrerequisites: #(#(#any 'Protocols-Common' '') #(#any 'Seaside-Canvas' '') #(#any 'Grease-VisualWorks-Core' '') #(#any 'SiouX-Net-Http' '') #(#any 'ExternalWebBrowser' '') #(#any 'URISupport' '') #(#any 'WebSupport' ''))DisregardedPrerequisites: #(#(#name 'HTTP' #componentType #package) #(#name 'MIME' #componentType #package) #(#name 'SiouX-Server' #componentType #bundle) #(#name 'Grease-Core' #componentType #package) #(#name 'Seaside-Core' #componentType #package))PackageName: Seaside-VisualWorks-AdaptorsParcel: #('Seaside-VisualWorks-Adaptors')PrerequisiteDescriptions: #(#(#name 'Protocols-Common' #componentType #package) #(#name 'Seaside-Canvas' #componentType #package) #(#name 'Grease-VisualWorks-Core' #componentType #package) #(#name 'SiouX-Net-Http' #componentType #package) #(#name 'ExternalWebBrowser' #componentType #package) #(#name 'URISupport' #componentType #package) #(#name 'WebSupport' #componentType #package))PrerequisiteParcels: #(#('Protocols-Common' '') #('Seaside-Canvas' '') #('Grease-VisualWorks-Core' '') #('SiouX-Net-Http' '') #('ExternalWebBrowser' '') #('URISupport' '') #('WebSupport' ''))PrintStringCache: (3.2.0 - 1,jkott)Version: 3.2.0 - 1Date: 3:31:28 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:31:28 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SeasideHttpWritingOptions</name><environment>SiouX</environment><super>Net.HttpWritingOptions</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>chunkSize </class-inst-vars><imports></imports><category></category><attributes><package>Seaside-VisualWorks-Adaptors</package></attributes></class><comment><class-id>SiouX.SeasideHttpWritingOptions</class-id><body>SeasideHttpWritingOptions  is holding the HttpWriteHandler/HttpPrintHandler Seaside specific options and knows how to create an instance of HttpWriteHandler/HttpPrintHandler.Class Instance Variables	chunkSize	&lt;Number&gt; default value for chunk size </body></comment><class><name>SeasideHttpReadingOptions</name><environment>SiouX</environment><super>Net.HttpReadingOptions</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Seaside-VisualWorks-Adaptors</package></attributes></class><comment><class-id>SiouX.SeasideHttpReadingOptions</class-id><body>SeasideHttpReadingOptions holds SeasideHttpBuildHandler options and knows how create an instance of SeasideHttpBuildHandler</body></comment><class><name>SeasideResponder</name><environment>SiouX</environment><super>SiouX.NetHttpResponder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>seasideRequestDispatcher </inst-vars><class-inst-vars>defaultSeasideRequestDispatcher </class-inst-vars><imports>			private Net.*			private Grease.*			private Seaside.*			private OS.*			</imports><category></category><attributes><package>Seaside-VisualWorks-Adaptors</package></attributes></class><comment><class-id>SiouX.SeasideResponder</class-id><body>SeasideResponder excutes a web request.Instance Variables	seasideRequestDispatcher	&lt;WADispatcher&gt;  Seaside dispatcherClass Variables	defaultSeasideRequestDispatcher	&lt;WADispatcher&gt; default Seaside dispatcher</body></comment><class><name>SeasideHttpBuildHandler</name><environment>SiouX</environment><super>Net.HttpBuildHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Seaside-VisualWorks-Adaptors</package></attributes></class><comment><class-id>SiouX.SeasideHttpBuildHandler</class-id><body>This class saves all attachments and form data that have file name attribute directly into files. If a file name already exists the new name will be created with suffix "_v" and next available number. For example, if a request includes a part with 	Content-Disposition: filename=readme.txt and the file "readme.txt" already exists the file will be created as "readme_v1.txt". </body></comment><class><name>SeasideServer</name><environment>SiouX</environment><super>SiouX.Server</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>isInDebugMode defaultAutoRestart logger </class-inst-vars><imports>			private Security.PKCS8			private OS.*			private Security.X509.*			private UI.*			</imports><category></category><attributes><package>Seaside-VisualWorks-Adaptors</package></attributes></class><comment><class-id>SiouX.SeasideServer</class-id><body>Represents a Seaside server. Most functionality is the class side management of the default instance and support for configuration settings.Class Instance Variables	logger &lt;CommonLog&gt;	isInDebugMode &lt;Boolean&gt; allows passing all unexpected server errors. By default the option is off and all server errors are suppressed.	defaultAutoRestart &lt;Symbol&gt; does the server restart automatically? The permitted values are #always, #never, and #ifQuiescent.</body></comment><methods><class-id>SiouX.SeasideHttpWritingOptions</class-id> <category>accessing</category><body package="Seaside-VisualWorks-Adaptors">chunkSize	^chunkSize ifNil: [ self class chunkSize ]</body></methods><methods><class-id>SiouX.SeasideHttpWritingOptions class</class-id> <category>accessing</category><body package="Seaside-VisualWorks-Adaptors">chunkSize	^chunkSize ifNil: [chunkSize := self defaultChunkSize ]</body><body package="Seaside-VisualWorks-Adaptors">chunkSize: anObject	chunkSize := anObject</body></methods><methods><class-id>SiouX.SeasideHttpReadingOptions</class-id> <category>accessing</category><body package="Seaside-VisualWorks-Adaptors">acceptNonAsciiCharacters	^true</body></methods><methods><class-id>SiouX.SeasideHttpReadingOptions class</class-id> <category>defaults</category><body package="Seaside-VisualWorks-Adaptors">defaultBuilderType	^SeasideHttpBuildHandler</body></methods><methods><class-id>SiouX.SeasideHttpReadingOptions class</class-id> <category>default values</category><body package="Seaside-VisualWorks-Adaptors">defaultAttachmentDirectoryValue	^'seaside-temp-files'</body><body package="Seaside-VisualWorks-Adaptors">saveAttachmentsAsFilesValue	^true</body></methods><methods><class-id>SiouX.SeasideResponder</class-id> <category>private - request parts</category><body package="Seaside-VisualWorks-Adaptors">requestBodyFor: aNativeRequest	"Answer the undecoded request body as a String."	^aNativeRequest body isSimple		ifTrue: [ aNativeRequest contents ]		ifFalse: [nil]</body><body package="Seaside-VisualWorks-Adaptors">requestCookiesFor: aNativeRequest	| cookies |	cookies := OrderedCollection new.	aNativeRequest cookie ifNotNil: [ :field |		field value do: [ :cookie |			cookies add: (WARequestCookie key: cookie key value: cookie value ) ]].	^cookies</body><body package="Seaside-VisualWorks-Adaptors">requestFieldsFor: aNativeRequest	| fields |	fields := WARequestFields new.	aNativeRequest isMultipart		ifTrue: [ self postEncodedDataFrom: aNativeRequest keysAndValuesDo: [:key :value | fields at: key add: value ] ]		ifFalse: [ self urlEncodedDataFrom: aNativeRequest contents keysAndValuesDo: [:key :value | fields at: key add: value ] ].	^fields</body><body package="Seaside-VisualWorks-Adaptors">requestFor: aNativeRequest connection: aConnection	^(WARequest		method: (self requestMethodFor: aNativeRequest)		uri: (self requestUrlFor: aNativeRequest)		version: (self requestVersionFor: aNativeRequest))			setHeaders: (self requestHeadersFor: aNativeRequest);			setPostFields: (self requestFieldsFor: aNativeRequest);			setBody: (self requestBodyFor: aNativeRequest);			setCookies: (self requestCookiesFor: aNativeRequest);			setRemoteAddress: aConnection id hostAddress;			yourself</body><body package="Seaside-VisualWorks-Adaptors">requestHeadersFor: aNativeRequest	| headers ws |	headers := Dictionary new.	aNativeRequest header fields do: [ :field || rs |		 field source 			ifNotNil: [rs := field source reset.					rs upTo: $:; next.					headers at: field name put: rs upToEnd]			ifNil:["CGI transport doesn't have source "				ws := (String new: 100) writeStream.				field writeValueOn: ws encoding: nil.				headers at: field name put: ws contents] ].	^headers</body><body package="Seaside-VisualWorks-Adaptors">requestMethodFor: aNativeRequest	^aNativeRequest method</body><body package="Seaside-VisualWorks-Adaptors">requestUrlFor: aNativeRequest	| parameters stream |	parameters := WARequestFields new.	self urlEncodedDataFrom: aNativeRequest url query keysAndValuesDo: [:key :value | parameters at: key add: value ].	stream := String new writeStream.	aNativeRequest url decodedPath		do: [ :each | stream nextPutAll: each ]		separatedBy: [ stream nextPut: $/].	^(WAUrl absolute: stream contents)		queryFields: parameters;		fragment: aNativeRequest url fragment;		yourself</body><body package="Seaside-VisualWorks-Adaptors">requestVersionFor: aNativeRequest		^aNativeRequest isHttp10		ifTrue: [ WAHttpVersion http10]		ifFalse: [WAHttpVersion http11 ]</body></methods><methods><class-id>SiouX.SeasideResponder</class-id> <category>accessing</category><body package="Seaside-VisualWorks-Adaptors">codec	^Grease.GRGenericCodec new initialize: #'utf-8'</body><body package="Seaside-VisualWorks-Adaptors">seasideRequestDispatcher	^seasideRequestDispatcher ifNil: [ seasideRequestDispatcher := self class defaultSeasideRequestDispatcher ]</body><body package="Seaside-VisualWorks-Adaptors">seasideRequestDispatcher: aSeasideRequestDispatcher	seasideRequestDispatcher := aSeasideRequestDispatcher</body></methods><methods><class-id>SiouX.SeasideResponder</class-id> <category>private</category><body package="Seaside-VisualWorks-Adaptors">asSeasideFileStream: aMimeEntity	| contentType stream contents |	aMimeEntity formFilename isEmpty ifTrue: [^nil].	contentType := String new writeStream.	aMimeEntity contentTypeField printValueOn: contentType.	contentType := contentType contents copyWithout: Character cr.	stream := aMimeEntity body byteSource.	contents := stream isExternalStream				ifTrue: [(stream fileName withEncoding: #binary) contentsOfEntireFile]				ifFalse: [stream contents].	^(WAFile new)		fileName: aMimeEntity formFilename;		contents: contents;		contentType: contentType</body><body package="Seaside-VisualWorks-Adaptors">postEncodedDataFrom: aNativeRequest keysAndValuesDo: aBlock	aNativeRequest parts do: [ :part |		| key |		key := part contentDisposition parameterAt: 'name' ifAbsent: [String new].		part formFilename			ifNil: [ aBlock value: key value: (self codec decode: part body valueAsStream contents) ]			ifNotNil: [ aBlock value: key value: (self asSeasideFileStream: part) ] ]</body><body package="Seaside-VisualWorks-Adaptors">urlEncodedDataFrom: aString keysAndValuesDo: aBlock	| encoder stream |	encoder := URLEncoder new setEncoder: (StreamEncoder new: #iso8859_1).	aString == nil ifTrue: [^self].	stream := aString readStream.	[ stream atEnd ] whileFalse: [ | field key val mid |		field := stream upTo: $&amp;.		(mid := field indexOf: $=) isZero			ifTrue: [ key := field. val := '' ]			ifFalse: [ key := field copyFrom: 1 to: mid - 1.				val := field copyFrom: mid+1 to: field size ].		key := encoder decode: key.		val := encoder decode: val.		aBlock value: key value: (self codec decode: val) ]</body></methods><methods><class-id>SiouX.SeasideResponder</class-id> <category>printing</category><body package="Seaside-VisualWorks-Adaptors">printOn: aStream	aStream 		nextPutAll: self path;		nextPutAll: ' (Seaside)'</body></methods><methods><class-id>SiouX.SeasideResponder</class-id> <category>services</category><body package="Seaside-VisualWorks-Adaptors">acceptRequest: requestLine 	^true</body><body package="Seaside-VisualWorks-Adaptors">executeRequestFor: aRequestContext	| message requestContext |	message := self requestFor: aRequestContext request connection: aRequestContext connection.	requestContext := WARequestContext		request: message		response: (WABufferedResponse on: ( self codec encoderFor: GRPlatform current readWriteByteStream))		codec: self codec.	[self seasideRequestDispatcher handle: requestContext ]		on: WAResponseNotification		do: [ :n | "got a response"  ].	^requestContext response asHttpResponse: aRequestContext response.</body></methods><methods><class-id>SiouX.SeasideResponder class</class-id> <category>accessing</category><body package="Seaside-VisualWorks-Adaptors">defaultSeasideRequestDispatcher	^defaultSeasideRequestDispatcher ifNil: [ self defaultSeasideRequestDispatcherValue ]</body><body package="Seaside-VisualWorks-Adaptors">defaultSeasideRequestDispatcher: dispatcher"	dispatcher	&lt;WADispatcher&gt; default requestDispatcher"	defaultSeasideRequestDispatcher := dispatcher</body></methods><methods><class-id>SiouX.SeasideResponder class</class-id> <category>defaults</category><body package="Seaside-VisualWorks-Adaptors">defaultReadingOptionsValue	^SeasideHttpReadingOptions new</body><body package="Seaside-VisualWorks-Adaptors">defaultSeasideRequestDispatcherValue	^WADispatcher default</body><body package="Seaside-VisualWorks-Adaptors">defaultWritingOptionsValue	^SeasideHttpWritingOptions new</body></methods><methods><class-id>SiouX.SeasideHttpBuildHandler</class-id> <category>private prepare streams</category><body package="Seaside-VisualWorks-Adaptors">bodyStreamFor: aMimeEntity	| fn name encoding|	"It seems that browsers don't know how to properly encode non-ascii filenames and simply slap them into the header in UTF-8.	So let's play by the same rules"	fn :=	aMimeEntity fileName.	"ifNotNil: [ :broken || fixed |			fixed := (broken asByteArrayEncoding: #iso8859_1) asStringEncoding: #utf8.			aMimeEntity fileName: fixed.			fixed ]."	(self saveAttachmentsAsFiles not or: [ fn isNil] ) ifTrue: [^self internalStream ].	[fn asFilename ] on: UnsupportedCharacterError do: [ :ex | ^self internalStream ].	name := self fileNameFrom: fn.	^((encoding := aMimeEntity charsetIfNone: [nil ]) isNil		ifTrue: [ name ]		ifFalse: [name withEncoding: encoding ] ) readWriteStream binary</body><body package="Seaside-VisualWorks-Adaptors">internalStream	^ReadWriteStream on: (ByteArray new: 1024)</body><body package="Seaside-VisualWorks-Adaptors">openBodyStream: aMessageBody	aMessageBody byteSource: (self bodyStreamFor: aMessageBody parent ).	^aMessageBody byteSource</body></methods><methods><class-id>SiouX.SeasideHttpBuildHandler</class-id> <category>body callbacks</category><body package="Seaside-VisualWorks-Adaptors">processAttachment: aBody from: aStream	^self processBody: aBody from: aStream</body></methods><methods><class-id>SiouX.SeasideHttpBuildHandler</class-id> <category>private</category><body package="Seaside-VisualWorks-Adaptors">fileNameFrom: aString	| fn name i tail ext version newName |	tail := aString asFilename tail.	name := tail.	(i := tail indexOf: $.) ~= 0		ifTrue: [ name := tail copyFrom: 1 to: i - 1.				ext :=  tail copyFrom: i + 1 to: tail size. ].	version := 0.	[newName := (version = 0  ifTrue: [name ] ifFalse: [name, '_v', version printString]).	newName := ext ifNil: [ newName ] ifNotNil: [newName, '.', ext].	fn := self attachmentDirectory construct: newName.	 fn  exists ]		whileTrue: [ version := version + 1 ].	^fn</body><body package="Seaside-VisualWorks-Adaptors">safelyRead: aBody from: sourceStream into: resultStream	sourceStream binary.	[[ [sourceStream atEnd ] 		whileFalse: [resultStream nextPut: sourceStream next].	 ]		on: Error 		do: [ :ex | self handleStartBody: aBody exception: ex ].	sourceStream text.	] ensure: [  resultStream close]</body></methods><methods><class-id>SiouX.SeasideServer</class-id> <category>services</category><body package="Seaside-VisualWorks-Adaptors">start	super start.	Grease.GreaseSystem recordServerStartUp.</body></methods><methods><class-id>SiouX.SeasideServer class</class-id> <category>running</category><body package="Seaside-VisualWorks-Adaptors">openExternalWebBrowser	RuntimeSystem isRuntime ifTrue: [^self].	self isRunning ifFalse: [ self error: 'The server is not running!'].	Smalltalk.ExternalWebBrowser open: self siteURL asString</body><body package="Seaside-VisualWorks-Adaptors">start	self current isRunning ifFalse: [ self current start].</body><body package="Seaside-VisualWorks-Adaptors">startDebugMode	self current debug: true.</body><body package="Seaside-VisualWorks-Adaptors">startLog	self current logging: true.</body><body package="Seaside-VisualWorks-Adaptors">stop		self current stop</body><body package="Seaside-VisualWorks-Adaptors">stopDebugMode	self current debug: false.</body><body package="Seaside-VisualWorks-Adaptors">stopLog	self current logging: false.</body></methods><methods><class-id>SiouX.SeasideServer class</class-id> <category>testing</category><body package="Seaside-VisualWorks-Adaptors">isInDebugMode	^self current debugging</body><body package="Seaside-VisualWorks-Adaptors">isLogging	^self current isLogging</body><body package="Seaside-VisualWorks-Adaptors">isRunning	^self current listeners anySatisfy: [ :listener | listener isRunning ]</body></methods><methods><class-id>SiouX.SeasideServer class</class-id> <category>private-post load action</category><body package="Seaside-VisualWorks-Adaptors">postLoadAction	"Most browsers seem to just slap the filename of uploaded files into the header in raw utf8"	Net.ValueWithParams defaultParameterValueEncoding: #utf8.	#{Seaside.DoNotStartSeasideServer} isDefined ifTrue: [^nil ].	[self start]		on: Error 		do: [ :ex | 			self postLoadActionErrorText: ex.			ex return.].	self postLoadActionText</body><body package="Seaside-VisualWorks-Adaptors">postLoadActionErrorText:  exception"	self  postLoadActionErrorText: Error new"	self printToTranscriptDo:[ :ts |		ts 	cr;cr;			emphasis:(Array with: #bold  with: #color -&gt; Graphics.ColorValue magenta );			nextPutAll: 'ERROR while starting Seaside Server.';			emphasis: nil;			cr; cr; nextPutAll: exception errorString ]</body><body package="Seaside-VisualWorks-Adaptors">postLoadActionText"	self postLoadActionText"	self printToTranscriptDo:[ :ts |		ts cr;cr.		self isRunning			ifTrue: [ts 					emphasis:(Array with: #bold  with: #color -&gt; Graphics.ColorValue blue );					nextPutAll: 'Seaside Server STARTED!';					emphasis: #color -&gt; Graphics.ColorValue blue;					cr; cr; nextPutAll: 'Copy the URL below and paste it into your web browser';					cr; cr; nextPutAll: self siteURL asString;					cr; cr; nextPutAll: 'The server can be managed through the Seaside menu in the Launcher. It can be tuned through the standard Settings mechanisms';					cr; emphasis: nil ]			ifFalse: [ts 					emphasis:(Array with: #bold  with: #color -&gt; Graphics.ColorValue magenta );					nextPutAll: 'Seaside Server FAILED to start!';					cr ]]</body><body package="Seaside-VisualWorks-Adaptors">printToTranscriptDo: aBlock	| ts |	ts := TextStream on: (String new: 20).		ts nextPutAllText: Transcript value; cr.	aBlock value: ts.	Transcript		value: ts contents;		changed: #update</body></methods><methods><class-id>SiouX.SeasideServer class</class-id> <category>accessing</category><body package="Seaside-VisualWorks-Adaptors">current 	^Server registry 		at: self serverID 		ifAbsentPut: [ self createServer ]</body><body package="Seaside-VisualWorks-Adaptors">current: aSeasideServer" self current: nil "	(Server registry at: self serverID ifAbsent: [ nil]) ifNotNil: [ :current | current release.].	aSeasideServer ifNil: [^Server registry removeKey: self serverID ifAbsent: []].	^Server registry at: self serverID put: aSeasideServer</body><body package="Seaside-VisualWorks-Adaptors">logger	logger ifNil: [ (logger :=  CommonLog announcers: self)  file: self serverID, '.log' ].	^logger</body><body package="Seaside-VisualWorks-Adaptors">logging	^self logger isLogging</body><body package="Seaside-VisualWorks-Adaptors">logging: aBoolean	(aBoolean and: [ self logger isLogging not ]) ifTrue: [ self logger start ].	(aBoolean not and: [ self logger isLogging ]) ifTrue: [ self logger stop ].</body><body package="Seaside-VisualWorks-Adaptors">responder	^self current responders first</body><body package="Seaside-VisualWorks-Adaptors">serverID	^'Seaside'</body><body package="Seaside-VisualWorks-Adaptors">serverName	^'Cincom_Smalltalk VisualWorks ', SystemUtils.SystemVersionName</body><body package="Seaside-VisualWorks-Adaptors">siteURL	| address hostName urlClass |	address := self current listeners first address.	hostName := (address hostAddress = IPSocketAddress thisHost		ifTrue: [ SocketAccessor getHostname ]		ifFalse: [ address hostName ]).	urlClass := self current listeners first connectionClass protocol = 'https' 		ifTrue: [ #'Net.HttpsURL' asQualifiedReference value ]  		ifFalse: [Net.HttpURL].	^urlClass 			host: (hostName, ':', address port printString)			path: ( self responder seasideRequestDispatcher name tokensBasedOn: $/ )</body></methods><methods><class-id>SiouX.SeasideServer class</class-id> <category>defaults-constants</category><body package="Seaside-VisualWorks-Adaptors">defaultListeningIPAddress	^'0.0.0.0'</body><body package="Seaside-VisualWorks-Adaptors">defaultPortNumber	^7777</body></methods><methods><class-id>SiouX.SeasideServer class</class-id> <category>instance creation</category><body package="Seaside-VisualWorks-Adaptors">createServer	"	The current server configuration of listener and responder is done with	#server: pragma in SeasideServer class &gt;&gt; configureCurrent:	and #server:path: pragma in SeasideResponder class &gt;&gt; configureCurrent.	"	| wasInDebugMode current |	wasInDebugMode := false.		current := Server registry at: self serverID ifAbsent: [nil].	current ifNotNil: [ wasInDebugMode := current debugging ].	current:= self id: self serverID.	self isLogging ifTrue: [self startLog].	wasInDebugMode ifTrue: [self startDebugMode ].	^current</body></methods><methods><class-id>Grease.GRCodecStream</class-id> <category>accessing</category><body package="Seaside-VisualWorks-Adaptors">close	stream close</body></methods><methods><class-id>Grease.GRCodecStream</class-id> <category>streaming</category><body package="Seaside-VisualWorks-Adaptors">finish	stream finish</body></methods><methods><class-id>Grease.GRCodecStream</class-id> <category>testing</category><body package="Seaside-VisualWorks-Adaptors">isSegmented	^false</body><body package="Seaside-VisualWorks-Adaptors">needsFileLineEndConversion	^false</body></methods><methods><class-id>Grease.GRCodecStream</class-id> <category>streaming</category><body package="Seaside-VisualWorks-Adaptors">reset	stream reset</body></methods><methods><class-id>Seaside.WAResponse</class-id> <category>adaptors</category><body package="Seaside-VisualWorks-Adaptors">asHttpResponse: anHttpResponse	anHttpResponse statusCode: self status printString.	self headers associationsDo: [ :eachHeader | 		anHttpResponse addField: (Net.HeaderField									readFrom: (self fieldSourceFor: eachHeader)									acceptNonAsciiCharacters: true) ].	self cookies do: [ :eachCookie || cookieValue header |		header := Net.SetCookieField new.		cookieValue := header addName: eachCookie key value: (eachCookie value ifNil: [ '' ]).		eachCookie expiry ifNotNil: [ :val | cookieValue expires: val  ].		eachCookie path ifNotNil: [ :val | cookieValue path: val ].		eachCookie secure ifNotNil: [ :val | cookieValue secure: val ].		eachCookie httpOnly ifNotNil: [ :val | cookieValue httponly: val ].		anHttpResponse addField: header].	^anHttpResponse</body><body package="Seaside-VisualWorks-Adaptors">fieldSourceFor: aHeaderAssoc		^(aHeaderAssoc key, ': ',  aHeaderAssoc value greaseString) readStream</body></methods><methods><class-id>Seaside.WABufferedResponse</class-id> <category>adaptors</category><body package="Seaside-VisualWorks-Adaptors">asHttpResponse: anHttpResponse	super asHttpResponse: anHttpResponse.	self handlePadding.	anHttpResponse fieldAt: 'content-type' ifAbsent:		[ self contentType: ( Net.HeaderField readFrom: ('content-type: ' , self contentType greaseString) readWriteStream) ].	anHttpResponse body byteSource: self stream binary.	^anHttpResponse</body><body package="Seaside-VisualWorks-Adaptors">handlePadding	"If you create an error page that's too small, Microsoft Internet Explorer will display its own error page that includes a link to the MSN network search engine rather than your own error page. See &lt;http://www.404-error-page.com/404-error-page-too-short-problem-microsoft-ie.shtml&gt; for details."		| size |	size := self  stream size.	^ (size &lt; 512 and: [ #(400 403 404 405 406 408 409 410 500 501 505) includes: self   status ])		ifTrue: [ self  nextPutAll: (String new: (512 - size) withAll: $ ) ]</body></methods><methods><class-id>SiouX.SeasideResponder class</class-id> <category>configuration</category><body package="Seaside-VisualWorks-Adaptors">configureCurrent	&lt;server: 'Seaside' path: '/'&gt;</body></methods><methods><class-id>SiouX.SeasideServer class</class-id> <category>configuration</category><body package="Seaside-VisualWorks-Adaptors">configureCurrent: aSeasideServer	&lt;server: 'Seaside'&gt;	| address |	address := IPSocketAddress 		hostAddress: (ByteArray withAll: ((self defaultListeningIPAddress tokensBasedOn: $.) collect: [ :x | x asNumber ])) 		port: self defaultPortNumber.	aSeasideServer listenOn: address for: HttpConnection</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>HttpWritingOptions</name><environment>Net</environment><super>Net.MimeWritingOptions</super><private>false</private><indexed-type>none</indexed-type><inst-vars>useGZipTransfer chunkSize shouldChunk logAsPrintString setContentLength addUserAgentField userAgentFieldValue </inst-vars><class-inst-vars>useGZipTransfer shouldChunk logAsPrintString setContentLength addUserAgentField userAgentFieldValue </class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><class><name>WAResponse</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>headers cookies status message </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><class><name>Server</name><environment>SiouX</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>listeners connections responders debugging id logs noResponderReply </inst-vars><class-inst-vars>logFactory noResponderReply configurationFileName importErrorsFilename </class-inst-vars><imports>			private Protocols.*			private OS.*			private XML.*			</imports><category></category><attributes><package>SiouX-Server</package></attributes></class><class><name>HttpBuildHandler</name><environment>Net</environment><super>Net.MimeParserHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>decompressContents decodeContents </class-inst-vars><imports>			OS.ZLib.*			</imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class><class><name>GRCodecStream</name><environment>Grease</environment><super>Grease.GRDelegatingStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><class><name>WABufferedResponse</name><environment>Seaside</environment><super>Seaside.WAResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contentsStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><class><name>NetHttpResponder</name><environment>SiouX</environment><super>SiouX.Responder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>readingOptions writingOptions </inst-vars><class-inst-vars>defaultReadingOptions defaultWritingOptions </class-inst-vars><imports>			private OS.IOConstants.*			private Net.*			</imports><category></category><attributes><package>SiouX-Net-Http</package></attributes></class><class><name>HttpReadingOptions</name><environment>Net</environment><super>Net.MimeReadingOptions</super><private>false</private><indexed-type>none</indexed-type><inst-vars>decompressContents decodeContents </inst-vars><class-inst-vars>decompressContents decodeContents </class-inst-vars><imports></imports><category>Net-HTTP-Support</category><attributes><package>HTTP</package></attributes></class></st-source>