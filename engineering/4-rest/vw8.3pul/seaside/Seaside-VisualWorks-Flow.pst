<?xml version="1.0"?><st-source><!-- Name: Seaside-VisualWorks-FlowNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: Support Seaside-Flow in VisualWorks with Continuations.DbIdentifier: bear73DbTrace: 492586DbUsername: jkottDbVersion: 3.2.0 - 1DevelopmentPrerequisites: #(#(#any 'Grease-Core' '') #(#any 'Grease-VisualWorks-Core' '') #(#any 'Seaside-Namespace' '') #(#any 'Seaside-Core' '') #(#any 'Seaside-Flow' ''))PackageName: Seaside-VisualWorks-FlowParcel: #('Seaside-VisualWorks-Flow')PrerequisiteDescriptions: #(#(#name 'Grease-Core' #componentType #package) #(#name 'Grease-VisualWorks-Core' #componentType #package) #(#name 'Seaside-Namespace' #componentType #package) #(#name 'Seaside-Core' #componentType #package) #(#name 'Seaside-Flow' #componentType #package))PrerequisiteParcels: #(#('Grease-Core' '') #('Grease-VisualWorks-Core' '') #('Seaside-Namespace' '') #('Seaside-Core' '') #('Seaside-Flow' ''))PrintStringCache: (3.2.0 - 1,jkott)Version: 3.2.0 - 1Date: 3:31:27 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:31:27 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WAContinuation</name><environment>Seaside</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Seaside-VisualWorks-Flow</package></attributes></class><class><name>WAPartialContinuation</name><environment>Seaside</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Seaside-VisualWorks-Flow</package></attributes></class><class><name>WAMarkerNotFound</name><environment>Seaside</environment><super>Grease.GRError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Seaside-VisualWorks-Flow</package></attributes></class><class><name>WAMarkerRequest</name><environment>Seaside</environment><super>Grease.GRNotification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Seaside-VisualWorks-Flow</package></attributes></class><methods><class-id>Seaside.WAContinuation</class-id> <category>private</category><body package="Seaside-VisualWorks-Flow">initializeFromContext: aContext	| context stream |	self initialize.	context := aContext.	stream := WriteStream on: (Array new: 200).	[context notNil] whileTrue:		[stream nextPut: context.		1 to: context class instSize do: [:index | stream nextPut: (context instVarAt: index)].		1 to: context localSize do: [:index | stream nextPut: (context localAt: index)].		context := context sender].	values := stream contents</body><body package="Seaside-VisualWorks-Flow">restoreValues	| stream context |	stream := values readStream.	[stream atEnd] whileFalse:		[context := stream next.		1 to: context class instSize do: [:index | context instVarAt: index put: stream next].		1 to: context localSize do: [:index | context localAt: index put: stream next]]</body><body package="Seaside-VisualWorks-Flow">terminate: aContext	| context next |	context := aContext.	[context notNil] whileTrue: [next := context sender. context sender: nil. context := next]</body></methods><methods><class-id>Seaside.WAContinuation</class-id> <category>evaluating</category><body package="Seaside-VisualWorks-Flow">value	self value: nil</body><body package="Seaside-VisualWorks-Flow">value: anObject	"Invoke the continuation and answer anObject as return value."	self terminate: thisContext.	self restoreValues.	thisContext sender: values first.	^anObject</body><body package="Seaside-VisualWorks-Flow">valueWithArguments: anArray	anArray size = 1 ifFalse: [^self error: 'Continuations can only be resumed with one argument.'].	self value: anArray first</body><body package="Seaside-VisualWorks-Flow">valueWithPossibleArguments: anArray	^self value: anArray first</body></methods><methods><class-id>Seaside.WAContinuation</class-id> <category>accessing</category><body package="Seaside-VisualWorks-Flow">numArgs	^1</body></methods><methods><class-id>Seaside.WAContinuation class</class-id> <category>instance creation</category><body package="Seaside-VisualWorks-Flow">current	^self fromContext: thisContext sender</body><body package="Seaside-VisualWorks-Flow">currentDo: aBlock	^aBlock value: (self fromContext: thisContext sender)</body><body package="Seaside-VisualWorks-Flow">fromContext: aStack	^self basicNew initializeFromContext: aStack</body></methods><methods><class-id>Seaside.WAPartialContinuation</class-id> <category>private</category><body package="Seaside-VisualWorks-Flow">captureFrom: aSourceContext to: aTargetContext	"Utilitiy method to capture the contexts between aSourceContext and aTargetContext."	| stream context |	context := aSourceContext.	stream := WriteStream on: (Array new: 100).	[context isNil or: [context == aTargetContext]] whileFalse:		[stream nextPut: context.		1 to: context class instSize do: [ :index | stream nextPut: (context instVarAt: index)].		1 to: context localSize do: [ :index | stream nextPut: (context localAt: index)].		context := context sender].	context ifNil: [WAMarkerNotFound signal: aTargetContext printString , ' not found while capturing continuation.'].	^stream contents</body><body package="Seaside-VisualWorks-Flow">restoreValues	"Restore the captured context chain."	| stream context |	stream := values readStream.	[stream atEnd] whileFalse: 		[context := stream next.		1 to: context class instSize do: [ :index | context instVarAt: index put: stream next].		1 to: context localSize do: [ :index | context localAt: index put: stream next]].	^context</body><body package="Seaside-VisualWorks-Flow">unwindFrom: aSourceContext to: aTargetContext	"Utilitiy method to unwind and terminate from aSourceContext to aTargetContext. This implementation uses Squeak specific code implemented as primitives and is pretty fast."	aSourceContext unwindUpTo: aTargetContext.	aSourceContext terminateTo: aTargetContext</body></methods><methods><class-id>Seaside.WAPartialContinuation</class-id> <category>evaluating</category><body package="Seaside-VisualWorks-Flow">value	^self value: nil</body><body package="Seaside-VisualWorks-Flow">value: anObject	"Evaluate the receiving partial continuation. Note that partial continuations can be evaluated without a marker, in this case they are just spliced at the end of the current stack and resume return back to the sender."	| marker |	marker := WAMarkerRequest signal.	marker isNil		ifTrue: [marker := thisContext sender]		ifFalse: [self unwindFrom: thisContext to: marker].	self restoreValues sender: marker.	thisContext sender: values first.	^anObject</body><body package="Seaside-VisualWorks-Flow">valueWithArguments: anArray	^anArray size = 1		ifTrue:	[self value: anArray first]		ifFalse:	[self error: 'Continuations can only be resumed with one argument.']</body><body package="Seaside-VisualWorks-Flow">valueWithPossibleArguments: anArray	^self value: anArray first</body></methods><methods><class-id>Seaside.WAPartialContinuation</class-id> <category>initialize-release</category><body package="Seaside-VisualWorks-Flow">initializeFrom: aSourceContext to: aTargetContext	self initialize.	values := self captureFrom: aSourceContext to: aTargetContext</body></methods><methods><class-id>Seaside.WAPartialContinuation</class-id> <category>accessing</category><body package="Seaside-VisualWorks-Flow">numArgs	^1</body></methods><methods><class-id>Seaside.WAPartialContinuation class</class-id> <category>instance creation</category><body package="Seaside-VisualWorks-Flow">currentDo: aBlock	| marker |	marker := WAMarkerRequest signal ifNil: [WAMarkerNotFound signal: 'Marker not found when capturing partial continuation.'].	^aBlock value: (self from: thisContext sender to: marker)</body><body package="Seaside-VisualWorks-Flow">from: aSourceContext to: aTargetContext	^self basicNew initializeFrom: aSourceContext to: aTargetContext</body></methods><methods><class-id>Seaside.WAMarkerRequest</class-id> <category>private - actions</category><body package="Seaside-VisualWorks-Flow">defaultAction	^nil</body></methods><methods><class-id>Grease.GRVisualWorksPlatform</class-id> <category>*seaside-flow</category><body package="Seaside-VisualWorks-Flow">callbackMarker	| context |	context := thisContext sender.	[context isNil or: [(context receiver isKindOf: Seaside.WACallback) or: [context method homeMethod mclass == Seaside.WATaskVisitor and: [context method homeMethod selector = #visitTask:]]]]		whileFalse: [context := context sender].	context ifNil: [self error: 'You can only #call: and #answer: from within a callback or a Task.'].	^context</body><body package="Seaside-VisualWorks-Flow">seasideSuspendFlowDo: aBlock	| continuation |	continuation := Seaside.WAPartialContinuation		from: thisContext sender		to: self callbackMarker.	^aBlock value: [:answer |		[continuation value: answer]			on: Seaside.WAMarkerRequest			do: [:request | request resume: self callbackMarker]]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>GRNotification</name><environment>Grease</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Exceptions</category><attributes><package>Grease-Core</package></attributes></class><class><name>GRObject</name><environment>Grease</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core</category><attributes><package>Grease-Core</package></attributes></class><class><name>GRError</name><environment>Grease</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Exceptions</category><attributes><package>Grease-Core</package></attributes></class><class><name>GRVisualWorksPlatform</name><environment>Grease</environment><super>Grease.GRPlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Protocols.*			</imports><category></category><attributes><package>Grease-VisualWorks-Core</package></attributes></class></st-source>