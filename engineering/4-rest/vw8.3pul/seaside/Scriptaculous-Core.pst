<?xml version="1.0"?><st-source><!-- Name: Scriptaculous-CoreComment: script.aculo.us integration for Seaside. script.aculo.us provides you with easy-to-use, cross-browser user interface JavaScript libraries to make your web sites and web applications fly.DbIdentifier: bear73DbTrace: 492618DbUsername: jkottDbVersion: 3.2.0 - JohanBrichau.106 1DevelopmentPrerequisites: #(#(#any 'Scriptaculous-Namespace' '') #(#any 'Prototype-Core' ''))Id: 36195f1e-7e73-40a9-ad89-bd10fb363712Namespace: ScriptaculousPackageName: Scriptaculous-CoreParcel: #('Scriptaculous-Core')ParcelName: Scriptaculous-CorePrerequisiteParcels: #(#('Scriptaculous-Namespace' '') #('Prototype-Core' ''))PrintStringCache: (3.2.0 - JohanBrichau.106 1,jkott)Url: http://smalltalkhub.com/mc/Seaside/Seaside32/main/Scriptaculous-Core-JohanBrichau.106.mczVersion: 3.2.0 - JohanBrichau.106 1Date: 3:31:31 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:31:31 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SUSlider</name><environment>Scriptaculous</environment><super>Prototype.PTPrototype</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handleId trackId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Scriptaculous-Core-Controls</category><attributes><package>Scriptaculous-Core</package></attributes></class><class><name>SUDraggable</name><environment>Scriptaculous</environment><super>Prototype.PTNamed</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Scriptaculous-Core-Dragging</category><attributes><package>Scriptaculous-Core</package></attributes></class><class><name>SUSound</name><environment>Scriptaculous</environment><super>Prototype.PTNamed</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Scriptaculous-Core</category><attributes><package>Scriptaculous-Core</package></attributes></class><class><name>SUDroppable</name><environment>Scriptaculous</environment><super>Prototype.PTNamed</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Scriptaculous-Core-Dragging</category><attributes><package>Scriptaculous-Core</package></attributes></class><class><name>SUDevelopmentLibrary</name><environment>Scriptaculous</environment><super>Seaside.WAFileLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Scriptaculous-Core-Libraries</category><attributes><package>Scriptaculous-Core</package></attributes></class><class><name>SUEffect</name><environment>Scriptaculous</environment><super>Prototype.PTNamed</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Scriptaculous-Core</category><attributes><package>Scriptaculous-Core</package></attributes></class><class><name>SUInPlaceEditor</name><environment>Scriptaculous</environment><super>Prototype.PTUpdater</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Scriptaculous-Core-Controls</category><attributes><package>Scriptaculous-Core</package></attributes></class><class><name>SUGoogleLibrary</name><environment>Scriptaculous</environment><super>Seaside.WAFileLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Scriptaculous-Core-Libraries</category><attributes><package>Scriptaculous-Core</package></attributes></class><class><name>SUSortable</name><environment>Scriptaculous</environment><super>Prototype.PTNamed</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Scriptaculous-Core-Dragging</category><attributes><package>Scriptaculous-Core</package></attributes></class><class><name>SUAutocompleter</name><environment>Scriptaculous</environment><super>Prototype.PTUpdater</super><private>false</private><indexed-type>none</indexed-type><inst-vars>element </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Scriptaculous-Core-Controls</category><attributes><package>Scriptaculous-Core</package></attributes></class><class><name>SUInPlaceCollectionEditor</name><environment>Scriptaculous</environment><super>Scriptaculous.SUInPlaceEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Scriptaculous-Core-Controls</category><attributes><package>Scriptaculous-Core</package></attributes></class><methods><class-id>Scriptaculous.SUSlider</class-id> <category>private</category><body package="Scriptaculous-Core">defaultArguments	^ (Array with: self handleId with: self trackId) , super defaultArguments</body><body package="Scriptaculous-Core">defaultPrototype	^ 'Control.Slider'</body></methods><methods><class-id>Scriptaculous.SUSlider</class-id> <category>options</category><body package="Scriptaculous-Core">alignX: anNumber	"This will move the starting point on the x-axis for the handle in relation to the track. It is often used to move the 'point' of the handle to where 0 should be. It can also be used to set a different starting point on the track."	self optionAt: 'alignX' put: anNumber</body><body package="Scriptaculous-Core">alignY: anNumber	"This will move the starting point on the y-axis for the handle in relation to the track. It is often used to move the 'point' of the handle to where 0 should be. It can also be used to set a different starting point on the track."	self optionAt: 'alignY' put: anNumber</body><body package="Scriptaculous-Core">axis: aSymbol	"Sets the direction that the slider will move in. It should either be horizontal or vertical."	self optionAt: 'axis' put: aSymbol</body><body package="Scriptaculous-Core">disabled: aBoolean	"This will lock the slider so that it will not move and thus is disabled."	self optionAt: 'disabled' put: aBoolean</body><body package="Scriptaculous-Core">increment: aNumber	"Defines the relationship of value to pixels. Setting this to 1 will mean each movement of 1 pixel equates to 1 value."	self optionAt: 'increment' put: aNumber</body><body package="Scriptaculous-Core">maximum: aNumber	"The maximum value that the slider will move to. For horizontal this is to the right while vertical it is down."	self optionAt: 'maximum' put: aNumber</body><body package="Scriptaculous-Core">minimum: aNumber	"The minimum value that the slider can move to. For horizontal this is to the left while vertical it is up."	self optionAt: 'minimum' put: aNumber</body><body package="Scriptaculous-Core">range: anInterval	self optionAt: 'range' put: anInterval</body><body package="Scriptaculous-Core">value: aNumber	"Will set the initial slider value. The handle will be set to this value, assuming it is within the minimum and maxium values."	self optionAt: 'sliderValue' put: aNumber</body><body package="Scriptaculous-Core">values: anArray	"Accepts an array of integers. If set these will be the only legal values for the slider to be at. Thus you can set specific slider values that the user can move the slider to."	self optionAt: 'values' put: anArray</body></methods><methods><class-id>Scriptaculous.SUSlider</class-id> <category>accessing</category><body package="Scriptaculous-Core">handleId	^ handleId</body><body package="Scriptaculous-Core">handleId: aString	^ handleId := aString</body><body package="Scriptaculous-Core">trackId	^ trackId</body><body package="Scriptaculous-Core">trackId: aString	trackId := aString</body></methods><methods><class-id>Scriptaculous.SUSlider</class-id> <category>events</category><body package="Scriptaculous-Core">onChange: anObject	"Called whenever the Slider has finished moving or has had its value changed. The called function gets the slider value as its parameter."	self optionAt: 'onChange' put: anObject asFunction</body><body package="Scriptaculous-Core">onSlide: anObject	"Called whenever the Slider is moved by dragging. The called function gets the slider value as its parameter."	self optionAt: 'onSlide' put: anObject asFunction</body></methods><methods><class-id>Scriptaculous.SUSlider</class-id> <category>initialization</category><body package="Scriptaculous-Core">initialize	super initialize.	self create</body></methods><methods><class-id>Scriptaculous.SUDraggable</class-id> <category>options</category><body package="Scriptaculous-Core">constraint: aSymbol	"If set to #horizontal or #vertical the drag will be constrained to take place only horizontally or vertically."	self optionAt: 'constraint' put: aSymbol</body><body package="Scriptaculous-Core">constraintHorizontal	self constraint: #horizontal</body><body package="Scriptaculous-Core">constraintVertical	self constraint: #vertical</body><body package="Scriptaculous-Core">delay: aDuration	self optionAt: 'delay' put: aDuration</body><body package="Scriptaculous-Core">ghosting: aBoolean	"Clones the element and drags the clone, leaving the original in place until the clone is dropped."	self optionAt: 'ghosting' put: aBoolean</body><body package="Scriptaculous-Core">handle: aString	"Sets whether the element should only be draggable by an embedded handle. The value must be an element reference or element id."	self optionAt: 'handle' put: aString</body><body package="Scriptaculous-Core">revert: aBoolean	"If set to true, the element returns to its original position when the drags ends."	self optionAt: 'revert' put: aBoolean</body><body package="Scriptaculous-Core">scroll: aBoolean	self optionAt: 'scroll' put: aBoolean</body><body package="Scriptaculous-Core">scrollSensitivity: anInteger	self optionAt: 'scrollSensitivity' put: anInteger</body><body package="Scriptaculous-Core">scrollSpeed: anInteger	self optionAt: 'scrollSpeed' put: anInteger</body><body package="Scriptaculous-Core">snap: aBooleanOrPoint	"If set to false no snapping occurs. Otherwise takes the forms [x,y]."	self optionAt: 'snap' put: aBooleanOrPoint</body><body package="Scriptaculous-Core">zindex: anInteger	"The css zindex of the draggable item."	self optionAt: 'zindex' put: anInteger</body></methods><methods><class-id>Scriptaculous.SUDraggable</class-id> <category>events</category><body package="Scriptaculous-Core">onChange: anObject	self optionAt: 'change' put: anObject asFunction</body><body package="Scriptaculous-Core">onDrag: anObject	self optionAt: 'onDrag' put: anObject asFunction</body><body package="Scriptaculous-Core">onDropped: anObject	self optionAt: 'onDropped' put: anObject asFunction</body><body package="Scriptaculous-Core">onEnd: anObject	self optionAt: 'onEnd' put: anObject asFunction</body><body package="Scriptaculous-Core">onSnap: anObject	self optionAt: 'snap' put: anObject asFunction</body><body package="Scriptaculous-Core">onStart: anObject	self optionAt: 'onStart' put: anObject asFunction</body></methods><methods><class-id>Scriptaculous.SUDraggable</class-id> <category>effects</category><body package="Scriptaculous-Core">endEffect: anObject	self optionAt: 'endeffect' put: anObject asFunction</body><body package="Scriptaculous-Core">revertEffect: anObject	self optionAt: 'reverteffect' put: anObject asFunction</body><body package="Scriptaculous-Core">startEffect: anObject	self optionAt: 'starteffect' put: anObject asFunction</body></methods><methods><class-id>Scriptaculous.SUDraggable</class-id> <category>initialization</category><body package="Scriptaculous-Core">initialize	super initialize.	self create</body></methods><methods><class-id>Scriptaculous.SUDraggable</class-id> <category>private</category><body package="Scriptaculous-Core">defaultPrototype	^ 'Draggable'</body></methods><methods><class-id>Scriptaculous.SUSound</class-id> <category>private</category><body package="Scriptaculous-Core">defaultMethod	^ 'play'</body><body package="Scriptaculous-Core">defaultPrototype	^ 'Sound'</body></methods><methods><class-id>Scriptaculous.SUSound</class-id> <category>options</category><body package="Scriptaculous-Core">replace: aBoolean	self optionAt: 'replace' put: aBoolean</body><body package="Scriptaculous-Core">track: aString	self optionAt: 'track' put: aString</body></methods><methods><class-id>Scriptaculous.SUSound</class-id> <category>accessing</category><body package="Scriptaculous-Core">url	^ id</body><body package="Scriptaculous-Core">url: aUrl	id := aUrl</body></methods><methods><class-id>Scriptaculous.SUSound</class-id> <category>actions</category><body package="Scriptaculous-Core">disable	self method: 'disable'</body><body package="Scriptaculous-Core">enable	self method: 'enable'</body><body package="Scriptaculous-Core">play	self method: 'play'</body><body package="Scriptaculous-Core">play: aUrl	self url: aUrl; play</body></methods><methods><class-id>Scriptaculous.SUDroppable</class-id> <category>options</category><body package="Scriptaculous-Core">accept: aStringOrArray	"Set accept to a string or an array of strings describing CSS classes. The Droppable will only accept Draggables that have one or more of these CSS classes."	self optionAt: 'accept' put: aStringOrArray</body><body package="Scriptaculous-Core">containment: aStringOrArray	"The droppable will only accept the Draggable if the Draggable is contained in the given elements (or element ids). Can be a single element or an array of elements."	self optionAt: 'containment' put: aStringOrArray</body><body package="Scriptaculous-Core">greedy: aBoolean	"If true stops processing hovering (don't look for other Droppables that are under the Draggable)."	self optionAt: 'greedy' put: aBoolean</body><body package="Scriptaculous-Core">hoverclass: aString	"If set, the Droppable will have this additional CSS class when an accepted Draggable is hovered over it."	self optionAt: 'hoverclass' put: aString</body><body package="Scriptaculous-Core">overlap: aString	"If set to 'horizontal' or 'vertical' the droppable will only react to a Draggable if its overlapping by more than 50% in the given direction."	self optionAt: 'overlap' put: aString</body><body package="Scriptaculous-Core">overlapHorizontal	self overlap: 'horizontal'</body><body package="Scriptaculous-Core">overlapVertical	self overlap: 'vertical'</body></methods><methods><class-id>Scriptaculous.SUDroppable</class-id> <category>private</category><body package="Scriptaculous-Core">defaultMethod	^ 'add'</body><body package="Scriptaculous-Core">defaultPrototype	^ 'Droppables'</body></methods><methods><class-id>Scriptaculous.SUDroppable</class-id> <category>actions</category><body package="Scriptaculous-Core">add	"To make an element react when a Draggable is dropped onto it."	self method: 'add'</body><body package="Scriptaculous-Core">remove	"Remove any droppable capabilities from element."	self method: 'remove'</body></methods><methods><class-id>Scriptaculous.SUDroppable</class-id> <category>events</category><body package="Scriptaculous-Core">onDrop: anObject	"Called whenever a Draggable is released over the Droppable and the Droppable is accepts it."	self optionAt: 'onDrop' put: anObject asFunction</body><body package="Scriptaculous-Core">onHover: anObject	"Called whenever a Draggable is moved over the Droppable and the Droppable is affected (would accept it). The callback gets 2 parameters, the passenger of the draggable and the percentage of overlapping as defined by the overlap option."	self optionAt: 'onHover' put: anObject asFunction</body></methods><methods><class-id>Scriptaculous.SUDevelopmentLibrary</class-id> <category>accessing</category><body package="Scriptaculous-Core">selectorsToInclude	^ #( scriptaculousJs treePatchJs )</body></methods><methods><class-id>Scriptaculous.SUDevelopmentLibrary</class-id> <category>patches</category><body package="Scriptaculous-Core">treePatchJs	^ 'Object.extend(Sortable, {	tree_sequence: function(element, options) {		return Sortable.tree(element, options).children.map(function(each) {			return [encodeURIComponent(each.parent.id) + ":" + encodeURIComponent(each.id)]				.concat(each.children.map(arguments.callee));		}).flatten().join(","); } });'</body></methods><methods><class-id>Scriptaculous.SUDevelopmentLibrary</class-id> <category>uploaded</category><body package="Scriptaculous-Core">builderJs	^ '// script.aculo.us builder.js v1.9.0, Thu Dec 23 16:54:48 -0500 2010// Copyright (c) 2005-2010 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)//// script.aculo.us is freely distributable under the terms of an MIT-style license.// For details, see the script.aculo.us web site: http://script.aculo.us/var Builder = {  NODEMAP: {    AREA: ''map'',    CAPTION: ''table'',    COL: ''table'',    COLGROUP: ''table'',    LEGEND: ''fieldset'',    OPTGROUP: ''select'',    OPTION: ''select'',    PARAM: ''object'',    TBODY: ''table'',    TD: ''table'',    TFOOT: ''table'',    TH: ''table'',    THEAD: ''table'',    TR: ''table''  },  // note: For Firefox &lt; 1.5, OPTION and OPTGROUP tags are currently broken,  //       due to a Firefox bug  node: function(elementName) {    elementName = elementName.toUpperCase();    // try innerHTML approach    var parentTag = this.NODEMAP[elementName] || ''div'';    var parentElement = document.createElement(parentTag);    try { // prevent IE "feature": http://dev.rubyonrails.org/ticket/2707      parentElement.innerHTML = "&lt;" + elementName + "&gt;&lt;/" + elementName + "&gt;";    } catch(e) {}    var element = parentElement.firstChild || null;    // see if browser added wrapping tags    if(element &amp;&amp; (element.tagName.toUpperCase() != elementName))      element = element.getElementsByTagName(elementName)[0];    // fallback to createElement approach    if(!element) element = document.createElement(elementName);    // abort if nothing could be created    if(!element) return;    // attributes (or text)    if(arguments[1])      if(this._isStringOrNumber(arguments[1]) ||        (arguments[1] instanceof Array) ||        arguments[1].tagName) {          this._children(element, arguments[1]);        } else {          var attrs = this._attributes(arguments[1]);          if(attrs.length) {            try { // prevent IE "feature": http://dev.rubyonrails.org/ticket/2707              parentElement.innerHTML = "&lt;" +elementName + " " +                attrs + "&gt;&lt;/" + elementName + "&gt;";            } catch(e) {}            element = parentElement.firstChild || null;            // workaround firefox 1.0.X bug            if(!element) {              element = document.createElement(elementName);              for(attr in arguments[1])                element[attr == ''class'' ? ''className'' : attr] = arguments[1][attr];            }            if(element.tagName.toUpperCase() != elementName)              element = parentElement.getElementsByTagName(elementName)[0];          }        }    // text, or array of children    if(arguments[2])      this._children(element, arguments[2]);     return $(element);  },  _text: function(text) {     return document.createTextNode(text);  },  ATTR_MAP: {    ''className'': ''class'',    ''htmlFor'': ''for''  },  _attributes: function(attributes) {    var attrs = [];    for(attribute in attributes)      attrs.push((attribute in this.ATTR_MAP ? this.ATTR_MAP[attribute] : attribute) +          ''="'' + attributes[attribute].toString().escapeHTML().gsub(/"/,''&amp;quot;'') + ''"'');    return attrs.join(" ");  },  _children: function(element, children) {    if(children.tagName) {      element.appendChild(children);      return;    }    if(typeof children==''object'') { // array can hold nodes and text      children.flatten().each( function(e) {        if(typeof e==''object'')          element.appendChild(e);        else          if(Builder._isStringOrNumber(e))            element.appendChild(Builder._text(e));      });    } else      if(Builder._isStringOrNumber(children))        element.appendChild(Builder._text(children));  },  _isStringOrNumber: function(param) {    return(typeof param==''string'' || typeof param==''number'');  },  build: function(html) {    var element = this.node(''div'');    $(element).update(html.strip());    return element.down();  },  dump: function(scope) {    if(typeof scope != ''object'' &amp;&amp; typeof scope != ''function'') scope = window; //global scope    var tags = ("A ABBR ACRONYM ADDRESS APPLET AREA B BASE BASEFONT BDO BIG BLOCKQUOTE BODY " +      "BR BUTTON CAPTION CENTER CITE CODE COL COLGROUP DD DEL DFN DIR DIV DL DT EM FIELDSET " +      "FONT FORM FRAME FRAMESET H1 H2 H3 H4 H5 H6 HEAD HR HTML I IFRAME IMG INPUT INS ISINDEX "+      "KBD LABEL LEGEND LI LINK MAP MENU META NOFRAMES NOSCRIPT OBJECT OL OPTGROUP OPTION P "+      "PARAM PRE Q S SAMP SCRIPT SELECT SMALL SPAN STRIKE STRONG STYLE SUB SUP TABLE TBODY TD "+      "TEXTAREA TFOOT TH THEAD TITLE TR TT U UL VAR").split(/\s+/);    tags.each( function(tag){      scope[tag] = function() {        return Builder.node.apply(Builder, [tag].concat($A(arguments)));      };    });  }};'</body><body package="Scriptaculous-Core">controlsJs	^ '// script.aculo.us controls.js v1.9.0, Thu Dec 23 16:54:48 -0500 2010// Copyright (c) 2005-2010 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)//           (c) 2005-2010 Ivan Krstic (http://blogs.law.harvard.edu/ivan)//           (c) 2005-2010 Jon Tirsen (http://www.tirsen.com)// Contributors://  Richard Livsey//  Rahul Bhargava//  Rob Wills//// script.aculo.us is freely distributable under the terms of an MIT-style license.// For details, see the script.aculo.us web site: http://script.aculo.us/// Autocompleter.Base handles all the autocompletion functionality// that''s independent of the data source for autocompletion. This// includes drawing the autocompletion menu, observing keyboard// and mouse events, and similar.//// Specific autocompleters need to provide, at the very least,// a getUpdatedChoices function that will be invoked every time// the text inside the monitored textbox changes. This method// should get the text for which to provide autocompletion by// invoking this.getToken(), NOT by directly accessing// this.element.value. This is to allow incremental tokenized// autocompletion. Specific auto-completion logic (AJAX, etc)// belongs in getUpdatedChoices.//// Tokenized incremental autocompletion is enabled automatically// when an autocompleter is instantiated with the ''tokens'' option// in the options parameter, e.g.:// new Ajax.Autocompleter(''id'',''upd'', ''/url/'', { tokens: '','' });// will incrementally autocomplete with a comma as the token.// Additionally, '','' in the above example can be replaced with// a token array, e.g. { tokens: ['','', ''\n''] } which// enables autocompletion on multiple tokens. This is most// useful when one of the tokens is \n (a newline), as it// allows smart autocompletion after linebreaks.if(typeof Effect == ''undefined'')  throw("controls.js requires including script.aculo.us'' effects.js library");var Autocompleter = { };Autocompleter.Base = Class.create({  baseInitialize: function(element, update, options) {    element          = $(element);    this.element     = element;    this.update      = $(update);    this.hasFocus    = false;    this.changed     = false;    this.active      = false;    this.index       = 0;    this.entryCount  = 0;    this.oldElementValue = this.element.value;    if(this.setOptions)      this.setOptions(options);    else      this.options = options || { };    this.options.paramName    = this.options.paramName || this.element.name;    this.options.tokens       = this.options.tokens || [];    this.options.frequency    = this.options.frequency || 0.4;    this.options.minChars     = this.options.minChars || 1;    this.options.onShow       = this.options.onShow ||      function(element, update){        if(!update.style.position || update.style.position==''absolute'') {          update.style.position = ''absolute'';          Position.clone(element, update, {            setHeight: false,            offsetTop: element.offsetHeight          });        }        Effect.Appear(update,{duration:0.15});      };    this.options.onHide = this.options.onHide ||      function(element, update){ new Effect.Fade(update,{duration:0.15}) };    if(typeof(this.options.tokens) == ''string'')      this.options.tokens = new Array(this.options.tokens);    // Force carriage returns as token delimiters anyway    if (!this.options.tokens.include(''\n''))      this.options.tokens.push(''\n'');    this.observer = null;    this.element.setAttribute(''autocomplete'',''off'');    Element.hide(this.update);    Event.observe(this.element, ''blur'', this.onBlur.bindAsEventListener(this));    Event.observe(this.element, ''keydown'', this.onKeyPress.bindAsEventListener(this));  },  show: function() {    if(Element.getStyle(this.update, ''display'')==''none'') this.options.onShow(this.element, this.update);    if(!this.iefix &amp;&amp;      (Prototype.Browser.IE) &amp;&amp;      (Element.getStyle(this.update, ''position'')==''absolute'')) {      new Insertion.After(this.update,       ''&lt;iframe id="'' + this.update.id + ''_iefix" ''+       ''style="display:none;position:absolute;filter:progid:DXImageTransform.Microsoft.Alpha(opacity=0);" '' +       ''src="javascript:false;" frameborder="0" scrolling="no"&gt;&lt;/iframe&gt;'');      this.iefix = $(this.update.id+''_iefix'');    }    if(this.iefix) setTimeout(this.fixIEOverlapping.bind(this), 50);  },  fixIEOverlapping: function() {    Position.clone(this.update, this.iefix, {setTop:(!this.update.style.height)});    this.iefix.style.zIndex = 1;    this.update.style.zIndex = 2;    Element.show(this.iefix);  },  hide: function() {    this.stopIndicator();    if(Element.getStyle(this.update, ''display'')!=''none'') this.options.onHide(this.element, this.update);    if(this.iefix) Element.hide(this.iefix);  },  startIndicator: function() {    if(this.options.indicator) Element.show(this.options.indicator);  },  stopIndicator: function() {    if(this.options.indicator) Element.hide(this.options.indicator);  },  onKeyPress: function(event) {    if(this.active)      switch(event.keyCode) {       case Event.KEY_TAB:       case Event.KEY_RETURN:         this.selectEntry();         Event.stop(event);       case Event.KEY_ESC:         this.hide();         this.active = false;         Event.stop(event);         return;       case Event.KEY_LEFT:       case Event.KEY_RIGHT:         return;       case Event.KEY_UP:         this.markPrevious();         this.render();         Event.stop(event);         return;       case Event.KEY_DOWN:         this.markNext();         this.render();         Event.stop(event);         return;      }     else       if(event.keyCode==Event.KEY_TAB || event.keyCode==Event.KEY_RETURN ||         (Prototype.Browser.WebKit &gt; 0 &amp;&amp; event.keyCode == 0)) return;    this.changed = true;    this.hasFocus = true;    if(this.observer) clearTimeout(this.observer);      this.observer =        setTimeout(this.onObserverEvent.bind(this), this.options.frequency*1000);  },  activate: function() {    this.changed = false;    this.hasFocus = true;    this.getUpdatedChoices();  },  onHover: function(event) {    var element = Event.findElement(event, ''LI'');    if(this.index != element.autocompleteIndex)    {        this.index = element.autocompleteIndex;        this.render();    }    Event.stop(event);  },  onClick: function(event) {    var element = Event.findElement(event, ''LI'');    this.index = element.autocompleteIndex;    this.selectEntry();    this.hide();  },  onBlur: function(event) {    // needed to make click events working    setTimeout(this.hide.bind(this), 250);    this.hasFocus = false;    this.active = false;  },  render: function() {    if(this.entryCount &gt; 0) {      for (var i = 0; i &lt; this.entryCount; i++)        this.index==i ?          Element.addClassName(this.getEntry(i),"selected") :          Element.removeClassName(this.getEntry(i),"selected");      if(this.hasFocus) {        this.show();        this.active = true;      }    } else {      this.active = false;      this.hide();    }  },  markPrevious: function() {    if(this.index &gt; 0) this.index--;      else this.index = this.entryCount-1;    this.getEntry(this.index).scrollIntoView(true);  },  markNext: function() {    if(this.index &lt; this.entryCount-1) this.index++;      else this.index = 0;    this.getEntry(this.index).scrollIntoView(false);  },  getEntry: function(index) {    return this.update.firstChild.childNodes[index];  },  getCurrentEntry: function() {    return this.getEntry(this.index);  },  selectEntry: function() {    this.active = false;    this.updateElement(this.getCurrentEntry());  },  updateElement: function(selectedElement) {    if (this.options.updateElement) {      this.options.updateElement(selectedElement);      return;    }    var value = '''';    if (this.options.select) {      var nodes = $(selectedElement).select(''.'' + this.options.select) || [];      if(nodes.length&gt;0) value = Element.collectTextNodes(nodes[0], this.options.select);    } else      value = Element.collectTextNodesIgnoreClass(selectedElement, ''informal'');    var bounds = this.getTokenBounds();    if (bounds[0] != -1) {      var newValue = this.element.value.substr(0, bounds[0]);      var whitespace = this.element.value.substr(bounds[0]).match(/^\s+/);      if (whitespace)        newValue += whitespace[0];      this.element.value = newValue + value + this.element.value.substr(bounds[1]);    } else {      this.element.value = value;    }    this.oldElementValue = this.element.value;    this.element.focus();    if (this.options.afterUpdateElement)      this.options.afterUpdateElement(this.element, selectedElement);  },  updateChoices: function(choices) {    if(!this.changed &amp;&amp; this.hasFocus) {      this.update.innerHTML = choices;      Element.cleanWhitespace(this.update);      Element.cleanWhitespace(this.update.down());      if(this.update.firstChild &amp;&amp; this.update.down().childNodes) {        this.entryCount =          this.update.down().childNodes.length;        for (var i = 0; i &lt; this.entryCount; i++) {          var entry = this.getEntry(i);          entry.autocompleteIndex = i;          this.addObservers(entry);        }      } else {        this.entryCount = 0;      }      this.stopIndicator();      this.index = 0;      if(this.entryCount==1 &amp;&amp; this.options.autoSelect) {        this.selectEntry();        this.hide();      } else {        this.render();      }    }  },  addObservers: function(element) {    Event.observe(element, "mouseover", this.onHover.bindAsEventListener(this));    Event.observe(element, "click", this.onClick.bindAsEventListener(this));  },  onObserverEvent: function() {    this.changed = false;    this.tokenBounds = null;    if(this.getToken().length&gt;=this.options.minChars) {      this.getUpdatedChoices();    } else {      this.active = false;      this.hide();    }    this.oldElementValue = this.element.value;  },  getToken: function() {    var bounds = this.getTokenBounds();    return this.element.value.substring(bounds[0], bounds[1]).strip();  },  getTokenBounds: function() {    if (null != this.tokenBounds) return this.tokenBounds;    var value = this.element.value;    if (value.strip().empty()) return [-1, 0];    var diff = arguments.callee.getFirstDifferencePos(value, this.oldElementValue);    var offset = (diff == this.oldElementValue.length ? 1 : 0);    var prevTokenPos = -1, nextTokenPos = value.length;    var tp;    for (var index = 0, l = this.options.tokens.length; index &lt; l; ++index) {      tp = value.lastIndexOf(this.options.tokens[index], diff + offset - 1);      if (tp &gt; prevTokenPos) prevTokenPos = tp;      tp = value.indexOf(this.options.tokens[index], diff + offset);      if (-1 != tp &amp;&amp; tp &lt; nextTokenPos) nextTokenPos = tp;    }    return (this.tokenBounds = [prevTokenPos + 1, nextTokenPos]);  }});Autocompleter.Base.prototype.getTokenBounds.getFirstDifferencePos = function(newS, oldS) {  var boundary = Math.min(newS.length, oldS.length);  for (var index = 0; index &lt; boundary; ++index)    if (newS[index] != oldS[index])      return index;  return boundary;};Ajax.Autocompleter = Class.create(Autocompleter.Base, {  initialize: function(element, update, url, options) {    this.baseInitialize(element, update, options);    this.options.asynchronous  = true;    this.options.onComplete    = this.onComplete.bind(this);    this.options.defaultParams = this.options.parameters || null;    this.url                   = url;  },  getUpdatedChoices: function() {    this.startIndicator();    var entry = encodeURIComponent(this.options.paramName) + ''='' +      encodeURIComponent(this.getToken());    this.options.parameters = this.options.callback ?      this.options.callback(this.element, entry) : entry;    if(this.options.defaultParams)      this.options.parameters += ''&amp;'' + this.options.defaultParams;    new Ajax.Request(this.url, this.options);  },  onComplete: function(request) {    this.updateChoices(request.responseText);  }});// The local array autocompleter. Used when you''d prefer to// inject an array of autocompletion options into the page, rather// than sending out Ajax queries, which can be quite slow sometimes.//// The constructor takes four parameters. The first two are, as usual,// the id of the monitored textbox, and id of the autocompletion menu.// The third is the array you want to autocomplete from, and the fourth// is the options block.//// Extra local autocompletion options:// - choices - How many autocompletion choices to offer//// - partialSearch - If false, the autocompleter will match entered//                    text only at the beginning of strings in the//                    autocomplete array. Defaults to true, which will//                    match text at the beginning of any *word* in the//                    strings in the autocomplete array. If you want to//                    search anywhere in the string, additionally set//                    the option fullSearch to true (default: off).//// - fullSsearch - Search anywhere in autocomplete array strings.//// - partialChars - How many characters to enter before triggering//                   a partial match (unlike minChars, which defines//                   how many characters are required to do any match//                   at all). Defaults to 2.//// - ignoreCase - Whether to ignore case when autocompleting.//                 Defaults to true.//// It''s possible to pass in a custom function as the ''selector''// option, if you prefer to write your own autocompletion logic.// In that case, the other options above will not apply unless// you support them.Autocompleter.Local = Class.create(Autocompleter.Base, {  initialize: function(element, update, array, options) {    this.baseInitialize(element, update, options);    this.options.array = array;  },  getUpdatedChoices: function() {    this.updateChoices(this.options.selector(this));  },  setOptions: function(options) {    this.options = Object.extend({      choices: 10,      partialSearch: true,      partialChars: 2,      ignoreCase: true,      fullSearch: false,      selector: function(instance) {        var ret       = []; // Beginning matches        var partial   = []; // Inside matches        var entry     = instance.getToken();        var count     = 0;        for (var i = 0; i &lt; instance.options.array.length &amp;&amp;          ret.length &lt; instance.options.choices ; i++) {          var elem = instance.options.array[i];          var foundPos = instance.options.ignoreCase ?            elem.toLowerCase().indexOf(entry.toLowerCase()) :            elem.indexOf(entry);          while (foundPos != -1) {            if (foundPos == 0 &amp;&amp; elem.length != entry.length) {              ret.push("&lt;li&gt;&lt;strong&gt;" + elem.substr(0, entry.length) + "&lt;/strong&gt;" +                elem.substr(entry.length) + "&lt;/li&gt;");              break;            } else if (entry.length &gt;= instance.options.partialChars &amp;&amp;              instance.options.partialSearch &amp;&amp; foundPos != -1) {              if (instance.options.fullSearch || /\s/.test(elem.substr(foundPos-1,1))) {                partial.push("&lt;li&gt;" + elem.substr(0, foundPos) + "&lt;strong&gt;" +                  elem.substr(foundPos, entry.length) + "&lt;/strong&gt;" + elem.substr(                  foundPos + entry.length) + "&lt;/li&gt;");                break;              }            }            foundPos = instance.options.ignoreCase ?              elem.toLowerCase().indexOf(entry.toLowerCase(), foundPos + 1) :              elem.indexOf(entry, foundPos + 1);          }        }        if (partial.length)          ret = ret.concat(partial.slice(0, instance.options.choices - ret.length));        return "&lt;ul&gt;" + ret.join('''') + "&lt;/ul&gt;";      }    }, options || { });  }});// AJAX in-place editor and collection editor// Full rewrite by Christophe Porteneuve &lt;tdd@tddsworld.com&gt; (April 2007).// Use this if you notice weird scrolling problems on some browsers,// the DOM might be a bit confused when this gets called so do this// waits 1 ms (with setTimeout) until it does the activationField.scrollFreeActivate = function(field) {  setTimeout(function() {    Field.activate(field);  }, 1);};Ajax.InPlaceEditor = Class.create({  initialize: function(element, url, options) {    this.url = url;    this.element = element = $(element);    this.prepareOptions();    this._controls = { };    arguments.callee.dealWithDeprecatedOptions(options); // DEPRECATION LAYER!!!    Object.extend(this.options, options || { });    if (!this.options.formId &amp;&amp; this.element.id) {      this.options.formId = this.element.id + ''-inplaceeditor'';      if ($(this.options.formId))        this.options.formId = '''';    }    if (this.options.externalControl)      this.options.externalControl = $(this.options.externalControl);    if (!this.options.externalControl)      this.options.externalControlOnly = false;    this._originalBackground = this.element.getStyle(''background-color'') || ''transparent'';    this.element.title = this.options.clickToEditText;    this._boundCancelHandler = this.handleFormCancellation.bind(this);    this._boundComplete = (this.options.onComplete || Prototype.emptyFunction).bind(this);    this._boundFailureHandler = this.handleAJAXFailure.bind(this);    this._boundSubmitHandler = this.handleFormSubmission.bind(this);    this._boundWrapperHandler = this.wrapUp.bind(this);    this.registerListeners();  },  checkForEscapeOrReturn: function(e) {    if (!this._editing || e.ctrlKey || e.altKey || e.shiftKey) return;    if (Event.KEY_ESC == e.keyCode)      this.handleFormCancellation(e);    else if (Event.KEY_RETURN == e.keyCode)      this.handleFormSubmission(e);  },  createControl: function(mode, handler, extraClasses) {    var control = this.options[mode + ''Control''];    var text = this.options[mode + ''Text''];    if (''button'' == control) {      var btn = document.createElement(''input'');      btn.type = ''submit'';      btn.value = text;      btn.className = ''editor_'' + mode + ''_button'';      if (''cancel'' == mode)        btn.onclick = this._boundCancelHandler;      this._form.appendChild(btn);      this._controls[mode] = btn;    } else if (''link'' == control) {      var link = document.createElement(''a'');      link.href = ''#'';      link.appendChild(document.createTextNode(text));      link.onclick = ''cancel'' == mode ? this._boundCancelHandler : this._boundSubmitHandler;      link.className = ''editor_'' + mode + ''_link'';      if (extraClasses)        link.className += '' '' + extraClasses;      this._form.appendChild(link);      this._controls[mode] = link;    }  },  createEditField: function() {    var text = (this.options.loadTextURL ? this.options.loadingText : this.getText());    var fld;    if (1 &gt;= this.options.rows &amp;&amp; !/\r|\n/.test(this.getText())) {      fld = document.createElement(''input'');      fld.type = ''text'';      var size = this.options.size || this.options.cols || 0;      if (0 &lt; size) fld.size = size;    } else {      fld = document.createElement(''textarea'');      fld.rows = (1 &gt;= this.options.rows ? this.options.autoRows : this.options.rows);      fld.cols = this.options.cols || 40;    }    fld.name = this.options.paramName;    fld.value = text; // No HTML breaks conversion anymore    fld.className = ''editor_field'';    if (this.options.submitOnBlur)      fld.onblur = this._boundSubmitHandler;    this._controls.editor = fld;    if (this.options.loadTextURL)      this.loadExternalText();    this._form.appendChild(this._controls.editor);  },  createForm: function() {    var ipe = this;    function addText(mode, condition) {      var text = ipe.options[''text'' + mode + ''Controls''];      if (!text || condition === false) return;      ipe._form.appendChild(document.createTextNode(text));    };    this._form = $(document.createElement(''form''));    this._form.id = this.options.formId;    this._form.addClassName(this.options.formClassName);    this._form.onsubmit = this._boundSubmitHandler;    this.createEditField();    if (''textarea'' == this._controls.editor.tagName.toLowerCase())      this._form.appendChild(document.createElement(''br''));    if (this.options.onFormCustomization)      this.options.onFormCustomization(this, this._form);    addText(''Before'', this.options.okControl || this.options.cancelControl);    this.createControl(''ok'', this._boundSubmitHandler);    addText(''Between'', this.options.okControl &amp;&amp; this.options.cancelControl);    this.createControl(''cancel'', this._boundCancelHandler, ''editor_cancel'');    addText(''After'', this.options.okControl || this.options.cancelControl);  },  destroy: function() {    if (this._oldInnerHTML)      this.element.innerHTML = this._oldInnerHTML;    this.leaveEditMode();    this.unregisterListeners();  },  enterEditMode: function(e) {    if (this._saving || this._editing) return;    this._editing = true;    this.triggerCallback(''onEnterEditMode'');    if (this.options.externalControl)      this.options.externalControl.hide();    this.element.hide();    this.createForm();    this.element.parentNode.insertBefore(this._form, this.element);    if (!this.options.loadTextURL)      this.postProcessEditField();    if (e) Event.stop(e);  },  enterHover: function(e) {    if (this.options.hoverClassName)      this.element.addClassName(this.options.hoverClassName);    if (this._saving) return;    this.triggerCallback(''onEnterHover'');  },  getText: function() {    return this.element.innerHTML.unescapeHTML();  },  handleAJAXFailure: function(transport) {    this.triggerCallback(''onFailure'', transport);    if (this._oldInnerHTML) {      this.element.innerHTML = this._oldInnerHTML;      this._oldInnerHTML = null;    }  },  handleFormCancellation: function(e) {    this.wrapUp();    if (e) Event.stop(e);  },  handleFormSubmission: function(e) {    var form = this._form;    var value = $F(this._controls.editor);    this.prepareSubmission();    var params = this.options.callback(form, value) || '''';    if (Object.isString(params))      params = params.toQueryParams();    params.editorId = this.element.id;    if (this.options.htmlResponse) {      var options = Object.extend({ evalScripts: true }, this.options.ajaxOptions);      Object.extend(options, {        parameters: params,        onComplete: this._boundWrapperHandler,        onFailure: this._boundFailureHandler      });      new Ajax.Updater({ success: this.element }, this.url, options);    } else {      var options = Object.extend({ method: ''get'' }, this.options.ajaxOptions);      Object.extend(options, {        parameters: params,        onComplete: this._boundWrapperHandler,        onFailure: this._boundFailureHandler      });      new Ajax.Request(this.url, options);    }    if (e) Event.stop(e);  },  leaveEditMode: function() {    this.element.removeClassName(this.options.savingClassName);    this.removeForm();    this.leaveHover();    this.element.style.backgroundColor = this._originalBackground;    this.element.show();    if (this.options.externalControl)      this.options.externalControl.show();    this._saving = false;    this._editing = false;    this._oldInnerHTML = null;    this.triggerCallback(''onLeaveEditMode'');  },  leaveHover: function(e) {    if (this.options.hoverClassName)      this.element.removeClassName(this.options.hoverClassName);    if (this._saving) return;    this.triggerCallback(''onLeaveHover'');  },  loadExternalText: function() {    this._form.addClassName(this.options.loadingClassName);    this._controls.editor.disabled = true;    var options = Object.extend({ method: ''get'' }, this.options.ajaxOptions);    Object.extend(options, {      parameters: ''editorId='' + encodeURIComponent(this.element.id),      onComplete: Prototype.emptyFunction,      onSuccess: function(transport) {        this._form.removeClassName(this.options.loadingClassName);        var text = transport.responseText;        if (this.options.stripLoadedTextTags)          text = text.stripTags();        this._controls.editor.value = text;        this._controls.editor.disabled = false;        this.postProcessEditField();      }.bind(this),      onFailure: this._boundFailureHandler    });    new Ajax.Request(this.options.loadTextURL, options);  },  postProcessEditField: function() {    var fpc = this.options.fieldPostCreation;    if (fpc)      $(this._controls.editor)[''focus'' == fpc ? ''focus'' : ''activate'']();  },  prepareOptions: function() {    this.options = Object.clone(Ajax.InPlaceEditor.DefaultOptions);    Object.extend(this.options, Ajax.InPlaceEditor.DefaultCallbacks);    [this._extraDefaultOptions].flatten().compact().each(function(defs) {      Object.extend(this.options, defs);    }.bind(this));  },  prepareSubmission: function() {    this._saving = true;    this.removeForm();    this.leaveHover();    this.showSaving();  },  registerListeners: function() {    this._listeners = { };    var listener;    $H(Ajax.InPlaceEditor.Listeners).each(function(pair) {      listener = this[pair.value].bind(this);      this._listeners[pair.key] = listener;      if (!this.options.externalControlOnly)        this.element.observe(pair.key, listener);      if (this.options.externalControl)        this.options.externalControl.observe(pair.key, listener);    }.bind(this));  },  removeForm: function() {    if (!this._form) return;    this._form.remove();    this._form = null;    this._controls = { };  },  showSaving: function() {    this._oldInnerHTML = this.element.innerHTML;    this.element.innerHTML = this.options.savingText;    this.element.addClassName(this.options.savingClassName);    this.element.style.backgroundColor = this._originalBackground;    this.element.show();  },  triggerCallback: function(cbName, arg) {    if (''function'' == typeof this.options[cbName]) {      this.options[cbName](this, arg);    }  },  unregisterListeners: function() {    $H(this._listeners).each(function(pair) {      if (!this.options.externalControlOnly)        this.element.stopObserving(pair.key, pair.value);      if (this.options.externalControl)        this.options.externalControl.stopObserving(pair.key, pair.value);    }.bind(this));  },  wrapUp: function(transport) {    this.leaveEditMode();    // Can''t use triggerCallback due to backward compatibility: requires    // binding + direct element    this._boundComplete(transport, this.element);  }});Object.extend(Ajax.InPlaceEditor.prototype, {  dispose: Ajax.InPlaceEditor.prototype.destroy});Ajax.InPlaceCollectionEditor = Class.create(Ajax.InPlaceEditor, {  initialize: function($super, element, url, options) {    this._extraDefaultOptions = Ajax.InPlaceCollectionEditor.DefaultOptions;    $super(element, url, options);  },  createEditField: function() {    var list = document.createElement(''select'');    list.name = this.options.paramName;    list.size = 1;    this._controls.editor = list;    this._collection = this.options.collection || [];    if (this.options.loadCollectionURL)      this.loadCollection();    else      this.checkForExternalText();    this._form.appendChild(this._controls.editor);  },  loadCollection: function() {    this._form.addClassName(this.options.loadingClassName);    this.showLoadingText(this.options.loadingCollectionText);    var options = Object.extend({ method: ''get'' }, this.options.ajaxOptions);    Object.extend(options, {      parameters: ''editorId='' + encodeURIComponent(this.element.id),      onComplete: Prototype.emptyFunction,      onSuccess: function(transport) {        var js = transport.responseText.strip();        if (!/^\[.*\]$/.test(js)) // TODO: improve sanity check          throw(''Server returned an invalid collection representation.'');        this._collection = eval(js);        this.checkForExternalText();      }.bind(this),      onFailure: this.onFailure    });    new Ajax.Request(this.options.loadCollectionURL, options);  },  showLoadingText: function(text) {    this._controls.editor.disabled = true;    var tempOption = this._controls.editor.firstChild;    if (!tempOption) {      tempOption = document.createElement(''option'');      tempOption.value = '''';      this._controls.editor.appendChild(tempOption);      tempOption.selected = true;    }    tempOption.update((text || '''').stripScripts().stripTags());  },  checkForExternalText: function() {    this._text = this.getText();    if (this.options.loadTextURL)      this.loadExternalText();    else      this.buildOptionList();  },  loadExternalText: function() {    this.showLoadingText(this.options.loadingText);    var options = Object.extend({ method: ''get'' }, this.options.ajaxOptions);    Object.extend(options, {      parameters: ''editorId='' + encodeURIComponent(this.element.id),      onComplete: Prototype.emptyFunction,      onSuccess: function(transport) {        this._text = transport.responseText.strip();        this.buildOptionList();      }.bind(this),      onFailure: this.onFailure    });    new Ajax.Request(this.options.loadTextURL, options);  },  buildOptionList: function() {    this._form.removeClassName(this.options.loadingClassName);    this._collection = this._collection.map(function(entry) {      return 2 === entry.length ? entry : [entry, entry].flatten();    });    var marker = (''value'' in this.options) ? this.options.value : this._text;    var textFound = this._collection.any(function(entry) {      return entry[0] == marker;    }.bind(this));    this._controls.editor.update('''');    var option;    this._collection.each(function(entry, index) {      option = document.createElement(''option'');      option.value = entry[0];      option.selected = textFound ? entry[0] == marker : 0 == index;      option.appendChild(document.createTextNode(entry[1]));      this._controls.editor.appendChild(option);    }.bind(this));    this._controls.editor.disabled = false;    Field.scrollFreeActivate(this._controls.editor);  }});//**** DEPRECATION LAYER FOR InPlace[Collection]Editor! ****//**** This only  exists for a while,  in order to  let ****//**** users adapt to  the new API.  Read up on the new ****//**** API and convert your code to it ASAP!            ****Ajax.InPlaceEditor.prototype.initialize.dealWithDeprecatedOptions = function(options) {  if (!options) return;  function fallback(name, expr) {    if (name in options || expr === undefined) return;    options[name] = expr;  };  fallback(''cancelControl'', (options.cancelLink ? ''link'' : (options.cancelButton ? ''button'' :    options.cancelLink == options.cancelButton == false ? false : undefined)));  fallback(''okControl'', (options.okLink ? ''link'' : (options.okButton ? ''button'' :    options.okLink == options.okButton == false ? false : undefined)));  fallback(''highlightColor'', options.highlightcolor);  fallback(''highlightEndColor'', options.highlightendcolor);};Object.extend(Ajax.InPlaceEditor, {  DefaultOptions: {    ajaxOptions: { },    autoRows: 3,                                // Use when multi-line w/ rows == 1    cancelControl: ''link'',                      // ''link''|''button''|false    cancelText: ''cancel'',    clickToEditText: ''Click to edit'',    externalControl: null,                      // id|elt    externalControlOnly: false,    fieldPostCreation: ''activate'',              // ''activate''|''focus''|false    formClassName: ''inplaceeditor-form'',    formId: null,                               // id|elt    highlightColor: ''#ffff99'',    highlightEndColor: ''#ffffff'',    hoverClassName: '''',    htmlResponse: true,    loadingClassName: ''inplaceeditor-loading'',    loadingText: ''Loading...'',    okControl: ''button'',                        // ''link''|''button''|false    okText: ''ok'',    paramName: ''value'',    rows: 1,                                    // If 1 and multi-line, uses autoRows    savingClassName: ''inplaceeditor-saving'',    savingText: ''Saving...'',    size: 0,    stripLoadedTextTags: false,    submitOnBlur: false,    textAfterControls: '''',    textBeforeControls: '''',    textBetweenControls: ''''  },  DefaultCallbacks: {    callback: function(form) {      return Form.serialize(form);    },    onComplete: function(transport, element) {      // For backward compatibility, this one is bound to the IPE, and passes      // the element directly.  It was too often customized, so we don''t break it.      new Effect.Highlight(element, {        startcolor: this.options.highlightColor, keepBackgroundImage: true });    },    onEnterEditMode: null,    onEnterHover: function(ipe) {      ipe.element.style.backgroundColor = ipe.options.highlightColor;      if (ipe._effect)        ipe._effect.cancel();    },    onFailure: function(transport, ipe) {      alert(''Error communication with the server: '' + transport.responseText.stripTags());    },    onFormCustomization: null, // Takes the IPE and its generated form, after editor, before controls.    onLeaveEditMode: null,    onLeaveHover: function(ipe) {      ipe._effect = new Effect.Highlight(ipe.element, {        startcolor: ipe.options.highlightColor, endcolor: ipe.options.highlightEndColor,        restorecolor: ipe._originalBackground, keepBackgroundImage: true      });    }  },  Listeners: {    click: ''enterEditMode'',    keydown: ''checkForEscapeOrReturn'',    mouseover: ''enterHover'',    mouseout: ''leaveHover''  }});Ajax.InPlaceCollectionEditor.DefaultOptions = {  loadingCollectionText: ''Loading options...''};// Delayed observer, like Form.Element.Observer,// but waits for delay after last key input// Ideal for live-search fieldsForm.Element.DelayedObserver = Class.create({  initialize: function(element, delay, callback) {    this.delay     = delay || 0.5;    this.element   = $(element);    this.callback  = callback;    this.timer     = null;    this.lastValue = $F(this.element);    Event.observe(this.element,''keyup'',this.delayedListener.bindAsEventListener(this));  },  delayedListener: function(event) {    if(this.lastValue == $F(this.element)) return;    if(this.timer) clearTimeout(this.timer);    this.timer = setTimeout(this.onTimerEvent.bind(this), this.delay * 1000);    this.lastValue = $F(this.element);  },  onTimerEvent: function() {    this.timer = null;    this.callback(this.element, $F(this.element));  }});'</body><body package="Scriptaculous-Core">dragdropJs	^ '// script.aculo.us dragdrop.js v1.9.0, Thu Dec 23 16:54:48 -0500 2010// Copyright (c) 2005-2010 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)//// script.aculo.us is freely distributable under the terms of an MIT-style license.// For details, see the script.aculo.us web site: http://script.aculo.us/if(Object.isUndefined(Effect))  throw("dragdrop.js requires including script.aculo.us'' effects.js library");var Droppables = {  drops: [],  remove: function(element) {    this.drops = this.drops.reject(function(d) { return d.element==$(element) });  },  add: function(element) {    element = $(element);    var options = Object.extend({      greedy:     true,      hoverclass: null,      tree:       false    }, arguments[1] || { });    // cache containers    if(options.containment) {      options._containers = [];      var containment = options.containment;      if(Object.isArray(containment)) {        containment.each( function(c) { options._containers.push($(c)) });      } else {        options._containers.push($(containment));      }    }    if(options.accept) options.accept = [options.accept].flatten();    Element.makePositioned(element); // fix IE    options.element = element;    this.drops.push(options);  },  findDeepestChild: function(drops) {    deepest = drops[0];    for (i = 1; i &lt; drops.length; ++i)      if (Element.isParent(drops[i].element, deepest.element))        deepest = drops[i];    return deepest;  },  isContained: function(element, drop) {    var containmentNode;    if(drop.tree) {      containmentNode = element.treeNode;    } else {      containmentNode = element.parentNode;    }    return drop._containers.detect(function(c) { return containmentNode == c });  },  isAffected: function(point, element, drop) {    return (      (drop.element!=element) &amp;&amp;      ((!drop._containers) ||        this.isContained(element, drop)) &amp;&amp;      ((!drop.accept) ||        (Element.classNames(element).detect(          function(v) { return drop.accept.include(v) } ) )) &amp;&amp;      Position.within(drop.element, point[0], point[1]) );  },  deactivate: function(drop) {    if(drop.hoverclass)      Element.removeClassName(drop.element, drop.hoverclass);    this.last_active = null;  },  activate: function(drop) {    if(drop.hoverclass)      Element.addClassName(drop.element, drop.hoverclass);    this.last_active = drop;  },  show: function(point, element) {    if(!this.drops.length) return;    var drop, affected = [];    this.drops.each( function(drop) {      if(Droppables.isAffected(point, element, drop))        affected.push(drop);    });    if(affected.length&gt;0)      drop = Droppables.findDeepestChild(affected);    if(this.last_active &amp;&amp; this.last_active != drop) this.deactivate(this.last_active);    if (drop) {      Position.within(drop.element, point[0], point[1]);      if(drop.onHover)        drop.onHover(element, drop.element, Position.overlap(drop.overlap, drop.element));      if (drop != this.last_active) Droppables.activate(drop);    }  },  fire: function(event, element) {    if(!this.last_active) return;    Position.prepare();    if (this.isAffected([Event.pointerX(event), Event.pointerY(event)], element, this.last_active))      if (this.last_active.onDrop) {        this.last_active.onDrop(element, this.last_active.element, event);        return true;      }  },  reset: function() {    if(this.last_active)      this.deactivate(this.last_active);  }};var Draggables = {  drags: [],  observers: [],  register: function(draggable) {    if(this.drags.length == 0) {      this.eventMouseUp   = this.endDrag.bindAsEventListener(this);      this.eventMouseMove = this.updateDrag.bindAsEventListener(this);      this.eventKeypress  = this.keyPress.bindAsEventListener(this);      Event.observe(document, "mouseup", this.eventMouseUp);      Event.observe(document, "mousemove", this.eventMouseMove);      Event.observe(document, "keypress", this.eventKeypress);    }    this.drags.push(draggable);  },  unregister: function(draggable) {    this.drags = this.drags.reject(function(d) { return d==draggable });    if(this.drags.length == 0) {      Event.stopObserving(document, "mouseup", this.eventMouseUp);      Event.stopObserving(document, "mousemove", this.eventMouseMove);      Event.stopObserving(document, "keypress", this.eventKeypress);    }  },  activate: function(draggable) {    if(draggable.options.delay) {      this._timeout = setTimeout(function() {        Draggables._timeout = null;        window.focus();        Draggables.activeDraggable = draggable;      }.bind(this), draggable.options.delay);    } else {      window.focus(); // allows keypress events if window isn''t currently focused, fails for Safari      this.activeDraggable = draggable;    }  },  deactivate: function() {    this.activeDraggable = null;  },  updateDrag: function(event) {    if(!this.activeDraggable) return;    var pointer = [Event.pointerX(event), Event.pointerY(event)];    // Mozilla-based browsers fire successive mousemove events with    // the same coordinates, prevent needless redrawing (moz bug?)    if(this._lastPointer &amp;&amp; (this._lastPointer.inspect() == pointer.inspect())) return;    this._lastPointer = pointer;    this.activeDraggable.updateDrag(event, pointer);  },  endDrag: function(event) {    if(this._timeout) {      clearTimeout(this._timeout);      this._timeout = null;    }    if(!this.activeDraggable) return;    this._lastPointer = null;    this.activeDraggable.endDrag(event);    this.activeDraggable = null;  },  keyPress: function(event) {    if(this.activeDraggable)      this.activeDraggable.keyPress(event);  },  addObserver: function(observer) {    this.observers.push(observer);    this._cacheObserverCallbacks();  },  removeObserver: function(element) {  // element instead of observer fixes mem leaks    this.observers = this.observers.reject( function(o) { return o.element==element });    this._cacheObserverCallbacks();  },  notify: function(eventName, draggable, event) {  // ''onStart'', ''onEnd'', ''onDrag''    if(this[eventName+''Count''] &gt; 0)      this.observers.each( function(o) {        if(o[eventName]) o[eventName](eventName, draggable, event);      });    if(draggable.options[eventName]) draggable.options[eventName](draggable, event);  },  _cacheObserverCallbacks: function() {    [''onStart'',''onEnd'',''onDrag''].each( function(eventName) {      Draggables[eventName+''Count''] = Draggables.observers.select(        function(o) { return o[eventName]; }      ).length;    });  }};/*--------------------------------------------------------------------------*/var Draggable = Class.create({  initialize: function(element) {    var defaults = {      handle: false,      reverteffect: function(element, top_offset, left_offset) {        var dur = Math.sqrt(Math.abs(top_offset^2)+Math.abs(left_offset^2))*0.02;        new Effect.Move(element, { x: -left_offset, y: -top_offset, duration: dur,          queue: {scope:''_draggable'', position:''end''}        });      },      endeffect: function(element) {        var toOpacity = Object.isNumber(element._opacity) ? element._opacity : 1.0;        new Effect.Opacity(element, {duration:0.2, from:0.7, to:toOpacity,          queue: {scope:''_draggable'', position:''end''},          afterFinish: function(){            Draggable._dragging[element] = false          }        });      },      zindex: 1000,      revert: false,      quiet: false,      scroll: false,      scrollSensitivity: 20,      scrollSpeed: 15,      snap: false,  // false, or xy or [x,y] or function(x,y){ return [x,y] }      delay: 0    };    if(!arguments[1] || Object.isUndefined(arguments[1].endeffect))      Object.extend(defaults, {        starteffect: function(element) {          element._opacity = Element.getOpacity(element);          Draggable._dragging[element] = true;          new Effect.Opacity(element, {duration:0.2, from:element._opacity, to:0.7});        }      });    var options = Object.extend(defaults, arguments[1] || { });    this.element = $(element);    if(options.handle &amp;&amp; Object.isString(options.handle))      this.handle = this.element.down(''.''+options.handle, 0);    if(!this.handle) this.handle = $(options.handle);    if(!this.handle) this.handle = this.element;    if(options.scroll &amp;&amp; !options.scroll.scrollTo &amp;&amp; !options.scroll.outerHTML) {      options.scroll = $(options.scroll);      this._isScrollChild = Element.childOf(this.element, options.scroll);    }    Element.makePositioned(this.element); // fix IE    this.options  = options;    this.dragging = false;    this.eventMouseDown = this.initDrag.bindAsEventListener(this);    Event.observe(this.handle, "mousedown", this.eventMouseDown);    Draggables.register(this);  },  destroy: function() {    Event.stopObserving(this.handle, "mousedown", this.eventMouseDown);    Draggables.unregister(this);  },  currentDelta: function() {    return([      parseInt(Element.getStyle(this.element,''left'') || ''0''),      parseInt(Element.getStyle(this.element,''top'') || ''0'')]);  },  initDrag: function(event) {    if(!Object.isUndefined(Draggable._dragging[this.element]) &amp;&amp;      Draggable._dragging[this.element]) return;    if(Event.isLeftClick(event)) {      // abort on form elements, fixes a Firefox issue      var src = Event.element(event);      if((tag_name = src.tagName.toUpperCase()) &amp;&amp; (        tag_name==''INPUT'' ||        tag_name==''SELECT'' ||        tag_name==''OPTION'' ||        tag_name==''BUTTON'' ||        tag_name==''TEXTAREA'')) return;      var pointer = [Event.pointerX(event), Event.pointerY(event)];      var pos     = this.element.cumulativeOffset();      this.offset = [0,1].map( function(i) { return (pointer[i] - pos[i]) });      Draggables.activate(this);      Event.stop(event);    }  },  startDrag: function(event) {    this.dragging = true;    if(!this.delta)      this.delta = this.currentDelta();    if(this.options.zindex) {      this.originalZ = parseInt(Element.getStyle(this.element,''z-index'') || 0);      this.element.style.zIndex = this.options.zindex;    }    if(this.options.ghosting) {      this._clone = this.element.cloneNode(true);      this._originallyAbsolute = (this.element.getStyle(''position'') == ''absolute'');      if (!this._originallyAbsolute)        Position.absolutize(this.element);      this.element.parentNode.insertBefore(this._clone, this.element);    }    if(this.options.scroll) {      if (this.options.scroll == window) {        var where = this._getWindowScroll(this.options.scroll);        this.originalScrollLeft = where.left;        this.originalScrollTop = where.top;      } else {        this.originalScrollLeft = this.options.scroll.scrollLeft;        this.originalScrollTop = this.options.scroll.scrollTop;      }    }    Draggables.notify(''onStart'', this, event);    if(this.options.starteffect) this.options.starteffect(this.element);  },  updateDrag: function(event, pointer) {    if(!this.dragging) this.startDrag(event);    if(!this.options.quiet){      Position.prepare();      Droppables.show(pointer, this.element);    }    Draggables.notify(''onDrag'', this, event);    this.draw(pointer);    if(this.options.change) this.options.change(this);    if(this.options.scroll) {      this.stopScrolling();      var p;      if (this.options.scroll == window) {        with(this._getWindowScroll(this.options.scroll)) { p = [ left, top, left+width, top+height ]; }      } else {        p = Position.page(this.options.scroll).toArray();        p[0] += this.options.scroll.scrollLeft + Position.deltaX;        p[1] += this.options.scroll.scrollTop + Position.deltaY;        p.push(p[0]+this.options.scroll.offsetWidth);        p.push(p[1]+this.options.scroll.offsetHeight);      }      var speed = [0,0];      if(pointer[0] &lt; (p[0]+this.options.scrollSensitivity)) speed[0] = pointer[0]-(p[0]+this.options.scrollSensitivity);      if(pointer[1] &lt; (p[1]+this.options.scrollSensitivity)) speed[1] = pointer[1]-(p[1]+this.options.scrollSensitivity);      if(pointer[0] &gt; (p[2]-this.options.scrollSensitivity)) speed[0] = pointer[0]-(p[2]-this.options.scrollSensitivity);      if(pointer[1] &gt; (p[3]-this.options.scrollSensitivity)) speed[1] = pointer[1]-(p[3]-this.options.scrollSensitivity);      this.startScrolling(speed);    }    // fix AppleWebKit rendering    if(Prototype.Browser.WebKit) window.scrollBy(0,0);    Event.stop(event);  },  finishDrag: function(event, success) {    this.dragging = false;    if(this.options.quiet){      Position.prepare();      var pointer = [Event.pointerX(event), Event.pointerY(event)];      Droppables.show(pointer, this.element);    }    if(this.options.ghosting) {      if (!this._originallyAbsolute)        Position.relativize(this.element);      delete this._originallyAbsolute;      Element.remove(this._clone);      this._clone = null;    }    var dropped = false;    if(success) {      dropped = Droppables.fire(event, this.element);      if (!dropped) dropped = false;    }    if(dropped &amp;&amp; this.options.onDropped) this.options.onDropped(this.element);    Draggables.notify(''onEnd'', this, event);    var revert = this.options.revert;    if(revert &amp;&amp; Object.isFunction(revert)) revert = revert(this.element);    var d = this.currentDelta();    if(revert &amp;&amp; this.options.reverteffect) {      if (dropped == 0 || revert != ''failure'')        this.options.reverteffect(this.element,          d[1]-this.delta[1], d[0]-this.delta[0]);    } else {      this.delta = d;    }    if(this.options.zindex)      this.element.style.zIndex = this.originalZ;    if(this.options.endeffect)      this.options.endeffect(this.element);    Draggables.deactivate(this);    Droppables.reset();  },  keyPress: function(event) {    if(event.keyCode!=Event.KEY_ESC) return;    this.finishDrag(event, false);    Event.stop(event);  },  endDrag: function(event) {    if(!this.dragging) return;    this.stopScrolling();    this.finishDrag(event, true);    Event.stop(event);  },  draw: function(point) {    var pos = this.element.cumulativeOffset();    if(this.options.ghosting) {      var r   = Position.realOffset(this.element);      pos[0] += r[0] - Position.deltaX; pos[1] += r[1] - Position.deltaY;    }    var d = this.currentDelta();    pos[0] -= d[0]; pos[1] -= d[1];    if(this.options.scroll &amp;&amp; (this.options.scroll != window &amp;&amp; this._isScrollChild)) {      pos[0] -= this.options.scroll.scrollLeft-this.originalScrollLeft;      pos[1] -= this.options.scroll.scrollTop-this.originalScrollTop;    }    var p = [0,1].map(function(i){      return (point[i]-pos[i]-this.offset[i])    }.bind(this));    if(this.options.snap) {      if(Object.isFunction(this.options.snap)) {        p = this.options.snap(p[0],p[1],this);      } else {      if(Object.isArray(this.options.snap)) {        p = p.map( function(v, i) {          return (v/this.options.snap[i]).round()*this.options.snap[i] }.bind(this));      } else {        p = p.map( function(v) {          return (v/this.options.snap).round()*this.options.snap }.bind(this));      }    }}    var style = this.element.style;    if((!this.options.constraint) || (this.options.constraint==''horizontal''))      style.left = p[0] + "px";    if((!this.options.constraint) || (this.options.constraint==''vertical''))      style.top  = p[1] + "px";    if(style.visibility=="hidden") style.visibility = ""; // fix gecko rendering  },  stopScrolling: function() {    if(this.scrollInterval) {      clearInterval(this.scrollInterval);      this.scrollInterval = null;      Draggables._lastScrollPointer = null;    }  },  startScrolling: function(speed) {    if(!(speed[0] || speed[1])) return;    this.scrollSpeed = [speed[0]*this.options.scrollSpeed,speed[1]*this.options.scrollSpeed];    this.lastScrolled = new Date();    this.scrollInterval = setInterval(this.scroll.bind(this), 10);  },  scroll: function() {    var current = new Date();    var delta = current - this.lastScrolled;    this.lastScrolled = current;    if(this.options.scroll == window) {      with (this._getWindowScroll(this.options.scroll)) {        if (this.scrollSpeed[0] || this.scrollSpeed[1]) {          var d = delta / 1000;          this.options.scroll.scrollTo( left + d*this.scrollSpeed[0], top + d*this.scrollSpeed[1] );        }      }    } else {      this.options.scroll.scrollLeft += this.scrollSpeed[0] * delta / 1000;      this.options.scroll.scrollTop  += this.scrollSpeed[1] * delta / 1000;    }    Position.prepare();    Droppables.show(Draggables._lastPointer, this.element);    Draggables.notify(''onDrag'', this);    if (this._isScrollChild) {      Draggables._lastScrollPointer = Draggables._lastScrollPointer || $A(Draggables._lastPointer);      Draggables._lastScrollPointer[0] += this.scrollSpeed[0] * delta / 1000;      Draggables._lastScrollPointer[1] += this.scrollSpeed[1] * delta / 1000;      if (Draggables._lastScrollPointer[0] &lt; 0)        Draggables._lastScrollPointer[0] = 0;      if (Draggables._lastScrollPointer[1] &lt; 0)        Draggables._lastScrollPointer[1] = 0;      this.draw(Draggables._lastScrollPointer);    }    if(this.options.change) this.options.change(this);  },  _getWindowScroll: function(w) {    var T, L, W, H;    with (w.document) {      if (w.document.documentElement &amp;&amp; documentElement.scrollTop) {        T = documentElement.scrollTop;        L = documentElement.scrollLeft;      } else if (w.document.body) {        T = body.scrollTop;        L = body.scrollLeft;      }      if (w.innerWidth) {        W = w.innerWidth;        H = w.innerHeight;      } else if (w.document.documentElement &amp;&amp; documentElement.clientWidth) {        W = documentElement.clientWidth;        H = documentElement.clientHeight;      } else {        W = body.offsetWidth;        H = body.offsetHeight;      }    }    return { top: T, left: L, width: W, height: H };  }});Draggable._dragging = { };/*--------------------------------------------------------------------------*/var SortableObserver = Class.create({  initialize: function(element, observer) {    this.element   = $(element);    this.observer  = observer;    this.lastValue = Sortable.serialize(this.element);  },  onStart: function() {    this.lastValue = Sortable.serialize(this.element);  },  onEnd: function() {    Sortable.unmark();    if(this.lastValue != Sortable.serialize(this.element))      this.observer(this.element)  }});var Sortable = {  SERIALIZE_RULE: /^[^_\-](?:[A-Za-z0-9\-\_]*)[_](.*)$/,  sortables: { },  _findRootElement: function(element) {    while (element.tagName.toUpperCase() != "BODY") {      if(element.id &amp;&amp; Sortable.sortables[element.id]) return element;      element = element.parentNode;    }  },  options: function(element) {    element = Sortable._findRootElement($(element));    if(!element) return;    return Sortable.sortables[element.id];  },  destroy: function(element){    element = $(element);    var s = Sortable.sortables[element.id];    if(s) {      Draggables.removeObserver(s.element);      s.droppables.each(function(d){ Droppables.remove(d) });      s.draggables.invoke(''destroy'');      delete Sortable.sortables[s.element.id];    }  },  create: function(element) {    element = $(element);    var options = Object.extend({      element:     element,      tag:         ''li'',       // assumes li children, override with tag: ''tagname''      dropOnEmpty: false,      tree:        false,      treeTag:     ''ul'',      overlap:     ''vertical'', // one of ''vertical'', ''horizontal''      constraint:  ''vertical'', // one of ''vertical'', ''horizontal'', false      containment: element,    // also takes array of elements (or id''s); or false      handle:      false,      // or a CSS class      only:        false,      delay:       0,      hoverclass:  null,      ghosting:    false,      quiet:       false,      scroll:      false,      scrollSensitivity: 20,      scrollSpeed: 15,      format:      this.SERIALIZE_RULE,      // these take arrays of elements or ids and can be      // used for better initialization performance      elements:    false,      handles:     false,      onChange:    Prototype.emptyFunction,      onUpdate:    Prototype.emptyFunction    }, arguments[1] || { });    // clear any old sortable with same element    this.destroy(element);    // build options for the draggables    var options_for_draggable = {      revert:      true,      quiet:       options.quiet,      scroll:      options.scroll,      scrollSpeed: options.scrollSpeed,      scrollSensitivity: options.scrollSensitivity,      delay:       options.delay,      ghosting:    options.ghosting,      constraint:  options.constraint,      handle:      options.handle };    if(options.starteffect)      options_for_draggable.starteffect = options.starteffect;    if(options.reverteffect)      options_for_draggable.reverteffect = options.reverteffect;    else      if(options.ghosting) options_for_draggable.reverteffect = function(element) {        element.style.top  = 0;        element.style.left = 0;      };    if(options.endeffect)      options_for_draggable.endeffect = options.endeffect;    if(options.zindex)      options_for_draggable.zindex = options.zindex;    // build options for the droppables    var options_for_droppable = {      overlap:     options.overlap,      containment: options.containment,      tree:        options.tree,      hoverclass:  options.hoverclass,      onHover:     Sortable.onHover    };    var options_for_tree = {      onHover:      Sortable.onEmptyHover,      overlap:      options.overlap,      containment:  options.containment,      hoverclass:   options.hoverclass    };    // fix for gecko engine    Element.cleanWhitespace(element);    options.draggables = [];    options.droppables = [];    // drop on empty handling    if(options.dropOnEmpty || options.tree) {      Droppables.add(element, options_for_tree);      options.droppables.push(element);    }    (options.elements || this.findElements(element, options) || []).each( function(e,i) {      var handle = options.handles ? $(options.handles[i]) :        (options.handle ? $(e).select(''.'' + options.handle)[0] : e);      options.draggables.push(        new Draggable(e, Object.extend(options_for_draggable, { handle: handle })));      Droppables.add(e, options_for_droppable);      if(options.tree) e.treeNode = element;      options.droppables.push(e);    });    if(options.tree) {      (Sortable.findTreeElements(element, options) || []).each( function(e) {        Droppables.add(e, options_for_tree);        e.treeNode = element;        options.droppables.push(e);      });    }    // keep reference    this.sortables[element.identify()] = options;    // for onupdate    Draggables.addObserver(new SortableObserver(element, options.onUpdate));  },  // return all suitable-for-sortable elements in a guaranteed order  findElements: function(element, options) {    return Element.findChildren(      element, options.only, options.tree ? true : false, options.tag);  },  findTreeElements: function(element, options) {    return Element.findChildren(      element, options.only, options.tree ? true : false, options.treeTag);  },  onHover: function(element, dropon, overlap) {    if(Element.isParent(dropon, element)) return;    if(overlap &gt; .33 &amp;&amp; overlap &lt; .66 &amp;&amp; Sortable.options(dropon).tree) {      return;    } else if(overlap&gt;0.5) {      Sortable.mark(dropon, ''before'');      if(dropon.previousSibling != element) {        var oldParentNode = element.parentNode;        element.style.visibility = "hidden"; // fix gecko rendering        dropon.parentNode.insertBefore(element, dropon);        if(dropon.parentNode!=oldParentNode)          Sortable.options(oldParentNode).onChange(element);        Sortable.options(dropon.parentNode).onChange(element);      }    } else {      Sortable.mark(dropon, ''after'');      var nextElement = dropon.nextSibling || null;      if(nextElement != element) {        var oldParentNode = element.parentNode;        element.style.visibility = "hidden"; // fix gecko rendering        dropon.parentNode.insertBefore(element, nextElement);        if(dropon.parentNode!=oldParentNode)          Sortable.options(oldParentNode).onChange(element);        Sortable.options(dropon.parentNode).onChange(element);      }    }  },  onEmptyHover: function(element, dropon, overlap) {    var oldParentNode = element.parentNode;    var droponOptions = Sortable.options(dropon);    if(!Element.isParent(dropon, element)) {      var index;      var children = Sortable.findElements(dropon, {tag: droponOptions.tag, only: droponOptions.only});      var child = null;      if(children) {        var offset = Element.offsetSize(dropon, droponOptions.overlap) * (1.0 - overlap);        for (index = 0; index &lt; children.length; index += 1) {          if (offset - Element.offsetSize (children[index], droponOptions.overlap) &gt;= 0) {            offset -= Element.offsetSize (children[index], droponOptions.overlap);          } else if (offset - (Element.offsetSize (children[index], droponOptions.overlap) / 2) &gt;= 0) {            child = index + 1 &lt; children.length ? children[index + 1] : null;            break;          } else {            child = children[index];            break;          }        }      }      dropon.insertBefore(element, child);      Sortable.options(oldParentNode).onChange(element);      droponOptions.onChange(element);    }  },  unmark: function() {    if(Sortable._marker) Sortable._marker.hide();  },  mark: function(dropon, position) {    // mark on ghosting only    var sortable = Sortable.options(dropon.parentNode);    if(sortable &amp;&amp; !sortable.ghosting) return;    if(!Sortable._marker) {      Sortable._marker =        ($(''dropmarker'') || Element.extend(document.createElement(''DIV''))).          hide().addClassName(''dropmarker'').setStyle({position:''absolute''});      document.getElementsByTagName("body").item(0).appendChild(Sortable._marker);    }    var offsets = dropon.cumulativeOffset();    Sortable._marker.setStyle({left: offsets[0]+''px'', top: offsets[1] + ''px''});    if(position==''after'')      if(sortable.overlap == ''horizontal'')        Sortable._marker.setStyle({left: (offsets[0]+dropon.clientWidth) + ''px''});      else        Sortable._marker.setStyle({top: (offsets[1]+dropon.clientHeight) + ''px''});    Sortable._marker.show();  },  _tree: function(element, options, parent) {    var children = Sortable.findElements(element, options) || [];    for (var i = 0; i &lt; children.length; ++i) {      var match = children[i].id.match(options.format);      if (!match) continue;      var child = {        id: encodeURIComponent(match ? match[1] : null),        element: element,        parent: parent,        children: [],        position: parent.children.length,        container: $(children[i]).down(options.treeTag)      };      /* Get the element containing the children and recurse over it */      if (child.container)        this._tree(child.container, options, child);      parent.children.push (child);    }    return parent;  },  tree: function(element) {    element = $(element);    var sortableOptions = this.options(element);    var options = Object.extend({      tag: sortableOptions.tag,      treeTag: sortableOptions.treeTag,      only: sortableOptions.only,      name: element.id,      format: sortableOptions.format    }, arguments[1] || { });    var root = {      id: null,      parent: null,      children: [],      container: element,      position: 0    };    return Sortable._tree(element, options, root);  },  /* Construct a [i] index for a particular node */  _constructIndex: function(node) {    var index = '''';    do {      if (node.id) index = ''['' + node.position + '']'' + index;    } while ((node = node.parent) != null);    return index;  },  sequence: function(element) {    element = $(element);    var options = Object.extend(this.options(element), arguments[1] || { });    return $(this.findElements(element, options) || []).map( function(item) {      return item.id.match(options.format) ? item.id.match(options.format)[1] : '''';    });  },  setSequence: function(element, new_sequence) {    element = $(element);    var options = Object.extend(this.options(element), arguments[2] || { });    var nodeMap = { };    this.findElements(element, options).each( function(n) {        if (n.id.match(options.format))            nodeMap[n.id.match(options.format)[1]] = [n, n.parentNode];        n.parentNode.removeChild(n);    });    new_sequence.each(function(ident) {      var n = nodeMap[ident];      if (n) {        n[1].appendChild(n[0]);        delete nodeMap[ident];      }    });  },  serialize: function(element) {    element = $(element);    var options = Object.extend(Sortable.options(element), arguments[1] || { });    var name = encodeURIComponent(      (arguments[1] &amp;&amp; arguments[1].name) ? arguments[1].name : element.id);    if (options.tree) {      return Sortable.tree(element, arguments[1]).children.map( function (item) {        return [name + Sortable._constructIndex(item) + "[id]=" +                encodeURIComponent(item.id)].concat(item.children.map(arguments.callee));      }).flatten().join(''&amp;'');    } else {      return Sortable.sequence(element, arguments[1]).map( function(item) {        return name + "[]=" + encodeURIComponent(item);      }).join(''&amp;'');    }  }};// Returns true if child is contained within elementElement.isParent = function(child, element) {  if (!child.parentNode || child == element) return false;  if (child.parentNode == element) return true;  return Element.isParent(child.parentNode, element);};Element.findChildren = function(element, only, recursive, tagName) {  if(!element.hasChildNodes()) return null;  tagName = tagName.toUpperCase();  if(only) only = [only].flatten();  var elements = [];  $A(element.childNodes).each( function(e) {    if(e.tagName &amp;&amp; e.tagName.toUpperCase()==tagName &amp;&amp;      (!only || (Element.classNames(e).detect(function(v) { return only.include(v) }))))        elements.push(e);    if(recursive) {      var grandchildren = Element.findChildren(e, only, recursive, tagName);      if(grandchildren) elements.push(grandchildren);    }  });  return (elements.length&gt;0 ? elements.flatten() : []);};Element.offsetSize = function (element, type) {  return element[''offset'' + ((type==''vertical'' || type==''height'') ? ''Height'' : ''Width'')];};'</body><body package="Scriptaculous-Core">effectsJs	^ '// script.aculo.us effects.js v1.9.0, Thu Dec 23 16:54:48 -0500 2010// Copyright (c) 2005-2010 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)// Contributors://  Justin Palmer (http://encytemedia.com/)//  Mark Pilgrim (http://diveintomark.org/)//  Martin Bialasinki//// script.aculo.us is freely distributable under the terms of an MIT-style license.// For details, see the script.aculo.us web site: http://script.aculo.us/// converts rgb() and #xxx to #xxxxxx format,// returns self (or first argument) if not convertableString.prototype.parseColor = function() {  var color = ''#'';  if (this.slice(0,4) == ''rgb('') {    var cols = this.slice(4,this.length-1).split('','');    var i=0; do { color += parseInt(cols[i]).toColorPart() } while (++i&lt;3);  } else {    if (this.slice(0,1) == ''#'') {      if (this.length==4) for(var i=1;i&lt;4;i++) color += (this.charAt(i) + this.charAt(i)).toLowerCase();      if (this.length==7) color = this.toLowerCase();    }  }  return (color.length==7 ? color : (arguments[0] || this));};/*--------------------------------------------------------------------------*/Element.collectTextNodes = function(element) {  return $A($(element).childNodes).collect( function(node) {    return (node.nodeType==3 ? node.nodeValue :      (node.hasChildNodes() ? Element.collectTextNodes(node) : ''''));  }).flatten().join('''');};Element.collectTextNodesIgnoreClass = function(element, className) {  return $A($(element).childNodes).collect( function(node) {    return (node.nodeType==3 ? node.nodeValue :      ((node.hasChildNodes() &amp;&amp; !Element.hasClassName(node,className)) ?        Element.collectTextNodesIgnoreClass(node, className) : ''''));  }).flatten().join('''');};Element.setContentZoom = function(element, percent) {  element = $(element);  element.setStyle({fontSize: (percent/100) + ''em''});  if (Prototype.Browser.WebKit) window.scrollBy(0,0);  return element;};Element.getInlineOpacity = function(element){  return $(element).style.opacity || '''';};Element.forceRerendering = function(element) {  try {    element = $(element);    var n = document.createTextNode('' '');    element.appendChild(n);    element.removeChild(n);  } catch(e) { }};/*--------------------------------------------------------------------------*/var Effect = {  _elementDoesNotExistError: {    name: ''ElementDoesNotExistError'',    message: ''The specified DOM element does not exist, but is required for this effect to operate''  },  Transitions: {    linear: Prototype.K,    sinoidal: function(pos) {      return (-Math.cos(pos*Math.PI)/2) + .5;    },    reverse: function(pos) {      return 1-pos;    },    flicker: function(pos) {      var pos = ((-Math.cos(pos*Math.PI)/4) + .75) + Math.random()/4;      return pos &gt; 1 ? 1 : pos;    },    wobble: function(pos) {      return (-Math.cos(pos*Math.PI*(9*pos))/2) + .5;    },    pulse: function(pos, pulses) {      return (-Math.cos((pos*((pulses||5)-.5)*2)*Math.PI)/2) + .5;    },    spring: function(pos) {      return 1 - (Math.cos(pos * 4.5 * Math.PI) * Math.exp(-pos * 6));    },    none: function(pos) {      return 0;    },    full: function(pos) {      return 1;    }  },  DefaultOptions: {    duration:   1.0,   // seconds    fps:        100,   // 100= assume 66fps max.    sync:       false, // true for combining    from:       0.0,    to:         1.0,    delay:      0.0,    queue:      ''parallel''  },  tagifyText: function(element) {    var tagifyStyle = ''position:relative'';    if (Prototype.Browser.IE) tagifyStyle += '';zoom:1'';    element = $(element);    $A(element.childNodes).each( function(child) {      if (child.nodeType==3) {        child.nodeValue.toArray().each( function(character) {          element.insertBefore(            new Element(''span'', {style: tagifyStyle}).update(              character == '' '' ? String.fromCharCode(160) : character),              child);        });        Element.remove(child);      }    });  },  multiple: function(element, effect) {    var elements;    if (((typeof element == ''object'') ||        Object.isFunction(element)) &amp;&amp;       (element.length))      elements = element;    else      elements = $(element).childNodes;    var options = Object.extend({      speed: 0.1,      delay: 0.0    }, arguments[2] || { });    var masterDelay = options.delay;    $A(elements).each( function(element, index) {      new effect(element, Object.extend(options, { delay: index * options.speed + masterDelay }));    });  },  PAIRS: {    ''slide'':  [''SlideDown'',''SlideUp''],    ''blind'':  [''BlindDown'',''BlindUp''],    ''appear'': [''Appear'',''Fade'']  },  toggle: function(element, effect, options) {    element = $(element);    effect  = (effect || ''appear'').toLowerCase();        return Effect[ Effect.PAIRS[ effect ][ element.visible() ? 1 : 0 ] ](element, Object.extend({      queue: { position:''end'', scope:(element.id || ''global''), limit: 1 }    }, options || {}));  }};Effect.DefaultOptions.transition = Effect.Transitions.sinoidal;/* ------------- core effects ------------- */Effect.ScopedQueue = Class.create(Enumerable, {  initialize: function() {    this.effects  = [];    this.interval = null;  },  _each: function(iterator) {    this.effects._each(iterator);  },  add: function(effect) {    var timestamp = new Date().getTime();    var position = Object.isString(effect.options.queue) ?      effect.options.queue : effect.options.queue.position;    switch(position) {      case ''front'':        // move unstarted effects after this effect        this.effects.findAll(function(e){ return e.state==''idle'' }).each( function(e) {            e.startOn  += effect.finishOn;            e.finishOn += effect.finishOn;          });        break;      case ''with-last'':        timestamp = this.effects.pluck(''startOn'').max() || timestamp;        break;      case ''end'':        // start effect after last queued effect has finished        timestamp = this.effects.pluck(''finishOn'').max() || timestamp;        break;    }    effect.startOn  += timestamp;    effect.finishOn += timestamp;    if (!effect.options.queue.limit || (this.effects.length &lt; effect.options.queue.limit))      this.effects.push(effect);    if (!this.interval)      this.interval = setInterval(this.loop.bind(this), 15);  },  remove: function(effect) {    this.effects = this.effects.reject(function(e) { return e==effect });    if (this.effects.length == 0) {      clearInterval(this.interval);      this.interval = null;    }  },  loop: function() {    var timePos = new Date().getTime();    for(var i=0, len=this.effects.length;i&lt;len;i++)      this.effects[i] &amp;&amp; this.effects[i].loop(timePos);  }});Effect.Queues = {  instances: $H(),  get: function(queueName) {    if (!Object.isString(queueName)) return queueName;    return this.instances.get(queueName) ||      this.instances.set(queueName, new Effect.ScopedQueue());  }};Effect.Queue = Effect.Queues.get(''global'');Effect.Base = Class.create({  position: null,  start: function(options) {    if (options &amp;&amp; options.transition === false) options.transition = Effect.Transitions.linear;    this.options      = Object.extend(Object.extend({ },Effect.DefaultOptions), options || { });    this.currentFrame = 0;    this.state        = ''idle'';    this.startOn      = this.options.delay*1000;    this.finishOn     = this.startOn+(this.options.duration*1000);    this.fromToDelta  = this.options.to-this.options.from;    this.totalTime    = this.finishOn-this.startOn;    this.totalFrames  = this.options.fps*this.options.duration;    this.render = (function() {      function dispatch(effect, eventName) {        if (effect.options[eventName + ''Internal''])          effect.options[eventName + ''Internal''](effect);        if (effect.options[eventName])          effect.options[eventName](effect);      }      return function(pos) {        if (this.state === "idle") {          this.state = "running";          dispatch(this, ''beforeSetup'');          if (this.setup) this.setup();          dispatch(this, ''afterSetup'');        }        if (this.state === "running") {          pos = (this.options.transition(pos) * this.fromToDelta) + this.options.from;          this.position = pos;          dispatch(this, ''beforeUpdate'');          if (this.update) this.update(pos);          dispatch(this, ''afterUpdate'');        }      };    })();    this.event(''beforeStart'');    if (!this.options.sync)      Effect.Queues.get(Object.isString(this.options.queue) ?        ''global'' : this.options.queue.scope).add(this);  },  loop: function(timePos) {    if (timePos &gt;= this.startOn) {      if (timePos &gt;= this.finishOn) {        this.render(1.0);        this.cancel();        this.event(''beforeFinish'');        if (this.finish) this.finish();        this.event(''afterFinish'');        return;      }      var pos   = (timePos - this.startOn) / this.totalTime,          frame = (pos * this.totalFrames).round();      if (frame &gt; this.currentFrame) {        this.render(pos);        this.currentFrame = frame;      }    }  },  cancel: function() {    if (!this.options.sync)      Effect.Queues.get(Object.isString(this.options.queue) ?        ''global'' : this.options.queue.scope).remove(this);    this.state = ''finished'';  },  event: function(eventName) {    if (this.options[eventName + ''Internal'']) this.options[eventName + ''Internal''](this);    if (this.options[eventName]) this.options[eventName](this);  },  inspect: function() {    var data = $H();    for(property in this)      if (!Object.isFunction(this[property])) data.set(property, this[property]);    return ''#&lt;Effect:'' + data.inspect() + '',options:'' + $H(this.options).inspect() + ''&gt;'';  }});Effect.Parallel = Class.create(Effect.Base, {  initialize: function(effects) {    this.effects = effects || [];    this.start(arguments[1]);  },  update: function(position) {    this.effects.invoke(''render'', position);  },  finish: function(position) {    this.effects.each( function(effect) {      effect.render(1.0);      effect.cancel();      effect.event(''beforeFinish'');      if (effect.finish) effect.finish(position);      effect.event(''afterFinish'');    });  }});Effect.Tween = Class.create(Effect.Base, {  initialize: function(object, from, to) {    object = Object.isString(object) ? $(object) : object;    var args = $A(arguments), method = args.last(),      options = args.length == 5 ? args[3] : null;    this.method = Object.isFunction(method) ? method.bind(object) :      Object.isFunction(object[method]) ? object[method].bind(object) :      function(value) { object[method] = value };    this.start(Object.extend({ from: from, to: to }, options || { }));  },  update: function(position) {    this.method(position);  }});Effect.Event = Class.create(Effect.Base, {  initialize: function() {    this.start(Object.extend({ duration: 0 }, arguments[0] || { }));  },  update: Prototype.emptyFunction});Effect.Opacity = Class.create(Effect.Base, {  initialize: function(element) {    this.element = $(element);    if (!this.element) throw(Effect._elementDoesNotExistError);    // make this work on IE on elements without ''layout''    if (Prototype.Browser.IE &amp;&amp; (!this.element.currentStyle.hasLayout))      this.element.setStyle({zoom: 1});    var options = Object.extend({      from: this.element.getOpacity() || 0.0,      to:   1.0    }, arguments[1] || { });    this.start(options);  },  update: function(position) {    this.element.setOpacity(position);  }});Effect.Move = Class.create(Effect.Base, {  initialize: function(element) {    this.element = $(element);    if (!this.element) throw(Effect._elementDoesNotExistError);    var options = Object.extend({      x:    0,      y:    0,      mode: ''relative''    }, arguments[1] || { });    this.start(options);  },  setup: function() {    this.element.makePositioned();    this.originalLeft = parseFloat(this.element.getStyle(''left'') || ''0'');    this.originalTop  = parseFloat(this.element.getStyle(''top'')  || ''0'');    if (this.options.mode == ''absolute'') {      this.options.x = this.options.x - this.originalLeft;      this.options.y = this.options.y - this.originalTop;    }  },  update: function(position) {    this.element.setStyle({      left: (this.options.x  * position + this.originalLeft).round() + ''px'',      top:  (this.options.y  * position + this.originalTop).round()  + ''px''    });  }});// for backwards compatibilityEffect.MoveBy = function(element, toTop, toLeft) {  return new Effect.Move(element,    Object.extend({ x: toLeft, y: toTop }, arguments[3] || { }));};Effect.Scale = Class.create(Effect.Base, {  initialize: function(element, percent) {    this.element = $(element);    if (!this.element) throw(Effect._elementDoesNotExistError);    var options = Object.extend({      scaleX: true,      scaleY: true,      scaleContent: true,      scaleFromCenter: false,      scaleMode: ''box'',        // ''box'' or ''contents'' or { } with provided values      scaleFrom: 100.0,      scaleTo:   percent    }, arguments[2] || { });    this.start(options);  },  setup: function() {    this.restoreAfterFinish = this.options.restoreAfterFinish || false;    this.elementPositioning = this.element.getStyle(''position'');    this.originalStyle = { };    [''top'',''left'',''width'',''height'',''fontSize''].each( function(k) {      this.originalStyle[k] = this.element.style[k];    }.bind(this));    this.originalTop  = this.element.offsetTop;    this.originalLeft = this.element.offsetLeft;    var fontSize = this.element.getStyle(''font-size'') || ''100%'';    [''em'',''px'',''%'',''pt''].each( function(fontSizeType) {      if (fontSize.indexOf(fontSizeType)&gt;0) {        this.fontSize     = parseFloat(fontSize);        this.fontSizeType = fontSizeType;      }    }.bind(this));    this.factor = (this.options.scaleTo - this.options.scaleFrom)/100;    this.dims = null;    if (this.options.scaleMode==''box'')      this.dims = [this.element.offsetHeight, this.element.offsetWidth];    if (/^content/.test(this.options.scaleMode))      this.dims = [this.element.scrollHeight, this.element.scrollWidth];    if (!this.dims)      this.dims = [this.options.scaleMode.originalHeight,                   this.options.scaleMode.originalWidth];  },  update: function(position) {    var currentScale = (this.options.scaleFrom/100.0) + (this.factor * position);    if (this.options.scaleContent &amp;&amp; this.fontSize)      this.element.setStyle({fontSize: this.fontSize * currentScale + this.fontSizeType });    this.setDimensions(this.dims[0] * currentScale, this.dims[1] * currentScale);  },  finish: function(position) {    if (this.restoreAfterFinish) this.element.setStyle(this.originalStyle);  },  setDimensions: function(height, width) {    var d = { };    if (this.options.scaleX) d.width = width.round() + ''px'';    if (this.options.scaleY) d.height = height.round() + ''px'';    if (this.options.scaleFromCenter) {      var topd  = (height - this.dims[0])/2;      var leftd = (width  - this.dims[1])/2;      if (this.elementPositioning == ''absolute'') {        if (this.options.scaleY) d.top = this.originalTop-topd + ''px'';        if (this.options.scaleX) d.left = this.originalLeft-leftd + ''px'';      } else {        if (this.options.scaleY) d.top = -topd + ''px'';        if (this.options.scaleX) d.left = -leftd + ''px'';      }    }    this.element.setStyle(d);  }});Effect.Highlight = Class.create(Effect.Base, {  initialize: function(element) {    this.element = $(element);    if (!this.element) throw(Effect._elementDoesNotExistError);    var options = Object.extend({ startcolor: ''#ffff99'' }, arguments[1] || { });    this.start(options);  },  setup: function() {    // Prevent executing on elements not in the layout flow    if (this.element.getStyle(''display'')==''none'') { this.cancel(); return; }    // Disable background image during the effect    this.oldStyle = { };    if (!this.options.keepBackgroundImage) {      this.oldStyle.backgroundImage = this.element.getStyle(''background-image'');      this.element.setStyle({backgroundImage: ''none''});    }    if (!this.options.endcolor)      this.options.endcolor = this.element.getStyle(''background-color'').parseColor(''#ffffff'');    if (!this.options.restorecolor)      this.options.restorecolor = this.element.getStyle(''background-color'');    // init color calculations    this._base  = $R(0,2).map(function(i){ return parseInt(this.options.startcolor.slice(i*2+1,i*2+3),16) }.bind(this));    this._delta = $R(0,2).map(function(i){ return parseInt(this.options.endcolor.slice(i*2+1,i*2+3),16)-this._base[i] }.bind(this));  },  update: function(position) {    this.element.setStyle({backgroundColor: $R(0,2).inject(''#'',function(m,v,i){      return m+((this._base[i]+(this._delta[i]*position)).round().toColorPart()); }.bind(this)) });  },  finish: function() {    this.element.setStyle(Object.extend(this.oldStyle, {      backgroundColor: this.options.restorecolor    }));  }});Effect.ScrollTo = function(element) {  var options = arguments[1] || { },  scrollOffsets = document.viewport.getScrollOffsets(),  elementOffsets = $(element).cumulativeOffset();  if (options.offset) elementOffsets[1] += options.offset;  return new Effect.Tween(null,    scrollOffsets.top,    elementOffsets[1],    options,    function(p){ scrollTo(scrollOffsets.left, p.round()); }  );};/* ------------- combination effects ------------- */Effect.Fade = function(element) {  element = $(element);  var oldOpacity = element.getInlineOpacity();  var options = Object.extend({    from: element.getOpacity() || 1.0,    to:   0.0,    afterFinishInternal: function(effect) {      if (effect.options.to!=0) return;      effect.element.hide().setStyle({opacity: oldOpacity});    }  }, arguments[1] || { });  return new Effect.Opacity(element,options);};Effect.Appear = function(element) {  element = $(element);  var options = Object.extend({  from: (element.getStyle(''display'') == ''none'' ? 0.0 : element.getOpacity() || 0.0),  to:   1.0,  // force Safari to render floated elements properly  afterFinishInternal: function(effect) {    effect.element.forceRerendering();  },  beforeSetup: function(effect) {    effect.element.setOpacity(effect.options.from).show();  }}, arguments[1] || { });  return new Effect.Opacity(element,options);};Effect.Puff = function(element) {  element = $(element);  var oldStyle = {    opacity: element.getInlineOpacity(),    position: element.getStyle(''position''),    top:  element.style.top,    left: element.style.left,    width: element.style.width,    height: element.style.height  };  return new Effect.Parallel(   [ new Effect.Scale(element, 200,      { sync: true, scaleFromCenter: true, scaleContent: true, restoreAfterFinish: true }),     new Effect.Opacity(element, { sync: true, to: 0.0 } ) ],     Object.extend({ duration: 1.0,      beforeSetupInternal: function(effect) {        Position.absolutize(effect.effects[0].element);      },      afterFinishInternal: function(effect) {         effect.effects[0].element.hide().setStyle(oldStyle); }     }, arguments[1] || { })   );};Effect.BlindUp = function(element) {  element = $(element);  element.makeClipping();  return new Effect.Scale(element, 0,    Object.extend({ scaleContent: false,      scaleX: false,      restoreAfterFinish: true,      afterFinishInternal: function(effect) {        effect.element.hide().undoClipping();      }    }, arguments[1] || { })  );};Effect.BlindDown = function(element) {  element = $(element);  var elementDimensions = element.getDimensions();  return new Effect.Scale(element, 100, Object.extend({    scaleContent: false,    scaleX: false,    scaleFrom: 0,    scaleMode: {originalHeight: elementDimensions.height, originalWidth: elementDimensions.width},    restoreAfterFinish: true,    afterSetup: function(effect) {      effect.element.makeClipping().setStyle({height: ''0px''}).show();    },    afterFinishInternal: function(effect) {      effect.element.undoClipping();    }  }, arguments[1] || { }));};Effect.SwitchOff = function(element) {  element = $(element);  var oldOpacity = element.getInlineOpacity();  return new Effect.Appear(element, Object.extend({    duration: 0.4,    from: 0,    transition: Effect.Transitions.flicker,    afterFinishInternal: function(effect) {      new Effect.Scale(effect.element, 1, {        duration: 0.3, scaleFromCenter: true,        scaleX: false, scaleContent: false, restoreAfterFinish: true,        beforeSetup: function(effect) {          effect.element.makePositioned().makeClipping();        },        afterFinishInternal: function(effect) {          effect.element.hide().undoClipping().undoPositioned().setStyle({opacity: oldOpacity});        }      });    }  }, arguments[1] || { }));};Effect.DropOut = function(element) {  element = $(element);  var oldStyle = {    top: element.getStyle(''top''),    left: element.getStyle(''left''),    opacity: element.getInlineOpacity() };  return new Effect.Parallel(    [ new Effect.Move(element, {x: 0, y: 100, sync: true }),      new Effect.Opacity(element, { sync: true, to: 0.0 }) ],    Object.extend(      { duration: 0.5,        beforeSetup: function(effect) {          effect.effects[0].element.makePositioned();        },        afterFinishInternal: function(effect) {          effect.effects[0].element.hide().undoPositioned().setStyle(oldStyle);        }      }, arguments[1] || { }));};Effect.Shake = function(element) {  element = $(element);  var options = Object.extend({    distance: 20,    duration: 0.5  }, arguments[1] || {});  var distance = parseFloat(options.distance);  var split = parseFloat(options.duration) / 10.0;  var oldStyle = {    top: element.getStyle(''top''),    left: element.getStyle(''left'') };    return new Effect.Move(element,      { x:  distance, y: 0, duration: split, afterFinishInternal: function(effect) {    new Effect.Move(effect.element,      { x: -distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {    new Effect.Move(effect.element,      { x:  distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {    new Effect.Move(effect.element,      { x: -distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {    new Effect.Move(effect.element,      { x:  distance*2, y: 0, duration: split*2,  afterFinishInternal: function(effect) {    new Effect.Move(effect.element,      { x: -distance, y: 0, duration: split, afterFinishInternal: function(effect) {        effect.element.undoPositioned().setStyle(oldStyle);  }}); }}); }}); }}); }}); }});};Effect.SlideDown = function(element) {  element = $(element).cleanWhitespace();  // SlideDown need to have the content of the element wrapped in a container element with fixed height!  var oldInnerBottom = element.down().getStyle(''bottom'');  var elementDimensions = element.getDimensions();  return new Effect.Scale(element, 100, Object.extend({    scaleContent: false,    scaleX: false,    scaleFrom: window.opera ? 0 : 1,    scaleMode: {originalHeight: elementDimensions.height, originalWidth: elementDimensions.width},    restoreAfterFinish: true,    afterSetup: function(effect) {      effect.element.makePositioned();      effect.element.down().makePositioned();      if (window.opera) effect.element.setStyle({top: ''''});      effect.element.makeClipping().setStyle({height: ''0px''}).show();    },    afterUpdateInternal: function(effect) {      effect.element.down().setStyle({bottom:        (effect.dims[0] - effect.element.clientHeight) + ''px'' });    },    afterFinishInternal: function(effect) {      effect.element.undoClipping().undoPositioned();      effect.element.down().undoPositioned().setStyle({bottom: oldInnerBottom}); }    }, arguments[1] || { })  );};Effect.SlideUp = function(element) {  element = $(element).cleanWhitespace();  var oldInnerBottom = element.down().getStyle(''bottom'');  var elementDimensions = element.getDimensions();  return new Effect.Scale(element, window.opera ? 0 : 1,   Object.extend({ scaleContent: false,    scaleX: false,    scaleMode: ''box'',    scaleFrom: 100,    scaleMode: {originalHeight: elementDimensions.height, originalWidth: elementDimensions.width},    restoreAfterFinish: true,    afterSetup: function(effect) {      effect.element.makePositioned();      effect.element.down().makePositioned();      if (window.opera) effect.element.setStyle({top: ''''});      effect.element.makeClipping().show();    },    afterUpdateInternal: function(effect) {      effect.element.down().setStyle({bottom:        (effect.dims[0] - effect.element.clientHeight) + ''px'' });    },    afterFinishInternal: function(effect) {      effect.element.hide().undoClipping().undoPositioned();      effect.element.down().undoPositioned().setStyle({bottom: oldInnerBottom});    }   }, arguments[1] || { })  );};// Bug in opera makes the TD containing this element expand for a instance after finishEffect.Squish = function(element) {  return new Effect.Scale(element, window.opera ? 1 : 0, {    restoreAfterFinish: true,    beforeSetup: function(effect) {      effect.element.makeClipping();    },    afterFinishInternal: function(effect) {      effect.element.hide().undoClipping();    }  });};Effect.Grow = function(element) {  element = $(element);  var options = Object.extend({    direction: ''center'',    moveTransition: Effect.Transitions.sinoidal,    scaleTransition: Effect.Transitions.sinoidal,    opacityTransition: Effect.Transitions.full  }, arguments[1] || { });  var oldStyle = {    top: element.style.top,    left: element.style.left,    height: element.style.height,    width: element.style.width,    opacity: element.getInlineOpacity() };  var dims = element.getDimensions();  var initialMoveX, initialMoveY;  var moveX, moveY;  switch (options.direction) {    case ''top-left'':      initialMoveX = initialMoveY = moveX = moveY = 0;      break;    case ''top-right'':      initialMoveX = dims.width;      initialMoveY = moveY = 0;      moveX = -dims.width;      break;    case ''bottom-left'':      initialMoveX = moveX = 0;      initialMoveY = dims.height;      moveY = -dims.height;      break;    case ''bottom-right'':      initialMoveX = dims.width;      initialMoveY = dims.height;      moveX = -dims.width;      moveY = -dims.height;      break;    case ''center'':      initialMoveX = dims.width / 2;      initialMoveY = dims.height / 2;      moveX = -dims.width / 2;      moveY = -dims.height / 2;      break;  }  return new Effect.Move(element, {    x: initialMoveX,    y: initialMoveY,    duration: 0.01,    beforeSetup: function(effect) {      effect.element.hide().makeClipping().makePositioned();    },    afterFinishInternal: function(effect) {      new Effect.Parallel(        [ new Effect.Opacity(effect.element, { sync: true, to: 1.0, from: 0.0, transition: options.opacityTransition }),          new Effect.Move(effect.element, { x: moveX, y: moveY, sync: true, transition: options.moveTransition }),          new Effect.Scale(effect.element, 100, {            scaleMode: { originalHeight: dims.height, originalWidth: dims.width },            sync: true, scaleFrom: window.opera ? 1 : 0, transition: options.scaleTransition, restoreAfterFinish: true})        ], Object.extend({             beforeSetup: function(effect) {               effect.effects[0].element.setStyle({height: ''0px''}).show();             },             afterFinishInternal: function(effect) {               effect.effects[0].element.undoClipping().undoPositioned().setStyle(oldStyle);             }           }, options)      );    }  });};Effect.Shrink = function(element) {  element = $(element);  var options = Object.extend({    direction: ''center'',    moveTransition: Effect.Transitions.sinoidal,    scaleTransition: Effect.Transitions.sinoidal,    opacityTransition: Effect.Transitions.none  }, arguments[1] || { });  var oldStyle = {    top: element.style.top,    left: element.style.left,    height: element.style.height,    width: element.style.width,    opacity: element.getInlineOpacity() };  var dims = element.getDimensions();  var moveX, moveY;  switch (options.direction) {    case ''top-left'':      moveX = moveY = 0;      break;    case ''top-right'':      moveX = dims.width;      moveY = 0;      break;    case ''bottom-left'':      moveX = 0;      moveY = dims.height;      break;    case ''bottom-right'':      moveX = dims.width;      moveY = dims.height;      break;    case ''center'':      moveX = dims.width / 2;      moveY = dims.height / 2;      break;  }  return new Effect.Parallel(    [ new Effect.Opacity(element, { sync: true, to: 0.0, from: 1.0, transition: options.opacityTransition }),      new Effect.Scale(element, window.opera ? 1 : 0, { sync: true, transition: options.scaleTransition, restoreAfterFinish: true}),      new Effect.Move(element, { x: moveX, y: moveY, sync: true, transition: options.moveTransition })    ], Object.extend({         beforeStartInternal: function(effect) {           effect.effects[0].element.makePositioned().makeClipping();         },         afterFinishInternal: function(effect) {           effect.effects[0].element.hide().undoClipping().undoPositioned().setStyle(oldStyle); }       }, options)  );};Effect.Pulsate = function(element) {  element = $(element);  var options    = arguments[1] || { },    oldOpacity = element.getInlineOpacity(),    transition = options.transition || Effect.Transitions.linear,    reverser   = function(pos){      return 1 - transition((-Math.cos((pos*(options.pulses||5)*2)*Math.PI)/2) + .5);    };  return new Effect.Opacity(element,    Object.extend(Object.extend({  duration: 2.0, from: 0,      afterFinishInternal: function(effect) { effect.element.setStyle({opacity: oldOpacity}); }    }, options), {transition: reverser}));};Effect.Fold = function(element) {  element = $(element);  var oldStyle = {    top: element.style.top,    left: element.style.left,    width: element.style.width,    height: element.style.height };  element.makeClipping();  return new Effect.Scale(element, 5, Object.extend({    scaleContent: false,    scaleX: false,    afterFinishInternal: function(effect) {    new Effect.Scale(element, 1, {      scaleContent: false,      scaleY: false,      afterFinishInternal: function(effect) {        effect.element.hide().undoClipping().setStyle(oldStyle);      } });  }}, arguments[1] || { }));};Effect.Morph = Class.create(Effect.Base, {  initialize: function(element) {    this.element = $(element);    if (!this.element) throw(Effect._elementDoesNotExistError);    var options = Object.extend({      style: { }    }, arguments[1] || { });    if (!Object.isString(options.style)) this.style = $H(options.style);    else {      if (options.style.include('':''))        this.style = options.style.parseStyle();      else {        this.element.addClassName(options.style);        this.style = $H(this.element.getStyles());        this.element.removeClassName(options.style);        var css = this.element.getStyles();        this.style = this.style.reject(function(style) {          return style.value == css[style.key];        });        options.afterFinishInternal = function(effect) {          effect.element.addClassName(effect.options.style);          effect.transforms.each(function(transform) {            effect.element.style[transform.style] = '''';          });        };      }    }    this.start(options);  },  setup: function(){    function parseColor(color){      if (!color || [''rgba(0, 0, 0, 0)'',''transparent''].include(color)) color = ''#ffffff'';      color = color.parseColor();      return $R(0,2).map(function(i){        return parseInt( color.slice(i*2+1,i*2+3), 16 );      });    }    this.transforms = this.style.map(function(pair){      var property = pair[0], value = pair[1], unit = null;      if (value.parseColor(''#zzzzzz'') != ''#zzzzzz'') {        value = value.parseColor();        unit  = ''color'';      } else if (property == ''opacity'') {        value = parseFloat(value);        if (Prototype.Browser.IE &amp;&amp; (!this.element.currentStyle.hasLayout))          this.element.setStyle({zoom: 1});      } else if (Element.CSS_LENGTH.test(value)) {          var components = value.match(/^([\+\-]?[0-9\.]+)(.*)$/);          value = parseFloat(components[1]);          unit = (components.length == 3) ? components[2] : null;      }      var originalValue = this.element.getStyle(property);      return {        style: property.camelize(),        originalValue: unit==''color'' ? parseColor(originalValue) : parseFloat(originalValue || 0),        targetValue: unit==''color'' ? parseColor(value) : value,        unit: unit      };    }.bind(this)).reject(function(transform){      return (        (transform.originalValue == transform.targetValue) ||        (          transform.unit != ''color'' &amp;&amp;          (isNaN(transform.originalValue) || isNaN(transform.targetValue))        )      );    });  },  update: function(position) {    var style = { }, transform, i = this.transforms.length;    while(i--)      style[(transform = this.transforms[i]).style] =        transform.unit==''color'' ? ''#''+          (Math.round(transform.originalValue[0]+            (transform.targetValue[0]-transform.originalValue[0])*position)).toColorPart() +          (Math.round(transform.originalValue[1]+            (transform.targetValue[1]-transform.originalValue[1])*position)).toColorPart() +          (Math.round(transform.originalValue[2]+            (transform.targetValue[2]-transform.originalValue[2])*position)).toColorPart() :        (transform.originalValue +          (transform.targetValue - transform.originalValue) * position).toFixed(3) +            (transform.unit === null ? '''' : transform.unit);    this.element.setStyle(style, true);  }});Effect.Transform = Class.create({  initialize: function(tracks){    this.tracks  = [];    this.options = arguments[1] || { };    this.addTracks(tracks);  },  addTracks: function(tracks){    tracks.each(function(track){      track = $H(track);      var data = track.values().first();      this.tracks.push($H({        ids:     track.keys().first(),        effect:  Effect.Morph,        options: { style: data }      }));    }.bind(this));    return this;  },  play: function(){    return new Effect.Parallel(      this.tracks.map(function(track){        var ids = track.get(''ids''), effect = track.get(''effect''), options = track.get(''options'');        var elements = [$(ids) || $$(ids)].flatten();        return elements.map(function(e){ return new effect(e, Object.extend({ sync:true }, options)) });      }).flatten(),      this.options    );  }});Element.CSS_PROPERTIES = $w(  ''backgroundColor backgroundPosition borderBottomColor borderBottomStyle '' +  ''borderBottomWidth borderLeftColor borderLeftStyle borderLeftWidth '' +  ''borderRightColor borderRightStyle borderRightWidth borderSpacing '' +  ''borderTopColor borderTopStyle borderTopWidth bottom clip color '' +  ''fontSize fontWeight height left letterSpacing lineHeight '' +  ''marginBottom marginLeft marginRight marginTop markerOffset maxHeight ''+  ''maxWidth minHeight minWidth opacity outlineColor outlineOffset '' +  ''outlineWidth paddingBottom paddingLeft paddingRight paddingTop '' +  ''right textIndent top width wordSpacing zIndex'');Element.CSS_LENGTH = /^(([\+\-]?[0-9\.]+)(em|ex|px|in|cm|mm|pt|pc|\%))|0$/;String.__parseStyleElement = document.createElement(''div'');String.prototype.parseStyle = function(){  var style, styleRules = $H();  if (Prototype.Browser.WebKit)    style = new Element(''div'',{style:this}).style;  else {    String.__parseStyleElement.innerHTML = ''&lt;div style="'' + this + ''"&gt;&lt;/div&gt;'';    style = String.__parseStyleElement.childNodes[0].style;  }  Element.CSS_PROPERTIES.each(function(property){    if (style[property]) styleRules.set(property, style[property]);  });  if (Prototype.Browser.IE &amp;&amp; this.include(''opacity''))    styleRules.set(''opacity'', this.match(/opacity:\s*((?:0|1)?(?:\.\d*)?)/)[1]);  return styleRules;};if (document.defaultView &amp;&amp; document.defaultView.getComputedStyle) {  Element.getStyles = function(element) {    var css = document.defaultView.getComputedStyle($(element), null);    return Element.CSS_PROPERTIES.inject({ }, function(styles, property) {      styles[property] = css[property];      return styles;    });  };} else {  Element.getStyles = function(element) {    element = $(element);    var css = element.currentStyle, styles;    styles = Element.CSS_PROPERTIES.inject({ }, function(results, property) {      results[property] = css[property];      return results;    });    if (!styles.opacity) styles.opacity = element.getOpacity();    return styles;  };}Effect.Methods = {  morph: function(element, style) {    element = $(element);    new Effect.Morph(element, Object.extend({ style: style }, arguments[2] || { }));    return element;  },  visualEffect: function(element, effect, options) {    element = $(element);    var s = effect.dasherize().camelize(), klass = s.charAt(0).toUpperCase() + s.substring(1);    new Effect[klass](element, options);    return element;  },  highlight: function(element, options) {    element = $(element);    new Effect.Highlight(element, options);    return element;  }};$w(''fade appear grow shrink fold blindUp blindDown slideUp slideDown ''+  ''pulsate shake puff squish switchOff dropOut'').each(  function(effect) {    Effect.Methods[effect] = function(element, options){      element = $(element);      Effect[effect.charAt(0).toUpperCase() + effect.substring(1)](element, options);      return element;    };  });$w(''getInlineOpacity forceRerendering setContentZoom collectTextNodes collectTextNodesIgnoreClass getStyles'').each(  function(f) { Effect.Methods[f] = Element[f]; });Element.addMethods(Effect.Methods);'</body><body package="Scriptaculous-Core">scriptaculousJs	^ '// script.aculo.us scriptaculous.js v1.9.0, Thu Dec 23 16:54:48 -0500 2010// Copyright (c) 2005-2010 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)//// Permission is hereby granted, free of charge, to any person obtaining// a copy of this software and associated documentation files (the// "Software"), to deal in the Software without restriction, including// without limitation the rights to use, copy, modify, merge, publish,// distribute, sublicense, and/or sell copies of the Software, and to// permit persons to whom the Software is furnished to do so, subject to// the following conditions://// The above copyright notice and this permission notice shall be// included in all copies or substantial portions of the Software.//// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.//// For details, see the script.aculo.us web site: http://script.aculo.us/var Scriptaculous = {  Version: ''1.9.0'',  require: function(libraryName) {    try{      // inserting via DOM fails in Safari 2.0, so brute force approach      document.write(''&lt;script type="text/javascript" src="''+libraryName+''"&gt;&lt;\/script&gt;'');    } catch(e) {      // for xhtml+xml served content, fall back to DOM methods      var script = document.createElement(''script'');      script.type = ''text/javascript'';      script.src = libraryName;      document.getElementsByTagName(''head'')[0].appendChild(script);    }  },  REQUIRED_PROTOTYPE: ''1.6.0.3'',  load: function() {    function convertVersionString(versionString) {      var v = versionString.replace(/_.*|\./g, '''');      v = parseInt(v + ''0''.times(4-v.length));      return versionString.indexOf(''_'') &gt; -1 ? v-1 : v;    }    if((typeof Prototype==''undefined'') ||       (typeof Element == ''undefined'') ||       (typeof Element.Methods==''undefined'') ||       (convertVersionString(Prototype.Version) &lt;        convertVersionString(Scriptaculous.REQUIRED_PROTOTYPE)))       throw("script.aculo.us requires the Prototype JavaScript framework &gt;= " +        Scriptaculous.REQUIRED_PROTOTYPE);    var js = /scriptaculous\.js(\?.*)?$/;    $$(''script[src]'').findAll(function(s) {      return s.src.match(js);    }).each(function(s) {      var path = s.src.replace(js, ''''),      includes = s.src.match(/\?.*load=([a-z,]*)/);      (includes ? includes[1] : ''builder,effects,dragdrop,controls,slider,sound'').split('','').each(       function(include) { Scriptaculous.require(path+include+''.js'') });    });  }};Scriptaculous.load();'</body><body package="Scriptaculous-Core">sliderJs	^ '// script.aculo.us slider.js v1.9.0, Thu Dec 23 16:54:48 -0500 2010// Copyright (c) 2005-2010 Marty Haught, Thomas Fuchs//// script.aculo.us is freely distributable under the terms of an MIT-style license.// For details, see the script.aculo.us web site: http://script.aculo.us/if (!Control) var Control = { };// options://  axis: ''vertical'', or ''horizontal'' (default)//// callbacks://  onChange(value)//  onSlide(value)Control.Slider = Class.create({  initialize: function(handle, track, options) {    var slider = this;    if (Object.isArray(handle)) {      this.handles = handle.collect( function(e) { return $(e) });    } else {      this.handles = [$(handle)];    }    this.track   = $(track);    this.options = options || { };    this.axis      = this.options.axis || ''horizontal'';    this.increment = this.options.increment || 1;    this.step      = parseInt(this.options.step || ''1'');    this.range     = this.options.range || $R(0,1);    this.value     = 0; // assure backwards compat    this.values    = this.handles.map( function() { return 0 });    this.spans     = this.options.spans ? this.options.spans.map(function(s){ return $(s) }) : false;    this.options.startSpan = $(this.options.startSpan || null);    this.options.endSpan   = $(this.options.endSpan || null);    this.restricted = this.options.restricted || false;    this.maximum   = this.options.maximum || this.range.end;    this.minimum   = this.options.minimum || this.range.start;    // Will be used to align the handle onto the track, if necessary    this.alignX = parseInt(this.options.alignX || ''0'');    this.alignY = parseInt(this.options.alignY || ''0'');    this.trackLength = this.maximumOffset() - this.minimumOffset();    this.handleLength = this.isVertical() ?      (this.handles[0].offsetHeight != 0 ?        this.handles[0].offsetHeight : this.handles[0].style.height.replace(/px$/,"")) :      (this.handles[0].offsetWidth != 0 ? this.handles[0].offsetWidth :        this.handles[0].style.width.replace(/px$/,""));    this.active   = false;    this.dragging = false;    this.disabled = false;    if (this.options.disabled) this.setDisabled();    // Allowed values array    this.allowedValues = this.options.values ? this.options.values.sortBy(Prototype.K) : false;    if (this.allowedValues) {      this.minimum = this.allowedValues.min();      this.maximum = this.allowedValues.max();    }    this.eventMouseDown = this.startDrag.bindAsEventListener(this);    this.eventMouseUp   = this.endDrag.bindAsEventListener(this);    this.eventMouseMove = this.update.bindAsEventListener(this);    // Initialize handles in reverse (make sure first handle is active)    this.handles.each( function(h,i) {      i = slider.handles.length-1-i;      slider.setValue(parseFloat(        (Object.isArray(slider.options.sliderValue) ?          slider.options.sliderValue[i] : slider.options.sliderValue) ||         slider.range.start), i);      h.makePositioned().observe("mousedown", slider.eventMouseDown);    });    this.track.observe("mousedown", this.eventMouseDown);    document.observe("mouseup", this.eventMouseUp);    document.observe("mousemove", this.eventMouseMove);    this.initialized = true;  },  dispose: function() {    var slider = this;    Event.stopObserving(this.track, "mousedown", this.eventMouseDown);    Event.stopObserving(document, "mouseup", this.eventMouseUp);    Event.stopObserving(document, "mousemove", this.eventMouseMove);    this.handles.each( function(h) {      Event.stopObserving(h, "mousedown", slider.eventMouseDown);    });  },  setDisabled: function(){    this.disabled = true;  },  setEnabled: function(){    this.disabled = false;  },  getNearestValue: function(value){    if (this.allowedValues){      if (value &gt;= this.allowedValues.max()) return(this.allowedValues.max());      if (value &lt;= this.allowedValues.min()) return(this.allowedValues.min());      var offset = Math.abs(this.allowedValues[0] - value);      var newValue = this.allowedValues[0];      this.allowedValues.each( function(v) {        var currentOffset = Math.abs(v - value);        if (currentOffset &lt;= offset){          newValue = v;          offset = currentOffset;        }      });      return newValue;    }    if (value &gt; this.range.end) return this.range.end;    if (value &lt; this.range.start) return this.range.start;    return value;  },  setValue: function(sliderValue, handleIdx){    if (!this.active) {      this.activeHandleIdx = handleIdx || 0;      this.activeHandle    = this.handles[this.activeHandleIdx];      this.updateStyles();    }    handleIdx = handleIdx || this.activeHandleIdx || 0;    if (this.initialized &amp;&amp; this.restricted) {      if ((handleIdx&gt;0) &amp;&amp; (sliderValue&lt;this.values[handleIdx-1]))        sliderValue = this.values[handleIdx-1];      if ((handleIdx &lt; (this.handles.length-1)) &amp;&amp; (sliderValue&gt;this.values[handleIdx+1]))        sliderValue = this.values[handleIdx+1];    }    sliderValue = this.getNearestValue(sliderValue);    this.values[handleIdx] = sliderValue;    this.value = this.values[0]; // assure backwards compat    this.handles[handleIdx].style[this.isVertical() ? ''top'' : ''left''] =      this.translateToPx(sliderValue);    this.drawSpans();    if (!this.dragging || !this.event) this.updateFinished();  },  setValueBy: function(delta, handleIdx) {    this.setValue(this.values[handleIdx || this.activeHandleIdx || 0] + delta,      handleIdx || this.activeHandleIdx || 0);  },  translateToPx: function(value) {    return Math.round(      ((this.trackLength-this.handleLength)/(this.range.end-this.range.start)) *      (value - this.range.start)) + "px";  },  translateToValue: function(offset) {    return ((offset/(this.trackLength-this.handleLength) *      (this.range.end-this.range.start)) + this.range.start);  },  getRange: function(range) {    var v = this.values.sortBy(Prototype.K);    range = range || 0;    return $R(v[range],v[range+1]);  },  minimumOffset: function(){    return(this.isVertical() ? this.alignY : this.alignX);  },  maximumOffset: function(){    return(this.isVertical() ?      (this.track.offsetHeight != 0 ? this.track.offsetHeight :        this.track.style.height.replace(/px$/,"")) - this.alignY :      (this.track.offsetWidth != 0 ? this.track.offsetWidth :        this.track.style.width.replace(/px$/,"")) - this.alignX);  },  isVertical:  function(){    return (this.axis == ''vertical'');  },  drawSpans: function() {    var slider = this;    if (this.spans)      $R(0, this.spans.length-1).each(function(r) { slider.setSpan(slider.spans[r], slider.getRange(r)) });    if (this.options.startSpan)      this.setSpan(this.options.startSpan,        $R(0, this.values.length&gt;1 ? this.getRange(0).min() : this.value ));    if (this.options.endSpan)      this.setSpan(this.options.endSpan,        $R(this.values.length&gt;1 ? this.getRange(this.spans.length-1).max() : this.value, this.maximum));  },  setSpan: function(span, range) {    if (this.isVertical()) {      span.style.top = this.translateToPx(range.start);      span.style.height = this.translateToPx(range.end - range.start + this.range.start);    } else {      span.style.left = this.translateToPx(range.start);      span.style.width = this.translateToPx(range.end - range.start + this.range.start);    }  },  updateStyles: function() {    this.handles.each( function(h){ Element.removeClassName(h, ''selected'') });    Element.addClassName(this.activeHandle, ''selected'');  },  startDrag: function(event) {    if (Event.isLeftClick(event)) {      if (!this.disabled){        this.active = true;        var handle = Event.element(event);        var pointer  = [Event.pointerX(event), Event.pointerY(event)];        var track = handle;        if (track==this.track) {          var offsets  = this.track.cumulativeOffset();          this.event = event;          this.setValue(this.translateToValue(           (this.isVertical() ? pointer[1]-offsets[1] : pointer[0]-offsets[0])-(this.handleLength/2)          ));          var offsets  = this.activeHandle.cumulativeOffset();          this.offsetX = (pointer[0] - offsets[0]);          this.offsetY = (pointer[1] - offsets[1]);        } else {          // find the handle (prevents issues with Safari)          while((this.handles.indexOf(handle) == -1) &amp;&amp; handle.parentNode)            handle = handle.parentNode;          if (this.handles.indexOf(handle)!=-1) {            this.activeHandle    = handle;            this.activeHandleIdx = this.handles.indexOf(this.activeHandle);            this.updateStyles();            var offsets  = this.activeHandle.cumulativeOffset();            this.offsetX = (pointer[0] - offsets[0]);            this.offsetY = (pointer[1] - offsets[1]);          }        }      }      Event.stop(event);    }  },  update: function(event) {   if (this.active) {      if (!this.dragging) this.dragging = true;      this.draw(event);      if (Prototype.Browser.WebKit) window.scrollBy(0,0);      Event.stop(event);   }  },  draw: function(event) {    var pointer = [Event.pointerX(event), Event.pointerY(event)];    var offsets = this.track.cumulativeOffset();    pointer[0] -= this.offsetX + offsets[0];    pointer[1] -= this.offsetY + offsets[1];    this.event = event;    this.setValue(this.translateToValue( this.isVertical() ? pointer[1] : pointer[0] ));    if (this.initialized &amp;&amp; this.options.onSlide)      this.options.onSlide(this.values.length&gt;1 ? this.values : this.value, this);  },  endDrag: function(event) {    if (this.active &amp;&amp; this.dragging) {      this.finishDrag(event, true);      Event.stop(event);    }    this.active = false;    this.dragging = false;  },  finishDrag: function(event, success) {    this.active = false;    this.dragging = false;    this.updateFinished();  },  updateFinished: function() {    if (this.initialized &amp;&amp; this.options.onChange)      this.options.onChange(this.values.length&gt;1 ? this.values : this.value, this);    this.event = null;  }});'</body><body package="Scriptaculous-Core">soundJs	^ '// script.aculo.us sound.js v1.9.0, Thu Dec 23 16:54:48 -0500 2010// Copyright (c) 2005-2010 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)//// Based on code created by Jules Gravinese (http://www.webveteran.com/)//// script.aculo.us is freely distributable under the terms of an MIT-style license.// For details, see the script.aculo.us web site: http://script.aculo.us/Sound = {  tracks: {},  _enabled: true,  template:    new Template(''&lt;embed style="height:0" id="sound_#{track}_#{id}" src="#{url}" loop="false" autostart="true" hidden="true"/&gt;''),  enable: function(){    Sound._enabled = true;  },  disable: function(){    Sound._enabled = false;  },  play: function(url){    if(!Sound._enabled) return;    var options = Object.extend({      track: ''global'', url: url, replace: false    }, arguments[1] || {});    if(options.replace &amp;&amp; this.tracks[options.track]) {      $R(0, this.tracks[options.track].id).each(function(id){        var sound = $(''sound_''+options.track+''_''+id);        sound.Stop &amp;&amp; sound.Stop();        sound.remove();      });      this.tracks[options.track] = null;    }    if(!this.tracks[options.track])      this.tracks[options.track] = { id: 0 };    else      this.tracks[options.track].id++;    options.id = this.tracks[options.track].id;    $$(''body'')[0].insert(      Prototype.Browser.IE ? new Element(''bgsound'',{        id: ''sound_''+options.track+''_''+options.id,        src: options.url, loop: 1, autostart: true      }) : Sound.template.evaluate(options));  }};if(Prototype.Browser.Gecko &amp;&amp; navigator.userAgent.indexOf("Win") &gt; 0){  if(navigator.plugins &amp;&amp; $A(navigator.plugins).detect(function(p){ return p.name.indexOf(''QuickTime'') != -1 }))    Sound.template = new Template(''&lt;object id="sound_#{track}_#{id}" width="0" height="0" type="audio/mpeg" data="#{url}"/&gt;'');  else if(navigator.plugins &amp;&amp; $A(navigator.plugins).detect(function(p){ return p.name.indexOf(''Windows Media'') != -1 }))    Sound.template = new Template(''&lt;object id="sound_#{track}_#{id}" type="application/x-mplayer2" data="#{url}"&gt;&lt;/object&gt;'');  else if(navigator.plugins &amp;&amp; $A(navigator.plugins).detect(function(p){ return p.name.indexOf(''RealPlayer'') != -1 }))    Sound.template = new Template(''&lt;embed type="audio/x-pn-realaudio-plugin" style="height:0" id="sound_#{track}_#{id}" src="#{url}" loop="false" autostart="true" hidden="true"/&gt;'');  else    Sound.play = function(){};}'</body><body package="Scriptaculous-Core">unittestJs	^ '// script.aculo.us unittest.js v1.9.0, Thu Dec 23 16:54:48 -0500 2010// Copyright (c) 2005-2010 Thomas Fuchs (http://script.aculo.us, http://mir.aculo.us)//           (c) 2005-2010 Jon Tirsen (http://www.tirsen.com)//           (c) 2005-2010 Michael Schuerig (http://www.schuerig.de/michael/)//// script.aculo.us is freely distributable under the terms of an MIT-style license.// For details, see the script.aculo.us web site: http://script.aculo.us/// experimental, Firefox-onlyEvent.simulateMouse = function(element, eventName) {  var options = Object.extend({    pointerX: 0,    pointerY: 0,    buttons:  0,    ctrlKey:  false,    altKey:   false,    shiftKey: false,    metaKey:  false  }, arguments[2] || {});  var oEvent = document.createEvent("MouseEvents");  oEvent.initMouseEvent(eventName, true, true, document.defaultView,     options.buttons, options.pointerX, options.pointerY, options.pointerX, options.pointerY,     options.ctrlKey, options.altKey, options.shiftKey, options.metaKey, 0, $(element));    if(this.mark) Element.remove(this.mark);  this.mark = document.createElement(''div'');  this.mark.appendChild(document.createTextNode(" "));  document.body.appendChild(this.mark);  this.mark.style.position = ''absolute'';  this.mark.style.top = options.pointerY + "px";  this.mark.style.left = options.pointerX + "px";  this.mark.style.width = "5px";  this.mark.style.height = "5px;";  this.mark.style.borderTop = "1px solid red;";  this.mark.style.borderLeft = "1px solid red;";    if(this.step)    alert(''[''+new Date().getTime().toString()+''] ''+eventName+''/''+Test.Unit.inspect(options));    $(element).dispatchEvent(oEvent);};// Note: Due to a fix in Firefox 1.0.5/6 that probably fixed "too much", this doesn''t work in 1.0.6 or DP2.// You need to downgrade to 1.0.4 for now to get this working// See https://bugzilla.mozilla.org/show_bug.cgi?id=289940 for the fix that fixed too muchEvent.simulateKey = function(element, eventName) {  var options = Object.extend({    ctrlKey: false,    altKey: false,    shiftKey: false,    metaKey: false,    keyCode: 0,    charCode: 0  }, arguments[2] || {});  var oEvent = document.createEvent("KeyEvents");  oEvent.initKeyEvent(eventName, true, true, window,     options.ctrlKey, options.altKey, options.shiftKey, options.metaKey,    options.keyCode, options.charCode );  $(element).dispatchEvent(oEvent);};Event.simulateKeys = function(element, command) {  for(var i=0; i&lt;command.length; i++) {    Event.simulateKey(element,''keypress'',{charCode:command.charCodeAt(i)});  }};var Test = {};Test.Unit = {};// security exception workaroundTest.Unit.inspect = Object.inspect;Test.Unit.Logger = Class.create();Test.Unit.Logger.prototype = {  initialize: function(log) {    this.log = $(log);    if (this.log) {      this._createLogTable();    }  },  start: function(testName) {    if (!this.log) return;    this.testName = testName;    this.lastLogLine = document.createElement(''tr'');    this.statusCell = document.createElement(''td'');    this.nameCell = document.createElement(''td'');    this.nameCell.className = "nameCell";    this.nameCell.appendChild(document.createTextNode(testName));    this.messageCell = document.createElement(''td'');    this.lastLogLine.appendChild(this.statusCell);    this.lastLogLine.appendChild(this.nameCell);    this.lastLogLine.appendChild(this.messageCell);    this.loglines.appendChild(this.lastLogLine);  },  finish: function(status, summary) {    if (!this.log) return;    this.lastLogLine.className = status;    this.statusCell.innerHTML = status;    this.messageCell.innerHTML = this._toHTML(summary);    this.addLinksToResults();  },  message: function(message) {    if (!this.log) return;    this.messageCell.innerHTML = this._toHTML(message);  },  summary: function(summary) {    if (!this.log) return;    this.logsummary.innerHTML = this._toHTML(summary);  },  _createLogTable: function() {    this.log.innerHTML =    ''&lt;div id="logsummary"&gt;&lt;/div&gt;'' +    ''&lt;table id="logtable"&gt;'' +    ''&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Status&lt;/th&gt;&lt;th&gt;Test&lt;/th&gt;&lt;th&gt;Message&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;'' +    ''&lt;tbody id="loglines"&gt;&lt;/tbody&gt;'' +    ''&lt;/table&gt;'';    this.logsummary = $(''logsummary'');    this.loglines = $(''loglines'');  },  _toHTML: function(txt) {    return txt.escapeHTML().replace(/\n/g,"&lt;br/&gt;");  },  addLinksToResults: function(){     $$("tr.failed .nameCell").each( function(td){ // todo: limit to children of this.log      td.title = "Run only this test";      Event.observe(td, ''click'', function(){ window.location.search = "?tests=" + td.innerHTML;});    });    $$("tr.passed .nameCell").each( function(td){ // todo: limit to children of this.log      td.title = "Run all tests";      Event.observe(td, ''click'', function(){ window.location.search = "";});    });  }};Test.Unit.Runner = Class.create();Test.Unit.Runner.prototype = {  initialize: function(testcases) {    this.options = Object.extend({      testLog: ''testlog''    }, arguments[1] || {});    this.options.resultsURL = this.parseResultsURLQueryParameter();    this.options.tests      = this.parseTestsQueryParameter();    if (this.options.testLog) {      this.options.testLog = $(this.options.testLog) || null;    }    if(this.options.tests) {      this.tests = [];      for(var i = 0; i &lt; this.options.tests.length; i++) {        if(/^test/.test(this.options.tests[i])) {          this.tests.push(new Test.Unit.Testcase(this.options.tests[i], testcases[this.options.tests[i]], testcases["setup"], testcases["teardown"]));        }      }    } else {      if (this.options.test) {        this.tests = [new Test.Unit.Testcase(this.options.test, testcases[this.options.test], testcases["setup"], testcases["teardown"])];      } else {        this.tests = [];        for(var testcase in testcases) {          if(/^test/.test(testcase)) {            this.tests.push(               new Test.Unit.Testcase(                 this.options.context ? '' -&gt; '' + this.options.titles[testcase] : testcase,                  testcases[testcase], testcases["setup"], testcases["teardown"]               ));          }        }      }    }    this.currentTest = 0;    this.logger = new Test.Unit.Logger(this.options.testLog);    setTimeout(this.runTests.bind(this), 1000);  },  parseResultsURLQueryParameter: function() {    return window.location.search.parseQuery()["resultsURL"];  },  parseTestsQueryParameter: function(){    if (window.location.search.parseQuery()["tests"]){        return window.location.search.parseQuery()["tests"].split('','');    };  },  // Returns:  //  "ERROR" if there was an error,  //  "FAILURE" if there was a failure, or  //  "SUCCESS" if there was neither  getResult: function() {    var hasFailure = false;    for(var i=0;i&lt;this.tests.length;i++) {      if (this.tests[i].errors &gt; 0) {        return "ERROR";      }      if (this.tests[i].failures &gt; 0) {        hasFailure = true;      }    }    if (hasFailure) {      return "FAILURE";    } else {      return "SUCCESS";    }  },  postResults: function() {    if (this.options.resultsURL) {      new Ajax.Request(this.options.resultsURL,         { method: ''get'', parameters: ''result='' + this.getResult(), asynchronous: false });    }  },  runTests: function() {    var test = this.tests[this.currentTest];    if (!test) {      // finished!      this.postResults();      this.logger.summary(this.summary());      return;    }    if(!test.isWaiting) {      this.logger.start(test.name);    }    test.run();    if(test.isWaiting) {      this.logger.message("Waiting for " + test.timeToWait + "ms");      setTimeout(this.runTests.bind(this), test.timeToWait || 1000);    } else {      this.logger.finish(test.status(), test.summary());      this.currentTest++;      // tail recursive, hopefully the browser will skip the stackframe      this.runTests();    }  },  summary: function() {    var assertions = 0;    var failures = 0;    var errors = 0;    var messages = [];    for(var i=0;i&lt;this.tests.length;i++) {      assertions +=   this.tests[i].assertions;      failures   +=   this.tests[i].failures;      errors     +=   this.tests[i].errors;    }    return (      (this.options.context ? this.options.context + '': '': '''') +       this.tests.length + " tests, " +       assertions + " assertions, " +       failures   + " failures, " +      errors     + " errors");  }};Test.Unit.Assertions = Class.create();Test.Unit.Assertions.prototype = {  initialize: function() {    this.assertions = 0;    this.failures   = 0;    this.errors     = 0;    this.messages   = [];  },  summary: function() {    return (      this.assertions + " assertions, " +       this.failures   + " failures, " +      this.errors     + " errors" + "\n" +      this.messages.join("\n"));  },  pass: function() {    this.assertions++;  },  fail: function(message) {    this.failures++;    this.messages.push("Failure: " + message);  },  info: function(message) {    this.messages.push("Info: " + message);  },  error: function(error) {    this.errors++;    this.messages.push(error.name + ": "+ error.message + "(" + Test.Unit.inspect(error) +")");  },  status: function() {    if (this.failures &gt; 0) return ''failed'';    if (this.errors &gt; 0) return ''error'';    return ''passed'';  },  assert: function(expression) {    var message = arguments[1] || ''assert: got "'' + Test.Unit.inspect(expression) + ''"'';    try { expression ? this.pass() :       this.fail(message); }    catch(e) { this.error(e); }  },  assertEqual: function(expected, actual) {    var message = arguments[2] || "assertEqual";    try { (expected == actual) ? this.pass() :      this.fail(message + '': expected "'' + Test.Unit.inspect(expected) +         ''", actual "'' + Test.Unit.inspect(actual) + ''"''); }    catch(e) { this.error(e); }  },  assertInspect: function(expected, actual) {    var message = arguments[2] || "assertInspect";    try { (expected == actual.inspect()) ? this.pass() :      this.fail(message + '': expected "'' + Test.Unit.inspect(expected) +         ''", actual "'' + Test.Unit.inspect(actual) + ''"''); }    catch(e) { this.error(e); }  },  assertEnumEqual: function(expected, actual) {    var message = arguments[2] || "assertEnumEqual";    try { $A(expected).length == $A(actual).length &amp;&amp;       expected.zip(actual).all(function(pair) { return pair[0] == pair[1] }) ?        this.pass() : this.fail(message + '': expected '' + Test.Unit.inspect(expected) +           '', actual '' + Test.Unit.inspect(actual)); }    catch(e) { this.error(e); }  },  assertNotEqual: function(expected, actual) {    var message = arguments[2] || "assertNotEqual";    try { (expected != actual) ? this.pass() :       this.fail(message + '': got "'' + Test.Unit.inspect(actual) + ''"''); }    catch(e) { this.error(e); }  },  assertIdentical: function(expected, actual) {     var message = arguments[2] || "assertIdentical";     try { (expected === actual) ? this.pass() :       this.fail(message + '': expected "'' + Test.Unit.inspect(expected) +          ''", actual "'' + Test.Unit.inspect(actual) + ''"''); }     catch(e) { this.error(e); }   },  assertNotIdentical: function(expected, actual) {     var message = arguments[2] || "assertNotIdentical";     try { !(expected === actual) ? this.pass() :       this.fail(message + '': expected "'' + Test.Unit.inspect(expected) +          ''", actual "'' + Test.Unit.inspect(actual) + ''"''); }     catch(e) { this.error(e); }   },  assertNull: function(obj) {    var message = arguments[1] || ''assertNull'';    try { (obj==null) ? this.pass() :       this.fail(message + '': got "'' + Test.Unit.inspect(obj) + ''"''); }    catch(e) { this.error(e); }  },  assertMatch: function(expected, actual) {    var message = arguments[2] || ''assertMatch'';    var regex = new RegExp(expected);    try { (regex.exec(actual)) ? this.pass() :      this.fail(message + '' : regex: "'' +  Test.Unit.inspect(expected) + '' did not match: '' + Test.Unit.inspect(actual) + ''"''); }    catch(e) { this.error(e); }  },  assertHidden: function(element) {    var message = arguments[1] || ''assertHidden'';    this.assertEqual("none", element.style.display, message);  },  assertNotNull: function(object) {    var message = arguments[1] || ''assertNotNull'';    this.assert(object != null, message);  },  assertType: function(expected, actual) {    var message = arguments[2] || ''assertType'';    try {       (actual.constructor == expected) ? this.pass() :       this.fail(message + '': expected "'' + Test.Unit.inspect(expected) +          ''", actual "'' + (actual.constructor) + ''"''); }    catch(e) { this.error(e); }  },  assertNotOfType: function(expected, actual) {    var message = arguments[2] || ''assertNotOfType'';    try {       (actual.constructor != expected) ? this.pass() :       this.fail(message + '': expected "'' + Test.Unit.inspect(expected) +          ''", actual "'' + (actual.constructor) + ''"''); }    catch(e) { this.error(e); }  },  assertInstanceOf: function(expected, actual) {    var message = arguments[2] || ''assertInstanceOf'';    try {       (actual instanceof expected) ? this.pass() :       this.fail(message + ": object was not an instance of the expected type"); }    catch(e) { this.error(e); }   },  assertNotInstanceOf: function(expected, actual) {    var message = arguments[2] || ''assertNotInstanceOf'';    try {       !(actual instanceof expected) ? this.pass() :       this.fail(message + ": object was an instance of the not expected type"); }    catch(e) { this.error(e); }   },  assertRespondsTo: function(method, obj) {    var message = arguments[2] || ''assertRespondsTo'';    try {      (obj[method] &amp;&amp; typeof obj[method] == ''function'') ? this.pass() :       this.fail(message + ": object doesn''t respond to [" + method + "]"); }    catch(e) { this.error(e); }  },  assertReturnsTrue: function(method, obj) {    var message = arguments[2] || ''assertReturnsTrue'';    try {      var m = obj[method];      if(!m) m = obj[''is''+method.charAt(0).toUpperCase()+method.slice(1)];      m() ? this.pass() :       this.fail(message + ": method returned false"); }    catch(e) { this.error(e); }  },  assertReturnsFalse: function(method, obj) {    var message = arguments[2] || ''assertReturnsFalse'';    try {      var m = obj[method];      if(!m) m = obj[''is''+method.charAt(0).toUpperCase()+method.slice(1)];      !m() ? this.pass() :       this.fail(message + ": method returned true"); }    catch(e) { this.error(e); }  },  assertRaise: function(exceptionName, method) {    var message = arguments[2] || ''assertRaise'';    try {       method();      this.fail(message + ": exception expected but none was raised"); }    catch(e) {      ((exceptionName == null) || (e.name==exceptionName)) ? this.pass() : this.error(e);     }  },  assertElementsMatch: function() {    var expressions = $A(arguments), elements = $A(expressions.shift());    if (elements.length != expressions.length) {      this.fail(''assertElementsMatch: size mismatch: '' + elements.length + '' elements, '' + expressions.length + '' expressions'');      return false;    }    elements.zip(expressions).all(function(pair, index) {      var element = $(pair.first()), expression = pair.last();      if (element.match(expression)) return true;      this.fail(''assertElementsMatch: (in index '' + index + '') expected '' + expression.inspect() + '' but got '' + element.inspect());    }.bind(this)) &amp;&amp; this.pass();  },  assertElementMatches: function(element, expression) {    this.assertElementsMatch([element], expression);  },  benchmark: function(operation, iterations) {    var startAt = new Date();    (iterations || 1).times(operation);    var timeTaken = ((new Date())-startAt);    this.info((arguments[2] || ''Operation'') + '' finished '' +        iterations + '' iterations in '' + (timeTaken/1000)+''s'' );    return timeTaken;  },  _isVisible: function(element) {    element = $(element);    if(!element.parentNode) return true;    this.assertNotNull(element);    if(element.style &amp;&amp; Element.getStyle(element, ''display'') == ''none'')      return false;        return this._isVisible(element.parentNode);  },  assertNotVisible: function(element) {    this.assert(!this._isVisible(element), Test.Unit.inspect(element) + " was not hidden and didn''t have a hidden parent either. " + ("" || arguments[1]));  },  assertVisible: function(element) {    this.assert(this._isVisible(element), Test.Unit.inspect(element) + " was not visible. " + ("" || arguments[1]));  },  benchmark: function(operation, iterations) {    var startAt = new Date();    (iterations || 1).times(operation);    var timeTaken = ((new Date())-startAt);    this.info((arguments[2] || ''Operation'') + '' finished '' +        iterations + '' iterations in '' + (timeTaken/1000)+''s'' );    return timeTaken;  }};Test.Unit.Testcase = Class.create();Object.extend(Object.extend(Test.Unit.Testcase.prototype, Test.Unit.Assertions.prototype), {  initialize: function(name, test, setup, teardown) {    Test.Unit.Assertions.prototype.initialize.bind(this)();    this.name           = name;        if(typeof test == ''string'') {      test = test.gsub(/(\.should[^\(]+\()/,''#{0}this,'');      test = test.gsub(/(\.should[^\(]+)\(this,\)/,''#{1}(this)'');      this.test = function() {        eval(''with(this){''+test+''}'');      }    } else {      this.test = test || function() {};    }        this.setup          = setup || function() {};    this.teardown       = teardown || function() {};    this.isWaiting      = false;    this.timeToWait     = 1000;  },  wait: function(time, nextPart) {    this.isWaiting = true;    this.test = nextPart;    this.timeToWait = time;  },  run: function() {    try {      try {        if (!this.isWaiting) this.setup.bind(this)();        this.isWaiting = false;        this.test.bind(this)();      } finally {        if(!this.isWaiting) {          this.teardown.bind(this)();        }      }    }    catch(e) { this.error(e); }  }});// *EXPERIMENTAL* BDD-style testing to please non-technical folk// This draws many ideas from RSpec http://rspec.rubyforge.org/Test.setupBDDExtensionMethods = function(){  var METHODMAP = {    shouldEqual:     ''assertEqual'',    shouldNotEqual:  ''assertNotEqual'',    shouldEqualEnum: ''assertEnumEqual'',    shouldBeA:       ''assertType'',    shouldNotBeA:    ''assertNotOfType'',    shouldBeAn:      ''assertType'',    shouldNotBeAn:   ''assertNotOfType'',    shouldBeNull:    ''assertNull'',    shouldNotBeNull: ''assertNotNull'',        shouldBe:        ''assertReturnsTrue'',    shouldNotBe:     ''assertReturnsFalse'',    shouldRespondTo: ''assertRespondsTo''  };  var makeAssertion = function(assertion, args, object) {    	this[assertion].apply(this,(args || []).concat([object]));  };    Test.BDDMethods = {};     $H(METHODMAP).each(function(pair) {     Test.BDDMethods[pair.key] = function() {        var args = $A(arguments);        var scope = args.shift();        makeAssertion.apply(scope, [pair.value, args, this]); };   });    [Array.prototype, String.prototype, Number.prototype, Boolean.prototype].each(    function(p){ Object.extend(p, Test.BDDMethods) }  );};Test.context = function(name, spec, log){  Test.setupBDDExtensionMethods();    var compiledSpec = {};  var titles = {};  for(specName in spec) {    switch(specName){      case "setup":      case "teardown":        compiledSpec[specName] = spec[specName];        break;      default:        var testName = ''test''+specName.gsub(/\s+/,''-'').camelize();        var body = spec[specName].toString().split(''\n'').slice(1);        if(/^\{/.test(body[0])) body = body.slice(1);        body.pop();        body = body.map(function(statement){           return statement.strip()        });        compiledSpec[testName] = body.join(''\n'');        titles[testName] = specName;    }  }  new Test.Unit.Runner(compiledSpec, { titles: titles, testLog: log || ''testlog'', context: name });};'</body></methods><methods><class-id>Scriptaculous.SUEffect</class-id> <category>options</category><body package="Scriptaculous-Core">direction: aString	"Set the direction of the transition. Values can be either 'top-left', 'top-right', 'bottom-left', 'bottom-right' or 'center' (default). Applicable only on Grow and Shrink effects."	self optionAt: 'direction' put: aString</body><body package="Scriptaculous-Core">duration: aNumber	"Duration of the effect in seconds, given as a float. Defaults to 1.0."	self optionAt: 'duration' put: aNumber</body><body package="Scriptaculous-Core">fps: aNumber	"Target this many frames per second. Default to 25. Can't be higher than 100."	self optionAt: 'fps' put: aNumber</body><body package="Scriptaculous-Core">from: aNumber	"Sets the starting point of the transition, a float between 0.0 and 1.0. Defaults to 0.0."	self optionAt: 'from' put: aNumber</body><body package="Scriptaculous-Core">queue: aString	"Sets queuing options. When used with a string, can be 'front' or 'end' or 'with-last' to queue the effect in the global effects queue at the beginning or end, or a queue parameter object that can have {position: 'front/end', scope: 'scope', limit:1}."	self optionAt: 'queue' put: aString</body><body package="Scriptaculous-Core">sync: aBoolean	"Sets whether the effect should render new frames automatically (which it does by default). If true, you can render frames manually by calling the render() instance method of an effect. This is used by Effect.Parallel()."	self optionAt: 'sync' put: aBoolean</body><body package="Scriptaculous-Core">to: aNumber	"Sets the end point of the transition, a float between 0.0 and 1.0. Defaults to 1.0."	self optionAt: 'to' put: aNumber</body><body package="Scriptaculous-Core">transition: anObject	"Sets a function that modifies the current point of the animation, which is between 0 and 1. Following transitions are supplied: Effect.Transitions.sinoidal (default), Effect.Transitions.linear, Effect.Transitions.reverse, Effect.Transitions.wobble and Effect.Transitions.flicker."	self optionAt: 'transition' put: anObject asFunction</body></methods><methods><class-id>Scriptaculous.SUEffect</class-id> <category>effects</category><body package="Scriptaculous-Core">event	"One-shot events that follow timelines defined by effect queues."	self create; method: 'Event'; arguments: #()</body><body package="Scriptaculous-Core">highlight	"This effect Flashes a color as the background of an element. It is mostly used to draw attention to a part of the page that has been updated via javascript or AJAX, when the update would not otherwise be obvious."	self create; method: 'Highlight'</body><body package="Scriptaculous-Core">morph	"This effect morphs to a given CSS style rule. It does take orginal styles given by CSS style rules or the style attribute into consideration when calculating the transforms. It works with all length and color based CSS properties, including margins, paddings, borders, opacity and text/background colors."	self create; method: 'Morph'</body><body package="Scriptaculous-Core">move	"This effect moves an element by modifying its position attributes."		self create; method: 'Move'</body><body package="Scriptaculous-Core">move: aPoint	self x: aPoint x; y: aPoint y; move</body><body package="Scriptaculous-Core">opacity	"This effect changes an element's opacity"	self create; method: 'Opacity'</body><body package="Scriptaculous-Core">parallel: aCollection	"This is a special effect to allow to combine more than one core effect into a parallel effect."	self create; method: 'Parallel'; arguments: (Array with: aCollection)</body><body package="Scriptaculous-Core">scale: aNumber	"This effect changes an elements width and height dimensions and the base for em units. This allows for smooth, automatic relative scaling of elements contained within the scaled element."	self create; method: 'Scale'; arguments: self arguments , (Array with: aNumber)</body><body package="Scriptaculous-Core">scroll	"Scroll page view to element."	self create; method: 'ScrollTo'</body><body package="Scriptaculous-Core">tweenFrom: aFromInteger to: aToInteger using: aStringOrFunction	"This effect tweens between two values and sets a property or calls a method on an object; or allows for a callback method, which will be automatically bound to the object."	self create; method: 'Tween'; arguments: self arguments , (Array with: aFromInteger with: aToInteger with: aStringOrFunction)</body></methods><methods><class-id>Scriptaculous.SUEffect</class-id> <category>effects-combination</category><body package="Scriptaculous-Core">appear	"Make an element appear. If the element was previously set to display:none; inside the style attribute of the element, the effect will automatically show the element. This means that it must be places under the style attribute of an object, and not in the CSS in the head of the document or a linked file."	self create; method: 'Appear'</body><body package="Scriptaculous-Core">blindDown	"Simulate a window blind, where the contents of the affected elements stay in place."	self create; method: 'BlindDown'</body><body package="Scriptaculous-Core">blindUp	"Simulate a window blind, where the contents of the affected elements stay in place."	self create; method: 'BlindUp'</body><body package="Scriptaculous-Core">dropOut	"Make the element drop and fade out at the same time."	self create; method: 'DropOut'</body><body package="Scriptaculous-Core">fade	"Make an element fade away and takes it out of the document flow at the end of the effect by setting the CSS display property to none."	self create; method: 'Fade'</body><body package="Scriptaculous-Core">fold	"Reduce the element to its top then to left to make it disappear."	self create; method: 'Fold'</body><body package="Scriptaculous-Core">grow	"See a demo."	self create; method: 'Grow'</body><body package="Scriptaculous-Core">puff	"Give the illusion of the element puffing away (like a in a cloud of smoke)."	self create; method: 'Puff'</body><body package="Scriptaculous-Core">pulsate	"Pulsate the element, loops over five times over fading out and in."	self create; method: 'Pulsate'</body><body package="Scriptaculous-Core">shake	"Move the element slightly to the left, then to the right, repeatedly."	self create; method: 'Shake'</body><body package="Scriptaculous-Core">shrink	"Reduce the element to its top-left corner."	self create; method: 'Shrink'</body><body package="Scriptaculous-Core">slideDown	"Simulate a window blind, where the contents of the affected elements scroll up and down accordingly."	self create; method: 'SlideDown'</body><body package="Scriptaculous-Core">slideUp	"Simulate a window blind, where the contents of the affected elements scroll up and down accordingly."	self create; method: 'SlideUp'</body><body package="Scriptaculous-Core">squish	"Reduce the element to its top-left corner."	self create; method: 'Squish'</body><body package="Scriptaculous-Core">switchOff	"Give the illusion of a TV-style switch off."	self create; method: 'SwitchOff'</body></methods><methods><class-id>Scriptaculous.SUEffect</class-id> <category>options-highlight</category><body package="Scriptaculous-Core">endColor: aColor	"Sets the color of the last frame of the highlight. This is best set to the background color of the highlighted element."	self optionAt: 'endcolor' put: aColor</body><body package="Scriptaculous-Core">restoreColor: aColor	"Sets the background color of the element after the highlight has finished."	self optionAt: 'restorecolor' put: aColor</body><body package="Scriptaculous-Core">startColor: aColor	"Sets the color of first frame of the highlight."	self optionAt: 'startcolor' put: aColor</body></methods><methods><class-id>Scriptaculous.SUEffect</class-id> <category>events</category><body package="Scriptaculous-Core">onAfterFinish: anObject	"Called after the last redraw of the effect was made."	self options at: 'afterFinish' put: anObject asFunction</body><body package="Scriptaculous-Core">onAfterUpdate: anObject	"Called on each iteration of the effects rendering loop, after the redraw takes places."	self options at: 'afterUpdate' put: anObject asFunction</body><body package="Scriptaculous-Core">onBeforeStart: anObject	"Called before the main effects rendering loop is started."	self options at: 'beforeStart' put: anObject asFunction</body><body package="Scriptaculous-Core">onBeforeUpdate: anObject	"Called on each iteration of the effects rendering loop, before the redraw takes places."	self options at: 'beforeUpdate' put: anObject asFunction</body></methods><methods><class-id>Scriptaculous.SUEffect</class-id> <category>options-move</category><body package="Scriptaculous-Core">absolute	self mode: 'absolute'</body><body package="Scriptaculous-Core">mode: aString	"Defaults to 'relative', can also be 'absolute', specifies if the element is moved absolutely or relative to its own position."		self optionAt: 'mode' put: aString</body><body package="Scriptaculous-Core">relative	self mode: 'relative'</body><body package="Scriptaculous-Core">x: anInteger	"Either the new absolute target of the effect elements top value or the modifier of its current top value, depending on the mode option."		self optionAt: 'x' put: anInteger</body><body package="Scriptaculous-Core">y: anInteger	"Either the new absolute target of the effect elements top value or the modifier of its current top value, depending on the mode option."		self optionAt: 'y' put: anInteger</body></methods><methods><class-id>Scriptaculous.SUEffect</class-id> <category>effects-toggles</category><body package="Scriptaculous-Core">toggle: aString	"Allow for easily toggling elements with an animation."	self method: 'toggle'; arguments: self arguments , (Array with: aString)</body><body package="Scriptaculous-Core">toggleAppear	self toggle: 'Appear'</body><body package="Scriptaculous-Core">toggleBlind	self toggle: 'Blind'</body><body package="Scriptaculous-Core">toggleSlide	self toggle: 'Slide'</body></methods><methods><class-id>Scriptaculous.SUEffect</class-id> <category>options-morph</category><body package="Scriptaculous-Core">style: aString	"Target CSS style rule for a morph transition."	self optionAt: 'style' put: aString</body></methods><methods><class-id>Scriptaculous.SUEffect</class-id> <category>options-scale</category><body package="Scriptaculous-Core">scaleContent: aBoolean	"Set whether content scaling should be enabled, defaults to true."	self optionAt: 'scaleContent' put: aBoolean</body><body package="Scriptaculous-Core">scaleFrom: aNumber	"Set the starting percentage for scaling, defaults to 100.0."	self optionAt: 'scaleFrom' put: aNumber</body><body package="Scriptaculous-Core">scaleFromCenter: aBoolean	"If true, scale the element in a way that the center of the element stays on the same position on the screen, defaults to false."	self optionAt: 'scaleFromCenter' put: aBoolean</body><body package="Scriptaculous-Core">scaleMode: anObject	"Either 'box' (default, scales the visible area of the element) or 'contents' (scales the complete element, that is parts normally only visible byscrolling are taken into account). You can also precisely control the size the element will become by assigning the originalHeight and originalWidth variables to scaleMode."	self optionAt: 'scaleMode' put: anObject</body><body package="Scriptaculous-Core">scaleX: aBoolean	"Set whether the element should be scaled horizontally, defaults to true."	self optionAt: 'scaleX' put: aBoolean</body><body package="Scriptaculous-Core">scaleY: aBoolean	"Set whether the element should be scaled vertically, defaults to true."	self optionAt: 'scaleY' put: aBoolean</body></methods><methods><class-id>Scriptaculous.SUEffect</class-id> <category>private</category><body package="Scriptaculous-Core">defaultMethod	^ 'toggle'</body><body package="Scriptaculous-Core">defaultPrototype	^ 'Effect'</body></methods><methods><class-id>Scriptaculous.SUEffect</class-id> <category>options-pulsate</category><body package="Scriptaculous-Core">pulses: anInteger	"Control the amount of pulses."	self optionAt: 'pulses' put: anInteger</body></methods><methods><class-id>Scriptaculous.SUEffect</class-id> <category>options-scroll</category><body package="Scriptaculous-Core">offset: anInteger	"Negative or positive number of pixels as offset to the top of view."	self optionAt: 'offset' put: anInteger</body></methods><methods><class-id>Scriptaculous.SUInPlaceEditor</class-id> <category>options</category><body package="Scriptaculous-Core">autoRows: anInteger	self optionAt: 'autoRows' put: anInteger</body><body package="Scriptaculous-Core">cancelControl: aString	"link|button|false"	self optionAt: 'cancelControl' put: aString</body><body package="Scriptaculous-Core">cancelText: aString	"The text of the link that cancels editing."		self optionAt: 'cancelText' put: aString</body><body package="Scriptaculous-Core">clickToEditText: aString	"The text shown during mouseover the editable text."		self optionAt: 'clickToEditText' put: aString</body><body package="Scriptaculous-Core">externalControl: aString	"Id of an element that acts as an external control used to enter edit mode. The external control will be hidden when entering edit mode and shown again when leaving edit mode."		self optionAt: 'externalControl' put: aString</body><body package="Scriptaculous-Core">externalControlOnly: aBoolean	self optionAt: 'externalControlOnly' put: aBoolean</body><body package="Scriptaculous-Core">fieldPostCreation: aString	"activate|focus|false"		self optionAt: 'fieldPostCreation' put: aString</body><body package="Scriptaculous-Core">formClassName: aString	self optionAt: 'formClassName' put: aString</body><body package="Scriptaculous-Core">formId: aString	"Id of the element to edit."		self optionAt: 'formId' put: aString</body><body package="Scriptaculous-Core">highlightColor: aColor	"The highlight color."	self optionAt: 'highlightColor' put: aColor</body><body package="Scriptaculous-Core">highlightEndColor: aColor	"The color which the highlight fades to."	self optionAt: 'highlightEndColor' put: aColor</body><body package="Scriptaculous-Core">hoverClassName: aString	self optionAt: 'hoverClassName' put: aString</body><body package="Scriptaculous-Core">htmlResponse: aBoolean	self optionAt: 'htmlResponse' put: aBoolean</body><body package="Scriptaculous-Core">loadingClassName: aString	self optionAt: 'loadingClassName' put: aString</body><body package="Scriptaculous-Core">loadingText: aString	self optionAt: 'loadingText' put: aString</body><body package="Scriptaculous-Core">okControl: aString	"link|button|false"		self optionAt: 'okControl' put: aString</body><body package="Scriptaculous-Core">okText: aString	"The text of the submit button that submits the changed value to the server."	self optionAt: 'okText' put: aString</body><body package="Scriptaculous-Core">paramName: aString	self optionAt: 'paramName' put: aString</body><body package="Scriptaculous-Core">rows: anInteger	"The row height of the input field, anything greater than 1 uses a multiline textarea for input."	self optionAt: 'rows' put: anInteger</body><body package="Scriptaculous-Core">savingClassName: aString	self optionAt: 'savingClassName' put: aString</body><body package="Scriptaculous-Core">savingText: aString	"The text shown while the text is sent to the server."	self optionAt: 'savingText' put: aString</body><body package="Scriptaculous-Core">size: anInteger	self optionAt: 'size' put: anInteger</body><body package="Scriptaculous-Core">stripLoadedTextTags: aBoolean	self optionAt: 'stripLoadedTextTags' put: aBoolean</body><body package="Scriptaculous-Core">submitOnBlur: aBoolean	self optionAt: 'submitOnBlur' put: aBoolean</body><body package="Scriptaculous-Core">textAfterControls: aString	self optionAt: 'textAfterControls' put: aString</body><body package="Scriptaculous-Core">textBeforeControls: aString	self optionAt: 'textBeforeControls' put: aString</body><body package="Scriptaculous-Core">textBetweenControls: aString	self optionAt: 'textBetweenControls' put: aString</body></methods><methods><class-id>Scriptaculous.SUInPlaceEditor</class-id> <category>events</category><body package="Scriptaculous-Core">onEnterEditMode: anObject	self optionAt: 'onEnterEditMode' put: anObject asFunction</body><body package="Scriptaculous-Core">onEnterHover: anObject	self optionAt: 'onEnterHover' put: anObject asFunction</body><body package="Scriptaculous-Core">onFormCustomization: anObject	self optionAt: 'onFormCustomization' put: anObject asFunction</body><body package="Scriptaculous-Core">onLeaveEditMode: anObject	self optionAt: 'onLeaveEditMode' put: anObject asFunction</body><body package="Scriptaculous-Core">onLeaveHover: anObject	self optionAt: 'onLeaveHover' put: anObject asFunction</body></methods><methods><class-id>Scriptaculous.SUInPlaceEditor</class-id> <category>private</category><body package="Scriptaculous-Core">defaultPrototype	^ 'Ajax.InPlaceEditor'</body></methods><methods><class-id>Scriptaculous.SUInPlaceEditor</class-id> <category>initialization</category><body package="Scriptaculous-Core">initialize	super initialize.	self options removeKey: 'evalScripts'</body></methods><methods><class-id>Scriptaculous.SUInPlaceEditor</class-id> <category>deprecated</category><body package="Scriptaculous-Core">cancelButton: aBoolean 	self 		greaseDeprecatedApi: 'SUInPlaceEditor&gt;&gt;#cancelButton:'		details: 'Use cancelControl:.'.	self cancelControl: (aBoolean 			ifTrue: [ 'button' ]			ifFalse: [ false ])</body><body package="Scriptaculous-Core">cancelLink: aBoolean 	self 		greaseDeprecatedApi: 'SUInPlaceEditor&gt;&gt;#cancelLink:'		details: 'Use #cancelControl:.'.	self cancelControl: (aBoolean 			ifTrue: [ 'link' ]			ifFalse: [ false ])</body><body package="Scriptaculous-Core">okButton: aBoolean 	self 		greaseDeprecatedApi: 'SUInPlaceEditor&gt;&gt;#okButton:'		details: 'Use okControl:.'.	self okControl: (aBoolean 			ifTrue: [ 'button' ]			ifFalse: [ false ])</body><body package="Scriptaculous-Core">okLink: aBoolean 	self 		greaseDeprecatedApi: 'SUInPlaceEditor&gt;&gt;#okLink:'		details: 'Use okControl:.'.	self okControl: (aBoolean 			ifTrue: [ 'link' ]			ifFalse: [ false ])</body></methods><methods><class-id>Scriptaculous.SUInPlaceEditor</class-id> <category>triggers</category><body package="Scriptaculous-Core">triggerInPlaceEditor: aBlock	self callback: aBlock value: (JSStream argument: 1).	self optionAt: 'callback' put: (JSFunction new		add: (self options removeKey: 'parameters');		return: true;		yourself)</body></methods><methods><class-id>Scriptaculous.SUGoogleLibrary</class-id> <category>updating</category><body package="Scriptaculous-Core">updateRoot: anHtmlRoot	super updateRoot: anHtmlRoot.	anHtmlRoot javascript		url: 'https://ajax.googleapis.com/ajax/libs/scriptaculous/1.9.0/scriptaculous.js'</body></methods><methods><class-id>Scriptaculous.SUSortable</class-id> <category>events</category><body package="Scriptaculous-Core">onChange: anObject	"Called whenever the sort order changes while dragging. When dragging from one Sortable to another, the callback is called once on each Sortable."	self optionAt: 'onChange' put: anObject asFunction</body><body package="Scriptaculous-Core">onUpdate: anObject	"Called when the drag ends and the Sortable's order is changed in any way. When dragging from one Sortable to another, the callback is called once on each Sortable."	self optionAt: 'onUpdate' put: anObject asFunction</body></methods><methods><class-id>Scriptaculous.SUSortable</class-id> <category>initialization</category><body package="Scriptaculous-Core">initialize	super initialize.	self format: (JSStream on: '/^(.*)$/')</body></methods><methods><class-id>Scriptaculous.SUSortable</class-id> <category>options</category><body package="Scriptaculous-Core">constraint: aString	"If set to #horizontal or #vertical the drag will be constrained to take place only horizontally or vertically."	self optionAt: 'constraint' put: aString</body><body package="Scriptaculous-Core">constraintHorizontal	self constraint: #horizontal</body><body package="Scriptaculous-Core">constraintVertical	self constraint: #vertical</body><body package="Scriptaculous-Core">containment: aStringOrArray	"Enables dragging and dropping between Sortables. Takes an array of elements or element-ids (of the containers)."	self optionAt: 'containment' put: aStringOrArray</body><body package="Scriptaculous-Core">delay: aDuration	self optionAt: 'delay' put: aDuration</body><body package="Scriptaculous-Core">dropOnEmpty: aBoolean	"If set to true, the Sortable container will be made into a Droppable, that can receive a Draggable (as according to the containment rules) as a child element when there are no more elements inside."	self optionAt: 'dropOnEmpty' put: aBoolean</body><body package="Scriptaculous-Core">format: aString	"The format that the id is computed from each item-id."		self optionAt: 'format' put: aString</body><body package="Scriptaculous-Core">ghosting: aBoolean	"If set to true, dragged elements of the Sortable will e cloned and appear as 'ghost', i.e. a representation of their original element, instead of directly dragging the original element."	self optionAt: 'ghosting' put: aBoolean</body><body package="Scriptaculous-Core">handle: aString	"Further restricts the selection of child elements to only encompass elements with the given CSS class (or, if you provide an array of strings, on any of the classes)."	self optionAt: 'handle' put: aString</body><body package="Scriptaculous-Core">hoverclass: aString	"Gives the created Droppables a hoverclass."	self optionAt: 'hoverclass' put: aString</body><body package="Scriptaculous-Core">only: aString	"Further restricts the selection of child elements to only encompass elements with the given CSS class (or, if you provide an array of strings, on any of the classes)."	self optionAt: 'only' put: aString</body><body package="Scriptaculous-Core">overlap: aSymbol	"Either Â#verticalÂ or Â#horizontalÂ. For floating sortables or horizontal lists, choose Â#horizontalÂ. Vertical lists should use Â#verticalÂ."	self optionAt: 'overlap' put: aSymbol</body><body package="Scriptaculous-Core">overlapHorizontal	self overlap: #horizontal</body><body package="Scriptaculous-Core">overlapVertical	self overlap: #vertical</body><body package="Scriptaculous-Core">scroll: aBoolean	self optionAt: 'scroll' put: aBoolean</body><body package="Scriptaculous-Core">scrollSensitivity: aNumber	self optionAt: 'scrollSensitivity' put: aNumber</body><body package="Scriptaculous-Core">scrollSpeed: aNumber	self optionAt: 'scrollSpeed' put: aNumber</body><body package="Scriptaculous-Core">tag: aString	"Sets the kind of tag (of the child elements of the container) that will be made sortable. For UL and OL containers, this is 'LI', you have to provide the tag kind for other sorts of child tags."	self optionAt: 'tag' put: aString</body><body package="Scriptaculous-Core">tree: aBoolean	self optionAt: 'tree' put: aBoolean</body><body package="Scriptaculous-Core">treeTag: aString	self optionAt: 'treeTag' put: aString</body></methods><methods><class-id>Scriptaculous.SUSortable</class-id> <category>actions</category><body package="Scriptaculous-Core">create	self method: 'create'</body><body package="Scriptaculous-Core">destroy	self method: 'destroy'</body><body package="Scriptaculous-Core">sequence	self method: 'sequence'</body><body package="Scriptaculous-Core">serialize	self method: 'serialize'</body><body package="Scriptaculous-Core">tree	self method: 'tree_sequence'</body></methods><methods><class-id>Scriptaculous.SUSortable</class-id> <category>private</category><body package="Scriptaculous-Core">defaultMethod	^ 'create'</body><body package="Scriptaculous-Core">defaultPrototype	^ 'Sortable'</body></methods><methods><class-id>Scriptaculous.SUAutocompleter</class-id> <category>options</category><body package="Scriptaculous-Core">autoSelect: aBoolean	self optionAt: 'autoSelect' put: aBoolean</body><body package="Scriptaculous-Core">frequency: aNumber	"Default is 0.4 seconds"	self optionAt: 'frequency' put: aNumber</body><body package="Scriptaculous-Core">indicator: aString	"When sending the Ajax request Autocompleter shows this element with Element.show. When the request has been completed it will be hidden with Element.hide."	self optionAt: 'indicator' put: aString</body><body package="Scriptaculous-Core">minChars: aNumber	"The minimum number of characters required to start the autocompletion. Default is 1"	self optionAt: 'minChars' put: aNumber</body><body package="Scriptaculous-Core">paramName: aString	self optionAt: 'paramName' put: aString</body><body package="Scriptaculous-Core">selectClass: aString	"The CSS class name of the elements within the list-items that should be used when copying the text to the text-input."	self optionAt: 'select' put: aString</body><body package="Scriptaculous-Core">tokens: anArray	"The token required to separate multiple autocompletion entries in one text-input."	self optionAt: 'tokens' put: anArray</body></methods><methods><class-id>Scriptaculous.SUAutocompleter</class-id> <category>private</category><body package="Scriptaculous-Core">defaultArguments	^ (Array with: self element) , super defaultArguments</body><body package="Scriptaculous-Core">defaultPrototype	^ 'Ajax.Autocompleter'</body></methods><methods><class-id>Scriptaculous.SUAutocompleter</class-id> <category>accessing</category><body package="Scriptaculous-Core">element	^ element</body><body package="Scriptaculous-Core">element: aString	element := aString</body></methods><methods><class-id>Scriptaculous.SUAutocompleter</class-id> <category>events</category><body package="Scriptaculous-Core">onHide: anObject	self optionAt: 'onHide' put: anObject asFunction</body><body package="Scriptaculous-Core">onSelected: anObject	"Hook for a custom function called after the element has been updated. This function is called after the built-in function that adds the list item text to the input field. The function receives two parameters, the autocompletion input field and the selected item."	self optionAt: 'afterUpdateElement' put: anObject asFunction</body><body package="Scriptaculous-Core">onShow: anObject	self optionAt: 'onShow' put: anObject asFunction</body><body package="Scriptaculous-Core">onUpdate: anObject	"Hook for a custom function called after the element has been updated. This function is called instead of the built-in function that adds the list item text to the input field. The function receives one parameter only, the selected item."	self optionAt: 'updateElement' put: anObject asFunction</body></methods><methods><class-id>Scriptaculous.SUAutocompleter</class-id> <category>actions</category><body package="Scriptaculous-Core">activate	"Activate the autocompletion list."	self call: 'activate'</body><body package="Scriptaculous-Core">hide	"Deactivate the autocompletion list."	self call: 'hide'</body><body package="Scriptaculous-Core">next	"Mark the next entry in the list."	self call: 'markNext'</body><body package="Scriptaculous-Core">previous	"Mark the previous entry in the list."	self call: 'markPrevious'</body><body package="Scriptaculous-Core">selectedIndex	"Answer the selected index in the list."	self access: 'index'</body></methods><methods><class-id>Scriptaculous.SUAutocompleter</class-id> <category>initialization</category><body package="Scriptaculous-Core">registerCallbackIn: aCallbackStore	self paramName: (aCallbackStore store: (JSAjaxCallback on: [ :v | self processWith: v ]))</body></methods><methods><class-id>Scriptaculous.SUInPlaceCollectionEditor</class-id> <category>private</category><body package="Scriptaculous-Core">defaultPrototype	^ 'Ajax.InPlaceCollectionEditor'</body></methods><methods><class-id>Scriptaculous.SUInPlaceCollectionEditor</class-id> <category>options</category><body package="Scriptaculous-Core">collection: anArray	self optionAt: 'collection' put: anArray</body></methods><methods><class-id>Javascript.JSScript</class-id> <category>*scriptaculous-core</category><body package="Scriptaculous-Core">scriptaculous	"Answer a factory that automatically adds to the receiving script."	^ self prototype</body></methods><methods><class-id>Core.Point</class-id> <category>*scriptaculous-core</category><body package="Scriptaculous-Core">javascriptOn: aStream	aStream nextPut: $[; javascript: self x; nextPut: $,; javascript: self y; nextPut: $]</body></methods><methods><class-id>Seaside.WARenderer</class-id> <category>*scriptaculous-core</category><body package="Scriptaculous-Core">scriptaculous	"Answer a script.aculo.us factory in the context of the receiver."	^ self prototype</body></methods><methods><class-id>Grease.GRPackage class</class-id> <category>*scriptaculous-core</category><body package="Scriptaculous-Core">scriptaculousCore	^ self new		name: 'Scriptaculous-Core';		description: 'script.aculo.us integration for Seaside. script.aculo.us provides you with easy-to-use, cross-browser user interface JavaScript libraries to make your web sites and web applications fly.';		addDependency: 'Prototype-Core';		url: #seasideUrl;		yourself</body></methods><methods><class-id>Prototype.PTAjax</class-id> <category>*scriptaculous-core-triggers</category><body package="Scriptaculous-Core">triggerAutocompleter: aBlock	"Triggers an autocompleter, not that you need to define a passanger for the list items to make this work."	aBlock fixCallbackTemps.	self		callback: [ :value | aBlock value: (self renderContext callbacks passengerAt: value) ]		value: (JSStream on: 'arguments[1].id')</body><body package="Scriptaculous-Core">triggerSliderCallback: aBlock	aBlock fixCallbackTemps.	self		callback: [ :value | aBlock value: value asNumber ]		value: (JSStream argument: 0)</body><body package="Scriptaculous-Core">triggerSortable: aString callback: aBlock	aBlock fixCallbackTemps.	self		callback: [ :value |			aBlock value: ((value substrings: ',') 				collect: [ :each | self renderContext callbacks passengerAt: each ]) ]		value: (SUSortable new			id: aString;			sequence)</body><body package="Scriptaculous-Core">triggerTree: aString callback: aBlock	aBlock fixCallbackTemps.	self		callback: [ :values |			aBlock value: (Array streamContents: [ :stream |				(values substrings: ',') do: [ :token |					| pair |					pair := (token subStrings: ':')						collect: [ :each | self renderContext callbacks passengerAt: each ifAbsent: [ nil ] ].					pair size = 2						ifTrue: [ stream nextPut: pair first -&gt; pair second ] ] ]) ]		value: (SUSortable new 			id: aString;			tree)</body></methods><methods><class-id>Prototype.PTFactory</class-id> <category>*scriptaculous-core-controls</category><body package="Scriptaculous-Core">autocompleter	^ self create: SUAutocompleter</body></methods><methods><class-id>Prototype.PTFactory</class-id> <category>*scriptaculous-core-creational-dragging</category><body package="Scriptaculous-Core">draggable	^ self create: SUDraggable</body><body package="Scriptaculous-Core">droppable	^ self create: SUDroppable</body></methods><methods><class-id>Prototype.PTFactory</class-id> <category>*scriptaculous-core-elements</category><body package="Scriptaculous-Core">effect	^ self create: SUEffect</body></methods><methods><class-id>Prototype.PTFactory</class-id> <category>*scriptaculous-core-controls</category><body package="Scriptaculous-Core">inPlaceCollectionEditor	^ self create: SUInPlaceCollectionEditor</body><body package="Scriptaculous-Core">inPlaceEditor	^ self create: SUInPlaceEditor</body><body package="Scriptaculous-Core">slider	^ self create: SUSlider</body></methods><methods><class-id>Prototype.PTFactory</class-id> <category>*scriptaculous-core-creational-dragging</category><body package="Scriptaculous-Core">sortable	^ self create: SUSortable</body></methods><methods><class-id>Prototype.PTFactory</class-id> <category>*scriptaculous-core-elements</category><body package="Scriptaculous-Core">sound	^ self create: SUSound</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>JSScript</name><environment>Javascript</environment><super>Javascript.JSObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>statements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Javascript-Core</category><attributes><package>Javascript-Core</package></attributes></class><class><name>PTPrototype</name><environment>Prototype</environment><super>Prototype.PTObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>options </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Prototype-Core</category><attributes><package>Prototype-Core</package></attributes></class><class><name>PTAjax</name><environment>Prototype</environment><super>Prototype.PTPrototype</super><private>false</private><indexed-type>none</indexed-type><inst-vars>url callback </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Prototype-Core-Ajax</category><attributes><package>Prototype-Core</package></attributes></class><class><name>WAFileLibrary</name><environment>Seaside</environment><super>Seaside.WAAbstractFileLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Libraries</category><attributes><package>Seaside-Core</package></attributes></class><class><name>PTNamed</name><environment>Prototype</environment><super>Prototype.PTPrototype</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id method arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Prototype-Core</category><attributes><package>Prototype-Core</package></attributes></class><class><name>Point</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>PTUpdater</name><environment>Prototype</environment><super>Prototype.PTAjax</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Prototype-Core-Ajax</category><attributes><package>Prototype-Core</package></attributes></class><class><name>PTFactory</name><environment>Prototype</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>context block rendererClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Prototype-Core</category><attributes><package>Prototype-Core</package></attributes></class><class><name>WARenderer</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>context lastId </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>Seaside-Core-Rendering</category><attributes><package>Seaside-Core</package></attributes></class></st-source>