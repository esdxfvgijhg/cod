<?xml version="1.0"?><st-source><!-- Name: Seaside-EmailComment: Contains convenience classes for sending of emails and preventing header injections.DbIdentifier: bear73DbTrace: 492597DbUsername: jkottDbVersion: 3.2.0 - pmm.26 1DevelopmentPrerequisites: #(#(#any 'Seaside-Namespace' '') #(#any 'Seaside-Core' '') #(#any 'Seaside-VisualWorks-Core' ''))Id: ed2428c6-8e0f-42b2-b3c7-77b19d3e6b87Namespace: SeasidePackageName: Seaside-EmailParcel: #('Seaside-Email')ParcelName: Seaside-EmailPrerequisiteParcels: #(#('Seaside-Namespace' '') #('Seaside-Core' '') #('Seaside-VisualWorks-Core' ''))PrintStringCache: (3.2.0 - pmm.26 1,jkott)Url: http://smalltalkhub.com/mc/Seaside/Seaside32/main/Seaside-Email-pmm.26.mczVersion: 3.2.0 - pmm.26 1Date: 3:31:28 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:31:28 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WAEmailConfiguration</name><environment>Seaside</environment><super>Seaside.WASystemConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Email-Configuration</category><attributes><package>Seaside-Email</package></attributes></class><class><name>WAEmailMessage</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>to from cc bcc subject headers body replyTo </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Email</category><attributes><package>Seaside-Email</package></attributes></class><class><name>WAMultiPartEmailMessage</name><environment>Seaside</environment><super>Seaside.WAEmailMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parts boundary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Email</category><attributes><package>Seaside-Email</package></attributes></class><class><name>WAEmailBody</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contentString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Email</category><attributes><package>Seaside-Email</package></attributes></class><class><name>WAHtmlEmailBody</name><environment>Seaside</environment><super>Seaside.WAEmailBody</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Email</category><attributes><package>Seaside-Email</package></attributes></class><class><name>WAStringEmailBody</name><environment>Seaside</environment><super>Seaside.WAEmailBody</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Email</category><attributes><package>Seaside-Email</package></attributes></class><methods><class-id>Seaside.WAEmailConfiguration</class-id> <category>description</category><body package="Seaside-Email">describeOn: config	(config string: #smtpServer)		group: #email;		label: 'SMTP Server';		comment: 'The hostname of the SMTP Server to use for sending Emails'.	(config integer: #smtpPort)		beAdvanced;		group: #email;		label: 'SMTP Port';		comment: 'The port of the SMTP Server to use for sending Emails.';		default: 25.	(config string: #smtpUsername)		beAdvanced;		group: #email;		label: 'SMTP Server user name';		comment: 'The user name used to log into the SMTP Server to use for sending Emails'.	(config string: #smtpPassword)		beAdvanced;		group: #email;		label: 'SMTP Server password';		comment: 'The password used to log into the SMTP Server to use for sending Emails'</body></methods><methods><class-id>Seaside.WAEmailMessage</class-id> <category>accessing</category><body package="Seaside-Email">bcc	^ bcc</body><body package="Seaside-Email">body	^ body</body><body package="Seaside-Email">body: anObject	body := anObject</body><body package="Seaside-Email">cc	^ cc</body><body package="Seaside-Email">from	^ from</body><body package="Seaside-Email">from: anObject	from := anObject</body><body package="Seaside-Email">headers	^ headers</body><body package="Seaside-Email">subject	^ subject</body><body package="Seaside-Email">subject: anObject	subject := anObject</body><body package="Seaside-Email">to	^ to</body></methods><methods><class-id>Seaside.WAEmailMessage</class-id> <category>adding</category><body package="Seaside-Email">addAllTo: aCollectionOfEmailAddress	aCollectionOfEmailAddress do: [ :each |		self addTo: each ]</body><body package="Seaside-Email">addBcc: anEmailAddress	^ self bcc add: anEmailAddress</body><body package="Seaside-Email">addCc: anEmailAddress	^ self cc add: anEmailAddress</body><body package="Seaside-Email">addTo: anEmailAddress	^ self to add: anEmailAddress</body><body package="Seaside-Email">headerAt: aKeyString put: aValueString	^ self headers at: aKeyString put: aValueString</body><body package="Seaside-Email">replyTo	^ replyTo</body><body package="Seaside-Email">replyTo: anEmailAddress	replyTo := anEmailAddress</body></methods><methods><class-id>Seaside.WAEmailMessage</class-id> <category>private</category><body package="Seaside-Email">plainMessage	^ String		streamContents: [ :stream | 			self renderAddress: self from withHeader: 'From: ' on: stream.			self to do: [ :each |				self renderAddress: each withHeader: 'To: ' on: stream ].			self cc do: [ :each |				self renderAddress: each withHeader: 'Cc: ' on: stream ].			self bcc do: [ :each |				self renderAddress: each withHeader: 'Bcc: ' on: stream ].			stream				nextPutAll: 'Subject: ';				nextPutAll: self subject;				nextPut: Character cr.			self replyTo isNil ifFalse: [				self renderAddress: self replyTo withHeader: 'Reply-To: ' on: stream ].			self headers keysAndValuesDo: [ :key :value | 				stream					nextPutAll: key greaseString;					nextPut: $:;					nextPut: Character space;					nextPutAll: value greaseString;					nextPut: Character cr ].			stream nextPut: Character cr.	"let body start"			self writeBodyOn: stream ]</body><body package="Seaside-Email">recipients	^ self to , self cc , self bcc collect: [ :each | each greaseString ]</body><body package="Seaside-Email">recipientsAddresses	^ Array streamContents: [ :stream |		self to do: [ :each |			stream nextPut: each address ].		self cc do: [ :each |			stream nextPut: each address ].		self bcc do: [ :each |			stream nextPut: each address ] ]</body><body package="Seaside-Email">renderAddress: anEmailAddress withHeader: aString on: aStream 	aStream		nextPutAll: aString;		nextPutAll: anEmailAddress greaseString;		nextPut: Character cr</body><body package="Seaside-Email">writeBodyOn: stream	self body isNil		ifFalse: [ stream nextPutAll: self body greaseString ]</body></methods><methods><class-id>Seaside.WAEmailMessage</class-id> <category>initialization</category><body package="Seaside-Email">initialize	super initialize.	to := OrderedCollection new.	cc := OrderedCollection new.	bcc := OrderedCollection new.	headers := Dictionary new.	self 		headerAt: 'Date'		put: (GRPrinter rfc822 print: DateAndTime now)</body></methods><methods><class-id>Seaside.WAEmailMessage</class-id> <category>actions</category><body package="Seaside-Email">send	GRPlatform current seasideDeliverEmailMessage: self</body></methods><methods><class-id>Seaside.WAEmailMessage</class-id> <category>convenience</category><body package="Seaside-Email">setStringBody: aString	self setStringBody: aString wrap: false</body><body package="Seaside-Email">setStringBody: aString wrap: aBoolean	self body: (aBoolean		ifTrue: [ WAStringEmailBody string: aString lineLength: 80 ]		ifFalse: [ WAStringEmailBody contentString: aString ])</body></methods><methods><class-id>Seaside.WAEmailMessage</class-id> <category>testing</category><body package="Seaside-Email">isMultipart	^ false</body></methods><methods><class-id>Seaside.WAEmailMessage class</class-id> <category>instance creation</category><body package="Seaside-Email">from: aFromEmailAddress to: aToEmailAddress subject: aString	^ self new		from: aFromEmailAddress;		addTo: aToEmailAddress;		subject: aString;		yourself</body><body package="Seaside-Email">from: aFromEmailAddress toAll: aCollectionOfEmailAddress subject: aString	^ self new		from: aFromEmailAddress;		addAllTo: aCollectionOfEmailAddress;		subject: aString;		yourself</body></methods><methods><class-id>Seaside.WAMultiPartEmailMessage</class-id> <category>testing</category><body package="Seaside-Email">isMultipart	^ true</body></methods><methods><class-id>Seaside.WAMultiPartEmailMessage</class-id> <category>writing</category><body package="Seaside-Email">writeBodyOn: stream	self parts asArray sort		do: [ :eachPart | 			self writeMiddleBoundaryOn: stream.			eachPart writeOn: stream ].	self writeEndBoundaryOn: stream</body><body package="Seaside-Email">writeEndBoundaryOn: stream	stream		nextPut: Character cr;		nextPutAll: '--';		nextPutAll: self boundary;		nextPutAll: '--';		nextPut: Character cr</body><body package="Seaside-Email">writeMiddleBoundaryOn: stream	stream		nextPut: Character cr;		nextPutAll: '--';		nextPutAll: self boundary;		nextPut: Character cr</body></methods><methods><class-id>Seaside.WAMultiPartEmailMessage</class-id> <category>initialization</category><body package="Seaside-Email">initialize	| mimeParameters |	super initialize.	boundary := self class newBoundary.	mimeParameters := Dictionary new.	mimeParameters at: 'boundary' put: boundary.	self headerAt: 'Content-Type' put: (WAMimeType main: 'multipart' sub: 'alternative' parameters: mimeParameters)</body></methods><methods><class-id>Seaside.WAMultiPartEmailMessage</class-id> <category>as yet unclassified</category><body package="Seaside-Email">addPart: aWAEmailBody	self parts add: aWAEmailBody</body><body package="Seaside-Email">boundary	^ boundary</body><body package="Seaside-Email">parts	^ parts ifNil: [ parts := Set new ]</body><body package="Seaside-Email">setHtmlBody: aBlock	"block should be in the form of a [:h | h render: 'hello world']"	self addPart: (WAHtmlEmailBody renderingBlock: aBlock)</body><body package="Seaside-Email">setStringBody: aString wrap: aBoolean	self		addPart:			(aBoolean				ifTrue: [ WAStringEmailBody string: aString lineLength: 80 ]				ifFalse: [ WAStringEmailBody contentString: aString ])</body></methods><methods><class-id>Seaside.WAMultiPartEmailMessage class</class-id> <category>as yet unclassified</category><body package="Seaside-Email">newBoundary	^ String		streamContents: [ :s | 			s nextPutAll: 'SeasideEmail'.			s nextPutAll: (10000 to: 999999) atRandom greaseString ]</body></methods><methods><class-id>Seaside.WAEmailBody</class-id> <category>accessing</category><body package="Seaside-Email">&lt;= anEmailBody	^ self sortOrder &lt;= anEmailBody sortOrder</body><body package="Seaside-Email">contentString	^ contentString</body><body package="Seaside-Email">contentString: aString	contentString := aString</body><body package="Seaside-Email">contentType	^ self subclassResponsibility</body><body package="Seaside-Email">greaseString	^ self contentString</body><body package="Seaside-Email">sortOrder	^ self subclassResponsibility</body><body package="Seaside-Email">writeOn: aStream	aStream		nextPutAll: 'Content-Type: ';		nextPutAll: self contentType greaseString ;		nextPut: Character cr;		nextPut: Character cr;		nextPutAll: self contentString;		nextPut: Character cr</body></methods><methods><class-id>Seaside.WAEmailBody</class-id> <category>comparing</category><body package="Seaside-Email">= anObject	"Answer whether the receiver and anObject represent the same object."	self == anObject		ifTrue: [ ^ true ].	self class = anObject class		ifFalse: [ ^ false ].	^ self contentType = anObject contentType</body><body package="Seaside-Email">hash	"Answer an integer value that is related to the identity of the receiver."	^ self contentType hash</body></methods><methods><class-id>Seaside.WAEmailBody</class-id> <category>testing</category><body package="Seaside-Email">isHtml	^ false</body><body package="Seaside-Email">isPlainText	^ false</body></methods><methods><class-id>Seaside.WAHtmlEmailBody</class-id> <category>testing</category><body package="Seaside-Email">isHtml	^ true</body></methods><methods><class-id>Seaside.WAHtmlEmailBody</class-id> <category>accessing</category><body package="Seaside-Email">contentType	^ WAMimeType textHtml</body><body package="Seaside-Email">sortOrder	^ 2</body></methods><methods><class-id>Seaside.WAHtmlEmailBody</class-id> <category>as yet unclassified</category><body package="Seaside-Email">renderBlock: anHtmlRenderingBlock	self		contentString:			(WAHtmlCanvas builder				fullDocument: true;				render: anHtmlRenderingBlock)</body></methods><methods><class-id>Seaside.WAHtmlEmailBody class</class-id> <category>as yet unclassified</category><body package="Seaside-Email">renderingBlock: anHtmlRenderingBlock	^ self new renderBlock: anHtmlRenderingBlock</body></methods><methods><class-id>Seaside.WAStringEmailBody</class-id> <category>accessing</category><body package="Seaside-Email">contentType	^ WAMimeType textPlain</body><body package="Seaside-Email">isPlainText	^ true</body><body package="Seaside-Email">sortOrder	^ 1</body></methods><methods><class-id>Seaside.WAStringEmailBody class</class-id> <category>private</category><body package="Seaside-Email">convertCrLfToCrIn: aString	^ aString		copyReplaceAll: (String with: Character cr with: Character lf)		with: (String with: Character cr)</body><body package="Seaside-Email">splitIntoLines: aString	^ Array streamContents: [ :stream |		| cr start |		cr := Character cr.		start := 1.		1 to: aString size do: [ :index |			(aString at: index) = cr ifTrue: [				stream nextPut: (aString copyFrom: start to: index - 1).				start := index + 1 ] ].			start &lt;= (aString size + 1) ifTrue: [ 				stream nextPut: (aString copyFrom: start to: aString size) ] ]</body><body package="Seaside-Email">splitString: aString intoChunksNoLongerThan: anInteger	^ Array streamContents: [ :stream |		self			splitString: aString			intoChunksNoLongerThan: anInteger			into: stream ]</body><body package="Seaside-Email">splitString: aString intoChunksNoLongerThan: anInteger into: aStream	| space lastSpaceIndex toScan |	space := Character space.	toScan := aString size min: anInteger + 1.	lastSpaceIndex := 0.	1 to: toScan do: [ :index |		(aString at: index) = space ifTrue: [			lastSpaceIndex := index ] ].		lastSpaceIndex = 0		ifTrue: [			lastSpaceIndex := aString size min: anInteger.			aStream nextPut: (aString copyFrom: 1 to: lastSpaceIndex) ]		ifFalse: [			aStream nextPut: (aString copyFrom: 1 to: lastSpaceIndex - 1) ].			lastSpaceIndex &lt; aString size ifTrue: [		self			splitString: (aString copyFrom: lastSpaceIndex + 1 to: aString size)			intoChunksNoLongerThan: anInteger			into: aStream ]</body></methods><methods><class-id>Seaside.WAStringEmailBody class</class-id> <category>instance creation</category><body package="Seaside-Email">contentString: aString	^ self new		contentString: (self convertCrLfToCrIn: aString);		yourself</body><body package="Seaside-Email">string: aString lineLength: anInteger	| string |	string := String streamContents: [ :stream |		| lines |		lines := self splitIntoLines: (self convertCrLfToCrIn: aString).		lines do: [ :each |			each size &lt;= anInteger				ifTrue: [ stream nextPutAll: each ]				ifFalse: [					(self splitString: each intoChunksNoLongerThan: anInteger)						do: [ :chunk | stream nextPutAll: chunk ]						separatedBy: [ stream nextPut: Character cr ] ] ]			separatedBy: [ stream nextPut: Character cr ] ].	^ self new		contentString: string;		yourself</body></methods><methods><class-id>Grease.GRPackage class</class-id> <category>*seaside-email</category><body package="Seaside-Email">seasideEmail	^ self new		name: 'Seaside-Email';		description: 'Contains convenience classes for sending of emails and preventing header injections.';		addDependency: 'Seaside-Core';		url: #seasideUrl;		yourself</body></methods><methods><class-id>Grease.GRPlatform</class-id> <category>*seaside-email</category><body package="Seaside-Email">seasideDeliverEmailMessage: aWAEmailMessage	self subclassResponsibility</body><body package="Seaside-Email">seasideHandlerPreferenceAt: aKey ifAbsent: aBlock			^ [ WACurrentRequestContext value application preferenceAt: aKey ] "in a Seaside context"		on: WARequestContextNotFound, WAAttributeNotFound 		do: [ :ex | aBlock value ] "not in a Seaside context, treat as absent"</body><body package="Seaside-Email">seasideSmtpPassword	"^ self seasideApplicationPreferenceAt: #smtpPassword ifAbsent: [?]"	self subclassResponsibility</body><body package="Seaside-Email">seasideSmtpPort	"^ self seasideApplicationPreferenceAt: #smtpPort ifAbsent: [?]"	self subclassResponsibility</body><body package="Seaside-Email">seasideSmtpServer		"^ self seasideApplicationPreferenceAt: #smtpServer ifAbsent: [?]"	self subclassResponsibility</body><body package="Seaside-Email">seasideSmtpUsername	"^ self seasideApplicationPreferenceAt: #smtpUsername ifAbsent: [?]"	self subclassResponsibility</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>WAObject</name><environment>Seaside</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core</category><attributes><package>Seaside-Core</package></attributes></class><class><name>GRPlatform</name><environment>Grease</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core</category><attributes><package>Grease-Core</package></attributes></class><class><name>WASystemConfiguration</name><environment>Seaside</environment><super>Seaside.WAConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>description </inst-vars><class-inst-vars>instance </class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class></st-source>