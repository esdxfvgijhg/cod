<?xml version="1.0"?><st-source><!-- Name: SUnitToo-SeasideNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: A framework on top of SUnitToo for unit testing of Seaside components/tasks in the same manner as they run on the web. TestCase is automatically configured with a preinitialized component and a UserAgent representing a browser accessing the component. During test #setUp the component gets registred with the Seaside server, and the agent hits the first page of the component. Therefore by the time the test method starts the first page is already available for inspection. A Page captures not just the response, but also its URL, the parsed DOM tree of the contents and a copy of the component (from the corresponding continuation) in the state that produced the page. XPath can be used to analyze and validate the parsed response contents (see Page>>find:).Note: The most convenient way to run SUnitToo test suites is using SUnitToo(ls) package.Let's build a simple test case for the WACounter demo. We need to create a subclass of SeasideSUnitToo.TestCase, e.g. WACounterTest and specify the class of the component to test.WACounterTest>>componentClass	^WACounterAnd here's an example test checking the function of the ++ link:testIncrease	self assert: self component count isZero.	"check current state of the component"	self clickLinkWithText: '++'.	"find a link with text '++' on current page and simulate a click, i.e. do a GET of the associated href"	self assert: self component count = 1.	"check current value of the counter"	self assert: (self find: '//h1/text()') first text = '1'	"find the heading element on current page and make sure the text corresponds to current counter value"The agent caches returned pages the same way a web browser would. It allows to look #back and #forward in the page history. It works the same way as web browser back/forward buttons, so #currentPage doesn't have to be the last one in the history. Here's another sample test exercising the continuation magic in the face of the back button.testClickBackClick	self assert: self component count = 0.	"initial state"	self clickLinkWithText: '++'.	"hit the increment link"	self assert: self component count = 1.	"check new state"	self back.	"click the back button"	self assert: (self find: '//h1/text()') first text = '0'.	"current page should display 0"	self assert: self component count = 0.	"the snapshot of the component when it generated current page should have count 0"	self clickLinkWithText: '++'.	"click incremement"	self assert: self component count = 1.	"check new state of the component"Since both the client and the server live in the same image the agent also provides access to all interesting participants of the test: the instantiated component, associated application and session and also the HttpClient instance used to hit the server. The server used for testing is the global 'SeasideServer class>>current'. Tested components get automatically registered with the server during test setUp (under the #componentTestingPath) and unregistred in test tearDown.Finally, since most non-trivial web applications will likely use form posts, there's also the HtmlForm. It provides a number of helper methods emulating various types of form input.testCheckBox	self newForm		check: 'id_a'; "set the check box value"		check: 'id_c'; "set the check box value"		click: 'Submit'. "click the submit button"testRadioButton	self newForm		radioCheck: 'id1_a'; "set the radio button value" "		click: 'Submit'.  "click the submit button"testDisplay	(self newForm)		fill: 'Bob Smith' in: 'name'; "fill in an input field"		fill: '16' in: 'age'; "fill in an input field"		click: 'Display'. "click the submit button"testSelection	self newForm		select: #( 'Dakar' 'Sydney' ) in: 'multiSelectionList'; "select in a multi-selection list"		click: 'Submit'. "click the submit button"The #click: also performs the form post, so it needs to be last in the sequence. If a form doesn't have a submit button, HtmlForm>>post can be called directly as well. It is also possible to emulate file upload. Upload posts automatically as well.testFileUpload	self newForm upload: 'test.txt' in: 'upload' source: 'Hello World!' readStream.DbIdentifier: bear73DbTrace: 492603DbUsername: jkottDbVersion: 3.2.0 - 1DevelopmentPrerequisites: #(#(#any 'SUnitToo' '') #(#any 'XPath' '') #(#any 'WebSupport' '') #(#any 'HTTP' '') #(#any 'Seaside-Core' '') #(#any 'Seaside-Component' '') #(#any 'Seaside-Session' '') #(#any 'Seaside-Tools-Core' '') #(#any 'Seaside-VisualWorks-Adaptors' ''))ExplicitPrerequisites: #()IgnoredPrerequisites: #('Seaside-Opentalk')Library: truePackageName: SUnitToo-SeasideParcel: #('SUnitToo-Seaside')PrerequisiteDescriptions: #(#(#name 'SUnitToo') #(#name 'XPath') #(#name 'WebSupport') #(#name 'HTTP' #componentType #package) #(#name 'Seaside-Core' #componentType #package) #(#name 'Seaside-Component' #componentType #package) #(#name 'Seaside-Session' #componentType #package) #(#name 'Seaside-Tools-Core' #componentType #package) #(#name 'Seaside-VisualWorks-Adaptors' #componentType #package))PrerequisiteParcels: #(#('SUnitToo' '') #('XPath' '') #('WebSupport' '') #('HTTP' '') #('Seaside-Core' '') #('Seaside-Component' '') #('Seaside-Session' '') #('Seaside-Tools-Core' '') #('Seaside-VisualWorks-Adaptors' ''))PrintStringCache: (3.2.0 - 1,jkott)Version: 3.2.0 - 1Date: 3:31:29 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:31:29 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>HtmlForm</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>url formData multipart agent </inst-vars><class-inst-vars></class-inst-vars><imports>			private SiouX.*			</imports><category>Seaside-Testing</category><attributes><package>SUnitToo-Seaside</package></attributes></class><comment><class-id>SUnit.HtmlForm</class-id><body>HtmlForm helps to construct form data set and submit it using Http "POST" method.This class if often used when testing a WAComponent and is created from a SeasideSUnitToo.TestCase by sending #newForm.Example:self newForm	fill: 'Bob' in: 'name';	select: #('Male') in: 'sex';	check: 'happy';	radioCheck: 'tall';	click: 'Save'.Instance Variables:	agent     &lt;UserAgent&gt;	agent knows the current HTML page contents and how to submit the form data set	formData	&lt;Collection&gt;	form data set created based on the current HTML page contents	multipart	&lt;Boolean&gt;	It the option is true the form data set will be submited as an Http multipart message. The default value is false.	url      &lt;String&gt;  url to post the form data set</body></comment><class><name>Page</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>response content url component session continuation context application </inst-vars><class-inst-vars></class-inst-vars><imports>			private SiouX.*			</imports><category>Seaside-Testing</category><attributes><package>SUnitToo-Seaside</package></attributes></class><comment><class-id>SUnit.Page</class-id><body>Page represents a web page contents. The page knows an instance of the component that created this page.Instance Variables:	component	&lt;WAComponent&gt; a component  that created this page contents	content	&lt;XML.Document &gt;	HTML document	response	&lt;HttpResponse&gt;	response	url	&lt;String&gt;	the page url</body></comment><class><name>WebTestCase</name><environment>SUnit</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>agent </inst-vars><class-inst-vars></class-inst-vars><imports>			private SiouX.SeasideServer			</imports><category>Seaside-Testing</category><attributes><package>SUnitToo-Seaside</package></attributes></class><comment><class-id>SUnit.WebTestCase</class-id><body>TestCase is an abstract class that you subclass from to create unit tests about a Seaside WAComponent subclass. Implement #componentClass to return the class you want to test, then create SUnit tests as per normal.The component will be downloaded during #setUp and provided as #page. The WAComponent will also be matched up from the session as #component.You can navigate through actions on the page with #clickLinkWithText: or create a HtmlForm to post back fields with #newForm. See HtmlForm for details on how to fill out a form.You can act like a user and hit the back button by sending #back.Instance Variables	agent	&lt;UserAgent&gt; represents the client browser hitting the tested component</body></comment><class><name>UserAgent</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>history application future client </inst-vars><class-inst-vars></class-inst-vars><imports>			private SiouX.*			</imports><category>Seaside-Testing</category><attributes><package>SUnitToo-Seaside</package></attributes></class><comment><class-id>SUnit.UserAgent</class-id><body>UserAgent helps to browse pages, post form data and upload files.Instance Variables:	history	&lt;OrderedCollection&gt; collection of pages	application	&lt;WAApplication&gt; Seaside application with the test component	future	&lt;OrderedCollection&gt; collection of pages	component	&lt;WAComponent&gt; test component	client	&lt;HttpClient&gt; used to access the server</body></comment><methods><class-id>SUnit.HtmlForm</class-id> <category>API</category><body package="SUnitToo-Seaside">check: id	"The method is used to set value for check boxes."	self checkNamed: (self nameForId: id)</body><body package="SUnitToo-Seaside">checkNamed: name	"Adds the check box to the form data"	formData add: name -&gt; name</body><body package="SUnitToo-Seaside">click: aButtonName	"The method is used to post forms and has to be the last one in the sequence"	self clickNamed: (self submitNameForValue: aButtonName).	self post</body><body package="SUnitToo-Seaside">clickNamed: aButtonName	"Adds the submit button to the form data"	formData add: aButtonName -&gt; aButtonName</body><body package="SUnitToo-Seaside">fill: value in: id	"The method is used to fill in an input fields"	self fill: value named: (self nameForId: id).</body><body package="SUnitToo-Seaside">fill: value named: name	"Adds the input field value to the form data"	formData add: name -&gt; value</body><body package="SUnitToo-Seaside">post	"The method posts the form"	agent post: url formData: formData multipart: multipart</body><body package="SUnitToo-Seaside">radioCheck: id	"The method is used to set the radio button value "	self fill: (self radioValueForId: id) in: id</body><body package="SUnitToo-Seaside">select: collection in: id	"The method is used to add selection from the multi-selection list to the form "	self select: collection named: (self nameForId: id)</body><body package="SUnitToo-Seaside">select: collection named: name	"The method is used to add selection from the multi-selection list to the form "	| options |	options := collection collect: [:each | self optionValueForText: each inNamed: name].	options do: [:each | self fill: each named: name]</body><body package="SUnitToo-Seaside">upload: filenameString in: id source: aStream 	"The method uploads files defined in a form as:	html fileUpload id: 'fileUpload'; callback: [ :f | ...].	html submitButton value: 'Submit'. "	self upload: filenameString named: (self nameForId: id) source: aStream</body><body package="SUnitToo-Seaside">upload: filenameString named: name source: aStream 	"The method uploads files "	agent 		uploadTo: url 		file: filenameString 		name: name		source: aStream		formData: formData</body></methods><methods><class-id>SUnit.HtmlForm</class-id> <category>accessing</category><body package="SUnitToo-Seaside">agent	^agent</body><body package="SUnitToo-Seaside">agent: anObject	agent := anObject.	url := self findUrl.	multipart := self findIsMultipart.	self addHiddenFields</body><body package="SUnitToo-Seaside">formData	^formData</body><body package="SUnitToo-Seaside">multipart	^multipart</body><body package="SUnitToo-Seaside">multipart: anObject	multipart := anObject</body><body package="SUnitToo-Seaside">url	^url</body><body package="SUnitToo-Seaside">url: anObject	url := anObject</body></methods><methods><class-id>SUnit.HtmlForm</class-id> <category>private</category><body package="SUnitToo-Seaside">addHiddenFields	(self find: '//input[@type="hidden"]') do: [:each | self fill: (each valueOfAttribute: 'value' ifAbsent: ['']) named: (each valueOfAttribute: 'name' ifAbsent: [''])]</body><body package="SUnitToo-Seaside">elementForId: id	^(self find: '//*[@id]') detect: [:each | (each valueOfAttribute: 'id' ifAbsent: [nil])  = id]</body><body package="SUnitToo-Seaside">find: xpathString	^agent currentPage find: xpathString</body><body package="SUnitToo-Seaside">findIsMultipart	| attributes |	attributes := self find: '//form/@enctype'.	attributes isEmpty ifTrue: [^false].	^attributes first value = 'multipart/form-data'</body><body package="SUnitToo-Seaside">findUrl	^SiouX.SeasideServer siteURL, (self find: '//form/@action') first value</body><body package="SUnitToo-Seaside">nameForId: id	^(self elementForId: id) valueOfAttribute: 'name' ifAbsent: [nil]</body><body package="SUnitToo-Seaside">optionValueForText: text inNamed: name	^(self find: '//select[@name="', name, '"]/descendant::option[text()="', text, '"]/@value') first value</body><body package="SUnitToo-Seaside">radioValueForId: id	^(self find: '//input[@type="radio" and @id="', id, '"]/@value') first value</body><body package="SUnitToo-Seaside">submitNameForValue: value	^(self find: '//input[@type="submit" and @value="', value, '"]/@name') first value</body></methods><methods><class-id>SUnit.HtmlForm</class-id> <category>initialize-release</category><body package="SUnitToo-Seaside">initialize 	formData := OrderedCollection new.	multipart := false</body></methods><methods><class-id>SUnit.HtmlForm class</class-id> <category>instance creation</category><body package="SUnitToo-Seaside">agent: anUserAgent	^self new		agent: anUserAgent;		yourself</body><body package="SUnitToo-Seaside">new	^super new initialize</body><body package="SUnitToo-Seaside">on: aURL	^self new		url: aURL;		yourself</body></methods><methods><class-id>SUnit.Page</class-id> <category>accessing</category><body package="SUnitToo-Seaside">application	^application</body><body package="SUnitToo-Seaside">component	^component</body><body package="SUnitToo-Seaside">content	^content</body><body package="SUnitToo-Seaside">context	^context</body><body package="SUnitToo-Seaside">continuation	^continuation</body><body package="SUnitToo-Seaside">response	^response</body><body package="SUnitToo-Seaside">session	^session</body><body package="SUnitToo-Seaside">session: aSession	session := aSession</body><body package="SUnitToo-Seaside">url	^url</body><body package="SUnitToo-Seaside">url: anObject	url := anObject</body></methods><methods><class-id>SUnit.Page</class-id> <category>finding</category><body package="SUnitToo-Seaside">find: xpathString		^self find: xpathString in: content root</body><body package="SUnitToo-Seaside">find: xpathString in: anElement	| xpath |	xpath := XML.XPathParser new parse: xpathString as: #locationPath.	^(xpath xpathValueFor: anElement variables: nil) sortedNodes</body></methods><methods><class-id>SUnit.Page</class-id> <category>private</category><body package="SUnitToo-Seaside">extractAnchorContinuation	| href match continuationKey |	href := nil.	match := '*', session actionField ,'=*'.	(self find: '//a') anySatisfy: [:each |		href := (each valueOfAttribute: 'href' ifAbsent: [nil]) ifNotNil: [:hrefUrl | SeasideServer siteURL, hrefUrl].		href notNil and: [href protocol = 'http' and: [href query notNil and: [match match: href query]]]].	href ifNil: [^false].	href query ifNil: [^false].	continuationKey := href query readStream skipThroughAll: session actionField; next; upTo: $&amp;.	continuation := session continuations at: continuationKey ifAbsent: [nil].	^continuation notNil</body><body package="SUnitToo-Seaside">extractAnchorSession	| href match sessionKey |	href := nil.	match := '*', application keyField ,'=*'.	(self find: '//a') anySatisfy: [:each |		href := (each valueOfAttribute: 'href' ifAbsent: [nil]) ifNotNil: [:hrefUrl | SeasideServer siteURL, hrefUrl].		href notNil and: [href protocol = 'http' and: [href query notNil and: [match match: href query]]]].	href ifNil: [^false].	href query ifNil: [^false].	sessionKey := href query readStream skipThroughAll: application keyField; next; upTo: $&amp;.	session := application cache at: sessionKey ifAbsent: [nil].	^session notNil</body><body package="SUnitToo-Seaside">extractComponent	| componentClass |	context := continuation renderContext.	componentClass := (application preferenceAt: #rootClass) pharoValue.	component := continuation states detect: [:each | each class = componentClass] ifNone: [nil]</body><body package="SUnitToo-Seaside">extractCookieSession	response setCookie ifNotNil: [:header |		header value do: [:cookie |			cookie value key = application keyCookieName ifTrue:				[session := application cache at: cookie value value.				^true]]].	^false</body><body package="SUnitToo-Seaside">extractFormContinuation	| continuationKey |	continuationKey := self find: '//input[@class="hidden" and @type="hidden" and @name="', session actionField, '"]/@value[1]'.	continuationKey notEmpty		ifTrue: [continuation := session continuations at: continuationKey first value]		ifFalse:			[ | href |			href := self find: '//form/@action'.			href notEmpty ifTrue:				[href := SeasideServer siteURL, href first value.				(href notNil and: [href protocol = 'http' and: [href query notNil and: [('*', session actionField, '*') match: href query]]]) ifTrue:					[continuationKey := href query readStream skipThroughAll: session actionField; next; upTo: $&amp;.					continuation := session continuations at: continuationKey ifAbsent:[nil]]]].	^continuation notNil</body><body package="SUnitToo-Seaside">extractFormSession	| sessionKey |	sessionKey := self find: '//input[@class="hidden" and @type="hidden" and @name="', application keyField, '"]/@value'.	sessionKey notEmpty		ifTrue: [session := application cache at: sessionKey first value]		ifFalse:			[ | href |			href := self find: '//form/@action'.			href notEmpty ifTrue:				[href := SeasideServer siteURL, href first value.				(href notNil and: [href protocol = 'http' and: [href query notNil and: [('*', application keyField, '*') match: href query]]]) ifTrue:					[sessionKey := href query readStream skipThroughAll: application keyField; next; upTo: $&amp;.					session := application cache at: sessionKey ifAbsent: [nil]]]].	^session notNil</body><body package="SUnitToo-Seaside">htmlEntities	^(Dictionary new)		add: 'Otilde' -&gt; 213;		add: 'Iacute' -&gt; 205;		add: 'Egrave' -&gt; 200;		add: 'iexcl' -&gt; 161;		add: 'Atilde' -&gt; 195;		add: 'copy' -&gt; 169;		add: 'frac12' -&gt; 189;		add: 'ccedil' -&gt; 231;		add: 'Icirc' -&gt; 206;		add: 'ntilde' -&gt; 241;		add: 'deg' -&gt; 176;		add: 'szlig' -&gt; 223;		add: 'eth' -&gt; 240;		add: 'oacute' -&gt; 243;		add: 'Uacute' -&gt; 218;		add: 'raquo' -&gt; 187;		add: 'iquest' -&gt; 191;		add: 'shy' -&gt; 173;		add: 'iuml' -&gt; 239;		add: 'Ouml' -&gt; 214;		add: 'frac14' -&gt; 188;		add: 'ocirc' -&gt; 244;		add: 'Ucirc' -&gt; 219;		add: 'aacute' -&gt; 225;		add: 'oslash' -&gt; 248;		add: 'quot' -&gt; 34;		add: 'Scaron' -&gt; 352;		add: 'Dagger' -&gt; 8225;		add: 'uuml' -&gt; 252;		add: 'amp' -&gt; 38;		add: 'ndash' -&gt; 8211;		add: 'Auml' -&gt; 196;		add: 'acirc' -&gt; 226;		add: 'igrave' -&gt; 236;		add: 'Ograve' -&gt; 210;		add: 'cedil' -&gt; 184;		add: 'yen' -&gt; 165;		add: 'aring' -&gt; 229;		add: 'lsquo' -&gt; 8216;		add: 'yacute' -&gt; 253;		add: 'ugrave' -&gt; 249;		add: 'Eacute' -&gt; 201;		add: 'Agrave' -&gt; 192;		add: 'lsaquo' -&gt; 8249;		add: 'sup1' -&gt; 185;		add: 'reg' -&gt; 174;		add: 'oelig' -&gt; 339;		add: 'Yuml' -&gt; 376;		add: 'lt' -&gt; 60;		add: 'plusmn' -&gt; 177;		add: 'Ecirc' -&gt; 202;		add: 'euro' -&gt; 8364;		add: 'rdquo' -&gt; 8221;		add: 'sup2' -&gt; 178;		add: 'acute' -&gt; 180;		add: 'uml' -&gt; 168;		add: 'thinsp' -&gt; 8201;		add: 'sup3' -&gt; 179;		add: 'aelig' -&gt; 230;		add: 'euml' -&gt; 235;		add: 'not' -&gt; 172;		add: 'otilde' -&gt; 245;		add: 'para' -&gt; 182;		add: 'macr' -&gt; 175;		add: 'sect' -&gt; 167;		add: 'Ccedil' -&gt; 199;		add: 'pound' -&gt; 163;		add: 'Ntilde' -&gt; 209;		add: 'cent' -&gt; 162;		add: 'nbsp' -&gt; 160;		add: 'iacute' -&gt; 237;		add: 'egrave' -&gt; 232;		add: 'laquo' -&gt; 171;		add: 'Oacute' -&gt; 211;		add: 'zwj' -&gt; 8205;		add: 'atilde' -&gt; 227;		add: 'zwnj' -&gt; 8204;		add: 'Iuml' -&gt; 207;		add: 'times' -&gt; 215;		add: 'icirc' -&gt; 238;		add: 'lrm' -&gt; 8206;		add: 'Ocirc' -&gt; 212;		add: 'sbquo' -&gt; 8218;		add: 'bdquo' -&gt; 8222;		add: 'uacute' -&gt; 250;		add: 'Aacute' -&gt; 193;		add: 'Oslash' -&gt; 216;		add: 'ordf' -&gt; 170;		add: 'ouml' -&gt; 246;		add: 'Uuml' -&gt; 220;		add: 'THORN' -&gt; 222;		add: 'ucirc' -&gt; 251;		add: 'Acirc' -&gt; 194;		add: 'dagger' -&gt; 8224;		add: 'scaron' -&gt; 353;		add: 'Igrave' -&gt; 204;		add: 'curren' -&gt; 164;		add: 'micro' -&gt; 181;		add: 'OElig' -&gt; 338;		add: 'auml' -&gt; 228;		add: 'rlm' -&gt; 8207;		add: 'Aring' -&gt; 197;		add: 'divide' -&gt; 247;		add: 'mdash' -&gt; 8212;		add: 'Yacute' -&gt; 221;		add: 'ograve' -&gt; 242;		add: 'Ugrave' -&gt; 217;		add: 'permil' -&gt; 8240;		add: 'AElig' -&gt; 198;		add: 'emsp' -&gt; 8195;		add: 'gt' -&gt; 62;		add: 'tilde' -&gt; 732;		add: 'rsquo' -&gt; 8217;		add: 'middot' -&gt; 183;		add: 'ldquo' -&gt; 8220;		add: 'circ' -&gt; 710;		add: 'thorn' -&gt; 254;		add: 'agrave' -&gt; 224;		add: 'eacute' -&gt; 233;		add: 'rsaquo' -&gt; 8250;		add: 'brvbar' -&gt; 166;		add: 'ETH' -&gt; 208;		add: 'yuml' -&gt; 255;		add: 'Euml' -&gt; 203;		add: 'ensp' -&gt; 8194;		add: 'frac34' -&gt; 190;		add: 'ecirc' -&gt; 234;		add: 'ordm' -&gt; 186;		yourself</body><body package="SUnitToo-Seaside">parseContentsFrom: anHttpResponse application: anApplication	application := anApplication.	response := anHttpResponse.	response contentType = 'text/html' ifFalse: [^self].	content := (self xmlParserOn: anHttpResponse body source reset) scanDocument.	((self extractCookieSession or: [self extractFormSession or: [self extractAnchorSession or: [session notNil]]])		and: [self extractFormContinuation or: [self extractAnchorContinuation]])			ifTrue: [self extractComponent]</body><body package="SUnitToo-Seaside">xmlParserOn: stream	| parser |	parser := XML.XMLParser on: stream.	parser entityResolver: (XML.PluggableEntityResolver withBlock: [XML.ResolveEmptyResource]).	parser validate: false.	self htmlEntities keysAndValuesDo: [:key :value |		parser dtd generalEntityAt: key put: (XML.GeneralEntity new name: key; text: (String with: (Character value: value))) from: parser].	^parser</body></methods><methods><class-id>SUnit.Page</class-id> <category>printing</category><body package="SUnitToo-Seaside">printOn: aStream	aStream nextPutAll: url greaseString</body></methods><methods><class-id>SUnit.WebTestCase</class-id> <category>running</category><body package="SUnitToo-Seaside">componentClass	"Implement the method to return the class you want to test"	^self subclassResponsibility</body><body package="SUnitToo-Seaside">componentTestingPath	^'currently-being-tested/', self componentClass name</body><body package="SUnitToo-Seaside">setUp	self setupServer.	agent := UserAgent new.	self setupComponent.	self setupFirstPage</body><body package="SUnitToo-Seaside">setupComponent	agent application: (Seaside.WAAdmin register: self componentClass asApplicationAt: self componentTestingPath)</body><body package="SUnitToo-Seaside">setupFirstPage	agent gotoFirstPage</body><body package="SUnitToo-Seaside">setupServer	SeasideServer start</body><body package="SUnitToo-Seaside">tearDown	self tearDownComponent</body><body package="SUnitToo-Seaside">tearDownComponent	agent application parent unregister: agent application.	agent close</body></methods><methods><class-id>SUnit.WebTestCase</class-id> <category>API</category><body package="SUnitToo-Seaside">back	"Sending this message will act like hitting a browser back button "	agent back</body><body package="SUnitToo-Seaside">clickLinkWithText: text	"The method navigates through actions on the page"	| anchor |	anchor := (self find: '//a[@href]') detect: [:each | each characterData = text].	agent goto: (anchor valueOfAttribute: 'href' ifAbsent: [nil])</body><body package="SUnitToo-Seaside">clickMapWithId: id at: point	"The method navigates through image map on the page"	| anchor |	anchor := (self find: '//a[@href]') detect: [:each | (each valueOfAttribute: 'id' ifAbsent: [nil]) ifNotNil: [:attr | attr  = id]].	agent goto: (anchor valueOfAttribute: 'href' ifAbsent: [nil]), '?', point x printString, ',', point y printString</body><body package="SUnitToo-Seaside">find: xpath	"The method is using XPath to search the parsed response contents"	^agent currentPage find: xpath</body><body package="SUnitToo-Seaside">newForm	"The method creates a HtmlForm to post back fields."	^HtmlForm agent: agent</body></methods><methods><class-id>SUnit.WebTestCase</class-id> <category>accessing</category><body package="SUnitToo-Seaside">component"Return the component being tested."	^agent component</body><body package="SUnitToo-Seaside">frontMostComponent	self component visiblePresentersDo: [:each | each isDecoration ifFalse: [^each]].</body><body package="SUnitToo-Seaside">page"Return the current page, current in the sense of where in the page history is the agent currently positioned."	^agent currentPage</body></methods><methods><class-id>SUnit.UserAgent</class-id> <category>accessing</category><body package="SUnitToo-Seaside">application	^application</body><body package="SUnitToo-Seaside">application: anObject	application := anObject</body><body package="SUnitToo-Seaside">client	^client</body><body package="SUnitToo-Seaside">client: anObject	client := anObject</body><body package="SUnitToo-Seaside">component	^self currentPage component</body><body package="SUnitToo-Seaside">currentPage	^history last</body><body package="SUnitToo-Seaside">session	^application onlySession</body></methods><methods><class-id>SUnit.UserAgent</class-id> <category>API</category><body package="SUnitToo-Seaside">back	"Moves to the previous page  "	future add: history removeLast</body><body package="SUnitToo-Seaside">forward	"Moves to the next page  "	history add: future removeLast</body><body package="SUnitToo-Seaside">goto: url	"Navigates to the provided url  "	(self newPageFor: SeasideServer siteURL, url)		parseContentsFrom: ( client get: SeasideServer siteURL, url) 		application: application.	self clearFuture.</body><body package="SUnitToo-Seaside">gotoFirstPage	"Navigates to the first page."	self goto: application basicUrl pathString</body><body package="SUnitToo-Seaside">newPageFor: url	"Creates a new page for the url"	| page |	page := Page new.	page url: url.	history notEmpty ifTrue: [page session: history last session].	^history add: page</body><body package="SUnitToo-Seaside">post: url formData: aCollection multipart: aBoolean	"Posts the form data and parses the response contents "	| response |	response := self 			post: url 			requestDo: [ :requestx |				aBoolean ifTrue: [ requestx beMultipart ].				requestx formData: aCollection ].	(self newPageFor: url)		parseContentsFrom: response		application: application.</body><body package="SUnitToo-Seaside">post: url requestDo: aBlock	"Posts an http request"	|  aRequest  |	aRequest := client requestClass post: url.	aBlock value: aRequest.	^[ client executeRequest: aRequest ] 		on: Net.HttpMovedError 		do: [ :ex | 			ex return: (client get:  SeasideServer siteURL, ex parameter location)  ].</body><body package="SUnitToo-Seaside">refresh	"Refreshes the page"	history last get: application.	self clearFuture.	^history last</body><body package="SUnitToo-Seaside">uploadTo: url file: filenameString name: aString source: aStream formData: aCollection	"Posts an http request to upload a file and parses the response contents"	| response |	response := self 			post: url 			requestDo: [ :requestx |  						requestx 							beMultipart; 							formData: aCollection;							addFormKey: aString filename: filenameString source: aStream ].	(self newPageFor: url)		parseContentsFrom: response		application: application.</body></methods><methods><class-id>SUnit.UserAgent</class-id> <category>initialize-release</category><body package="SUnitToo-Seaside">clearFuture	future := OrderedCollection new</body><body package="SUnitToo-Seaside">close	client ifNotNil: [ client close ]</body><body package="SUnitToo-Seaside">initialize	history := OrderedCollection new.	client := Net.HttpClient new.	self clearFuture</body></methods><methods><class-id>SUnit.UserAgent class</class-id> <category>instance creation</category><body package="SUnitToo-Seaside">new	^super new initialize</body></methods><methods><class-id>Seaside.WASession</class-id> <category>accessing</category><body package="SUnitToo-Seaside">continuations	^continuations</body></methods><methods><class-id>Seaside.WASnapshot</class-id> <category>accessing</category><body package="SUnitToo-Seaside">detect: aBlock ifNone: noneBlock	^objects detect: aBlock ifNone: noneBlock</body></methods><methods><class-id>Seaside.WAApplication</class-id> <category>accessing</category><body package="SUnitToo-Seaside">keyField	^ '_s'</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>WASession</name><environment>Seaside</environment><super>Seaside.WARequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>continuations properties documentHandlers key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Session</category><attributes><package>Seaside-Session</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>WASnapshot</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objects </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Backtracking</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAApplication</name><environment>Seaside</environment><super>Seaside.WARegistry</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Session</category><attributes><package>Seaside-Session</package></attributes></class></st-source>