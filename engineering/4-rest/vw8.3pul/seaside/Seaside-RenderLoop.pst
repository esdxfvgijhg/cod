<?xml version="1.0"?><st-source><!-- Name: Seaside-RenderLoopComment: Defines the low-level rendering and callback processing functionality.DbIdentifier: bear73DbTrace: 492581DbUsername: jkottDbVersion: 3.2.0 - pmm.99 1DevelopmentPrerequisites: #(#(#any 'Seaside-Namespace' '') #(#any 'Seaside-Session' '') #(#any 'Seaside-Component' ''))Id: 6cdd138f-4bb9-4657-9869-905e7952486bNamespace: SeasidePackageName: Seaside-RenderLoopParcel: #('Seaside-RenderLoop')ParcelName: Seaside-RenderLoopPrerequisiteParcels: #(#('Seaside-Namespace' '') #('Seaside-Session' '') #('Seaside-Component' ''))PrintStringCache: (3.2.0 - pmm.99 1,jkott)Url: http://smalltalkhub.com/mc/Seaside/Seaside32/main/Seaside-RenderLoop-pmm.99.mczVersion: 3.2.0 - pmm.99 1Date: 3:31:27 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:31:27 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WAMissingResponseError</name><environment>Seaside</environment><super>Seaside.WAError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-RenderLoop</category><attributes><package>Seaside-RenderLoop</package></attributes></class><class><name>WARenderLoopContinuation</name><environment>Seaside</environment><super>Seaside.WASessionContinuation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-RenderLoop</category><attributes><package>Seaside-RenderLoop</package></attributes></class><class><name>WAActionPhaseContinuation</name><environment>Seaside</environment><super>Seaside.WARenderLoopContinuation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>renderContext </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-RenderLoop</category><attributes><package>Seaside-RenderLoop</package></attributes></class><class><name>WACallbackProcessingActionContinuation</name><environment>Seaside</environment><super>Seaside.WAActionPhaseContinuation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>jumpTo </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-RenderLoop</category><attributes><package>Seaside-RenderLoop</package></attributes></class><class><name>WARenderPhaseContinuation</name><environment>Seaside</environment><super>Seaside.WARenderLoopContinuation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-RenderLoop</category><attributes><package>Seaside-RenderLoop</package></attributes></class><class><name>WAFlushingRenderPhaseContinuation</name><environment>Seaside</environment><super>Seaside.WARenderPhaseContinuation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-RenderLoop</category><attributes><package>Seaside-RenderLoop</package></attributes></class><class><name>WARenderLoopConfiguration</name><environment>Seaside</environment><super>Seaside.WASystemConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-RenderLoop</category><attributes><package>Seaside-RenderLoop</package></attributes></class><comment><class-id>Seaside.WARenderLoopConfiguration</class-id><body>WARenderLoopConfiguration defines attributes required by the Render Loop classes (see the Seaside-Core-RenderLoop category). Any application using these classes should include this configuration (this is done by default for new applications).See #addAttributes: for details on provided attributes.</body></comment><class><name>WAInitialRenderLoopContinuation</name><environment>Seaside</environment><super>Seaside.WAActionPhaseContinuation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-RenderLoop</category><attributes><package>Seaside-RenderLoop</package></attributes></class><comment><class-id>Seaside.WAInitialRenderLoopContinuation</class-id><body>I'm the initial continuation of a render loop. I just render the initial page. Subclasses may want to override #shouldRedirect and answer true so that a redirect happens before displaying the first page.</body></comment><class><name>WAPluggableActionContinuation</name><environment>Seaside</environment><super>Seaside.WAActionPhaseContinuation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>action </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-RenderLoop</category><attributes><package>Seaside-RenderLoop</package></attributes></class><comment><class-id>Seaside.WAPluggableActionContinuation</class-id><body>This continuation executes an action (any class that implements #value or #value:). If possible, the renderContext is passed in as an argument. When the action is complete, if a response hasn't been returned, control is passed to a render continuation.'Instance Variables:	action	&lt;BlockClosure | BlockContext | GRDelayedSend | MessageSend | WAContinuation | WAPartialContinuation&gt;</body></comment><class><name>WACurrentCallbackProcessingActionContinuation</name><environment>Seaside</environment><super>Seaside.WADynamicVariable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-RenderLoop</category><attributes><package>Seaside-RenderLoop</package></attributes></class><methods><class-id>Seaside.WAMissingResponseError</class-id> <category>accessing</category><body package="Seaside-RenderLoop">seasidePossibleCauses	^ #(		'A Component attempted to use #call: or a similar method while rendering. Calling and answering can only be done in a callback.'	)</body></methods><methods><class-id>Seaside.WARenderLoopContinuation</class-id> <category>accessing</category><body package="Seaside-RenderLoop">presenter	"Answer the root presenter instance for the current session."	^ self session presenter</body></methods><methods><class-id>Seaside.WARenderLoopContinuation</class-id> <category>updating</category><body package="Seaside-RenderLoop">toPresenterSendRoot: anHtmlRoot	(WAVisiblePresenterGuide client:		(WAUpdateRootVisitor root: anHtmlRoot))		start: self presenter</body><body package="Seaside-RenderLoop">updateRoot: anHtmlRoot	| charSet |	charSet := self application contentType charSet.	charSet isNil ifFalse: [		anHtmlRoot meta charset: charSet ].	anHtmlRoot beHtml5.	anHtmlRoot title: 'Seaside'.	self application libraries 		do: [ :each | each default updateRoot: anHtmlRoot ].	self session updateRoot: anHtmlRoot</body><body package="Seaside-RenderLoop">updateStates: aSnapshot	super updateStates: aSnapshot.	(WAAllPresenterGuide client:		(WAUpdateStatesVisitor snapshot: aSnapshot))		start: self presenter</body><body package="Seaside-RenderLoop">updateUrl: aUrl	super updateUrl: aUrl.	(WAVisiblePresenterGuide client: (WAUpdateUrlVisitor url: aUrl))		start: self presenter</body></methods><methods><class-id>Seaside.WARenderLoopContinuation</class-id> <category>testing</category><body package="Seaside-RenderLoop">isActionContinuation	^ self class isActionContinuation</body><body package="Seaside-RenderLoop">isRenderContinuation	^ self class isRenderContinuation</body></methods><methods><class-id>Seaside.WARenderLoopContinuation</class-id> <category>private</category><body package="Seaside-RenderLoop">actionPhaseContinuationClass	^ (self application preferenceAt: #actionPhaseContinuationClass) value</body><body package="Seaside-RenderLoop">createActionContinuation	"Answer a new action phase continuation."	^ self actionPhaseContinuationClass snapshot: self states</body><body package="Seaside-RenderLoop">createActionContinuationWithContext: aRenderContext	"Answer a new action phase continuation."	^ self actionPhaseContinuationClass snapshot: self states renderContext: aRenderContext</body><body package="Seaside-RenderLoop">createRenderContinuation	"Answer a new render phase continuation."	^ (self application preferenceAt: #renderPhaseContinuationClass) value new</body><body package="Seaside-RenderLoop">withNotificationHandlerDo: aBlock	| currentHandler |	currentHandler := WACurrentExceptionHandler value.	^ currentHandler isNil		ifTrue: [			aBlock on: WARenderNotification do: [ :n | ] ]		ifFalse: [			"For platforms with ANSI exceptions we have to nest exception handlers						with ANSI exceptions			When signaling an exception from an exception handler block the look up of			the new exception handler starts in the exception handler block.						without ANSI exceptions			When signaling an exception from an exception handler block the look up of			the new exception handler starts where the original exception was signaled.						platforms without ANSI exceptions: Pharo&lt;4, Squeak, GS2.x			platforms with ANSI exception: Pharo&gt;=4, VAST, VW, GS3.x"			[ currentHandler handleExceptionsDuring: aBlock ]				on: WARenderNotification				 do: [ :n | ] ]</body></methods><methods><class-id>Seaside.WARenderLoopContinuation class</class-id> <category>testing</category><body package="Seaside-RenderLoop">isActionContinuation	^ false</body><body package="Seaside-RenderLoop">isRenderContinuation	^ false</body><body package="Seaside-RenderLoop">isRenderLoopContinuation	^ true</body></methods><methods><class-id>Seaside.WAActionPhaseContinuation</class-id> <category>accessing</category><body package="Seaside-RenderLoop">renderContext	^ renderContext</body><body package="Seaside-RenderLoop">renderContext: aRenderContext	renderContext := aRenderContext</body></methods><methods><class-id>Seaside.WAActionPhaseContinuation</class-id> <category>private</category><body package="Seaside-RenderLoop">shouldRedirect	| request |	request := self request.	^ (request isGet and: [ request fields includesKey: '_n' ]) not</body><body package="Seaside-RenderLoop">startTasks	"Make sure that any new Tasks get executed"	(WAVisiblePresenterGuide client: WATaskVisitor new) start: self presenter</body></methods><methods><class-id>Seaside.WAActionPhaseContinuation</class-id> <category>handling</category><body package="Seaside-RenderLoop">handleFiltered: aRequestContext	self performAction.	self continue</body></methods><methods><class-id>Seaside.WAActionPhaseContinuation</class-id> <category>processing</category><body package="Seaside-RenderLoop">basicPerformAction	"Do nothing by default. Subclasses can override."</body><body package="Seaside-RenderLoop">continue	| renderContinuation |	renderContinuation := self createRenderContinuation.	renderContinuation captureState.	self shouldRedirect		ifTrue: [ self redirectToContinuation: renderContinuation ]		ifFalse: [ renderContinuation handle: self requestContext ]</body><body package="Seaside-RenderLoop">performAction	self withNotificationHandlerDo: [ self basicPerformAction ].	self startTasks</body></methods><methods><class-id>Seaside.WAActionPhaseContinuation</class-id> <category>initialization</category><body package="Seaside-RenderLoop">initializeWithSnapshot: aSnapshot renderContext: aRenderContext	self initializeWithSnapshot: aSnapshot.	renderContext := aRenderContext</body></methods><methods><class-id>Seaside.WAActionPhaseContinuation class</class-id> <category>testing</category><body package="Seaside-RenderLoop">isActionContinuation	^ true</body></methods><methods><class-id>Seaside.WAActionPhaseContinuation class</class-id> <category>private</category><body package="Seaside-RenderLoop">defaultRenderContext	^ nil</body></methods><methods><class-id>Seaside.WAActionPhaseContinuation class</class-id> <category>instance creation</category><body package="Seaside-RenderLoop">snapshot: aSnapshot	^ self snapshot: aSnapshot renderContext: self defaultRenderContext</body><body package="Seaside-RenderLoop">snapshot: aSnapshot renderContext: aRenderContext	^ self basicNew		initializeWithSnapshot: aSnapshot renderContext: aRenderContext;		yourself</body></methods><methods><class-id>Seaside.WACallbackProcessingActionContinuation</class-id> <category>private</category><body package="Seaside-RenderLoop">redirectToContinuation: aSessionContinuation	self respond: [ :response |		| url |		url := aSessionContinuation registerForUrl.		jumpTo isNil ifFalse: [			url fragment: jumpTo ].		response redirectTo: url ]</body></methods><methods><class-id>Seaside.WACallbackProcessingActionContinuation</class-id> <category>processing</category><body package="Seaside-RenderLoop">basicPerformAction	super basicPerformAction.	self renderContext callbacks handle: self requestContext</body><body package="Seaside-RenderLoop">performAction	"Ajax requests modify the captured state - though this behaviour has been heavily debated"	[ super performAction ] ensure: [		self request isXmlHttpRequest ifTrue: [ self captureState ] ]</body></methods><methods><class-id>Seaside.WACallbackProcessingActionContinuation</class-id> <category>public</category><body package="Seaside-RenderLoop">jumpToAnchor: aString	jumpTo := aString</body></methods><methods><class-id>Seaside.WACallbackProcessingActionContinuation class</class-id> <category>instance creation</category><body package="Seaside-RenderLoop">snapshot: aSnapshot renderContext: aRenderContext	aRenderContext isNil ifTrue: [ self error: 'Objects of this class require a RenderContext for callback processing.' ].	^ super snapshot: aSnapshot renderContext: aRenderContext</body></methods><methods><class-id>Seaside.WARenderPhaseContinuation</class-id> <category>private</category><body package="Seaside-RenderLoop">createHtmlRootWithContext: aRenderContext	^ WAHtmlRoot context: aRenderContext</body><body package="Seaside-RenderLoop">createRenderContext	| renderContext |	renderContext := WARenderContext new.		"Wrap the default visitor with a rendering guide"	renderContext visitor: (WARenderingGuide client: renderContext visitor).		^ renderContext</body></methods><methods><class-id>Seaside.WARenderPhaseContinuation</class-id> <category>processing</category><body package="Seaside-RenderLoop">addRedirectedToHeader: aRequestContext	"The Ajaxifier needs to know the URL of the render continuation (in order to save it).	Unfortunately the redirect from the action to the render continuation happens totally transparently to the JavaScript.	So we add a custom header to the response so that the JavaScript can find out the URL of the render continuation."	 (aRequestContext request headerAt: 'x-requested-with') = 'Ajaxifier' ifTrue: [		aRequestContext response headerAt: 'X-RedirectedTo' put: aRequestContext request url greaseString ]</body><body package="Seaside-RenderLoop">documentOpened: aResponse	"callback sent once #updateRoot: has been send to:	 	- all the libraries		- the session		- all the components	and the document has been opened (the opening body tag has been written)	per default do nothing"</body><body package="Seaside-RenderLoop">processRendering: aResponse 	| document actionContinuation renderContext actionUrl actionBaseUrl htmlRoot |	"Prepare the response"	aResponse contentType: self application contentType.	"Create objects we need"	document := self requestContext newDocument.	renderContext := self createRenderContext.	actionContinuation := self createActionContinuationWithContext: renderContext.		"Create URL"	actionUrl := actionContinuation registerForUrl: false.	actionBaseUrl := actionUrl copy.	self updateUrl: actionUrl.	"Hook objects together"	renderContext		document: document;		actionUrl: actionUrl;		actionBaseUrl: actionBaseUrl;		resourceUrl: self application resourceBaseUrl.	actionContinuation renderContext: renderContext.	htmlRoot := self createHtmlRootWithContext: renderContext.	self updateRoot: htmlRoot.	self toPresenterSendRoot: htmlRoot.	"Render"	document open: htmlRoot.	self documentOpened: aResponse.	self presenter renderWithContext: renderContext.	document close.	renderContext destroy</body></methods><methods><class-id>Seaside.WARenderPhaseContinuation</class-id> <category>handling</category><body package="Seaside-RenderLoop">handleFiltered: aRequestContext	self addRedirectedToHeader: aRequestContext.	self respond: [ :response | self processRendering: response ].	"The render phase should have returned a response"	WAMissingResponseError signal</body></methods><methods><class-id>Seaside.WARenderPhaseContinuation class</class-id> <category>testing</category><body package="Seaside-RenderLoop">isRenderContinuation	^ true</body></methods><methods><class-id>Seaside.WAFlushingRenderPhaseContinuation</class-id> <category>processing</category><body package="Seaside-RenderLoop">documentOpened: aResponse	aResponse flush</body></methods><methods><class-id>Seaside.WARenderLoopConfiguration</class-id> <category>description</category><body package="Seaside-RenderLoop">actionPhaseContinuationClasses	^ self continuationClasses select: [ :each | each isRenderLoopContinuation and: [ each isActionContinuation ] ]</body><body package="Seaside-RenderLoop">continuationClasses	^ WAApplicationConfiguration instance continuationClasses</body><body package="Seaside-RenderLoop">describeOn: config	(config classBinding: #actionPhaseContinuationClass)		beAdvanced;		group: #renderLoop;		comment: 'The continuation used for the Render Loop''s action phase.';		options: [ self actionPhaseContinuationClasses ];		default: WACallbackProcessingActionContinuation.	(config classBinding: #renderPhaseContinuationClass)		beAdvanced;		group: #renderLoop;		comment: 'The continuation used for the Render Loop''s render phase.';		options: [ self renderPhaseContinuationClasses ];		default: WARenderPhaseContinuation.	(config classBinding: #rootClass)		comment: 'The root component of this seaside application.';		options: [ self rootClasses ].	(config classBindingCollection: #rootDecorationClasses)		comment: 'The decoration clases that should wrap the root component.';		options: [ self rootDecorationClasses ].	config		at: #initialContinuationClass putClass: WAInitialRenderLoopContinuation</body><body package="Seaside-RenderLoop">renderPhaseContinuationClasses	^ self continuationClasses select: [ :each | each isRenderLoopContinuation and: [ each isRenderContinuation ] ]</body><body package="Seaside-RenderLoop">rootClasses	^ (WAComponent allSubclasses select: [ :each | each canBeRoot ])		asSortedCollection: [ :a :b | a name &lt;= b name ]</body><body package="Seaside-RenderLoop">rootDecorationClasses	^ (WADecoration allSubclasses select: [ :each | each canBeRoot ])		asSortedCollection: [ :a :b | a name &lt;= b name ]</body></methods><methods><class-id>Seaside.WARenderLoopConfiguration</class-id> <category>ancestry</category><body package="Seaside-RenderLoop">parents	"We override several attributes of the application configuration."	^ Array with: WAApplicationConfiguration instance</body></methods><methods><class-id>Seaside.WAInitialRenderLoopContinuation</class-id> <category>processing</category><body package="Seaside-RenderLoop">basicPerformAction	| root |	root := self createRoot.	self session properties at: #presenter put: root.	self prepareRoot: root</body><body package="Seaside-RenderLoop">prepareRoot: aComponent	(WAAllPresenterGuide client:		(WAInitialRequestVisitor request: self requestContext request))		start: aComponent.	(WAVisiblePresenterGuide client: (WATaskVisitor new)) start: aComponent</body></methods><methods><class-id>Seaside.WAInitialRenderLoopContinuation</class-id> <category>creational</category><body package="Seaside-RenderLoop">createRoot	| root |	root := self requestContext rootComponentIfAbsent: [ self rootClass new ].	^ self rootDecorationClasses		inject: root		into: [ :component :decorationClass |			component 				addDecoration: decorationClass new;				yourself ]</body></methods><methods><class-id>Seaside.WAInitialRenderLoopContinuation</class-id> <category>private</category><body package="Seaside-RenderLoop">shouldRedirect	"This should probably be made configurable, but for backwards compatibility with Seaside 3.0,	where we do not redirect when you enter a session, we return false."		^ false</body></methods><methods><class-id>Seaside.WAInitialRenderLoopContinuation</class-id> <category>accessing</category><body package="Seaside-RenderLoop">rootClass	^ (self application preferenceAt: #rootClass) value</body><body package="Seaside-RenderLoop">rootDecorationClasses	^ (self application preferenceAt: #rootDecorationClasses) collect: [ :each | each value ]</body></methods><methods><class-id>Seaside.WAPluggableActionContinuation</class-id> <category>processing</category><body package="Seaside-RenderLoop">basicPerformAction	^ action valueWithPossibleArguments: (Array with: renderContext)</body></methods><methods><class-id>Seaside.WAPluggableActionContinuation</class-id> <category>initialization</category><body package="Seaside-RenderLoop">initializeWithSnapshot: aSnapshot renderContext: aRenderContext action: aValuable	self initializeWithSnapshot: aSnapshot renderContext: aRenderContext.	action := aValuable</body></methods><methods><class-id>Seaside.WAPluggableActionContinuation class</class-id> <category>instance creation</category><body package="Seaside-RenderLoop">action: aValuable	^ self snapshot: self defaultSnapshot renderContext: self defaultRenderContext action: aValuable</body><body package="Seaside-RenderLoop">snapshot: aSnapshot renderContext: aRenderContext	^ self snapshot: aSnapshot renderContext: aRenderContext action: self defaultAction</body><body package="Seaside-RenderLoop">snapshot: aSnapshot renderContext: aRenderContext action: aValuable	^ self basicNew		initializeWithSnapshot: aSnapshot renderContext: aRenderContext action: aValuable;		yourself</body></methods><methods><class-id>Seaside.WAPluggableActionContinuation class</class-id> <category>private</category><body package="Seaside-RenderLoop">defaultAction	^ GRDelayedSend empty</body></methods><methods><class-id>Seaside.WASession</class-id> <category>*seaside-renderloop</category><body package="Seaside-RenderLoop">presenter	^ self properties at: #presenter ifAbsent: [ nil ]</body></methods><methods><class-id>Seaside.WARequestContext</class-id> <category>*seaside-renderloop</category><body package="Seaside-RenderLoop">rootComponent: aComponent	"Set the root component for the render loop.	If this message is sent before a session is created the given component will be used as the root component of the render loop instead of the root component configured on the application."	self properties at: #rootComponent put: aComponent</body><body package="Seaside-RenderLoop">rootComponentIfAbsent: aNiladicBlock	"Answer the root component if set, the value of aNiladicBlock if not set."	^ self properties at: #rootComponent ifAbsent: aNiladicBlock</body></methods><methods><class-id>Seaside.WASessionContinuation class</class-id> <category>*seaside-renderloop</category><body package="Seaside-RenderLoop">isRenderLoopContinuation	^ false</body></methods><methods><class-id>Seaside.WASessionContinuation</class-id> <category>*seaside-renderloop</category><body package="Seaside-RenderLoop">isRenderLoopContinuation	^ self class isRenderLoopContinuation</body></methods><methods><class-id>Grease.GRPackage class</class-id> <category>*seaside-renderloop</category><body package="Seaside-RenderLoop">seasideRenderLoop	^ self new		name: 'Seaside-RenderLoop';		description: 'Defines the low-level rendering and callback processing functionality.';		addDependency: 'Seaside-Session';		addDependency: 'Seaside-Component';		url: #seasideUrl;		yourself</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>WASessionContinuation</name><environment>Seaside</environment><super>Seaside.WARequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>states </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Session</category><attributes><package>Seaside-Session</package></attributes></class><class><name>WASystemConfiguration</name><environment>Seaside</environment><super>Seaside.WAConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>description </inst-vars><class-inst-vars>instance </class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WADynamicVariable</name><environment>Seaside</environment><super>Seaside.WANotification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Utilities</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WASession</name><environment>Seaside</environment><super>Seaside.WARequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>continuations properties documentHandlers key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Session</category><attributes><package>Seaside-Session</package></attributes></class><class><name>WARequestContext</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handlers request response codec consumer properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAError</name><environment>Seaside</environment><super>Grease.GRError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Exceptions</category><attributes><package>Seaside-Core</package></attributes></class></st-source>