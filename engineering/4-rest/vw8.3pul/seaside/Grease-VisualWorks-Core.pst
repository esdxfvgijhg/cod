<?xml version="1.0"?><st-source><!-- Name: Grease-VisualWorks-CoreNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: Utilities and platform dependendent classes for Seaside.DbIdentifier: bear73DbTrace: 493798DbUsername: tkoganDbVersion: 3.2.0 - 2DevelopmentPrerequisites: #(#(#any 'Grease-Core' '') #(#any 'SHA' '') #(#any 'MIME' '') #(#any 'Protocols-Common' ''))DialectVersion: VisualWorks 7.9DisregardedPrerequisites: #(#(#name 'Grease-VisualWorks-Extensions' #componentType #package) #(#name 'Grease-Namespace' #componentType #package))ExplicitPrerequisites: #()IgnoredPrerequisites: #()Namespace: Smalltalk.GreasePackageName: Grease-VisualWorks-CoreParcel: #('Grease-VisualWorks-Core')PrerequisiteDescriptions: #(#(#name 'Grease-Core' #componentType #package) #(#name 'SHA') #(#name 'MIME' #componentType #package) #(#name 'Protocols-Common' #componentType #package))PrerequisiteParcels: #(#('Grease-Core' '') #('SHA' '') #('MIME' '') #('Protocols-Common' ''))PrintStringCache: (3.2.0 - 2,tkogan)Version: 3.2.0 - 2Post-Load Block: 	[:package |	Grease.GRVisualWorksPlatform select.	ObjectMemory registerObject: true withEngineFor: 'IEEEFloatingPointPrimitives']Date: 3:31:26 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:31:26 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ReadWriteCharacterStream</name><environment>Grease</environment><super>Core.ReadWriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Grease-VisualWorks-Core</package></attributes></class><comment><class-id>Grease.ReadWriteCharacterStream</class-id><body>ReadWriteCharacterStream will try to resolve a conflict between the underlying collection and the kind of object that may be put on it. Ensure that characters are written to a String, and byte integers to a ByteArray.</body></comment><class><name>GRVisualWorksPlatform</name><environment>Grease</environment><super>Grease.GRPlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Protocols.*			</imports><category></category><attributes><package>Grease-VisualWorks-Core</package></attributes></class><comment><class-id>Grease.GRVisualWorksPlatform</class-id><body>GRVisualWorksPlatform is the VisualWorks platform implementation</body></comment><class><name>GRGenericCodecStream</name><environment>Grease</environment><super>Grease.GRCodecStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Grease-VisualWorks-Core</package></attributes></class><comment><class-id>Grease.GRGenericCodecStream</class-id><body>GRGenericCodecStream uses EncodedStream with StreamEncoder to provide Seaside codec streams.</body></comment><class><name>DateAndTime</name><environment>Grease</environment><super>Core.Timestamp</super><private>false</private><indexed-type>none</indexed-type><inst-vars>offset </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Grease-VisualWorks-Core</package></attributes></class><class><name>Timespan</name><environment>Grease</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>start duration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Chronology</category><attributes><package>Grease-VisualWorks-Core</package></attributes></class><comment><class-id>Grease.Timespan</class-id><body>Timespan has been ported from Pharo.Instance Variables:	duration	&lt;Duration&gt;	description of duration	start	&lt;Timespan&gt;	description of start</body></comment><class><name>Week</name><environment>Grease</environment><super>Grease.Timespan</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Chronology</category><attributes><package>Grease-VisualWorks-Core</package></attributes></class><class><name>WriteCharacterStream</name><environment>Grease</environment><super>Core.WriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Grease-VisualWorks-Core</package></attributes></class><comment><class-id>Grease.WriteCharacterStream</class-id><body>WriteCharacterStream mimics the Pharo/Grease WriteStream implementation which slightly differs from that of VisualWorks. When a Grease.WriteCharacterStream is reset, both readLimit and position are set to zero.</body></comment><class><name>GRLatin1CodecStream</name><environment>Grease</environment><super>Grease.GRNullCodecStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Grease-VisualWorks-Core</package></attributes></class><class><name>Author</name><environment>Grease</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>fullName </inst-vars><class-inst-vars>uniqueInstance </class-inst-vars><imports></imports><category></category><attributes><package>Grease-VisualWorks-Core</package></attributes></class><comment><class-id>Grease.Author</class-id><body>Author is a bare-bones representation of a Smalltalk developer. Needed to create components from the Seaside Welcome page.Instance Variables	fullName	&lt;String&gt;	fullName of the user.</body></comment><class><name>GRGenericCodec</name><environment>Grease</environment><super>Grease.GRCodec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoder name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Grease-VisualWorks-Core</package></attributes></class><class><name>GRLatin1Codec</name><environment>Grease</environment><super>Grease.GRNullCodec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Grease-VisualWorks-Core</package></attributes></class><comment><class-id>Grease.GRLatin1Codec</class-id><body>A GRPharoLatin1Codec is a GRCodec optimized for ISO-8859-1 (direct byte to character mapping).Instance Variables	name	&lt;String&gt; the name of the codec.</body></comment><class><name>Year</name><environment>Grease</environment><super>Grease.Timespan</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Chronology</category><attributes><package>Grease-VisualWorks-Core</package></attributes></class><class><name>GreaseSystem</name><environment>Grease</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>startUpTime serverStartUpTime </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Grease-VisualWorks-Core</package></attributes></class><comment><class-id>Grease.GreaseSystem</class-id><body>GreaseSystem is a subsystem used to track certain system events such as image startup etc.</body></comment><class><name>Month</name><environment>Grease</environment><super>Grease.Timespan</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Chronology</category><attributes><package>Grease-VisualWorks-Core</package></attributes></class><shared-variable><name>DaysInMonth</name><environment>Grease.Month</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>#(31 28 31 30 31 30 31 31 30 31 30 31)</initializer><attributes><package>Grease-VisualWorks-Core</package></attributes></shared-variable><shared-variable><name>DayNames</name><environment>Grease.Week</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>#(#Sunday #Monday #Tuesday #Wednesday #Thursday #Friday #Saturday)</initializer><attributes><package>Grease-VisualWorks-Core</package></attributes></shared-variable><shared-variable><name>StartDay</name><environment>Grease.Week</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Grease-VisualWorks-Core</package></attributes></shared-variable><shared-variable><name>PositiveInfinity</name><environment>Core.Float</environment><private>false</private><constant>false</constant><category>constants</category><initializer>Float unity / Float zero</initializer><attributes><package>Grease-VisualWorks-Core</package></attributes></shared-variable><shared-variable><name>NegativeInfinity</name><environment>Core.Float</environment><private>false</private><constant>false</constant><category>constants</category><initializer>Float unity negated / Float zero</initializer><attributes><package>Grease-VisualWorks-Core</package></attributes></shared-variable><shared-variable><name>NaN</name><environment>Core.Float</environment><private>false</private><constant>false</constant><category>constants</category><initializer>Float zero / Float zero</initializer><attributes><package>Grease-VisualWorks-Core</package></attributes></shared-variable><shared-variable><name>ShutDownList</name><environment>Grease.GRVisualWorksPlatform</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>OrderedCollection new</initializer><attributes><package>Grease-VisualWorks-Core</package></attributes></shared-variable><shared-variable><name>StartUpList</name><environment>Grease.GRVisualWorksPlatform</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>OrderedCollection new</initializer><attributes><package>Grease-VisualWorks-Core</package></attributes></shared-variable><methods><class-id>Grease.ReadWriteCharacterStream</class-id> <category>accessing</category><body package="Grease-VisualWorks-Core">nextPut: aCharacterOrInteger"	My underlying collection may be a ByteArray or a String, depending on how I get created.	If I am wrapped by an encoder, it might be trying to output an Integer when my collection is a String,	leading to an error.	I will attempt to resolve the conflict."	| output |		output := collection isString		ifTrue: [ aCharacterOrInteger isCharacter			ifTrue: [aCharacterOrInteger ]			ifFalse: [Character value: aCharacterOrInteger]]		ifFalse: [ aCharacterOrInteger isCharacter			ifTrue: [aCharacterOrInteger codePoint]			ifFalse: [aCharacterOrInteger]].	^ super nextPut: output</body></methods><methods><class-id>Grease.GRVisualWorksPlatform</class-id> <category>startup</category><body package="Grease-VisualWorks-Core">addToShutDownList: anObject	ShutDownList add: anObject</body><body package="Grease-VisualWorks-Core">addToStartUpList: anObject	StartUpList add: anObject</body><body package="Grease-VisualWorks-Core">removeFromShutDownList: anObject	ShutDownList remove: anObject ifAbsent: []</body><body package="Grease-VisualWorks-Core">removeFromStartUpList: anObject	StartUpList remove: anObject ifAbsent: []</body></methods><methods><class-id>Grease.GRVisualWorksPlatform</class-id> <category>exceptions</category><body package="Grease-VisualWorks-Core">openDebuggerOn: anError	Notifier debugException: anError</body><body package="Grease-VisualWorks-Core">stackDepth	| context depth |	depth := 1.	context := thisContext.	[(context := context sender) notNil] whileTrue: [depth := depth + 1].	^depth</body></methods><methods><class-id>Grease.GRVisualWorksPlatform</class-id> <category>file library</category><body package="Grease-VisualWorks-Core">asMethodReturningByteArray: aByteArrayOrString named: aSymbol	^aSymbol, '	^', aByteArrayOrString asByteArray storeString</body><body package="Grease-VisualWorks-Core">compile: aString into: aClass classified: aSymbol	Store.Policies packagePolicy packageIsForced ifTrue: [^aClass compile: aString classified: aSymbol].	^Store.Policies packagePolicy forcePackage: Store.Registry nullPackage while: [aClass compile: aString classified: aSymbol]</body><body package="Grease-VisualWorks-Core">contentsOfFile: aString binary: aBoolean	^aBoolean		ifTrue: [(aString asFilename withEncoding: #binary) contentsOfEntireFile]		ifFalse: [aString asFilename contentsOfEntireFile]</body><body package="Grease-VisualWorks-Core">convertToSmalltalkNewlines: aString	aString isNil ifTrue: [ ^ nil ].	^ String streamContents: [ :writeStream |		| readStream |		readStream := aString readStream.		[ readStream atEnd ] whileFalse: [			| next |			next := readStream next.			next = Character cr				ifTrue: [					readStream peek = Character lf						ifTrue: [ readStream skip: 1 ].					writeStream nextPut: Character cr ]				ifFalse: [					next = Character lf						ifTrue: [ writeStream nextPut: Character cr ]						ifFalse: [ writeStream nextPut: next ] ] ] ]</body><body package="Grease-VisualWorks-Core">directoriesIn: aPathString	"Answer a collection of absolute paths for all the directories (no files) in the directory given by aPathString	must not include directory names that start with ."	| directory |	directory := Filename named: aPathString.	directory isDirectory ifFalse: [ ^ #() ].	^(directory directoryContents		reject: [:each | each first = $. or: [(directory / each) isDirectory not]])			collect: [:each | (directory / each) asString]</body><body package="Grease-VisualWorks-Core">ensureExistenceOfFolder: aString	aString asFilename ensureDirectory</body><body package="Grease-VisualWorks-Core">filesIn: aPathString	"Return a collection of absolute paths for all the files (no directories) in the directory given by aPathString	must not include file names that start with ."	| directory |	directory := Filename named: aPathString.	directory isDirectory ifFalse: [^#()].	^(directory directoryContents		reject: [:each | each first = $. or: [(directory / each) isDirectory]])			collect: [:each | (directory / each) asString]</body><body package="Grease-VisualWorks-Core">localNameOf: aFilename	^aFilename asFilename tail</body><body package="Grease-VisualWorks-Core">newline	^''</body><body package="Grease-VisualWorks-Core">pathSeparator	^String with: Filename separator</body><body package="Grease-VisualWorks-Core">removeSelector: aSymbol from: aClass	aClass removeSelector: aSymbol</body><body package="Grease-VisualWorks-Core">write: aStringOrByteArray toFile: aFileNameString inFolder: aFolderString	| stream |	stream := (aFolderString asFilename / aFileNameString) writeStream.	[aStringOrByteArray isCharacters ifFalse: [stream binary].	stream nextPutAll: aStringOrByteArray]		ensure: [stream close]</body></methods><methods><class-id>Grease.GRVisualWorksPlatform</class-id> <category>processes</category><body package="Grease-VisualWorks-Core">isProcessTerminated: aProcess	^aProcess isTerminated</body><body package="Grease-VisualWorks-Core">terminateProcess: aProcess	aProcess terminate</body></methods><methods><class-id>Grease.GRVisualWorksPlatform</class-id> <category>factory</category><body package="Grease-VisualWorks-Core">newRandom	^Random new</body><body package="Grease-VisualWorks-Core">readWriteByteStream	^ReadWriteStream on: ByteArray new</body><body package="Grease-VisualWorks-Core">readWriteCharacterStream	^ReadWriteCharacterStream on: String new</body><body package="Grease-VisualWorks-Core">semaphoreClass	^Semaphore</body><body package="Grease-VisualWorks-Core">weakDictionaryOfSize: aNumber	"Squeak returns IdentityDictionary, but they have considered WeakIdentityKeyDictionary. This basically means the API is weak keys and identity comparisons."	^EphemeronDictionary new: aNumber</body><body package="Grease-VisualWorks-Core">writeCharacterStreamOn: aString	"String based write stream"	^ Grease.WriteCharacterStream on: aString</body></methods><methods><class-id>Grease.GRVisualWorksPlatform</class-id> <category>email</category><body package="Grease-VisualWorks-Core">deliverMailFrom: fromAddress to: recipientList text: messageText	Net.RFC822Message newTextPlain		from: fromAddress;		to: recipientList;		text: messageText;		send</body></methods><methods><class-id>Grease.GRVisualWorksPlatform</class-id> <category>cryptography</category><body package="Grease-VisualWorks-Core">secureHashFor: aString	^Security.SHA hash: aString</body></methods><methods><class-id>Grease.GRVisualWorksPlatform</class-id> <category>version info</category><body package="Grease-VisualWorks-Core">label	^SystemUtils version</body></methods><methods><class-id>Grease.GRVisualWorksPlatform</class-id> <category>*seaside-tests-functional</category><body package="Grease-VisualWorks-Core">seasideGarbageCollect	ObjectMemory garbageCollect</body></methods><methods><class-id>Grease.GRVisualWorksPlatform</class-id> <category>encoding</category><body package="Grease-VisualWorks-Core">base64Decode: aString	| bytes |	bytes := DecodedStream 				on: aString readStream 				encodedBy: B64StreamDecoder asEncoder. 	^(EncodedStream on: bytes encodedBy: (StreamEncoder new: #ascii)) contents</body></methods><methods><class-id>Grease.GRVisualWorksPlatform</class-id> <category>bindings</category><body package="Grease-VisualWorks-Core">bindingOf: aClass	"Answer the binding of aClass.	The binding is the literal that get compiled into the method.	We need the binding to be updated when the class is changed.	The binding has to respond to #value.		This is mostly an issue on GemStone/S because when we hold on	to a class directly we will end up holding on to an old class version.		Dialects with namespaces will need to override this.		On VisualWorks this should like this	^ aClass fullyQualifiedReference"	^ aClass fullyQualifiedReference</body></methods><methods><class-id>Grease.GRGenericCodecStream</class-id> <category>streaming</category><body package="Grease-VisualWorks-Core">next	^stream next</body><body package="Grease-VisualWorks-Core">next: anInteger	^stream next: anInteger</body><body package="Grease-VisualWorks-Core">nextPut: aCharacterOrByte	aCharacterOrByte isCharacter		ifTrue: [ stream nextPut: aCharacterOrByte ]		ifFalse: [ stream nextPut: (Character value: aCharacterOrByte) ]</body><body package="Grease-VisualWorks-Core">nextPutAll: aStringOrByteArray	aStringOrByteArray isString		ifTrue: [ stream nextPutAll: aStringOrByteArray ]		ifFalse: [			1 to: aStringOrByteArray size do: [ :index |				| value |				value := aStringOrByteArray at: index.				value &lt;= 255					ifTrue: [ stream nextPut: (Character value: value) ]					ifFalse: [ GRError signal: 'Byte value expected.' ] ] ]</body></methods><methods><class-id>Grease.GRGenericCodecStream</class-id> <category>accessing</category><body package="Grease-VisualWorks-Core">contents	^ stream stream contents asString</body></methods><methods><class-id>Grease.DateAndTime</class-id> <category>accessing</category><body package="Grease-VisualWorks-Core">asUTC	^(self - offset)		offset: Duration zero;		yourself</body><body package="Grease-VisualWorks-Core">dayOfMonth	"Answer which day of the month is represented by the receiver."	^ day</body><body package="Grease-VisualWorks-Core">hour	^ hours</body><body package="Grease-VisualWorks-Core">isLeapYear	^ Year isLeapYear: self year.</body><body package="Grease-VisualWorks-Core">minute	"Answer a number that represents the number of complete minutes in the receiver' time part, 	after the number of complete hours has been removed."	 	^ minutes</body><body package="Grease-VisualWorks-Core">monthIndex	^month</body><body package="Grease-VisualWorks-Core">offset	^offset</body><body package="Grease-VisualWorks-Core">offset: anObject	offset := anObject</body><body package="Grease-VisualWorks-Core">second	"Answer a number that represents the number of complete seconds in the receiver's time part, 	after the number of complete minutes has been removed." " 	^ (self localSeconds rem: Smalltalk.SecondsInMinute) % 60"	^seconds</body><body package="Grease-VisualWorks-Core">year	^ year</body></methods><methods><class-id>Grease.DateAndTime</class-id> <category>initialize-release</category><body package="Grease-VisualWorks-Core">initialize	super initialize.	self initializeOffset</body><body package="Grease-VisualWorks-Core">initializeOffset	offset := Duration zero</body></methods><methods><class-id>Grease.DateAndTime</class-id> <category>converting</category><body package="Grease-VisualWorks-Core">asDateAndTime	^ self</body><body package="Grease-VisualWorks-Core">asMonth	^ Month starting: self</body><body package="Grease-VisualWorks-Core">asWeek	^ Week starting: self</body><body package="Grease-VisualWorks-Core">asYear	^ Year starting: self</body><body package="Grease-VisualWorks-Core">fromTimestamp: aTimestamp	| instSize |	instSize := aTimestamp class instSize min: self class instSize.	1 to: instSize		do: [:index | self instVarAt: index put: (aTimestamp instVarAt: index)]</body></methods><methods><class-id>Grease.DateAndTime</class-id> <category>double dispatch</category><body package="Grease-VisualWorks-Core">equalFromTimestamp: aTimestamp	" If my offset is zero, I am already in UTC. The rest of the comparison should be the same as in the superclass as Timestamp does not have a concept of offset.	Otherwise,convert myself to UTC and compare again with aTimestamp "	^offset = Duration zero		ifTrue: [super equalFromTimestamp: aTimestamp]		ifFalse: [aTimestamp = self asUTC]</body></methods><methods><class-id>Grease.DateAndTime class</class-id> <category>instance creation</category><body package="Grease-VisualWorks-Core">clockPrecision	"One nanosecond precision"	^ Duration fromNanoseconds: 1</body><body package="Grease-VisualWorks-Core">fromSeconds: seconds	^self fromTimestamp: (super fromSeconds: seconds) offset: Duration zero</body><body package="Grease-VisualWorks-Core">fromTimestamp: aTimestamp offset: aDuration	^(self basicNew)		fromTimestamp: aTimestamp;		offset: aDuration;		yourself</body><body package="Grease-VisualWorks-Core">now	" self now "	^self fromTimestamp: super now offset: self systemOffset</body><body package="Grease-VisualWorks-Core">nowUTC	" self nowUTC "	^self fromTimestamp: super nowUTC offset: Duration zero</body><body package="Grease-VisualWorks-Core">systemOffset	^Duration fromSeconds: SystemTimeZone new secondsFromUniversal</body><body package="Grease-VisualWorks-Core">year: year day: dayOfYear	"Return a DateAndTime"	^ self		year: year		day: dayOfYear		hour: 0		minute: 0		second: 0</body><body package="Grease-VisualWorks-Core">year: year day: day hour: hour minute: minute second: second	^self year: year day: day hour: hour minute: minute second: second offset: Duration zero</body><body package="Grease-VisualWorks-Core">year: year day: day hour: hour minute: minute second: second offset: offset	| date |	date := Date newDay: day year: year.	^self new		year: year;		month: date monthIndex;		day: date dayOfMonth;		hour: hour;		minute: minute;		second: second;		offset: offset;		yourself</body><body package="Grease-VisualWorks-Core">year: year month: month day: day	"Return a DateAndTime, midnight local time"	^ self		year: year		month: month		day: day		hour: 0		minute: 0</body><body package="Grease-VisualWorks-Core">year: year month: month day: day hour: hour minute: minute	"Return a DateAndTime" 		^ self 		year: year 		month: month 		day: day 		hour: hour		minute: minute		second: 0</body><body package="Grease-VisualWorks-Core">year: year month: month day: day hour: hour minute: minute second: second	^self year: year month: month day: day hour: hour minute: minute second: second offset: Duration zero</body><body package="Grease-VisualWorks-Core">year: year month: month day: day hour: hour minute: minute second: second offset: offset	^self new		year: year;		month: month;		day: day;		hour: hour;		minute: minute;		second: second;		offset: offset;		yourself</body></methods><methods><class-id>Grease.Timespan</class-id> <category>accessing</category><body package="Grease-VisualWorks-Core">asDate 	^ start asDate</body><body package="Grease-VisualWorks-Core">asDateAndTime	^ start</body><body package="Grease-VisualWorks-Core">day	"Answer the day of the year represented by the receiver."	^ self dayOfYear</body><body package="Grease-VisualWorks-Core">dayOfMonth	"Answer the day of the month represented by the receiver."	^ start dayOfMonth</body><body package="Grease-VisualWorks-Core">dayOfWeek	"Answer the day of the week represented by the receiver."	^ start dayOfWeek</body><body package="Grease-VisualWorks-Core">dayOfWeekName	"Answer the day of the week represented by the receiver."	^ start dayOfWeekName</body><body package="Grease-VisualWorks-Core">dayOfYear	"Answer the day of the year represented by the receiver."	^ start dayOfYear</body><body package="Grease-VisualWorks-Core">daysInMonth 	^ start daysInMonth</body><body package="Grease-VisualWorks-Core">daysInYear 	"Answer the number of days in the month represented by the receiver."	^ start daysInYear</body><body package="Grease-VisualWorks-Core">daysLeftInYear	^ start daysLeftInYear</body><body package="Grease-VisualWorks-Core">duration 	"Answer the Duration of this timespan"	^ duration</body><body package="Grease-VisualWorks-Core">end 	^ self duration asNanoseconds = 0		ifTrue: [ self start ]		ifFalse: [ self next start - DateAndTime clockPrecision ]</body><body package="Grease-VisualWorks-Core">firstDayOfMonth	^ start firstDayOfMonth</body><body package="Grease-VisualWorks-Core">hash	^ start hash + duration hash</body><body package="Grease-VisualWorks-Core">isLeapYear	^ start isLeapYear</body><body package="Grease-VisualWorks-Core">julianDayNumber 	^ start julianDayNumber</body><body package="Grease-VisualWorks-Core">julianDayNumberUTC	^ start julianDayNumberUTC</body><body package="Grease-VisualWorks-Core">month	^ start month</body><body package="Grease-VisualWorks-Core">monthAbbreviation 	^ start monthAbbreviation</body><body package="Grease-VisualWorks-Core">monthIndex	^ self month</body><body package="Grease-VisualWorks-Core">monthName 	^ start monthName</body><body package="Grease-VisualWorks-Core">next	^ self class starting: (start + duration) duration: duration</body><body package="Grease-VisualWorks-Core">offset	^ start offset</body><body package="Grease-VisualWorks-Core">previous 	^ self class starting: (start - duration) duration: duration</body><body package="Grease-VisualWorks-Core">start 	"Answer the start DateAndTime of this timespan"	^ start</body><body package="Grease-VisualWorks-Core">start: aDateAndTime	"Store the start DateAndTime of this timespan"	start := aDateAndTime asDateAndTime</body><body package="Grease-VisualWorks-Core">year 	^ start year</body></methods><methods><class-id>Grease.Timespan</class-id> <category>enumerating</category><body package="Grease-VisualWorks-Core">dates	| dates |	dates := OrderedCollection new.	self datesDo: [ :m | dates add: m ].	^ dates asArray.</body><body package="Grease-VisualWorks-Core">datesDo: aBlock 	self do: aBlock with: start asDate.</body><body package="Grease-VisualWorks-Core">every: aDuration do: aBlock	| element end |	element := self start.	end := self end.	[ element &lt;= end ] whileTrue:		[ aBlock value: element.		element := element + aDuration. ]</body><body package="Grease-VisualWorks-Core">intersection: aTimespan	 "Return the Timespan both have in common, or nil"	 | aBegin anEnd |	 aBegin := self start max: aTimespan start.	 anEnd := self end min: aTimespan end.	 anEnd &lt; aBegin ifTrue: [^nil].	 ^ self class starting: aBegin ending: anEnd.</body><body package="Grease-VisualWorks-Core">months	| months |	months := OrderedCollection new: 12.	self monthsDo: [ :m | months add: m ].	^ months asArray.</body><body package="Grease-VisualWorks-Core">monthsDo: aBlock 	self do: aBlock with: start asMonth.</body><body package="Grease-VisualWorks-Core">union: aTimespan	 "Return the Timespan spanned by both"	| aBegin anEnd |	aBegin := self start min: aTimespan start.	anEnd := self end max: aTimespan end.	^ Timespan starting: aBegin ending: (anEnd + DateAndTime clockPrecision).</body><body package="Grease-VisualWorks-Core">weeks	| weeks |	weeks := OrderedCollection new.	self weeksDo: [ :m | weeks add: m ].	^ weeks asArray.</body><body package="Grease-VisualWorks-Core">weeksDo: aBlock	self do: aBlock with: self asWeek.</body><body package="Grease-VisualWorks-Core">workDatesDo: aBlock 	"Exclude Saturday and Sunday"	self do: aBlock with: start asDate when: [ :d | d dayOfWeek &lt; 6 ].</body><body package="Grease-VisualWorks-Core">years	| years |	years := OrderedCollection new.	self yearsDo: [ :m | years add: m ].	^ years asArray.</body><body package="Grease-VisualWorks-Core">yearsDo: aBlock	self do: aBlock with: start asYear.</body></methods><methods><class-id>Grease.Timespan</class-id> <category>testing</category><body package="Grease-VisualWorks-Core">includes: aDateAndTime 	^ (aDateAndTime isKindOf: Timespan)			ifTrue: [ (self includes: aDateAndTime start)						and: [ self includes: aDateAndTime end ] ]			ifFalse: [ aDateAndTime asDateAndTime between: start and: self end ]</body><body package="Grease-VisualWorks-Core">includesAllOf: aCollection 	"Answer whether all the elements of aCollection are in the receiver."	aCollection do: [:elem | (self includes: elem) ifFalse: [^ false]].	^ true</body><body package="Grease-VisualWorks-Core">includesAnyOf: aCollection 	"Answer whether any element of aCollection is included in the receiver"	aCollection do: [ :elem | (self includes: elem) ifTrue: [^ true]].	^false</body></methods><methods><class-id>Grease.Timespan</class-id> <category>arithmetic</category><body package="Grease-VisualWorks-Core">+ operand	"operand conforms to protocol Duration" 		^ self class starting: (self start + operand) duration: self duration</body><body package="Grease-VisualWorks-Core">- operand	"operand conforms to protocol DateAndTime or protocol Duration"	^ (operand respondsTo: #asDateAndTime) 	 	ifTrue: [ self start - operand ]	 	ifFalse: [ self + (operand negated) ].</body><body package="Grease-VisualWorks-Core">&lt; comparand	^ self start &lt; comparand</body><body package="Grease-VisualWorks-Core">= comparand	^ self species = comparand species 		and: [ self start = comparand start 				and: [ self duration = comparand duration ]]</body></methods><methods><class-id>Grease.Timespan</class-id> <category>conversion</category><body package="Grease-VisualWorks-Core">asDosTimestamp 	^ start asDosTimestamp</body><body package="Grease-VisualWorks-Core">asDuration	^ self duration</body><body package="Grease-VisualWorks-Core">asMonth 	^ start asMonth</body><body package="Grease-VisualWorks-Core">asSeconds 	"Answer the seconds since the Squeak epoch: 1 January 1901"  	^ start asSeconds</body><body package="Grease-VisualWorks-Core">asTime	^ start asTime</body><body package="Grease-VisualWorks-Core">asTimeStamp	^ start asTimeStamp</body><body package="Grease-VisualWorks-Core">asWeek	^ start asWeek</body><body package="Grease-VisualWorks-Core">asYear 	^ start asYear</body><body package="Grease-VisualWorks-Core">to: anEnd	"Answer an Timespan. anEnd must be aDateAndTime or a Timespan" 	^ Timespan starting: (self start) ending: (anEnd asDateAndTime).</body><body package="Grease-VisualWorks-Core">translateTo: aTimeZone	^ self class		starting: (start translateTo: aTimeZone)</body><body package="Grease-VisualWorks-Core">translateToUTC 	^ self translateTo: 0</body></methods><methods><class-id>Grease.Timespan</class-id> <category>private</category><body package="Grease-VisualWorks-Core">do: aBlock with: aFirstElement 	self do: aBlock with: aFirstElement when: [ :t | true ].</body><body package="Grease-VisualWorks-Core">do: aBlock with: aFirstElement when: aConditionBlock	| element end |	element := aFirstElement.	end := self end.	[ element start &lt;= end ] whileTrue:		[(aConditionBlock value: element)			ifTrue: [ aBlock value: element ].		element := element next. ]</body><body package="Grease-VisualWorks-Core">duration: aDuration	"Set the Duration of this timespan"	duration := aDuration</body></methods><methods><class-id>Grease.Timespan</class-id> <category>printing</category><body package="Grease-VisualWorks-Core">printOn: aStream 	super printOn: aStream.	aStream 		nextPut: $(;		print: start;		nextPut: $D;		print: duration;		nextPut: $).</body></methods><methods><class-id>Grease.Timespan class</class-id> <category>squeak protocol</category><body package="Grease-VisualWorks-Core">current 	^ self starting: DateAndTime now</body><body package="Grease-VisualWorks-Core">new	"Answer a Timespan starting on the Squeak epoch: 1 January 1901"	^ self starting: DateAndTime new</body><body package="Grease-VisualWorks-Core">starting: aDateAndTime 	^ self starting: aDateAndTime duration: Duration zero</body><body package="Grease-VisualWorks-Core">starting: aDateAndTime duration: aDuration	^ self basicNew  		start: aDateAndTime asDateAndTime; 		duration: aDuration;		yourself.</body><body package="Grease-VisualWorks-Core">starting: startDateAndTime ending: endDateAndTime	^ self 		starting: startDateAndTime 		duration: (endDateAndTime asDateAndTime - startDateAndTime).</body></methods><methods><class-id>Grease.Week</class-id> <category>squeak protocol</category><body package="Grease-VisualWorks-Core">asWeek	^ self</body><body package="Grease-VisualWorks-Core">index	^ self asMonth dayOfWeek + self dayOfMonth - 2  // 7 + 1</body><body package="Grease-VisualWorks-Core">printOn: aStream	aStream nextPutAll: 'a Week starting: '.	self start printOn: aStream.</body></methods><methods><class-id>Grease.Week class</class-id> <category>squeak protocol</category><body package="Grease-VisualWorks-Core">dayNames	^ DayNames</body><body package="Grease-VisualWorks-Core">indexOfDay: aSymbol	^ DayNames indexOf: aSymbol</body><body package="Grease-VisualWorks-Core">startDay	^ StartDay ifNil: [ StartDay := DayNames first ]</body><body package="Grease-VisualWorks-Core">startDay: aSymbol	(DayNames includes: aSymbol)		ifTrue: [ StartDay := aSymbol ]		ifFalse: [ self error: aSymbol, ' is not a recognised day name' ]</body><body package="Grease-VisualWorks-Core">starting: aDateAndTime duration: aDuration	"Override - the duration is always one week.	 Week will start from the Week class&gt;&gt;startDay"	| midnight delta adjusted |	midnight := aDateAndTime asDateAndTime midnight.	delta := ((midnight dayOfWeek + 7 - (DayNames indexOf: self startDay)) rem: 7) abs.	"24 hrs * 60 min * 60 sec = 86400 sec "	adjusted := midnight - (Duration fromSeconds: delta * 86400).	^ super starting: adjusted duration: (Duration weeks: 1).</body></methods><methods><class-id>Grease.Week class</class-id> <category>smalltalk-80</category><body package="Grease-VisualWorks-Core">nameOfDay: anIndex	^ DayNames at: anIndex</body></methods><methods><class-id>Grease.WriteCharacterStream</class-id> <category>positioning</category><body package="Grease-VisualWorks-Core">reset	"Set the read limit and the receiver's access position to 0."	readLimit := position := 0</body></methods><methods><class-id>Grease.WriteCharacterStream</class-id> <category>accessing</category><body package="Grease-VisualWorks-Core">nextPut: aCharacterOrInteger"	My underlying collection may be a ByteArray or a String, depending on how I get created.	If I am wrapped by an encoder, it might be trying to output an Integer when my collection is a String,	leading to an error.	I will attempt to resolve the conflict."	| output |		output := collection isString		ifTrue: [ aCharacterOrInteger isCharacter			ifTrue: [aCharacterOrInteger ]			ifFalse: [Character value: aCharacterOrInteger]]		ifFalse: [ aCharacterOrInteger isCharacter			ifTrue: [aCharacterOrInteger codePoint]			ifFalse: [aCharacterOrInteger]].	^ super nextPut: output</body></methods><methods><class-id>Grease.GRLatin1CodecStream</class-id> <category>streaming</category><body package="Grease-VisualWorks-Core">next	^ Character value: stream next</body><body package="Grease-VisualWorks-Core">next: anInteger	^(stream next: anInteger) asString</body></methods><methods><class-id>Grease.Author</class-id> <category>accessing</category><body package="Grease-VisualWorks-Core">fullName	^fullName isEmptyOrNil ifTrue: [#Anonymous &lt;&lt; #seaside &gt;&gt; 'Anonymous']</body><body package="Grease-VisualWorks-Core">fullName: aString	fullName := aString</body><body package="Grease-VisualWorks-Core">fullNamePerSe	"Answer the currently-prevailing author full name, such as it is, empty or not"	^fullName</body></methods><methods><class-id>Grease.Author</class-id> <category>initialize-release</category><body package="Grease-VisualWorks-Core">initialize	super initialize.	fullName := ''</body><body package="Grease-VisualWorks-Core">reset	fullName := ''</body></methods><methods><class-id>Grease.Author class</class-id> <category>instance creation</category><body package="Grease-VisualWorks-Core">new	self error: 'Author is a singleton -- send uniqueInstance instead'</body><body package="Grease-VisualWorks-Core">uniqueInstance	^uniqueInstance ifNil: [uniqueInstance := super new]</body></methods><methods><class-id>Grease.Author class</class-id> <category>accessing</category><body package="Grease-VisualWorks-Core">reset	^uniqueInstance := nil</body></methods><methods><class-id>Grease.Author class</class-id> <category>convenience</category><body package="Grease-VisualWorks-Core">fullName	"Seaside implements #fullName as a convenience method to acces the uniqueInstance fullName. In VisualWorks this conflicts with Behavior&gt;&gt;fullName."	^super fullName</body><body package="Grease-VisualWorks-Core">fullNamePerSe	^Author uniqueInstance fullNamePerSe</body></methods><methods><class-id>Grease.GRGenericCodec</class-id> <category>accessing</category><body package="Grease-VisualWorks-Core">encoder	^encoder</body><body package="Grease-VisualWorks-Core">name	"Answer a human readable string of the receivers encoding policy."	^name</body><body package="Grease-VisualWorks-Core">url	"Answer a codec that is responsible to encode and decode URLs. In most cases an UTF-8 codec is the only valid choice, but subclasses might decide to do something else."	^self</body></methods><methods><class-id>Grease.GRGenericCodec</class-id> <category>conversion</category><body package="Grease-VisualWorks-Core">decoderFor: aReadStream	^GRGenericCodecStream		on: (Protocols.DecodedStream on: aReadStream encodedBy: encoder)</body><body package="Grease-VisualWorks-Core">encoderFor: aWriteStream	^GRGenericCodecStream		on: (EncodedStream on: aWriteStream greaseBeUtf8Encoding encodedBy: encoder)</body></methods><methods><class-id>Grease.GRGenericCodec</class-id> <category>convenience</category><body package="Grease-VisualWorks-Core">decode: bytesInStringForm	| input output |	input := (bytesInStringForm copy changeClassTo: ByteArray) readStream.	output := String new writeStream.	[input atEnd] whileFalse: [output nextPut: (encoder nextFrom: input)].	^output contents</body><body package="Grease-VisualWorks-Core">encode: aString	| input output |	input := aString readStream.	output := ByteArray new writeStream.	[input atEnd] whileFalse: [encoder write: input next on: output].	^output contents changeClassTo: ByteString</body></methods><methods><class-id>Grease.GRGenericCodec</class-id> <category>initialize-release</category><body package="Grease-VisualWorks-Core">initialize: anEncodingName	name := anEncodingName.	encoder := StreamEncoder new: anEncodingName.	encoder skipRecord: PositionRecord new</body></methods><methods><class-id>Grease.GRGenericCodec class</class-id> <category>testing</category><body package="Grease-VisualWorks-Core">supportsEncoding: aString	^(StreamEncoder new: aString) notNil</body></methods><methods><class-id>Grease.GRGenericCodec class</class-id> <category>private</category><body package="Grease-VisualWorks-Core">basicForEncoding: anEncodingName	^self new initialize: anEncodingName</body></methods><methods><class-id>Grease.GRLatin1Codec</class-id> <category>convenience</category><body package="Grease-VisualWorks-Core">decode: aStringOrByteArray	"Overridden for efficiency."	^aStringOrByteArray asString</body></methods><methods><class-id>Grease.GRLatin1Codec</class-id> <category>conversion</category><body package="Grease-VisualWorks-Core">decoderFor: aReadStream	"wrap to avoid String vs ByteArray issues"	^GRLatin1CodecStream on: aReadStream</body><body package="Grease-VisualWorks-Core">encoderFor: aWriteStream	"wrap to avoid String vs ByteArray issues"	^GRLatin1CodecStream on: aWriteStream</body></methods><methods><class-id>Grease.GRLatin1Codec</class-id> <category>accessing</category><body package="Grease-VisualWorks-Core">name	^name</body></methods><methods><class-id>Grease.GRLatin1Codec</class-id> <category>initialization</category><body package="Grease-VisualWorks-Core">initializeWithName: aString	self initialize.	name := aString</body></methods><methods><class-id>Grease.GRLatin1Codec class</class-id> <category>accessing</category><body package="Grease-VisualWorks-Core">codecs	^Array with: (self basicForEncoding: 'iso-8859-1')</body></methods><methods><class-id>Grease.GRLatin1Codec class</class-id> <category>testing</category><body package="Grease-VisualWorks-Core">supportsEncoding: aString	"Answer whether the the given encoding name is supported."	^self supportedEncodingNames includes: aString</body></methods><methods><class-id>Grease.GRLatin1Codec class</class-id> <category>private</category><body package="Grease-VisualWorks-Core">basicForEncoding: aString	(self supportsEncoding: aString) ifFalse: [self unsupportedEncoding: aString].	^self basicNew initializeWithName: aString</body><body package="Grease-VisualWorks-Core">supportedEncodingNames	^#('iso-8859-1' 'ISO-8859-1' 'latin-1' 'latin1')</body></methods><methods><class-id>Grease.Year</class-id> <category>printing</category><body package="Grease-VisualWorks-Core">printOn: aStream	aStream nextPutAll: 'a Year ('. 	self start year printOn: aStream. 	aStream nextPutAll: ')'.</body></methods><methods><class-id>Grease.Year</class-id> <category>conversion</category><body package="Grease-VisualWorks-Core">asYear 	^ self</body></methods><methods><class-id>Grease.Year</class-id> <category>accessing</category><body package="Grease-VisualWorks-Core">daysInMonth 	self shouldNotImplement</body><body package="Grease-VisualWorks-Core">daysInYear	^ self duration days.</body></methods><methods><class-id>Grease.Year</class-id> <category>changes</category><body package="Grease-VisualWorks-Core">previous	"This implementation handles leap years correctly"		^ self class year: (self year - 1)</body></methods><methods><class-id>Grease.Year class</class-id> <category>squeak protocol</category><body package="Grease-VisualWorks-Core">current 	^ self year: (DateAndTime now year)</body><body package="Grease-VisualWorks-Core">isLeapYear: aYearInteger	| adjustedYear |	adjustedYear := aYearInteger &gt; 0		ifTrue: [aYearInteger]		ifFalse: [(aYearInteger + 1) negated].	"There was no year 0"	^ ((adjustedYear \\ 4 ~= 0) or: [(adjustedYear \\ 100 = 0) and: [adjustedYear \\ 400 ~= 0]]) not.</body><body package="Grease-VisualWorks-Core">starting: aDateAndTime duration: aDuration 	"Override - start from midnight"	| midnight |	midnight := aDateAndTime asDateAndTime midnight.	^ super		starting: midnight		duration: (Duration days: (self daysInYear: midnight year)).</body><body package="Grease-VisualWorks-Core">year: aYear	^ self starting: (DateAndTime year: aYear month: 1 day: 1).</body></methods><methods><class-id>Grease.Year class</class-id> <category>smalltalk-80</category><body package="Grease-VisualWorks-Core">daysInYear: yearInteger	^ 365 + ((self isLeapYear: yearInteger) ifTrue: [1] ifFalse: [0]).</body><body package="Grease-VisualWorks-Core">leapYear: yearInteger 	^ (self isLeapYear: yearInteger)		ifTrue: [1]		ifFalse: [0]</body></methods><methods><class-id>Grease.GreaseSystem</class-id> <category>default actions</category><body package="Grease-VisualWorks-Core">setUp	"This is the activation hook. It will be called automatically when the system is activated, normally on image startup.	Do Not Call This Directly.  If you want to manually start up or shut down a subsystem call #activate or #deactivate."	super setUp.	startUpTime := Time millisecondClockValue.	Grease.GRVisualWorksPlatform.StartUpList do: #startUp</body><body package="Grease-VisualWorks-Core">tearDown	"This is the deactivation hook. It will be called automatically when the system is deactivated, normally because the image is about to quit.	Do Not Call This Directly.  If you want to manually start up or shut down a subsystem call #activate or #deactivate."	startUpTime := nil.	Grease.GRVisualWorksPlatform.ShutDownList do: #shutDown.	super tearDown</body></methods><methods><class-id>Grease.GreaseSystem</class-id> <category>actions</category><body package="Grease-VisualWorks-Core">recordServerStartUp	serverStartUpTime := Time millisecondClockValue</body></methods><methods><class-id>Grease.GreaseSystem</class-id> <category>accessing</category><body package="Grease-VisualWorks-Core">serverStartUpTime	^serverStartUpTime</body><body package="Grease-VisualWorks-Core">serverUpTime	^Time millisecondClockValue - self serverStartUpTime</body><body package="Grease-VisualWorks-Core">startUpTime	^startUpTime</body><body package="Grease-VisualWorks-Core">upTime	^Time millisecondClockValue - self startUpTime</body></methods><methods><class-id>Grease.GreaseSystem class</class-id> <category>accessing</category><body package="Grease-VisualWorks-Core">serverUpTime	" Answer the server up time in milliseconds. "	" SeasideSystem serverUpTime "	^self current serverUpTime</body><body package="Grease-VisualWorks-Core">startUpTime	^self current startUpTime</body><body package="Grease-VisualWorks-Core">upTime	" Answer the up time in milliseconds. "	" SeasideSystem upTime "	^self current upTime</body></methods><methods><class-id>Grease.GreaseSystem class</class-id> <category>actions</category><body package="Grease-VisualWorks-Core">recordServerStartUp	self current recordServerStartUp</body></methods><methods><class-id>Grease.Month</class-id> <category>squeak protocol</category><body package="Grease-VisualWorks-Core">asMonth	^ self</body><body package="Grease-VisualWorks-Core">daysInMonth	^ self duration days.</body><body package="Grease-VisualWorks-Core">index	^ self monthIndex</body><body package="Grease-VisualWorks-Core">name 	^ self monthName</body><body package="Grease-VisualWorks-Core">previous 	^ self class starting: (self start - 1)</body><body package="Grease-VisualWorks-Core">printOn: aStream 	aStream nextPutAll: self monthName, ' ', self year printString.</body></methods><methods><class-id>Grease.Month class</class-id> <category>smalltalk-80</category><body package="Grease-VisualWorks-Core">daysInMonth: indexOrName forYear: yearInteger 	| index |	index := indexOrName isInteger 				ifTrue: [indexOrName]				ifFalse: [self indexOfMonth: indexOrName].	^ (DaysInMonth at: index)			+ ((index = 2					and: [Year isLeapYear: yearInteger])						ifTrue: [1] ifFalse: [0])</body><body package="Grease-VisualWorks-Core">indexOfMonth: aMonthName 	1 to: 12 do: [ :i |  (aMonthName, '*' match: (Smalltalk.MonthNames at: i)) ifTrue: [^i] ]. 	self error: aMonthName , ' is not a recognized month name'.</body><body package="Grease-VisualWorks-Core">nameOfMonth: anIndex	^ Smalltalk.MonthNames at: anIndex.</body></methods><methods><class-id>Grease.Month class</class-id> <category>squeak protocol</category><body package="Grease-VisualWorks-Core">month: month year: year	"Create a Month for the given &lt;year&gt; and &lt;month&gt;.	&lt;month&gt; may be a number or a String with the	name of the month. &lt;year&gt; should be with 4 digits."	^ self starting: (DateAndTime year: year month: month day: 1)</body><body package="Grease-VisualWorks-Core">readFrom: aStream	| m y c |	m := (ReadWriteStream with: '') reset.	[(c := aStream next) isSeparator] whileFalse: [m nextPut: c].	[(c := aStream next) isSeparator] whileTrue.	y := (ReadWriteStream with: '') reset.	y nextPut: c.	[aStream atEnd] whileFalse: [y nextPut: aStream next].	^ self 		month: (Month indexOfMonth: m contents)		year: y contents asNumber"Month readFrom: 'July 1998' readStream"</body><body package="Grease-VisualWorks-Core">starting: aDateAndTime duration: aDuration 	"Override - a each month has a defined duration"	| start adjusted days |	start := aDateAndTime asDateAndTime.	adjusted := DateAndTime				year: start year				month: start month				day: 1.	days := self daysInMonth: adjusted month forYear: adjusted year.	^ super		starting: adjusted		duration: (Duration days: days)</body></methods><methods><class-id>Grease.GRNotification class</class-id> <category>signalling</category><body package="Grease-VisualWorks-Core">signal	^self new raiseSignal</body><body package="Grease-VisualWorks-Core">signal: aString	^self new		messageText: aString;		raiseSignal</body></methods><methods><class-id>Grease.GRNotification</class-id> <category>private</category><body package="Grease-VisualWorks-Core">findHandlerContextFrom: startContext markDebug: inDebug	"****************		This method has been modified to SKIP propagation rules, which makes it incompatible with the regular VisualWorks exception workflow. Use with extreme caution, these notifications will no longer skip exception handlers that have already been checked during the execution of an exception handler action.	****************"	"Search for and return an appropriate handler. Set firstUnwindContext. 	 If no handler is found, return nil."	| ctx cm he firstSkip debugCtx |	ctx := searchContext := startContext.	firstSkip := nil.	[ctx == nil ifTrue: [^nil].		"no handler"	cm := ctx method.	cm isMarkedForHandle		ifTrue:	"Guard the sending of #handles: by ensuring the handlerException isExceptionHandler.				 #on:do: cannot efficiently enforce a type constraint on its exception signal argument."			[((he := ctx handlerException) isExceptionHandler and:				[he == GenericException ifTrue: [debugCtx := ctx].				he handles: self]) not]		ifFalse: 			[(firstUnwindContext == nil and: [firstSkip == nil]) ifTrue:				[cm isMarkedForUnwind ifTrue: [firstUnwindContext := ctx]].			ctx := ctx skipOverUnwindingBlocks.			true]]		whileTrue: 			[ctx := ctx findNextMarkedUpTo: nil].	(firstSkip notNil and: [firstUnwindContext == nil]) ifTrue:		["The first pass was inconclusive about the value of firstUnwindContext.		  Do it the hard way."		firstUnwindContext := firstSkip.		[firstUnwindContext == nil		or: [firstUnwindContext method isMarkedForUnwind]]			whileFalse:				[firstUnwindContext := firstUnwindContext findNextMarkedUpTo: ctx.				firstUnwindContext == nil ifFalse:					[firstUnwindContext := firstUnwindContext skipOverUnwindingBlocks]]].	^inDebug		ifTrue:			[debugCtx isNil				ifTrue: [debugCtx := self findDebugSignalHandlerCtxFrom: startContext orUntil: ctx].			debugCtx isNil				ifTrue: [ctx]				ifFalse: [debugCtx]]		ifFalse: [ctx]</body></methods><methods><class-id>Grease.GRNotification</class-id> <category>signalling</category><body package="Grease-VisualWorks-Core">signal	^self raiseSignal</body><body package="Grease-VisualWorks-Core">signal: aString	^self		messageText: aString;		raiseSignal</body></methods><methods><class-id>Grease.GRCodecStream</class-id> <category>accessing</category><body package="Grease-VisualWorks-Core">binary	stream binary</body><body package="Grease-VisualWorks-Core">nextAvailable: anumber	^stream nextAvailable: anumber</body><body package="Grease-VisualWorks-Core">position	^stream position</body><body package="Grease-VisualWorks-Core">position: aNumber	stream position: aNumber</body><body package="Grease-VisualWorks-Core">text	stream text</body></methods><methods><class-id>Grease.GRError class</class-id> <category>signalling</category><body package="Grease-VisualWorks-Core">signal	^self new raiseSignal</body><body package="Grease-VisualWorks-Core">signal: aString	^self new		messageText: aString;		raiseSignal</body></methods><methods><class-id>Grease.GRError</class-id> <category>signalling</category><body package="Grease-VisualWorks-Core">signal	^self raiseSignal</body><body package="Grease-VisualWorks-Core">signal: aString	^self		messageText: aString;		raiseSignal</body></methods><methods><class-id>Grease.DateAndTime</class-id> <category>printing</category><body package="Grease-VisualWorks-Core">printOn: aStream	"Format a respresentation of the receiver."	&lt;SeasideOverride&gt;	self printAsIso8601On: aStream</body></methods><methods><class-id>Core.Date</class-id> <category>accessing</category><body package="Grease-VisualWorks-Core">asMonth "	self today asMonth"	^ (Grease.DateAndTime year: self year day: self day hour: 0 minute: 0 second: 0) asMonth</body><body package="Grease-VisualWorks-Core">month	^ self asMonth</body></methods><methods><class-id>Kernel.GeneralBindingReference</class-id> <category>*pharo-fixup</category><body package="Grease-VisualWorks-Core">pharoValue	&lt;SeasideOverride&gt;	^self value</body></methods><methods><class-id>Core.Time class</class-id> <category>squeak protocol</category><body package="Grease-VisualWorks-Core">midnight	"(self midnight)"	"Answer a new instance at midnight."	^self fromSeconds: 0</body></methods><methods><class-id>Core.Float class</class-id> <category>constants access</category><body package="Grease-VisualWorks-Core">nan	^NaN</body><body package="Grease-VisualWorks-Core">negativeInfinity	^NegativeInfinity</body><body package="Grease-VisualWorks-Core">positiveInfinity	^PositiveInfinity</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>GRError</name><environment>Grease</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Exceptions</category><attributes><package>Grease-Core</package></attributes></class><class><name>Magnitude</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>WriteStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>ReadWriteStream</name><environment>Core</environment><super>Core.WriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Subsystem</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state canActivate prerequisites </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class><class><name>GRPlatform</name><environment>Grease</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core</category><attributes><package>Grease-Core</package></attributes></class><class><name>GRNotification</name><environment>Grease</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Exceptions</category><attributes><package>Grease-Core</package></attributes></class><class><name>GRCodecStream</name><environment>Grease</environment><super>Grease.GRDelegatingStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><class><name>GeneralBindingReference</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>path cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>GRCodec</name><environment>Grease</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>GRNullCodec</name><environment>Grease</environment><super>Grease.GRCodec</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><class><name>GRNullCodecStream</name><environment>Grease</environment><super>Grease.GRCodecStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class></st-source>