<?xml version="1.0"?><st-source><!-- Name: Seaside-Tests-CoreComment: Unit tests for the package Seaside-Core.DbIdentifier: bear73DbTrace: 494119DbUsername: jkottDbVersion: 3.2.0 - pmm.308 2DevelopmentPrerequisites: #(#(#any 'Seaside-Namespace' '') #(#any 'Seaside-Core' '') #(#any 'Seaside-VisualWorks-Core' '') #(#any 'Seaside-Session' '') #(#any 'Seaside-Environment' '') #(#any 'SUnitToo' '') #(#any 'Grease-Tests-Core' ''))Id: 9d6f674d-493c-4078-bc4f-ec4a5e01ba78Namespace: SeasidePackageName: Seaside-Tests-CoreParcel: #('Seaside-Tests-Core')ParcelName: Seaside-Tests-CorePrerequisiteDescriptions: #(#(#name 'Seaside-Namespace') #(#name 'Seaside-Core') #(#name 'Seaside-VisualWorks-Core') #(#name 'Seaside-Session' #componentType #package) #(#name 'Seaside-Environment' #componentType #package) #(#name 'SUnitToo' #componentType #package) #(#name 'Grease-Tests-Core'))PrerequisiteParcels: #(#('Seaside-Namespace' '') #('Seaside-Core' '') #('Seaside-VisualWorks-Core' '') #('Seaside-Session' '') #('Seaside-Environment' '') #('SUnitToo' '') #('Grease-Tests-Core' ''))PrintStringCache: (3.2.0 - pmm.308 2,jkott)Url: http://smalltalkhub.com/mc/Seaside/Seaside32/main/Seaside-Tests-Core-pmm.308.mczVersion: 3.2.0 - pmm.308 2Date: 12:17:55 PM September 16, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (sep16.3) of September 16, 2016 on September 16, 2016 at 12:17:55 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WACacheTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Cache</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAExpiringCacheTest</name><environment>Seaside</environment><super>Seaside.WACacheTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Cache</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAAcceptTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-HTTP</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAResponseTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>response </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-HTTP</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAComboResponseTest</name><environment>Seaside</environment><super>Seaside.WAResponseTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-HTTP</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAContextTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestContext </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-RequestHandling</category><attributes><package>Seaside-Tests-Core</package></attributes></class><comment><class-id>Seaside.WAContextTest</class-id><body>I am the base class for all tests that need a WARequestContext present.</body></comment><class><name>WARequestHandlerTest</name><environment>Seaside</environment><super>Seaside.WAContextTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handler dispatcher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-RequestHandling</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAMergedRequestFieldsTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>merged one two </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-HTTP</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAUrlTest</name><environment>Seaside</environment><super>Seaside.WAContextTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>url </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-HTTP</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WACallbackTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>registry log </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Callbacks</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WARegistryKeyHandlingTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>registry registrySize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-RequestHandling</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WARequestContextTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-RequestHandling</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAHeaderFieldsTest</name><environment>Seaside</environment><super>Grease.GROrderedMultiMapTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-HTTP</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WARequestTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-HTTP</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAHandlerTrackingStrategyTest</name><environment>Seaside</environment><super>Seaside.WAContextTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>strategy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-RequestHandling</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAQueryFieldHandlerTrackingStrategyTest</name><environment>Seaside</environment><super>Seaside.WAHandlerTrackingStrategyTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-RequestHandling</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WACookieTest</name><environment>Seaside</environment><super>Seaside.WAContextTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-HTTP</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WATestNoopRequestHandler</name><environment>Seaside</environment><super>Seaside.WARequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-RequestHandling</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WABacktrackingTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Backtracking</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAHtmlAttributesTest</name><environment>Seaside</environment><super>Seaside.WAContextTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Document</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WATestError</name><environment>Seaside</environment><super>Grease.GRError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WANextUnconsumedPathElementRequestHandler</name><environment>Seaside</environment><super>Seaside.WARequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nextUnconsumedPathElement </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-RequestHandling</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WABulkReapingCacheTest</name><environment>Seaside</environment><super>Seaside.WAExpiringCacheTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Cache</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAExceptionHandlerTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-RequestHandling</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAErrorHandlerTest</name><environment>Seaside</environment><super>Seaside.WAExceptionHandlerTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-RequestHandling</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WACollectionMimeDocumentTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>document </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-HTTP</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAHashCacheTest</name><environment>Seaside</environment><super>Seaside.WAExpiringCacheTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Cache</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAMimeDocumentTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-HTTP</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAResponseGeneratorTest</name><environment>Seaside</environment><super>Seaside.WAContextTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-RequestHandling</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAFileHandlerListingTest</name><environment>Seaside</environment><super>Seaside.WAContextTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Libraries</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WATestNoopSessionHandler</name><environment>Seaside</environment><super>Seaside.WARequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-RequestHandling</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAPrecomputedKeyGenerator</name><environment>Seaside</environment><super>Seaside.WAKeyGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keys current </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Cache</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WADispatcherTest</name><environment>Seaside</environment><super>Seaside.WARequestHandlerTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-RequestHandling</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WATestServerAdaptor</name><environment>Seaside</environment><super>Seaside.WAServerAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>status </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Server</category><attributes><package>Seaside-Tests-Core</package></attributes></class><comment><class-id>Seaside.WATestServerAdaptor</class-id><body>A WATestServerAdaptor is a stub of a server adaptor. It doesn't start an adaptor, it just pretends to allow testing of the server manager</body></comment><class><name>WAConfigurationTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Configuration</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAObjectTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WARegistryTest</name><environment>Seaside</environment><super>Seaside.WARequestHandlerTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-RequestHandling</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WALocaleTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-HTTP</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WADocumentHandlerResponseTest</name><environment>Seaside</environment><super>Seaside.WAContextTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-RequestHandling</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAMimeTypeTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-HTTP</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAEncoderTest</name><environment>Seaside</environment><super>Seaside.WAContextTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Document</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAPlatformTest</name><environment>Seaside</environment><super>Grease.GRPlatformTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAAbstractHtmlElementTest</name><environment>Seaside</environment><super>Seaside.WAContextTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Document</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAMetaElementTest</name><environment>Seaside</environment><super>Seaside.WAAbstractHtmlElementTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Document</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WABidirectionalCacheTest</name><environment>Seaside</environment><super>Seaside.WACacheTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Cache</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WATestingFiles</name><environment>Seaside</environment><super>Seaside.WAFileLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Libraries</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAForbiddenFileHandlerListingTest</name><environment>Seaside</environment><super>Seaside.WAFileHandlerListingTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Libraries</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WADynamicVariableTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Utilities</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAFileHandlerTest</name><environment>Seaside</environment><super>Seaside.WARequestHandlerTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Libraries</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WABufferedResponseTest</name><environment>Seaside</environment><super>Seaside.WAResponseTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-HTTP</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAConfigurationMock</name><environment>Seaside</environment><super>Seaside.WASystemConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>describeBlock parentsBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Configuration</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAUnidirectionalCacheTest</name><environment>Seaside</environment><super>Seaside.WACacheTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Cache</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAFileTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>file </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-HTTP</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WATestingMetadataFileLibrary</name><environment>Seaside</environment><super>Seaside.WAFileMetadataLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Libraries</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAFileLibraryTest</name><environment>Seaside</environment><super>Seaside.WAContextTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Libraries</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAKeyGeneratorTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Utilities</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAMutexTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mutex process process2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Utilities</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAHttpVersionTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-HTTP</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WADocumentHandlerTest</name><environment>Seaside</environment><super>Seaside.WARequestHandlerTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-RequestHandling</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAServerManagerTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>adaptor manager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Server</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAFileMetadataLibraryTest</name><environment>Seaside</environment><super>Seaside.WAContextTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Libraries</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WARequestFieldsTest</name><environment>Seaside</environment><super>Grease.GROrderedMultiMapTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-HTTP</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAPathConsumerTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>consumer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-RequestHandling</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAObjectUnderstandingUnregistered</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hasReceivedUnregistered </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Cache</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WAStreamedResponseTest</name><environment>Seaside</environment><super>Seaside.WAResponseTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-HTTP</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WARenderContextTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Rendering</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WACurrentRequestContextTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-RequestHandling</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WATextFileHandlerListingTest</name><environment>Seaside</environment><super>Seaside.WAFileHandlerListingTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-Libraries</category><attributes><package>Seaside-Tests-Core</package></attributes></class><methods><class-id>Seaside.WACacheTest</class-id> <category>testing</category><body package="Seaside-Tests-Core">testAtPut	1 to: 100 do: [ :i |		| absent mapped |		absent := false.		cache at: i ifAbsent: [ absent := true ].		self assert: absent.		mapped := cache at: i put: i greaseString.		self assert: mapped = i greaseString.		mapped := cache at: i ifAbsent: [ self assert: false ].		self assert: mapped = i greaseString ]</body><body package="Seaside-Tests-Core">testAtPutOverwrite	1 to: 100 do: [ :i |		| absent mapped |		absent := false.		cache at: i ifAbsent: [ absent := true ].		self assert: absent.		cache at: i put: 'zork'.		mapped := cache at: i put: i greaseString.		self assert: mapped = i greaseString.		mapped := cache at: i ifAbsent: [ self assert: false ].		self assert: mapped = i greaseString ]</body><body package="Seaside-Tests-Core">testKeysAndValuesDo	| reference readBack |	reference := Dictionary new.	1 to: 100 do: [ :i |		cache at: i put: i greaseString.		reference at: i put: i greaseString ].		readBack := Dictionary new.	cache keysAndValuesDo: [ :key :value |		readBack at: key put: value ].		self assert: readBack = reference</body><body package="Seaside-Tests-Core">testStore	| generator |	generator := WAPrecomputedKeyGenerator keys: #(1 1 1 2 2 2 3).	WAKeyGenerator		use: generator		during: [			self assert: (cache store: 'key1') = 1.			self assert: (cache store: 'key2') = 2.			self assert: (cache store: 'key3') = 3 ]</body></methods><methods><class-id>Seaside.WACacheTest</class-id> <category>running</category><body package="Seaside-Tests-Core">setUp	cache := self createCache</body></methods><methods><class-id>Seaside.WACacheTest</class-id> <category>private</category><body package="Seaside-Tests-Core">createCache	self subclassResponsibility</body></methods><methods><class-id>Seaside.WACacheTest class</class-id> <category>testing</category><body package="Seaside-Tests-Core">isAbstract	^ self name = #WACacheTest</body></methods><methods><class-id>Seaside.WAExpiringCacheTest</class-id> <category>testing</category><body package="Seaside-Tests-Core">testCopy	| copy absent |	cache at: 1 put: '1'.	cache at: 2 put: '2'.	copy := cache copy.		copy at: 1 put: '1a'.	copy at: 3 put: '3'.		"cache:		1 -&gt; '1'		2 -&gt; '2'	copy:		1 -&gt; '1a'		2 -&gt; '2'		3 -&gt; '3'	"		self assert: (cache at: 1 ifAbsent: [ self assert: false ]) = '1'.	self assert: (cache at: 2 ifAbsent: [ self assert: false ]) = '2'.	absent := false.	cache at: 3 ifAbsent: [ absent := true ].	self assert: absent.		self assert: (copy at: 1 ifAbsent: [ self assert: false ]) = '1a'.	self assert: (cache at: 2 ifAbsent: [ self assert: false ]) = '2'.	self assert: (copy at: 3 ifAbsent: [ self assert: false ]) = '3'</body><body package="Seaside-Tests-Core">testRmoveKey	cache at: 1 put: '1'.	cache at: 2 put: '2'.	self assert: cache size = 2.		self assert: (cache removeKey: 2) = '2'.	self assert: cache size = 1.		self assert: (cache at: 1 ifAbsent: [ nil ]) = '1'.	self assert: (cache at: 2 ifAbsent: [ #missing ]) = #missing.</body></methods><methods><class-id>Seaside.WAExpiringCacheTest</class-id> <category>running</category><body package="Seaside-Tests-Core">createCache	^ WAHashCache		initialSize: 13		maximumSize: 0		maximumAbsoluteAge: 0		maximumRelativeAge: 0		overflowAction: WAHashCache signalError</body></methods><methods><class-id>Seaside.WAExpiringCacheTest class</class-id> <category>testing</category><body package="Seaside-Tests-Core">isAbstract	^ self name = #WAExpiringCacheTest</body></methods><methods><class-id>Seaside.WAAcceptTest</class-id> <category>private</category><body package="Seaside-Tests-Core">assert: anArray at: anInteger charset: aString quality: aFloat	| value |	value := (anArray at: anInteger).	self assert: (value isKindOf: WAQualifiedValue).	self assert: value quality = aFloat.		self assert: value value = aString</body><body package="Seaside-Tests-Core">assert: anArray at: anInteger encoding: aString quality: aFloat	self assert: anArray at: anInteger charset: aString quality: aFloat</body><body package="Seaside-Tests-Core">assert: anArray at: anInteger language: aLanguageString country: aCountryString quality: aFloat	| value mimeType |	value := (anArray at: anInteger).	self assert: (value isKindOf: WAQualifiedValue).	self assert: value quality = aFloat.		mimeType := value value.	self assert: (mimeType isKindOf: WALocale).	self assert: (mimeType language = aLanguageString).	self assert: (mimeType country = aCountryString)</body><body package="Seaside-Tests-Core">assert: anArray at: anInteger main: aMainString sub: aSubString quality: aFloat	| value mimeType |	value := (anArray at: anInteger).	self assert: (value isKindOf: WAQualifiedValue).	self assert: value quality = aFloat.		mimeType := value value.	self assert: (mimeType isKindOf: WAMimeType).	self assert: (mimeType main = aMainString).	self assert: (mimeType sub = aSubString)</body></methods><methods><class-id>Seaside.WAAcceptTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testIe6	| accept acceptLanguage acceptEncoding |	accept := WAAccept fromString: 'image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, application/vnd.ms-excel, application/msword, application/vnd.ms-powerpoint, application/x-shockwave-flash, */*'.	self assert: accept size = 9.	self assert: accept at: 1 main: 'image' sub: 'gif' quality: 1.0.	self assert: accept at: 2 main: 'image' sub: 'x-xbitmap' quality: 1.0.	self assert: accept at: 3 main: 'image' sub: 'jpeg' quality: 1.0.	self assert: accept at: 4 main: 'image' sub: 'pjpeg' quality: 1.0.	self assert: accept at: 5 main: 'application' sub: 'vnd.ms-excel' quality: 1.0.	self assert: accept at: 6 main: 'application' sub: 'msword' quality: 1.0.	self assert: accept at: 7 main: 'application' sub: 'vnd.ms-powerpoint' quality: 1.0.	self assert: accept at: 8 main: 'application' sub: 'x-shockwave-flash' quality: 1.0.	self assert: accept at: 9 main: '*' sub: '*' quality: 1.0.		acceptEncoding := WAAcceptEncoding fromString: 'gzip, deflate'.	self assert: acceptEncoding size = 2.	self assert: acceptEncoding at: 1 encoding: 'gzip' quality: 1.0.	self assert: acceptEncoding at: 2 encoding: 'deflate' quality: 1.0.		acceptLanguage := WAAcceptLanguage fromString: 'de-ch'.	self assert: acceptLanguage size = 1.	self assert: acceptLanguage at: 1 language: 'de' country: 'ch' quality: 1.0</body><body package="Seaside-Tests-Core">testIssue655	| accept |	accept := WAAccept fromString: 'text/html, image/gif, image/jpeg, *; q=.2, */*; q=.2'.	self assert: accept size = 5.	self assert: accept at: 1 main: 'text' sub: 'html' quality: 1.0.	self assert: accept at: 2 main: 'image' sub: 'gif' quality: 1.0.	self assert: accept at: 3 main: 'image' sub: 'jpeg' quality: 1.0.	self assert: accept at: 4 main: '*' sub: '*' quality: 0.2.	self assert: accept at: 5 main: '*' sub: '*' quality: 0.2</body><body package="Seaside-Tests-Core">testMozilla	| accept accpetLanguage acceptCharset acceptEncoding |	accept := WAAccept fromString: 'text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5'.	self assert: accept size = 7.	self assert: accept at: 1 main: 'text' sub: 'xml' quality: 1.0.	self assert: accept at: 2 main: 'application' sub: 'xml' quality: 1.0.	self assert: accept at: 3 main: 'application' sub: 'xhtml+xml' quality: 1.0.	self assert: accept at: 4 main: 'text' sub: 'html' quality: 0.9.	self assert: accept at: 5 main: 'text' sub: 'plain' quality: 0.8.	self assert: accept at: 6 main: 'image' sub: 'png' quality: 1.0.	self assert: accept at: 7 main: '*' sub: '*' quality: 0.5.		acceptCharset := WAAcceptCharset fromString: 'ISO-8859-1,utf-8;q=0.7,*;q=0.7'.	self assert: acceptCharset size = 3.	self assert: acceptCharset at: 1 charset: 'ISO-8859-1' quality: 1.0.	self assert: acceptCharset at: 2 charset: 'utf-8' quality: 0.7.	self assert: acceptCharset at: 3 charset: '*' quality: 0.7.		acceptEncoding := WAAcceptEncoding fromString: 'gzip,deflate'.	self assert: acceptEncoding size = 2.	self assert: acceptEncoding at: 1 encoding: 'gzip' quality: 1.0.	self assert: acceptEncoding at: 2 encoding: 'deflate' quality: 1.0.		accpetLanguage := WAAcceptLanguage fromString: 'de-de,de;q=0.8,en-us;q=0.5,en;q=0.3'.	self assert: accpetLanguage size = 4.	self assert: accpetLanguage at: 1 language: 'de' country: 'de' quality: 1.0.	self assert: accpetLanguage at: 2 language: 'de' country: nil quality: 0.8.	self assert: accpetLanguage at: 3 language: 'en' country: 'us' quality: 0.5.	self assert: accpetLanguage at: 4 language: 'en' country: nil quality: 0.3</body><body package="Seaside-Tests-Core">testRfc1	"http://tools.ietf.org/html/rfc2616#section-14.1"	| accept |	accept := WAAccept fromString: 'audio/*; q=0.2, audio/basic'.	self assert: accept size = 2.	self assert: accept at: 1 main: 'audio' sub: '*' quality: 0.2.	self assert: accept at: 2 main: 'audio' sub: 'basic' quality: 1.0</body><body package="Seaside-Tests-Core">testRfc2	"http://tools.ietf.org/html/rfc2616#section-14.1"	| accept |	accept := WAAccept fromString: 'text/plain; q=0.5, text/html, text/x-dvi; q=0.8, text/x-c'.	self assert: accept size = 4.	self assert: accept at: 1 main: 'text' sub: 'plain' quality: 0.5.	self assert: accept at: 2 main: 'text' sub: 'html' quality: 1.0.	self assert: accept at: 3 main: 'text' sub: 'x-dvi' quality: 0.8.	self assert: accept at: 4 main: 'text' sub: 'x-c' quality: 1.0</body><body package="Seaside-Tests-Core">testRfc3	"http://tools.ietf.org/html/rfc2616#section-14.1"	| accept |	accept := WAAccept fromString: 'text/*, text/html, text/html;level=1, */*'.	self assert: accept size = 4.	self assert: accept at: 1 main: 'text' sub: '*' quality: 1.0.	self assert: accept at: 2 main: 'text' sub: 'html' quality: 1.0.	self assert: accept at: 3 main: 'text' sub: 'html' quality: 1.0.	self assert: accept at: 4 main: '*' sub: '*' quality: 1.0</body><body package="Seaside-Tests-Core">testRfc4	"http://tools.ietf.org/html/rfc2616#section-14.1"	| accept |	accept := WAAccept fromString: 'text/*;q=0.3, text/html;q=0.7, text/html;level=1, text/html;level=2;q=0.4, */*;q=0.5'.	self assert: accept size = 5.	self assert: accept at: 1 main: 'text' sub: '*' quality: 0.3.	self assert: accept at: 2 main: 'text' sub: 'html' quality: 0.7.	self assert: accept at: 3 main: 'text' sub: 'html' quality: 1.0.	self assert: accept at: 4 main: 'text' sub: 'html' quality: 0.4.	self assert: accept at: 5 main: '*' sub: '*' quality: 0.5.		self assert: ((accept at: 3) value parameters at: 'level') = '1'.	self assert: ((accept at: 4) value parameters at: 'level') = '2'</body></methods><methods><class-id>Seaside.WAResponseTest</class-id> <category>private</category><body package="Seaside-Tests-Core">assertLines: anArray	self assert: self lines = anArray</body></methods><methods><class-id>Seaside.WAResponseTest</class-id> <category>accessing</category><body package="Seaside-Tests-Core">contents	"Answer a string of the complete response as it is sent to the client."		self subclassResponsibility</body><body package="Seaside-Tests-Core">lines	"Answer the response as an array of lines, to be used within the tests."	| result stream |	result := OrderedCollection new.	stream := self contents readStream.	[ stream atEnd ] whileFalse: [ result add: (stream greaseUpToAll: (String with: Character cr with: Character lf)) ].	^ result asArray</body><body package="Seaside-Tests-Core">response	"Answer the response under test."	^ response</body></methods><methods><class-id>Seaside.WAResponseTest</class-id> <category>tests-conveniance</category><body package="Seaside-Tests-Core">testAttachmentWithFileName	self response attachmentWithFileName: 'foo.txt'.	self assertLines: #('HTTP/1.1 200 OK' 'Content-Disposition: attachment; filename="foo.txt"' 'Content-Length: 0' '')</body><body package="Seaside-Tests-Core">testBasicAuthentication	self response basicAuthenticationRealm: 'seaside'.	self assertLines: #('HTTP/1.1 401 Unauthorized' 'WWW-Authenticate: Basic realm="seaside"' 'Content-Length: 0' '')</body><body package="Seaside-Tests-Core">testInlineWithFileName	self response inlineWithFileName: 'bar.txt'.	self assertLines: #('HTTP/1.1 200 OK' 'Content-Disposition: inline; filename="bar.txt"' 'Content-Length: 0' '')</body><body package="Seaside-Tests-Core">testRedirectTo	self response redirectTo: 'http://www.seaside.st/'.	self assertLines:  #('HTTP/1.1 302 Found' 'Location: http://www.seaside.st/' 'Content-Length: 0' '')</body><body package="Seaside-Tests-Core">testRefreshAfterLocation	self response refreshAfter: 3 seconds location: 'http://www.seaside.st/'.	self assertLines: #('HTTP/1.1 200 OK' 'Refresh: 3; http://www.seaside.st/' 'Content-Length: 0' '')</body><body package="Seaside-Tests-Core">testStrictTransportSecurity	self response strictTransportSecurity: 500 includeSubDomains: true.	self assert: (self response headerAt: 'Strict-Transport-Security') = 'max-age=500; includeSubDomains'.		self response strictTransportSecurity: 500 includeSubDomains: false.	self assert: (self response headerAt: 'Strict-Transport-Security') = 'max-age=500'</body></methods><methods><class-id>Seaside.WAResponseTest</class-id> <category>tests-cache</category><body package="Seaside-Tests-Core">testCacheFor	self response cacheFor: (Duration days: 1 hours: 0 minutes: 0 seconds: 0).	self assert: (self response headerAt: 'Pragma') isNil.	self assert: (self response headerAt: 'Expires') notNil.	self assert: (self response headerAt: 'Cache-Control') = 'max-age=86400'</body><body package="Seaside-Tests-Core">testCacheForever	self response cacheForever.	self assert: (self response headerAt: 'Pragma') isNil.	self assert: (self response headerAt: 'Expires') notNil.	self assert: (self response headerAt: 'Cache-Control') isNil</body><body package="Seaside-Tests-Core">testCacheForeverExpiryDate	| expiry delta |	expiry := self response cacheForeverExpiryDate.	delta := expiry - DateAndTime now.	self assert: delta days &gt; 7.	self assert: delta days &lt; 356</body><body package="Seaside-Tests-Core">testDefaultCache	self deny: (self response headers includesKey: 'Pragma').	self deny: (self response headers includesKey: 'Expires').	self deny: (self response headers includesKey: 'Cache-Control')</body><body package="Seaside-Tests-Core">testDeleteCookie	| cookie actual |	cookie := (WARequestCookie key: 'key' value: 'value')		pathUnencoded: '/highway/to/hell' codec: GRNullCodec new;		domain: 'hotel'		yourself.	self response deleteCookie: cookie.	self assert: self response cookies size = 1.	actual := self response cookies first.	self assert: cookie ~~ actual.	self assert: actual domain = 'hotel'.	self assert: actual path = '/highway/to/hell'</body><body package="Seaside-Tests-Core">testDoNotCache	self response doNotCache.	self assert: (self response headerAt: 'Pragma') = 'no-cache'.	self assert: (self response headerAt: 'Expires') notNil.	self assert: (self response headerAt: 'Cache-Control') = 'no-cache, max-age=0, must-revalidate, no-store'</body><body package="Seaside-Tests-Core">testDoNotCacheExpiryDate	| expiry delta |	expiry := self response doNotCacheExpiryDate.	delta := expiry - DateAndTime now.	self assert: delta days &lt; -7</body></methods><methods><class-id>Seaside.WAResponseTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testContentType	self response contentType: WAMimeType textHtml.	self assert: self response contentType = WAMimeType textHtml.		self response contentType: WAMimeType imagePng.	self assert: self response contentType = WAMimeType imagePng</body><body package="Seaside-Tests-Core">testIsCommitted	self deny: self response isCommitted.	self response contentType: 'text/html'.	self deny: self response isCommitted.	self response nextPutAll: 'Visit &lt;a href="http://www.seaside.st"&gt;seaside.st&lt;/a&gt;.'.	self assertLines: #('HTTP/1.1 200 OK' 'Content-Type: text/html' 'Content-Length: 53' '' 'Visit &lt;a href="http://www.seaside.st"&gt;seaside.st&lt;/a&gt;.')</body><body package="Seaside-Tests-Core">testStreaming	| stream |	self response notFound.		" This is a normal write stream that supports the standard WriteStream protocol. All Smalltalk dialects should support common messages such as #nextPut:, #nextPutAll:, #print:, #crlf, etc."	stream := self response stream.	stream nextPutAll: 'A long long way from home.'.	stream crlf.	stream nextPut: $!.	stream print: 123.		self assertLines: #('HTTP/1.1 404 Not Found' 'Content-Length: 32' '' 'A long long way from home.' '!123')</body></methods><methods><class-id>Seaside.WAResponseTest</class-id> <category>tests-documents</category><body package="Seaside-Tests-Core">testDocumentMimeType	self response document: 'alert("Seaside")' mimeType: 'text/javascript'.	self assertLines: #('HTTP/1.1 200 OK' 'Content-Type: text/javascript' 'Content-Length: 16' '' 'alert("Seaside")')</body><body package="Seaside-Tests-Core">testDocumentMimeTypeFileName	self response document: 'foo;bar;zork' mimeType: 'text/csv' fileName: 'table.csv'.	self assertLines: #('HTTP/1.1 200 OK' 'Content-Disposition: attachment; filename="table.csv"' 'Content-Type: text/csv' 'Content-Length: 12' '' 'foo;bar;zork')</body></methods><methods><class-id>Seaside.WAResponseTest</class-id> <category>tests-headers</category><body package="Seaside-Tests-Core">testHeadersAt	self assert: (self response headerAt: 'foo') isNil.	self response headerAt: 'foo' put: 'bar'.	self assert: (self response headerAt: 'foo') = 'bar'</body><body package="Seaside-Tests-Core">testHeadersAtAppend	self assert: (self response headerAt: 'foo' append: 'bar') = 'bar'.	self assert: (self response headerAt: 'foo') = 'bar'.	self assert: (self response headerAt: 'foo' append: 'zork') = 'zork'.	self assert: (self response headerAt: 'foo') = 'bar'.	self assert: (self response headers size) = 2</body><body package="Seaside-Tests-Core">testHeadersAtIfAbsent	self assert: (self response headerAt: 'foo' ifAbsent: [ 'zork' ]) = 'zork'.	self response headerAt: 'foo' put: 'bar'.	self assert: (self response headerAt: 'foo' ifAbsent: [ 'zork' ]) = 'bar'</body><body package="Seaside-Tests-Core">testHeadersAtPut	self assert: (self response headerAt: 'foo' put: 'bar') = 'bar'.	self assert: (self response headerAt: 'foo') = 'bar'.	self assert: (self response headerAt: 'foo' put: 'zork') = 'zork'.	self assert: (self response headerAt: 'foo') = 'zork'.	self assert: (self response headers size) = 1</body><body package="Seaside-Tests-Core">testHeadersRemoveAt	self response headerAt: 'foo' put: 'bar'.	self response headerAt: 'bar' put: 'baz'.	self assert: (self response removeHeaderAt: 'foo') = #('bar').	self assert: (self response removeHeaderAt: 'bar') = #('baz').	self assert: (self response headers isEmpty)</body></methods><methods><class-id>Seaside.WAResponseTest</class-id> <category>tests-status</category><body package="Seaside-Tests-Core">testCodes	| names codes |	names := #( authenticationFailed forbidden found gone internalError notFound notImplemented ).	codes := #( 401 403 302 410 500 404 501 ).	names with: codes do: [ :name :code | 		self response perform: name.		self assert: self response status = code.		self assert: self response message = (self response class messageForStatus: code) ]</body><body package="Seaside-Tests-Core">testMessage	self assert: self response message = 'OK'.		self response status: 404.	self assert: self response message = 'Not Found'.		self response status: 290.	self assert: self response message isNil.		self response status: 290 message: 'Seaside Rocks'.	self assert: self response message = 'Seaside Rocks'</body><body package="Seaside-Tests-Core">testStatus	self assert: self response status = 200.	self response status: 404.	self assert: self response status = 404</body></methods><methods><class-id>Seaside.WAResponseTest class</class-id> <category>testing</category><body package="Seaside-Tests-Core">isAbstract	^ self name = #WAResponseTest</body></methods><methods><class-id>Seaside.WAComboResponseTest</class-id> <category>accessing</category><body package="Seaside-Tests-Core">contents	| stream |	stream := WriteStream on: String new.	self response writeOn: stream.	^ stream contents</body><body package="Seaside-Tests-Core">response	^ super response ifNil: [ response := WAComboResponse external: (GRPlatform current writeCharacterStreamOn: (String new: 4096)) ]</body></methods><methods><class-id>Seaside.WAComboResponseTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testIsCommitted	super testIsCommitted.	self deny: self response isCommitted</body></methods><methods><class-id>Seaside.WAComboResponseTest</class-id> <category>tests-conveniance</category><body package="Seaside-Tests-Core">testEmptyAfterReset	| resetPossible |	resetPossible := self response		status: WAResponse statusNotFound;		attachmentWithFileName: 'upload.csv';		nextPutAll: 'the content';		resetIfPossible.	self assert: resetPossible.	self assertLines: #('HTTP/1.1 200 OK' 'Content-Length: 0' '')</body><body package="Seaside-Tests-Core">testResetThenWrite	| resetPossible |	resetPossible := self response		status: WAResponse statusNotFound;		attachmentWithFileName: 'upload.csv';		nextPutAll: 'the wrong content';		resetIfPossible.	self assert: resetPossible.	self response		status: WAResponse statusImATeapot;		headerAt: 'X-The-Header' put: 'the value';		nextPutAll: 'the real content'.	self assertLines: #('HTTP/1.1 418 I''m a teapot' 'X-The-Header: the value' 'Content-Length: 16' '' 'the real content')</body></methods><methods><class-id>Seaside.WAContextTest</class-id> <category>utilities</category><body package="Seaside-Tests-Core">requestContextWithUrl: aUrlOrString	self requestContextWithUrl: aUrlOrString cookies: Array new</body><body package="Seaside-Tests-Core">requestContextWithUrl: aUrlOrString cookies: aCollection	| handlers |	handlers := self requestContext handlers.	self requestContext		initializeWithRequest: 			((WARequest method: 'GET' uri: aUrlOrString)				setCookies: aCollection asArray;				yourself)		response: WABufferedResponse new		codec: self createCodec.	self requestContext handlers addAll: handlers</body><body package="Seaside-Tests-Core">responseAfter: aBlock	self requestContext response initialize.	aBlock on: WAResponseNotification do: [ :n | ].	^ self requestContext response</body></methods><methods><class-id>Seaside.WAContextTest</class-id> <category>configuration</category><body package="Seaside-Tests-Core">createCodec	^ GRNullCodec new</body><body package="Seaside-Tests-Core">createHandlers	^ #()</body><body package="Seaside-Tests-Core">createRequest	^ WARequest new</body><body package="Seaside-Tests-Core">createRequestContext	^ WARequestContext request: self createRequest response: self createResponse codec: self createCodec</body><body package="Seaside-Tests-Core">createResponse	^ WABufferedResponse new</body></methods><methods><class-id>Seaside.WAContextTest</class-id> <category>running</category><body package="Seaside-Tests-Core">performTest	requestContext := self createRequestContext.	WACurrentRequestContext 		use: self requestContext		during: [			self				pushAll: self createHandlers				during: [ super performTest ] ]</body></methods><methods><class-id>Seaside.WAContextTest</class-id> <category>accessing</category><body package="Seaside-Tests-Core">requestContext	^ requestContext</body></methods><methods><class-id>Seaside.WAContextTest</class-id> <category>private</category><body package="Seaside-Tests-Core">pushAll: aCollection during: aBlock	^ aCollection isEmpty		ifTrue: [ aBlock value ]		ifFalse: [			self requestContext				push: aCollection first				during: [ self pushAll: aCollection allButFirst during: aBlock ] ]</body></methods><methods><class-id>Seaside.WAContextTest class</class-id> <category>testing</category><body package="Seaside-Tests-Core">isAbstract	^ self name = #WAContextTest</body></methods><methods><class-id>Seaside.WARequestHandlerTest</class-id> <category>private</category><body package="Seaside-Tests-Core">handlerName	^ 'foo'</body><body package="Seaside-Tests-Core">newHandler	^ WARequestHandler new</body></methods><methods><class-id>Seaside.WARequestHandlerTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testAddFilter	| filter1 filter2 |	filter1 := WARequestFilter new.	filter2 := WARequestFilter new.	self assert: (handler addFilter: filter1) = filter1.	self assert: (handler addFilter: filter2) = filter2.	self assert: handler filters size = 2.	self assert: handler filters first = filter1.	self assert: handler filters last = filter2</body><body package="Seaside-Tests-Core">testAddFilterFirst	| filter1 filter2 filter3 |	filter1 := WARequestFilter new.	filter2 := WARequestFilter new.	filter3 := WARequestFilter new.	self assert: (handler addFilterFirst: filter1) = filter1.	self assert: (handler addFilterFirst: filter2) = filter2.	self assert: (handler addFilterFirst: filter3) = filter3.	self assert: handler filters size = 3.	self assert: handler filters first = filter3.	self assert: handler filters last = filter1</body><body package="Seaside-Tests-Core">testAddFilterLast	| filter1 filter2 filter3 |	filter1 := WARequestFilter new.	filter2 := WARequestFilter new.	filter3 := WARequestFilter new.	self assert: (handler addFilterLast: filter1) = filter1.	self assert: (handler addFilterLast: filter2) = filter2.	self assert: (handler addFilterLast: filter3) = filter3.	self assert: handler filters size = 3.	self assert: handler filters first = filter1.	self assert: handler filters last = filter3</body><body package="Seaside-Tests-Core">testCopyConfiguration	| config copy |	config := handler configuration.		copy := handler copy.		self assert: handler configuration == config.	self deny: copy configuration == handler configuration.	self deny: copy configuration isNil</body><body package="Seaside-Tests-Core">testCopyEmpty	| copied |	copied := handler copy.	self deny: handler == copied.	self assert: handler filter == handler.	self assert: copied filter == copied</body><body package="Seaside-Tests-Core">testCopyFilters	| copied |	handler addFilter: WARequestFilter new.	handler addFilter: WARequestFilter new.	copied := handler copy.	self deny: handler == copied.	self deny: handler filter == copied filter.	self deny: handler filter next == copied filter next.	self assert: handler filter handler == handler.	self assert: copied filter handler == copied</body><body package="Seaside-Tests-Core">testCopyParent	| parent copy |	parent := WADispatcher new.	handler setParent: parent.		copy := handler copy.		self assert: handler parent == parent.	self assert: copy parent isNil</body><body package="Seaside-Tests-Core">testHandler	| filter1 filter2 |	filter1 := handler addFilter: WARequestFilter new.	filter2 := handler addFilter: WARequestFilter new.	self assert: handler handler = handler.	self assert: filter1 handler = handler.	self assert: filter2 handler = handler</body><body package="Seaside-Tests-Core">testPreferenceAt	handler configuration addParent:		(WAConfigurationMock new			description: [ :config | (config string: #foo) default: #bar ];			yourself).	self assert: (handler preferenceAt: #foo) = #bar.	handler preferenceAt: #foo put: #baz.	self assert: (handler preferenceAt: #foo) = #baz.	handler preferenceAt: #foo put: nil.	self deny: (handler configuration hasExpressionAt: #foo).	self should: [ handler preferenceAt: #missing ] raise: WAAttributeNotFound</body><body package="Seaside-Tests-Core">testRemoveFilter	| filter1 filter2 |	handler addFilter: (filter1 := WARequestFilter new).	handler addFilter: (filter2 := WARequestFilter new).	self assert: (handler removeFilter: WARequestFilter new) isNil.	self assert: (handler removeFilter: filter1) = filter1.	self assert: handler filters size = 1.	self assert: handler filters first = filter2.	self assert: (handler removeFilter: filter2) = filter2.	self assert: handler filters isEmpty.	self assert: (handler removeFilter: filter2) isNil</body><body package="Seaside-Tests-Core">testRemoveFromOldParent	| parent parent2 |	parent := WADispatcher new.	parent register: handler at: 'crepe'.	self assert: handler parent == parent.	self assert: (parent handlers includes: handler).		parent2 := WADispatcher new.	parent2 register: handler at: 'suzette'.	self assert: handler parent == parent2.	self assert: (parent2 handlers includes: handler).	self deny: (parent handlers includes: handler)</body></methods><methods><class-id>Seaside.WARequestHandlerTest</class-id> <category>running</category><body package="Seaside-Tests-Core">setUp	super setUp.	dispatcher := WADispatcher new.	handler := self newHandler.	dispatcher register: handler at: self handlerName</body></methods><methods><class-id>Seaside.WARequestHandlerTest class</class-id> <category>testing</category><body package="Seaside-Tests-Core">isAbstract	^ self name = #WARequestHandlerTest</body></methods><methods><class-id>Seaside.WAMergedRequestFieldsTest</class-id> <category>tests-enumerating</category><body package="Seaside-Tests-Core">testAssociationsDo	| keys values |	one at: 'foo' put: 1.	two at: 'bar' put: 2.	two at: 'foo' put: 3.	keys := OrderedCollection new.	values := OrderedCollection new.	merged associationsDo: [ :assoc | 		keys add: assoc key.		values add: assoc value ].	self assert: keys asArray = #('foo' 'bar' 'foo').	self assert: values asArray = #(1 2 3)</body><body package="Seaside-Tests-Core">testDo	| result |	one at: 'foo' put: 1.	two at: 'bar' put: 2.	two at: 'foo' put: 3.	result := OrderedCollection new.	merged do: [ :each | result add: each ].	self assert: result asArray = #(1 2 3)</body><body package="Seaside-Tests-Core">testKeys	one at: 'foo' put: 1.	two at: 'bar' put: 2.	two at: 'foo' put: 3.	self assert: merged keys asArray = #('foo' 'bar' 'foo')</body><body package="Seaside-Tests-Core">testKeysAndValuesDo	| keys values |	one at: 'foo' put: 1.	two at: 'bar' put: 2.	two at: 'foo' put: 3.	keys := OrderedCollection new.	values := OrderedCollection new.	merged keysAndValuesDo: [ :key :value | 		keys add: key.		values add: value ].	self assert: keys asArray = #('foo' 'bar' 'foo').	self assert: values asArray = #(1 2 3)</body><body package="Seaside-Tests-Core">testKeysDo	| result |	one at: 'foo' put: 1.	two at: 'bar' put: 2.	two at: 'foo' put: 3.	result := OrderedCollection new.	merged keysDo: [ :each | result add: each ].	self assert: result asArray = #('foo' 'bar' 'foo')</body><body package="Seaside-Tests-Core">testValues	one at: 'foo' put: 1.	two at: 'bar' put: 2.	two at: 'foo' put: 3.	self assert: merged values asArray = #(1 2 3)</body></methods><methods><class-id>Seaside.WAMergedRequestFieldsTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testKeyNotFound	self assert: (merged at: 'foo') isNil</body><body package="Seaside-Tests-Core">testReadOnly	self		should: [ merged at: 'foo' put: 1 ]		raise: Error.	self		should: [ merged at: 'foo' ifAbsentPut: [ 1 ] ]		raise: Error.	self		should: [ merged removeKey: 'foo' ]		raise: Error</body></methods><methods><class-id>Seaside.WAMergedRequestFieldsTest</class-id> <category>tests-accessing</category><body package="Seaside-Tests-Core">testAllAt	one at: 'one' put: 1.	one at: 'both' put: 1.	two at: 'two' put: 2.	two at: 'both' put: 2.		self assert: (merged allAt: 'one') = #(1).	self assert: (merged allAt: 'two') = #(2).	self assert: (merged allAt: 'both') = #(1 2).	self assert: (merged allAt: 'neither') = #()</body><body package="Seaside-Tests-Core">testAllAtIfAbsent	one at: 'one' put: 1.	one at: 'both' put: 1.	two at: 'two' put: 2.	two at: 'both' put: 2.		self assert: (merged allAt: 'one' ifAbsent: [ 'absent' ]) = #(1).	self assert: (merged allAt: 'two' ifAbsent: [ 'absent' ]) = #(2).	self assert: (merged allAt: 'both' ifAbsent: [ 'absent' ]) = #(1 2).	self assert: (merged allAt: 'neither' ifAbsent: [ 'absent' ]) = 'absent'</body><body package="Seaside-Tests-Core">testAt	one at: 'foo' put: 1.	two at: 'bar' put: 2.	self assert: (merged at: 'foo') = 1.	self assert: (merged at: 'bar') = 2.	two at: 'foo' put: 3.	self assert: (merged at: 'foo') = 1.	self assert: (merged at: 'zork') isNil</body><body package="Seaside-Tests-Core">testAtIfAbsent	one at: 'foo' put: 1.	two at: 'bar' put: 2.	self assert: (merged at: 'foo' ifAbsent: [ true ]) = 1.	self assert: (merged at: 'bar' ifAbsent: [ true ]) = 2.	two at: 'foo' put: 3.	self assert: (merged at: 'foo' ifAbsent: [ true ]) = 1.	self assert: (merged at: 'zork' ifAbsent: [ true ])</body><body package="Seaside-Tests-Core">testAtIfPresent	one at: 'foo' put: 1.	two at: 'bar' put: 2.	self assert: (merged 		at: 'foo' 		ifPresent: [ :value | self assert: value = 1. true ]).	self assert: (merged		at: 'bar'		ifPresent: [ :value | self assert: value = 2. true ]).	two at: 'foo' put: 3.	self assert: (merged 		at: 'foo' 		ifPresent: [ :value | self assert: value = 1. true ]).	merged		at: 'zork'		ifPresent: [ :value | self assert: false ]</body><body package="Seaside-Tests-Core">testSize	self assert: merged size = 0.	one at: 'foo' put: 1.	self assert: merged size = 1.	two at: 'foo' put: 2.	self assert: merged size = 2.	two at: 'bar' put: 4.	self assert: merged size = 3</body></methods><methods><class-id>Seaside.WAMergedRequestFieldsTest</class-id> <category>tests-testing</category><body package="Seaside-Tests-Core">testIncludesKey	one at: 'foo' put: 1.	two at: 'baz' put: 3.	two at: 'bar' put: 2.	two at: 'baz' put: 3.	self assert: (merged includesKey: 'foo').	self assert: (merged includesKey: 'bar').	self assert: (merged includesKey: 'baz').	self deny: (merged includesKey: 'zork')</body><body package="Seaside-Tests-Core">testIsEmpty	self assert: merged isEmpty.	two at: 'bar' put: 2.	self deny: merged isEmpty.	two removeKey: 'bar'.	one at: 'foo' put: 1.	self deny: merged isEmpty.	two at: 'foo' put: 2.	self deny: merged isEmpty</body></methods><methods><class-id>Seaside.WAMergedRequestFieldsTest</class-id> <category>running</category><body package="Seaside-Tests-Core">setUp	merged := WAMergedRequestFields on: (Array 		with: (one := WARequestFields new) 		with: (two := WARequestFields new))</body></methods><methods><class-id>Seaside.WAUrlTest</class-id> <category>running</category><body package="Seaside-Tests-Core">setUp	url := WAUrl new</body></methods><methods><class-id>Seaside.WAUrlTest</class-id> <category>testing-parsing</category><body package="Seaside-Tests-Core">absoluteExamples	^ #( 'http://www.seaside.st/'		 'http://www.seaside.st:8080/'		 'http://lukas@www.seaside.st/'		 'http://lukas:renggli@www.seaside.st/'		 'http://www.seaside.st/resources'		 'http://www.seaside.st/styles/favicon.png'		 'http://www.seaside.st/%24%26%2B%2C%2F%3A%3B%3D%3F%40'		 'http://www.seaside.st/#top'		 'http://www.seaside.st/styles#top'		 'http://www.seaside.st/about/screenshots?_c'		 'http://www.seaside.st/about/screenshots?_s=XrkNBpErXTKlVRhn'		 'http://www.seaside.st/about/screenshots?_s=XrkNBpErXTKlVRhn&amp;_k=lZWXfESZ'		 'http://www.seaside.st/about/screenshots?_s=XrkNBpErXTKlVRhn&amp;_k=lZWXfESZ&amp;_n&amp;47'		 'http://www.seaside.st/about/screenshots?_s=XrkNBpErXTKlVRhn&amp;_k=lZWXfESZ&amp;_n&amp;47#149361951'		 'http://www.seaside.st/;jsessionid=42?redirectcounter=1'		 'http://www.seaside.st/seaside/files;old/WAStandardFiles;key1=value1,value3;key2=value2/seaside.jpg;jsessionid=42?redirectcounter=1'		'http://www.seaside.st/seaside/WAStandardFiles;session%3Aid=42?redirectcounter=1'		 'http://lukas:renggli@www.seaside.st/about/screenshots?_s=XrkNBpErXTKlVRhn&amp;_k=lZWXfESZ&amp;_n&amp;47#149361951'		 'http://lukas:renggli@www.seaside.st:8080/about/screenshots?_s=XrkNBpErXTKlVRhn&amp;_k=lZWXfESZ&amp;_n&amp;47#149361951' )</body><body package="Seaside-Tests-Core">ambigousExamples	"These examples consist of many edge cases that are sometimes not quite legal. The test assures that they no error is thrown and that they parse to something meaningful anyway."		^ #( "scheme"		 ( 'www.seaside.st' '/www.seaside.st' )		 ( 'http://www.seaside.st:443/' 'http://www.seaside.st:443/' )		 ( 'https://www.seaside.st:80/' 'https://www.seaside.st:80/' )				 "port"		 ( 'http://www.seaside.st:/' 'http://www.seaside.st/' )				 "host"		 ( 'http://' '/' )		 ( 'http://@' '/' )				 "username, password"		 ( 'http://@www.seaside.st/' 'http://@www.seaside.st/' )		 ( 'http://:lukas@www.seaside.st/' 'http://:lukas@www.seaside.st/' )		 ( 'http://lukas:@www.seaside.st/' 'http://lukas:@www.seaside.st/' )				 "path"		 ( 'http://www.seaside.st' 'http://www.seaside.st/' )		 ( 'http://www.seaside.st//' 'http://www.seaside.st/' )		 ( 'http://www.seaside.st/.' 'http://www.seaside.st/' )		 ( 'http://www.seaside.st/./' 'http://www.seaside.st/' )		 ( 'http://www.seaside.st/..' 'http://www.seaside.st/' )		 ( 'http://www.seaside.st/../' 'http://www.seaside.st/' )				 "query"		 ( 'http://www.seaside.st/?' 'http://www.seaside.st/' )		 ( 'http://www.seaside.st/??' 'http://www.seaside.st/?%3F' )		 ( 'http://www.seaside.st/?=2' 'http://www.seaside.st/' )		 ( 'http://www.seaside.st/?&amp;' 'http://www.seaside.st/' )		 ( 'http://www.seaside.st/?1==' 'http://www.seaside.st/?1=%3D' )		 ( 'http://www.seaside.st/?1=2&amp;' 'http://www.seaside.st/?1=2' )		 				 "fragment"		 ( 'http://www.seaside.st/#' 'http://www.seaside.st/' )		 ( 'http://www.seaside.st/##' 'http://www.seaside.st/#%23' )		 ( 'http://www.seaside.st/#?a=b' 'http://www.seaside.st/#%3Fa%3Db' ) )</body><body package="Seaside-Tests-Core">equalExamples	"These examples about URI equivalence come from Sam Ruby and are quite hardcore. Java and Perl fail them, C# passes them.	http://intertwingly.net/blog/2004/07/31/URI-Equivalence"		^ #( 		 ( 'http://example.com/'				'http://example.com' )		 ( 'http://example.com/' 				'HTTP://example.com/' )		 ( 'http://example.com/' 				'http://example.com:/' )		 ( 'http://example.com/' 				'http://example.com:80/' )		 ( 'http://example.com/' 				'http://Example.com/' )		 ( 'http://example.com/~smith/'		'http://example.com/%7Esmith/' )		 ( 'http://example.com/~smith/'		'http://example.com/%7esmith/' )		 ( 'http://example.com/%7Esmith/'	'http://example.com/%7esmith/' )		 ( 'http://example.com/foo/bar/'		'http://example.com/foo//bar/' )		 ( 'http://example.com/foo/bar/'		'http://example.com/foo////bar/' )					"The following example requires Unicode normalization, something that probably only GemStone/S 3.2+ is able to perform.		 ( 'http://example.com/%C3%87'		'http://example.com/C%CC%A7' )" )</body><body package="Seaside-Tests-Core">invalidExamples	"These examples are not legal. The test assures that an error is thrown."		^ #(				 "port"		  'http://www.seaside.st:8x/'		  'http://www.seaside.st:x8/' )</body><body package="Seaside-Tests-Core">relativeExamples	^ #( ( 'http://www.seaside.st/foo' '' 'http://www.seaside.st/foo' )		 ( 'http://www.seaside.st/foo' '.' 'http://www.seaside.st/foo' )		 ( 'http://www.seaside.st/foo' './bar' 'http://www.seaside.st/foo/bar' )		 ( 'http://www.seaside.st/foo' 'bar' 'http://www.seaside.st/foo/bar' )		 ( 'http://www.seaside.st/foo' 'bar/.' 'http://www.seaside.st/foo/bar' )		 ( 'http://www.seaside.st/foo' 'bar/..' 'http://www.seaside.st/foo' )		 ( 'http://www.seaside.st/foo' 'bar/../..' 'http://www.seaside.st/' )		 ( 'http://www.seaside.st/foo' 'bar/../../..' 'http://www.seaside.st/' )		 ( 'http://www.seaside.st/foo' '/' 'http://www.seaside.st/' )		 ( 'http://www.seaside.st/foo' '/.' 'http://www.seaside.st/' )		 ( 'http://www.seaside.st/foo' '/./bar' 'http://www.seaside.st/bar' )		 ( 'http://www.seaside.st/foo' '/bar' 'http://www.seaside.st/bar' )		 ( 'http://www.seaside.st/foo' '/bar/.' 'http://www.seaside.st/bar' )		 ( 'http://www.seaside.st/foo' '/bar/..' 'http://www.seaside.st/' )		 ( 'http://www.seaside.st/foo' '/bar/../..' 'http://www.seaside.st/' )		 ( 'http://www.seaside.st/foo' '/bar/../../..' 'http://www.seaside.st/' ) )</body><body package="Seaside-Tests-Core">testIsSsl	url := WAUrl absolute: 'https://www.seaside.st/'.	self assert: url isSsl.	url := WAUrl absolute: 'http://www.seaside.st/'.	self deny: url isSsl.	url := WAUrl absolute: 'ftps://www.seaside.st/'.	self assert: url isSsl.	url := WAUrl absolute: 'ftp://www.seaside.st/'.	self deny: url isSsl.	self deny: WAUrl new isSsl</body><body package="Seaside-Tests-Core">testParseAbsolute	self absoluteExamples do: [ :each | 		self 			assert: (WAUrl absolute: each) greaseString = each			description: each			resumable: true ]</body><body package="Seaside-Tests-Core">testParseAmbigous	self ambigousExamples do: [ :each | 		self 			assert: (WAUrl absolute: each first) greaseString = each last			description: each last			resumable: true ]</body><body package="Seaside-Tests-Core">testParseEqual	self equalExamples do: [ :each |		self 			assert: (WAUrl absolute: each first) = (WAUrl absolute: each second)		 	description: each second resumable: true ]</body><body package="Seaside-Tests-Core">testParseInvalid	self invalidExamples do: [ :each | 		self 			should: [ WAUrl absolute: each ]			raise: WAInvalidUrlSyntaxError ]</body><body package="Seaside-Tests-Core">testParseRelative	self relativeExamples do: [ :each | 		self 			assert: (WAUrl 				absolute: each first				relative: each second) greaseString = each last			description: each last			resumable: true ]</body></methods><methods><class-id>Seaside.WAUrlTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testConversion	| converted |	url		host: 'example.com';		addToPath: 'foo';		addToPath: 'bar'.		converted := 'http://example.com/foo/bar' seasideUrl.		self assert: (converted isKindOf: WAUrl).	self assert: url = converted</body><body package="Seaside-Tests-Core">testFragment	url fragment: 'id'.	self assert: url fragment = 'id'.	self assert: url greaseString = '/#id'</body><body package="Seaside-Tests-Core">testHost	url host: 'seaside.st'.	self assert: url host = 'seaside.st'.	self assert: url greaseString = 'http://seaside.st/'</body><body package="Seaside-Tests-Core">testPassword	url		host: 'seaside.st';		user: 'foo';		password: 'bar'.	self assert: url password = 'bar'.	self assert: url greaseString = 'http://foo:bar@seaside.st/'</body><body package="Seaside-Tests-Core">testPath	self assert: url greaseString = '/'.	url path add: 'aa'.	self assert: url greaseString = '/aa'.	url path add: 'bb'.	self assert: url greaseString = '/aa/bb'.	self assert: url path asArray = #('aa' 'bb' )</body><body package="Seaside-Tests-Core">testPort	url		host: 'seaside.st';		port: 8080.	self assert: url port = 8080.	self assert: url greaseString = 'http://seaside.st:8080/'</body><body package="Seaside-Tests-Core">testQueryFields	url queryFields 		at: '1'		put: nil.	self assert: url greaseString = '/?1'.	url queryFields 		at: '2'		put: 'foo'.	self assert: url greaseString = '/?1&amp;2=foo'.	url queryFields 		at: '3'		put: 123.	self assert: url greaseString = '/?1&amp;2=foo&amp;3=123'.	url queryFields 		at: '4'		put: 'foo bar&amp;zork'.	self assert: url greaseString = '/?1&amp;2=foo&amp;3=123&amp;4=foo%20bar%26zork'.	url queryFields 		at: '1'		add: 'dupe'.	self assert: url greaseString = '/?1&amp;2=foo&amp;3=123&amp;4=foo%20bar%26zork&amp;1=dupe'</body><body package="Seaside-Tests-Core">testScheme	url		scheme: 'https';		host: 'seaside.st'.	self assert: url scheme = 'https'.	self assert: url greaseString = 'https://seaside.st/'.	"Tests from Boris"	url host: 'seaside.st'.	url		port: 80;		scheme: 'http'.	self assert: url greaseString = 'http://seaside.st/'.	url		port: 443;		scheme: 'https'.	self assert: url greaseString = 'https://seaside.st/'.	url		port: 80;		scheme: #http.	self assert: url greaseString = 'http://seaside.st/'.	url		port: 443;		scheme: #https.	self assert: url greaseString = 'https://seaside.st/'</body><body package="Seaside-Tests-Core">testSlash	url host: 'seaside.st'.	self assert: (url			slash: true;			greaseString) = 'http://seaside.st/'.	self assert: (url			slash: false;			greaseString) = 'http://seaside.st/'.	url addToPath: 'foo'.	self assert: (url			slash: true;			greaseString) = 'http://seaside.st/foo/'.	self assert: (url			slash: false;			greaseString) = 'http://seaside.st/foo'</body><body package="Seaside-Tests-Core">testTakeServerParametersFromRequest	| request |	request := WARequest new		setHeaders: (Dictionary new			at: 'host' put: 'www.seaside.st:8080';			yourself);		yourself.	url takeServerParametersFromRequest: request.	self assert: url printString = 'http://www.seaside.st:8080/'</body><body package="Seaside-Tests-Core">testTakeServerParametersFromRequestBase	| request |	request := (WARequest 		method: 'GET'		uri: (WAUrl new				scheme: 'https';				yourself))		setHeaders: (Dictionary new				at: 'host' put: 'www.thehost.com:1337';				yourself);		yourself.	url takeServerParametersFromRequest: request.	self assert: url greaseString = 'https://www.thehost.com:1337/'</body><body package="Seaside-Tests-Core">testTakeServerParametersFromRequestHttps	| request |	request := WARequest new		setHeaders: (Dictionary new				at: 'host' put: 'www.seaside.st';				at: 'base' put: 'foo/bar';				yourself);		yourself.	url takeServerParametersFromRequest: request.	self assert: url greaseString = 'http://www.seaside.st/foo/bar'</body><body package="Seaside-Tests-Core">testUser	url		host: 'seaside.st';		user: 'foo'.	self assert: url user = 'foo'.	self assert: url greaseString = 'http://foo@seaside.st/'</body><body package="Seaside-Tests-Core">testUserinfo	url		host: 'seaside.st';		userinfo: 'foo:bar'.	self assert: url userinfo = 'foo:bar'.	self assert: url greaseString = 'http://foo%3Abar@seaside.st/'.	"A colon needs to be escaped unless it is separating a (deprecated) password	part. This password part must be specified with #password: because we can't	tell the difference between the two types of colons in #userinfo:."	self assert: url user = 'foo:bar'.	self assert: url password isNil.	url user: 'foo'; password: 'bar'.	self assert: url userinfo = 'foo:bar'.	self assert: url user = 'foo'.	self assert: url password = 'bar'</body></methods><methods><class-id>Seaside.WAUrlTest</class-id> <category>tests-adding</category><body package="Seaside-Tests-Core">testAddAllToPath	url addAllToPath: #('files' 'WAStandardFiles' 'seaside.jpg' ).	self assert: url path size = 3.	self assert: url path first = 'files'.	self assert: url path last = 'seaside.jpg'.	self assert: url greaseString = '/files/WAStandardFiles/seaside.jpg'</body><body package="Seaside-Tests-Core">testAddField	url addField: 'x'.	self assert: url greaseString = '/?x'.	url addField: 'y'.	self assert: url greaseString = '/?x&amp;y'.	url addField: 'x'.	self assert: url greaseString = '/?x&amp;y&amp;x'</body><body package="Seaside-Tests-Core">testAddFieldValue	url 		addField: 'x'		value: 1.	self assert: url greaseString = '/?x=1'.	url 		addField: 'y'		value: 2.	self assert: url greaseString = '/?x=1&amp;y=2'.	url 		addField: 'x'		value: 3.	self assert: url greaseString = '/?x=1&amp;y=2&amp;x=3'</body><body package="Seaside-Tests-Core">testAddPathParameter	url addAllToPath: #('seaside' 'files' 'WAStandardFiles' 'seaside.jpg' ).	url addField: 'redirectcounter' value: 1.	url addPathParameterAt: 2 key: 'old'.	url addPathParameterAt: 3 key: 'key1' value: 'value1'.	url addPathParameterAt: 3 key: 'key2' value: 'value2'.	url addPathParameterAt: 3 key: 'key1' value: 'value3'.	url addPathParameterAt: 4 key: 'jsessionid' value: 42.		self assert: (url pathParameterAt: 1 key: 'jsessionid' ifAbsent: [ 'foo' ]) = 'foo'.	self assert: (url pathParameterAllAt: 1 key: 'jsessionid' ifAbsent: [ 'foo' ]) = 'foo'.		self assert: (url pathParameterAllAt: 2 key: 'jsessionid' ifAbsent: [ 'bar' ]) = 'bar'.	self assert: (url pathParameterAt: 2 key: 'jsessionid' ifAbsent: [ 'bar' ]) = 'bar'.	self assert: (url pathParameterAt: 2 key: 'old' ifAbsent: [ 'bar' ]) isNil.	self assert: (url pathParameterAllAt: 2 key: 'old' ifAbsent: [ 'bar' ]) = (Array with: nil).		self assert: (url pathParameterAt: 3 key: 'jsessionid' ifAbsent: [ 'bar' ]) = 'bar'.	self assert: (url pathParameterAllAt: 3 key: 'jsessionid' ifAbsent: [ 'bar' ]) = 'bar'.	self assert: (url pathParameterAt: 3 key: 'key1' ifAbsent: [ 'bar' ]) = 'value1'.	self assert: (url pathParameterAllAt: 3 key: 'key1' ifAbsent: [ 'bar' ]) = (Array with: 'value1' with: 'value3').	self assert: (url pathParameterAt: 3 key: 'key2' ifAbsent: [ 'bar' ]) = 'value2'.	self assert: (url pathParameterAllAt: 3 key: 'key2' ifAbsent: [ 'bar' ]) = (Array with: 'value2').		self assert: (url pathParameterAllAt: 4 key: 'key1' ifAbsent: [ 'bar' ]) = 'bar'.	self assert: (url pathParameterAt: 4 key: 'key1' ifAbsent: [ 'bar' ]) = 'bar'.	self assert: (url pathParameterAt: 4 key: 'jsessionid' ifAbsent: [ 'bar' ]) = 42.	self assert: (url pathParameterAllAt: 4 key: 'jsessionid' ifAbsent: [ 'bar' ]) = (Array with: 42).		self assert: url greaseString = '/seaside/files;old/WAStandardFiles;key1=value1,value3;key2=value2/seaside.jpg;jsessionid=42?redirectcounter=1'</body><body package="Seaside-Tests-Core">testAddToPathEmptyString	url addToPath: ''.	self assert: url path isEmpty.	self assert: url greaseString = '/'</body><body package="Seaside-Tests-Core">testAddToPathWithLeadingAndTrailingSlash	url addToPath: '/files/WAStandardFiles/'.	self assert: url path size = 2.	self assert: url path first = 'files'.	self assert: url path second = 'WAStandardFiles'.	self assert: url greaseString = '/files/WAStandardFiles/'</body><body package="Seaside-Tests-Core">testAddToPathWithLeadingSlash	url addToPath: '/files/WAStandardFiles/seaside.jpg'.	self assert: url path size = 3.	self assert: url path first = 'files'.	self assert: url path second = 'WAStandardFiles'.	self assert: url path third = 'seaside.jpg'.	self assert: url greaseString = '/files/WAStandardFiles/seaside.jpg'</body><body package="Seaside-Tests-Core">testAddToPathWithTrailingSlashOnly	url addToPath: 'files/WAStandardFiles/'.	self assert: url path size = 2.	self assert: url path first = 'files'.	self assert: url path second = 'WAStandardFiles'.	self assert: url greaseString = '/files/WAStandardFiles/'</body><body package="Seaside-Tests-Core">testAddToPathWithoutLeadingSlash	url addToPath: 'files/WAStandardFiles/seaside.jpg'.	self assert: url path size = 3.	self assert: url path first = 'files'.	self assert: url path second = 'WAStandardFiles'.	self assert: url path third = 'seaside.jpg'.	self assert: url greaseString = '/files/WAStandardFiles/seaside.jpg'</body><body package="Seaside-Tests-Core">testInvalidSyntax	"Regression test for:	http://code.google.com/p/seaside/issues/detail?id=762		ANSI #next	The result is undefined if there the receiver has no future sequence values."	self 		should: [ WAUrl decodePercent: 'abc%' ]		raise: WAInvalidUrlSyntaxError</body><body package="Seaside-Tests-Core">testPathStringUnencoded	self assert: url pathStringUnencoded = '/'.	url addAllToPath: #('files' 'WAStandardFiles' 'seaside.jpg' ).	self assert: url pathStringUnencoded = '/files/WAStandardFiles/seaside.jpg'.	url slash: true.	self assert: url pathStringUnencoded = '/files/WAStandardFiles/seaside.jpg/'</body></methods><methods><class-id>Seaside.WAUrlTest</class-id> <category>tests-comparing</category><body package="Seaside-Tests-Core">testEqual	url host: 'seaside.st'; addField: 'foo' value: 'bar'. 	self assert: url = url.	self deny: url = WAUrl new.	self deny: url = url printString.	self deny: url = (url withoutQuery).	self deny: url = (url withField: 'zork').	self deny: url = (url withField: 'zork' value: 'zonk')</body><body package="Seaside-Tests-Core">testHash	url host: 'seaside.st'.	self assert: url hash = url hash.	self assert: url hash = url copy hash</body></methods><methods><class-id>Seaside.WAUrlTest</class-id> <category>tests-encoding</category><body package="Seaside-Tests-Core">testDecodedWith	"http://Ã¹s:er:pa:Ã@localhost:8080/foo/Ã¤bc/dÃªf?Ãµ=stÃ®getc&amp;Ã´#tÃ¥rget"	| pathArray expectedPathArray |	url := (WAUrl absolute: 'http://%c3%b9s%3aer:pa%3A%c3%9f@localhost:8080/foo/%C3%A4bc/d%c3%aaf?%c3%b5=st%c3%aegetc&amp;%c3%b4#t%c3%a5rget') decodedWith: (GRCodec forEncoding: 'utf-8').	self assert: url scheme = 'http'.	self assert: url userinfo = (self asString: #(249 115 58 101 114 58 112 97 58 223 )).	self assert: url user = (self asString: #(249 115 58 101 114 )).	self assert: url password = (self asString: #(112 97 58 223 )).	self assert: url host = 'localhost'.	self assert: url port = 8080.	pathArray := url path asArray.	self assert: pathArray size = 3.	"must not use Collection &gt;&gt; #= due to Enterprise Smalltalk (tm)"	expectedPathArray := Array 		with: 'foo'		with: (self asString: #(228 98 99 ))		with: (self asString: #(100 234 102 )).	expectedPathArray keysAndValuesDo: [ :index :each | self assert: (pathArray at: index) = each ].	self assert: url queryFields size = 2.	self assert: (url queryFields at: (self asString: #(245 ))) = (self asString: #(					115					116					238					103					101					116					99				)).	self assert: (url queryFields includesKey: (self asString: #(244 ))).	self assert: (url queryFields at: (self asString: #(244 ))) isNil.	""	self assert: url fragment = (self asString: #(116 229 114 103 101 116 ))</body><body package="Seaside-Tests-Core">testNastyEdgeCasesParsing	url := (WAUrl absolute: 'http://example.com/blue+light%20blue?blue%2Blight+blue')		decodedWith: GRNullCodec new.	self assert: url path first = 'blue+light blue'.	self assert: (url queryFields includesKey: 'blue+light blue').		url := (WAUrl absolute: 'http://example.com/blue%2Fred%3Fand+green')		decodedWith: GRNullCodec new.	self assert: url path first = 'blue/red?and+green'.		url := (WAUrl absolute: 'http://example.com/:@-._~!$&amp;''()*+,=;:@-._~!$&amp;''()*+,=:@-._~!$&amp;''()*+,==?/?:@-._~!$''()*+,;=/?:@-._~!$''()*+,;==#/?:@-._~!$&amp;''()*+,;=')		decodedWith: GRNullCodec new.	self assert: url path first = ':@-._~!$&amp;''()*+,='.	self assert: (url pathParameterAllAt: 1 key: ':@-._~!$&amp;''()*+,' ifAbsent: [ 'fail' ]) = #(':@-._~!$&amp;''()*+' '==').	self assert: (url queryFields at: '/?:@-._~!$''()* ,;') = '/?:@-._~!$''()* ,;=='.	self assert: url fragment = '/?:@-._~!$&amp;''()*+,;='</body><body package="Seaside-Tests-Core">testNastyEdgeCasesSerialization	url host: 'example.com'.	url addToPath: 'blue+light blue'.	url queryFields at: 'blue+light blue' put: nil.	"legal but hardcore	self assert: url greaseString = 'http://example.com/blue+light%20blue?blue%2Blight+blue'"	self assert: url greaseString = 'http://example.com/blue%2Blight%20blue?blue%2Blight%20blue'</body><body package="Seaside-Tests-Core">testPathEncoding	url path: #( 'foo/bar' ).	self assert: url printString = '/foo%2Fbar'.	url path: #( 'foo bar' ).	self assert: url printString = '/foo%20bar'.	url path: #( 'foo+bar' ).	self assert: url printString = '/foo%2Bbar'.	url path: #( 'foo%bar' ).	self assert: url printString = '/foo%25bar'</body><body package="Seaside-Tests-Core">testPathString	self assert: (url pathStringEncodedWith: GRNullCodec new) = '/'.	url path: #( 'foo' 'bar' ).	self assert: (url pathStringEncodedWith: GRNullCodec new) = '/foo/bar'</body><body package="Seaside-Tests-Core">testQueryEmpty	self assert: url queryFields isEmpty.	self assert: url printString = '/'</body><body package="Seaside-Tests-Core">testQueryEncoding	self		assert: (url withField: '/' value: ' ')			printString = '/?%2F=%20'.	self		assert: (url withField: '+' value: '%')			printString = '/?%2B=%25'.	self		assert: (url withField: '?' value: '&amp;')			printString = '/?%3F=%26'.	self		assert: (url withField: '[' value: ']')			printString = '/?%5B=%5D'.	self		assert: (url withField: '=' value: '&lt;')			printString = '/?%3D=%3C'</body><body package="Seaside-Tests-Core">testQueryString	self assert: url queryString = ''.	url addField: 'foo'.	self assert: url queryString = 'foo'.	url addField: 'foo' value: 'bar'.	self assert: url queryString = 'foo&amp;foo=bar'.	url addField: 'foo#' value: 'bar#'.	self assert: url queryString = 'foo&amp;foo=bar&amp;foo%23=bar%23'</body><body package="Seaside-Tests-Core">testRelativeTo	| first second relativePath |	first := WAUrl absolute: 'http://www.seaside.st/news'.	second := WAUrl absolute: 'http://www.seaside.st/news/2008/April'.	relativePath := first relativeTo: second.	"we can not use #= here because of the Smalltalk that makes the easy parts more fucking tedious than Java"	self assert: relativePath size = 2.	self assert: relativePath first = '2008'.	self assert: relativePath second = 'April'</body></methods><methods><class-id>Seaside.WAUrlTest</class-id> <category>tests-copy</category><body package="Seaside-Tests-Core">testCopy	| copy |	url addToPath: 'foo/bar'.	url addField: 'foo' value: 'bar'.	copy := url copy.	url addToPath: 'zork'.	url addField: 'zork'.	self assert: url printString = '/foo/bar/zork?foo=bar&amp;zork'.	self assert: copy printString = '/foo/bar?foo=bar'</body><body package="Seaside-Tests-Core">testCopyWithPathParameter	| copy |	url addToPath: 'zork'.	copy := url copy.	url addPathParameterAt: 1 key: 'foo'.		self assert: url printString = '/zork;foo'.	self assert: copy printString = '/zork'</body><body package="Seaside-Tests-Core">testCopyWithPathParameterValue	| copy |	url addToPath: 'zork'.	copy := url copy.	url addPathParameterAt: 1 key: 'foo' value: 'bar'.	self assert: url printString = '/zork;foo=bar'.	self assert: copy printString = '/zork'</body><body package="Seaside-Tests-Core">testWith	| copy |	copy := url with: 'with'.	url addToPath: 'zork'.	url addField: 'zork'.	self assert: url printString = '/zork?zork'.	self assert: copy printString = '/with'</body><body package="Seaside-Tests-Core">testWithField	| copy |	copy := url withField: 'foo'.	url addToPath: 'zork'.	url addField: 'zork'.	self assert: url printString = '/zork?zork'.	self assert: copy printString = '/?foo'</body><body package="Seaside-Tests-Core">testWithFieldValue	| copy |	copy := url withField: 'foo' value: 'bar'.	url addToPath: 'zork'.	url addField: 'zork'.	self assert: url printString = '/zork?zork'.	self assert: copy printString = '/?foo=bar'</body><body package="Seaside-Tests-Core">testWithoutFragment	| copy |	url fragment: 'foo'.	copy := url withoutFragment.	url addToPath: 'zork'.	url addField: 'zork'.	self assert: url printString = '/zork?zork#foo'.	self assert: copy printString = '/'</body><body package="Seaside-Tests-Core">testWithoutQuery	| copy |	url addField: 'foo' value: 'bar'.	copy := url withoutQuery.	url addToPath: 'zork'.	url addField: 'zork'.	self assert: url printString = '/zork?foo=bar&amp;zork'.	self assert: copy printString = '/'</body></methods><methods><class-id>Seaside.WAUrlTest</class-id> <category>utilities</category><body package="Seaside-Tests-Core">asString: aCollectionOfIntegers	^ String streamContents: [ :stream |		aCollectionOfIntegers do: [ :each |			stream nextPut: (Character codePoint: each) ] ]</body></methods><methods><class-id>Seaside.WACallbackTest</class-id> <category>utilities</category><body package="Seaside-Tests-Core">assertLog: aCollection	self		assert: log asArray = aCollection asArray		description: 'Expected ' , aCollection asArray printString , ', but got ' , log asArray printString.	log := OrderedCollection new</body><body package="Seaside-Tests-Core">request: aRequestFields	"Processes a request with the fields given in aRequestFields."		| request context |	request := WARequest new setPostFields: aRequestFields; yourself.	context := WARequestContext request: request response: WAResponse new.	registry handle: context</body></methods><methods><class-id>Seaside.WACallbackTest</class-id> <category>running</category><body package="Seaside-Tests-Core">setUp	super setUp.	registry := WACallbackRegistry new.	log := OrderedCollection new</body></methods><methods><class-id>Seaside.WACallbackTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testAdvanceKey	self assert: registry advanceKey = '1'.	self assert: registry advanceKey = '2'.	self assert: registry advanceKey = '3'</body><body package="Seaside-Tests-Core">testNextKey	self assert: registry nextKey = '1'.	registry increaseKey.	self assert: registry nextKey = '2'.	self assert: registry nextKey = '2'</body></methods><methods><class-id>Seaside.WACallbackTest</class-id> <category>tests-callbacks</category><body package="Seaside-Tests-Core">testActionCallback	| key1 key2 |	key1 := registry store: (WAActionCallback on: [ log add: 1 ]).	key2 := registry store: (WAActionCallback on: [ log add: 2 ]).	" trigger first callback "	self 		should: 			[ self request: (WARequestFields new					at: key1						put: nil;					yourself) ]		raise: WARenderNotification.	self assertLog: #(1 ).	" trigger second callback "	self 		should: 			[ self request: (WARequestFields new					at: key2						put: nil;					yourself) ]		raise: WARenderNotification.	self assertLog: #(2 ).	" first callback has priority "	self 		should: 			[ self request: (WARequestFields new					at: key2						put: nil;					at: key1						put: nil;					yourself) ]		raise: WARenderNotification.	self assertLog: #(1 ).	" first callback is only triggered once "	self 		should: 			[ self request: (WARequestFields new					at: key1						put: nil;					at: key1						put: nil;					yourself) ]		raise: WARenderNotification.	self assertLog: #(1 )</body><body package="Seaside-Tests-Core">testCancelCallback	| keyValue keySave keyCancel |	keyValue := registry store: (WAValueCallback on: [ :v | log add: v ]).	keySave := registry store: (WAActionCallback on: [ log add: 'save' ]).	keyCancel := registry store: (WACancelActionCallback on: [ log add: 'cancel' ]).	" a save callback "	self 		should: 			[ self request: (WARequestFields new					at: keyValue						put: 'a';					at: keySave						put: nil;					yourself) ]		raise: WARenderNotification.	self assertLog: #('a' 'save' ).	self 		should: 			[ self request: (WARequestFields new					at: keySave						put: nil;					at: keyValue						put: 'b';					yourself) ]		raise: WARenderNotification.	self assertLog: #('b' 'save' ).	" a cancel callback "	self 		should: 			[ self request: (WARequestFields new					at: keyValue						put: 'a';					at: keyCancel						put: nil;					yourself) ]		raise: WARenderNotification.	self assertLog: #('cancel' ).	self 		should: 			[ self request: (WARequestFields new					at: keyCancel						put: nil;					at: keyValue						put: 'b';					yourself) ]		raise: WARenderNotification.	self assertLog: #('cancel' )</body><body package="Seaside-Tests-Core">testDefaultCallback	| keyValue keySave keyDefault |	keyValue := registry store: (WAValueCallback on: [ :v | log add: v ]).	keySave := registry store: (WAActionCallback on: [ log add: 'save' ]).	keyDefault := registry store: (WADefaultActionCallback on: [ log add: 'default' ]).	" a save callback "	self 		should: 			[ self request: (WARequestFields new					at: keyValue						put: 'a';					at: keySave						put: nil;					at: keyDefault						put: nil;					yourself) ]		raise: WARenderNotification.	self assertLog: #('a' 'save' ).	self 		should: 			[ self request: (WARequestFields new					at: keyDefault						put: nil;					at: keySave						put: nil;					at: keyValue						put: 'b';					yourself) ]		raise: WARenderNotification.	self assertLog: #('b' 'save' ).	" a default callback "	self 		should: 			[ self request: (WARequestFields new					at: keyValue						put: 'a';					at: keyDefault						put: nil;					yourself) ]		raise: WARenderNotification.	self assertLog: #('a' 'default' ).	self 		should: 			[ self request: (WARequestFields new					at: keyDefault						put: nil;					at: keyValue						put: 'b';					yourself) ]		raise: WARenderNotification.	self assertLog: #('b' 'default' )</body><body package="Seaside-Tests-Core">testDispatchCallback	| key key1 key2 |	key := registry store: WADispatchCallback new.	key1 := registry store: (WAValueCallback on: 			[ :v | log add: 1; add: v ]).	key2 := registry store: (WAValueCallback on: 			[ :v | log add: 2; add: v ]).	" an empty callback "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key put: nil;					yourself) ]		raise: WARenderNotification.	self assertLog: #().	" another empty callback "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key put: '';					yourself) ]		raise: WARenderNotification.	self assertLog: #().	" the first callback "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key put: key1;					yourself) ]		raise: WARenderNotification.	self assertLog: #(1 '' ).	" the second callback "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key put: key2;					yourself) ]		raise: WARenderNotification.	self assertLog: #(2 '' ).		" a double callback "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key put: key2;					at: key put: key2;					yourself) ]		raise: WARenderNotification.	self assertLog: #(2 '' )</body><body package="Seaside-Tests-Core">testImageCallback	| key |	key := registry store: (WAImageCallback on: [ log add: 1 ]).	" an invalid callback "	self 		shouldnt: [			self request: (WARequestFields new				at: key				put: nil;				yourself) ]		raise: WARenderNotification.	self assertLog: #().	" a valid callback "	self 		should:  [			self request: (WARequestFields new				at: key , '.x'				put: nil;				yourself) ]		raise: WARenderNotification.	self assertLog: #(1)</body><body package="Seaside-Tests-Core">testMapCallback	| key |	key := registry store: (WAMapCallback on: [ :v | log add: v ]).	" valid "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key						put: '?1,2';					yourself) ]		raise: WARenderNotification.	self assertLog: (Array with: 1 @ 2).	" valid "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key						put: '?1,23';					yourself) ]		raise: WARenderNotification.	self assertLog: (Array with: 1 @ 23).	" valid "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key						put: '?12,34';					yourself) ]		raise: WARenderNotification.	self assertLog: (Array with: 12 @ 34).	" invalid: no value "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key						put: nil;					yourself) ]		raise: WARenderNotification.	self assertLog: #().	" invalid: empty string "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key						put: '';					yourself) ]		raise: WARenderNotification.	self assertLog: #().	" invalid: invalid syntax "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key						put: '1,2';					yourself) ]		raise: WARenderNotification.	self assertLog: #().	" invalid: invalid syntax "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key						put: '?1';					yourself) ]		raise: WARenderNotification.	self assertLog: #().	" invalid: invalid syntax "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key						put: '?1,';					yourself) ]		raise: WARenderNotification.	" invalid: invalid syntax "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key						put: '?1x2';					yourself) ]		raise: WARenderNotification.	self assertLog: #().	" invalid: invalid syntax "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key						put: '?a,b';					yourself) ]		raise: WARenderNotification.	self assertLog: #()</body><body package="Seaside-Tests-Core">testMultiValuesCallback	| key key1 key2 dict |	dict := Dictionary new.	key1 := '1'.	key2 := '2'.	dict at: key1 greaseInteger put: '1a'.	dict at: key2 greaseInteger put: '2a'.	key := registry store: (WAMultipleValuesCallback				on: [ :v | log := v ]				values: dict).	"an empty callback"	self		shouldnt: [			self request: (WARequestFields new				at: key put: nil;				yourself) ]		raise: WARenderNotification.	self assert: log isEmpty.		" another empty callback "	self 		shouldnt: [			self request: (WARequestFields new				at: key put: '';				yourself) ]		raise: WARenderNotification.	self assert: log isEmpty.		" the first callback "	self 		shouldnt: [			self request: (WARequestFields new				at: key put: key1;				yourself) ]		raise: WARenderNotification.	self assertLog: #( '1a' ).		" the second callback "	self 		shouldnt: [			self request: (WARequestFields new				at: key add: key1;				at: key add: key2;				yourself) ]		raise: WARenderNotification.	self assertLog: #('1a' '2a' )</body><body package="Seaside-Tests-Core">testUploadCallback	| key file |	key := registry store: (WAUploadCallback on: [ :v | log add: v ]).	" nil uploads are ignored "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key						put: nil;					yourself) ]		raise: WARenderNotification.	self assertLog: #().	" string uploads are ignored "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key						put: 'foo';					yourself) ]		raise: WARenderNotification.	self assertLog: #().	" WAFile uploads are triggered "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key						put: (file := WAFile new);					yourself) ]		raise: WARenderNotification.	self assertLog: (Array with: file)</body><body package="Seaside-Tests-Core">testValueCallback	| key1 key2 |	key1 := registry store: (WAValueCallback on: 			[ :v | log add: 1; add: v ]).	key2 := registry store: (WAValueCallback on: 			[ :v | log add: 2; add: v ]).	" a single value callback with nil "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key1 put: nil;					yourself) ]		raise: WARenderNotification.	self assertLog: #(1 '' ).	" a single value callback with an empty string "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key1 put: '';					yourself) ]		raise: WARenderNotification.	self assertLog: #(1 '' ).	" a single value callback with a string "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key1 put: 'foo';					yourself) ]		raise: WARenderNotification.	self assertLog: #(1 'foo' ).	" a single value callback with a filled collection "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key1 add: 'foo';					at: key1 add: 'bar';					yourself) ]		raise: WARenderNotification.	self assertLog: #(1 'foo' ).	" two callbacks in order "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key1 put: 'b';					at: key2 put: 'c';					yourself) ]		raise: WARenderNotification.	self assertLog: #(1 'b' 2 'c' ).	" two callbacks not in order "	self 		shouldnt: 			[ self request: (WARequestFields new					at: key2 put: 'c';					at: key1 put: 'b';					yourself) ]		raise: WARenderNotification.	self assertLog: #(1 'b' 2 'c' )</body><body package="Seaside-Tests-Core">testValuesCallback	| key key1 key2 dict |	dict := Dictionary new.	key1 := '1'.	key2 := '2'.	dict at: key1 greaseInteger put: '1a'.	dict at: key2 greaseInteger put: '2a'.	key := registry store: (WAValuesCallback		on: [ :v | log add: v ]		values: dict).	"an empty callback"	self 		shouldnt: [			self request: (WARequestFields new				at: key				put: nil;				yourself) ]		raise: WARenderNotification.	self assertLog: #().		" another empty callback "	self 		shouldnt: [			self request: (WARequestFields new				at: key				put: '';			yourself) ]		raise: WARenderNotification.	self assertLog: #().		" the first callback "	self shouldnt: [		self request: (WARequestFields new			at: key			put: key1;			yourself) ]		raise: WARenderNotification.	self assertLog: #( '1a' ).		" the second callback "	self 		shouldnt: [			self request: (WARequestFields new				at: key				put: key2;				yourself) ]		raise: WARenderNotification.	self assertLog: #( '2a' )</body></methods><methods><class-id>Seaside.WARegistryKeyHandlingTest</class-id> <category>private</category><body package="Seaside-Tests-Core">assertCookieAddition: aResponse	| cookie |	self assert: aResponse cookies size = 1.	cookie := aResponse cookies first.	self assert: cookie path = self path.	self assert: cookie key = self cookieKey.	self assert: cookie discard</body><body package="Seaside-Tests-Core">assertCookieAddition: aResponse key: aString	self assertCookieAddition: aResponse.	self assert: aResponse cookies first value = aString</body><body package="Seaside-Tests-Core">assertCookieDeletion: aResponse	| cookie |	self assert: aResponse cookies size = 1.	cookie := aResponse cookies first.	self assert: cookie path = self path.	self assert: cookie key = self cookieKey.	self assert: cookie expiry &lt; (DateAndTime now - (Duration days: 1 hours: 0 minutes: 0 seconds: 0)).	self deny: cookie discard</body><body package="Seaside-Tests-Core">assertDefault: aResponse	self assert: registry cache size = registrySize.	self assert: aResponse status = 404</body><body package="Seaside-Tests-Core">assertDispatched: aResponse	self assert: registry cache size = registrySize.	self assert: aResponse status = 200</body><body package="Seaside-Tests-Core">assertExpired: aResponse	self assert: registry cache size = registrySize.	self assert: aResponse status = 302.	self assert: (aResponse headers at: 'Location') = self path</body><body package="Seaside-Tests-Core">assertNoCookies: aResponse	self assert: aResponse cookies isEmpty</body><body package="Seaside-Tests-Core">cookieKey	^ self fieldName</body><body package="Seaside-Tests-Core">createRegistry	^ WADispatcher new		register: (WARegistry new			cache: WABidirectionalCache new;			yourself)		at: self registryName</body><body package="Seaside-Tests-Core">createRegistryWithCookiesEnabled	"We have an instance variable named 'registry' and GemStone does not like 		method temps to have the same name as instance variables."	| newRegistry |	newRegistry := self createRegistry.	newRegistry configuration at: #trackingStrategy put: WACookieIfSupportedSessionTrackingStrategy new.	^ newRegistry</body><body package="Seaside-Tests-Core">createRequestContextWithFieldKey: fieldString cookieKey: cookieString	| fields cookies request |	fields := WARequestFields new.	fieldString isNil ifFalse: [ fields at: self fieldName put: fieldString ].	cookies := OrderedCollection new.	cookieString isNil ifFalse: [		| cookie |		cookie := (WARequestCookie key: self cookieKey value: cookieString)			pathUnencoded: self path encoded: self path;			yourself.		cookies add: cookie ].	request := (WARequest method: 'GET' uri: self path)		setPostFields: fields;		setCookies: cookies;		yourself.	^ WARequestContext request: request response: WABufferedResponse new</body><body package="Seaside-Tests-Core">dispatch: aRequestContext to: aRegistry	registrySize := aRegistry cache size.	self assert: aRequestContext consumer next = self registryName.	[ aRegistry handle: aRequestContext ]		on: WAResponseNotification		do: [ :n | ].			^ aRequestContext response</body><body package="Seaside-Tests-Core">fieldName	^ '_s'</body><body package="Seaside-Tests-Core">path	^ '/', self registryName</body><body package="Seaside-Tests-Core">registerNewHandler	^ registry register: WATestNoopRequestHandler new</body><body package="Seaside-Tests-Core">registryName	^ 'test'</body></methods><methods><class-id>Seaside.WARegistryKeyHandlingTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testCookiesDisabledFieldNoCookieHandlerAbsent	"Cookies are DISABLED.	There is a key in the URL, no cookie, but handler specified by key does not exist"		| response context |	registry := self createRegistry.	context := self createRequestContextWithFieldKey: '123' cookieKey: nil.	response := self dispatch: context to: registry.		"Behaviour should be the same as #testFieldNoCookieHandlerAbsent"	self assertNoCookies: response.	self assertExpired: response</body><body package="Seaside-Tests-Core">testCookiesDisabledFieldNoCookieHandlerPresent	"Cookies are DISABLED.	There is a key in the URL but no cookie. The handler specified by key exists."		| response context key |	registry := self createRegistry.	key := self registerNewHandler.	context := self createRequestContextWithFieldKey: key cookieKey: nil.	response := self dispatch: context to: registry.		self assertNoCookies: response.	self assertDispatched: response</body><body package="Seaside-Tests-Core">testCookiesDisabledMatchingHandlerAbsent	"Cookies are DISABLED.	There is a key in the URL and a cookie and the values match. However, the handler specified by key does not exist."		| response context |	registry := self createRegistry.	context := self createRequestContextWithFieldKey: '123' cookieKey: '123'.	response := self dispatch: context to: registry.		"Behaviour should be the same as #testFieldNoCookieHandlerAbsent."	self assertNoCookies: response.	self assertExpired: response</body><body package="Seaside-Tests-Core">testCookiesDisabledMatchingHandlerPresent	"Cookies are DISABLED.	There is a key in the URL and a cookie and the values match. The handler specified by key exists."		| response context key |	registry := self createRegistry.	key := self registerNewHandler.	context := self createRequestContextWithFieldKey: key cookieKey: key.	response := self dispatch: context to: registry.		"Behaviour should be the same as #testFieldNoCookieHandlerPresent."	self assertNoCookies: response.	self assertDispatched: response</body><body package="Seaside-Tests-Core">testCookiesDisabledMismatchingWithBothHandlers	"Cookies are DISABLED.	There is a key in the URL and a cookie but values do not match.	Both keys have registered handlers associated with them."		| response context urlKey cookieKey |	registry := self createRegistry.	urlKey := self registerNewHandler.	cookieKey := self registerNewHandler.	context := self createRequestContextWithFieldKey: urlKey cookieKey: cookieKey.	response := self dispatch: context to: registry.		"Behaviour should be the same as #testCookiesDisabledFieldNoCookieHandlerPresent."	self assertNoCookies: response.	self assertDispatched: response</body><body package="Seaside-Tests-Core">testCookiesDisabledMismatchingWithCookieHandler	"Cookies are DISABLED.	There is a key in the URL and a cookie but values do not match.	There is no handler registered at the URL key but there is one at the cookie key."		| response context key |	registry := self createRegistry.	key := self registerNewHandler.	context := self createRequestContextWithFieldKey: '123' cookieKey: key.	response := self dispatch: context to: registry.		"Behaviour should be the same as #testCookiesDisabledFieldNoCookieHandlerAbsent."	self assertNoCookies: response.	self assertExpired: response</body><body package="Seaside-Tests-Core">testCookiesDisabledMismatchingWithNoHandlers	"Cookies are DISABLED.	There is a key in the URL and a cookie but values do not match.	There is no handler registered at either key."		| response context |	registry := self createRegistry.	context := self createRequestContextWithFieldKey: '123' cookieKey: '456'.	response := self dispatch: context to: registry.		"Behaviour should be the same as #testCookiesDisabledFieldNoCookieHandlerAbsent."	self assertNoCookies: response.	self assertExpired: response</body><body package="Seaside-Tests-Core">testCookiesDisabledMismatchingWithUrlHandler	"Cookies are DISABLED.	There is a key in the URL and a cookie but values do not match.	There is a handler registered at the URL key but not at the cookie key."		| response context key |	registry := self createRegistry.	key := self registerNewHandler.	context := self createRequestContextWithFieldKey: key cookieKey: '123'.	response := self dispatch: context to: registry.		"Behaviour should be the same as #testCookiesDisabledFieldNoCookieHandlerPresent."	self assertNoCookies: response.	self assertDispatched: response</body><body package="Seaside-Tests-Core">testCookiesDisabledNoFieldCookieHandlerAbsent	"Cookies are DISABLED.	There is no key in the URL but there is a cookie. However, the handler specified by key does not exist."		| response context |	registry := self createRegistry.	context := self createRequestContextWithFieldKey: nil cookieKey: '123'.	response := self dispatch: context to: registry.		"Behaviour should be the same as #testNoKey."	self assertNoCookies: response.	self assertDefault: response</body><body package="Seaside-Tests-Core">testCookiesDisabledNoFieldCookieHandlerPresent	"Cookies are DISABLED.	There is no key in the URL but there is a cookie. The handler specified by key exists."		| response context key |	registry := self createRegistry.	key := self registerNewHandler.	context := self createRequestContextWithFieldKey: nil cookieKey: key.	response := self dispatch: context to: registry.		"Behaviour should be the same as #testNoKey."	self assertNoCookies: response.	self assertDefault: response</body><body package="Seaside-Tests-Core">testCookiesDisabledNoKey	"Cookies are DISABLED.	There is no URL field and no cookie. This is a new request to the Registry."		| response context |	registry := self createRegistry.	context := self createRequestContextWithFieldKey: nil cookieKey: nil.	response := self dispatch: context to: registry.		"Behaviour should be the same as #testNoKey."	self assertNoCookies: response.	self assertDefault: response</body><body package="Seaside-Tests-Core">testNoKey	"Cookies are DISABLED.	There is no URL field and no cookie. This is a new request to the Registry."		| response context |	registry := self createRegistry.	context := self createRequestContextWithFieldKey: nil cookieKey: nil.	response := self dispatch: context to: registry.		self assertNoCookies: response.	self assertDefault: response</body></methods><methods><class-id>Seaside.WARequestContextTest</class-id> <category>configuration</category><body package="Seaside-Tests-Core">createCodec	^ GRNullCodec new</body><body package="Seaside-Tests-Core">createRequest	^ WARequest new</body><body package="Seaside-Tests-Core">createRequestContext	^ WARequestContext request: self createRequest response: self createResponse codec: self createCodec</body><body package="Seaside-Tests-Core">createResponse	^ WABufferedResponse new</body></methods><methods><class-id>Seaside.WARequestContextTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testNewDocumentNotHandler	"regression test for	http://code.google.com/p/seaside/issues/detail?id=653"	| context document |	context := self createRequestContext.	document := context newDocument.	self assert: document notNil</body></methods><methods><class-id>Seaside.WAHeaderFieldsTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testCrLf	| crlf testValue |	crlf := String with: Character cr with: Character lf.	testValue := 'value', crlf, 'Location: www.bad.com', crlf, crlf.	self		should: [			collection add: 'key' -&gt; testValue ]		raise: WAInvalidHeaderValueError.	self		should: [			collection addAll: (Dictionary new				add: 'key' -&gt; testValue;				yourself) ]		raise: WAInvalidHeaderValueError.	self		should: [			collection at: 'key' add: testValue ]		raise: WAInvalidHeaderValueError.	self		should: [			collection at: 'key' put: testValue ]		raise: WAInvalidHeaderValueError.	self		should: [			collection at: 'key' ifAbsentPut: [ testValue ] ]		raise: WAInvalidHeaderValueError.	self		should: [			collection at: 'key' put: testValue ]		raise: WAInvalidHeaderValueError</body><body package="Seaside-Tests-Core">testDictionaryConversion	| dict |	dict := Dictionary new at: 1 put: 2; yourself.	collection := dict seasideRequestFields.	self assert: (collection isKindOf: WARequestFields).	self assertAssociations: (Array with: 1 -&gt; 2)</body><body package="Seaside-Tests-Core">testSmallDictionaryConversion	| dict |	dict := GRSmallDictionary new at: 1 put: 2; yourself.	collection := dict seasideRequestFields.	self assert: (collection isKindOf: WARequestFields).	self assertAssociations: (Array with: 1 -&gt; 2)</body></methods><methods><class-id>Seaside.WAHeaderFieldsTest</class-id> <category>configuration</category><body package="Seaside-Tests-Core">collectionClass	^ WAHeaderFields</body></methods><methods><class-id>Seaside.WAHeaderFieldsTest</class-id> <category>tests-accessing</category><body package="Seaside-Tests-Core">testAt	self assert: (collection removeKey: '1') isNil.	collection add: '1' -&gt; 'foo'.	collection add: '1' -&gt; 'bar'.	self assert: (collection at: '1') =		(self allowsDuplicateKeys ifTrue: [ 'foo' ] ifFalse: [ 'bar' ])</body><body package="Seaside-Tests-Core">testRemoveKey	self assert: (collection removeKey: '1') isNil.	collection add: '1' -&gt; 'foo'.	collection add: '1' -&gt; 'bar'.	collection add: '2' -&gt; 'baz'.	self assert: (collection removeKey: '1') =		(self allowsDuplicateKeys ifTrue: [ #('foo' 'bar') ] ifFalse: [ 'bar' ]).	self assertAssociations: (Array with: '2' -&gt; 'baz').	self assert: (collection removeKey: '2') =		(self allowsDuplicateKeys ifTrue: [ #('baz') ] ifFalse: [ 'baz' ]).	self assertAssociations: #()</body></methods><methods><class-id>Seaside.WARequestTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">test10	| request |	request := WARequest method: 'GET' uri: '/' version: WAHttpVersion http10.		self assert: request isGet.	self assert: request isHttp10.	self deny: request isSsl</body><body package="Seaside-Tests-Core">test11	| request |	request := WARequest method: 'GET' uri: '/' version: WAHttpVersion http11.		self assert: request isGet.	self assert: request isHttp11.	self deny: request isSsl</body><body package="Seaside-Tests-Core">testBasicAuthorisation	| request headers |	request := WARequest method: 'GET' uri: '/foo?bar=1'.	headers := Dictionary new.	headers at: 'authorization' put: 'Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ=='.	request setHeaders: headers.		self assert: request authorization = 'Aladdin:open sesame'.	self assert: request user = 'Aladdin'.	self assert: request password = 'open sesame'</body><body package="Seaside-Tests-Core">testIsPrefetch	| request headers |	request := WARequest method: 'GET' uri: '/foo'.	self deny: request isPrefetch.		headers := Dictionary new.	headers at: 'x-moz' put: 'prefetch'.	request setHeaders: headers.	self assert: request isPrefetch</body><body package="Seaside-Tests-Core">testIsSsl	| request |	request := WARequest		method: 'GET'		uri: ('/' seasideUrl			scheme: 'https';			yourself)		version: WAHttpVersion http11.		self assert: request isGet.	self assert: request isHttp11.	self assert: request isSsl</body><body package="Seaside-Tests-Core">testPostFields	| request headers |	request := WARequest method: 'POST' uri: '/foo?bar=1'.	headers := Dictionary new.	headers at: 'content-type' put: WAMimeType formUrlencoded greaseString.	request setHeaders: headers.	request setBody: 'baz=2&amp;bar=3'.	request setPostFields: (WARequestFields new at: 'baz' put: '2'; at: 'bar' put: '3'; yourself).		self assert: request postFields size = 2.	self assert: (request postFields at: 'baz') = '2'.	self assert: (request postFields at: 'bar') = '3'.	self assert: request queryFields size = 1.	self assert: (request queryFields at: 'bar') = '1'.	self assert: request fields size = 3.	self assert: (request fields at: 'bar') = '1'.	self assert: (request fields at: 'baz') = '2'</body></methods><methods><class-id>Seaside.WAHandlerTrackingStrategyTest</class-id> <category>private</category><body package="Seaside-Tests-Core">assertCookieInContext: aRequestContext withValue: aString	| cookies cookie |	cookies := aRequestContext response cookies.	self assert: cookies size = 1.	cookie := cookies first.	self assert: cookie key = strategy keyCookieName.	self assert: cookie value = aString</body><body package="Seaside-Tests-Core">assertNoCookies: aRequestContext	self assert: aRequestContext response cookies isEmpty</body><body package="Seaside-Tests-Core">newDocumentHandler	^ WADocumentHandler document: 'WADocumentHandler document: document'</body><body package="Seaside-Tests-Core">newStrategy	self subclassResponsibility</body></methods><methods><class-id>Seaside.WAHandlerTrackingStrategyTest</class-id> <category>configuration</category><body package="Seaside-Tests-Core">createRequest	^ WARequest method: 'GET' uri: '/catspajamassc2'</body></methods><methods><class-id>Seaside.WAHandlerTrackingStrategyTest</class-id> <category>running</category><body package="Seaside-Tests-Core">setUp	super setUp.	strategy := self newStrategy</body></methods><methods><class-id>Seaside.WAHandlerTrackingStrategyTest class</class-id> <category>testing</category><body package="Seaside-Tests-Core">isAbstract	^ self name = #WAHandlerTrackingStrategyTest</body></methods><methods><class-id>Seaside.WAQueryFieldHandlerTrackingStrategyTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testAddKeyToContext	| context |	context := self requestContext.	strategy addKey: 'The_Metaphor' toContext: context.	self assertNoCookies: context</body><body package="Seaside-Tests-Core">testAddKeyToUrl	| context uri |	context := self requestContext.	uri := context request uri copy.	strategy addKey: 'The_Metaphor' toUrl: uri.	self assert: uri greaseString = '/catspajamassc2?_s=The_Metaphor'</body><body package="Seaside-Tests-Core">testKeyButNotValue	| context actual |	context := self requestContext.	context request uri addField: strategy keyField.	actual := strategy keyFromContext: context.	self assert: actual isNil</body><body package="Seaside-Tests-Core">testKeyPresent	| context actual |	context := self requestContext.	context request uri addField: strategy keyField value: '4e232e46-003d2-04324-d3ac8fa8'.	actual := strategy keyFromContext: context.	self assert: actual = '4e232e46-003d2-04324-d3ac8fa8'</body><body package="Seaside-Tests-Core">testNoKey	| actual |	actual := strategy keyFromContext: self requestContext.	self assert: actual isNil</body></methods><methods><class-id>Seaside.WAQueryFieldHandlerTrackingStrategyTest</class-id> <category>private</category><body package="Seaside-Tests-Core">newStrategy	^ WAQueryFieldHandlerTrackingStrategy new</body></methods><methods><class-id>Seaside.WACookieTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testCombine	| expiry actual cookie1 cookie2 |	expiry := DateAndTime year: 2007 month: 11 day: 21 hour: 14 minute: 42 second: 48 offset: (Duration days: 0 hours: 2 minutes: 0 seconds: 0).	cookie1 := WACookie key: 'ikuser' value: '1234'.	cookie1 expiry: expiry.	cookie2 := WACookie key: 'JSESSIONID' value: '8543783483494373483764'.		actual := WACookie		combine: (Array with: cookie1 with: cookie2)		using: [ :each | each rfc6265String ].	self assert: actual = 'ikuser=1234; expires=Wed, 21-Nov-2007 12:42:48 GMT, JSESSIONID=8543783483494373483764'</body><body package="Seaside-Tests-Core">testCopy	| original copy |	original := (WACookie key: 'meta' value: 'phor')		ports: #(80) asOrderedCollection;		yourself.			copy := original copy.	copy ports at: 1 put: 443.			self assert: original ports size = 1.	self assert: original ports first = 80.		self assert: copy ports size = 1.	self assert: copy ports first = 443</body><body package="Seaside-Tests-Core">testEquals	| cookie1 cookie2 |	cookie1 := WARequestCookie key: 'JSESSIONID' value: '8543783483494373483764'.	cookie2 := WARequestCookie key: 'JSESSIONID' value: '8543783483494373483767'.		self assert: cookie1 = cookie2.	self assert: cookie2 = cookie1.	self assert: cookie1 hash = cookie2 hash.		cookie2 domain: 'www.example.com'.	self deny: cookie1 = cookie2.	self deny: cookie2 = cookie1.	self deny: cookie1 hash = cookie2 hash.	cookie1 domain: 'www.example.com'.	self assert: cookie1 = cookie2.	self assert: cookie2 = cookie1.	self assert: cookie1 hash = cookie2 hash.		cookie1 path: '/cgi-bin/index.cbl'.	self deny: cookie1 = cookie2.	self deny: cookie2 = cookie1.	self deny: cookie1 hash = cookie2 hash.		cookie2 path: '/cgi-bin/index.cbl'.	self assert: cookie1 = cookie2.	self assert: cookie2 = cookie1.	self assert: cookie1 hash = cookie2 hash.		cookie1 ports: #(8080).	self assert: cookie1 = cookie2.	self assert: cookie2 = cookie1.	self assert: cookie1 hash = cookie2 hash.		cookie2 ports: #(9090).	self assert: cookie1 = cookie2.	self assert: cookie2 = cookie1.	self assert: cookie1 hash = cookie2 hash</body><body package="Seaside-Tests-Core">testExpireInPast	| cookie |	cookie := (WACookie key: 'unit' value: 'testing').	cookie expireInPast.	self assert: cookie expiry &lt; DateAndTime now asUTC.	self assert: cookie expiry &gt;= (DateAndTime year: 1970 day: 1 hour: 0 minute: 0 second: 0) asUTC.	self assert: cookie maxAge = 0</body><body package="Seaside-Tests-Core">testExpirePrinting	| cookie |	cookie := WACookie key: 'foo' value: 'bar'.	cookie expiry: (DateAndTime year: 2003 day: 4 hour: 5 minute: 6 second: 7 offset: Duration zero).	self assert: cookie rfc6265String = 'foo=bar; expires=Sat, 04-Jan-2003 05:06:07 GMT'</body><body package="Seaside-Tests-Core">testFromStringOldNetscape	| cookies customer partNumber shipping |	cookies := WACookie fromString: 'Customer=WILE_E_COYOTE;                 Part_Number=Rocket_Launcher_0001;                 Shipping=FedEx' codec: GRNullCodec new.	self assert: cookies size = 3.		customer := cookies detect: [ :each | each key = 'Customer' ].	self assert: customer value = 'WILE_E_COYOTE'.		partNumber := cookies detect: [ :each | each key = 'Part_Number' ].	self assert: partNumber value = 'Rocket_Launcher_0001'.		shipping := cookies detect: [ :each | each key = 'Shipping' ].	self assert: shipping value = 'FedEx'</body><body package="Seaside-Tests-Core">testFromStringRfc2965	| cookies customer partNumber shipping |	cookies := WARequestCookie fromString: '$Version="1";                 Customer="WILE_E_COYOTE"; $Path="/acme"; $Port="1"; $Domain="www.1.com";                 Part_Number="Rocket_Launcher_0001"; $Path="/acme/rockes"; $Port="2,3"; $Domain="www.2.com";                 Shipping="FedEx"' codec: GRNullCodec new.	self assert: cookies size = 3.		customer := cookies detect: [ :each | each key = 'Customer' ].	self assert: customer version = 1.	self assert: customer value = 'WILE_E_COYOTE'.	self assert: customer path = '/acme'.	self assert: customer domain = 'www.1.com'.	self assert: customer ports size = 1.	self assert: customer ports first = 1.		partNumber := cookies detect: [ :each | each key = 'Part_Number' ].	self assert: partNumber version = 1.	self assert: partNumber value = 'Rocket_Launcher_0001'.	self assert: partNumber path = '/acme/rockes'.	self assert: partNumber domain = 'www.2.com'.	self assert: partNumber ports size = 2.	self assert: partNumber ports first = 2.	self assert: partNumber ports second = 3.		shipping := cookies detect: [ :each | each key = 'Shipping' ].	self assert: shipping version = 1.	self assert: shipping value = 'FedEx'.	self assert: shipping path = '/'.	self assert: shipping domain isNil.	self assert: shipping ports isNil</body><body package="Seaside-Tests-Core">testPathEncoding	| cookies cookie |	cookies := WARequestCookie fromString: '$Version="1";                 Customer="WILE_E_COYOTE"; $Path="/%20"' codec: GRNullCodec new.	self assert: cookies size = 1.	cookie := cookies first.	self assert: cookie path = '/ '.	self assert: cookie pathUnencoded = '/ '.	self assert: cookie pathEncoded = '/%20'</body><body package="Seaside-Tests-Core">testWriteOn	| expiry cookie |	expiry := DateAndTime year: 2007 month: 11 day: 21 hour: 14 minute: 42 second: 48 offset: (Duration days: 0 hours: 2 minutes: 0 seconds: 0).	cookie := WACookie key: 'ikuser' value: '1234'.	self assert: cookie oldNetscapeString = 'ikuser=1234'.	self assert: cookie rfc2109String = 'ikuser="1234"; Version=1'.	self assert: cookie rfc2965String = 'ikuser="1234"; Version=1'.	self assert: cookie rfc6265String = 'ikuser=1234'.		cookie expiry: expiry.	cookie maxAge: 3600.	self assert: cookie oldNetscapeString = 'ikuser=1234; expires=Wed, 21-Nov-2007 12:42:48 GMT'.	self assert: cookie rfc2109String = 'ikuser="1234"; Max-Age="3600"; Version=1'.	self assert: cookie rfc2965String = 'ikuser="1234"; Max-Age="3600"; Version=1'.	self assert: cookie rfc6265String = 'ikuser=1234; expires=Wed, 21-Nov-2007 12:42:48 GMT; Max-Age=3600'.		cookie path: '/seaside/counter'.	self assert: cookie oldNetscapeString = 'ikuser=1234; expires=Wed, 21-Nov-2007 12:42:48 GMT; path=/seaside/counter'.	self assert: cookie rfc2109String = 'ikuser="1234"; Max-Age="3600"; path="/seaside/counter"; Version=1'.	self assert: cookie rfc2965String = 'ikuser="1234"; Max-Age="3600"; path="/seaside/counter"; Version=1'.	self assert: cookie rfc6265String = 'ikuser=1234; expires=Wed, 21-Nov-2007 12:42:48 GMT; Max-Age=3600; path=/seaside/counter'.		cookie value: nil.	self assert: cookie oldNetscapeString = 'ikuser=; expires=Wed, 21-Nov-2007 12:42:48 GMT; path=/seaside/counter'.	self assert: cookie rfc2109String = 'ikuser=""; Max-Age="3600"; path="/seaside/counter"; Version=1'.	self assert: cookie rfc2965String = 'ikuser=""; Max-Age="3600"; path="/seaside/counter"; Version=1'.	self assert: cookie rfc6265String = 'ikuser=; expires=Wed, 21-Nov-2007 12:42:48 GMT; Max-Age=3600; path=/seaside/counter'.		cookie value: '1234'.	cookie domain: 'www.example.com'.	cookie ports: (Array with: 80 with: 433).	self assert: cookie oldNetscapeString = 'ikuser=1234; expires=Wed, 21-Nov-2007 12:42:48 GMT; path=/seaside/counter; domain=www.example.com'.	self assert: cookie rfc2109String = 'ikuser="1234"; Max-Age="3600"; path="/seaside/counter"; domain="www.example.com"; Version=1'.	self assert: cookie rfc2965String = 'ikuser="1234"; Max-Age="3600"; path="/seaside/counter"; Port="80,433"; domain="www.example.com"; Version=1'.	self assert: cookie rfc6265String = 'ikuser=1234; expires=Wed, 21-Nov-2007 12:42:48 GMT; Max-Age=3600; domain=www.example.com; path=/seaside/counter'.		cookie discard: true.	cookie secure: true.	cookie httpOnly: true.	self assert: cookie oldNetscapeString = 'ikuser=1234; expires=Wed, 21-Nov-2007 12:42:48 GMT; path=/seaside/counter; domain=www.example.com; Secure; HttpOnly'.	self assert: cookie rfc2109String = 'ikuser="1234"; Max-Age="3600"; path="/seaside/counter"; domain="www.example.com"; Secure; HttpOnly; Version=1'.	self assert: cookie rfc2965String = 'ikuser="1234"; Max-Age="3600"; path="/seaside/counter"; Port="80,433"; domain="www.example.com"; Secure; HttpOnly; Discard; Version=1'.	self assert: cookie rfc6265String = 'ikuser=1234; expires=Wed, 21-Nov-2007 12:42:48 GMT; Max-Age=3600; domain=www.example.com; path=/seaside/counter; Secure; HttpOnly'.		cookie comment: 'FIS Heer username'.	cookie commentUrl: 'http://www.example.com/session-cookie.html'.	self assert: cookie oldNetscapeString = 'ikuser=1234; expires=Wed, 21-Nov-2007 12:42:48 GMT; path=/seaside/counter; domain=www.example.com; Secure; HttpOnly'.	self assert: cookie rfc2109String = 'ikuser="1234"; Comment="FIS Heer username"; Max-Age="3600"; path="/seaside/counter"; domain="www.example.com"; Secure; HttpOnly; Version=1'.	self assert: cookie rfc2965String = 'ikuser="1234"; Comment="FIS Heer username"; CommentURL="http://www.example.com/session-cookie.html"; Max-Age="3600"; path="/seaside/counter"; Port="80,433"; domain="www.example.com"; Secure; HttpOnly; Discard; Version=1'.	self assert: cookie rfc6265String = 'ikuser=1234; expires=Wed, 21-Nov-2007 12:42:48 GMT; Max-Age=3600; domain=www.example.com; path=/seaside/counter; Secure; HttpOnly'</body></methods><methods><class-id>Seaside.WATestNoopRequestHandler</class-id> <category>handling</category><body package="Seaside-Tests-Core">handleFiltered: aRequestContext	"do nothing"</body></methods><methods><class-id>Seaside.WABacktrackingTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testArray	| original snapshot1 snapshot2 snapshot3 |	original := Array with: 1 with: 2 with: 3.	snapshot1 := original snapshotCopy.	original at: 1 put: #a.	snapshot2 := original snapshotCopy.	original at: 2 put: #b.	snapshot3 := original snapshotCopy.	original restoreFromSnapshot: snapshot1.	self assert: original = #( 1 2 3 ).	original restoreFromSnapshot: snapshot2.	self assert: original = #( a 2 3 ).	original restoreFromSnapshot: snapshot3.	self assert: original = #( a b 3 )</body><body package="Seaside-Tests-Core">testBag	| original snapshot1 snapshot2 snapshot3 |	original := Bag with: 1 with: 2.	snapshot1 := original snapshotCopy.	original add: 3.	snapshot2 := original snapshotCopy.	original remove: 1.	snapshot3 := original snapshotCopy.	original restoreFromSnapshot: snapshot1.	self assert: original size = 2.	self assert: (original includes: 1).	self assert: (original includes: 2).	self deny: (original includes: 3).	original restoreFromSnapshot: snapshot2.	self assert: original size = 3.	self assert: (original includes: 1).	self assert: (original includes: 2).	self assert: (original includes: 3).	original restoreFromSnapshot: snapshot3.	self assert: original size = 2.	self deny: (original includes: 1).	self assert: (original includes: 2).	self assert: (original includes: 3).	original add: 4.	original restoreFromSnapshot: snapshot3.	self assert: original size = 2.	self deny: (original includes: 1).	self assert: (original includes: 2).	self assert: (original includes: 3).	self deny: (original includes: 4)</body><body package="Seaside-Tests-Core">testDictionary	| original snapshot1 snapshot2 snapshot3 snapshot4 |	original := Dictionary new.	original at: 1 put: #a; at: 2 put: #b.	snapshot1 := original snapshotCopy.	original at: 3 put: #c.	snapshot2 := original snapshotCopy.	original at: 3 put: #d.	snapshot3 := original snapshotCopy.	original removeKey: 1.	snapshot4 := original snapshotCopy.	original restoreFromSnapshot: snapshot1.	self assert: original size = 2.	self assert: (original at: 1 ifAbsent: [ ]) = #a.	self assert: (original at: 2 ifAbsent: [ ]) = #b.	self assert: (original at: 3 ifAbsent: [ ]) isNil.	self assert: (original at: 4 ifAbsent: [ ]) isNil.	original restoreFromSnapshot: snapshot2.	self assert: (original at: 1 ifAbsent: [ ]) = #a.	self assert: (original at: 2 ifAbsent: [ ]) = #b.	self assert: (original at: 3 ifAbsent: [ ]) = #c.	self assert: (original at: 4 ifAbsent: [ ]) isNil.	original restoreFromSnapshot: snapshot3.	self assert: (original at: 1 ifAbsent: [ ]) = #a.	self assert: (original at: 2 ifAbsent: [ ]) = #b.	self assert: (original at: 3 ifAbsent: [ ]) = #d.	self assert: (original at: 4 ifAbsent: [ ]) isNil.	original restoreFromSnapshot: snapshot4.	self assert: (original at: 1 ifAbsent: [ ]) isNil.	self assert: (original at: 2 ifAbsent: [ ]) = #b.	self assert: (original at: 3 ifAbsent: [ ]) = #d.	self assert: (original at: 4 ifAbsent: [ ]) isNil.	original at: 2 put: #!.	original restoreFromSnapshot: snapshot4.	self assert: (original at: 1 ifAbsent: [ ]) isNil.	self assert: (original at: 2 ifAbsent: [ ]) = #b.	self assert: (original at: 3 ifAbsent: [ ]) = #d.	self assert: (original at: 4 ifAbsent: [ ]) isNil</body><body package="Seaside-Tests-Core">testHolder	| original snapshot1 snapshot2 snapshot3 |	original := WAValueHolder new.	snapshot1 := original snapshotCopy.	original contents: 1.	snapshot2 := original snapshotCopy.	original contents: 2.	snapshot3 := original snapshotCopy.	original restoreFromSnapshot: snapshot1.	self assert: original contents isNil.	original restoreFromSnapshot: snapshot2.	self assert: original contents = 1.	original restoreFromSnapshot: snapshot3.	self assert: original contents = 2</body><body package="Seaside-Tests-Core">testObject	| original snapshot |	original := Object new.	snapshot := original snapshotCopy.	original restoreFromSnapshot: snapshot</body><body package="Seaside-Tests-Core">testOrderedCollection	| original snapshot |	original := OrderedCollection with: 1 with: 2.	snapshot := original snapshotCopy.		original restoreFromSnapshot: snapshot.	self assert: original asArray = #(1 2).		original removeLast.		original restoreFromSnapshot: snapshot.	self assert: original asArray = #(1 2)</body><body package="Seaside-Tests-Core">testSet	| original snapshot1 snapshot2 snapshot3 |	original := Set with: 1 with: 2.	snapshot1 := original snapshotCopy.	original add: 3.	snapshot2 := original snapshotCopy.	original remove: 1.	snapshot3 := original snapshotCopy.	original restoreFromSnapshot: snapshot1.	self assert: original size = 2.	self assert: (original includes: 1).	self assert: (original includes: 2).	self deny: (original includes: 3).	original restoreFromSnapshot: snapshot2.	self assert: original size = 3.	self assert: (original includes: 1).	self assert: (original includes: 2).	self assert: (original includes: 3).	original restoreFromSnapshot: snapshot3.	self assert: original size = 2.	self deny: (original includes: 1).	self assert: (original includes: 2).	self assert: (original includes: 3).	original add: 4.	original restoreFromSnapshot: snapshot3.	self assert: original size = 2.	self deny: (original includes: 1).	self assert: (original includes: 2).	self assert: (original includes: 3).	self deny: (original includes: 4)</body></methods><methods><class-id>Seaside.WAHtmlAttributesTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testAt	attributes at: 'foo' put: 'bar'.	self assert: (attributes at: 'foo') = 'bar'.	self assert: (attributes at: 'bar') isNil</body><body package="Seaside-Tests-Core">testAtAppend	self		assert: [ :attr | attr at: 'onclick' append: 'this' separator: ';' ]		gives: ' onclick="this"'.	self		assert: [ :attr |			attr				at: 'onclick' append: 'this' separator: ';';				at: 'onclick' append: 'that' separator: ';' ]		gives: ' onclick="this;that"'.	self		assert: [ :attr |			attr				at: 'onclick' append: 'this' separator: ';';				at: 'onclick' append: nil separator: ';' ]		gives: ' onclick="this"'.	self		assert: [ :attr |			attr				at: 'onclick' append: 1 separator: ';';				at: 'onclick' append: 2 separator: ';' ]		gives: ' onclick="1;2"'</body><body package="Seaside-Tests-Core">testAtPut	self		assert: [ :attr | attr at: 'id' put: 'foo' ]		gives: ' id="foo"'.	self		assert: [ :attr | attr at: 'tabindex' put: 6 ]		gives: ' tabindex="6"'.	self		assert: [ :attr | attr at: 'checked' put: true ]		gives: ' checked="checked"'.	self		assert: [ :attr | attr at: 'readonly' put: false ]		gives: ''.	self		assert: [ :attr | attr at: 'disabled' put: nil ]		gives: ''</body><body package="Seaside-Tests-Core">testOrder	self		assert: [ :attr | attr at: 'a' put: 1; at: 'b' put: 2; at: 'c' put: 3 ]		gives: ' a="1" b="2" c="3"'.	self		assert: [ :attr | attr at: 'a' put: 1; at: 'b' put: 2; at: 'c' put: 3; at: 'b' put: 4 ]		gives: ' a="1" b="4" c="3"'</body><body package="Seaside-Tests-Core">testRemoveKey	attributes at: 'id' put: 'foo'.	self assert: (attributes removeKey: 'id') = 'foo'.	self assert: (attributes removeKey: 'id') isNil</body></methods><methods><class-id>Seaside.WAHtmlAttributesTest</class-id> <category>running</category><body package="Seaside-Tests-Core">setUp	attributes := WAHtmlAttributes new</body></methods><methods><class-id>Seaside.WAHtmlAttributesTest</class-id> <category>private</category><body package="Seaside-Tests-Core">assert: aBlock gives: aString 	| stream |	aBlock value: (attributes := WAHtmlAttributes new).	(WAHtmlDocument 		on: (stream := WriteStream on: String new)		codec: self requestContext codec) print: attributes.	self 		assert: stream contents = aString		description: 'Expected ' , aString printString , ', but got ' , stream contents printString		resumable: true</body></methods><methods><class-id>Seaside.WAHtmlAttributesTest</class-id> <category>tests-convenience</category><body package="Seaside-Tests-Core">testAddClass	self		assert: [ :attr | attr addClass: 'foo' ]		gives: ' class="foo"'.	self		assert: [ :attr | attr addClass: 'foo'; addClass: 'bar' ]		gives: ' class="foo bar"'</body><body package="Seaside-Tests-Core">testAddStyle	self		assert: [ :attr | attr addStyle: 'display: hidden' ]		gives: ' style="display: hidden"'.	self		assert: [ :attr | attr addStyle: 'display: hidden'; addStyle: 'position: absolute' ]		gives: ' style="display: hidden;position: absolute"'</body></methods><methods><class-id>Seaside.WAHtmlAttributesTest</class-id> <category>tests-fixtures</category><body package="Seaside-Tests-Core">testCaseSensititve	self		assert: [ :attr | attr at: 'lastBuildDate' put: 'Sat, 07 Sep 2002 09:42:31 GMT' ]		gives: ' lastBuildDate="Sat, 07 Sep 2002 09:42:31 GMT"'</body></methods><methods><class-id>Seaside.WANextUnconsumedPathElementRequestHandler</class-id> <category>handling</category><body package="Seaside-Tests-Core">handle: aRequestContext	| consumer |	consumer := aRequestContext consumer.	nextUnconsumedPathElement := consumer atEnd		ifTrue: [ nil ]		ifFalse: [ aRequestContext consumer peek ].	super handle: aRequestContext</body><body package="Seaside-Tests-Core">handleFiltered: aRequestContext</body></methods><methods><class-id>Seaside.WANextUnconsumedPathElementRequestHandler</class-id> <category>accessing</category><body package="Seaside-Tests-Core">nextUnconsumedPathElement	^ nextUnconsumedPathElement</body></methods><methods><class-id>Seaside.WABulkReapingCacheTest</class-id> <category>running</category><body package="Seaside-Tests-Core">createCache	^ WABulkReapingCache		initialSize: 13		maximumSize: 0		maximumAbsoluteAge: 0		maximumRelativeAge: 0		overflowAction: WAHashCache signalError</body></methods><methods><class-id>Seaside.WABulkReapingCacheTest</class-id> <category>testing</category><body package="Seaside-Tests-Core">testExpireAbsolute	"	max age: 3 sec		put 1	wait 2 sec	put 2	wait 2 sec		1 should be expired	2 should not be expired"	| delay absent |	self workAroundPharo3Bug.		cache := WABulkReapingCache		initialSize: 13		maximumSize: 10		maximumAbsoluteAge: 3		maximumRelativeAge: 0		overflowAction: WAHashCache signalError.	delay := Delay forSeconds: 2.			cache at: 1 put: '1'.	delay wait.	cache at: 2 put: '2'.	delay wait.	self assert: cache reap = 1 description: 'should reap exactly one item'.		"1 should be gone"	absent := false.	cache at: 1 ifAbsent: [ absent := true ].	self assert: absent description: 'the oldest item should be gone'.		"2 should still be there"	self assert: (cache at: 2 ifAbsent: [ self assert: false ]) = '2' description: 'the newest item should not be gone'</body><body package="Seaside-Tests-Core">testExpireRelative	"	max age: 3 sec		put 1	put 2	wait 2 sec	access 1	wait 2 sec		1 should not be expired	2 should be expired"	| delay absent |	self workAroundPharo3Bug.		cache := WABulkReapingCache		initialSize: 13		maximumSize: 10		maximumAbsoluteAge: 0		maximumRelativeAge: 3		overflowAction: WAHashCache signalError.	delay := Delay forSeconds: 2.			cache at: 1 put: '1'.	cache at: 2 put: '2'.	delay wait.		cache at: 1 ifAbsent: [ self assert: false ].	delay wait.	self assert: cache reap = 1 description: 'should reap exactly one item'.		"1 should still be there"	self assert: (cache at: 1 ifAbsent: [ self assert: false ]) = '1'.		"2 should be gone"	absent := false.	cache at: 2 ifAbsent: [ absent := true ].	self assert: absent</body><body package="Seaside-Tests-Core">testInitialCount	| counter |	self workAroundPharo3Bug.		counter := GRPlatform current newReducedConflictCounter.	self assert: counter value = 0.	counter increment.	self assert: counter value = 1</body><body package="Seaside-Tests-Core">testSendUnregistered	"	max age: 1 sec		put 1	wait 2 sec		1 should be expired and have received #unregistered"	| delay value absent |	self workAroundPharo3Bug.		cache := WABulkReapingCache		initialSize: 13		maximumSize: 10		maximumAbsoluteAge: 1		maximumRelativeAge: 0		overflowAction: WAHashCache signalError.	delay := Delay forSeconds: 2.		value := WAObjectUnderstandingUnregistered new.	self deny: value hasReceivedUnregistered.	cache at: 1 put: value.	delay wait.	self assert: cache reap = 1 description: 'should reap exactly one item'.		"1 should be gone"	absent := false.	cache at: 1 ifAbsent: [ absent := true ].	self assert: absent.		self assert: value hasReceivedUnregistered</body></methods><methods><class-id>Seaside.WABulkReapingCacheTest</class-id> <category>private</category><body package="Seaside-Tests-Core">workAroundPharo3Bug	"apparently the first delay you execute in a Pharo 3 image gets ignored	fixed in Pharo 4"	(Delay forMilliseconds: 1) wait</body></methods><methods><class-id>Seaside.WAExceptionHandlerTest</class-id> <category>testing</category><body package="Seaside-Tests-Core">assertHandles: anObject	self assertHandles: anObject returnsSatisfying: [ :result | result ]</body><body package="Seaside-Tests-Core">assertHandles: anObject returnsSatisfying: aBlock 	| result instanceResult |	result := self handlerClass handles: anObject.	instanceResult := self createHandler handles: anObject.	self assert: result = instanceResult.	self assert: (aBlock value: result)</body><body package="Seaside-Tests-Core">testCommaReturnsExceptionSet	| set |	set := self handlerClass, WATestError.	self assert: (set isKindOf: ExceptionSet).	self assert: (set handles: WATestError new).		set := self createHandler, WATestError.	self assert: (set isKindOf: ExceptionSet).	self assert: (set handles: WATestError new)</body><body package="Seaside-Tests-Core">testHandlerClassValidExceptionSelector	"The ANSI standard specifies that an object must implement #handles: and #, in	order to be used as an 'exception selector' (that is, as the first paramter to #on:do:).	However, some platforms seem to require other protocol. This test will make sure	that each platform has implemented what is required to make this work."		[ [ self unhandledExceptionClass signal ]		on: self handlerClass		do: [ :exception | self assert: false ] ]			on: Exception			do: [ :exception | ^ self "test passed" ].			self assert: false "The method should have returned already"</body><body package="Seaside-Tests-Core">testHandlerInstanceValidExceptionSelector	"The ANSI standard specifies that an object must implement #handles: and #, in	order to be used as an 'exception selector' (that is, as the first paramter to #on:do:).	However, some platforms seem to require other protocol. This test will make sure	that each platform has implemented what is required to make this work."		[ [ self unhandledExceptionClass signal ]		on: self createHandler		do: [ :exception | self assert: false ] ]			on: Exception			do: [ :exception | ^ self "test passed" ].			self assert: false "The method should have returned already"</body><body package="Seaside-Tests-Core">testHandlesReturnsBool	self 		assertHandles: WATestError new		returnsSatisfying: [ :result | #(true false) includes: result ]</body><body package="Seaside-Tests-Core">testInternalError	| context |	context := self createRequestContext.	[ self handlerClass			internalError: (WATestError new)			context: context ]		on: WAResponseNotification		do: [ :n |			self assert: (context response isKindOf: WAResponse).			self assert: context response status = 500.			^ self ].			self assert: false</body><body package="Seaside-Tests-Core">testInternalErrorWithMessage	| context |	context := self createRequestContext.	[ self handlerClass			internalError: (WATestError new messageText: 'test'; yourself)			context: context ]		on: WAResponseNotification		do: [ :n |			self assert: (context response isKindOf: WAResponse).			self assert: context response status = 500.			^ self ].			self assert: false</body><body package="Seaside-Tests-Core">testUnhandledException	[ self handlerClass		handleExceptionsDuring: [ self unhandledExceptionClass signal ]		context: self requestContext ]			on: self unhandledExceptionClass			do: [ :exception | "success" ^ self ].		self assert: false</body></methods><methods><class-id>Seaside.WAExceptionHandlerTest</class-id> <category>accessing</category><body package="Seaside-Tests-Core">createHandler	^ self handlerClass context: self createRequestContext</body><body package="Seaside-Tests-Core">createRequestContext	^ WARequestContext request: WARequest new response: WABufferedResponse new</body><body package="Seaside-Tests-Core">handlerClass	"The handler to test in this test case"	^ WAExceptionHandler</body><body package="Seaside-Tests-Core">unhandledExceptionClass	"An exception that is not handled by #handlerClass"	^ Exception</body></methods><methods><class-id>Seaside.WAErrorHandlerTest</class-id> <category>accessing</category><body package="Seaside-Tests-Core">handlerClass	^ WAErrorHandler</body></methods><methods><class-id>Seaside.WAErrorHandlerTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testError	| context |	context := self createRequestContext.	[ self handlerClass		handleExceptionsDuring: [ WAError signal ]		context: context ]			on: WAResponseNotification			do: [ :n | self assert: context response status = 500. ^ self ].				self assert: false</body><body package="Seaside-Tests-Core">testHandlesError	self assert: (self handlerClass handles: Error new).	self assert: (self createHandler handles: Error new)</body><body package="Seaside-Tests-Core">testHandlesWarning	self assert: (self handlerClass handles: Warning new).	self assert: (self createHandler handles: Warning new)</body><body package="Seaside-Tests-Core">testWarning	| context |	context := self createRequestContext.	[ self handlerClass		handleExceptionsDuring: [ Warning signal ]		context: context ]			on: WAResponseNotification			do: [ :n | self assert: context response status = 500. ^ self ].				self assert: false</body></methods><methods><class-id>Seaside.WAErrorHandlerTest class</class-id> <category>testing</category><body package="Seaside-Tests-Core">shouldInheritSelectors	^ true</body></methods><methods><class-id>Seaside.WACollectionMimeDocumentTest</class-id> <category>running</category><body package="Seaside-Tests-Core">setUp	super setUp.	document := WAMimeDocument on: 'aString' mimeType: WAMimeType textPlain</body></methods><methods><class-id>Seaside.WACollectionMimeDocumentTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testAsMIMEDocument	self assert: document seasideMimeDocument == document</body><body package="Seaside-Tests-Core">testContent	self assert: document content = 'aString'</body><body package="Seaside-Tests-Core">testContentStream	| stream |		stream := document contentStream.	'aString' do: [ :each |		self deny: stream atEnd.		self assert: stream next = each ].		self assert: stream atEnd</body></methods><methods><class-id>Seaside.WAHashCacheTest</class-id> <category>running</category><body package="Seaside-Tests-Core">createCache	^ WAHashCache		initialSize: 13		maximumSize: 0		maximumAbsoluteAge: 0		maximumRelativeAge: 0		overflowAction: WAHashCache signalError</body></methods><methods><class-id>Seaside.WAHashCacheTest</class-id> <category>testing</category><body package="Seaside-Tests-Core">testExpireAbsolute	"	max age: 3 sec		put 1	wait 2 sec	put 2	wait 2 sec		1 should be expired	2 should not be expired"	| delay absent |	cache := WAHashCache		initialSize: 13		maximumSize: 10		maximumAbsoluteAge: 3		maximumRelativeAge: 0		overflowAction: WAHashCache signalError.	delay := Delay forSeconds: 2.			cache at: 1 put: '1'.	delay wait.	cache at: 2 put: '2'.	delay wait.		"1 should be gone"	absent := false.	cache at: 1 ifAbsent: [ absent := true ].	self assert: absent.		"2 should still be there"	self assert: (cache at: 2 ifAbsent: [ self assert: false ]) = '2'</body><body package="Seaside-Tests-Core">testExpireRelative	"	max age: 3 sec		put 1	put 2	wait 2 sec	access 1	wait 2 sec		1 should not be expired	2 should be expired"	| delay absent |	cache := WAHashCache		initialSize: 13		maximumSize: 10		maximumAbsoluteAge: 0		maximumRelativeAge: 3		overflowAction: WAHashCache signalError.	delay := Delay forSeconds: 2.			cache at: 1 put: '1'.	cache at: 2 put: '2'.	delay wait.		cache at: 1 ifAbsent: [ self assert: false ].	delay wait.		"1 should still be there"	self assert: (cache at: 1 ifAbsent: [ self assert: false ]) = '1'.		"2 should be gone"	absent := false.	cache at: 2 ifAbsent: [ absent := true ].	self assert: absent</body><body package="Seaside-Tests-Core">testRemoveAbsoluteOldest	cache := WAHashCache		initialSize: 13		maximumSize: 10		maximumAbsoluteAge: 0		maximumRelativeAge: 0		overflowAction: WAHashCache removeAbsoluteOldest.			1 to: 20 do: [ :i |		cache at: i put: i greaseString ].		1 to: 10 do: [ :i |		| absent |		absent := false.		cache at: i ifAbsent: [ absent := true ].		self assert: absent ].		11 to: 20 do: [ :i |		| mapped |		mapped := cache at: i ifAbsent: [ self assert: false ].		self assert: mapped = i greaseString ]</body><body package="Seaside-Tests-Core">testRemoveRelativeOldest	"set maximum size = 10	add 1, 2, ... 10	access 1, 2, ... 9 -&gt; 10 has not been accessed for the most time	add 11	1, 2, ...9, 11 should be in map"	| tenMissing |	cache := WAHashCache		initialSize: 13		maximumSize: 10		maximumAbsoluteAge: 0		maximumRelativeAge: 0		overflowAction: WAHashCache removeRelativeOldest.			1 to: 10 do: [ :i |		cache at: i put: i greaseString ].		"access every but 10"	1 to: 9 do: [ :i |		cache at: i ifAbsent: [ self assert: false ] ].		cache at: 11 put: '11'.		1 to: 9 do: [ :i |		self assert: (cache at: i ifAbsent: [ self assert: false ]) = i greaseString ].		self assert: (cache at: 11 ifAbsent: [ self assert: false ]) = '11'.		tenMissing := false.	cache at: 10 ifAbsent: [ tenMissing := true ].	self assert: tenMissing</body><body package="Seaside-Tests-Core">testSendUnregistered	"	max age: 1 sec		put 1	wait 2 sec		1 should be expired and have received #unregistered"	| delay value absent |	cache := WAHashCache		initialSize: 13		maximumSize: 10		maximumAbsoluteAge: 1		maximumRelativeAge: 0		overflowAction: WAHashCache signalError.	delay := Delay forSeconds: 2.		value := WAObjectUnderstandingUnregistered new.	self deny: value hasReceivedUnregistered.	cache at: 1 put: value.	delay wait.		"1 should be gone"	absent := false.	cache at: 1 ifAbsent: [ absent := true ].	self assert: absent.		self assert: value hasReceivedUnregistered</body><body package="Seaside-Tests-Core">testSignalError	cache := WAHashCache		initialSize: 13		maximumSize: 10		maximumAbsoluteAge: 0		maximumRelativeAge: 0		overflowAction: WAHashCache signalError.			1 to: 10 do: [ :i |		cache at: i put: i greaseString ].		self should: [ cache at: 11 put: '11' ] raise: WAMaximumNumberOfSessionsExceededError</body></methods><methods><class-id>Seaside.WAMimeDocumentTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testAsMIMEDocumentByteArray	| document content |	document := #(1 2 3 4) asByteArray seasideMimeDocument.	self assert: document contentType = WAMimeType applicationOctetStream.	content := document content.	self assert: content size = 4.	self assert: content class = ByteArray.	1 to: 4 do: [ :index | self assert: (content at: index) = index ]</body><body package="Seaside-Tests-Core">testAsMIMEDocumentByteArrayColon	| document content |	document := #(1 2 3 4) asByteArray seasideMimeDocument.	document mimeType: WAMimeType imageJpeg.	self assert: document contentType = WAMimeType imageJpeg.	content := document content.	self assert: content size = 4.	self assert: content class = ByteArray.	1 to: 4 do: [ :index | self assert: (content at: index) = index ]</body><body package="Seaside-Tests-Core">testAsMIMEDocumentString	| document |	document := 'hello Seaside' seasideMimeDocument.	self assert: document contentType = WAMimeType textPlain.	self assert: document content = 'hello Seaside'</body><body package="Seaside-Tests-Core">testAsMIMEDocumentStringColon	| document |	document := 'hello Seaside' seasideMimeDocument.	document mimeType: 'text/x-weirdo' seasideMimeType.	self assert: document contentType = 'text/x-weirdo' seasideMimeType.	self assert: document content = 'hello Seaside'</body><body package="Seaside-Tests-Core">testByteArraySeasideMimeDocumentType	| document mpeg |	mpeg := WAMimeType main: 'audio' sub: 'mpeg'.	document :=  #(1 2 3 4) asByteArray seasideMimeDocumentType: mpeg.	self assert: document mimeType = mpeg.	self assert: document contents = #(1 2 3 4) asByteArray</body><body package="Seaside-Tests-Core">testStringSeasideMimeDocumentType	| document csv |	csv := WAMimeType main: 'text' sub: 'csv'.	document := 'foo,bar' seasideMimeDocumentType: csv.	self assert: document mimeType = csv.	self assert: document contents = 'foo,bar'</body></methods><methods><class-id>Seaside.WAResponseGeneratorTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testForbidden	| generator |	generator := WAResponseGenerator on: self requestContext.	self requestContext response nextPutAll: 'oops'.	generator forbidden.	self assertContents: 'Error: you are forbidden to access "/"'</body><body package="Seaside-Tests-Core">testInternalError	| generator |	generator := WAResponseGenerator on: self requestContext.	self requestContext response nextPutAll: 'oops'.	[ WATestError signal ]		on: WATestError		do: [ :error |			generator internalError: error ].	self assertContents: 'Internal Error: '</body><body package="Seaside-Tests-Core">testNotFound	| generator |	generator := WAResponseGenerator on: self requestContext.	self requestContext response nextPutAll: 'oops'.	generator notFound.	self assertContents: '/ not found'</body><body package="Seaside-Tests-Core">testNotImplemented	| generator |	generator := WAResponseGenerator on: self requestContext.	self requestContext response nextPutAll: 'oops'.	generator notImplemented.	self assertContents:  'Not Implemented'</body><body package="Seaside-Tests-Core">testPageExpired	| generator |	generator := WAResponseGenerator on: self requestContext.	self requestContext response nextPutAll: 'oops'.	generator pageExpired.	self assertContents: 'This page has expired, please use the back-button to navigate to the last valid page.'</body></methods><methods><class-id>Seaside.WAResponseGeneratorTest</class-id> <category>private</category><body package="Seaside-Tests-Core">assertContents: aString	self assert: self requestContext response contents = aString</body></methods><methods><class-id>Seaside.WAFileHandlerListingTest</class-id> <category>testing</category><body package="Seaside-Tests-Core">assertLibrariesResponse: response	self assert: (response contents 					indexOfSubCollection: self expectedLibrariesContents 					startingAt: 1) &gt; 0</body><body package="Seaside-Tests-Core">assertLibraryResponse: response	self assert: (response contents					indexOfSubCollection: self expectedLibraryContents					startingAt: 1) &gt; 0</body><body package="Seaside-Tests-Core">expectedLibrariesContents	^ handler libraries first name</body><body package="Seaside-Tests-Core">expectedLibraryContents	^ WATestingFiles default filenames detect: [ :each | true ]</body><body package="Seaside-Tests-Core">expectedMimeType	self subclassResponsibility</body><body package="Seaside-Tests-Core">expectedStatus	^ 200</body><body package="Seaside-Tests-Core">handlerClass	self subclassResponsibility</body><body package="Seaside-Tests-Core">testFileLibraries	| response |	handler := WAFileHandler new.	handler preferenceAt: #fileHandlerListingClass put: self handlerClass.	self requestContextWithUrl: '/i/dont/care/'.	self requestContext consumer next; next; next.	response := self responseAfter: [ handler handle: self requestContext ].	self assert: response status = self expectedStatus.	self assert: response contentType = self expectedMimeType.	self assertLibrariesResponse: response</body><body package="Seaside-Tests-Core">testFileLibrary	| response |	handler := WAFileHandler new.	handler preferenceAt: #fileHandlerListingClass put: self handlerClass.	self requestContextWithUrl: '/i/dont/care/WATestingFiles'.	self requestContext consumer next; next; next.	response := self responseAfter: [ handler handle: self requestContext ].	self assert: response status = self expectedStatus.	self assert: response contentType = self expectedMimeType.	self assertLibraryResponse: response</body></methods><methods><class-id>Seaside.WAFileHandlerListingTest class</class-id> <category>testing</category><body package="Seaside-Tests-Core">isAbstract	^ self name = #WAFileHandlerListingTest</body></methods><methods><class-id>Seaside.WATestNoopSessionHandler</class-id> <category>handling</category><body package="Seaside-Tests-Core">handleFiltered: aRequestContext	"do nothing"</body></methods><methods><class-id>Seaside.WATestNoopSessionHandler</class-id> <category>testing</category><body package="Seaside-Tests-Core">isSession	^ true</body></methods><methods><class-id>Seaside.WATestNoopSessionHandler</class-id> <category>accessing</category><body package="Seaside-Tests-Core">key: aString	"ignore"</body></methods><methods><class-id>Seaside.WAPrecomputedKeyGenerator</class-id> <category>public</category><body package="Seaside-Tests-Core">keyOfLength: anInteger	| key |	key := keys at: current.	current := current + 1.	^ key</body></methods><methods><class-id>Seaside.WAPrecomputedKeyGenerator</class-id> <category>initialization</category><body package="Seaside-Tests-Core">initializeWithKeys: aSequenceableCollection	self initialize.	keys := aSequenceableCollection.	current := 1</body></methods><methods><class-id>Seaside.WAPrecomputedKeyGenerator class</class-id> <category>instance creation</category><body package="Seaside-Tests-Core">from: start to: end	^ self keys: (start to: end) asArray</body><body package="Seaside-Tests-Core">keys: aSequenceableCollection	^ self basicNew		initializeWithKeys: aSequenceableCollection</body></methods><methods><class-id>Seaside.WADispatcherTest</class-id> <category>private</category><body package="Seaside-Tests-Core">newHandler	| child |	child := WADispatcher new.	child		register: WARequestHandler new at: 'foo';		register: (WADispatcher new					register: WARequestHandler new at: 'baz';					yourself) at: 'bar'.	^ child</body></methods><methods><class-id>Seaside.WADispatcherTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testCopyDispatcher	| copy originalHandler |	copy := handler copy.	self deny: copy == handler.	self assert: copy defaultName = handler defaultName.	self assert: copy handlers keys size = handler handlers keys size.	self assert: (copy handlers keys allSatisfy: [ :each | handler handlers keys includes: each ]).	self assert: (handler handlers keys allSatisfy: [ :each | copy handlers keys includes: each ]).	copy handlers		do: [ :each | 			originalHandler := handler handlerAt: each name.			self assert: each class == originalHandler class.			self deny: each == originalHandler.			each isDispatcher				ifTrue: [ self assert: each handlers keys = originalHandler handlers keys ] ]</body><body package="Seaside-Tests-Core">testEmptyPathConsumption	| root |	root := WADispatcher new.	dispatcher := root register: WADispatcher new at: 'tweets'.	handler := dispatcher register: WANextUnconsumedPathElementRequestHandler new at: 'kentbeck'.	[ root handle: self requestContext ]		on: WAResponseNotification		do: [ :notification | "everything is fine" ].	self assert: handler nextUnconsumedPathElement isNil</body><body package="Seaside-Tests-Core">testPathConsumption	dispatcher := WADispatcher new.	handler := dispatcher register: WANextUnconsumedPathElementRequestHandler new at: 'tweets'.	[ dispatcher handle: self requestContext ]		on: WAResponseNotification		do: [ :notification | "everything is fine" ].	self assert: handler nextUnconsumedPathElement = 'kentbeck'</body></methods><methods><class-id>Seaside.WADispatcherTest</class-id> <category>configuration</category><body package="Seaside-Tests-Core">createRequest	^ WARequest		method: 'GET'		uri: '/tweets/kentbeck'</body></methods><methods><class-id>Seaside.WATestServerAdaptor</class-id> <category>initialization</category><body package="Seaside-Tests-Core">running	status := #running</body><body package="Seaside-Tests-Core">starting	status := #starting</body><body package="Seaside-Tests-Core">stopped	status := #stopped</body><body package="Seaside-Tests-Core">stopping	status := #stopping</body></methods><methods><class-id>Seaside.WATestServerAdaptor</class-id> <category>converting-request</category><body package="Seaside-Tests-Core">basicStop	status := #stopped</body><body package="Seaside-Tests-Core">requestAddressFor: aNativeRequest	self shouldNotImplement</body><body package="Seaside-Tests-Core">requestBodyFor: aNativeRequest	self shouldNotImplement</body><body package="Seaside-Tests-Core">requestCookiesFor: aNativeRequest	self shouldNotImplement</body><body package="Seaside-Tests-Core">requestFieldsFor: aNativeRequest	self shouldNotImplement</body><body package="Seaside-Tests-Core">requestHeadersFor: aNativeRequest	self shouldNotImplement</body><body package="Seaside-Tests-Core">requestMethodFor: aNativeRequest	self shouldNotImplement</body><body package="Seaside-Tests-Core">requestVersionFor: aNativeRequest	self shouldNotImplement</body></methods><methods><class-id>Seaside.WATestServerAdaptor</class-id> <category>testing</category><body package="Seaside-Tests-Core">isRunning	^ status = #running</body><body package="Seaside-Tests-Core">isStarting	^ status = #starting</body><body package="Seaside-Tests-Core">isStopped	^ status = #stopped</body><body package="Seaside-Tests-Core">isStopping	^ status = #stopping</body></methods><methods><class-id>Seaside.WATestServerAdaptor</class-id> <category>converting</category><body package="Seaside-Tests-Core">responseFrom: aRequestContext	self shouldNotImplement</body></methods><methods><class-id>Seaside.WAConfigurationTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testCircular	"Circular ancestry graphs are not allowed."	| first second third |	first := WAUserConfiguration new.	second := WAUserConfiguration new		addParent: first;		yourself.	third := WAUserConfiguration new		addParent: second;		yourself.	self 		should: [ first addParent: third ]		raise: Error.	self 		should: [ first addParent: first ]		raise: Error</body><body package="Seaside-Tests-Core">testCollectionInheritance	"Collection values assigned with #at:addAll: should add on to the inherited value."	| empty root one two three four |	empty := WAConfigurationMock new		description: [ :config | (config collection: #a) ];		yourself.	root := WAConfigurationMock new		description: [ :config | (config collection: #a) default: #(1 2) ];		yourself.	one := WAConfigurationMock new		description: [ :config | config at: #a addAll: #(3) removeAll: #(2) ];		parents: [ Array with: root ];		yourself.	two := WAConfigurationMock new		description: [ :config | config at: #a addAll: #(1 2 3 4) ];		parents: [ Array with: one ];		yourself.	three := WAUserConfiguration new		addParent: two;		at: #a addAll: #(4 5) removeAll: #(1 8);		yourself.	four := WAConfigurationMock new		description: [ :config | config at: #a addAll: #(3 4) removeAll: #(2 3) ];		parents: [ Array with: one ];		yourself.	self assert: (empty at: #a) = #().	self assert: (root at: #a) = #(1 2).	self assert: (one at: #a) = #(1 3).	self assert: (two at: #a) = #(1 2 3 4).	self assert: (three at: #a) = #(2 3 4 5).	self assert: (four at: #a) = #(1 3 4)</body><body package="Seaside-Tests-Core">testDefaultNeverOverrides	"A default value should never override a specified value, even if the default is inherited from a later parent."	| root withValue withoutValue withThenWithout withoutThenWith |	root := self basicSystemConfiguration.	withValue := WAUserConfiguration new		addParent: root;		yourself.	withValue 		at: #a		put: #value.	withoutValue := WAUserConfiguration new		addParent: root;		yourself.	withThenWithout := WAUserConfiguration new		addParent: withValue;		addParent: withoutValue;		yourself.	withoutThenWith := WAUserConfiguration new		addParent: withoutValue;		addParent: withValue;		yourself.	self assert: (root at: #a) = #default.	self assert: (withValue at: #a) = #value.	self assert: (withoutValue at: #a) = #default.	self assert: (withThenWithout at: #a) = #value.	self assert: (withoutThenWith at: #a) = #value</body><body package="Seaside-Tests-Core">testHasExpressionAt	| root user child |	root := self basicSystemConfiguration.	user := WAUserConfiguration new		addParent: root;		yourself.	self deny: (user hasExpressionAt: #a).	user at: #a put: 2.	self assert: (user hasExpressionAt: #a).	child := WAUserConfiguration new		addParent: user;		yourself.	self deny: (child hasExpressionAt: #a)</body><body package="Seaside-Tests-Core">testLastAddedOverrides	"If a non-default value is inherited from more than one parent, the one from the last parent in the list should take precedence.		These are the two graphs we are talking about (X means no value specified):  top                   mirror  /  \                    /  \ 2    X                  X   2 |     |                   |    | X    1                  1   X  \  /                    \  /  root                   root"	| root aX a2 b1 bX top mirror |	root := self basicSystemConfiguration.	aX := WAUserConfiguration new		addParent: root;		yourself.	a2 := WAUserConfiguration new		addParent: aX;		yourself.	a2 		at: #a		put: 2.	b1 := WAUserConfiguration new		addParent: root;		yourself.	b1 		at: #a		put: 1.	bX := WAUserConfiguration new		addParent: b1;		yourself.	top := WAUserConfiguration new		addParent: a2;		addParent: bX;		yourself.	mirror := WAUserConfiguration new		addParent: bX;		addParent: a2;		yourself.	self assert: (root at: #a) = #default.	self assert: (aX at: #a) = #default.	self assert: (a2 at: #a) = 2.	self assert: (b1 at: #a) = 1.	self assert: (bX at: #a) = 1.	self assert: (top at: #a) = 1.	self assert: (mirror at: #a) = 2</body><body package="Seaside-Tests-Core">testLastAddedOverrides2	"If a non-default value is inherited from more than one parent, the one from the last parent in the list should take precedence.		These are the two graphs we are talking about (X means no value specified):    top                mirror    / \                  |   |    |  2                 2   |    | /                    \ |    1                       1    |                        |    root                    root"	| root top mirror one two |	root := self basicSystemConfiguration.	one := WAUserConfiguration new		addParent: root;		yourself.	one 		at: #a		put: 1.	two := WAUserConfiguration new		addParent: one;		yourself.	two 		at: #a		put: 2.	top := WAUserConfiguration new		addParent: one;		addParent: two;		yourself.	mirror := WAUserConfiguration new		addParent: two;		addParent: one;		yourself.	self assert: (root at: #a) = #default.	self assert: (one at: #a) = 1.	self assert: (two at: #a) = 2.	self assert: (top at: #a) = 2.	self assert: (mirror at: #a) = 1</body><body package="Seaside-Tests-Core">testOverrides	"A value in a configuration should override all those given by its ancestors."	| root one two three four system five |	root := self basicSystemConfiguration.	one := WAUserConfiguration new		addParent: root;		yourself.	two := WAUserConfiguration new		addParent: one;		yourself.	two at: #a put: 2.	system := WAConfigurationMock new		description: [ :config | config at: #a put: #override ];		parents: [ Array with: two ];		yourself.	three := WAUserConfiguration new		addParent: system;		yourself.	four := WAUserConfiguration new		addParent: three;		yourself.	four at: #a put: 4.	five := WAUserConfiguration new		addParent: four;		yourself.	self assert: (root at: #a) = #default.	self assert: (one at: #a) = #default.	self assert: (two at: #a) = 2.	self assert: (system at: #a) = #override.	self assert: (three at: #a) = #override.	self assert: (four at: #a) = 4.	self assert: (five at: #a) = 4</body><body package="Seaside-Tests-Core">testSearchContextsCaching	"Search contexts should be cached after accessing them for the first time. Also the cache should be empty after clearSearchContexts."	| root user |	root := self basicSystemConfiguration.	user := WAUserConfiguration new		addParent: root;		yourself.		self assert: (user retrieveSearchContext: #a default: 'testingSearchContextsCache') = 'testingSearchContextsCache'.	user at: #a.	self assert: (user retrieveSearchContext: #a default: 'testingSearchContextsCache') attribute default = #default .	user clearSearchContexts.	self assert: (user retrieveSearchContext: #a default: 'testingSearchContextsCache') = 'testingSearchContextsCache'</body><body package="Seaside-Tests-Core">testValueWithoutAttribute	"A user configuration should not be able to provide a value if it does not inherit the attribute."	| root user top mirror |	root := self basicSystemConfiguration.	user := WAUserConfiguration new		addParent: root;		yourself.	user 		at: #a		put: 1.	user removeParent: root.	top := WAUserConfiguration new		addParent: root;		addParent: user;		yourself.	mirror := WAUserConfiguration new		addParent: user;		addParent: root;		yourself.	self assert: (root at: #a) = #default.	self should: [ user at: #a ] raise: WAAttributeNotFound.	self assert: (top at: #a) = #default.	self assert: (mirror at: #a) = #default.	self 		should: 			[ user 				at: #a				put: 2 ]		raise: Error</body><body package="Seaside-Tests-Core">testValueWithoutAttribute2	"A user configuration should not be able to provide a value if it does not inherit the attribute."	| root top mirror user1 user2 |	root := self basicSystemConfiguration.	user1 := WAUserConfiguration new		addParent: root;		yourself.	user1 		at: #a		put: 1.	user2 := WAUserConfiguration new		addParent: root;		yourself.	user2 		at: #a		put: 2.	user2 removeParent: root.	top := WAUserConfiguration new		addParent: user1;		addParent: user2;		yourself.	mirror := WAUserConfiguration new		addParent: user2;		addParent: user1;		yourself.	self assert: (root at: #a) = #default.	self assert: (user1 at: #a) = 1.	self should: [ user2 at: #a ] raise: WAAttributeNotFound.	self assert: (top at: #a) = 1.	self assert: (mirror at: #a) = 1</body><body package="Seaside-Tests-Core">testValueWithoutAttributeWithIfAbsentBlock	"A user configuration should not be able to provide a value if it does not inherit the attribute."	| root top mirror user1 user2 absent |	root := self basicSystemConfiguration.	user1 := WAUserConfiguration new		addParent: root;		yourself.	user1 		at: #a		put: 1.	user2 := WAUserConfiguration new		addParent: root;		yourself.	user2 		at: #a		put: 2.	user2 removeParent: root.	top := WAUserConfiguration new		addParent: user1;		addParent: user2;		yourself.	mirror := WAUserConfiguration new		addParent: user2;		addParent: user1;		yourself.	self assert: (root at: #a) = #default.	self assert: (user1 at: #a) = 1.	absent := false.	user2 at: #a ifAbsent: [ absent := true ].	self assert: absent.	self assert: (top at: #a) = 1.	self assert: (mirror at: #a) = 1</body><body package="Seaside-Tests-Core">testValueWithoutDefault	"Make sure that a configuration can specify a local value even if the attribute doesn't have a default value." 		| root1 root2 user |	root1 := WAConfigurationMock new		description: [ :config | config string: #a ];		yourself.	root2 := WAConfigurationMock new		description: [ :config | config string: #b ];		yourself.		user := WAUserConfiguration new addParent: root1; addParent: root2; yourself.	user at: #a put: 1.	user at: #b put: 2.		self assert: (root1 at: #a) isNil.	self assert: (root2 at: #b) isNil.	self assert: (user at: #a) = 1.	self assert: (user at: #b) = 2</body></methods><methods><class-id>Seaside.WAConfigurationTest</class-id> <category>accessing</category><body package="Seaside-Tests-Core">basicSystemConfiguration	^ WAConfigurationMock new		description: [ :config | (config string: #a) default: #default ];		yourself</body></methods><methods><class-id>Seaside.WAObjectTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testError	"Make sure #error: signals a subclass of WAError."		self should: [ WAObject new error: 'oh dear' ] raise: WAError.	self should: [ WAObject error: 'oh dear' ] raise: WAError</body><body package="Seaside-Tests-Core">testRequestContext	| context |	self should: [ WAObject new requestContext ] raise: WARequestContextNotFound.		context := WARequestContext request: nil response: nil.	WACurrentRequestContext		use: context		during: [ self assert: WAObject new requestContext == context ]</body></methods><methods><class-id>Seaside.WARegistryTest</class-id> <category>private</category><body package="Seaside-Tests-Core">newHandler	^ WARegistry new</body><body package="Seaside-Tests-Core">requestContextFor: aRequest	^ WARequestContext request: aRequest response: WABufferedResponse</body><body package="Seaside-Tests-Core">requestWithMethod: aString	^ WARequest		method: aString		uri: '/app/oneo'</body></methods><methods><class-id>Seaside.WARegistryTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testCopyRegistry	| stored key copy stored2 key2 |	(handler isKindOf: WAApplication) "applicaiton can only track session"		ifTrue: [ ^ self ].	stored := WARequestHandler new.	key := handler register: stored.	copy := handler copy.		self assert: (handler cache at: key ifAbsent: [ nil ]) = stored.	"Since registry keys are dynamically assigned, we don't expect a copy to have the same	keys and values."		stored2 := WARequestHandler new.	key2 := handler register: stored2.	self assert: (handler cache at: key2 ifAbsent: [ nil ]) = stored2.	self assert: (copy cache at: key2 ifAbsent: [ nil ]) isNil.		copy clear.	self assert: (handler cache at: key ifAbsent: [ nil ]) = stored</body><body package="Seaside-Tests-Core">testUrlFor	| context request response documentHandler url |	handler class == WARegistry "only WARegistry supports tracking generic request handlers"		ifFalse: [ ^ self ].	request := self requestWithMethod: 'GET'.	request setCookies: (Array with: (WARequestCookie key: '_s' value: 'sessionid')).	response := WABufferedResponse new.	documentHandler := WADocumentHandler document: 'ESUG 2015'.		context := WARequestContext request: request response: response.	url := WACurrentRequestContext		use: context		during: [ handler register: documentHandler;			urlFor: documentHandler ].	self assert: (url queryFields includesKey: '_s').	request url addField: '_s' value: (url queryFields at: '_s').			[  handler handle: context ]		on: WAResponseNotification		do: [ :notification | ].			self assert: response status = 200.	self assert: (response cookies isEmpty)</body></methods><methods><class-id>Seaside.WALocaleTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testCountryName	| locale |	locale := WALocale fromString: 'de-CH'.		self assert: locale countryName = 'SWITZERLAND'.		locale := WALocale fromString: 'en-ZA'.		self assert: locale countryName = 'SOUTH AFRICA'.		locale := WALocale fromString: 'eng-ZAF'.		self assert: locale countryName = 'SOUTH AFRICA'</body><body package="Seaside-Tests-Core">testIso3	| locale |	locale := WALocale fromString: 'gsw-CHE'.	self assert: locale language = 'gsw'.	self assert: locale country = 'CHE'.	self assert: locale greaseString = 'gsw-CHE'.	locale := WALocale fromString: 'gsw_CHE'.	self assert: locale language = 'gsw'.	self assert: locale country = 'CHE'.	self assert: locale greaseString = 'gsw-CHE'</body><body package="Seaside-Tests-Core">testLanguage	| locale |	locale := WALocale language: 'de'.	self assert: locale language = 'de'.	self assert: locale country isNil</body><body package="Seaside-Tests-Core">testLanguageName	| locale |	locale := WALocale fromString: 'de'.		self assert: locale languageName = 'German'.		locale := WALocale fromString: 'gsw'.		self assert: locale languageName = 'Swiss German; Alemannic; Alsatian'</body><body package="Seaside-Tests-Core">testLangugeAndCountry	| locale |	locale := WALocale fromString: 'de-CH'.	self assert: locale language = 'de'.	self assert: locale country = 'CH'.	self assert: locale greaseString = 'de-CH'.	locale := WALocale fromString: 'de_CH'.	self assert: locale language = 'de'.	self assert: locale country = 'CH'.	self assert: locale greaseString = 'de-CH'</body><body package="Seaside-Tests-Core">testLangugeOnly	| locale |	locale := WALocale fromString: 'de'.	self assert: locale language = 'de'.	self assert: locale country isNil.	self assert: locale greaseString = 'de'</body><body package="Seaside-Tests-Core">testWithoutCountry	| locale |	locale := WALocale fromString: 'de_CH'.	self assert: locale language = 'de'.	self assert: locale country = 'CH'.	locale := locale withoutCountry.	self assert: locale language = 'de'.	self assert: locale country isNil.		locale := WALocale fromString: 'de'.	self assert: locale language = 'de'.	self assert: locale country isNil.	locale := locale withoutCountry.	self assert: locale language = 'de'.	self assert: locale country isNil</body></methods><methods><class-id>Seaside.WADocumentHandlerResponseTest</class-id> <category>private</category><body package="Seaside-Tests-Core">assertHttpResponseFrom: aResponse matches: aHandler	| expectedContents actualContents |	self assert: aResponse status = 200.	self assert: aResponse contentType = aHandler document mimeType.	expectedContents := aHandler document contents.	actualContents := aResponse contents.	self assert: actualContents size = expectedContents size.	self assert: actualContents species = expectedContents species.	self assert: aResponse cookies isEmpty</body><body package="Seaside-Tests-Core">createAndVerifyBinaryDocumentNamed: aFilename hasAttachment: aHttpHeaderValue	self		createAndVerifyDocumentNamed: aFilename		content: WATestingFiles default samplePng		mimeType: WAMimeType imagePng		hasAttachment: aHttpHeaderValue</body><body package="Seaside-Tests-Core">createAndVerifyDocumentNamed: aFilename content: anObject mimeType: aMimeTypeString hasAttachment: aHttpHeaderValue	| handler response |	handler := WADocumentHandler		document: anObject		mimeType: aMimeTypeString		fileName: aFilename.	self assert: handler document contents = anObject.	response := self responseAfter: [ handler handle: self requestContext ].	self assert: (self headerAt: 'Expires' forResponse: response) notNil.	self assert: (self headerAt: 'Content-Disposition' forResponse: response) = aHttpHeaderValue.	self assertHttpResponseFrom: response matches: handler</body><body package="Seaside-Tests-Core">createAndVerifyTextDocumentNamed: aFilename hasAttachment: aHttpHeaderValue	self		createAndVerifyDocumentNamed: aFilename		content: 'body { background-color: #ffffff }'		mimeType: WAMimeType textCss		hasAttachment: aHttpHeaderValue</body><body package="Seaside-Tests-Core">headerAt: aString forResponse: aResponse	^ aResponse headerAt: aString</body></methods><methods><class-id>Seaside.WADocumentHandlerResponseTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testByteArrayWithFilename	self		createAndVerifyBinaryDocumentNamed: 'sample.png'		hasAttachment: 'attachment; filename="sample.png"'</body><body package="Seaside-Tests-Core">testByteArrayWithoutFilename	self		createAndVerifyBinaryDocumentNamed: nil		hasAttachment: nil</body><body package="Seaside-Tests-Core">testStringWithFilename	self		createAndVerifyTextDocumentNamed: 'toolbar.css'		hasAttachment: 'attachment; filename="toolbar.css"'</body><body package="Seaside-Tests-Core">testStringWithoutFilename	self		createAndVerifyTextDocumentNamed: nil		hasAttachment: nil</body></methods><methods><class-id>Seaside.WAMimeTypeTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testBasic	| mimeType |	mimeType := WAMimeType fromString: 'image/jpeg'.	self assert: mimeType main = 'image'.	self assert: mimeType sub = 'jpeg'.	self assert: mimeType parameters isEmpty.	self assert: mimeType greaseString = 'image/jpeg'</body><body package="Seaside-Tests-Core">testCharSet	| mimeType |	mimeType := WAMimeType fromString: 'text/html'.	mimeType charset: 'utf-8'.	self assert: mimeType greaseString = 'text/html;charset=utf-8'</body><body package="Seaside-Tests-Core">testConversion	| mimeType |	mimeType := 'image/jpeg' seasideMimeType.	self assert: (mimeType isKindOf: WAMimeType).	self assert: mimeType main = 'image'.	self assert: mimeType sub = 'jpeg'.	self assert: mimeType parameters isEmpty.	self assert: mimeType greaseString = 'image/jpeg'.	mimeType := mimeType seasideMimeType.	self assert: (mimeType isKindOf: WAMimeType)</body><body package="Seaside-Tests-Core">testEquals	| first second |	first := WAMimeType fromString: 'text/html'.	second := WAMimeType fromString: 'text/html'.		self assert: first = second.	self assert: first hash = second hash.		second charset: 'utf-8'.	self assert: first = second.	self assert: first hash = second hash.		first charset: 'iso-8859-1'.	self assert: first = second.	self assert: first hash = second hash.		second := WAMimeType fromString: 'text/xml'.	self deny: first = second</body><body package="Seaside-Tests-Core">testIsBinary	| notBinary binary |	notBinary := #('text/plain' 'text/bar' 'application/x-javascript' 'application/xhml+xml' 'application/xml').	notBinary do: [ :each |		| mimeType |		mimeType := WAMimeType fromString: each.		self deny: mimeType isBinary ].		binary := #('application/octet-stream' 'image/jpeg').	binary do: [ :each |		| mimeType |		mimeType := WAMimeType fromString: each.		self assert: mimeType isBinary ]</body><body package="Seaside-Tests-Core">testIsNonStandard	| mimeType |	mimeType := WAMimeType fromString: 'image/png'.	self deny: mimeType isNonStandard.		mimeType := WAMimeType fromString: 'image/x-icon'.	self assert: mimeType isNonStandard.		mimeType := WAMimeType fromString: 'image/X-icon'.	self assert: mimeType isNonStandard.		mimeType := WAMimeType fromString: 'x-icon/image'.	self assert: mimeType isNonStandard.		mimeType := WAMimeType fromString: 'X-icon/image'.	self assert: mimeType isNonStandard</body><body package="Seaside-Tests-Core">testIsVendorSpecifc	| mimeType |	mimeType := WAMimeType fromString: 'image/png'.	self deny: mimeType isVendorSpecific.		mimeType := WAMimeType fromString: 'image/vnd.microsoft.icon'.	self assert: mimeType isVendorSpecific.		mimeType := WAMimeType fromString: 'vnd.microsoft.icon/image'.	self deny: mimeType isVendorSpecific</body><body package="Seaside-Tests-Core">testIssue655	"Regression test for Issue 655 where java.net.HttpURLConnection would provide fucked up headers."	| mimeType |	mimeType := WAMimeType fromString: '*; q=.2'.	self assert: mimeType main = '*'.	self assert: mimeType sub = '*'.	self assert: (mimeType parameters at: 'q') = '.2'.		mimeType := WAMimeType fromString: '*'.	self assert: mimeType main = '*'.	self assert: mimeType sub = '*'.	self assert: (mimeType parameters at: 'q' ifAbsent: [ nil ]) isNil</body><body package="Seaside-Tests-Core">testJson	"regression test for	http://code.google.com/p/seaside/issues/detail?id=759"	self deny: (WAMimeType fromString: 'text/json') isBinary.	self deny: (WAMimeType fromString: 'application/json') isBinary</body><body package="Seaside-Tests-Core">testMatches	| pattern mimeType |	pattern := WAMimeType fromString: 'image/png'.	mimeType := WAMimeType fromString: 'image/png'.	self assert: (mimeType matches: pattern).		mimeType := WAMimeType fromString: 'image/gif'.	self deny: (mimeType matches: pattern).		pattern := WAMimeType fromString: 'image/*'.	mimeType := WAMimeType fromString: 'image/png'.	self assert: (mimeType matches: pattern).		mimeType := WAMimeType fromString: 'text/html'.	self deny: (mimeType matches: pattern).		pattern := WAMimeType fromString: '*/*'.	mimeType := WAMimeType fromString: 'image/png'.	self assert: (mimeType matches: pattern)</body><body package="Seaside-Tests-Core">testNoCharSet	| mimeType |	mimeType := WAMimeType fromString: 'text/html'.	self assert: mimeType charSet isNil</body><body package="Seaside-Tests-Core">testParamters	^ #('text/html;charset=utf-8' 'text/html; charset=utf-8' ) do: [ :each | 		| mimeType |		mimeType := WAMimeType fromString: each.		self assert: mimeType main = 'text'.		self assert: mimeType sub = 'html'.		self assert: mimeType parameters size = 1.		self assert: (mimeType parameters at: 'charset') = 'utf-8'.		self assert: mimeType greaseString = 'text/html;charset=utf-8' ]</body></methods><methods><class-id>Seaside.WAEncoderTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testEncodedUrl	self assert: 'Seaside Aubergines' urlEncodedGives: 'Seaside%20Aubergines'.	self assert: 'www.seaside.st' urlEncodedGives: 'www.seaside.st'.	self assert: '~seaside-info_' urlEncodedGives: '~seaside-info_'.	self assert: 'http://www.seaside.st?foo=1&amp;bar=2' urlEncodedGives: 'http%3A%2F%2Fwww.seaside.st%3Ffoo%3D1%26bar%3D2'.	self assert: 'a%' urlEncodedGives: 'a%25'.	self assert: (String with: Character cr) urlEncodedGives: '%0D'</body><body package="Seaside-Tests-Core">testEncodedXml	self assert: 'Seaside' xmlEncodedGives: 'Seaside'.	self assert: '&lt;div id="&amp;amp;"&gt;' xmlEncodedGives: '&amp;lt;div id=&amp;quot;&amp;amp;amp;&amp;quot;&amp;gt;'</body></methods><methods><class-id>Seaside.WAEncoderTest</class-id> <category>as yet unclassified</category><body package="Seaside-Tests-Core">testEncodedXmlUnicde	| lineSeparator paragraphSeparator snowMan string |	lineSeparator := Character codePoint: 16r2028.	paragraphSeparator := Character codePoint: 16r2028.	paragraphSeparator := Character codePoint: 16r2028.	snowMan := Character codePoint: 16r2603.	string := (String with: lineSeparator), (String with: paragraphSeparator), (String with: snowMan).	self assert: string xmlEncodedGives: string</body><body package="Seaside-Tests-Core">testEncodedXmlUnicdeSmp	| emoji string |	emoji := Character codePoint: 16r1F64C.	string := (String with: emoji).	self assert: string xmlEncodedGives: string</body></methods><methods><class-id>Seaside.WAEncoderTest</class-id> <category>private</category><body package="Seaside-Tests-Core">assert: aString urlEncodedGives: anEncodedString	| actual |	actual := String streamContents: [ :stream |		(GRPlatform current urlEncoderOn: stream codec: self requestContext codec) nextPutAll: aString ].	self assert: actual = anEncodedString</body><body package="Seaside-Tests-Core">assert: aString xmlEncodedGives: anEncodedString	| actual |	actual := String streamContents: [ :stream |		(GRPlatform current xmlEncoderOn: stream) nextPutAll: aString ].	self assert: actual = anEncodedString</body></methods><methods><class-id>Seaside.WAEncoderTest class</class-id> <category>testing</category><body package="Seaside-Tests-Core">shouldInheritSelectors	^ true</body></methods><methods><class-id>Seaside.WAPlatformTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testSeasideVersion	self assert: (self platform seasideVersion isKindOf: GRVersion)</body></methods><methods><class-id>Seaside.WAAbstractHtmlElementTest</class-id> <category>private</category><body package="Seaside-Tests-Core">assert: aBlock gives: aString	| html |	html := String streamContents: [ :stream |		| context root document |		document := WAHtmlDocument on: stream.		context := WARenderContext new			actionUrl: WAUrl new;			document: document;			yourself.		 root := WAHtmlRoot context: context.		 aBlock value: root.		document open: root.		document close ].	self		assert: html = ('&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;', aString, '&lt;/head&gt;&lt;body onload="onLoad()"&gt;&lt;script type="text/javascript"&gt;function onLoad(){};&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;')		description:	'Expected: ' , aString printString , ', Actual: ' , html printString		resumable: true</body></methods><methods><class-id>Seaside.WAAbstractHtmlElementTest class</class-id> <category>testing</category><body package="Seaside-Tests-Core">isAbstract	^ self name = #WAAbstractHtmlElementTest</body></methods><methods><class-id>Seaside.WAMetaElementTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testLeftToRight	self		assert: [ :root | root meta beLeftToRight ]		gives: '&lt;meta dir="LTR"/&gt;'</body></methods><methods><class-id>Seaside.WABidirectionalCacheTest</class-id> <category>running</category><body package="Seaside-Tests-Core">createCache	^ WABidirectionalCache new</body></methods><methods><class-id>Seaside.WABidirectionalCacheTest</class-id> <category>testing</category><body package="Seaside-Tests-Core">testCopy	| copy absent |	cache at: 1 put: '1'.	cache at: 2 put: '2'.	copy := cache copy.		copy remove: '2'.	copy at: 1 put: '1a'.	copy at: 3 put: '3'.		"cache:		1 -&gt; '1'		2 -&gt; '2'	copy:		1 -&gt; '1a'		3 -&gt; '3'	"		self assert: (cache at: 1 ifAbsent: [ self assert: false ]) = '1'.	self assert: (cache at: 2 ifAbsent: [ self assert: false ]) = '2'.	self assert: (cache keyAtValue: '1' ifAbsent: [ self assert: false ]) = 1.	self assert: (cache keyAtValue: '2' ifAbsent: [ self assert: false ]) = 2.	absent := false.	cache at: 3 ifAbsent: [ absent := true ].	self assert: absent.	absent := false.	cache keyAtValue: '1a' ifAbsent: [ absent := true ].	self assert: absent.	cache keyAtValue: '3' ifAbsent: [ absent := true ].	self assert: absent.		self assert: (copy at: 1 ifAbsent: [ self assert: false ]) = '1a'.	self assert: (copy at: 3 ifAbsent: [ self assert: false ]) = '3'.	self assert: (copy keyAtValue: '1a' ifAbsent: [ self assert: false ]) = 1.	self assert: (copy keyAtValue: '3' ifAbsent: [ self assert: false ]) = 3.	absent := false.	copy at: 2 ifAbsent: [ absent := true ].	self assert: absent.	absent := false.	copy keyAtValue: '1' ifAbsent: [ absent := true ].	self assert: absent.	copy keyAtValue: '2' ifAbsent: [ absent := true ].	self assert: absent</body><body package="Seaside-Tests-Core">testKeyAtValue	1 to: 100 do: [ :i |		| absent key |		absent := false.		cache keyAtValue: i greaseString ifAbsent: [ absent := true ].		self assert: absent.		cache at: i put: i greaseString.		key := cache keyAtValue: i greaseString ifAbsent: [ self assert: false ].		self assert: key = i ]</body><body package="Seaside-Tests-Core">testMultipleMappings	cache at: 'key1' put: 'value'.	self should: [ cache at: 'key2' put: 'value' ] raise: Error</body><body package="Seaside-Tests-Core">testRemove	1 to: 100 do: [ :i |		cache at: i put: i greaseString ].		1 to: 100 do: [ :i |		| absent |		self assert: (cache at: i ifAbsent: [ self assert: false ]) = i greaseString.		cache remove: i greaseString.		absent := false.		cache at: i ifAbsent: [ absent := true ].		self assert: absent ]</body><body package="Seaside-Tests-Core">testValuesCollect	| values |	cache at: 1 put: '1'.	cache at: 2 put: '2'.		values := cache valuesCollect: [ :each |		each, each ].	self assert: values class == cache class.	self assert: values size = 2.	self assert: ((values at: 1 ifAbsent: [ nil ]) = '11').	self assert: ((values at: 2 ifAbsent: [ nil ]) = '22')</body></methods><methods><class-id>Seaside.WATestingFiles</class-id> <category>accessing-images</category><body package="Seaside-Tests-Core">sampleJs	^ '	function foo (a, b) {}'</body></methods><methods><class-id>Seaside.WATestingFiles</class-id> <category>uploaded</category><body package="Seaside-Tests-Core">samplePng	^ #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 0 16 0 0 0 16 8 6 0 0 0 31 243 255 97 0 0 0 6 98 75 71 68 0 255 0 255 0 255 160 189 167 147 0 0 0 9 112 72 89 115 0 0 11 19 0 0 11 19 1 0 154 156 24 0 0 0 7 116 73 77 69 7 214 4 9 20 4 42 36 195 187 166 0 0 2 112 73 68 65 84 56 203 173 147 221 75 83 113 24 199 63 155 155 110 57 245 164 169 232 24 180 240 173 50 207 48 74 144 68 27 82 209 141 43 147 145 136 226 159 97 36 236 70 130 174 162 232 38 34 42 86 104 26 42 5 74 47 243 5 65 212 110 52 148 48 95 74 156 107 206 236 156 249 50 117 110 167 139 58 232 130 186 144 30 248 193 247 226 249 124 248 61 207 143 31 28 172 146 107 156 213 74 119 119 183 114 16 216 180 15 222 19 184 65 116 67 167 27 228 223 167 211 13 226 31 112 226 126 184 198 89 173 104 84 24 232 183 55 54 10 73 201 41 16 217 37 184 178 66 95 107 171 4 84 44 222 110 89 150 229 96 219 204 204 76 89 93 109 61 85 85 85 212 56 171 105 111 123 169 87 5 157 246 250 122 135 226 245 18 24 25 1 69 225 136 77 132 212 52 94 127 15 140 249 46 86 230 100 103 153 15 23 228 159 160 188 188 92 133 117 64 36 14 224 42 60 40 42 41 73 88 236 233 97 119 99 131 104 56 204 178 94 199 156 205 198 194 217 211 230 230 155 46 163 86 27 135 40 138 108 132 130 60 122 248 88 7 68 0 180 234 112 74 40 4 202 222 78 190 230 230 225 63 83 76 83 83 51 62 159 143 188 188 60 218 59 94 176 24 76 222 108 56 89 89 168 246 169 2 79 48 16 32 45 63 31 157 193 192 252 229 75 248 47 216 185 238 172 197 231 243 97 52 26 233 31 232 227 211 236 23 4 177 250 208 146 144 237 138 17 76 31 79 126 254 166 191 87 193 100 226 104 105 41 19 69 133 92 113 92 99 109 109 13 69 81 88 95 15 50 60 58 202 80 192 138 201 168 195 159 146 105 143 17 124 168 73 170 141 27 44 211 188 21 38 232 26 241 144 62 61 133 167 239 61 130 32 32 203 50 119 238 221 229 227 143 12 66 187 113 108 135 35 49 239 170 3 208 155 37 123 162 152 195 192 173 49 182 36 3 130 55 132 102 106 146 150 251 207 8 71 34 172 104 173 44 109 9 164 101 89 9 200 219 100 202 126 79 140 0 32 204 38 74 244 87 150 204 195 196 235 102 241 246 26 176 228 22 99 200 182 112 42 43 129 213 245 29 62 15 116 72 54 105 201 21 35 8 123 5 207 106 116 206 97 201 201 96 97 122 25 128 236 226 45 178 114 94 49 120 99 202 247 77 41 72 4 200 148 253 30 155 180 228 122 50 249 110 92 21 104 0 28 117 86 49 122 46 208 127 190 193 34 24 73 37 202 46 235 138 159 161 167 43 146 118 40 189 162 203 61 63 254 183 143 161 81 131 163 206 42 238 28 219 113 233 205 146 93 189 85 252 92 188 235 95 240 127 169 159 24 23 11 103 188 240 115 88 0 0 0 0 73 69 78 68 174 66 96 130) asByteArray</body></methods><methods><class-id>Seaside.WATestingFiles</class-id> <category>private</category><body package="Seaside-Tests-Core">defaultFileHandler	"Superclass could have implementation of (WAFileHandler default), 	but that is not defined at time test runs when they are loaded in order."	^ WADispatcher new register: WAFileHandler new at: 'files'</body><body package="Seaside-Tests-Core">nonFileSelectors	^ super nonFileSelectors copyWith: #defaultFileHandler</body></methods><methods><class-id>Seaside.WATestingFiles</class-id> <category>accessing</category><body package="Seaside-Tests-Core">urlOf: aSymbol	"Could this be moved to the superclass? --JGF"	^ self urlOf: aSymbol using: self defaultFileHandler</body></methods><methods><class-id>Seaside.WAForbiddenFileHandlerListingTest</class-id> <category>testing</category><body package="Seaside-Tests-Core">expectedLibrariesContents	^ 'forbidden'</body><body package="Seaside-Tests-Core">expectedLibraryContents	^ 'forbidden'</body><body package="Seaside-Tests-Core">expectedMimeType	^ WAMimeType textPlain</body><body package="Seaside-Tests-Core">expectedStatus	^ 403</body><body package="Seaside-Tests-Core">handlerClass	^ WAForbiddenFileHandlerListing</body></methods><methods><class-id>Seaside.WADynamicVariableTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testAnswer	self assert: (WADynamicVariable use: 'value' during: [ true ])</body><body package="Seaside-Tests-Core">testWithNestedValue	WADynamicVariable 		use: 'outer' 		during: [			WADynamicVariable 				use: 'inner'				during: [ self assert: WADynamicVariable value = 'inner' ].			self assert: WADynamicVariable value = 'outer' ]</body><body package="Seaside-Tests-Core">testWithValue	WADynamicVariable 		use: 'value' 		during: [ self assert: WADynamicVariable value = 'value' ]</body><body package="Seaside-Tests-Core">testWithoutValue	self assert: WADynamicVariable value isNil</body></methods><methods><class-id>Seaside.WAFileHandlerTest</class-id> <category>private</category><body package="Seaside-Tests-Core">newHandler	^ WAFileHandler new</body></methods><methods><class-id>Seaside.WAFileHandlerTest</class-id> <category>testing</category><body package="Seaside-Tests-Core">assertListing: aResponse	self assert: aResponse status = 403.	self assert: aResponse contentType main = 'text'.	self assert: aResponse contentType sub = 'plain'</body><body package="Seaside-Tests-Core">assertNotExisiting: aResponse	self assert: aResponse status = 404.	self assert: aResponse contentType main = 'text'.	self assert: aResponse contentType sub = 'plain'</body><body package="Seaside-Tests-Core">testHandleDoesNotExist	| response |	self requestContextWithUrl: '/root/files/Cheeseburger/'.	response := self responseAfter: [ handler handle: self requestContext ].	self assertNotExisiting: response.		self requestContextWithUrl: '/root/files/Cheeseburger'.	response := self responseAfter: [ handler handle: self requestContext ].	self assertNotExisiting: response.		self requestContextWithUrl: '/root/files/WAStandardFiles/cheeseburger.jpeg'.	response := self responseAfter: [ handler handle: self requestContext ].	self assertNotExisiting: response</body><body package="Seaside-Tests-Core">testHandleFileRequest	| response |	self requestContextWithUrl: '/root/files/WATestingFiles/sample.js'.	self requestContext consumer next; next.	response := self responseAfter: [ handler handle: self requestContext ].	self assert: response status = 200.	self assert: response contentType main = 'application'.	self assert: response contentType sub = 'x-javascript'.	self assert: response contents = WATestingFiles new sampleJs</body><body package="Seaside-Tests-Core">testHandleListing	| response |	self requestContextWithUrl: '/root/files/WATestingFiles/'.	requestContext consumer next; next.	response := self responseAfter: [ handler handle: self requestContext ].	self assertListing: response.		self requestContextWithUrl: '/root/files/WATestingFiles'.	requestContext consumer next; next.	response := self responseAfter: [ handler handle: self requestContext ].	self assertListing: response.		self requestContextWithUrl: '/root/files/'.	requestContext consumer next; next.	response := self responseAfter: [ handler handle: self requestContext ].	self assertListing: response.		self requestContextWithUrl: '/root/files'.	requestContext consumer next; next.	response := self responseAfter: [ handler handle: self requestContext ].	self assertListing: response</body><body package="Seaside-Tests-Core">testResourceBaseUrlConfigured	| actualUrl |	handler preferenceAt: #resourceBaseUrl put: (WAUrl absolute:  '/15/30').	actualUrl := WATestingFiles default urlOf: #sampleJs using: handler.	self assert: actualUrl greaseString = '/15/30/WATestingFiles/sample.js'</body><body package="Seaside-Tests-Core">testResourceBaseUrlNotConfigured	| actualUrl |	handler preferenceAt: #resourceBaseUrl put: nil.	actualUrl := WATestingFiles default urlOf: #sampleJs using: handler.	self assert: actualUrl greaseString = ('/', self handlerName, '/WATestingFiles/sample.js')</body></methods><methods><class-id>Seaside.WABufferedResponseTest</class-id> <category>accessing</category><body package="Seaside-Tests-Core">contents	| stream |	stream := WriteStream on: String new.	self response writeOn: stream.	^ stream contents</body><body package="Seaside-Tests-Core">response	^ super response ifNil: [ response := WABufferedResponse new ]</body></methods><methods><class-id>Seaside.WABufferedResponseTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testIsCommitted	super testIsCommitted.	self deny: self response isCommitted</body></methods><methods><class-id>Seaside.WABufferedResponseTest</class-id> <category>tests-conveniance</category><body package="Seaside-Tests-Core">testEmptyAfterReset	| resetPossible |	resetPossible := self response		status: WAResponse statusNotFound;		attachmentWithFileName: 'upload.csv';		nextPutAll: 'the content';		resetIfPossible.	self assert: resetPossible.	self assertLines: #('HTTP/1.1 200 OK' 'Content-Length: 0' '')</body><body package="Seaside-Tests-Core">testResetThenWrite	| resetPossible |	resetPossible := self response		status: WAResponse statusNotFound;		attachmentWithFileName: 'upload.csv';		nextPutAll: 'the wrong content';		resetIfPossible.	self assert: resetPossible.	self response		status: WAResponse statusImATeapot;		headerAt: 'X-The-Header' put: 'the value';		nextPutAll: 'the real content'.	self assertLines: #('HTTP/1.1 418 I''m a teapot' 'X-The-Header: the value' 'Content-Length: 16' '' 'the real content')</body></methods><methods><class-id>Seaside.WAConfigurationMock</class-id> <category>ancestry</category><body package="Seaside-Tests-Core">parents	^ parentsBlock isNil 		ifFalse: [ parentsBlock value ]		ifTrue: 			[ #() ]</body></methods><methods><class-id>Seaside.WAConfigurationMock</class-id> <category>accessing</category><body package="Seaside-Tests-Core">description: aBlock	describeBlock := aBlock</body><body package="Seaside-Tests-Core">parents: aBlock 	parentsBlock := aBlock</body></methods><methods><class-id>Seaside.WAConfigurationMock</class-id> <category>description</category><body package="Seaside-Tests-Core">describeOn: config	describeBlock isNil ifFalse: [ describeBlock value: config ]</body></methods><methods><class-id>Seaside.WAConfigurationMock class</class-id> <category>instance creation</category><body package="Seaside-Tests-Core">new	"For testing, we'd rather create new instances than use singletons."	^ self basicNew initialize</body></methods><methods><class-id>Seaside.WAUnidirectionalCacheTest</class-id> <category>running</category><body package="Seaside-Tests-Core">createCache	^ WAUnidirectionalCache new</body></methods><methods><class-id>Seaside.WAUnidirectionalCacheTest</class-id> <category>testing</category><body package="Seaside-Tests-Core">testCopy	| copy absent |	cache at: 1 put: '1'.	cache at: 2 put: '2'.	copy := cache copy.		copy at: 1 put: '1a'.	copy at: 3 put: '3'.		"cache:		1 -&gt; '1'		2 -&gt; '2'	copy:		1 -&gt; '1a'		2 -&gt; '2'		3 -&gt; '3'	"		self assert: (cache at: 1 ifAbsent: [ self assert: false ]) = '1'.	self assert: (cache at: 2 ifAbsent: [ self assert: false ]) = '2'.	absent := false.	cache at: 3 ifAbsent: [ absent := true ].	self assert: absent.		self assert: (copy at: 1 ifAbsent: [ self assert: false ]) = '1a'.	self assert: (cache at: 2 ifAbsent: [ self assert: false ]) = '2'.	self assert: (copy at: 3 ifAbsent: [ self assert: false ]) = '3'</body></methods><methods><class-id>Seaside.WAFileTest</class-id> <category>running</category><body package="Seaside-Tests-Core">setUp	file := WAFile new</body></methods><methods><class-id>Seaside.WAFileTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testBorderline	file fileName: 'C'.	self assert: file fileName = 'C'.	file fileName: 'C:'.	self assert: file fileName = 'C:'.	file fileName: 'C:\'.	self assert: file fileName = ''</body><body package="Seaside-Tests-Core">testContentType	file contentType: 'text/plain'.	self assert: file contentType = 'text/plain' seasideMimeType.		file contentType: 'text/plain' seasideMimeType.	self assert: file contentType = 'text/plain' seasideMimeType.	file contentType: nil.	self assert: file contentType isNil</body><body package="Seaside-Tests-Core">testContents	file contents: #(83 101 97 115 105 100 101) asByteArray.	self assert: file rawContents = #(83 101 97 115 105 100 101) asByteArray.	self assert: (file contentsDecodedUsing: 'ISO-8859-1') = 'Seaside'</body><body package="Seaside-Tests-Core">testContentsDecoded	file contents: #(83 101 97 115 105 100 101) asByteArray.	self should: [ file contentsDecoded ] raise: WAIllegalStateException.	file contentType: 'text/plain'.	self should: [ file contentsDecoded ] raise: WAIllegalStateException.	file contentType: 'text/plain; charset=iso-8859-1' seasideMimeType.	self assert: file contentsDecoded = 'Seaside'</body><body package="Seaside-Tests-Core">testNonLatinWindowsPath	| koreanName |	"If the following assertion fails, your Smalltalk dialect most probably does not support non-latin characters. This is true for Squeak 3.7. If your Smalltalk dialect does support non-latin characters adjust the test."	self shouldnt:  [		koreanName := (String			with: (Character codePoint: 50976)			with: (Character codePoint: 47532)			with: (Character codePoint: 47484)), '.txt' ]		raise: Error.	file fileName: koreanName.	self assert: file fileName = koreanName.	file fileName: 'C:\important\', koreanName.	self assert: file fileName = koreanName</body><body package="Seaside-Tests-Core">testWindowsPath	file fileName: 'C:\important\passwords.txt'.	self assert: file fileName = 'passwords.txt'.	file fileName: '/important/passwords.txt'.	self assert: file fileName = '/important/passwords.txt'.	file fileName: 'passwords.txt'.	self assert: file fileName = 'passwords.txt'</body></methods><methods><class-id>Seaside.WATestingMetadataFileLibrary</class-id> <category>uploaded</category><body package="Seaside-Tests-Core">demoJpegContent	^ #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255) asByteArray</body><body package="Seaside-Tests-Core">demoTxtContent	^ 'this is a string'</body><body package="Seaside-Tests-Core">imgglyphiconshalflingsPngContent	^ #(137 80 78 71 13 10 26 10 0 0 0 13 73 72 68 82 0 0 1 213 0 0 0 133 8 3 0 0 0 58 158 146 134 0 0 0 132 80 76 84 69 255 255 255 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 51 132 103 176 84 0 0 0 43 116 82 78 83 0 207 15 239 159 191 47 95 223 31 175 63 127 77 143 79 128 111 9 246 216 171 75 168 162 72 27 30 201 243 117 195 147 249 213 237 39 144 192 42 122 199 189 204 142 115 190 0 0 16 0 73 68 65 84 120 94 237 157 137 114 164 56 151 133 175 214 5 104 178 243 95 102 221 247 229 188 255 251 77 24 112 43 204 185 74 96 112 185 171 106 116 42 42 211 113 144 111 10 125 72 41 225 27 66 126 30 117 89 7 192 45 134 193 111 50 74 193 199 108 176 243 198 33 187 97 148 79 209 112 197 183 1 8 86 190 99 113 251 176 207 74 2 72 146 150 0 178 226 168 82 133 136 96 229 102 176 201 236 27 236 141 40 176 15 154 176 200 87 231 229 213 81 6 184 89 38 135 161 8 41 226 65 94 219 15 0 16 232 156 171 200 47 100 203 230 22 213 175 113 88 214 239 218 199 27 43 98 141 151 70 251 156 244 173 129 0 2 99 79 83 181 33 112 97 84 85 172 74 212 213 119 31 131 142 112 73 100 116 59 30 173 171 195 102 0 88 94 28 215 100 166 147 124 229 171 77 14 193 47 139 32 76 85 24 210 230 138 238 183 169 90 179 107 33 15 24 107 13 224 91 237 115 202 23 3 35 192 242 118 142 170 91 175 110 39 47 21 221 2 47 106 244 195 51 202 199 160 3 210 2 119 95 9 95 175 14 47 85 79 84 61 137 83 94 81 179 111 200 111 82 197 59 85 124 42 85 134 186 227 103 0 152 229 133 218 7 160 246 105 182 91 130 89 193 25 164 115 84 3 22 133 102 103 173 88 21 168 130 113 125 219 129 120 63 169 93 225 13 171 177 30 82 53 161 106 146 42 73 14 239 114 137 252 72 254 205 190 122 93 12 213 88 178 200 149 188 126 40 181 79 203 15 136 43 184 136 65 69 186 167 106 1 83 74 0 236 190 232 175 219 191 205 136 64 20 22 68 161 234 90 84 23 172 11 84 72 85 66 213 71 72 197 108 182 137 59 63 63 23 186 155 95 181 240 118 215 250 234 253 239 213 56 216 10 149 176 146 235 136 222 129 239 100 147 203 103 168 142 1 40 11 219 16 95 83 21 64 206 82 29 214 30 28 145 137 170 88 99 172 120 128 198 11 125 200 152 23 123 22 246 147 60 200 223 72 145 87 199 77 136 174 91 35 112 116 48 165 66 213 168 82 251 0 212 62 205 118 203 142 248 190 164 26 43 213 241 255 78 53 142 31 143 61 224 198 165 163 77 187 194 94 188 183 214 123 241 160 115 215 103 99 113 241 31 194 254 35 60 200 103 170 199 125 181 220 159 45 13 84 125 26 129 15 218 135 124 30 129 87 222 129 145 234 35 112 176 150 70 224 75 84 61 53 164 7 140 225 233 149 23 15 120 15 120 241 116 246 42 84 153 129 12 120 221 119 228 143 235 116 122 252 218 239 85 174 62 207 150 218 237 115 236 167 119 152 1 233 128 42 205 150 174 83 125 228 197 84 190 201 146 1 242 228 8 43 54 249 198 76 131 148 49 201 19 238 156 111 103 108 154 237 151 126 175 114 245 121 101 211 110 159 99 223 32 196 101 96 53 13 164 237 149 205 117 170 14 139 57 135 33 182 214 67 174 48 84 29 171 10 53 230 248 246 106 30 167 252 92 227 231 175 93 175 114 245 249 46 196 113 251 176 95 195 195 57 190 112 152 42 223 133 104 83 109 156 139 161 245 37 97 37 84 45 149 172 158 223 74 218 198 83 62 170 112 202 191 79 149 239 42 177 174 183 15 251 41 184 60 36 145 211 84 101 140 194 114 88 229 228 142 202 75 168 93 197 254 160 237 214 213 213 213 213 213 213 213 213 213 213 213 213 213 213 213 213 213 149 228 167 83 151 135 103 179 157 242 147 66 118 33 145 109 129 105 2 172 26 170 29 231 172 255 192 166 71 187 188 122 215 220 107 229 135 100 205 171 204 75 74 189 154 228 180 210 16 194 144 228 243 196 88 184 158 16 136 0 2 217 124 15 192 55 168 146 223 252 203 145 164 149 106 58 160 202 113 206 249 51 54 249 107 113 28 116 31 56 71 213 146 185 10 50 78 83 20 17 207 185 232 192 231 229 163 23 78 101 216 200 189 164 234 107 91 49 213 234 243 95 121 233 0 30 15 144 205 84 57 78 219 231 228 70 228 75 113 28 112 206 175 197 136 106 148 81 163 234 0 228 96 40 254 84 68 202 164 52 68 92 45 205 47 45 191 236 186 9 54 126 130 151 84 61 86 121 149 42 249 9 65 4 74 70 70 193 166 210 164 202 113 176 196 33 127 158 201 47 239 212 12 98 51 67 132 125 15 64 216 183 228 11 4 162 102 181 45 5 53 170 106 215 158 222 41 36 26 180 39 64 222 128 139 226 99 20 209 124 247 240 153 251 42 228 160 175 122 64 199 90 43 172 228 175 10 231 175 62 1 140 35 128 231 41 170 156 7 91 253 17 24 247 254 243 189 126 30 79 138 99 162 26 135 68 254 113 95 117 120 151 59 69 53 123 217 228 51 15 240 5 41 161 176 47 243 82 121 246 167 33 34 146 95 233 232 84 61 208 192 138 77 90 254 42 148 252 213 12 32 70 0 153 71 102 0 70 180 56 168 113 170 111 51 144 237 206 31 222 97 62 17 148 56 211 62 78 118 162 202 145 255 186 175 162 234 20 213 218 233 70 40 148 18 144 52 122 163 19 81 253 125 55 6 253 192 84 91 244 218 126 94 105 96 223 62 177 94 67 81 207 70 227 56 6 48 75 28 142 79 237 143 247 147 27 1 165 252 92 203 115 246 244 25 190 149 229 37 170 116 21 215 53 128 253 84 170 85 168 105 58 55 169 30 231 175 206 248 77 179 158 141 198 113 34 150 151 64 241 1 138 15 44 92 71 0 160 242 121 172 229 185 158 131 176 168 252 245 190 106 195 163 60 40 91 111 109 213 173 129 239 143 192 115 107 4 62 166 42 34 7 84 143 103 39 25 64 222 222 26 173 194 113 166 137 226 240 44 170 198 153 182 197 35 149 183 92 31 174 103 13 228 171 127 167 175 146 136 234 249 217 146 107 204 150 178 58 91 170 117 188 75 149 87 18 116 143 32 108 41 200 15 37 204 56 226 214 202 6 85 184 19 71 0 87 253 91 223 171 170 166 74 117 250 148 149 141 211 86 54 84 207 187 84 245 85 191 175 84 1 175 211 184 117 23 2 85 184 19 71 224 200 255 204 190 42 149 234 183 187 11 241 50 252 56 94 164 218 206 95 117 117 132 4 220 49 85 142 195 254 49 85 46 127 124 39 209 75 26 184 60 227 227 149 205 239 67 85 195 34 24 71 45 161 121 235 170 63 187 186 186 186 186 186 186 186 186 186 186 186 186 186 186 186 186 186 186 186 186 186 240 38 223 244 189 182 243 233 166 179 127 13 240 148 49 112 164 9 81 175 16 102 81 148 148 12 26 47 114 180 61 200 79 77 213 87 172 236 51 86 227 226 106 156 166 234 40 245 240 72 89 161 55 2 227 195 232 217 214 79 202 119 152 49 95 163 218 38 141 230 161 114 105 79 153 82 125 206 149 81 184 80 43 147 218 159 139 32 129 177 86 159 176 98 211 105 170 113 181 83 163 34 194 122 56 56 81 207 211 194 136 162 25 35 149 22 49 227 250 75 163 169 54 185 119 168 202 37 170 242 25 84 219 65 118 137 77 65 29 132 171 239 253 61 170 207 213 30 168 3 111 98 130 131 55 72 13 170 78 20 5 88 166 90 27 71 11 245 29 9 186 125 72 213 127 44 231 49 85 170 47 210 129 25 235 117 170 192 176 218 1 160 226 198 0 191 82 19 23 196 39 6 13 69 244 213 39 74 247 168 162 170 229 131 70 223 207 26 129 155 159 251 138 170 199 62 72 22 177 33 202 139 44 111 223 192 122 157 106 94 141 204 84 83 41 73 57 203 103 150 2 20 189 221 71 61 93 240 107 168 242 129 251 35 240 124 68 117 214 169 122 128 251 170 53 112 22 114 21 235 117 170 237 179 55 5 40 134 169 102 63 142 6 147 130 162 60 213 45 5 19 188 252 160 35 240 130 231 101 1 15 224 12 213 154 122 141 87 155 133 250 223 137 234 136 69 89 69 49 19 109 50 111 246 213 211 179 165 114 103 4 230 190 202 184 177 210 154 79 142 192 118 42 15 212 248 158 161 86 255 202 8 108 136 17 83 61 30 129 189 89 155 108 212 80 36 4 33 25 60 46 81 77 64 186 79 85 62 103 4 150 54 213 75 179 165 152 129 0 212 80 158 160 86 255 194 108 201 172 27 212 183 186 133 62 91 34 170 118 109 241 1 158 169 150 228 48 8 9 136 151 168 2 192 143 63 7 62 236 61 158 160 86 191 185 178 249 104 111 143 217 177 134 169 110 119 33 180 140 204 176 104 247 153 101 75 92 143 180 64 210 167 75 79 192 242 160 60 55 122 229 92 127 184 181 83 237 103 207 129 245 56 109 228 199 84 249 14 82 245 147 63 55 32 109 211 24 107 206 222 133 208 53 109 185 245 0 28 85 219 132 192 80 141 122 63 210 83 175 228 221 169 191 150 170 124 29 213 207 147 149 31 67 220 87 89 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 93 182 200 109 13 242 93 169 203 26 23 149 141 110 95 236 162 193 26 241 144 182 236 67 238 202 123 185 160 46 91 12 165 239 249 230 227 84 157 254 72 82 131 204 230 35 3 128 17 107 48 146 31 164 232 229 93 148 137 98 249 70 62 250 82 171 134 203 135 90 126 30 229 19 100 236 242 210 246 11 64 135 200 61 120 154 100 227 249 160 126 199 196 26 83 140 161 140 129 48 13 64 82 118 167 90 65 237 52 1 152 245 45 184 141 181 214 27 187 243 221 83 4 79 46 159 188 139 226 97 24 42 224 85 170 214 160 225 242 161 150 15 12 165 249 36 244 211 57 49 48 118 123 145 134 79 161 200 165 173 2 201 111 37 57 24 187 43 102 202 46 64 64 16 145 1 65 217 241 78 203 219 30 213 253 211 51 166 237 178 177 138 159 60 48 88 242 213 126 233 87 84 158 169 46 245 111 184 124 168 229 3 112 211 125 170 48 118 125 17 221 39 126 236 242 182 158 236 235 84 97 236 193 175 99 225 49 1 202 238 148 90 222 118 94 76 103 169 117 249 170 219 124 75 9 230 171 63 71 134 106 7 172 7 49 208 39 44 245 23 197 85 15 85 95 161 100 198 219 84 97 108 165 161 248 76 149 93 126 162 58 67 61 192 170 67 21 135 176 80 52 202 254 171 74 22 96 194 176 184 19 81 221 160 50 213 9 38 0 222 238 252 25 110 160 122 27 252 38 67 189 0 0 68 117 249 144 173 190 74 201 219 187 84 97 42 13 197 167 80 213 101 168 28 136 161 50 214 54 84 25 128 48 133 125 132 188 81 165 12 148 224 39 133 181 0 239 80 13 249 190 136 184 68 229 163 91 234 157 78 101 166 136 156 205 206 226 64 58 165 124 151 42 87 147 235 115 124 2 166 113 21 251 93 21 105 188 244 12 149 243 114 81 90 35 112 248 136 99 90 169 130 169 46 185 217 6 228 191 169 72 34 63 58 120 73 148 112 180 30 132 151 159 187 175 178 174 247 85 91 204 10 149 53 211 136 250 106 182 228 76 113 13 170 83 226 73 30 80 105 145 31 103 42 79 179 165 159 253 123 21 85 215 191 87 159 166 152 10 149 127 61 136 156 91 217 12 240 161 246 96 154 3 79 200 55 124 90 217 124 163 57 240 243 251 153 3 163 234 250 28 216 212 37 13 41 58 100 43 39 239 66 108 61 213 69 90 127 110 122 220 241 105 181 243 181 235 213 144 191 108 189 202 186 190 94 45 48 79 43 45 197 92 25 29 238 199 91 188 3 124 227 94 17 242 227 134 79 105 203 183 239 45 217 111 121 111 201 190 184 183 68 252 200 37 93 191 183 100 139 252 120 234 178 103 237 174 174 174 174 174 174 174 174 174 174 174 174 174 174 174 174 174 174 174 46 206 239 253 122 159 5 124 102 61 239 171 228 216 202 62 188 42 223 250 165 56 203 109 113 126 140 177 191 179 95 101 1 50 233 201 155 23 252 219 50 53 202 93 170 177 65 53 58 204 247 226 219 34 128 148 21 139 225 244 152 35 223 1 238 74 121 152 112 62 190 88 15 192 61 164 249 52 223 43 126 226 248 34 197 52 241 149 86 82 136 63 67 149 227 48 60 21 149 143 14 46 222 162 106 141 139 64 116 75 47 217 182 156 163 140 149 132 77 236 27 235 189 53 122 249 172 197 121 136 68 242 249 115 55 121 151 128 167 75 156 89 243 70 175 245 164 107 221 143 142 227 203 195 65 26 170 87 19 37 170 167 35 170 28 135 181 192 243 90 36 130 122 149 106 113 107 111 115 69 68 66 165 58 72 213 234 3 236 111 25 191 214 105 229 141 77 28 199 200 51 138 57 25 95 44 146 0 242 116 244 116 251 8 239 17 35 6 206 142 179 222 178 191 54 98 194 192 61 79 26 170 59 251 115 146 71 57 77 117 124 174 113 88 243 2 79 165 26 239 142 240 209 213 92 20 7 212 141 124 171 218 254 54 24 121 246 205 24 172 68 71 62 144 71 11 176 47 34 80 159 110 63 142 252 204 98 247 158 225 226 242 222 127 22 3 79 254 214 51 118 126 49 71 123 154 153 162 127 85 152 147 84 39 87 227 144 230 40 154 244 124 216 131 156 88 178 171 159 43 61 39 85 109 255 157 42 251 101 185 96 216 7 30 226 161 249 34 216 251 27 78 162 154 43 85 183 243 159 0 140 37 127 133 74 229 113 68 21 185 129 239 28 108 223 140 19 231 147 179 226 251 84 235 8 140 208 24 33 131 62 2 83 121 99 37 186 243 113 244 207 21 139 135 0 163 111 143 192 97 231 47 73 228 66 126 90 160 238 253 120 220 87 163 74 245 228 192 60 82 28 158 229 238 252 27 84 121 4 206 81 62 121 182 100 70 71 229 155 241 183 106 53 102 75 233 202 108 201 122 43 236 3 46 10 249 98 253 235 239 85 111 85 155 205 135 154 9 57 32 207 227 72 113 120 150 203 179 226 207 154 45 125 213 202 6 184 188 178 73 247 87 54 72 228 47 74 175 230 192 233 124 243 206 218 156 8 147 30 7 32 168 250 172 248 254 202 230 255 233 93 136 216 94 175 198 43 205 107 192 129 166 70 28 0 241 228 172 248 254 93 8 61 191 247 235 125 78 230 253 150 241 9 52 29 56 69 53 230 114 50 14 207 114 121 86 172 83 253 174 212 213 213 213 213 213 213 213 213 213 213 213 213 213 213 213 213 213 213 213 101 159 242 93 171 231 3 255 197 31 255 234 111 68 254 246 47 255 245 175 69 211 56 5 16 84 51 201 69 13 176 194 10 161 153 193 201 38 234 171 46 47 103 244 235 175 191 214 183 111 168 8 124 193 62 201 173 188 220 63 255 211 223 253 253 243 31 254 248 143 255 206 17 108 50 0 6 162 58 99 20 69 227 16 194 48 234 254 63 255 139 176 18 240 16 69 5 192 65 206 0 107 183 159 165 171 229 221 239 65 149 210 236 172 163 170 144 127 102 135 162 115 121 185 127 250 183 63 252 25 248 143 63 252 39 117 143 152 1 96 240 68 213 225 33 129 182 200 28 176 104 176 170 63 23 171 157 143 179 162 232 136 42 231 98 198 133 162 81 203 227 44 85 235 109 187 195 120 79 174 175 241 149 171 41 220 122 238 107 123 55 49 202 76 89 217 38 138 250 203 47 203 27 55 58 114 74 116 33 141 128 151 193 240 80 80 7 3 246 31 179 177 212 229 67 192 124 51 57 0 0 92 89 161 194 31 82 101 241 230 203 220 97 182 55 114 55 172 122 254 214 116 255 121 170 106 213 125 125 147 176 246 115 71 121 185 149 42 159 142 123 202 4 4 101 128 156 135 93 173 3 6 100 0 240 8 154 111 231 125 156 8 148 162 102 14 88 0 246 244 8 28 157 25 29 92 20 248 51 173 85 243 168 24 106 123 151 94 15 192 236 186 209 96 149 166 159 241 174 199 41 122 200 47 145 179 231 55 15 94 86 156 176 22 0 242 57 170 14 166 140 153 46 186 199 36 0 133 153 96 44 202 0 160 24 76 236 255 73 196 208 117 48 1 83 101 77 205 123 146 170 148 21 170 120 185 70 245 194 230 203 121 127 100 172 81 1 61 187 175 156 163 154 18 170 156 74 181 189 211 110 6 128 231 147 127 245 151 223 180 239 74 38 6 165 122 198 11 76 222 251 111 116 130 31 241 246 182 163 42 193 255 23 38 89 253 170 132 108 1 155 145 168 239 105 27 37 162 254 211 18 189 198 114 131 42 195 59 198 221 162 26 41 75 248 53 213 44 25 85 211 37 170 148 175 123 76 117 116 201 41 197 5 200 8 15 122 158 124 192 100 3 16 236 180 31 129 253 155 63 138 255 232 91 135 81 134 65 70 56 187 103 52 0 24 118 88 81 165 65 53 46 10 6 123 145 170 62 208 30 143 29 76 149 167 75 195 57 170 105 68 21 202 165 17 152 243 117 143 71 224 128 198 6 251 192 32 84 222 110 3 236 147 103 75 161 24 200 180 243 103 12 34 41 137 12 187 105 158 115 15 1 32 15 231 206 244 213 181 91 111 169 216 230 196 202 38 0 126 140 30 24 90 147 162 83 211 40 224 245 68 213 77 231 168 202 128 42 127 105 182 196 43 27 166 202 148 178 186 229 245 0 96 140 92 5 59 32 207 115 230 149 141 7 240 223 101 23 104 132 43 107 173 139 195 248 33 126 145 8 32 74 25 46 175 108 60 109 199 203 74 216 148 14 22 48 188 228 97 74 190 181 168 140 24 207 81 45 168 194 120 101 101 195 121 185 199 84 141 41 34 49 10 169 100 36 241 20 231 213 93 136 255 193 179 236 124 131 42 26 243 104 93 78 125 85 213 174 5 42 84 117 12 10 114 75 168 88 189 104 152 236 57 170 115 187 29 248 130 57 202 179 61 166 106 95 61 104 14 38 201 121 205 136 116 41 87 113 94 116 142 18 243 245 123 75 158 246 6 86 101 103 7 184 217 202 183 18 214 255 231 168 58 84 165 139 119 12 255 23 182 213 135 236 191 94 152 103 0 0 0 0 73 69 78 68 174 66 96 130) asByteArray</body><body package="Seaside-Tests-Core">jsbootstrapJsContent	^ '	function foo (a, b) {}'</body><body package="Seaside-Tests-Core">mainCss	^ WAFileLibraryResource		filepath: 'main.css'		mimeType: WAMimeType textCss		cacheDuration: (Duration days: 0 hours: 0 minutes: 30 seconds: 0)		contents: (GRDelayedSend receiver: self selector: #mainCssContent)</body><body package="Seaside-Tests-Core">mainCssContent	^ ''</body></methods><methods><class-id>Seaside.WATestingMetadataFileLibrary</class-id> <category>uploaded metadata</category><body package="Seaside-Tests-Core">imgglyphiconshalflingsPng	^ WAFileLibraryResource		filepath: 'img/glyphicons-halflings.png'		mimeType: (WAMimeType main: 'image' sub: 'png')		cacheDuration: (Duration days: 0 hours: 0 minutes: 30 seconds: 0)		contents: (GRDelayedSend receiver: self selector: #imgglyphiconshalflingsPngContent)</body><body package="Seaside-Tests-Core">jsbootstrapJs	^ WAFileLibraryResource		filepath: 'js/bootstrap.js'		mimeType: (WAMimeType main: 'application' sub: 'x-javascript')		cacheDuration: (Duration days: 0 hours: 0 minutes: 30 seconds: 0)		contents: (GRDelayedSend receiver: self selector: #jsbootstrapJsContent)</body></methods><methods><class-id>Seaside.WAFileLibraryTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testAsFilename	| library |	library := WATestingFiles default.	self assert: (library asFilename: #mainJs) = 'main.js'.	self assert: (library asFilename: #style2Css) = 'style2.css'.	self assert: (library asFilename: #index) = 'index'</body><body package="Seaside-Tests-Core">testAsSelector	self assert: (WAFileLibrary asSelector: 'main.css') = #mainCss.	self assert: (WAFileLibrary asSelector: 'main.js') = #mainJs.	self assert: (WAFileLibrary asSelector: 'style-2.css') = #style2Css.	self assert: (WAFileLibrary asSelector: 'style_2.css') = #style2Css.		"https://code.google.com/p/seaside/issues/detail?id=786"	self assert: (WAFileLibrary asSelector: 'main') = #main.	self assert: (WAFileLibrary asSelector: 'main.') = #main.	self assert: (WAFileLibrary asSelector: ').find(') isNil.	self assert: (WAFileLibrary asSelector: '),10)') isNil</body><body package="Seaside-Tests-Core">testAsSelectorCapitalized	| library |	library := WATestingFiles default.	self assert: (library asSelector: 'COMMENTS.TXT') = #COMMENTSTxt.	self assert: (library asFilename: #COMMENTSTxt) = 'COMMENTS.txt'</body><body package="Seaside-Tests-Core">testAsSelectorFunky	self assert: (WAFileLibrary asSelector: '1_2$3-4/5()6!7   8.9.test 1 2 3 me 4 5 6 .txt') = #test123me456Txt</body><body package="Seaside-Tests-Core">testAsSelectorLeadingDigits	| library |	library := WATestingFiles default.	self assert: (library asSelector: '1readme.txt') = #readmeTxt.	self assert: (library asSelector: '123456789readme.txt') = #readmeTxt.	self assert: (library asSelector: '123456789readme89.txt') = #readme89Txt</body><body package="Seaside-Tests-Core">testCompileByteArray	| library file |	library := WATestingFiles default.	[		| data first second |		self deny: (library class selectors includes: #demoJpeg).		data := (1 to: 255) asByteArray.		file := WAFile new			contentType: WAMimeType imageJpeg;			contents: data;			fileName: 'demo.jpeg';			yourself.		library addFile: file.		self assert: (library class selectors includes: #demoJpeg).		first := library perform: #demoJpeg.		self assert: first = data.		second := library perform: #demoJpeg.		self assert: first = second	] ensure: [		library removeFile: file fileName.		self deny: (library class selectors includes: #demoJpeg) ]</body><body package="Seaside-Tests-Core">testCompileByteArrayAgain	| library file |	library := WATestingFiles default.	[		| data first second |		self deny: (library class selectors includes: #demoJpeg).		data := (1 to: 255) asByteArray.		file := WAFile new			contentType: WAMimeType imageJpeg;			contents: data;			fileName: 'demo.jpeg';			yourself.		library addFile: file.		self assert: (library class selectors includes: #demoJpeg).		first := library perform: #demoJpeg.		self assert: first = data.		second := library perform: #demoJpeg.		self assert: first = second.			data := (1 to: 255) reverse asByteArray.		file := WAFile new			contentType: WAMimeType imageJpeg;			contents: data;			fileName: 'demo.jpeg';			yourself.		library addFile: file.		self assert: (library class selectors includes: #demoJpeg).		first := library perform: #demoJpeg.		self assert: first = data.		second := library perform: #demoJpeg.		self assert: first = second	] ensure: [		library removeFile: file fileName.		self deny: (library class selectors includes: #demoJpeg) ]</body><body package="Seaside-Tests-Core">testCompileString	| library file |	library := WATestingFiles default.	[		| data first second |		self deny: (library class selectors includes: #demoTxt).			data := 'this is a string'.		file := WAFile new			contentType: WAMimeType textPlain;			contents: data;			fileName: 'demo.txt';			yourself.			library addFile: file.		self assert: (library class selectors includes: #demoTxt).		first := library perform: #demoTxt.		self assert: first = data.		second := library perform: #demoTxt.		self assert: first == second	] ensure: [		library removeFile: file fileName.		self deny: (library class selectors includes: #demoTxt) ]</body><body package="Seaside-Tests-Core">testCompileStringAgain	| library file |	library := WATestingFiles default.	[		| data first second |		self deny: (library class selectors includes: #demoTxt).			data := 'this is a string'.		file := WAFile new			contentType: WAMimeType textPlain;			contents: data;			fileName: 'demo.txt';			yourself.			library addFile: file.		self assert: (library class selectors includes: #demoTxt).		first := library perform: #demoTxt.		self assert: first = data.		second := library perform: #demoTxt.		self assert: first == second.		data := 'this is another string'.		file := WAFile new			contentType: WAMimeType textPlain;			contents: data;			fileName: 'demo.txt';			yourself.			library addFile: file.		self assert: (library class selectors includes: #demoTxt).		first := library perform: #demoTxt.		self assert: first = data.		second := library perform: #demoTxt.		self assert: first == second	] ensure: [		library removeFile: file fileName.		self deny: (library class selectors includes: #demoTxt) ]</body><body package="Seaside-Tests-Core">testFilenames	| filenames |	filenames := WATestingFiles default filenames.	self assert: filenames size = 2.	self assert: (filenames includes: 'sample.png').	self assert: (filenames includes: 'sample.js')</body><body package="Seaside-Tests-Core">testIsBinary	self deny: (WAFileLibrary isBinary: 'scipt.js').	self deny: (WAFileLibrary isBinary: 'markup.xml').	self deny: (WAFileLibrary isBinary: 'markup.xhtml').	self deny: (WAFileLibrary isBinary: 'markup.html').	self deny: (WAFileLibrary isBinary: 'file.txt').	self deny: (WAFileLibrary isBinary: 'calendar.ics').	self assert: (WAFileLibrary isBinary: 'image.jpeg').	self assert: (WAFileLibrary isBinary:  'squeak.exe')</body><body package="Seaside-Tests-Core">testMainJs	| handler response |	handler := WAFileHandler new.	self requestContextWithUrl: '/i/dont/care/main.js'.	self requestContext consumer next; next; next.	response := self responseAfter: [ handler handle: self requestContext ].	self assert: response status = 404</body><body package="Seaside-Tests-Core">testMimeType	| library |	library := WATestingFiles default.	self assert: (library mimetypeForFile: 'main.js') = 'application/x-javascript' seasideMimeType.	self assert: (library mimetypeForFile: 'style2.css') = WAMimeType textCss.	self assert: (library mimetypeForFile: 'image.jpg') = WAMimeType imageJpeg.	self assert: (library mimetypeForFile: 'index') = WAMimeType applicationOctetStream</body><body package="Seaside-Tests-Core">testName	"Issue 620: 	WAFileLibrary&gt;&gt;name answers a Symbol, but used in places where String should be used	http://code.google.com/p/seaside/issues/detail?id=620		Issue 186: 	WAFileLibrary&gt;&gt;deployFiles fail if folder already exists	http://code.google.com/p/glassdb/issues/detail?id=186		Avoid having a Symbol because otherwise deploying the files on GemStone fails because equality checks with existing files always anser false."	| library |	library := WATestingFiles default.	self assert: library name = 'WATestingFiles'.	self assert: library name isString.	self deny: library name isSymbol</body><body package="Seaside-Tests-Core">testNoneStatisfy	self deny: (#(1 2 3) noneSatisfy: [ :each |		each even ]).	self assert: (#(1 3 5) noneSatisfy: [ :each |		each even ])</body><body package="Seaside-Tests-Core">testSamplePng	| handler library response stream contents |	handler := WAFileHandler new.	library := WATestingFiles default.	self requestContextWithUrl: '/i/dont/care/WATestingFiles/sample.png'.	requestContext consumer next; next; next.	response := self responseAfter: [ handler handle: self requestContext ].	self assert: response status = 200.	self assert: response contentType = WAMimeType imagePng.	stream := WriteStream on: ByteArray new.	response writeContentOn: stream.	contents := stream contents.	self assert: contents asByteArray = (library perform: #samplePng)</body><body package="Seaside-Tests-Core">testUrlOf	self assert: (WATestingFiles / #samplePng) greaseString = '/files/WATestingFiles/sample.png'</body></methods><methods><class-id>Seaside.WAKeyGeneratorTest</class-id> <category>accessing</category><body package="Seaside-Tests-Core">count	^ 512</body></methods><methods><class-id>Seaside.WAKeyGeneratorTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testUnique	| collection id |	collection := Set new: self count.	self count timesRepeat: [		id := WAKeyGenerator current keyOfLength: 48.		self			deny: (collection includes: id)			description: 'This is extremely unlikely to fail, if it does repeatedly then there is something wrong with the random generator.'.		collection add: id ]</body></methods><methods><class-id>Seaside.WAMutexTest</class-id> <category>running</category><body package="Seaside-Tests-Core">setUp	super setUp.	mutex := WAMutex new</body><body package="Seaside-Tests-Core">tearDown	super tearDown.	process isNil ifFalse: [ GRPlatform current terminateProcess: process ].	process2 isNil ifFalse: [ GRPlatform current terminateProcess: process2 ].	"Clear instance variables so that GemStone does not attempt to persist a Semaphore"	mutex := nil.	process := nil.	process2 := nil</body></methods><methods><class-id>Seaside.WAMutexTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testCopy	| semaphore1 semaphore2 copy |	semaphore1 := GRPlatform current semaphoreClass new.	semaphore2 := GRPlatform current semaphoreClass new.	process := [ mutex critical: 		[ semaphore1 signal.		semaphore2 wait ] ] newProcess.	process resume.	semaphore1 wait.	copy := mutex copy.	self deny: copy == mutex.	self assert: copy species = mutex species.	self assert: copy owner isNil.	self assert: (copy critical: [ 1 ]) = 1</body><body package="Seaside-Tests-Core">testExclusion	| value semaphore1 semaphore2 semaphore3 semaphore4 |	value := nil.	semaphore1 := GRPlatform current semaphoreClass new.	semaphore2 := GRPlatform current semaphoreClass new.	semaphore3 := GRPlatform current semaphoreClass new.	semaphore4 := GRPlatform current semaphoreClass new.	process := 	[ mutex critical: 		[ semaphore1 signal.		semaphore2 wait.		value := 1 ] ] newProcess.	process2 := 	[ semaphore3 signal.	mutex critical: 		[ semaphore3 signal.		semaphore4 wait.		value := 2.		semaphore3 signal ] ] newProcess.	process resume.	semaphore1 wait.	process2 resume.	semaphore3 wait.	self assert: mutex owner == process.	self assert: value isNil.	semaphore2 signal.	semaphore3 wait.	self assert: mutex owner == process2.	self assert: value = 1.	semaphore4 signal.	semaphore3 wait.	self assert: mutex owner isNil.	self assert: value = 2</body><body package="Seaside-Tests-Core">testMultipleEntry	| value |	value := mutex critical: [ mutex critical: [ 1 ] ].		self assert: value = 1.	self assert: mutex owner isNil</body><body package="Seaside-Tests-Core">testSelfTerminate	| value semaphore |	value := nil.	semaphore := GRPlatform current semaphoreClass new.	process := 	[ value := mutex critical: 		[ semaphore signal.		mutex terminateOwner.		1 ] ] newProcess.	process resume.	semaphore wait.	self assert: mutex owner isNil.	self assert: value isNil.	self assert: (GRPlatform current isProcessTerminated: process)</body><body package="Seaside-Tests-Core">testSimple	| value |	value := mutex critical: [ 1 ].		self assert: value = 1.	self assert: mutex owner isNil</body><body package="Seaside-Tests-Core">testTerminate	| value semaphore1 semaphore2 semaphore3 |	value := nil.	semaphore1 := GRPlatform current semaphoreClass new.	semaphore2 := GRPlatform current semaphoreClass new.	semaphore3 := GRPlatform current semaphoreClass new.	process := 	[ value := [ mutex critical: 		[ semaphore1 signal.		semaphore2 wait.		1 ] ] ensure: [ semaphore3 signal ] ] newProcess.	process resume.	semaphore1 wait.	self assert: mutex owner == process.	mutex terminateOwner.	semaphore3 wait.	self assert: mutex owner isNil.	self assert: value isNil.	self assert: (GRPlatform current isProcessTerminated: process)</body></methods><methods><class-id>Seaside.WAHttpVersionTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testComparison	"Note that the major and minor numbers MUST be treated as separate   integers and that each MAY be incremented higher than a single digit.   Thus, HTTP/2.4 is a lower version than HTTP/2.13, which in turn is   lower than HTTP/12.3. Leading zeros MUST be ignored by recipients and   MUST NOT be sent."	| v10 v11 v24 v213 v123 |	v10 := WAHttpVersion major: 1 minor: 0.	v11 := WAHttpVersion major: 1 minor: 1.	v24 := WAHttpVersion major: 2 minor: 4.	v213 := WAHttpVersion major: 2 minor: 13.	v123 := WAHttpVersion major: 12 minor: 3.		self assert: v10 &lt; v11.	self assert: v10 &lt;= v11.	self deny: v10 &gt; v11.	self deny: v10 &gt;= v11.	self assert: v11 &gt; v10.	self assert: v11 &gt;= v10.	self deny: v11 &lt; v10.	self deny: v11 &lt;= v10.		self assert: v24 &lt; v213.	self assert: v24 &lt;= v213.	self deny: v24 &gt; v213.	self deny: v24 &gt;= v213.	self assert: v213 &gt; v24.	self assert: v213 &gt;= v24.	self deny: v213 &lt; v24.	self deny: v213 &lt;= v24.			self assert: v213 &lt; v123.	self assert: v213 &lt;= v123.	self deny: v213 &gt; v123.	self deny: v213 &gt;= v123.	self assert: v123 &gt; v213.	self assert: v123 &gt;= v213.	self deny: v123 &lt; v213.	self deny: v123 &lt;= v213.		self assert: v24 &lt; v123.	self assert: v24 &lt;= v123.	self deny: v24 &gt; v123.	self deny: v24 &gt;= v123.	self assert: v123 &gt; v24.	self assert: v123 &gt;= v24.	self deny: v123 &lt; v24.	self deny: v123 &lt;= v24</body><body package="Seaside-Tests-Core">testCreation	| version |	version := WAHttpVersion major: 1 minor: 0.		self assert: version major = 1.	self assert: version minor = 0</body><body package="Seaside-Tests-Core">testCreation10	| version |	version := WAHttpVersion http10.		self assert: version major = 1.	self assert: version minor = 0</body><body package="Seaside-Tests-Core">testCreation11	| version |	version := WAHttpVersion http11.		self assert: version major = 1.	self assert: version minor = 1</body><body package="Seaside-Tests-Core">testCreationWithNew	| version |	version := WAHttpVersion new.		self assert: version major = 1.	self assert: version minor = 1</body><body package="Seaside-Tests-Core">testEquality	| a10 b10 a11 |	a10 := WAHttpVersion major: 1 minor: 0.	b10 := WAHttpVersion major: 1 minor: 0.	a11 := WAHttpVersion major: 1 minor: 1.		self assert: a10 = b10.	self assert: a10 &lt;= b10.	self assert: a10 &gt;= b10.	self deny: a10 = a11</body><body package="Seaside-Tests-Core">testGreaseString	| version |	version := WAHttpVersion 		major: 1		minor: 0.	self assert: version greaseString = 'HTTP/1.0'</body><body package="Seaside-Tests-Core">testHash	| oneOneZero oneDotOne |	oneOneZero := WAHttpVersion http10.	oneDotOne := WAHttpVersion http11.		self deny: oneDotOne hash = oneOneZero hash</body><body package="Seaside-Tests-Core">testStreamHeaderLineParsing	| stream version |	stream := '  GET   /foo  HTTP/1.1 ' readStream.	stream next: 12. 	version := WAHttpVersion readFrom: stream.		self assert: version major = 1.	self assert: version minor = 1</body><body package="Seaside-Tests-Core">testStreamVersionNumberParsing	| stream version |	stream := '12.3' readStream.	version := WAHttpVersion readFrom: stream.		self assert: version major = 12.	self assert: version minor = 3</body><body package="Seaside-Tests-Core">testStreamVersionStringParsing	| stream version |	stream := 'HTTP/1.0' readStream.	version := WAHttpVersion readFrom: stream.		self assert: version major = 1.	self assert: version minor = 0</body><body package="Seaside-Tests-Core">testStringVersionNumberParsing	| version string |	string := '12.3'.	version := WAHttpVersion fromString: string.		self assert: version major = 12.	self assert: version minor = 3</body><body package="Seaside-Tests-Core">testStringVersionStringParsing	| version string |	string := 'HTTP/1.0'.	version := WAHttpVersion fromString: string.		self assert: version major = 1.	self assert: version minor = 0</body><body package="Seaside-Tests-Core">testTestingMethods	| v10 v11 |	v10 := WAHttpVersion major: 1 minor: 0.	v11 := WAHttpVersion major: 1 minor: 1.		self assert: v10 isHttp10.	self deny: v11 isHttp10.	self assert: v11 isHttp11.	self deny: v10 isHttp11</body></methods><methods><class-id>Seaside.WADocumentHandlerTest</class-id> <category>private</category><body package="Seaside-Tests-Core">newHandler	^ WADocumentHandler		document: 'body { background-color: #ffffff }'		mimeType: WAMimeType textCss		fileName: 'sample.css'</body></methods><methods><class-id>Seaside.WADocumentHandlerTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testCopyDocumentHandler	| copy |	copy := handler copy.	self assert: copy = handler.	self deny: copy == handler.	self assert: copy document = handler document.	self deny: copy document == handler document</body></methods><methods><class-id>Seaside.WAServerManagerTest</class-id> <category>private</category><body package="Seaside-Tests-Core">availablePort	"This method should always return an unused port for the server manager"		^ (manager adaptors collect: [ :each | each port ]) asSet max + 1</body></methods><methods><class-id>Seaside.WAServerManagerTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testCanStartWithAvailablePort	| adaptor1 |	adaptor starting.	self deny: (manager canStart: adaptor).	adaptor running.	self deny: (manager canStart: adaptor).	adaptor stopping.	self deny: (manager canStart: adaptor).	adaptor stopped.	self assert: (manager canStart: adaptor).		adaptor1 := WATestServerAdaptor manager: manager.	adaptor1 port: adaptor port.	adaptor1 stopped.	self assert: (manager canStart: adaptor1)</body><body package="Seaside-Tests-Core">testCanStartWithUnavailablePort	| adaptor1 |	adaptor1 := WATestServerAdaptor manager: manager.	adaptor1 port: adaptor port.	adaptor1 starting.	self deny: (manager canStart: adaptor1).	adaptor1 running.	self deny: (manager canStart: adaptor1).	adaptor1 stopping.	self deny: (manager canStart: adaptor1).	adaptor1 stopped.	self deny: (manager canStart: adaptor1)</body><body package="Seaside-Tests-Core">testCanStop	adaptor starting.	self assert: (manager canStop: adaptor).	adaptor running.	self assert: (manager canStop: adaptor).	adaptor stopping.	self assert: (manager canStop: adaptor).	adaptor stopped.	self deny: (manager canStop: adaptor)</body></methods><methods><class-id>Seaside.WAServerManagerTest</class-id> <category>running</category><body package="Seaside-Tests-Core">setUp	super setUp.	manager := WAServerManager new.	adaptor := WATestServerAdaptor manager: manager.	adaptor port: 12345.	adaptor running.	self assert: adaptor isRunning.	self assert: (manager adaptors includes: adaptor)</body><body package="Seaside-Tests-Core">tearDown	super tearDown.	adaptor stopped.	self assert: adaptor isStopped.	manager unregister: adaptor.	self deny: (manager adaptors includes: adaptor)</body></methods><methods><class-id>Seaside.WAFileMetadataLibraryTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testAsFileAndFoldername	| library |	library := WATestingMetadataFileLibrary default.	self assert: (library asFileAndFoldername: #mainCss) first equals: library name</body><body package="Seaside-Tests-Core">testAsFilename	| library |	library := WATestingMetadataFileLibrary default.	self assert: (library asFilename: #imgglyphiconshalflingsPng) ='img/glyphicons-halflings.png'.	self assert: (library asFilename: #jsbootstrapJs) =  'js/bootstrap.js'</body><body package="Seaside-Tests-Core">testAsSelector	self assert: (WAFileMetadataLibrary asSelector: 'js/bootstrap.js') = #jsbootstrapJs.	self assert: (WAFileMetadataLibrary asSelector: 'img/glyphicons-halflings.png') = #imgglyphiconshalflingsPng.	self assert: (WAFileMetadataLibrary asSelector: 'css/bootstrap-responsive.css') = #cssbootstrapresponsiveCss</body><body package="Seaside-Tests-Core">testCompileByteArray	| library file |	library := WATestingMetadataFileLibrary default.	[		| data first second |		self deny: (library class selectors includes: #demoJpeg).		data := (1 to: 255) asByteArray.		file := WAFile new			contentType: WAMimeType imageJpeg;			contents: data;			fileName: 'demo.jpeg';			yourself.		library addFile: file.		self assert: (library class selectors includes: #demoJpeg).		first := library perform: #demoJpeg.		self assert: first contents value = data.		self assert: first mimeType = file contentType.		self assert: first filepath = file fileName.		second := library perform: #demoJpeg.		self assert: first contents value = second contents value	] ensure: [		library removeFile: file fileName.		self deny: (library class selectors includes: #demoJpeg) ]</body><body package="Seaside-Tests-Core">testCompileByteArrayAgain	| library file |	library := WATestingMetadataFileLibrary default.	[		| data first second |		self deny: (library class selectors includes: #demoJpeg).		data := (1 to: 255) asByteArray.		file := WAFile new			contentType: WAMimeType imageJpeg;			contents: data;			fileName: 'demo.jpeg';			yourself.		library addFile: file.		self assert: (library class selectors includes: #demoJpeg).		first := library perform: #demoJpeg.		self assert: first contents value = data.		second := library perform: #demoJpeg.		self assert: first contents value = second contents value.			data := (1 to: 255) reverse asByteArray.		file := WAFile new			contentType: WAMimeType imageJpeg;			contents: data;			fileName: 'demo.jpeg';			yourself.		library addFile: file.		self assert: (library class selectors includes: #demoJpeg).		first := library perform: #demoJpeg.		self assert: first contents value = data.		second := library perform: #demoJpeg.		self assert: first contents value = second contents value	] ensure: [		library removeFile: file fileName.		self deny: (library class selectors includes: #demoJpeg) ]</body><body package="Seaside-Tests-Core">testCompileString	| library file |	library := WATestingMetadataFileLibrary default.	[		| data first second |		self deny: (library class selectors includes: #demoTxt).			data := 'this is a string'.		file := WAFile new			contentType: WAMimeType textPlain;			contents: data;			fileName: 'demo.txt';			yourself.			library addFile: file.		self assert: (library class selectors includes: #demoTxt).		first := library perform: #demoTxt.		self assert: first contents value = data.		self assert: first mimeType = file contentType.		self assert: first filepath = file fileName.		second := library perform: #demoTxt.		self assert: first contents value == second contents value	] ensure: [		library removeFile: file fileName.		self deny: (library class selectors includes: #demoTxt) ]</body><body package="Seaside-Tests-Core">testFilenames	| filenames |	filenames := WATestingMetadataFileLibrary default filenames.	self assert: filenames size = 3.	self assert: (filenames includes: 'img/glyphicons-halflings.png').	self assert: (filenames includes: 'js/bootstrap.js').	self assert: (filenames includes: 'main.css')</body><body package="Seaside-Tests-Core">testImgglyphiconshalflingsPng	| handler library response stream contents |	handler := WAFileHandler new.	library := WATestingMetadataFileLibrary default.	self requestContextWithUrl: '/i/dont/care/WATestingMetadataFileLibrary/img/glyphicons-halflings.png'.	requestContext consumer next; next; next.	response := self responseAfter: [ handler handle: self requestContext ].	self assert: response status = 200.	self assert: response contentType = WAMimeType imagePng.	stream := WriteStream on: ByteArray new.	response writeContentOn: stream.	contents := stream contents.	self assert: contents asByteArray = (library perform: #imgglyphiconshalflingsPng) contents value</body><body package="Seaside-Tests-Core">testIsBinary	self deny: (WAFileMetadataLibrary isBinary: 'scipt.js').	self deny: (WAFileMetadataLibrary isBinary: 'markup.xml').	self deny: (WAFileMetadataLibrary isBinary: 'markup.xhtml').	self deny: (WAFileMetadataLibrary isBinary: 'markup.html').	self deny: (WAFileMetadataLibrary isBinary: 'file.txt').	self deny: (WAFileMetadataLibrary isBinary: 'calendar.ics').	self assert: (WAFileMetadataLibrary isBinary: 'image.jpeg').	self assert: (WAFileMetadataLibrary isBinary:  'squeak.exe')</body><body package="Seaside-Tests-Core">testMimeType	| library |	library := WATestingMetadataFileLibrary default.	self assert: (library mimetypeOf: #imgglyphiconshalflingsPng) = WAMimeType imagePng.	self assert: (library mimetypeOf: #jsbootstrapJs) =  'application/x-javascript' seasideMimeType</body><body package="Seaside-Tests-Core">testName	"Issue 620: 	WAFileLibrary&gt;&gt;name answers a Symbol, but used in places where String should be used	http://code.google.com/p/seaside/issues/detail?id=620		Issue 186: 	WAFileLibrary&gt;&gt;deployFiles fail if folder already exists	http://code.google.com/p/glassdb/issues/detail?id=186		Avoid having a Symbol because otherwise deploying the files on GemStone fails because equality checks with existing files always anser false."	| library |	library := WATestingMetadataFileLibrary default.	self assert: library name = 'WATestingMetadataFileLibrary'.	self assert: library name isString.	self deny: library name isSymbol</body><body package="Seaside-Tests-Core">testUrlOf	self assert: (WATestingMetadataFileLibrary / #jsbootstrapJs) greaseString = '/files/WATestingMetadataFileLibrary/js/bootstrap.js'</body></methods><methods><class-id>Seaside.WARequestFieldsTest</class-id> <category>configuration</category><body package="Seaside-Tests-Core">collectionClass	^ WARequestFields</body></methods><methods><class-id>Seaside.WAPathConsumerTest</class-id> <category>running</category><body package="Seaside-Tests-Core">setUp	super setUp.	consumer := WAPathConsumer path: #('tweets' 'kentbeck') asOrderedCollection</body></methods><methods><class-id>Seaside.WAPathConsumerTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testAtEnd	self deny: consumer atEnd.	consumer next.	self deny: consumer atEnd.	consumer next.	self assert: consumer atEnd</body><body package="Seaside-Tests-Core">testNext	self assert: consumer next = 'tweets'.	self assert: consumer next = 'kentbeck'.	self should: [ consumer next ] raise: Error</body><body package="Seaside-Tests-Core">testNextIfPresent	| evaluated |	evaluated := false.	consumer nextIfPresentDo: [ :next |		 self assert: next = 'tweets'.		evaluated := true ].	self assert: evaluated.		evaluated := false.	consumer nextIfPresentDo: [ :next |		 self assert: next = 'kentbeck'.		evaluated := true ].	self assert: evaluated.		evaluated := false.	consumer nextIfPresentDo: [ :next |		evaluated := true ].	self deny: evaluated</body><body package="Seaside-Tests-Core">testPeek	self assert: consumer peek = 'tweets'.	self assert: consumer peek = 'tweets'.	consumer next.	self assert: consumer peek = 'kentbeck'.	self assert: consumer peek = 'kentbeck'.	consumer next.	self should: [ consumer peek ] raise: Error</body><body package="Seaside-Tests-Core">testPeekToEnd	| result |	result := Array with: 'tweets' with: 'kentbeck'.	self assert: consumer peekToEnd = result.	self deny: consumer atEnd.	self assert: consumer next = 'tweets'.	self assert: consumer next = 'kentbeck'.	self assert: consumer atEnd</body><body package="Seaside-Tests-Core">testTry	self deny: (consumer try: 'foo').	self assert: (consumer try: 'tweets').	self deny: (consumer try: 'tweets').	self assert: (consumer try: 'kentbeck').	self assert: consumer atEnd.	self deny: (consumer try: 'kentbeck')</body><body package="Seaside-Tests-Core">testUpToEnd	| result |	result := OrderedCollection new add: 'tweets' ; add: 'kentbeck'; yourself.	self assert: consumer upToEnd = result.	self assert: consumer atEnd</body></methods><methods><class-id>Seaside.WAObjectUnderstandingUnregistered</class-id> <category>initialization</category><body package="Seaside-Tests-Core">initialize	super initialize.	hasReceivedUnregistered := false</body></methods><methods><class-id>Seaside.WAObjectUnderstandingUnregistered</class-id> <category>accessing</category><body package="Seaside-Tests-Core">hasReceivedUnregistered	^ hasReceivedUnregistered</body></methods><methods><class-id>Seaside.WAObjectUnderstandingUnregistered</class-id> <category>registration</category><body package="Seaside-Tests-Core">unregistered	hasReceivedUnregistered := true</body></methods><methods><class-id>Seaside.WAStreamedResponseTest</class-id> <category>accessing</category><body package="Seaside-Tests-Core">contents	self response flush.	^ self response stream contents</body><body package="Seaside-Tests-Core">response	^ super response ifNil: [ response := WAStreamedResponse on: (WriteStream on: String new) ]</body></methods><methods><class-id>Seaside.WAStreamedResponseTest</class-id> <category>tests-flush</category><body package="Seaside-Tests-Core">testFlushDelay	self response forbidden.	self response headerAt: 'X-Application-Server' put: 'Seaside'.	self deny: self response isCommitted.	self 		shouldnt: [ self response committedCheck ]		raise: WAIllegalStateException</body><body package="Seaside-Tests-Core">testFlushNextPutAll	self response nextPutAll: 'Hello World'. " &lt;-- should flush "	self assert: self response isCommitted.	self 		should: [ self response committedCheck ]		raise: WAIllegalStateException.	self assertLines: #('HTTP/1.1 200 OK' '' 'Hello World')</body><body package="Seaside-Tests-Core">testFlushStream	self response stream. " &lt;-- should flush "	self assert: self response isCommitted.	self 		should: [ self response committedCheck ]		raise: WAIllegalStateException.	self assertLines: #('HTTP/1.1 200 OK' '')</body></methods><methods><class-id>Seaside.WAStreamedResponseTest</class-id> <category>tests-state</category><body package="Seaside-Tests-Core">testCookieAfterCommit	self response flush.	self 		should: [ self response addCookie: WACookie new ]		raise: WAIllegalStateException</body><body package="Seaside-Tests-Core">testHeaderAfterCommit	self response flush.	self 		should: [ self response headerAt: 'foo' put: 'bar' ]		raise: WAIllegalStateException.	self 		should: [ self response headerAt: 'foo' append: 'bar' ]		raise: WAIllegalStateException.	self 		should: [ self response removeHeaderAt: 'foo' ]		raise: WAIllegalStateException</body><body package="Seaside-Tests-Core">testStatusAfterCommit	self response flush.	self 		should: [ self response forbidden ]		raise: WAIllegalStateException.	self 		should: [ self response status: 404 message: 'Almost found' ]		raise: WAIllegalStateException</body></methods><methods><class-id>Seaside.WAStreamedResponseTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testIsCommitted	super testIsCommitted.	self assert: self response isCommitted</body></methods><methods><class-id>Seaside.WAStreamedResponseTest</class-id> <category>private</category><body package="Seaside-Tests-Core">assertLines: anArray	"Streamed responses don't have content length information. They simply can't know."		super assertLines: (anArray reject: [ :each | each beginsWithSubCollection: 'Content-Length' ])</body></methods><methods><class-id>Seaside.WAStreamedResponseTest</class-id> <category>tests-conveniance</category><body package="Seaside-Tests-Core">testCanResetIfNoBody	| resetPossible |	resetPossible := self response		status: WAResponse statusNotFound;		attachmentWithFileName: 'upload.csv';		resetIfPossible.	self assert: resetPossible.	self assertLines: #('HTTP/1.1 200 OK' 'Content-Length: 0' '')</body><body package="Seaside-Tests-Core">testCantReset	| resetPossible |	resetPossible := self response		status: WAResponse statusNotFound;		attachmentWithFileName: 'upload.csv';		nextPutAll: 'the content';		resetIfPossible.	self deny: resetPossible.	self assertLines: #('HTTP/1.1 404 Not Found' 'Content-Disposition: attachment; filename="upload.csv"' '' 'the content')</body></methods><methods><class-id>Seaside.WARenderContextTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testAbsoluteUrlForResource	| context |	context := WARenderContext new.	context resourceUrl: (WAUrl absolute: 'http://seaside.st/foo').	self assert: (context absoluteUrlForResource: nil) isNil.	self assert: ((context absoluteUrlForResource: 'bar') isKindOf: WAUrl).	self assert: (context absoluteUrlForResource: 'bar') greaseString = 'http://seaside.st/foo/bar'.	self assert: ((context absoluteUrlForResource: '/bar') isKindOf: WAUrl).	self assert: (context absoluteUrlForResource: '/bar') greaseString = 'http://seaside.st/foo/bar'.	self assert: ((context absoluteUrlForResource: '') isKindOf: WAUrl).	self assert: (context absoluteUrlForResource: '') greaseString = 'http://seaside.st/foo'.	self assert: ((context absoluteUrlForResource: 'http://localhost/foo') isKindOf: WAUrl).	self assert: (context absoluteUrlForResource: 'http://localhost/foo') greaseString = 'http://localhost/foo'</body><body package="Seaside-Tests-Core">testAbsoluteUrlForResourceWithoutBase	| context |	context := WARenderContext new.	context resourceUrl: nil.	self assert: (context absoluteUrlForResource: nil) isNil.	self assert: ((context absoluteUrlForResource: 'bar') isKindOf: WAUrl).	self assert: (context absoluteUrlForResource: 'bar') greaseString = '/bar'.	self assert: ((context absoluteUrlForResource: '/bar') isKindOf: WAUrl).	self assert: (context absoluteUrlForResource: '/bar') greaseString = '/bar'.	self assert: ((context absoluteUrlForResource: '') isKindOf: WAUrl).	self assert: (context absoluteUrlForResource: '') greaseString = '/'.	self assert: ((context absoluteUrlForResource: 'http://localhost/foo') isKindOf: WAUrl).	self assert: (context absoluteUrlForResource: 'http://localhost/foo') greaseString = 'http://localhost/foo'</body></methods><methods><class-id>Seaside.WACurrentRequestContextTest</class-id> <category>tests</category><body package="Seaside-Tests-Core">testWithValue	WACurrentRequestContext		use: 1		during: [ self assert: WACurrentRequestContext value = 1 ]</body><body package="Seaside-Tests-Core">testWithoutValue	self should: [ WACurrentRequestContext value ] raise: WARequestContextNotFound</body></methods><methods><class-id>Seaside.WATextFileHandlerListingTest</class-id> <category>testing</category><body package="Seaside-Tests-Core">expectedMimeType	^ WAMimeType textPlain</body><body package="Seaside-Tests-Core">handlerClass	^ WATextFileHandlerListing</body></methods><methods><class-id>Seaside.WAKeyGenerator class</class-id> <category>*Seaside-Tests-Core</category><body package="Seaside-Tests-Core">use: aKeyGenerator during: aNiladicBlock	| old |	old := current.	current := aKeyGenerator.	^ aNiladicBlock ensure: [		current := old ]</body></methods><methods><class-id>Grease.GRPackage class</class-id> <category>*seaside-tests-core</category><body package="Seaside-Tests-Core">seasideTestsCore	^ self new		name: 'Seaside-Tests-Core';		description: 'Unit tests for the package Seaside-Core.';		addDependency: 'Seaside-Core';		addDependency: 'Grease-Tests-Core';		url: #seasideUrl;		yourself</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>WAObject</name><environment>Seaside</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAFileLibrary</name><environment>Seaside</environment><super>Seaside.WAAbstractFileLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Libraries</category><attributes><package>Seaside-Core</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>GROrderedMultiMapTest</name><environment>Grease</environment><super>Grease.GRSmallDictionaryTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Tests-Core</category><attributes><package>Grease-Tests-Core</package></attributes></class><class><name>WASystemConfiguration</name><environment>Seaside</environment><super>Seaside.WAConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>description </inst-vars><class-inst-vars>instance </class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAKeyGenerator</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>generator space </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>Seaside-Core-Utilities</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAServerAdaptor</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>manager port requestHandler codec </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Server</category><attributes><package>Seaside-Core</package></attributes></class><class><name>GRPlatformTest</name><environment>Grease</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Tests-Core</category><attributes><package>Grease-Tests-Core</package></attributes></class><class><name>WARequestHandler</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filter parent configuration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAFileMetadataLibrary</name><environment>Seaside</environment><super>Seaside.WAAbstractFileLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Libraries</category><attributes><package>Seaside-Core</package></attributes></class><class><name>GRError</name><environment>Grease</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Exceptions</category><attributes><package>Grease-Core</package></attributes></class></st-source>