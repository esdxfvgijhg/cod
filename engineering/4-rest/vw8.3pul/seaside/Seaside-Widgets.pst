<?xml version="1.0"?><st-source><!-- Name: Seaside-WidgetsComment: Various sample Decorations and Components that require Canvas.DbIdentifier: bear73DbTrace: 492583DbUsername: jkottDbVersion: 3.2.0 - JohanBrichau.36 1DevelopmentPrerequisites: #(#(#any 'Seaside-Namespace' '') #(#any 'Seaside-Canvas' '') #(#any 'Seaside-Component' ''))Id: 6161ba44-690a-4d2f-9a20-ec9cb9292079Namespace: SeasidePackageName: Seaside-WidgetsParcel: #('Seaside-Widgets')ParcelName: Seaside-WidgetsPrerequisiteParcels: #(#('Seaside-Namespace' '') #('Seaside-Canvas' '') #('Seaside-Component' ''))PrintStringCache: (3.2.0 - JohanBrichau.36 1,jkott)Url: http://smalltalkhub.com/mc/Seaside/Seaside32/main/Seaside-Widgets-JohanBrichau.36.mczVersion: 3.2.0 - JohanBrichau.36 1Date: 3:31:27 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:31:27 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WACanvasWidget</name><environment>Seaside</environment><super>Seaside.WAComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WACanvasWidget</class-id><body>A common superclass for all widgets that want to use WAHtmlCanvas as their renderer.</body></comment><class><name>WATableReport</name><environment>Seaside</environment><super>Seaside.WACanvasWidget</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sortColumn isReversed columns rowPeriod rowColors rows </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WATableReport</class-id><body>WATableReport presents tabular data. A WATableReport contains a collections of objects, one per row, and a collection of WAReportColumns. The WAReportColumn objects are configured to produce the text for the table cell based on the each row object. Each column has a header and an optional column sum. The table can be sorted on a column by clicking its header, unless the column handles rendering on the canvas itself. A table can be given a set of html colors (rowColors), used to colors the rows to aid in viewing. For more information see:	Example - WATableReportFunctionalTest (initialization code below)	WATableReport Tutorial - http://www.cdshaffer.com/david/Seaside/WATableReport/index.htmlInstance Variables:	columns	&lt;Collection of WAReportColumn&gt;	Each WAReportColumn produces the text for each table cell in a column  	isReversed	&lt;Boolean&gt;	true if the current sort column is to be sorted in reverse order	rowColors	&lt;Collection of String/Symbol&gt;	Each element is a string for an html color, which is used as a background color for table rows	rowPeriod	&lt;Integer&gt;	Each color in rowColors is used for rowPeriod consectutive rows before using the next row color.	rows	&lt;Collection of Object&gt;	Each element of the collection provides the data for a row in the table.	sortColumn	&lt;WAValueHolder on WAReportColumn&gt;	Column used to sort the the table rowsExample:	WATableReport new		rows: WAComponent allSubclasses asArray;		columns: (OrderedCollection new			add: (WAReportColumn				selector: #fullName title: 'Name'				onClick: [ :each | self inform: each description ]);			add: ((WAReportColumn				selector: #canBeRoot title: 'Can Be Root')				sortBlock: [ :a :b | a ]);			add: (WAReportColumn				renderBlock: [ :each :html | html emphasis: each description ]				title: 'Description');			yourself);		rowColors: #(lightblue lightyellow);		rowPeriod: 1;		yourself</body></comment><class><name>WANavigation</name><environment>Seaside</environment><super>Seaside.WACanvasWidget</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><class><name>WADateTimeSelector</name><environment>Seaside</environment><super>Seaside.WACanvasWidget</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dateSelector timeSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WADateTimeSelector</class-id><body>WADateTimeSelector allows the user to select a date and time in a given range dropdown menus (html select). Actual work done by WADateSelector and WATimeSelector. Date range is default range of WADateSelector.See WADateSelectorFunctionalTest for sample of usage.Select "Date Selector" tab of the Functional Seaside Test Suite to run an example  (http://127.0.0.1:xxxx/seaside/tests/alltests)Instance Variables:	dateSelector	&lt;WADateSelector&gt;	presents date selection to user	timeSelector	&lt;WATimeSelector&gt;	presents time selection to user</body></comment><class><name>WATrail</name><environment>Seaside</environment><super>Seaside.WACanvasWidget</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WATrail</class-id><body>WATrail implements breadcrumbs for pages generated using a sequence of WAComponent&gt;&gt;call: methods. Each component in the call sequence that is to appear in the breadcrumb must implement the method "trailName", which returns the text displayed in the breadcrumb. Instantiate (WATrail on: rootComponent) an WATrail object on the first component (root) of the breadcrumb. When the root component, or subsequent component, transfers control via "self call:" the WATrail object is automatically updated and will display the correct call sequence in the breadcrumb. When a user clicks on a link in the breadcrumb the call sequence is automatically updated.The breadcrumb is placed in a div with class "trail" and each crumb is separated with the character '&gt;', which is inside a span of class "separator" to aid in using CSS to format the breadcrumbs.Instance Variables:	root	&lt;WAComponent&gt;	first component in the breadcrumb and in the call sequence.</body></comment><class><name>WAReportColumn</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clickBlock formatBlock hasTotal title sortBlock valueBlock cssClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WAReportColumn</class-id><body>WAReportColumn displays a column, one cell at a time, of a WAReportTable. Columns can be sorted, have a title, can have a total, and its element can be links. The valueBlock obtains the output (an object) to display for each row from the row's object.  The formatBlock is used to convert the valueBlock output to a string. If you need html markup to display the result, use the two argument form of valueBlock. However, columns with two argument valueBlock can not be sorted. See class methods for shortcut methods for setting the value block. For more information see:	WATableReportInstance Variables:	clickBlock	&lt;BlockClosure [:rowObject | ]&gt;	When clickBlock is set items in column will be anchors. clickBlock is called with the selected object when anchor is clicked on. Typically clickBlock calls a component which generates a new page.	formatBlock	&lt;BlockClosure [:object | ]&gt;	Should convert the result of the one-argument valueBlock to the string to be displayed. If formatBlock is nil then  "displayString" is sent to the result of valueBlock for the display string for this column.  	hasTotal	&lt;Boolean&gt;	If true the column will display the sum of all elements in the column, sum is displayed in the last row.	sortBlock	&lt;BlockClosure [:a :b | ]&gt;	Used to sort the element in the column. Arguments are the value from the one argument valueBlock	title	&lt;String&gt;	Column header 	valueBlock	&lt;BlockClosure [:rowObject | ] or [:rowObject :aWARenderCanvas |] &gt;			[:rowObject | ] this form results in an object that is to be displayed in a column cell, argument is the object for a given row (see WATableReport)		[:rowObject :aHtmlCanvas |] this form is to render the value for a column cell from rowObject directly on aWRenderCanvascssClass	title &lt;String&gt; CSS class	the CSS class assigned to the &lt;td&gt;-tag in this column </body></comment><class><name>WASimpleNavigation</name><environment>Seaside</environment><super>Seaside.WANavigation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WASimpleNavigation</class-id><body>I'm a simple tab panel, that can be styled with stylesheets. New tabs can be added using #add:label:You may want to add the WANavigationFiles library to your application for some default CSS styling.</body></comment><class><name>WATree</name><environment>Seaside</environment><super>Seaside.WACanvasWidget</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root selected expanded childrenBlock labelBlock canSelectBlock selectBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WATree</class-id><body>WATree implements a tree menu, which supports nesting, collapsing and expanding. Prefixes items with "+/-" to indicate items that can be expanded/collapsed.See class methods for simple example.Instance Variables:	canSelectBlock	&lt;BlockClosure [:nodeInTree | ]&gt;	returns true if user can select the argument of the block, if true node is an anchor	childrenBlock	&lt;BlockClosure [:nodeInTree | ]&gt;	returns children (or subnodes) of the given node in the tree, sent to all nodes	expanded	&lt;IdentitySet&gt;	Collection of all nodes that are currently expanded	labelBlock	&lt;[:nodeInTree | ]&gt; returns text to display for given node	root	&lt;Object&gt;	root or top level node in tree, childrenBlock is used to determine roots subnodes	selectBlock	&lt;BlockClosure [:selectedNode | ]&gt;	called when an node is selected, put a callback to your code here	selected	&lt;Object&gt;	currently selected node</body></comment><class><name>WAFormDialog</name><environment>Seaside</environment><super>Seaside.WACanvasWidget</super><private>false</private><indexed-type>none</indexed-type><inst-vars>validationError form </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WAFormDialog</class-id><body>WAFormDialog is an empty html form. Used in WAComponent&gt;&gt;inform: to create a dialog component that displays text and an "Ok" button to close the component. See subclasses for sample usage &amp; more functionality.Instance Variables:	form	&lt;WAFormDecoration&gt; Decorator that generates form tags	validationError	&lt;String&gt;	Text descriping invalid data entered by user. Displayed when not nil. Set to nil when user submits form.</body></comment><class><name>WAYesOrNoDialog</name><environment>Seaside</environment><super>Seaside.WAFormDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WAYesOrNoDialog</class-id><body>WAYesOrNoDialog displays a yes/no dialog. Returns boolean indicating user selection. See WAComponent&gt;&gt;confirm: for sample usage and easy way to use WAYesOrNoDialog.</body></comment><class><name>WADateSelector</name><environment>Seaside</environment><super>Seaside.WACanvasWidget</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day month year startYear endYear </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WADateSelector</class-id><body>WADateSelector displays dropdown menus (html select) allowing a user to delect a date within a range. "startYear" and "endYear" define the range of selectable dates. Date displayed in month, day, year format. WADateSelector&gt;&gt;date returns date user selected as a Date object.See WADateSelectorFunctionalTest for sample of usage.Select "Date Selector" tab of the Functional Seaside Test Suite to run an example  (http://127.0.0.1:xxxx/seaside/tests/alltests)Instance Variables:	day	&lt;Integer 1-31&gt; selected day	endYear	&lt;Integer&gt;	end of range of dates user is allowed to select, not required to use 4 digits	month	&lt;Integer 1-12&gt;	selected month	startYear	&lt;Integer&gt;	 start of range of dates user is allowed to select, not required to use 4 digits	year	&lt;Integer&gt;	selected year</body></comment><class><name>WAWidgetDecoration</name><environment>Seaside</environment><super>Seaside.WADecoration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Decorations</category><attributes><package>Seaside-Widgets</package></attributes></class><class><name>WAMessageDecoration</name><environment>Seaside</environment><super>Seaside.WAWidgetDecoration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>message </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Decorations</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WAMessageDecoration</class-id><body>I add a string message on top of the WAComponent I decorate. For example if change WACounter&gt;&gt;initialize as below the text "Counter Example" will appear on above the counter when rendered.WACounter&gt;&gt;initialize	super initialize.	self count: 0.	self addMessage: 'Counter Example'	"added line"</body></comment><class><name>WAAlphabeticBatchedList</name><environment>Seaside</environment><super>Seaside.WACanvasWidget</super><private>false</private><indexed-type>none</indexed-type><inst-vars>items currentPage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WAAlphabeticBatchedList</class-id><body>WAAlphabeticBatchedList organizes a collection of items into pages for display. A page contains all items whose string representation (item displayString) starts with the same character. WAAlphabeticBatchedList only displays the navigation (alphabet with links) for the list. Your code needs to display the current page.Use WAAlphabeticBatchedList&gt;&gt;items: to set the collections of items.Use WAAlphabeticBatchedList&gt;&gt;batch to get the items to display on the current pageSee WABatchFunctionalTest for example of usage.Select "Batch" tab of the Functional Seaside Test Suite to run an example  (http://127.0.0.1:xxxx/seaside/tests/alltests)Instance Variables:	currentPage	&lt;Character&gt;	the character of the curent page	items	&lt;(Collection of: (Object ))&gt; collection of the items managed by WAAlphabeticBatchedList. Collection is sorted before items are displayed.</body></comment><class><name>WADateTable</name><environment>Seaside</environment><super>Seaside.WACanvasWidget</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rows startDate endDate datesCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WADateTable</class-id><body>WADateTable renders a table containing dates from startDate to endDate. The table contains one column for each date from startDate to endDate. The top row of the table groups columns by month and labels each month (January 2008). The second row contains the date of each month (1-31) in the date range. The table also contains "rows size" rows. The first column of these rows contains the contents of the instance variable "rows". Rest of the cells are empty.Basically this is an abstract superclass for WASelectionDateTableInstance Variables:	datesCache	&lt;(SequenceableCollection of: Date&gt;	contains a date object for each date in the range startDate-endDate	endDate	&lt;Date&gt;	end date of the range displayed in the table	rows	&lt;SequenceableCollection&gt;	labels of the rows	startDate	&lt;Date&gt;	start date of the range displayed in the table</body></comment><class><name>WASelectionDateTable</name><environment>Seaside</environment><super>Seaside.WADateTable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cellBlock dateSelectionStart dateSelectionEnd rowSelectionStart rowSelectionEnd </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WASelectionDateTable</class-id><body>WASelectionDateTable renders a table containing dates and rows. A user can select a continuous block of cells in the table.  The table contains one column for each date from startDate to endDate. The top row of the table groups columns by month and labels each month (January 2008). The second row contains the date of each month  (1-30) in the date range. The table also contains "rows size" rows. The first column of these rows contains the contents of the instance variable "rows". Rest of the cells contents are given by "cellBlock". Instance Variables:	cellBlock	&lt;BlockClosure [:rowIndex :date | ]&gt;	returns text for the cell in row "rowIndex" and column for "date"	dateSelectionEnd	&lt;Date&gt;	last selected date	dateSelectionStart	&lt;Date&gt;	first selected date	rowSelectionEnd	&lt;Integer&gt;	index of last selected row	rowSelectionStart	&lt;Integer&gt;	index of first selected row</body></comment><class><name>WATimeSelector</name><environment>Seaside</environment><super>Seaside.WACanvasWidget</super><private>false</private><indexed-type>none</indexed-type><inst-vars>second hour minute startHour endHour </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WATimeSelector</class-id><body>WATimeSelector displays dropdown menus (html select) allowing a user to delect a time within a range. "startHour" and "endHour" define the range of selectable times. Time is displayed in 24 hour format. WATimeSelector&gt;&gt;time returns time user selected as a Time object.See WADateSelectorFunctionalTest for sample of usage.Select "Date Selector" tab of the Functional Seaside Test Suite to run an example  (http://127.0.0.1:xxxx/seaside/tests/alltests)Instance Variables:	endHour	&lt;Integer 0-23&gt;	end of time interval for selectable times	hour	&lt;Integer 0-23&gt;	selected hour	minute	&lt;Integer 0-59&gt;	selected minute	second	&lt;Integer 0-59&gt;	selected second	startHour	&lt;Integer 0-23&gt;	start of time interval for selectable times</body></comment><class><name>WANavigationFiles</name><environment>Seaside</environment><super>Seaside.WAFileLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WANavigationFiles</class-id><body>Provides CSS to render WANavigation using tabs.</body></comment><class><name>WAValidationDecoration</name><environment>Seaside</environment><super>Seaside.WAWidgetDecoration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>message validationBlock exceptionClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Decorations</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WAValidationDecoration</class-id><body>A WAValidationDecoration validates its component form data when the component returns using "answer" or "answer:". A WAValidationDecoration can be added to component via the method "validateWith:" as below.	SampleLoginComponent&gt;&gt;intialize		form := WAFormDecoration new buttons: self buttons.		self addDecoration: form.		self validateWith: [:answerArgOrSelf | answerArgOrSelf validate].		self addMessage: 'Please enter the following information'.If component returns via "answer:" the answer: argument is passed to the validate block. If the component returns using "answer" the sender of "answer" is passed to the validate block.Instance Variables	exceptionClass:		&lt;Notification&gt;	message:		&lt;String&gt;	validationBlock:		&lt;one arg block&gt;exceptionClass	- Type of notication that is raised by validation code when validation fails. Default value is WAValidationNotificationmessage	- String message displayed on validation failure. Obtained from the notificationvalidationBlock	- One arg block, </body></comment><class><name>WAPath</name><environment>Seaside</environment><super>Seaside.WACanvasWidget</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WAPath</class-id><body>WAPath represents a path navigation (breadcrumbs) for a web page and displays standard breadcrumbs(xxx &gt;&gt; yyy &gt;&gt; zzz). WAPath maintains a stack of associations, one for each "location" or "page" in the path. The association key is the text that is displayed in the breadcrimb. The association value is an object of your choosing, which your code uses to restore that "page". To add to the path use the method WAPath&gt;&gt;pushSegment: anObject name: 'lulu'. The name: arguement is the association key, the segment: argument is the association value.The method WAPath&gt;&gt;currentSegment returns object associated with the current "page". Your code is not notified when the user clicks on a link in the WAPath object. So when you render a page call WAPath&gt;&gt;currentSegment to get the current object, and generate the page accordingly.See WAInspector for example use.Use WATrail to handle breadcrumbs for sequences of call: and answers:.Instance Variables:	stack	&lt;Array of associations(String-&gt;Object) &gt; History of the page. Keys -&gt; display string, values -&gt; object used in helping generating page.</body></comment><class><name>WADelayedAnswerDecoration</name><environment>Seaside</environment><super>Seaside.WAWidgetDecoration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>delay </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Decorations</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WADelayedAnswerDecoration</class-id><body>WADelayedAnswerDecoration adds a delay in displaying a component. See WADelayFunctionalTest for sample usage.Select 'Delay" tab of the Functional Seaside Test Suite to run an example  (http://127.0.0.1:xxxx/tests/functional/WADelayFunctionalTest)Instance Variables:	delay	&lt;Integer&gt;	delay length in seconds </body></comment><class><name>WABatchedList</name><environment>Seaside</environment><super>Seaside.WACanvasWidget</super><private>false</private><indexed-type>none</indexed-type><inst-vars>items batchSize currentPage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WABatchedList</class-id><body>WABatchedList helps display a collection of items across multiple pages. WABatchedList organizes a collection into pages (or batches) of batchSize items each and renders navigation links for a user to moved between pages. WABatchedList&gt;&gt;batch returns the items to display in the current page or batch. Your code has to display the items.See WABatchSelection for example of usage.Instance Variables:	batchSize	&lt;Integer&gt;	number of items to display on a single page	currentPage	&lt;Integer&gt;	 index of current page, starts a 1	items	&lt;SequenceableCollection of Objects&gt;	objects organized into pages for display</body></comment><class><name>WABatchSelection</name><environment>Seaside</environment><super>Seaside.WACanvasWidget</super><private>false</private><indexed-type>none</indexed-type><inst-vars>batcher linkSelector textSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WABatchSelection</class-id><body>WABatchSelection displays a list of objects. The list is show N (currently 8) items per page, with links to navigate to other pages if needed. Objects in the list must implement one method that returns text description of the item and one method that returns a name or label used as the link users click to select the item. The text description is displayed below the link.Example	items := OrderedCollection new.	1 to: 20 do: [:each | items add: (Contact new name: each; phoneNumber: '54321';yourself)].	selection := WABatchSelection items: items link: #name text: #phoneNumber.	result := self call: selection.	where the Contact class has methodsinstance vars "phoneNumber" and "name", with	setter &amp; getter methods.Instance Variables:	batcher	&lt;WABatchedList&gt;	description of batcher	linkSelector	&lt;Symbol&gt;	method sent to items in list for link text	textSelector	&lt;Symbol&gt;	method sent to items in list for text description</body></comment><class><name>WASelection</name><environment>Seaside</environment><super>Seaside.WACanvasWidget</super><private>false</private><indexed-type>none</indexed-type><inst-vars>items labelBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WASelection</class-id><body>WASelection creates a selectable list. Items can be any object. If optional labelBlock is not given the string versions of the items are displayed to user, otherwise labelBlock is used to generate the text to display for each item. Returns the item selected by user, (not the index nor the text shown the user). 	| selection |	selection := WASelection new.	selection items: #(1 'cat' 'rat').	selection 		labelBlock: [:item | item = 1 ifTrue: ['First'] ifFalse: [item asUppercase]].	result := self call: selection.	self inform: result printStringInstance Variables:	items	&lt;Array of Objects&gt; 		labelBlock	&lt;One arg Block&gt;	</body></comment><class><name>WAValidationNotification</name><environment>Seaside</environment><super>Seaside.WANotification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Decorations</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WAValidationNotification</class-id><body>I am signaled to indicate that a validation has occurred.  See: WAFormDialog&gt;&gt;#validationError:, WAComponent&gt;&gt;validateWith: and WAValidationDecoration.</body></comment><class><name>WAChoiceDialog</name><environment>Seaside</environment><super>Seaside.WAFormDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>options selection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WAChoiceDialog</class-id><body>WAChoiceDialog produces a form with select tag (dropdown menu) on a collection of options and "Ok" and "Cancel" buttons. Options can be any object. Returns actual object selected or nil if user select "Cancel". WAChoiceDialog is used to implement the chooseFrom:caption: convenience method in WAComponent.	| selection |	selection := WAChoiceDialog options: #('Smalltalk' 'Perl' 'Python' 'Ruby' 9).	result := self call: selection.	self inform: result printStringInstance Variables:	options	&lt;Collection of Objects&gt; objects in list	selection	&lt;Object&gt;	object selected by user or nil if user cancels</body></comment><class><name>WAWindowDecoration</name><environment>Seaside</environment><super>Seaside.WAWidgetDecoration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>title cssClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Decorations</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WAWindowDecoration</class-id><body>WAWindowDecoration adds a simple title and close button in a bordered area at the top of the page. When closed button is selected nil is "answer"ed. Useful for a quick &amp; dirty dialog window. Used by WAPlugin and SCTestRunner.Instance Variables:	cssClass	&lt;String&gt;	String added to "window-title " to generate cssClass for the title	title	&lt;String&gt;	title of page</body></comment><class><name>WAMiniCalendar</name><environment>Seaside</environment><super>Seaside.WACanvasWidget</super><private>false</private><indexed-type>none</indexed-type><inst-vars>monthIndex year date canSelectBlock selectBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WAMiniCalendar</class-id><body>WAMiniCalendar renders a monthly calendar. Users can navigate by month, year, or select a year and a month. Users can select a date in the calendar. Set canSelectBlock to control which dates a user can select. Use selectBlock to perform an action when a user selects a date. WAMiniCalendar&gt;&gt;date returns the selected date.Select "Mini Calendar" tab of the Functional Seaside Test Suite to run an example  (http://127.0.0.1:xxxx/tests/functional/WAMiniCalendarFunctionalTest)Instance Variables:	canSelectBlock		&lt;BlockClosure with date argument&gt;	return true if date argument should be rendered with a link, ie user can select that date	date				&lt;WAValueHolder on a date&gt;	Selected date	monthIndex			&lt;WAValueHolder on an Integer&gt;	Currently displayed month	year				&lt;WAValueHolder on an Integer&gt;	Currently displayed year	selectBlock			&lt;BlockClosure with date argument&gt; called when user selects a date</body></comment><class><name>WANavigationBar</name><environment>Seaside</environment><super>Seaside.WACanvasWidget</super><private>false</private><indexed-type>none</indexed-type><inst-vars>actionsSelector owner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WANavigationBar</class-id><body>WANavigationBar provides navigation links for a component, the WANavigationBar's owner. WANavigationBar is vertical in that all items in the bar are rendered in a column. WANavigationBar's owner typically is a top level component that renders a number of children components, including the WANavigationBar. When a user selects an item in the WANavigationBar a message is sent to the owner, so it can change.The owner component needs to implement the method indicated by the instance variable "actionsSelector", the default value is "actions". This method returns a collections of symbols. The symbols become the list of items in the navigation bar. The first letter of the symbol is capitalized when displayed. If the symbol represents a 0-argument method it is rendered as a link. When the user clicks on the link the original symbol is send as a message to the owner component. If the symbol represents a 1-argument method it is rendered as a label followed by a text input box. The user has to know that they hit enter after filling the text box.Instance Variables:	actionsSelector	&lt;ByteSymbol&gt;	Symbol sent to owner to get a list of items to be listed in the navigation bar. Default value is "actions".	owner	&lt;WAComponent&gt;	This is the navigation bar for the component "owner".</body></comment><class><name>WAInputDialog</name><environment>Seaside</environment><super>Seaside.WACanvasWidget</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WAInputDialog</class-id><body>WAInputDialog generates a simple form with a text input field and a submit button. The instance variable "value" is used for initial value of the text field and hold the text entered by user. WAInputDialog answers with text entered by user (value of "value"). See WAComponent&gt;&gt;request:label:default: for sample use and easy way to use WAInputDialog.Instance Variables:	label	&lt;String&gt;	label of submit button	value	&lt;Object | String&gt;	</body></comment><class><name>WALabelledFormDialog</name><environment>Seaside</environment><super>Seaside.WAFormDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Components</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WALabelledFormDialog</class-id><body>WALabelledFormDialog is an abstract class for generating html forms. Given a data model WALabelledFormDialog displays a label and input field for each instance variable of interest. User supplied data is placed in the data model.Subclasses need to implment the methods labelForSelector:, model, and rows. The "model" method just returns the object whose fields we wish to populate with date. The "rows" method returns a collections of symbols. One symbol for each row of data in the dialog. The symbol is used generate the accessor methods for the data in the model. The method "labelForSelector:" returns the labels for each row and each submit button in the form.A standard text input field is used for each row of data. To use other html widgets for input for = a datum implement the method renderXXXOn: where XXX is the symbol for the row. See "renderNameOn:" in example below.The default form has one button "Ok". Override the "buttons" method to change the text or number of submit buttons on the form. Override the "defaultButton" method to indicate which button is the default. For each button in the form the subclass needs a method with the same name as the button, which is called when the user clicks that button. See example below.LabelledFormDialogExample subclass of WALabelledFormDialog instance methods	initialize		super initialize.		contact := Contact new. "contact is an inst var"		self addMessage: 'Please enter the followning information'.	model		^ contact	ok		self answer: contact	cancel		self answer	rows		^ #(name phoneNumber)	buttons		#(ok cancel)	labelForSelector: aSymbol		aSymbol == #name ifTrue: [^'Your Name'].		aSymbol == #phoneNumber ifTrue: [^'Phone Number'].		aSymbol == #ok ifTrue: [^'Ok'].		aSymbol == #cancel ifTrue: [^'Cancel'].		^ super labelForSelector: aSymbol	renderNameOn: html 		"Show how to specily special input instead of using simple text field."		(html select)				list: #('Roger' 'Pete');				selected: 'Roger';				callback: [:v | contact name: v]Contact Class used above has instance variables name, phoneNumber with standard getter and setter methods</body></comment><class><name>WAFormDecoration</name><environment>Seaside</environment><super>Seaside.WAWidgetDecoration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>buttons </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Widgets-Decorations</category><attributes><package>Seaside-Widgets</package></attributes></class><comment><class-id>Seaside.WAFormDecoration</class-id><body>A WAFormDecoration places its component inside an html form tag. The buttons inst var must be set. The component that a WAFormDecoration decorates must implement the method "defaultButton", which returns the string/symbol of the default button (one selected by default) of the form. Don't place any decorators between WAFormDecoration and its component otherwise "defaultButton" method fails. For each string/symbol in the buttons inst var the decorated component must implement a method of the same name, which is called when the button is selected.Instance Variables	buttons:		&lt;Collection of strings or symbols&gt;buttons	- list of strings or symbols, each string/symbol is the label (first letter capitalized) for a button and the name of the callback method on component when button is pressed, </body></comment><methods><class-id>Seaside.WACanvasWidget</class-id> <category>rendering</category><body package="Seaside-Widgets">rendererClass	"Make sure we use WAHtmlCanvas even if a different renderer is default."	^ WAHtmlCanvas</body></methods><methods><class-id>Seaside.WATableReport</class-id> <category>accessing</category><body package="Seaside-Widgets">columns: anArray	columns := anArray</body><body package="Seaside-Widgets">rowColors: colorArray	rowColors := colorArray</body><body package="Seaside-Widgets">rowPeriod: aNumber	rowPeriod := aNumber</body><body package="Seaside-Widgets">rows	| r |	self sortColumn ifNil: [ ^ rows ].	r := self sortColumn sortRows: rows.	^ self isReversed		ifTrue: [ r reverse ]		ifFalse: [ r ]</body><body package="Seaside-Widgets">rows: anArray	rows := anArray</body></methods><methods><class-id>Seaside.WATableReport</class-id> <category>initialization</category><body package="Seaside-Widgets">initialize	super initialize.	isReversed := false.	rows := #().	columns := #().	sortColumn := WAValueHolder new.	rowColors := #('#fff' '#eee').	rowPeriod := 1</body></methods><methods><class-id>Seaside.WATableReport</class-id> <category>state variables</category><body package="Seaside-Widgets">reverse	isReversed := isReversed not</body><body package="Seaside-Widgets">sortColumn	^ sortColumn contents</body><body package="Seaside-Widgets">sortColumn: anObject	isReversed := anObject = self sortColumn and: [ isReversed not ].	sortColumn contents: anObject</body></methods><methods><class-id>Seaside.WATableReport</class-id> <category>rendering</category><body package="Seaside-Widgets">renderColumn: aColumn row: aRow on: html	| text |	aColumn canRender ifTrue: [		html tableData			class: aColumn cssClass;			with: [ aColumn renderValue: aRow on: html ].		^ self ].	text := aColumn textForRow: aRow.	text isEmpty ifTrue: [ text := ' ' ].	html tableData		class: aColumn cssClass;		with: [			aColumn canChoose				ifFalse: [ html text: text ]				ifTrue: [					html anchor						callback: [ self chooseRow: aRow column: aColumn ];						with: text ] ]</body><body package="Seaside-Widgets">renderContentOn: html	html table: [		html tableHead: [ self renderTableHeaderOn: html ].		html tableFoot: [ self renderTableFooterOn: html ].		html tableBody: [ self renderRowsOn: html ] ]</body><body package="Seaside-Widgets">renderFooterForColumn: aColumn on: html	html tableData		class: aColumn cssClass;		with: (aColumn totalForRows: rows)</body><body package="Seaside-Widgets">renderHeaderForColumn: aColumn on: html	html tableHeading		class: aColumn cssClass;		with: [			aColumn canSort				ifTrue: [					html anchor						callback: [ self sortColumn: aColumn ];						with: aColumn title ]				ifFalse: [ html text: aColumn title ] ]</body><body package="Seaside-Widgets">renderRowNumber: index item: row on: html	html tableRow		style: 'background-color: ' , (self colorForRowNumber: index);		with: [			columns do: [ :each |				self renderColumn: each row: row on: html ] ]</body><body package="Seaside-Widgets">renderRowsOn: html 	self rows keysAndValuesDo: [ :index :row | 		self renderRowNumber: index item: row on: html ]</body><body package="Seaside-Widgets">renderTableFooterOn: html	html tableRow: [		columns do: [ :each |			self renderFooterForColumn: each on: html ] ]</body><body package="Seaside-Widgets">renderTableHeaderOn: html	html tableRow: [		columns do: [ :each |			self renderHeaderForColumn: each on: html ] ]</body></methods><methods><class-id>Seaside.WATableReport</class-id> <category>private</category><body package="Seaside-Widgets">chooseRow: aRow column: aColumn	aColumn chooseRow: aRow</body><body package="Seaside-Widgets">colorForRowNumber: aNumber	^ rowColors at: ((aNumber - 1 // rowPeriod) \\ rowColors size) + 1 ifAbsent: [ '#fff' ]</body></methods><methods><class-id>Seaside.WATableReport</class-id> <category>testing</category><body package="Seaside-Widgets">isReversed	^ isReversed</body></methods><methods><class-id>Seaside.WATableReport</class-id> <category>hooks</category><body package="Seaside-Widgets">states	^ Array with: sortColumn</body></methods><methods><class-id>Seaside.WANavigation</class-id> <category>selection</category><body package="Seaside-Widgets">select: anObject	selection contents: anObject.	self selectionChanged</body><body package="Seaside-Widgets">selection	^ selection contents</body><body package="Seaside-Widgets">selectionChanged</body></methods><methods><class-id>Seaside.WANavigation</class-id> <category>rendering</category><body package="Seaside-Widgets">renderContentOn: html	html div class: 'kalsey'; with: [		html div			class: 'navigation-options';			with: [ self renderOptionsOn: html ].		html div			class: 'navigation-content';			with: [ self renderSelectionOn: html ] ]</body><body package="Seaside-Widgets">renderOptionsOn: html	html unorderedList		list: self options;		selected: self selection;		callback: [ :value | self select: value ];		labels: [ :each | self labelForOption: each ]</body><body package="Seaside-Widgets">renderSelectionOn: html</body></methods><methods><class-id>Seaside.WANavigation</class-id> <category>accessing</category><body package="Seaside-Widgets">options	^ #()</body></methods><methods><class-id>Seaside.WANavigation</class-id> <category>initialization</category><body package="Seaside-Widgets">initialize	super initialize.	selection := WAValueHolder new</body></methods><methods><class-id>Seaside.WANavigation</class-id> <category>query</category><body package="Seaside-Widgets">labelForOption: anObject 	^ anObject greaseString</body></methods><methods><class-id>Seaside.WANavigation</class-id> <category>hooks</category><body package="Seaside-Widgets">states	^ Array with: selection</body></methods><methods><class-id>Seaside.WADateTimeSelector</class-id> <category>initialization</category><body package="Seaside-Widgets">initialize	super initialize.	dateSelector := WADateSelector new.	timeSelector := WATimeSelector new</body></methods><methods><class-id>Seaside.WADateTimeSelector</class-id> <category>accessing</category><body package="Seaside-Widgets">dateAndTime	^ DateAndTime date: dateSelector date time: timeSelector time</body><body package="Seaside-Widgets">dateAndTime: anObject	dateSelector date: anObject asDate.	timeSelector time: anObject asTime</body></methods><methods><class-id>Seaside.WADateTimeSelector</class-id> <category>rendering</category><body package="Seaside-Widgets">renderContentOn: html	html span: dateSelector.	html span: [ html strong: ' : ' ].	html span: timeSelector</body></methods><methods><class-id>Seaside.WADateTimeSelector</class-id> <category>hooks</category><body package="Seaside-Widgets">children	^ Array with: dateSelector with: timeSelector</body></methods><methods><class-id>Seaside.WATrail</class-id> <category>accessing</category><body package="Seaside-Widgets">root: anObject	root := anObject</body><body package="Seaside-Widgets">separator	^ ' &gt; '</body></methods><methods><class-id>Seaside.WATrail</class-id> <category>rendering</category><body package="Seaside-Widgets">renderContentOn: html	| last selected |	last := nil.	html div		class: 'trail';		with: [			root visiblePresentersDo: [ :each | 				(each isDecoration and: [ each isDelegation ]) ifTrue: [					(each decoratedComponent respondsTo: #trailName) ifTrue: [						last := each.						html anchor							callback: [ each remove ];							with: (each decoratedComponent perform: #trailName).						html span							class: 'separator';							with: self separator ] ] ].			selected := last isNil				ifTrue: [ root ]				ifFalse: [ last delegate ].			(selected respondsTo: #trailName) ifTrue: [				html text: (selected perform: #trailName) ] ]</body></methods><methods><class-id>Seaside.WATrail class</class-id> <category>instance creation</category><body package="Seaside-Widgets">on: anObject	^ self new root: anObject</body></methods><methods><class-id>Seaside.WAReportColumn</class-id> <category>public</category><body package="Seaside-Widgets">canChoose	^ clickBlock notNil</body><body package="Seaside-Widgets">canSort	^ self canRender not and: [ sortBlock notNil ]</body><body package="Seaside-Widgets">chooseRow: row	^ clickBlock value: row</body><body package="Seaside-Widgets">sortRows: anArray	| assocs |	assocs := anArray collect: [ :ea | ea -&gt; (self valueForRow: ea) ].	assocs := assocs asSortedCollection: [ :a :b | sortBlock value: a value value: b value ].	^ assocs collect: [ :ea | ea key ]</body><body package="Seaside-Widgets">textForRow: row	^ formatBlock value: (self valueForRow: row)</body><body package="Seaside-Widgets">title	^ title</body><body package="Seaside-Widgets">totalForRows: aCollection	^ hasTotal		ifFalse: [ '' ]		ifTrue: [ formatBlock value: (aCollection inject: 0 into: [ :sum :r | sum + (self valueForRow: r) ]) ]</body><body package="Seaside-Widgets">valueForRow: row	^ valueBlock value: row</body></methods><methods><class-id>Seaside.WAReportColumn</class-id> <category>accessing</category><body package="Seaside-Widgets">clickBlock: aBlock	clickBlock := aBlock</body><body package="Seaside-Widgets">columnClickBlock: aBlock	self clickBlock: [ :r | aBlock value: (self valueForRow: r) ]</body><body package="Seaside-Widgets">cssClass	^ cssClass</body><body package="Seaside-Widgets">cssClass: aString	cssClass := aString</body><body package="Seaside-Widgets">formatBlock: anObject	formatBlock := anObject</body><body package="Seaside-Widgets">hasTotal: aBoolean	hasTotal := aBoolean</body><body package="Seaside-Widgets">index: aNumber	valueBlock := [ :row | row at: aNumber ]</body><body package="Seaside-Widgets">selector: aSymbol	valueBlock := [ :row | row perform: aSymbol ]</body><body package="Seaside-Widgets">sortBlock: anObject	sortBlock := anObject</body><body package="Seaside-Widgets">title: aString	title := aString</body><body package="Seaside-Widgets">valueBlock: aBlock	valueBlock := aBlock</body></methods><methods><class-id>Seaside.WAReportColumn</class-id> <category>rendering</category><body package="Seaside-Widgets">canRender	^ valueBlock argumentCount &gt; 1</body><body package="Seaside-Widgets">renderValue: anObject on: html	valueBlock value: anObject value: html</body></methods><methods><class-id>Seaside.WAReportColumn</class-id> <category>initialization</category><body package="Seaside-Widgets">initialize	super initialize.	formatBlock := [ :x | x greaseString ].	sortBlock := [ :a :b | a &lt;= b ].	valueBlock := [ :row | nil ].	clickBlock := nil.	title := 'Untitled'.	hasTotal := false</body></methods><methods><class-id>Seaside.WAReportColumn class</class-id> <category>instance creation</category><body package="Seaside-Widgets">renderBlock: aBlock title: aString	^ self new		title: aString;		valueBlock: aBlock;		yourself</body><body package="Seaside-Widgets">selector: aSymbol	^ self selector: aSymbol title: aSymbol capitalized</body><body package="Seaside-Widgets">selector: aSymbol title: aString	^ self selector: aSymbol title: aString onClick: nil</body><body package="Seaside-Widgets">selector: aSymbol title: aString onClick: aBlock	^ self new		title: aString;		selector: aSymbol;		clickBlock: aBlock;		yourself</body></methods><methods><class-id>Seaside.WASimpleNavigation</class-id> <category>accessing</category><body package="Seaside-Widgets">components	^ components</body><body package="Seaside-Widgets">labels	"Return the tabs labels"	^ self options</body><body package="Seaside-Widgets">options	^ components collect: [ :each | each key ]</body><body package="Seaside-Widgets">selectedComponent	^ (components detect: [ :each | each key = self selection ] ifNone: [ ^ nil ]) value</body></methods><methods><class-id>Seaside.WASimpleNavigation</class-id> <category>rendering</category><body package="Seaside-Widgets">renderSelectionOn: html	html render: self selectedComponent</body></methods><methods><class-id>Seaside.WASimpleNavigation</class-id> <category>behavior</category><body package="Seaside-Widgets">add: aComponent label: aString	components add: aString -&gt; aComponent</body><body package="Seaside-Widgets">selectFirst	"Selects the first added component as active."		components notEmpty		ifTrue: [ self select: components first key ]</body></methods><methods><class-id>Seaside.WASimpleNavigation</class-id> <category>hooks</category><body package="Seaside-Widgets">children	^ Array with: self selectedComponent</body></methods><methods><class-id>Seaside.WASimpleNavigation</class-id> <category>initialization</category><body package="Seaside-Widgets">initialize	super initialize.	components := OrderedCollection new</body></methods><methods><class-id>Seaside.WATree</class-id> <category>accessing-configuration</category><body package="Seaside-Widgets">canSelectBlock	^ canSelectBlock</body><body package="Seaside-Widgets">canSelectBlock: aBlock	canSelectBlock := aBlock</body><body package="Seaside-Widgets">childrenBlock	^ childrenBlock</body><body package="Seaside-Widgets">childrenBlock: aBlock	childrenBlock := aBlock</body><body package="Seaside-Widgets">labelBlock	^ labelBlock</body><body package="Seaside-Widgets">labelBlock: aBlock	labelBlock := aBlock</body><body package="Seaside-Widgets">selectBlock	^ selectBlock</body><body package="Seaside-Widgets">selectBlock: aBlock	selectBlock := aBlock</body></methods><methods><class-id>Seaside.WATree</class-id> <category>accessing</category><body package="Seaside-Widgets">root	^ root</body><body package="Seaside-Widgets">root: aNode	root := aNode</body><body package="Seaside-Widgets">selected	^ selected</body><body package="Seaside-Widgets">selected: aNode	selected := aNode</body></methods><methods><class-id>Seaside.WATree</class-id> <category>rendering-nodes</category><body package="Seaside-Widgets">renderNode: aNode on: html	html listItem: [		self renderNodeButton: aNode on: html.		self renderNodeLabel: aNode on: html.		self renderNodeChildren: aNode on: html ]</body><body package="Seaside-Widgets">renderNodeButton: aNode on: html 	| isExpanded |	html span		class: 'button';		with: 			[ (self hasChildren: aNode) ifTrue: 				[ isExpanded := self isExpanded: aNode.				self 					renderNodeButtonLink: aNode					action: (GRDelayedSend 							receiver: self							selector: (isExpanded 									ifTrue: [ #collapse: ]									ifFalse: [ #expand: ])							argument: aNode)					text: (isExpanded 							ifTrue: [ '-' ]							ifFalse: [ '+' ])					on: html ] ]</body><body package="Seaside-Widgets">renderNodeButtonLink: aNode action: aBlock text: anObject on: html	html anchor callback: aBlock; with: anObject</body><body package="Seaside-Widgets">renderNodeChildren: aNode on: html	| children |	children := self childrenOf: aNode.	children isEmpty ifFalse: [		(self isExpanded: aNode) ifTrue: [			html unorderedList: [				children do: [ :each |					self renderNode: each on: html ] ] ] ]</body><body package="Seaside-Widgets">renderNodeLabel: aNode on: html 	| label |	html span		class: 'label';		class: (self selected == aNode 				ifTrue: [ 'active' ]				ifFalse: [ 'inactive' ]);		with: 			[ label := self labelOf: aNode.			(self canSelect: aNode) 				ifFalse: [ html render: label ]				ifTrue: 					[ self 						renderNodeLabelLink: aNode						action: (GRDelayedSend 								receiver: self								selector: #select:								argument: aNode)						text: label						on: html ] ]</body><body package="Seaside-Widgets">renderNodeLabelLink: aNode action: aBlock text: anObject on: html	html anchor callback: aBlock; with: anObject</body></methods><methods><class-id>Seaside.WATree</class-id> <category>rendering</category><body package="Seaside-Widgets">renderContentOn: html	self renderTreeOn: html</body><body package="Seaside-Widgets">renderTreeOn: html	html unorderedList: [ self renderNode: self root on: html ]</body></methods><methods><class-id>Seaside.WATree</class-id> <category>actions</category><body package="Seaside-Widgets">collapse: aNode	expanded remove: aNode</body><body package="Seaside-Widgets">expand: aNode	expanded add: aNode</body><body package="Seaside-Widgets">expandAll: aCollection	expanded addAll: aCollection</body><body package="Seaside-Widgets">select: aNode 	(self canSelect: aNode) ifFalse: [ ^ self ].	self selected: aNode.	self selectBlock isNil ifFalse: [ self selectBlock value: aNode ]</body></methods><methods><class-id>Seaside.WATree</class-id> <category>accessing-nodes</category><body package="Seaside-Widgets">childrenOf: aNode	| children |	children := self childrenBlock value: aNode.	^ children ifNil: [ Array new ]</body><body package="Seaside-Widgets">labelOf: aNode	^ self labelBlock value: aNode</body></methods><methods><class-id>Seaside.WATree</class-id> <category>initialization</category><body package="Seaside-Widgets">initialize	super initialize.	expanded := IdentitySet new.	self selectBlock: [ :node | self answer: node ].	self childrenBlock: [ :node | Array new ].	self labelBlock: [ :node | node greaseString ]</body></methods><methods><class-id>Seaside.WATree</class-id> <category>testing</category><body package="Seaside-Widgets">canSelect: aNode	^ self selectBlock notNil and: [ self canSelectBlock isNil or: [ self canSelectBlock value: aNode ] ]</body><body package="Seaside-Widgets">hasChildren: aNode	^ (self childrenOf: aNode) isEmpty not</body><body package="Seaside-Widgets">isExpanded: aNode	^ expanded includes: aNode</body></methods><methods><class-id>Seaside.WATree</class-id> <category>hooks</category><body package="Seaside-Widgets">states	^ Array with: expanded</body></methods><methods><class-id>Seaside.WATree class</class-id> <category>instance creation</category><body package="Seaside-Widgets">root: anObject	^ self new		root: anObject;		yourself</body><body package="Seaside-Widgets">root: anObject path: anArray	^ (self root: anObject)		expandAll: anArray;		selected: anArray last;		yourself</body></methods><methods><class-id>Seaside.WATree class</class-id> <category>examples</category><body package="Seaside-Widgets">exampleClassBrowser	^ self new		root: Collection;		labelBlock: [ :class | class name ];		childrenBlock: [ :class | class subclasses ];		yourself</body></methods><methods><class-id>Seaside.WAFormDialog</class-id> <category>rendering</category><body package="Seaside-Widgets">renderContentOn: html	html hiddenInput 		callback: [ validationError := nil ].	validationError isNil		ifFalse: [ self renderValidationError: validationError on: html ].	html div		class: self divClass;		with: [ self renderDialogOn: html ]</body><body package="Seaside-Widgets">renderDialogOn: html</body><body package="Seaside-Widgets">renderSpacerRowOn: html	html div class: 'dialog-spacer'; with: [ html space ]</body><body package="Seaside-Widgets">renderValidationError: aString on: html	html span class: 'dialog-validation'; with: aString</body></methods><methods><class-id>Seaside.WAFormDialog</class-id> <category>testing</category><body package="Seaside-Widgets">addFormByDefault	^ true</body><body package="Seaside-Widgets">isValid	^ validationError isNil</body></methods><methods><class-id>Seaside.WAFormDialog</class-id> <category>actions</category><body package="Seaside-Widgets">addForm	form := WAFormDecoration new buttons: self buttons.	self addDecoration: form</body><body package="Seaside-Widgets">ok	self answer</body><body package="Seaside-Widgets">removeForm	form isNil		ifFalse: [ self removeDecoration: form ]</body></methods><methods><class-id>Seaside.WAFormDialog</class-id> <category>accessing</category><body package="Seaside-Widgets">buttons	^ #(ok)</body><body package="Seaside-Widgets">defaultButton	^ self buttons first</body><body package="Seaside-Widgets">divClass	^ self class name</body><body package="Seaside-Widgets">model	^ self</body></methods><methods><class-id>Seaside.WAFormDialog</class-id> <category>validation</category><body package="Seaside-Widgets">validationError: aString	validationError := aString</body></methods><methods><class-id>Seaside.WAFormDialog</class-id> <category>initialization</category><body package="Seaside-Widgets">initialize	super initialize.	self addFormByDefault		ifTrue: [ self addForm ]</body></methods><methods><class-id>Seaside.WAYesOrNoDialog</class-id> <category>accessing</category><body package="Seaside-Widgets">buttons	^ #(yes no)</body><body package="Seaside-Widgets">no	self answer: false</body><body package="Seaside-Widgets">yes	self answer: true</body></methods><methods><class-id>Seaside.WAYesOrNoDialog class</class-id> <category>examples</category><body package="Seaside-Widgets">exampleComponent	^ self new</body></methods><methods><class-id>Seaside.WADateSelector</class-id> <category>rendering</category><body package="Seaside-Widgets">renderContentOn: html	html select		list: self months;		on: #month of: self;		labels: [ :each | self labelForMonth: each ].	html select		list: self days;		on: #day of: self;		labels: [ :each | self labelForDay: each ].	html select		list: self yearRange;		on: #year of: self;		labels: [ :each | self labelForYear: each ].	self dateIsValid ifFalse: [ self renderValidationErrorOn: html ]</body><body package="Seaside-Widgets">renderValidationErrorOn: html	html span		class: 'error';		with: 'invalid date'</body></methods><methods><class-id>Seaside.WADateSelector</class-id> <category>accessing</category><body package="Seaside-Widgets">date	(self privateIsValidDay: day monthNumber: month year: year)		ifFalse: [ self error: 'Invalid date' ].	^ self dateClass year: year month: month day: day</body><body package="Seaside-Widgets">date: aDate	day := aDate dayOfMonth.	month := aDate monthIndex.	year := aDate year</body><body package="Seaside-Widgets">day	^ day</body><body package="Seaside-Widgets">day: anObject	day := anObject</body><body package="Seaside-Widgets">days	^ 1 to: 31</body><body package="Seaside-Widgets">endYear	^ endYear</body><body package="Seaside-Widgets">endYear: anInteger	endYear := anInteger</body><body package="Seaside-Widgets">labelForDay: aNumber	^ aNumber</body><body package="Seaside-Widgets">labelForMonth: aNumber	^ Date nameOfMonth: aNumber</body><body package="Seaside-Widgets">labelForYear: aNumber	^ aNumber</body><body package="Seaside-Widgets">month	^ month</body><body package="Seaside-Widgets">month: anObject	month := anObject</body><body package="Seaside-Widgets">months	^ 1 to: 12</body><body package="Seaside-Widgets">startYear	^ startYear</body><body package="Seaside-Widgets">startYear: anInteger	startYear := anInteger</body><body package="Seaside-Widgets">year	^ year</body><body package="Seaside-Widgets">year: anObject	year := anObject</body><body package="Seaside-Widgets">yearRange	^ self startYear to: self endYear</body></methods><methods><class-id>Seaside.WADateSelector</class-id> <category>initialization</category><body package="Seaside-Widgets">initialize	super initialize.	startYear := Date today year - 1.	endYear := Date today year + 5.	self date: self dateClass today</body></methods><methods><class-id>Seaside.WADateSelector</class-id> <category>private</category><body package="Seaside-Widgets">dateClass	^ Date</body><body package="Seaside-Widgets">privateIsValidDay: theDay monthNumber: theMonth year: theYear	| daysInMonth |	(theMonth between: 1 and: 12)		ifFalse: [ ^ false ].	daysInMonth := Date daysInMonth: (Date nameOfMonth: theMonth) forYear: theYear.	^ theDay between: 1 and: daysInMonth</body></methods><methods><class-id>Seaside.WADateSelector</class-id> <category>testing</category><body package="Seaside-Widgets">dateIsValid	[ self date ] on: Error do: [ :e | ^ false ].	^ true</body></methods><methods><class-id>Seaside.WAWidgetDecoration</class-id> <category>rendering</category><body package="Seaside-Widgets">rendererClass	"Make sure we use WAHtmlCanvas even if a different renderer is default."	^ WAHtmlCanvas</body></methods><methods><class-id>Seaside.WAMessageDecoration</class-id> <category>rendering</category><body package="Seaside-Widgets">renderContentOn: html	html heading level3; with: message.	self renderNextOn: html</body></methods><methods><class-id>Seaside.WAMessageDecoration</class-id> <category>accessing</category><body package="Seaside-Widgets">message: aString	message := aString</body></methods><methods><class-id>Seaside.WAAlphabeticBatchedList</class-id> <category>rendering</category><body package="Seaside-Widgets">renderContentOn: html	items isEmpty		ifTrue: [ ^ self ].	html div		class: 'batch';		with: [			self renderPreviousOn: html.			self renderPagesOn: html.			self renderNextOn: html ]</body><body package="Seaside-Widgets">renderNextOn: html	html space.	self isOnLastPage		ifFalse: [ html anchor callback: [ self nextPage ]; with: '&gt;&gt;' ]		ifTrue: [ html text: '&gt;&gt;' ]</body><body package="Seaside-Widgets">renderPagesOn: html	self allPages		do: [ :char |			currentPage = char				ifFalse: [					(self validPages includes: char)						ifTrue: [ html anchor callback: [ self currentPage: char ] ; with: char ]						ifFalse: [ html text: char ] ]				ifTrue: [ html strong: char ] ]		separatedBy: [ html space ]</body><body package="Seaside-Widgets">renderPreviousOn: html	self isOnFirstPage		ifFalse: [ html anchor callback: [ self previousPage ]; with: '&lt;&lt;' ]		ifTrue: [ html text: '&lt;&lt;' ].	html space</body></methods><methods><class-id>Seaside.WAAlphabeticBatchedList</class-id> <category>testing</category><body package="Seaside-Widgets">isOnFirstPage	^ self validPages first = self currentPage</body><body package="Seaside-Widgets">isOnLastPage	^ self validPages last = self currentPage</body></methods><methods><class-id>Seaside.WAAlphabeticBatchedList</class-id> <category>accessing</category><body package="Seaside-Widgets">currentPage	^ currentPage ifNil: [ currentPage := self validPages first ]</body><body package="Seaside-Widgets">currentPage: aCharacter	currentPage := aCharacter</body><body package="Seaside-Widgets">items	^ items</body><body package="Seaside-Widgets">items: aCollection	items := aCollection</body></methods><methods><class-id>Seaside.WAAlphabeticBatchedList</class-id> <category>accessing-calculated</category><body package="Seaside-Widgets">allPages	^ 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'</body><body package="Seaside-Widgets">batch	^ items select: [ :each |		each greaseString asUppercase first = self currentPage ]</body><body package="Seaside-Widgets">validPages	^ (items collect: [ :each |		each greaseString asUppercase first ]) asSet sorted</body></methods><methods><class-id>Seaside.WAAlphabeticBatchedList</class-id> <category>actions</category><body package="Seaside-Widgets">nextPage	self isOnLastPage		ifFalse: [ currentPage := self validPages after: currentPage ]</body><body package="Seaside-Widgets">previousPage	self isOnFirstPage		ifFalse: [ currentPage := self validPages before: currentPage ]</body></methods><methods><class-id>Seaside.WAAlphabeticBatchedList</class-id> <category>hooks</category><body package="Seaside-Widgets">states	^ Array with: self</body></methods><methods><class-id>Seaside.WADateTable</class-id> <category>accessing</category><body package="Seaside-Widgets">endDate: aDate	endDate := aDate.	self updateDatesCache</body><body package="Seaside-Widgets">rows: aCollection	rows := aCollection</body><body package="Seaside-Widgets">startDate: aDate	startDate := aDate.	self updateDatesCache</body></methods><methods><class-id>Seaside.WADateTable</class-id> <category>rendering</category><body package="Seaside-Widgets">renderCellForDate: aDate row: anObject index: aNumber on: html	html tableData: [ html space ]</body><body package="Seaside-Widgets">renderContentOn: html	html table		class: 'DateTable';		with: [			html tableRow: [				self renderMonthHeadingsOn: html ].			html tableRow: [				self renderDayHeadingsOn: html ].			rows keysAndValuesDo: [ :index :each | 				html tableRow: [					self						renderRow: each						index: index						on: html ] ] ]</body><body package="Seaside-Widgets">renderDayHeadingsOn: html	self renderHeadingSpacerOn: html.	self		datesDo: [ :date |			html tableHeading				class: 'DayHeading';				with: date dayOfMonth ]		separatedBy: [ self renderHeadingSpacerOn: html ]</body><body package="Seaside-Widgets">renderHeadingForRow: anObject on: html	html tableHeading		class: 'RowHeading';		with: anObject</body><body package="Seaside-Widgets">renderHeadingSpacerOn: html	html tableData: ''</body><body package="Seaside-Widgets">renderMonthHeadingsOn: html	self monthsAndLengthsDo: [ :month :length |		self renderHeadingSpacerOn: html.		html tableHeading			colSpan: length;			class: 'MonthHeading';			with: [				html text: month name.				html space.				html text: month year ] ]</body><body package="Seaside-Widgets">renderRow: anObject index: aNumber on: html	self renderHeadingForRow: anObject on: html.	self		datesDo: [ :date | 			self				renderCellForDate: date				row: anObject				index: aNumber				on: html ]		separatedBy: [ self renderHeadingSpacerOn: html ]</body></methods><methods><class-id>Seaside.WADateTable</class-id> <category>enumerating</category><body package="Seaside-Widgets">datesDo: aBlock separatedBy: monthlyBlock	| month |	month := datesCache first monthIndex.	datesCache do: [ :date |		date monthIndex = month ifFalse: [ month := date monthIndex. monthlyBlock value ].		aBlock value: date ].	monthlyBlock value</body><body package="Seaside-Widgets">monthsAndLengthsDo: aTwoArgumentBlock	| count last |	count := 0.	last := nil.	self		datesDo: [ :each |			count := count + 1.			last := each ]		separatedBy: [			aTwoArgumentBlock value: last month value: count.			count := 0 ]</body></methods><methods><class-id>Seaside.WADateTable</class-id> <category>actions</category><body package="Seaside-Widgets">updateDatesCache	| date |	(startDate isNil or: [ endDate isNil ])		ifTrue: [ ^ self ].	datesCache := OrderedCollection new.	date := startDate.	[ date &gt; endDate ] whileFalse: [ 		datesCache add: date.		date := date next ]</body></methods><methods><class-id>Seaside.WASelectionDateTable</class-id> <category>private</category><body package="Seaside-Widgets">colorForDate: aDate rowIndex: aNumber	^ (self hasSelection and: [ self selectionContainsDate: aDate rowIndex: aNumber ])		ifTrue: [ 'lightgrey' ]		ifFalse: [ 'white' ]</body><body package="Seaside-Widgets">endDateSelection	^ dateSelectionStart isNil		ifFalse: [ dateSelectionStart max: dateSelectionEnd ]</body><body package="Seaside-Widgets">endRow	^ rowSelectionStart max: rowSelectionEnd</body><body package="Seaside-Widgets">endRowSelection	^ rowSelectionStart isNil		ifFalse: [ rows at: (rowSelectionStart max: rowSelectionEnd) ]</body><body package="Seaside-Widgets">rowsAndDatesDisplay: aBlock	cellBlock := aBlock</body><body package="Seaside-Widgets">selectDate: aDate rowIndex: rowIndex	self hasSelection		ifFalse: [ 			dateSelectionStart := dateSelectionEnd := aDate.			rowSelectionStart := rowSelectionEnd := rowIndex ]		ifTrue: [ 			dateSelectionEnd := aDate.			rowSelectionEnd := rowIndex ]</body><body package="Seaside-Widgets">selectedRows	^ rows copyFrom: self startRow to: self endRow</body><body package="Seaside-Widgets">selectionContainsDate: aDate rowIndex: aNumber	^ ((aDate between: dateSelectionStart and: dateSelectionEnd)		or: [ aDate between: dateSelectionEnd and: dateSelectionStart ])		and: [ 			(aNumber between: rowSelectionStart and: rowSelectionEnd)				or: [ aNumber between: rowSelectionEnd and: rowSelectionStart ] ]</body><body package="Seaside-Widgets">startDateSelection	^ dateSelectionStart isNil		ifFalse: [ dateSelectionStart min: dateSelectionEnd ]</body><body package="Seaside-Widgets">startRow	^ rowSelectionStart min: rowSelectionEnd</body><body package="Seaside-Widgets">startRowSelection	^ rowSelectionStart isNil		ifFalse: [ rows at: (rowSelectionStart min: rowSelectionEnd) ]</body></methods><methods><class-id>Seaside.WASelectionDateTable</class-id> <category>accessing</category><body package="Seaside-Widgets">endDate: aDate	self clearSelection.	super endDate: aDate</body><body package="Seaside-Widgets">rows: aCollection	self clearSelection.	super rows: aCollection</body><body package="Seaside-Widgets">startDate: aDate	self clearSelection.	super startDate: aDate</body></methods><methods><class-id>Seaside.WASelectionDateTable</class-id> <category>selecting</category><body package="Seaside-Widgets">clearSelection	dateSelectionStart := dateSelectionEnd := rowSelectionStart := rowSelectionEnd := nil</body></methods><methods><class-id>Seaside.WASelectionDateTable</class-id> <category>testing</category><body package="Seaside-Widgets">hasSelection	^ dateSelectionStart notNil</body></methods><methods><class-id>Seaside.WASelectionDateTable</class-id> <category>editor access</category><body package="Seaside-Widgets">selectAll	dateSelectionStart := startDate.	dateSelectionEnd := endDate.	rowSelectionStart := 1.	rowSelectionEnd := rows size</body></methods><methods><class-id>Seaside.WASelectionDateTable</class-id> <category>rendering</category><body package="Seaside-Widgets">renderCellForDate: aDate row: anObject index: aNumber on: html	html tableData		style: 'background-color: ', (self colorForDate: aDate rowIndex: aNumber);		align: 'center';		with: [			html anchor				callback: [ self selectDate: aDate rowIndex: aNumber ];				with: (cellBlock value: anObject value: aDate) ]</body></methods><methods><class-id>Seaside.WATimeSelector</class-id> <category>accessing</category><body package="Seaside-Widgets">date: aDate	second := aDate dayOfMonth.	hour := aDate monthIndex.	minute := aDate year</body><body package="Seaside-Widgets">days	^ 1 to: 31</body><body package="Seaside-Widgets">endHour	^ endHour</body><body package="Seaside-Widgets">endHour: anInteger	endHour := anInteger</body><body package="Seaside-Widgets">hour	^ hour</body><body package="Seaside-Widgets">hour: anObject	hour := anObject</body><body package="Seaside-Widgets">minute	^ minute</body><body package="Seaside-Widgets">minute: anObject	minute := anObject</body><body package="Seaside-Widgets">second	^ second</body><body package="Seaside-Widgets">second: anObject	second := anObject</body><body package="Seaside-Widgets">startHour	^ startHour</body><body package="Seaside-Widgets">startHour: anInteger	startHour := anInteger</body><body package="Seaside-Widgets">time	(self privateIsValidSecond: second hourNumber: hour minuteNumber: minute)		ifFalse: [ self error: 'Invalid time' ].	^ self timeClass hour: hour minute: minute second: second</body><body package="Seaside-Widgets">time: aTime	second := aTime second.	hour := aTime hour.	minute := aTime minute</body></methods><methods><class-id>Seaside.WATimeSelector</class-id> <category>private</category><body package="Seaside-Widgets">privateIsValidSecond: theSecond hourNumber: theHour minuteNumber: theMinute	^ (theHour between: 0 and: 23)		and: [ (theMinute between: 0 and: 59)		and: [ theSecond between: 0 and: 59 ] ]</body><body package="Seaside-Widgets">timeClass	^ Time</body></methods><methods><class-id>Seaside.WATimeSelector</class-id> <category>initialization</category><body package="Seaside-Widgets">initialize	super initialize.	startHour := 0.	endHour := 23.	self time: Time midnight</body></methods><methods><class-id>Seaside.WATimeSelector</class-id> <category>rendering</category><body package="Seaside-Widgets">renderContentOn: html	html select		list: (0 to: 23);		on: #hour of: self.	html select		list: (0 to: 59);		on: #minute of: self.	html select		list: (0 to: 59);		on: #second of: self.	self timeIsValid		ifFalse: [ self renderValidationErrorOn: html ]</body><body package="Seaside-Widgets">renderValidationErrorOn: html	html span		class: 'error';		with: 'invalid time'</body></methods><methods><class-id>Seaside.WATimeSelector</class-id> <category>testing</category><body package="Seaside-Widgets">timeIsValid	[ self time ] on: Error do: [ :e | ^ false ].	^ true</body></methods><methods><class-id>Seaside.WANavigationFiles</class-id> <category>accessing</category><body package="Seaside-Widgets">selectorsToInclude	^ #(mainCss)</body></methods><methods><class-id>Seaside.WANavigationFiles</class-id> <category>styles</category><body package="Seaside-Widgets">mainCss	^ ' /* this is from http://kalsey.com/tools/csstabs/ - would also be nice to do http://www.alistapart.com/articles/slidingdoors/ */.kalsey .navigation-options {	border-bottom : 1px solid #ccc;	margin : 0;	padding-bottom : 19px;	padding-left : 10px;}.kalsey .navigation-options ul, .kalsey .navigation-options li	{	display : inline;	list-style-type : none;	margin : 0;	padding : 0;}.kalsey .navigation-options a:link, .kalsey .navigation-options a:visited	{	background : #E8EBF0;	border : 1px solid #ccc;	color : #666;	float : left;	font-size : small;	font-weight : normal;	line-height : 14px;	margin-right : 8px;	padding : 2px 10px 2px 10px;	text-decoration : none;}.kalsey .navigation-options a:link.active, .kalsey .navigation-options a:visited.active	{	background : #fff;	border-bottom : 1px solid #fff;	color : #000;}.kalsey .navigation-options ul a:hover	{	color : #f00;}.kalsey .navigation-options .option-selected a {	background : #fff;	border-bottom : 1px solid #fff;	color : #000;}.kalsey .navigation-content {	background : #fff;	border : 1px solid #ccc;	border-top : none;	clear : both;	margin : 0px;	padding : 15px;	line-height: 1.1;  /* IE6 CSS workaround - http://www.dracos.co.uk/web/css/ie6floatbug/ */}/* customization */.kalsey .navigation-content tbody tr th, .kalsey .navigation-content tfoot tr th {	text-align: right;	vertical-align: top;}.kalsey .navigation-content h2 {	font-size: 1.2em;}.kalsey .navigation-content tbody.right tr td, .kalsey .navigation-content tfoot.right tr td {	text-align: right;}'</body></methods><methods><class-id>Seaside.WAValidationDecoration</class-id> <category>convenience</category><body package="Seaside-Widgets">validateWith: aBlock	validationBlock := aBlock</body></methods><methods><class-id>Seaside.WAValidationDecoration</class-id> <category>initialization</category><body package="Seaside-Widgets">initialize	super initialize.	message := WAValueHolder new</body></methods><methods><class-id>Seaside.WAValidationDecoration</class-id> <category>accessing</category><body package="Seaside-Widgets">exceptionClass	^ exceptionClass ifNil: [ exceptionClass := WAValidationNotification ]</body><body package="Seaside-Widgets">exceptionClass: aClass	exceptionClass := aClass</body></methods><methods><class-id>Seaside.WAValidationDecoration</class-id> <category>request processing</category><body package="Seaside-Widgets">validate: anObject	^ [ validationBlock value: anObject.	message contents: nil.	true ]		on: self exceptionClass		do: [ :exception |			message contents: exception messageText.			exception return: false ]</body></methods><methods><class-id>Seaside.WAValidationDecoration</class-id> <category>rendering</category><body package="Seaside-Widgets">renderContentOn: html	message contents isNil ifFalse: [		html div			class: 'validation-error';			with: message contents ].	self renderNextOn: html</body></methods><methods><class-id>Seaside.WAValidationDecoration</class-id> <category>delegation</category><body package="Seaside-Widgets">handleAnswer: anObject	^ (super handleAnswer: anObject) or: [ (self validate: anObject) not ]</body></methods><methods><class-id>Seaside.WAValidationDecoration</class-id> <category>processing</category><body package="Seaside-Widgets">handleAnswer: anObject continueWith: aBlock	(self validate: anObject)		ifTrue: [ aBlock value ]</body></methods><methods><class-id>Seaside.WAValidationDecoration</class-id> <category>hooks</category><body package="Seaside-Widgets">states	^ Array with: message</body></methods><methods><class-id>Seaside.WAPath</class-id> <category>initialization</category><body package="Seaside-Widgets">initialize	super initialize.	stack := #()</body></methods><methods><class-id>Seaside.WAPath</class-id> <category>behavior</category><body package="Seaside-Widgets">choose: anAssociation 	"Install a new stack of navigation from the old one and the specified association."	| newStack |	newStack := WriteStream on: Array new.	stack do: 		[ :ea | 		newStack nextPut: ea.		ea == anAssociation ifTrue: 			[ stack := newStack contents.			^ self ] ]</body><body package="Seaside-Widgets">pushSegment: anObject name: aString	stack := stack, (Array with: aString -&gt; anObject)</body></methods><methods><class-id>Seaside.WAPath</class-id> <category>accessing</category><body package="Seaside-Widgets">currentSegment	^ stack isEmpty		ifFalse: [ stack last value ]</body></methods><methods><class-id>Seaside.WAPath</class-id> <category>rendering</category><body package="Seaside-Widgets">renderContentOn: html	stack isEmpty 		ifTrue: [ ^ self ].	html div class: 'path'; with: [		stack allButLast do: [ :assoc |			html anchor 				callback: [ self choose: assoc ]; 				with: assoc key.			html text: ' &gt;&gt; ' ].		html strong: stack last key ]</body></methods><methods><class-id>Seaside.WAPath</class-id> <category>hooks</category><body package="Seaside-Widgets">states	^ Array with: self</body></methods><methods><class-id>Seaside.WAPath class</class-id> <category>example</category><body package="Seaside-Widgets">exampleComponent	^ self new		pushSegment: 123 name: 'xxx';		pushSegment: 456 name: 'yyy';		pushSegment: 789 name: 'zzz';		yourself</body></methods><methods><class-id>Seaside.WADelayedAnswerDecoration</class-id> <category>accessing</category><body package="Seaside-Widgets">delay	^ delay ifNil: [ 1 ]</body><body package="Seaside-Widgets">delay: aNumber	delay := aNumber</body></methods><methods><class-id>Seaside.WADelayedAnswerDecoration</class-id> <category>updating</category><body package="Seaside-Widgets">updateRoot: anHtmlRoot 	| url |	super updateRoot: anHtmlRoot.	url := anHtmlRoot context actionUrl withField:				(anHtmlRoot context callbacks store:					(WAActionCallback on: [ self decoratedComponent answer ])).	anHtmlRoot meta 		redirectAfter: self delay		to: url greaseString</body></methods><methods><class-id>Seaside.WABatchedList</class-id> <category>accessing-calculated</category><body package="Seaside-Widgets">batch	^ self items copyFrom: self startIndex to: self endIndex</body><body package="Seaside-Widgets">endIndex	^ self currentPage * self batchSize min: self items size</body><body package="Seaside-Widgets">maxPages	^ (self items size / self batchSize) ceiling</body><body package="Seaside-Widgets">pageRange	^ self pageRangeStart to: self pageRangeEnd</body><body package="Seaside-Widgets">pageRangeEnd	^ self maxPages min: self currentPage + 9</body><body package="Seaside-Widgets">pageRangeStart	^ 1 max: self currentPage - 9</body><body package="Seaside-Widgets">startIndex	^ (self currentPage - 1) * self batchSize + 1</body></methods><methods><class-id>Seaside.WABatchedList</class-id> <category>accessing</category><body package="Seaside-Widgets">batchSize	^ batchSize</body><body package="Seaside-Widgets">batchSize: aNumber	batchSize := aNumber</body><body package="Seaside-Widgets">currentPage	^ currentPage</body><body package="Seaside-Widgets">currentPage: aNumber	currentPage := aNumber</body><body package="Seaside-Widgets">items	^ items</body><body package="Seaside-Widgets">items: aCollection	items := aCollection</body></methods><methods><class-id>Seaside.WABatchedList</class-id> <category>testing</category><body package="Seaside-Widgets">hasMultiplePages	^ self maxPages &gt; 1</body><body package="Seaside-Widgets">isOnFirstPage	^ self currentPage = 1</body><body package="Seaside-Widgets">isOnLastPage	^ self currentPage = self maxPages</body></methods><methods><class-id>Seaside.WABatchedList</class-id> <category>rendering</category><body package="Seaside-Widgets">renderContentOn: html	self maxPages = 0		ifTrue: [ ^ self ].	html div		class: 'batch';		with: [			self renderPreviousOn: html.			self renderPagesOn: html.			self renderNextOn: html ]</body><body package="Seaside-Widgets">renderNextOn: html	html space.	self isOnLastPage		ifFalse: [ html anchor callback: [ self nextPage ]; with: '&gt;&gt;' ]		ifTrue: [ html text: '&gt;&gt;' ]</body><body package="Seaside-Widgets">renderPagesOn: html	self pageRange		do: [ :index |			self currentPage = index				ifFalse: [					html anchor						callback: [ self currentPage: index ];						with: index ]				ifTrue: [ html strong: index ] ]		separatedBy: [ html space ]</body><body package="Seaside-Widgets">renderPreviousOn: html	self isOnFirstPage		ifFalse: [ html anchor callback: [ self previousPage ]; with: '&lt;&lt;' ]		ifTrue: [ html text: '&lt;&lt;' ].	html space</body></methods><methods><class-id>Seaside.WABatchedList</class-id> <category>initialization</category><body package="Seaside-Widgets">initialize	super initialize.	self batchSize: 10.	self currentPage: 1</body></methods><methods><class-id>Seaside.WABatchedList</class-id> <category>actions</category><body package="Seaside-Widgets">nextPage	self isOnLastPage		ifFalse: [ self currentPage: self currentPage + 1 ]</body><body package="Seaside-Widgets">previousPage	self isOnFirstPage		ifFalse: [ self currentPage: self currentPage - 1 ]</body></methods><methods><class-id>Seaside.WABatchedList</class-id> <category>hooks</category><body package="Seaside-Widgets">states	^ Array with: self</body></methods><methods><class-id>Seaside.WABatchedList class</class-id> <category>accessing</category><body package="Seaside-Widgets">exampleComponent	^ self new		items: (1 to: 100);		yourself</body></methods><methods><class-id>Seaside.WABatchSelection</class-id> <category>accessing</category><body package="Seaside-Widgets">batchSize	^ batcher batchSize</body><body package="Seaside-Widgets">batchSize: aSize    batcher batchSize: aSize</body><body package="Seaside-Widgets">items: aCollection	batcher := WABatchedList new		items: aCollection;		batchSize: 8;		yourself</body><body package="Seaside-Widgets">linkSelector: aSymbol	linkSelector := aSymbol</body><body package="Seaside-Widgets">textSelector: aSymbol	textSelector := aSymbol</body></methods><methods><class-id>Seaside.WABatchSelection</class-id> <category>commands</category><body package="Seaside-Widgets">choose: anItem	self answer: anItem</body></methods><methods><class-id>Seaside.WABatchSelection</class-id> <category>rendering</category><body package="Seaside-Widgets">renderContentOn: html	html unorderedList: [		batcher batch do: [ :each |			html anchor				callback: [ self choose: each ];				with: (each perform: linkSelector).			html break.			html text: (each perform: textSelector).			html paragraph ] ].	html div		style: 'text-align: center';		with: batcher</body></methods><methods><class-id>Seaside.WABatchSelection</class-id> <category>hooks</category><body package="Seaside-Widgets">children	^ Array with: batcher</body></methods><methods><class-id>Seaside.WABatchSelection class</class-id> <category>instance creation</category><body package="Seaside-Widgets">items: aCollection link: linkSelector text: textSelector	^ self new		items: aCollection;		linkSelector: linkSelector;		textSelector: textSelector;		yourself</body></methods><methods><class-id>Seaside.WASelection</class-id> <category>accessing</category><body package="Seaside-Widgets">items	^ items</body><body package="Seaside-Widgets">items: aCollection	items := aCollection</body><body package="Seaside-Widgets">labelBlock	^ labelBlock</body><body package="Seaside-Widgets">labelBlock: aBlock	labelBlock := aBlock</body></methods><methods><class-id>Seaside.WASelection</class-id> <category>rendering</category><body package="Seaside-Widgets">renderContentOn: html	html unorderedList		list: self items;		labels: self labelBlock;		callback: [ :value | self answer: value ]</body></methods><methods><class-id>Seaside.WASelection</class-id> <category>initialization</category><body package="Seaside-Widgets">initialize	super initialize.	items := #().	labelBlock := [ :each | each greaseString ]</body></methods><methods><class-id>Seaside.WAChoiceDialog</class-id> <category>accessing</category><body package="Seaside-Widgets">buttons	^ #(ok cancel)</body><body package="Seaside-Widgets">options	^ options</body><body package="Seaside-Widgets">options: aCollection	options := aCollection</body><body package="Seaside-Widgets">selection	^ selection</body><body package="Seaside-Widgets">selection: anObject	selection := anObject</body></methods><methods><class-id>Seaside.WAChoiceDialog</class-id> <category>actions</category><body package="Seaside-Widgets">cancel	self answer: nil</body><body package="Seaside-Widgets">ok	self answer: self selection</body></methods><methods><class-id>Seaside.WAChoiceDialog</class-id> <category>rendering</category><body package="Seaside-Widgets">renderContentOn: html	html select		list: self options;		selected: self selection;		callback: [ :value | self selection: value ]</body></methods><methods><class-id>Seaside.WAChoiceDialog class</class-id> <category>instance creation</category><body package="Seaside-Widgets">options: aCollection	^ self options: aCollection selection: nil</body><body package="Seaside-Widgets">options: aCollection selection: anObject	^ self new		options: aCollection;		selection: anObject;		yourself</body></methods><methods><class-id>Seaside.WAChoiceDialog class</class-id> <category>examples</category><body package="Seaside-Widgets">exampleComponent	^ self options: #('Perl' 'Python' 'Ruby' 'Smalltalk') selection: 'Smalltalk'</body></methods><methods><class-id>Seaside.WAWindowDecoration</class-id> <category>testing</category><body package="Seaside-Widgets">isGlobal	^ true</body></methods><methods><class-id>Seaside.WAWindowDecoration</class-id> <category>rendering</category><body package="Seaside-Widgets">renderCloseButtonOn: html	html anchor		title: 'Close';		callback: [ self decoratedComponent answer: nil ];		with: [ html html: '&amp;times;' ]</body><body package="Seaside-Widgets">renderContentOn: html	html div class: 'window'; with: [		html div class: 'window-titlebar'; with: [			html div class: 'window-title'; class: cssClass; with: title.			html div class: 'window-close'; with: [ self renderCloseButtonOn: html ] ].		html div class: 'window-content'; with: [ self renderNextOn: html ] ]</body></methods><methods><class-id>Seaside.WAWindowDecoration</class-id> <category>accessing</category><body package="Seaside-Widgets">cssClass: aString	cssClass := aString</body><body package="Seaside-Widgets">title: aString	title := aString</body></methods><methods><class-id>Seaside.WAWindowDecoration class</class-id> <category>instance creation</category><body package="Seaside-Widgets">title: aTitle	^ self new		title: aTitle;		yourself</body></methods><methods><class-id>Seaside.WAMiniCalendar</class-id> <category>rendering</category><body package="Seaside-Widgets">renderCellForDate: aDate on: html	html tableData: [		(aDate monthIndex = self monthIndex and: [ aDate year = self year ])			ifTrue: [				html span					class: (self date = aDate ifTrue: [ 'calendarArchiveDate' ]);					with: [						(self canSelect: aDate) 							ifTrue: [								html anchor									callback: [ self select: aDate ];									with: aDate dayOfMonth ]							ifFalse: [ html text: aDate dayOfMonth ] ] ] ]</body><body package="Seaside-Widgets">renderContentOn: html	html div		class: 'calendar';		with: [			html div				class: 'calendarCaption';				with: [ self renderMonthHeadingOn: html ].			html table: [				html tableRow					class: 'calendarTitle';					with: [						self weekDays do: [ :each |							html tableData: each ] ].						self weeksDo: [ :week |							self renderRowForWeek: week on: html ] ].			self renderMonthNavigationOn: html.			html				space;				space.			self renderYearNavigationOn: html ]</body><body package="Seaside-Widgets">renderMonthHeadingOn: html	html form: [		html div: [			html select				list: (1 to: 12);				on: #monthIndex of: self;				labels: [ :index | Date nameOfMonth: index ].			html textInput				maxLength: 4;				on: #year of: self.			html submitButton text: 'Refresh' ] ]</body><body package="Seaside-Widgets">renderMonthNavigationOn: html	| tab |	tab := #(12 1 2 3 4 5 6 7 8 9 10 11 12 1).	html span		class: 'calendarPrevious';		with: [			html anchor				callback: [ self previousMonth ];				with: ((self monthNames at: (tab at: self monthIndex)) first: 3) ].	html space.	html span		class: 'calendarNext';		with: [			html anchor				callback: [ self nextMonth ];				with: ((self monthNames at: (tab at: self monthIndex + 2)) first: 3) ]</body><body package="Seaside-Widgets">renderRowForWeek: initialDay on: html	html tableRow: [		0 to: 6 do: [ :each |			self renderCellForDate: (initialDay addDays: each) on: html ] ]</body><body package="Seaside-Widgets">renderYearNavigationOn: html	html span		class: 'calendarPrevious';		with: [			html anchor				callback: [ self year: self year - 1 ];				with: self year - 1 ].	html space.	html span		class: 'calendarNext';		with: [			html anchor				callback: [ self year: self year + 1 ];				with: self year + 1 ]</body></methods><methods><class-id>Seaside.WAMiniCalendar</class-id> <category>accessing</category><body package="Seaside-Widgets">canSelectBlock: aBlock	canSelectBlock := aBlock</body><body package="Seaside-Widgets">selectBlock: aBlock	selectBlock := aBlock</body></methods><methods><class-id>Seaside.WAMiniCalendar</class-id> <category>accessing-delegated</category><body package="Seaside-Widgets">date	^ date contents</body><body package="Seaside-Widgets">date: aDate 	date contents: aDate.	monthIndex contents: aDate monthIndex.	year contents: aDate year</body><body package="Seaside-Widgets">monthIndex	^ monthIndex contents</body><body package="Seaside-Widgets">monthIndex: anInteger 	monthIndex contents: anInteger</body><body package="Seaside-Widgets">year	^ year contents</body><body package="Seaside-Widgets">year: anIntegerOrString 	year contents: (anIntegerOrString greaseInteger ifNil: [ 1900 ])</body></methods><methods><class-id>Seaside.WAMiniCalendar</class-id> <category>private</category><body package="Seaside-Widgets">monthHeading	^ self monthName , ' ' , self year greaseString</body><body package="Seaside-Widgets">monthName	^ Date nameOfMonth: self monthIndex</body><body package="Seaside-Widgets">weekDays	^ #(Sun Mon Tue Wed Thu Fri Sat)</body><body package="Seaside-Widgets">weeksDo: aBlock	| day nextMonth |	day := Date newDay: 1 month: (Date nameOfMonth: self monthIndex) year: self year.	day := day subtractDays: (day dayOfWeek - 1).	nextMonth := (self monthIndex \\ 12) + 1.	[ day monthIndex = nextMonth ] whileFalse: [		aBlock value: day.		day := day addDays: 7 ]</body></methods><methods><class-id>Seaside.WAMiniCalendar</class-id> <category>testing</category><body package="Seaside-Widgets">canSelect: aDate	^ canSelectBlock value: aDate</body></methods><methods><class-id>Seaside.WAMiniCalendar</class-id> <category>action</category><body package="Seaside-Widgets">nextMonth	self monthIndex = 12		ifTrue: [ self monthIndex: 1; year: self year + 1 ]		ifFalse: [ self monthIndex: self monthIndex + 1 ]</body><body package="Seaside-Widgets">previousMonth	self monthIndex = 1		ifTrue: [ self monthIndex: 12; year: self year - 1 ]		ifFalse: [ self monthIndex: self monthIndex - 1 ]</body><body package="Seaside-Widgets">select: aDate	self date: aDate.	selectBlock value: aDate</body></methods><methods><class-id>Seaside.WAMiniCalendar</class-id> <category>localization</category><body package="Seaside-Widgets">monthNames	^ (1 to: 12) collect: [ :each | Date nameOfMonth: each ]</body></methods><methods><class-id>Seaside.WAMiniCalendar</class-id> <category>initialization</category><body package="Seaside-Widgets">initialize	super initialize.	monthIndex := WAValueHolder with: Date today monthIndex.	year := WAValueHolder with: Date today year.	date := WAValueHolder new.	canSelectBlock := [ :value | true ].	selectBlock := [ :value | self answer: value ]</body></methods><methods><class-id>Seaside.WAMiniCalendar</class-id> <category>hooks</category><body package="Seaside-Widgets">states	^ Array with: date with: monthIndex with: year</body></methods><methods><class-id>Seaside.WAMiniCalendar class</class-id> <category>testing</category><body package="Seaside-Widgets">canBeRoot	^ true</body></methods><methods><class-id>Seaside.WAMiniCalendar class</class-id> <category>accessing</category><body package="Seaside-Widgets">exampleComponent	^ self new</body></methods><methods><class-id>Seaside.WANavigationBar</class-id> <category>rendering</category><body package="Seaside-Widgets">renderContentOn: html	self actions do: [ :symbol |		symbol numArgs = 0			ifTrue: [ self renderLink: symbol on: html ]			ifFalse: [ self renderInput: symbol on: html ] ]</body><body package="Seaside-Widgets">renderInput: aSymbol on: html	html form: [		html strong: aSymbol capitalized.		html space.		html textInput			callback: [ :value |				self target perform: aSymbol with: value ] ]</body><body package="Seaside-Widgets">renderLink: aSymbol on: html	html anchor		on: aSymbol of: self target.	html break</body></methods><methods><class-id>Seaside.WANavigationBar</class-id> <category>accessing</category><body package="Seaside-Widgets">actions	^ self target perform: actionsSelector</body><body package="Seaside-Widgets">actionsSelector: aSymbol	actionsSelector := aSymbol</body><body package="Seaside-Widgets">owner: anObject	owner := anObject</body><body package="Seaside-Widgets">target	^ owner activeComponent</body></methods><methods><class-id>Seaside.WANavigationBar</class-id> <category>initialization</category><body package="Seaside-Widgets">initialize	super initialize.	actionsSelector := #actions</body></methods><methods><class-id>Seaside.WAInputDialog</class-id> <category>accessing</category><body package="Seaside-Widgets">default: aString	value := aString</body><body package="Seaside-Widgets">label	^ label ifNil: [ label := 'OK' ]</body><body package="Seaside-Widgets">label: aString	label := aString</body><body package="Seaside-Widgets">value	^ value</body><body package="Seaside-Widgets">value: aString	value := aString</body></methods><methods><class-id>Seaside.WAInputDialog</class-id> <category>rendering</category><body package="Seaside-Widgets">renderContentOn: html	html form		defaultAction: [ self answer: value ];		with: [			html div: [				html textInput on: #value of: self.				html space.				html submitButton					callback: [ self answer: value ];					text: self label ] ]</body></methods><methods><class-id>Seaside.WALabelledFormDialog</class-id> <category>rendering</category><body package="Seaside-Widgets">renderDefaultFieldForSelector: aSymbol on: html	html textInput		on: aSymbol of: self model</body><body package="Seaside-Widgets">renderDialogOn: html	self rows do: [ :ea | 		ea = #-			ifTrue: [ self renderSpacerRowOn: html ]			ifFalse: [ self renderRowForSelector: ea on: html ] ]</body><body package="Seaside-Widgets">renderFieldForSelector: aSymbol on: html	| renderSelector |	renderSelector := self renderingSelectorFor: aSymbol.	(self respondsTo: renderSelector)		ifTrue: [ self perform: renderSelector with: html ]		ifFalse: [ self renderDefaultFieldForSelector: aSymbol on: html ]</body><body package="Seaside-Widgets">renderLabelForSelector: aSymbol on: html	html text: (self labelForSelector: aSymbol)</body><body package="Seaside-Widgets">renderRowForSelector: aSymbol on: html	html div		id: 'dialog-row-' , aSymbol;		class: 'dialog-row';		with: [			html span				class: 'dialog-form-label';				with: [ self renderLabelForSelector: aSymbol on: html ].			html span				class: 'dialog-form-field';				with: [ self renderFieldForSelector: aSymbol on: html ] ]</body><body package="Seaside-Widgets">renderTableRowsOn: html	self rows do: [ :ea | 		ea = #-			ifTrue: [ self renderSpacerRowOn: html ]			ifFalse: [ self renderRowForSelector: ea on: html ] ]</body><body package="Seaside-Widgets">renderingSelectorFor: aSymbol	^ ('render', aSymbol capitalized, 'On:') asSymbol</body></methods><methods><class-id>Seaside.WALabelledFormDialog</class-id> <category>accessing</category><body package="Seaside-Widgets">rows	^ #()</body></methods><methods><class-id>Seaside.WALabelledFormDialog</class-id> <category>hooks</category><body package="Seaside-Widgets">style	^ '.dialog-row {	clear: both;	/*set position: relative to handle the ie disappearing text bug*/	position: relative;	margin-top: 3px;}.dialog-form-label {	width: 100px;	float: left;	text-align: right;	padding: 2px 6px;	margin-right: 4px;	margin-top: 2px;}.dialog-form-field {	text-align: left;	padding: 2px;	margin-top: 2px;	float: left;}.dialog-buttons {	clear: both;	padding: 10px;	text-align: center}.dialog-spacer {	clear: both;	height: 10px;}	'</body></methods><methods><class-id>Seaside.WAFormDecoration</class-id> <category>accessing</category><body package="Seaside-Widgets">buttons	^ buttons</body><body package="Seaside-Widgets">buttons: selectorArray	buttons := selectorArray</body></methods><methods><class-id>Seaside.WAFormDecoration</class-id> <category>rendering</category><body package="Seaside-Widgets">renderButtonForSelector: aSymbol on: html	html submitButton on: aSymbol of: self decoratedComponent</body><body package="Seaside-Widgets">renderButtonsOn: html	html div class: 'dialog-buttons'; with: [		self buttons do: [ :each |			html  span				class: 'dialog-button-', each;				with: [ self renderButtonForSelector: each on: html ] ] ]</body><body package="Seaside-Widgets">renderContentOn: html	html form		defaultAction: [ self defaultAction ];		with: [			html div: [				self renderNextOn: html.				self renderButtonsOn: html ] ]</body></methods><methods><class-id>Seaside.WAFormDecoration</class-id> <category>actions</category><body package="Seaside-Widgets">defaultAction	self decoratedComponent perform: self decoratedComponent defaultButton</body></methods><methods><class-id>Seaside.WAComponent</class-id> <category>*seaside-widgets-decorations</category><body package="Seaside-Widgets">addMessage: aString	"Add a decoration that displays a level 3 heading with aString around the receiver. Answer the decoration, so don't forget #yourself."		^ self addDecoration: (WAMessageDecoration new message: aString; yourself)</body></methods><methods><class-id>Seaside.WAComponent</class-id> <category>*seaside-widgets-dialogs</category><body package="Seaside-Widgets">chooseFrom: aCollection caption: aString onAnswer: aBlock	"Choose an item from the given aCollection with caption aString. Evaluate aBlock with the selected item."		self chooseFrom: aCollection default: nil caption: aString onAnswer: aBlock</body><body package="Seaside-Widgets">chooseFrom: aCollection default: anObject caption: aString onAnswer: aBlock	"Choose an item from the given aCollection, the default anObject and the caption aString. Evaluate aBlock with the selected item."		self 		call: (WAChoiceDialog new			addMessage: aString;			options: aCollection;			selection: anObject;			yourself)		onAnswer: aBlock</body><body package="Seaside-Widgets">chooseFrom: aCollection default: anObject onAnswer: aBlock	"Choose an item from the given aCollection and the default anObject. Evaluate aBlock with the selected item."		self chooseFrom: aCollection default: anObject caption: nil onAnswer: aBlock</body><body package="Seaside-Widgets">chooseFrom: aCollection onAnswer: aBlock	"Choose an item from the given aCollection. Evaluate aBlock with the selected item."	self chooseFrom: aCollection default: nil caption: nil onAnswer: aBlock</body><body package="Seaside-Widgets">confirm: aString onAnswer: aBlock	"Display a yes/no dialog with caption aString. Evaluate aBlock passing in true if the response is yes, false if no."	self		call: (WAYesOrNoDialog new			addMessage: aString;			yourself)		onAnswer: aBlock</body><body package="Seaside-Widgets">inform: aString	onAnswer: aBlock		"Display a dialog with aString to the user until he clicks the ok button. Continue by evaluating aBlock."	self 		call: (WAFormDialog new			addMessage: aString;			yourself)		onAnswer: aBlock</body><body package="Seaside-Widgets">request: aRequestString default: aDefaultString onAnswer: aBlock	"Display an input dialog with the question aRequestString and the default string aDefaultString. Passes the answer into aBlock."	self request: aRequestString label: nil default: aDefaultString onAnswer: aBlock</body><body package="Seaside-Widgets">request: aRequestString label: aLabelString default: aDefaultString onAnswer: aBlock	"Display an input dialog with the question aRequestString, the button label aLabelString and the default string aDefaultString. Passes the answer into aBlock."		self		call: (WAInputDialog new			addMessage: aRequestString;			default: aDefaultString;			label: aLabelString;			yourself)		onAnswer: aBlock</body><body package="Seaside-Widgets">request: aRequestString label: aLabelString onAnswer: aBlock	"Display an input dialog with the question aRequestString and the button label aLabelString. Passes the answer into aBlock."	self request: aRequestString label: aLabelString default: nil onAnswer: aBlock</body><body package="Seaside-Widgets">request: aString onAnswer: aBlock	"Display an input dialog with the question aRequestString. Passes the answer into aBlock."	self request: aString default: nil onAnswer: aBlock</body></methods><methods><class-id>Seaside.WAComponent</class-id> <category>*seaside-widgets-decorations</category><body package="Seaside-Widgets">validateWith: aBlock	^ self addDecoration: (WAValidationDecoration new validateWith: aBlock)</body></methods><methods><class-id>Grease.GRPackage class</class-id> <category>*seaside-widgets</category><body package="Seaside-Widgets">seasideWidgets	^ self new		name: 'Seaside-Widgets';		description: 'Various sample Decorations and Components that require Canvas.';		addDependency: 'Seaside-Canvas';		addDependency: 'Seaside-Component';		url: #seasideUrl;		yourself</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>WAObject</name><environment>Seaside</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAComponent</name><environment>Seaside</environment><super>Seaside.WAPresenter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>decoration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Component</category><attributes><package>Seaside-Component</package></attributes></class><class><name>WANotification</name><environment>Seaside</environment><super>Grease.GRNotification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Exceptions</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WADecoration</name><environment>Seaside</environment><super>Seaside.WAPresenter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>next </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Component</category><attributes><package>Seaside-Component</package></attributes></class><class><name>WAFileLibrary</name><environment>Seaside</environment><super>Seaside.WAAbstractFileLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Libraries</category><attributes><package>Seaside-Core</package></attributes></class></st-source>