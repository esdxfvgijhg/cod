<?xml version="1.0"?><st-source><!-- Name: Seaside-Tests-REST-CoreComment: Unit tests for the package Seaside-REST-Core.DbIdentifier: bear73DbTrace: 494122DbUsername: jkottDbVersion: 3.2.0 - jok.33 2DevelopmentPrerequisites: #(#(#any 'Seaside-Namespace' '') #(#any 'Seaside-REST-Core' '') #(#any 'Seaside-VisualWorks-REST-Core' '') #(#any 'Seaside-Tests-Core' ''))Id: fb67cbfb-eb2d-1d41-a1ce-0174f4b30db7Namespace: SeasidePackageName: Seaside-Tests-REST-CoreParcel: #('Seaside-Tests-REST-Core')ParcelName: Seaside-Tests-REST-CorePrerequisiteDescriptions: #(#(#name 'Seaside-Namespace') #(#name 'Seaside-REST-Core') #(#name 'Seaside-VisualWorks-REST-Core' #componentType #package) #(#name 'Seaside-Tests-Core' #componentType #package))PrerequisiteParcels: #(#('Seaside-Namespace' '') #('Seaside-REST-Core' '') #('Seaside-VisualWorks-REST-Core' '') #('Seaside-Tests-Core' ''))PrintStringCache: (3.2.0 - jok.33 2,jkott)Url: http://smalltalkhub.com/mc/Seaside/Seaside32/main/Seaside-Tests-REST-Core-jok.33.mczVersion: 3.2.0 - jok.33 2Date: 12:17:57 PM September 16, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (sep16.3) of September 16, 2016 on September 16, 2016 at 12:17:57 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WAMimeTypeStubHandler</name><environment>Seaside</environment><super>Seaside.WARestfulHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WASubMimeTypeMatchTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>match </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WAStreamTypeHandler</name><environment>Seaside</environment><super>Seaside.WARestfulHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WAByMethodRoutesTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>routes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WARestfulHandlerTest</name><environment>Seaside</environment><super>Seaside.WAContextTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WARouteVictimMock</name><environment>Seaside</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WACompositeMimeTypeMatchTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>match </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WAPragmaStubHandler</name><environment>Seaside</environment><super>Seaside.WARestfulHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WAWildcardMimeTypeMatchTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>match </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WASimpleRouteTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WAFullMimeTypeMatchTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>match </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WAPlaceholderParameterTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WAStubFilter</name><environment>Seaside</environment><super>Seaside.WARestfulFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WAAcceptsMatchTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WAExactParameterMatchTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WAByMethodRoutesStub</name><environment>Seaside</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WAMainMimeTypeMatchTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>match </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WAStreamTypeHandlerTest</name><environment>Seaside</environment><super>Seaside.WAContextTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WAComplexRouteTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WAPragmaBasedRestfulHandlerTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WAPlaceholderPathMatchTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WAMimeTypeMatchTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WAStubHandler</name><environment>Seaside</environment><super>Seaside.WARestfulHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WARouteTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WAOrPathMatchTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WAMimeTypeStubHandlerTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WAExactPathMatchTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><class><name>WARestfulFilterTest</name><environment>Seaside</environment><super>Seaside.WAContextTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-REST-Core</category><attributes><package>Seaside-Tests-REST-Core</package></attributes></class><methods><class-id>Seaside.WASubMimeTypeMatchTest</class-id> <category>tests</category><body package="Seaside-Tests-REST-Core">testMatches	self assert: (match matches: (WAMimeType main: 'application' sub: 'xml')).	self assert: (match matches: (WAMimeType main: 'something' sub: 'xml')).	self deny: (match matches: (WAMimeType main: 'application' sub: 'something')).	self deny: (match matches: (WAMimeType main: 'something' sub: 'something')).		self assert: (match matches: (WAMimeType main: '*' sub: 'xml')).	self assert: (match matches: (WAMimeType main: 'application' sub: '*')).	self assert: (match matches: (WAMimeType main: '*' sub: '*')).		self assert: (match matches: (WAMimeType main: 'something' sub: '*')).	self deny: (match matches: (WAMimeType main: '*' sub: 'something'))</body><body package="Seaside-Tests-REST-Core">testPriority	self assert: match priority = 2</body></methods><methods><class-id>Seaside.WASubMimeTypeMatchTest</class-id> <category>running</category><body package="Seaside-Tests-REST-Core">setUp	match := WASubMimeTypeMatch sub: 'xml'</body></methods><methods><class-id>Seaside.WAByMethodRoutesTest</class-id> <category>tests</category><body package="Seaside-Tests-REST-Core">testArgumentNamesOf	self assert: (GRPlatform current argumentNamesOf: (WAByMethodRoutesStub compiledMethodAt: #deleteDocument:inDatabase:)) asSet = #('aFirstString' 'aSecondString') asSet</body><body package="Seaside-Tests-REST-Core">testCompactDatabase	self		assertMethod: 'POST'		selector: #compactDatabase:		path: #('credit_cards' '_compact')		arguments: #('credit_cards')</body><body package="Seaside-Tests-REST-Core">testCreateBulkDocumentsInDatabase	self		assertMethod: 'POST'		selector: #createBulkDocumentsInDatabase:		path: #('credit_cards' '_bulk_docs')		arguments: #('credit_cards')</body><body package="Seaside-Tests-REST-Core">testCreateDatabase	self		assertMethod: 'PUT'		selector: #createDatabase:		path: #('credit_cards')		arguments: #('credit_cards')</body><body package="Seaside-Tests-REST-Core">testCreateNewDocumentInDatabase	self		assertMethod: 'POST'		selector: #createNewDocumentInDatabase:		path: #('credit_cards')		arguments: #('credit_cards')</body><body package="Seaside-Tests-REST-Core">testCreateOrUpdateDocumentinDatabase	self		assertMethod: 'PUT'		selector: #createOrUpdateDocument:inDatabase:		path: #('credit_cards' '1111-2222-3333-4444')		arguments: #('1111-2222-3333-4444' 'credit_cards')</body><body package="Seaside-Tests-REST-Core">testDeleteDatabase	self		assertMethod: 'DELETE'		selector: #deleteDatabase:		path: #('credit_cards')		arguments: #('credit_cards')</body><body package="Seaside-Tests-REST-Core">testDeleteDocumentInDatabase	self		assertMethod: 'DELETE'		selector: #deleteDocument:inDatabase:		path: #('credit_cards' '1111-2222-3333-4444')		arguments: #('1111-2222-3333-4444' 'credit_cards')</body><body package="Seaside-Tests-REST-Core">testGetAllDatabases	self		assertMethod: 'GET'		selector: #getAllDatabases		path: #('_all_dbs')		arguments: #()</body><body package="Seaside-Tests-REST-Core">testGetConfig	self		assertMethod: 'GET'		selector: #getConfig		path: #('_config')		arguments: #()</body><body package="Seaside-Tests-REST-Core">testGetDatabase	self		assertMethod: 'GET'		selector: #getDatabase:		path: #('credit_cards')		arguments: #('credit_cards')</body><body package="Seaside-Tests-REST-Core">testGetDocumentOfDatabase	self		assertMethod: 'GET'		selector: #getDocument:ofDatabase:		path: #('credit_cards' '1111-2222-3333-4444')		arguments: #('1111-2222-3333-4444' 'credit_cards')</body><body package="Seaside-Tests-REST-Core">testGetInfo	self		assertMethod: 'GET'		selector: #getInfo		path: #()		arguments: #()</body><body package="Seaside-Tests-REST-Core">testGetStats	self		assertMethod: 'GET'		selector: #getStats		path: #('_stats')		arguments: #()</body><body package="Seaside-Tests-REST-Core">testGetUuids	self		assertMethod: 'GET'		selector: #getUuids:		path: #('_uuids')		parameters: (Dictionary new			at: 'count' put: '100';			yourself)		arguments: #('100')</body><body package="Seaside-Tests-REST-Core">testGetViewInDesignInDatabase	self		assertMethod: 'GET'		selector: #getView:inDesign:inDatabase:		path: #('credit_cards' '_design' 'fraud' '_view' 'recent')		arguments: #('recent' 'fraud' 'credit_cards')</body><body package="Seaside-Tests-REST-Core">testPathUnconsumedWhenNotFound	| requestUrl request context notFound |	requestUrl := WAUrl new		addAllToPath: #('I' 'can' 'not' 'be' 'found');		yourself.	request := WARequest		method: 'GET'		uri: requestUrl.	context := WARequestContext request: request response: WAResponse new.	notFound := false.	routes routeForContext: context consume: true ifAbsent: [ notFound := true ].	self assert: notFound.	self deny: context consumer atEnd.	self assert: context consumer upToEnd = #('I' 'can' 'not' 'be' 'found') asOrderedCollection</body><body package="Seaside-Tests-REST-Core">testQueryDatabase	self		assertMethod: 'POST'		selector: #queryDatabase:		path: #('credit_cards' '_temp_view')		arguments: #('credit_cards')</body><body package="Seaside-Tests-REST-Core">testReplicate	self		assertMethod: 'POST'		selector: #replicate		path: #('_replicate')		arguments: #()</body></methods><methods><class-id>Seaside.WAByMethodRoutesTest</class-id> <category>private</category><body package="Seaside-Tests-REST-Core">assertMethod: aMethodString selector: aSymbol path: aFirstCollectionOfStrings arguments: aSecondCollectionOfStrings	self		assertMethod: aMethodString		selector: aSymbol		path: aFirstCollectionOfStrings		parameters: Dictionary new		arguments: aSecondCollectionOfStrings</body><body package="Seaside-Tests-REST-Core">assertMethod: aMethodString selector: aSymbol path: aFirstCollectionOfStrings parameters: aDictionary arguments: aSecondCollectionOfStrings	| result stub requestUrl request context |	requestUrl := WAUrl new		addAllToPath: aFirstCollectionOfStrings;		queryFields: aDictionary;		yourself.	request := WARequest		method: aMethodString		uri: requestUrl.	context := WARequestContext request: request response: WAResponse new.	result := routes routeForContext: context consume: true ifAbsent: [ self assert: false ].	stub := WAByMethodRoutesStub new.	result sendMessageTo: stub.	self assert: stub selector = aSymbol.	self assert: stub arguments = aSecondCollectionOfStrings.	self assert: context consumer atEnd</body><body package="Seaside-Tests-REST-Core">routes	^ OrderedCollection new		"Meta"		add: (WARoute get: #getInfo);		add: (WARoute get: '/_all_dbs' selector: #getAllDatabases);		add: (WARoute get: '/_config' selector: #getConfig);		add: (WARoute get: '/_stats' selector: #getStats);		add: (WARoute get: '/_uuids?count={1}' selector: #getUuids:);		add: (WARoute post: '/_replicate' selector: #replicate);				"Database"		add: (WARoute post: '/{1}/_compact' selector: #compactDatabase:);		add: (WARoute put: #createDatabase:);		add: (WARoute delete: #deleteDatabase:);		add: (WARoute get: #getDatabase:);				"Documents"		add: (WARoute get: '/{1}/_all_docs' selector: #getAllDocuments:);		add: (WARoute get: '/{2}/{1}' selector: #getDocument:ofDatabase:);		add: (WARoute post: #createNewDocumentInDatabase:);		add: (WARoute put: '/{2}/{1}' selector: #createOrUpdateDocument:inDatabase:);		add: (WARoute delete: '/{2}/{1}' selector: #deleteDocument:inDatabase:);		add: (WARoute post: '/{1}/_bulk_docs' selector: #createBulkDocumentsInDatabase:);		add: (WARoute post: '/{1}/_temp_view' selector: #queryDatabase:);		add: (WARoute get: '/{3}/_design/{2}/_view/{1}' selector: #getView:inDesign:inDatabase:);		yourself</body></methods><methods><class-id>Seaside.WAByMethodRoutesTest</class-id> <category>running</category><body package="Seaside-Tests-REST-Core">setUp	super setUp.	routes := WAByMethodRoutes routes: self routes</body></methods><methods><class-id>Seaside.WARestfulHandlerTest</class-id> <category>running</category><body package="Seaside-Tests-REST-Core">setUp	super setUp.	handler := WAStubHandler new</body></methods><methods><class-id>Seaside.WARestfulHandlerTest</class-id> <category>tests</category><body package="Seaside-Tests-REST-Core">testFindRouteForMethodConsumerIfAbsent	| route result requestUrl request context |	requestUrl := WAUrl new		addAllToPath: #('users' 'marschall');		yourself.	request := WARequest		method: 'GET'		uri: requestUrl.	context := WARequestContext request: request response: WAResponse new.	result := handler routeForContext: context ifAbsent: [ self assert: false ].	route := result route.	self assert: route method = 'GET'.	self assert: route pathElementCount = 2.	self assert: route selector = #getDatabase:document:.	self assert: result elements = #('users' 'marschall').	self assert: context consumer atEnd</body></methods><methods><class-id>Seaside.WARouteVictimMock</class-id> <category>accessing</category><body package="Seaside-Tests-REST-Core">first: anObject	^ Array with: anObject</body><body package="Seaside-Tests-REST-Core">first: anFirstObject second: aSecondObject	^ Array with: anFirstObject with: aSecondObject</body><body package="Seaside-Tests-REST-Core">first: anFirstObject second: aSecondObject third: aThirdObject	^ Array with: anFirstObject with: aSecondObject with: aThirdObject</body><body package="Seaside-Tests-REST-Core">nothing	^ Array new</body></methods><methods><class-id>Seaside.WACompositeMimeTypeMatchTest</class-id> <category>tests</category><body package="Seaside-Tests-REST-Core">testMatches	self assert: (match matches: (WAMimeType fromString: 'text/plain')).	self deny: (match matches: (WAMimeType fromString: 'application/json'))</body><body package="Seaside-Tests-REST-Core">testPriorityFor	match := WACompositeMimeTypeMatch matches: (Array		with: (WAMimeTypeMatch fromString: 'application/*')		with: (WAMimeTypeMatch fromString: '*/*')).	self assert: (match priorityFor: (WAMimeType fromString: 'application/json')) = 2</body></methods><methods><class-id>Seaside.WACompositeMimeTypeMatchTest</class-id> <category>running</category><body package="Seaside-Tests-REST-Core">setUp	match := WACompositeMimeTypeMatch matches: (Array with:		(WAMimeTypeMatch fromString: 'text/*'))</body></methods><methods><class-id>Seaside.WAWildcardMimeTypeMatchTest</class-id> <category>tests</category><body package="Seaside-Tests-REST-Core">testMatches	self assert: (match matches: (WAMimeType main: 'application' sub: 'xml')).	self assert: (match matches: (WAMimeType main: 'something' sub: 'xml')).	self assert: (match matches: (WAMimeType main: 'application' sub: 'something')).	self assert: (match matches: (WAMimeType main: 'something' sub: 'something')).		self assert: (match matches: (WAMimeType main: '*' sub: 'xml')).	self assert: (match matches: (WAMimeType main: 'application' sub: '*')).	self assert: (match matches: (WAMimeType main: '*' sub: '*'))</body><body package="Seaside-Tests-REST-Core">testPriority	self assert: match priority = 1</body></methods><methods><class-id>Seaside.WAWildcardMimeTypeMatchTest</class-id> <category>running</category><body package="Seaside-Tests-REST-Core">setUp	match := WAWildcardMimeTypeMatch new</body></methods><methods><class-id>Seaside.WASimpleRouteTest</class-id> <category>tests</category><body package="Seaside-Tests-REST-Core">testParameterMatching	| route parameters |	route := WARoute get: #a:.	self assert: (route matchesParameters: Dictionary new).	parameters := Dictionary new at: 'key' put: 'value'; yourself.	self deny: (route matchesParameters: parameters)</body><body package="Seaside-Tests-REST-Core">testPathMatching	| route |	route := WARoute get: #a:.	self deny: (route matchesPath: Array new).	self assert: (route matchesPath: #('something')).	self deny: (route matchesPath: #('something' 'else')).	self assert: (route priority = 1).		route := WARoute get: #a:b:.	self deny: (route matchesPath: Array new).	self deny: (route matchesPath: #('something')).	self assert: (route matchesPath: #('something' 'else')).	self deny: (route matchesPath: #('something' 'else' 'more')).	self assert: (route priority = 2)</body></methods><methods><class-id>Seaside.WAFullMimeTypeMatchTest</class-id> <category>tests</category><body package="Seaside-Tests-REST-Core">testMatches	self assert: (match matches: (WAMimeType main: 'application' sub: 'xml')).	self deny: (match matches: (WAMimeType main: 'something' sub: 'xml')).	self deny: (match matches: (WAMimeType main: 'application' sub: 'something')).	self deny: (match matches: (WAMimeType main: 'something' sub: 'something')).		self assert: (match matches: (WAMimeType main: '*' sub: 'xml')).	self assert: (match matches: (WAMimeType main: 'application' sub: '*')).	self assert: (match matches: (WAMimeType main: '*' sub: '*')).		self deny: (match matches: (WAMimeType main: 'something' sub: '*')).	self deny: (match matches: (WAMimeType main: '*' sub: 'something'))</body><body package="Seaside-Tests-REST-Core">testPriority	self assert: match priority = 3</body></methods><methods><class-id>Seaside.WAFullMimeTypeMatchTest</class-id> <category>running</category><body package="Seaside-Tests-REST-Core">setUp	match := WAFullMimeTypeMatch main: 'application' sub: 'xml'</body></methods><methods><class-id>Seaside.WAPlaceholderParameterTest</class-id> <category>tests</category><body package="Seaside-Tests-REST-Core">testInstantiation	| match |	match := WAParameterMatch name: 'rev' value: '{1}' arguments: #().	self assert: (match isKindOf: WAPlaceholderParameterMatch).	self assert: match index = 1</body><body package="Seaside-Tests-REST-Core">testMatches	| match |	match := WAParameterMatch name: 'rev' value: '{1}' arguments: #().	self assert: (match matchesName: 'rev' value: '58692').	self assert: (match matchesName: 'rev' value: 'a').	self deny: (match matchesName: 'revision' value: '58692')</body><body package="Seaside-Tests-REST-Core">testNamedInstantiation	| match |	match := WAParameterMatch name: 'rev' value: '{put}' arguments: #('post' 'put' 'get').	self assert: (match isKindOf: WAPlaceholderParameterMatch).	self assert: match index = 2</body></methods><methods><class-id>Seaside.WAStubFilter</class-id> <category>private</category><body package="Seaside-Tests-REST-Core">createRoutes	^ OrderedCollection new		"GET"		add: (WARoute get: #listDatabases);		add: (WARoute post: #createDatabase:);		add: (WARoute post: #createDatabase:document:);		add: (WARoute get: #getDatabase:document:);		add: (WARoute delete: #deleteDatabase:document:);		yourself</body></methods><methods><class-id>Seaside.WAAcceptsMatchTest</class-id> <category>tests</category><body package="Seaside-Tests-REST-Core">testAcceptsConflict	| pathElement routeXml routeJson acceptTextJS acceptAppJson acceptAll accepts routeContainer matchedRoute |	pathElement := 'dontcare'.	routeXml := WAComplexRoute		method: 'GET'		selector: #dontCare		url: (WAUrl absolute: pathElement)		arguments: #()		produces: (WAFullMimeTypeMatch main: 'text' sub: 'xml')		consumes: WAWildcardMimeTypeMatch new.			routeJson := WAComplexRoute		method: 'GET'		selector: #dontCare		url: (WAUrl absolute: pathElement)		arguments: #()		produces: (WAFullMimeTypeMatch main: 'application' sub: 'json')		consumes: WAWildcardMimeTypeMatch new.		acceptTextJS := WAAccept value: (WAMimeType main: 'text' sub: 'xml') quality: 0.5.	acceptAppJson := WAAccept value: WAMimeType applicationJson quality: 0.5.	acceptAll := WAAccept value: (WAMimeType main: '*' sub: '*') quality: 0.01.	"this will sort:  acceptTextJS, acceptAppJson, acceptAll"		accepts := Array with: acceptAll with: acceptAppJson with: acceptTextJS.	routeContainer := WARouteContainer routes: (Array with: routeXml with: routeJson).		matchedRoute := routeContainer		routeForElements: (Array with: pathElement)		parameters: WARequestFields new		contentType: nil		accept: accepts		ifAbsent: [ nil ].		self assert: matchedRoute isNil</body><body package="Seaside-Tests-REST-Core">testAcceptsMatch	| pathElement routeXml routeJson acceptTextJS acceptAppJson acceptAll accepts routeContainer matchedRoute |	pathElement := 'dontcare'.	routeXml := WAComplexRoute		method: 'GET'		selector: #dontCare		url: (WAUrl absolute: pathElement)		arguments: #()		produces: (WASubMimeTypeMatch sub: 'xml')		consumes: WAWildcardMimeTypeMatch new.			routeJson := WAComplexRoute		method: 'GET'		selector: #dontCare		url: (WAUrl absolute: pathElement)		arguments: #()		produces: (WAFullMimeTypeMatch main: 'application' sub: 'json')		consumes: WAWildcardMimeTypeMatch new.		acceptTextJS := WAAccept value: WAMimeType textJavascript quality: 1.0.	acceptAppJson := WAAccept value: WAMimeType applicationJson quality: 1.0.	acceptAll := WAAccept value: (WAMimeType main: '*' sub: '*') quality: 0.01.	"this will sort:  acceptTextJS, acceptAppJson, acceptAll"		accepts := Array with: acceptAll with: acceptAppJson with: acceptTextJS.	routeContainer := WARouteContainer routes: (Array with: routeXml with: routeJson).		matchedRoute := routeContainer		routeForElements: (Array with: pathElement)		parameters: WARequestFields new		contentType: nil		accept: accepts		ifAbsent: [ nil ].		self assert: matchedRoute = routeJson</body><body package="Seaside-Tests-REST-Core">testAcceptsQuality	| pathElement routeXml routeJson acceptTextJS acceptAppJson acceptAll accepts routeContainer matchedRoute |	pathElement := 'dontcare'.	routeXml := WAComplexRoute		method: 'GET'		selector: #dontCare		url: (WAUrl absolute: pathElement)		arguments: #()		produces: (WASubMimeTypeMatch sub: 'xml')		consumes: WAWildcardMimeTypeMatch new.			routeJson := WAComplexRoute		method: 'GET'		selector: #dontCare		url: (WAUrl absolute: pathElement)		arguments: #()		produces: (WAFullMimeTypeMatch main: 'application' sub: 'json')		consumes: WAWildcardMimeTypeMatch new.		acceptTextJS := WAAccept value: (WAMimeType main: 'text' sub: 'xml') quality: 1.0.	acceptAppJson := WAAccept value: WAMimeType applicationJson quality: 0.5.	acceptAll := WAAccept value: (WAMimeType main: '*' sub: '*') quality: 0.01.	"this will sort:  acceptTextJS, acceptAppJson, acceptAll"		accepts := Array with: acceptAll with: acceptAppJson with: acceptTextJS.	routeContainer := WARouteContainer routes: (Array with: routeXml with: routeJson).		matchedRoute := routeContainer		routeForElements: (Array with: pathElement)		parameters: WARequestFields new		contentType: nil		accept: accepts		ifAbsent: [ nil ].		self assert: matchedRoute = routeXml</body></methods><methods><class-id>Seaside.WAExactParameterMatchTest</class-id> <category>tests</category><body package="Seaside-Tests-REST-Core">testInstantiation	| match |	match := WAParameterMatch name: 'rev' value: '58692' arguments: #().	self assert: (match isKindOf: WAExactParameterMatch)</body><body package="Seaside-Tests-REST-Core">testMatches	| match |	match := WAParameterMatch name: 'rev' value: '58692' arguments: #().	self assert: (match matchesName: 'rev' value: '58692').	self deny: (match matchesName: 'rev' value: 58692).	self deny: (match matchesName: 'rev' value: 'a').	self deny: (match matchesName: 'revision' value: '58692')</body></methods><methods><class-id>Seaside.WAByMethodRoutesStub</class-id> <category>stubs</category><body package="Seaside-Tests-REST-Core">compactDatabase: aString	selector := #compactDatabase:.	arguments := Array with: aString</body><body package="Seaside-Tests-REST-Core">createBulkDocumentsInDatabase: aString	selector := #createBulkDocumentsInDatabase:.	arguments := Array with: aString</body><body package="Seaside-Tests-REST-Core">createDatabase: aString	selector := #createDatabase:.	arguments := Array with: aString</body><body package="Seaside-Tests-REST-Core">createNewDocumentInDatabase: aString	selector := #createNewDocumentInDatabase:.	arguments := Array with: aString</body><body package="Seaside-Tests-REST-Core">createOrUpdateDocument: aFirstString inDatabase: aSecondString	selector := #createOrUpdateDocument:inDatabase:.	arguments := Array with: aFirstString with: aSecondString</body><body package="Seaside-Tests-REST-Core">deleteDatabase: aString	selector := #deleteDatabase:.	arguments := Array with: aString</body><body package="Seaside-Tests-REST-Core">deleteDocument: aFirstString inDatabase: aSecondString	selector := #deleteDocument:inDatabase:.	arguments := Array with: aFirstString with: aSecondString</body><body package="Seaside-Tests-REST-Core">getAllDatabases	selector := #getAllDatabases.	arguments := Array new</body><body package="Seaside-Tests-REST-Core">getAllDocuments: aString	selector := #getAllDocuments:.	arguments := Array with: aString</body><body package="Seaside-Tests-REST-Core">getConfig	selector := #getConfig.	arguments := Array new</body><body package="Seaside-Tests-REST-Core">getDatabase: aString	selector := #getDatabase:.	arguments := Array with: aString</body><body package="Seaside-Tests-REST-Core">getDocument: aFirstString ofDatabase: aSecondString	selector := #getDocument:ofDatabase:.	arguments := Array with: aFirstString with: aSecondString</body><body package="Seaside-Tests-REST-Core">getInfo	selector := #getInfo.	arguments := Array new</body><body package="Seaside-Tests-REST-Core">getStats	selector := #getStats.	arguments := Array new</body><body package="Seaside-Tests-REST-Core">getUuids: aString	selector := #getUuids:.	arguments := Array with: aString</body><body package="Seaside-Tests-REST-Core">getView: aFirstString inDesign: aSecondString inDatabase: aThirdString	selector := #getView:inDesign:inDatabase:.	arguments := Array with: aFirstString with: aSecondString with: aThirdString</body><body package="Seaside-Tests-REST-Core">queryDatabase: aString	selector := #queryDatabase:.	arguments := Array with: aString</body><body package="Seaside-Tests-REST-Core">replicate	selector := #replicate.	arguments := Array new</body></methods><methods><class-id>Seaside.WAByMethodRoutesStub</class-id> <category>accessing</category><body package="Seaside-Tests-REST-Core">arguments	^ arguments</body><body package="Seaside-Tests-REST-Core">selector	^ selector</body></methods><methods><class-id>Seaside.WAMainMimeTypeMatchTest</class-id> <category>running</category><body package="Seaside-Tests-REST-Core">setUp	match := WAMainMimeTypeMatch main: 'application'</body></methods><methods><class-id>Seaside.WAMainMimeTypeMatchTest</class-id> <category>tests</category><body package="Seaside-Tests-REST-Core">testMatches	self assert: (match matches: (WAMimeType main: 'application' sub: 'xml')).	self deny: (match matches: (WAMimeType main: 'something' sub: 'xml')).	self assert: (match matches: (WAMimeType main: 'application' sub: 'something')).	self deny: (match matches: (WAMimeType main: 'something' sub: 'something')).		self assert: (match matches: (WAMimeType main: '*' sub: 'xml')).	self assert: (match matches: (WAMimeType main: 'application' sub: '*')).	self assert: (match matches: (WAMimeType main: '*' sub: '*')).		self deny: (match matches: (WAMimeType main: 'something' sub: '*')).	self assert: (match matches: (WAMimeType main: '*' sub: 'something'))</body><body package="Seaside-Tests-REST-Core">testPriority	self assert: match priority = 2</body></methods><methods><class-id>Seaside.WAStreamTypeHandlerTest</class-id> <category>private</category><body package="Seaside-Tests-REST-Core">assertPerformGetTo: aCollectionOfStrings equals: aCollection contentType: aMimeType	| requestUrl request response context |	requestUrl := WAUrl new		addAllToPath: aCollectionOfStrings;		yourself.	request := WARequest		method: 'GET'		uri: requestUrl.	response := WABufferedResponse new.			context := WARequestContext request: request response: response.	[ handler handle: context ]		on: WAResponseNotification		do: [ :n | ].		self assert: response contents = aCollection.	aMimeType isNil ifFalse: [		self assert: response contentType = aMimeType.		self assert: response contentType greaseString = aMimeType greaseString ]</body></methods><methods><class-id>Seaside.WAStreamTypeHandlerTest</class-id> <category>tests</category><body package="Seaside-Tests-REST-Core">testFaviconIco	self assertPerformGetTo: #('favicon.ico') equals: handler faviconIco contentType: nil</body><body package="Seaside-Tests-REST-Core">testIndex	self assertPerformGetTo: #('index') equals: handler index contentType: nil</body><body package="Seaside-Tests-REST-Core">testRobotsTxt	self assertPerformGetTo: #('robots.txt') equals: handler robotsTxt contentType: (WAMimeType fromString: 'text/plain;charset=utf-8')</body><body package="Seaside-Tests-REST-Core">testStarGif	self assertPerformGetTo: #('star.gif') equals: handler starGif contentType: (WAMimeType fromString: 'image/gif')</body></methods><methods><class-id>Seaside.WAStreamTypeHandlerTest</class-id> <category>running</category><body package="Seaside-Tests-REST-Core">setUp	super setUp.	handler := WAStreamTypeHandler new</body></methods><methods><class-id>Seaside.WAComplexRouteTest</class-id> <category>tests</category><body package="Seaside-Tests-REST-Core">testComplexMatching	| route arguments |	route := WAComplexRoute		method: 'GET'		selector: #zork		pattern: '/{first}/prefix{second}/{third}postfix/[methods.mcz|classes.mcz]'		arguments: #('first' 'second' 'third')		produces: nil		consumes: nil.	self assert: (route matchesPath: #('first' 'prefixO' 'zzpostfix' 'methods.mcz')).	arguments := Array new: 3.	route		mapArgumentsWithElements: #('first' 'prefixO' 'zzpostfix' 'methods.mcz')		parameters: Dictionary new		into: arguments.	self assert: arguments = #('first' 'O' 'zz')</body><body package="Seaside-Tests-REST-Core">testInstantiation	WAUrl absolute: '/{3}/_all_docs?startkey={1}&amp;limit={2}'</body><body package="Seaside-Tests-REST-Core">testOverlyComplexMatching	| route arguments |	route := WAComplexRoute		method: 'GET'		selector: #zork		pattern: '/*first*/[methods.mcz|classes.mcz]'		arguments: #('first')		produces: nil		consumes: nil.	self assert: (route matchesPath: #('first' 'prefixO' 'zzpostfix' 'methods.mcz')).	self assert: (route matchesPath: #('methods.mcz')).	self deny: (route matchesPath: #('first' 'prefixO' 'zzpostfix' 'traits.mcz')).	arguments := Array new: 1.	route		mapArgumentsWithElements: #('first' 'prefixO' 'zzpostfix' 'methods.mcz')		parameters: Dictionary new		into: arguments.	self assert: arguments = #(('first' 'prefixO' 'zzpostfix')).	arguments := Array new: 1.	route		mapArgumentsWithElements: #('methods.mcz')		parameters: Dictionary new		into: arguments.	self assert: arguments = #(()).		route := WAComplexRoute		method: 'GET'		selector: #zork		pattern: '/prefix/*first*/{postfix}/[methods.mcz|classes.mcz]'		arguments: #('first' 'postfix')		produces: nil		consumes: nil.	self assert: (route matchesPath: #('prefix' 'first' 'prefixO' 'zzpostfix' 'postfix' 'methods.mcz')).	self assert: (route matchesPath: #('prefix' 'postfix' 'methods.mcz')).		arguments := Array new: 2.	route		mapArgumentsWithElements: #('prefix' 'first' 'prefixO' 'zzpostfix' 'postfix' 'methods.mcz')		parameters: Dictionary new		into: arguments.	self assert: arguments = #(('first' 'prefixO' 'zzpostfix') 'postfix').	arguments := Array new: 2.	route		mapArgumentsWithElements: #('prefix' 'postfix' 'methods.mcz')		parameters: Dictionary new		into: arguments.	self assert: arguments = #(() 'postfix')</body><body package="Seaside-Tests-REST-Core">testParameterMatchingMixedParameters	| route parameters |	route := WARoute get: '/{1}/_all_docs?rev={2}&amp;uuids=true' selector: #a:b:.	self deny: (route matchesParameters: Dictionary new).	parameters := Dictionary new at: 'rev' put: '5'; yourself.	self deny: (route matchesParameters: parameters).	parameters at: 'uuids' put: 'true'.	self assert: (route matchesParameters: parameters).	parameters at: 'phpsessionid' put: '32432'.	self deny: (route matchesParameters: Dictionary new).	parameters removeKey: 'phpsessionid'.	self assert: (route matchesParameters: parameters).	parameters at: 'uuids' put: 'false'.	self deny: (route matchesParameters: parameters)</body><body package="Seaside-Tests-REST-Core">testParameterMatchingNoParameters	| route parameters |	route := WARoute get: '/{1}/_all_docs' selector: #a:.	self assert: (route matchesParameters: Dictionary new).	parameters := Dictionary new at: 'key' put: 'value'; yourself.	self deny: (route matchesParameters: parameters)</body><body package="Seaside-Tests-REST-Core">testPathMatching	| route |	route := WARoute get: '/{1}/_all_docs' selector: #a:.	self deny: (route matchesPath: #('something')).	self assert: (route matchesPath: #('something' '_all_docs')).	self deny: (route matchesPath: #('something' 'else')).	self deny: (route matchesPath: #('something' '_all_docs' 'more')).	self assert: (route priority = 5)</body></methods><methods><class-id>Seaside.WAPragmaBasedRestfulHandlerTest</class-id> <category>tests</category><body package="Seaside-Tests-REST-Core">testCreateRoutes	self assert: handler notNil</body></methods><methods><class-id>Seaside.WAPragmaBasedRestfulHandlerTest</class-id> <category>running</category><body package="Seaside-Tests-REST-Core">setUp	handler := WAPragmaStubHandler new</body></methods><methods><class-id>Seaside.WAPlaceholderPathMatchTest</class-id> <category>tests</category><body package="Seaside-Tests-REST-Core">testFullInstantiation	| match |	match := WAPPathMatch fromString: '{7}' index: 2 arguments: #().	self assert: (match isKindOf: WAFullPlaceholderPathMatch).	self assert: match priority = 2.	self assert: match sourceIndex = 2.	self assert: match targetIndex = 7</body><body package="Seaside-Tests-REST-Core">testFullMapArgumentsWithElementsInto	| match result |	match := WAPPathMatch fromString: '{1}' index: 1 arguments: #().	result := Array new: 1.	match mapArgumentsWithElements: #('foo') into: result.	self assert: result first = 'foo'</body><body package="Seaside-Tests-REST-Core">testMatchesFull	| match |	match := WAPPathMatch fromString: '{7}' index: 1 arguments: #().	self assert: (match matches: 'foo')</body><body package="Seaside-Tests-REST-Core">testMatchesPrefix	| match |	match := WAPPathMatch fromString: 'foo.{7}' index: 1 arguments: #().	self assert: (match matches: 'foo.bar').	self deny: (match matches: 'foo.').	self deny: (match matches: 'fo.bar').	self deny: (match matches: 'oo.bar')</body><body package="Seaside-Tests-REST-Core">testMatchesSuffix	| match |	match := WAPPathMatch fromString: '{7}.bar' index: 1 arguments: #().	self assert: (match matches: 'foo.bar').	self deny: (match matches: '.bar').	self deny: (match matches: 'foo.barz').	self deny: (match matches: 'foo.ba')</body><body package="Seaside-Tests-REST-Core">testMultiInstantiation	| match |	match := WAPPathMatch fromString: '*7*' index: 2 arguments: #().	self assert: (match isKindOf: WAMultiPlaceholderPathMatch).	self assert: match priority = 1.	self assert: match sourceIndex = 2.	self assert: match targetIndex = 7</body><body package="Seaside-Tests-REST-Core">testNamedInstantiation	| match |	match := WAPPathMatch fromString: '{put}' index: 2 arguments: #('get' 'put' 'post').	self assert: (match isKindOf: WAFullPlaceholderPathMatch).	self assert: match priority = 2.	self assert: match sourceIndex = 2.	self assert: match targetIndex = 2</body><body package="Seaside-Tests-REST-Core">testNamedMultiInstantiation	| match |	match := WAPPathMatch fromString: '*put*' index: 2 arguments: #('get' 'put' 'post').	self assert: (match isKindOf: WAMultiPlaceholderPathMatch).	self assert: match priority = 1.	self assert: match sourceIndex = 2.	self assert: match targetIndex = 2</body><body package="Seaside-Tests-REST-Core">testPrefixInstantiation	| match |	match := WAPPathMatch fromString: 'foo.{787}' index: 2 arguments: #().	self assert: (match isKindOf: WAPrefixPlaceholderPathMatch).	self assert: match priority = 3.	self assert: match sourceIndex = 2.	self assert: match targetIndex = 787</body><body package="Seaside-Tests-REST-Core">testPrefixMapArgumentsWithElementsInto	| match result |	match := WAPPathMatch fromString: 'foo.{1}' index: 1 arguments: #().	result := Array new: 1.	match mapArgumentsWithElements: #('foo.bar') into: result.	self assert: result first = 'bar'</body><body package="Seaside-Tests-REST-Core">testSuffixInstantiation	| match |	match := WAPPathMatch fromString: '{787}.bar' index: 2 arguments: #().	self assert: (match isKindOf: WASuffixPlaceholderPathMatch).	self assert: match priority = 3.	self assert: match sourceIndex = 2.	self assert: match targetIndex = 787</body><body package="Seaside-Tests-REST-Core">testSuffixMapArgumentsWithElementsInto	| match result |	match := WAPPathMatch fromString: '{1}.bar' index: 1 arguments: #().	result := Array new: 1.	match mapArgumentsWithElements: #('foo.bar') into: result.	self assert: result first = 'foo'</body></methods><methods><class-id>Seaside.WAMimeTypeMatchTest</class-id> <category>tests</category><body package="Seaside-Tests-REST-Core">testFromMimeType	| mimeType |	mimeType := WAMimeTypeMatch fromString: 'application/xml'.	self assert: mimeType class = WAFullMimeTypeMatch.		mimeType := WAMimeTypeMatch fromString: 'application/*'.	self assert: mimeType class = WAMainMimeTypeMatch.		mimeType := WAMimeTypeMatch fromString: '*/xml'.	self assert: mimeType class = WASubMimeTypeMatch.		mimeType := WAMimeTypeMatch fromString: '*/*'.	self assert: mimeType class = WAWildcardMimeTypeMatch</body></methods><methods><class-id>Seaside.WAStubHandler</class-id> <category>private</category><body package="Seaside-Tests-REST-Core">createRoutes	^ OrderedCollection new		"GET"		add: (WARoute get: #listDatabases);		add: (WARoute post: #createDatabase:);		add: (WARoute post: #createDatabase:document:);		add: (WARoute get: #getDatabase:document:);		add: (WARoute delete: #deleteDatabase:document:);		yourself</body></methods><methods><class-id>Seaside.WARouteTest</class-id> <category>tests</category><body package="Seaside-Tests-REST-Core">testCount	| route |	route := WARoute get: #listDatabases.	self assert: route pathElementCount isZero.		route := WARoute get: #getDatabase:.	self assert: route pathElementCount = 1.		route := WARoute get: #getDatabase:document:.	self assert: route pathElementCount = 2</body><body package="Seaside-Tests-REST-Core">testMethod	| route |	route := WARoute get: #listDatabases.	self assert: route method = 'GET'.		route := WARoute post: #createDatabase:document:.	self assert: route method = 'POST'.		route := WARoute copy: #copyDatabase:document:.	self assert: route method = 'COPY'</body><body package="Seaside-Tests-REST-Core">testSendSelectorWithTo	| route victim result |	victim := WARouteVictimMock new.	route := WARoute get: #nothing.	result := route sendSelectorWith: Array new to: victim.	self assert: result = Array new.		route := WARoute get: #first:.	result := route sendSelectorWith: #('terrorists') to: victim.	self assert: result = #('terrorists').		route := WARoute get: #first:second:.	result := route sendSelectorWith: #('terrorists' 'marschall') to: victim.	self assert: result = #('terrorists' 'marschall')</body></methods><methods><class-id>Seaside.WAOrPathMatchTest</class-id> <category>tests</category><body package="Seaside-Tests-REST-Core">testInstantiation	| match |	match := WAOrPathMatch fromString: 'path' index: 1 arguments: #().	self assert: (match isKindOf: WAOrPathMatch).	self assert: match priority = 3</body><body package="Seaside-Tests-REST-Core">testMatches	| match |	match := WAOrPathMatch fromString: '[path|parameters]' index: 1 arguments: #().	self assert: (match matches: 'path').	self assert: (match matches: 'parameters').	self deny: (match matches: 'poth').		match := WAOrPathMatch fromString: '[path|or|parameters]' index: 1 arguments: #().	self assert: (match matches: 'path').	self assert: (match matches: 'parameters').	self assert: (match matches: 'or').	self deny: (match matches: 'poth')</body></methods><methods><class-id>Seaside.WAMimeTypeStubHandlerTest</class-id> <category>tests</category><body package="Seaside-Tests-REST-Core">testMultipleConentTypeRouting	self assertContentType: 'foo/bar' accept: nil routesTo: #processTwo.	self assertContentType: 'zork/fnord' accept: nil routesTo: #processTwo</body><body package="Seaside-Tests-REST-Core">testProduceMimeType	self assertContentType: nil accept: 'image/jpeg' produces: 'image/jpeg'.	self assertContentType: nil accept: 'image/png' produces: 'image/png'</body><body package="Seaside-Tests-REST-Core">testProduceNoMimeType	self assertContentType: 'application/xml' accept: nil produces: nil</body><body package="Seaside-Tests-REST-Core">testSimpleAcceptRouting	self assertContentType: nil accept: 'image/jpeg;q=0.8,image/png' routesTo: #producePng.	self assertContentType: nil accept: 'image/jpeg;q=0.8,image/png;q=0.9' routesTo: #producePng.	self assertContentType: nil accept: 'image/png,image/jpeg;q=0.8' routesTo: #producePng.	self assertContentType: nil accept: 'image/png;q=0.9,image/jpeg;q=0.8' routesTo: #producePng.		self assertContentType: '1/1' accept: 'image/png' routesTo: #producePng.	self assertContentType: '1/1' accept: 'image/png' routesTo: #producePng</body><body package="Seaside-Tests-REST-Core">testSimpleConentTypeRouting	self assertContentType: 'application/xml' accept: nil routesTo: #processApplicationXml.	self assertContentType: 'text/xml' accept: nil routesTo: #processXml</body></methods><methods><class-id>Seaside.WAMimeTypeStubHandlerTest</class-id> <category>private</category><body package="Seaside-Tests-REST-Core">assertContentType: aMimeTypeStringOrNil accept: anAcceptStringOrNil produces: aProducedMimeTypeStringOrNil	| routes headers request context result |	routes := WAByMethodRoutes routes: (GRPlatform current createRoutesFor: WAMimeTypeStubHandler).	headers := GRSmallDictionary new.	aMimeTypeStringOrNil isNil ifFalse: [		headers at: 'content-type' put: aMimeTypeStringOrNil ].	anAcceptStringOrNil isNil ifFalse: [		headers at: 'accept' put: anAcceptStringOrNil ].	request := (WARequest method: 'GET' uri: 'index')		setHeaders: headers;		yourself.	context := WARequestContext request: request response: WAResponse new.	result := routes routeForContext: context consume: true ifAbsent: [ self assert: false ].	self assert: result seasideMimeType = (aProducedMimeTypeStringOrNil isNil		ifTrue: [ nil ]		ifFalse: [  WAMimeType fromString: aProducedMimeTypeStringOrNil ])</body><body package="Seaside-Tests-REST-Core">assertContentType: aMimeTypeStringOrNil accept: anAcceptStringOrNil routesTo: aSymbol	| routes headers request context result |	routes := WAByMethodRoutes routes: (GRPlatform current createRoutesFor: WAMimeTypeStubHandler).	headers := GRSmallDictionary new.	aMimeTypeStringOrNil isNil ifFalse: [		headers at: 'content-type' put: aMimeTypeStringOrNil ].	anAcceptStringOrNil isNil ifFalse: [		headers at: 'accept' put: anAcceptStringOrNil ].	request := (WARequest method: 'GET' uri: 'index')		setHeaders: headers;		yourself.	context := WARequestContext request: request response: WAResponse new.	result := routes routeForContext: context consume: true ifAbsent: [ self assert: false ].	self assert: result route selector = aSymbol</body></methods><methods><class-id>Seaside.WAExactPathMatchTest</class-id> <category>tests</category><body package="Seaside-Tests-REST-Core">testInstantiation	| match |	match := WAPPathMatch fromString: 'path' index: 1 arguments: #().	self assert: (match isKindOf: WAExactPathMatch).	self assert: match priority = 3</body><body package="Seaside-Tests-REST-Core">testMatches	| match |	match := WAPPathMatch fromString: 'path' index: 1 arguments: #().	self assert: (match matches: 'path').	self deny: (match matches: 'poth')</body></methods><methods><class-id>Seaside.WARestfulFilterTest</class-id> <category>tests</category><body package="Seaside-Tests-REST-Core">testFindRouteForMethodConsumerIfAbsent	| route result requestUrl request context |	requestUrl := WAUrl new		addAllToPath: #('users' 'marschall');		yourself.	request := WARequest		method: 'GET'		uri: requestUrl.	context := WARequestContext request: request response: WAResponse new.	result := handler routeForContext: context ifAbsent: [ self assert: false ].	route := result route.	self assert: route method = 'GET'.	self assert: route pathElementCount = 2.	self assert: route selector = #getDatabase:document:.	self assert: result elements = #('users' 'marschall').	self deny: context consumer atEnd</body></methods><methods><class-id>Seaside.WARestfulFilterTest</class-id> <category>running</category><body package="Seaside-Tests-REST-Core">setUp	super setUp.	handler := WAStubFilter new</body></methods><methods><class-id>Seaside.WAMimeTypeStubHandler</class-id> <category>request-handling</category><body package="Seaside-Tests-REST-Core">processApplicationXml	&lt;get&gt;	&lt;path: 'index'&gt;	&lt;consumes: 'application/xml'&gt;</body><body package="Seaside-Tests-REST-Core">processTwo	&lt;get&gt;	&lt;path: 'index'&gt;	&lt;consumes: 'foo/bar'&gt;	&lt;consumes: 'zork/fnord'&gt;</body><body package="Seaside-Tests-REST-Core">processXml	&lt;get&gt;	&lt;path: 'index'&gt;	&lt;consumes: '*/xml'&gt;</body><body package="Seaside-Tests-REST-Core">produceJpeg	&lt;get&gt;	&lt;path: 'index'&gt;	&lt;produces: 'image/jpeg'&gt;</body><body package="Seaside-Tests-REST-Core">producePng	&lt;get&gt;	&lt;path: 'index'&gt;	&lt;produces: 'image/png'&gt;</body></methods><methods><class-id>Seaside.WAStreamTypeHandler</class-id> <category>request-handling</category><body package="Seaside-Tests-REST-Core">faviconIco	&lt;get&gt;	&lt;path: 'favicon.ico'&gt;	^ #(16r47 16r49 16r46 16r38 16r39 16r61 16rE0 16r00 16rE0 16r00 16rD5 16r3F 16r00 16rEC 16rBA 16r9C 16rFD 16r49 16r00 16rFD 16r6D 16r00 16rE4 16rAE 16rAD 16rFF 16r64 16r00 16rFE 16r74 16r00 16rFF 16r8E 16r00 16rFF 16r86 16r00 16rEA 16r8C 16r5B 16rFF 16r78 16r00 16rFE 16r5B 16r00 16rFA 16r54 16r00 16rE6 16r16 16r00 16rEC 16r2F 16r00 16rFF 16r92 16r00 16rEE 16rC8 16rAF 16rFF 16rA2 16r00 16rDA 16r7A 16r76 16rFF 16r70 16r00 16rFF 16r95 16r00 16rD6 16r68 16r68 16rFF 16r89 16r00 16rDE 16r10 16r00 16rF5 16rE7 16rE7 16rF8 16rEA 16rEA 16rF3 16rDD 16rD3 16rEF 16rD2 16rC0 16rDC 16r89 16r89 16rEB 16r9F 16r6B 16rF7 16r58 16rA0 16rFF 16r9A 16r00 16rFB 16rFB 16rFB 16rE1 16r80 16r00 16rDC 16rF0 16rA0 16rD8 16r43 16r3D 16rDF 16rA7 16rA7 16rEC 16rD0 16rD0 16rD8 16r62 16r55 16rF9 16r60 16rA0 16rFA 16rF0 16rEA 16rED 16rC1 16r9D 16rEB 16r56 16r31 16rF9 16r72 16rA0 16rEB 16rC2 16rC0 16rD4 16r4A 16r4A 16rEE 16r76 16r2F 16rED 16r7B 16r3D 16rF5 16r54 16r00 16rEB 16r7E 16r4B 16rF5 16r70 16r16 16rEA 16r9A 16r7B 16rF2 16r8D 16r23 16rEA 16r9D 16r5B 16rE1 16r7C 16r67 16rED 16r64 16r30 16rF7 16rE9 16rE9 16rEA 16r90 16r6A 16rE2 16r97 16r87 16rED 16r88 16r3D 16rEE 16r25 16r00 16rDD 16r25 16r16 16rED 16r6D 16r3D 16rFF 16rA9 16r00 16rFF 16rFF 16rFF 16r21 16rF9 16r40 16r10 16r00 16r00 16r3F 16r00 16r2C 16r00 16r00 16r00 16r00 16rE0 16r00 16rE0 16r00 16r00 16r60 16r7E 16rC0 16r9F 16rF0 16r77 16r72 16r10 16r86 16r48 16rE4 16r83 16r60 16rCA 16r24 16r93 16rF0 16r41 16rA2 16r35 16rC4 16rC0 16r30 16rCA 16r43 16rC1 16r00 16r93 16rD9 16r18 16r16 16rA0 16r92 16rE3 16r28 16r40 16r26 16r15 16rC5 16r2E 16r44 16rFA 16rA1 16r68 16r33 16r87 16rEF 16r60 16r38 16r28 16rA0 16r8D 16rD1 16r4F 16r27 16r49 16r1C 16rFE 16r50 16rA0 16r40 16r13 16r20 16r11 16r42 16r00 16r31 16r12 16r15 16r13 16r60 16r90 16r82 16r60 16r2F 16r30 16r48 16r1A 16r80 16r2A 16r10 16r50 16r15 16r60 16rB0 16rB0 16r3C 16r37 16r49 16r80 16r1E 16r40 16r8D 16r78 16rC0 16r2C 16r49 16r38 16r90 16r20 16r1D 16r35 16r22 16rC0 16r20 16r16 16r2B 16r48 16r3D 16r10 16r10 16r39 16r42 16r17 16r1B 16r14 16r17 16r48 16r29 16r3B 16r25 16r4F 16r49 16r2B 16r11 16r1F 16rC0 16r41 16r00 16r3B) asByteArray</body><body package="Seaside-Tests-REST-Core">index	&lt;get&gt;	^ 'ok'</body><body package="Seaside-Tests-REST-Core">robotsTxt	&lt;get&gt;	&lt;path: 'robots.txt'&gt;	&lt;produces: 'text/plain'&gt;	^ 'User-agent: *Disallow: /'</body><body package="Seaside-Tests-REST-Core">starGif	&lt;get&gt;	&lt;path: 'star.gif'&gt;	&lt;produces: 'image/gif'&gt;	^ #(16r47 16r49 16r46 16r38 16r39 16r61 16rE0 16r00 16rE0 16r00 16rD5 16r3F 16r00 16rEC 16rBA 16r9C 16rFD 16r49 16r00 16rFD 16r6D 16r00 16rE4 16rAE 16rAD 16rFF 16r64 16r00 16rFE 16r74 16r00 16rFF 16r8E 16r00 16rFF 16r86 16r00 16rEA 16r8C 16r5B 16rFF 16r78 16r00 16rFE 16r5B 16r00 16rFA 16r54 16r00 16rE6 16r16 16r00 16rEC 16r2F 16r00 16rFF 16r92 16r00 16rEE 16rC8 16rAF 16rFF 16rA2 16r00 16rDA 16r7A 16r76 16rFF 16r70 16r00 16rFF 16r95 16r00 16rD6 16r68 16r68 16rFF 16r89 16r00 16rDE 16r10 16r00 16rF5 16rE7 16rE7 16rF8 16rEA 16rEA 16rF3 16rDD 16rD3 16rEF 16rD2 16rC0 16rDC 16r89 16r89 16rEB 16r9F 16r6B 16rF7 16r58 16rA0 16rFF 16r9A 16r00 16rFB 16rFB 16rFB 16rE1 16r80 16r00 16rDC 16rF0 16rA0 16rD8 16r43 16r3D 16rDF 16rA7 16rA7 16rEC 16rD0 16rD0 16rD8 16r62 16r55 16rF9 16r60 16rA0 16rFA 16rF0 16rEA 16rED 16rC1 16r9D 16rEB 16r56 16r31 16rF9 16r72 16rA0 16rEB 16rC2 16rC0 16rD4 16r4A 16r4A 16rEE 16r76 16r2F 16rED 16r7B 16r3D 16rF5 16r54 16r00 16rEB 16r7E 16r4B 16rF5 16r70 16r16 16rEA 16r9A 16r7B 16rF2 16r8D 16r23 16rEA 16r9D 16r5B 16rE1 16r7C 16r67 16rED 16r64 16r30 16rF7 16rE9 16rE9 16rEA 16r90 16r6A 16rE2 16r97 16r87 16rED 16r88 16r3D 16rEE 16r25 16r00 16rDD 16r25 16r16 16rED 16r6D 16r3D 16rFF 16rA9 16r00 16rFF 16rFF 16rFF 16r21 16rF9 16r40 16r10 16r00 16r00 16r3F 16r00 16r2C 16r00 16r00 16r00 16r00 16rE0 16r00 16rE0 16r00 16r00 16r60 16r7E 16rC0 16r9F 16rF0 16r77 16r72 16r10 16r86 16r48 16rE4 16r83 16r60 16rCA 16r24 16r93 16rF0 16r41 16rA2 16r35 16rC4 16rC0 16r30 16rCA 16r43 16rC1 16r00 16r93 16rD9 16r18 16r16 16rA0 16r92 16rE3 16r28 16r40 16r26 16r15 16rC5 16r2E 16r44 16rFA 16rA1 16r68 16r33 16r87 16rEF 16r60 16r38 16r28 16rA0 16r8D 16rD1 16r4F 16r27 16r49 16r1C 16rFE 16r50 16rA0 16r40 16r13 16r20 16r11 16r42 16r00 16r31 16r12 16r15 16r13 16r60 16r90 16r82 16r60 16r2F 16r30 16r48 16r1A 16r80 16r2A 16r10 16r50 16r15 16r60 16rB0 16rB0 16r3C 16r37 16r49 16r80 16r1E 16r40 16r8D 16r78 16rC0 16r2C 16r49 16r38 16r90 16r20 16r1D 16r35 16r22 16rC0 16r20 16r16 16r2B 16r48 16r3D 16r10 16r10 16r39 16r42 16r17 16r1B 16r14 16r17 16r48 16r29 16r3B 16r25 16r4F 16r49 16r2B 16r11 16r1F 16rC0 16r41 16r00 16r3B) asByteArray</body></methods><methods><class-id>Seaside.WAPragmaStubHandler</class-id> <category>public-meta</category><body package="Seaside-Tests-REST-Core">getAllDatabases	&lt;get&gt;	&lt;path: '/_all_dbs'&gt;</body><body package="Seaside-Tests-REST-Core">getConfig	&lt;get&gt;	&lt;path: '/_config'&gt;</body><body package="Seaside-Tests-REST-Core">getInfo	&lt;get&gt;</body><body package="Seaside-Tests-REST-Core">getStats	&lt;get&gt;	&lt;path: '/_stats'&gt;</body><body package="Seaside-Tests-REST-Core">getUuids: numberOfUuids	&lt;get&gt;	&lt;path: '/_uuids?count={numberOfUuids}'&gt;</body><body package="Seaside-Tests-REST-Core">replicate	&lt;post&gt;	&lt;path: '/_replicate'&gt;</body></methods><methods><class-id>Seaside.WAPragmaStubHandler</class-id> <category>public-database</category><body package="Seaside-Tests-REST-Core">compactDatabase: databaseName	&lt;post&gt;	&lt;path: '/{databaseName}/_compact'&gt;</body><body package="Seaside-Tests-REST-Core">createDatabase: databaseName	&lt;put&gt;</body><body package="Seaside-Tests-REST-Core">deleteDatabase: databaseName	&lt;delete&gt;</body><body package="Seaside-Tests-REST-Core">getDatabase: databaseName	&lt;get&gt;</body></methods><methods><class-id>Seaside.WAPragmaStubHandler</class-id> <category>public-documents</category><body package="Seaside-Tests-REST-Core">createBulkDocumentsInDatabase: databaseName	&lt;post&gt;	&lt;path: '/{databaseName}/_bulk_docs'&gt;</body><body package="Seaside-Tests-REST-Core">createNewDocumentInDatabase: databaseName	&lt;post&gt;</body><body package="Seaside-Tests-REST-Core">createOrUpdateDocument: documentId inDatabase: databaseName	&lt;put&gt;	&lt;path: '/{databaseName}/{documentId}'&gt;</body><body package="Seaside-Tests-REST-Core">deleteDocument: documentId inDatabase: databaseName	&lt;delete&gt;	&lt;path: '/{databaseName}/{documentId}'&gt;</body><body package="Seaside-Tests-REST-Core">getAllDocuments: databaseName	&lt;get&gt;	&lt;path: '/{databaseName}/_all_docs'&gt;</body><body package="Seaside-Tests-REST-Core">getDocument: documentId ofDatabase: databaseName	&lt;get&gt;	&lt;path: '/{databaseName}/{documentId}'&gt;</body><body package="Seaside-Tests-REST-Core">getView: viewName inDesign: designName inDatabase: databaseName	&lt;get&gt;	&lt;path: '/{databaseName}/_design/{designName}/_view/{viewName}'&gt;</body><body package="Seaside-Tests-REST-Core">queryDatabase: databaseName	&lt;post&gt;	&lt;path: '/{databaseName}/_temp_view'&gt;</body></methods><methods><class-id>Grease.GRPackage class</class-id> <category>*seaside-tests-rest-core</category><body package="Seaside-Tests-REST-Core">seasideTestsRestCore	^ self new		name: 'Seaside-Tests-REST-Core';		description: 'Unit tests for the package Seaside-REST-Core.';		addDependency: 'Seaside-REST-Core';		url: #seasideUrl;		yourself</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>WAContextTest</name><environment>Seaside</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestContext </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Tests-Core-RequestHandling</category><attributes><package>Seaside-Tests-Core</package></attributes></class><class><name>WARestfulHandler</name><environment>Seaside</environment><super>Seaside.WARequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>routes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Handler</category><attributes><package>Seaside-REST-Core</package></attributes></class><class><name>WARestfulFilter</name><environment>Seaside</environment><super>Seaside.WARequestFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>routes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-REST-Core-Handler</category><attributes><package>Seaside-REST-Core</package></attributes></class></st-source>