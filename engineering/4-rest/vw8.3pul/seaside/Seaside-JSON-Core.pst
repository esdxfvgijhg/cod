<?xml version="1.0"?><st-source><!-- Name: Seaside-JSON-CoreComment: JSON integration in Seaside. Provides a basic functionality to generate JSON from Smalltalk.DbIdentifier: bear73DbTrace: 492593DbUsername: jkottDbVersion: 3.2.0 - pmm.35 1DevelopmentPrerequisites: #(#(#any 'Seaside-Namespace' '') #(#any 'Seaside-Core' '') #(#any 'Seaside-VisualWorks-Core' '') #(#any 'Seaside-Canvas' ''))Id: 1b45cc99-b2c5-4a4e-a93e-2b0ca185fe4cNamespace: SeasidePackageName: Seaside-JSON-CoreParcel: #('Seaside-JSON-Core')ParcelName: Seaside-JSON-CorePrerequisiteParcels: #(#('Seaside-Namespace' '') #('Seaside-Core' '') #('Seaside-VisualWorks-Core' '') #('Seaside-Canvas' ''))PrintStringCache: (3.2.0 - pmm.35 1,jkott)Url: http://smalltalkhub.com/mc/Seaside/Seaside32/main/Seaside-JSON-Core-pmm.35.mczVersion: 3.2.0 - pmm.35 1Date: 3:31:28 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:31:28 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WAJsonBrush</name><environment>Seaside</environment><super>Seaside.WABrush</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-JSON-Core</category><attributes><package>Seaside-JSON-Core</package></attributes></class><class><name>WAJsonElementBrush</name><environment>Seaside</environment><super>Seaside.WAJsonBrush</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-JSON-Core</category><attributes><package>Seaside-JSON-Core</package></attributes></class><class><name>WAJsonDocument</name><environment>Seaside</environment><super>Seaside.WADocument</super><private>false</private><indexed-type>none</indexed-type><inst-vars>jsonEncoder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-JSON-Core</category><attributes><package>Seaside-JSON-Core</package></attributes></class><class><name>WAJsonParser</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-JSON-Core</category><attributes><package>Seaside-JSON-Core</package></attributes></class><comment><class-id>Seaside.WAJsonParser</class-id><body>I am a parser for JSON. It is a bit more forgiving than the standard and allows any kind of top level element except numbers, not just {} and []. See http://www.json.org/ for details.I can be subclasses to create more sophisticated objects than just Arrays and Dictionaries. To do that, override the one or more methods in the creating protocol.</body></comment><class><name>WAJsonCanvas</name><environment>Seaside</environment><super>Seaside.WACanvas</super><private>false</private><indexed-type>none</indexed-type><inst-vars>first </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-JSON-Core</category><attributes><package>Seaside-JSON-Core</package></attributes></class><class><name>WAJsonObjectBrush</name><environment>Seaside</environment><super>Seaside.WAJsonBrush</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-JSON-Core</category><attributes><package>Seaside-JSON-Core</package></attributes></class><class><name>WAJsonSyntaxError</name><environment>Seaside</environment><super>Seaside.WAError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-JSON-Core</category><attributes><package>Seaside-JSON-Core</package></attributes></class><comment><class-id>Seaside.WAJsonSyntaxError</class-id><body>A WAJsonSyntaxError signals invalid JSON input.</body></comment><class><name>WAJsonEncoder</name><environment>Seaside</environment><super>Seaside.WATableBasedEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-JSON-Core</category><attributes><package>Seaside-JSON-Core</package></attributes></class><class><name>WAJsonValueBrush</name><environment>Seaside</environment><super>Seaside.WAJsonElementBrush</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-JSON-Core</category><attributes><package>Seaside-JSON-Core</package></attributes></class><class><name>JSJsonParser</name><environment>Seaside</environment><super>Seaside.WAJsonParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-JSON-Core</category><attributes><package>Seaside-JSON-Core</package></attributes></class><comment><class-id>Seaside.JSJsonParser</class-id><body>I'm purely for backwards compatibility with Seaside 3.0</body></comment><class><name>WAJsonKeyValueBrush</name><environment>Seaside</environment><super>Seaside.WAJsonElementBrush</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-JSON-Core</category><attributes><package>Seaside-JSON-Core</package></attributes></class><class><name>WAJsonArrayBrush</name><environment>Seaside</environment><super>Seaside.WAJsonBrush</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-JSON-Core</category><attributes><package>Seaside-JSON-Core</package></attributes></class><methods><class-id>Seaside.WAJsonBrush</class-id> <category>private</category><body package="Seaside-JSON-Core">closeBrush	self subclassResponsibility</body><body package="Seaside-JSON-Core">openBrush	self subclassResponsibility</body></methods><methods><class-id>Seaside.WAJsonBrush</class-id> <category>public</category><body package="Seaside-JSON-Core">with: anObject	self openBrush.	super with: [		canvas render: anObject ].	self closeBrush</body></methods><methods><class-id>Seaside.WAJsonBrush</class-id> <category>accessing</category><body package="Seaside-JSON-Core">document	^ canvas document</body></methods><methods><class-id>Seaside.WAJsonElementBrush</class-id> <category>private</category><body package="Seaside-JSON-Core">closeBrush</body><body package="Seaside-JSON-Core">openBrush	canvas writeIfNotFirst: ', '</body></methods><methods><class-id>Seaside.WAJsonDocument</class-id> <category>writing</category><body package="Seaside-JSON-Core">closeArray	stream nextPut: $]</body><body package="Seaside-JSON-Core">closeObject	stream nextPut: $}</body><body package="Seaside-JSON-Core">openArray	stream nextPut: $[</body><body package="Seaside-JSON-Core">openObject	stream nextPut: ${</body><body package="Seaside-JSON-Core">string: aString	stream nextPut: $".	jsonEncoder nextPutAll: aString.	stream nextPut: $"</body></methods><methods><class-id>Seaside.WAJsonDocument</class-id> <category>initialization</category><body package="Seaside-JSON-Core">initializeWithStream: aStream codec: aCodec	super initializeWithStream: aStream codec: aCodec.	jsonEncoder := GRPlatform current jsonEncoderOn: aStream</body></methods><methods><class-id>Seaside.WAJsonParser</class-id> <category>creating</category><body package="Seaside-JSON-Core">createArray	"Create an empty collection. Subclasses might want to refine this implementation."	^ Array new</body><body package="Seaside-JSON-Core">createFalse	"Create the false literal. Subclasses might want to refine this implementation."		^ false</body><body package="Seaside-JSON-Core">createNull	"Create the null literal. Subclasses might want to refine this implementation."	^ nil</body><body package="Seaside-JSON-Core">createNumber: aString	"Create a number literal. Subclasses might want to refine this implementation."	^ aString asNumber</body><body package="Seaside-JSON-Core">createObject	"Create an empty object. Subclasses might want to refine this implementation."		^ Dictionary new</body><body package="Seaside-JSON-Core">createProperty: aKey with: aValue	"Create an empty attribute value pair. Subclasses might want to refine this implementation."		^ aKey -&gt; aValue</body><body package="Seaside-JSON-Core">createString: aString	"Create a string literal. Subclasses might want to refine this implementation."	^ aString</body><body package="Seaside-JSON-Core">createTrue	"Create the true literal. Subclasses might want to refine this implementation."	^ true</body></methods><methods><class-id>Seaside.WAJsonParser</class-id> <category>parsing-internal</category><body package="Seaside-JSON-Core">parseCharacter	| char |	(char := stream next) = $\ 		ifFalse: [ ^ char ].	(char := stream next) = $" 		ifTrue: [ ^ char ].	char = $\		ifTrue: [ ^ char ].	char = $/		ifTrue: [ ^ char ].	char = $b		ifTrue: [ ^ Character backspace ].	char = $f		ifTrue: [ ^ Character newPage ].	char = $n		ifTrue: [ ^ Character lf ].	char = $r		ifTrue: [ ^ Character cr ].	char = $t		ifTrue: [ ^ Character tab ].	char = $u		ifTrue: [ ^ self parseCharacterHex ].	self error: 'invalid escape character \' , (String with: char)</body><body package="Seaside-JSON-Core">parseCharacterHex	| value |	value := self parseCharacterHexDigit.	3 timesRepeat: [ value := (value &lt;&lt; 4) + self parseCharacterHexDigit ].	^ Character codePoint: value</body><body package="Seaside-JSON-Core">parseCharacterHexDigit	| digit |	stream atEnd ifFalse: [ 		digit := stream next greaseInteger.		(digit between: "$0" 48 and: "$9" 57)			ifTrue: [ ^ digit - 48 ].		(digit between: "$A" 65 and: "$F" 70)			ifTrue: [ ^ digit - 55 ].		(digit between: "$a" 97 and: "$f" 102)			ifTrue: [ ^ digit - 87 ] ].	self error: 'hex-digit expected'</body><body package="Seaside-JSON-Core">parseNumber	| negated number |	negated := stream peek = $-.	negated ifTrue: [ stream next ].	number := self parseNumberInteger.	(stream peek = $.) ifTrue: [		stream next. 		number := number + self parseNumberFraction ].	('eE' includes: stream peek) ifTrue: [		stream next.		number := number * self parseNumberExponent ].	negated ifTrue: [ number := number negated ].	^ self whitespace; createNumber: number</body><body package="Seaside-JSON-Core">parseNumberExponent	| number negated |	number := 0.	negated := stream peek = $-.	(negated or: [ stream peek = $+ ]) ifTrue: [ stream next ].	[ stream atEnd not and: [ stream peek isDigit ] ]		whileTrue: [ number := 10 * number + (stream next greaseInteger - 48) ].	negated ifTrue: [ number := number negated ].	^ 10 raisedTo: number</body><body package="Seaside-JSON-Core">parseNumberFraction	| number power |	number := 0.	power := 1.0.	[ stream atEnd not and: [ stream peek isDigit ] ] whileTrue: [		number := 10 * number + (stream next greaseInteger - 48).		power := power * 10.0 ].	^ number / power</body><body package="Seaside-JSON-Core">parseNumberInteger	| number |	number := 0.	[ stream atEnd not and: [ stream peek isDigit ] ]		whileTrue: [ number := 10 * number + (stream next greaseInteger - 48) ].	^ number</body><body package="Seaside-JSON-Core">parseProperty	| name value |	name := self parseString.	self expectChar: $:.	value := self parseValue.	^ self createProperty: name with: value</body><body package="Seaside-JSON-Core">parseString	| result |	self expectChar: $".	result := WriteStream on: String new.	[ stream atEnd or: [ stream peek = $" ] ] 		whileFalse: [ result nextPut: self parseCharacter ].	^ self expectChar: $"; createString: result contents</body></methods><methods><class-id>Seaside.WAJsonParser</class-id> <category>adding</category><body package="Seaside-JSON-Core">addProperty: anAssociation to: anObject	"Add the property anAssociation described with key and value to anObject. Subclasses might want to refine this implementation."		^ anObject 		add: anAssociation;		yourself</body><body package="Seaside-JSON-Core">addValue: anObject to: aCollection	"Add anObject to aCollection. Subclasses might want to refine this implementation."	^ aCollection copyWith: anObject</body></methods><methods><class-id>Seaside.WAJsonParser</class-id> <category>parsing</category><body package="Seaside-JSON-Core">parse	| result |	result := self whitespace; parseValue.	self whitespace.	stream atEnd		ifFalse: [ self error: 'end of input expected' ].	^ result</body><body package="Seaside-JSON-Core">parseArray	| result |	self expectChar: $[.	result := self createArray.	(self matchChar: $])		ifTrue: [ ^ result ].	[ stream atEnd ] whileFalse: [		result := self			addValue: self parseValue			to: result.		(self matchChar: $]) 			ifTrue: [ ^ result ].		self expectChar: $, ].	self error: 'end of array expected'</body><body package="Seaside-JSON-Core">parseObject	| result |	self expectChar: ${.	result := self createObject.	(self matchChar: $})		ifTrue: [ ^ result ].	[ stream atEnd ] whileFalse: [		result := self			addProperty: self parseProperty			to: result.		(self matchChar: $})			ifTrue: [ ^ result ].		self expectChar: $, ].	self error: 'end of object expected'</body><body package="Seaside-JSON-Core">parseValue	stream atEnd ifFalse: [ 		| char |		self whitespace.		char := stream peek.		char = ${			ifTrue: [ ^ self parseObject ].		char = $[			ifTrue: [ ^ self parseArray ].		char = $"			ifTrue: [ ^ self parseString ].		(char = $- or: [ char between: $0 and: $9 ])			ifTrue: [ ^ self parseNumber ].		(char = $t)			ifTrue: [ self match: 'true' ifTrue: [ ^ self createTrue ] ].		(char = $f)			ifTrue: [ self match: 'false' ifTrue: [ ^ self createFalse ] ].		(char = $n)			ifTrue: [ self match: 'null' ifTrue: [ ^ self createNull ] ] ].	self error: 'invalid input'</body></methods><methods><class-id>Seaside.WAJsonParser</class-id> <category>private</category><body package="Seaside-JSON-Core">error: aString	"Raise a parse error labelled aString."	^ WAJsonSyntaxError signal: aString</body><body package="Seaside-JSON-Core">expectChar: aChar	"Expects aChar and consume input, throw an error otherwise."	^ (self matchChar: aChar) ifFalse: [ self error: aChar greaseString, ' expected' ]</body><body package="Seaside-JSON-Core">match: aString ifTrue: aBlock	" Tries to match the string, consume input and answer the value of the block if true."	self whitespace.	aString do: [ :each |		(stream atEnd or: [ each ~= stream next ]) ifTrue: [ self error: aString , ' expected' ] ].	aBlock value</body><body package="Seaside-JSON-Core">matchChar: aChar	" Tries to match the character, consume input and answer true if successful."	self whitespace.	(stream atEnd or: [ stream peek ~= aChar ]) ifTrue: [ ^ false ].	stream next.	^ true</body><body package="Seaside-JSON-Core">whitespace	"Strip whitespaces from the input stream."	[ stream atEnd not and: [ stream peek isSeparator ] ]		whileTrue: [ stream next ]</body></methods><methods><class-id>Seaside.WAJsonParser</class-id> <category>initialization</category><body package="Seaside-JSON-Core">initializeOn: aStream	self initialize.	stream := aStream</body></methods><methods><class-id>Seaside.WAJsonParser class</class-id> <category>instance creation</category><body package="Seaside-JSON-Core">new	self error: 'Instantiate the parser with a stream.'</body><body package="Seaside-JSON-Core">on: aStream	^ self basicNew initializeOn: aStream</body></methods><methods><class-id>Seaside.WAJsonParser class</class-id> <category>accessing</category><body package="Seaside-JSON-Core">parse: aString	^ self parseStream: aString readStream</body><body package="Seaside-JSON-Core">parseStream: aStream	^ (self on: aStream) parse</body></methods><methods><class-id>Seaside.WAJsonCanvas</class-id> <category>public</category><body package="Seaside-JSON-Core">array: aBlock	^ (self brush: WAJsonArrayBrush new) with: aBlock</body><body package="Seaside-JSON-Core">key: aKeyString value: aValueObject	^ (self brush: (WAJsonKeyValueBrush key: aKeyString)) with: aValueObject</body><body package="Seaside-JSON-Core">nextPut: aCharacter 	self document nextPut: aCharacter</body><body package="Seaside-JSON-Core">object: aBlock	^ (self brush: WAJsonObjectBrush new) with: aBlock</body><body package="Seaside-JSON-Core">render: anObject	self flush.	anObject jsonOn: self</body><body package="Seaside-JSON-Core">value: aBlock	^ (self brush: WAJsonValueBrush new) with: aBlock</body></methods><methods><class-id>Seaside.WAJsonCanvas</class-id> <category>private</category><body package="Seaside-JSON-Core">nest: aBlock	first := true.	super nest: aBlock.	first := false</body><body package="Seaside-JSON-Core">writeIfNotFirst: aString	first ifFalse: [		self document nextPutAll: aString ]</body></methods><methods><class-id>Seaside.WAJsonCanvas</class-id> <category>double-disptach</category><body package="Seaside-JSON-Core">boolean: aBoolean	self document stream nextPutAll: (aBoolean ifTrue: [ 'true' ] ifFalse: [ 'false' ])</body><body package="Seaside-JSON-Core">dateAndTime: aDateAndTime	" Note: date and time is not standard json. So we use the ISO 8601 standard here. We convert to string to make it valid json "	self document stream nextPut: $".	aDateAndTime printOn: self document stream.	self document stream nextPut: $"</body><body package="Seaside-JSON-Core">null	self document stream nextPutAll: 'null'</body><body package="Seaside-JSON-Core">number: aNumber	aNumber printOn: self document stream</body><body package="Seaside-JSON-Core">string: aString	self document string: aString</body></methods><methods><class-id>Seaside.WAJsonCanvas</class-id> <category>initialization</category><body package="Seaside-JSON-Core">initializeWithContext: aRenderContext	super initializeWithContext: aRenderContext.	first := true</body></methods><methods><class-id>Seaside.WAJsonCanvas class</class-id> <category>instance creation</category><body package="Seaside-JSON-Core">builder	^ (WABuilder on: self)		documentClass: WAJsonDocument;		yourself</body></methods><methods><class-id>Seaside.WAJsonObjectBrush</class-id> <category>private</category><body package="Seaside-JSON-Core">closeBrush	self document closeObject</body><body package="Seaside-JSON-Core">openBrush	canvas writeIfNotFirst: ', '.	self document openObject</body></methods><methods><class-id>Seaside.WAJsonEncoder</class-id> <category>accessing</category><body package="Seaside-JSON-Core">nextPut: aCharacter 	| index encoded |	index := aCharacter greaseInteger + 1.	index &gt; table size ifTrue: [		stream nextPut: aCharacter.		^ self ].	encoded := table at: index.	"Issue 482: use #notNil because it is faster than #isString because it is not actually sent"	encoded notNil		ifTrue: [ stream nextPutAll: encoded ]		ifFalse: [ stream nextPut: aCharacter ]</body></methods><methods><class-id>Seaside.WAJsonEncoder class</class-id> <category>initialization</category><body package="Seaside-JSON-Core">initialize	self initializeTable</body><body package="Seaside-JSON-Core">initializeTable	| printer escapes |	printer := GRNumberPrinter new.	printer base: 16; padding: $0; digits: 4.	table := Array new: self maximumCharacterValue + 1.	"write control characters"	0 to: 31 do: [ :index | 		table 			at: index + 1			put: '\u', (printer print: index) ].	"overwrite named (control) characters"	escapes := #( 8 '\b' 9 '\t' 10 '\n' 12 '\f' 13 '\r' 34 '\"' 92 '\\' ).	1 to: escapes size - 1 by: 2 do: [ :index | 		table 			at: (escapes at: index) + 1			put: (escapes at: index + 1) ]</body></methods><methods><class-id>Seaside.WAJsonEncoder class</class-id> <category>private</category><body package="Seaside-JSON-Core">maximumCharacterValue	"Everything higher is safe."		^ 16r7F</body></methods><methods><class-id>Seaside.WAJsonKeyValueBrush</class-id> <category>initialization</category><body package="Seaside-JSON-Core">initializeWithKey: aString	self initialize.	key := aString</body></methods><methods><class-id>Seaside.WAJsonKeyValueBrush</class-id> <category>private</category><body package="Seaside-JSON-Core">openBrush	super openBrush.	key jsonOn: canvas.	self document stream nextPutAll: ': '</body></methods><methods><class-id>Seaside.WAJsonKeyValueBrush class</class-id> <category>instance creation</category><body package="Seaside-JSON-Core">key: aString	^ self basicNew initializeWithKey: aString</body></methods><methods><class-id>Seaside.WAJsonArrayBrush</class-id> <category>private</category><body package="Seaside-JSON-Core">closeBrush	self document closeArray</body><body package="Seaside-JSON-Core">openBrush	self document openArray</body></methods><methods><class-id>Seaside.WAUrl</class-id> <category>*seaside-json-core</category><body package="Seaside-JSON-Core">jsonOn: aRenderer	aRenderer string: self printString</body></methods><methods><class-id>Core.Integer</class-id> <category>*seaside-json-core</category><body package="Seaside-JSON-Core">jsonOn: aRenderer	aRenderer number: self</body></methods><methods><class-id>Core.String</class-id> <category>*seaside-json-core</category><body package="Seaside-JSON-Core">jsonOn: aRenderer	aRenderer string: self</body></methods><methods><class-id>Core.Collection</class-id> <category>*seaside-json-core</category><body package="Seaside-JSON-Core">jsonOn: aRenderer 	aRenderer array: [		self do: [ :each |			aRenderer value: each ] ]</body></methods><methods><class-id>Core.Object</class-id> <category>*seaside-json-core</category><body package="Seaside-JSON-Core">asJson	^ WAJsonCanvas builder render: [ :json |		self jsonOn: json ]</body><body package="Seaside-JSON-Core">jsonOn: aRenderer	self error: 'Override #jsonOn: to make the receiver serializeable as JSON'</body></methods><methods><class-id>Core.Character</class-id> <category>*seaside-json-core</category><body package="Seaside-JSON-Core">jsonOn: aRenderer	aRenderer string: (String with: self)</body></methods><methods><class-id>Grease.GRPackage class</class-id> <category>*seaside-json-core</category><body package="Seaside-JSON-Core">seasideJsonCore	^ self new		name: 'Seaside-JSON-Core';		description: 'JSON integration in Seaside. Provides a basic functionality to generate JSON from Smalltalk.';		addDependency: 'Seaside-Core';		addDependency: 'Seaside-Canvas';		url: #seasideUrl;		yourself</body></methods><methods><class-id>Core.Dictionary</class-id> <category>*seaside-json-core</category><body package="Seaside-JSON-Core">jsonOn: aRenderer	aRenderer object: [		self keysAndValuesDo: [ :key :value |			aRenderer key: key value: value ] ]</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>*seaside-json-core</category><body package="Seaside-JSON-Core">jsonOn: aRenderer	aRenderer null</body></methods><methods><class-id>Core.Boolean</class-id> <category>*seaside-json-core</category><body package="Seaside-JSON-Core">jsonOn: aRenderer	aRenderer boolean: self</body></methods><methods><class-id>Grease.DateAndTime</class-id> <category>*seaside-json-core</category><body package="Seaside-JSON-Core">jsonOn: aRenderer	aRenderer dateAndTime: self</body></methods><methods><class-id>Grease.GRSmallDictionary</class-id> <category>*seaside-json-core</category><body package="Seaside-JSON-Core">jsonOn: aRenderer	aRenderer object: [		self keysAndValuesDo: [ :key :value |			aRenderer key: key value: value ] ]</body></methods><methods><class-id>Grease.GRDelegatingStream</class-id> <category>*seaside-json-core</category><body package="Seaside-JSON-Core">json: anObject	| document context canvas |	document := WAJsonDocument on: self.	context := WARenderContext new		actionUrl: WAUrl new;		document: document;		yourself.	canvas := WAJsonCanvas context: context.	canvas render: anObject.	document close</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>*seaside-json-core</category><body package="Seaside-JSON-Core">jsonOn: aRenderer	self numArgs = 0		ifTrue: [ self value ]		ifFalse: [ self value: aRenderer ]</body></methods><methods><class-id>Core.Float</class-id> <category>*seaside-json-core</category><body package="Seaside-JSON-Core">jsonOn: aRenderer	(self - self) = 0.0 "check for infinity, negative infinity and NaN"		ifTrue: [ aRenderer number: self ]		ifFalse: [ aRenderer null ]</body></methods><methods><class-id>Core.Stream</class-id> <category>*seaside-json-core</category><body package="Seaside-JSON-Core">json: anObject	| document context canvas |	document := WAJsonDocument on: self.	context := WARenderContext new		actionUrl: WAUrl new;		document: document;		yourself.	canvas := WAJsonCanvas context: context.	canvas render: anObject.	document close</body></methods><methods><class-id>Grease.GRPlatform</class-id> <category>*seaside-json-core</category><body package="Seaside-JSON-Core">jsonEncoderOn: aStream	"Answer an JSON encoder that works on aStream.	Platforms may provide optimized implementations."	^ WAJsonEncoder on: aStream</body></methods><initialize><class-id>Seaside.WAJsonEncoder</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>WAError</name><environment>Seaside</environment><super>Grease.GRError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Exceptions</category><attributes><package>Seaside-Core</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>GRDelegatingStream</name><environment>Grease</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><class><name>Float</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>WAObject</name><environment>Seaside</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core</category><attributes><package>Seaside-Core</package></attributes></class><class><name>GRPlatform</name><environment>Grease</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core</category><attributes><package>Grease-Core</package></attributes></class><class><name>WAUrl</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scheme user password host port path slash queryFields fragment pathParameters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WADocument</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream root </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WACanvas</name><environment>Seaside</environment><super>Seaside.WARenderer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentBrush parentBrush </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Canvas</category><attributes><package>Seaside-Canvas</package></attributes></class><class><name>WATableBasedEncoder</name><environment>Seaside</environment><super>Seaside.WAEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>table </inst-vars><class-inst-vars>table </class-inst-vars><imports></imports><category>Seaside-Core-Document</category><attributes><package>Seaside-Core</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>GRSmallDictionary</name><environment>Grease</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>size keys values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Collections</category><attributes><package>Grease-Core</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>WABrush</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>canvas parent closed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Canvas</category><attributes><package>Seaside-Canvas</package></attributes></class><class><name>DateAndTime</name><environment>Grease</environment><super>Core.Timestamp</super><private>false</private><indexed-type>none</indexed-type><inst-vars>offset </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Grease-VisualWorks-Core</package></attributes></class></st-source>