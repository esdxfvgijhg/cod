<?xml version="1.0"?><st-source><!-- Name: Seaside-GlorpNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: This package provides glue to connect Seaside and Glorp, as well as transparent support for database connection pooling.DescriptionProvides class GlorpFilter to automatically associate a database session (Glorp) with a Seaside session, for the duration of the Seaside session. This, combined with the GlorpActiveRecord and WriteBarriers (which are automatically loaded as prerequisites) adds an easy-to-use persistence facility for Seaside applications. To better manage database resources, this package also includes class VWPoolingDatabaseAccessor, which provides support for connection pooling.UsageYourSeasideComponent class>>initialize	"self initialize"	| application |	application := self registerAsApplication: 'GlorpExample'.	application configuration addParent: GlorpConfiguration instanceYourSeasideComponent>>renderOn: html	| glorpSession |	(glorpSession := self session glorpSession)		ifNil: [html text: 'Database not configured for use']		ifNotNil: [html text: 'Database ready to go!']	...The connection pooling feature may also be used with any Glorp application, simply by instantiating VWPoolingDatabaseAccessor to create an accessor object. The accessor is intended to be maintained as application state, and used when new sessions are created. In this case, rather than using #sessionForLogin: to create a session, you should build the session object like this:	(session := GlorpSession new) accessor: poolingAccessor.	session system: MyDescriptorSystem	...ImplementationThe functionality in ths package is based on work by Ramon Leon. For details, see the class comments for GlorpResource and VWPoolingDatabaseAccessor.DbIdentifier: bear73DbTrace: 492601DbUsername: jkottDbVersion: 3.2.0 - 1DevelopmentPrerequisites: #(#(#any 'Database' '') #(#any 'Glorp' '') #(#any 'GlorpVWPort' '') #(#any 'GlorpVWPortNonBase' '') #(#any 'Seaside-Core' '') #(#any 'Seaside-Session' ''))PackageName: Seaside-GlorpParcel: #('Seaside-Glorp')PrerequisiteDescriptions: #(#(#name 'Database' #componentType #package) #(#name 'Glorp' #componentType #bundle) #(#name 'GlorpVWPort' #componentType #package) #(#name 'GlorpVWPortNonBase' #componentType #package) #(#name 'Seaside-Core' #componentType #package) #(#name 'Seaside-Session' #componentType #package))PrerequisiteParcels: #(#('Database' '') #('Glorp' '') #('GlorpVWPort' '') #('GlorpVWPortNonBase' '') #('Seaside-Core' '') #('Seaside-Session' ''))PrintStringCache: (3.2.0 - 1,jkott)Version: 3.2.0 - 1Date: 3:31:29 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:31:29 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>GlorpDescriptorConfiguration</name><environment>Glorp</environment><super>Seaside.WASystemConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Seaside-Glorp</package></attributes></class><class><name>GlorpFilter</name><environment>Glorp</environment><super>Seaside.WARequestFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseSession </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Seaside-Glorp</package></attributes></class><comment><class-id>Glorp.GlorpFilter</class-id><body>Provides a session filter for Seaside components that use Glorp to access a database. The Glorp session is maintained for the duration of the Seaside session.UsageTo use a GlorpResource for a Seaside component configure the component with a GlorpConfiguration instance. Once it is configured you can call "self session glorpSession" to acquire a session to interacting with the database during rendering or callbacks.To configure your component, use the Seaside configuration page or register your component as shown below.YourSeasideComponent class&gt;&gt;initialize	"self initialize"	| application |	application := self registerAsApplication: 'GlorpExample'.	application configuration addParent: GlorpConfiguration new.If you need to access the resource object from a Seaside component, use:	self session glorpSessionInstance Variables:	databaseSession	&lt;GlorpSession&gt;	a Glorp session for a database</body></comment><class><name>ConnectionPool</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>queue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MagritteGlorp</category><attributes><package>Seaside-Glorp</package></attributes></class><comment><class-id>Glorp.ConnectionPool</class-id><body>ConnectionPool maintains a queue of connections to a database. Used by VWPoolingDatabaseAccessor to maintain a connection pool for a Glorp session. Pool is not bounded. Unconnected connections are dropped from the pool.Instance Variables:	queue	&lt;SharedQueue&gt; queue of connections to a database</body></comment><class><name>VWPoolingDatabaseAccessor</name><environment>Glorp</environment><super>Glorp.VWDatabaseAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pendingCommands </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>Seaside-Glorp</package></attributes></class><comment><class-id>Glorp.VWPoolingDatabaseAccessor</class-id><body>VWPoolingDatabaseAccessor is a Glorp DatabaseAccessor that pools connections to the database.DescriptionThis class automatically maintains a pool of connections to the database, creating them as needed. There is no bound on the number of connections in the pool.ImplementationNew connections are created on the fly on an 'as needed' basis. The connections are released when the accessor is told to #logout. This gives us a high-water mark for connections to our database and may need to be capped to an upper limit at some point in the future.Pooled connections are held in the shared variable PoolsByLogin, a Dictionary which holds a ConnectionPool object for each Login. To do some work, a connection is drawn from the ConnectionPool. When a connection is taken from the pool, it is put back immediately after the command it was drawn for has completed. However, if the command returns a cursor or is inside a transaction, the connection is kept until the cursor is released or the transaction is completed.Cursors are managed by the pendingCommands collection, where the query is saved until #completedCommand: is called, where the pendingCommand is removed from the collection and the connection is released if we're not inside a transaction.Instance Variables:	pendingCommands	&lt;OrderedCollection&gt; pending database commandsShared Class Variables:	PoolsByLogin	&lt;Dictionary key: Login value: ConnectionPool&gt; connection pool registry</body></comment><class><name>GlorpConfiguration</name><environment>Glorp</environment><super>Seaside.WASystemConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Seaside-Glorp</package></attributes></class><comment><class-id>Glorp.GlorpConfiguration</class-id><body>Defines attributes needed for a component to use GlorpFilter. These attributes are optional, they can also be pulled from the Package that the application being initialized for is in. The configuration options here override the package options.</body></comment><class><name>GlorpSQLite3Configuration</name><environment>Glorp</environment><super>Glorp.GlorpConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Seaside-Glorp</package></attributes></class><comment><class-id>Glorp.GlorpSQLite3Configuration</class-id><body>GlorpSQLite3Configuration defines attributes needed to connect to SQLite3 DB</body></comment><class><name>GlorpOracleConfiguration</name><environment>Glorp</environment><super>Glorp.GlorpConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Seaside-Glorp</package></attributes></class><comment><class-id>Glorp.GlorpOracleConfiguration</class-id><body>Defines attributes needed to connect to Oracle DB</body></comment><class><name>GlorpPostgresConfiguration</name><environment>Glorp</environment><super>Glorp.GlorpConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Seaside-Glorp</package></attributes></class><comment><class-id>Glorp.GlorpPostgresConfiguration</class-id><body>Defines attributes needed to connect to Postgresql DB</body></comment><class><name>GlorpMySqlConfiguration</name><environment>Glorp</environment><super>Glorp.GlorpConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Seaside-Glorp</package></attributes></class><comment><class-id>Glorp.GlorpMySqlConfiguration</class-id><body>Defines attributes needed to connect to MySQL DB</body></comment><class><name>PlainPasswordAttribute</name><environment>Seaside</environment><super>Seaside.WAPasswordAttribute</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Seaside-Glorp</package></attributes></class><comment><class-id>Seaside.PlainPasswordAttribute</class-id><body>PlainPasswordAttribute is used to represent configuration attributes that are passwords but are not to return a hashed value from a string.</body></comment><shared-variable><name>PoolsByLogin</name><environment>Glorp.VWPoolingDatabaseAccessor</environment><private>false</private><constant>false</constant><category>pooling</category><initializer>Dictionary new</initializer><attributes><package>Seaside-Glorp</package></attributes></shared-variable><methods><class-id>Glorp.GlorpDescriptorConfiguration</class-id> <category>description</category><body package="Seaside-Glorp">describeOn: config	(config list: #glorpDescriptorSystem)		label: 'Descriptor System';		options: [DescriptorSystem allSubclasses];		comment: 'Glorp DescriptorSystem class that defines the database mappings for this connection';		group: #mapping.</body></methods><methods><class-id>Glorp.GlorpFilter</class-id> <category>processing</category><body package="Seaside-Glorp">configureActiveRecord	(#{Glorp.ActiveRecords.ActiveRecord} valueOrDo: [^self]) setSession: databaseSession</body><body package="Seaside-Glorp">handleFiltered: aRequestContext	self configureActiveRecord.	super handleFiltered: aRequestContext</body></methods><methods><class-id>Glorp.GlorpFilter</class-id> <category>api</category><body package="Seaside-Glorp">databaseSession	^databaseSession</body><body package="Seaside-Glorp">setupSession	| configuration login accessor |	databaseSession := nil.	configuration := self application configuration.	(login := configuration glorpLogin) ifNil: [^self].	accessor := VWPoolingDatabaseAccessor forLogin: login.	databaseSession := GlorpSession new		accessor: accessor;		system: (configuration glorpDescriptorSystem forPlatform: accessor platform);		useModificationTracker;		yourself</body></methods><methods><class-id>Glorp.ConnectionPool</class-id> <category>accessing</category><body package="Seaside-Glorp">addConnection: aConnection 	queue nextPut: aConnection</body><body package="Seaside-Glorp">nextAvailableConnection	| connection |		[(connection := queue nextAvailable) isNil] 			whileFalse: 				[(connection isConnected and: 						["postgres-specific hack"						(connection respondsTo: #connection) not 							or: [connection connection isActive]]) 					ifTrue: [^connection]].	^nil</body></methods><methods><class-id>Glorp.ConnectionPool</class-id> <category>printing</category><body package="Seaside-Glorp">printOn: aStream 	super printOn: aStream.	aStream		nextPutAll: ' (';		print: queue size;		nextPutAll: ' available)'</body></methods><methods><class-id>Glorp.ConnectionPool</class-id> <category>initialize-release</category><body package="Seaside-Glorp">initialize	queue := SharedQueue new</body></methods><methods><class-id>Glorp.ConnectionPool class</class-id> <category>instance creation</category><body package="Seaside-Glorp">new	^super new initialize</body></methods><methods><class-id>Glorp.VWPoolingDatabaseAccessor</class-id> <category>login</category><body package="Seaside-Glorp">isLoggedIn	^true</body><body package="Seaside-Glorp">login	currentLogin database class == UndefinedObject ifTrue: [^false].	currentLogin connectString ifNil: [^false].	currentLogin username ifNil: [^false].	self loginIfError: [:ex | ^false].	^true</body><body package="Seaside-Glorp">logout	self releaseConnection</body><body package="Seaside-Glorp">reLogin	self releaseConnection</body></methods><methods><class-id>Glorp.VWPoolingDatabaseAccessor</class-id> <category>transactions</category><body package="Seaside-Glorp">beginTransaction	self acquireConnection.	^super beginTransaction</body><body package="Seaside-Glorp">commitTransaction	[super commitTransaction] ensure: [self releaseConnection]</body><body package="Seaside-Glorp">isInTransaction	^connection notNil and: [super isInTransaction]</body><body package="Seaside-Glorp">rollbackTransaction	[super rollbackTransaction] ensure: [self releaseConnection]</body></methods><methods><class-id>Glorp.VWPoolingDatabaseAccessor</class-id> <category>pooling</category><body package="Seaside-Glorp">acquireConnection	self acquireConnectionIfError: [:error | error pass]</body><body package="Seaside-Glorp">acquireConnectionIfError: errorBlock	connection ifNotNil: [^self].	connection := self pool nextAvailableConnection ifNil: [super loginIfError: errorBlock. connection]."	self log: 'Acquired connection from pool'"</body><body package="Seaside-Glorp">connectWhile: aBlock 	| wasConnected |	wasConnected := connection notNil.	self acquireConnection.	^aBlock ensure: [wasConnected ifFalse: [self releaseConnection]]</body><body package="Seaside-Glorp">pool	^PoolsByLogin at: currentLogin ifAbsentPut: [ConnectionPool new]</body><body package="Seaside-Glorp">releaseConnection	connection ifNil: [^self].	connection inTransactionMode ifTrue: ["self log: 'releaseConncetion&gt;&gt;rollback'." connection rollback].	self pool addConnection: connection.	connection := nil."	self log: 'Released connection to pool'"</body></methods><methods><class-id>Glorp.VWPoolingDatabaseAccessor</class-id> <category>executing</category><body package="Seaside-Glorp">basicExecuteSQLString: aString returnResult: returnResult binding: aBindingArray doing: aBlock 	^self connectWhile: 			[super 				basicExecuteSQLString: aString				returnResult: returnResult				binding: aBindingArray				doing: aBlock]</body><body package="Seaside-Glorp">disconnect	self reset</body><body package="Seaside-Glorp">executeCommand: aCommand inDBSession: aSession	self acquireConnection.	self beginCommand: aCommand.	^super executeCommand: aCommand inDBSession: aSession</body><body package="Seaside-Glorp">executeSQLStringNoResult: aString doing: aBlock forCommand: aCommand	"Because we know we're not returning a result here, finish the command immediately rather than waiting for the cursor to do it when it finishes (because there is no cursor)."	| result |	self beginCommand: aCommand.	result := super executeSQLStringNoResult: aString doing: aBlock forCommand: aCommand.	self completedCommand: aCommand.	^result.</body><body package="Seaside-Glorp">externalDatabaseErrorSignal	^self connectionClass externalDatabaseErrorSignal</body></methods><methods><class-id>Glorp.VWPoolingDatabaseAccessor</class-id> <category>cursors</category><body package="Seaside-Glorp">beginCommand: aCommand	(self pendingCommands includes: aCommand) ifTrue: [^self]."	self log: 'beginCommand: ', aCommand printString."	self pendingCommands add: aCommand</body><body package="Seaside-Glorp">completedCommand: aCommand	"Indicate that we've completed the command. Release associated resources.	If aCommand is nil, assume that it is a post INSERT query to learn the IDENTITY value."	aCommand ifNotNil: [		pendingCommands remove: aCommand ifAbsent: [self error: 'Attempting to complete a command that wasn''t listed as incomplete. This really shouldn''t happen']].	pendingCommands isEmpty		ifFalse: ["self log: 'completedCommand: -- ', pendingCommands size printString, ' remaining'"]		ifTrue:			["self log: 'completedCommand'."			self isInTransaction ifTrue: [^self].			self releaseConnection].</body><body package="Seaside-Glorp">cursorFor: answerStream command: aCommand	self beginCommand: aCommand.	^super cursorFor: answerStream command: aCommand.</body></methods><methods><class-id>Glorp.VWPoolingDatabaseAccessor</class-id> <category>accessing</category><body package="Seaside-Glorp">createSession"	self log: 'createSession'."	self acquireConnection.	^super createSession</body><body package="Seaside-Glorp">createSessionFor: aCommand 	^self connectWhile: [super createSessionFor: aCommand]</body><body package="Seaside-Glorp">encoding	^self connectWhile: [super encoding]</body><body package="Seaside-Glorp">pendingCommands	pendingCommands isNil ifTrue: [pendingCommands := OrderedCollection new].	^pendingCommands.</body></methods><methods><class-id>Glorp.VWPoolingDatabaseAccessor</class-id> <category>initialize</category><body package="Seaside-Glorp">reset	super reset.	self releaseConnection</body></methods><methods><class-id>Glorp.VWPoolingDatabaseAccessor class</class-id> <category>instance creation</category><body package="Seaside-Glorp">forLogin: aLogin	^self new currentLogin: aLogin</body></methods><methods><class-id>Glorp.VWPoolingDatabaseAccessor class</class-id> <category>class initialization</category><body package="Seaside-Glorp">initialize	PoolsByLogin := Dictionary new</body></methods><methods><class-id>Glorp.GlorpConfiguration</class-id> <category>testing</category><body package="Seaside-Glorp">isGlorpConfiguration	^true</body></methods><methods><class-id>Glorp.GlorpConfiguration</class-id> <category>description</category><body package="Seaside-Glorp">describeOn: config	(config list: #glorpDescriptorSystem)		label: 'Descriptor System';		options: [DescriptorSystem allSubclasses];		comment: 'Glorp DescriptorSystem class that defines the database mappings for this connection';		group: #database.	(config list: #glorpDatabasePlatform)		label: 'Database Platform';		options: [DatabasePlatform allSubclasses];		comment: 'Type of database connection - OraclePlatform, PostgreSQLPlatform etc';		group: #database.	(config string: #databaseServer)		label: 'Address';		comment: 'host:port, port not needed in default port for the database';		group: #database.	(config string: #databaseName)		label: 'Name';		comment: 'Name of the database to connect to';		group: #database.	(config string: #databaseSchema)		label: 'Schema';		comment: 'Schema in the database to connect to';		group: #database.	(config string: #databaseUsername)		label: 'Username';		comment: 'Username to login as';		group: #database.	(config plainPassword: #databasePassword)		label: 'Password';		comment: 'Password to login with';		group: #database</body><body package="Seaside-Glorp">glorpDatabasePlatform	^self class glorpDatabasePlatform</body></methods><methods><class-id>Glorp.GlorpConfiguration class</class-id> <category>accessing</category><body package="Seaside-Glorp">configurationFor: aClass	^self subclasses detect: [ :each | each glorpDatabasePlatform = aClass ] ifNone: [ nil ]</body><body package="Seaside-Glorp">glorpDatabasePlatform	^self subclassResponsibility</body></methods><methods><class-id>Glorp.GlorpSQLite3Configuration</class-id> <category>description</category><body package="Seaside-Glorp">describeOn: config	(config list: #glorpDatabasePlatform)		label: 'Database Platform';		default: self glorpDatabasePlatform;		options: [OrderedCollection with: self glorpDatabasePlatform ];		comment: 'Type of database connection - SQLite3Platform';		group: #database.	(config string: #databaseServer)		" SQLite only uses filenames, Reflect the fact in the label and the comment. "		label: 'Filename';		comment: 'The name of the database file.';		group: #database.</body></methods><methods><class-id>Glorp.GlorpSQLite3Configuration class</class-id> <category>accessing</category><body package="Seaside-Glorp">glorpDatabasePlatform	^Glorp.SQLite3Platform</body></methods><methods><class-id>Glorp.GlorpOracleConfiguration</class-id> <category>description</category><body package="Seaside-Glorp">describeOn: config	(config list: #glorpDatabasePlatform)		label: 'Database Platform';		default: self glorpDatabasePlatform;		options: [OrderedCollection with: self glorpDatabasePlatform ];		comment: 'Type of database connection - OraclePlatform';		group: #database.	(config string: #databaseServer)		label: 'Address';		comment: 'host:port, port not needed in default port for the database';		group: #database.	(config string: #databaseSchema)		label: 'Schema';		comment: 'Schema in the database to connect to';		group: #database.	(config string: #databaseUsername)		label: 'Username';		comment: 'Username to login as';		group: #database.	(config plainPassword: #databasePassword)		label: 'Password';		comment: 'Password to login with';		group: #database</body></methods><methods><class-id>Glorp.GlorpOracleConfiguration class</class-id> <category>accessing</category><body package="Seaside-Glorp">glorpDatabasePlatform	^Glorp.OraclePlatform</body></methods><methods><class-id>Glorp.GlorpPostgresConfiguration</class-id> <category>description</category><body package="Seaside-Glorp">describeOn: config	(config list: #glorpDatabasePlatform)		label: 'Database Platform';		default: self glorpDatabasePlatform;		options: [OrderedCollection with: self glorpDatabasePlatform ];		comment: 'Type of database connection - PostgreSQLPlatform';		group: #database.	(config string: #databaseServer)		label: 'Address';		comment: 'host:port, port not needed in default port for the database';		group: #database.	(config string: #databaseName)		label: 'Name';		comment: 'Name of the database to connect to';		group: #database.	(config string: #databaseSchema)		label: 'Schema';		comment: 'Schema in the database to connect to';		group: #database.	(config string: #databaseUsername)		label: 'Username';		comment: 'Username to login as';		group: #database.	(config plainPassword: #databasePassword)		label: 'Password';		comment: 'Password to login with';		group: #database</body></methods><methods><class-id>Glorp.GlorpPostgresConfiguration class</class-id> <category>accessing</category><body package="Seaside-Glorp">glorpDatabasePlatform	^Glorp.PostgreSQLPlatform</body></methods><methods><class-id>Glorp.GlorpMySqlConfiguration</class-id> <category>description</category><body package="Seaside-Glorp">describeOn: config	(config list: #glorpDatabasePlatform)		label: 'Database Platform';		default: self glorpDatabasePlatform;		options: [OrderedCollection with: self glorpDatabasePlatform ];		comment: 'Type of database connection -MySQL';		group: #database.	(config string: #databaseServer)		label: 'Address';		comment: 'host:port, port not needed in default port for the database';		group: #database.	(config string: #databaseSchema)		label: 'Schema';		comment: 'Schema in the database to connect to';		group: #database.	(config string: #databaseUsername)		label: 'Username';		comment: 'Username to login as';		group: #database.	(config plainPassword: #databasePassword)		label: 'Password';		comment: 'Password to login with';		group: #database</body></methods><methods><class-id>Glorp.GlorpMySqlConfiguration class</class-id> <category>accessing</category><body package="Seaside-Glorp">glorpDatabasePlatform	^Glorp.MySQLPlatform</body></methods><methods><class-id>Seaside.PlainPasswordAttribute</class-id> <category>converting</category><body package="Seaside-Glorp">valueFromString: aString	" Do not hash the value, do as WAStringAttribute would do. "	^ aString isEmptyOrNil ifFalse: [ aString ]</body></methods><methods><class-id>Seaside.WASession</class-id> <category>accessing</category><body package="Seaside-Glorp">databaseSession	"We'd prefer you used #glorpSession now."	^self glorpSession</body><body package="Seaside-Glorp">glorpFilterIfAbsent: absentBlock	^self filters		detect: [:each | each isKindOf: Glorp.GlorpFilter]		ifNone: absentBlock</body><body package="Seaside-Glorp">glorpSession	^(self glorpFilterIfAbsent: [self addFilter: Glorp.GlorpFilter new setupSession]) databaseSession</body></methods><methods><class-id>Seaside.WASession</class-id> <category>parent/child</category><body package="Seaside-Glorp">unregistered	super unregistered.	"If we have a glorp filter set up, make sure we clean it up now that this session is dead."	(self glorpFilterIfAbsent: [^self]) databaseSession		logout;		reset</body></methods><methods><class-id>Seaside.WAConfiguration</class-id> <category>accessing</category><body package="Seaside-Glorp">glorpLogin	^nil</body></methods><methods><class-id>Seaside.WAConfiguration</class-id> <category>testing</category><body package="Seaside-Glorp">hasGlorpConfiguration	^false</body></methods><methods><class-id>Seaside.WAConfigurationDescription</class-id> <category>attribute creation</category><body package="Seaside-Glorp">plainPassword: aSymbol	^self addAttribute: (PlainPasswordAttribute key: aSymbol)</body></methods><methods><class-id>Seaside.WAUserConfiguration</class-id> <category>database attributes</category><body package="Seaside-Glorp">glorpCurrentSchema	^[self at: #glorpDescriptorSystem] on: WAAttributeNotFound do: [ :ex | nil]</body><body package="Seaside-Glorp">glorpCurrentSchema: aClass	self  glorpCurrentSchema  ~~  aClass 		ifTrue: [aClass 					ifNil: [self  removeExpressionAt:  #glorpDescriptorSystem ]					ifNotNil: [self  at: #glorpDescriptorSystem put: aClass ]].</body><body package="Seaside-Glorp">glorpCurrentSchemaName	^self  glorpCurrentSchema ifNotNil: [ :aclass | aclass fullName ]</body><body package="Seaside-Glorp">glorpDatabaseName	^[self  at:  #databaseName ] on: WAAttributeNotFound do: [ :ex | nil ].</body><body package="Seaside-Glorp">glorpDatabaseName: aString	(self  at:  #databaseName) ~=  aString 		ifTrue: [aString 					ifNil: [self  removeExpressionAt:  #databaseName ]					ifNotNil: [self  at:  #databaseName put: aString ]].</body><body package="Seaside-Glorp">glorpDatabaseServer	^[self at: #databaseServer ] on: WAAttributeNotFound do: [ :ex | nil]</body><body package="Seaside-Glorp">glorpDatabaseServer: aString	(self  at:  #databaseServer) ~=  aString 		ifTrue: [aString 					ifNil: [self  removeExpressionAt:   #databaseServer  ]					ifNotNil: [self  at:  #databaseServer put: aString ]].</body></methods><methods><class-id>Seaside.WAUserConfiguration</class-id> <category>accessing</category><body package="Seaside-Glorp">glorpDescriptorSystem	^self glorpCurrentSchema ifNil: [Glorp.DescriptorSystem]</body><body package="Seaside-Glorp">glorpLogin	^ self glorpLoginDatabaseClass ifNotNil: [ : dbClass |		Glorp.Login new			database: dbClass new;			connectString: self glorpLoginConnectString;			schema: self glorpLoginSchema;			username: self glorpLoginUsername;			password: self glorpLoginPassword;			yourself ]</body></methods><methods><class-id>Seaside.WAUserConfiguration</class-id> <category>database attributes</category><body package="Seaside-Glorp">glorpLoginConnectString	| server |	(server := self glorpDatabaseServer) ifNil: [ ^nil].	(self glorpDatabaseName) ifNotNil: [ :dbname | ^server, '_',dbname ].	^server</body><body package="Seaside-Glorp">glorpLoginConnectString: aString	| server databaseName |	aString		ifNil: [nil]		ifNotNil: [ :connectStringx |  | dbIndex |				(dbIndex := connectStringx indexOf: $_)  = 0 					ifTrue: [server := connectStringx]					ifFalse: [server := connectStringx copyFrom: 1 to: dbIndex - 1.							databaseName := connectStringx copyFrom: dbIndex + 1 to: connectStringx size. ]].	self  glorpDatabaseServer: server.	self glorpDatabaseName: databaseName.</body><body package="Seaside-Glorp">glorpLoginDatabaseClass	^[self  at: #glorpDatabasePlatform] on: WAAttributeNotFound do: [ :ex | ^nil]</body><body package="Seaside-Glorp">glorpLoginDatabaseClass: aClass	(self  at:  #glorpDatabasePlatform) ~=  aClass 		ifTrue: [aClass 					ifNil: [self  removeExpressionAt:  #glorpDatabasePlatform ]					ifNotNil: [self  at:  #glorpDatabasePlatform put: aClass ]].</body><body package="Seaside-Glorp">glorpLoginDatabaseClassName	^self glorpLoginDatabaseClass  ifNil: [''] ifNotNil: [ :aclass | aclass  fullName]</body><body package="Seaside-Glorp">glorpLoginPassword	^[self  at: #databasePassword ] on: WAAttributeNotFound do: [ :ex | nil]</body><body package="Seaside-Glorp">glorpLoginPassword: aString	(self  at:  #databasePassword) ~=  aString 		ifTrue: [aString 					ifNil: [self  removeExpressionAt:  #databasePassword ]					ifNotNil: [self  at:  #databasePassword put: aString ]].</body><body package="Seaside-Glorp">glorpLoginSchema	^[self at: #databaseSchema] on: WAAttributeNotFound do: [ :ex | nil]</body><body package="Seaside-Glorp">glorpLoginSchema: aString	(self  at:  #databaseSchema) ~=  aString 		ifTrue: [aString 					ifNil: [self  removeExpressionAt:   #databaseSchema ]					ifNotNil: [self  at:  #databaseSchema put: aString ]].</body><body package="Seaside-Glorp">glorpLoginUsername	^[self  at: #databaseUsername ] on: WAAttributeNotFound do: [ :ex | nil]</body><body package="Seaside-Glorp">glorpLoginUsername: aString	(self  at:  #databaseUsername) ~=  aString 		ifTrue: [aString 					ifNil: [self  removeExpressionAt:  #databaseUsername ]					ifNotNil: [self  at:  #databaseUsername put: aString ]].</body></methods><methods><class-id>Seaside.WAUserConfiguration</class-id> <category>testing</category><body package="Seaside-Glorp">hasGlorpConfiguration	^self parents anySatisfy: [ :each | each isGlorpConfiguration or: [ each hasGlorpConfiguration ] ]</body></methods><initialize><class-id>Glorp.VWPoolingDatabaseAccessor</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>WARequestFilter</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>next </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Filter</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAConfiguration</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cachedSearchContexts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAUserConfiguration</name><environment>Seaside</environment><super>Seaside.WAConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expressions parents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAConfigurationDescription</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attributes expressions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WASystemConfiguration</name><environment>Seaside</environment><super>Seaside.WAConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>description </inst-vars><class-inst-vars>instance </class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAPasswordAttribute</name><environment>Seaside</environment><super>Seaside.WAAttribute</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><class><name>VWDatabaseAccessor</name><environment>Glorp</environment><super>Glorp.DatabaseAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>driverSession preparedStatements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-VW3</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>WASession</name><environment>Seaside</environment><super>Seaside.WARequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>continuations properties documentHandlers key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Session</category><attributes><package>Seaside-Session</package></attributes></class></st-source>