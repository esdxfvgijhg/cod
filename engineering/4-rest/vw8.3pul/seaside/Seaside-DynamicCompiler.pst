<?xml version="1.0"?><st-source><!-- Name: Seaside-DynamicCompilerNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: This package makes it easy to include raw CSS on WAComponents and raw CSS and Javascript on WAFileLibrary subclasses. It uses DynamicCompiler to apply acceptance of JS and CSS methods.DbIdentifier: bear73DbTrace: 492602DbUsername: jkottDbVersion: 3.2.0 - 1DevelopmentPrerequisites: #(#(#any 'Seaside-Namespace' '') #(#any 'Seaside-Core' '') #(#any 'Seaside-Component' ''))ExplicitPrerequisites: #()IgnoredPrerequisites: #()Library: truePackageName: Seaside-DynamicCompilerParcel: #('Seaside-DynamicCompiler')PrerequisiteDescriptions: #(#(#name 'Seaside-Namespace' #componentType #package) #(#name 'Seaside-Core' #componentType #package) #(#name 'Seaside-Component' #componentType #package))PrerequisiteParcels: #(#('Seaside-Namespace' '') #('Seaside-Core' '') #('Seaside-Component' ''))PrintStringCache: (3.2.0 - 1,jkott)Version: 3.2.0 - 1Date: 3:31:29 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:31:29 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DynamicParser</name><environment>Seaside</environment><super>Kernel.Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Seaside-DynamicCompiler</package></attributes></class><comment><class-id>Seaside.DynamicParser</class-id><body>DynamicParser switches between its subclasses based on whether the subclass can parse the string presented to it. It changes its parser type dynamically so you can simply set #parserClass on the class side of your class to ^DynamicParser and it will then work.Subclasses must implement #canParse: on the class side.</body></comment><class><name>DynamicCompiler</name><environment>Seaside</environment><super>Kernel.Compiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Seaside-DynamicCompiler</package></attributes></class><comment><class-id>Seaside.DynamicCompiler</class-id><body>DynamicCompiler switches between its subclasses based on whether the subclass can compiler the string presented to it. It changes its compiler type dynamically so you can simply set #compilerClass on the class side of your class to ^DynamicCompiler and it will then work.Subclasses must implement #canCompile: on the class side.</body></comment><class><name>CSSParser</name><environment>Seaside</environment><super>Seaside.DynamicParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Seaside-DynamicCompiler</package></attributes></class><class><name>JavascriptParser</name><environment>Seaside</environment><super>Seaside.DynamicParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Seaside-DynamicCompiler</package></attributes></class><comment><class-id>Seaside.JavascriptParser</class-id><body>CSSParser is a DynamicParser from the DynamicCompilers package which identifies that a snippit of code is actually a CSS rule or rules. You can use this by implementing #parserClass on the class side of your class and returning ^DynamicParser. The existance of this class in the image gives dynamic compilers the capability to recognize CSS.The compiler method will have a pragma on it of #css so you can identify that the method is a CSS method. The compiled method will return the CSS as a string.An example method you can write with this dynamic parser:.myClass #myId:hover, .myClass #myId:visited {	background-color: green;	color: yellow}This parser is a dumb parser, it merely parse the signature of a CSS rule(s) and does not currently check the for syntax correctness in the body of the method.</body></comment><methods><class-id>Seaside.DynamicParser</class-id> <category>private</category><body package="Seaside-DynamicCompiler">changeParser	| parserClass sourceCode |	sourceCode := source contents.	parserClass := self class allSubclasses detect: [:each | each canParse: sourceCode] ifNone: [^self].	self changeClassTo: parserClass</body></methods><methods><class-id>Seaside.DynamicParser</class-id> <category>initialize-release</category><body package="Seaside-DynamicCompiler">on: inputStream 	super on: inputStream.	self changeParser</body></methods><methods><class-id>Seaside.DynamicParser class</class-id> <category>testing</category><body package="Seaside-DynamicCompiler">canParse: source	^false</body></methods><methods><class-id>Seaside.DynamicCompiler</class-id> <category>private</category><body package="Seaside-DynamicCompiler">changeCompiler	| compilerClass sourceCode |	sourceCode := sourceStream contents.	compilerClass := self class allSubclasses detect: [:each | each canCompile: sourceCode] ifNone: [^self].	self changeClassTo: compilerClass</body><body package="Seaside-DynamicCompiler">from: textOrStream class: aClass context: aContext notifying: req 	super from: textOrStream class: aClass context: aContext notifying: req.	self changeCompiler</body></methods><methods><class-id>Seaside.DynamicCompiler class</class-id> <category>testing</category><body package="Seaside-DynamicCompiler">canCompile: source	^false</body></methods><methods><class-id>Seaside.CSSParser</class-id> <category>expression types-success/error</category><body package="Seaside-DynamicCompiler">statement	| literal return |	(literal := LiteralNode new) value: source contents.	(return := ReturnNode new) value: literal.	parseNode := builder newBlockArguments: #() body: return</body></methods><methods><class-id>Seaside.CSSParser</class-id> <category>expression types-^value/error</category><body package="Seaside-DynamicCompiler">method: fromDoIt context: ctxt 	"pattern [ | temporaries ] block =&gt; MethodNode"	| methodNode |	methodNode := builder newMethodSelector: self pattern first.	self statement.	methodNode block: parseNode.	methodNode sourcePosition: (1 to: source contents size).	methodNode addAttributeMessage: (Message selector: #css).	^methodNode</body><body package="Seaside-DynamicCompiler">pattern	"unarySelector | binarySelector arg | keyword arg {keyword arg} =&gt; 	{selector, arguments}"	| selector |	token isString		ifTrue: [selector := token]		ifFalse: [selector := String with: token].	self scanToken.	[tokenType == #leftBrace]		whileFalse: 			[token ifNil: [^Array with: selector asSymbol with: #()].			token isString				ifTrue: [selector := selector , token]				ifFalse: [selector := selector copyWith: token].			self scanToken].	^Array with: selector asSymbol with: #()</body></methods><methods><class-id>Seaside.CSSParser class</class-id> <category>testing</category><body package="Seaside-DynamicCompiler">canParse: source"	word &lt;more&gt; {	.word &lt;more&gt; {	#word &lt;more&gt; {	... so we look for &lt;any&gt; { but without any ( unless backtracks as ':' word '('"	| sourceStream signature bits |	sourceStream := (self filterStrings: source) readStream.	signature := sourceStream upTo: ${.	sourceStream atEnd ifTrue: [^false].	(signature occurrencesOf: Character cr) &lt; 2 ifFalse: [^false].	"... now look for blatently not css characters ^ and ' "	((signature includes: $^) or: [signature includes: $']) ifTrue: [^false].	"... now we look for :word or :word("	(signature includes: $:) ifFalse: [^(signature includes: $() not].	bits := signature tokensBasedOn: $:.	bits removeFirst.	^bits allSatisfy: [:each |		| words |		words := each runsSatisfying: [:e | e isAlphabetic or: [e = $-]].		words notEmpty and: [#('first-child' 'link' 'visited' 'active' 'hover' 'focus' 'lang' 'not') includes: words first]]</body><body package="Seaside-DynamicCompiler">filterStrings: source	| stream output quoted escaped |	stream := source readStream.	output := String new writeStream.	quoted := false.	escaped := false.	[stream atEnd] whileFalse:		[ | next |		next := stream next.		(next = $\ and: [escaped not])			ifTrue: [escaped := true]			ifFalse:				[escaped ifFalse:					[quoted ifFalse: [output nextPut: next].					next = $" ifTrue: [quoted ifTrue: [output nextPut: $"]. quoted := quoted not]].				escaped := false]].	^output contents</body></methods><methods><class-id>Seaside.JavascriptParser</class-id> <category>expression types-^value/error</category><body package="Seaside-DynamicCompiler">method: fromDoIt context: ctxt 	"pattern [ | temporaries ] block =&gt; MethodNode"	| methodNode |	methodNode := builder newMethodSelector: self pattern first.	self statement.	methodNode block: parseNode.	methodNode sourcePosition: (1 to: source contents size).	methodNode addAttributeMessage: (Message selector: #javascript).	(self findSenders: source contents readStream) do: [:selector | methodNode addAttributeMessage: (Message selector: selector asSymbol)].	^methodNode</body><body package="Seaside-DynamicCompiler">pattern	"unarySelector | binarySelector arg | keyword arg {keyword arg} =&gt; 	{selector, arguments}"	| selector |	(tokenType == #keyword or: [tokenType == #word]) ifFalse: [^self expected: (#MessagePattern &lt;&lt; #dialogs &gt;&gt; 'Message pattern')].	selector := token.	self scanToken.	[tokenType == #keyword]		whileTrue: 			[hereChar == $=				ifTrue:					[source position: mark-1.					self scan: source.					^Array with: selector asSymbol with: #()]				ifFalse:					[selector := selector , token.					self scanToken]].	^Array with: (selector copyWithout: $:) asSymbol with: #()</body></methods><methods><class-id>Seaside.JavascriptParser</class-id> <category>expression types-success/error</category><body package="Seaside-DynamicCompiler">statement	| literal return |	(literal := LiteralNode new) value: source contents.	(return := ReturnNode new) value: literal.	parseNode := builder newBlockArguments: #() body: return</body></methods><methods><class-id>Seaside.JavascriptParser</class-id> <category>finding senders</category><body package="Seaside-DynamicCompiler">addSelectors: selectors on: stream	selectors add: (self nextSelector: stream).	[stream peek = $.] whileTrue: [stream next. selectors add: (self nextSelector: stream)]</body><body package="Seaside-DynamicCompiler">findSenders: stream	| senders |	senders := Set new.	[stream atEnd] whileFalse:		[(stream peek: 2) = '/*' ifTrue: [stream next: 2. self skipComment: stream].		(stream peek: 2) = '//' ifTrue: [stream upTo: Character cr].		stream peek = $' ifTrue: [stream next. self skipString: stream].		stream peek = $" ifTrue: [stream next. self skipString: stream].		(stream peek: 5) = 'this.'			ifTrue: [stream next: 5. (self addSelectors: senders on: stream)]			ifFalse: [stream next]].	senders remove: '' ifAbsent: [].	^senders</body><body package="Seaside-DynamicCompiler">nextSelector: stream	| result |	result := String new writeStream.	[stream atEnd not and: [stream peek isAlphaNumeric or: [stream peek = $_]]] whileTrue: [result nextPut: stream next].	^result contents</body><body package="Seaside-DynamicCompiler">skipComment: stream	| depth |	depth := 1.	[stream atEnd] whileFalse:		[(stream peek: 2) = '/*' ifTrue: [depth := depth + 1. stream next].		(stream peek: 2) = '*/' ifTrue: [depth := depth - 1. stream next].		stream next.		depth isZero ifTrue: [^self]]</body><body package="Seaside-DynamicCompiler">skipString: stream	| end escape |	end := (stream collection at: stream position).	escape := String with: $\ with: end.	[stream atEnd] whileFalse:		[(stream peek: 2) = escape ifTrue: [stream next: 2].		stream next = end ifTrue: [^self]]</body></methods><methods><class-id>Seaside.JavascriptParser class</class-id> <category>testing</category><body package="Seaside-DynamicCompiler">canParse: source"	word() {	word(...) {	word: function() {	word: function(...) {	word: {	... so we look for word ':' &lt;s&gt; {	... or we look for word ')' &lt;s&gt; {"	| sourceStream signature stream front tail |	sourceStream := source readStream.	signature := sourceStream upTo: ${.	sourceStream atEnd ifTrue: [^false].	stream := signature readStream.	(signature includes: $:) ifTrue:		[front := stream upTo: $:.		stream skipSeparators.		(stream atEnd not and: [(stream nextAvailable: 9) asLowercase ~= 'function(']) ifTrue: [^false].		tail := stream upToEnd].	(signature includes: $)) ifTrue:		[front := stream upTo: $).		tail := stream upToEnd].	front ifNil: [^false].	(front includes: Character cr) ifTrue: [^false].	^tail readStream skipSeparators atEnd</body></methods><methods><class-id>Core.PeekableStream</class-id> <category>character reading</category><body package="Seaside-DynamicCompiler">peek: anInteger	| result |	[result := self nextAvailable: anInteger] ensure:		[self skip: result size negated].	^result</body></methods><methods><class-id>Core.Object</class-id> <category>private</category><body package="Seaside-DynamicCompiler">aggregatePragmas: keyword	| stream |	stream := String new writeStream.	(Pragma allNamed: keyword in: self class)		do: [:pragma | stream nextPutAll: (self perform: pragma selector)]		separatedBy: [stream cr; cr].	^stream contents</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>PeekableStream</name><environment>Core</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Compiler</name><environment>Kernel</environment><super>Kernel.SmalltalkCompiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class><class><name>Parser</name><environment>Kernel</environment><super>Kernel.Scanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder requestor oldLanguage newLanguage extendedLanguage parseNode failBlock endTemps targetClass environment topEnvironment bindingRefs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class></st-source>