<?xml version="1.0"?><st-source><!-- Name: Seaside-SessionComment: Support for stateful and secure session handling.DbIdentifier: bear73DbTrace: 492579DbUsername: jkottDbVersion: 3.2.0 - JohanBrichau.186 1DevelopmentPrerequisites: #(#(#any 'Seaside-Namespace' '') #(#any 'Seaside-Core' '') #(#any 'Seaside-VisualWorks-Core' ''))Id: 5a0ac26c-0204-412d-b3df-1afb88014dafNamespace: SeasidePackageName: Seaside-SessionParcel: #('Seaside-Session')ParcelName: Seaside-SessionPrerequisiteParcels: #(#('Seaside-Namespace' '') #('Seaside-Core' '') #('Seaside-VisualWorks-Core' ''))PrintStringCache: (3.2.0 - JohanBrichau.186 1,jkott)Url: http://smalltalkhub.com/mc/Seaside/Seaside32/main/Seaside-Session-JohanBrichau.186.mczVersion: 3.2.0 - JohanBrichau.186 1Date: 3:31:27 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:31:27 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WASessionTrackingStrategy</name><environment>Seaside</environment><super>Seaside.WAHandlerTrackingStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Session</category><attributes><package>Seaside-Session</package></attributes></class><comment><class-id>Seaside.WASessionTrackingStrategy</class-id><body>I am the abstract base class for tracking strategies that track sessions differently from other request handlers (mostly WADocumentHandlers).Concrete implementsions have to take care that expired document handlers don't expire sessions.</body></comment><class><name>WACookieForBrowserIPForCrawlerTrackingStrategy</name><environment>Seaside</environment><super>Seaside.WASessionTrackingStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cookieStrategy ipStrategy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Session</category><attributes><package>Seaside-Session</package></attributes></class><comment><class-id>Seaside.WACookieForBrowserIPForCrawlerTrackingStrategy</class-id><body>WACookieForBrowserIPForCrawlerTrackingStrategy uses cookie based session tracking for browsers and IPs for crawlers (they don't support cookies). This way there is never a session key in any URL.This is inspired by:http://www.tomcatexpert.com/blog/2011/05/18/crawler-session-manager-valve</body></comment><class><name>WASession</name><environment>Seaside</environment><super>Seaside.WARequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>continuations properties documentHandlers key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Session</category><attributes><package>Seaside-Session</package></attributes></class><comment><class-id>Seaside.WASession</class-id><body>I am a Seaside session. A new instance of me gets created when an user accesses an application for the first time and is persistent as long as the user is interacting with it.This class is intended to be subclasses by applications that need global state, like a user. Custom state can be added by creating instance variables and storing it there. The session can be retrieved by #session if inside a component or task or by evaluating: WACurrentRequestContext sessionIf the session has not been used for #defaultTimeoutSeconds, it is garbage collected by the system. To manually expire a session call #expire.A good way to clear all sessions is the following code:WARegistry clearAllHandlers.WAPlatform current garbageCollect</body></comment><class><name>WASessionContinuation</name><environment>Seaside</environment><super>Seaside.WARequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>states </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Session</category><attributes><package>Seaside-Session</package></attributes></class><comment><class-id>Seaside.WASessionContinuation</class-id><body>I represent a continuation as part of the flow of pages within a session. I am not a real continuation (as compared to those used in #call: and #answer:), I only represent a specific point in the session. I reference the root component and a memory snapshot of backtracked objects.</body></comment><class><name>WACookieSessionTrackingStrategy</name><environment>Seaside</environment><super>Seaside.WASessionTrackingStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Session</category><attributes><package>Seaside-Session</package></attributes></class><comment><class-id>Seaside.WACookieSessionTrackingStrategy</class-id><body>I am the abstract base class for tracking strategies that use cookies to track sessions and query fields to track everything else.</body></comment><class><name>WAInvisibleSessionTrackingStrategy</name><environment>Seaside</environment><super>Seaside.WASessionTrackingStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Session</category><attributes><package>Seaside-Session</package></attributes></class><comment><class-id>Seaside.WAInvisibleSessionTrackingStrategy</class-id><body>I am the abstract base class for classes that that use some request attribute that is present on every request for tracking sessions. For document handlers query fields are used.</body></comment><class><name>WASslSessionTrackingStrategy</name><environment>Seaside</environment><super>Seaside.WAInvisibleSessionTrackingStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Session</category><attributes><package>Seaside-Session</package></attributes></class><comment><class-id>Seaside.WASslSessionTrackingStrategy</class-id><body>I track sessions using the SSL session id. This has the advantage that the session id never shows up in the request as a parameter or cookie.Special server configuration to set the life time of an SSL session may be required.http://www.roseindia.net/javacertification/ibm-287/http_sessions.shtmlhttp://publib.boulder.ibm.com/infocenter/iseries/v5r4/index.jsp?topic=%2Frzatz%2F51%2Fprogram%2Fsesdeci.htmhttp://en.wikipedia.org/wiki/Session_fixation#Solution:_Utilize_SSL_.2F_TLS_Session_identifier</body></comment><class><name>WAIPSessionTrackingStrategy</name><environment>Seaside</environment><super>Seaside.WAInvisibleSessionTrackingStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Session</category><attributes><package>Seaside-Session</package></attributes></class><comment><class-id>Seaside.WAIPSessionTrackingStrategy</class-id><body>I track sessions using the remote address of a client. Usually you don't want to use this because it causes troubles when multiple users share the same IP (eg. several users from the same company). That's why I'm marked as abstract.There are some special cases like crawlers where it can work though.</body></comment><class><name>WAApplication</name><environment>Seaside</environment><super>Seaside.WARegistry</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Session</category><attributes><package>Seaside-Session</package></attributes></class><comment><class-id>Seaside.WAApplication</class-id><body>WAApplication is the starting point for a Seaside application. When a WAComponent is registered as a top level component a WAApplication object is added to a WADispatcher. The dispatcher forwards all requests to the WAApplication, which in turn forwards them to the correct WASession object. WAApplication's parent class WARegistry maintains a list of all active sessions to the application. "configuration" contains a chain of WAConfituration classes that define attributes of the application. The attribute "rootComponent", for example, defines the top level WAComponent class for the application. The configuration chain includes WAUserConfiguration, WAGlobalConfiguration, WARenderLoopConfiguration and WASessionConfiguration. Other configurations can be added to the chain when the top level application is registered with a dispatcher. (See below)"libraries" is a collection of WALibrary classes, which are used to serve css, javascript and images used by the application. These may be in methods or in files. Sometimes these libraries are replaced by static files served by Apache. See WAFileLibrary class comment for more information.Registering an Application.	An application can be registered with a dispatcher by using the Seaside configuration page or via code. Below MyComponent is a subclass of WAComponent. The following registers the component as an application, gives some values to attributes (or preferences) and adds a library and a configuration. MyComponent class&gt;&gt;initialize	"self initialize"	| application |	application := self registerAsApplication: 'sample'.	application preferenceAt: #sessionClass put: Glorp.WAGlorpSession.	application addLibrary: SampleLibrary.	application configuration addAncestor: GlorpConfiguration new.	application preferenceAt: #glorpDatabasePlatform put: Glorp.PostgreSQLPlatform.	application preferenceAt: #databaseServer put: '127.0.0.1'.	application preferenceAt: #databaseConnectString put: 'glorptests'.MyComponent&gt;&gt;someInstanceMethod	"example of how to access attributes (preferences)"	self session application preferenceAt: #glorpDatabasePlatform</body></comment><class><name>WANullSessionContinuation</name><environment>Seaside</environment><super>Seaside.WASessionContinuation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Session</category><attributes><package>Seaside-Session</package></attributes></class><class><name>WAApplicationConfiguration</name><environment>Seaside</environment><super>Seaside.WASystemConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Session</category><attributes><package>Seaside-Session</package></attributes></class><comment><class-id>Seaside.WAApplicationConfiguration</class-id><body>WAApplicationConfiguration defines attributes required by WAApplication. All applications should include this configuration (this is done by default for new applications).See #addAttributes: for details on provided attributes.</body></comment><class><name>WAMutualExclusionFilter</name><environment>Seaside</environment><super>Seaside.WARequestFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mutex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Session-Filter</category><attributes><package>Seaside-Session</package></attributes></class><class><name>WACookieOnlySessionTrackingStrategy</name><environment>Seaside</environment><super>Seaside.WACookieSessionTrackingStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Session</category><attributes><package>Seaside-Session</package></attributes></class><comment><class-id>Seaside.WACookieOnlySessionTrackingStrategy</class-id><body>I track sessions using cookies and everything else using query fields. This works fine as long as the client accepts cookies. This breaks for web crawlers (they don't accept cookies).</body></comment><class><name>WACookieIfSupportedSessionTrackingStrategy</name><environment>Seaside</environment><super>Seaside.WACookieSessionTrackingStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Session</category><attributes><package>Seaside-Session</package></attributes></class><comment><class-id>Seaside.WACookieIfSupportedSessionTrackingStrategy</class-id><body>I use cookies to track sessions if the browser supports it and use query fields (?_s=key) otherwise. I keep adding the session cookie and the session query field until the session cookie shows up in the request. Then I stop adding the query field.</body></comment><methods><class-id>Seaside.WASessionTrackingStrategy class</class-id> <category>testing</category><body package="Seaside-Session">isAbstract	^ self name = #WASessionTrackingStrategy</body></methods><methods><class-id>Seaside.WACookieForBrowserIPForCrawlerTrackingStrategy</class-id> <category>public</category><body package="Seaside-Session">addKey: aString toContext: aRequestContext	^ (self strategyFor: aRequestContext)		addKey: aString toContext: aRequestContext</body><body package="Seaside-Session">addKey: aString toUrl: aUrl	^ (self strategyFor: WACurrentRequestContext value)		addKey: aString toUrl: aUrl</body><body package="Seaside-Session">keyFromContext: aRequestContext	^ (self strategyFor: aRequestContext)		keyFromContext: aRequestContext</body><body package="Seaside-Session">noHandlerFoundForKey: aString in: anApplication context: aRequestContext	^ (self strategyFor: aRequestContext)		noHandlerFoundForKey: aString in: anApplication context: aRequestContext</body></methods><methods><class-id>Seaside.WACookieForBrowserIPForCrawlerTrackingStrategy</class-id> <category>private</category><body package="Seaside-Session">crawlerSubStrings	^ #(		'bot'		'Bot'		'Yahoo! Slurp'		'Feedfetcher-Google'	)</body><body package="Seaside-Session">isFromCrawler: aRequestContext	| userAgent |	userAgent := aRequestContext request userAgent.	^ userAgent notNil and: [ self crawlerSubStrings anySatisfy: [ :each |			(userAgent indexOfSubCollection: each) &gt; 0 ] ]</body><body package="Seaside-Session">strategyFor: aRequestContext	^ (self isFromCrawler: aRequestContext)		ifTrue: [ ipStrategy ]		ifFalse: [ cookieStrategy ]</body></methods><methods><class-id>Seaside.WACookieForBrowserIPForCrawlerTrackingStrategy</class-id> <category>initialization</category><body package="Seaside-Session">initialize	super initialize.	ipStrategy := WAIPSessionTrackingStrategy new.	cookieStrategy := WACookieOnlySessionTrackingStrategy new</body></methods><methods><class-id>Seaside.WASession</class-id> <category>accessing</category><body package="Seaside-Session">actionField	^ '_k'</body><body package="Seaside-Session">actionUrlForContinuation: aContinuation	^ self actionUrlForKey: (continuations store: (aContinuation setParent: self; yourself))</body><body package="Seaside-Session">actionUrlForKey: aString	^ self url		addField: self actionField value: aString;		yourself</body><body package="Seaside-Session">application	^ self parent</body><body package="Seaside-Session">cache	self greaseDeprecatedApi: 'WASession&gt;&gt;#cache' details: 'Use #documentHandlers instead.'.	^ self documentHandlers</body><body package="Seaside-Session">cache: aCache	self greaseDeprecatedApi: 'WASession&gt;&gt;#cache:' details: 'Use #documentHandlers: instead.'.	self documentHandlers: aCache</body><body package="Seaside-Session">documentHandlers	documentHandlers isNil ifTrue: [		documentHandlers := self createDocumentHandlerCache ].	^ documentHandlers</body><body package="Seaside-Session">documentHandlers: aCache	documentHandlers := aCache</body><body package="Seaside-Session">key	^ key</body><body package="Seaside-Session">key: aString	key := aString</body><body package="Seaside-Session">properties	"Answer a dictionary of session-related properties."	^ properties ifNil: [ properties := GRSmallDictionary new ]</body></methods><methods><class-id>Seaside.WASession</class-id> <category>handling</category><body package="Seaside-Session">handleFiltered: aRequestContext	| continationKey continuation fields documentHandlerKey |	fields := aRequestContext request fields.	documentHandlerKey := fields at: self documentHandlerFieldName ifAbsent: [ nil ].	documentHandlerKey isNil ifFalse: [		| documentHandler |		documentHandler := self documentHandlers at: documentHandlerKey ifAbsent: [ 			^ aRequestContext responseGenerator				notFound;				respond ].		^ documentHandler handle: aRequestContext ].		continationKey := fields		at: self actionField		ifAbsent: [ ^ self start ].			continuation := continuations		at: continationKey		ifAbsent: [ ^ self unknownRequest ].	continuation handle: aRequestContext</body><body package="Seaside-Session">start	self application initialContinuationClass new handle: self requestContext</body><body package="Seaside-Session">unknownRequest	^ self start</body></methods><methods><class-id>Seaside.WASession</class-id> <category>updating</category><body package="Seaside-Session">updateRoot: anHtmlRoot</body><body package="Seaside-Session">updateStates: aSnapshot	self filters do: [ :each | each updateStates: aSnapshot ].	aSnapshot register: filter</body><body package="Seaside-Session">updateUrl: aUrl</body></methods><methods><class-id>Seaside.WASession</class-id> <category>testing</category><body package="Seaside-Session">isSession	^ true</body></methods><methods><class-id>Seaside.WASession</class-id> <category>copying</category><body package="Seaside-Session">postCopy	super postCopy.	continuations := continuations copy</body></methods><methods><class-id>Seaside.WASession</class-id> <category>scripts</category><body package="Seaside-Session">jumpToAnchor: aString	| actionContinuation |	actionContinuation := self requestContext handlers		detect: [ :each | each isActionContinuation ]		ifNone: [ WAIllegalStateException signal: 'You can only send #jumpToAnchor: from within a callback' ].	actionContinuation jumpToAnchor: aString</body></methods><methods><class-id>Seaside.WASession</class-id> <category>private</category><body package="Seaside-Session">basicUrl	| url |	self isRoot		ifTrue: [ url := WAUrl new ]		ifFalse: [ 			url := self parent url.			self parent trackingStrategy addKey: key toUrl: url ].	^ url</body><body package="Seaside-Session">documentHandlerFieldName	^ '_d'</body></methods><methods><class-id>Seaside.WASession</class-id> <category>initialization</category><body package="Seaside-Session">createContinuationCache	"To configure the continuation cache you must currently subclass WASession and	override this method.	There is no need to use WABulkReapingCache for GemStone/S here because we're inside the session mutex."	^ WAHashCache		initialSize: 7		maximumSize: 20		maximumAbsoluteAge: 0		maximumRelativeAge: 0		overflowAction: WAHashCache removeRelativeOldest</body><body package="Seaside-Session">createDocumentHandlerCache	"No mutex necessary since we are inside the session mutex.	We don't expire document handlers"	^ WAUnidirectionalCache new</body><body package="Seaside-Session">initialize	super initialize.	self initializeFilters.	continuations := self createContinuationCache</body><body package="Seaside-Session">initializeFilters	self addFilter: (GRPlatform current createMutualExclusionFilter)</body></methods><methods><class-id>Seaside.WASession</class-id> <category>parent/child</category><body package="Seaside-Session">register: aDocumentHandler	| handlerKey |	handlerKey := self documentHandlers store: (aDocumentHandler setParent: self; yourself).	^ self basicUrl		addField: self documentHandlerFieldName value: handlerKey;		yourself</body><body package="Seaside-Session">unregister	parent unregisterAt: key</body></methods><methods><class-id>Seaside.WASessionContinuation</class-id> <category>accessing</category><body package="Seaside-Session">request	"Answer the current request object."	^ self requestContext request</body><body package="Seaside-Session">states	^ states ifNil: [ states := WASnapshot new ]</body></methods><methods><class-id>Seaside.WASessionContinuation</class-id> <category>private</category><body package="Seaside-Session">redirectToContinuation: aSessionContinuation	self respond: [ :response | response redirectTo: aSessionContinuation registerForUrl ]</body><body package="Seaside-Session">registerForUrl	^ self registerForUrl: true</body><body package="Seaside-Session">registerForUrl: aBoolean	| url |	url := self session actionUrlForContinuation: self.	aBoolean ifTrue: [ self updateUrl: url ].	^ url</body><body package="Seaside-Session">withUnregisteredHandlerDo: aBlock 	^ aBlock 		on: WAUnregisteredHandlerError		do: [ :err | self requestContext redirectTo: self application url ]</body></methods><methods><class-id>Seaside.WASessionContinuation</class-id> <category>updating</category><body package="Seaside-Session">updateStates: aSnapshot	self session updateStates: aSnapshot</body><body package="Seaside-Session">updateUrl: aUrl	self session updateUrl: aUrl</body></methods><methods><class-id>Seaside.WASessionContinuation</class-id> <category>processing</category><body package="Seaside-Session">captureState	"self states reset"	"Setting states to nil matches the behaviour of Seaside 2.8. Resetting the Snapshot	is useful for JS callbacks in that refreshing the page will show the modified state	but can also result in many ActionPhaseContinuations all sharing the same state	but with different callbacks, some of which may reference state that is no longer present."	states := nil.	self updateStates: self states</body><body package="Seaside-Session">respond: aBlock 	self requestContext respond: aBlock</body></methods><methods><class-id>Seaside.WASessionContinuation</class-id> <category>handling</category><body package="Seaside-Session">handle: aRequestContext	"Resume processing of a request. To ensure valid application state restore all registered states."	self states restore.	self withUnregisteredHandlerDo: [ super handle: aRequestContext ]</body></methods><methods><class-id>Seaside.WASessionContinuation</class-id> <category>initialization</category><body package="Seaside-Session">initializeWithSnapshot: aSnapshot	self initialize.	states := aSnapshot</body></methods><methods><class-id>Seaside.WASessionContinuation class</class-id> <category>instance creation</category><body package="Seaside-Session">new	^ self snapshot: self defaultSnapshot</body><body package="Seaside-Session">snapshot: aSnapshot	^ self basicNew		initializeWithSnapshot: aSnapshot;		yourself</body></methods><methods><class-id>Seaside.WASessionContinuation class</class-id> <category>private</category><body package="Seaside-Session">defaultSnapshot	^ WASnapshot new</body></methods><methods><class-id>Seaside.WASessionContinuation class</class-id> <category>testing</category><body package="Seaside-Session">isAbstract	^ self name = #WASessionContinuation</body></methods><methods><class-id>Seaside.WACookieSessionTrackingStrategy</class-id> <category>private</category><body package="Seaside-Session">addCookieWithValue: aString to: aRequestContext	"Create a new handler key cookie and att it to the response."		aRequestContext response addCookie: 		(aRequestContext newCookie			key: self keyCookieName;			value: aString;			discard: true;			comment: 'the Seaside Session Cookie';			commentUrl: 'http://www.seaside.st/documentation/sessionCookie';			yourself)</body><body package="Seaside-Session">cookieFromContext: aRequestContext ifAbsent: absentBlock	"Answer the handler key cookie. If none is found, return the result of evaluating absentBlock.	There can be several cookies with the correct key so we try to find the one with the most specific path."	| candidates requestUrl |	candidates := aRequestContext request cookiesAt: self keyCookieName.		candidates isEmptyOrNil		ifTrue: [ ^ absentBlock value ].	candidates size = 1 		ifTrue: [ ^ candidates first ].			requestUrl := aRequestContext request url.	candidates := candidates collect: [ :each |		each -&gt; (each path seasideUrl relativeTo: requestUrl) ].		candidates := candidates reject: [ :each |		| path |		path := each value.		path notEmpty and: [ path first = '..' ] ].	candidates isEmpty		ifTrue: [ ^ absentBlock value ].			candidates size &gt; 1 ifTrue: [		candidates sort: [ :a :b |			 a value size &lt;= b value size ] ].		^ candidates first key</body><body package="Seaside-Session">deleteSessionCookieOf: anApplication from: aRequestContext	| cookie baseUrl |	cookie := self cookieFromContext: aRequestContext ifAbsent: [ ^ self ].	baseUrl := anApplication url.	aRequestContext response 		deleteCookie: cookie		path:  baseUrl pathStringUnencoded		domain: baseUrl host</body><body package="Seaside-Session">keyCookieName	"Answer the name of the cookie to track the handler."		^ self keyField</body></methods><methods><class-id>Seaside.WACookieSessionTrackingStrategy</class-id> <category>public</category><body package="Seaside-Session">addKey: aString toContext: aRequestContext	| oldCookie |	oldCookie := self cookieFromContext: aRequestContext ifAbsent: [ nil ].	(oldCookie isNil or: [ oldCookie value ~= aString ]) ifTrue: [		"only add the cookie if we don't already have one or it has the wrong key"		self addCookieWithValue: aString to: aRequestContext ]</body><body package="Seaside-Session">keyFromContext: aRequestContext	"If a query field is present it overrides a cookie."	| key |	key := self queryFieldKeyFromContext: aRequestContext.	^ key isNil		ifTrue: [ (self cookieFromContext: aRequestContext ifAbsent: [ ^ nil ]) value ]		ifFalse: [ key ]</body></methods><methods><class-id>Seaside.WACookieSessionTrackingStrategy class</class-id> <category>testing</category><body package="Seaside-Session">isAbstract	^ self name = #WACookieSessionTrackingStrategy</body></methods><methods><class-id>Seaside.WAInvisibleSessionTrackingStrategy</class-id> <category>public</category><body package="Seaside-Session">addKey: aString toContext: aRequestContext	"The session id is already present, no need to add it."</body><body package="Seaside-Session">addKey: aString toUrl: aUrl	"The session id is already present, no need to add it."</body><body package="Seaside-Session">keyFromContext: aRequestContext	"If a query field is present it overrides a session id."	| key |	key := self queryFieldKeyFromContext: aRequestContext.	^ key isNil		ifTrue: [ self sessionIdFromContext: aRequestContext ]		ifFalse: [ key ]</body><body package="Seaside-Session">noHandlerFoundForKey: aString in: anApplication context: aRequestContext	aString = (self keyFromContext: aRequestContext)		ifTrue: [			"expired session, create a new session"			anApplication handleDefault: aRequestContext withKey: aString ]		ifFalse: [			"repired document handler, answer not found"			super noHandlerFoundForKey: aString in: anApplication context: aRequestContext ]</body></methods><methods><class-id>Seaside.WAInvisibleSessionTrackingStrategy</class-id> <category>private</category><body package="Seaside-Session">sessionIdFromContext: aRequestContext	 self subclassResponsibility</body></methods><methods><class-id>Seaside.WAInvisibleSessionTrackingStrategy class</class-id> <category>testing</category><body package="Seaside-Session">isAbstract	^ self name = #WAInvisibleSessionTrackingStrategy</body></methods><methods><class-id>Seaside.WASslSessionTrackingStrategy</class-id> <category>private</category><body package="Seaside-Session">sessionIdFromContext: aRequestContext	^ aRequestContext request sslSessionId</body></methods><methods><class-id>Seaside.WAIPSessionTrackingStrategy</class-id> <category>private</category><body package="Seaside-Session">remoteAddressFromRequest: aRequest	^ aRequest			headerAt: 'x-forwarded-for'			ifAbsent: [				aRequest					headerAt: 'forwarded-for'					ifAbsent: [ aRequest remoteAddress ] ]</body><body package="Seaside-Session">sessionIdFromContext: aRequestContext	^ self remoteAddressFromRequest: aRequestContext request</body></methods><methods><class-id>Seaside.WAIPSessionTrackingStrategy class</class-id> <category>testing</category><body package="Seaside-Session">isAbstract	^ true</body></methods><methods><class-id>Seaside.WAApplication</class-id> <category>configuration</category><body package="Seaside-Session">contentType	^ self mimeType seasideMimeType		charset: self requestContext charSet;		yourself</body><body package="Seaside-Session">defaultConfiguration	^ super defaultConfiguration		removeParent: WARegistryConfiguration instance;		addParent: WAApplicationConfiguration instance;		yourself</body><body package="Seaside-Session">mimeType	^ self preferenceAt: #mimeType</body><body package="Seaside-Session">resourceBaseUrl	^ self preferenceAt: #resourceBaseUrl</body><body package="Seaside-Session">rootClass: aComponentClass	self preferenceAt: #rootClass put: (GRPlatform current bindingOf: aComponentClass)</body><body package="Seaside-Session">sessionAllowTermination	^ self preferenceAt: #sessionAllowTermination</body><body package="Seaside-Session">sessionClass: aClass	^ self preferenceAt: #sessionClass put: (GRPlatform current bindingOf: aClass)</body></methods><methods><class-id>Seaside.WAApplication</class-id> <category>private</category><body package="Seaside-Session">handlePrefetch: aRequestContext	"Mozilla prefetches some &lt;link&gt; elements:	https://developer.mozilla.org/en/Link_prefetching_FAQ	This usally isn't a problem as long as they are used for style sheets.	It is however a problem when they are used for navigational 'Index', 'Next', and 'Prev'	See the following bug:	http://code.google.com/p/pier/issues/detail?id=132		Disabling has the disadvantage that we also disable prefech of things that would support prefetching	(like style sheets). However we don't recommend to have Seaside serving these in production.		We are not actually sure whether 403 Forbidden is the correct way to indicate that we don't support prefetching.	Ohter options would include:		- 412 Precondition Failed, user agent has to try different headers (seems fitting, however seems to be also about entity header)		- 405 Method Not Allowed, but this is about HTTP methods and we must send Allow containg the valid methods			We don't go through the response generator because the user will never see the response	so it doesn't make sense to customize the contents."	aRequestContext respond: [ :response |		response forbidden ]</body><body package="Seaside-Session">isImplemented: aString	"Answer whether the receiver implements the given HTTP method."	^ #('GET' 'POST') includes: aString</body><body package="Seaside-Session">newSession	"Create a new session which inherits our configuration."	^ self sessionClass new		configuration: (WAUserConfiguration new addParent: self configuration; yourself);		yourself</body></methods><methods><class-id>Seaside.WAApplication</class-id> <category>handling</category><body package="Seaside-Session">handleDefault: aRequestContext	self handle: aRequestContext registering: self newSession</body><body package="Seaside-Session">handleDefault: aRequestContext withKey: aKey	"starts a new session with the given key	Pay attention if the client can choose the key then you are vulnerable to session fixation attacks"	self handle: aRequestContext registering: self newSession at: aKey</body><body package="Seaside-Session">handleFiltered: aRequestContext 	"Seaside applications do not respond to prefetch requests and only understand GET and POST requests."		aRequestContext request isPrefetch 		ifTrue: [ self handlePrefetch: aRequestContext ]		ifFalse: [			(self isImplemented: aRequestContext request method)				ifTrue: [ super handleFiltered: aRequestContext ]				ifFalse: [					aRequestContext responseGenerator						notImplemented;						respond ] ]</body></methods><methods><class-id>Seaside.WAApplication</class-id> <category>testing</category><body package="Seaside-Session">isApplication	^ true</body></methods><methods><class-id>Seaside.WAApplication</class-id> <category>accessing</category><body package="Seaside-Session">sessions	| collection |	collection := OrderedCollection new.	self sessionsDo: [ :session | collection add: session ].	^ collection</body></methods><methods><class-id>Seaside.WAApplication</class-id> <category>enumerating</category><body package="Seaside-Session">sessionsDo: aBlock	self handlersDo: aBlock</body></methods><methods><class-id>Seaside.WAApplication</class-id> <category>libraries</category><body package="Seaside-Session">addLibrary: aLibraryClass	self		preferenceAt: #libraries		put: ((self preferenceAt: #libraries) copyWith: (GRPlatform current bindingOf: aLibraryClass))</body></methods><methods><class-id>Seaside.WAApplication</class-id> <category>parent/child</category><body package="Seaside-Session">register: aSession	| key |	key := super register: aSession.	aSession key: key.	^ key</body><body package="Seaside-Session">register: aSession at: aKey	super register: aSession at: aKey.	aSession key: aKey.	^ aKey</body></methods><methods><class-id>Seaside.WAApplication</class-id> <category>initialization</category><body package="Seaside-Session">createCache	^ GRPlatform current createSessionCacheForApplication: self</body></methods><methods><class-id>Seaside.WAApplication class</class-id> <category>accessing</category><body package="Seaside-Session">description	^ 'Application'</body></methods><methods><class-id>Seaside.WANullSessionContinuation</class-id> <category>handling</category><body package="Seaside-Session">handleFiltered: aRequestContext	"Do nothing"</body></methods><methods><class-id>Seaside.WAApplicationConfiguration</class-id> <category>description</category><body package="Seaside-Session">continuationClasses	^ (WASessionContinuation allSubclasses reject: [ :each | each isAbstract ])		asSortedCollection: [ :a :b | a name &lt;= b name ]</body><body package="Seaside-Session">describeOn: config	(config classBindingCollection: #libraries)		options: [ self libraryClasses ].	(config classBinding: #initialContinuationClass)		beAdvanced;		options: [ self continuationClasses ];		default: WANullSessionContinuation.	(config string: #mimeType)		beAdvanced;		label: 'MIME Type';		comment: 'The media type of HTML documents reported to the browser.';		default: 'text/html'.	(config url: #resourceBaseUrl)		group: #server;		comment: 'Sets the base URL for URLS generated with #resourceUrl:'.	(config boolean: #sessionAllowTermination)		comment: 'Whether sessions allows a special HTTP request to terminate the process currently running in the session. This is used during development and should be disabled for deployment.';		default: false.	(config classBinding: #sessionClass)		comment: 'Sessions in this application will be instances of this class.';		options: [ self sessionClasses ];		default: WASession.	(config listOfClasses: #trackingStrategy)		comment: 'How sessions and document handlers should be tracked.';		options: [ self trackingStrategyClasses ];		default: WAQueryFieldHandlerTrackingStrategy new</body><body package="Seaside-Session">libraryClasses	^ WAAbstractFileLibrary libraries asSortedCollection: [ :a :b | a name &lt;= b name ]</body><body package="Seaside-Session">sessionClasses	^ WASession withAllSubclasses asSortedCollection: [ :a :b | a name &lt;= b name ]</body><body package="Seaside-Session">trackingStrategyClasses	^ (WAHandlerTrackingStrategy allSubclasses reject: [ :each | each isAbstract ])		asSortedCollection: [ :a :b | a name &lt;= b name ]</body></methods><methods><class-id>Seaside.WAApplicationConfiguration</class-id> <category>ancestry</category><body package="Seaside-Session">parents	"Skip WARegistryConfiguration because we override #trackingStrategy. It doesn't work otherwise."	^ Array		with: WARequestHandlingConfiguration instance		with: WACacheConfiguration instance</body></methods><methods><class-id>Seaside.WAMutualExclusionFilter</class-id> <category>private</category><body package="Seaside-Session">shouldTerminate: aRequestContext	^ (aRequestContext request fields includesKey: 'terminate')		and: [ aRequestContext application preferenceAt: #sessionAllowTermination ]</body><body package="Seaside-Session">terminate: aRequestContext	mutex terminateOwner.	aRequestContext respond: [ :response |		response			contentType: WAMimeType textPlain;			nextPutAll: 'Process terminated' ]</body></methods><methods><class-id>Seaside.WAMutualExclusionFilter</class-id> <category>processing</category><body package="Seaside-Session">handleFiltered: aRequestContext	(self shouldTerminate: aRequestContext)		ifTrue: [ self terminate: aRequestContext ]		ifFalse: [ mutex critical: [ super handleFiltered: aRequestContext ] ]</body></methods><methods><class-id>Seaside.WAMutualExclusionFilter</class-id> <category>initialization</category><body package="Seaside-Session">initialize	super initialize.	mutex := WAMutex new</body></methods><methods><class-id>Seaside.WACookieOnlySessionTrackingStrategy</class-id> <category>public</category><body package="Seaside-Session">addKey: aString toUrl: aUrl	"We never add a session key to the URL, the user agent has to support cookies"</body><body package="Seaside-Session">noHandlerFoundForKey: aString in: anApplication context: aRequestContext	| queryField |	queryField := self queryFieldKeyFromContext: aRequestContext.	aString = queryField ifFalse: [		"Don't delete the session cookie if we have an expired document halder.		Only delete the session cookie if we actually have an expired session."		self deleteSessionCookieOf: anApplication from: aRequestContext ].	super noHandlerFoundForKey: aString in: anApplication context: aRequestContext</body></methods><methods><class-id>Seaside.WACookieOnlySessionTrackingStrategy class</class-id> <category>testing</category><body package="Seaside-Session">isAbstract	^ self name = #WACookieHandlerTrackingStragety</body></methods><methods><class-id>Seaside.WACookieIfSupportedSessionTrackingStrategy</class-id> <category>public</category><body package="Seaside-Session">addKey: aString toUrl: aUrl	"Only add a query field if there isn't already a cookie"	self		cookieFromContext: self requestContext		ifAbsent: [ self addQueryFieldWithValue: aString to: aUrl ]</body><body package="Seaside-Session">noHandlerFoundForKey: aString in: anApplication context: aRequestContext	| queryFieldKey |	queryFieldKey := self queryFieldKeyFromContext: aRequestContext.	queryFieldKey isNil		ifTrue: [			| cookie |			"there is no query field -&gt; a cookie was used for the look up -&gt; delete it"			cookie := self cookieFromContext: aRequestContext ifAbsent: [ nil ].			cookie notNil ifTrue: [				"If there is a cookie delete it.				Unfortunately if the browser doesn't support cookies then an expired document handler will result in the session cookie being deleted."				self deleteSessionCookieOf: anApplication from: aRequestContext ] ]		ifFalse: [			| cookie |			cookie := self cookieFromContext: aRequestContext ifAbsent: [ nil ].			(cookie notNil and: [ cookie value = queryFieldKey ]) ifTrue: [				"A query field was used for the look up but there is also a cookie with the same value -&gt; delete it"				self deleteSessionCookieOf: anApplication from: aRequestContext ] ].	super noHandlerFoundForKey: aString in: anApplication context: aRequestContext</body></methods><methods><class-id>Seaside.WAImageTag</class-id> <category>*seaside-session</category><body package="Seaside-Session">document: aDocument	self document: aDocument mimeType: nil</body><body package="Seaside-Session">document: aDocument mimeType: mimeType	self document: aDocument mimeType: mimeType fileName: nil</body><body package="Seaside-Session">document: aDocument mimeType: mimeType fileName: fileName	self url: (canvas context urlForDocument: aDocument mimeType: mimeType fileName: fileName)</body></methods><methods><class-id>Seaside.WAContentElement</class-id> <category>*seaside-session</category><body package="Seaside-Session">document: aString	self document: aString mimeType: self typeOrNil</body><body package="Seaside-Session">document: aString fileName: fileName	self document: aString mimeType: self typeOrNil fileName: fileName</body><body package="Seaside-Session">document: aString mimeType: mimeType	self document: aString mimeType: mimeType fileName: nil</body><body package="Seaside-Session">document: aString mimeType: mimeType fileName: fileName	self url: (root context urlForDocument: aString mimeType: mimeType fileName: fileName)</body></methods><methods><class-id>Seaside.WARequestHandler</class-id> <category>*seaside-session</category><body package="Seaside-Session">isApplication	^ false</body><body package="Seaside-Session">isSession	^ false</body></methods><methods><class-id>Seaside.WAAnchorTag</class-id> <category>*seaside-session</category><body package="Seaside-Session">document: aDocument	self document: aDocument mimeType: nil</body><body package="Seaside-Session">document: aDocument mimeType: mimeType	self document: aDocument mimeType: mimeType fileName: nil</body><body package="Seaside-Session">document: aDocument mimeType: mimeType fileName: fileName	self url: (canvas context urlForDocument: aDocument mimeType: mimeType fileName: fileName).	mimeType isNil ifFalse: [		self type: mimeType ]</body></methods><methods><class-id>Seaside.WAImageButtonTag</class-id> <category>*seaside-session</category><body package="Seaside-Session">document: aDocument	self document: aDocument mimeType: nil</body><body package="Seaside-Session">document: aDocument mimeType: mimeType	self document: aDocument mimeType: mimeType fileName: nil</body><body package="Seaside-Session">document: aDocument mimeType: mimeType fileName: fileName	self url: (canvas context urlForDocument: aDocument mimeType: mimeType fileName: fileName)</body></methods><methods><class-id>Seaside.WAIframeTag</class-id> <category>*seaside-session</category><body package="Seaside-Session">document: anObject	self document: anObject mimeType: nil</body><body package="Seaside-Session">document: anObject mimeType: aMimeString	self document: anObject mimeType: aMimeString fileName: nil</body><body package="Seaside-Session">document: anObject mimeType: aMimeString fileName: aFileNameString	self url: (canvas context		urlForDocument: anObject		mimeType: aMimeString		fileName: aFileNameString)</body></methods><methods><class-id>Seaside.WARequestContext</class-id> <category>*seaside-session</category><body package="Seaside-Session">application	"Answer the current application or nil."	^ handlers 		detect: [ :each | each isApplication ]		ifNone: [ nil ]</body><body package="Seaside-Session">redirectTo: aUrlOrString 	self responseGenerator		redirectTo: aUrlOrString;		respond</body><body package="Seaside-Session">session	"Answer the current session or nil."	^ handlers 		detect: [ :each | each isSession ]		ifNone: [ nil ]</body></methods><methods><class-id>Seaside.WARequestFilter</class-id> <category>*seaside-session</category><body package="Seaside-Session">updateStates: aSnapshot	aSnapshot register: next</body></methods><methods><class-id>Seaside.WARenderContext</class-id> <category>*seaside-session</category><body package="Seaside-Session">urlForDocument: anObject	^ self urlForDocument: anObject mimeType: nil</body><body package="Seaside-Session">urlForDocument: anObject mimeType: mimeString	^ self urlForDocument: anObject mimeType: mimeString fileName: nil</body><body package="Seaside-Session">urlForDocument: anObject mimeType: mimeType fileName: fileName	| handler |	handler := (WADocumentHandler		document: anObject		mimeType: mimeType		fileName: fileName).	^ self requestContext session register: handler</body></methods><methods><class-id>Seaside.WAObject</class-id> <category>*seaside-session</category><body package="Seaside-Session">application	"Answer the current seaside application, instance of WAApplication or a subclass."		^ self requestContext application</body><body package="Seaside-Session">session	"Answer the current seaside session, instance of WASession or a subclass."		^ self requestContext session</body></methods><methods><class-id>Seaside.WAApplication</class-id> <category>configuration</category><body package="Seaside-Session">initialContinuationClass	&lt;SeasideOverride&gt;	^ (self preferenceAt: #initialContinuationClass) pharoValue</body><body package="Seaside-Session">libraries	&lt;SeasideOverride&gt;	^ (self preferenceAt: #libraries) collect: [ :each | each pharoValue ]</body><body package="Seaside-Session">sessionClass	&lt;SeasideOverride&gt;	^ (self preferenceAt: #sessionClass) pharoValue</body></methods><methods><class-id>Seaside.WAApplication</class-id> <category>libraries</category><body package="Seaside-Session">removeLibrary: aLibraryClass	&lt;SeasideOverride&gt;	self		preferenceAt: #libraries		put: ((self preferenceAt: #libraries) reject: [ :each | each pharoValue = aLibraryClass ])</body></methods><methods><class-id>Grease.GRPackage class</class-id> <category>*seaside-session</category><body package="Seaside-Session">seasideSession	^ self new		name: 'Seaside-Session';		description: 'Support for stateful and secure session handling.';		addDependency: 'Seaside-Core';		url: #seasideUrl;		yourself</body></methods><methods><class-id>Grease.GRPlatform</class-id> <category>*seaside-session</category><body package="Seaside-Session">createMutualExclusionFilter	"GemStone/S should create a WAGsMutualExclusionFilter here"	^ WAMutualExclusionFilter new</body><body package="Seaside-Session">createSessionCacheForApplication: anApplication	"GemStone/S should create a WABulkReapingCache without a mutex here"	^ WAMutualExclusionCache on: (WAHashCache		initialSize: 13		maximumSize: (anApplication configuration at: #maximumSize)		maximumAbsoluteAge: (anApplication configuration at: #maximumAbsoluteAge)		maximumRelativeAge: (anApplication configuration at: #maximumRelativeAge)		overflowAction: (anApplication configuration at: #overflowAction))</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>WAObject</name><environment>Seaside</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAHandlerTrackingStrategy</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAAnchorTag</name><environment>Seaside</environment><super>Seaside.WATagBrush</super><private>false</private><indexed-type>none</indexed-type><inst-vars>url </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Canvas-Tags</category><attributes><package>Seaside-Canvas</package></attributes></class><class><name>WARequestHandler</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filter parent configuration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WARegistry</name><environment>Seaside</environment><super>Seaside.WARequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAImageTag</name><environment>Seaside</environment><super>Seaside.WATagBrush</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Canvas-Tags</category><attributes><package>Seaside-Canvas</package></attributes></class><class><name>WARenderContext</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>visitor actionUrl actionBaseUrl resourceUrl callbacks document properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Rendering</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAContentElement</name><environment>Seaside</environment><super>Seaside.WAHtmlElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document-Elements</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WARequestContext</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handlers request response codec consumer properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAIframeTag</name><environment>Seaside</environment><super>Seaside.WATagBrush</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rootBlock url </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Canvas-Tags</category><attributes><package>Seaside-Canvas</package></attributes></class><class><name>GRPlatform</name><environment>Grease</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core</category><attributes><package>Grease-Core</package></attributes></class><class><name>WARequestFilter</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>next </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Filter</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAImageButtonTag</name><environment>Seaside</environment><super>Seaside.WASubmitButtonTag</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Canvas-Tags</category><attributes><package>Seaside-Canvas</package></attributes></class><class><name>WASystemConfiguration</name><environment>Seaside</environment><super>Seaside.WAConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>description </inst-vars><class-inst-vars>instance </class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class></st-source>