<?xml version="1.0"?><st-source><!-- Name: Seaside-CoreComment: The core of Seaside, required for all packages.DbIdentifier: bear73DbTrace: 492576DbUsername: jkottDbVersion: 3.2.0 - JohanBrichau.869 1DevelopmentPrerequisites: #(#(#any 'Seaside-Namespace' '') #(#any 'Grease-Core' '') #(#any 'Grease-VisualWorks-Core' ''))Id: aeaa443c-7437-4469-af62-6a29ef484708Namespace: SeasidePackageName: Seaside-CoreParcel: #('Seaside-Core')ParcelName: Seaside-CorePrerequisiteParcels: #(#('Seaside-Namespace' '') #('Grease-Core' '') #('Grease-VisualWorks-Core' ''))PrintStringCache: (3.2.0 - JohanBrichau.869 1,jkott)Url: http://smalltalkhub.com/mc/Seaside/Seaside32/main/Seaside-Core-JohanBrichau.869.mczVersion: 3.2.0 - JohanBrichau.869 1Date: 3:31:26 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:31:26 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WAObject</name><environment>Seaside</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAObject</class-id><body>A WAObject is the base class for all portable Seaside classes. It guarantees that #initialize is send upon object creation. Additionally it provides convenience methods for accessing the current request context, session and application.</body></comment><class><name>WAVisitor</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Utilities</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAAttributeVisitor</name><environment>Seaside</environment><super>Seaside.WAVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAHandlerTrackingStrategy</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAHandlerTrackingStrategy</class-id><body>I am a strategy of how request handlers should be tracked by a WARegistry or subclass.One important thing to remember a WARegistry can contain all kinds of request handlers. The most common case is a WAApplication that contains both WADocumentHandlers and WASessions. Some tracking methods may not be appropriate for some kinds of handlers (eg. a WADocumentHandler should never be tracked using a cookie). Some requests may have multiple keys (eg. a query field for a WADocumentHandler and a cookie for a WASession). It's the job of the strategy to take this into consideration.The 'public' protocol contains the methods that a tracking strategy must implement. The 'private' protocol contains some utility methods that may be helpful implementing these methods.</body></comment><class><name>WAQueryFieldHandlerTrackingStrategy</name><environment>Seaside</environment><super>Seaside.WAHandlerTrackingStrategy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAQueryFieldHandlerTrackingStrategy</class-id><body>I track request handlers using a query field. This results in URLs looking like this:/tests/functional?_s=de379kaie13This is a very simple and robust approach. It is also very convenient for development. Just remove the _s and you have a new session.However there are some drawbacks. The smallest is aesthetical, the URL in the address bar of the browser is less "clean". Second because the session id is part of the request URL it shows up in all kinds of places. For example server logs. Not only the log of the server running the application but also very web site visited from there because it shows up in the Referer HTTP header. The danger of this is that when somebody knows the session id of somebody else he can take over his session. While most of these problems can be mitigated by adding a WAProtectionFilter to every session this creates new problems for users with changing IPs (eg. mobile devices).</body></comment><class><name>WAConditionalComment</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>condition root </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document-Elements</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAConditionalComment</class-id><body>A WAConditionalComment is an implementation of Downlevel-hidden Conditional Comments:http://msdn2.microsoft.com/en-us/library/ms537512.aspxThese are only visible for the IE family of browsers.See also WAOpeningConditionalComment and WAClosingConditionalComment.</body></comment><class><name>WAQualifiedValue</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value quality </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAQualifiedValue</class-id><body>A WAQualifiedValue is an Object with an assigned quality value.Instance Variables	quality:		&lt;Float&gt;	value:		&lt;Object&gt;quality	- between 0.0 and 1.0 or Float infinity if no value is givenvalue	- the qualified object</body></comment><class><name>WAAcceptEncoding</name><environment>Seaside</environment><super>Seaside.WAQualifiedValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAAcceptEncoding</class-id><body>A WAAcceptCharset is a WAQualifiedValue with a value that is an instance of String. It represents how much a user agent prefers a certain encoding for the response.</body></comment><class><name>WAClosingRevealedConditionalComment</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document-Elements</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAClosingRevealedConditionalComment</class-id><body>Closes a WARevealedConditionalComment.</body></comment><class><name>WARequestHandler</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filter parent configuration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WARequestHandler</class-id><body>WARequestHandler is an abstract class whose subclasses handle http requests. Most of the methods are either empty or return a default value. Subclasses must implement the following messages:	handleFiltered:	process the request</body></comment><class><name>WADispatcher</name><environment>Seaside</environment><super>Seaside.WARequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultName handlers </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WADispatcher</class-id><body>WADispatcher takes http requests and dispatches them to the correct handler (WAApplication, WAFileHandler, etc). WADispatcher class&gt;&gt;default is the top level dispatcher. When a Seaside application is registered as "foo" the application is added to the top level dispatcher. The application is added to the entryPoints of the dispatcher at the key "foo". If a Seaside application is registered as "bar/foo" then the application isadded to a  dispatcher's entryPoints at the key "foo". That dispatcher is in the top level dispatcher's  entryPoints at the key "bar".   When a http request is received it is sent to WADispatcher class&gt;&gt;default to find the correct handler for the request. If a handler exists for the request is sent to that handler. Otherwise the request is sent to the not found response generator.The VW port maintains multiple copies of the tree of dispatchers rooted at WADispatcher class&gt;&gt;default. One copy is for each different URL that can reach Seaside (http://..../seaside/go/counter - normal, http://..../counter - SeasideShortPath, http://..../seaside/stream/counter - streaming). Instance Variables:	defaultName	&lt;String&gt;	entryPoints	&lt;(Dictionary of: WAEntryPoint)&gt;	 the keys are strings, which are the names and URL path segments for the handler at that key</body></comment><class><name>WARegistry</name><environment>Seaside</environment><super>Seaside.WARequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WARegistry</class-id><body>WARegistry maintains a set of handlers indexed by a key which it assigns when the handler is registerd. WARegistry checks incoming request URLs for a key and looks for a matching active request handler. If one exists, the request is sent to the proper handler. If not, the request is either a new request (in which case #handleDefaultRequest: is called) or a request to a now-inactive handler (in which case #handleExpiredRequest: is called). These two methods allow subclasses to properly handle these requests.Subclasses must implement the following messages:	handleDefaultRequest:		Handle a request without a session key, ie a new request.	handlerField		The URL parameter in which to store the request handler key.Instance Variables:	cache - an instance of WACache to hold the stored request handlers</body></comment><class><name>WAKeyGenerator</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>generator space </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>Seaside-Core-Utilities</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WARequestFilter</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>next </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Filter</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WARequestFilter</class-id><body>WARequestFilter is an implementation for the chain-of-responsibility and decorator pattern for request handlers. Request filters are a way of hooking into the request handling. There is no limit on what they can do, examples include - preprocess the request - postprocess the response - set up thread locals or expection handlers - return a different response (eg. from cache or access denied) This functionality is also known as servlet filters, WSGI infrastructure or rack infrastructure.Instance Variables:	next	&lt;WAValueHolder&lt;WARequestFilter&gt;&gt;		next	- The next filter in the chain.</body></comment><class><name>WATrailingSlashFilter</name><environment>Seaside</environment><super>Seaside.WARequestFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Filter</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WATrailingSlashFilter</class-id><body>Enforces a trailing slash on the wrapped request handler.</body></comment><class><name>WACache</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Cache</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WACache</class-id><body>WACacheNG is the abstract base class for session and continuation stores in Seaside. The default implementation is WAHashCacheNG.</body></comment><class><name>WAEncoder</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAEncoder</class-id><body>I encode everything that is written to myself using #nextPut: and #nextPutAll: onto the wrapped stream.</body></comment><class><name>WATableBasedEncoder</name><environment>Seaside</environment><super>Seaside.WAEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>table </inst-vars><class-inst-vars>table </class-inst-vars><imports></imports><category>Seaside-Core-Document</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WATableBasedEncoder</class-id><body>I encode everything that is written to myself using #nextPut: and #nextPutAll: onto the wrapped stream. The specific encoding that is done is determined by my subclasses (the conversion of a single character is defined in the class-side method #encode:on:).To be efficient, each subclass uses a cached encoding table to transform the most used characters from the UTF Basic Multilingual Plane.</body></comment><class><name>WAError</name><environment>Seaside</environment><super>Grease.GRError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Exceptions</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAIllegalStateException</name><environment>Seaside</environment><super>Seaside.WAError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WARoot</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>context </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WARoot</class-id><body>A WARoot is the root of a document. It is responsible to generate header and footer of a document.</body></comment><class><name>WAXmlRoot</name><environment>Seaside</environment><super>Seaside.WARoot</super><private>false</private><indexed-type>none</indexed-type><inst-vars>charSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WACallbackRegistry</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>callbacks nextKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Callbacks</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAHtmlElement</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root attributes children </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document-Elements</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAHtmlElement</class-id><body>Root class of all elements inside a &lt;head&gt; section.</body></comment><class><name>WABaseElement</name><environment>Seaside</environment><super>Seaside.WAHtmlElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document-Elements</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WABaseElement</class-id><body>In HTML, links and references to external images, applets, form-processing programs, style sheets, etc. are always specified by a URI. Relative URIs are resolved according to a base URI, which may come from a variety of sources. The BASE element allows authors to specify a document's base URI explicitly.When present, the BASE element must appear in the HEAD section of an HTML document, before any element that refers to an external source. The path information specified by the BASE element only affects URIs in the document where the element appears.For example, given the following BASE declaration and A declaration:updateRoot: html	super updateRoot: html.	html base url: 'http://www.aviary.com/products/intro.html'renderContentOn: html	html anchor		url: '../cages/birds.gif';		with: 'Bird Cages'the relative URI "../cages/birds.gif" would resolve to:http://www.aviary.com/cages/birds.gif</body></comment><class><name>WAPainter</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Rendering</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAPainter</class-id><body>A Painter is an object that renders onto a Document using a Renderer (typically a subclass of WACanvas). The class of the Renderer is specified by #rendererClass.Subclasses should implement #renderContentOn: to do the actual rendering.Painters do not store or backtrack state and do not provide call/answer semantics or decorations. They are often created for each request, used, and then discarded. If you want any of the above features, you should use a subclass of WAPresenter or WAComponent.To cause a Painter to render itself, you should pass it to the #render: message of a Renderer. For example, from within a Component you could do the following:	renderContentOn: html		html render: MyPainterSubclass new</body></comment><class><name>WACallback</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Callbacks</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAValueCallback</name><environment>Seaside</environment><super>Seaside.WACallback</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Callbacks</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAEmailCallback</name><environment>Seaside</environment><super>Seaside.WAValueCallback</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Callbacks</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAEmailCallback</class-id><body>A WAEmailCallback is a callback for email input fields.</body></comment><class><name>WAConfiguration</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cachedSearchContexts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAConfiguration</class-id><body>A configuration for a Seaside application contains attributes which can be used by Seaside and the application. WAConfiguration hierarchy uses the composite pattern.Subclasses of WASystemConfiguration define and configure related groups of attributes. See WASystemConfiguration class comment for information on defining your own attributes.WAUserConfiguration is a composite of configurations. The set of configurations contained in WAUserConfiguration is called the ancestors. Attribute values in a configuration override the attribute values in the ancestors. WAUserConfiguration also holds the non-default values of attributes.Seaside applications start with a WAUserConfiguration (see WAApplication&gt;&gt;configuration) a single parent: WARenderLoopConfiguration. The full ancestry also includes WASessionConfiguration WAGlobalConfiguration. Other configurations can be added to an application on the Seaside configuration page for the application or in your application. Values for the attributes can be given in either location. See Seaside documentation (http://www.seaside.st/documentation) on configuration and preferences (http://www.seaside.st/documentation/Configuration%20and%20Preferences) for more information.Example of setting attributes and adding configurations in codeASubclassOfWAComponent class&gt;&gt;initialize	"self initialize"	| application |	application := self registerAsApplication: 'GlorpExample'.	"set a standard attribute"	application preferenceAt: #sessionClass put: Glorp.WAGlorpSession. 	"add a configuration"	application configuration addParent: GlorpConfiguration new.	application preferenceAt: #databaseLogin put: 'foo'. "set attribute defined in GlorpConfiguration"Subclasses must implement the following messages:	name		return the name of the configuration	localValueAt:ifAbsent:		return the value of the attribute given as first argument</body></comment><class><name>WAUserConfiguration</name><environment>Seaside</environment><super>Seaside.WAConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expressions parents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAUserConfiguration</class-id><body>WAUserConfiguration is a composite of configurations.  This composite of configurations is stored in the field "parents". WAUserConfiguration provides methods to dynamically provide non-default values for attributes. WAUserConfiguration inherits attributes and values defined in its ancestors. If WAUserConfiguration does not have a value for an attribute it will search its ancestors for a value, stopping when it finds a value.An instance of WAUserConfiguration is the first configuration added to a Seaside application (WAApplication). All other configurations added to the application are added as ancestors of this instance. When a value for an attribute is set either by the standard Seaside component configuration page or in code the value is added to the "values" dictionary in WAUserConfiguration.Instance Variables:	parents	&lt;Collection of: WAConfiguration&gt;	 hierarchy of configurations defining all attributes for this instance of WAUserConfiguration	values	&lt;Dictionary&gt;	the dictionary key is an attribute key, dictionary value is value of that attribute </body></comment><class><name>WAHeaderFields</name><environment>Seaside</environment><super>Grease.GROrderedMultiMap</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAHeaderFields</class-id><body>I am the headers dictionary of an HTTP request or response.</body></comment><class><name>WAConfiguredRequestFilter</name><environment>Seaside</environment><super>Seaside.WARequestFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>configuration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Filter</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WABidirectionalCache</name><environment>Seaside</environment><super>Seaside.WACache</super><private>false</private><indexed-type>none</indexed-type><inst-vars>byKey byValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Cache</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WABidirectionalCache</class-id><body>I support key -&gt; value and value -&gt; key mappings and never forget anything.I also implement serveral methods of Dictionary.</body></comment><class><name>WAConfigurationElement</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAOpeningConditionalComment</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>condition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document-Elements</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAOpeningConditionalComment</class-id><body>Opens a WAConditionalComment and encodes the condition.</body></comment><class><name>WAOpeningRevealedConditionalComment</name><environment>Seaside</environment><super>Seaside.WAOpeningConditionalComment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document-Elements</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAOpeningRevealedConditionalComment</class-id><body>Opens a WARevealedConditionalComment and encodes the condition.</body></comment><class><name>WAXmlEncoder</name><environment>Seaside</environment><super>Seaside.WAEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAXmlEncoder</class-id><body>I encode XHTML text.</body></comment><class><name>WAConfigurationDescription</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attributes expressions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAConfigurationDescription</class-id><body>I hold a collection of attributes and present methods to construct new methods, providing an interface a bit like WACanvas and #renderContentOn: to WASystemConfiguration&gt;&gt;addAttributes:.I can use any kind of collection class and handle setting the #configuration: parameter of the attribute appropriately on addition. If my collection is a Dictionary, I will store the attributes by their keys.</body></comment><class><name>WARequestCookie</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key path pathEncoded domain ports value version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WARequestCookie</class-id><body>A WARequestCookie is the cookie the user agent sent to the server.Instance Variables	domain:			&lt;String&gt;	key:			&lt;String&gt;	path:			&lt;String&gt;	pathEncoded:	&lt;String&gt;	ports:			&lt;Collection&lt;Integer&gt;&gt;	value:			&lt;String&gt;	version:			&lt;Integer&gt;domain	- xxxxxkey	- xxxxxpath	- xxxxxports	- xxxxxvalue	- xxxxxversion	- the version of the cookie specification supported, currently only 1 is known</body></comment><class><name>WACookie</name><environment>Seaside</environment><super>Seaside.WARequestCookie</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expiry secure discard comment commentUrl httpOnly maxAge </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WACookie</class-id><body>I represent a cookie, a piece of information that is stored on the client and read and writable by the server. I am basically a key/value pair of strings.You can never trust information in a cookie, the client is free to edit it.I model only a part of the full cookie specification.Browser support:http://www.mnot.net/blog/2006/10/27/cookie_funNetscape spechttp://cgi.netscape.com/newsref/std/cookie_spec.htmlCookie spechttp://tools.ietf.org/html/rfc2109Cookie 2 spechttp://tools.ietf.org/html/rfc2965HttpOnlyhttp://msdn2.microsoft.com/en-us/library/ms533046.aspxhttps://bugzilla.mozilla.org/show_bug.cgi?id=178993Compared to WARequestCookie I represent the information that is sent to the user agent.</body></comment><class><name>WAAbstractFileLibrary</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>Seaside-Core-Libraries</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAExceptionHandler</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestContext </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAExceptionHandler</class-id><body>Exception handlers are invoked when an error in a Seaside application occurs. Request handlers can use the class-side method #handleExceptionsDuring: to set up exception handlers around a block of code.== Catching ==Exception handlers can configure which exceptions they want to catch by overriding the class-side method #exceptionsToCatch. They may also choose to override #handleExceptionsDuring: on the class-side directly, if they need more complex behaviour.== Handling ==Handling behaviour is implemented on the instance side by implementing #handleException:. This method should return a suitable seaside response (usually an instance of WAResponse) if it returns.== Internal Errors ==Internal errors are typically errors that occur while trying to execute one of the other error handlers and should be as basic as possible to ensure they don't have any trouble executing. Request handlers can ask for an internal error response by calling #internalError: on the class-side of an exception handler.== HTML Responses ==See WAWalkbackErrorHandler in the development packages for examples of how to do rendering with the canvas API.</body></comment><class><name>WAErrorHandler</name><environment>Seaside</environment><super>Seaside.WAExceptionHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAErrorHandler</class-id><body>WAErrorHandler catches Errors and Warnings and provides two methods for handling each type of exception:handleError:handleWarning:If either method is not implemented, the default implementation will call #handleDefault:, which can be used to provide common behaviour for both exception types.</body></comment><class><name>WAMimeDocument</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents mimeType fileName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAMimeDocument</class-id><body>WAMimeDocument is the abstract base class for mime documents. It is intended as a very basic, mime documents. Implementations are free to use more advance, native implementations as long as they conform to the protocol.Instance Variables	contentType:		&lt;WAMimeType&gt;mimeType	- the mime type of this document</body></comment><class><name>WADocument</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream root </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WADocument</class-id><body>A WADocument combines an output stream and an instance of root. The root is responsible to render header and footer if necessary.</body></comment><class><name>WAXmlDocument</name><environment>Seaside</environment><super>Seaside.WADocument</super><private>false</private><indexed-type>none</indexed-type><inst-vars>urlEncoder xmlEncoder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAXmlDocument</class-id><body>A WAXmlDocument is adds the possibility to generate XML tags and knows encoders for XML text and URLs.</body></comment><class><name>WAUnescapedDocument</name><environment>Seaside</environment><super>Seaside.WAXmlDocument</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAUnescapedDocument</class-id><body>A WAUnescapedDocument is does not do any escaping.</body></comment><class><name>WAActionCallback</name><environment>Seaside</environment><super>Seaside.WACallback</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Callbacks</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAImageCallback</name><environment>Seaside</environment><super>Seaside.WAActionCallback</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Callbacks</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAFileHandlerListing</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handler context </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Libraries</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAForbiddenFileHandlerListing</name><environment>Seaside</environment><super>Seaside.WAFileHandlerListing</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Libraries</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAExpiringCache</name><environment>Seaside</environment><super>Seaside.WACache</super><private>false</private><indexed-type>none</indexed-type><inst-vars>maximumSize maximumRelativeAge maximumAbsoluteAge overflowAction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Cache</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAExpiringCache</class-id><body>I am the abstract base class for caches that remove entries. Subclasses are intended to use to track sessions.    Instance Variables	maximumSize			&lt;Integer&gt;	maximumRelativeAge		&lt;Integer&gt;	maximumAbsoluteAge	&lt;Integer&gt;	overflowAction			&lt;Symbol&gt;</body></comment><class><name>WABulkReapingCache</name><environment>Seaside</environment><super>Seaside.WAExpiringCache</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Cache</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WABulkReapingCache</class-id><body>I am a cache that reaps all elements at once instead of incrementally.I am intended to be used in GemStone/S instead of WAHashCache. A background process should send #reap to me.    Instance Variables	dictionary:		&lt;Dictionary&gt;</body></comment><class><name>WAAuthenticationFilter</name><environment>Seaside</environment><super>Seaside.WARequestFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>authenticator realm </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Filter</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAAuthenticationFilter</class-id><body>WAAuthenticationFilter protects a request handler with username and password using the standard HTTP basic authentication. This passes username and password in clear-text, unless used over an encripted HTTPS connection. You should set the authenticator, and object that is able to validate usernames and passwords by implementing #verifyPassword:forUser:.</body></comment><class><name>WAHtmlRoot</name><environment>Seaside</environment><super>Seaside.WARoot</super><private>false</private><indexed-type>none</indexed-type><inst-vars>docType htmlAttrs headAttrs bodyAttrs headElements title styles scripts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAHtmlRoot</class-id><body>A WAHtmlRoot is the root element of an HTML Document (&lt;html&gt;).Instance Variables	bodyAttrs:		&lt;WAHtmlAttributes&gt;	context:			&lt;WARenderContext&gt;	docType:		&lt;String&gt;	headAttrs:		&lt;WAHtmlAttributes&gt;	headElements:	&lt;OrderedCollection&lt;WAHtmlElement&gt;&gt;	htmlAttrs:		&lt;WAHtmlAttributes&gt;	scripts:			&lt;Set&lt;String&gt;&gt;	styles:			&lt;Set&lt;String&gt;&gt;	title:			&lt;String&gt;bodyAttrs	- the attributes of the &lt;body&gt; elementcontext	- the context used to render the contents of the &lt;body&gt; elementdocType	- the document typeheadAttrs	- the attributes of the &lt;head&gt; elementheadElements	- the elements inside the &lt;head&gt; sectionhtmlAttrs	- the attributes of the &lt;html&gt; elementscripts	- contains the strings returned by WAPresenter &gt;&gt; #scriptstyles	- contains the strings returned by WAPresenter &gt;&gt; #styletitle	- the title of the HTML document, the contents of the &lt;title&gt; element</body></comment><class><name>WAFileHandler</name><environment>Seaside</environment><super>Seaside.WARequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>Seaside-Core-Libraries</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAFileHandler</class-id><body>Seaside serves static files using WAFileLibrary subclasses. WAFileHandler handles all requests for WALibrary files (or methods) for all applications on the Seaside server. WAFileHandler is registered with the default WADispatcher automatically.</body></comment><class><name>WANotification</name><environment>Seaside</environment><super>Grease.GRNotification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Exceptions</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WADynamicVariable</name><environment>Seaside</environment><super>Seaside.WANotification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Utilities</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WADynamicVariable</class-id><body>A WADynamicVariable is a variable that is visible only in the stackframes outgoing from this one.Example:WADynamicVariable	use: 'Seaside'	during: [ self compilcatedCalculation ]	WheneverWADynamicVariable valuegets evaluated somewhere inside [ self compilcatedCalculation ] or a method invoked directly or indirectly by it, its value will be 'Seaside'. If no #use:during: handler is around the current stack frame, then the value will be the return value of #defaultValue.Do not use WADynamicVariable directly, instead create a subclass for each variable you want to use.</body></comment><class><name>WACurrentRequestContext</name><environment>Seaside</environment><super>Seaside.WADynamicVariable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WACurrentRequestContext</class-id><body>A WACurrentRequestContext is a thread local variable that points to the current WARequestContext.</body></comment><class><name>WAAllValuesCallback</name><environment>Seaside</environment><super>Seaside.WAValueCallback</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Callbacks</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAAllValuesCallback</class-id><body>WAAllValuesCallback is a special WAValueCallback that whos value is a sequenceable collection of values.</body></comment><class><name>WAMetaElement</name><environment>Seaside</environment><super>Seaside.WAHtmlElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document-Elements</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAMetaElement</class-id><body>The META element can be used to identify properties of a document (e.g., author, expiration date, a list of key words, etc.) and assign values to those properties. This specification does not define a normative set of properties.Each META element specifies a property/value pair. The name attribute identifies the property and the content attribute specifies the property's value.For example, the following declaration sets a value for the Author property:&lt;META name="Author" content="Dave Raggett"&gt;The lang attribute can be used with META to specify the language for the value of the content attribute. This enables speech synthesizers to apply language dependent pronunciation rules.In this example, the author's name is declared to be French:htm meta	name: 'Author'; language: 'fr'; content: 'Arnaud Le Hors'	Note. The META element is a generic mechanism for specifying meta data. However, some HTML elements and attributes already handle certain pieces of meta data and may be used by authors instead of META to specify those pieces: the TITLE element, the ADDRESS element, the INS and DEL elements, the title attribute, and the cite attribute.Note. When a property specified by a META element takes a value that is a URI, some authors prefer to specify the meta data via the LINK element. Thus, the following meta data declaration:html meta      name: 'DC.identifier';      content: 'http://www.ietf.org/rfc/rfc1866.txt'might also be written:html link         relationship: 'DC.identifier';         type: 'text/plain';         url: 'http://www.ietf.org/rfc/rfc1866.txt'The http-equiv attribute can be used in place of the name attribute and has a special significance when documents are retrieved via the Hypertext Transfer Protocol (HTTP). HTTP servers may use the property name specified by the http-equiv attribute to create an [RFC822]-style header in the HTTP response. Please see the HTTP specification ([RFC2616]) for details on valid HTTP headers.The following sample META declaration:htttp meta         responseHeaderName: 'Expires';         content: 'Tue, 20 Aug 1996 14:25:27 GMT'will result in the HTTP header:Expires: Tue, 20 Aug 1996 14:25:27 GMTThis can be used by caches to determine when to fetch a fresh copy of the associated document.Note. Some user agents support the use of META to refresh the current page after a specified number of seconds, with the option of replacing it by a different URI. Authors should not use this technique to forward users to different pages, as this makes the page inaccessible to some users. Instead, automatic page forwarding should be done using server-side redirects.html meta         redirectAfter: 5 to: 'http://www.google.com/'</body></comment><class><name>WACancelActionCallback</name><environment>Seaside</environment><super>Seaside.WAActionCallback</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Callbacks</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WADefaultActionCallback</name><environment>Seaside</environment><super>Seaside.WAActionCallback</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Callbacks</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAUnidirectionalCache</name><environment>Seaside</environment><super>Seaside.WACache</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Cache</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAUnidirectionalCache</class-id><body>I support only key -&gt; value mappings and never forget anything.</body></comment><class><name>WAExceptionFilter</name><environment>Seaside</environment><super>Seaside.WAConfiguredRequestFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Filter</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WARevealedConditionalComment</name><environment>Seaside</environment><super>Seaside.WAConditionalComment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document-Elements</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WARevealedConditionalComment</class-id><body>A WAConditionalComment is an implementation of Downlevel-revealed Conditional Comments:http://msdn2.microsoft.com/en-us/library/ms537512.aspxNon-IE family browsers see them always.See also WAOpeningRevealedConditionalComment and WARevealedConditionalComment.</body></comment><class><name>WAInvalidUrlSyntaxError</name><environment>Seaside</environment><super>Seaside.WAError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAAttribute</name><environment>Seaside</environment><super>Seaside.WAConfigurationElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>group comment label default advanced </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAAttribute</class-id><body>A WAAttribute represents a value of a specified type in a Seaside configuration. Some attributes are needed by Seaside for application parameters like deployment Mode and session timeout. Optional attributes like a database login may be used internally by the application.Each subclass of WAAttribute handles one type (Number, Boolean, etc) of attribute. The "group" of the attribute is used to place all attributes in the same group together on the Seaside configuration page. The "key" of the attribute identifies the attribute. Attribute keys must be globally unique so use namespacing where required to ensure uniqueness. See WAConfiguration for example of accessing a configuration attribute. Subclasses may implement their own configuration options depending on their needs.Subclasses must implement the following messages:	valueFromString: aString		convert "aString" into type represented by the class, return result of the conversion		accept: aVisitor with: anObject		Typical implementation is:			aVisitor visitXXXAttribute: self with: anObject		where XXX is the type of this attribute. The method visitXXXAttribute:with: must be implemented in all visitors, in particular WAUserConfigurationEditorVisitor which creates the configuration page for Seaside applications.Instance Variables:	configuration	&lt;WAConfiguration&gt;	The configuration object that defined the attribute	group			&lt;Symbol&gt;				name of the group the attribute belongs to	key				&lt;Symbol&gt;				key or name of the attribute, used to look up the attribute	comment		&lt;String&gt; 				a full length description of the attribute for displaying in the configuration interface	label			&lt;String&gt;				a short field label used in the user interface. If not specified, a label is constructed from the key.	default			&lt;Object&gt;				The default value for the attribute.</body></comment><class><name>WAListAttribute</name><environment>Seaside</environment><super>Seaside.WAAttribute</super><private>false</private><indexed-type>none</indexed-type><inst-vars>optionsBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAListAttribute</class-id><body>WAListAttribute is an attribute that is restricted to a list of values. Instance Variables:	options	&lt;Block&gt;	A block returning a list of possible values for the attribute</body></comment><class><name>WACollectionAttribute</name><environment>Seaside</environment><super>Seaside.WAListAttribute</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAUnhandledNotificationError</name><environment>Seaside</environment><super>Seaside.WAError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>notification </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Exceptions</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAUnhandledNotificationError</class-id><body>Seaside has several Notifications that signal the desire to end the current attempt to process a request. These Notification must be handled as they are not resumable or continuable. If those Notifications are not handled, their default actions are to signal this error.</body></comment><class><name>WAAttributeExpression</name><environment>Seaside</environment><super>Seaside.WAConfigurationElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAValueExpression</name><environment>Seaside</environment><super>Seaside.WAAttributeExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAPainterVisitor</name><environment>Seaside</environment><super>Seaside.WAVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Rendering</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAPainterVisitor</class-id><body>An implementation of the Visitor pattern for Painter subclasses.</body></comment><class><name>WASystemConfiguration</name><environment>Seaside</environment><super>Seaside.WAConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>description </inst-vars><class-inst-vars>instance </class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WASystemConfiguration</class-id><body>You should subclass WASystemConfiguration to define new attributes. The method #describeOn: is passed an instance of WAConfigurationDescription which can be used to create new attributes. The attributes can be configured to specify their default value, label, and so on. See the methods on WAAttribute and its subclasses to see what options are available.If a configuration needs to override the value of another WASystemConfiguration or depends on its attributes, implement the method "parents", returning a collection of configuration objects.WASystemConfiguration subclasses are "read-only" in that their attributes, parents, and default values are all specified in code. Users and applications that want to configure values for attributes should create a WAUserConfiguration and specify the WASystemConfiguration in its ancestry.WASystemConfiguration classes are singleton. You should use #instance on the class side to get the current instance. You cannot call #copy on a WASystemConfiguration.Subclasses should implement the following messages:	describeOn:		They may also want to implement:	parents</body></comment><class><name>WAFileHandlerConfiguration</name><environment>Seaside</environment><super>Seaside.WASystemConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Libraries</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WABooleanAttribute</name><environment>Seaside</environment><super>Seaside.WAAttribute</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WABooleanAttribute</class-id><body>WABooleanAttribute  represents a boolean attribute. It converts between text entered on the configuration page and boolean values.</body></comment><class><name>WADocumentHandler</name><environment>Seaside</environment><super>Seaside.WARequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>document </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WADocumentHandler</class-id><body>WADocumentHandler handles requests for images, text documents and binary files (byte arrays). This class is not normally used directly. A number of WA*Tag classes implement document:mimeType:fileName: which use WADocumentHandler. Given a document, #document:mimeType:fileName: creates a WADocumentHandler for the document, registers the handler with a Registry, and adds the correct url in the tag for the document.Instance Variables:	document	&lt;WAMimeDocument&gt;	MIMEDocument object representing this document and mimeType, generates stream used to write document for the response.</body></comment><class><name>WAUrlAttribute</name><environment>Seaside</environment><super>Seaside.WAAttribute</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAUrlAttribute</class-id><body>WAUrlAttribute represents a URL attribute. It converts between text entered on the configuration page and WAUrl instances.</body></comment><class><name>WAAcceptCharset</name><environment>Seaside</environment><super>Seaside.WAQualifiedValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAAcceptCharset</class-id><body>A WAAcceptCharset is a WAQualifiedValue with a value that is an instance of String. It represents how much a user agent prefers a certain character set for the response.</body></comment><class><name>WAPathConsumer</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>path </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAPathConsumer</class-id><body>A WAPathConsumer keeps track of the unconsumed path elements in request handling.Image the following request path:/start/middle/endand a dispatcher mapped at 'start' and an application mapped at 'middle'.First nothing at all would be consumed so the unconsumed path would be #('start' 'middle' 'end').Then the dispatcher consumes 'start' and delegates to the application so the unconsumed path would be #('middle' 'end').Then the application consumes 'middle' so the unconsumed path would be #('end').In that caseself requestContext consumer peekinside an #initialRequest: should answer 'end'.Instance Variables	path:		&lt;Collection&lt;String&gt;&gt;path	- the collection of unconsumed path elements</body></comment><class><name>WAPasswordAttribute</name><environment>Seaside</environment><super>Seaside.WAAttribute</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAPasswordAttribute</class-id><body>WAPasswordAttribute represents a password attribute. When set from a string, it records a hashed value. On the Seaside configuration page it does not display its current value.</body></comment><class><name>WAClassListAttribute</name><environment>Seaside</environment><super>Seaside.WAListAttribute</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAClassListAttribute</class-id><body>WAClassListAttribute is an attribute that is restricted to a list of classes. The value will be an instance of the given class created with #new. </body></comment><class><name>WACacheListEntry</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>previous next time cacheEntry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Cache</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAAttributeSearchContext</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key attribute cachedValues attributeHolders attributeInheritors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAAttributeSearchContext</class-id><body>This class makes attribute searching more efficient by traversing the ancestry once and caching which Configurations hold the attribute. It is then passed through search functions which cache values for the attribute.</body></comment><class><name>WAAddRemoveExpression</name><environment>Seaside</environment><super>Seaside.WAAttributeExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>additions removals </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WATextFileHandlerListing</name><environment>Seaside</environment><super>Seaside.WAFileHandlerListing</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Libraries</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAMapCallback</name><environment>Seaside</environment><super>Seaside.WAValueCallback</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Callbacks</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAAcceptLanguage</name><environment>Seaside</environment><super>Seaside.WAQualifiedValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAAcceptLanguage</class-id><body>A WAAcceptLanguage is a WAQualifiedValue with a value that is an instance of WALocale. It represents how much a user agent prefers a certain locale.</body></comment><class><name>WAContentElement</name><environment>Seaside</environment><super>Seaside.WAHtmlElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document-Elements</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAContentElement</class-id><body>Common superclass of all elements inside a &lt;head&gt; that can have content. Either between the start and end tag or a (mime) document pointed to by an URL.</body></comment><class><name>WALinkElement</name><environment>Seaside</environment><super>Seaside.WAContentElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document-Elements</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WALinkElement</class-id><body>Defines either a link or style sheet rules. If it has children then it defines style sheet rules, else it defines a link.= if link =This element defines a link. Unlike A, it may only appear in the HEAD section of a document, although it may appear any number of times. Although LINK has no content, it conveys relationship information that may be rendered by user agents in a variety of ways (e.g., a tool-bar with a drop-down menu of links).= style sheet rules =The STYLE element allows authors to put style sheet rules in the head of the document. HTML permits any number of STYLE elements in the HEAD section of a document.User agents that don't support style sheets, or don't support the specific style sheet language used by a STYLE element, must hide the contents of the STYLE element. It is an error to render the content as part of the document's text. Some style sheet languages support syntax for hiding the content from non-conforming user agents.</body></comment><class><name>WACurrentExceptionHandler</name><environment>Seaside</environment><super>Seaside.WADynamicVariable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Filter</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WACurrentExceptionHandler</class-id><body>I hold a reference to the current WAExceptionHandler. This may be needed when nesting exception handlers so that the look up of an exception handler from within an exception handler block still succeeds.</body></comment><class><name>WAConfigurationError</name><environment>Seaside</environment><super>Seaside.WAError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAAuthConfiguration</name><environment>Seaside</environment><super>Seaside.WASystemConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Filter</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAAuthConfiguration</class-id><body>WAAuthConfiguration defines attributes to store a username and password for an application. It is used by WAApplication to provide a basic single-account authentication mechanism for applications like the Seaside Configuration application. It changes to mainClass for the session to WAAuthMain, which adds a Decoration to check for authentication before displaying the root component.You can implement your own authentication mechanism without using this configuration by subclassing WAApplication and implementing #verifyPassword:forUser: to lookup account details from a database or similar. You can then manually set WAAuthMain as your main class.</body></comment><class><name>WAFileMetadataLibrary</name><environment>Seaside</environment><super>Seaside.WAAbstractFileLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Libraries</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAFileMetadataLibrary</class-id><body>I seek to address the following WAFileLibrary related issues:-""Arbitrary support for filenames"" JQuery-UI theme libraries contain currently unsupported filenames such as "e6e6e6_40x100_textures_02_glass_75.png".-""Arbitrary directories for files"" JQuery-UI (and Twitter Bootstrap) expects certain JavaScript files, images etc in a subdirectory, such as "ui/i18n/ui.datepicker-de.js".-""Arbitrary mime-types for files"" Currently mime-types are determined from the file-extension, sometimes it would be good to have some more control.WAAbstractFileLibrary has been introduced which acts as a base for the old file libraries derived from WAFileLibrary and introduces a new subclass WAFileMetadataLibrary. WAFileMetadataLibrary supports resources with paths, which is handy when, for example, the javascript or css in a file library expects its supporting images to be in subdirectories such as img/xxxx.png. WAFileMetadataLibrary also records the original filenames so that when you #deployFiles from the file library on a production server, the exported files will maintain their original names and paths.There's a new method for recursing a sub-directory tree to add all the files and record their relative paths:=MYWAFileMetadataDerivedFileLibrary recursivelyAddAllFilesIn: '/var/www/files/twitterbootstrap'</body></comment><class><name>WAEmailAddress</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>username address </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAUpdateRootVisitor</name><environment>Seaside</environment><super>Seaside.WAPainterVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Rendering</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAUpdateRootVisitor</class-id><body>A visitor which asks Painters to update a WARoot subclass using #updateRoot:.This is used to update the root of the Document stored on a WARenderContext.</body></comment><class><name>WARequest</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method uri version remoteAddress headers cookies body postFields sslSessionId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WARequest</class-id><body>I am a server independent http request object. Instance of me can be aquired through WAObject &gt;&gt; #currentRequest.Instance Variables	method:			&lt;String&gt;	uri:					&lt;WAUrl&gt;	version:				&lt;WAHttpVersion&gt;	remoteAddress:	&lt;String&gt;	headers:			&lt;Dictionary&lt;String, String&gt;&gt;	cookies:			&lt;Collection&lt;WARequestCookie&gt;&gt;	body:				&lt;String&gt;	postFields:			&lt;WARequestFields&gt;	sslSessionId:		&lt;String&gt;			method	- the HTTP method, should be upper case. In general only 'GET' and 'POST' are encountered in Seaside. SqueakSource also supports 'PUT'.		uri	- The request url without parameters. For example if the client requested 'http://www.google.com/search?q=seaside' then the contents of url would be '/search'. To get the parameters use #fields. This url is fully decoded. Use the #host method to get the host name. Dependening on the server adapter the #scheme may be 'http' or 'https' if the original request was HTTPS.	version	- The version of this request.	remoteAddress	- The IP address of the client. If the server is behind a reverse proxy then this is '127.0.0.1'. This could in theory also be an IPv6 address.headers	- The header of the HTTP request. This is a Dictionary mapping lowercase strings to other strings.	cookies	- The collection of cookies (instance of WARequestCookie) the client sent. Note not all clients support all fields. E.g. you might send a path but the client might not return it. Note there can be several cookies with the same key but a different domain or path. See the #cookiesAt: method.	body	- The undecoded, raw request body as a String, may be nil. See the "accessing-body" protocol for accessing it.	postFields	- The HTTP POST request parameters. In general this is a dictionary mapping Strings to Strings. In the case of multivalued paramters multiple mappings may exist.	sslSessionId	- The SSL session id. This is an opaque string. It is not present if the request wasn't made over SSL (or TLS) or the server adaptor does not support this feature.</body></comment><class><name>WACacheConfiguration</name><environment>Seaside</environment><super>Seaside.WASystemConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Cache</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WACacheConfiguration</class-id><body>I am the configuration of WAHashCache.</body></comment><class><name>WAHtmlAttributes</name><environment>Seaside</environment><super>Grease.GRSmallDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAHtmlAttributes</class-id><body>I represent the attributes of a (X)(HT)ML tag. Compared to my superclass I ignore requests to add a nil-values. I also don't throw an exception when accessing a key that doesn't exist, but instead return nil.</body></comment><class><name>WAClassBindingAttribute</name><environment>Seaside</environment><super>Seaside.WAListAttribute</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAResponse</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>headers cookies status message </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAResponse</class-id><body>A WAResponse is an abstract HTTP response objects. It is independent of the used server adapter.Instance Variables	status:		&lt;Integer&gt; The HTTP status code.	message:	&lt;String&gt; The HTTP status message.	headers:	&lt;WAHeaderFields&gt; A dictionary with the header fields.	cookies:	&lt;OrderedCollection&gt; A collection of cookies.</body></comment><class><name>WARequestContextNotFound</name><environment>Seaside</environment><super>Seaside.WAError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Exceptions</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WARequestContextNotFound</class-id><body>This exception is raised when trying to obtain the current request context when none is available.</body></comment><class><name>WALocale</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>language country </inst-vars><class-inst-vars>iso2Languages iso3Languages iso2Countries iso3Countries </class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WALocale</class-id><body>A WALocale defines a users langauge and country.Instance Variables	country:		&lt;String&gt;	language:		&lt;String&gt;country	- either an ISO 2 or ISO 3 country codelanguage	- either an ISO 2 or ISO 3 language code</body></comment><class><name>WARequestHandlingConfiguration</name><environment>Seaside</environment><super>Seaside.WASystemConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WARequestHandlingConfiguration</class-id><body>This configuration class holds attributes needed by classes in the Request Handling layer.</body></comment><class><name>WARegistryConfiguration</name><environment>Seaside</environment><super>Seaside.WASystemConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WARenderNotification</name><environment>Seaside</environment><super>Seaside.WANotification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Exceptions</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAExceptionFilterConfiguration</name><environment>Seaside</environment><super>Seaside.WASystemConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Filter</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WARenderer</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>context lastId </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>Seaside-Core-Rendering</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WARenderer</class-id><body>A Renderer provides methods for rendering data (typically HTML) onto a Document. It gets all the information needed to do its work from a WARenderContext, which is passed in on initialization.Renderer are typically controlled by a Painter.</body></comment><class><name>WAHashCache</name><environment>Seaside</environment><super>Seaside.WAExpiringCache</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyTable size byAccessStart byAccessEnd byCreationStart byCreationEnd </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Cache</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAHashCache</class-id><body>WAHashCache is a hash table based implementation of WACache.The characteristics of WAHashCache are:- supports both absolute and relative timeouts at the same time https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Automatic_Session_Expiration- supports a maximum size with definable overflow action (expire oldest, expire least recently used, signal exception)- access by key is fast (O(1) average case O(n) worst case)- reaping expired sessions is proportional (O(n)) to the number of expired session and independent of the total number of sessions (O(1))- creating a new session independent of the total number of sessions- does not guard against hash collision attacks, you should not use user generated keysInstance Variables:	keyTable 				&lt;Array&gt;	valueTable				&lt;Array&gt;	size					&lt;Integer&gt;	byAccessStart			&lt;WACacheListEntryNG&gt;	byAccessEnd			&lt;WACacheListEntryNG&gt;	byCreationStart		&lt;WACacheListEntryNG&gt;	byCreationEnd			&lt;WACacheListEntryNG&gt;</body></comment><class><name>WAClosingConditionalComment</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document-Elements</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAClosingConditionalComment</class-id><body>Closes a WAConditionalComment.</body></comment><class><name>WAHtmlDocument</name><environment>Seaside</environment><super>Seaside.WAXmlDocument</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scriptGenerator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAHtmlDocument</class-id><body>A WAHtmlDocument controls how a string is created from a series of brushes.</body></comment><class><name>WANumberAttribute</name><environment>Seaside</environment><super>Seaside.WAAttribute</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WANumberAttribute</class-id><body>WANumberAttribute represents a number attribute. It converts between text entered on the configuration page and numbers.</body></comment><class><name>WARequestFields</name><environment>Seaside</environment><super>Grease.GROrderedMultiMap</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAComboResponse</name><environment>Seaside</environment><super>Seaside.WAResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bufferedStream externalStream committed closed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAComboResponse</class-id><body>WAComboResponse is a combination of a buffered and a streaming response. By default, WAComboResponse will buffer the entire response to be sent at the end of the request processing cycle. If streaming is desired, the response can be flushed by sending it the #flush message. Flushing a response will sent all previously buffered data using chunked transfer-encoding (which preserves persistent connections). Clients can flush the response as often as they want at appropriate points in their response generation; everything buffered up to that point will be sent. For example, a search results page might use something like:renderContentOn: aCanvas	"Render the search page"	self renderSearchLabelOn: aCanvas.	aCanvas flush. "flush before starting search to give immediate feedback"	self searchResultsDo:[:aResult|		self renderSearchResultOn: aCanvas.		aCanvas flush. "flush after each search result"	].After a response has been flushed once, header modifications are no longer possible and will raise a WAIllegalStateException.Server adaptors need to be aware that a committed response must be closed, when complete. An uncommitted response should be handled as usual by the server adapter.</body></comment><class><name>WAUploadCallback</name><environment>Seaside</environment><super>Seaside.WAValueCallback</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Callbacks</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAAllUploadsCallback</name><environment>Seaside</environment><super>Seaside.WAUploadCallback</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Callbacks</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAConcatenatedHtmlAttributeValue</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>values separator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAClassBindingCollectionAttribute</name><environment>Seaside</environment><super>Seaside.WAListAttribute</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WASnapshot</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objects </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Backtracking</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WASnapshot</class-id><body>I represent a memory snapshot of objects. Objects can be registered by sending the message #register:. All object snapshots are updated by sending #snapshot and restored by sending #restore. To have specific snpshot and restore actions for particular classes override #snapshotCopy and #restoreFromSnapshot: in your classes.</body></comment><class><name>WAMimeType</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>main sub parameters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAMimeType</class-id><body>A WAMimeType abstracts a Internet media type, it is a two-part identifier for file formats on the Internet.Instance Variables	main:			&lt;String&gt;	parameters:	&lt;GRSmallDictionary&gt;	sub:			&lt;String&gt;main	- the main typeparameters	- a lazily initialized dictionary of optional parameterssub	- the subtype</body></comment><class><name>WARenderVisitor</name><environment>Seaside</environment><super>Seaside.WAPainterVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>renderContext </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Rendering</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WARenderVisitor</class-id><body>A visitor that renders Painters. It creates an instance of the #rendererClass specified by each Painter it visits and passes it to the Painter with #renderContentOn:.</body></comment><class><name>WAAuthConfigurationError</name><environment>Seaside</environment><super>Seaside.WAError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Exceptions</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAAuthConfigurationError</class-id><body>A WAAuthConfigurationError is signaled when no WAAuthConfiguration was added to an application that is behind a WAAuthenticationFilter.</body></comment><class><name>WAUrlCallback</name><environment>Seaside</environment><super>Seaside.WAValueCallback</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Callbacks</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAUrlCallback</class-id><body>A WAEmailCallback is a callback for url input fields.</body></comment><class><name>WAScriptGenerator</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>loadScripts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAStringAttribute</name><environment>Seaside</environment><super>Seaside.WAAttribute</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAStringAttribute</class-id><body>WAStringAttribute represents a string attribute. It does the trivial conversion between text entered on the Seaside configuration page and a string.</body></comment><class><name>WAResponseNotification</name><environment>Seaside</environment><super>Seaside.WANotification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Exceptions</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAResponseNotification</class-id><body>A WAResponseNotification is signaled whenever the application server wants to return a response back to the client.</body></comment><class><name>WASharedConfiguration</name><environment>Seaside</environment><super>Seaside.WAUserConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars>instances </class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAAccept</name><environment>Seaside</environment><super>Seaside.WAQualifiedValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAAccept</class-id><body>A WAAccept is a WAQualifiedValue with a value that is an instance of WAMimeType. It represents how much a user agent prefers a certain mime type.</body></comment><class><name>WAFile</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents contentType fileName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAFile</class-id><body>I represent a file that was uploaded by the user via #fileInput.Instance Variables	contents:		&lt;ByteArray&gt;	contentType:	&lt;WAMimeType&gt;	fileName:		&lt;String&gt;contents	- the contents of the file, binarycontentType	- the content type of the file	fileName	- The name of the file the user agent uploaded. This is locale name on the machine of the client. The instance variable might include the full path on the file system, the accessor will never return the path.</body></comment><class><name>WAMutualExclusionCache</name><environment>Seaside</environment><super>Seaside.WACache</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mutex cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Cache</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAMutualExclusionCache</class-id><body>WAMutualExclusionCacheNG is a wrapper around a WACacheNG that wraps all messages in a mutex.Instance Variables:	mutex	&lt;WAMutex&gt;	cache	&lt;WACache&gt;</body></comment><class><name>WAAllEmailsCallback</name><environment>Seaside</environment><super>Seaside.WAAllValuesCallback</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Callbacks</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAResponseGenerator</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestContext </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAResponseGenerator</class-id><body>The response generator configures the response of the provided request context according to the called generation method. This class can be subclassed to provide custom response templates.</body></comment><class><name>WAIntegerAttribute</name><environment>Seaside</environment><super>Seaside.WANumberAttribute</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAInvalidHeaderValueError</name><environment>Seaside</environment><super>Seaside.WAError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAServerManager</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>adaptors </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>Seaside-Core-Server</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAScriptElement</name><environment>Seaside</environment><super>Seaside.WAContentElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document-Elements</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAScriptElement</class-id><body>The SCRIPT element places a script within a document. This element may appear any number of times in the HEAD of an HTML document.The script may be defined within the contents of the SCRIPT element or in an external file. If the src attribute is not set, user agents must interpret the contents of the element as the script. If the src has a URI value, user agents must ignore the element's contents and retrieve the script via the URI. Note that the charset attribute refers to the character encoding of the script designated by the src attribute; it does not concern the content of the SCRIPT element.</body></comment><class><name>WARequestContext</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handlers request response codec consumer properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WARequestContext</class-id><body>WARequestContext encapsulates all the knowledge that should be available while processing a single request. It does not matter if this is a request to a static file, an AJAX request, a long Comet request or a normal Seaside requestion.The request context is valid only during the request that caused it. It should not be stored. Neither within instance variables, nor within the execution stack so that it might be captured by a continuation. In both cases this might lead to memory leaks.</body></comment><class><name>WAFileLibraryResource</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filepath mimeType cacheDuration contents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Libraries</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAAttributeNotFound</name><environment>Seaside</environment><super>Seaside.WAConfigurationError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WACacheKeyEntry</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key keyHash value next byAccessListEntry byCreationListEntry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Cache</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAProtectionFilter</name><environment>Seaside</environment><super>Seaside.WARequestFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>remoteAddress </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Filter</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAProtectionFilter</class-id><body>The protection filter ensures that the wrapped request handler only accepts requests from the same IP. Do add this filter to a WASession for example to avoid session hijacking, do not add it to static request handlers such as WAApplication or WADispatcher as this might restrict access to the handler if your IP changes.Note that checking for IP addresses is not bullet proof and should never be used as the sole security measure for a web application as IP addresses can be easily spoofed.</body></comment><class><name>WAUrl</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scheme user password host port path slash queryFields fragment pathParameters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAUrl</class-id><body>I represent all portions of an URL as described by the RFC 1738 and updated by RFC 3986. I include scheme, userinfo, host, port, path, parameter, query, and fragment.Instance Variables	scheme:			&lt;String&gt; or nil	user:				&lt;String&gt; or nil	password:			&lt;String&gt; or nil	host:				&lt;String&gt; or nil	port:				&lt;Integer&gt; or nil	path:				&lt;OrderedCollection&gt; or nil	slash:				&lt;Boolean&gt;	queryFields:		&lt;WARequestFields&gt; or nil	fragment:			&lt;String&gt; or nil	pathParameters:	&lt;GROrderedMultiMap&gt; or nil		A Primer on URL encoding:http://blog.lunatech.com/2009/02/03/what-every-web-developer-must-know-about-url-encoding		Path Parameters:http://doriantaylor.com/policy/http-url-path-parameter-syntaxyou can have multiple name without values/path/name;param1;p2;p3or names with multiple values;param=val1,val2,val3</body></comment><class><name>WABufferedResponse</name><environment>Seaside</environment><super>Seaside.WAResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contentsStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WABufferedResponse</class-id><body>A WABufferedResponse is a concrete implementation of a HTTP response. Its contentsStream is used to represent the body of the message.Instance Variables	contentsStream:		&lt;WriteStream&gt; The contents of this message.</body></comment><class><name>WAValuesCallback</name><environment>Seaside</environment><super>Seaside.WAValueCallback</super><private>false</private><indexed-type>none</indexed-type><inst-vars>values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Callbacks</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAMultipleValuesCallback</name><environment>Seaside</environment><super>Seaside.WAValuesCallback</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Callbacks</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAUnregisteredHandlerError</name><environment>Seaside</environment><super>Seaside.WAError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Exceptions</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAUnregisteredHandlerError</class-id><body>This error is signaled by WARegistry whenever an attempt is made to find the key or URL for a handler that is not registered in its cache.</body></comment><class><name>WAAllUrlsCallback</name><environment>Seaside</environment><super>Seaside.WAAllValuesCallback</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Callbacks</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAReducedConflictCounter</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Cache</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAReducedConflictCounter</class-id><body>I am a fake implementation of RcCounter</body></comment><class><name>WAServerAdaptor</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>manager port requestHandler codec </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Server</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAServerAdaptor</class-id><body>A WAServer is the abstract base class for all servers. Actual servers do not have to subclass it but have to support the protocol: - #codec - #usesSmalltalkEncodingInstance Variables	codec:		&lt;WACodec&gt;codec	- the codec used for response conversion from characters to bytes</body></comment><class><name>WAUrlEncoder</name><environment>Seaside</environment><super>Seaside.WATableBasedEncoder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAUrlEncoder</class-id><body>I do percent-encoding of parts (e.g. path segments and arguments) of a URI.Additionally, a Codec is given the chance to encode the characters into bytes before being percent-encoded (see http://tools.ietf.org/html/rfc3986#section-2.5). This allows extended characters to be represented in URIs in, for example, UTF-8.</body></comment><class><name>WAHttpVersion</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>major minor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAFileLibrary</name><environment>Seaside</environment><super>Seaside.WAAbstractFileLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Libraries</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAFileLibrary</class-id><body>What does FileLibrary do=============================It allows to serve static files directly from seaside without the need for a standalone server like Apache or to configure Kom. These files can reference each other (say a CSS references an image) and can be distrubuted the same way as normal Smalltalk code (Monticello, SqueakMap, ...).Each file in a file library is represented by a method. The method name is created from the file name, the dot is removed and the first letter of the suffix in capitalized. This puts certain limitations to the allowed filenames. Eg. 'main.css' becomes #mainCss.Like Script- and StyleLibraries FileLibraries can be added to an application so that they automatically include themselves in the document root. Implement #selectorsToInclude and return the selectors you whish to be added to the document root.How to create a FileLibrary================================- First create the static files and put them in some directory. From there they can reference the other files in the same directory normally with their filenames.- Make sure you have a "Files" entry that serves your files. This is a normal entry point type that you can find in your /seaside/config application. If you don't already have one, you can create it if you select "Files" in the type field of the "add entry point" dialog. For the rest of this text we assume you chose "files" as the path.- Create a subclass of WAFileLibrary, for the rest of this text I assume its name is MyFileLibrary.- To add the files to your file library there are two ways.1. Programmatically with MyFileLibrary class &gt;&gt; #addAllFilesIn: / #addFileNamed:. For example MyFileLibrary addAllFilesIn: '/path/to/directory/with/files' or MyFileLibrary addFileNamed: '/path/to/background.png'.2. Via the web interface. Go to your /seaside/config application and there click configure for your "Files". Click "configure" behind MyFileLibrary. There you can add a file by uploading it (select the file, then click "Add")Note that a "Files" can consist of several file libraries and can even have tradional script or style libraries.How to integrate a FileLibrary into your application=============================================================Files from a FileLibrary are ingetrated the same way other static files are integrated. They have a constant path that is '/seaside/&lt;Static File Library&gt;/&lt;FileLibrary class name&gt;/&lt;filename&gt;' so for example '/seaside/files/MyFileLibrary/background.png'. These can be conveniently generated by 'MyFileLibrary / #aSelector' where #aSelector is the name of the method representing that file. For example 'MyFileLibrary / #backgroundPng'.How to get back the files in a FileLibrary=================================================The contents of a file library can be written out to disk. Writing out a file library first makes a folder with the name of the file library in the folder of your Smallatlk image. Then a file for each file in the file library is created in this folder. Writing out to disk can happen in three ways1. MyFileLibrary default deployFiles2. Via the configuration interface of the file library. On the same page where you can add files to your file library there is also a button 'write to disk' which will write out all the files in this library.3. Via the configuration interface of your application. In the section where you can add libraries to your application there is a a button 'write to disk' which will write out all the libraries of this application.Examples:==========The following code uses WAFileLibrary to add a CSS file to a page.updateRoot: anHtmlRoot	super updateRoot: anHtmlRoot.	anHtmlRoot stylesheet 		url: WAFileLibraryDemo / #mainCss		The folllowing code uses WAFileLibrary to display an image.renderContentOn: html	html image		url: WAFileLibraryDemo / #mainJpg		Trouble Shooting:==========Earlier versions would create methods without a time stamp. You can fix this by recompiling these methods by adapting the following codeSUAllTestLibrary basicNew in: [ :library |	#(demologoGif headerGif backgroundGif demoGif logoGif menuGif) do: [ :each |		library class			addFileNamed: (library asFilename: each)			contents: (library perform: each) ] ]</body></comment><class><name>WARenderContext</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>visitor actionUrl actionBaseUrl resourceUrl callbacks document properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Rendering</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WARenderContext</class-id><body>A WARenderContext provides all the state needed by a Renderer to do its work.It is a decoupling device between whatever is initiating rendering and the Renderer itself.</body></comment><class><name>WADispatchCallback</name><environment>Seaside</environment><super>Seaside.WACallback</super><private>false</private><indexed-type>none</indexed-type><inst-vars>callbacks </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Callbacks</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAMaximumNumberOfSessionsExceededError</name><environment>Seaside</environment><super>Seaside.WAError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Cache</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAMaximumNumberOfSessionsExceededError</class-id><body>http://ora-00018.ora-code.com/</body></comment><class><name>WATransactionFilter</name><environment>Seaside</environment><super>Seaside.WARequestFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>closed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Filter</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WATransactionFilter</class-id><body>This filter provides the implementation of WAComponent&gt;&gt;#isolate:. It rejects all requests as soon as the filter has been closed.</body></comment><class><name>WABuilder</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullDocument rootBlock rootClass documentClass scriptGeneratorClass rendererClass codec actionUrl resourceUrl </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Rendering</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WABuilder</class-id><body>This is a convenience class which provides a result of a rendering operation as a string. It is expected to be used like this:WAHtmlCanvas builder render: [ :html |	html anchor		url: 'htttp://www.seaside.st';		with: 'Seaside Homepage' ]See WABuilderCanvasTest for more examples.</body></comment><class><name>WAStreamedResponse</name><environment>Seaside</environment><super>Seaside.WAResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>committed externalStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAStreamedResponse</class-id><body>A WAStreamedResponse is a HTTP response that directly writes to an external write stream. This response class is used to implement efficient HTTP response streaming, as it can directly write do the socket while content is still generated.Instance Variables	committed:		&lt;Boolean&gt;	Whether the status and header was written to the stream.	externalStream:		&lt;WriteStream&gt;	The external stream to write to.</body></comment><class><name>WAMergedRequestFields</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>delegates </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAMergedRequestFields</class-id><body>Provides a read-only view onto multiple dictionaries. Note that this can lead to to duplicated keys that can only retrieved by iterating over all the associations.</body></comment><class><name>WAHashTableSizes</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>sizes </class-inst-vars><imports></imports><category>Seaside-Core-Cache</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAHashTableSizes</class-id><body>WAHashTableSizes is a helper class, used by hashedCollections to determine sizes for hash tables.Public protocol is all class-side:#goodSizeAtLeast: anInteger   answers a "good" integer greater than or equal to the given integer.An integer is not "good" as a hash table size if it is any of:* Not prime* Divides 256**k +- a, for small k and a* Close to a power of two* Close to dividing the hashMultiply constantSee Andres Valloud's hashing book, and Knuth TAOCP vol. 3.This class caches a table of selected good primes within the positive SmallInteger range. When this table must be rebuilt, it uses an instance to compute the table. Primes are selected to keep the table fairly small, with approximately five entries per power of two.The cached table is ordered, and is searched with a binary search to find the closest good size &gt;= the requested size.Original implementation by Martin McClure</body></comment><class><name>WADefaultScriptGenerator</name><environment>Seaside</environment><super>Seaside.WAScriptGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WADefaultScriptGenerator</class-id><body>A WADefaultScriptGenerator uses the onLoad event on the body to trigger the load scripts. Events handlers are directly inlined with the respective elements. Both techniques are considered outdated and should be avoided if possible.</body></comment><class><name>WAValueHolder</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Utilities</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAValueHolder</class-id><body>I wrap a single object. I am like value holder except that I am portable and don't include the Model cruft in Squeak.</body></comment><class><name>WAMutex</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>semaphore owner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Utilities</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAMutex</class-id><body>WAMutex provides mutual exclusion properties.Only one process at a time can execute code within its #critical: method. Other processes attempting to call #critical: will block until the first process leaves the critical section. The process that owns the mutex (the one currently in the critical section), however, may call #critical: repeatedly without fear of blocking.The process currently inside the critical section can be terminated by calling #terminateOwner. This will result in the process being unwound and the critical section being freed.</body></comment><class><name>WAUpdateUrlVisitor</name><environment>Seaside</environment><super>Seaside.WAPainterVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>url </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Rendering</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WAUpdateUrlVisitor</class-id><body>A visitor which asks Painters to update a WAUrl subclass using #updateRoot:.This is used to update the base URL stored on a WARenderContext.</body></comment><class><name>WABulkReapingCacheEntry</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value creationTime accessTime count lastCount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Cache</category><attributes><package>Seaside-Core</package></attributes></class><comment><class-id>Seaside.WABulkReapingCacheEntry</class-id><body>I am a value in a WABulkReapingCache. It's important that my values are not concurrently updated in order to avoid commit conflicts on GemStone/S.accessTime:		only set by reapercreationTime:	immutable, set only oncevalue:			immutable, set only oncelastCount:		only set by reapercount:			updated concurrently but this is not an issue since we use a WAReducedConflictCounter    Instance Variables	count:			&lt;WAReducedConflictCounter&gt;	lastCount:		&lt;Integer&gt;	creationTime:	&lt;Integer&gt;	accessTime:		&lt;Integer&gt;	value:			&lt;Object&gt;</body></comment><shared-variable><name>StatusMessages</name><environment>Seaside.WAResponse</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Seaside-Core</package></attributes></shared-variable><shared-variable><name>MimeTypes</name><environment>Seaside.WAAbstractFileLibrary</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Seaside-Core</package></attributes></shared-variable><methods><class-id>Seaside.WAObject</class-id> <category>dynamic variables</category><body package="Seaside-Core">requestContext	"Answer the current WARequestContext instance."	^ WACurrentRequestContext value</body></methods><methods><class-id>Seaside.WAObject class</class-id> <category>error handling</category><body package="Seaside-Core">defaultErrorClass	^ WAError</body></methods><methods><class-id>Seaside.WAVisitor</class-id> <category>visiting</category><body package="Seaside-Core">start: anObject	self visit: anObject</body><body package="Seaside-Core">visit: anObject	anObject accept: self</body><body package="Seaside-Core">visitAll: aCollection	aCollection do: [ :each | self visit: each ]</body></methods><methods><class-id>Seaside.WAAttributeVisitor</class-id> <category>visiting</category><body package="Seaside-Core">visitAttribute: anAttribute</body><body package="Seaside-Core">visitBooleanAttribute: anAttribute	self visitAttribute: anAttribute</body><body package="Seaside-Core">visitClassBindingAttribute: anAttribute	self visitListAttribute: anAttribute</body><body package="Seaside-Core">visitClassBindingCollectionAttribute: anAttribute	self visitListAttribute: anAttribute</body><body package="Seaside-Core">visitClassListAttribute: anAttribute	self visitListAttribute: anAttribute</body><body package="Seaside-Core">visitCollectionAttribute: anAttribute	self visitListAttribute: anAttribute</body><body package="Seaside-Core">visitIntegerAttribute: anAttribute	self visitNumberAttribute: anAttribute</body><body package="Seaside-Core">visitListAttribute: anAttribute	self visitAttribute: anAttribute</body><body package="Seaside-Core">visitNumberAttribute: anAttribute	self visitAttribute: anAttribute</body><body package="Seaside-Core">visitPasswordAttribute: anAttribute	self visitAttribute: anAttribute</body><body package="Seaside-Core">visitStringAttribute: anAttribute	self visitAttribute: anAttribute</body><body package="Seaside-Core">visitUrlAttribute: anAttribute	self visitAttribute: anAttribute</body></methods><methods><class-id>Seaside.WAHandlerTrackingStrategy</class-id> <category>public</category><body package="Seaside-Core">addKey: aString toContext: aRequestContext	"Add the key of the handler to the request context. This is mostly used for adding a cookie to the response."	self subclassResponsibility</body><body package="Seaside-Core">addKey: aString toUrl: aUrl	"Add the key of the handler to the URL."	self subclassResponsibility</body><body package="Seaside-Core">keyFromContext: aRequestContext	"Answer the handler key extracted from aRequestContext.	The key is used to look up the handler in the registry.		Keys are used to track both sessions and request handlers so a key of a request handler should override the key of a session	(eg. if you have a session cookie and a query field you have to answer the query field of the request handler)."	self subclassResponsibility</body><body package="Seaside-Core">noHandlerFoundForKey: aString in: anApplication context: aRequestContext	"This message is sent when no handler with the given key was found. Either there wasn't on in the first place or it was expired.		The default behavior is just to let the application handle an expired handler.	In some cases additional actions need to be performed (eg. deleting a session cookie).	In some cases at he tracking stragety does not support generating a random handler key (eg. IP address or ssl session id based), in these cases a new session with the given key has to be created. As ususal care has to be taken that this is done only for expired sessions and not for expired document handlers."	anApplication handleExpired: aRequestContext</body></methods><methods><class-id>Seaside.WAHandlerTrackingStrategy</class-id> <category>private</category><body package="Seaside-Core">addPathParameterWithValue: aString to: aUrl	| path |	path := aUrl path.	path isEmpty ifTrue: [		"hack if path is empty, will result in		/;_s=1234?_k=5678"		aUrl addToPath: '' ].	aUrl addPathParameterAt: path size key: self keyField value: aString</body><body package="Seaside-Core">addQueryFieldWithValue: aString to: aUrl	aUrl addField: self keyField value: aString</body><body package="Seaside-Core">keyField	"Answer the name of the field used to track handlers."	^ '_s'</body><body package="Seaside-Core">pathParameterKeyFromContext: aRequestContext	| url |	url := aRequestContext request url.	1 to: url path size do: [ :index |		| key |		key := url pathParameterAt: index key: self keyField ifAbsent: [ nil ].		key isNil ifFalse: [			^ key ] ].	^ nil</body><body package="Seaside-Core">queryFieldKeyFromContext: aRequestContext	^ aRequestContext request at: self keyField ifAbsent: [ nil ]</body></methods><methods><class-id>Seaside.WAHandlerTrackingStrategy class</class-id> <category>testing</category><body package="Seaside-Core">isAbstract	^ self name = #WAHandlerTrackingStrategy</body></methods><methods><class-id>Seaside.WAQueryFieldHandlerTrackingStrategy</class-id> <category>public</category><body package="Seaside-Core">addKey: aString toContext: aRequestContext	"Nothing to do, we only add to the URL"</body><body package="Seaside-Core">addKey: aString toUrl: aUrl	self addQueryFieldWithValue: aString to: aUrl</body><body package="Seaside-Core">keyFromContext: aRequestContext	^ self queryFieldKeyFromContext: aRequestContext</body></methods><methods><class-id>Seaside.WAConditionalComment</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithRoot: anHtmlRoot	self initialize.	root := anHtmlRoot.	condition := 'if'</body></methods><methods><class-id>Seaside.WAConditionalComment</class-id> <category>private</category><body package="Seaside-Core">addToCondition: aString	condition := condition , aString</body><body package="Seaside-Core">closingConditionClass	^ WAClosingConditionalComment</body><body package="Seaside-Core">openingConditionClass	^ WAOpeningConditionalComment</body></methods><methods><class-id>Seaside.WAConditionalComment</class-id> <category>operators</category><body package="Seaside-Core">equal	"implicit of nothing else"</body><body package="Seaside-Core">greaterThan	self addToCondition: ' gt'</body><body package="Seaside-Core">lessThan	self addToCondition: ' lt'</body><body package="Seaside-Core">not	self addToCondition: ' !'</body><body package="Seaside-Core">orEqual	self addToCondition: 'e'</body></methods><methods><class-id>Seaside.WAConditionalComment</class-id> <category>public</category><body package="Seaside-Core">do: aBlock	root add: (self openingConditionClass condition: condition).	aBlock value.	root add: (self closingConditionClass new)</body></methods><methods><class-id>Seaside.WAConditionalComment</class-id> <category>features</category><body package="Seaside-Core">ie	self addToCondition: ' IE'</body><body package="Seaside-Core">ie5	self addToCondition: '5'</body><body package="Seaside-Core">ie50	self addToCondition: '5.0'</body><body package="Seaside-Core">ie55	self ie: '5.5'</body><body package="Seaside-Core">ie6	self ie: '6'</body><body package="Seaside-Core">ie7	self ie: '7'</body><body package="Seaside-Core">ie8	self ie: '8'</body><body package="Seaside-Core">ie9	self ie: '9'</body><body package="Seaside-Core">ie: aString	self addToCondition: ' IE ', aString</body></methods><methods><class-id>Seaside.WAConditionalComment class</class-id> <category>instance creation</category><body package="Seaside-Core">root: anHtmlRoot	^ self basicNew initializeWithRoot: anHtmlRoot</body></methods><methods><class-id>Seaside.WAQualifiedValue</class-id> <category>accessing</category><body package="Seaside-Core">quality	^ quality</body><body package="Seaside-Core">quality: aFloat	quality := aFloat</body><body package="Seaside-Core">value	^ value</body><body package="Seaside-Core">value: anObject	value := anObject</body></methods><methods><class-id>Seaside.WAQualifiedValue</class-id> <category>comparing</category><body package="Seaside-Core">&lt;= other	^ self quality &lt;= other quality</body></methods><methods><class-id>Seaside.WAQualifiedValue</class-id> <category>printing</category><body package="Seaside-Core">printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: value;		nextPutAll: ',q=';		print: quality;		nextPut: $)</body></methods><methods><class-id>Seaside.WAQualifiedValue class</class-id> <category>private</category><body package="Seaside-Core">valueClass	self subclassResponsibility</body></methods><methods><class-id>Seaside.WAQualifiedValue class</class-id> <category>instance creation</category><body package="Seaside-Core">fromString: aString	^ Array streamContents: [ :stream |		GRPlatform subStringsIn: aString splitBy: $, do: [ :each |			| value quality semicolonIndex |			quality := 1.0. "default value according to spec"			semicolonIndex := each indexOf: $;.			semicolonIndex = 0				ifTrue: [					value := self valueClass fromString: each trimBoth ]				ifFalse: [					| parameters |					parameters := nil.					value := self valueClass fromString: (each copyFrom: 1 to: semicolonIndex - 1) trimBoth.					GRPlatform subStringsIn: (each copyFrom: semicolonIndex + 1 to: each size) splitBy: $; do: [ :parameter |						| key parameterValue |						key := (parameter copyUpTo: $=) trimBoth.						parameterValue := (parameter copyAfter: $=) trimBoth.						key = 'q'							ifTrue: [								parameterValue first = $. ifTrue: [									"work around for Issue 655									some user agents send '.2' instead of '2.0'"									parameterValue := '0', parameterValue ].								quality := Float readFrom: parameterValue readStream ]							ifFalse: [								parameters isNil ifTrue: [									parameters := GRSmallDictionary new ].								parameters at: key put: parameterValue ] ].					(parameters isNil not and: [ value respondsTo: #parameters: ]) ifTrue: [						"only WAMimeType actually supports parameters"						value parameters: parameters ] ].			stream nextPut: (self value: value quality: quality) ] ]</body><body package="Seaside-Core">value: anObject quality: aFloat	^ self new		value: anObject;		quality: aFloat;		yourself</body></methods><methods><class-id>Seaside.WAAcceptEncoding class</class-id> <category>private</category><body package="Seaside-Core">valueClass	^ String</body></methods><methods><class-id>Seaside.WAClosingRevealedConditionalComment</class-id> <category>printing</category><body package="Seaside-Core">encodeOn: aDocument	aDocument nextPutAll: '&lt;!--&lt;![endif]--&gt;'</body></methods><methods><class-id>Seaside.WARequestHandler</class-id> <category>private-accessing</category><body package="Seaside-Core">filter	^ filter contents</body><body package="Seaside-Core">setFilter: aFilter	filter contents: aFilter</body></methods><methods><class-id>Seaside.WARequestHandler</class-id> <category>filters</category><body package="Seaside-Core">addFilter: aFilter	"Add aFilter to the receiver. Answer the filter added."	^ self addFilterLast: aFilter</body><body package="Seaside-Core">addFilterFirst: aFilter	"Add aFilter as the first one in the filter chain. Answer the filter added."	aFilter setNext: self filter.	self setFilter: aFilter.	^ aFilter</body><body package="Seaside-Core">addFilterLast: aFilter	"Add aFilter as the last one in the filter chain. Answer the filter added."	| previous current |	previous := nil.	current := self filter.	[ current = self ] whileFalse: [		previous := current.		current := current next ].	aFilter setNext: current.	previous isNil		ifTrue: [ self setFilter: aFilter ]		ifFalse: [ previous setNext: aFilter ].	^ aFilter</body><body package="Seaside-Core">filters	"Answer an ordered collection of all filters active in the receiver."		| current result |	current := self filter.	result := OrderedCollection new.	[ current = self ] whileFalse: [		result add: current.		current := current next ].	^ result</body><body package="Seaside-Core">handler	^ self</body><body package="Seaside-Core">removeFilter: aFilter	"Remove aFilter from the receiver. Answer the removed filter or nil."	| previous current |	previous := nil.	current := self filter.	[ current = self ] whileFalse: [		current = aFilter ifTrue: [			previous isNil				ifTrue: [ self setFilter: current next ]				ifFalse: [ previous setNext: current next ].			^ aFilter setNext: nil ].		previous := current.		current := current next ].	^ nil</body></methods><methods><class-id>Seaside.WARequestHandler</class-id> <category>testing</category><body package="Seaside-Core">isDispatcher	^ false</body><body package="Seaside-Core">isRegistry	^ false</body><body package="Seaside-Core">isRoot	^ self parent isNil</body></methods><methods><class-id>Seaside.WARequestHandler</class-id> <category>handling</category><body package="Seaside-Core">handle: aRequestContext	"Handle a request described by aRequestContext. Do not override this method; instead subclass #handleFiltered: to allow filters to process the request first."	aRequestContext push: self during: [ self filter handleFiltered: aRequestContext ]</body><body package="Seaside-Core">handleFiltered: aRequestContext 	"Handle aRequestContext by either dispatching to a different request handler of by producing a response and singalling the result."	self subclassResponsibility</body></methods><methods><class-id>Seaside.WARequestHandler</class-id> <category>copying</category><body package="Seaside-Core">copyTo: aRequestHandler	^ aRequestHandler</body><body package="Seaside-Core">postCopy	super postCopy.	filter := filter copy.	self setFilter: (self filter copyTo: self).	configuration := configuration copy.	parent := nil</body></methods><methods><class-id>Seaside.WARequestHandler</class-id> <category>filters-convenience</category><body package="Seaside-Core">exceptionHandler: anExceptionHandlerClass	| theFilter |	theFilter := self filters		detect: [ :ea | ea isExceptionFilter ]		ifNone: [ self addFilter: WAExceptionFilter new ].		theFilter configuration at: #exceptionHandler put: anExceptionHandlerClass</body></methods><methods><class-id>Seaside.WARequestHandler</class-id> <category>configuration</category><body package="Seaside-Core">charSet	^ self preferenceAt: #charSet</body><body package="Seaside-Core">configuration	^ configuration</body><body package="Seaside-Core">configuration: aConfiguration	configuration := aConfiguration</body><body package="Seaside-Core">defaultConfiguration	^ WAUserConfiguration new		addParent: WARequestHandlingConfiguration instance;		yourself</body><body package="Seaside-Core">documentClass	^ (self preferenceAt: #documentClass) value</body><body package="Seaside-Core">preferenceAt: aSymbol	^ self configuration at: aSymbol</body><body package="Seaside-Core">preferenceAt: aSymbol ifAbsent: aBlock	^ self configuration at: aSymbol ifAbsent: aBlock</body><body package="Seaside-Core">preferenceAt: aSymbol put: anObject	anObject isNil		ifTrue: [ self configuration removeExpressionAt: aSymbol ]		ifFalse: [ self configuration at: aSymbol put: anObject ].		^ anObject</body><body package="Seaside-Core">responseGenerator	^ (self preferenceAt: #responseGenerator) value</body><body package="Seaside-Core">scriptGeneratorClass	^ (self preferenceAt: #scriptGeneratorClass) value</body><body package="Seaside-Core">scriptGeneratorClass: aClass	self preferenceAt: #scriptGeneratorClass put: (GRPlatform current bindingOf: aClass)</body><body package="Seaside-Core">serverHostname	^ self preferenceAt: #serverHostname</body><body package="Seaside-Core">serverHostname: aString	self preferenceAt: #serverHostname put: aString</body><body package="Seaside-Core">serverPath	^ self preferenceAt: #serverPath</body><body package="Seaside-Core">serverPath: aString	self preferenceAt: #serverPath put: aString</body><body package="Seaside-Core">serverPort	^ self preferenceAt: #serverPort</body><body package="Seaside-Core">serverPort: anInteger	self preferenceAt: #serverPort put: anInteger</body><body package="Seaside-Core">serverProtocol	^ self preferenceAt: #serverProtocol</body><body package="Seaside-Core">serverProtocol: aSymbol	self preferenceAt: #serverProtocol put: aSymbol</body></methods><methods><class-id>Seaside.WARequestHandler</class-id> <category>accessing</category><body package="Seaside-Core">name	^ self isRoot		ifTrue: [ '' ]		ifFalse: [ self parent nameOfHandler: self ]</body><body package="Seaside-Core">parent	^ parent</body><body package="Seaside-Core">url	| url |		url := self basicUrl.	self serverPath isNil ifFalse: [ url parsePath: self serverPath ].	self serverProtocol isNil ifFalse: [ url scheme: self serverProtocol ].	self serverHostname isNil ifFalse: [ url host: self serverHostname ].	self serverPort isNil ifFalse: [ url port: self serverPort ].	^ url</body><body package="Seaside-Core">urlFor: aRequestHandler	"Return the URL for the given request handler, which should be a	child of the receiver. The default implementation simply returns the	receiver's URL, but subclasses should override to add a relevant	parameter or path segment that identifies the particular chid."	^ self url</body></methods><methods><class-id>Seaside.WARequestHandler</class-id> <category>parent/child</category><body package="Seaside-Core">childrenDo: aBlock	"Request handlers that act as containers should implement this method to	iterate over all child handlers and pass each into aBlock."</body><body package="Seaside-Core">setParent: aRequestHandler	parent notNil ifTrue: [ parent unregister: self ].	parent := aRequestHandler</body><body package="Seaside-Core">unregister	"Unregister this request handler from its parent handler."		parent notNil ifTrue: [ parent unregister: self ]</body><body package="Seaside-Core">unregister: aRequestHandler	"Request handlers that act as containers should implement this method to	remove aRequestHandler from their collections and send #unregistered to	aRequestHandler. This method is also called by #setParent:."</body><body package="Seaside-Core">unregistered	"This method is called to notify a RequestHandler that it has been removed	from its container. Subclasses should override to perfrom cleanup actions."	parent := nil</body><body package="Seaside-Core">withDescendantsDo: aBlock	"Evaluate aBlock for this request handler and recursively for each of	its child handlers."		aBlock value: self.	self childrenDo: [ :each | each withDescendantsDo: aBlock ]</body></methods><methods><class-id>Seaside.WARequestHandler</class-id> <category>private</category><body package="Seaside-Core">authConfigurationError: aString	WAAuthConfigurationError signal: aString</body><body package="Seaside-Core">basicUrl	^ self isRoot		ifTrue: [ WAUrl new ]		ifFalse: [ self parent urlFor: self ]</body></methods><methods><class-id>Seaside.WARequestHandler</class-id> <category>initialization</category><body package="Seaside-Core">initialize	super initialize.	configuration := self defaultConfiguration.	filter := WAValueHolder with: self</body></methods><methods><class-id>Seaside.WARequestHandler</class-id> <category>authentication</category><body package="Seaside-Core">verifyPassword: password forUser: username 	"This method is called by WAAuthMain to verify the username provided	in the HTTP request. The default implementation compares them against	the configuration values provided by WAAuthConfiguration. WAAuthMain	can also be used by itself if you implement this method in your	own Application subclass to do something different."	| loginPreference hashPreference |	loginPreference := self preferenceAt: #login.	hashPreference := self preferenceAt: #passwordHash.	loginPreference isNil ifTrue: [		self authConfigurationError: 'Login not defined. The default authentication method requires a WAAuthConfiguration' ].	hashPreference isNil ifTrue: [		self authConfigurationError: 'Password not defined. The default authentication method requires a WAAuthConfiguration' ].	^ username isEmptyOrNil not		and: [ password isEmptyOrNil not		and: [ loginPreference = username		and: [ hashPreference = (GRPlatform current secureHashFor: password) ] ] ]</body></methods><methods><class-id>Seaside.WARequestHandler</class-id> <category>enumerating</category><body package="Seaside-Core">parentChildPairsDo: aTwoArgumentBlock	"Evaluate the given two argument block for all the direct parent-child handler pairs in the handler chain up the receiver."	self parent isNil ifFalse: [		self parent parentChildPairsDo: aTwoArgumentBlock.		aTwoArgumentBlock value: self parent value: self ]</body></methods><methods><class-id>Seaside.WARequestHandler class</class-id> <category>accessing</category><body package="Seaside-Core">concreteSubclasses	^ self allSubclasses reject: [ :each | each isAbstract ]</body><body package="Seaside-Core">description	^ self name greaseString</body></methods><methods><class-id>Seaside.WARequestHandler class</class-id> <category>testing</category><body package="Seaside-Core">isAbstract	^ self name = #WARequestHandler</body></methods><methods><class-id>Seaside.WADispatcher</class-id> <category>testing</category><body package="Seaside-Core">isDispatcher	^ true</body></methods><methods><class-id>Seaside.WADispatcher</class-id> <category>accessing</category><body package="Seaside-Core">defaultHandler	self defaultName isNil ifTrue: [ ^ nil ].	^ self handlerAt: self defaultName ifAbsent: [ nil ]</body><body package="Seaside-Core">defaultName	^ defaultName</body><body package="Seaside-Core">defaultName: aString	defaultName := aString</body><body package="Seaside-Core">handlerAt: aString	^ self			handlerAt: aString			with: [ :dispatcher :token |				dispatcher handlers at: token ]</body><body package="Seaside-Core">handlerAt: aString ifAbsent: aBlock	^ self		handlerAt: (aString			ifNil: [ ^ aBlock value ])		with: [ :dispatcher :token |			dispatcher handlers				at: token				ifAbsent: [ ^ aBlock value ] ]</body><body package="Seaside-Core">handlerAt: aString with: aBlock	| dispatcher |	dispatcher := self.	GRPlatform subStringsIn: aString splitBy: $/ do: [ :token |		dispatcher := aBlock value: dispatcher value: token ].	^ dispatcher</body><body package="Seaside-Core">handlers	^ handlers</body><body package="Seaside-Core">nameOfHandler: aRequestHandler 	"Answer the name of the given request handler. Signal an error the given handler is not registered in the receiver."	^ handlers		keyAtValue: aRequestHandler		ifAbsent: [ WAUnregisteredHandlerError signal ]</body><body package="Seaside-Core">urlFor: aRequestHandler	^ self url		addToPath: (self nameOfHandler: aRequestHandler);		yourself</body></methods><methods><class-id>Seaside.WADispatcher</class-id> <category>handling</category><body package="Seaside-Core">handleDefault: aRequestContext	self defaultName isNil		ifTrue: [ aRequestContext responseGenerator forbidden; respond ]		ifFalse: [ self handleFiltered: aRequestContext named: self defaultName ]</body><body package="Seaside-Core">handleFiltered: aRequestContext	| consumer |	consumer := aRequestContext consumer.	consumer atEnd		ifTrue: [ self handleDefault: aRequestContext ]		ifFalse: [ self handleFiltered: aRequestContext named: consumer next ]</body><body package="Seaside-Core">handleFiltered: aRequestContext named: aString	(self 		handlerAt: aString 		ifAbsent: [ aRequestContext responseGenerator notFound; respond ])			handle: aRequestContext</body></methods><methods><class-id>Seaside.WADispatcher</class-id> <category>copying</category><body package="Seaside-Core">postCopy	super postCopy.	handlers := handlers valuesCollect: [ :each | each copy setParent: self; yourself ]</body></methods><methods><class-id>Seaside.WADispatcher</class-id> <category>parent/child</category><body package="Seaside-Core">childrenDo: aBlock	handlers do: aBlock</body><body package="Seaside-Core">register: aRequestHandler at: aString 	aString ifNil: [ WAError signal: 'Registration key cannot be nil.' ].	handlers 		at: aString		put: (aRequestHandler setParent: self; yourself).	^ aRequestHandler</body><body package="Seaside-Core">unregister: aRequestHandler	handlers 		removeKey: aRequestHandler name		ifAbsent: [ ^ nil ].	^ aRequestHandler unregistered</body></methods><methods><class-id>Seaside.WADispatcher</class-id> <category>initialization</category><body package="Seaside-Core">initialize	super initialize.	handlers := WABidirectionalCache new</body></methods><methods><class-id>Seaside.WADispatcher class</class-id> <category>accessing</category><body package="Seaside-Core">default	^ default ifNil: [ default := self new ]</body><body package="Seaside-Core">description	^ 'Dispatcher'</body></methods><methods><class-id>Seaside.WADispatcher class</class-id> <category>initialization</category><body package="Seaside-Core">resetDefault	default := nil</body></methods><methods><class-id>Seaside.WARegistry</class-id> <category>configuration</category><body package="Seaside-Core">defaultConfiguration	^ super defaultConfiguration		removeParent: WARequestHandlingConfiguration instance;		addParent: WARegistryConfiguration instance;		yourself</body><body package="Seaside-Core">trackingStrategy	^ self configuration at: #trackingStrategy</body></methods><methods><class-id>Seaside.WARegistry</class-id> <category>testing</category><body package="Seaside-Core">isRegistry	^ true</body></methods><methods><class-id>Seaside.WARegistry</class-id> <category>accessing</category><body package="Seaside-Core">cache	^ cache</body><body package="Seaside-Core">cache: aCache	cache := aCache</body><body package="Seaside-Core">urlFor: aRequestHandler	^ self		urlFor: aRequestHandler		ifAbsent: [ WAUnregisteredHandlerError signal ]</body><body package="Seaside-Core">urlFor: aRequestHandler ifAbsent: absentBlock	"Return the URL for the given request handler. If the handler is not registered, return	the result of absentBlock.	This URL will include the handler's key; if you don't want this, use #url instead."	| key url |	key := self keyFor: aRequestHandler ifAbsent: [ ^ absentBlock value ].	url := self url.	self trackingStrategy addKey: key toUrl: url.	^ url</body></methods><methods><class-id>Seaside.WARegistry</class-id> <category>handling</category><body package="Seaside-Core">handleDefault: aRequestContext 	"This method is called whenever a request is received with no key specified. This method can be overridden by subclasses to register a new handler to handle the request."		aRequestContext responseGenerator		notFound;		respond</body><body package="Seaside-Core">handleExpired: aRequestContext 	"This method is called whenever a request is received with a key that does not match a registered handler."		aRequestContext responseGenerator		expiredRegistryKey;		respond</body><body package="Seaside-Core">handleFiltered: aRequestContext	| key handler |	key := self trackingStrategy keyFromContext: aRequestContext.	key isNil		ifTrue: [			self handleDefault: aRequestContext ]		ifFalse: [			handler := self cache at: key ifAbsent: [ nil ].			handler isNil				ifTrue: [					self trackingStrategy noHandlerFoundForKey: key in: self context: aRequestContext ]				ifFalse: [					self handleKeyed: handler with: key context: aRequestContext ] ]</body><body package="Seaside-Core">handleKeyed: aRequestHandler with: aString context: aRequestContext	"This method is called whenever a request is received with a key that matches	a registered handler."		self dispatch: aRequestContext to: aRequestHandler key: aString</body></methods><methods><class-id>Seaside.WARegistry</class-id> <category>enumerating</category><body package="Seaside-Core">handlersDo: aBlock	self keysAndHandlersDo: [ :key :value | aBlock value: value ]</body><body package="Seaside-Core">keysAndHandlersDo: aBlock	self cache keysAndValuesDo: aBlock</body></methods><methods><class-id>Seaside.WARegistry</class-id> <category>parent/child</category><body package="Seaside-Core">childrenDo: aBlock	self cache keysAndValuesDo: [ :key :value | aBlock value: value ]</body><body package="Seaside-Core">clear	"Remove all registered handlers."	self cache clear</body><body package="Seaside-Core">keyFor: aRequestHandler ifAbsent: absentBlock	^ self cache keyAtValue: aRequestHandler ifAbsent: absentBlock</body><body package="Seaside-Core">register: aRequestHandler	^ self cache store: (aRequestHandler setParent: self; yourself)</body><body package="Seaside-Core">register: aRequestHandler at: aKey	^ self cache at: aKey put: (aRequestHandler setParent: self; yourself)</body><body package="Seaside-Core">unregister: aRequestHandler	^ self cache remove: aRequestHandler</body><body package="Seaside-Core">unregisterAt: aKey	^ self cache removeKey: aKey</body><body package="Seaside-Core">unregistered	super unregistered.	self clear</body></methods><methods><class-id>Seaside.WARegistry</class-id> <category>handling-helpers</category><body package="Seaside-Core">dispatch: aRequestContext to: aRequestHandler key: aString	"This method is used by the handling methods to trigger the dispatch of a request	to the specified handler."		self trackingStrategy addKey: aString toContext: aRequestContext.	aRequestHandler handle: aRequestContext</body><body package="Seaside-Core">handle: aRequestContext registering: aRequestHandler	"Register a new handler and then dispatch the request to it. A cookie may need	to be added to the response with the handler's key."		| key |	key := self register: aRequestHandler.	self dispatch: aRequestContext to: aRequestHandler key: key</body><body package="Seaside-Core">handle: aRequestContext registering: aRequestHandler at: aKey	"Register a new handler at the given key and then dispatch the request to it. A cookie may need	to be added to the response with the handler's key."		self register: aRequestHandler at: aKey.	self dispatch: aRequestContext to: aRequestHandler key: aKey</body></methods><methods><class-id>Seaside.WARegistry</class-id> <category>initialization</category><body package="Seaside-Core">createCache	^ WAMutualExclusionCache on: WABidirectionalCache new</body><body package="Seaside-Core">initialize	super initialize.	cache := self createCache</body></methods><methods><class-id>Seaside.WARegistry</class-id> <category>copying</category><body package="Seaside-Core">postCopy	super postCopy.	"Since our handlers are dynamically registered and temporary, it makes	sense not to copy them."	cache := self createCache</body></methods><methods><class-id>Seaside.WARegistry class</class-id> <category>testing</category><body package="Seaside-Core">isAbstract	^ self name = #WARegistry</body></methods><methods><class-id>Seaside.WAKeyGenerator</class-id> <category>accessing</category><body package="Seaside-Core">generator: aStream	"A stream of random numbers, basically a random generator."	generator := aStream</body><body package="Seaside-Core">space: aCollectionOfCharacters	"Defines the key generator space."	space := aCollectionOfCharacters</body></methods><methods><class-id>Seaside.WAKeyGenerator</class-id> <category>public</category><body package="Seaside-Core">keyOfLength: anInteger	"Answer a random key as a string with the length anInteger. This does not use any of the fancy collection methods for speed reasons."	| key |	key := String new: anInteger.	1 to: anInteger do: [ :index | key at: index put: (space at: (generator nextInt: space size)) ].	^ key</body></methods><methods><class-id>Seaside.WAKeyGenerator</class-id> <category>initialization</category><body package="Seaside-Core">initialize	super initialize.	self generator: GRPlatform current newRandom.	self space: 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_-'</body></methods><methods><class-id>Seaside.WAKeyGenerator class</class-id> <category>initialization</category><body package="Seaside-Core">initialize	current := self new</body></methods><methods><class-id>Seaside.WAKeyGenerator class</class-id> <category>accessing</category><body package="Seaside-Core">current	^ current</body></methods><methods><class-id>Seaside.WARequestFilter</class-id> <category>accessing</category><body package="Seaside-Core">handler	"Answer the owning request handler."	^ self next handler</body><body package="Seaside-Core">next	"Answer the next filter or request handler."		^ next contents</body></methods><methods><class-id>Seaside.WARequestFilter</class-id> <category>testing</category><body package="Seaside-Core">isExceptionFilter	^ false</body></methods><methods><class-id>Seaside.WARequestFilter</class-id> <category>copying</category><body package="Seaside-Core">copyTo: aRequestHandler	^ self copy setNext: (self next copyTo: aRequestHandler)</body><body package="Seaside-Core">postCopy	super postCopy.	next := next copy</body></methods><methods><class-id>Seaside.WARequestFilter</class-id> <category>initialization</category><body package="Seaside-Core">initialize	super initialize.	next := WAValueHolder new</body><body package="Seaside-Core">setNext: aFilter	next contents: aFilter</body></methods><methods><class-id>Seaside.WARequestFilter</class-id> <category>processing</category><body package="Seaside-Core">handleFiltered: aRequestContext 	"Pass on the aRequestContext to the next filter or handler. Subclasses might override this method to customize the request and response handling."		self next handleFiltered: aRequestContext</body></methods><methods><class-id>Seaside.WATrailingSlashFilter</class-id> <category>processing</category><body package="Seaside-Core">handleFiltered: aRequestContext	(self shouldRedirect: aRequestContext)		ifFalse: [ super handleFiltered: aRequestContext ]		ifTrue: [ self redirectWithTrailingSlash: aRequestContext ]</body><body package="Seaside-Core">redirectWithTrailingSlash: aRequestContext 	aRequestContext responseGenerator		redirectTo: (aRequestContext request url copy			takeServerParametersFromRequest: aRequestContext request;			slash: true;			yourself);		respond</body></methods><methods><class-id>Seaside.WATrailingSlashFilter</class-id> <category>testing</category><body package="Seaside-Core">shouldRedirect: aRequestContext	^ aRequestContext request isGet and: [ aRequestContext request url slash not ]</body></methods><methods><class-id>Seaside.WACache</class-id> <category>accessing</category><body package="Seaside-Core">at: aKey ifAbsent: aBlock	self subclassResponsibility</body><body package="Seaside-Core">keyAtValue: anObject ifAbsent: aBlock	self subclassResponsibility</body><body package="Seaside-Core">keySize	^ 16</body><body package="Seaside-Core">size	self subclassResponsibility</body></methods><methods><class-id>Seaside.WACache</class-id> <category>putting</category><body package="Seaside-Core">at: aKey put: anObject	self subclassResponsibility</body><body package="Seaside-Core">store: anObject	"Store anObject in the cache, generating a new random key. Return the key."	self subclassResponsibility</body></methods><methods><class-id>Seaside.WACache</class-id> <category>enumerating</category><body package="Seaside-Core">keysAndValuesDo: aTwoArgumentBlock	self subclassResponsibility</body></methods><methods><class-id>Seaside.WACache</class-id> <category>removing</category><body package="Seaside-Core">remove: anObject	self subclassResponsibility</body></methods><methods><class-id>Seaside.WACache</class-id> <category>public</category><body package="Seaside-Core">clear	self subclassResponsibility</body></methods><methods><class-id>Seaside.WAEncoder</class-id> <category>accessing</category><body package="Seaside-Core">nextPut: aCharacter 	self subclassResponsibility</body><body package="Seaside-Core">nextPutAll: aString	self subclassResponsibility</body></methods><methods><class-id>Seaside.WAEncoder</class-id> <category>initialization</category><body package="Seaside-Core">initializeOn: aStream	self initialize.	stream := aStream</body></methods><methods><class-id>Seaside.WAEncoder class</class-id> <category>instance creation</category><body package="Seaside-Core">on: aStream	^ self basicNew initializeOn: aStream</body></methods><methods><class-id>Seaside.WATableBasedEncoder</class-id> <category>accessing</category><body package="Seaside-Core">nextPut: aCharacter 	| value encoded |	value := aCharacter greaseInteger.	encoded := table at: value + 1.	"Issue 482: use #notNil because it is faster than #isString because it is not actually sent"	encoded notNil		ifTrue: [ stream nextPutAll: encoded ]		ifFalse: [ stream nextPut: aCharacter ]</body><body package="Seaside-Core">nextPutAll: aString 	"uses #to:do: for speed reasons (on Pharo)	this is not premature optimization, this is a hotspot method method	and #to:do: shows measurable speed improvements for rendering seaside pages"	1 to: aString size do: [ :index |		self nextPut: (aString at: index) ]</body></methods><methods><class-id>Seaside.WATableBasedEncoder</class-id> <category>initialization</category><body package="Seaside-Core">initializeOn: aStream table: anArray	self initializeOn: aStream.	table := anArray</body></methods><methods><class-id>Seaside.WATableBasedEncoder class</class-id> <category>instance creation</category><body package="Seaside-Core">new	^ self on: GRPlatform current readWriteCharacterStream</body><body package="Seaside-Core">on: aStream	^ self on: aStream table: table</body><body package="Seaside-Core">on: aStream codec: aCodec	"For compatibility with WAUrlEncoder"	^ self on: aStream</body><body package="Seaside-Core">on: aStream table: anArray	^ self basicNew initializeOn: aStream table: anArray; yourself</body></methods><methods><class-id>Seaside.WATableBasedEncoder class</class-id> <category>private</category><body package="Seaside-Core">maximumCharacterValue	"find the maximum value of a character that we can instantiate, for Squeak 3.7 this is 255"	^ [ Character codePoint: 16rFFFF.		16rFFFF ]			on: Error			do: [ :error  | 16rFF ]</body></methods><methods><class-id>Seaside.WARoot</class-id> <category>initialization</category><body package="Seaside-Core">setContext: aRenderContext	context := aRenderContext</body></methods><methods><class-id>Seaside.WARoot</class-id> <category>accessing</category><body package="Seaside-Core">absoluteUrlForResource: aString	^ self context absoluteUrlForResource: aString</body><body package="Seaside-Core">context	^ context</body></methods><methods><class-id>Seaside.WARoot</class-id> <category>writing</category><body package="Seaside-Core">closeOn: aDocument	"Close aDocument and optionally write its footer."</body><body package="Seaside-Core">openOn: aDocument	"Open aDocument and optionally write its header."</body></methods><methods><class-id>Seaside.WARoot class</class-id> <category>instance creation</category><body package="Seaside-Core">context: aRenderContext	^ self new setContext: aRenderContext</body></methods><methods><class-id>Seaside.WAXmlRoot</class-id> <category>accessing</category><body package="Seaside-Core">charSet	^ charSet ifNil: [ charSet := self class defaultCharSet ]</body><body package="Seaside-Core">charSet: aString	charSet := aString</body></methods><methods><class-id>Seaside.WAXmlRoot</class-id> <category>writing</category><body package="Seaside-Core">openOn: aDocument	super openOn: aDocument.	self writePreambleOn: aDocument</body><body package="Seaside-Core">writePreambleOn: aDocument	aDocument nextPutAll: '&lt;?xml version="1.0" encoding="'; nextPutAll: self charSet; nextPutAll: '"?&gt;'</body></methods><methods><class-id>Seaside.WAXmlRoot class</class-id> <category>accessing</category><body package="Seaside-Core">defaultCharSet	^ 'UTF-8'</body></methods><methods><class-id>Seaside.WACallbackRegistry</class-id> <category>initialization</category><body package="Seaside-Core">initialize	super initialize.	callbacks := Dictionary new.	nextKey := 1</body></methods><methods><class-id>Seaside.WACallbackRegistry</class-id> <category>accessing</category><body package="Seaside-Core">advanceKey	| key |	key := self nextKey.	self increaseKey.	^ key</body><body package="Seaside-Core">increaseKey	nextKey := nextKey + 1</body><body package="Seaside-Core">nextKey	^ nextKey greaseString</body></methods><methods><class-id>Seaside.WACallbackRegistry</class-id> <category>registration</category><body package="Seaside-Core">store: aCallback 	| key |	key := self advanceKey.	callbacks 		at: (aCallback convertKey: key)		put: aCallback.	aCallback 		setKey: key		callbacks: callbacks.	^ key</body></methods><methods><class-id>Seaside.WACallbackRegistry</class-id> <category>processing</category><body package="Seaside-Core">handle: aRequestContext	| set fields |	set := Set new.	fields := aRequestContext request fields.	fields keysDo: [ :key |		callbacks at: key ifPresent: [ :callback |			(callback isEnabledFor: aRequestContext)				ifTrue: [ set add: callback ] ] ].	set sorted do: [ :callback |		callback evaluateWithFieldValues:			(fields allAt: callback key) ]</body></methods><methods><class-id>Seaside.WAHtmlElement</class-id> <category>testing</category><body package="Seaside-Core">isClosed	^ true</body></methods><methods><class-id>Seaside.WAHtmlElement</class-id> <category>accessing-attributes</category><body package="Seaside-Core">attributeAt: aString	^ self attributes at: aString</body><body package="Seaside-Core">attributeAt: aString ifAbsent: aBlock	^ self attributes at: aString ifAbsent: aBlock</body><body package="Seaside-Core">attributeAt: aString put: anObject	^ self attributes at: aString put: anObject</body></methods><methods><class-id>Seaside.WAHtmlElement</class-id> <category>printing</category><body package="Seaside-Core">encodeAfterOn: aDocument	aDocument closeTag: self tag</body><body package="Seaside-Core">encodeBeforeOn: aDocument	aDocument openTag: self tag attributes: attributes closed: self isClosed</body><body package="Seaside-Core">encodeChildrenOn: aDocument	self childrenDo: [ :each | each encodeOn: aDocument ]</body><body package="Seaside-Core">encodeOn: aDocument	self encodeBeforeOn: aDocument.	self isClosed ifTrue: [ ^ self ].	self encodeChildrenOn: aDocument.	self encodeAfterOn: aDocument</body></methods><methods><class-id>Seaside.WAHtmlElement</class-id> <category>accessing-children</category><body package="Seaside-Core">add: anElement	children ifNil: [ children := OrderedCollection new ].	children add: anElement</body><body package="Seaside-Core">childrenDo: aBlock	children isNil		ifFalse: [ children do: aBlock ]</body></methods><methods><class-id>Seaside.WAHtmlElement</class-id> <category>accessing</category><body package="Seaside-Core">attributes	^ attributes ifNil: [ attributes := WAHtmlAttributes new ]</body><body package="Seaside-Core">tag	self subclassResponsibility</body></methods><methods><class-id>Seaside.WAHtmlElement</class-id> <category>public</category><body package="Seaside-Core">with: anObject	self add: anObject</body></methods><methods><class-id>Seaside.WAHtmlElement</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithRoot: aRoot	self initialize.	root := aRoot</body></methods><methods><class-id>Seaside.WAHtmlElement class</class-id> <category>instance creation</category><body package="Seaside-Core">root: aRoot	^ self basicNew initializeWithRoot: aRoot; yourself</body></methods><methods><class-id>Seaside.WABaseElement</class-id> <category>accessing</category><body package="Seaside-Core">tag	^ 'base'</body></methods><methods><class-id>Seaside.WABaseElement</class-id> <category>attributes</category><body package="Seaside-Core">target: aString 	"The target IDL attribute must reflect the content attribute of the same name."		self attributes at: 'target' put: aString</body><body package="Seaside-Core">url: aString	self attributeAt: 'href' put: aString</body></methods><methods><class-id>Seaside.WAPainter</class-id> <category>rendering</category><body package="Seaside-Core">renderContentOn: aRenderer	"This is the main rendering method of WAPainter. It will be called with an instance of	the Renderer class returned by #rendererClass whenever this Painter is asked to render	itself. By convention, implementations of this method that expect a Canvas renderer	use 'html' as the parameter name."		self subclassResponsibility</body><body package="Seaside-Core">renderOn: aRenderer	"This method allows Painters to be passed into the #render: method of a Renderer.	It should not normally be overridden. Subclasses should override #renderContentOn:.		DO NOT call this method directly. Instead, pass this Painter as a parameter to the	#render: method of aRenderer."		self renderWithContext: aRenderer context</body><body package="Seaside-Core">renderWithContext: aRenderContext	"This is the main entry point when attempting to render a Painter.	It should not normally be overridden. Subclasses should override #renderContentOn:.		You DO NOT normally need to call this method directly. Usually you have an instance	of a Renderer (e.g. a WAHtmlCanvas) and can call the #render: method."		aRenderContext visitor visit: self</body><body package="Seaside-Core">rendererClass	"Returns a subclass of WARenderer to use when rendering this Painter."		^ WARenderer default</body></methods><methods><class-id>Seaside.WAPainter</class-id> <category>visiting</category><body package="Seaside-Core">accept: aVisitor	aVisitor visitPainter: self</body></methods><methods><class-id>Seaside.WAPainter</class-id> <category>updating</category><body package="Seaside-Core">updateRoot: anHtmlRoot	"Override this method to modify the Root object of a Document while rendering. This	method is usually called by a WAUpdateRootVisitor.		If you are using Painters within a tree of Presenters/Components, this method will not	be called unless the Painter is included in the list of children of the Presenter."</body><body package="Seaside-Core">updateUrl: aUrl	"Override this method to modify the WAUrl object which will be used as a base URL	while rendering. This method is usually called by a WAUpdateUrlVisitor.		If you are using Painters within a tree of Presenters/Components, this method will not	be called unless the Painter is included in the list of children of the Presenter."</body></methods><methods><class-id>Seaside.WACallback</class-id> <category>accessing</category><body package="Seaside-Core">block: aBlock</body><body package="Seaside-Core">key	"Answer the callback key of the receiver."		^ self convertKey: key</body><body package="Seaside-Core">priority	"Answer the priority in which the receiver is evaluated."		^ 0</body></methods><methods><class-id>Seaside.WACallback</class-id> <category>comparing</category><body package="Seaside-Core">&lt;= other	^ self priority &lt; other priority or: [ self priority = other priority and: [ self key asNumber &lt;= other key asNumber ] ]</body></methods><methods><class-id>Seaside.WACallback</class-id> <category>initialization</category><body package="Seaside-Core">setKey: aString callbacks: aDictionary	key := aString</body></methods><methods><class-id>Seaside.WACallback</class-id> <category>converting</category><body package="Seaside-Core">convertKey: aString	^ aString</body><body package="Seaside-Core">valueForField: anObject	"Answer the value that should be used when the field value in the Request	is anObject. This allows subclasses to specify a default value other than	nil, for example."	^ anObject</body></methods><methods><class-id>Seaside.WACallback</class-id> <category>evaluation</category><body package="Seaside-Core">evaluateWithArgument: anObject	self subclassResponsibility</body><body package="Seaside-Core">evaluateWithFieldValues: anOrderedCollection	self evaluateWithArgument: (self valueForField: (anOrderedCollection at: 1 ifAbsent: [ nil ]))</body></methods><methods><class-id>Seaside.WACallback</class-id> <category>testing</category><body package="Seaside-Core">isEnabledFor: aRequestContext	^ true</body></methods><methods><class-id>Seaside.WACallback class</class-id> <category>instance creation</category><body package="Seaside-Core">on: aBlock	^ self new block: aBlock</body></methods><methods><class-id>Seaside.WAValueCallback</class-id> <category>accessing</category><body package="Seaside-Core">block: aOneArgBlock	block := aOneArgBlock fixCallbackTemps</body></methods><methods><class-id>Seaside.WAValueCallback</class-id> <category>converting</category><body package="Seaside-Core">valueForField: anObject	"For most ValueCallbacks, it is more convenient to work with an empty String	than with nil when the HTML input is empty."		^ anObject ifNil: [ String new ]</body></methods><methods><class-id>Seaside.WAValueCallback</class-id> <category>evaluation</category><body package="Seaside-Core">evaluateWithArgument: anObject	anObject isNil		ifFalse: [ block valueWithPossibleArguments: (Array with: anObject) ]</body></methods><methods><class-id>Seaside.WAEmailCallback</class-id> <category>converting</category><body package="Seaside-Core">valueForField: anObject	^ anObject isEmptyOrNil		ifTrue: [ nil ]		ifFalse: [ WAEmailAddress address: anObject ]</body></methods><methods><class-id>Seaside.WAConfiguration</class-id> <category>attributes</category><body package="Seaside-Core">allAttributes	| attributes |	attributes := IdentityDictionary new.		self ancestorsDo: [ :each |		each localAttributesDo: [ :attr |			attributes at: attr key put: attr ] ].		^ attributes</body><body package="Seaside-Core">attributeAt: aSymbol	^ self attributeAt: aSymbol ifAbsent: [ WAAttributeNotFound signalWithKey: aSymbol ]</body><body package="Seaside-Core">attributeAt: aSymbol ifAbsent: aBlock	^ self allAttributes at: aSymbol ifAbsent: aBlock</body><body package="Seaside-Core">localAttributeAt: aSymbol ifAbsent: absentBlock	self subclassResponsibility</body><body package="Seaside-Core">localAttributeAt: aSymbol ifPresent: aBlock	| value |	value := self localAttributeAt: aSymbol ifAbsent: [ ^ nil ].	^ aBlock value: value</body><body package="Seaside-Core">localAttributesDo: aBlock	self subclassResponsibility</body></methods><methods><class-id>Seaside.WAConfiguration</class-id> <category>ancestry</category><body package="Seaside-Core">ancestors	"As it happens, the 'seen' set gives us the result we need"	| set |	set := IdentitySet new.	self 		ancestorsDo:  [ :each | "nothing" ]		seen: set.	^ set</body><body package="Seaside-Core">ancestorsDo: aBlock 	| set |	set := IdentitySet new.	self 		ancestorsDo: aBlock		seen: set.	^ set</body><body package="Seaside-Core">inheritsFrom: aConfiguration	"Answer whether the given Configuration is a direct or indirect ancestor of this one"	^ self ancestors includes: aConfiguration</body><body package="Seaside-Core">parents	^ #()</body></methods><methods><class-id>Seaside.WAConfiguration</class-id> <category>values</category><body package="Seaside-Core">at: aSymbol	"Retrieves the value of a configuration according to a symbol.	Checks if the search context resides in the cache, and if not searches for the value according to the configurations ancestry."	| value context |	context := self getSearchContextFor: aSymbol.		value := self valueForContext: context.		^ value isNil		ifTrue: [ context attribute default ]		ifFalse: [ value ]</body><body package="Seaside-Core">at: aSymbol ifAbsent: aBlock	"Retrieves the value of a configuration according to a symbol.	Checks if the search context resides in the cache, and if not searches for the value according to the configurations ancestry."	| value context |	context := self getSearchContextFor: aSymbol ifAbsent: aBlock.		value := self valueForContext: context.		^ value isNil		ifTrue: [ context attribute default ]		ifFalse: [ value ]</body><body package="Seaside-Core">expressionAt: aSymbol ifAbsent: absentBlock	self subclassResponsibility</body><body package="Seaside-Core">expressionAt: aSymbol ifPresent: aBlock	| expression |	expression := self expressionAt: aSymbol ifAbsent: [ ^ nil ].	^ aBlock value: expression</body><body package="Seaside-Core">hasExpressionAt: aSymbol	self expressionAt: aSymbol ifAbsent: [ ^ false ].	^ true</body></methods><methods><class-id>Seaside.WAConfiguration</class-id> <category>ancestry-private</category><body package="Seaside-Core">ancestorsDo: aBlock seen: seenSet 	self parents reverseDo: [ :each | 		(seenSet includes: each) ifFalse: [			aBlock value: each.			seenSet add: each.			each 				ancestorsDo: aBlock				seen: seenSet ] ]</body></methods><methods><class-id>Seaside.WAConfiguration</class-id> <category>testing</category><body package="Seaside-Core">isShared	^ false</body></methods><methods><class-id>Seaside.WAConfiguration</class-id> <category>accessing</category><body package="Seaside-Core">name	^ self class name</body></methods><methods><class-id>Seaside.WAConfiguration</class-id> <category>attributes-private</category><body package="Seaside-Core">clearSearchContexts	cachedSearchContexts := IdentityDictionary new</body><body package="Seaside-Core">getSearchContextFor: aSymbol	"Returns a search context for the given symbol."	^ self getSearchContextFor: aSymbol ifAbsent: [ WAAttributeNotFound signalWithKey: aSymbol ]</body><body package="Seaside-Core">getSearchContextFor: aSymbol ifAbsent: aBlock	"Returns a search context for the given symbol."	| context |		context := self		retrieveSearchContext: aSymbol		ifAbsentPut: [			WAAttributeSearchContext key: aSymbol target: self ].	context attribute isNil ifTrue: [ aBlock value ].	^ context</body><body package="Seaside-Core">retrieveSearchContext: aSymbol default: defaultValue	"Answer the cached search context. If none found, the defaultValue is returned."	^ cachedSearchContexts at: aSymbol ifAbsent: [ defaultValue ]</body><body package="Seaside-Core">retrieveSearchContext: aSymbol ifAbsentPut: aBlock	"Answers a search context. If the context resides in the cache, the value from the cache is returned. If not, a new cache entry is created using aBlock."	| context |	cachedSearchContexts isNil ifTrue: [		cachedSearchContexts := IdentityDictionary new ].	context := cachedSearchContexts at: aSymbol ifAbsentPut: aBlock.	^ context attribute isNil		ifTrue: [ cachedSearchContexts at: aSymbol put: aBlock value ]		ifFalse: [ context ]</body></methods><methods><class-id>Seaside.WAConfiguration</class-id> <category>values-private</category><body package="Seaside-Core">inheritedValueForContext: aContext	| value |	(self parents select: [ :each | aContext isAttributeInheritedOn: each ]) reverseDo: [ :each |		value := each valueForContext: aContext.		value notNil ifTrue: [ ^ value ] ].		^ nil</body><body package="Seaside-Core">valueForContext: aContext	aContext at: self ifPresent: [ :v | ^ v ].		self expressionAt: aContext key ifPresent: [ :expression |		^ aContext			at: self			put: (expression determineValueWithContext: aContext configuration: self) ].		(aContext isAttributeLocalOn: self) ifTrue: [ ^ aContext at: self put: nil ].	^ aContext at: self put: (self inheritedValueForContext: aContext)</body></methods><methods><class-id>Seaside.WAUserConfiguration</class-id> <category>ancestry</category><body package="Seaside-Core">addParent: aConfiguration	(self parents includes: aConfiguration)		ifTrue: [ ^ aConfiguration ].	(self canAddParent: aConfiguration) 		ifTrue: [ self clearSearchContexts. parents add: aConfiguration ]		ifFalse: [ WAConfigurationError signal: 'Cannot add this configuration as a parent. Would this cause a circular ancestry graph?' ].	^ aConfiguration</body><body package="Seaside-Core">canAddParent: aConfiguration 	^ (aConfiguration = self or: [ aConfiguration inheritsFrom: self ]) not</body><body package="Seaside-Core">moveParentDown: aConfiguration 	| index |	self clearSearchContexts.	index := parents indexOf: aConfiguration ifAbsent: [ ^ self ].	index &lt; parents size ifTrue: [ parents swap: index with: index + 1 ]</body><body package="Seaside-Core">moveParentUp: aConfiguration 	| index |	self clearSearchContexts.	index := parents indexOf: aConfiguration ifAbsent: [ ^ self ].	index &gt; 1 ifTrue: [ parents swap: index with: index - 1 ]</body><body package="Seaside-Core">parents	^ parents</body><body package="Seaside-Core">removeParent: aConfiguration 	self clearSearchContexts.	parents 		remove: aConfiguration		ifAbsent: [ ]</body></methods><methods><class-id>Seaside.WAUserConfiguration</class-id> <category>attributes</category><body package="Seaside-Core">localAttributeAt: aSymbol ifAbsent: absentBlock	^ absentBlock value</body><body package="Seaside-Core">localAttributesDo: aBlock	"we have no local attributes -- do nothing"</body></methods><methods><class-id>Seaside.WAUserConfiguration</class-id> <category>values</category><body package="Seaside-Core">at: aSymbol addAll: aCollection	^ self at: aSymbol addAll: aCollection removeAll: #()</body><body package="Seaside-Core">at: aSymbol addAll: additions removeAll: removals	^ self		storeExpression:			((WAAddRemoveExpression key: aSymbol)				additions: additions;				removals: removals;				yourself)		forAttribute: (self attributeAt: aSymbol)</body><body package="Seaside-Core">at: aSymbol put: anObject	"It would be faster to simply add the value to the dictionary and	implement #takeValue:forAttribute: in terms of this method, but	config options are set only rarely and this ensures you are setting	a value for an attribute that actually exists."	^ self takeValue: anObject forAttribute: (self attributeAt: aSymbol)</body><body package="Seaside-Core">at: aSymbol putClass: aClass	^ self at: aSymbol put: (GRPlatform current bindingOf: aClass)</body><body package="Seaside-Core">expressionAt: aSymbol ifAbsent: errorBlock	^ expressions at: aSymbol ifAbsent: errorBlock</body><body package="Seaside-Core">removeExpressionAt: aSymbol	^ self removeExpressionAt: aSymbol ifAbsent: [ nil ]</body><body package="Seaside-Core">removeExpressionAt: aSymbol ifAbsent: aBlock	self clearSearchContexts.	^ expressions removeKey: aSymbol ifAbsent: aBlock</body><body package="Seaside-Core">storeExpression: anAttributeExpression forAttribute: anAttribute	self clearSearchContexts.	^ expressions at: anAttribute key put: anAttributeExpression</body><body package="Seaside-Core">takeValue: anObject forAttribute: anAttribute	^ anObject isNil ifFalse: [		self			storeExpression:				((WAValueExpression key: anAttribute key)					value: anObject;					yourself)			forAttribute: anAttribute ]</body><body package="Seaside-Core">takeValueFromString: aString forAttribute: anAttribute	^ self takeValue: (anAttribute valueFromString: aString) forAttribute: anAttribute</body></methods><methods><class-id>Seaside.WAUserConfiguration</class-id> <category>initialization</category><body package="Seaside-Core">initialize	super initialize.	expressions := Dictionary new.	parents := OrderedCollection new</body></methods><methods><class-id>Seaside.WAUserConfiguration</class-id> <category>copying</category><body package="Seaside-Core">postCopy	super postCopy.	expressions := expressions copy.	parents := parents copy</body></methods><methods><class-id>Seaside.WAHeaderFields</class-id> <category>private</category><body package="Seaside-Core">checkValue: aValue	(aValue isString and: [		(aValue indexOf: Character cr) ~= 0			or: [ (aValue indexOf: Character lf) ~= 0 ] ]) ifTrue: [				WAInvalidHeaderValueError signal: 'invalid header value', aValue "we know this is a String now" ]</body><body package="Seaside-Core">errorKeyNotFound	^ nil</body><body package="Seaside-Core">privateAt: aKey put: aValue	self checkValue: aValue.	^ super privateAt: aKey put: aValue</body></methods><methods><class-id>Seaside.WAConfiguredRequestFilter</class-id> <category>initialization</category><body package="Seaside-Core">initialize	super initialize.	configuration := self defaultConfiguration</body></methods><methods><class-id>Seaside.WAConfiguredRequestFilter</class-id> <category>configuration</category><body package="Seaside-Core">configuration	^ configuration</body><body package="Seaside-Core">defaultConfiguration	"Return the configuration (normally a new instance of WAUserConfiguration) to be	used with the Filter upon initialization."		self subclassResponsibility</body></methods><methods><class-id>Seaside.WABidirectionalCache</class-id> <category>enumerating</category><body package="Seaside-Core">do: aBlock	byKey do: aBlock</body><body package="Seaside-Core">keysAndValuesDo: aTwoArgumentBlock	byKey keysAndValuesDo: aTwoArgumentBlock</body></methods><methods><class-id>Seaside.WABidirectionalCache</class-id> <category>private</category><body package="Seaside-Core">errorAlreadyMapped	self error: 'Already mapped'</body><body package="Seaside-Core">includesKey: key	^ byKey includesKey: key</body></methods><methods><class-id>Seaside.WABidirectionalCache</class-id> <category>initialization</category><body package="Seaside-Core">initialize	super initialize.	byKey := Dictionary new.	byValue := Dictionary new</body></methods><methods><class-id>Seaside.WABidirectionalCache</class-id> <category>public</category><body package="Seaside-Core">clear	byKey removeAll.	byValue removeAll</body><body package="Seaside-Core">valuesCollect: aBlock	| result |	result := self species new.	self keysAndValuesDo: [ :key :value |		result at: key put: (aBlock value: value) ].	^ result</body></methods><methods><class-id>Seaside.WABidirectionalCache</class-id> <category>removing</category><body package="Seaside-Core">remove: anObject	| key |	key := byValue removeKey: anObject.	byKey removeKey: key</body><body package="Seaside-Core">removeKey: aKey ifAbsent: aBlock	| value |	value := byKey at: aKey ifAbsent: [ ^ aBlock value ].	byKey removeKey: aKey.	byValue removeKey: value.	^ value</body></methods><methods><class-id>Seaside.WABidirectionalCache</class-id> <category>accessing</category><body package="Seaside-Core">at: aKey	^ byKey at: aKey</body><body package="Seaside-Core">at: aKey ifAbsent: aBlock	^ byKey at: aKey ifAbsent: aBlock</body><body package="Seaside-Core">keyAtValue: anObject ifAbsent: aBlock	^ byValue at: anObject ifAbsent: aBlock</body><body package="Seaside-Core">keys	^ byKey keys</body><body package="Seaside-Core">size	^ byKey size</body></methods><methods><class-id>Seaside.WABidirectionalCache</class-id> <category>putting</category><body package="Seaside-Core">at: aKey put: anObject	byValue at: anObject ifPresent: [ :key |		key = aKey ifFalse: [			self errorAlreadyMapped ] ].	byKey at: aKey ifPresent: [ :value |		byValue removeKey: value ].	byKey at: aKey put: anObject.	byValue at: anObject put: aKey.	^ anObject</body><body package="Seaside-Core">store: anObject	| candidateKey |	[ 		candidateKey := WAKeyGenerator current keyOfLength: self keySize.		self includesKey: candidateKey ] whileTrue.	self at: candidateKey put: anObject.	^ candidateKey</body></methods><methods><class-id>Seaside.WABidirectionalCache</class-id> <category>testing</category><body package="Seaside-Core">includes: anObject	^ byValue includesKey: anObject</body></methods><methods><class-id>Seaside.WABidirectionalCache</class-id> <category>copying</category><body package="Seaside-Core">postCopy	super postCopy.	byKey := byKey copy.	byValue := byValue copy</body></methods><methods><class-id>Seaside.WAConfigurationElement</class-id> <category>accessing</category><body package="Seaside-Core">key	^ key</body></methods><methods><class-id>Seaside.WAConfigurationElement</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithKey: aSymbol	self initialize.	key := aSymbol</body></methods><methods><class-id>Seaside.WAConfigurationElement class</class-id> <category>instance creation</category><body package="Seaside-Core">key: aSymbol	^ self basicNew initializeWithKey: aSymbol; yourself</body></methods><methods><class-id>Seaside.WAOpeningConditionalComment</class-id> <category>accessing</category><body package="Seaside-Core">condition	^ condition</body><body package="Seaside-Core">condition: aString	condition := aString</body></methods><methods><class-id>Seaside.WAOpeningConditionalComment</class-id> <category>printing</category><body package="Seaside-Core">encodeOn: aDocument	aDocument		nextPutAll: '&lt;!--[';		nextPutAll: self condition;		nextPutAll: ']&gt;'</body></methods><methods><class-id>Seaside.WAOpeningConditionalComment class</class-id> <category>instance creation</category><body package="Seaside-Core">condition: aString	^ self new		condition: aString;		yourself</body></methods><methods><class-id>Seaside.WAOpeningRevealedConditionalComment</class-id> <category>printing</category><body package="Seaside-Core">encodeOn: aDocument	aDocument		nextPutAll: '&lt;!--[';		nextPutAll: self condition;		nextPutAll: ']&gt;&lt;!--&gt;'</body></methods><methods><class-id>Seaside.WAXmlEncoder</class-id> <category>accessing</category><body package="Seaside-Core">nextPut: aCharacter	| codePoint |	codePoint := aCharacter greaseInteger.	codePoint = 34 "$""" ifTrue: [ ^ stream nextPutAll: '&amp;quot;' ].	codePoint = 60 "$&lt;" ifTrue: [ ^ stream nextPutAll: '&amp;lt;' ].	codePoint = 38 "$&amp;" ifTrue: [ ^ stream nextPutAll: '&amp;amp;' ].	codePoint = 62 "$&gt;" ifTrue: [ ^ stream nextPutAll: '&amp;gt;' ].	stream nextPut: aCharacter</body><body package="Seaside-Core">nextPutAll: aString	"uses #to:do: for speed reasons (on Pharo)	this is not premature optimization, this is a hotspot method method	and #to:do: shows measurable speed improvements for rendering seaside pages"	1 to: aString size do: [ :index |		self nextPut: (aString at: index) ]</body></methods><methods><class-id>Seaside.WAXmlEncoder class</class-id> <category>instance creation</category><body package="Seaside-Core">on: aStream codec: aCodec	"For compatibility with WAUrlEncoder"	^ self on: aStream</body></methods><methods><class-id>Seaside.WAConfigurationDescription</class-id> <category>accessing</category><body package="Seaside-Core">attributes	^ attributes</body><body package="Seaside-Core">expressions	^ expressions</body></methods><methods><class-id>Seaside.WAConfigurationDescription</class-id> <category>attribute creation</category><body package="Seaside-Core">addAttribute: anAttribute	^ self add: anAttribute to: attributes</body><body package="Seaside-Core">boolean: aSymbol	^ self addAttribute: (WABooleanAttribute key: aSymbol)</body><body package="Seaside-Core">classBinding: aSymbol	^ self addAttribute: (WAClassBindingAttribute key: aSymbol)</body><body package="Seaside-Core">classBindingCollection: aSymbol	^ self addAttribute: (WAClassBindingCollectionAttribute key: aSymbol)</body><body package="Seaside-Core">collection: aSymbol	^ self addAttribute: (WACollectionAttribute key: aSymbol)</body><body package="Seaside-Core">integer: aSymbol	^ self addAttribute: (WAIntegerAttribute key: aSymbol)</body><body package="Seaside-Core">list: aSymbol	^ self addAttribute: (WAListAttribute key: aSymbol)</body><body package="Seaside-Core">listOfClasses: aSymbol	^ self addAttribute: (WAClassListAttribute key: aSymbol)</body><body package="Seaside-Core">number: aSymbol	^ self addAttribute: (WANumberAttribute key: aSymbol)</body><body package="Seaside-Core">password: aSymbol	^ self addAttribute: (WAPasswordAttribute key: aSymbol)</body><body package="Seaside-Core">string: aSymbol	^ self addAttribute: (WAStringAttribute key: aSymbol)</body><body package="Seaside-Core">url: aSymbol	^ self addAttribute: (WAUrlAttribute key: aSymbol)</body></methods><methods><class-id>Seaside.WAConfigurationDescription</class-id> <category>values</category><body package="Seaside-Core">addExpression: anExpression	^ self add: anExpression to: expressions</body><body package="Seaside-Core">at: aSymbol addAll: aCollection	self at: aSymbol addAll: aCollection removeAll: #()</body><body package="Seaside-Core">at: aSymbol addAll: additions removeAll: removals	self addExpression: ((WAAddRemoveExpression key: aSymbol)			additions: additions;			removals: removals;			yourself)</body><body package="Seaside-Core">at: aSymbol put: anObject 	self addExpression: ((WAValueExpression key: aSymbol)			value: anObject;			yourself)</body><body package="Seaside-Core">at: aSymbol putClass: aClass 	self at: aSymbol put: (GRPlatform current bindingOf: aClass)</body></methods><methods><class-id>Seaside.WAConfigurationDescription</class-id> <category>private</category><body package="Seaside-Core">add: aDescriptor to: aDictionary	^ aDictionary at: aDescriptor key put: aDescriptor</body></methods><methods><class-id>Seaside.WAConfigurationDescription</class-id> <category>initialization</category><body package="Seaside-Core">initialize	super initialize.	attributes := IdentityDictionary new.	expressions := IdentityDictionary new</body></methods><methods><class-id>Seaside.WARequestCookie</class-id> <category>accessing</category><body package="Seaside-Core">domain	^ domain</body><body package="Seaside-Core">domain: aString	domain := aString</body><body package="Seaside-Core">key	^ key</body><body package="Seaside-Core">key: aString	key := aString</body><body package="Seaside-Core">path	^ path ifNil: [ '/' ]</body><body package="Seaside-Core">path: aString	self pathUnencoded: aString codec: nil</body><body package="Seaside-Core">pathEncoded	^ pathEncoded</body><body package="Seaside-Core">pathEncoded: aString codec: aCodec	pathEncoded := aString isNil ifTrue: [ '/' ] ifFalse: [ aString ].	path := aString isNil		ifTrue: [ '/' ]		ifFalse: [			aCodec isNil				ifTrue: [ aString ]				ifFalse: [ ((WAUrl absolute: aString) decodedWith: aCodec) pathStringUnencoded ] ]</body><body package="Seaside-Core">pathUnencoded	^ path</body><body package="Seaside-Core">pathUnencoded: aString codec: aCodec	path := aString.	pathEncoded := aString isNil		ifTrue: [ '/' ]		ifFalse: [			| codec |			codec := aCodec isNil ifTrue: [ self requestContext codec ] ifFalse: [ aCodec ].			String new: (aString size * 1.1) greaseInteger streamContents: [ :stream |				| encoder |				encoder := GRPlatform current urlEncoderOn: stream codec:  codec.				GRPlatform subStringsIn: path splitBy: $/ do: [ :each |					stream nextPut: $/.					encoder nextPutAll: each ] ] ]</body><body package="Seaside-Core">pathUnencoded: aFirstString encoded: aSecondString	path := aFirstString.	pathEncoded := aSecondString</body><body package="Seaside-Core">port: anInteger	self ports: (Array with: anInteger)</body><body package="Seaside-Core">ports	^ ports</body><body package="Seaside-Core">ports: aCollection	ports := aCollection</body><body package="Seaside-Core">value	^ value</body><body package="Seaside-Core">value: aString	value := aString</body><body package="Seaside-Core">version	^ version</body><body package="Seaside-Core">version: anInteger	version := anInteger</body></methods><methods><class-id>Seaside.WARequestCookie</class-id> <category>comparing</category><body package="Seaside-Core">= other	"cookies are identified by the triple name/domain/path"	^ self species = other species		and: [ self key = other key		and: [ self domain = other domain		and: [ self path = other path ] ] ]</body><body package="Seaside-Core">hash	"see #="	^ (self key hash bitXor: self domain hash) bitXor: self path hash</body></methods><methods><class-id>Seaside.WARequestCookie</class-id> <category>copying</category><body package="Seaside-Core">postCopy	super postCopy.	ports := ports copy</body></methods><methods><class-id>Seaside.WARequestCookie</class-id> <category>initialization</category><body package="Seaside-Core">setPorts: aString	ports := OrderedCollection new: 1.	GRPlatform subStringsIn: aString splitBy: $, do: [ :token |		ports add: token greaseInteger ]</body></methods><methods><class-id>Seaside.WARequestCookie class</class-id> <category>instance creation</category><body package="Seaside-Core">fromString: aString codec: aCodec	"Creates an array of cookies from a HTTP Cookie: header value."	| version current cookies |	version := nil.	aString isEmptyOrNil		ifTrue: [ ^ #() ].	current := nil.	cookies := OrderedCollection new: 3.	GRPlatform subStringsIn: aString splitBy: $; do: [ :each |		| key value action |		key := self keyFrom: each.		value := self valueFrom: each.		key = '$Version' 			ifTrue: [				version := value greaseInteger ]			ifFalse: [				action := self actions 					at: key					ifAbsent: [ nil ].				action isNil 					ifTrue: [						current := self 							key: key							value: value.						current version: version.						cookies add: current ]					ifFalse: [						action							value: aCodec							value: current							value: value ] ] ].	^ cookies</body><body package="Seaside-Core">key: keyString value: valueString	^ self new		key: keyString;		value: valueString;		yourself</body></methods><methods><class-id>Seaside.WARequestCookie class</class-id> <category>private</category><body package="Seaside-Core">keyFrom: aString	^ (aString copyUpTo: $=) trimBoth</body><body package="Seaside-Core">trimBlanksAndQuotes: aString	| trimmed |	trimmed := aString trimBoth.	^ (trimmed size &gt; 2		and: [ trimmed first = $"		and: [ trimmed last = $" ] ])			ifTrue: [ trimmed copyFrom: 2 to: trimmed size - 1 ]			ifFalse: [ trimmed ]</body><body package="Seaside-Core">valueFrom: aString	^ (aString includes: $=)		ifTrue: [ self trimBlanksAndQuotes: (aString copyAfter: $=) ]</body></methods><methods><class-id>Seaside.WARequestCookie class</class-id> <category>accessing</category><body package="Seaside-Core">actions	^ Dictionary new		at: '$Domain' put: [ :codec :cookie :value | cookie domain: value ];		at: '$Path' put: [ :codec :cookie :value | cookie pathEncoded: value codec: codec ];		at: '$Port' put: [ :codec :cookie :value | cookie setPorts: value ];		yourself</body></methods><methods><class-id>Seaside.WACookie</class-id> <category>accessing</category><body package="Seaside-Core">comment	^ comment</body><body package="Seaside-Core">comment: aString	comment := aString</body><body package="Seaside-Core">commentUrl	^ commentUrl</body><body package="Seaside-Core">commentUrl: aUrl	commentUrl := aUrl</body><body package="Seaside-Core">discard	^ discard</body><body package="Seaside-Core">discard: aBoolean	discard := aBoolean</body><body package="Seaside-Core">expiry	^ expiry</body><body package="Seaside-Core">expiry: aDateTime	expiry := aDateTime asUTC</body><body package="Seaside-Core">httpOnly	^ httpOnly</body><body package="Seaside-Core">httpOnly: anObject	httpOnly := anObject</body><body package="Seaside-Core">maxAge	^ maxAge</body><body package="Seaside-Core">maxAge: anInteger	"Optional.  The Max-Age attribute defines the lifetime of the	cookie, in seconds.  The delta-seconds value is a decimal non-	negative integer.  After delta-seconds seconds elapse, the client	should discard the cookie.  A value of zero means the cookie	should be discarded immediately."	maxAge := anInteger</body><body package="Seaside-Core">secure	^ secure</body><body package="Seaside-Core">secure: aBoolean	secure := aBoolean</body></methods><methods><class-id>Seaside.WACookie</class-id> <category>writing-private</category><body package="Seaside-Core">write: aString asQuotedStringOn: aStream	aStream nextPut: $".	aString do: [ :each |		each = $" 			ifTrue: [ aStream nextPutAll: '\"' ]			ifFalse: [ aStream nextPut: each ] ].	aStream nextPut: $"</body><body package="Seaside-Core">write: aString quoted: aBoolean on: aStream	aBoolean		ifTrue: [			self				write: aString				asQuotedStringOn: aStream ]		ifFalse: [ aStream nextPutAll: aString ]</body><body package="Seaside-Core">writeCommentOn: aStream	self comment isNil		ifTrue: [ ^ self ].	aStream nextPutAll: '; Comment='.	self write: self comment asQuotedStringOn: aStream</body><body package="Seaside-Core">writeCommentUrlOn: aStream 	self commentUrl isNil ifTrue: [ ^ self ].	aStream nextPutAll: '; CommentURL='.	self 		write: self commentUrl greaseString		asQuotedStringOn: aStream</body><body package="Seaside-Core">writeDiscardOn: aStream	(self discard notNil and: [ self discard ])		ifTrue: [ aStream nextPutAll: '; Discard' ]</body><body package="Seaside-Core">writeDomainQuoted: aBoolean on: aStream	domain isNil		ifTrue: [ ^ self ].	aStream nextPutAll: '; domain='.	self write: self domain quoted: aBoolean on: aStream</body><body package="Seaside-Core">writeExpiresOn: aStream	expiry isNil		ifTrue: [ ^ self ].	aStream		nextPutAll: '; expires=';		nextPutAll: self expiryString</body><body package="Seaside-Core">writeHttpOnlyOn: aStream	self httpOnly		ifTrue: [ aStream nextPutAll: '; HttpOnly' ]</body><body package="Seaside-Core">writeKeyValueQuoted: aBoolean on: aStream	aStream nextPutAll: self key.	aStream nextPut: $=.	self		write: (self value ifNil: [ '' ])		quoted: aBoolean		on: aStream</body><body package="Seaside-Core">writeMaxAgeQuoted: aBoolean on: aStream	maxAge isNil		ifTrue: [ ^ self ].	aStream nextPutAll: '; Max-Age='.	self write: self maxAge greaseString quoted: aBoolean on: aStream</body><body package="Seaside-Core">writePathQuoted: aBoolean on: aStream	pathEncoded isNil		ifTrue: [ ^ self ].	aStream nextPutAll: '; path='.	self write: pathEncoded quoted: aBoolean on: aStream</body><body package="Seaside-Core">writePortsOn: aStream	ports isEmptyOrNil		ifTrue: [ ^ self ].	aStream nextPutAll: '; Port="'.	self ports do: [ :each | aStream print: each ] separatedBy: [ aStream nextPut: $, ].	aStream nextPut: $"</body><body package="Seaside-Core">writeSecureOn: aStream	self secure		ifTrue: [ aStream nextPutAll: '; Secure' ]</body><body package="Seaside-Core">writeVersionOn: aStream	aStream nextPutAll: '; Version='.	aStream print: self version</body></methods><methods><class-id>Seaside.WACookie</class-id> <category>initialization</category><body package="Seaside-Core">initialize	super initialize.	self secure: false.	self discard: false.	self httpOnly: false.	self version: 1</body></methods><methods><class-id>Seaside.WACookie</class-id> <category>private</category><body package="Seaside-Core">expiryString	^ GRPrinter cookieTimestamp print: expiry</body></methods><methods><class-id>Seaside.WACookie</class-id> <category>api</category><body package="Seaside-Core">expireIn: aDuration	"sets the lifetime of the receiver measured in a duration"	self expiry: DateAndTime now + aDuration.	self maxAge: aDuration asSeconds</body><body package="Seaside-Core">expireInPast	self maxAge: 0.	self expiry: (DateAndTime now - (Duration days: 10 hours: 0 minutes: 0 seconds: 0))</body><body package="Seaside-Core">expireInSeconds: anInteger	"sets the lifetime of the receiver measured in seconds"	self expiry: (Duration days: 0 hours: 0 minutes: 0 seconds: anInteger).	self maxAge: anInteger</body></methods><methods><class-id>Seaside.WACookie</class-id> <category>writing</category><body package="Seaside-Core">oldNetscapeString	"Serializes the receiver according to the orginal Netscape spec.	This has the broadest browser support but limited features.	It can not be used with HTTP header combining.	See class comment for a link to the spec."	self greaseDeprecatedApi: 'WACookie&gt;&gt;#oldNetscapeString' details: 'Use #rfc6265String instead.'. 	^ String streamContents: [ :stream |		self writeKeyValueQuoted: false on: stream.		self writeExpiresOn: stream.		self writePathQuoted: false on: stream.		self writeDomainQuoted: false on: stream.		self writeSecureOn: stream.		self writeHttpOnlyOn: stream ]</body><body package="Seaside-Core">rfc2109String	"Serializes the receiver according to RFC 2109.	Almost no browser support.	It can be used with HTTP header combining.	See class comment for a link to the spec."	self greaseDeprecatedApi: 'WACookie&gt;&gt;#rfc2109String' details: 'Use #rfc6265String instead.'. 	^ String streamContents: [ :stream |		self writeKeyValueQuoted: true on: stream.		self writeCommentOn: stream.		self writeMaxAgeQuoted: true on: stream.		self writePathQuoted: true on: stream.		self writeDomainQuoted: true on: stream.		self writeSecureOn: stream.		self writeHttpOnlyOn: stream.		self writeVersionOn: stream ]</body><body package="Seaside-Core">rfc2965String	"Serializes the receiver according to RFC 2965.	This has the most features but is only supported in Opera.	It can be used together with other serialization forms.	It can be used with HTTP header combining.	See class comment for a link to the spec."	self greaseDeprecatedApi: 'WACookie&gt;&gt;#rfc2965String' details: 'Use #rfc6265String instead.'. 	^ String streamContents: [ :stream |		self writeKeyValueQuoted: true on: stream.		self writeCommentOn: stream.		self writeCommentUrlOn: stream.		self writeMaxAgeQuoted: true on: stream.		self writePathQuoted: true on: stream.		self writePortsOn: stream.		self writeDomainQuoted: true on: stream.		self writeSecureOn: stream.		self writeHttpOnlyOn: stream.		self writeDiscardOn: stream.		self writeVersionOn: stream ]</body><body package="Seaside-Core">rfc6265String	"Serializes the receiver according to RFC 6265.	Almost no browser support.	It can be used with HTTP header combining.	See class comment for a link to the spec."	^ String streamContents: [ :stream |		| useQuotes |		"the spec allows us to quote but we don't know how good browser support is"		useQuotes := false.		self writeKeyValueQuoted: useQuotes on: stream.		self writeExpiresOn: stream.		self writeMaxAgeQuoted: useQuotes on: stream.		self writeDomainQuoted: useQuotes on: stream.		self writePathQuoted: useQuotes on: stream.		self writeSecureOn: stream.		self writeHttpOnlyOn: stream ]</body><body package="Seaside-Core">writeOn: aStream	aStream nextPutAll: self rfc6265String</body></methods><methods><class-id>Seaside.WACookie class</class-id> <category>convenience</category><body package="Seaside-Core">combine: aCollectionOfCookies using: aOneArgumentBlock	"combines several cookies into one HTTP header line	aOneArgumentBlock takes a cookie as an argument and returns a string,	it is supposed to send one of #oldNetscapeString #rfc2109String #rfc2965String to the argument"	^ String streamContents: [ :stream |		aCollectionOfCookies			do: [ :each |				stream nextPutAll: (aOneArgumentBlock value: each) ]			separatedBy: [ stream nextPutAll: ', ' ] ]</body></methods><methods><class-id>Seaside.WAAbstractFileLibrary</class-id> <category>private</category><body package="Seaside-Core">asFilename: aSelector	self subclassResponsibility</body><body package="Seaside-Core">asSelector: aFilename	^ self class asSelector: aFilename</body><body package="Seaside-Core">fileSelectors	self subclassResponsibility</body><body package="Seaside-Core">fileSelectorsTo: aSuperClass	| selectors current |	selectors := Set new.	current := self class.	[ aSuperClass name = current name ] whileFalse: [		current selectors do: [ :each |			(self isFileSelector: each) ifTrue: [				selectors add: each ] ].		current := current superclass ].	^ selectors</body><body package="Seaside-Core">fullPathForFileName: aString using: aFileHandler	^ String streamContents: [ :stream |		| pathSeparator xSendfileBaseDirectory |		pathSeparator := GRPlatform current pathSeparator.		xSendfileBaseDirectory := aFileHandler xSendfileBaseDirectory.		stream nextPutAll: xSendfileBaseDirectory.		(xSendfileBaseDirectory endsWithSubCollection: pathSeparator) ifFalse: [			stream nextPutAll: pathSeparator ].		stream			nextPutAll: self name;			nextPutAll: pathSeparator;			nextPutAll: aString ]</body><body package="Seaside-Core">isFileSelector: aSymbol	"added condition to prevent overrides of methods defined in this class being picked up"	^ aSymbol isUnary		and: [ (self lastUpperCaseIndexIn: aSymbol) &gt; 1		and: [ (self nonFileSelectors includes: aSymbol) not ] ]</body><body package="Seaside-Core">lastUpperCaseIndexIn: aString	^ aString findLast: [ :each | each isUppercase ]</body><body package="Seaside-Core">nonFileSelectors	"Answers all the unary selectors with an upper clase latter that are not file selector.s	This method is intended to be overridden by superclasses that add functionality. Don't forget to add the result of the super send."	^ #(cacheDuration fileSelectors deployFiles configurationComponent selectorsToInclude nonFileSelectors)</body></methods><methods><class-id>Seaside.WAAbstractFileLibrary</class-id> <category>handling</category><body package="Seaside-Core">handle: aRequestContext	self subclassResponsibility</body></methods><methods><class-id>Seaside.WAAbstractFileLibrary</class-id> <category>accessing</category><body package="Seaside-Core">fileSizeOf: aSymbol	self subclassResponsibility</body><body package="Seaside-Core">filenames	^ self fileSelectors collect: [ :each | self asFilename: each ]</body><body package="Seaside-Core">mimetypeOf: aSymbol	self subclassResponsibility</body><body package="Seaside-Core">selectorsToInclude	"The files represented by the selectors this method returns will be automatically added to the html &lt;head&gt; if the receiver is added to the respective Seaside application.	This makes only sense for CSS and JS files"	^ #()</body><body package="Seaside-Core">urlForFile: aFilename	^ self urlOf: (self asSelector: aFilename)</body><body package="Seaside-Core">urlOf: aSymbol	^ self urlOf: aSymbol using: WAFileHandler default</body><body package="Seaside-Core">urlOf: aSymbol using: aHandler	^ aHandler baseUrlForLibrary		addToPath: self className;		addToPath: (self asFilename: aSymbol);		yourself</body></methods><methods><class-id>Seaside.WAAbstractFileLibrary</class-id> <category>actions</category><body package="Seaside-Core">addFile: aFile 	"adds a file to the receiver	aFile an instance of of WAFile"	| contents |	aFile isNil ifTrue: [		"in case no file was selected for uploading"		^ self ].	contents := (aFile contentType isNil or: [ aFile contentType isBinary ])		ifTrue: [ aFile rawContents ]		ifFalse: [			GRPlatform current convertToSmalltalkNewlines: (aFile contentType charSet isNil				ifTrue: [ aFile rawContents ]				ifFalse: [ aFile contentsDecoded ]) ].	self class 		addFileNamed: aFile fileName		contents: contents</body><body package="Seaside-Core">deployFiles	self subclassResponsibility</body><body package="Seaside-Core">removeFile: aFilename 	GRPlatform current 		removeSelector: (self asSelector: aFilename)		from: self class</body><body package="Seaside-Core">renameFile: oldName to: newName	| contents file |	(self asSelector: oldName) = (self asSelector: newName)		ifTrue: [ ^ nil ].	contents := self perform: (self asSelector: oldName).	file := WAFile new contents: contents.	file fileName: newName.	self addFile: file.	self removeFile: oldName</body></methods><methods><class-id>Seaside.WAAbstractFileLibrary</class-id> <category>testing</category><body package="Seaside-Core">name	^ self class name greaseString</body></methods><methods><class-id>Seaside.WAAbstractFileLibrary</class-id> <category>updating</category><body package="Seaside-Core">updateRoot: anHtmlRoot	"Only override if you want to automatically include new types of resources. The default implementation knows how to reference CSS, JS and FavIcons into anHtmlRoot."	self selectorsToInclude do: [ :each |		| mimeType |		mimeType := self mimetypeOf: each.		(mimeType sub indexOfSubCollection: 'javascript' startingAt: 1) ~= 0			ifTrue: [ anHtmlRoot javascript url: (self urlOf: each) ].		(mimeType sub indexOfSubCollection: 'ico' startingAt: 1) ~= 0			ifTrue: [ anHtmlRoot link beShortcutIcon; url: (self urlOf: each) ].		(mimeType sub = 'css')			ifTrue: [ anHtmlRoot stylesheet url: (self urlOf: each) ] ]</body></methods><methods><class-id>Seaside.WAAbstractFileLibrary class</class-id> <category>accessing-defaults</category><body package="Seaside-Core">defaultCacheDuration	"Answer the duration the response should be cached by the user agent."	^ Duration		days: 0		hours: 0		minutes: 30		seconds: 0</body><body package="Seaside-Core">defaultMimeType	^ 'application/octet-stream'</body><body package="Seaside-Core">defaultMimeTypes	^ #(		'%' 'application/x-trash'		'323' 'text/h323'		'abw' 'application/x-abiword'		'ai' 'application/postscript'		'aif' 'audio/x-aiff'		'aifc' 'audio/x-aiff'		'aiff' 'audio/x-aiff'		'alc' 'chemical/x-alchemy'		'art' 'image/x-jg'		'asc' 'text/plain'		'asf' 'video/x-ms-asf'		'asn' 'chemical/x-ncbi-asn1-spec'		'aso' 'chemical/x-ncbi-asn1-binary'		'asx' 'video/x-ms-asf'		'au' 'audio/basic'		'avi' 'video/x-msvideo'		'b' 'chemical/x-molconn-Z'		'bak' 'application/x-trash'		'bat' 'application/x-msdos-program'		'bcpio' 'application/x-bcpio'		'bib' 'text/x-bibtex'		'bin' 'application/octet-stream'		'bmp' 'image/x-ms-bmp'		'book' 'application/x-maker'		'bsd' 'chemical/x-crossfire'		'c' 'text/x-csrc'		'c++' 'text/x-c++src'		'c3d' 'chemical/x-chem3d'		'cac' 'chemical/x-cache'		'cache' 'chemical/x-cache'		'cascii' 'chemical/x-cactvs-binary'		'cat' 'application/vnd.ms-pki.seccat'		'cbin' 'chemical/x-cactvs-binary'		'cc' 'text/x-c++src'		'cdf' 'application/x-cdf'		'cdr' 'image/x-coreldraw'		'cdt' 'image/x-coreldrawtemplate'		'cdx' 'chemical/x-cdx'		'cdy' 'application/vnd.cinderella'		'cef' 'chemical/x-cxf'		'cer' 'chemical/x-cerius'		'chm' 'chemical/x-chemdraw'		'chrt' 'application/x-kchart'		'cif' 'chemical/x-cif'		'class' 'application/java-vm'		'cls' 'text/x-tex'		'cmdf' 'chemical/x-cmdf'		'cml' 'chemical/x-cml'		'cod' 'application/vnd.rim.cod'		'com' 'application/x-msdos-program'		'cpa' 'chemical/x-compass'		'cpio' 'application/x-cpio'		'cpp' 'text/x-c++src'		'cpt' 'image/x-corelphotopaint'		'crl' 'application/x-pkcs7-crl'		'crt' 'application/x-x509-ca-cert'		'csf' 'chemical/x-cache-csf'		'csh' 'text/x-csh'		'csm' 'chemical/x-csml'		'csml' 'chemical/x-csml'		'css' 'text/css'		'csv' 'text/comma-separated-values'		'ctab' 'chemical/x-cactvs-binary'		'ctx' 'chemical/x-ctx'		'cu' 'application/cu-seeme'		'cub' 'chemical/x-gaussian-cube'		'cxf' 'chemical/x-cxf'		'cxx' 'text/x-c++src'		'dat' 'chemical/x-mopac-input'		'dcr' 'application/x-director'		'deb' 'application/x-debian-package'		'dif' 'video/dv'		'diff' 'text/plain'		'dir' 'application/x-director'		'djv' 'image/vnd.djvu'		'djvu' 'image/vnd.djvu'		'dl' 'video/dl'		'dll' 'application/x-msdos-program'		'dmg' 'application/x-apple-diskimage'		'dms' 'application/x-dms'		'doc' 'application/msword'		'dot' 'application/msword'		'dv' 'video/dv'		'dvi' 'application/x-dvi'		'dx' 'chemical/x-jcamp-dx'		'dxr' 'application/x-director'		'emb' 'chemical/x-embl-dl-nucleotide'		'embl' 'chemical/x-embl-dl-nucleotide'		'ent' 'chemical/x-pdb'		'eps' 'application/postscript'		'etx' 'text/x-setext'		'exe' 'application/x-msdos-program'		'ez' 'application/andrew-inset'		'fb' 'application/x-maker'		'fbdoc' 'application/x-maker'		'fch' 'chemical/x-gaussian-checkpoint'		'fchk' 'chemical/x-gaussian-checkpoint'		'fig' 'application/x-xfig'		'flac' 'application/x-flac'		'fli' 'video/fli'		'fm' 'application/x-maker'		'frame' 'application/x-maker'		'frm' 'application/x-maker'		'gal' 'chemical/x-gaussian-log'		'gam' 'chemical/x-gamess-input'		'gamin' 'chemical/x-gamess-input'		'gau' 'chemical/x-gaussian-input'		'gcd' 'text/x-pcs-gcd'		'gcf' 'application/x-graphing-calculator'		'gcg' 'chemical/x-gcg8-sequence'		'gen' 'chemical/x-genbank'		'gf' 'application/x-tex-gf'		'gif' 'image/gif'		'gjc' 'chemical/x-gaussian-input'		'gjf' 'chemical/x-gaussian-input'		'gl' 'video/gl'		'gnumeric' 'application/x-gnumeric'		'gpt' 'chemical/x-mopac-graph'		'gsf' 'application/x-font'		'gsm' 'audio/x-gsm'		'gtar' 'application/x-gtar'		'h' 'text/x-chdr'		'h++' 'text/x-c++hdr'		'hdf' 'application/x-hdf'		'hh' 'text/x-c++hdr'		'hin' 'chemical/x-hin'		'hpp' 'text/x-c++hdr'		'hqx' 'application/mac-binhex40'		'hs' 'text/x-haskell'		'hta' 'application/hta'		'htc' 'text/x-component'		'htm' 'text/html'		'html' 'text/html'		'hxx' 'text/x-c++hdr'		'ica' 'application/x-ica'		'ice' 'x-conference/x-cooltalk'		'ico' 'image/x-icon'		'ics' 'text/calendar'		'icz' 'text/calendar'		'ief' 'image/ief'		'iges' 'model/iges'		'igs' 'model/iges'		'iii' 'application/x-iphone'		'inp' 'chemical/x-gamess-input'		'ins' 'application/x-internet-signup'		'iso' 'application/x-iso9660-image'		'isp' 'application/x-internet-signup'		'ist' 'chemical/x-isostar'		'istr' 'chemical/x-isostar'		'jad' 'text/vnd.sun.j2me.app-descriptor'		'jar' 'application/java-archive'		'java' 'text/x-java'		'jdx' 'chemical/x-jcamp-dx'		'jmz' 'application/x-jmol'		'jng' 'image/x-jng'		'jnlp' 'application/x-java-jnlp-file'		'jpe' 'image/jpeg'		'jpeg' 'image/jpeg'		'jpg' 'image/jpeg'		'js' 'application/x-javascript'		'kar' 'audio/midi'		'key' 'application/pgp-keys'		'kil' 'application/x-killustrator'		'kin' 'chemical/x-kinemage'		'kpr' 'application/x-kpresenter'		'kpt' 'application/x-kpresenter'		'ksp' 'application/x-kspread'		'kwd' 'application/x-kword'		'kwt' 'application/x-kword'		'latex' 'application/x-latex'		'lha' 'application/x-lha'		'lhs' 'text/x-literate-haskell'		'lsf' 'video/x-la-asf'		'lsx' 'video/x-la-asf'		'ltx' 'text/x-tex'		'lzh' 'application/x-lzh'		'lzx' 'application/x-lzx'		'm3u' 'audio/x-mpegurl'		'm4a' 'audio/mpeg'		'maker' 'application/x-maker'		'man' 'application/x-troff-man'		'mcif' 'chemical/x-mmcif'		'mcm' 'chemical/x-macmolecule'		'mdb' 'application/msaccess'		'me' 'application/x-troff-me'		'mesh' 'model/mesh'		'mid' 'audio/midi'		'midi' 'audio/midi'		'mif' 'application/x-mif'		'mm' 'application/x-freemind'		'mmd' 'chemical/x-macromodel-input'		'mmf' 'application/vnd.smaf'		'mml' 'text/mathml'		'mmod' 'chemical/x-macromodel-input'		'mng' 'video/x-mng'		'moc' 'text/x-moc'		'mol' 'chemical/x-mdl-molfile'		'mol2' 'chemical/x-mol2'		'moo' 'chemical/x-mopac-out'		'mop' 'chemical/x-mopac-input'		'mopcrt' 'chemical/x-mopac-input'		'mov' 'video/quicktime'		'movie' 'video/x-sgi-movie'		'mp2' 'audio/mpeg'		'mp3' 'audio/mpeg'		'mp4' 'video/mp4'		'mpc' 'chemical/x-mopac-input'		'mpe' 'video/mpeg'		'mpeg' 'video/mpeg'		'mpega' 'audio/mpeg'		'mpg' 'video/mpeg'		'mpga' 'audio/mpeg'		'ms' 'application/x-troff-ms'		'msh' 'model/mesh'		'msi' 'application/x-msi'		'mvb' 'chemical/x-mopac-vib'		'mxu' 'video/vnd.mpegurl'		'nb' 'application/mathematica'		'nc' 'application/x-netcdf'		'nwc' 'application/x-nwc'		'o' 'application/x-object'		'oda' 'application/oda'		'odb' 'application/vnd.oasis.opendocument.database'		'odc' 'application/vnd.oasis.opendocument.chart'		'odf' 'application/vnd.oasis.opendocument.formula'		'odg' 'application/vnd.oasis.opendocument.graphics'		'odi' 'application/vnd.oasis.opendocument.image'		'odm' 'application/vnd.oasis.opendocument.text-master'		'odp' 'application/vnd.oasis.opendocument.presentation'		'ods' 'application/vnd.oasis.opendocument.spreadsheet'		'odt' 'application/vnd.oasis.opendocument.text'		'ogg' 'application/ogg'		'old' 'application/x-trash'		'oth' 'application/vnd.oasis.opendocument.text-web'		'oza' 'application/x-oz-application'		'p' 'text/x-pascal'		'p7r' 'application/x-pkcs7-certreqresp'		'pac' 'application/x-ns-proxy-autoconfig'		'pas' 'text/x-pascal'		'pat' 'image/x-coreldrawpattern'		'pbm' 'image/x-portable-bitmap'		'pcf' 'application/x-font'		'pcf.Z' 'application/x-font'		'pcx' 'image/pcx'		'pdb' 'chemical/x-pdb'		'pdf' 'application/pdf'		'pfa' 'application/x-font'		'pfb' 'application/x-font'		'pgm' 'image/x-portable-graymap'		'pgn' 'application/x-chess-pgn'		'pgp' 'application/pgp-signature'		'pk' 'application/x-tex-pk'		'pl' 'text/x-perl'		'pls' 'audio/x-scpls'		'pm' 'text/x-perl'		'png' 'image/png'		'pnm' 'image/x-portable-anymap'		'pot' 'text/plain'		'ppm' 'image/x-portable-pixmap'		'pps' 'application/vnd.ms-powerpoint'		'ppt' 'application/vnd.ms-powerpoint'		'prf' 'application/pics-rules'		'prt' 'chemical/x-ncbi-asn1-ascii'		'ps' 'application/postscript'		'psd' 'image/x-photoshop'		'psp' 'text/x-psp'		'py' 'text/x-python'		'pyc' 'application/x-python-code'		'pyo' 'application/x-python-code'		'qt' 'video/quicktime'		'qtl' 'application/x-quicktimeplayer'		'ra' 'audio/x-realaudio'		'ram' 'audio/x-pn-realaudio'		'rar' 'application/rar'		'ras' 'image/x-cmu-raster'		'rd' 'chemical/x-mdl-rdfile'		'rdf' 'application/rdf+xml'		'rgb' 'image/x-rgb'		'rm' 'audio/x-pn-realaudio'		'roff' 'application/x-troff'		'ros' 'chemical/x-rosdal'		'rpm' 'application/x-redhat-package-manager'		'rss' 'application/rss+xml'		'rtf' 'text/rtf'		'rtx' 'text/richtext'		'rxn' 'chemical/x-mdl-rxnfile'		'sct' 'text/scriptlet'		'sd' 'chemical/x-mdl-sdfile'		'sd2' 'audio/x-sd2'		'sda' 'application/vnd.stardivision.draw'		'sdc' 'application/vnd.stardivision.calc'		'sdd' 'application/vnd.stardivision.impress'		'sdf' 'chemical/x-mdl-sdfile'		'sdp' 'application/vnd.stardivision.impress'		'sdw' 'application/vnd.stardivision.writer'		'ser' 'application/java-serialized-object'		'sgf' 'application/x-go-sgf'		'sgl' 'application/vnd.stardivision.writer-global'		'sh' 'text/x-sh'		'shar' 'application/x-shar'		'shtml' 'text/html'		'sid' 'audio/prs.sid'		'sik' 'application/x-trash'		'silo' 'model/mesh'		'sis' 'application/vnd.symbian.install'		'sit' 'application/x-stuffit'		'skd' 'application/x-koan'		'skm' 'application/x-koan'		'skp' 'application/x-koan'		'skt' 'application/x-koan'		'smf' 'application/vnd.stardivision.math'		'smi' 'application/smil'		'smil' 'application/smil'		'snd' 'audio/basic'		'spc' 'chemical/x-galactic-spc'		'spl' 'application/x-futuresplash'		'src' 'application/x-wais-source'		'stc' 'application/vnd.sun.xml.calc.template'		'std' 'application/vnd.sun.xml.draw.template'		'sti' 'application/vnd.sun.xml.impress.template'		'stl' 'application/vnd.ms-pki.stl'		'stw' 'application/vnd.sun.xml.writer.template'		'sty' 'text/x-tex'		'sv4cpio' 'application/x-sv4cpio'		'sv4crc' 'application/x-sv4crc'		'svg' 'image/svg+xml'		'svgz' 'image/svg+xml'		'sw' 'chemical/x-swissprot'		'swf' 'application/x-shockwave-flash'		'swfl' 'application/x-shockwave-flash'		'sxc' 'application/vnd.sun.xml.calc'		'sxd' 'application/vnd.sun.xml.draw'		'sxg' 'application/vnd.sun.xml.writer.global'		'sxi' 'application/vnd.sun.xml.impress'		'sxm' 'application/vnd.sun.xml.math'		'sxw' 'application/vnd.sun.xml.writer'		't' 'application/x-troff'		'tar' 'application/x-tar'		'taz' 'application/x-gtar'		'tcl' 'text/x-tcl'		'tex' 'text/x-tex'		'texi' 'application/x-texinfo'		'texinfo' 'application/x-texinfo'		'text' 'text/plain'		'tgf' 'chemical/x-mdl-tgf'		'tgz' 'application/x-gtar'		'tif' 'image/tiff'		'tiff' 'image/tiff'		'tk' 'text/x-tcl'		'tm' 'text/texmacs'		'torrent' 'application/x-bittorrent'		'tr' 'application/x-troff'		'ts' 'text/texmacs'		'tsp' 'application/dsptype'		'tsv' 'text/tab-separated-values'		'txt' 'text/plain'		'udeb' 'application/x-debian-package'		'uls' 'text/iuls'		'ustar' 'application/x-ustar'		'val' 'chemical/x-ncbi-asn1-binary'		'vcd' 'application/x-cdlink'		'vcf' 'text/x-vcard'		'vcs' 'text/x-vcalendar'		'vmd' 'chemical/x-vmd'		'vms' 'chemical/x-vamas-iso14976'		'vor' 'application/vnd.stardivision.writer'		'vrm' 'x-world/x-vrml'		'vrml' 'x-world/x-vrml'		'vsd' 'application/vnd.visio'		'wad' 'application/x-doom'		'wav' 'audio/x-wav'		'wax' 'audio/x-ms-wax'		'wbmp' 'image/vnd.wap.wbmp'		'wbxml' 'application/vnd.wap.wbxml'		'wk' 'application/x-123'		'wm' 'video/x-ms-wm'		'wma' 'audio/x-ms-wma'		'wmd' 'application/x-ms-wmd'		'wml' 'text/vnd.wap.wml'		'wmlc' 'application/vnd.wap.wmlc'		'wmls' 'text/vnd.wap.wmlscript'		'wmlsc' 'application/vnd.wap.wmlscriptc'		'wmv' 'video/x-ms-wmv'		'wmx' 'video/x-ms-wmx'		'wmz' 'application/x-ms-wmz'		'wp5' 'application/wordperfect5.1'		'wpd' 'application/wordperfect'		'wrl' 'x-world/x-vrml'		'wsc' 'text/scriptlet'		'wvx' 'video/x-ms-wvx'		'wz' 'application/x-wingz'		'xbm' 'image/x-xbitmap'		'xcf' 'application/x-xcf'		'xht' 'application/xhtml+xml'		'xhtml' 'application/xhtml+xml'		'xlb' 'application/vnd.ms-excel'		'xls' 'application/vnd.ms-excel'		'xlt' 'application/vnd.ms-excel'		'xml' 'application/xml'		'xpi' 'application/x-xpinstall'		'xpm' 'image/x-xpixmap'		'xsl' 'application/xml'		'xtel' 'chemical/x-xtel'		'xul' 'application/vnd.mozilla.xul+xml'		'xwd' 'image/x-xwindowdump'		'xyz' 'chemical/x-xyz'		'zip' 'application/zip'		'zmt' 'chemical/x-mopac-input'		'~' 'application/x-trash'	)</body></methods><methods><class-id>Seaside.WAAbstractFileLibrary class</class-id> <category>accessing</category><body package="Seaside-Core">libraries	^ WAFileLibrary allSubclasses,  WAFileMetadataLibrary allSubclasses</body><body package="Seaside-Core">mimetypeFor: aString	^ (self mimetypes at: aString ifAbsent: [ self defaultMimeType ]) seasideMimeType</body><body package="Seaside-Core">mimetypes	^ MimeTypes</body></methods><methods><class-id>Seaside.WAAbstractFileLibrary class</class-id> <category>actions</category><body package="Seaside-Core">deployFiles	^ self default deployFiles</body></methods><methods><class-id>Seaside.WAAbstractFileLibrary class</class-id> <category>handling</category><body package="Seaside-Core">handle: aRequestContext	^ self default handle: aRequestContext</body></methods><methods><class-id>Seaside.WAAbstractFileLibrary class</class-id> <category>convenience</category><body package="Seaside-Core">/ aSymbol	^ self urlOf: aSymbol</body><body package="Seaside-Core">urlOf: aSymbol	^ self default urlOf: aSymbol</body></methods><methods><class-id>Seaside.WAAbstractFileLibrary class</class-id> <category>private</category><body package="Seaside-Core">asSelector: aFilename	| mainPart extension |	mainPart := (aFilename copyUpToLast: $.)		select: [ :each | each isAlphaNumeric ].	[ mainPart isEmpty not and: [ mainPart first isDigit ] ]		whileTrue: [ mainPart := mainPart allButFirst ].		mainPart isEmpty ifTrue: [ ^ nil ].			extension := ((aFilename copyAfterLast: $.)		select: [ :each | each isAlphaNumeric ]) asLowercase capitalized.	^ (mainPart, extension) asSymbol</body><body package="Seaside-Core">compileBinary: aByteArrayOrString selector: aSymbol 	"compiles aByteArrayOrString into a method named aSymbol that returns aByteArrayOrString as a byte array"	| code |	code := GRPlatform current 		asMethodReturningByteArray: aByteArrayOrString		named: aSymbol.	GRPlatform current 		compile: code		into: self		classified: self methodCategory</body><body package="Seaside-Core">compileText: aByteArrayOrString selector: aSymbol 	"Compiles aByteArrayOrString into a method named aSymbol that returns aByteArrayOrString as a string literal.	aSymbol		^ aByteArrayOrString"	| code |	code := String streamContents: [ :stream | 		stream			nextPutAll: aSymbol;			nextPut: Character cr.		stream			tab;			nextPutAll: '^ '''.		aByteArrayOrString greaseString do: [ :each | 			each = $' ifTrue: [ stream nextPut: $' ].			stream nextPut: each ].		stream nextPut: $' ].	GRPlatform current 		compile: code		into: self		classified: self methodCategory</body><body package="Seaside-Core">isBinary: aFilename	^ (self mimetypeFor: (aFilename copyAfterLast: $.)) isBinary</body><body package="Seaside-Core">isBinaryAt: aPath 	^ self isBinary: (GRPlatform current localNameOf: aPath)</body><body package="Seaside-Core">methodCategory	"the method category for uploaded files"	^ #uploaded</body></methods><methods><class-id>Seaside.WAAbstractFileLibrary class</class-id> <category>testing</category><body package="Seaside-Core">handlesFolder: aSymbol	^ self name = aSymbol</body></methods><methods><class-id>Seaside.WAAbstractFileLibrary class</class-id> <category>file addition</category><body package="Seaside-Core">addAllFilesIn: aPathString 	"adds all files in the directory specified by aPathString to the current file library - 	does *not* recurse into sub-directories"	(GRPlatform current filesIn: aPathString) do: [ :each | self addFileAt: each ]</body><body package="Seaside-Core">addFileAt: aPath 	"Add the file specified by aPath to the current file library."	self 		addFileAt: aPath		contents: (GRPlatform current 				contentsOfFile: aPath				binary: (self isBinaryAt: aPath))</body><body package="Seaside-Core">addFileAt: aPath contents: aByteArrayOrString 	self 		addFileNamed: (GRPlatform current localNameOf: aPath)		contents: aByteArrayOrString</body><body package="Seaside-Core">addFileNamed: aFilename contents: aByteArrayOrString	self subclassResponsibility</body></methods><methods><class-id>Seaside.WAAbstractFileLibrary class</class-id> <category>instance creation</category><body package="Seaside-Core">default	^ default ifNil: [ default := self new ]</body></methods><methods><class-id>Seaside.WAAbstractFileLibrary class</class-id> <category>class initialization</category><body package="Seaside-Core">initialize	MimeTypes := Dictionary new.	1 to: self defaultMimeTypes size by: 2 do: [ :index |		MimeTypes			at: (self defaultMimeTypes at: index)			put: (self defaultMimeTypes at: index + 1) ]</body></methods><methods><class-id>Seaside.WAExceptionHandler</class-id> <category>accessing</category><body package="Seaside-Core">requestContext	"Exception handlers are created with a request context because they may	often be running where WACurrentRequestContext is either undefined or	unused."	^ requestContext</body></methods><methods><class-id>Seaside.WAExceptionHandler</class-id> <category>actions</category><body package="Seaside-Core">handleException: anException	"If for some reason we are asked to handle an exception for which we have no	handling behaviour defined, just pass."		^ anException pass</body><body package="Seaside-Core">handleExceptionsDuring: aBlock	^ aBlock		on: self		do: [ :exception | 			[ self handleException: exception ]				"If there's an error while handling the exception, fall				back on an internal error response."				on: Error				do: [ :error | self internalError: error ] ]</body><body package="Seaside-Core">internalError: anError 	"This method should not call #handleException: because subclasses want to modify the behaviour for for other exceptions without changing the simple fallback internal error behaviour."		self requestContext responseGenerator		internalError: anError;		respond</body></methods><methods><class-id>Seaside.WAExceptionHandler</class-id> <category>ansi-exception-selector</category><body package="Seaside-Core">, anException	^ self class, anException</body><body package="Seaside-Core">handles: anException	^ self class handles: anException</body></methods><methods><class-id>Seaside.WAExceptionHandler</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithContext: aRequestContext	self initialize.	requestContext := aRequestContext</body></methods><methods><class-id>Seaside.WAExceptionHandler class</class-id> <category>instance creation</category><body package="Seaside-Core">context: aRequestContext	^ self basicNew initializeWithContext: aRequestContext; yourself</body><body package="Seaside-Core">new	^ self context: nil</body></methods><methods><class-id>Seaside.WAExceptionHandler class</class-id> <category>exception handling</category><body package="Seaside-Core">exceptionSelector	^ ExceptionSet new</body><body package="Seaside-Core">handleExceptionsDuring: aBlock context: aRequestContext	^ (self context: aRequestContext) handleExceptionsDuring: aBlock</body></methods><methods><class-id>Seaside.WAExceptionHandler class</class-id> <category>ansi-exception-selector</category><body package="Seaside-Core">, anException 	"Create an exception set that includes all the exceptions we handle and the	one passed as a parameter."	^ self exceptionSelector, anException</body><body package="Seaside-Core">handles: anException 	"You should probably override #exceptionSelector instead of this method.	If you do need to override this method, make sure to override #, as well"	^ self exceptionSelector handles: anException</body></methods><methods><class-id>Seaside.WAExceptionHandler class</class-id> <category>responding</category><body package="Seaside-Core">internalError: anError context: aRequestContext	^ (self context: aRequestContext) internalError: anError</body></methods><methods><class-id>Seaside.WAErrorHandler</class-id> <category>actions</category><body package="Seaside-Core">handleDefault: anException	"This method provides the default behaviour if subclasses do	not implement one of the specific handler methods."	^ self internalError: anException</body><body package="Seaside-Core">handleError: anError	^ self handleDefault: anError</body><body package="Seaside-Core">handleException: anException	(Error handles: anException)		ifTrue: [ ^ self handleError: anException ].	(Warning handles: anException)		ifTrue: [ ^ self handleWarning: anException ].	^ super handleException: anException</body><body package="Seaside-Core">handleWarning: aWarning	^ self handleDefault: aWarning</body></methods><methods><class-id>Seaside.WAErrorHandler class</class-id> <category>exception handling</category><body package="Seaside-Core">exceptionSelector	^ super exceptionSelector, Error, Warning</body></methods><methods><class-id>Seaside.WAMimeDocument</class-id> <category>accessing</category><body package="Seaside-Core">contents	"Answer the content of the receiver as a Collection of Characters or bytes."		^ contents</body><body package="Seaside-Core">contents: aCollection	contents := aCollection</body><body package="Seaside-Core">fileName	"Answer the file name of this document, or nil."		^ fileName</body><body package="Seaside-Core">fileName: aString	fileName := aString</body><body package="Seaside-Core">mimeType	"Answer the file name of this document, or nil."		^ mimeType</body><body package="Seaside-Core">mimeType: aMimeType	mimeType := aMimeType isNil		ifFalse: [ aMimeType seasideMimeType ]		ifTrue: [ WAMimeType applicationOctetStream ]</body></methods><methods><class-id>Seaside.WAMimeDocument</class-id> <category>comparing</category><body package="Seaside-Core">= anObject	^ (anObject isKindOf: WAMimeDocument)		and: [ self mimeType = anObject mimeType		and: [ self fileName = anObject fileName		and: [ self contents = anObject contents ] ] ]</body><body package="Seaside-Core">hash	^ (self mimeType hash		bitXor: self fileName hash)		bitXor: self contents hash</body></methods><methods><class-id>Seaside.WAMimeDocument</class-id> <category>compatibility</category><body package="Seaside-Core">content	^ self contents</body><body package="Seaside-Core">contentStream	^ self contents readStream</body><body package="Seaside-Core">contentType	^ self mimeType</body></methods><methods><class-id>Seaside.WAMimeDocument</class-id> <category>converting</category><body package="Seaside-Core">seasideMimeDocument	^ self</body></methods><methods><class-id>Seaside.WAMimeDocument</class-id> <category>initialization</category><body package="Seaside-Core">initializeOn: aCollection mimeType: aMimeType fileName: aString	self initialize.	self contents: aCollection.	self mimeType: aMimeType.	self fileName: aString</body></methods><methods><class-id>Seaside.WAMimeDocument class</class-id> <category>instance creation</category><body package="Seaside-Core">on: aCollection	^ self on: aCollection mimeType: nil</body><body package="Seaside-Core">on: aCollection mimeType: aMimeType	^ self on: aCollection mimeType: aMimeType fileName: nil</body><body package="Seaside-Core">on: aCollection mimeType: aMimeType fileName: aString	^ self basicNew initializeOn: aCollection mimeType: aMimeType fileName: aString; yourself</body></methods><methods><class-id>Seaside.WADocument</class-id> <category>writing</category><body package="Seaside-Core">nextPut: aCharacter	stream nextPut: aCharacter</body><body package="Seaside-Core">nextPutAll: aString	stream nextPutAll: aString</body></methods><methods><class-id>Seaside.WADocument</class-id> <category>actions</category><body package="Seaside-Core">close	"Close the receiving document."	root isNil ifFalse: [ root closeOn: self ]</body><body package="Seaside-Core">open: aRoot	"Open the receiving document with aRoot."	(root := aRoot) openOn: self</body></methods><methods><class-id>Seaside.WADocument</class-id> <category>accessing</category><body package="Seaside-Core">scriptGenerator: aScriptGenerator	"ignore"</body><body package="Seaside-Core">stream	"Answer the underlying character stream of this document."	^ stream</body></methods><methods><class-id>Seaside.WADocument</class-id> <category>initialization</category><body package="Seaside-Core">destroy	stream := root := nil</body><body package="Seaside-Core">initializeWithStream: aStream codec: aCodec	self initialize.	stream := aStream</body></methods><methods><class-id>Seaside.WADocument class</class-id> <category>instance creation</category><body package="Seaside-Core">new	^ self on: GRPlatform current readWriteCharacterStream</body><body package="Seaside-Core">on: aStream 	^ self 		on: aStream		codec: GRNullCodec new</body><body package="Seaside-Core">on: aStream codec: aCodec	^ self basicNew initializeWithStream: aStream codec: aCodec; yourself</body></methods><methods><class-id>Seaside.WAXmlDocument</class-id> <category>accessing</category><body package="Seaside-Core">urlEncoder	"Answer an encoder for URL data."	^ urlEncoder</body><body package="Seaside-Core">xmlEncoder	"Answer an encoder for XML data."	^ xmlEncoder</body></methods><methods><class-id>Seaside.WAXmlDocument</class-id> <category>writing</category><body package="Seaside-Core">closeTag: aString	"Close the XML tag named aString."	stream nextPutAll: '&lt;/'; nextPutAll: aString; nextPut: $&gt;</body><body package="Seaside-Core">openTag: aString	"Open the XML tag named aString."	self openTag: aString attributes: nil closed: false</body><body package="Seaside-Core">openTag: aString attributes: anAttributes	"Open the XML tag named aString with the attribute dictionary anAttributes."	self openTag: aString attributes: anAttributes closed: false</body><body package="Seaside-Core">openTag: aString attributes: anAttributes closed: aBoolean	"Open the XML tag named aString with the attribute dictionary anAttributes. Immediately close the tag if aBoolean is true."		stream nextPut: $&lt;; nextPutAll: aString.	anAttributes encodeOn: self.	aBoolean ifTrue: [ stream nextPut: $/ ].	stream nextPut: $&gt;</body><body package="Seaside-Core">print: anObject	anObject encodeOn: self</body></methods><methods><class-id>Seaside.WAXmlDocument</class-id> <category>initialization</category><body package="Seaside-Core">destroy	super destroy.	urlEncoder := xmlEncoder := nil</body><body package="Seaside-Core">initializeWithStream: aStream codec: aCodec	super initializeWithStream: aStream codec: aCodec.	xmlEncoder := GRPlatform current xmlEncoderOn: aStream.	urlEncoder := GRPlatform current urlEncoderOn: aStream codec: aCodec</body></methods><methods><class-id>Seaside.WAUnescapedDocument</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithStream: aStream codec: aCodec	super initializeWithStream: aStream codec: aCodec.	xmlEncoder := aStream</body></methods><methods><class-id>Seaside.WAActionCallback</class-id> <category>accessing</category><body package="Seaside-Core">block: aZeroOrOneArgBlock	block := aZeroOrOneArgBlock fixCallbackTemps</body><body package="Seaside-Core">priority	^ 5</body></methods><methods><class-id>Seaside.WAActionCallback</class-id> <category>evaluation</category><body package="Seaside-Core">evaluateWithArgument: anObject	block valueWithPossibleArguments: (Array with: anObject).	self signalRenderNotification</body><body package="Seaside-Core">signalRenderNotification	WARenderNotification signal</body></methods><methods><class-id>Seaside.WAActionCallback</class-id> <category>testing</category><body package="Seaside-Core">isEnabledFor: aRequestContext	^ aRequestContext request isXmlHttpRequest not</body></methods><methods><class-id>Seaside.WAImageCallback</class-id> <category>converting</category><body package="Seaside-Core">convertKey: aString	^ aString , '.x'</body></methods><methods><class-id>Seaside.WAFileHandlerListing</class-id> <category>responding</category><body package="Seaside-Core">responseForLibraries	self subclassResponsibility</body><body package="Seaside-Core">responseForLibrary: aLibrary	self subclassResponsibility</body></methods><methods><class-id>Seaside.WAFileHandlerListing</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithFileHandler: aFileHandler context: aRequestContext	self initialize.	handler := aFileHandler.	context := aRequestContext</body></methods><methods><class-id>Seaside.WAFileHandlerListing class</class-id> <category>instance creation</category><body package="Seaside-Core">on: aFileHandler context: aRequestContext	^ self basicNew initializeWithFileHandler: aFileHandler context: aRequestContext; yourself</body></methods><methods><class-id>Seaside.WAForbiddenFileHandlerListing</class-id> <category>responding</category><body package="Seaside-Core">responseForLibraries	context responseGenerator		forbidden;		respond</body><body package="Seaside-Core">responseForLibrary: aLibrary 	context responseGenerator		forbidden;		respond</body></methods><methods><class-id>Seaside.WAExpiringCache</class-id> <category>removing</category><body package="Seaside-Core">remove: anObject	self shouldNotImplement</body><body package="Seaside-Core">removeKey: aKey	self subclassResponsibility</body></methods><methods><class-id>Seaside.WAExpiringCache</class-id> <category>private</category><body package="Seaside-Core">cacheEntryRemoved: anObject	(anObject respondsTo: #unregistered) ifTrue: [		[ anObject unregistered ]			on: Error			do: [ "keep reaping process running" ] ]</body></methods><methods><class-id>Seaside.WAExpiringCache</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithInitialSize: aSizeInteger maximumSize: aMaximumSizeInteger maximumAbsoluteAge: aMaximumAbsoluteAge maximumRelativeAge: aMaximumRelativeAge overflowAction: aOverflowActionSymbol	self initialize.	maximumSize := aMaximumSizeInteger.	maximumAbsoluteAge := aMaximumAbsoluteAge.	maximumRelativeAge := aMaximumRelativeAge.	overflowAction := aOverflowActionSymbol</body></methods><methods><class-id>Seaside.WAExpiringCache</class-id> <category>accessing</category><body package="Seaside-Core">keyAtValue: anObject ifAbsent: aBlock	self shouldNotImplement</body></methods><methods><class-id>Seaside.WAExpiringCache class</class-id> <category>instance creation</category><body package="Seaside-Core">initialSize: aSizeInteger maximumSize: aMaximumSizeInteger maximumAbsoluteAge: aMaximumAbsoluteAge maximumRelativeAge: aMaximumRelativeAge overflowAction: aOverflowActionSymbol	^ self basicNew		initializeWithInitialSize: aSizeInteger maximumSize: aMaximumSizeInteger maximumAbsoluteAge: aMaximumAbsoluteAge maximumRelativeAge: aMaximumRelativeAge overflowAction: aOverflowActionSymbol;		yourself</body><body package="Seaside-Core">newLikeOldCache	"creates a new cache configured similar to the one in Seaside &lt;= 3.1"	^ self initialSize: 13		maximumSize: 0		maximumAbsoluteAge: 0		maximumRelativeAge: 600		overflowAction: nil</body></methods><methods><class-id>Seaside.WABulkReapingCache</class-id> <category>accessing</category><body package="Seaside-Core">at: aKey ifAbsent: aBlock	| entry |	entry := dictionary at: aKey ifAbsent: [ ^ aBlock value ].	entry incrementCount.	^ entry value</body><body package="Seaside-Core">size	^ dictionary size</body></methods><methods><class-id>Seaside.WABulkReapingCache</class-id> <category>private</category><body package="Seaside-Core">isExpired: aCacheEntry	^ self isExpired: aCacheEntry now: Time totalSeconds</body><body package="Seaside-Core">isExpired: aCacheEntry now: currentSeconds	(maximumAbsoluteAge &gt; 0 and: [ (currentSeconds- aCacheEntry creationTime) &gt; maximumAbsoluteAge ])		ifTrue: [ ^ true ].		(maximumRelativeAge &gt; 0 and: [ (currentSeconds - aCacheEntry accessTime) &gt; maximumRelativeAge ])		ifTrue: [ ^ true ].			^ false</body></methods><methods><class-id>Seaside.WABulkReapingCache</class-id> <category>public</category><body package="Seaside-Core">clear	dictionary valuesDo: [ :value |		self cacheEntryRemoved: value value ].	dictionary removeAll</body><body package="Seaside-Core">reap	"Iterate through the cache and remove objects that have expired. Returns the number of expired objects."		| now platform count expiredEntries |	now := Time totalSeconds.	expiredEntries := OrderedCollection new.		dictionary keysAndValuesDo: [ :key :value |		value hasBeenAccessedSinceLastReap ifTrue: [			value setAccessTime: now ].		(self isExpired: value now: now) ifTrue: [			expiredEntries add: key ] ].		"In GemStone, this method is performed by a separate maintenance VM, 	so we are already in transaction (assumed to be running in #autoBegin 	transactionMode) and do not have to worry about acquiring the TransactionMutex.	Since we are using reducedConflict dictionaries in the first place, we will remove the keys	and values from the existing dictionaries without using the mutex."		count := 0.	platform := GRPlatform current.	expiredEntries do:[ :key |		| value |		value := dictionary removeKey: key.		self cacheEntryRemoved: value value.		count := count + 1.		(count \\ 100) isZero ifTrue: [			platform doCommitTransaction ] ].	(count \\ 100) isZero ifFalse: [		platform doCommitTransaction ].	^ count</body></methods><methods><class-id>Seaside.WABulkReapingCache</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithInitialSize: aSizeInteger maximumSize: aMaximumSizeInteger maximumAbsoluteAge: aMaximumAbsoluteAge maximumRelativeAge: aMaximumRelativeAge overflowAction: aOverflowActionSymbol	super initializeWithInitialSize: aSizeInteger maximumSize: aMaximumSizeInteger maximumAbsoluteAge: aMaximumAbsoluteAge maximumRelativeAge: aMaximumRelativeAge overflowAction: aOverflowActionSymbol.	dictionary := GRPlatform current reducedConflictDictionary new</body></methods><methods><class-id>Seaside.WABulkReapingCache</class-id> <category>enumerating</category><body package="Seaside-Core">keysAndValuesDo: aTwoArgumentBlock	dictionary keysAndValuesDo: [ :key :value |		 aTwoArgumentBlock value: key value: value value ]</body></methods><methods><class-id>Seaside.WABulkReapingCache</class-id> <category>copying</category><body package="Seaside-Core">postCopy	| oldDictionary |	super postCopy.	oldDictionary := dictionary.	dictionary := GRPlatform current reducedConflictDictionary new.	oldDictionary keysAndValuesDo: [ :key :value |		dictionary at: key put: value copy "shallow copy is enough" ]</body></methods><methods><class-id>Seaside.WABulkReapingCache</class-id> <category>putting</category><body package="Seaside-Core">at: aKey put: anObject	| present value |	present := false.	value := WABulkReapingCacheEntry value: anObject.	dictionary		at: aKey		ifAbsentPut: [ present := true. value ].	present ifTrue: [		^ anObject ].	dictionary at: aKey put: value.	^ anObject</body><body package="Seaside-Core">store: anObject	| candidateKey value |	value := WABulkReapingCacheEntry value: anObject.	[ 		| written |		written := false.		candidateKey := WAKeyGenerator current keyOfLength: self keySize.		dictionary at: candidateKey ifAbsentPut: [ written := true. value ].		written ] whileFalse.	^ candidateKey</body></methods><methods><class-id>Seaside.WABulkReapingCache</class-id> <category>removing</category><body package="Seaside-Core">removeKey: aKey	| entry value |	entry := dictionary removeKey: aKey.	value := entry value.	self cacheEntryRemoved: value.	^ value</body></methods><methods><class-id>Seaside.WAAuthenticationFilter</class-id> <category>accessing</category><body package="Seaside-Core">authenticator	"Answer the object used for authentication. Defaults to the owning handler."	^ authenticator ifNil: [ self handler ]</body><body package="Seaside-Core">authenticator: anObject	authenticator := anObject</body><body package="Seaside-Core">realm	"Answer the realm to be displayed in the authentication dialog."		^ realm ifNil: [ realm := 'Seaside' ]</body><body package="Seaside-Core">realm: anObject	realm := anObject</body></methods><methods><class-id>Seaside.WAAuthenticationFilter</class-id> <category>processing</category><body package="Seaside-Core">handleFiltered: aRequestContext 	(self verifyRequest: aRequestContext request) 		ifTrue: [ super handleFiltered: aRequestContext ]		ifFalse: [			aRequestContext responseGenerator				authenticate: self realm;				respond ]</body></methods><methods><class-id>Seaside.WAAuthenticationFilter</class-id> <category>testing</category><body package="Seaside-Core">verifyRequest: aRequest	^ self authenticator verifyPassword: aRequest password forUser: aRequest user</body></methods><methods><class-id>Seaside.WAHtmlRoot</class-id> <category>elements</category><body package="Seaside-Core">base	^ self add: (WABaseElement root: self)</body><body package="Seaside-Core">if	^ WAConditionalComment root: self</body><body package="Seaside-Core">javascript	^ self script beJavascript; yourself</body><body package="Seaside-Core">link	^ self add: (WALinkElement root: self)</body><body package="Seaside-Core">meta	^ self add: (WAMetaElement root: self)</body><body package="Seaside-Core">revealedIf	^ WARevealedConditionalComment root: self</body><body package="Seaside-Core">script	^ self add: (WAScriptElement root: self)</body><body package="Seaside-Core">stylesheet	^ self link beStylesheet; beCss; yourself</body></methods><methods><class-id>Seaside.WAHtmlRoot</class-id> <category>accessing-attributes</category><body package="Seaside-Core">bodyAttributes	^ bodyAttrs ifNil: [ bodyAttrs := WAHtmlAttributes new ]</body><body package="Seaside-Core">headAttributes	^ headAttrs ifNil: [ headAttrs := WAHtmlAttributes new ]</body><body package="Seaside-Core">htmlAttributes	^ htmlAttrs ifNil: [ htmlAttrs := WAHtmlAttributes new ]</body></methods><methods><class-id>Seaside.WAHtmlRoot</class-id> <category>writing</category><body package="Seaside-Core">closeOn: aDocument	aDocument scriptGenerator		close: self on: aDocument.	self writeFootOn: aDocument</body><body package="Seaside-Core">openOn: aDocument	aDocument scriptGenerator 		open: self on: aDocument.	self writeHeadOn: aDocument</body><body package="Seaside-Core">writeElementsOn: aDocument	aDocument openTag: 'title'; nextPutAll: title; closeTag: 'title'.	headElements do: [ :each | aDocument print: each ]</body><body package="Seaside-Core">writeFootOn: aDocument	aDocument closeTag: 'body'.	aDocument closeTag: 'html'</body><body package="Seaside-Core">writeHeadOn: aDocument	aDocument nextPutAll: docType.	aDocument openTag: 'html' attributes: htmlAttrs.	aDocument openTag: 'head' attributes: headAttrs.	self writeElementsOn: aDocument.	self writeStylesOn: aDocument.	self writeScriptsOn: aDocument.	aDocument closeTag: 'head'.	aDocument openTag: 'body' attributes: bodyAttrs</body><body package="Seaside-Core">writeScriptsOn: aDocument	scripts ifNil: [ ^ self ].	scripts do: [ :each |		aDocument print: ((WAScriptElement root: self)			beJavascript;			document: each;			yourself) ]</body><body package="Seaside-Core">writeStylesOn: aDocument	styles ifNil: [ ^ self ].	styles do: [ :each |		aDocument print: ((WALinkElement root: self)			beStylesheet; beCss;			document: each;			yourself) ]</body></methods><methods><class-id>Seaside.WAHtmlRoot</class-id> <category>convenience</category><body package="Seaside-Core">contentBase: urlString	self base url: urlString</body><body package="Seaside-Core">redirectTo: aLocationString delay: aNumber	self meta redirectAfter: aNumber to: aLocationString</body></methods><methods><class-id>Seaside.WAHtmlRoot</class-id> <category>initialization</category><body package="Seaside-Core">initialize	super initialize.	headElements := OrderedCollection new.	title := docType := String new</body></methods><methods><class-id>Seaside.WAHtmlRoot</class-id> <category>doctype</category><body package="Seaside-Core">beHtml5	self docType: '&lt;!DOCTYPE html&gt;'</body><body package="Seaside-Core">beXhtml10Strict	self meta contentScriptType: WAMimeType textJavascript.	self addXmlNamespaces.	self docType: '&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"&gt;'</body><body package="Seaside-Core">beXhtml10Transitional	self meta contentScriptType: WAMimeType textJavascript.	self addXmlNamespaces.	self docType: '&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;'</body><body package="Seaside-Core">beXhtml11	self meta contentScriptType: WAMimeType textJavascript.	self addXmlNamespaces.	self docType: '&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd"&gt;'</body><body package="Seaside-Core">docType	^ docType</body><body package="Seaside-Core">docType: aString	"Set the document-type of the receiver. The table at http://www.w3.org/TR/2002/NOTE-xhtml-media-types-20020430/ summarizes the recommendation to content authors for labeling their XHTML documents:Media type				XHTML 1.0 (HTML compatible)	XHTML 1.0 (other)	XHTML Basic / 1.1	XHTML+MathMLtext/html				MAY							SHOULD NOT			SHOULD NOT			SHOULD NOTapplication/xhtml+xml	SHOULD							SHOULD				SHOULD				SHOULDapplication/xml			MAY							MAY				MAY				MAYtext/xml					MAY							MAY				MAY				MAY"	docType := aString</body></methods><methods><class-id>Seaside.WAHtmlRoot</class-id> <category>accessing-properties</category><body package="Seaside-Core">title	^ title</body><body package="Seaside-Core">title: aString	title := aString</body></methods><methods><class-id>Seaside.WAHtmlRoot</class-id> <category>accessing</category><body package="Seaside-Core">headElements	^ headElements</body><body package="Seaside-Core">headElements: anOrderedCollection	headElements := anOrderedCollection</body></methods><methods><class-id>Seaside.WAHtmlRoot</class-id> <category>adding</category><body package="Seaside-Core">add: aHtmlElement	"Add a HTML head element to the receiver."	^ headElements add: aHtmlElement</body><body package="Seaside-Core">addScript: aString	"Include the script aString into the receiver."	scripts ifNil: [ scripts := Set new ].	scripts add: aString</body><body package="Seaside-Core">addStyle: aString	"Include the style-sheet aString into the receiver."	styles ifNil: [ styles := Set new ].	styles add: aString</body></methods><methods><class-id>Seaside.WAHtmlRoot</class-id> <category>private</category><body package="Seaside-Core">addXmlNamespaces	self htmlAttributes		at: 'xmlns' put: 'http://www.w3.org/1999/xhtml';		at: 'xml:lang' put: 'en';		at: 'lang' put: 'en'</body></methods><methods><class-id>Seaside.WAFileHandler</class-id> <category>configuration</category><body package="Seaside-Core">defaultConfiguration	^ super defaultConfiguration		removeParent: WARequestHandlingConfiguration instance;		addParent: WAFileHandlerConfiguration instance;		yourself</body><body package="Seaside-Core">fileHandlerListingClass	^ self preferenceAt: #fileHandlerListingClass</body><body package="Seaside-Core">resourceBaseUrl	^ self preferenceAt: #resourceBaseUrl</body><body package="Seaside-Core">useXSendfile	^ self preferenceAt: #useXSendfile</body><body package="Seaside-Core">xSendfileBaseDirectory	^ self preferenceAt: #xSendfileBaseDirectory</body></methods><methods><class-id>Seaside.WAFileHandler</class-id> <category>accessing</category><body package="Seaside-Core">baseUrlForLibrary	| resourceBaseUrl |	resourceBaseUrl := self resourceBaseUrl.	^ resourceBaseUrl isNil		ifTrue: [ self url ]		ifFalse: [ resourceBaseUrl copy ]</body><body package="Seaside-Core">libraries	^ WAAbstractFileLibrary libraries</body><body package="Seaside-Core">libraryAt: aSymbol ifAbsent: aBlock	^ self libraries 		detect: [ :each | each handlesFolder: aSymbol ]		ifNone: aBlock</body></methods><methods><class-id>Seaside.WAFileHandler</class-id> <category>handling</category><body package="Seaside-Core">handleFiltered: aRequestContext	self responseForContext: aRequestContext</body></methods><methods><class-id>Seaside.WAFileHandler</class-id> <category>private</category><body package="Seaside-Core">responseForContext: aRequestContext	| libraryClass consumer |	consumer := aRequestContext consumer.	consumer atEnd		ifTrue: [ ^ (self fileHandlerListingClass on: self context: aRequestContext) responseForLibraries ].	libraryClass := self 		libraryAt: consumer next asSymbol		ifAbsent: [ ^ aRequestContext responseGenerator notFound; respond ].	consumer atEnd		ifTrue: [			| listingClass |			listingClass := (self fileHandlerListingClass on: self context: aRequestContext).			listingClass responseForLibrary: libraryClass default ]		ifFalse: [			libraryClass handle: aRequestContext.			" won't be executed if a document is found "			aRequestContext responseGenerator				notFound;				respond ]</body></methods><methods><class-id>Seaside.WAFileHandler class</class-id> <category>accessing</category><body package="Seaside-Core">default	default isNil ifTrue: [ default := self new ].	^ default</body><body package="Seaside-Core">default: aFileHandler	default := aFileHandler</body><body package="Seaside-Core">description	^ 'File Library'</body></methods><methods><class-id>Seaside.WADynamicVariable</class-id> <category>defaults</category><body package="Seaside-Core">defaultAction	^ self class defaultValue</body></methods><methods><class-id>Seaside.WADynamicVariable class</class-id> <category>evaluating</category><body package="Seaside-Core">use: anObject during: aBlock	"Set the dynamic value of the receiver to anObject during the evaluation of aBlock."		^ aBlock on: self do: [ :notification | notification resume: anObject ]</body><body package="Seaside-Core">value	"Answer the dynamic value of the receiver."		^ self signal</body></methods><methods><class-id>Seaside.WADynamicVariable class</class-id> <category>defaults</category><body package="Seaside-Core">defaultValue	^ nil</body></methods><methods><class-id>Seaside.WACurrentRequestContext class</class-id> <category>defaults</category><body package="Seaside-Core">defaultValue	^ WARequestContextNotFound signal</body></methods><methods><class-id>Seaside.WAAllValuesCallback</class-id> <category>evaluation</category><body package="Seaside-Core">evaluateWithFieldValues: anOrderedCollection	self evaluateWithArgument: (anOrderedCollection collect: [ :each |		self valueForField: each ])</body></methods><methods><class-id>Seaside.WAMetaElement</class-id> <category>attributes</category><body package="Seaside-Core">charset: aString	"The charset attribute specifies the character encoding used by the document. This is a character encoding declaration. If the attribute is present in an XML document, its value must be an ASCII case-insensitive match for the string 'UTF-8' (and the document is therefore forced to use UTF-8 as its encoding).The charset attribute on the meta element has no effect in XML documents, and is only allowed in order to facilitate migration to and from XHTML.There must not be more than one meta element with a charset attribute per document."		self attributes at: 'charset' put: aString</body><body package="Seaside-Core">content: aString	self attributeAt: 'content' put: aString</body><body package="Seaside-Core">language: aString	self attributeAt: 'lang' put: aString</body><body package="Seaside-Core">name: aString	self attributeAt: 'name' put: aString</body><body package="Seaside-Core">responseHeaderName: aString	self attributeAt: 'http-equiv' put: aString</body><body package="Seaside-Core">scheme: aString	self attributeAt: 'scheme' put: aString</body><body package="Seaside-Core">textDirection: aString	self attributeAt: 'dir' put: aString</body></methods><methods><class-id>Seaside.WAMetaElement</class-id> <category>convenience</category><body package="Seaside-Core">beLeftToRight	self textDirection: 'LTR'</body><body package="Seaside-Core">beRightToLeft	self textDirection: 'RTL'</body><body package="Seaside-Core">contentScriptType: aMimeTypeOrString	self responseHeaderName: 'Content-Script-Type'.	self content: aMimeTypeOrString</body><body package="Seaside-Core">contentType: aMimeTypeOrString	self responseHeaderName: 'Content-Type'.	self content: aMimeTypeOrString</body><body package="Seaside-Core">redirectAfter: seconds to: aString 	self responseHeaderName: 'refresh'.	self content: seconds greaseString , ';URL=' , aString</body></methods><methods><class-id>Seaside.WAMetaElement</class-id> <category>accessing</category><body package="Seaside-Core">tag	^ 'meta'</body></methods><methods><class-id>Seaside.WACancelActionCallback</class-id> <category>accessing</category><body package="Seaside-Core">priority	^ -5</body></methods><methods><class-id>Seaside.WADefaultActionCallback</class-id> <category>accessing</category><body package="Seaside-Core">priority	^ 10</body></methods><methods><class-id>Seaside.WAUnidirectionalCache</class-id> <category>private</category><body package="Seaside-Core">errorAlreadyMapped	self error: 'Already mapped'</body></methods><methods><class-id>Seaside.WAUnidirectionalCache</class-id> <category>accessing</category><body package="Seaside-Core">at: aKey ifAbsent: aBlock	^ dictionary at: aKey ifAbsent: aBlock</body><body package="Seaside-Core">keyAtValue: anObject ifAbsent: aBlock	self shouldNotImplement</body><body package="Seaside-Core">size	^ dictionary size</body></methods><methods><class-id>Seaside.WAUnidirectionalCache</class-id> <category>initialization</category><body package="Seaside-Core">initialize	super initialize.	dictionary := Dictionary new</body></methods><methods><class-id>Seaside.WAUnidirectionalCache</class-id> <category>copying</category><body package="Seaside-Core">postCopy	super postCopy.	dictionary := dictionary copy</body></methods><methods><class-id>Seaside.WAUnidirectionalCache</class-id> <category>public</category><body package="Seaside-Core">clear	dictionary removeAll</body></methods><methods><class-id>Seaside.WAUnidirectionalCache</class-id> <category>putting</category><body package="Seaside-Core">at: aKey put: anObject	^ dictionary at: aKey put: anObject</body><body package="Seaside-Core">store: anObject	| candidateKey |	[ 		| written |		written := false.		candidateKey := WAKeyGenerator current keyOfLength: self keySize.		dictionary at: candidateKey ifAbsentPut: [ written := true. anObject ].		written ] whileFalse.	^ candidateKey</body></methods><methods><class-id>Seaside.WAUnidirectionalCache</class-id> <category>removing</category><body package="Seaside-Core">remove: anObject	self shouldNotImplement</body></methods><methods><class-id>Seaside.WAUnidirectionalCache</class-id> <category>enumerating</category><body package="Seaside-Core">keysAndValuesDo: aTwoArgumentBlock	dictionary keysAndValuesDo: aTwoArgumentBlock</body></methods><methods><class-id>Seaside.WAExceptionFilter</class-id> <category>configuration</category><body package="Seaside-Core">defaultConfiguration	^ WAUserConfiguration new		addParent: WAExceptionFilterConfiguration instance;		yourself</body><body package="Seaside-Core">exceptionHandler	^ self configuration at: #exceptionHandler</body></methods><methods><class-id>Seaside.WAExceptionFilter</class-id> <category>testing</category><body package="Seaside-Core">isExceptionFilter	^ true</body></methods><methods><class-id>Seaside.WAExceptionFilter</class-id> <category>processing</category><body package="Seaside-Core">handleFiltered: aRequestContext	| handler |	handler := self exceptionHandler context: aRequestContext.	handler handleExceptionsDuring: [		WACurrentExceptionHandler			use: handler			during: [ super handleFiltered: aRequestContext ] ]</body></methods><methods><class-id>Seaside.WARevealedConditionalComment</class-id> <category>private</category><body package="Seaside-Core">closingConditionClass	^ WAClosingRevealedConditionalComment</body><body package="Seaside-Core">openingConditionClass	^ WAOpeningRevealedConditionalComment</body></methods><methods><class-id>Seaside.WAAttribute</class-id> <category>accessing</category><body package="Seaside-Core">comment	"Answer a comment or help text of the receiving attribute."	^ comment</body><body package="Seaside-Core">comment: aString	comment := aString</body><body package="Seaside-Core">default	"Answer a default value for the receiving attribute."	^ default</body><body package="Seaside-Core">default: anObject	default := anObject</body><body package="Seaside-Core">group	"Answer the group of the receiving attribute."		^ group ifNil: [ #general ]</body><body package="Seaside-Core">group: aSymbol	group := aSymbol</body><body package="Seaside-Core">label	"Answer the label of the receiving attribute."	^ label ifNil: [ self labelForSelector: self key ]</body><body package="Seaside-Core">label: aString	label := aString</body></methods><methods><class-id>Seaside.WAAttribute</class-id> <category>converting</category><body package="Seaside-Core">stringForValue: anObject 	^ anObject isNil ifFalse: [ anObject greaseString ]</body><body package="Seaside-Core">valueFromString: aString	self subclassResponsibility</body></methods><methods><class-id>Seaside.WAAttribute</class-id> <category>testing</category><body package="Seaside-Core">isAdvanced	"Answer whether this is an advanced option and should be hidden by default in the configuration editor so as not to overwhelm new users."	^ advanced</body><body package="Seaside-Core">isCollectionAttribute	^ false</body></methods><methods><class-id>Seaside.WAAttribute</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithKey: aSymbol	super initializeWithKey: aSymbol.	advanced := false</body></methods><methods><class-id>Seaside.WAAttribute</class-id> <category>visiting</category><body package="Seaside-Core">accept: aVisitor	aVisitor visitAttribute: self</body></methods><methods><class-id>Seaside.WAAttribute</class-id> <category>actions</category><body package="Seaside-Core">beAdvanced	advanced := true</body></methods><methods><class-id>Seaside.WAAttribute</class-id> <category>printing</category><body package="Seaside-Core">printOn: aStream 	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self key greaseString;		nextPut: $)</body></methods><methods><class-id>Seaside.WAListAttribute</class-id> <category>accessing</category><body package="Seaside-Core">options	^ optionsBlock isNil		ifTrue: [ #() ]		ifFalse: [ optionsBlock value ]</body><body package="Seaside-Core">options: aBlock	optionsBlock := aBlock</body></methods><methods><class-id>Seaside.WAListAttribute</class-id> <category>visiting</category><body package="Seaside-Core">accept: aVisitor	aVisitor visitListAttribute: self</body></methods><methods><class-id>Seaside.WAListAttribute</class-id> <category>converting</category><body package="Seaside-Core">valueFromString: aString 	self error: 'List attributes cannot be converted from Strings'</body></methods><methods><class-id>Seaside.WACollectionAttribute</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithKey: aSymbol	super initializeWithKey: aSymbol.	self default: #()</body></methods><methods><class-id>Seaside.WACollectionAttribute</class-id> <category>accessing</category><body package="Seaside-Core">default: aCollection	super default: (Array withAll: aCollection)</body></methods><methods><class-id>Seaside.WACollectionAttribute</class-id> <category>visiting</category><body package="Seaside-Core">accept: aVisitor	aVisitor visitCollectionAttribute: self</body></methods><methods><class-id>Seaside.WACollectionAttribute</class-id> <category>testing</category><body package="Seaside-Core">isCollectionAttribute	^ true</body></methods><methods><class-id>Seaside.WAUnhandledNotificationError</class-id> <category>accessing</category><body package="Seaside-Core">notification	^ notification</body><body package="Seaside-Core">notification: aNotification	notification := aNotification</body></methods><methods><class-id>Seaside.WAUnhandledNotificationError class</class-id> <category>signaling</category><body package="Seaside-Core">signalWithNotification: aNotification	^ self new		notification: aNotification;		signal</body></methods><methods><class-id>Seaside.WAAttributeExpression</class-id> <category>values</category><body package="Seaside-Core">determineValueWithContext: aContext configuration: aConfiguration	self subclassResponsibility</body></methods><methods><class-id>Seaside.WAValueExpression</class-id> <category>accessing</category><body package="Seaside-Core">value	^ value</body><body package="Seaside-Core">value: anObject	value := anObject</body></methods><methods><class-id>Seaside.WAValueExpression</class-id> <category>values</category><body package="Seaside-Core">determineValueWithContext: aContext configuration: aConfiguration	^ self value</body></methods><methods><class-id>Seaside.WAPainterVisitor</class-id> <category>copying</category><body package="Seaside-Core">copyForRenderContext: aRenderContext 	"Return a copy, making sure that references to a RenderContext are replaced	with aRenderContext."		^ self copy		postCopyForRenderContext: aRenderContext;		yourself</body><body package="Seaside-Core">postCopyForRenderContext: aRenderContext	"self is a shallow copy. Subclasses should copy fields as necessary to complete	the full copy and ensure that all references to the old RenderContext are replaced	with aRenderContext. Note that #postCopy is also called prior to this method being called."</body></methods><methods><class-id>Seaside.WAPainterVisitor</class-id> <category>visiting</category><body package="Seaside-Core">visitPainter: aPainter</body></methods><methods><class-id>Seaside.WASystemConfiguration</class-id> <category>private</category><body package="Seaside-Core">attributes	^ self description attributes</body><body package="Seaside-Core">description	^ description isNil 		ifFalse: [ description ]		ifTrue: [ self buildDescription ]</body></methods><methods><class-id>Seaside.WASystemConfiguration</class-id> <category>attributes</category><body package="Seaside-Core">localAttributeAt: aSymbol ifAbsent: absentBlock	^ self attributes at: aSymbol ifAbsent: absentBlock</body><body package="Seaside-Core">localAttributesDo: aBlock	self attributes do: aBlock</body></methods><methods><class-id>Seaside.WASystemConfiguration</class-id> <category>description</category><body package="Seaside-Core">buildDescription	| d |	d := WAConfigurationDescription new.	self describeOn: d.	^ description := d</body><body package="Seaside-Core">clearDescription	description := nil.	self clearSearchContexts</body><body package="Seaside-Core">describeOn: conf	"Should be implemented by subclasses to add attributes and value overrides to the configuration"</body></methods><methods><class-id>Seaside.WASystemConfiguration</class-id> <category>copying</category><body package="Seaside-Core">copy	^ self error: 'SystemConfigurations are singletons and should not be copied.'</body></methods><methods><class-id>Seaside.WASystemConfiguration</class-id> <category>values</category><body package="Seaside-Core">expressionAt: aSymbol ifAbsent: absentBlock	^ self description expressions at: aSymbol ifAbsent: absentBlock</body></methods><methods><class-id>Seaside.WASystemConfiguration class</class-id> <category>actions</category><body package="Seaside-Core">clearAllDescriptions	self allSubclasses do: [ :each | each instance clearDescription ]</body></methods><methods><class-id>Seaside.WASystemConfiguration class</class-id> <category>accessing</category><body package="Seaside-Core">instance	^ instance ifNil: [ instance := self basicNew initialize ]</body></methods><methods><class-id>Seaside.WASystemConfiguration class</class-id> <category>instance creation</category><body package="Seaside-Core">new	^ self error: 'SystemConfigurations are singletons. Use #instance.'</body></methods><methods><class-id>Seaside.WASystemConfiguration class</class-id> <category>class initialization</category><body package="Seaside-Core">initialize	"Work around for Issue 643	http://code.google.com/p/seaside/issues/detail?id=643"	self clearAllDescriptions</body></methods><methods><class-id>Seaside.WAFileHandlerConfiguration</class-id> <category>ancestry</category><body package="Seaside-Core">parents	^ Array with: WARequestHandlingConfiguration instance</body></methods><methods><class-id>Seaside.WAFileHandlerConfiguration</class-id> <category>description</category><body package="Seaside-Core">describeOn: config	(config list: #fileHandlerListingClass)		beAdvanced;		options: [ self listingClasses ];		default: WAForbiddenFileHandlerListing.	(config url: #resourceBaseUrl)		group: #server;		comment: 'Sets the base URL for generated URLs.'.	(config boolean: #useXSendfile)		beAdvanced;		group: #server;		comment: 'Sets whether to use the X-Sendfile header to stream file library contents.';		default: false.	(config string: #xSendfileBaseDirectory)		beAdvanced;		group: #server;		comment: 'The directory in which the deployed file libraries are.'</body><body package="Seaside-Core">listingClasses	^ WAFileHandlerListing allSubclasses asSortedCollection: [ :a :b | a name &lt;= b name ]</body></methods><methods><class-id>Seaside.WABooleanAttribute</class-id> <category>visiting</category><body package="Seaside-Core">accept: aVisitor	aVisitor visitBooleanAttribute: self</body></methods><methods><class-id>Seaside.WABooleanAttribute</class-id> <category>converting</category><body package="Seaside-Core">valueFromString: aString	^ aString = 'true'		ifTrue: [ true ]		ifFalse: [			aString = 'false'				 ifTrue: [ false ]				 ifFalse: [ WAConfigurationError signal: 'Invalid value for boolean attribute' ] ]</body></methods><methods><class-id>Seaside.WADocumentHandler</class-id> <category>initialization</category><body package="Seaside-Core">initializeOn: aDocument	self initialize.	document := aDocument</body></methods><methods><class-id>Seaside.WADocumentHandler</class-id> <category>accessing</category><body package="Seaside-Core">document	^ document</body></methods><methods><class-id>Seaside.WADocumentHandler</class-id> <category>comparing</category><body package="Seaside-Core">= anObject	^ self species = anObject species and: [ self document = anObject document ]</body><body package="Seaside-Core">hash	^ self document hash</body></methods><methods><class-id>Seaside.WADocumentHandler</class-id> <category>copying</category><body package="Seaside-Core">postCopy	super postCopy.	document := document copy</body></methods><methods><class-id>Seaside.WADocumentHandler</class-id> <category>handling</category><body package="Seaside-Core">handleFiltered: aRequestContext	aRequestContext respond: [ :response |		response			cacheForever;			document: self document ]</body></methods><methods><class-id>Seaside.WADocumentHandler class</class-id> <category>instance creation</category><body package="Seaside-Core">document: anObject	^ self basicNew initializeOn: anObject seasideMimeDocument; yourself</body><body package="Seaside-Core">document: anObject mimeType: aMimeType	^ self document: anObject mimeType: aMimeType fileName: nil</body><body package="Seaside-Core">document: anObject mimeType: aMimeType fileName: aString	| document |	document := aMimeType isNil		ifTrue: [ anObject seasideMimeDocument ]		ifFalse: [ anObject seasideMimeDocumentType: aMimeType ].	aString isNil		ifFalse: [ document fileName: aString ].	^ self document: document</body></methods><methods><class-id>Seaside.WAUrlAttribute</class-id> <category>converting</category><body package="Seaside-Core">valueFromString: aString	^ aString isEmptyOrNil ifFalse: [ WAUrl absolute: aString ]</body></methods><methods><class-id>Seaside.WAUrlAttribute</class-id> <category>visiting</category><body package="Seaside-Core">accept: aVisitor	aVisitor visitUrlAttribute: self</body></methods><methods><class-id>Seaside.WAAcceptCharset class</class-id> <category>private</category><body package="Seaside-Core">valueClass	^ String</body></methods><methods><class-id>Seaside.WAPathConsumer</class-id> <category>accessing</category><body package="Seaside-Core">atEnd	"Answer whether there are any unconsumed path elements left."	^ path isEmpty</body><body package="Seaside-Core">next	"Remove the first unconsumed path element and answer it."	^ path removeFirst</body><body package="Seaside-Core">nextIfPresentDo: aOneArgumentBlock	"Evaluate the given block with #next if not #atEnd."	self atEnd		ifFalse: [ aOneArgumentBlock value: self next ]</body><body package="Seaside-Core">peek	"Answer the first unconsumed path element without removing it."	^ path first</body><body package="Seaside-Core">peekToEnd	"answer the remaining elements in my path without consuming them"	^ Array withAll: path</body><body package="Seaside-Core">try: aString	"See if the next element in the stream matches aString.	If it does, consume the element and return true.	If it does not or we are at the end of the stream, simply return false."	(self atEnd or: [ self peek ~= aString ])		ifTrue: [ ^ false ].	self next.	^ true</body><body package="Seaside-Core">upToEnd	"answer the remaining elements in my path"	| elements |	elements := path.	path := #().	^ elements</body></methods><methods><class-id>Seaside.WAPathConsumer</class-id> <category>initialization</category><body package="Seaside-Core">initializeWith: aCollectionOfStrings	self initialize.	path := aCollectionOfStrings</body></methods><methods><class-id>Seaside.WAPathConsumer class</class-id> <category>instance creation</category><body package="Seaside-Core">path: aCollectionOfStrings	^ self basicNew initializeWith: aCollectionOfStrings</body></methods><methods><class-id>Seaside.WAPasswordAttribute</class-id> <category>visiting</category><body package="Seaside-Core">accept: aVisitor	aVisitor visitPasswordAttribute: self</body></methods><methods><class-id>Seaside.WAPasswordAttribute</class-id> <category>converting</category><body package="Seaside-Core">valueFromString: aString 	^ aString isEmptyOrNil ifFalse: [ GRPlatform current secureHashFor: aString ]</body></methods><methods><class-id>Seaside.WAClassListAttribute</class-id> <category>converting</category><body package="Seaside-Core">stringForValue: aClass 	^ aClass isNil ifFalse: [ aClass name greaseString ]</body></methods><methods><class-id>Seaside.WAClassListAttribute</class-id> <category>visiting</category><body package="Seaside-Core">accept: aVisitor	aVisitor visitClassListAttribute: self</body></methods><methods><class-id>Seaside.WACacheListEntry</class-id> <category>accessing</category><body package="Seaside-Core">cacheEntry	^ cacheEntry</body><body package="Seaside-Core">next	^ next</body><body package="Seaside-Core">next: aCacheListEntry	next := aCacheListEntry</body><body package="Seaside-Core">previous	^ previous</body><body package="Seaside-Core">previous: aCacheListEntry	previous := aCacheListEntry</body><body package="Seaside-Core">time	^ time</body></methods><methods><class-id>Seaside.WACacheListEntry</class-id> <category>operations</category><body package="Seaside-Core">expunge	next isNil ifFalse: [		next previous: previous ].	previous isNil ifFalse: [		previous next: next ].	next := nil.	previous := nil</body><body package="Seaside-Core">initializeTime	time := Time totalSeconds</body></methods><methods><class-id>Seaside.WACacheListEntry</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithEntry: aCacheEntry	self initialize.	cacheEntry := aCacheEntry.	self initializeTime</body></methods><methods><class-id>Seaside.WACacheListEntry class</class-id> <category>instance creation</category><body package="Seaside-Core">entry: aCacheEntry	^ self basicNew		initializeWithEntry: aCacheEntry;		yourself</body></methods><methods><class-id>Seaside.WAAttributeSearchContext</class-id> <category>accessing</category><body package="Seaside-Core">at: aConfiguration ifPresent: aBlock	^ self cachedValues at: aConfiguration ifPresent: aBlock</body><body package="Seaside-Core">at: aConfiguration put: cachedObject	^ self cachedValues at: aConfiguration put: cachedObject</body><body package="Seaside-Core">attribute	^ attribute</body><body package="Seaside-Core">key	^ key</body></methods><methods><class-id>Seaside.WAAttributeSearchContext</class-id> <category>testing</category><body package="Seaside-Core">isAttributeFoundOn: aConfiguration 	^ (self isAttributeLocalOn: aConfiguration) or: [ self isAttributeInheritedOn: aConfiguration ]</body><body package="Seaside-Core">isAttributeInheritedOn: aConfiguration 	^ attributeInheritors includes: aConfiguration</body><body package="Seaside-Core">isAttributeLocalOn: aConfiguration 	^ attributeHolders includes: aConfiguration</body></methods><methods><class-id>Seaside.WAAttributeSearchContext</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithKey: keySymbol	self initialize.	key := keySymbol.	attributeHolders := Set new.	attributeInheritors := Set new.	cachedValues := Dictionary new</body></methods><methods><class-id>Seaside.WAAttributeSearchContext</class-id> <category>private</category><body package="Seaside-Core">cachedValues	^ cachedValues</body><body package="Seaside-Core">findAttributeAndSelectAncestorsOf: aConfiguration	| found |	(attributeHolders includes: aConfiguration) ifTrue: [ ^ true ].				aConfiguration localAttributeAt: self key ifPresent: [ :attr |		attribute := attr.		attributeHolders add: aConfiguration.		^ true ].			found := false.	aConfiguration parents do: [ :each |		found := found | (self findAttributeAndSelectAncestorsOf: each) ].		found ifTrue: [ attributeInheritors add: aConfiguration ].		^ found</body></methods><methods><class-id>Seaside.WAAttributeSearchContext class</class-id> <category>instance creation</category><body package="Seaside-Core">key: keySymbol target: targetConfiguration	^ self basicNew		initializeWithKey: keySymbol;		findAttributeAndSelectAncestorsOf: targetConfiguration;		yourself</body></methods><methods><class-id>Seaside.WAAddRemoveExpression</class-id> <category>accessing</category><body package="Seaside-Core">additions	^ additions</body><body package="Seaside-Core">additions: aCollection	additions := aCollection</body><body package="Seaside-Core">removals	^ removals</body><body package="Seaside-Core">removals: anObject	removals := anObject</body></methods><methods><class-id>Seaside.WAAddRemoveExpression</class-id> <category>values</category><body package="Seaside-Core">determineValueWithContext: aContext configuration: aConfiguration	| collection result |	collection := aConfiguration inheritedValueForContext: aContext.		collection isNil ifTrue: [ collection := aContext attribute default ].	collection isNil ifTrue: [ collection := Array new ].		result := OrderedCollection withAll: collection.	result := result reject: [ :each |		(self additions includes: each)			or: [ self removals includes: each ] ].	result addAll: self additions.		^ result asArray</body></methods><methods><class-id>Seaside.WATextFileHandlerListing</class-id> <category>responding</category><body package="Seaside-Core">responseForLibraries	context respond: [ :response |		response contentType: WAMimeType textPlain.		handler libraries do: [ :each |			response stream				nextPutAll: each name;				crlf ] ]</body><body package="Seaside-Core">responseForLibrary: aLibrary	context respond: [ :response |		response contentType: WAMimeType textPlain.		aLibrary fileSelectors do: [ :each |			response stream				nextPutAll: (aLibrary asFilename: each);				crlf ] ]</body></methods><methods><class-id>Seaside.WAMapCallback</class-id> <category>converting</category><body package="Seaside-Core">valueForField: anObject 	| stream x y |	stream := (super valueForField: anObject) readStream.	(stream atEnd not and: [ stream next = $? ]) ifFalse: [ ^ nil ].	x := (stream upTo: $,) greaseInteger.	(x isNil or: [ stream atEnd ]) ifTrue: [ ^ nil ].	y := stream upToEnd greaseInteger.	y isNil ifTrue: [ ^ nil ].	^ x @ y</body></methods><methods><class-id>Seaside.WAAcceptLanguage class</class-id> <category>private</category><body package="Seaside-Core">valueClass	^ WALocale</body></methods><methods><class-id>Seaside.WAContentElement</class-id> <category>attributes</category><body package="Seaside-Core">charset: aString	self attributeAt: 'charset' put: aString</body><body package="Seaside-Core">contents: aString	self document: aString</body><body package="Seaside-Core">resourceUrl: aString	self url: (root absoluteUrlForResource: aString)</body><body package="Seaside-Core">type: aMimeTypeOrString	self attributeAt: 'type' put: aMimeTypeOrString</body><body package="Seaside-Core">url: aString	self subclassResponsibility</body></methods><methods><class-id>Seaside.WAContentElement</class-id> <category>testing</category><body package="Seaside-Core">isClosed	^ false</body></methods><methods><class-id>Seaside.WAContentElement</class-id> <category>private</category><body package="Seaside-Core">typeOrNil	^ self attributeAt: 'type' ifAbsent:  [ nil ]</body></methods><methods><class-id>Seaside.WAContentElement</class-id> <category>printing</category><body package="Seaside-Core">encodeChildrenOn: aDocument 	children isEmptyOrNil ifTrue: [ ^ self ].	children do: [ :each | aDocument nextPutAll: each greaseString ]</body></methods><methods><class-id>Seaside.WALinkElement</class-id> <category>attributes</category><body package="Seaside-Core">media: aString	"This attribute specifies the intended destination medium for style information. It may be a single media descriptor or a comma-separated list. The default value for this attribute is 'screen'."	self attributeAt: 'media' put: aString</body><body package="Seaside-Core">relationship: aString	"This attribute describes the relationship from the current document to the anchor specified by the href attribute. The value of this attribute is a space-separated list of link types."		self attributes at: 'rel' append: aString</body><body package="Seaside-Core">reverse: aString	"This attribute is used to describe a reverse link from the anchor specified by the href attribute to the current document. The value of this attribute is a space-separated list of link types."	self attributeAt: 'rev' put: aString</body><body package="Seaside-Core">title: aString	self attributeAt: 'title' put: aString</body><body package="Seaside-Core">url: aString	self attributeAt: 'href' put: aString</body></methods><methods><class-id>Seaside.WALinkElement</class-id> <category>relationship</category><body package="Seaside-Core">beAlternate	"Gives alternate representations of the current document."	self relationship: 'alternate'</body><body package="Seaside-Core">beAlternateStylesheet	self relationship: 'alternate stylesheet'</body><body package="Seaside-Core">beAppendix	self relationship: 'appendix'</body><body package="Seaside-Core">beArchives	"Provides a link to a collection of records, documents, or other materials of historical interest."	self relationship: 'archives'</body><body package="Seaside-Core">beAuthor	"Gives a link to the current document's author."	self relationship: 'author'</body><body package="Seaside-Core">beBookmark	self relationship: 'bookmark'</body><body package="Seaside-Core">beCanonical	"Used to specify a canonical URL."	self relationship: 'canonical'</body><body package="Seaside-Core">beChapter	self relationship: 'chapter'</body><body package="Seaside-Core">beClossary	self relationship: 'lossary'</body><body package="Seaside-Core">beCopyright	self relationship: 'copyright'</body><body package="Seaside-Core">beFirst	"Indicates that the current document is a part of a series, and that the first document in the series is the referenced document."	self relationship: 'first'</body><body package="Seaside-Core">beFontDefinition	self relationship: 'fontdef'</body><body package="Seaside-Core">beGlossary	self relationship: 'glossary'</body><body package="Seaside-Core">beHelp	self relationship: 'help'</body><body package="Seaside-Core">beIndex	self relationship: 'index'</body><body package="Seaside-Core">beLast	self relationship: 'last'</body><body package="Seaside-Core">beMicrosummary	"http://wiki.mozilla.org/Microsummaries"	self relationship: 'microsummary'</body><body package="Seaside-Core">beNext	"Indicates that the current document is a part of a series, and that the next document in the series is the referenced document."	self relationship: 'next'</body><body package="Seaside-Core">bePrevious	"Indicates that the current document is a part of a series, and that the previous document in the series is the referenced document."	self relationship: 'previous'</body><body package="Seaside-Core">beSearch	"Gives a link to a resource that can be used to search through the current document and its related pages. "	self relationship: 'search'</body><body package="Seaside-Core">beSection	self relationship: 'section'</body><body package="Seaside-Core">beShortcutIcon	self relationship: 'shortcut icon'</body><body package="Seaside-Core">beStart	"Refers to the first document in a collection of documents. This link type tells search engines which document is considered by the author to be the starting point of the collection."	self relationship: 'start'</body><body package="Seaside-Core">beStylesheet	"Imports a stylesheet."	self relationship: 'stylesheet'</body><body package="Seaside-Core">beSubsection	self relationship: 'subsection'</body><body package="Seaside-Core">beTableOfContents	self relationship: 'contents'</body><body package="Seaside-Core">beTop	self relationship: 'top'</body><body package="Seaside-Core">beUp	"Provides a link to a document giving the context for the current document."	self relationship: 'up'</body></methods><methods><class-id>Seaside.WALinkElement</class-id> <category>type</category><body package="Seaside-Core">beAtom	self type: 'application/atom+xml' seasideMimeType</body><body package="Seaside-Core">beCss	self type: WAMimeType textCss</body><body package="Seaside-Core">beRss	self type: 'application/rss+xml' seasideMimeType</body></methods><methods><class-id>Seaside.WALinkElement</class-id> <category>media</category><body package="Seaside-Core">addAll	self addMedia: 'all'</body><body package="Seaside-Core">addAural	self addMedia: 'aural'</body><body package="Seaside-Core">addBraille	self addMedia: 'braille'</body><body package="Seaside-Core">addHandheld	self addMedia: 'handheld'</body><body package="Seaside-Core">addMedia: aString	self attributes addMedia: aString</body><body package="Seaside-Core">addPrint	self addMedia: 'print'</body><body package="Seaside-Core">addProjection	self addMedia: 'projection'</body><body package="Seaside-Core">addScreen	self addMedia: 'screen'</body><body package="Seaside-Core">addTeletype	self addMedia: 'tty'</body><body package="Seaside-Core">addTelevision	self addMedia: 'tv'</body></methods><methods><class-id>Seaside.WALinkElement</class-id> <category>accessing</category><body package="Seaside-Core">tag	^ children isEmptyOrNil		ifTrue: [ 'link' ]		ifFalse: [ 'style' ]</body></methods><methods><class-id>Seaside.WALinkElement</class-id> <category>testing</category><body package="Seaside-Core">isClosed	^ children isEmptyOrNil</body></methods><methods><class-id>Seaside.WALinkElement</class-id> <category>accessing-children</category><body package="Seaside-Core">add: anElement	super add: anElement.	attributes isNil ifFalse: [		attributes removeKey: 'rel' ifAbsent: [ "ignore" ] ]</body></methods><methods><class-id>Seaside.WAAuthConfiguration</class-id> <category>description</category><body package="Seaside-Core">describeOn: config	(config string: #login)		group: #authentication;		comment: 'The username for this application.'.	(config password: #passwordHash)		group: #authentication;		comment: 'The password for this application.';		label: 'Password'</body></methods><methods><class-id>Seaside.WAFileMetadataLibrary</class-id> <category>private</category><body package="Seaside-Core">asFileAndFoldername: aSelector	| foldername filename pathSeparator |	pathSeparator := GRPlatform current pathSeparator.	filename := (self fileResourceOf: aSelector) filepath.	filename := filename replaceAll: $/ with: pathSeparator first.	foldername := (filename includes: $/)		ifTrue: [ self name , pathSeparator, (filename copyUpToLast: pathSeparator first) ]		ifFalse: [ self name ].	^ Array with: foldername with: (GRPlatform current localNameOf: filename)</body><body package="Seaside-Core">asFilename: aSelector	^ (self fileResourceOf: aSelector) filepath</body><body package="Seaside-Core">fileResourceOf: aSelector	^ (self respondsTo: aSelector)		ifTrue: [ self perform: aSelector ]		ifFalse: [ WAFileLibraryResource emptyInstance ]</body><body package="Seaside-Core">fileSelectors	"deliberately name WAFileMetadataLibrary rather than self class"	^ self fileSelectorsTo: WAFileMetadataLibrary</body><body package="Seaside-Core">isFileSelector: aSymbol	| isContentMethod |		isContentMethod := aSymbol endsWithSubCollection: #Content.	^ isContentMethod not  and:  [ super isFileSelector: aSymbol ]</body></methods><methods><class-id>Seaside.WAFileMetadataLibrary</class-id> <category>accessing</category><body package="Seaside-Core">fileSizeOf: aSelector	^ (self fileResourceOf: aSelector) contents value size</body><body package="Seaside-Core">mimetypeOf: aSelector	^ (self fileResourceOf: aSelector) mimeType</body></methods><methods><class-id>Seaside.WAFileMetadataLibrary</class-id> <category>handling</category><body package="Seaside-Core">handle: aRequestContext	| filepath selector fileHandler fileResource |	filepath := String streamContents: [ :stream | 		aRequestContext consumer upToEnd			do: [ :each | 				stream nextPutAll: each ] 			separatedBy: [ stream nextPutAll: GRPlatform current pathSeparator ] ].			selector := self asSelector: filepath.	(self fileSelectors includes: selector) 		ifFalse: [ ^ self ].		fileResource := self fileResourceOf: selector.	fileHandler := aRequestContext handler.	fileHandler useXSendfile		ifTrue: [			aRequestContext respond: [ :response |				response					cacheFor: fileResource cacheDuration;					headerAt: 'X-Sendfile' put: (self fullPathForFileName: filepath using: fileHandler);					contentType: fileResource mimeType ] ]		ifFalse: [			aRequestContext respond: [ :response |				response					cacheFor: fileResource cacheDuration;					document: fileResource contents value					mimeType: fileResource mimeType ] ]</body></methods><methods><class-id>Seaside.WAFileMetadataLibrary</class-id> <category>actions</category><body package="Seaside-Core">deployFiles	"Write to disk the files that the receiver use to serve as methods.	The files are stored in a subfolder named like the classname of the receiver in a subfolder of Smalltalk image folder."		GRPlatform current ensureExistenceOfFolder: self name.	self fileSelectors do: [ :each | 		| folderInfo |		folderInfo := self asFileAndFoldername: each. 		GRPlatform current ensureExistenceOfFolder: folderInfo first.		GRPlatform current 			write: (self fileResourceOf: each) contents value			toFile: folderInfo second			inFolder: folderInfo first ]</body></methods><methods><class-id>Seaside.WAFileMetadataLibrary class</class-id> <category>file addition</category><body package="Seaside-Core">addFileNamed: filename contents: aByteArrayOrString	| selector mimeType code contentSelector |	selector := self asSelector: filename.	contentSelector := selector, 'Content'.	mimeType := self mimetypeFor: (filename copyAfterLast: $.).		code := String streamContents: [ :stream |		stream			nextPutAll: selector; nextPut: Character cr;			nextPut: Character tab; nextPutAll: '^ WAFileLibraryResource'; nextPut: Character cr; 			nextPut: Character tab; nextPut: Character tab; nextPutAll: 'filepath: '''; nextPutAll: filename; nextPutAll: ''''; nextPut: Character cr;			nextPut: Character tab; nextPut: Character tab; nextPutAll: 'mimeType: (WAMimeType main: '''; nextPutAll: mimeType main; nextPutAll: ''' sub: '''; nextPutAll: mimeType sub; nextPutAll: ''')'; nextPut: Character cr;			nextPut: Character tab; nextPut: Character tab; nextPutAll: 'cacheDuration: (Duration days: 0 hours: 0 minutes: 30 seconds: 0)'; nextPut: Character cr;			nextPut: Character tab; nextPut: Character tab;  nextPutAll: 'contents: (GRDelayedSend receiver: self selector: #'; nextPutAll: contentSelector; nextPutAll: ')' ].			GRPlatform current 		compile: code		into: self		classified: self methodCategory, ' metadata'.			(self isBinary: filename)		ifTrue: [ self compileBinary: aByteArrayOrString selector: contentSelector ]		ifFalse: [ self compileText: aByteArrayOrString selector: contentSelector ]</body><body package="Seaside-Core">recursivelyAddAllFilesIn: aPathString 	"adds all files in the directory specified by aPathString to the current file library - 	*does* recurse into sub-directories"	| isAbsolutePath rootPath |	isAbsolutePath := (aPathString first = GRPlatform current pathSeparator first).	rootPath := isAbsolutePath 		ifTrue: [ aPathString ]		ifFalse: [ self absolutePathFromRelative: aPathString ].			self recursivelyAddAllFilesIn: aPathString relativeToRootDirectory: rootPath</body><body package="Seaside-Core">recursivelyAddAllFilesIn: aPathString relativeToRootDirectory: relativeRootDirectory	(GRPlatform current directoriesIn: aPathString) do: [ :each | 		self recursivelyAddAllFilesIn: each relativeToRootDirectory: relativeRootDirectory ].	(GRPlatform current filesIn: aPathString) do: [ :each | 		self addFileAt: each relativeToRootDirectory: relativeRootDirectory ]</body></methods><methods><class-id>Seaside.WAFileMetadataLibrary class</class-id> <category>private</category><body package="Seaside-Core">absolutePathFromRelative: aRelativeFilePath	| allFiles absoluteFile filePart |	allFiles := GRPlatform current filesIn: aRelativeFilePath.	allFiles isEmpty ifTrue: [		allFiles := GRPlatform current directoriesIn: aRelativeFilePath ].		absoluteFile := allFiles first.	filePart := GRPlatform current localNameOf: absoluteFile.		^ absoluteFile allButLast: filePart size</body><body package="Seaside-Core">addFileAt: aPath relativeToRootDirectory: relativeRootDirectory	| relativeFilepath pathSeparator |	relativeFilepath := aPath allButFirst: relativeRootDirectory size.	pathSeparator := GRPlatform current pathSeparator.		(relativeFilepath first = pathSeparator first) 		ifTrue: [ relativeFilepath := relativeFilepath allButFirst ].			relativeFilepath := relativeFilepath replaceAll: pathSeparator first with: $/. 	self addFileNamed: relativeFilepath		contents: (GRPlatform current 				contentsOfFile: aPath				binary: (self isBinaryAt: aPath))</body></methods><methods><class-id>Seaside.WAEmailAddress</class-id> <category>private</category><body package="Seaside-Core">encodeOn: aStream usingQuotes: aBoolean	username isNil ifFalse:  [		aBoolean ifTrue: [ aStream nextPut: $" ].		aStream nextPutAll: username.		aBoolean ifTrue: [ aStream nextPut: $" ].		aStream nextPutAll: ' &lt;' ].	aStream nextPutAll: address.	username isNil ifFalse: [ aStream nextPut: $&gt; ]</body><body package="Seaside-Core">sanitize: aString	"prevents SMTP header injection"	| newlineIndex |	newlineIndex := (aString indexOf: Character cr) min: (aString indexOf: Character lf).	^ newlineIndex = 0		ifTrue: [ aString ]		ifFalse: [ aString copyFrom: 1 to: newlineIndex - 1  ]</body></methods><methods><class-id>Seaside.WAEmailAddress</class-id> <category>accessing</category><body package="Seaside-Core">address	^ address</body><body package="Seaside-Core">address: aString	address := self sanitize: aString</body><body package="Seaside-Core">username	^ username</body><body package="Seaside-Core">username: aString	username := self sanitize: aString</body></methods><methods><class-id>Seaside.WAEmailAddress</class-id> <category>printing</category><body package="Seaside-Core">printOn: aStream 	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: self greaseString.	aStream nextPut: $)</body></methods><methods><class-id>Seaside.WAEmailAddress</class-id> <category>displaying</category><body package="Seaside-Core">encodeOn: aDocument	self encodeOn: aDocument xmlEncoder usingQuotes: false</body><body package="Seaside-Core">greaseString	^ String streamContents: [ :stream | 		self 			encodeOn: stream			usingQuotes: true ]</body></methods><methods><class-id>Seaside.WAEmailAddress class</class-id> <category>instance creation</category><body package="Seaside-Core">address: aString	^ self new		address: aString;		yourself</body><body package="Seaside-Core">address: anAddressString username: aUsernameString	^ self new		address: anAddressString;		username: aUsernameString;		yourself</body></methods><methods><class-id>Seaside.WAUpdateRootVisitor</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithRoot: aRoot	self initialize.	root := aRoot</body></methods><methods><class-id>Seaside.WAUpdateRootVisitor</class-id> <category>accessing</category><body package="Seaside-Core">root	^ root</body></methods><methods><class-id>Seaside.WAUpdateRootVisitor</class-id> <category>visiting</category><body package="Seaside-Core">visitPainter: aPainter	aPainter updateRoot: self root</body></methods><methods><class-id>Seaside.WAUpdateRootVisitor class</class-id> <category>instance creation</category><body package="Seaside-Core">new	^ self root: WARoot new</body><body package="Seaside-Core">root: aRoot	^ self basicNew initializeWithRoot: aRoot; yourself</body></methods><methods><class-id>Seaside.WARequest</class-id> <category>accessing-cookies</category><body package="Seaside-Core">cookieAt: aKey	"Answer the first found cookie with the given key, there might be several cookies with the name key but different paths, in this case use #cookiesAt:."	^ self cookies		detect: [ :each | each key = aKey ]		ifNone: [ nil ]</body><body package="Seaside-Core">cookies	^ cookies ifNil: [ #() ]</body><body package="Seaside-Core">cookiesAt: aKey	"Answer all the cookies with the given key."		^ self cookies		select: [ :each | each key = aKey ]</body></methods><methods><class-id>Seaside.WARequest</class-id> <category>accessing-headers</category><body package="Seaside-Core">accept	"The Accept request-header field can be used to specify certain media types which are acceptable for the response. Accept headers can be used to indicate that the request is specifically limited to a small set of desired types, as in the case of a request for an in-line image.		Answers an OrderedCollection of WAAccept with the values in the order the client sent them."	^ WAAccept fromString: (self headerAt: 'accept' ifAbsent: [ ^ nil ])</body><body package="Seaside-Core">acceptCharset	"The Accept-Charset request-header field can be used to indicate what character sets are acceptable for the response. This field allows clients capable of understanding more comprehensive or special- purpose character sets to signal that capability to a server which is capable of representing documents in those character sets.		Answers an OrderedCollection of WAAcceptCharset with the values in the order the client sent them."	^ WAAcceptCharset fromString: (self headerAt: 'accept-charset' ifAbsent: [ ^ nil ])</body><body package="Seaside-Core">acceptEncoding	"The Accept-Encoding request-header field is similar to Accept, but restricts the content-codings (section 3.5) that are acceptable in the response.		Answers an OrderedCollection of WAAcceptEncoding with the values in the order the client sent them."	^ WAAcceptEncoding fromString: (self headerAt: 'accept-encoding' ifAbsent: [ ^ nil ])</body><body package="Seaside-Core">acceptLanguage	"The Accept-Language request-header field is similar to Accept, but restricts the set of natural languages that are preferred as a response to the request.		Answers an OrderedCollection of WAAcceptLanguage with the values in the order the client sent them."	^ WAAcceptLanguage fromString: (self headerAt: 'accept-language' ifAbsent: [ ^ nil ])</body><body package="Seaside-Core">authorization	"Answer the basic authorization string from the request. This is the username and the password separated by a colon."		| authorization |	authorization := self headerAt: 'authorization'.	^ authorization isNil ifFalse: [ self decodeAuthorization: authorization ]</body><body package="Seaside-Core">contentType	"The Content-Type entity-header field indicates the media type of the entity-body sent to the recipient or, in the case of the HEAD method, the media type that would have been sent had the request been a GET.		Answer an instance of WAMimeType or nil."		| contentType |	contentType := self headerAt: 'content-type'.	^ contentType isNil ifFalse: [ WAMimeType fromString: contentType ]</body><body package="Seaside-Core">host	^ self headerAt: 'host'</body><body package="Seaside-Core">referer	^ self headerAt: 'referer'</body><body package="Seaside-Core">userAgent	^ self headerAt: 'user-agent'</body></methods><methods><class-id>Seaside.WARequest</class-id> <category>testing</category><body package="Seaside-Core">includesKey: key	^ self fields includesKey: key</body><body package="Seaside-Core">isGet	^ self method = 'GET'</body><body package="Seaside-Core">isHttp10	^ version isHttp10</body><body package="Seaside-Core">isHttp11	^ version isHttp11</body><body package="Seaside-Core">isPost	^ self method = 'POST'</body><body package="Seaside-Core">isPrefetch	"Link prefetching is a browser mechanism, which utilizes browser idle time to download or prefetch documents that the user might visit in the near future. When the user visits one of the prefetched documents, it can be served up quickly out of the browser's cache."		^ (self headerAt: 'x-moz') = 'prefetch'</body><body package="Seaside-Core">isSsl	^ self uri isSsl</body><body package="Seaside-Core">isXmlHttpRequest	^ (self headerAt: 'x-requested-with') = 'XMLHttpRequest'</body></methods><methods><class-id>Seaside.WARequest</class-id> <category>accessing</category><body package="Seaside-Core">at: key	^ self fields at: key</body><body package="Seaside-Core">at: key ifAbsent: aBlock	^ self fields at: key ifAbsent: aBlock</body><body package="Seaside-Core">at: key ifPresent: aBlock	^ self fields at: key ifPresent: aBlock</body><body package="Seaside-Core">fields	^ WAMergedRequestFields on: (Array with: self queryFields with: self postFields)</body><body package="Seaside-Core">headerAt: aKey	^ self headerAt: aKey ifAbsent: [ nil ]</body><body package="Seaside-Core">headerAt: aKey ifAbsent: aBlock	^ headers at: aKey ifAbsent: aBlock</body><body package="Seaside-Core">headers	^ headers</body><body package="Seaside-Core">method	^ method</body><body package="Seaside-Core">password	"Answer the password from basic authentication."		| authorization |	^ (authorization := self authorization) isNil		ifFalse: [ authorization copyAfter: $: ]</body><body package="Seaside-Core">queryFields	^ self uri queryFields</body><body package="Seaside-Core">remoteAddress	"answer the IP address of the client (String)"	^ remoteAddress</body><body package="Seaside-Core">sslSessionId	"Answer the SSL session id or nil if the request wasn't made over SSL or the server adaptor does not support it (String).		See also #isSsl"	^ sslSessionId</body><body package="Seaside-Core">uri	^ uri</body><body package="Seaside-Core">url	^ self uri</body><body package="Seaside-Core">user	"Answer the username from basic authentication."		| authorization |	^ (authorization := self authorization) isNil		ifFalse: [ authorization copyUpTo: $: ]</body><body package="Seaside-Core">version	^ version</body><body package="Seaside-Core">version: aVersion	version := aVersion</body></methods><methods><class-id>Seaside.WARequest</class-id> <category>initialization</category><body package="Seaside-Core">destroy	body := method := uri := version := postFields := remoteAddress := headers := cookies := nil</body><body package="Seaside-Core">initializeWithMethod: methodString uri: aUrlOrString version: aVersion	self initialize.	method := methodString asUppercase.	uri := aUrlOrString seasideUrl.	version := aVersion.	headers := WAHeaderFields new.	postFields := WARequestFields new.	cookies := OrderedCollection new.	remoteAddress := nil</body><body package="Seaside-Core">setBody: aString	body := aString</body><body package="Seaside-Core">setCookies: cookieCollection	cookies := cookieCollection</body><body package="Seaside-Core">setHeaders: headerDictionary	headers := headerDictionary</body><body package="Seaside-Core">setPostFields: aRequestFields	postFields := aRequestFields seasideRequestFields</body><body package="Seaside-Core">setRemoteAddress: addressString	remoteAddress := addressString</body><body package="Seaside-Core">setSslSessionId: anSslSessionIdString	sslSessionId := anSslSessionIdString</body></methods><methods><class-id>Seaside.WARequest</class-id> <category>printing</category><body package="Seaside-Core">printOn: aStream 	super printOn: aStream.	aStream		nextPutAll: ' method: ';		nextPutAll: self method.	aStream		nextPutAll: ' uri: ';		nextPutAll: self uri greaseString.	aStream nextPutAll: ' version: '.	self version printOn: aStream</body></methods><methods><class-id>Seaside.WARequest</class-id> <category>accessing-body</category><body package="Seaside-Core">bodyDecodeUsing: aCharSetName 	"Answer the body decoded using the given character set name. Answer nil if there's no body."	^ body isNil ifFalse: [ (GRCodec forEncoding: aCharSetName) decode: body ]</body><body package="Seaside-Core">bodyDecoded	"Answer the body decoded using the character set in the request header. Answer nil if no body is present. Signal an error if not character set is present in the request header."	| contentType charSet |	contentType := self contentType.	charSet := contentType isNil ifFalse: [ contentType charSet ].	^ charSet isNil		ifTrue: [ WAIllegalStateException signal: 'no character set of request body can not be determined' ]		ifFalse: [ self bodyDecodeUsing: charSet ]</body><body package="Seaside-Core">postFields	^ postFields</body><body package="Seaside-Core">rawBody	"Answer the raw, undecoded body. May be nil.		Use #bodyDecoded or #bodyDecodeUsing: to access the decoded contents."	^ body</body></methods><methods><class-id>Seaside.WARequest</class-id> <category>private</category><body package="Seaside-Core">decodeAuthorization: aString	| lastSpaceIndex |	lastSpaceIndex := aString lastIndexOf: $ .	^ GRPlatform current base64Decode: (lastSpaceIndex = 0		ifTrue: [ aString ]		ifFalse: [ aString copyFrom: lastSpaceIndex + 1to: aString size ])</body></methods><methods><class-id>Seaside.WARequest class</class-id> <category>instance creation</category><body package="Seaside-Core">method: methodString uri: aUrlOrString	^ self method: methodString uri: aUrlOrString version: self defaultVersion</body><body package="Seaside-Core">method: methodString uri: aUrlOrString version: aVersion	^ self basicNew		initializeWithMethod: methodString			uri: aUrlOrString			version: aVersion;		yourself</body><body package="Seaside-Core">new	^ self		method: self defaultMethod		uri: self defaultUri		version: self defaultVersion</body></methods><methods><class-id>Seaside.WARequest class</class-id> <category>configuration</category><body package="Seaside-Core">defaultMethod	^ 'GET'</body><body package="Seaside-Core">defaultUri	^ '/' seasideUrl</body><body package="Seaside-Core">defaultVersion	^ WAHttpVersion http11</body></methods><methods><class-id>Seaside.WACacheConfiguration</class-id> <category>description</category><body package="Seaside-Core">describeOn: config	(config integer: #maximumSize)		comment: 'Number of sessions supported. When this limit is reached the overflow action is run. 0 for no maximum size. Has to be positive.';		group: #cache;		default: 10000.	(config integer: #maximumRelativeAge)		comment: 'After so many seconds of inactivity a session is considered expired. 0 for no limit. Has to be positive.';		group: #cache;		default: 1800. "30 min"	(config integer: #maximumAbsoluteAge)		comment: 'After so many seconds after its creation a session is considered expired no matter when it was last accessed. 0 for no limit. Has to be positive.';		group: #cache;		default: 28800. "8 h"	(config list: #overflowAction)		options: WAHashCache overflowActions;		comment: 'What to do when the maximum number of sessions is reached. Only matters when the maximum size is bigger than 0.';		group: #cache;		default: WAHashCache removeRelativeOldest</body></methods><methods><class-id>Seaside.WAHtmlAttributes</class-id> <category>private</category><body package="Seaside-Core">errorKeyNotFound	^ nil</body><body package="Seaside-Core">privateAt: aKey put: aValue	aValue ifNil: [ ^ nil ].	^ super privateAt: aKey put: aValue</body></methods><methods><class-id>Seaside.WAHtmlAttributes</class-id> <category>convenience</category><body package="Seaside-Core">addClass: aString	"Add an additional CSS class aString to the receiver."	self at: 'class' append: aString separator: Character space</body><body package="Seaside-Core">addMedia: aString	"Add an additional intended destination medium aString to the receiver."	self at: 'media' append: aString separator: ', '</body><body package="Seaside-Core">addStyle: aString	"Add an additional CSS style definition aString to the receiver."	self at: 'style' append: aString separator: $;</body></methods><methods><class-id>Seaside.WAHtmlAttributes</class-id> <category>encoding</category><body package="Seaside-Core">encodeOn: aDocument	"Encode the receivers attribute onto aDocument. Note that this implementation reqires those two checks for true and false exactly the way they are here, to reliable encode boolean attributes in an XHTML compliant way."	self keysAndValuesDo: [ :key :value |		value == false ifFalse: [			aDocument nextPut: Character space; nextPutAll: key; nextPutAll: '="'.			value == true				ifTrue: [ aDocument nextPutAll: key ]				ifFalse: [ aDocument print: value ].			aDocument nextPut: $" ] ]</body></methods><methods><class-id>Seaside.WAHtmlAttributes</class-id> <category>accessing</category><body package="Seaside-Core">at: aKey append: aValue	"Append aValue to the attribute aKey. If already present, concatenate it with a space. Ignore the request if aValue is nil."	self at: aKey append: aValue separator: Character space</body><body package="Seaside-Core">at: aKey append: aValue separator: aSeparator 	"Append aValue to the attribute aKey. If already present, concatenate it with aString. Ignore the request if aValue is nil.	https://code.google.com/p/seaside/issues/detail?id=816	we have to be frugal with allocation"		aValue isNil ifFalse: [		| current |		current := self at: aKey ifAbsentPut: [ aValue ].		current ~~ aValue ifTrue: [			"we couldn't store a value because there was already one"			current isConcatenatedHtmlAttributeValue				ifTrue: [ current addValue: aValue ]				ifFalse: [ self at: aKey put: (WAConcatenatedHtmlAttributeValue separator: aSeparator value: current value: aValue) ] ] ]</body></methods><methods><class-id>Seaside.WAClassBindingAttribute</class-id> <category>converting</category><body package="Seaside-Core">stringForValue: aBinding 	^ aBinding isNil ifFalse: [ aBinding value name greaseString ]</body></methods><methods><class-id>Seaside.WAClassBindingAttribute</class-id> <category>accessing</category><body package="Seaside-Core">default: aClass	default := aClass isNil		ifTrue: [ nil ]		ifFalse: [ GRPlatform current bindingOf: aClass ]</body></methods><methods><class-id>Seaside.WAClassBindingAttribute</class-id> <category>visiting</category><body package="Seaside-Core">accept: aVisitor	aVisitor visitClassBindingAttribute: self</body></methods><methods><class-id>Seaside.WAResponse</class-id> <category>convenience-accessing</category><body package="Seaside-Core">contentType	^ self headerAt: 'Content-Type' ifAbsent: [ WAMimeType textPlain ]</body><body package="Seaside-Core">contentType: aMimeType	self headerAt: 'Content-Type' put: aMimeType</body></methods><methods><class-id>Seaside.WAResponse</class-id> <category>accessing-status</category><body package="Seaside-Core">status: aNumber	"Set the status to aNumber and associate the default message."	self status: aNumber message: (self class messageForStatus: aNumber)</body><body package="Seaside-Core">status: aNumber message: aString	"Set the status to aNumber and the message to aString."		status := aNumber.	message := aString</body></methods><methods><class-id>Seaside.WAResponse</class-id> <category>writing</category><body package="Seaside-Core">writeContentOn: aStream	self subclassResponsibility</body><body package="Seaside-Core">writeCookiesOn: aStream	cookies do: [ :each | 		aStream nextPutAll: 'Set-Cookie: '.		each writeOn: aStream.		aStream crlf ]</body><body package="Seaside-Core">writeHeadersOn: aStream 	headers keysAndValuesDo: [ :key :value | 		aStream			nextPutAll: key;			nextPutAll: ': ';			nextPutAll: value greaseString;			crlf ]</body><body package="Seaside-Core">writeOn: aStream	self writeStatusOn: aStream.	self writeHeadersOn: aStream.	self writeCookiesOn: aStream.	aStream crlf.	self writeContentOn: aStream</body><body package="Seaside-Core">writeStatusOn: aStream 	aStream nextPutAll: self httpVersion.	aStream		nextPut: $ ;		nextPutAll: self status greaseString.	self message isNil ifFalse:  [		aStream			nextPut: $ ;			nextPutAll: self message ].	aStream crlf</body></methods><methods><class-id>Seaside.WAResponse</class-id> <category>accessing-headers</category><body package="Seaside-Core">headerAt: aString	"Answer the header with aString."		^ self headers at: aString</body><body package="Seaside-Core">headerAt: aString append: aValue 	"Appends a response header with aString and aValue. This method allows response headers to have multiple values."	^ self headers 		at: aString		add: aValue greaseString</body><body package="Seaside-Core">headerAt: aString ifAbsent: aBlock	"Answer the header with aString, if none answer the result of evaluating aBlock."		^ self headers at: aString ifAbsent: aBlock</body><body package="Seaside-Core">headerAt: aString put: aValue	"Set a response header with aString and aValue. If the header had already been set, the new value overwrites the previous one."		^ self headers at: aString put: aValue</body><body package="Seaside-Core">headerAt: aKeyString putDate: aDateAndTime 	"Convenience method that sets a response header with aKeyString and aDateAndTime. If the header had already been set, the new value overwrites the previous one."	^ self 		headerAt: aKeyString		put: (GRPrinter httpDate print: aDateAndTime)</body><body package="Seaside-Core">removeHeaderAt: aString	"Removes all occurences of the header value aString."	^ self headers removeKey: aString</body></methods><methods><class-id>Seaside.WAResponse</class-id> <category>documents</category><body package="Seaside-Core">document: aDocument	| document mimeType |	document := aDocument seasideMimeDocument.	self attachmentWithFileName: document fileName.	mimeType := document mimeType.	self contentType: mimeType.	mimeType isBinary		ifTrue: [ self binary ].	self nextPutAll: document content</body><body package="Seaside-Core">document: anObject mimeType: aMimeType	self document: (anObject seasideMimeDocument 		mimeType: aMimeType;		yourself)</body><body package="Seaside-Core">document: anObject mimeType: aMimeType fileName: aString	self document: (anObject seasideMimeDocument 		mimeType: aMimeType;		fileName: aString;		yourself)</body></methods><methods><class-id>Seaside.WAResponse</class-id> <category>initialization</category><body package="Seaside-Core">destroy	headers := cookies := nil</body><body package="Seaside-Core">initialize	super initialize.	self initializeFields</body><body package="Seaside-Core">initializeFields	status := 200.	message := 'OK'.	headers := WAHeaderFields new.	cookies := OrderedCollection new</body><body package="Seaside-Core">initializeOn: aStream 	self initialize</body></methods><methods><class-id>Seaside.WAResponse</class-id> <category>configuration</category><body package="Seaside-Core">cacheForeverExpiryDate	"Answer the expiry date that should be used if the response should be cached forever.		Note that according to HTTP 1.1 says: To mark a response as 'never expires,' an origin server sends an Expires date approximately one year from the time the response is sent. HTTP/1.1 servers SHOULD NOT send Expires dates more than one year in the future."		^ (DateAndTime now) + (Duration days: 300 hours: 0 minutes: 0 seconds: 0)</body><body package="Seaside-Core">doNotCacheExpiryDate	"Answer the expiry date that should be used if the response should not be cached at all."		^ DateAndTime year: 2000 month: 1 day: 1 hour: 0 minute: 0 second: 0</body><body package="Seaside-Core">httpVersion	"Answer the HTTP version to be used."	^ 'HTTP/1.1'</body></methods><methods><class-id>Seaside.WAResponse</class-id> <category>convenience</category><body package="Seaside-Core">resetIfPossible	"Try to reset the receiver, answer whether it was successful.	Resetting may fail in stream method the response is already committed."	self initializeFields.	^ true</body><body package="Seaside-Core">respond	WAResponseNotification signal</body></methods><methods><class-id>Seaside.WAResponse</class-id> <category>testing</category><body package="Seaside-Core">isCommitted	"Answer a boolean indicating if the response header has been committed."		^ false</body><body package="Seaside-Core">isStreamingResponse	"Return true if the receiver supports partial stream responses."	^ false</body></methods><methods><class-id>Seaside.WAResponse</class-id> <category>printing</category><body package="Seaside-Core">printOn: aStream 	super printOn: aStream.	aStream nextPutAll: ' status: '; print: self status.	aStream nextPutAll: ' message: '; print: self message</body></methods><methods><class-id>Seaside.WAResponse</class-id> <category>accessing</category><body package="Seaside-Core">cookies	"Answer the cookies of this response."	^ cookies</body><body package="Seaside-Core">headers	"Answer the headers of this response."		^ headers</body><body package="Seaside-Core">message	"Answer the message associated with this response."	^ message</body><body package="Seaside-Core">status	"Answer the status code associated with this response."	^ status</body><body package="Seaside-Core">stream	"Answer a write stream, this is where contents should be written to."		self subclassResponsibility</body></methods><methods><class-id>Seaside.WAResponse</class-id> <category>streaming</category><body package="Seaside-Core">binary	"put the response stream into binary mode"		self subclassResponsibility</body><body package="Seaside-Core">nextPut: aByteOrCharacter	"Append the element to the body part of the response."		self stream nextPut: aByteOrCharacter</body><body package="Seaside-Core">nextPutAll: aStringOrByteArray	"Append the elements of aStringOrByteArray to the body part of the response."		self stream nextPutAll: aStringOrByteArray</body></methods><methods><class-id>Seaside.WAResponse</class-id> <category>convenience-status</category><body package="Seaside-Core">basicAuthenticationRealm: aString 	self 		headerAt: 'WWW-Authenticate'		put: 'Basic realm="' , aString greaseString , '"'.	self authenticationFailed</body><body package="Seaside-Core">redirectTo: aUrlOrString	self location: aUrlOrString.	self found</body><body package="Seaside-Core">refreshAfter: aDuration location: aUrl 	self 		headerAt: 'Refresh'		put: aDuration asSeconds greaseString , '; ' , aUrl greaseString</body></methods><methods><class-id>Seaside.WAResponse</class-id> <category>convenience-headers</category><body package="Seaside-Core">attachmentWithFileName: aString 	aString notNil ifTrue:  [		self 			headerAt: 'Content-Disposition'			put: 'attachment; filename="' , aString greaseString , '"' ]</body><body package="Seaside-Core">frameOptions: aString	"This header will be deprecated and it's functionality will be moved to Content-Security-Policy 1.1 (which does not have the same level of support yet)."		self		headerAt: 'X-Frame-Options'		put: aString</body><body package="Seaside-Core">inlineWithFileName: aString 	aString notNil ifTrue: [		self 			headerAt: 'Content-Disposition'			put: 'inline; filename="' , aString greaseString , '"' ]</body><body package="Seaside-Core">location: aUrlOrString 	self 		headerAt: 'Location'		put: aUrlOrString greaseString</body><body package="Seaside-Core">strictTransportSecurity: maxAge includeSubDomains: aBoolean	"Implements Strict Transport Security (STS).		http://lists.w3.org/Archives/Public/www-archive/2009Dec/att-0048/draft-hodges-strict-transport-sec-06.plain.html	Use only over secure connections (HTTPS)."		self		headerAt: 'Strict-Transport-Security'		put: 'max-age=', maxAge greaseString,			(aBoolean ifTrue: [ '; includeSubDomains' ] ifFalse: [ '' ])</body></methods><methods><class-id>Seaside.WAResponse</class-id> <category>status</category><body package="Seaside-Core">authenticationFailed	"Indicate that the request requires HTTP authentication."		self status: WAResponse statusUnauthorized</body><body package="Seaside-Core">badRequest	"The request could not be understood by the server due to malformed syntax. The client SHOULD NOT repeat the request without modifications."		self status: WAResponse statusBadRequest</body><body package="Seaside-Core">created	"The request has been fulfilled and resulted in a new resource being created."		self status: WAResponse statusCreated</body><body package="Seaside-Core">forbidden	"Indicate that the server understood the request but refused to fulfill it."		self status: WAResponse statusForbidden</body><body package="Seaside-Core">found	"Indicate that the resource reside temporarily under a different URI."		self status: WAResponse statusFound</body><body package="Seaside-Core">gone	"Indicate that the resource is no longer available at the server and no forwarding address is known."		self status: WAResponse statusGone</body><body package="Seaside-Core">internalError	"Indicate an error inside the server which prevented it from fulfilling the request."	self status: WAResponse statusInternalServerError</body><body package="Seaside-Core">movedPermanently	"The requested resource has been assigned a new permanent URI and any future references to this resource SHOULD use one of the returned URIs."		self status: WAResponse statusMovedPermanently</body><body package="Seaside-Core">notFound	"Indicate that the requested resource is not available."		self status: WAResponse statusNotFound</body><body package="Seaside-Core">notImplemented	"Indicate the HTTP server does not support the functionality needed to fulfill the request."		self status: WAResponse statusNotImplemented</body><body package="Seaside-Core">preconditionFailed	"The precondition given in one or more of the request-header fields evaluated to false when it was tested on the server. This response code allows the client to place preconditions on the current resource metainformation (header field data) and thus prevent the requested method from being applied to a resource other than the one intended."		self status: WAResponse statusPreconditionFailed</body></methods><methods><class-id>Seaside.WAResponse</class-id> <category>accessing-cookies</category><body package="Seaside-Core">addCookie: aCookie	"Add the cookie to the receiver."	^ self cookies add: aCookie</body><body package="Seaside-Core">deleteCookie: aCookie 	"Try to get the path from the closest entry point in the context. This path	is used in case the browser did not provide the path information in the cookie.	Trouble is, this method may be called in a context where WACurrentRequestContext	is not defined or where there is no RequestHandler. In this case, we just use nil and	pray the cookie has path information or was created without any."		| baseUrl |	baseUrl := [ self requestContext handler url ] 		on: WARequestContextNotFound		do: [ :err | nil ].	self 		deleteCookie: aCookie		path: (baseUrl isNil ifFalse: [ baseUrl pathStringUnencoded ])		domain: (baseUrl isNil ifFalse: [ baseUrl host ])</body><body package="Seaside-Core">deleteCookie: aCookie path: aPathString domain: aDomainString	"Delete the cookie in the browser.		The spec sez:	If a CGI script wishes to delete a cookie, it can do so by returning a cookie with the same name, and an expires time which is in the past. The path and name must match exactly in order for the expiring cookie to replace the valid cookie. This requirement makes it difficult for anyone but the originator of a cookie to delete a cookie.		What is not specified but also has to match is the domain.		The trouble is:	Browsers that follow the Netscape spec don't send path or domain information"	| copy |	copy := (WACookie 		key: aCookie key		value: '')		pathUnencoded: aCookie pathUnencoded encoded: aCookie pathEncoded;		version: aCookie version;		domain: aCookie domain;		yourself.	aCookie version isNil ifTrue:  [		"old Netscape cookie with no path or domain information"		aPathString isNil ifFalse: [ 			copy path: aPathString ].		aDomainString isNil ifFalse: [			copy domain: aDomainString ] ].	copy expireInPast.	self addCookie: copy</body><body package="Seaside-Core">deleteCookieAt: aKeyString	"Delete the cookie in the browser. This method is quite unreliable. Consider using #deleteCookie:"	self deleteCookie: (WACookie key: aKeyString value: '')</body></methods><methods><class-id>Seaside.WAResponse</class-id> <category>convenience-caching</category><body package="Seaside-Core">cacheFor: aDuration	"Configure the receiver to be cached for aDuration."	self removeHeaderAt: 'Pragma'. "Proxies"	self headerAt: 'Expires' putDate: DateAndTime now + aDuration. "HTTP 1.0"	self headerAt: 'Cache-Control' put: 'max-age=' , aDuration asSeconds printString "HTTP 1.1"</body><body package="Seaside-Core">cacheForever	"Configure the response to be cached by user agents."		self removeHeaderAt: 'Pragma'. "Proxies"	self headerAt: 'Expires' putDate: self cacheForeverExpiryDate. "HTTP 1.0"	self removeHeaderAt: 'Cache-Control' "HTTP 1.1"</body><body package="Seaside-Core">doNotCache	"Configure the receiver to not be cached at all."		self headerAt: 'Pragma' put: 'no-cache'. "Proxies"	self headerAt: 'Expires' putDate: self doNotCacheExpiryDate. "HTTP 1.0"	"http://blog.55minutes.com/2011/10/how-to-defeat-the-browser-back-button-cache/"	"https://code.google.com/p/seaside/issues/detail?id=772"	self headerAt: 'Cache-Control' put: 'no-cache, max-age=0, must-revalidate, no-store' "HTTP 1.1"</body></methods><methods><class-id>Seaside.WAResponse</class-id> <category>public</category><body package="Seaside-Core">flush	"Flush the receiver and send partial content	By default do nothing"</body></methods><methods><class-id>Seaside.WAResponse class</class-id> <category>accessing</category><body package="Seaside-Core">messageForStatus: anInteger	^ StatusMessages at: anInteger ifAbsent: [ nil ]</body></methods><methods><class-id>Seaside.WAResponse class</class-id> <category>initialization</category><body package="Seaside-Core">initialize	self initializeStatusMessages</body><body package="Seaside-Core">initializeStatusMessages	StatusMessages := Dictionary new.	StatusMessages		at: self statusContinue put: 'Continue';		at: self statusSwitchingProtocols put: 'Switching Protocols';		at: self statusProcessing put: 'Processing';		at: self statusOk put: 'OK';		at: self statusCreated put: 'Created';		at: self statusAccepted put: 'Accepted';		at: self statusNonAuthoritativeInformation put: 'Non-Authoritative Information';		at: self statusNoContent put: 'No Content';		at: self statusResetContent put: 'Reset Content';		at: self statusPartialContent put: 'Partial Content';		at: self statusMultiStatus put: 'Multi-Status';		at: self statusAlreadyReported put: 'Already Reported';		at: self statusInstanceManipulationUsed put: 'IM Used';				at: self statusMultipleChoices put: 'Multiple Choices';		at: self statusMovedPermanently put: 'Moved Permanently';		at: self statusFound put: 'Found';		at: self statusSeeOther put: 'See Other';		at: self statusNotModified put: 'Not Modified';		at: self statusUseProxy put: 'Use Proxy';		at: self statusTemporaryRedirect put: 'Temporary Redirect';		at: self statusPermanentRedirect put: 'Permanent Redirect';		at: self statusBadRequest put: 'Bad Request';		at: self statusUnauthorized put: 'Unauthorized';		at: self statusPaymentRequired put: 'Payment Required';		at: self statusForbidden put: 'Forbidden';		at: self statusNotFound put: 'Not Found';		at: self statusMethodNotAllowed put: 'Method Not Allowed';		at: self statusNotAcceptable put: 'Not Acceptable';		at: self statusProxyAuthenticationRequired put: 'Proxy Authentication Required';		at: self statusRequestTimeout put: 'Request Timeout';		at: self statusConflict put: 'Conflict';		at: self statusGone put: 'Gone';		at: self statusLengthRequired put: 'Length Required';		at: self statusPreconditionFailed put: 'Precondition Failed';		at: self statusRequestEntityTooLarge put: 'Request Entity Too Large';		at: self statusRequestUriTooLong put: 'Request-URI Too Long';		at: self statusUnsupportedMediaType put: 'Unsupported Media Type';		at: self statusRequestedRangeNotSatisfiable put: 'Requested Range Not Satisfiable';		at: self statusExpectationFailed put: 'Expectation Failed';		at: self statusImATeapot put: 'I''m a teapot';		at: self statusUnprocessableEntity put: 'Unprocessable Entity';		at: self statusLocked put: 'Locked';		at: self statusFailedDependency put: 'Failed Dependency';		at: self statusUpgradeRequired put: 'Upgrade Required';		at: self statusPreconditionRequired put: 'Precondition Required';		at: self statusTooManyRequests put: 'Too Many Requests';		at: self statusRequestHeaderFieldsTooLarge put: 'Request Header Fields Too Large';		at: self statusInternalServerError put: 'Internal Server Error';		at: self statusNotImplemented put: 'Not Implemented';		at: self statusBadGateway put: 'Bad Gateway';		at: self statusServiceUnavailable put: 'Service Unavailable';		at: self statusGatewayTimeout put: 'Gateway Timeout';		at: self statusHttpVersionNotSupported put: 'HTTP Version Not Supported';		at: self statusVariantAlsoNegotiates put: 'Variant Also Negotiates';		at: self statusInsufficientStorage put: 'Insufficient Storage';		at: self statusLoopDetected put: 'Loop Detected';		at: self statusNotExtended put: 'Not Extended';		at: self statusNetworkAuthenticationRequired put: 'Network Authentication Required'</body></methods><methods><class-id>Seaside.WAResponse class</class-id> <category>status-client-error</category><body package="Seaside-Core">statusBadRequest	^ 400</body><body package="Seaside-Core">statusConflict	^ 409</body><body package="Seaside-Core">statusExpectationFailed	^ 417</body><body package="Seaside-Core">statusFailedDependency	^ 424</body><body package="Seaside-Core">statusForbidden	^ 403</body><body package="Seaside-Core">statusGone	^ 410</body><body package="Seaside-Core">statusImATeapot	^ 418</body><body package="Seaside-Core">statusLengthRequired	^ 411</body><body package="Seaside-Core">statusLocked	^ 423</body><body package="Seaside-Core">statusMethodNotAllowed	^ 405</body><body package="Seaside-Core">statusNotAcceptable	^ 406</body><body package="Seaside-Core">statusNotFound	^ 404</body><body package="Seaside-Core">statusPaymentRequired	^ 402</body><body package="Seaside-Core">statusPreconditionFailed	^ 412</body><body package="Seaside-Core">statusPreconditionRequired	^ 428</body><body package="Seaside-Core">statusProxyAuthenticationRequired	^ 407</body><body package="Seaside-Core">statusRequestEntityTooLarge	^ 413</body><body package="Seaside-Core">statusRequestHeaderFieldsTooLarge	^ 431</body><body package="Seaside-Core">statusRequestTimeout	^ 408</body><body package="Seaside-Core">statusRequestUriTooLong	^ 414</body><body package="Seaside-Core">statusRequestedRangeNotSatisfiable	^ 416</body><body package="Seaside-Core">statusTooManyRequests	^ 429</body><body package="Seaside-Core">statusUnauthorized	^ 401</body><body package="Seaside-Core">statusUnorderedCollection	^ 425</body><body package="Seaside-Core">statusUnprocessableEntity	^ 422</body><body package="Seaside-Core">statusUnsupportedMediaType	^ 415</body><body package="Seaside-Core">statusUpgradeRequired	^ 426</body></methods><methods><class-id>Seaside.WAResponse class</class-id> <category>status-redirection</category><body package="Seaside-Core">statusFound	^ 302</body><body package="Seaside-Core">statusMovedPermanently	^ 301</body><body package="Seaside-Core">statusMultipleChoices	^ 300</body><body package="Seaside-Core">statusNotModified	^ 304</body><body package="Seaside-Core">statusPermanentRedirect	^ 308</body><body package="Seaside-Core">statusSeeOther	^ 303</body><body package="Seaside-Core">statusSwitchProxy	^ 306</body><body package="Seaside-Core">statusTemporaryRedirect	^ 307</body><body package="Seaside-Core">statusUseProxy	^ 305</body></methods><methods><class-id>Seaside.WAResponse class</class-id> <category>status-success</category><body package="Seaside-Core">statusAccepted	^ 202</body><body package="Seaside-Core">statusAlreadyReported	^ 208</body><body package="Seaside-Core">statusCreated	^ 201</body><body package="Seaside-Core">statusInstanceManipulationUsed	^ 226</body><body package="Seaside-Core">statusMultiStatus	^ 207</body><body package="Seaside-Core">statusNoContent	^ 204</body><body package="Seaside-Core">statusNonAuthoritativeInformation	^ 203</body><body package="Seaside-Core">statusOk	^ 200</body><body package="Seaside-Core">statusPartialContent	^ 206</body><body package="Seaside-Core">statusResetContent	^ 205</body></methods><methods><class-id>Seaside.WAResponse class</class-id> <category>status-server-error</category><body package="Seaside-Core">statusBadGateway	^ 502</body><body package="Seaside-Core">statusBandwidthLimitExceeded	^ 509</body><body package="Seaside-Core">statusGatewayTimeout	^ 504</body><body package="Seaside-Core">statusHttpVersionNotSupported	^ 505</body><body package="Seaside-Core">statusInsufficientStorage	^ 507</body><body package="Seaside-Core">statusInternalServerError	^ 500</body><body package="Seaside-Core">statusLoopDetected	^ 508</body><body package="Seaside-Core">statusNetworkAuthenticationRequired	^ 511</body><body package="Seaside-Core">statusNotExtended	^ 510</body><body package="Seaside-Core">statusNotImplemented	^ 501</body><body package="Seaside-Core">statusServiceUnavailable	^ 503</body><body package="Seaside-Core">statusVariantAlsoNegotiates	^ 506</body></methods><methods><class-id>Seaside.WAResponse class</class-id> <category>status-informal</category><body package="Seaside-Core">statusContinue	^ 100</body><body package="Seaside-Core">statusProcessing	^ 102</body><body package="Seaside-Core">statusSwitchingProtocols	^ 101</body></methods><methods><class-id>Seaside.WALocale</class-id> <category>accessing</category><body package="Seaside-Core">country	^ country</body><body package="Seaside-Core">country: aString	country := aString</body><body package="Seaside-Core">countryName	"answers the country name in english and all capitals"	^ self country size = 2		ifTrue: [ self class iso2Countries at: self country ]		ifFalse: [ self class iso3Countries at: self country ]</body><body package="Seaside-Core">language	^ language</body><body package="Seaside-Core">language: aString	language := aString</body><body package="Seaside-Core">languageName	"answers the language name in english and all capitals"	^ self language size = 2		ifTrue: [ self class iso2Languages at: self language ]		ifFalse: [ self class iso3Languages at: self language ]</body></methods><methods><class-id>Seaside.WALocale</class-id> <category>printing</category><body package="Seaside-Core">printOn: aStream 	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self greaseString;		nextPut: $)</body></methods><methods><class-id>Seaside.WALocale</class-id> <category>copying</category><body package="Seaside-Core">withoutCountry	"Answer a copy with the language but no country."	^ WALocale language: self language country: nil</body></methods><methods><class-id>Seaside.WALocale</class-id> <category>converting</category><body package="Seaside-Core">greaseString	^ country isNil		ifTrue: [			"optimization, no need for allocation at all"			language ]		ifFalse: [			| string stream |			"allocate with correct size, avoid copy"			string := String new: language size + 1 + country size.			stream := WriteStream on: string.			stream				nextPutAll: language;				nextPut: $-;				nextPutAll: country.			"no need for #contents because we allocated with the correct size"			^ string ]</body></methods><methods><class-id>Seaside.WALocale class</class-id> <category>class initialization</category><body package="Seaside-Core">initialize	self initializeLangaugeList.	self initializeCountryList</body><body package="Seaside-Core">initializeCountryList	iso2Countries := Dictionary new.	iso3Countries := Dictionary new.	self countryList do: [ :each |		iso2Countries			at: each first			put: each third.		iso3Countries			at: each second			put: each third ]</body><body package="Seaside-Core">initializeLangaugeList	iso2Languages := Dictionary new.	iso3Languages := Dictionary new.		self languageList do: [ :each |		each size &gt; 2			ifTrue: [				iso2Languages at: each first put: each third.				iso3Languages at: each second put: each third ]			ifFalse: [				iso3Languages at: each first put: each second ] ]</body></methods><methods><class-id>Seaside.WALocale class</class-id> <category>accessing</category><body package="Seaside-Core">countryList	^ #(('AF' 'AFG' 'AFGHANISTAN') ('AL' 'ALB' 'ALBANIA') ('DZ' 'DZA' 'ALGERIA') ('AS' 'ASM' 'AMERICAN SAMOA') ('AD' 'AND' 'ANDORRA') ('AO' 'AGO' 'ANGOLA') ('AI' 'AIA' 'ANGUILLA') ('AQ' 'ATA' 'ANTARCTICA') ('AG' 'ATG' 'ANTIGUA AND BARBUDA') ('AR' 'ARG' 'ARGENTINA') ('AM' 'ARM' 'ARMENIA') ('AW' 'ABW' 'ARUBA') ('AU' 'AUS' 'AUSTRALIA') ('AT' 'AUT' 'AUSTRIA') ('AZ' 'AZE' 'AZERBAIJAN') ('BS' 'BHS' 'BAHAMAS') ('BH' 'BHR' 'BAHRAIN') ('BD' 'BGD' 'BANGLADESH') ('BB' 'BRB' 'BARBADOS') ('BY' 'BLR' 'BELARUS') ('BE' 'BEL' 'BELGIUM') ('BZ' 'BLZ' 'BELIZE') ('BJ' 'BEN' 'BENIN') ('BM' 'BMU' 'BERMUDA') ('BT' 'BTN' 'BHUTAN') ('BO' 'BOL' 'BOLIVIA') ('BA' 'BIH' 'BOSNIA AND HERZEGOWINA') ('BW' 'BWA' 'BOTSWANA') ('BV' 'BVT' 'BOUVET ISLAND') ('BR' 'BRA' 'BRAZIL') ('IO' 'IOT' 'BRITISH INDIAN OCEAN TERRITORY') ('BN' 'BRN' 'BRUNEI DARUSSALAM') ('BG' 'BGR' 'BULGARIA') ('BF' 'BFA' 'BURKINA FASO') ('BI' 'BDI' 'BURUNDI') ('KH' 'KHM' 'CAMBODIA') ('CM' 'CMR' 'CAMEROON') ('CA' 'CAN' 'CANADA') ('CV' 'CPV' 'CAPE VERDE') ('KY' 'CYM' 'CAYMAN ISLANDS') ('CF' 'CAF' 'CENTRAL AFRICAN REPUBLIC') ('TD' 'TCD' 'CHAD') ('CL' 'CHL' 'CHILE') ('CN' 'CHN' 'CHINA') ('CX' 'CXR' 'CHRISTMAS ISLAND') ('CC' 'CCK' 'COCOS (KEELING) ISLANDS') ('CO' 'COL' 'COLOMBIA') ('KM' 'COM' 'COMOROS') ('CG' 'COG' 'CONGO') ('CK' 'COK' 'COOK ISLANDS') ('CR' 'CRI' 'COSTA RICA') ('CI' 'CIV' 'COTE D''IVOIRE') ('HR' 'HRV' 'CROATIA (local name: Hrvatska)') ('CU' 'CUB' 'CUBA') ('CY' 'CYP' 'CYPRUS') ('CZ' 'CZE' 'CZECH REPUBLIC') ('DK' 'DNK' 'DENMARK') ('DJ' 'DJI' 'DJIBOUTI') ('DM' 'DMA' 'DOMINICA') ('DO' 'DOM' 'DOMINICAN REPUBLIC') ('TP' 'TMP' 'EAST TIMOR') ('EC' 'ECU' 'ECUADOR') ('EG' 'EGY' 'EGYPT') ('SV' 'SLV' 'EL SALVADOR') ('GQ' 'GNQ' 'EQUATORIAL GUINEA') ('ER' '   ' 'ERITREA') ('EE' 'EST' 'ESTONIA') ('ET' 'ETH' 'ETHIOPIA') ('FK' 'FLK' 'FALKLAND ISLANDS (MALVINAS)') ('FO' 'FRO' 'FAROE ISLANDS') ('FJ' 'FJI' 'FIJI') ('FI' 'FIN' 'FINLAND') ('FR' 'FRA' 'FRANCE') ('FX' 'FXX' 'FRANCE, METROPOLITAN') ('GF' 'GUF' 'FRENCH GUIANA') ('PF' 'PYF' 'FRENCH POLYNESIA') ('TF' 'ATF' 'FRENCH SOUTHERN TERRITORIES') ('GA' 'GAB' 'GABON') ('GM' 'GMB' 'GAMBIA') ('GE' 'GEO' 'GEORGIA') ('DE' 'DEU' 'GERMANY') ('GH' 'GHA' 'GHANA') ('GI' 'GIB' 'GIBRALTAR') ('GR' 'GRC' 'GREECE') ('GL' 'GRL' 'GREENLAND') ('GD' 'GRD' 'GRENADA') ('GP' 'GLP' 'GUADELOUPE') ('GU' 'GUM' 'GUAM') ('GT' 'GTM' 'GUATEMALA') ('GN' 'GIN' 'GUINEA') ('GW' 'GNB' 'GUINEA-BISSAU') ('GY' 'GUY' 'GUYANA') ('HT' 'HTI' 'HAITI') ('HM' 'HMD' 'HEARD AND MC DONALD ISLANDS') ('VA' 'VAT' 'HOLY SEE (VATICAN CITY STATE)') ('HN' 'HND' 'HONDURAS') ('HK' 'HKG' 'HONG KONG') ('HU' 'HUN' 'HUNGARY') ('IS' 'ISL' 'ICELAND') ('IN' 'IND' 'INDIA') ('ID' 'IDN' 'INDONESIA') ('IR' 'IRN' 'IRAN (ISLAMIC REPUBLIC OF)') ('IQ' 'IRQ' 'IRAQ') ('IE' 'IRL' 'IRELAND') ('IL' 'ISR' 'ISRAEL') ('IT' 'ITA' 'ITALY') ('JM' 'JAM' 'JAMAICA') ('JP' 'JPN' 'JAPAN') ('JO' 'JOR' 'JORDAN') ('KZ' 'KAZ' 'KAZAKHSTAN') ('KE' 'KEN' 'KENYA') ('KI' 'KIR' 'KIRIBATI') ('KP' 'PRK' 'KOREA, DEMOCRATIC PEOPLE''S REPUBLIC OF') ('KR' 'KOR' 'KOREA, REPUBLIC OF') ('KW' 'KWT' 'KUWAIT') ('KG' 'KGZ' 'KYRGYZSTAN') ('LA' 'LAO' 'LAO PEOPLE''S DEMOCRATIC REPUBLIC') ('LV' 'LVA' 'LATVIA') ('LB' 'LBN' 'LEBANON') ('LS' 'LSO' 'LESOTHO') ('LR' 'LBR' 'LIBERIA') ('LY' 'LBY' 'LIBYAN ARAB JAMAHIRIYA') ('LI' 'LIE' 'LIECHTENSTEIN') ('LT' 'LTU' 'LITHUANIA') ('LU' 'LUX' 'LUXEMBOURG') ('MO' 'MAC' 'MACAU') ('MK' 'MKD' 'MACEDONIA, THE FORMER YUGOSLAV REPUBLIC OF') ('MG' 'MDG' 'MADAGASCAR') ('MW' 'MWI' 'MALAWI') ('MY' 'MYS' 'MALAYSIA') ('MV' 'MDV' 'MALDIVES') ('ML' 'MLI' 'MALI') ('MT' 'MLT' 'MALTA') ('MH' 'MHL' 'MARSHALL ISLANDS') ('MQ' 'MTQ' 'MARTINIQUE') ('MR' 'MRT' 'MAURITANIA') ('MU' 'MUS' 'MAURITIUS') ('YT' 'MYT' 'MAYOTTE') ('MX' 'MEX' 'MEXICO') ('FM' 'FSM' 'MICRONESIA, FEDERATED STATES OF') ('MD' 'MDA' 'MOLDOVA, REPUBLIC OF') ('MC' 'MCO' 'MONACO') ('MN' 'MNG' 'MONGOLIA') ('MS' 'MSR' 'MONTSERRAT') ('MA' 'MAR' 'MOROCCO') ('MZ' 'MOZ' 'MOZAMBIQUE') ('MM' 'MMR' 'MYANMAR') ('NA' 'NAM' 'NAMIBIA') ('NR' 'NRU' 'NAURU') ('NP' 'NPL' 'NEPAL') ('NL' 'NLD' 'NETHERLANDS') ('AN' 'ANT' 'NETHERLANDS ANTILLES') ('NC' 'NCL' 'NEW CALEDONIA') ('NZ' 'NZL' 'NEW ZEALAND') ('NI' 'NIC' 'NICARAGUA') ('NE' 'NER' 'NIGER') ('NG' 'NGA' 'NIGERIA') ('NU' 'NIU' 'NIUE') ('NF' 'NFK' 'NORFOLK ISLAND') ('MP' 'MNP' 'NORTHERN MARIANA ISLANDS') ('NO' 'NOR' 'NORWAY') ('OM' 'OMN' 'OMAN') ('PK' 'PAK' 'PAKISTAN') ('PW' 'PLW' 'PALAU') ('PA' 'PAN' 'PANAMA') ('PG' 'PNG' 'PAPUA NEW GUINEA') ('PY' 'PRY' 'PARAGUAY') ('PE' 'PER' 'PERU') ('PH' 'PHL' 'PHILIPPINES') ('PN' 'PCN' 'PITCAIRN') ('PL' 'POL' 'POLAND') ('PT' 'PRT' 'PORTUGAL') ('PR' 'PRI' 'PUERTO RICO') ('QA' 'QAT' 'QATAR') ('RE' 'REU' 'REUNION') ('RO' 'ROM' 'ROMANIA') ('RU' 'RUS' 'RUSSIAN FEDERATION') ('RW' 'RWA' 'RWANDA') ('KN' 'KNA' 'SAINT KITTS AND NEVIS') ('LC' 'LCA' 'SAINT LUCIA') ('VC' 'VCT' 'SAINT VINCENT AND THE GRENADINES') ('WS' 'WSM' 'SAMOA') ('SM' 'SMR' 'SAN MARINO') ('ST' 'STP' 'SAO TOME AND PRINCIPE') ('SA' 'SAU' 'SAUDI ARABIA') ('SN' 'SEN' 'SENEGAL') ('SC' 'SYC' 'SEYCHELLES') ('SL' 'SLE' 'SIERRA LEONE') ('SG' 'SGP' 'SINGAPORE') ('SK' 'SVK' 'SLOVAKIA (Slovak Republic)') ('SI' 'SVN' 'SLOVENIA') ('SB' 'SLB' 'SOLOMON ISLANDS') ('SO' 'SOM' 'SOMALIA') ('ZA' 'ZAF' 'SOUTH AFRICA') ('GS' 'SGS' 'SOUTH GEORGIA AND THE SOUTH SANDWICH ISLANDS') ('ES' 'ESP' 'SPAIN') ('LK' 'LKA' 'SRI LANKA') ('SH' 'SHN' 'ST. HELENA') ('PM' 'SPM' 'ST. PIERRE AND MIQUELON') ('SD' 'SDN' 'SUDAN') ('SR' 'SUR' 'SURINAME') ('SJ' 'SJM' 'SVALBARD AND JAN MAYEN ISLANDS') ('SZ' 'SWZ' 'SWAZILAND') ('SE' 'SWE' 'SWEDEN') ('CH' 'CHE' 'SWITZERLAND') ('SY' 'SYR' 'SYRIAN ARAB REPUBLIC') ('TW' 'TWN' 'TAIWAN, PROVINCE OF CHINA') ('TJ' 'TJK' 'TAJIKISTAN') ('TZ' 'TZA' 'TANZANIA, UNITED REPUBLIC OF') ('TH' 'THA' 'THAILAND') ('TG' 'TGO' 'TOGO') ('TK' 'TKL' 'TOKELAU') ('TO' 'TON' 'TONGA') ('TT' 'TTO' 'TRINIDAD AND TOBAGO') ('TN' 'TUN' 'TUNISIA') ('TR' 'TUR' 'TURKEY') ('TM' 'TKM' 'TURKMENISTAN') ('TC' 'TCA' 'TURKS AND CAICOS ISLANDS') ('TV' 'TUV' 'TUVALU') ('UG' 'UGA' 'UGANDA') ('UA' 'UKR' 'UKRAINE') ('AE' 'ARE' 'UNITED ARAB EMIRATES') ('GB' 'GBR' 'UNITED KINGDOM') ('US' 'USA' 'UNITED STATES') ('UM' 'UMI' 'UNITED STATES MINOR OUTLYING ISLANDS') ('UY' 'URY' 'URUGUAY') ('UZ' 'UZB' 'UZBEKISTAN') ('VU' 'VUT' 'VANUATU') ('VE' 'VEN' 'VENEZUELA') ('VN' 'VNM' 'VIET NAM') ('VG' 'VGB' 'VIRGIN ISLANDS (BRITISH)') ('VI' 'VIR' 'VIRGIN ISLANDS (U.S.)') ('WF' 'WLF' 'WALLIS AND FUTUNA ISLANDS') ('EH' 'ESH' 'WESTERN SAHARA') ('YE' 'YEM' 'YEMEN') ('YU' 'YUG' 'YUGOSLAVIA') ('ZR' 'ZAR' 'ZAIRE') ('ZM' 'ZMB' 'ZAMBIA') ('ZW' 'ZWE' 'ZIMBABWE'))</body><body package="Seaside-Core">iso2Countries	^ iso2Countries</body><body package="Seaside-Core">iso2Languages	^ iso2Languages</body><body package="Seaside-Core">iso3Countries	^ iso3Countries</body><body package="Seaside-Core">iso3Languages	^ iso3Languages</body><body package="Seaside-Core">languageList	^ #(('aa' 'aar' 'Afar') ('ab' 'abk' 'Abkhazian') ('ace' 'Achinese') ('ach' 'Acoli') ('ada' 'Adangme') ('ady' 'Adyghe; Adygei') ('afa' 'Afro-Asiatic (Other)') ('afh' 'Afrihili') ('af' 'afr' 'Afrikaans') ('ain' 'Ainu') ('ak' 'aka' 'Akan') ('akk' 'Akkadian') ('sq' 'alb' 'Albanian') ('ale' 'Aleut') ('alg' 'Algonquian languages') ('alt' 'Southern Altai') ('am' 'amh' 'Amharic') ('ang' 'English, Old (ca.450-1100)') ('anp' 'Angika') ('apa' 'Apache languages') ('ar' 'ara' 'Arabic') ('arc' 'Official Aramaic (700-300 BCE); Imperial Aramaic (700-300 BCE)') ('an' 'arg' 'Aragonese') ('hy' 'arm' 'Armenian') ('arn' 'Mapudungun; Mapuche') ('arp' 'Arapaho') ('art' 'Artificial (Other)') ('arw' 'Arawak') ('as' 'asm' 'Assamese') ('ast' 'Asturian; Bable; Leonese; Asturleonese') ('ath' 'Athapascan languages') ('aus' 'Australian languages') ('av' 'ava' 'Avaric') ('ae' 'ave' 'Avestan') ('awa' 'Awadhi') ('ay' 'aym' 'Aymara') ('az' 'aze' 'Azerbaijani') ('bad' 'Banda languages') ('bai' 'Bamileke languages') ('ba' 'bak' 'Bashkir') ('bal' 'Baluchi') ('bm' 'bam' 'Bambara') ('ban' 'Balinese') ('eu' 'baq' 'Basque') ('bas' 'Basa') ('bat' 'Baltic (Other)') ('bej' 'Beja; Bedawiyet') ('be' 'bel' 'Belarusian') ('bem' 'Bemba') ('bn' 'ben' 'Bengali') ('ber' 'Berber (Other)') ('bho' 'Bhojpuri') ('bh' 'bih' 'Bihari') ('bik' 'Bikol') ('bin' 'Bini; Edo') ('bi' 'bis' 'Bislama') ('bla' 'Siksika') ('bnt' 'Bantu (Other)') ('bs' 'bos' 'Bosnian') ('bra' 'Braj') ('br' 'bre' 'Breton') ('btk' 'Batak languages') ('bua' 'Buriat') ('bug' 'Buginese') ('bg' 'bul' 'Bulgarian') ('my' 'bur' 'Burmese') ('byn' 'Blin; Bilin') ('cad' 'Caddo') ('cai' 'Central American Indian (Other)') ('car' 'Galibi Carib') ('ca' 'cat' 'Catalan; Valencian') ('cau' 'Caucasian (Other)') ('ceb' 'Cebuano') ('cel' 'Celtic (Other)') ('ch' 'cha' 'Chamorro') ('chb' 'Chibcha') ('ce' 'che' 'Chechen') ('chg' 'Chagatai') ('zh' 'chi' 'Chinese') ('chk' 'Chuukese') ('chm' 'Mari') ('chn' 'Chinook jargon') ('cho' 'Choctaw') ('chp' 'Chipewyan; Dene Suline') ('chr' 'Cherokee') ('cu' 'chu' 'Church Slavic; Old Slavonic; Church Slavonic; Old Bulgarian; Old Church Slavonic') ('cv' 'chv' 'Chuvash') ('chy' 'Cheyenne') ('cmc' 'Chamic languages') ('cop' 'Coptic') ('kw' 'cor' 'Cornish') ('co' 'cos' 'Corsican') ('cpe' 'Creoles and pidgins, English based (Other)') ('cpf' 'Creoles and pidgins, French-based (Other)') ('cpp' 'Creoles and pidgins, Portuguese-based (Other)') ('cr' 'cre' 'Cree') ('crh' 'Crimean Tatar; Crimean Turkish') ('crp' 'Creoles and pidgins (Other)') ('csb' 'Kashubian') ('cus' 'Cushitic (Other)') ('cs' 'cze' 'Czech') ('dak' 'Dakota') ('da' 'dan' 'Danish') ('dar' 'Dargwa') ('day' 'Land Dayak languages') ('del' 'Delaware') ('den' 'Slave (Athapascan)') ('dgr' 'Dogrib') ('din' 'Dinka') ('dv' 'div' 'Divehi; Dhivehi; Maldivian') ('doi' 'Dogri') ('dra' 'Dravidian (Other)') ('dsb' 'Lower Sorbian') ('dua' 'Duala') ('dum' 'Dutch, Middle (ca.1050-1350)') ('nl' 'dut' 'Dutch; Flemish') ('dyu' 'Dyula') ('dz' 'dzo' 'Dzongkha') ('efi' 'Efik') ('egy' 'Egyptian (Ancient)') ('eka' 'Ekajuk') ('elx' 'Elamite') ('en' 'eng' 'English') ('enm' 'English, Middle (1100-1500)') ('eo' 'epo' 'Esperanto') ('et' 'est' 'Estonian') ('ee' 'ewe' 'Ewe') ('ewo' 'Ewondo') ('fan' 'Fang') ('fo' 'fao' 'Faroese') ('fat' 'Fanti') ('fj' 'fij' 'Fijian') ('fil' 'Filipino; Pilipino') ('fi' 'fin' 'Finnish') ('fiu' 'Finno-Ugrian (Other)') ('fon' 'Fon') ('fr' 'fre' 'French') ('frm' 'French, Middle (ca.1400-1600)') ('fro' 'French, Old (842-ca.1400)') ('frr' 'Northern Frisian') ('frs' 'Eastern Frisian') ('fy' 'fry' 'Western Frisian') ('ff' 'ful' 'Fulah') ('fur' 'Friulian') ('gaa' 'Ga') ('gay' 'Gayo') ('gba' 'Gbaya') ('gem' 'Germanic (Other)') ('ka' 'geo' 'Georgian') ('de' 'ger' 'German') ('gez' 'Geez') ('gil' 'Gilbertese') ('gd' 'gla' 'Gaelic; Scottish Gaelic') ('ga' 'gle' 'Irish') ('gl' 'glg' 'Galician') ('gv' 'glv' 'Manx') ('gmh' 'German, Middle High (ca.1050-1500)') ('goh' 'German, Old High (ca.750-1050)') ('gon' 'Gondi') ('gor' 'Gorontalo') ('got' 'Gothic') ('grb' 'Grebo') ('grc' 'Greek, Ancient (to 1453)') ('el' 'gre' 'Greek, Modern (1453-)') ('gn' 'grn' 'Guarani') ('gsw' 'Swiss German; Alemannic; Alsatian') ('gu' 'guj' 'Gujarati') ('gwi' 'Gwich''in') ('hai' 'Haida') ('ht' 'hat' 'Haitian; Haitian Creole') ('ha' 'hau' 'Hausa') ('haw' 'Hawaiian') ('he' 'heb' 'Hebrew') ('hz' 'her' 'Herero') ('hil' 'Hiligaynon') ('him' 'Himachali') ('hi' 'hin' 'Hindi') ('hit' 'Hittite') ('hmn' 'Hmong') ('ho' 'hmo' 'Hiri Motu') ('hsb' 'Upper Sorbian') ('hu' 'hun' 'Hungarian') ('hup' 'Hupa') ('iba' 'Iban') ('ig' 'ibo' 'Igbo') ('is' 'ice' 'Icelandic') ('io' 'ido' 'Ido') ('ii' 'iii' 'Sichuan Yi; Nuosu') ('ijo' 'Ijo languages') ('iu' 'iku' 'Inuktitut') ('ie' 'ile' 'Interlingue; Occidental') ('ilo' 'Iloko') ('ia' 'ina' 'Interlingua (International Auxiliary Language Association)') ('inc' 'Indic (Other)') ('id' 'ind' 'Indonesian') ('ine' 'Indo-European (Other)') ('inh' 'Ingush') ('ik' 'ipk' 'Inupiaq') ('ira' 'Iranian (Other)') ('iro' 'Iroquoian languages') ('it' 'ita' 'Italian') ('jv' 'jav' 'Javanese') ('jbo' 'Lojban') ('ja' 'jpn' 'Japanese') ('jpr' 'Judeo-Persian') ('jrb' 'Judeo-Arabic') ('kaa' 'Kara-Kalpak') ('kab' 'Kabyle') ('kac' 'Kachin; Jingpho') ('kl' 'kal' 'Kalaallisut; Greenlandic') ('kam' 'Kamba') ('kn' 'kan' 'Kannada') ('kar' 'Karen languages') ('ks' 'kas' 'Kashmiri') ('kr' 'kau' 'Kanuri') ('kaw' 'Kawi') ('kk' 'kaz' 'Kazakh') ('kbd' 'Kabardian') ('kha' 'Khasi') ('khi' 'Khoisan (Other)') ('km' 'khm' 'Central Khmer') ('kho' 'Khotanese') ('ki' 'kik' 'Kikuyu; Gikuyu') ('rw' 'kin' 'Kinyarwanda') ('ky' 'kir' 'Kirghiz; Kyrgyz') ('kmb' 'Kimbundu') ('kok' 'Konkani') ('kv' 'kom' 'Komi') ('kg' 'kon' 'Kongo') ('ko' 'kor' 'Korean') ('kos' 'Kosraean') ('kpe' 'Kpelle') ('krc' 'Karachay-Balkar') ('krl' 'Karelian') ('kro' 'Kru languages') ('kru' 'Kurukh') ('kj' 'kua' 'Kuanyama; Kwanyama') ('kum' 'Kumyk') ('ku' 'kur' 'Kurdish') ('kut' 'Kutenai') ('lad' 'Ladino') ('lah' 'Lahnda') ('lam' 'Lamba') ('lo' 'lao' 'Lao') ('la' 'lat' 'Latin') ('lv' 'lav' 'Latvian') ('lez' 'Lezghian') ('li' 'lim' 'Limburgan; Limburger; Limburgish') ('ln' 'lin' 'Lingala') ('lt' 'lit' 'Lithuanian') ('lol' 'Mongo') ('loz' 'Lozi') ('lb' 'ltz' 'Luxembourgish; Letzeburgesch') ('lua' 'Luba-Lulua') ('lu' 'lub' 'Luba-Katanga') ('lg' 'lug' 'Ganda') ('lui' 'Luiseno') ('lun' 'Lunda') ('luo' 'Luo (Kenya and Tanzania)') ('lus' 'Lushai') ('mk' 'mac' 'Macedonian') ('mad' 'Madurese') ('mag' 'Magahi') ('mh' 'mah' 'Marshallese') ('mai' 'Maithili') ('mak' 'Makasar') ('ml' 'mal' 'Malayalam') ('man' 'Mandingo') ('mi' 'mao' 'Maori') ('map' 'Austronesian (Other)') ('mr' 'mar' 'Marathi') ('mas' 'Masai') ('ms' 'may' 'Malay') ('mdf' 'Moksha') ('mdr' 'Mandar') ('men' 'Mende') ('mga' 'Irish, Middle (900-1200)') ('mic' 'Mi''kmaq; Micmac') ('min' 'Minangkabau') ('mis' 'Uncoded languages') ('mkh' 'Mon-Khmer (Other)') ('mg' 'mlg' 'Malagasy') ('mt' 'mlt' 'Maltese') ('mnc' 'Manchu') ('mni' 'Manipuri') ('mno' 'Manobo languages') ('moh' 'Mohawk') ('mo' 'mol' 'Moldavian') ('mn' 'mon' 'Mongolian') ('mos' 'Mossi') ('mul' 'Multiple languages') ('mun' 'Munda languages') ('mus' 'Creek') ('mwl' 'Mirandese') ('mwr' 'Marwari') ('myn' 'Mayan languages') ('myv' 'Erzya') ('nah' 'Nahuatl languages') ('nai' 'North American Indian') ('nap' 'Neapolitan') ('na' 'nau' 'Nauru') ('nv' 'nav' 'Navajo; Navaho') ('nr' 'nbl' 'Ndebele, South; South Ndebele') ('nd' 'nde' 'Ndebele, North; North Ndebele') ('ng' 'ndo' 'Ndonga') ('nds' 'Low German; Low Saxon; German, Low; Saxon, Low') ('ne' 'nep' 'Nepali') ('new' 'Nepal Bhasa; Newari') ('nia' 'Nias') ('nic' 'Niger-Kordofanian (Other)') ('niu' 'Niuean') ('nn' 'nno' 'Norwegian Nynorsk; Nynorsk, Norwegian') ('nb' 'nob' 'BokmÃ¥l, Norwegian; Norwegian BokmÃ¥l') ('nog' 'Nogai') ('non' 'Norse, Old') ('no' 'nor' 'Norwegian') ('nqo' 'N''Ko') ('nso' 'Pedi; Sepedi; Northern Sotho') ('nub' 'Nubian languages') ('nwc' 'Classical Newari; Old Newari; Classical Nepal Bhasa') ('ny' 'nya' 'Chichewa; Chewa; Nyanja') ('nym' 'Nyamwezi') ('nyn' 'Nyankole') ('nyo' 'Nyoro') ('nzi' 'Nzima') ('oc' 'oci' 'Occitan (post 1500); ProvenÃ§al') ('oj' 'oji' 'Ojibwa') ('or' 'ori' 'Oriya') ('om' 'orm' 'Oromo') ('osa' 'Osage') ('os' 'oss' 'Ossetian; Ossetic') ('ota' 'Turkish, Ottoman (1500-1928)') ('oto' 'Otomian languages') ('paa' 'Papuan (Other)') ('pag' 'Pangasinan') ('pal' 'Pahlavi') ('pam' 'Pampanga; Kapampangan') ('pa' 'pan' 'Panjabi; Punjabi') ('pap' 'Papiamento') ('pau' 'Palauan') ('peo' 'Persian, Old (ca.600-400 B.C.)') ('fa' 'per' 'Persian') ('phi' 'Philippine (Other)') ('phn' 'Phoenician') ('pi' 'pli' 'Pali') ('pl' 'pol' 'Polish') ('pon' 'Pohnpeian') ('pt' 'por' 'Portuguese') ('pra' 'Prakrit languages') ('pro' 'ProvenÃ§al, Old (to 1500)') ('ps' 'pus' 'Pushto; Pashto') ('qaa-qtz' 'Reserved for local use') ('qu' 'que' 'Quechua') ('raj' 'Rajasthani') ('rap' 'Rapanui') ('rar' 'Rarotongan; Cook Islands Maori') ('roa' 'Romance (Other)') ('rm' 'roh' 'Romansh') ('rom' 'Romany') ('ro' 'rum' 'Romanian') ('rn' 'run' 'Rundi') ('rup' 'Aromanian; Arumanian; Macedo-Romanian') ('ru' 'rus' 'Russian') ('sad' 'Sandawe') ('sg' 'sag' 'Sango') ('sah' 'Yakut') ('sai' 'South American Indian (Other)') ('sal' 'Salishan languages') ('sam' 'Samaritan Aramaic') ('sa' 'san' 'Sanskrit') ('sas' 'Sasak') ('sat' 'Santali') ('sr' 'scc' 'Serbian') ('scn' 'Sicilian') ('sco' 'Scots') ('hr' 'scr' 'Croatian') ('sel' 'Selkup') ('sem' 'Semitic (Other)') ('sga' 'Irish, Old (to 900)') ('sgn' 'Sign Languages') ('shn' 'Shan') ('sid' 'Sidamo') ('si' 'sin' 'Sinhala; Sinhalese') ('sio' 'Siouan languages') ('sit' 'Sino-Tibetan (Other)') ('sla' 'Slavic (Other)') ('sk' 'slo' 'Slovak') ('sl' 'slv' 'Slovenian') ('sma' 'Southern Sami') ('se' 'sme' 'Northern Sami') ('smi' 'Sami languages (Other)') ('smj' 'Lule Sami') ('smn' 'Inari Sami') ('sm' 'smo' 'Samoan') ('sms' 'Skolt Sami') ('sn' 'sna' 'Shona') ('sd' 'snd' 'Sindhi') ('snk' 'Soninke') ('sog' 'Sogdian') ('so' 'som' 'Somali') ('son' 'Songhai languages') ('st' 'sot' 'Sotho, Southern') ('es' 'spa' 'Spanish; Castilian') ('sc' 'srd' 'Sardinian') ('srn' 'Sranan Tongo') ('srr' 'Serer') ('ssa' 'Nilo-Saharan (Other)') ('ss' 'ssw' 'Swati') ('suk' 'Sukuma') ('su' 'sun' 'Sundanese') ('sus' 'Susu') ('sux' 'Sumerian') ('sw' 'swa' 'Swahili') ('sv' 'swe' 'Swedish') ('syc' 'Classical Syriac') ('syr' 'Syriac') ('ty' 'tah' 'Tahitian') ('tai' 'Tai (Other)') ('ta' 'tam' 'Tamil') ('tt' 'tat' 'Tatar') ('te' 'tel' 'Telugu') ('tem' 'Timne') ('ter' 'Tereno') ('tet' 'Tetum') ('tg' 'tgk' 'Tajik') ('tl' 'tgl' 'Tagalog') ('th' 'tha' 'Thai') ('bo' 'tib' 'Tibetan') ('tig' 'Tigre') ('ti' 'tir' 'Tigrinya') ('tiv' 'Tiv') ('tkl' 'Tokelau') ('tlh' 'Klingon; tlhIngan-Hol') ('tli' 'Tlingit') ('tmh' 'Tamashek') ('tog' 'Tonga (Nyasa)') ('to' 'ton' 'Tonga (Tonga Islands)') ('tpi' 'Tok Pisin') ('tsi' 'Tsimshian') ('tn' 'tsn' 'Tswana') ('ts' 'tso' 'Tsonga') ('tk' 'tuk' 'Turkmen') ('tum' 'Tumbuka') ('tup' 'Tupi languages') ('tr' 'tur' 'Turkish') ('tut' 'Altaic (Other)') ('tvl' 'Tuvalu') ('tw' 'twi' 'Twi') ('tyv' 'Tuvinian') ('udm' 'Udmurt') ('uga' 'Ugaritic') ('ug' 'uig' 'Uighur; Uyghur') ('uk' 'ukr' 'Ukrainian') ('umb' 'Umbundu') ('und' 'Undetermined') ('ur' 'urd' 'Urdu') ('uz' 'uzb' 'Uzbek') ('vai' 'Vai') ('ve' 'ven' 'Venda') ('vi' 'vie' 'Vietnamese') ('vo' 'vol' 'VolapÃ¼k') ('vot' 'Votic') ('wak' 'Wakashan languages') ('wal' 'Walamo') ('war' 'Waray') ('was' 'Washo') ('cy' 'wel' 'Welsh') ('wen' 'Sorbian languages') ('wa' 'wln' 'Walloon') ('wo' 'wol' 'Wolof') ('xal' 'Kalmyk; Oirat') ('xh' 'xho' 'Xhosa') ('yao' 'Yao') ('yap' 'Yapese') ('yi' 'yid' 'Yiddish') ('yo' 'yor' 'Yoruba') ('ypk' 'Yupik languages') ('zap' 'Zapotec') ('zbl' 'Blissymbols; Blissymbolics; Bliss') ('zen' 'Zenaga') ('za' 'zha' 'Zhuang; Chuang') ('znd' 'Zande languages') ('zu' 'zul' 'Zulu') ('zun' 'Zuni') ('zxx' 'No linguistic content') ('zza' 'Zaza; Dimili; Dimli; Kirdki; Kirmanjki; Zazaki'))</body></methods><methods><class-id>Seaside.WALocale class</class-id> <category>instance creation</category><body package="Seaside-Core">fromString: aString	| language country delimiter |	delimiter := (aString includes: $_)		ifTrue: [ $_ ]		ifFalse: [ $- ].	language := aString copyUpTo: delimiter.	country := aString copyAfter: delimiter.	country isEmpty ifTrue: [ country := nil ].	^ self		language: language		country: country</body><body package="Seaside-Core">language: aLanguageString	^ self new		language: aLanguageString;		yourself</body><body package="Seaside-Core">language: aLanguageString country: aCountryString	^ self new		language: aLanguageString;		country: aCountryString;		yourself</body></methods><methods><class-id>Seaside.WARequestHandlingConfiguration</class-id> <category>private</category><body package="Seaside-Core">documentClasses	^ WADocument withAllSubclasses asSortedCollection: [ :a :b | a name &lt;= b name ]</body><body package="Seaside-Core">responseGenerators	^ WAResponseGenerator withAllSubclasses asSortedCollection: [ :a :b | a name &lt;= b name ]</body><body package="Seaside-Core">scriptGeneratorClasses	^ WAScriptGenerator allSubclasses asSortedCollection: [ :a :b | a name &lt;= b name ]</body><body package="Seaside-Core">serverProtocols	^ #(nil 'http' 'https')</body></methods><methods><class-id>Seaside.WARequestHandlingConfiguration</class-id> <category>description</category><body package="Seaside-Core">describeOn: config 	(config string: #charSet)		beAdvanced;		label: 'Character Set';		comment: 'The character set reported to the browser. This is only used if you set the encoding in the server to ''(none)''.';		default: 'utf-8'.	(config classBinding: #documentClass)		beAdvanced;		options: [ self documentClasses ];		default: WAHtmlDocument.	(config classBinding: #scriptGeneratorClass)		beAdvanced;		options: [ self scriptGeneratorClasses ];		default: WADefaultScriptGenerator.	(config classBinding: #responseGenerator)		beAdvanced;		options: [ self responseGenerators ];		default: WAResponseGenerator.	(config list: #serverProtocol)		beAdvanced;		group: #server;		comment: 'The protocol in URLs generated by Seaside.';		options: [ self serverProtocols ].	(config string: #serverHostname)		beAdvanced;		group: #server;		comment: 'The hostname in URLs generated by Seaside.'.	(config integer: #serverPort)		beAdvanced;		group: #server;		comment: 'The port in URLs generated by Seaside.'.	(config string: #serverPath)		group: #server;		comment: 'The path in URLs generated by Seaside.'</body></methods><methods><class-id>Seaside.WARegistryConfiguration</class-id> <category>ancestry</category><body package="Seaside-Core">parents	^ Array with: WARequestHandlingConfiguration instance</body></methods><methods><class-id>Seaside.WARegistryConfiguration</class-id> <category>description</category><body package="Seaside-Core">describeOn: config	(config list: #trackingStrategy)		comment: 'How handlers should be tracked.';		options: [ Array with: WAQueryFieldHandlerTrackingStrategy new ];		default: WAQueryFieldHandlerTrackingStrategy new</body></methods><methods><class-id>Seaside.WARenderNotification</class-id> <category>public</category><body package="Seaside-Core">defaultAction	^ WAUnhandledNotificationError signalWithNotification: self</body></methods><methods><class-id>Seaside.WARenderNotification</class-id> <category>testing</category><body package="Seaside-Core">isResumable	^ false</body></methods><methods><class-id>Seaside.WAExceptionFilterConfiguration</class-id> <category>description</category><body package="Seaside-Core">describeOn: config	(config list: #exceptionHandler)		options: [ self exceptionHandlerClasses ];		default: WAErrorHandler</body><body package="Seaside-Core">exceptionHandlerClasses	^ WAExceptionHandler withAllSubclasses asSortedCollection: [ :a :b | a name &lt;= b name ]</body></methods><methods><class-id>Seaside.WARenderer</class-id> <category>public</category><body package="Seaside-Core">absoluteUrlForResource: aString	"Answer a resource URL for aString. The URL will always be absolute (ie. it will begin	with a / or a URL scheme like http://. If aString already looks like a URL, an instance	of WAUrl will be returned for it. If it looks like a path, it will be appended to the	resource base URL configured in the RenderContext if there is one."	^ self context absoluteUrlForResource: aString</body><body package="Seaside-Core">actionBaseUrl	^ self context actionBaseUrl</body><body package="Seaside-Core">actionUrl	^ self context actionUrl</body><body package="Seaside-Core">lastId	"Answer the last identifier that was generated with #nextId."		^ lastId</body><body package="Seaside-Core">nextId	"Answer an identifier string that is unique within this WARenderContext."		^ lastId := 'id', self callbacks advanceKey</body><body package="Seaside-Core">render: anObject	"Render anObject using this Renderer."		anObject renderOn: self</body><body package="Seaside-Core">text: anObject	"Emit anObject onto the target document."	self document print: anObject</body><body package="Seaside-Core">urlForAction: aBlock	"Answer an action URL that will evaluate aBlock when it is requested."	^ self actionUrl withField: (self callbacks store: (WAActionCallback on: aBlock))</body></methods><methods><class-id>Seaside.WARenderer</class-id> <category>accessing</category><body package="Seaside-Core">callbacks	"Answer the callback registry."	^ self context callbacks</body><body package="Seaside-Core">context	"Answer the rendering context."	^ context</body><body package="Seaside-Core">document	^ self context document</body></methods><methods><class-id>Seaside.WARenderer</class-id> <category>private</category><body package="Seaside-Core">flush	"Close any open elements and write any remaining data."</body></methods><methods><class-id>Seaside.WARenderer</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithContext: aRenderContext	self initialize.	context := aRenderContext</body></methods><methods><class-id>Seaside.WARenderer class</class-id> <category>instance creation</category><body package="Seaside-Core">builder	^ WABuilder on: self</body><body package="Seaside-Core">context: aRenderContext	^ self basicNew initializeWithContext: aRenderContext; yourself</body></methods><methods><class-id>Seaside.WARenderer class</class-id> <category>defaults</category><body package="Seaside-Core">default	^ default ifNil: [ default := WARenderer ]</body><body package="Seaside-Core">default: anObject	default := anObject</body><body package="Seaside-Core">resetDefault	WARenderer default: nil</body><body package="Seaside-Core">selectAsDefault	WARenderer default: self</body><body package="Seaside-Core">unselectAsDefault	(WARenderer default = self) ifTrue: [ WARenderer resetDefault ]</body></methods><methods><class-id>Seaside.WAHashCache</class-id> <category>private</category><body package="Seaside-Core">addToAccessEnd: aCacheListEntry	| currentLast |	currentLast := byAccessEnd.	currentLast isNil ifFalse: [		currentLast next: aCacheListEntry.		aCacheListEntry previous: currentLast ].	aCacheListEntry initializeTime.	byAccessEnd := aCacheListEntry.	byAccessStart isNil ifTrue: [		byAccessStart := aCacheListEntry ]</body><body package="Seaside-Core">addToCreationEnd: aCacheListEntry	| currentLast |	currentLast := byCreationEnd.	currentLast isNil ifFalse: [		currentLast next: aCacheListEntry.		aCacheListEntry previous: currentLast ].	byCreationEnd := aCacheListEntry.	byCreationStart isNil ifTrue: [		byCreationStart := aCacheListEntry ]</body><body package="Seaside-Core">at: aKey put: anObject overwrite: aBoolean	| index keyHash entry |	self sweepIncrementally.	self growCheck.	keyHash := aKey hash.	index := (keyHash \\ keyTable size) + 1.	entry := self findEntryOrNilWithKey: aKey hash: keyHash index: index.	entry isNil		ifTrue: [			"no mapping for this key exists"			| cacheEntry byAccessEntry byCreationEntry |			(maximumSize &gt; 0 and: [ size = maximumSize ])				ifTrue: [ self performOverflowAction ].			"create entry"			cacheEntry := WACacheKeyEntry key: aKey value: anObject.			byCreationEntry := WACacheListEntry entry: cacheEntry.			byAccessEntry := WACacheListEntry entry: cacheEntry.			cacheEntry byAccessListEntry: byAccessEntry.			cacheEntry byCreationListEntry: byCreationEntry.			self addToAccessEnd: byAccessEntry.			self addToCreationEnd: byCreationEntry.			self insertKeyEntry: cacheEntry.			size := size + 1 ]		ifFalse: [			"a mapping for this key already exists"			| byAccessListEntry byCreationListEntry |			aBoolean ifFalse: [ ^ false ].						byAccessListEntry := entry byAccessListEntry.			byCreationListEntry := entry byCreationListEntry.			self expunge: byAccessListEntry.			self addToAccessEnd: byAccessListEntry.			self expunge: byCreationListEntry.			self addToCreationEnd: byCreationListEntry.						"notify removal"			self cacheEntryRemoved: entry value.						"update entry"			entry value: anObject ].			^ true</body><body package="Seaside-Core">errorAlreadyMapped	self error: 'Already mapped'</body><body package="Seaside-Core">errorKeyNotFound	self error: 'Key not found'</body><body package="Seaside-Core">errorNotMapped	self error: 'Not mapped'</body><body package="Seaside-Core">expunge: aListEntry	"update list start"	aListEntry == byAccessStart		ifTrue: [ byAccessStart := aListEntry next ].	aListEntry == byCreationStart		ifTrue: [ byCreationStart := aListEntry next ].	"update list end"	aListEntry == byAccessEnd		ifTrue: [ byAccessEnd := aListEntry previous ].	aListEntry == byCreationEnd		ifTrue: [ byCreationEnd := aListEntry previous ].	"fix previous and next pointers"	aListEntry expunge</body><body package="Seaside-Core">findEntryOrNilWithKey: aKey hash: anHashInteger index: anIndexInteger	| entry |	entry := keyTable at: anIndexInteger.	[ entry isNil ] whileFalse: [		(entry keyHash = anHashInteger and: [ entry key = aKey ])			ifTrue: [				| byAccessListEntry |				byAccessListEntry := entry byAccessListEntry.				self expunge: byAccessListEntry.				self addToAccessEnd: byAccessListEntry.				^ entry ]			ifFalse: [ entry := entry next ] ].	^ nil</body><body package="Seaside-Core">growCheck	size &gt; (keyTable size * self loadFactor) ifTrue: [		"rehash for fun"		| newKeyTable newValueTable newTableSize |		newTableSize := WAHashTableSizes atLeast: keyTable size * 2.		newKeyTable := Array new: newTableSize.		newValueTable := Array new: newTableSize.				"rehash keys"		keyTable do: [ :each |			| next current |			current := each.			[ current isNil ] whileFalse: [				| index atTargetIndex |				next := current next.				index := (current keyHash \\ newTableSize) + 1.				atTargetIndex := newKeyTable at: index.				atTargetIndex isNil					ifTrue: [ newKeyTable at: index put: current ]					ifFalse: [						[ atTargetIndex next isNil ] whileFalse: [							atTargetIndex := atTargetIndex next ].						atTargetIndex next: current ].				current next: nil.				current := next ] ].				keyTable := newKeyTable ]</body><body package="Seaside-Core">insertKeyEntry: aCacheEntry	| keyHash key index entry previous |	keyHash := aCacheEntry keyHash.	key := aCacheEntry key.	index := (keyHash \\ keyTable size) + 1.	entry := keyTable at: index.	previous := nil.	[ entry isNil ] whileFalse: [		(entry keyHash = aCacheEntry and: [ entry key = key ])			ifTrue: [				previous isNil					ifTrue: [ keyTable at: index put: aCacheEntry ]					ifFalse: [  previous next: aCacheEntry ].				^ self ]			ifFalse: [				previous := entry.				entry := entry next ] ].	previous isNil		ifTrue: [ keyTable at: index put: aCacheEntry ]		ifFalse: [  previous next: aCacheEntry ]</body><body package="Seaside-Core">loadFactor	^ 0.75</body><body package="Seaside-Core">performOverflowAction	overflowAction == self class signalError ifTrue: [		WAMaximumNumberOfSessionsExceededError signal ].	overflowAction == self class removeAbsoluteOldest ifTrue: [		self removeCacheEntry: byCreationStart cacheEntry ].	overflowAction == self class removeRelativeOldest ifTrue: [		self removeCacheEntry: byAccessStart cacheEntry ]</body><body package="Seaside-Core">removeCacheEntry: aCacheEntry	self removeFromKeyTable: aCacheEntry.	self expunge: aCacheEntry byAccessListEntry.	self expunge: aCacheEntry byCreationListEntry.	self cacheEntryRemoved: aCacheEntry value.		size := size - 1.	^ aCacheEntry value</body><body package="Seaside-Core">removeFromKeyTable: aCacheEntry	| index entry previous |	index := (aCacheEntry keyHash \\ keyTable size) + 1.	entry := keyTable at: index.	previous := nil.	"no need for nil check, it has to be here"	[ aCacheEntry == entry ] whileFalse: [		previous := entry.		entry := entry next ].	previous isNil		ifTrue: [ keyTable at: index put: entry next ]		ifFalse: [ previous next: entry next ]</body><body package="Seaside-Core">sweep: aListRoot maximumAge: anNumberOfSeconds now: currentSeconds	| current |	current := aListRoot.	[ current isNil ] whileFalse: [		(currentSeconds - current time) &gt; anNumberOfSeconds			ifTrue: [				self removeCacheEntry: current cacheEntry.				current := current next ]			ifFalse: [				"the list is ordered so we can stop scanning"				^ self ] ]</body><body package="Seaside-Core">sweepIncrementally	| now |	now := Time totalSeconds.		"absolute timeout sweep"	maximumAbsoluteAge &gt; 0 ifTrue: [		self sweep: byCreationStart maximumAge: maximumAbsoluteAge now: now ].		"relative timeout sweep"	maximumRelativeAge &gt; 0 ifTrue: [		self sweep: byAccessStart maximumAge: maximumRelativeAge now: now ]</body></methods><methods><class-id>Seaside.WAHashCache</class-id> <category>removing</category><body package="Seaside-Core">removeKey: aKey	| keyHash index entry |	self sweepIncrementally.	keyHash := aKey hash.	index := (keyHash \\ keyTable size) + 1.	entry := self findEntryOrNilWithKey: aKey hash: keyHash index: index.	^ entry isNil		ifTrue: [ self errorKeyNotFound ]		ifFalse: [ self removeCacheEntry: entry ]</body></methods><methods><class-id>Seaside.WAHashCache</class-id> <category>putting</category><body package="Seaside-Core">at: aKey put: anObject	self at: aKey put: anObject overwrite: true.			^ anObject</body><body package="Seaside-Core">store: anObject	| candidateKey |	[ 		candidateKey := WAKeyGenerator current keyOfLength: self keySize.		self at: candidateKey put: anObject overwrite: false ] whileFalse.	^ candidateKey</body></methods><methods><class-id>Seaside.WAHashCache</class-id> <category>public</category><body package="Seaside-Core">clear	self keysAndValuesDo: [ :key :value |		self cacheEntryRemoved: value ].	size := 0.	keyTable atAllPut: nil.	byAccessStart := nil.	byAccessEnd := nil.	byCreationStart := nil.	byCreationEnd := nil</body></methods><methods><class-id>Seaside.WAHashCache</class-id> <category>enumerating</category><body package="Seaside-Core">keysAndValuesDo: aTwoArgumentBlock	self sweepIncrementally.	keyTable do: [ :each |		| cacheEntry |		cacheEntry := each.		[ cacheEntry isNil ] whileFalse: [			aTwoArgumentBlock value: cacheEntry key value: cacheEntry value.			cacheEntry := cacheEntry next ] ]</body></methods><methods><class-id>Seaside.WAHashCache</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithInitialSize: aSizeInteger maximumSize: aMaximumSizeInteger maximumAbsoluteAge: aMaximumAbsoluteAge maximumRelativeAge: aMaximumRelativeAge overflowAction: aOverflowActionSymbol	super initializeWithInitialSize: aSizeInteger maximumSize: aMaximumSizeInteger maximumAbsoluteAge: aMaximumAbsoluteAge maximumRelativeAge: aMaximumRelativeAge overflowAction: aOverflowActionSymbol.	size := 0.	keyTable := Array new: aSizeInteger</body></methods><methods><class-id>Seaside.WAHashCache</class-id> <category>accessing</category><body package="Seaside-Core">at: aKey ifAbsent: aBlock	| keyHash index entry |	self sweepIncrementally.	keyHash := aKey hash.	index := (keyHash \\ keyTable size) + 1.	entry := self findEntryOrNilWithKey: aKey hash: keyHash index: index.	^ entry isNil		ifTrue: [ aBlock value ]		ifFalse: [ entry value ]</body><body package="Seaside-Core">size	^ size</body></methods><methods><class-id>Seaside.WAHashCache</class-id> <category>copying</category><body package="Seaside-Core">copy	| copy |	copy := self class initialSize: keyTable size maximumSize: maximumSize maximumAbsoluteAge: maximumAbsoluteAge maximumRelativeAge: maximumRelativeAge overflowAction: overflowAction.	self keysAndValuesDo: [ :key :value |		copy at: key put: value ].	^ copy</body></methods><methods><class-id>Seaside.WAHashCache class</class-id> <category>accessing</category><body package="Seaside-Core">overflowActions	^ Array		with: self removeRelativeOldest		with: self removeAbsoluteOldest		with: self signalError</body><body package="Seaside-Core">removeAbsoluteOldest	^ #removeAbsoluteOldest</body><body package="Seaside-Core">removeRelativeOldest	^ #removeRelativeOldest</body><body package="Seaside-Core">signalError	^ #signalError</body></methods><methods><class-id>Seaside.WAClosingConditionalComment</class-id> <category>printing</category><body package="Seaside-Core">encodeOn: aDocument	aDocument nextPutAll: '&lt;![endif]--&gt;'</body></methods><methods><class-id>Seaside.WAHtmlDocument</class-id> <category>accessing</category><body package="Seaside-Core">scriptGenerator	^ scriptGenerator ifNil: [ scriptGenerator := WADefaultScriptGenerator new ]</body><body package="Seaside-Core">scriptGenerator: aScriptGenerator	scriptGenerator := aScriptGenerator</body></methods><methods><class-id>Seaside.WAHtmlDocument</class-id> <category>scripting</category><body package="Seaside-Core">addLoadScript: anObject	^ self scriptGenerator addLoadScript: anObject</body><body package="Seaside-Core">addLoadScriptFirst: anObject	^ self scriptGenerator addLoadScriptFirst: anObject</body><body package="Seaside-Core">loadScripts	^ self scriptGenerator loadScripts</body></methods><methods><class-id>Seaside.WANumberAttribute</class-id> <category>visiting</category><body package="Seaside-Core">accept: aVisitor	aVisitor visitNumberAttribute: self</body></methods><methods><class-id>Seaside.WANumberAttribute</class-id> <category>converting</category><body package="Seaside-Core">valueFromString: aString	^ aString isEmptyOrNil ifFalse: [ Number readFrom: aString readStream ]</body></methods><methods><class-id>Seaside.WAComboResponse</class-id> <category>initialization</category><body package="Seaside-Core">close	"Send a zero-sized chunk to end the data transfer."	closed ifTrue: [ self error: 'Response is closed' ].	externalStream nextPutAll: '0'; crlf; crlf; flush.	closed := true</body><body package="Seaside-Core">commit	"Begin a partial transmission"	self committedCheck.	"Send the http request header and set the receiver to chunked encoding"	self headerAt: 'Transfer-Encoding' put: 'chunked'.	committed := true.	self writeStatusOn: externalStream.	self writeHeadersOn: externalStream.	self writeCookiesOn: externalStream.	externalStream crlf; flush</body><body package="Seaside-Core">destroy	"Destroy the receiver"	super destroy.	bufferedStream := nil.	externalStream := nil</body><body package="Seaside-Core">initialize	"Initialize the receiver"	super initialize.	bufferedStream := GRPlatform current readWriteCharacterStream.	committed := false.	closed := false</body><body package="Seaside-Core">initializeOnBuffered: aBufferedStream external: anExternalStream	"Initialize the receiver"	self initialize.	bufferedStream := aBufferedStream.	externalStream := anExternalStream.	committed := false.	closed := false</body></methods><methods><class-id>Seaside.WAComboResponse</class-id> <category>accessing-status</category><body package="Seaside-Core">status: aNumber message: aString	"Set the response status. Raises an error if the response is committed."	self committedCheck.	^ super status: aNumber message: aString</body></methods><methods><class-id>Seaside.WAComboResponse</class-id> <category>convenience</category><body package="Seaside-Core">resetIfPossible	^ committed		ifTrue: [ false ]		ifFalse: [			self initializeFields.			bufferedStream reset.			true ]</body></methods><methods><class-id>Seaside.WAComboResponse</class-id> <category>streaming</category><body package="Seaside-Core">binary	"put the response stream into binary mode"	bufferedStream := (GRCountingStream on: (GRPlatform current readWriteByteStream)).	externalStream binary</body><body package="Seaside-Core">nextChunk: anInteger put: data	"Write a chunk of data to the external stream. Does NOT write if no data is provided since this would logically end the chunked transfer. To end data transfer use #close instead. Raise an error if the response has been committed and closed.		Unfortunately the size of the chunk is not measured in bytes but characters so we need the ability to pass in the chunk size	see also	http://code.google.com/p/seaside/issues/detail?id=733"	data isEmpty ifTrue: [ ^ self ].	closed ifTrue: [ self error: 'Response is closed' ].	externalStream nextPutAll: (anInteger printStringBase: 16); crlf.	externalStream nextPutAll: data; crlf; flush</body><body package="Seaside-Core">nextChunkPut: data	"Write a chunk of data to the external stream. Does NOT write if no data is provided since this would logically end the chunked transfer. To end data transfer use #close instead. Raise an error if the response has been committed and closed."	self nextChunk: data size put: data</body></methods><methods><class-id>Seaside.WAComboResponse</class-id> <category>accessing</category><body package="Seaside-Core">bufferedStream	"The stream to buffer data before sending it"	^ bufferedStream</body><body package="Seaside-Core">bufferedStream: aStream	"The stream to buffer data before sending it"	bufferedStream := aStream</body><body package="Seaside-Core">contents	"Answer the contents of the response. If the response is streaming, answer nil"	^ committed ifFalse: [ bufferedStream contents ]</body><body package="Seaside-Core">externalStream	"The external (socket) stream to send data to"	^ externalStream</body><body package="Seaside-Core">externalStream: aSocketStream	"The external (socket) stream to send data to"	externalStream := aSocketStream</body><body package="Seaside-Core">stream	"This answers the BUFFERED stream; to actually send the partial data you must #flush it"	^ bufferedStream</body></methods><methods><class-id>Seaside.WAComboResponse</class-id> <category>private</category><body package="Seaside-Core">isChunked	^ (self headerAt: 'Transfer-Encoding' ifAbsent: [ nil ]) = 'chunked'</body></methods><methods><class-id>Seaside.WAComboResponse</class-id> <category>accessing-cookies</category><body package="Seaside-Core">addCookie: aCookie	"Add aCookie to the receiver. Raise an error if the response is committed."	self committedCheck.	^ super addCookie: aCookie</body></methods><methods><class-id>Seaside.WAComboResponse</class-id> <category>writing</category><body package="Seaside-Core">writeContentOn: aStream	committed ifFalse: [ 		aStream nextPutAll: self contents ]</body><body package="Seaside-Core">writeHeadersOn: aStream	self isChunked ifFalse: [		self 		headerAt: 'Content-Length'		put: bufferedStream position ].	super writeHeadersOn: aStream</body></methods><methods><class-id>Seaside.WAComboResponse</class-id> <category>accessing-headers</category><body package="Seaside-Core">headerAt: aString append: aValue	"Appends a response header. Raises an error if the respone is committed."	self committedCheck.	^ super headerAt: aString append: aValue</body><body package="Seaside-Core">headerAt: aString put: aValue	"Sets a response header. Raises an error if the response is committed"	self committedCheck.	^ super headerAt: aString put: aValue</body><body package="Seaside-Core">removeHeaderAt: aString	"Removes all occurences of the header. Raises an error if the response is committed."	self committedCheck.	^ super removeHeaderAt: aString</body></methods><methods><class-id>Seaside.WAComboResponse</class-id> <category>testing</category><body package="Seaside-Core">isCommitted	"Return true if the response is committed, i.e., (partially) transmitted"	^ committed</body><body package="Seaside-Core">isStreamingResponse	"Return true if the receiver supports partial stream responses."	^ true</body></methods><methods><class-id>Seaside.WAComboResponse</class-id> <category>public</category><body package="Seaside-Core">flush	"Flush the receiver and send partial content"	committed ifFalse: [ self commit ].	"Write the partial content if any"	self nextChunk: bufferedStream count put: bufferedStream contents.	bufferedStream reset</body></methods><methods><class-id>Seaside.WAComboResponse</class-id> <category>errors</category><body package="Seaside-Core">committedCheck	"Raises a signal if this response is already committed."	self isCommitted 		ifTrue: [ WAIllegalStateException signal ]</body></methods><methods><class-id>Seaside.WAComboResponse class</class-id> <category>instance creation</category><body package="Seaside-Core">external: anExternalStream	^ self		onBuffered: (GRPlatform current writeCharacterStreamOn: (String new: 4096))		external: anExternalStream</body><body package="Seaside-Core">onBuffered: aBufferedStream external: anExternalStream	^ self basicNew initializeOnBuffered: aBufferedStream external: anExternalStream</body></methods><methods><class-id>Seaside.WAUploadCallback</class-id> <category>converting</category><body package="Seaside-Core">valueForField: anObject	^ (anObject isKindOf: WAFile) ifTrue: [ anObject ]</body></methods><methods><class-id>Seaside.WAAllUploadsCallback</class-id> <category>evaluation</category><body package="Seaside-Core">evaluateWithFieldValues: anOrderedCollection	self evaluateWithArgument: ((anOrderedCollection		collect: [ :each | self valueForField: each])		reject: [ :each | each isNil ])</body></methods><methods><class-id>Seaside.WAConcatenatedHtmlAttributeValue</class-id> <category>public</category><body package="Seaside-Core">addValue: anObject	values add: anObject</body></methods><methods><class-id>Seaside.WAConcatenatedHtmlAttributeValue</class-id> <category>testing</category><body package="Seaside-Core">isConcatenatedHtmlAttributeValue	^ true</body></methods><methods><class-id>Seaside.WAConcatenatedHtmlAttributeValue</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithSeparator: aSeparator value: anFirstObject value: aSecondObject	self initialize.	separator := aSeparator.	values := OrderedCollection new: 4.	values add: anFirstObject.	values add: aSecondObject</body></methods><methods><class-id>Seaside.WAConcatenatedHtmlAttributeValue</class-id> <category>printing</category><body package="Seaside-Core">encodeOn: aDocument 	values		do: [ :each | aDocument print: each ]		separatedBy: [ aDocument print: separator ]</body></methods><methods><class-id>Seaside.WAConcatenatedHtmlAttributeValue class</class-id> <category>instance creation</category><body package="Seaside-Core">separator: aSeparator value: anFirstObject value: aSecondObject	^ self basicNew initializeWithSeparator: aSeparator value: anFirstObject value: aSecondObject</body></methods><methods><class-id>Seaside.WAClassBindingCollectionAttribute</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithKey: aSymbol	super initializeWithKey: aSymbol.	self default: #()</body></methods><methods><class-id>Seaside.WAClassBindingCollectionAttribute</class-id> <category>accessing</category><body package="Seaside-Core">default: aCollection	default := aCollection collect: [ :each |		GRPlatform current bindingOf: each ]</body></methods><methods><class-id>Seaside.WAClassBindingCollectionAttribute</class-id> <category>visiting</category><body package="Seaside-Core">accept: aVisitor	aVisitor visitClassBindingCollectionAttribute: self</body></methods><methods><class-id>Seaside.WAClassBindingCollectionAttribute</class-id> <category>testing</category><body package="Seaside-Core">isCollectionAttribute	^ true</body></methods><methods><class-id>Seaside.WASnapshot</class-id> <category>actions</category><body package="Seaside-Core">reset	"Clears the snapshot dictionary."	objects := IdentityDictionary new</body><body package="Seaside-Core">restore	"Restore all the backtracked states."	objects keysAndValuesDo: [ :key :value | key restoreFromSnapshot: value ]</body><body package="Seaside-Core">snapshot	"Snapshot all the states that have been registered for backtracking overriding existing snapshots."	objects associationsDo: [ :assoc | assoc value: assoc key snapshotCopy ]</body></methods><methods><class-id>Seaside.WASnapshot</class-id> <category>initialization</category><body package="Seaside-Core">initialize	super initialize.	self reset</body></methods><methods><class-id>Seaside.WASnapshot</class-id> <category>registry</category><body package="Seaside-Core">register: anObject	"Register anObject for backtracking."	anObject isNil		ifFalse: [ objects at: anObject put: anObject snapshotCopy ]</body></methods><methods><class-id>Seaside.WAMimeType</class-id> <category>accessing</category><body package="Seaside-Core">main	^ main</body><body package="Seaside-Core">main: aString	main := aString</body><body package="Seaside-Core">parameters	parameters isNil ifTrue: [ parameters := GRSmallDictionary new ].	^ parameters</body><body package="Seaside-Core">parameters: aDictionary	parameters := aDictionary</body><body package="Seaside-Core">sub	^ sub</body><body package="Seaside-Core">sub: aString	sub := aString</body></methods><methods><class-id>Seaside.WAMimeType</class-id> <category>converting</category><body package="Seaside-Core">greaseString	| stringSize string stream |	stringSize := main size + 1 + sub size.	parameters isNil ifFalse: [		parameters keysAndValuesDo: [ :key :value |			stringSize := stringSize + 1 + key size + 1 + value size ] ].	"allocate with correct size, avoid copy"	string := String new: stringSize.	stream := WriteStream on: string.	stream		nextPutAll: main;		nextPut: $/;		nextPutAll: sub.	parameters isNil ifFalse: [		parameters keysAndValuesDo: [ :key :value | 			stream				nextPut: $;;				nextPutAll: key;				nextPut: $=;				nextPutAll: value ] ].	"no need for #contents because we allocated with the correct size"	^ string</body><body package="Seaside-Core">seasideMimeType	^ self</body></methods><methods><class-id>Seaside.WAMimeType</class-id> <category>parameters</category><body package="Seaside-Core">charSet	^ self parameters at: 'charset' ifAbsent: [ nil ]</body><body package="Seaside-Core">charset: aString	self parameters at: 'charset' put: aString</body><body package="Seaside-Core">parameterAt: aKey put: aValue	self parameters at: aKey put: aValue</body></methods><methods><class-id>Seaside.WAMimeType</class-id> <category>printing</category><body package="Seaside-Core">printOn: aStream 	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self greaseString;		nextPut: $)</body></methods><methods><class-id>Seaside.WAMimeType</class-id> <category>testing</category><body package="Seaside-Core">isBinary	"answers whether the contents of a document of the receiving mime type are binary"	self main = 'text' ifTrue: [ ^ false ].	self main = 'application'		ifTrue: [			"application/json is text"			self sub = 'json' ifTrue: [ ^ false ] ]		ifFalse: [ ^ true ].	GRPlatform subStringsIn: self sub splitBy: $+ do: [ :each |		"application/x-javascript and application/xml are text"		(#('x-javascript' 'xml') includes: each)			ifTrue: [ ^ false ] ].	^ true</body><body package="Seaside-Core">isNonStandard	"tests if the receiver is a non-standard mime type that is not registered with IANA"	^ (self main beginsWithSubCollection: 'x-')		or: [ (self main beginsWithSubCollection: 'X-')		or: [ (self sub beginsWithSubCollection: 'x-')		or: [ self sub beginsWithSubCollection: 'X-' ] ] ]</body><body package="Seaside-Core">isVendorSpecific	"tests if the receiver is a vendor specific mimetype"	^ self sub beginsWithSubCollection: 'vnd.'</body><body package="Seaside-Core">matches: aMimeType	"aMimeType is the pattern to match, it is a normal WAMimeType instance where main or sub can be wildcards"	^ (aMimeType main = '*'		or: [ aMimeType main = self main ])		and: [			aMimeType sub = '*'				or: [ aMimeType sub = self sub ] ]</body></methods><methods><class-id>Seaside.WAMimeType</class-id> <category>comparing</category><body package="Seaside-Core">= other	^ (other isKindOf: WAMimeType)		and: [ self main = other main		and: [ self sub = other sub ] ]</body><body package="Seaside-Core">hash	^ self main hash bitXor: self sub hash</body></methods><methods><class-id>Seaside.WAMimeType class</class-id> <category>convenience</category><body package="Seaside-Core">applicationAtomXml	^ self main: 'application' sub: 'atom+xml'</body><body package="Seaside-Core">applicationJson	^ self main: 'application' sub: 'json'</body><body package="Seaside-Core">applicationOctetStream	^ self main: 'application' sub: 'octet-stream'</body><body package="Seaside-Core">applicationRssXml	^ self main: 'application' sub: 'rss+xml'</body><body package="Seaside-Core">formUrlencoded	^ self main: 'application' sub: 'x-www-form-urlencoded'</body><body package="Seaside-Core">imageGif	^ self main: 'image' sub: 'gif'</body><body package="Seaside-Core">imageJpeg	^ self main: 'image' sub: 'jpeg'</body><body package="Seaside-Core">imagePng	^ self main: 'image' sub: 'png'</body><body package="Seaside-Core">textCss	^ self main: 'text' sub: 'css'</body><body package="Seaside-Core">textHtml	^ self main: 'text' sub: 'html'</body><body package="Seaside-Core">textJavascript	^ self main: 'text' sub: 'javascript'</body><body package="Seaside-Core">textPlain	^ self main: 'text' sub: 'plain'</body></methods><methods><class-id>Seaside.WAMimeType class</class-id> <category>instance creation</category><body package="Seaside-Core">fromString: aString 	| main endOfSub sub parameters slashIndex |	slashIndex := aString indexOf: $/.	slashIndex = 0		ifTrue: [			"work arount for Issue 655			some user agents just send '*', not '*/*'"			endOfSub := aString indexOf: $;.			endOfSub = 0				ifTrue: [					main := aString.					endOfSub := aString size ]				ifFalse: [					main := aString copyFrom: 1 to: endOfSub - 1 ].			sub := main ]		ifFalse: [			main := aString copyUpTo: $/.			endOfSub := aString indexOf: $;.			endOfSub := endOfSub = 0 				ifTrue: [ aString size ]				ifFalse: [ endOfSub - 1 ].			sub := aString 				copyFrom: main size + 2				to: endOfSub ].	endOfSub = aString size ifTrue: [		^ self 			main: main			sub: sub ].	parameters := GRSmallDictionary new.	GRPlatform subStringsIn: (aString copyFrom: endOfSub + 1 to: aString size) splitBy: $; do: [ :each |		parameters 			at: (each copyUpTo: $=) trimBoth			put: (each copyAfter: $=) trimBoth ].	^ self 		main: main		sub: sub		parameters: parameters</body><body package="Seaside-Core">main: aMainString sub: aSubString	^ self new		main: aMainString;		sub: aSubString;		yourself</body><body package="Seaside-Core">main: aMainString sub: aSubString parameters: aDictionary	^ (self main: aMainString sub: aSubString)		parameters: aDictionary;		yourself</body></methods><methods><class-id>Seaside.WARenderVisitor</class-id> <category>visiting</category><body package="Seaside-Core">visitPainter: aPainter 	| renderer |	renderer := aPainter rendererClass context: self renderContext.	aPainter renderContentOn: renderer.	renderer flush</body></methods><methods><class-id>Seaside.WARenderVisitor</class-id> <category>accessing</category><body package="Seaside-Core">renderContext	^ renderContext</body></methods><methods><class-id>Seaside.WARenderVisitor</class-id> <category>copying</category><body package="Seaside-Core">postCopyForRenderContext: aRenderContext	super postCopyForRenderContext: aRenderContext.	renderContext := aRenderContext</body></methods><methods><class-id>Seaside.WARenderVisitor</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithContext: aRenderContext	self initialize.	renderContext := aRenderContext</body></methods><methods><class-id>Seaside.WARenderVisitor class</class-id> <category>instance creation</category><body package="Seaside-Core">context: aRenderContext	^ self basicNew		initializeWithContext: aRenderContext;		yourself</body></methods><methods><class-id>Seaside.WAAuthConfigurationError</class-id> <category>accessing</category><body package="Seaside-Core">seasidePossibleCauses	^ #('No WAAuthConfiguration has been added to the application.')</body></methods><methods><class-id>Seaside.WAUrlCallback</class-id> <category>converting</category><body package="Seaside-Core">valueForField: anObject	^ anObject isEmptyOrNil		ifTrue: [ nil ]		ifFalse: [ WAUrl absolute: anObject ]</body></methods><methods><class-id>Seaside.WAScriptGenerator</class-id> <category>actions</category><body package="Seaside-Core">close: aHtmlRoot on: aDocument	"This method is called before the document is closed."</body><body package="Seaside-Core">closeOn: aDocument	"This method is called to close the document that has no root."		self loadScripts isEmpty 		ifTrue: [ ^ self ].	self 		writeScriptTag: [ self writeLoadScriptsOn: aDocument ]		on: aDocument</body><body package="Seaside-Core">open: aHtmlRoot on: aDocument	"This method is called before the document is opened."</body></methods><methods><class-id>Seaside.WAScriptGenerator</class-id> <category>accessing</category><body package="Seaside-Core">addLoadScript: anObject	"Add a script anObject to the receiver. This method ensures all scripts to run in the added order when the DOM is ready. Note that the default implementation calls the scripts when the page has finished loading."		^ loadScripts addLast: anObject</body><body package="Seaside-Core">addLoadScriptFirst: anObject	"Add a script anObject at the beginning of the load scripts."		^ loadScripts addFirst: anObject</body><body package="Seaside-Core">loadScripts	"Answer the load scripts of the receiver. These scripts will be evaluated in order when the page has loaded."	^ loadScripts</body></methods><methods><class-id>Seaside.WAScriptGenerator</class-id> <category>public</category><body package="Seaside-Core">event: aString do: anObject on: aBrush	"Attaches the Javscript anObject to the event aString of aBrush. This default implementation simply inlines the Javascript code into the brush; subclasses might override this to do something more meaningful."		aBrush attributes at: 'on' , aString append: anObject separator: ';'</body></methods><methods><class-id>Seaside.WAScriptGenerator</class-id> <category>initialization</category><body package="Seaside-Core">initialize	super initialize.	loadScripts := OrderedCollection new</body></methods><methods><class-id>Seaside.WAScriptGenerator</class-id> <category>private</category><body package="Seaside-Core">writeLoadScriptsOn: aDocument	"Utility method to write the receivers load scripts onto aDocument."	self loadScripts do: [ :each |		aDocument stream javascript: each.		aDocument  nextPut: $; ]</body><body package="Seaside-Core">writeScriptTag: aBlock on: aDocument	"Utitlity method to properly wrap the script generation code in aBlock onto aDocument."	| attributes |	attributes := WAHtmlAttributes new.	attributes at: 'type' put: 'text/javascript'.	aDocument openTag: 'script' attributes: attributes.	aBlock value.	aDocument closeTag: 'script'</body></methods><methods><class-id>Seaside.WAStringAttribute</class-id> <category>converting</category><body package="Seaside-Core">valueFromString: aString	^ aString isEmptyOrNil ifFalse: [ aString ]</body></methods><methods><class-id>Seaside.WAStringAttribute</class-id> <category>visiting</category><body package="Seaside-Core">accept: aVisitor	aVisitor visitStringAttribute: self</body></methods><methods><class-id>Seaside.WAResponseNotification</class-id> <category>public</category><body package="Seaside-Core">defaultAction	^ WAUnhandledNotificationError signalWithNotification: self</body></methods><methods><class-id>Seaside.WAResponseNotification</class-id> <category>testing</category><body package="Seaside-Core">isResumable	^ false</body></methods><methods><class-id>Seaside.WASharedConfiguration</class-id> <category>testing</category><body package="Seaside-Core">isShared	^ true</body></methods><methods><class-id>Seaside.WASharedConfiguration</class-id> <category>accessing</category><body package="Seaside-Core">name	^ name</body></methods><methods><class-id>Seaside.WASharedConfiguration</class-id> <category>actions</category><body package="Seaside-Core">unregister	self class unregister: self</body></methods><methods><class-id>Seaside.WASharedConfiguration</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithName: aString	self initialize.	name := aString</body></methods><methods><class-id>Seaside.WASharedConfiguration class</class-id> <category>instance creation</category><body package="Seaside-Core">named: aString	"Answer a shared configuration with the given name aString or answer a newly created one."		^ instances		detect: [ :each | each name = aString ]		ifNone: [			instances add: (self basicNew				initializeWithName: aString;				yourself) ]</body><body package="Seaside-Core">new	self error: 'Create or retrieve shared configurations by sending the message #named:'</body><body package="Seaside-Core">unregister: aConfiguration	"Removes aConfiguration from the list of known configurations."		^ instances remove: aConfiguration ifAbsent: [ nil ]</body></methods><methods><class-id>Seaside.WASharedConfiguration class</class-id> <category>accessing</category><body package="Seaside-Core">configurations	^ instances copy</body></methods><methods><class-id>Seaside.WASharedConfiguration class</class-id> <category>initialization</category><body package="Seaside-Core">initialize	instances isNil ifTrue: [		instances := Set new ]</body></methods><methods><class-id>Seaside.WAAccept class</class-id> <category>private</category><body package="Seaside-Core">valueClass	^ WAMimeType</body></methods><methods><class-id>Seaside.WAFile</class-id> <category>accessing</category><body package="Seaside-Core">contentType	^ contentType</body><body package="Seaside-Core">contentType: aMimeTypeOrString	contentType := aMimeTypeOrString isNil		ifFalse: [ aMimeTypeOrString seasideMimeType ]</body><body package="Seaside-Core">contents: aByteArray	contents := aByteArray</body><body package="Seaside-Core">contentsDecoded	"Answer the contents decoded using the character set in the part header. Signal an error if not character set is present in the part header."	| type charSet |	type := self contentType.	charSet := type isNil ifFalse: [ type charSet ].	^ charSet isNil		ifTrue: [ WAIllegalStateException signal: 'no character set of file upload can not be determined' ]		ifFalse: [ self contentsDecodedUsing: charSet ]</body><body package="Seaside-Core">contentsDecodedUsing: aCharSetName	"Answer the contents decoded using the given character set name."	^ (GRCodec forEncoding: aCharSetName) decode: self rawContents</body><body package="Seaside-Core">fileName	"compensate for windows explorer behavior"	^ self isWindowsPath		ifTrue: [ fileName copyAfterLast: $\ ]		ifFalse: [ fileName ]</body><body package="Seaside-Core">fileName: aString	fileName := aString</body><body package="Seaside-Core">rawContents	"Answer the raw, undecoded contents as sent by the user agent as a ByteArray.		Use #contentsDecoded or #contentsDecodeUsing: to access the decoded contents."		^ contents</body><body package="Seaside-Core">size	"the file size in bytes"	^ self rawContents size</body></methods><methods><class-id>Seaside.WAFile</class-id> <category>private</category><body package="Seaside-Core">isWindowsPath	"'#:\*' match: fileName is broken on Squeak for WideString arguments"	^ fileName notEmpty		and: [ fileName first isLetter		and: [ fileName size &gt;= 3		and: [ (fileName copyFrom: 2 to: 3) = ':\' ] ] ]</body></methods><methods><class-id>Seaside.WAMutualExclusionCache</class-id> <category>putting</category><body package="Seaside-Core">at: aKey put: anObject	^ mutex critical: [		cache at: aKey put: anObject ]</body><body package="Seaside-Core">store: anObject	^ mutex critical: [		cache store: anObject ]</body></methods><methods><class-id>Seaside.WAMutualExclusionCache</class-id> <category>accessing</category><body package="Seaside-Core">at: aKey ifAbsent: aBlock	^ mutex critical: [		cache at: aKey ifAbsent: aBlock ]</body><body package="Seaside-Core">keyAtValue: anObject ifAbsent: aBlock	^ mutex critical: [		cache keyAtValue: anObject ifAbsent: aBlock ]</body><body package="Seaside-Core">keySize	^ mutex critical: [		cache keySize ]</body><body package="Seaside-Core">size	^ mutex critical: [		cache size ]</body><body package="Seaside-Core">underlyingCache	^ cache</body></methods><methods><class-id>Seaside.WAMutualExclusionCache</class-id> <category>copying</category><body package="Seaside-Core">postCopy	super postCopy.	mutex := WAMutex new.	cache := cache copy</body></methods><methods><class-id>Seaside.WAMutualExclusionCache</class-id> <category>removing</category><body package="Seaside-Core">remove: anObject	^ mutex critical: [		cache remove: anObject ]</body><body package="Seaside-Core">removeKey: aKey	^ mutex critical: [		cache removeKey: aKey ]</body></methods><methods><class-id>Seaside.WAMutualExclusionCache</class-id> <category>initialization</category><body package="Seaside-Core">initializeOn: aCache	self initialize.	mutex := WAMutex new.	cache := aCache</body></methods><methods><class-id>Seaside.WAMutualExclusionCache</class-id> <category>public</category><body package="Seaside-Core">clear	^ mutex critical: [		cache clear ]</body></methods><methods><class-id>Seaside.WAMutualExclusionCache</class-id> <category>enumerating</category><body package="Seaside-Core">keysAndValuesDo: aTwoArgumentBlock	^ mutex critical: [		cache keysAndValuesDo: aTwoArgumentBlock ]</body></methods><methods><class-id>Seaside.WAMutualExclusionCache class</class-id> <category>instance creation</category><body package="Seaside-Core">on: aCache	^ self basicNew initializeOn: aCache; yourself</body></methods><methods><class-id>Seaside.WAAllEmailsCallback</class-id> <category>converting</category><body package="Seaside-Core">valueForField: anObject	^ anObject isEmptyOrNil		ifTrue: [ nil ]		ifFalse: [ WAEmailAddress address: anObject ]</body></methods><methods><class-id>Seaside.WAResponseGenerator</class-id> <category>accessing</category><body package="Seaside-Core">request	"Answer the current request."	^ self requestContext request</body><body package="Seaside-Core">requestContext	"Answer the current request context."	^ requestContext</body><body package="Seaside-Core">response	"Answer the current response."	^ self requestContext response</body></methods><methods><class-id>Seaside.WAResponseGenerator</class-id> <category>actions</category><body package="Seaside-Core">respond	"Tell the current request context to return the response."	self requestContext respond</body></methods><methods><class-id>Seaside.WAResponseGenerator</class-id> <category>initialization</category><body package="Seaside-Core">initializeOn: aRequestContext	self initialize.	requestContext := aRequestContext</body></methods><methods><class-id>Seaside.WAResponseGenerator</class-id> <category>generation</category><body package="Seaside-Core">authenticate: aString	"Asks for authentication to the domain aString."	self ifResetPossible: [		self response basicAuthenticationRealm: aString ]</body><body package="Seaside-Core">expiredRegistryKey	"The session key has expired, redirect the request to the home directory preserving the path as good as possible."	| url |	self request isXmlHttpRequest		ifTrue: [ ^ self forbidden ].	url := self requestContext registry url.	url addAllToPath: self requestContext consumer upToEnd.	self request fields keysAndValuesDo: [ :key :value |		(url isSeasideField: key) 			ifFalse: [ url addField: key value: value ] ].	self redirectTo: url</body><body package="Seaside-Core">forbidden	"The resource is forbidden to access and the request was not processed."	| response |	self makePlainTextAndPerform: #forbidden.	response := self response.	response nextPutAll: 'Error: you are forbidden to access "'.	self request url pathUnencodedOn: response.	response nextPutAll: '"'</body><body package="Seaside-Core">internalError: anException	"An internal error occurred while processing the request."	self makePlainTextAndPerform: #internalError.	self response		nextPutAll: 'Internal Error: ';		nextPutAll: (anException messageText ifNil: [ String new ])</body><body package="Seaside-Core">notFound	"The resource could not be found and the request processing was aborted."	| response |	self makePlainTextAndPerform: #notFound.	response := self response.	self request url pathUnencodedOn: response.	response nextPutAll: ' not found'</body><body package="Seaside-Core">notImplemented	"The functionality requested is not implemented and the request processing was aborted."	self makePlainTextAndPerform: #notImplemented.	self response		nextPutAll: 'Not Implemented'</body><body package="Seaside-Core">pageExpired	"The page is no longer in the cache and the request could not be processed."	self makePlainTextAndPerform: #doNotCache.	self response		nextPutAll: 'This page has expired, please use the back-button to navigate to the last valid page.'</body><body package="Seaside-Core">redirectTo: aUrlOrString	"Redirect to a new location."		| oldCookies |	"resetting the response also resets the cookies	however in the case of a redirect we want to keep the cookies	(for adding and deleting session cookies)"	oldCookies := self response cookies.	self ifResetPossible: [		oldCookies do: [ :each |			self response addCookie: each ].		self response			redirectTo: aUrlOrString ]</body><body package="Seaside-Core">refreshAfter: aDuration location: aUrl message: aString 	"Show aString for aDuration, then redirect to aUrl."	self ifResetPossible: [		| mimeType |		mimeType := WAMimeType textPlain.		mimeType charSet: self request charSet.		self response			contentType: mimeType;			refreshAfter: aDuration				location: aUrl				message: aString , (String with: Character cr) , 'You are being redirected to ' , aUrl greaseString ]</body></methods><methods><class-id>Seaside.WAResponseGenerator</class-id> <category>private</category><body package="Seaside-Core">ifResetPossible: aBlock	self response resetIfPossible ifTrue: [		aBlock value ]</body><body package="Seaside-Core">makePlainTextAndPerform: aSelector	"Changes the content type to text/plain and then performs the selector if possible."	self ifResetPossible: [		| mimeType response |		response := self response.		response perform: aSelector.		mimeType := WAMimeType textPlain.		mimeType charset: self requestContext charSet.		response contentType: mimeType ]</body></methods><methods><class-id>Seaside.WAResponseGenerator class</class-id> <category>instance creation</category><body package="Seaside-Core">on: aRequestContext	^ self basicNew initializeOn: aRequestContext</body></methods><methods><class-id>Seaside.WAIntegerAttribute</class-id> <category>visiting</category><body package="Seaside-Core">accept: aVisitor	aVisitor visitIntegerAttribute: self</body></methods><methods><class-id>Seaside.WAIntegerAttribute</class-id> <category>converting</category><body package="Seaside-Core">valueFromString: aString 	^ aString isEmptyOrNil ifFalse: [ aString greaseInteger ]</body></methods><methods><class-id>Seaside.WAServerManager</class-id> <category>accessing</category><body package="Seaside-Core">adaptors	^ adaptors copy</body><body package="Seaside-Core">register: aServerAdaptor	^ adaptors add: aServerAdaptor</body><body package="Seaside-Core">unregister: aServerAdaptor	self stop: aServerAdaptor.	adaptors remove: aServerAdaptor.	aServerAdaptor unregistered.	^ aServerAdaptor</body></methods><methods><class-id>Seaside.WAServerManager</class-id> <category>starting/stopping</category><body package="Seaside-Core">restart: aServerAdaptor	self stop: aServerAdaptor.	self start: aServerAdaptor</body><body package="Seaside-Core">restartAll	adaptors do: [ :each | each restart ]</body><body package="Seaside-Core">start: aServerAdaptor	(self canStart: aServerAdaptor) ifTrue: [		[ aServerAdaptor basicStart ]			ifCurtailed: [ self stop: aServerAdaptor ] ]</body><body package="Seaside-Core">startAll	adaptors do: [ :each | each start ]</body><body package="Seaside-Core">stop: aServerAdaptor	(self canStop: aServerAdaptor) ifTrue: [ aServerAdaptor basicStop ]</body><body package="Seaside-Core">stopAll	adaptors do: [ :each | each stop ]</body></methods><methods><class-id>Seaside.WAServerManager</class-id> <category>initialization</category><body package="Seaside-Core">initialize	super initialize.	adaptors := OrderedCollection new</body></methods><methods><class-id>Seaside.WAServerManager</class-id> <category>private</category><body package="Seaside-Core">canStart: aServerAdaptor	"Because we can't rely on the socket refusing to listen on a port already in use, we simply check here if we know of another adaptor using this adaptor's port"	^ aServerAdaptor isStopped 			and: [ self adaptors noneSatisfy: [ :adaptor | 				adaptor ~= aServerAdaptor					and: [ adaptor port = aServerAdaptor port					and: [ adaptor isStopped not ] ] ] ]</body><body package="Seaside-Core">canStop: aServerAdaptor	^ aServerAdaptor isStopped not</body></methods><methods><class-id>Seaside.WAServerManager class</class-id> <category>system startup</category><body package="Seaside-Core">shutDown	self default adaptors do: [ :each | each shutDown ]</body><body package="Seaside-Core">startUp	self default adaptors do: [ :each | each startUp ]</body></methods><methods><class-id>Seaside.WAServerManager class</class-id> <category>class initialization</category><body package="Seaside-Core">initialize	self initializeDefaultValueHolder.	GRPlatform current		addToStartUpList: self;		addToShutDownList: self</body><body package="Seaside-Core">initializeDefaultValueHolder	default isNil ifTrue: [ 		default := GRPlatform current newTransientValueHolder ]</body><body package="Seaside-Core">unload	GRPlatform current		removeFromStartUpList: self;		removeFromShutDownList: self</body></methods><methods><class-id>Seaside.WAServerManager class</class-id> <category>accessing</category><body package="Seaside-Core">default	default contents ifNil: [ default contents: self new ].	^ default contents</body></methods><methods><class-id>Seaside.WAScriptElement</class-id> <category>attributes</category><body package="Seaside-Core">defer	"When set, this boolean attribute provides a hint to the user agent that the script is not going to generate any document content (e.g., no 'document.write' in javascript) and thus, the user agent can continue parsing and rendering."		self attributeAt: 'defer' put: true</body><body package="Seaside-Core">url: aString	self attributeAt: 'src' put: aString</body></methods><methods><class-id>Seaside.WAScriptElement</class-id> <category>accessing</category><body package="Seaside-Core">tag	^ 'script'</body></methods><methods><class-id>Seaside.WAScriptElement</class-id> <category>types</category><body package="Seaside-Core">beJavascript	self type: WAMimeType textJavascript</body></methods><methods><class-id>Seaside.WARequestContext</class-id> <category>accessing-dynamic</category><body package="Seaside-Core">handler	"Answer the current RequestHandler or nil."	^ self handlers isEmpty ifFalse: [ self handlers first ]</body><body package="Seaside-Core">newCookie	"Create a new cookie. Try to restrict it as much as possible to make stealing it as hard as possible. Some of these restrictions may be too severe for some applications, in which case the sender can relax them."		| cookie baseUrl |	baseUrl := self handler url.	cookie := WACookie new		path: baseUrl pathStringUnencoded;		httpOnly: true;		yourself.	baseUrl host isNil ifFalse: [ cookie domain: baseUrl host ].	baseUrl scheme = 'https' ifTrue: [ cookie secure: true ].	(baseUrl port notNil and: [ baseUrl host notNil ]) ifTrue: [ cookie port: baseUrl port ].	^ cookie</body><body package="Seaside-Core">newDocument	"Answer a new Document configured to write onto our Response's stream using the	current Codec. Try to use the Document class specified by the closest Handler	but fall back on WAHtmlDocument if there is none."		^ self handler isNil		ifTrue: [			(WAHtmlDocument				on: self response stream codec: self codec)				scriptGenerator: WADefaultScriptGenerator new;				yourself  ]		ifFalse: [			(self handler documentClass				on: self response stream codec: self codec)				scriptGenerator: self handler scriptGeneratorClass new;				yourself ]</body><body package="Seaside-Core">registry	"Answer the closest Registry or nil."	^ handlers 		detect: [ :each | each isRegistry ]		ifNone: [ nil ]</body><body package="Seaside-Core">responseGenerator	"Answer a ResponseGenerator as configured in the closest RequestHandler."	^ (self handler isNil 		ifTrue: [ WAResponseGenerator ]		ifFalse: [ self handler responseGenerator ])			on: self</body></methods><methods><class-id>Seaside.WARequestContext</class-id> <category>accessing</category><body package="Seaside-Core">charSet	"Answer the character set to be used for the response.	First try to take the one from the codec.	If it is a GRNullCodec take the one from the handler.	If there's no handler answer nil."	| codecName handler |	codecName := self codec name.	codecName = GRNullCodec codecName		ifFalse: [ ^ codecName ].	handler := self handler.	self handler isNil		ifFalse: [ ^ handler charSet ].	^ nil</body><body package="Seaside-Core">codec	"Answer the Codec that should be used when preparing strings to be returned in the Response."	^ codec</body><body package="Seaside-Core">consumer	"Answer the path consumer."		^ consumer</body><body package="Seaside-Core">handlers	"Answer an OrderedCollection of RequestHandlers that are processing this request. The list is ordered such that the most recent handler is first in the list."	^ handlers</body><body package="Seaside-Core">properties	"Answer a dictionary of request-related properties."	^ properties ifNil: [ properties := GRSmallDictionary new ]</body><body package="Seaside-Core">request	"Answer the current Request object."		^ request</body><body package="Seaside-Core">response	"Answer the current Response object."		^ response</body><body package="Seaside-Core">shouldDestroy	^ self properties at: #shouldDestroy ifAbsent: [ true ]</body></methods><methods><class-id>Seaside.WARequestContext</class-id> <category>actions</category><body package="Seaside-Core">dontDestroy	"Prevent any objects from being released.	For debug purposes"	self properties at: #shouldDestroy put: false</body><body package="Seaside-Core">push: aRequestHandler during: aBlock	"Push aRequestHandler onto the handler stack while evaluating aBlock."		handlers addFirst: aRequestHandler.	^ [ WACurrentRequestContext use: self during: aBlock ]		ensure: [ handlers removeFirst ]</body><body package="Seaside-Core">respond	"Signal a desire to end request processing and return the current Response to the user agent."		WAResponseNotification signal</body><body package="Seaside-Core">respond: aBlock	"Evaluate aBlock with the current Response as a parameter and then signal a desire to end request processing and return the Response to the user agent."	aBlock value: self response.	self respond</body></methods><methods><class-id>Seaside.WARequestContext</class-id> <category>initialization</category><body package="Seaside-Core">destroy	"Clear references to objects when the receiver is no longer required. This helps avoid circular references and reduces memory consumption. This method is called by the WAServerAdaptor after request processing is finished."		self shouldDestroy ifTrue: [		self request destroy.		self response destroy.		handlers := request := response := codec := properties := nil ]</body><body package="Seaside-Core">initializeWithRequest: aRequest response: aResponse codec: aCodec	self initialize.	handlers := OrderedCollection new.	request := aRequest.	response := aResponse.	codec := aCodec.	aRequest isNil ifFalse: [		consumer := WAPathConsumer path: aRequest url path copy ]</body></methods><methods><class-id>Seaside.WARequestContext</class-id> <category>printing</category><body package="Seaside-Core">printOn: aStream 	super printOn: aStream.	self request isNil 		ifTrue: [ aStream nextPutAll: ' url: &lt;nil&gt;' ]		ifFalse: [			aStream				nextPutAll: ' url: ';				print: self request url greaseString ]</body></methods><methods><class-id>Seaside.WARequestContext class</class-id> <category>instance creation</category><body package="Seaside-Core">new	self error: self name , ' has to be instantiated with a request and response object.'</body><body package="Seaside-Core">request: aRequest response: aResponse	^ self 		request: aRequest		response: aResponse		codec: GRNullCodec new</body><body package="Seaside-Core">request: aRequest response: aResponse codec: aCodec	^ self basicNew initializeWithRequest: aRequest response: aResponse codec: aCodec</body></methods><methods><class-id>Seaside.WAFileLibraryResource</class-id> <category>accessing</category><body package="Seaside-Core">cacheDuration	^ cacheDuration</body><body package="Seaside-Core">cacheDuration: anObject	cacheDuration := anObject</body><body package="Seaside-Core">contents	^ contents</body><body package="Seaside-Core">contents: anObject	contents := anObject</body><body package="Seaside-Core">filepath	^ filepath</body><body package="Seaside-Core">filepath: anObject	filepath := anObject</body><body package="Seaside-Core">mimeType	^ mimeType</body><body package="Seaside-Core">mimeType: anObject	mimeType := anObject</body></methods><methods><class-id>Seaside.WAFileLibraryResource</class-id> <category>printing</category><body package="Seaside-Core">printOn: aStream	super printOn: aStream.	aStream		nextPutAll: ' cacheDuration: ';		print: self cacheDuration.	aStream		nextPutAll: ' filepath: ';		print: self filepath.	aStream		nextPutAll: ' mimeType: ';		print: self mimeType.	aStream		nextPutAll: ' contents: ';		print: (self contents greaseString truncateWithElipsisTo: 100)</body></methods><methods><class-id>Seaside.WAFileLibraryResource class</class-id> <category>instance creation</category><body package="Seaside-Core">emptyInstance	^ self filepath: '' mimeType: WAMimeType textPlain cacheDuration: Duration zero contents: ''</body><body package="Seaside-Core">filepath: filepath mimeType: aMimeType cacheDuration: cacheDuration contents: contents	^ self new		filepath: filepath;		mimeType: aMimeType;		cacheDuration: cacheDuration;		contents: contents;		yourself</body></methods><methods><class-id>Seaside.WAAttributeNotFound</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithKey: aSymbol	key := aSymbol</body></methods><methods><class-id>Seaside.WAAttributeNotFound</class-id> <category>accessing</category><body package="Seaside-Core">key	^ key</body><body package="Seaside-Core">seasidePossibleCauses	^ #(		'you need to clear your configuration caches to see new attributes (try "WAAdmin clearConfigurationCaches" in a workspace)'		'you have not included a necessary ancestor in a configuration'	)</body></methods><methods><class-id>Seaside.WAAttributeNotFound class</class-id> <category>signaling</category><body package="Seaside-Core">signalWithKey: aSymbol	^ self new		initializeWithKey: aSymbol;		signal</body></methods><methods><class-id>Seaside.WACacheKeyEntry</class-id> <category>accessing</category><body package="Seaside-Core">byAccessListEntry	^ byAccessListEntry</body><body package="Seaside-Core">byAccessListEntry: aCacheListEntry	byAccessListEntry := aCacheListEntry</body><body package="Seaside-Core">byCreationListEntry	^ byCreationListEntry</body><body package="Seaside-Core">byCreationListEntry: aCacheListEntry	byCreationListEntry := aCacheListEntry</body><body package="Seaside-Core">key	^ key</body><body package="Seaside-Core">keyHash	^ keyHash</body><body package="Seaside-Core">next	^ next</body><body package="Seaside-Core">next: aCacheKeyEntry	next := aCacheKeyEntry</body><body package="Seaside-Core">value	^ value</body><body package="Seaside-Core">value: anObject	value := anObject</body></methods><methods><class-id>Seaside.WACacheKeyEntry</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithKey: aKey value: anObject	self initialize.	key := aKey.	keyHash := aKey hash.	value := anObject</body></methods><methods><class-id>Seaside.WACacheKeyEntry</class-id> <category>printing</category><body package="Seaside-Core">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	key printOn: aStream.	aStream nextPutAll: ' -&gt; '.	value printOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Seaside.WACacheKeyEntry class</class-id> <category>instance creation</category><body package="Seaside-Core">key: aKey value: anObject	^ self basicNew		initializeWithKey: aKey value: anObject;		yourself</body></methods><methods><class-id>Seaside.WAProtectionFilter</class-id> <category>processing</category><body package="Seaside-Core">handleFiltered: aRequestContext 	(self verifyRequest: aRequestContext request) 		ifTrue: [ super handleFiltered: aRequestContext ]		ifFalse: [ 			aRequestContext responseGenerator				forbidden;				respond ]</body></methods><methods><class-id>Seaside.WAProtectionFilter</class-id> <category>testing</category><body package="Seaside-Core">verifyRequest: aRequest	^ (self remoteAddressFromRequest: aRequest) = self remoteAddress</body></methods><methods><class-id>Seaside.WAProtectionFilter</class-id> <category>private</category><body package="Seaside-Core">remoteAddress	^ remoteAddress</body><body package="Seaside-Core">remoteAddressFromRequest: aRequest	remoteAddress ifNil: [		remoteAddress := aRequest			headerAt: 'x-forwarded-for'			ifAbsent: [				aRequest					headerAt: 'forwarded-for'					ifAbsent: [						aRequest remoteAddress ] ] ].	^ aRequest remoteAddress</body></methods><methods><class-id>Seaside.WAUrl</class-id> <category>accessing</category><body package="Seaside-Core">fragment	"Answer the fragment part of the URL."	^ fragment</body><body package="Seaside-Core">fragment: aString	fragment := aString</body><body package="Seaside-Core">host	"Answer the host part of the URL."	^ host</body><body package="Seaside-Core">host: aString	host := aString isNil		ifFalse: [ aString greaseString asLowercase ]</body><body package="Seaside-Core">password	"Answer the password part of the URL userinfo. Note that the use of the format	'user:password' for userinfo has been deprecated in RFC 3986 (3.2.1)."	^ password</body><body package="Seaside-Core">password: aString	password := aString</body><body package="Seaside-Core">path	"Answer the path part of the URL."	^ path ifNil: [ path := OrderedCollection new: 5 ]</body><body package="Seaside-Core">path: aCollection	"Set the path part of the URL to aCollection."	path := aCollection</body><body package="Seaside-Core">pathParameterAllAt: anIndex key: aKey ifAbsent: aZeroArgumentBlock	"Answer all the parameters at path index anIndex with key aKey evaluation aZeroArgumentBlock if none is found."	^ self		privatePathParameterMapAt: anIndex		ifPresentDo: [ :parameters |			parameters allAt: aKey ifAbsent: aZeroArgumentBlock ]		ifAbsent: aZeroArgumentBlock</body><body package="Seaside-Core">pathParameterAt: anIndex key: aKey ifAbsent: aZeroArgumentBlock	"Answer the first parameter at path index anIndex with key aKey evaluation aZeroArgumentBlock if none is found."	^ self		privatePathParameterMapAt: anIndex		ifPresentDo: [ :parameters |			parameters at: aKey ifAbsent: aZeroArgumentBlock ]		ifAbsent: aZeroArgumentBlock</body><body package="Seaside-Core">port	"Answer the port number part of the URL."	^ port</body><body package="Seaside-Core">port: aNumber	port := aNumber</body><body package="Seaside-Core">queryFields	"Answer a dictionary with the query fields."	^ queryFields ifNil: [ queryFields := WARequestFields new ]</body><body package="Seaside-Core">queryFields: aDictionary	queryFields := aDictionary</body><body package="Seaside-Core">scheme	"Answer the URL's scheme."	^ scheme ifNil: [ 'http' ]</body><body package="Seaside-Core">scheme: aString	scheme := aString isNil ifFalse: [ aString asLowercase ]</body><body package="Seaside-Core">slash	"Answer if the path has a trailing slash."	^ slash</body><body package="Seaside-Core">slash: aBoolean	slash := aBoolean</body><body package="Seaside-Core">user	"Answer the user part of the URL userinfo. Note that the use of the format	'user:password' for userinfo has been deprecated in RFC 3986 (3.2.1)."	^ user</body><body package="Seaside-Core">user: aString	user := aString</body><body package="Seaside-Core">userinfo	"Answer the userinfo part of the URL. We store user and password separately,	even though the format 'user:password' is deprecated for userinfo in RFC 3986,	because otherwise it is impossible to figure out correct encoding when userinfo	data has a colon in it."	^ password isNil		ifTrue: [ user ]		ifFalse: [ String streamContents: [ :stream |			stream				nextPutAll: user;				nextPut: $:;				nextPutAll: password ] ]</body><body package="Seaside-Core">userinfo: aString	"Colons in userinfo must be encoded. The only exception (now deprecated by RFC 3986)	is a single colon separating a password from the rest of the user information. Since	we can't tell the difference here, we assume that any colons should be encoded. If	you want to specify a (deprecated) password, use #user: and #password:."		user := aString.	password := nil</body></methods><methods><class-id>Seaside.WAUrl</class-id> <category>converting</category><body package="Seaside-Core">decodedWith: aCodec	"answers a copy of the receiver decoded with the given codec	http://www.ietf.org/rfc/rfc3987.txt"	| url |	url := self copy.		"scheme, host, port cannot include escaped characters (%FF) and so should not	be able to include characters that need decoding"		"userinfo (username + password) can be percent encoded"	self user isNil ifFalse: [		url user: (aCodec url decode: self user) ].	self password isNil ifFalse: [		url password: (aCodec url decode: self password) ].		self path isEmpty ifFalse: [		url path: (self path collect: [ :each | aCodec url decode: each ]) ].	url queryFields: nil.	self queryFields keysAndValuesDo: [ :key :value |		url			addField: (aCodec url decode: key)			value: (value isNil ifFalse: [ aCodec url decode: value ]) ].	self fragment isNil ifFalse: [		url fragment: (aCodec url decode: self fragment) ].		^ url</body><body package="Seaside-Core">pathEncodedWith: aCodec on: aStream	| document |	document := WAUnescapedDocument 		on: aStream		codec: aCodec.	self encodePathOn: document</body><body package="Seaside-Core">pathStringEncodedWith: aCodec	| size |	"estimate the buffer size"	size := (self pathStringUnencodedSize * 1.1) greaseInteger.	^ String new: size streamContents: [ :stream |		self pathEncodedWith: aCodec on: stream ]</body><body package="Seaside-Core">pathStringSafeUnencoded	"Answer the path converted to a string without doing URL or HTML escaping.	Compared to #pathStringUnencoded, we cannot guarantee to not copy here.	"	| stream |	stream := WriteStream on: (String new: self pathStringUnencodedSize).	self pathUnencodedOn: stream.	^ stream contents</body><body package="Seaside-Core">pathStringUnencoded	"Answer the path converted to a string without doing URL or HTML escaping."	"allocate with correct size, avoid copy"	| string stream commonElementClass |	commonElementClass := self detectCommonPathElementClass.	commonElementClass isNil ifTrue: [		^ self pathStringSafeUnencoded ].	string := commonElementClass new: self pathStringUnencodedSize.	stream := WriteStream on: string.	self pathUnencodedOn: stream.	^ string</body><body package="Seaside-Core">pathUnencodedOn: aStream	"Print the path on on the given stream without doing URL or HTML escaping."	path isNil ifFalse: [		path do: [ :each |			aStream nextPut: $/.			aStream nextPutAll: each ] ].	(path isNil or: [ path isEmpty or: [ slash ] ])		ifTrue: [ aStream nextPut: $/ ]</body><body package="Seaside-Core">queryString	"Answer the full query part of the URL. It would probably be better to	store this as a string somewhere so we can support queries that are not	key/value field lists."		^ String streamContents: [ :stream |		| urlEncoder |		urlEncoder := GRPlatform current urlEncoderOn: stream.		self queryFields associations			do: [ :each |				urlEncoder nextPutAll: each key.				each value notNil ifTrue: [					stream nextPut: $=.					urlEncoder nextPutAll: each value greaseString ] ]			separatedBy: [ stream nextPut: $&amp; ] ]</body><body package="Seaside-Core">relativeTo: aUrl	"Answer a path element collection relative from the receiver to aUrl."		| currentPath argumentPath resultingPath |	currentPath := self path copy.	argumentPath := aUrl path copy.	[ currentPath notEmpty and: [ argumentPath notEmpty and: [ currentPath first = argumentPath first ] ] ] whileTrue: [		currentPath removeFirst.		argumentPath removeFirst ].	resultingPath := OrderedCollection new.	currentPath size 		timesRepeat: [ resultingPath add: '..' ].	resultingPath addAll: argumentPath.	^ resultingPath</body><body package="Seaside-Core">seasideUrl	^ self</body></methods><methods><class-id>Seaside.WAUrl</class-id> <category>copying</category><body package="Seaside-Core">postCopy	super postCopy.	path := path copy.	queryFields := queryFields copy.	pathParameters := pathParameters copy</body><body package="Seaside-Core">with: pathString	^ self copy		addToPath: pathString;		yourself</body><body package="Seaside-Core">withField: aString	^ self copy		addField: aString;		yourself</body><body package="Seaside-Core">withField: aString value: valueString	^ self copy		addField: aString value: valueString;		yourself</body><body package="Seaside-Core">withoutFragment	^ self copy		fragment: nil;		yourself</body><body package="Seaside-Core">withoutQuery	^ self copy		queryFields: nil;		yourself</body></methods><methods><class-id>Seaside.WAUrl</class-id> <category>private</category><body package="Seaside-Core">decode: aString	"percent decodes the given String"	^ self class decodePercent: aString</body><body package="Seaside-Core">detectCommonPathElementClass	"Detect if all path elements are of the same class. Answer that class if that is the case.	Answer nil otherwise.		If all the elements are of the same class we can avoid sending #contents to the wirte stream	because we can allocate a collection of the right size and type. This is important because	#contents does an additional copy which shows up in benchmarks.	If the lements are not of the same class we can not know the type of the target collection	(in a portable way) and have to use stream #contents."	| firstSpecies |	path isEmptyOrNil ifTrue: [		^ '' species ].	firstSpecies := (path at: 1) species.	2 to: path size do: [ :index |		(path at: index) species ~= firstSpecies			ifTrue: [ ^ nil ] ].	^ firstSpecies</body><body package="Seaside-Core">isSeasideField: aString	^ aString notEmpty		and: [ aString first = $_		or: [ aString allSatisfy: [ :each | each isDigit ] ] ]</body><body package="Seaside-Core">pathElementsIn: aString do: aOneArgumentBlock	GRPlatform		subStringsIn: aString		splitBy: $/		do: aOneArgumentBlock</body><body package="Seaside-Core">pathStringUnencodedSize	| count |	count := 0.	path isNil ifFalse: [		path do: [ :each |			count := count + each size + 1 ] ].	(path isNil or: [ path isEmpty or: [ slash ] ])		ifTrue: [ count := count + 1 ].	^ count</body><body package="Seaside-Core">privatePathParameterMapAt: anIndex	pathParameters isNil ifTrue: [		pathParameters := OrderedCollection new: self path size ].	^ pathParameters size &gt;= anIndex		ifTrue: [ pathParameters at: anIndex ]		ifFalse: [			anIndex - pathParameters size - 1 timesRepeat: [				pathParameters add: nil ].			pathParameters add: GROrderedMultiMap new ]</body><body package="Seaside-Core">privatePathParameterMapAt: anIndex ifPresentDo: aOneArgumentBlock ifAbsent: aZeroArgumentBlock	| parameters |	pathParameters isNil ifTrue: [		^ aZeroArgumentBlock value ].	parameters := pathParameters at: anIndex ifAbsent: [		^ aZeroArgumentBlock value ].	parameters isNil ifTrue: [		^ aZeroArgumentBlock value ].	^ aOneArgumentBlock value: parameters</body><body package="Seaside-Core">takeServerParametersFromRequest: aRequest	"Retrieves scheme, hostname and basepath from the request unless already set."	scheme isNil		ifTrue: [ self scheme: aRequest url scheme ].	host isNil 		ifTrue: [ aRequest headers at: 'host' ifPresent: [ :value | self parseAuthority: value from: 1 to: value size + 1 ] ].	path isNil		ifTrue: [ aRequest headers at: 'base' ifPresent: [ :value | self parsePath: value ] ]</body></methods><methods><class-id>Seaside.WAUrl</class-id> <category>adding</category><body package="Seaside-Core">addAllToPath: aCollectionOfStrings	"Add a collection of strings to the path."		aCollectionOfStrings do: [ :each | self addToPath: each ]</body><body package="Seaside-Core">addField: aKey	"Add the query field aKey to the receiving url."	self addField: aKey value: nil</body><body package="Seaside-Core">addField: aKey value: aValue	"Add the query field aKey with aValue to the receiving url."		aKey isEmpty 		ifFalse: [ self queryFields at: aKey add: aValue ]</body><body package="Seaside-Core">addPathParameterAt: anIndex key: aKey	"Add the path parameter aKey to the path element at anIndex."	(self privatePathParameterMapAt: anIndex) at: aKey put: nil</body><body package="Seaside-Core">addPathParameterAt: anIndex key: aKey value: aValue	"Add the path parameter aKey with aKey to the path element at anIndex."	(self privatePathParameterMapAt: anIndex) at: aKey add: aValue</body><body package="Seaside-Core">addToPath: aString	"Adds the argument as a path element. If the argument contains $/ it is split into multiple elements."	| p |	p := self path.	self pathElementsIn: aString do: [ :each |		p add: each ].	self slash: (aString notEmpty and: [ aString last = $/ ])</body></methods><methods><class-id>Seaside.WAUrl</class-id> <category>initialization</category><body package="Seaside-Core">initialize	super initialize.	slash := false</body><body package="Seaside-Core">initializeFromString: aString	| fragmentIndex queryIndex schemeIndex pathStart stringSize pathEnd authorityStart authorityEnd startWithPath |	self initialize.	stringSize := aString size.	fragmentIndex := aString indexOf: $#.	fragmentIndex &gt; 0 ifTrue: [		self			parseFragment: aString			from: fragmentIndex + 1 ].	queryIndex := aString indexOf: $?.	(queryIndex &gt; 0 and: [ fragmentIndex = 0 or: [ queryIndex &lt; fragmentIndex ] ]) ifTrue: [		self			parseQuery: aString 			from: queryIndex + 1			to: (fragmentIndex = 0 ifTrue: [ stringSize + 1 ] ifFalse: [ fragmentIndex ]) ].	schemeIndex := aString indexOfSubCollection: '://'.		(schemeIndex &gt; 0 and: [ fragmentIndex = 0 or: [ schemeIndex &lt; fragmentIndex ] ])		ifTrue: [			startWithPath := false.			self scheme: (aString copyFrom: 1 to: schemeIndex - 1).			pathStart := aString indexOf: $/ startingAt: schemeIndex + 3.			authorityStart := schemeIndex + 3 ]		ifFalse: [			startWithPath := true.			pathStart := aString indexOf: $/ startingAt: 1.			authorityStart := 0 ].		pathStart &gt; 0		ifTrue: [			(pathStart &gt; fragmentIndex and: [ fragmentIndex &gt; 0 ]) ifTrue: [				WAInvalidUrlSyntaxError signal: aString ].			(pathStart &gt; queryIndex and: [ queryIndex &gt; 0 ]) ifTrue: [				WAInvalidUrlSyntaxError signal: aString ].			authorityEnd := pathStart ]		ifFalse: [			(fragmentIndex &gt; 0 or: [ queryIndex &gt; 0 ]) ifTrue: [				WAInvalidUrlSyntaxError signal: aString ].			authorityEnd := stringSize + 1 ].		authorityStart &gt; 0 ifTrue: [		self parseAuthority: aString from: authorityStart to: authorityEnd ].		pathEnd := stringSize + 1.	fragmentIndex &gt; 0 ifTrue: [		pathEnd := fragmentIndex ].	(queryIndex &gt; 0 and: [ fragmentIndex = 0 or: [ queryIndex &lt; fragmentIndex ] ]) ifTrue: [		pathEnd := queryIndex ].		startWithPath		ifTrue: [			(stringSize &gt; 0 and: [ (aString at: 1) = $/ ])				ifTrue: [ self parsePath: aString absolute: true from: 2 to: pathEnd ]				ifFalse: [ self parsePath: aString absolute: false from: 1 to: pathEnd ] ]		ifFalse: [			pathStart &gt; 0 ifTrue: [				self parsePath: aString absolute: true from: pathStart + 1 to: pathEnd ] ]</body></methods><methods><class-id>Seaside.WAUrl</class-id> <category>comparing</category><body package="Seaside-Core">= aUrl	^ self class = aUrl class and: [ self printString = aUrl printString ]</body><body package="Seaside-Core">hash	^ self host hash bitXor: self path hash</body></methods><methods><class-id>Seaside.WAUrl</class-id> <category>printing</category><body package="Seaside-Core">printOn: aStream 	| document codec |	codec := [ self requestContext codec ] 		on: WARequestContextNotFound		do: [ :e | GRNullCodec new ].	document := WAUnescapedDocument 		on: aStream		codec: codec.	self encodeOn: document</body></methods><methods><class-id>Seaside.WAUrl</class-id> <category>encoding</category><body package="Seaside-Core">encodeFragmentOn: aDocument	aDocument urlEncoder nextPutAll: fragment</body><body package="Seaside-Core">encodeOn: aDocument	self encodeSchemeAndAuthorityOn: aDocument.	self encodePathOn: aDocument.	(queryFields isNil or: [ queryFields isEmpty ]) ifFalse: [		aDocument xmlEncoder nextPut: $?.		self encodeQueryOn: aDocument ].	fragment isNil ifFalse: [		aDocument xmlEncoder nextPut: $#.		self encodeFragmentOn: aDocument ]</body><body package="Seaside-Core">encodePathOn: aDocument	path isNil ifFalse: [		path keysAndValuesDo: [ :index :each |			aDocument nextPut: $/.			aDocument urlEncoder nextPutAll: each.			pathParameters isNil ifFalse: [				self encodePathParametersAt: index on: aDocument ] ] ].	(path isNil or: [ path isEmpty or: [ slash ] ])		ifTrue: [ aDocument nextPut: $/ ]</body><body package="Seaside-Core">encodePathParametersAt: anIndex on: aDocument	self		privatePathParameterMapAt: anIndex		ifPresentDo: [ :parameters | 			| alreadyProcessed |			alreadyProcessed := Set new.			parameters keys				do: [ :key | 					(alreadyProcessed includes: key)						ifFalse: [ | values |							aDocument nextPut: $;.							aDocument urlEncoder nextPutAll: key.							values := parameters allAt: key.							(values size = 1 and: [ values first isNil ])								ifFalse: [ | first |									first := true.									aDocument nextPut: $=.									values										do: [ :value | 											first												ifFalse: [ aDocument nextPut: $, ].											aDocument urlEncoder nextPutAll: value greaseString.											first := false ] ].							alreadyProcessed add: key ] ] ]		ifAbsent: [ "ignore" ]</body><body package="Seaside-Core">encodeQueryOn: aDocument 	| first |	first := true.	self queryFields keysAndValuesDo: [ :key :value |		first ifFalse: [ aDocument xmlEncoder nextPut: $&amp; ].		first := false.		aDocument urlEncoder nextPutAll: key.		value isNil ifFalse: [			aDocument nextPut: $=.			aDocument urlEncoder nextPutAll: value greaseString ] ]</body><body package="Seaside-Core">encodeSchemeAndAuthorityOn: aDocument	host ifNil: [ ^ self ].	aDocument nextPutAll: self scheme; nextPutAll: '://'.	user notNil ifTrue: [		aDocument urlEncoder nextPutAll: user.		password notNil ifTrue: [			aDocument nextPut: $:.			aDocument urlEncoder nextPutAll: password ].		aDocument nextPut: $@ ].	aDocument urlEncoder nextPutAll: host.	port notNil ifTrue: [		((self scheme = 'http' and: [ port = 80 ])			or: [ self scheme = 'https' and: [ port = 443 ] ])			ifFalse: [ aDocument nextPut: $:; print: port ] ]</body></methods><methods><class-id>Seaside.WAUrl</class-id> <category>testing</category><body package="Seaside-Core">isSsl	^ self scheme isEmptyOrNil not		and: [ self scheme last = $s ]</body></methods><methods><class-id>Seaside.WAUrl</class-id> <category>parsing</category><body package="Seaside-Core">parseAuthority: aString from: start to: end	| atIndex hostStart |	atIndex := aString indexOf: $@ startingAt: start.	(atIndex &gt; 0 and: [ atIndex &lt; end ])		ifTrue: [			self parseUserPassword: aString from: start to: atIndex.			hostStart := atIndex + 1 ]		ifFalse: [			hostStart := start ].			self parseHostPort: aString from: hostStart to: end</body><body package="Seaside-Core">parseFragment: aString from: startIndex	startIndex &gt; aString size ifTrue: [ ^ self ].	self fragment: (self class decodePercent: aString from: startIndex)</body><body package="Seaside-Core">parseHostPort: aString from: start to: end	| colonIndex |	colonIndex := aString indexOf: $: startingAt: start.	(colonIndex &gt; 0 and: [ colonIndex &lt; end ])		ifTrue: [			start &lt; colonIndex ifTrue: [				"don't set host when empty"				self host: (self class decodePercent: aString from: start to: colonIndex) ].			self port: (self parsePort: aString from: colonIndex + 1 to: end) ]		ifFalse: [			start &lt; end ifTrue: [				"don't set host when empty"				self host: (self class decodePercent: aString from: start to: end) ] ]</body><body package="Seaside-Core">parsePath: aString	| absolute |	absolute := aString notEmpty and: [ aString first = $/ ].	self		parsePath: aString		absolute: absolute		from: (absolute ifTrue: [ 2 ] ifFalse: [ 1 ])		to: aString size + 1</body><body package="Seaside-Core">parsePath: aString absolute: absolute from: start to: end	| p index elementStart |	absolute ifTrue: [		path := nil.		pathParameters := nil ].	p := self path.	index := p size.		elementStart := start.	[ elementStart &lt; end and: [ (aString at: elementStart) = $/ ] ] whileTrue: [			elementStart := elementStart + 1 ].	[ elementStart &gt; 0 and: [ elementStart &lt; end ] ] whileTrue: [		| elementEnd elementSize |		elementEnd := aString indexOf: $/ startingAt: elementStart + 1.		(elementEnd &gt; 0 and: [ elementEnd &lt; end ]) ifFalse: [			elementEnd := end ].		elementSize := elementEnd - elementStart.		elementSize &gt; 0 ifTrue: [			"avoid empty stings"			(elementSize = 1 and: [ (aString at: elementStart) = $. ]) ifFalse: [ "."				(elementSize = 2 and: [ (aString at: elementStart) = $.  and: [ (aString at: elementStart + 1) = $. ] ]) ".."					ifTrue: [						index := index - 1.						"should we signal a syntax error if the path is empty?"						p isEmpty ifFalse: [							p removeLast ] ]					ifFalse: [						| semiColonIndex |						index := index + 1.						semiColonIndex := aString indexOf: $; startingAt: elementStart.						(semiColonIndex &gt; 0 and: [ semiColonIndex &lt; elementEnd ])							ifTrue: [											p addLast: (self class decodePercent: aString from: elementStart to: semiColonIndex).								self parsePathParameters: aString at: index from: semiColonIndex + 1 to: elementEnd ]							ifFalse: [								p addLast: (self class decodePercent: aString from: elementStart to: elementEnd) ] ] ] ].		elementStart := elementEnd + 1.		[ elementStart &lt; end and: [ (aString at: elementStart) = $/ ] ] whileTrue: [			elementStart := elementStart + 1 ] ]</body><body package="Seaside-Core">parsePathParameters: aString at: anIndex from: start to: end	| parameterStart |	parameterStart := start.	[ parameterStart &gt; 0 and: [ parameterStart &lt; end ] ] whileTrue: [		| nameEnd parameterEnd |		nameEnd := aString indexOf: $= startingAt: parameterStart.		parameterEnd := aString indexOf: $; startingAt: parameterStart.		parameterEnd := parameterEnd &gt; 0			ifTrue: [ parameterEnd min: end ]			ifFalse: [ end ].		(nameEnd &gt; 0 and: [ nameEnd &lt; end ])			ifTrue: [				| parameterName valueStart |				parameterName := self class decodePercent: aString from: parameterStart to: nameEnd.				valueStart := nameEnd + 1.				[ valueStart &gt; 0 and: [ valueStart &lt; parameterEnd ] ] whileTrue: [					| valueEnd |					valueEnd := aString indexOf: $, startingAt: valueStart + 1.					valueEnd := valueEnd &gt; 0						ifTrue: [ valueEnd min: parameterEnd ]						ifFalse: [ parameterEnd ].					self						addPathParameterAt: anIndex 						key: parameterName						value: (self class decodePercent: aString from: valueStart to: valueEnd).					valueStart := valueEnd + 1 ] ]			ifFalse: [				self addPathParameterAt: anIndex key: (self class decodePercent: aString from: parameterStart to: parameterEnd) ].		parameterStart := parameterEnd + 1 ]</body><body package="Seaside-Core">parsePort: aString from: start to: end	| number |	number := nil.	start to: end - 1 do: [ :i |		| char |		char := aString at: i.		(char &lt; $0 or: [ char &gt; $9 ]) ifTrue: [			WAInvalidUrlSyntaxError signal: aString ].		number := (number isNil  ifTrue: [ 0 ] ifFalse: [ 10 * number ])			+ (char greaseInteger - $0 greaseInteger) ].	^ number</body><body package="Seaside-Core">parseQuery: aString from: queryStart to: queryEnd	| parameterStart |	parameterStart := queryStart.	[ parameterStart &gt; 0 and: [ parameterStart &lt; queryEnd ] ] whileTrue: [		| nameEnd parameterEnd |		nameEnd := aString indexOf: $= startingAt: parameterStart.		parameterEnd := aString indexOf: $&amp; startingAt: parameterStart.		parameterEnd := parameterEnd &gt; 0			ifTrue: [ parameterEnd min: queryEnd ]			ifFalse: [ queryEnd ].		(nameEnd &gt; 0 and: [ nameEnd &lt; queryEnd ])			ifTrue: [				self					addField: (self class decodePercentAndPlus: aString from: parameterStart to: nameEnd)					value: (self class decodePercentAndPlus: aString from: nameEnd + 1 to: parameterEnd) ]			ifFalse: [				self addField: (self class decodePercentAndPlus: aString from: parameterStart to: parameterEnd) ].		parameterStart := parameterEnd + 1 ]</body><body package="Seaside-Core">parseUserPassword: aString from: start to: end	| colonIndex |	colonIndex := aString indexOf: $: startingAt: start.	(colonIndex &gt; 0 and: [ colonIndex &lt; end ])		ifTrue: [			self user: (self class decodePercent: aString from: start to: colonIndex).			self password: (self class decodePercent: aString from: colonIndex + 1 to: end) ]		ifFalse: [			self user: (self class decodePercent: aString from: start to: end) ]</body></methods><methods><class-id>Seaside.WAUrl class</class-id> <category>parsing</category><body package="Seaside-Core">absolute: aString	"Parse aString as an absolute URL."	^ self basicNew initializeFromString: aString</body><body package="Seaside-Core">absolute: aString relative: aRelativeString	"Take absolute URL aString and combine it with a relative path aRelativeString."	^ (self absolute: aString)		parsePath: aRelativeString;		yourself</body></methods><methods><class-id>Seaside.WAUrl class</class-id> <category>decoding</category><body package="Seaside-Core">decodePercent: aString	"percent decodes the given String"	| input output char |	input := aString readStream.	output := WriteStream on: (String new: aString size).	[ input atEnd ] whileFalse: [		char := input next.		output nextPut: (char = $+			ifTrue: [ Character space ]			ifFalse: [				char = $%					ifTrue: [						| firstByte secondByte |						firstByte :=  input atEnd ifTrue: [ WAInvalidUrlSyntaxError signal: aString ] ifFalse: [ input next asUppercase digitValue ].						secondByte :=  input atEnd ifTrue: [ WAInvalidUrlSyntaxError signal: aString ] ifFalse: [ input next asUppercase digitValue ].						Character codePoint:firstByte * 16 + secondByte ]					ifFalse: [ char ] ]) ].	^ output contents</body><body package="Seaside-Core">decodePercent: aString from: start	"percent decodes the fragment string starting at the given index	/?:@-._~!$&amp;'()*+,;= are allowed unescaped anywhere within a fragment part"	^ self decodePercent: aString from: start to: aString size + 1</body><body package="Seaside-Core">decodePercent: aString from: start to: end	"percent decodes the string starting at the given index"	| input output index left |	index := aString indexOf: $% startingAt: start.	(index = 0 or: [ index &gt;= end ])		ifTrue: [ ^ aString copyFrom: start to: end - 1 ].	input := aString readStream.	input skip: start - 1. "start index 1 -&gt; skip 0"	output := WriteStream on: (String new: aString size).	left := end - start.	[ left &gt; 0 and: [ input atEnd not ] ] whileTrue: [		| char |		char := input next.		output nextPut: (char = $%			ifTrue: [				| firstByte secondByte |				firstByte :=  input atEnd ifTrue: [ WAInvalidUrlSyntaxError signal: aString ] ifFalse: [ input next asUppercase digitValue ].				secondByte :=  input atEnd ifTrue: [ WAInvalidUrlSyntaxError signal: aString ] ifFalse: [ input next asUppercase digitValue ].				left := left - 3.				Character codePoint:firstByte * 16 + secondByte ]			ifFalse: [				left := left - 1.				char ]) ].	^ output contents</body><body package="Seaside-Core">decodePercentAndPlus: aString from: start to: end	"percent decodes the given String"	| percentIndex input output left |	"check if we contain %"	percentIndex := aString indexOf: $% startingAt: start.	(percentIndex = 0 or: [ percentIndex &gt;= end ]) ifTrue: [		| plusIndex |		"check if we contain +"		plusIndex := aString indexOf: $+ startingAt: start.		(plusIndex = 0 or: [ plusIndex &gt;= end ]) ifTrue: [			^ aString copyFrom: start to: end - 1 ] ].		"we contain either % or +"	input := aString readStream.	input skip: start - 1. "start index 1 -&gt; skip 0"	output := WriteStream on: (String new: aString size).	left := end - start.	[ left &gt; 0 and: [ input atEnd not ] ] whileTrue: [		| char |		char := input next.		output nextPut: (char = $+			ifTrue: [				left := left - 1.				Character space ]			ifFalse: [				char = $%					ifTrue: [						| firstByte secondByte |						firstByte :=  input atEnd ifTrue: [ WAInvalidUrlSyntaxError signal: aString ] ifFalse: [ input next asUppercase digitValue ].						secondByte :=  input atEnd ifTrue: [ WAInvalidUrlSyntaxError signal: aString ] ifFalse: [ input next asUppercase digitValue ].						left := left - 3.						Character codePoint:firstByte * 16 + secondByte ]					ifFalse: [						left := left - 1.						char ] ]) ].	^ output contents</body></methods><methods><class-id>Seaside.WABufferedResponse</class-id> <category>accessing</category><body package="Seaside-Core">contents	^ contentsStream contents</body><body package="Seaside-Core">stream	^ contentsStream</body></methods><methods><class-id>Seaside.WABufferedResponse</class-id> <category>initialization</category><body package="Seaside-Core">destroy	super destroy.	contentsStream := nil</body><body package="Seaside-Core">initializeOn: aStream	super initializeOn: aStream.	contentsStream := aStream</body></methods><methods><class-id>Seaside.WABufferedResponse</class-id> <category>writing</category><body package="Seaside-Core">writeContentOn: aStream 	aStream nextPutAll: self contents</body><body package="Seaside-Core">writeHeadersOn: aStream 	self 		headerAt: 'Content-Length'		put: contentsStream position.	super writeHeadersOn: aStream</body></methods><methods><class-id>Seaside.WABufferedResponse</class-id> <category>streaming</category><body package="Seaside-Core">binary	"put the response stream into binary mode. For buffered response, 	 replace the contentStream with a ByteArray based stream."	contentsStream := GRPlatform current readWriteByteStream</body></methods><methods><class-id>Seaside.WABufferedResponse</class-id> <category>convenience</category><body package="Seaside-Core">resetIfPossible	self initializeFields.	contentsStream reset.	^ true</body></methods><methods><class-id>Seaside.WABufferedResponse class</class-id> <category>instance creation</category><body package="Seaside-Core">new	^ self on: (GRPlatform current writeCharacterStreamOn: (String new: 4096))</body><body package="Seaside-Core">on: aStream	^ self basicNew initializeOn: aStream</body></methods><methods><class-id>Seaside.WAValuesCallback</class-id> <category>evaluation</category><body package="Seaside-Core">evaluateWithArgument: anObject	values at: anObject greaseInteger ifPresent: [ :value | block valueWithPossibleArguments: (Array with: value) ]</body></methods><methods><class-id>Seaside.WAValuesCallback</class-id> <category>accessing</category><body package="Seaside-Core">values	^ values</body><body package="Seaside-Core">values: aDictionary 	values := aDictionary</body></methods><methods><class-id>Seaside.WAValuesCallback class</class-id> <category>instance creation</category><body package="Seaside-Core">on: aBlock values: aDictionary	^ self new block: aBlock; values: aDictionary; yourself</body></methods><methods><class-id>Seaside.WAMultipleValuesCallback</class-id> <category>evaluation</category><body package="Seaside-Core">evaluateWithFieldValues: anOrderedCollection	| selectedValues keys |	selectedValues := OrderedCollection new.	keys := anOrderedCollection collect: [ :each | each isNil ifFalse: [ each greaseInteger ] ].	keys do: [ :each | values at: each ifPresent: [ :value | selectedValues add: value ] ].	block valueWithPossibleArguments: (Array with: selectedValues)</body></methods><methods><class-id>Seaside.WAUnregisteredHandlerError</class-id> <category>accessing</category><body package="Seaside-Core">seasidePossibleCauses	^ #(		'You are trying to use a session or other request handler that has expired'	)</body></methods><methods><class-id>Seaside.WAAllUrlsCallback</class-id> <category>converting</category><body package="Seaside-Core">valueForField: anObject	^ anObject isEmptyOrNil		ifTrue: [ nil ]		ifFalse: [ WAUrl absolute: anObject ]</body></methods><methods><class-id>Seaside.WAReducedConflictCounter</class-id> <category>initialization</category><body package="Seaside-Core">initialize	super initialize.	count := 0</body></methods><methods><class-id>Seaside.WAReducedConflictCounter</class-id> <category>public</category><body package="Seaside-Core">increment	count := count + 1</body><body package="Seaside-Core">value	^ count</body></methods><methods><class-id>Seaside.WAServerAdaptor</class-id> <category>private</category><body package="Seaside-Core">basicStart	self subclassResponsibility</body><body package="Seaside-Core">basicStop	self subclassResponsibility</body><body package="Seaside-Core">shutDown</body><body package="Seaside-Core">startUp</body></methods><methods><class-id>Seaside.WAServerAdaptor</class-id> <category>processing</category><body package="Seaside-Core">handle: aRequestContext	"Handle the basic request-response loop."	self handleRequest: aRequestContext.	self handlePadding: aRequestContext</body><body package="Seaside-Core">handlePadding: aRequestContext	"If you create an error page that's too small, Microsoft Internet Explorer will display its own error page that includes a link to the MSN network search engine rather than your own error page. See &lt;http://www.404-error-page.com/404-error-page-too-short-problem-microsoft-ie.shtml&gt; for details."	| size |	size := aRequestContext response stream size.	^ (size &lt; 512 and: [ #(400 403 404 405 406 408 409 410 500 501 505) includes: aRequestContext response status ])		ifTrue: [ aRequestContext response nextPutAll: ((String new: 512 - size) atAllPut: $ ) ]</body><body package="Seaside-Core">handleRequest: aRequestContext	"Pass the request context to the appropriate request handler."		[ self requestHandler handle: aRequestContext ]		on: WAResponseNotification		do: [ :n | "got a response" ]</body><body package="Seaside-Core">process: aNativeRequest	"Process aNativeRequest by converting to a request context, handling the request, and converting the request context back to a native response. Make sure to release the context after processing, to help the garbage collector and avoid having large streams and sockets hanging around if people still refer to the obsolete request context."	| context |	context := self contextFor: aNativeRequest.	^ [ self handle: context; responseFrom: context ]		ensure: [ context destroy ]</body></methods><methods><class-id>Seaside.WAServerAdaptor</class-id> <category>converting-request</category><body package="Seaside-Core">requestAddressFor: aNativeRequest	self subclassResponsibility</body><body package="Seaside-Core">requestBodyFor: aNativeRequest	"Answer the undecoded request body as a String."		self subclassResponsibility</body><body package="Seaside-Core">requestCookiesFor: aNativeRequest	self subclassResponsibility</body><body package="Seaside-Core">requestFieldsFor: aNativeRequest	self subclassResponsibility</body><body package="Seaside-Core">requestHeadersFor: aNativeRequest	self subclassResponsibility</body><body package="Seaside-Core">requestMethodFor: aNativeRequest	self subclassResponsibility</body><body package="Seaside-Core">requestUrlFor: aNativeRequest	self subclassResponsibility</body><body package="Seaside-Core">requestVersionFor: aNativeRequest	self subclassResponsibility</body><body package="Seaside-Core">sslSessionIdFor: aNativeRequest	"Answer the SSL session id or nil if the request wasn't made over SSL or the server adaptor does not support it.		The default implementation answers nil for compatibility and convenience reasons."	^ nil</body></methods><methods><class-id>Seaside.WAServerAdaptor</class-id> <category>registration</category><body package="Seaside-Core">unregister	self manager unregister: self</body><body package="Seaside-Core">unregistered	manager := nil</body></methods><methods><class-id>Seaside.WAServerAdaptor</class-id> <category>accessing</category><body package="Seaside-Core">codec	^ codec</body><body package="Seaside-Core">codec: aCodec	codec := aCodec</body><body package="Seaside-Core">port	^ port</body><body package="Seaside-Core">port: anObject	port := anObject</body><body package="Seaside-Core">requestHandler	"We don't set the instance variable here, if nil, because the default	request handler may change over time and we want to keep using	the current default if the user hasn't specified one."	^ requestHandler ifNil: [ self defaultRequestHandler ]</body><body package="Seaside-Core">requestHandler: aRequestHandler	requestHandler := aRequestHandler</body></methods><methods><class-id>Seaside.WAServerAdaptor</class-id> <category>defaults</category><body package="Seaside-Core">defaultCodec	^ GRNullCodec new</body><body package="Seaside-Core">defaultPort	^ 8080</body><body package="Seaside-Core">defaultRequestHandler	^ WADispatcher default</body></methods><methods><class-id>Seaside.WAServerAdaptor</class-id> <category>testing</category><body package="Seaside-Core">canStart	^ manager notNil and: [ self manager canStart: self ]</body><body package="Seaside-Core">canStop	^ manager notNil and: [ self manager canStop: self ]</body><body package="Seaside-Core">isRunning	self subclassResponsibility</body><body package="Seaside-Core">isStarting	self subclassResponsibility</body><body package="Seaside-Core">isStopped	self subclassResponsibility</body><body package="Seaside-Core">isStopping	self subclassResponsibility</body></methods><methods><class-id>Seaside.WAServerAdaptor</class-id> <category>accessing-readonly</category><body package="Seaside-Core">additionalStatusOn: aStream</body><body package="Seaside-Core">manager	^ manager</body><body package="Seaside-Core">statusString	^ self isRunning		ifTrue: [ 'running' ]		ifFalse: [ 'stopped' ]</body></methods><methods><class-id>Seaside.WAServerAdaptor</class-id> <category>starting/stopping</category><body package="Seaside-Core">kill	self basicStop</body><body package="Seaside-Core">restart	self manager restart: self</body><body package="Seaside-Core">start	self manager start: self</body><body package="Seaside-Core">stop	self manager stop: self</body></methods><methods><class-id>Seaside.WAServerAdaptor</class-id> <category>converting</category><body package="Seaside-Core">contextFor: aNativeRequest	"Answer a request context for aNativeRequest."	^ WARequestContext		request: (self requestFor: aNativeRequest)		response: (self responseFor: aNativeRequest)		codec: self codec</body><body package="Seaside-Core">requestFor: aNativeRequest	"Answer a request object for aNativeRequest."	^ (WARequest		method: (self requestMethodFor: aNativeRequest)		uri: (self requestUrlFor: aNativeRequest)		version: (self requestVersionFor: aNativeRequest))			setHeaders: (self requestHeadersFor: aNativeRequest);			setBody: (self requestBodyFor: aNativeRequest);			setPostFields: (self requestFieldsFor: aNativeRequest);			setCookies: (self requestCookiesFor: aNativeRequest);			setRemoteAddress: (self requestAddressFor: aNativeRequest);			setSslSessionId: (self sslSessionIdFor: aNativeRequest);			yourself</body><body package="Seaside-Core">responseFor: aNativeRequest	"Answer a response object for aNativeRequest."	^ WABufferedResponse on: (self codec encoderFor: (GRPlatform current writeCharacterStreamOn: String new))</body><body package="Seaside-Core">responseFrom: aRequestContext	"Answer a native response from aRequestContext."	self subclassResponsibility</body></methods><methods><class-id>Seaside.WAServerAdaptor</class-id> <category>initialization</category><body package="Seaside-Core">initialize	super initialize.	codec := self defaultCodec.	port := self defaultPort</body><body package="Seaside-Core">initializeWithManager: aServerManager	self initialize.	manager := aServerManager</body></methods><methods><class-id>Seaside.WAServerAdaptor class</class-id> <category>testing</category><body package="Seaside-Core">isAbstract	^ self name = #WAServerAdaptor</body></methods><methods><class-id>Seaside.WAServerAdaptor class</class-id> <category>instance creation</category><body package="Seaside-Core">manager: aServerManager	^ aServerManager register: 		(self basicNew			initializeWithManager: aServerManager;			yourself)</body><body package="Seaside-Core">new	^ self manager: WAServerManager default</body><body package="Seaside-Core">port: anInteger	^ self new		port: anInteger;		yourself</body></methods><methods><class-id>Seaside.WAUrlEncoder class</class-id> <category>private</category><body package="Seaside-Core">encode: aCharacter on: aStream 	| printer |	('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.~' includes: aCharacter) ifTrue: [ ^ aStream nextPut: aCharacter ].	aStream nextPut: $%.	printer := GRNumberPrinter new.	printer		base: 16;		padding: $0;		digits: 2;		uppercase.	printer 		print: aCharacter greaseInteger		on: aStream</body><body package="Seaside-Core">maximumCharacterValue	"String to byte encoding has already happened in the server."		^ 16rFF</body></methods><methods><class-id>Seaside.WAUrlEncoder class</class-id> <category>instance creation</category><body package="Seaside-Core">on: aStream codec: aCodec	^ aCodec url encoderFor: (self on: aStream table: table)</body></methods><methods><class-id>Seaside.WAUrlEncoder class</class-id> <category>initialization</category><body package="Seaside-Core">initialize	self initializeTable</body><body package="Seaside-Core">initializeTable	"Initializes the encoding table."	| stream characterLimit |	characterLimit := self maximumCharacterValue.	"character values at zero so we need to add 1"	table := Array new: characterLimit + 1.	stream := WriteStream on: (String new: 6).	0 to: characterLimit do: [ :index | 		| character value |		character := Character codePoint: index.		self encode: character on: stream reset.		"Smalltalk indices are one based but character values start at 0"		value := stream contents = (String with: character)			ifTrue: [ nil ]			ifFalse: [ stream contents ].		table at: index + 1 put: value ]</body></methods><methods><class-id>Seaside.WAHttpVersion</class-id> <category>comparing</category><body package="Seaside-Core">&lt; otherVersion	^ (major &lt; otherVersion major) or: [		(major = otherVersion major) and: [ minor &lt; otherVersion minor ] ]</body><body package="Seaside-Core">&lt;= otherVersion	^ (self = otherVersion) or: [ self &lt; otherVersion ]</body><body package="Seaside-Core">= otherVersion	^ (major = otherVersion major) and: [ minor = otherVersion minor ]</body><body package="Seaside-Core">&gt; otherVersion	^ (major &gt; otherVersion major) or: [		(major = otherVersion major) and: [ minor &gt; otherVersion minor ] ]</body><body package="Seaside-Core">&gt;= otherVersion	^ (self = otherVersion) or: [ self &gt; otherVersion ]</body><body package="Seaside-Core">hash	^ major hash bitXor: minor hash</body></methods><methods><class-id>Seaside.WAHttpVersion</class-id> <category>printing</category><body package="Seaside-Core">printOn: aStream	aStream nextPutAll: 'HTTP/'.	major printOn: aStream.	aStream nextPut: $..	minor printOn: aStream</body></methods><methods><class-id>Seaside.WAHttpVersion</class-id> <category>testing</category><body package="Seaside-Core">isHttp10	^ major = 1 and: [ minor = 0 ]</body><body package="Seaside-Core">isHttp11	^ major = 1 and: [ minor = 1 ]</body></methods><methods><class-id>Seaside.WAHttpVersion</class-id> <category>accessing</category><body package="Seaside-Core">major	^ major</body><body package="Seaside-Core">minor	^ minor</body></methods><methods><class-id>Seaside.WAHttpVersion</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithMajor: majorInteger minor: minorInteger	self initialize.	major := majorInteger.	minor := minorInteger</body></methods><methods><class-id>Seaside.WAHttpVersion class</class-id> <category>instance creation</category><body package="Seaside-Core">fromString: aString	^ self readFrom: aString readStream</body><body package="Seaside-Core">http10	^ self major: 1 minor: 0</body><body package="Seaside-Core">http11	^ self major: 1 minor: 1</body><body package="Seaside-Core">major: majorInteger minor: minorInteger	^ self basicNew		initializeWithMajor: majorInteger minor: minorInteger;		yourself</body><body package="Seaside-Core">new	^ self http11</body><body package="Seaside-Core">readFrom: aStream 	| major minor |	[ aStream peek = Character space ] whileTrue: [ aStream next ].	aStream peek = $H ifTrue: [ aStream skipTo: $/ ].	"Skip over 'HTTP/' "	major := aStream upTo: $..	minor := aStream upTo: Character space.	^ self 		major: major greaseInteger		minor: minor greaseInteger</body></methods><methods><class-id>Seaside.WAFileLibrary</class-id> <category>accessing</category><body package="Seaside-Core">cacheDuration	"Answer the duration the response should be cached by the user agent."	^ self class defaultCacheDuration</body><body package="Seaside-Core">documentOf: aSelector	^ self perform: aSelector</body><body package="Seaside-Core">fileSizeOf: aSymbol	^ (self perform: aSymbol) size</body><body package="Seaside-Core">mimetypeForFile: aFilename	^ self class mimetypeFor: (aFilename copyAfterLast: $.)</body><body package="Seaside-Core">mimetypeOf: aSelector	^ self mimetypeForFile: (self asFilename: aSelector)</body></methods><methods><class-id>Seaside.WAFileLibrary</class-id> <category>actions</category><body package="Seaside-Core">deployFiles	"Write to disk the files that the receiver use to serve as methods.	The files are stored in a subfolder named like the classname of the receiver in a subfolder of Smalltalk image folder."	GRPlatform current ensureExistenceOfFolder: self name.	self fileSelectors do: [ :each | 		GRPlatform current 			write: (self perform: each)			toFile: (self asFilename: each)			inFolder: self name ]</body></methods><methods><class-id>Seaside.WAFileLibrary</class-id> <category>private</category><body package="Seaside-Core">asFilename: aSelector 	| dotIndex extension |	dotIndex := self lastUpperCaseIndexIn: aSelector.	dotIndex = 0 ifTrue: [		"convert Symbol to String"		^ aSelector greaseString ].	extension := (aSelector last: aSelector size - dotIndex + 1) asLowercase.	^ (aSelector first: dotIndex - 1) , '.' , extension</body><body package="Seaside-Core">fileSelectors	"deliberately name WAFileLibrary rather than self class"	^ self fileSelectorsTo: WAFileLibrary</body></methods><methods><class-id>Seaside.WAFileLibrary</class-id> <category>handling</category><body package="Seaside-Core">handle: aRequestContext	| fileName selector fileHandler |	fileName := aRequestContext consumer next.	selector := self asSelector: fileName.	(self fileSelectors includes: selector) 		ifFalse: [ ^ self ].		fileHandler := aRequestContext handler.	fileHandler useXSendfile		ifTrue: [			aRequestContext respond: [ :response |				response					cacheFor: self cacheDuration;					headerAt: 'X-Sendfile' put: (self fullPathForFileName: fileName using: fileHandler);					contentType: (self mimetypeOf: selector) ] ]		ifFalse: [			aRequestContext respond: [ :response |				response					cacheFor: self cacheDuration;					document: (self documentOf: selector)					mimeType: (self mimetypeOf: selector) ] ]</body></methods><methods><class-id>Seaside.WAFileLibrary class</class-id> <category>convenience</category><body package="Seaside-Core">register	"no longer needed left in so that code can still be loaded since it is sent in class side initialize methods"</body><body package="Seaside-Core">unregister	"no longer used"</body></methods><methods><class-id>Seaside.WAFileLibrary class</class-id> <category>migrating</category><body package="Seaside-Core">migrateSubclassesSeaside29	"migrates all subclasses of the receiver to Seaside 2.9	you should not send this message to WAFileLibrary because that will also migrate the classes in Seaside"	self allSubclassesDo: [ :each |		each migrateToSeaside29 ]</body><body package="Seaside-Core">migrateToSeaside29	"migrates only the receiver to Seaside 2.9"	(self default fileSelectors intersection: self selectors) do: [ :each |		| contents |		contents := (self default perform: each).		(contents isKindOf: ByteArray) ifTrue: [			| file |			file := WAFile new				contents: contents;				fileName: (self default asFilename: each);				yourself.			self default addFile: file ] ]</body></methods><methods><class-id>Seaside.WAFileLibrary class</class-id> <category>vw port-squeak</category><body package="Seaside-Core">adjustForVisualWorks	| newSource oldSource badCode goodCode |	badCode := 'xxxCache := #(nil).'.	goodCode := 'xxxCache := #(nil) beMutable.'.	self selectors do: [ :selector |		oldSource := self sourceCodeAt: selector.		(oldSource indexOfSubCollection: badCode startingAt: 1) &gt; 0 ifTrue: [			newSource := oldSource copyReplaceAll: badCode with: goodCode.			self compile: newSource classified: self methodCategory ] ]</body></methods><methods><class-id>Seaside.WAFileLibrary class</class-id> <category>file addition</category><body package="Seaside-Core">addFileNamed: aFilename contents: aByteArrayOrString	| selector |	selector := self asSelector: aFilename.	(self isBinary: aFilename)		ifTrue: [ self compileBinary: aByteArrayOrString selector: selector ]		ifFalse: [ self compileText: aByteArrayOrString selector: selector ]</body></methods><methods><class-id>Seaside.WARenderContext</class-id> <category>private</category><body package="Seaside-Core">defaultVisitor	^ WARenderVisitor context: self</body></methods><methods><class-id>Seaside.WARenderContext</class-id> <category>initialization</category><body package="Seaside-Core">destroy	self document destroy.	document := nil</body><body package="Seaside-Core">initialize	super initialize.	callbacks := WACallbackRegistry new</body></methods><methods><class-id>Seaside.WARenderContext</class-id> <category>accessing</category><body package="Seaside-Core">absoluteUrlForResource: aString 	| url |	aString isNil ifTrue: [ ^ nil ].	url := self resourceUrl.	(url isNil or: [ (aString indexOfSubCollection: '://' startingAt: 1) ~= 0 ]) ifTrue: [		^ WAUrl absolute: aString ].	^ url copy addToPath: aString; yourself</body><body package="Seaside-Core">actionBaseUrl	"Answer the action URL, that was not modified by #updateUrl:."		^ actionBaseUrl</body><body package="Seaside-Core">actionBaseUrl: anObject	actionBaseUrl := anObject seasideUrl</body><body package="Seaside-Core">actionUrl	"Answer the action URL that was modified by #updateUrl:."	^ actionUrl</body><body package="Seaside-Core">actionUrl: anObject	actionUrl := anObject seasideUrl</body><body package="Seaside-Core">callbacks	^ callbacks</body><body package="Seaside-Core">document	"Answer the value of document"	^ document</body><body package="Seaside-Core">document: anObject	"Set the value of document"	document := anObject</body><body package="Seaside-Core">document: aDocument during: aBlock	"Set the value of document for the duration of aBlock"	| previous |	previous := document.	[ document := aDocument.	aBlock value ]		ensure: [ document := previous ]</body><body package="Seaside-Core">properties	"Answer a property dictionary."	^ properties ifNil: [ properties := GRSmallDictionary new ]</body><body package="Seaside-Core">resourceUrl	^ resourceUrl</body><body package="Seaside-Core">resourceUrl: anObject	resourceUrl := anObject seasideUrl</body><body package="Seaside-Core">visitor	^ visitor ifNil: [ visitor := self defaultVisitor ]</body><body package="Seaside-Core">visitor: anObject	visitor := anObject</body></methods><methods><class-id>Seaside.WARenderContext</class-id> <category>copying</category><body package="Seaside-Core">postCopy	super postCopy.	visitor := visitor copyForRenderContext: self.	actionUrl := actionUrl copy.	resourceUrl := resourceUrl copy.	properties := properties copy</body></methods><methods><class-id>Seaside.WARenderContext</class-id> <category>callbacks</category><body package="Seaside-Core">callbackAt: aString	self greaseDeprecatedApi: 'WARenderContext&gt;&gt;#callbackAt:' details: 'Report if you still need it.'.	^ callbacks at: aString ifAbsent: [ ]</body></methods><methods><class-id>Seaside.WADispatchCallback</class-id> <category>initialization</category><body package="Seaside-Core">setKey: aString callbacks: aDictionary	super setKey: aString callbacks: aDictionary.	callbacks := aDictionary</body></methods><methods><class-id>Seaside.WADispatchCallback</class-id> <category>evaluation</category><body package="Seaside-Core">evaluateWithArgument: anObject	callbacks at: anObject ifPresent: [ :callback | callback evaluateWithFieldValues: #(nil) ]</body></methods><methods><class-id>Seaside.WATransactionFilter</class-id> <category>testing</category><body package="Seaside-Core">isClosed	^ closed</body></methods><methods><class-id>Seaside.WATransactionFilter</class-id> <category>initialization</category><body package="Seaside-Core">initialize	super initialize.	closed := false</body></methods><methods><class-id>Seaside.WATransactionFilter</class-id> <category>processing</category><body package="Seaside-Core">handleFiltered: aRequestContext 	self isClosed 		ifFalse: [ super handleFiltered: aRequestContext ]		ifTrue: [ 			aRequestContext responseGenerator				pageExpired;				respond ]</body></methods><methods><class-id>Seaside.WATransactionFilter</class-id> <category>actions</category><body package="Seaside-Core">close	closed := true</body></methods><methods><class-id>Seaside.WABuilder</class-id> <category>accessing</category><body package="Seaside-Core">actionUrl	^ actionUrl ifNil: [ actionUrl := WAUrl new ]</body><body package="Seaside-Core">actionUrl: aUrl	actionUrl := aUrl</body><body package="Seaside-Core">codec	^ codec ifNil: [		 codec := [ self requestContext codec ] 			on: WARequestContextNotFound			do: [ :e | GRNullCodec new ] ]</body><body package="Seaside-Core">codec: aCodec	codec := aCodec</body><body package="Seaside-Core">documentClass	^ documentClass ifNil: [ documentClass := WADocument ]</body><body package="Seaside-Core">documentClass: aDocumentClass	documentClass := aDocumentClass</body><body package="Seaside-Core">fullDocument	^ fullDocument</body><body package="Seaside-Core">fullDocument: aBoolean	fullDocument := aBoolean</body><body package="Seaside-Core">rendererClass	^ rendererClass</body><body package="Seaside-Core">rendererClass: aRendererClass 	rendererClass := aRendererClass</body><body package="Seaside-Core">resourceUrl	^ resourceUrl</body><body package="Seaside-Core">resourceUrl: aUrl	resourceUrl := aUrl</body><body package="Seaside-Core">rootBlock	^ rootBlock ifNil: [ rootBlock := [ :root | ] ]</body><body package="Seaside-Core">rootBlock: anObject	rootBlock := anObject</body><body package="Seaside-Core">rootClass	^ rootClass ifNil: [ rootClass := WARoot ]</body><body package="Seaside-Core">rootClass: aRootClass	rootClass := aRootClass</body><body package="Seaside-Core">scriptGeneratorClass	^ scriptGeneratorClass ifNil: [ scriptGeneratorClass := WADefaultScriptGenerator  ]</body><body package="Seaside-Core">scriptGeneratorClass: aScriptGeneratorClass	scriptGeneratorClass := aScriptGeneratorClass</body></methods><methods><class-id>Seaside.WABuilder</class-id> <category>private</category><body package="Seaside-Core">closeDocument: aDocument	self fullDocument 		ifTrue: [ aDocument close ]		ifFalse: [ 			"hack to make it work"			(aDocument isKindOf: WAHtmlDocument)				ifTrue: [ aDocument scriptGenerator closeOn: aDocument ] ]</body><body package="Seaside-Core">openDocument: aDocument context: aContext 	| documentRoot |	self fullDocument ifFalse: [ ^ self ].	documentRoot := self rootClass context: aContext.	self rootBlock value: documentRoot.	aDocument open: documentRoot</body></methods><methods><class-id>Seaside.WABuilder</class-id> <category>initialization</category><body package="Seaside-Core">initialize	super initialize.	self fullDocument: false</body></methods><methods><class-id>Seaside.WABuilder</class-id> <category>rendering</category><body package="Seaside-Core">render: anObject	"Render anObject and return the contents of the resulting Document as a String.	anObject must understand #renderOn:. Commonly anObject will be a one-argument	block, which will be evaluated with the appropriate renderer."		^ String streamContents: [ :stream |		| context document renderer |		document := self documentClass on: stream codec: self codec.		document scriptGenerator: self scriptGeneratorClass new.		context := WARenderContext new.		context document: document.		context actionUrl: self actionUrl; resourceUrl: self resourceUrl.		renderer := self rendererClass context: context.				self openDocument: document context: context.		renderer render: anObject; flush.		self closeDocument: document ]</body></methods><methods><class-id>Seaside.WABuilder class</class-id> <category>instance creation</category><body package="Seaside-Core">on: aRendererClass	^ self new		rendererClass: aRendererClass;		yourself</body></methods><methods><class-id>Seaside.WAStreamedResponse</class-id> <category>testing</category><body package="Seaside-Core">isCommitted	^ committed</body><body package="Seaside-Core">isStreamingResponse	"Return true if the receiver supports partial stream responses."	^ true</body></methods><methods><class-id>Seaside.WAStreamedResponse</class-id> <category>initialization</category><body package="Seaside-Core">destroy	super destroy.	externalStream := nil</body><body package="Seaside-Core">initializeOn: aStream 	super initializeOn: aStream.	committed := false.	externalStream := aStream</body></methods><methods><class-id>Seaside.WAStreamedResponse</class-id> <category>writing</category><body package="Seaside-Core">writeContentOn: aStream 	committed := true</body></methods><methods><class-id>Seaside.WAStreamedResponse</class-id> <category>public</category><body package="Seaside-Core">flush	"Flush the status code and header fields, if they haven't been written yet."	self isCommitted		ifFalse: [ self writeOn: externalStream ].	externalStream flush</body></methods><methods><class-id>Seaside.WAStreamedResponse</class-id> <category>accessing-cookies</category><body package="Seaside-Core">addCookie: aCookie	self committedCheck.	^ super addCookie: aCookie</body></methods><methods><class-id>Seaside.WAStreamedResponse</class-id> <category>accessing</category><body package="Seaside-Core">stream	self flush.	^ externalStream</body></methods><methods><class-id>Seaside.WAStreamedResponse</class-id> <category>accessing-headers</category><body package="Seaside-Core">headerAt: aString append: aValue	self committedCheck.	^ super headerAt: aString append: aValue</body><body package="Seaside-Core">headerAt: aString put: aValue	self committedCheck.	^ super headerAt: aString put: aValue</body><body package="Seaside-Core">removeHeaderAt: aString	self committedCheck.	^ super removeHeaderAt: aString</body></methods><methods><class-id>Seaside.WAStreamedResponse</class-id> <category>accessing-status</category><body package="Seaside-Core">status: aNumber message: aString	self committedCheck.	super status: aNumber message: aString</body></methods><methods><class-id>Seaside.WAStreamedResponse</class-id> <category>streaming</category><body package="Seaside-Core">binary	"put the response stream into binary mode"	externalStream binary</body></methods><methods><class-id>Seaside.WAStreamedResponse</class-id> <category>private</category><body package="Seaside-Core">committedCheck	"Raises a signal if this response is already committed."	self isCommitted 		ifTrue: [ WAIllegalStateException signal ]</body></methods><methods><class-id>Seaside.WAStreamedResponse</class-id> <category>convenience</category><body package="Seaside-Core">resetIfPossible	^ self isCommitted not and: [		"Reset only if not committed.		Stream does not have to be reset because it isn't committed yet.		(it couldn't be reset anyway because it's a SocketStream)"		super resetIfPossible  ]</body></methods><methods><class-id>Seaside.WAStreamedResponse class</class-id> <category>instance creation</category><body package="Seaside-Core">on: aStream	^ self basicNew initializeOn: aStream</body></methods><methods><class-id>Seaside.WAMergedRequestFields</class-id> <category>enumerating</category><body package="Seaside-Core">allAt: aKey	^ Array streamContents: [ :stream |		delegates do: [ :each | stream nextPutAll: (each allAt: aKey) ] ]</body><body package="Seaside-Core">allAt: aKey ifAbsent: absentBlock	| result |	result := self allAt: aKey.	^ result isEmpty		ifTrue: [ absentBlock value ]		ifFalse: [ result ]</body><body package="Seaside-Core">associationsDo: aBlock	delegates do: [ :each | each associationsDo: aBlock ]</body><body package="Seaside-Core">do: aBlock	delegates do: [ :each | each do: aBlock ]</body><body package="Seaside-Core">keys	^ Array streamContents: [ :stream |		delegates do: [ :each | stream nextPutAll: each keys ] ]</body><body package="Seaside-Core">keysAndValuesDo: aBlock	delegates do: [ :each | each keysAndValuesDo: aBlock ]</body><body package="Seaside-Core">keysDo: aBlock	delegates do: [ :each | each keysDo: aBlock ]</body><body package="Seaside-Core">values	^ Array streamContents: [ :stream |		delegates do: [ :each | stream nextPutAll: each values ] ]</body></methods><methods><class-id>Seaside.WAMergedRequestFields</class-id> <category>accessing</category><body package="Seaside-Core">at: aKey	^ self at: aKey ifAbsent: [ self errorKeyNotFound ]</body><body package="Seaside-Core">at: aKey ifAbsent: aBlock	delegates do: [ :each |		each			at: aKey			ifPresent: [ :value | ^ value ] ].	^ aBlock value</body><body package="Seaside-Core">at: aKey ifPresent: aBlock	delegates do: [ :each |		each			at: aKey			ifPresent: [ :value | ^ aBlock value: value ] ].	^ nil</body><body package="Seaside-Core">size	^ delegates inject: 0 into: [ :result :each | result + each size ]</body></methods><methods><class-id>Seaside.WAMergedRequestFields</class-id> <category>initialization</category><body package="Seaside-Core">initializeOn: anArray	self initialize.	delegates := anArray</body></methods><methods><class-id>Seaside.WAMergedRequestFields</class-id> <category>testing</category><body package="Seaside-Core">includesKey: aKey	^ delegates anySatisfy: [ :each | each includesKey: aKey ]</body><body package="Seaside-Core">isEmpty	^ delegates allSatisfy: [ :each | each isEmpty ]</body></methods><methods><class-id>Seaside.WAMergedRequestFields</class-id> <category>private</category><body package="Seaside-Core">errorKeyNotFound	^ nil</body></methods><methods><class-id>Seaside.WAMergedRequestFields class</class-id> <category>instance creation</category><body package="Seaside-Core">new	self error: self name , ' is created with #on:'</body><body package="Seaside-Core">on: anArray	^ self basicNew initializeOn: anArray</body></methods><methods><class-id>Seaside.WAHashTableSizes class</class-id> <category>initialize-release</category><body package="Seaside-Core">initialize	"Throw away any previously-cached sizes, then compute and cache the sizes."	"WAHashTableSizes initialize"		sizes := nil.	self sizes</body></methods><methods><class-id>Seaside.WAHashTableSizes class</class-id> <category>public</category><body package="Seaside-Core">atLeast: lowerLimit	"Answer the next good size &gt;= lowerlimit.	If lowerLimit is larger than the largest known good prime,	just make it odd."	| primes low mid high prime |	primes := self sizes.	low := 1.	high := primes size.	lowerLimit &gt; (primes at: high)		ifTrue: [			^ lowerLimit even				ifTrue: [ lowerLimit + 1 ]				ifFalse: [ lowerLimit ] ].	[ mid := (high - low) // 2 + low.	prime := primes at: mid.	prime &lt; lowerLimit		ifTrue: [ low := mid ]		ifFalse: [ high := mid ].	high - low &lt;= 1		ifTrue: [ ^ primes at: high ] ] repeat</body></methods><methods><class-id>Seaside.WAHashTableSizes class</class-id> <category>private</category><body package="Seaside-Core">sizes	sizes isNil		ifTrue: [ sizes := #(0 7 11 13 17 23 29 31 37 41 47 53 61 73 79 97 107 137 163 181 211 239 293 347 367 463 557 643 727 859 1097 1279 1451 1663 2213 2531 2897 3329 3823 4391 5051 5801 6659 7643 8783 10091 11587 13313 15287 17569 20173 23173 26627 35129 40343 46349 53233 70241 80687 92683 106487 140521 161377 185369 212969 244589 280963 322747 370759 425857 489179 561923 645481 741457 851723 1123841 1290983 1482919 1703437 2247673 2581907 2965847 3406841 4495357 5163797 5931649 6813673 8990687 10327627 11863289 13627357 17981399 20655181 23726569 27254671 35962753 41310361 47453149 54509341 71925533 82620719 94906297 109018691 143851009 165241457 189812533 218037343 287702021 330482857 379625083 436074697 575404003 660965629 759250133 872149373 1001836547) ].	^ sizes</body></methods><methods><class-id>Seaside.WADefaultScriptGenerator</class-id> <category>actions</category><body package="Seaside-Core">close: aHtmlRoot on: aDocument	self 		writeScriptTag: [			aDocument nextPutAll: 'function onLoad(){'.			self writeLoadScriptsOn: aDocument.			aDocument nextPutAll: '};' ]		on: aDocument</body><body package="Seaside-Core">open: aHtmlRoot on: aDocument	aHtmlRoot bodyAttributes at: 'onload' put: 'onLoad()'</body></methods><methods><class-id>Seaside.WAValueHolder</class-id> <category>accessing</category><body package="Seaside-Core">contents	^ contents</body><body package="Seaside-Core">contents: anObject	contents := anObject</body></methods><methods><class-id>Seaside.WAValueHolder</class-id> <category>printing</category><body package="Seaside-Core">printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' contents: '; print: self contents</body></methods><methods><class-id>Seaside.WAValueHolder class</class-id> <category>instance creation</category><body package="Seaside-Core">with: anObject	^ self new contents: anObject</body></methods><methods><class-id>Seaside.WAMutex</class-id> <category>copying</category><body package="Seaside-Core">copy	^ self species new</body></methods><methods><class-id>Seaside.WAMutex</class-id> <category>mutual exclusion</category><body package="Seaside-Core">critical: aBlock	| process |	process := Processor activeProcess.	^ (self owner == process)		ifTrue: [ aBlock value ]		ifFalse: [			semaphore critical: [				self owner: process.				aBlock ensure: [ self owner: nil ] ] ]</body><body package="Seaside-Core">terminateOwner	| o |	o := self owner.	o isNil ifFalse: [ GRPlatform current terminateProcess: o ]</body></methods><methods><class-id>Seaside.WAMutex</class-id> <category>initialization</category><body package="Seaside-Core">initialize	super initialize.	semaphore := GRPlatform current semaphoreClass forMutualExclusion.	owner := GRPlatform current newTransientValueHolder</body></methods><methods><class-id>Seaside.WAMutex</class-id> <category>accessing</category><body package="Seaside-Core">owner	^ owner contents</body><body package="Seaside-Core">owner: aProcess	owner contents: aProcess</body></methods><methods><class-id>Seaside.WAUpdateUrlVisitor</class-id> <category>visiting</category><body package="Seaside-Core">visitPainter: aPainter	aPainter updateUrl: self url</body></methods><methods><class-id>Seaside.WAUpdateUrlVisitor</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithUrl: aUrl	self initialize.	url := aUrl</body></methods><methods><class-id>Seaside.WAUpdateUrlVisitor</class-id> <category>accessing</category><body package="Seaside-Core">url	^ url</body></methods><methods><class-id>Seaside.WAUpdateUrlVisitor class</class-id> <category>instance creation</category><body package="Seaside-Core">new	^ self url: WAUrl new</body><body package="Seaside-Core">url: aUrl	^ self basicNew initializeWithUrl: aUrl; yourself</body></methods><methods><class-id>Seaside.WABulkReapingCacheEntry</class-id> <category>initialization</category><body package="Seaside-Core">initializeWithValue: anObject	| now |	self initialize.	value := anObject.	now := Time totalSeconds.	creationTime := now.	accessTime := now.	count := GRPlatform current newReducedConflictCounter.	lastCount := 0</body></methods><methods><class-id>Seaside.WABulkReapingCacheEntry</class-id> <category>accessing</category><body package="Seaside-Core">accessTime	^ accessTime</body><body package="Seaside-Core">creationTime	^ creationTime</body><body package="Seaside-Core">value	^ value</body><body package="Seaside-Core">value: anObject	| now |	now := Time totalSeconds.	accessTime := now.	creationTime := now.	value := anObject</body></methods><methods><class-id>Seaside.WABulkReapingCacheEntry</class-id> <category>public</category><body package="Seaside-Core">incrementCount	count increment</body><body package="Seaside-Core">setAccessTime: anInteger	accessTime := anInteger.	lastCount := count value</body></methods><methods><class-id>Seaside.WABulkReapingCacheEntry</class-id> <category>testing</category><body package="Seaside-Core">hasBeenAccessedSinceLastReap	^ count value &gt; lastCount</body></methods><methods><class-id>Seaside.WABulkReapingCacheEntry class</class-id> <category>instance creation</category><body package="Seaside-Core">value: anObject	^ self basicNew		initializeWithValue: anObject;		yourself</body></methods><methods><class-id>Core.Object</class-id> <category>*seaside-core</category><body package="Seaside-Core">encodeOn: aDocument 	aDocument print: self greaseString</body></methods><methods><class-id>Core.Object</class-id> <category>*seaside-core-document</category><body package="Seaside-Core">isConcatenatedHtmlAttributeValue	^ false</body></methods><methods><class-id>Core.Object</class-id> <category>*seaside-core</category><body package="Seaside-Core">labelForSelector: aSymbol	^ aSymbol asCapitalizedPhrase</body><body package="Seaside-Core">renderOn: aRenderer	"This method is called on all objects passed as an argument to the #render: method of a WARenderer subclass. Override this method to customize how objects render themselves. The default is the return value of #displayString.	Subclasses of WAPainter (including Components) should override #renderContentOn: and #rendererClass instead."	aRenderer text: self</body></methods><methods><class-id>Core.String</class-id> <category>*seaside-core</category><body package="Seaside-Core">asCapitalizedPhrase	| read words currentWord capitalizedWord |	(self noneSatisfy: [ :ea | ea isLowercase ])		ifTrue: [ ^ self ].	words := WriteStream on: String new.	read := ReadStream on: self.	[ read atEnd ] whileFalse: [		currentWord := WriteStream on: String new.		currentWord nextPut: read next.		[ | x | x := read peek. x isNil or: [ x isUppercase ] ]			whileFalse: [ currentWord nextPut: read next ].		capitalizedWord := currentWord contents capitalized.			(#(Of In At A Or To By) includes: capitalizedWord)				ifTrue: [ capitalizedWord := capitalizedWord asLowercase ].		words nextPutAll: capitalizedWord.		words nextPutAll: ' ' ].	words skip: -1.	^ words contents</body><body package="Seaside-Core">encodeOn: aDocument	aDocument xmlEncoder nextPutAll: self</body><body package="Seaside-Core">renderOn: aRenderer	aRenderer text: self</body><body package="Seaside-Core">seasideMimeDocument	^ WAMimeDocument on: self mimeType: WAMimeType textPlain</body><body package="Seaside-Core">seasideMimeDocumentType: aMimeType	^ self seasideMimeDocument		mimeType: aMimeType;		yourself</body><body package="Seaside-Core">seasideMimeType	^ WAMimeType fromString: self</body><body package="Seaside-Core">seasideUrl	^ WAUrl absolute: self</body></methods><methods><class-id>Grease.GRUnsupportedEncodingError</class-id> <category>*seaside-core</category><body package="Seaside-Core">seasidePossibleCauses	^ #(		'The given encoding name is not supported on this Smalltalk dialect.'		'The given encoding name is misspelled.'	)</body></methods><methods><class-id>Core.Collection</class-id> <category>*seaside-core</category><body package="Seaside-Core">renderOn: html	self do: [ :each | html render: each ]</body></methods><methods><class-id>Core.ByteArray</class-id> <category>*seaside-core</category><body package="Seaside-Core">renderOn: aRenderer	aRenderer text: self</body><body package="Seaside-Core">seasideMimeDocument	^ WAMimeDocument on: self mimeType: WAMimeType applicationOctetStream</body><body package="Seaside-Core">seasideMimeDocumentType: aMimeType	^ self seasideMimeDocument		mimeType: aMimeType;		yourself</body></methods><methods><class-id>Core.MessageNotUnderstood</class-id> <category>*seaside-core</category><body package="Seaside-Core">seasidePossibleCauses	| causes |	self receiver isNil ifFalse: [		^ #('you sent a message this type of object doesn''t understand') ].	causes := #(		'the receiver of the message is nil'		'a class extension hasn''t been loaded correctly'		'you sent the wrong message' ) asOrderedCollection.	self message selector = #contents ifTrue: [		causes addFirst: 'you forgot to send "super initialize" in a initialize method of a component or task' ].	^ causes</body></methods><methods><class-id>Grease.GRInvalidUtf8Error</class-id> <category>*seaside-core</category><body package="Seaside-Core">seasidePossibleCauses	^ #('The input is not UTF-8 but some other encoding like ISO-8859-1.')</body></methods><methods><class-id>Grease.GRPackage class</class-id> <category>*seaside-core</category><body package="Seaside-Core">seasideCore	^ self new		name: 'Seaside-Core';		description: 'The core of Seaside, required for all packages.';		addDependency: 'Grease-Core';		url: #seasideUrl;		yourself</body></methods><methods><class-id>Core.Dictionary</class-id> <category>*seaside-core</category><body package="Seaside-Core">seasideRequestFields	^ WARequestFields withAll: self</body></methods><methods><class-id>Core.Exception</class-id> <category>*seaside-core</category><body package="Seaside-Core">seasidePossibleCauses	"Used by WAWalkback to render a list of what might have caused the receiver to be signaled.	answers a collection of strings"	^ #()</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>*seaside-core</category><body package="Seaside-Core">encodeOn: aDocument</body><body package="Seaside-Core">renderOn: html</body><body package="Seaside-Core">seasideUrl	^ self</body></methods><methods><class-id>Grease.GRSmallDictionary</class-id> <category>*seaside-core</category><body package="Seaside-Core">seasideRequestFields	^ WARequestFields withAll: self</body></methods><methods><class-id>Grease.GRPlatform class</class-id> <category>*seaside-core</category><body package="Seaside-Core">subStringsIn: aString splitBy: aCharacter do: aOneArgumentBlock	"#subStrings: can be slow on Pharo because it uses a lot of allocation so we avoid it	see issue Issue 609"	| startIndex |	startIndex := aString indexOf: aCharacter.	startIndex = 0		ifTrue: [			aString isEmpty ifFalse: [				aOneArgumentBlock value: aString ] ]		ifFalse: [			| endIndex stringSize |			stringSize := aString size.			startIndex = 1 ifFalse: [				"case where we have a path not starting with aCharacter"				aOneArgumentBlock value: (aString copyFrom: 1 to: startIndex - 1) ].			endIndex := aString indexOf: aCharacter startingAt: startIndex + 1.			[ startIndex ~= 0 ] whileTrue: [				startIndex + 1 = endIndex					ifTrue: [						"skip, avoid adding empty strings"						startIndex := endIndex.						endIndex := aString indexOf: aCharacter startingAt: startIndex + 1 ]					ifFalse: [						endIndex = 0							ifTrue: [								startIndex &lt; stringSize ifTrue: [									"avoid adding empty path if aString ends with aCharacter"									aOneArgumentBlock value: (aString copyFrom: startIndex + 1 to: stringSize) ].								startIndex := 0 ]							ifFalse: [								aOneArgumentBlock value: (aString copyFrom: startIndex + 1 to: endIndex  - 1).								startIndex := endIndex.								endIndex := aString indexOf: aCharacter startingAt: startIndex + 1 ] ] ] ]</body></methods><methods><class-id>Grease.GRPlatform</class-id> <category>*seaside-core</category><body package="Seaside-Core">doCommitTransaction	"GemStone/S should commit the transaction here."	^ self</body><body package="Seaside-Core">newReducedConflictCounter	"GemStone/S should answer an RcCounter here"	^ WAReducedConflictCounter new</body><body package="Seaside-Core">newTransientValueHolder	"GemStone/S should answer a TransientValue here"	^ WAValueHolder new</body><body package="Seaside-Core">seasideVersion	"Answer the Seaside version"	^ (GRVersion major: 3 minor: 2 revision: 0)		yourself</body><body package="Seaside-Core">sourceFileEncoding	"Answer the encoding used for source files."	^ 'ISO-8859-1'</body><body package="Seaside-Core">urlEncoderOn: aStream	"Answer an URL encoder that works on aStream.	Platforms may provide optimized implementations."	^ WAUrlEncoder on: aStream</body><body package="Seaside-Core">urlEncoderOn: aStream codec: aCodec	"Answer an URL encoder that works on aStream.	Platforms may provide optimized implementations."	^ aCodec url encoderFor: (WAUrlEncoder on: aStream)</body><body package="Seaside-Core">xmlEncoderOn: aStream	"Answer an XML encoder that works on aStream.	Platforms may provide optimized implementations."	^ WAXmlEncoder on: aStream</body></methods><initialize><class-id>Seaside.WAKeyGenerator</class-id></initialize><initialize><class-id>Seaside.WAAbstractFileLibrary</class-id></initialize><initialize><class-id>Seaside.WASystemConfiguration</class-id></initialize><initialize><class-id>Seaside.WAResponse</class-id></initialize><initialize><class-id>Seaside.WALocale</class-id></initialize><initialize><class-id>Seaside.WASharedConfiguration</class-id></initialize><initialize><class-id>Seaside.WAServerManager</class-id></initialize><initialize><class-id>Seaside.WAUrlEncoder</class-id></initialize><initialize><class-id>Seaside.WAHashTableSizes</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>GRObject</name><environment>Grease</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core</category><attributes><package>Grease-Core</package></attributes></class><class><name>GRPlatform</name><environment>Grease</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core</category><attributes><package>Grease-Core</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>WAClassListAttribute</name><environment>Seaside</environment><super>Seaside.WAListAttribute</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WARequestHandler</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filter parent configuration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><class><name>MessageNotUnderstood</name><environment>Core</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reachedDefaultHandler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>GRNotification</name><environment>Grease</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Exceptions</category><attributes><package>Grease-Core</package></attributes></class><class><name>WAResponse</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>headers cookies status message </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-HTTP</category><attributes><package>Seaside-Core</package></attributes></class><class><name>GRSmallDictionary</name><environment>Grease</environment><super>Grease.GRObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>size keys values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Collections</category><attributes><package>Grease-Core</package></attributes></class><class><name>GROrderedMultiMap</name><environment>Grease</environment><super>Grease.GRSmallDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Collections</category><attributes><package>Grease-Core</package></attributes></class><class><name>GRError</name><environment>Grease</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Exceptions</category><attributes><package>Grease-Core</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>GRUnsupportedEncodingError</name><environment>Grease</environment><super>Grease.GRError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><class><name>GRInvalidUtf8Error</name><environment>Grease</environment><super>Grease.GRError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Grease-Core-Text</category><attributes><package>Grease-Core</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>WAClassBindingAttribute</name><environment>Seaside</environment><super>Seaside.WAListAttribute</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class></st-source>