<?xml version="1.0"?><st-source><!-- Name: Atom-CoreNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: Atom is an XML-based document format that describes lists of related information known as "feeds".  Feeds are composed of a number of items, known as "entries", each with an extensible set of attached metadata.  For example, each entry has a title.The primary use case that Atom addresses is the syndication of Web content such as weblogs and news headlines to Web sites as well as directly to user agents.The specification for ATOM is available at http://tools.ietf.org/html/rfc4287Example:"	atom feed:		[atom title with: 'Example Feed'.		atom link href: 'http://example.org/'.		atom updated with: Timestamp now printAsRFC3339String.		atom author with:			[atom name with: 'John Doe'].		atom id with: 'urn:uuid:60a76c80-d399-11d9-b93C-0003939e0af6'.		atom entry with:			[atom title with: 'Atom-Powered Robots Run Amok'.			atom link href: 'http://example.org/2003/12/13/atom03'.			atom id with: 'urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a'.			atom updated: Timestamp now printAsRFC3339String.			atom summary with: 'Some text.']]"Usage:To use Seaside-Atom, you must pick up the SeasideAtom.AtomCanvas instead of using the standard WAHtmlCanvas. You can do this by overriding #rendererClass in your WAComponent subclass. The example above demonstrates how to build an Atom feed which can be verified with an external atom verifier.DbIdentifier: bear73DbTrace: 492605DbUsername: jkottDbVersion: 3.2.0 - 1DevelopmentPrerequisites: #(#(#any 'Atom-Namespace' '') #(#any 'Seaside-Core' '') #(#any 'Seaside-Canvas' ''))ExplicitPrerequisites: #()Library: truePackageName: Atom-CoreParcel: #('Atom-Core')PrerequisiteDescriptions: #(#(#name 'Atom-Namespace' #componentType #package) #(#name 'Seaside-Core' #componentType #package) #(#name 'Seaside-Canvas' #componentType #package))PrerequisiteParcels: #(#('Atom-Namespace' '') #('Seaside-Core' '') #('Seaside-Canvas' ''))PrintStringCache: (3.2.0 - 1,jkott)Version: 3.2.0 - 1Date: 3:31:29 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:31:29 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>AtomTagBrush</name><environment>Atom</environment><super>Seaside.WABrush</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tag attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atom-Core</package></attributes></class><comment><class-id>Atom.AtomTagBrush</class-id><body>TagBrush is a generic brush that renders itself as a tag in to an Atom Document.Subclasses must implement the following messages:	private		tagInstance Variables:	attributes	&lt;Dictionary&gt;	the attributes set on us before we are rendered</body></comment><class><name>CategoriesTag</name><environment>Atom</environment><super>Atom.AtomTagBrush</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atom-Core</package></attributes></class><comment><class-id>Atom.CategoriesTag</class-id><body>The "app:categories" element provides a list of the categories that can be applied to the members of a Collection. See Section 7.2.1 for the detailed definition of app:categories.The server MAY reject attempts to create or store members whose categories are not present in its categories list. A Collection that indicates the category set is open SHOULD NOT reject otherwise acceptable members whose categories are not in its categories list. The absence of an app:categories element means that the category handling of the Collection is unspecified. A "fixed" category list that contains zero categories indicates the Collection does not accept category data.</body></comment><class><name>GeneratorTag</name><environment>Atom</environment><super>Atom.AtomTagBrush</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atom-Core</package></attributes></class><comment><class-id>Atom.GeneratorTag</class-id><body>The "atom:generator" element's content identifies the agent used to generate a feed, for debugging and other purposes.</body></comment><class><name>AtomRenderHandler</name><environment>Atom</environment><super>Seaside.WARequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atom-Core</package></attributes></class><comment><class-id>Atom.AtomRenderHandler</class-id><body>AtomRenderHandler is the default handler for returning application/atom+xml from an AtomComponent using the AtomRenderCanvas.</body></comment><class><name>CollectionTag</name><environment>Atom</environment><super>Atom.AtomTagBrush</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atom-Core</package></attributes></class><comment><class-id>Atom.CollectionTag</class-id><body>The "app:collection" element describes a Collection. The app:collection element MUST contain one atom:title element.The app:collection element MAY contain any number of app:accept elements, indicating the types of representations accepted by the Collection. The order of such elements is not significant.</body></comment><class><name>AtomRenderCanvas</name><environment>Atom</environment><super>Seaside.WACanvas</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atom-Core</package></attributes></class><comment><class-id>Atom.AtomRenderCanvas</class-id><body>AtomCanvas represents an Atom Document, there are two kinds of Atom Documents: Atom Feed Documents and Atom Entry Documents.An Atom Feed Document is a representation of an Atom feed, including metadata about the feed, and some or all of the entries associated with it.  Its root is the atom:feed element.An Atom Entry Document represents exactly one Atom entry, outside of the context of an Atom feed.  Its root is the atom:entry element.This class is used to build Atom Documents, with tag brushes for each kind of Atom tag.Instance Variables:	context	&lt;WARenderingContext&gt;	the rendering context for this atom document</body></comment><class><name>LinkTag</name><environment>Atom</environment><super>Atom.AtomTagBrush</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atom-Core</package></attributes></class><comment><class-id>Atom.LinkTag</class-id><body>The "atom:link" element defines a reference from an entry or feed to a Web resource.  This specification assigns no meaning to the content (if any) of this element.</body></comment><class><name>AtomComponent</name><environment>Atom</environment><super>Seaside.WAPainter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atom-Core</package></attributes></class><comment><class-id>Atom.AtomComponent</class-id><body>AtomComponent is an abstract superclass for components that output atom feeds.</body></comment><class><name>CategoryTag</name><environment>Atom</environment><super>Atom.AtomTagBrush</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atom-Core</package></attributes></class><comment><class-id>Atom.CategoryTag</class-id><body>The atom:category element conveys information about a category associated with an entry or feed.  This specification assigns no meaning to the content (if any) of this element.</body></comment><class><name>ContentTag</name><environment>Atom</environment><super>Atom.AtomTagBrush</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atom-Core</package></attributes></class><comment><class-id>Atom.ContentTag</class-id><body>The "atom:content" element either contains or links to the content of the entry.  The content of atom:content is Language-Sensitive.</body></comment><class><name>AtomServiceCanvas</name><environment>Atom</environment><super>Seaside.WACanvas</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atom-Core</package></attributes></class><comment><class-id>Atom.AtomServiceCanvas</class-id><body>ServiceCanvas represents an Atom Service Document. These contain Workspaces which provide Atom Feed Documents.Instance Variables:	context	&lt;WARenderingContext&gt;	the rendering context for this atom document</body></comment><class><name>AtomServiceHandler</name><environment>Atom</environment><super>Seaside.WARequestHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atom-Core</package></attributes></class><comment><class-id>Atom.AtomServiceHandler</class-id><body>AtomServiceHandler is the default handler for returning application/atom+xml from an AtomComponent using the AtomServiceCanvas.</body></comment><class><name>AtomSystemConfiguration</name><environment>Atom</environment><super>Seaside.WASystemConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Atom-Core</package></attributes></class><comment><class-id>Atom.AtomSystemConfiguration</class-id><body>AtomSystemConfiguration is the default configuration for Atom*Handlers.</body></comment><methods><class-id>Atom.AtomTagBrush</class-id> <category>accessing-attributes</category><body package="Atom-Core">attributeAt: aKey	^ self attributes at: aKey</body><body package="Atom-Core">attributeAt: aKey ifAbsent: aBlock	^ self attributes at: aKey ifAbsent: aBlock</body><body package="Atom-Core">attributeAt: aKey ifAbsentPut: aBlock	^ self attributes at: aKey ifAbsentPut: aBlock</body><body package="Atom-Core">attributeAt: aKey ifPresent: aBlock	^ self attributes at: aKey ifPresent: aBlock</body><body package="Atom-Core">attributeAt: aKey put: aValue	^ self attributes at: aKey put: aValue</body><body package="Atom-Core">attributes	^attributes ifNil: [attributes := WAHtmlAttributes new]</body><body package="Atom-Core">attributes: anObject	attributes := anObject</body></methods><methods><class-id>Atom.AtomTagBrush</class-id> <category>private</category><body package="Atom-Core">after	"This template method is called directly after rendering the content of the receiver."</body><body package="Atom-Core">before	"This template method is called directly before rendering the content of the receiver."</body><body package="Atom-Core">closeTag	"Close the receiving tag onto the document."		self document closeTag: self tag</body><body package="Atom-Core">document	^ canvas document</body><body package="Atom-Core">openTag	"Open the receiving and all associated attributes onto the document."		self document openTag: self tag attributes: attributes</body><body package="Atom-Core">tag	^tag</body><body package="Atom-Core">tag: aTag	tag := aTag</body></methods><methods><class-id>Atom.AtomTagBrush</class-id> <category>accessing</category><body package="Atom-Core">base	^self attributeAt: #'xml:base' ifAbsent: [nil]</body><body package="Atom-Core">base: anObject	self attributeAt: #'xml:base' put: anObject</body><body package="Atom-Core">lang	^self attributeAt: #'xml:lang' ifAbsent: [nil]</body><body package="Atom-Core">lang: anObject	self attributeAt: #'xml:lang' put: anObject</body><body package="Atom-Core">space	^self attributeAt: #'xml:space' ifAbsent: [nil]</body><body package="Atom-Core">space: anObject	self attributeAt: #'xml:space' put: anObject</body></methods><methods><class-id>Atom.AtomTagBrush</class-id> <category>public</category><body package="Atom-Core">with: anObject	"Render anObject into the receiver. Make sure that you call #with: last in the cascade, as this method will serialize the tag onto the output document."		self openTag.	super with: [		self before.		anObject renderOn: canvas.		self after ].	self closeTag</body></methods><methods><class-id>Atom.CategoriesTag</class-id> <category>accessing</category><body package="Atom-Core">fixed	^self attributeAt: #fixed ifAbsent: [nil]</body><body package="Atom-Core">fixed: anObject	self attributeAt: #fixed put: anObject</body><body package="Atom-Core">href	"The app:collection element MUST contain an 'href' attribute, whose value gives the IRI of the Collection."	^self attributeAt: #href ifAbsent: [nil]</body><body package="Atom-Core">href: anObject	"The app:collection element MUST contain an 'href' attribute, whose value gives the IRI of the Collection."	self attributeAt: #href put: anObject</body><body package="Atom-Core">scheme	^self attributeAt: #scheme ifAbsent: [nil]</body><body package="Atom-Core">scheme: anObject	self attributeAt: #scheme put: anObject</body></methods><methods><class-id>Atom.GeneratorTag</class-id> <category>accessing</category><body package="Atom-Core">uri	"The atom:generator element MAY have a uri attribute whose value MUST be an IRI reference [RFC3987].  When dereferenced, the resulting URI (mapped from an IRI, if necessary) SHOULD produce a representation that is relevant to that agent."	^self attributeAt: #uri ifAbsent: [nil]</body><body package="Atom-Core">uri: anObject	"The atom:generator element MAY have a uri attribute whose value MUST be an IRI reference [RFC3987].  When dereferenced, the resulting URI (mapped from an IRI, if necessary) SHOULD produce a representation that is relevant to that agent."	self attributeAt: #uri put: anObject</body><body package="Atom-Core">version	"The atom:generator element MAY have a version attribute that indicates the version of the generating agent."	^self attributeAt: #version ifAbsent: [nil]</body><body package="Atom-Core">version: anObject	"The atom:generator element MAY have a version attribute that indicates the version of the generating agent."	self attributeAt: #version put: anObject</body></methods><methods><class-id>Atom.AtomRenderHandler</class-id> <category>private</category><body package="Atom-Core">setContentType: aResponse	aResponse contentType: ((WAMimeType main: 'application' sub: 'atom+xml') charset: self charSet)</body></methods><methods><class-id>Atom.AtomRenderHandler</class-id> <category>handling</category><body package="Atom-Core">handleFiltered: aRequestContext	| document context canvas rootComponent |	self setContentType: aRequestContext response.	document := aRequestContext newDocument.	context := WARenderContext new document: document.	[ canvas := AtomRenderCanvas context: context.	rootComponent := self rootClass new.		WACurrentRequestContext use: aRequestContext during: [		canvas render: rootComponent ].			document close ] ensure: [ context destroy ].	aRequestContext respond</body></methods><methods><class-id>Atom.AtomRenderHandler</class-id> <category>configuration</category><body package="Atom-Core">charSet	^ self preferenceAt: #charSet</body><body package="Atom-Core">defaultConfiguration	^ super defaultConfiguration		addParent: AtomSystemConfiguration instance;		yourself</body></methods><methods><class-id>Atom.AtomRenderHandler</class-id> <category>accessing</category><body package="Atom-Core">rootClass	^ self preferenceAt: #rootClass</body><body package="Atom-Core">rootClass: aClass	^ self preferenceAt: #rootClass put: aClass</body></methods><methods><class-id>Atom.AtomRenderHandler</class-id> <category>initialize-release</category><body package="Atom-Core">initialize	super initialize.	self addFilter: WAExceptionFilter new</body></methods><methods><class-id>Atom.AtomRenderHandler class</class-id> <category>accessing</category><body package="Atom-Core">description	^'Atom feed'</body></methods><methods><class-id>Atom.CollectionTag</class-id> <category>accessing</category><body package="Atom-Core">href	"The app:collection element MUST contain an 'href' attribute, whose value gives the IRI of the Collection."	^self attributeAt: #href ifAbsent: [nil]</body><body package="Atom-Core">href: anObject	"The app:collection element MUST contain an 'href' attribute, whose value gives the IRI of the Collection."	self attributeAt: #href put: anObject</body></methods><methods><class-id>Atom.AtomRenderCanvas</class-id> <category>tags-metadata</category><body package="Atom-Core">author	"The atom:author element is a Person construct that indicates the author of the entry or feed."	^self tag: #author</body><body package="Atom-Core">category	"The atom:category element conveys information about a category associated with an entry or feed.  This specification assigns no meaning to the content (if any) of this element."	^self brush: (CategoryTag new tag: #'category')</body><body package="Atom-Core">contributor	"The atom:contributor element is a Person construct that indicates a person or other entity who contributed to the entry or feed."	^self tag: #contributor</body><body package="Atom-Core">generator	"The atom:generator element's content identifies the agent used to generate a feed, for debugging and other purposes."	^self brush: (GeneratorTag new tag: #generator)</body><body package="Atom-Core">icon	"The atom:icon element's content is an IRI reference [RFC3987] that identifies an image that provides iconic visual identification for a feed."	^self tag: #icon</body><body package="Atom-Core">id	"The atom:id element conveys a permanent, universally unique identifier for an entry or feed."	^self tag: #id</body><body package="Atom-Core">link	"The atom:link element defines a reference from an entry or feed to a Web resource.  This specification assigns no meaning to the content (if any) of this element."	^self brush: (LinkTag new tag: #link)</body><body package="Atom-Core">logo	"The atom:logo element's content is an IRI reference [RFC3987] that identifies an image that provides visual identification for a feed."	^self tag: #logo</body><body package="Atom-Core">published	"The atom:published element is a Date construct indicating an instant in time associated with an event early in the life cycle of the entry."	^self tag: #published</body><body package="Atom-Core">rights	"The atom:rights element is a Text construct that conveys information about rights held in and over an entry or feed."	^self tag: #rights</body><body package="Atom-Core">source	"If an atom:entry is copied from one feed into another feed, then the source atom:feed's metadata (all child elements of atom:feed other than the atom:entry elements) MAY be preserved within the copied entry by adding an atom:source child element, if it is not already present in the entry, and including some or all of the source feed's Metadata elements as the atom:source element's children.  Such metadata SHOULD be preserved if the source atom:feed contains any of the child elements atom:author, atom:contributor, atom:rights, or atom:category and those child elements are not present in the source atom:entry."	^self tag: #source</body><body package="Atom-Core">subtitle	"The atom:subtitle element is a Text construct that conveys a human-readable description or subtitle for a feed."	^self brush: (ContentTag new tag: #subtitle)</body><body package="Atom-Core">summary	"The atom:summary element is a Text construct that conveys a short summary, abstract, or excerpt of an entry."	^self brush: (ContentTag new tag: #summary)</body><body package="Atom-Core">title	"The atom:title element is a Text construct that conveys a human-readable title for an entry or feed."	^self brush: (ContentTag new tag: #title)</body><body package="Atom-Core">updated	"The atom:updated element is a Date construct indicating the most recent instant in time when an entry or feed was modified in a way the publisher considers significant.  Therefore, not all modifications necessarily result in a changed atom:updated value."	^self tag: #updated</body></methods><methods><class-id>Atom.AtomRenderCanvas</class-id> <category>tags-person</category><body package="Atom-Core">email	"The atom:email element's content conveys an e-mail address associated with the person.  Person constructs MAY contain and atom:email element, but MUST NOT contain more than one.  Its content MUST conform to the addr-spec production in [RFC2822]."	^self tag: #email</body><body package="Atom-Core">name	"The atom:name element's content conveys a human-readable name for the person.  The content of atom:name is Language-Sensitive.  Person constructs MUST contain exactly one atom:name element."	^self tag: #name</body><body package="Atom-Core">uri	"The atom:uri element's content conveys an IRI associated with the person.  Person constructs MAY contain an atom:uri element, but MUST NOT contain more than one.  The content of atom:uri in a Person construct MUST be an IRI reference [RFC3987]."	^self tag: #url</body></methods><methods><class-id>Atom.AtomRenderCanvas</class-id> <category>public</category><body package="Atom-Core">raw: aString	"Emit aString unescaped onto the target document."		self flush.	self document nextPutAll: aString displayString</body><body package="Atom-Core">tag: aString	"Defines a generic tag with the name aString."		^self brush: (AtomTagBrush new tag: aString)</body></methods><methods><class-id>Atom.AtomRenderCanvas</class-id> <category>tags-container</category><body package="Atom-Core">content	"The atom:content element either contains or links to the content of the entry.  The content of atom:content is Language-Sensitive."	^self brush: (ContentTag new tag: #content)</body><body package="Atom-Core">entry	"The atom:entry element represents an individual entry, acting as a container for metadata and data associated with the entry.  This element can appear as a child of the atom:feed element, or it can appear as the document (i.e., top-level) element of a stand-alone Atom Entry Document."	^self tag: #entry</body><body package="Atom-Core">feed	"The atom:feed element is the document (i.e., top-level) element of an Atom Feed Document, acting as a container for metadata and data associated with the feed.  Its element children consist of metadata elements followed by zero or more atom:entry child elements."	^(self tag: #feed)		attributeAt: #xmlns put: 'http://www.w3.org/2005/Atom';		yourself</body></methods><methods><class-id>Atom.AtomRenderCanvas class</class-id> <category>instance creation</category><body package="Atom-Core">context: aContext callbacks: aCallbacks	^self new context: aContext</body></methods><methods><class-id>Atom.LinkTag</class-id> <category>accessing</category><body package="Atom-Core">href	"The href attribute contains the link's IRI. atom:link elements MUST have an href attribute, whose value MUST be a IRI reference [RFC3987]."	^self attributeAt: #href ifAbsent: [nil]</body><body package="Atom-Core">href: anObject	"The href attribute contains the link's IRI. atom:link elements MUST have an href attribute, whose value MUST be a IRI reference [RFC3987]."	self attributeAt: #href put: anObject</body><body package="Atom-Core">hreflang	"The hreflang attribute's content describes the language of the resource pointed to by the href attribute.  When used together with the rel='alternate', it implies a translated version of the entry. Link elements MAY have an hreflang attribute, whose value MUST be a language tag [RFC3066]."	^self attributeAt: #hreflang ifAbsent: [nil]</body><body package="Atom-Core">hreflang: anObject	"The hreflang attribute's content describes the language of the resource pointed to by the href attribute.  When used together with the rel='alternate', it implies a translated version of the entry. Link elements MAY have an hreflang attribute, whose value MUST be a language tag [RFC3066]."	self attributeAt: #hreflang put: anObject</body><body package="Atom-Core">length	"The length attribute indicates an advisory length of the linked content in octets; it is a hint about the content length of the representation returned when the IRI in the href attribute is mapped to a URI and dereferenced.  Note that the length attribute does not override the actual content length of the representation as reported by the underlying protocol.  Link elements MAY have a length attribute."	^self attributeAt: #length ifAbsent: [nil]</body><body package="Atom-Core">length: anObject	"The length attribute indicates an advisory length of the linked content in octets; it is a hint about the content length of the representation returned when the IRI in the href attribute is mapped to a URI and dereferenced.  Note that the length attribute does not override the actual content length of the representation as reported by the underlying protocol.  Link elements MAY have a length attribute."	self attributeAt: #length put: anObject</body><body package="Atom-Core">rel	"atom:link elements MAY have a rel attribute that indicates the link relation type.  If the rel attribute is not present, the link element MUST be interpreted as if the link relation type is alternate."	^self attributeAt: #rel ifAbsent: [nil]</body><body package="Atom-Core">rel: aRel	"atom:link elements MAY have a rel attribute that indicates the link relation type.  If the rel attribute is not present, the link element MUST be interpreted as if the link relation type is alternate."	self attributeAt: #rel put: aRel</body><body package="Atom-Core">title	"The title attribute conveys human-readable information about the link.  The content of the title attribute is Language-Sensitive. Entities such as &amp;amp; and &amp;lt; represent their corresponding characters (&amp; and &lt;, respectively), not markup.  Link elements MAY have a title attribute."	^self attributeAt: #title ifAbsent: [nil]</body><body package="Atom-Core">title: anObject	"The title attribute conveys human-readable information about the link.  The content of the title attribute is Language-Sensitive. Entities such as &amp;amp; and &amp;lt; represent their corresponding characters (&amp; and &lt;, respectively), not markup.  Link elements MAY have a title attribute."	self attributeAt: #title put: anObject</body><body package="Atom-Core">type	"On the link element, the type attribute's value is an advisory media type: it is a hint about the type of the representation that is expected to be returned when the value of the href attribute is dereferenced.  Note that the type attribute does not override the actual media type returned with the representation.  Link elements MAY have a type attribute, whose value MUST conform to the syntax of a MIME media type [MIMEREG]."	^self attributeAt: #type ifAbsent: [nil]</body><body package="Atom-Core">type: anObject	"On the link element, the type attribute's value is an advisory media type: it is a hint about the type of the representation that is expected to be returned when the value of the href attribute is dereferenced.  Note that the type attribute does not override the actual media type returned with the representation.  Link elements MAY have a type attribute, whose value MUST conform to the syntax of a MIME media type [MIMEREG]."	self attributeAt: #type put: anObject</body></methods><methods><class-id>Atom.LinkTag</class-id> <category>relations</category><body package="Atom-Core">beAlternate	"The value alternate signifies that the IRI in the value of the href attribute identifies an alternate version of the resource described by the containing element."	self rel: 'alternate'</body><body package="Atom-Core">beEnclosure	"The value enclosure signifies that the IRI in the value of the href attribute identifies a related resource that is potentially large in size and might require special handling.  For atom:link elements with rel='enclosure', the length attribute SHOULD be provided."	self rel: 'enclosure'</body><body package="Atom-Core">beRelated	"The value related signifies that the IRI in the value of the href attribute identifies a resource related to the resource described by the containing element.  For example, the feed for a site that discusses the performance of the search engine at http://search.example.com might contain, as a child of atom:feed:       &lt;link rel='related' href='http://search.example.com/'/&gt;       An identical link might appear as a child of any atom:entry whose content contains a discussion of that same search engine."	self rel: 'related'</body><body package="Atom-Core">beSelf	"The value self signifies that the IRI in the value of the href attribute identifies a resource equivalent to the containing element."	self rel: 'self'</body><body package="Atom-Core">beVia	"The value via signifies that the IRI in the value of the href attribute identifies a resource that is the source of the information provided in the containing element."	self rel: 'via'</body></methods><methods><class-id>Atom.AtomComponent</class-id> <category>accessing</category><body package="Atom-Core">session	self shouldNotImplement</body></methods><methods><class-id>Atom.AtomComponent</class-id> <category>rendering</category><body package="Atom-Core">rendererClass	^AtomRenderCanvas</body></methods><methods><class-id>Atom.AtomComponent class</class-id> <category>testing</category><body package="Atom-Core">canBeRoot	^ self ~= AtomComponent</body></methods><methods><class-id>Atom.CategoryTag</class-id> <category>accessing</category><body package="Atom-Core">label	"The label attribute provides a human-readable label for display in end-user applications.  The content of the label attribute is Language-Sensitive.  Entities such as &amp;amp; and &amp;lt; represent their corresponding characters (&amp; and &lt;, respectively), not markup.  Category elements MAY have a label attribute."	^self attributeAt: #label ifAbsent: [nil]</body><body package="Atom-Core">label: anObject	"The label attribute provides a human-readable label for display in end-user applications.  The content of the label attribute is Language-Sensitive.  Entities such as &amp;amp; and &amp;lt; represent their corresponding characters (&amp; and &lt;, respectively), not markup.  Category elements MAY have a label attribute."	self attributeAt: #label put: anObject</body><body package="Atom-Core">scheme	"The scheme attribute is an IRI that identifies a categorization scheme.  Category elements MAY have a scheme attribute."	^self attributeAt: #scheme ifAbsent: [nil]</body><body package="Atom-Core">scheme: anObject	"The scheme attribute is an IRI that identifies a categorization scheme.  Category elements MAY have a scheme attribute."	self attributeAt: #scheme put: anObject</body><body package="Atom-Core">term	"The term attribute is a string that identifies the category to which the entry or feed belongs.  Category elements MUST have a term attribute."	^self attributeAt: #term ifAbsent: [nil]</body><body package="Atom-Core">term: anObject	"The term attribute is a string that identifies the category to which the entry or feed belongs.  Category elements MUST have a term attribute."	self attributeAt: #term put: anObject</body></methods><methods><class-id>Atom.ContentTag</class-id> <category>accessing</category><body package="Atom-Core">src	"atom:content MAY have a src attribute, whose value MUST be an IRI reference [RFC3987].  If the src attribute is present, atom:content MUST be empty.  Atom Processors MAY use the IRI to retrieve the content and MAY choose to ignore remote content or to present it in a different manner than local content.	If the src attribute is present, the type attribute SHOULD be provided and MUST be a MIME media type [MIMEREG], rather than text, html, or xhtml.  The value is advisory; that is to say, when the corresponding URI (mapped from an IRI, if necessary) is dereferenced, if the server providing that content also provides a media type, the server-provided media type is authoritative."	^self attributeAt: #src ifAbsent: [nil]</body><body package="Atom-Core">src: anObject	"atom:content MAY have a src attribute, whose value MUST be an IRI reference [RFC3987].  If the src attribute is present, atom:content MUST be empty.  Atom Processors MAY use the IRI to retrieve the content and MAY choose to ignore remote content or to present it in a different manner than local content.	If the src attribute is present, the type attribute SHOULD be provided and MUST be a MIME media type [MIMEREG], rather than text, html, or xhtml.  The value is advisory; that is to say, when the corresponding URI (mapped from an IRI, if necessary) is dereferenced, if the server providing that content also provides a media type, the server-provided media type is authoritative."	self attributeAt: #src put: anObject</body><body package="Atom-Core">type	"On the atom:content element, the value of the type attribute MAY be one of text, html, or xhtml.  Failing that, it MUST conform to the syntax of a MIME media type, but MUST NOT be a composite type (see Section 4.2.6 of [MIMEREG]).  If neither the type attribute nor the src attribute is provided, Atom Processors MUST behave as though the type attribute were present with a value of text."	^self attributeAt: #type ifAbsent: [nil]</body><body package="Atom-Core">type: anObject	"On the atom:content element, the value of the type attribute MAY be one of text, html, or xhtml.  Failing that, it MUST conform to the syntax of a MIME media type, but MUST NOT be a composite type (see Section 4.2.6 of [MIMEREG]).  If neither the type attribute nor the src attribute is provided, Atom Processors MUST behave as though the type attribute were present with a value of text."	self attributeAt: #type put: anObject</body></methods><methods><class-id>Atom.AtomServiceCanvas</class-id> <category>tags</category><body package="Atom-Core">accept	"The content of an 'app:accept' element value is a media range as defined in [RFC2616]. The media range specifies a type of representation that can be POSTed to a Collection. The app:accept element is similar to the HTTP Accept request-header [RFC2616]. Media type parameters are allowed within app:accept, but app:accept has no notion of preference -- 'accept-params' or 'q' arguments, as specified in Section 14.1 of [RFC2616] are not significant. White space (as defined in [REC-xml]) around the app:accept element's media range is insignificant and MUST be ignored. A value of 'application/atom+xml;type=entry' MAY appear in any app:accept list of media ranges and indicates that Atom Entry Documents can be POSTed to the Collection. If no app:accept element is present, clients SHOULD treat this as equivalent to an app:accept element with the content 'application/atom+xml;type=entry'. If one app:accept element exists and is empty, clients SHOULD assume that the Collection does not support the creation of new Entries."	^self tag: #accept</body><body package="Atom-Core">categories	"The 'app:categories' element provides a list of the categories that can be applied to the members of a Collection. See Section 7.2.1 for the detailed definition of app:categories. The server MAY reject attempts to create or store members whose categories are not present in its categories list. A Collection that indicates the category set is open SHOULD NOT reject otherwise acceptable members whose categories are not in its categories list. The absence of an app:categories element means that the category handling of the Collection is unspecified. A 'fixed' category list that contains zero categories indicates the Collection does not accept category data."	^self brush: (CategoriesTag new tag: #categories)</body><body package="Atom-Core">collection	"The 'app:collection' element describes a Collection. The app:collection element MUST contain one atom:title element. The app:collection element MAY contain any number of app:accept elements, indicating the types of representations accepted by the Collection. The order of such elements is not significant. The app:collection element MAY contain any number of app:categories elements."	^self brush: (CollectionTag new tag: #collection)</body><body package="Atom-Core">service	"The root of a Service Document is the 'app:service' element. The app:service element is the container for service information associated with one or more Workspaces. An app:service element MUST contain one or more app:workspace elements."	^(self tag: #service)		attributeAt: #xmlns put: 'http://www.w3.org/2007/app';		attributeAt: #'xmlns:atom' put: 'http://www.w3.org/2005/Atom';		yourself</body><body package="Atom-Core">workspace	"Workspaces are server-defined groups of Collections. The 'app:workspace' element contains zero or more app:collection elements describing the Collections of Resources available for editing."	^self tag: #workspace</body></methods><methods><class-id>Atom.AtomServiceCanvas</class-id> <category>tags-publishing controls</category><body package="Atom-Core">control	"The 'app:control' element MAY appear as a child of an atom:entry that is being created or updated via the Atom Publishing Protocol. The app:control element MUST appear only once in an Entry. The app:control element is considered foreign markup as defined in Section 6 of [RFC4287]."	^self tag: #control</body><body package="Atom-Core">draft	"The inclusion of the 'app:draft' element represents a request by the client to control the visibility of a Member Resource. The app:draft element MAY be ignored by the server. The number of app:draft elements in app:control MUST be zero or one. The content of an app:draft element MUST be one of 'yes' or 'no'. If the element contains 'no', this indicates a client request that the Member Resource be made publicly visible. If the app:draft element is not present, then servers that support the extension MUST behave as though an app:draft element containing 'no' was sent."	^self tag: #draft</body></methods><methods><class-id>Atom.AtomServiceCanvas</class-id> <category>public</category><body package="Atom-Core">raw: aString	"Emit aString unescaped onto the target document."		self flush.	self document nextPutAll: aString displayString</body><body package="Atom-Core">tag: aString	"Defines a generic tag with the name aString."		^self brush: (AtomTagBrush new tag: aString)</body></methods><methods><class-id>Atom.AtomServiceCanvas</class-id> <category>tags-metadata</category><body package="Atom-Core">category	"The atom:category element conveys information about a category associated with an entry or feed.  This specification assigns no meaning to the content (if any) of this element."	^self brush: (CategoryTag new tag: #'atom:category')</body><body package="Atom-Core">title	"The atom:title element is a Text construct that conveys a human-readable title for an entry or feed."	^self brush: (ContentTag new tag: #'atom:title')</body></methods><methods><class-id>Atom.AtomServiceCanvas</class-id> <category>tags-collections</category><body package="Atom-Core">edited	"The 'app:edited' element is a Date construct (as defined by [RFC4287]), whose content indicates the last time an Entry was edited. If the entry has not been edited yet, the content indicates the time it was created. Atom Entry elements in Collection Documents SHOULD contain one app:edited element, and MUST NOT contain more than one."	^self tag: #edited</body></methods><methods><class-id>Atom.AtomServiceCanvas class</class-id> <category>instance creation</category><body package="Atom-Core">context: aContext callbacks: aCallbacks	^self new context: aContext</body></methods><methods><class-id>Atom.AtomServiceHandler</class-id> <category>configuration</category><body package="Atom-Core">charSet	^ self preferenceAt: #charSet</body><body package="Atom-Core">defaultConfiguration	^ super defaultConfiguration		addParent: AtomSystemConfiguration instance;		yourself</body></methods><methods><class-id>Atom.AtomServiceHandler</class-id> <category>handling</category><body package="Atom-Core">handleFiltered: aRequestContext	| document context canvas rootComponent |	self setContentType: aRequestContext response.	document := aRequestContext newDocument.	context := WARenderContext new document: document.	[ canvas := AtomServiceCanvas context: context.	rootComponent := self rootClass new.		WACurrentRequestContext use: aRequestContext during: [		canvas render: rootComponent ].			document close ] ensure: [ context destroy ].	aRequestContext respond</body></methods><methods><class-id>Atom.AtomServiceHandler</class-id> <category>accessing</category><body package="Atom-Core">rootClass	^ self preferenceAt: #rootClass</body><body package="Atom-Core">rootClass: aClass	^ self preferenceAt: #rootClass put: aClass</body></methods><methods><class-id>Atom.AtomServiceHandler</class-id> <category>initialize-release</category><body package="Atom-Core">initialize	super initialize.	self addFilter: WAExceptionFilter new</body></methods><methods><class-id>Atom.AtomServiceHandler</class-id> <category>private</category><body package="Atom-Core">setContentType: aResponse	aResponse contentType: ((WAMimeType main: 'application' sub: 'atom+xml') charset: self charSet)</body></methods><methods><class-id>Atom.AtomServiceHandler class</class-id> <category>accessing</category><body package="Atom-Core">description	^'Atom service'</body></methods><methods><class-id>Atom.AtomSystemConfiguration</class-id> <category>accessing</category><body package="Atom-Core">parents	^ Array with: WARequestHandlingConfiguration instance</body><body package="Atom-Core">rootComponents	^(AtomComponent allSubclasses select: [ :each | each canBeRoot ])		asSortedCollection: [ :a :b | a name &lt;= b name ]</body></methods><methods><class-id>Atom.AtomSystemConfiguration</class-id> <category>description</category><body package="Atom-Core">describeOn: config	(config list: #rootClass)		label: 'Root Component';		options: [ self rootComponents ].	(config string: #charSet)		label: 'Charater Set';		comment: 'The character set reported to the browser. You may additionally need to configure your server that this is also the character set used by your server.';		default: 'utf-8'.	config at: #documentClass put: WAXmlDocument</body></methods><methods><class-id>Core.Timestamp class</class-id> <category>instance creation</category><body package="Atom-Core">fromRFC3339String: aString	"Create a Timestamp from RFC3339 string format, used by the RFC4287 Atom specification"	| stream |	stream := aString readStream.	^Timestamp new		year: (stream next: 4) asNumber;		month: (stream next; next: 2) asNumber;		day: (stream next; next: 2) asNumber;		hour: (stream next; next: 2) asNumber;		minute: (stream next; next: 2) asNumber;		second: (stream next; next: 2) asNumber;		yourself</body></methods><methods><class-id>Core.Timestamp</class-id> <category>printing</category><body package="Atom-Core">printAsRFC3339String	"Convert a Timestamp in to RFC3339 string format, used by the RFC4287 Atom specification"	| policy |	policy := TimestampPrintPolicy formatTokensFor: 'yyyy-mm-ddThh:mm:ssZ'.	^Locale current timePolicy print: self policy: policy</body></methods><methods><class-id>Seaside.WAHtmlRoot</class-id> <category>*atom-core</category><body package="Atom-Core">atom	^self link beAlternate; beAtom; yourself</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>WASystemConfiguration</name><environment>Seaside</environment><super>Seaside.WAConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>description </inst-vars><class-inst-vars>instance </class-inst-vars><imports></imports><category>Seaside-Core-Configuration</category><attributes><package>Seaside-Core</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>WABrush</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>canvas parent closed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Canvas</category><attributes><package>Seaside-Canvas</package></attributes></class><class><name>WAPainter</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Rendering</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WACanvas</name><environment>Seaside</environment><super>Seaside.WARenderer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentBrush parentBrush </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Canvas</category><attributes><package>Seaside-Canvas</package></attributes></class><class><name>WARequestHandler</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filter parent configuration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-RequestHandling</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAHtmlRoot</name><environment>Seaside</environment><super>Seaside.WARoot</super><private>false</private><indexed-type>none</indexed-type><inst-vars>docType htmlAttrs headAttrs bodyAttrs headElements title styles scripts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Document</category><attributes><package>Seaside-Core</package></attributes></class></st-source>