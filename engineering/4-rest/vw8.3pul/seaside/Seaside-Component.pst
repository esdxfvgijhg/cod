<?xml version="1.0"?><st-source><!-- Name: Seaside-ComponentComment: Stateful, reusable components to encapsulate a small part of a page.DbIdentifier: bear73DbTrace: 492580DbUsername: jkottDbVersion: 3.2.0 - pmm.102 1DevelopmentPrerequisites: #(#(#any 'Seaside-Namespace' '') #(#any 'Seaside-Core' '') #(#any 'Seaside-VisualWorks-Core' ''))Id: 0003bfac-7703-4ef2-9d02-efc9932f34a3Namespace: SeasidePackageName: Seaside-ComponentParcel: #('Seaside-Component')ParcelName: Seaside-ComponentPrerequisiteParcels: #(#('Seaside-Namespace' '') #('Seaside-Core' '') #('Seaside-VisualWorks-Core' ''))PrintStringCache: (3.2.0 - pmm.102 1,jkott)Url: http://smalltalkhub.com/mc/Seaside/Seaside32/main/Seaside-Component-pmm.102.mczVersion: 3.2.0 - pmm.102 1Date: 3:31:27 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:31:27 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WAPresenter</name><environment>Seaside</environment><super>Seaside.WAPainter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Component</category><attributes><package>Seaside-Component</package></attributes></class><comment><class-id>Seaside.WAPresenter</class-id><body>WAPresenter holds the functionality that is common to WAComponent and WADecoration. Subclasses of this class may have state and can be stored in instance variables of other Presenters.You might want to subclass WAPresenter if you do not need the special abilities (decoration and call/answer) of WAComponent but do need one or more of the following:	+ The ability to specify objects whose state should be backtracked (#states)	+ The ability to provide CSS and JavaScript for the component (#style, #script)	+ The ability to "embed" other persistent Presenters within this one (#children)WAPresenter does not support call/answer or the addition of Decorations. If you need either of these features, you should subclass WAComponent instead.Child Presenters:It is common for a Presenter to display instances of other Presenters while rendering itself.  It does this by passing them into the #render: method of a renderer (typically an instance of WACanvas).  For example, this #renderContentOn: method simply renders a heading and then displays a counter component immediately below it:	renderContentOn: html		html heading level3; with: 'My Counter'.		html render: myCounter.It's important that you use #render:, rather than directly calling the #renderContentOn: method of the subcomponent. The following is *not* correct:	renderContentOn: html		html heading level3; with: 'My Counter'.		myCounter renderContentOn: html.   "DON'T DO THIS".These sub-Presenters are usually instance variables of the Presenter that is "embedding" them.  They are commonly created as part of the Presenter's #initialize method:	initialize		myCounter := WACounter new.They may also be stored in a collection. One fairly common pattern is to keep a lazily initialized dictionary of sub-presenters that match a collection of model items. For example, if you wanted a BudgetItemRow subcomponent for each member of budgetItems, you might do something like this:	initialize		budgetRows := Dictionary new.	rowForItem: anItem		^budgetRows at: anItem ifAbsentPut: [ BudgetItemRow item: anItem ].	renderContentOn: html		self budgetItems			do: [ :each | html render: (self rowForItem: each) ]			separatedBy: [ html horizontalLine ].Each parent Presenter *must* implement a #children method that returns a collection of all of the sub-Presenters that it might display on the next render. For the above two examples, #children might look like this:	children		^Array with: myCounteror this:	children		^self budgetItems collect: [ :each | self rowForItem: each ].		Visibility:A Presenter is visible if it is:- the root of an application- a child of a visible Presenter (returned by #children) that has not been #call:'d</body></comment><class><name>WAComponent</name><environment>Seaside</environment><super>Seaside.WAPresenter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>decoration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Component</category><attributes><package>Seaside-Component</package></attributes></class><comment><class-id>Seaside.WAComponent</class-id><body>I am a Presenter with the additional abilities of wrapping myself with Decorations and displaying another Component with #call:.		Call/Answer:If a sub-Component makes a #call: to another Component, that Component will appear in place of the sub-Component.  For example, if an embedded WACounter, stored in an instance variable called myCounter, made a #call: to DateSelector, that DateSelector would appear in the context of the counter's parent, with the 'My Counter' heading above it.Since an embedded subcomponent has not been #call:'d, in general #answer: is a no-op.  However, the parent may attach an #onAnswer: block to the embedded subcomponent to be notified if it sends #answer:. This allows one component to be used both from #call: and through embedding. For example:	initialize		dateSelector := WADateSelector new 			onAnswer: [ :date | self dateChosen: date ].			Visibility:A component is visible if it:- meets the visibility requirements of a Presenter; or- is passed as an argument to #call: on a visible component</body></comment><class><name>WADecoration</name><environment>Seaside</environment><super>Seaside.WAPresenter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>next </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Component</category><attributes><package>Seaside-Component</package></attributes></class><comment><class-id>Seaside.WADecoration</class-id><body>I am an abstract decoration around instances of WAComponent. I can be added to aComponent by calling #addDecoration: and I change the basic behaviour or look of a component. There are several methods that can be overriden to archive this:- #renderContentOn: to emit xhtml around the decorated component. Call #renderOwnerOn: to let the owner emit its output.- #handleAnswer: to intercept the answer processing.</body></comment><class><name>WADelegation</name><environment>Seaside</environment><super>Seaside.WADecoration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>delegate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Component</category><attributes><package>Seaside-Component</package></attributes></class><class><name>WAUpdateStatesVisitor</name><environment>Seaside</environment><super>Seaside.WAPainterVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>snapshot </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Component-Visitors</category><attributes><package>Seaside-Component</package></attributes></class><class><name>WAInitialRequestVisitor</name><environment>Seaside</environment><super>Seaside.WAPainterVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>request </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Component-Visitors</category><attributes><package>Seaside-Component</package></attributes></class><class><name>WAPresenterGuide</name><environment>Seaside</environment><super>Seaside.WAPainterVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>client </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Component-Visitors</category><attributes><package>Seaside-Component</package></attributes></class><comment><class-id>Seaside.WAPresenterGuide</class-id><body>WAPresenterGuides takes another WAPainterVisitor as a client. When asked to visit a Component, they will first visit its Decorations. Along the way, they will ask their client to visit each Painter they come across.This allows us to separate the behaviour of the various Presenter-tree traversal methods from the behaviour to perform on each Presenter we visit.</body></comment><class><name>WARenderingGuide</name><environment>Seaside</environment><super>Seaside.WAPresenterGuide</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Component-Visitors</category><attributes><package>Seaside-Component</package></attributes></class><comment><class-id>Seaside.WARenderingGuide</class-id><body>Currently an empty class but still present for clarity and to allow customization of Rendering behaviour.</body></comment><class><name>WAAnswerHandler</name><environment>Seaside</environment><super>Seaside.WADecoration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Component</category><attributes><package>Seaside-Component</package></attributes></class><class><name>WAVisiblePresenterGuide</name><environment>Seaside</environment><super>Seaside.WAPresenterGuide</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Component-Visitors</category><attributes><package>Seaside-Component</package></attributes></class><comment><class-id>Seaside.WAVisiblePresenterGuide</class-id><body>Visit the tree of all Presenters and their registered #children. Do not visit a Decoration's #next Decoration if the Decoration indicates that it is not visible.</body></comment><class><name>WAAllPresenterGuide</name><environment>Seaside</environment><super>Seaside.WAVisiblePresenterGuide</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Component-Visitors</category><attributes><package>Seaside-Component</package></attributes></class><comment><class-id>Seaside.WAAllPresenterGuide</class-id><body>Visit the tree of all Presenters and their registered #children.</body></comment><class><name>WATaskNotDelegated</name><environment>Seaside</environment><super>Seaside.WAError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Component-Tasks</category><attributes><package>Seaside-Component</package></attributes></class><class><name>WAPluggablePresenterVisitor</name><environment>Seaside</environment><super>Seaside.WAPainterVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Component-Visitors</category><attributes><package>Seaside-Component</package></attributes></class><class><name>WATask</name><environment>Seaside</environment><super>Seaside.WAComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Component-Tasks</category><attributes><package>Seaside-Component</package></attributes></class><comment><class-id>Seaside.WATask</class-id><body>I am a subclass of WAComponent, specialized for defining workflow.  The difference between a task and a component is the following:Both of them are reusable, embeddable, callable pieces of user interface. A component has state (instance variables), behavior (it may change its state, and it may also choose to display other components with #call:), and appearance (it renders HTML). A Task has only the first two - it doesn't render any HTML directly, but only through the components it calls. This is useful when what you want to encapsulate/embed/call is purely a process (show this component, then this one, then this one).The key method for WATask is #go - as soon as a task is displayed, this method will get invoked, and will presumably #call: other components.In terms of implementation, you can think of a WATask in the following way: it is a component which renders two things:- a link whose callback invokes the #go method- a header that immediately redirects to the URL of that linkSubclasses must not implement #renderContentOn:An example can be found in WAFlowConvenienceFunctionalTest.</body></comment><class><name>WAChildComponentShouldNotBeSelfError</name><environment>Seaside</environment><super>Seaside.WAError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Component-Exceptions</category><attributes><package>Seaside-Component</package></attributes></class><class><name>WATaskVisitor</name><environment>Seaside</environment><super>Seaside.WAPainterVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Component-Visitors</category><attributes><package>Seaside-Component</package></attributes></class><methods><class-id>Seaside.WAPresenter</class-id> <category>updating</category><body package="Seaside-Component">updateRoot: anHtmlRoot	"This method allows you customize the &lt;head&gt; section of an HTML document. The API is very similar to the 'Canvas API' for rendering in the &lt;body&gt; section (where you 'draw' in #renderContentOn:).	anHtmlRoot is an instance of WAHtmlRoot	Whenever you override this method don't forget to send super"	super updateRoot: anHtmlRoot.	self style isNil ifFalse: [ anHtmlRoot addStyle: self style ].	self script isNil ifFalse: [ anHtmlRoot addScript: self script ]</body><body package="Seaside-Component">updateStates: aSnapshot	"This method allows to register objects for backtracking. Don't forget to send super in all cases."	self states do: [ :each | aSnapshot register: each ]</body></methods><methods><class-id>Seaside.WAPresenter</class-id> <category>rendering</category><body package="Seaside-Component">renderContentOn: aRenderer	"By default, render all our children in order. Presenters should override this method	to specify how they should render themselves. By convention, implementations of this	method that expect a Canvas renderer use 'html' as the parameter name.	See also #rendererClass."		self childrenDo: [ :each | aRenderer render: each ]</body><body package="Seaside-Component">renderUndecoratedWithContext: aRenderContext	"Render ourselves directly on aRenderer without allowing our Decorations to be visited."		self accept: aRenderContext visitor</body></methods><methods><class-id>Seaside.WAPresenter</class-id> <category>convenience</category><body package="Seaside-Component">allPresentersDo: aBlock	(WAAllPresenterGuide client:		(WAPluggablePresenterVisitor block: aBlock))		start: self</body><body package="Seaside-Component">visiblePresentersDo: aBlock	(WAVisiblePresenterGuide client:		(WAPluggablePresenterVisitor block: aBlock))		start: self</body></methods><methods><class-id>Seaside.WAPresenter</class-id> <category>visiting</category><body package="Seaside-Component">accept: aVisitor	aVisitor visitPresenter: self</body></methods><methods><class-id>Seaside.WAPresenter</class-id> <category>hooks</category><body package="Seaside-Component">children	"This method is really important. It should return a collection of all sub-presenters that will (or might) be rendered in #renderContentOn:. Components that are displayed using #call: are *not* children.	If the contents returned by this method change over time make sure to return them in #states as well, otherwise the back button will fail."	^ #()</body><body package="Seaside-Component">initialRequest: aRequest	"When a new session is started, all visible presenters (components or tasks) receive this message with the request as argument.	A common usage for this is to initialize their state depending on the URL of the request. This is one building block for bookmarkable URL. The other is updateUrl: where you can manipulate the anchor urls generated by Seaside.	You can not use #call: in here. Consider using a WATask instead and sending #call: in #go.	See WABrowser for examples.	You may want to access the WAPathConsumer (self requestContext consumer) to get a hold of the unconsumed path."</body><body package="Seaside-Component">script	"The same as #style except that it is for JavaScript. This is rarely used, consider using WAFileLibrary or exernal files instead."	^ nil</body><body package="Seaside-Component">states	"Answer a collection of states that should be backtracked."	^ #()</body><body package="Seaside-Component">style	"Returns a CSS stylesheet associated with this component. This stylesheet will be added to &lt;head&gt; section of the html document so it will be global and not scoped.	This is done for all visible components (see class comment of WAComponent for what visible means).	Nice for demos but consider using WAFileLibrary or external files instead."	^ nil</body></methods><methods><class-id>Seaside.WAPresenter</class-id> <category>testing</category><body package="Seaside-Component">isDecoration	^ false</body></methods><methods><class-id>Seaside.WAPresenter</class-id> <category>delegation</category><body package="Seaside-Component">handleAnswer: anObject	^ false</body></methods><methods><class-id>Seaside.WAPresenter</class-id> <category>decorations</category><body package="Seaside-Component">decoratedComponent	"For polymorphism with WADecoration"		^ nil</body></methods><methods><class-id>Seaside.WAPresenter</class-id> <category>iterating</category><body package="Seaside-Component">childrenDo: aBlock	self children do: [ :each | 		each == self ifTrue: [			"fix for http://code.google.com/p/seaside/issues/detail?id=697"			WAChildComponentShouldNotBeSelfError 				signal: self class name greaseString, ' &gt;&gt; #children - the returned collection contains a reference to self. Exception raised to avoid infinite recursion.' ].		each isNil			ifFalse: [ aBlock value: each ] ]</body></methods><methods><class-id>Seaside.WAComponent</class-id> <category>accessing</category><body package="Seaside-Component">decoration	^ decoration contents</body><body package="Seaside-Component">decoration: aDecoration	decoration contents: aDecoration</body><body package="Seaside-Component">decorations	"Answer an ordered collection of all decorations active in the receiver."		| current result |	current := self decoration.	result := OrderedCollection new.	[ current = self ] whileFalse: [		result add: current.		current := current next ].	^ result</body><body package="Seaside-Component">delegations	"Answer an ordered collection of all delegations active in the receiver."		^ self decorations select: [ :each | each isDelegation ]</body><body package="Seaside-Component">home	"Remove all delegations from the receiver, making sure that it is displayed again."		self delegations do: [ :each | self removeDecoration: each ]</body></methods><methods><class-id>Seaside.WAComponent</class-id> <category>updating</category><body package="Seaside-Component">updateStates: aSnapshot	super updateStates: aSnapshot.	aSnapshot register: decoration</body></methods><methods><class-id>Seaside.WAComponent</class-id> <category>initialization</category><body package="Seaside-Component">initialize	super initialize.	decoration := WAValueHolder with: self</body></methods><methods><class-id>Seaside.WAComponent</class-id> <category>convenience</category><body package="Seaside-Component">activeComponent	"Answer the visible component, this might be a different component being delegated to or the receiver itself."		self visiblePresentersDo: [ :each | each isDecoration ifFalse: [ ^ each ] ]</body></methods><methods><class-id>Seaside.WAComponent</class-id> <category>visiting</category><body package="Seaside-Component">accept: aVisitor	aVisitor visitComponent: self</body><body package="Seaside-Component">acceptDecorated: aVisitor	aVisitor visitDecorationsOfComponent: self</body></methods><methods><class-id>Seaside.WAComponent</class-id> <category>delegation</category><body package="Seaside-Component">answer	self answer: self</body><body package="Seaside-Component">answer: anObject	"Give back control back to the component from which the receiver was called.	When returning, a component can additionally return anObject to the caller."	self decoration handleAnswer: anObject</body><body package="Seaside-Component">call: aComponent onAnswer: aBlock	"Pass control from the receiver to aComponent. The receiver will be temporarily replaced with aComponent. When #answer: is sent to aComponent, aBlock is evaluated. This can be used for continuation passing style programmation of a control flow. #call:onAnswer: does not block buta WARenderNotification is immediately signaled, aborting the current callback or task processing."	self == aComponent ifTrue: [ 		WAError signal: 'You can not call self. You''re probably missing a return somewhere' ].	self		show: aComponent		onAnswer: aBlock.	WARenderNotification signal</body><body package="Seaside-Component">onAnswer: aBlock	"Adds an answer handler aBlock to the receiver."	^ self addDecoration: (WAAnswerHandler new block: aBlock)</body><body package="Seaside-Component">removeDelegation	"Goes one decoration back (like home but not as much)."	self delegations notEmpty ifTrue: [		self removeDecoration: self delegations first ]</body><body package="Seaside-Component">show: aComponent	"Pass control from the receiver to aComponent. The receiver will be temporarily replaced with aComponent. As opposed to #call: sending this message does not block and immediately returns."	self		show: aComponent		onAnswer: [ :value | ]</body><body package="Seaside-Component">show: aComponent onAnswer: aBlock	"Pass control from the receiver to aComponent. The receiver will be temporarily replaced with aComponent. When #answer: is sent to aComponent, aBlock is evaluated. This can be used for continuation passing style programmation of a control flow. #show:onAnswer: does not block."	self		show: aComponent		onAnswer: aBlock		delegation: (WADelegation new			delegate: aComponent;			yourself)</body><body package="Seaside-Component">show: aComponent onAnswer: aBlock delegation: aDelegation	| event |	event := nil.	event := aComponent onAnswer: [ :value |		aDelegation remove.		event remove.		aBlock valueWithPossibleArguments: (Array with: value) ].	self addDecoration: aDelegation</body></methods><methods><class-id>Seaside.WAComponent</class-id> <category>decorations</category><body package="Seaside-Component">addDecoration: aDecoration	"Add aDecoration to the receivers decoration chain. Answer the added decoration."		| previous current |	previous := nil.	current := self decoration.	[ current ~~ self and: [ self decoration: current shouldWrap: aDecoration ] ] whileTrue: [		previous := current.		current := current next ].	aDecoration setNext: current.	previous isNil		ifTrue: [ self decoration: aDecoration ]		ifFalse: [ previous setNext: aDecoration ].	^ aDecoration</body><body package="Seaside-Component">decorateWith: aDecoration during: aBlock	"Decorate the receiver with aDecoration during the execution of aBlock."	| result |	self addDecoration: aDecoration.	result := aBlock value.	self removeDecoration: aDecoration.	^ result</body><body package="Seaside-Component">decoratedComponent	"For polymorphism with WADecoration"	^ self</body><body package="Seaside-Component">decoration: oldDecoration shouldWrap: newDecoration	^ (oldDecoration isGlobal and: [ newDecoration isGlobal not ])		or: [ oldDecoration isDelegation and: [ newDecoration isLocal ] ]</body><body package="Seaside-Component">removeDecoration: aDecoration 	"Remove aDecoration from the chain of decorations. Answer nil if aDecoration is not present."	| previous current |	previous := nil.	current := self decoration.	[ current = self ] whileFalse: [		current = aDecoration ifTrue: [			previous isNil				ifTrue: [ self decoration: current next ]				ifFalse: [ previous setNext: current next ].			^ aDecoration setNext: nil ].		previous := current.		current := current next ].	^ nil</body></methods><methods><class-id>Seaside.WAComponent class</class-id> <category>accessing</category><body package="Seaside-Component">description	^ self name</body></methods><methods><class-id>Seaside.WAComponent class</class-id> <category>testing</category><body package="Seaside-Component">canBeRoot	"When returning true, the component can be registered as a standalone application from the configuration interface."	^ false</body></methods><methods><class-id>Seaside.WADecoration</class-id> <category>testing</category><body package="Seaside-Component">isDecoration	^ true</body><body package="Seaside-Component">isDelegation	"If #isDelegation is true, we do not want our 'next' presenter to be displayed."	^ false</body><body package="Seaside-Component">isGlobal	^ false</body><body package="Seaside-Component">isLocal	^ (self isGlobal or: [ self isDelegation ]) not</body></methods><methods><class-id>Seaside.WADecoration</class-id> <category>processing</category><body package="Seaside-Component">handleAnswer: anObject continueWith: aBlock	aBlock value</body></methods><methods><class-id>Seaside.WADecoration</class-id> <category>updating</category><body package="Seaside-Component">updateStates: aSnapshot	super updateStates: aSnapshot.	aSnapshot register: next</body></methods><methods><class-id>Seaside.WADecoration</class-id> <category>initialization</category><body package="Seaside-Component">initialize	super initialize.	next := WAValueHolder new</body><body package="Seaside-Component">setNext: aDecoration	next contents: aDecoration</body></methods><methods><class-id>Seaside.WADecoration</class-id> <category>visiting</category><body package="Seaside-Component">accept: aVisitor	aVisitor visitDecoration: self</body></methods><methods><class-id>Seaside.WADecoration</class-id> <category>rendering</category><body package="Seaside-Component">renderContentOn: html	self renderNextOn: html</body><body package="Seaside-Component">renderNextOn: html	self next renderUndecoratedWithContext: html context</body></methods><methods><class-id>Seaside.WADecoration</class-id> <category>accessing</category><body package="Seaside-Component">next	"Answer the next decoration or component."	^ next contents</body></methods><methods><class-id>Seaside.WADecoration</class-id> <category>actions</category><body package="Seaside-Component">remove	"Remove the decoration from the owning component."		self decoratedComponent removeDecoration: self</body></methods><methods><class-id>Seaside.WADecoration</class-id> <category>decorations</category><body package="Seaside-Component">decoratedComponent	"Answer the Component decorated by this Decoration."		^ self next decoratedComponent</body></methods><methods><class-id>Seaside.WADecoration</class-id> <category>delegation</category><body package="Seaside-Component">handleAnswer: anObject	(self next handleAnswer: anObject)		ifFalse: [ self handleAnswer: anObject continueWith: [ ^ false ] ].	^ true</body></methods><methods><class-id>Seaside.WADecoration class</class-id> <category>testing</category><body package="Seaside-Component">canBeRoot	^ false</body></methods><methods><class-id>Seaside.WADelegation</class-id> <category>accessing</category><body package="Seaside-Component">delegate	^ delegate</body><body package="Seaside-Component">delegate: aComponent	delegate := aComponent</body></methods><methods><class-id>Seaside.WADelegation</class-id> <category>testing</category><body package="Seaside-Component">isDelegation	^ true</body></methods><methods><class-id>Seaside.WADelegation</class-id> <category>hooks</category><body package="Seaside-Component">children	^ Array with: self delegate</body></methods><methods><class-id>Seaside.WADelegation</class-id> <category>rendering</category><body package="Seaside-Component">renderContentOn: html	html render: self delegate</body></methods><methods><class-id>Seaside.WADelegation</class-id> <category>visiting</category><body package="Seaside-Component">accept: aVisitor	aVisitor visitDelegation: self</body></methods><methods><class-id>Seaside.WAUpdateStatesVisitor</class-id> <category>visiting</category><body package="Seaside-Component">visitPresenter: aPresenter	aPresenter updateStates: self snapshot</body></methods><methods><class-id>Seaside.WAUpdateStatesVisitor</class-id> <category>initialization</category><body package="Seaside-Component">initializeWithSnapshot: aSnapshot	self initialize.	snapshot := aSnapshot</body></methods><methods><class-id>Seaside.WAUpdateStatesVisitor</class-id> <category>accessing</category><body package="Seaside-Component">snapshot	^ snapshot</body></methods><methods><class-id>Seaside.WAUpdateStatesVisitor class</class-id> <category>instance creation</category><body package="Seaside-Component">new	^ self snapshot: WASnapshot new</body><body package="Seaside-Component">snapshot: aSnapshot	^ self basicNew initializeWithSnapshot: aSnapshot; yourself</body></methods><methods><class-id>Seaside.WAInitialRequestVisitor</class-id> <category>visiting</category><body package="Seaside-Component">visitPresenter: aPresenter	aPresenter initialRequest: self request</body></methods><methods><class-id>Seaside.WAInitialRequestVisitor</class-id> <category>accessing</category><body package="Seaside-Component">request	^ request</body></methods><methods><class-id>Seaside.WAInitialRequestVisitor</class-id> <category>initialization</category><body package="Seaside-Component">initializeWithRequest: aRequest	self initialize.	request := aRequest</body></methods><methods><class-id>Seaside.WAInitialRequestVisitor class</class-id> <category>instance creation</category><body package="Seaside-Component">new	^ self request: nil</body><body package="Seaside-Component">request: aRequest	^ self basicNew initializeWithRequest: aRequest; yourself</body></methods><methods><class-id>Seaside.WAPresenterGuide</class-id> <category>copying</category><body package="Seaside-Component">postCopyForRenderContext: aRenderContext	super postCopyForRenderContext: aRenderContext.	client := client copyForRenderContext: aRenderContext</body></methods><methods><class-id>Seaside.WAPresenterGuide</class-id> <category>visiting</category><body package="Seaside-Component">visit: aPainter	aPainter acceptDecorated: self</body><body package="Seaside-Component">visitPainter: aPainter	self client visit: aPainter</body></methods><methods><class-id>Seaside.WAPresenterGuide</class-id> <category>initialization</category><body package="Seaside-Component">initializeWithClient: aPainterVisitor	self initialize.	client := aPainterVisitor</body></methods><methods><class-id>Seaside.WAPresenterGuide</class-id> <category>accessing</category><body package="Seaside-Component">client	^ client</body></methods><methods><class-id>Seaside.WAPresenterGuide class</class-id> <category>instance creation</category><body package="Seaside-Component">client: aPainterVisitor	^ self basicNew initializeWithClient: aPainterVisitor; yourself</body><body package="Seaside-Component">new	^ self client: WAPainterVisitor new</body></methods><methods><class-id>Seaside.WAAnswerHandler</class-id> <category>accessing</category><body package="Seaside-Component">block: aBlock	block := aBlock</body></methods><methods><class-id>Seaside.WAAnswerHandler</class-id> <category>processing</category><body package="Seaside-Component">handleAnswer: anObject continueWith: aBlock	block valueWithPossibleArguments: (Array with:  anObject)</body></methods><methods><class-id>Seaside.WAVisiblePresenterGuide</class-id> <category>visiting</category><body package="Seaside-Component">visitDecoration: aDecoration	super visitDecoration: aDecoration.	(self shouldVisitNextPresenterOf: aDecoration)		ifTrue: [ aDecoration next accept: self ]</body><body package="Seaside-Component">visitPresenter: aPresenter	super visitPresenter: aPresenter.	aPresenter childrenDo: [ :each | self visit: each ]</body></methods><methods><class-id>Seaside.WAVisiblePresenterGuide</class-id> <category>private</category><body package="Seaside-Component">shouldVisitNextPresenterOf: aDecoration	^ aDecoration isDelegation not</body></methods><methods><class-id>Seaside.WAAllPresenterGuide</class-id> <category>private</category><body package="Seaside-Component">shouldVisitNextPresenterOf: aDecoration	^ true</body></methods><methods><class-id>Seaside.WATaskNotDelegated</class-id> <category>accessing</category><body package="Seaside-Component">seasidePossibleCauses	^ #('The Task is embedded in another Component but has not been included in the list of child Components returned by the Component''s #children method.' 'The Task has an empty #go method.' 'The Task does not call another Component in its #go method.' 'The #go method is written to depend on the looping execution of Tasks. If the Task needs looping behaviour without calling a Component, implement the looping behaviour within the #go method.')</body></methods><methods><class-id>Seaside.WAPluggablePresenterVisitor</class-id> <category>initialization</category><body package="Seaside-Component">initializeWithBlock: aBlock	self initialize.	block := aBlock</body></methods><methods><class-id>Seaside.WAPluggablePresenterVisitor</class-id> <category>accessing</category><body package="Seaside-Component">block	^ block</body></methods><methods><class-id>Seaside.WAPluggablePresenterVisitor</class-id> <category>visiting</category><body package="Seaside-Component">visitPresenter: aPresenter	self block value: aPresenter</body></methods><methods><class-id>Seaside.WAPluggablePresenterVisitor class</class-id> <category>instance creation</category><body package="Seaside-Component">block: aBlock	^ self basicNew initializeWithBlock: aBlock; yourself</body><body package="Seaside-Component">new	^ self block: [ :presenter | ]</body></methods><methods><class-id>Seaside.WATask</class-id> <category>visiting</category><body package="Seaside-Component">accept: aVisitor	aVisitor visitTask: self</body></methods><methods><class-id>Seaside.WATask</class-id> <category>running</category><body package="Seaside-Component">execute	"Internal method to start the task running. DO NOT OVERRIDE THIS METHOD! Subclasses	should implement #go to specify behaviour.	We used to loop here but no longer need to because the WATaskVisitor will	rerun any Task that is found not to be delegated."		self answer: self go</body><body package="Seaside-Component">go	self subclassResponsibility</body></methods><methods><class-id>Seaside.WATask</class-id> <category>rendering</category><body package="Seaside-Component">renderContentOn: html	"Tasks define behaviour and should not render themselves directly. Behaviour is defined	in the #go method, which can use #call: and other methods to display components.		In general, if this method is called, it means that the application has not been configured	properly to use Flow and the task was never executed."	WATaskNotDelegated signal: 'This task has no delegation.'</body></methods><methods><class-id>Seaside.WATask</class-id> <category>testing</category><body package="Seaside-Component">isExecuting	"Answer whether or not the task is currently executing."	^ self activeComponent ~~ self</body></methods><methods><class-id>Seaside.WAChildComponentShouldNotBeSelfError</class-id> <category>accessing</category><body package="Seaside-Component">seasidePossibleCauses	^ #(		'you included self in the return value of #children'		'You''re probably missing a return (^) somewhere.'	)</body></methods><methods><class-id>Seaside.WATaskVisitor</class-id> <category>visiting</category><body package="Seaside-Component">visitTask: aTask	super visitTask: aTask.	aTask isExecuting ifFalse: [		[ aTask execute ]			on: WARenderNotification			do: [ :n | ] ]</body></methods><methods><class-id>Seaside.WAPainter</class-id> <category>*seaside-component</category><body package="Seaside-Component">acceptDecorated: aVisitor	self accept: aVisitor</body></methods><methods><class-id>Seaside.WAPainterVisitor</class-id> <category>*seaside-component</category><body package="Seaside-Component">visitComponent: aComponent	self visitPresenter: aComponent</body><body package="Seaside-Component">visitDecoration: aDecoration	self visitPresenter: aDecoration</body><body package="Seaside-Component">visitDecorationsOfComponent: aComponent	aComponent decoration accept: self</body><body package="Seaside-Component">visitDelegation: aDelegation	self visitDecoration: aDelegation</body><body package="Seaside-Component">visitPresenter: aPresenter	self visitPainter: aPresenter</body></methods><methods><class-id>Grease.GRPackage class</class-id> <category>*seaside-component</category><body package="Seaside-Component">seasideComponent	^ self new		name: 'Seaside-Component';		description: 'Stateful, reusable components to encapsulate a small part of a page.';		addDependency: 'Seaside-Core';		url: #seasideUrl;		yourself</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>WAPainter</name><environment>Seaside</environment><super>Seaside.WAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Rendering</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAError</name><environment>Seaside</environment><super>Grease.GRError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Exceptions</category><attributes><package>Seaside-Core</package></attributes></class><class><name>WAPainterVisitor</name><environment>Seaside</environment><super>Seaside.WAVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Seaside-Core-Rendering</category><attributes><package>Seaside-Core</package></attributes></class></st-source>