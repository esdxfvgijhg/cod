<?xml version="1.0"?><st-source><!-- Name: WebServicesDemoNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: Test classes to exercise the Web Services framework.OverviewThe Web Services Demo contains a set of test classes for creating WSDL specifications (1.1 and 2.0 are supported), and for creating and running web services applications. Some of the tests in this package make use of the Library Demo, adding service classes that encapsulate the library search functions.With VisualWorks 7.8, support for operation pragmas has been deprecated, and the Web Services tools no longer support them. For backward compatibility, operation pragmas and domain types can still be read by the framework. Class TestCreateWSDLSchema also includes examples that illustrate how to create WSDL specifications from the deprecated operation pragmas in services classes.UsageFor details on using the Web Services Demo, see the test class comments.ImplementationThe classes in this demo use the Protocols Library Demo (for more information, see the package comment for Protocols-LibraryDemo), and service classes in the WebServicesDemoModels package.DbIdentifier: bear73DbTrace: 493901DbUsername: tkoganDbVersion: 8.3 - 0DevelopmentPrerequisites: #(#(#any 'Protocols-LibraryDemo' '') #(#any 'SUnitToo' '') #(#any 'WebServicesDemoModels' '') #(#any 'WSDLTool' ''))ExplicitPrerequisites: #()IgnoredPrerequisites: #()PackageName: WebServicesDemoParcel: #('WebServicesDemo')ParcelName: WebServicesDemoPrerequisiteDescriptions: #(#(#name 'Protocols-LibraryDemo') #(#name 'SUnitToo') #(#name 'WebServicesDemoModels') #(#name 'WSDLTool'))PrerequisiteParcels: #(#('Protocols-LibraryDemo' '') #('SUnitToo' '') #('WebServicesDemoModels' '') #('WSDLTool' ''))PrintStringCache: (8.3 - 0,tkogan)Version: 8.3 - 0Date: 2:31:40 PM April 28, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.3) of April 28, 2017 on April 28, 2017 at 2:31:40 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>TestCreateWSClients</name><environment>WebServices</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>title </inst-vars><class-inst-vars></class-inst-vars><imports>			Protocols.Library.*			</imports><category>Web Services-Demo</category><attributes><package>WebServicesDemo</package></attributes></class><comment><class-id>WebServices.TestCreateWSClients</class-id><body>Tests to demonstrate different ways of creating a client, and making web service requests.OverviewThese tests illustrate how to make a web service request using: (1) SoapRequest  (2) a WsdlClient  (3) a subclass of WsdlClient.UsageBefore running these tests, the Library Server must be running in a different VisualWorks image. This is necessary to avoid binding conflicts.To run the Library Server:	1. Open another image for the server	2. Load the demo and execute:		LibraryResponder addToServer.	3. In the client image, run the tests from this class	4. Stop the server by evaluating:		LibraryResponder flushResponders.Some of the tests create client classes to invoke a web service. For example:	- #testWsdlSpecificClient creates subclasses of WsdlClient: TestWS.WSSearchServicesWsdlClient and TestWS.WSGeneralServicesWsdlClient.	To send a request, evaluate: TestWS.WSGeneralServicesWsdlClient new availableBooks.To send a messages using the following classes:	WsdlClient, see #testSendRequestByWsdlClient.	WebService.SoapRequest and HttpClient, see #testSendRequestBySoapRequest.Instance Variables	title		&lt;String&gt;	book title</body></comment><class><name>TestCreateWSApplication</name><environment>WebServices</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Protocols.Library.*			</imports><category>Web Services-Demo</category><attributes><package>WebServicesDemo</package></attributes></class><comment><class-id>WebServices.TestCreateWSApplication</class-id><body>Sample tests for creating a Web Services application from a WSDL specification.OverviewThese tests illustrate: (1) how to create server and client classes; (2) how to start server and client, and how to send requests.UsageTestCreateWSApplication includes methods that perform the following:	- Create client and server classes	#test11CreateClientResponderClasses and #test20CreateClientResponderClasses	- Invoke services from the server	#test11GeneralServices, #test11SearchServices, #test20GeneralServices and #test20SearchServicesA SOAP responder can be created for the two services classes: WSSearchServices and WSGeneralServices. The port addresses in the WSDL schema have the same host and port for both services. When an instance of the SOAP responder is created, it does the following:	1.	Initializes the WSDL registry using the WSDL schema from the #wsdlSchema class method	2.	Initializes the X2O binding registry using the #x2oBinding class method	3. 	Reads #serviceMap and creates a map for the service inferfaces and method selectors.ImplementationThis test class requires two service classes -- WSGeneralServices and WSSearchServices -- which may be found in the WebServicesDemoModels package. These two example classes are used to create web service operations.Class WSGeneralServices provides general library services. An example instance of the library is created by evaluating: WSLibrary cityPublicLibrary Class WSSearchServices represents the library search services. It provides the search operation for the city library object (WSLibrary cityPublicLibrary) and affiliated libraries (Library portNowhereMaritimeMuseumLibraryAndShipPlanArchive).</body></comment><class><name>TestOneWayMEP</name><environment>WebServices</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>service responderWsdl11 responderWsdl20 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Web Services-Demo</category><attributes><package>WebServicesDemo</package></attributes></class><comment><class-id>WebServices.TestOneWayMEP</class-id><body>The class includes cases to test one-way MEP support for Wsdl 1.1 and Wsdl 2.0. WSDL 1.1http://www.ws-i.org/profiles/basicprofile-1.1-2004-08-24.html#One-Way_Operations.One-way operations do not produce SOAP responses. Therefore, the Profile prohibits sending a SOAP envelope in response to a one-way operation. This means that transmission of one-way operations can not result in processing level responses or errors. For example, a '500 Internal Server Error' HTTP response that contains a fault can not be returned in this situation. The HTTP response to a one-way operation indicates the success or failure of the transmission of the message. Based on the semantics of the different response status codes supported by the HTTP protocol, the Profile specifies that '200' and '202' are the preferred status codes that the sender should expect, signifying that the one-way message was received. A successful transmission does not indicate that the SOAP processing layer and the application logic has had a chance to validate the envelope or have committed to processing itWSDL 2.0http://www.w3.org/TR/2007/REC-wsdl20-adjuncts-20070626/#http-operation-decl-destFor successful responses, the HTTP response code MUST be:    202 when the MEP is 'http://www.w3.org/ns/wsdl/in-only'    204 when the MEP is 'http://www.w3.org/ns/wsdl/robust-in-only'http://www.w3.org/TR/wsdl20-adjuncts/#robust-in-only2.3.1 In-Only message exchange patternThe in-only message exchange pattern consists of exactly one message as follows:    A message:        indicated by a Interface Message Reference component whose {message label} is "In" and {direction} is "in"        received from some node NThe in-only message exchange pattern uses the rule 2.2.3 No Faults propagation rule.An operation using this message exchange pattern has a {message exchange pattern} property with the value "http://www.w3.org/ns/wsdl/in-only".2.3.2 Robust In-Only message exchange patternThe robust-in-only message exchange pattern consists of exactly one message as follows:    A message:        indicated by a Interface Message Reference component whose {message label} is "In" and {direction} is "in"        received from some node NThe robust in-only message exchange pattern uses the rule 2.2.2 Message Triggers Fault propagation rule.An operation using this message exchange pattern has a {message exchange pattern} property with the value "http://www.w3.org/ns/wsdl/robust-in-only".</body></comment><class><name>TestSoapHeaders</name><environment>WebServices</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Protocols.Library.*			</imports><category>Web Services-Demo</category><attributes><package>WebServicesDemo</package></attributes></class><comment><class-id>WebServices.TestSoapHeaders</class-id><body>Tests of SOAP header support in VisualWorks. OverviewClass TestSoapHeaders includes sample code that demonstrates how to create WSDL schemas with SOAP headers, to create web services that use headers, and to send messages with headers.The WSAuthenticatedSearchService class provides some services that require SOAP headers for authentication.UsageFor examples that illustrate how to create WSDL schemas that specify SOAP headers, see:	#testCreateWsdl11Schema and #testCreateWsdl20SchemaTo send and receive WS messages with headers, see:	#test11ServiceWithHeaders and #test20ServiceWithHeadersSetting "SOAPResponder environmentWithHeaders" to true adds the headers to the ProcessEnvironment current, and allows access to the header values in the service class methods. For an example, see:	#test11ServiceWithProcessEnv and #test20ServiceWithProcessEnvTo run services that include SOAP headers, an Soap Responder must be created with interceptors. For an example, see:	AuthSearchResponder11&gt;&gt;interceptorsInterceptors such as DemoHeaderInterceptor are responsible for adding and processing header entries. The headers information is provided by DemoProcessingPolicy in the client application, e.g.:	policy := client policy.	policy		userID: 'UserID';		password: 'password'.	client authenticatedSearchByWord: 'and'.Class DemoHeaderInterceptor contains example code that illustrates how to create request or response headers. To create request headers, see:	DemoHeaderInterceptor&gt;&gt;sendingRequest:in:For an example of how to add header entries to a response, see:	DemoHeaderInterceptor&gt;&gt;sendingReply:in:If a service request fails, fault headers are added. Note that WSDL 1.1 and 2.0 differ in how they specify headers for failed messages. For an example, see the #sendingFailedReply: implementation in the classes DemoHeaderInterceptor11 and DemoHeaderInterceptor20.When the client receives a reply, it processes the reply headers using a different method in the interceptor class. For an example, see:	DemoHeaderInterceptor&gt;&gt;receivingReply:in:In the event of an error on the server, the failure is communicated back to the client with a header. Note that these differ slightly, depending upon whether you are using WSDL 1.1 or 2.0. For an example, see the #receivingFailedReply: implementation in class DemoHeaderInterceptor11 and DemoHeaderInterceptor20.SOAP headers are processed when the SOAP responder receives a request. The responder unmarshals the headers, and then sends the header objects to the corresponding interceptor for processing. For an example, see DemoHeaderInterceptor&gt;&gt;processInputHeaderFrom:transport: The SOAP headers are accessible in services methods. The responder can set an option to add header objects to the ProcessEnviroment. For example:	AuthSearchResponder11 responders asOrderedCollection first environmentWithHeaders: true.For an example of how to access header values in the method, see: WSAuthenticatedSearchService&gt;&gt;authenticatedSearchByTitle:</body></comment><class><name>TestCreateWSDLSchema</name><environment>WebServices</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Protocols.Library.*			</imports><category>Web Services-Demo</category><attributes><package>WebServicesDemo</package></attributes></class><comment><class-id>WebServices.TestCreateWSDLSchema</class-id><body>Tests for generating the WSDL specifications from a configuration descriptor.OverviewWSDL specifications can be generated from the information found in WsdlConfigurationDescriptor classes that provides a web service interface description.With VisualWorks 7.8, support for operation pragmas has been deprecated, and the Web Services tools no longer support them. For backward compatibility, operation pragmas and domain types can still be read by the framework. Class TestCreateWSDLSchema also includes examples that illustrate how to create WSDL specifications from operation pragmas in services classes.UsageBefore you can generate a WSDL specification, you need to describe user types in a XML to Object Binding specification (X2O spec). The types can be described using X2O Tool (open it using the Tools menu in the Launcher window). The X2O specification (&lt;schemaBindings&gt;) should include user domain types. You may also use the Web Services Wizard to create WSDL specifications.To create a WSDL 1.1 specification, see:	#testCreateWsdl11Schema and #testCreateWsdl11RpcSchemaTo create a WSDL 2.0 specification, see:	#testCreateWsdl20SchemaIf there are any operation exceptions or SOAP headers in your WSDL schema, their types should also be described in one of its &lt;xmlToSmalltalkBinding&gt; elements. The descriptor will add a new &lt;xmlToSmalltalkBinding&gt; binding to the X2O specification, that will include the operation request and response descriptions.This new &lt;xmlToSmalltalkBinding&gt; binding has the #targetNamespace attribute for the WSDL spec with the "_WSDLOperations" suffix. Later, if you need to change your WSDL spec operations, the descriptor will use the target namespace with the "_WSDLOperations" suffix to find operation types descriptions for update. To describe the operation parameters, use classes that are listed in XMLObjectBinding class&gt;&gt;simpleTypes or classes that are described in the X2O specification.</body></comment><methods><class-id>WebServices.TestCreateWSClients</class-id> <category>running</category><body package="WebServicesDemo">setUp	XMLObjectBinding configure.	WsdlBinding reset.	title := 'My Life in Germany'.</body></methods><methods><class-id>WebServices.TestCreateWSClients</class-id> <category>testing</category><body package="WebServicesDemo">testSendRequestBySoapRequest	"The test shows how to make a WS request using the SoapRequest class "	| config req reply value |	config := WsdlBinding initializeRegistriesFor: LibraryResponder .	"Create the SoapRequest and execute it "	req := SoapRequest new.  	reply := req 		port: config services first ports last;		smalltalkEntity: (Message selector: #AvailableBooks arguments: #());		execute.	self assert: ( reply isKindOf: WebServices.SoapResponse).	value := reply value.	self assert: ( value size = 10).	self assert: ( value first title = title ).</body><body package="WebServicesDemo">testSendRequestByWsdlClient	"Use the WsdlClient class to send requests"	| client args value str |	"The WsdlClient reads the specified WSDL schema and creates a default XML to ObjectBinding specification.	The XML schema complex types will be mapped to WenServices.Struct class."	[client := WsdlClient readFrom: LibraryResponder wsdlSchema readStream.	] on: MappingDerivationToStructs do: [ :ex | ex proceed].	str := client createScript. 	self 		assert: ( '*struct := WebServices.Struct new.	args := Array with: struct.	struct		at: #searchByExactTitles put: (WebServices.Struct new			at: #String put: (OrderedCollection with: ("String"));			yourself );		at: #includeAffiliatedLibraries put: ("Boolean").	value := client executeSelector: #SearchByTitles args: args.*' match: str)		description: 'The client can create a script that helps to provide the operation parameter types '.	"Set the port to invoke the Search services  "	client setPortNamed: (NodeTag qualifier: '' ns: 'urn:webservices/demo/libraryServices' type: 'WSSearchServices'). 	"Invoke the  #SearchByTitles operation"	args := WebServices.Struct new.	args		at: #searchByExactTitles put: (WebServices.Struct new at: #String put: (OrderedCollection with: title); yourself );		at: #includeAffiliatedLibraries put: false.	value := client  executeSelector:  #SearchByTitles args: (Array with: args).	self assert: ( value isStruct).	self assert: ( value  Book size = 1).	value := value Book first.	self assert: ( value title = title).	"Set the port to invoke the General services  "	client setPortNamed: (NodeTag qualifier: '' ns: 'urn:webservices/demo/libraryServices' type: 'WSGeneralServices'). 	value := client  executeSelector: #AvailableBooks args: (Array with: WebServices.Struct new).	self assert: ( value isStruct ).	self assert: ( value  WSBook size = 10).	self assert: ( value  WSBook first isStruct ).	self assert: ( value  WSBook first title = title ).</body><body package="WebServicesDemo">testWsdlSpecificClient	"Create a specific WSDL client and use the class to make WS requests"	| searchClient arg1 value generalClient value2 |	"If the client classes do not exist, we must create them"	#{TestWS.WSSearchServicesWsdlClient} isDefined		ifFalse: [(WsdlClassBuilder 					readFrom: LibraryResponder wsdlSchema readStream					inNamespace: 'TestWS')						package: 'ZTestingWS';						createClientClasses].	"The Search services invocation by the WSDL client"	searchClient :=#{TestWS.WSSearchServicesClient} value new. 	self 		assert: ('*arg1 := TestWS.SearchByTitles new		searchByExactTitles: (TestWS.CollectionOfString new			string: (OrderedCollection with: ("String"));			yourself);		includeAffiliatedLibraries: ("Boolean");		yourself.	value := client searchByTitles: arg1.*' match: searchClient createScript)		description: 'The client can create a script that helps to provide the operation parameter types '.	arg1 := #{TestWS.SearchByTitles} value new		searchByExactTitles: (#{TestWS.CollectionOfString} value new string: ( OrderedCollection with: title ));		includeAffiliatedLibraries: false;		yourself.	value := searchClient searchByTitles: arg1.	self assert: ( value  isKindOf: #{TestWS.SearchByTitlesResponse} value ).	self assert: ( value  result book first isKindOf: #{TestWS.ProtocolsLibraryBook} value ).	self assert: ( value  result book first title = title ).	"The General services invocation by the Opentalk client  "	generalClient := #{TestWS.WSGeneralServicesClient} value new.	self 	assert: ( '*value := client availableBooks*' match: generalClient createScript)		description: 'The client can create a script that helps to provide the operation parameter types '.	value2 := generalClient availableBooks.	self assert: ( value2 isKindOf: #{TestWS.AvailableBooksResponse} value ).	self assert: ( value2 result  isKindOf: #{TestWS.CollectionOfWSBook} value ).	self assert: ( value2  result wSBook  size = 10 ).	self assert: ( value2  result wSBook  first isKindOf: #{TestWS.WSBook} value ).	"Request the book with the existing acquisition number   "	arg1 := #{TestWS.HoldingByAcquisitionNumber} value new				holdingByAcquisitionNumber: 536870913;				yourself.	value := generalClient holdingByAcquisitionNumber: arg1.	"Request the book with the non-existing acquisition number   "	arg1 := #{TestWS.HoldingByAcquisitionNumber} value  new				holdingByAcquisitionNumber: 1;				yourself.	self should: [generalClient holdingByAcquisitionNumber: arg1.]		raise: #{TestWS.ProtocolsLibraryHoldingNotFound} value.</body></methods><methods><class-id>WebServices.TestCreateWSApplication</class-id> <category>accessing</category><body package="WebServicesDemo">generalClientClass	^#{MyServices.WSGeneralServicesClient} valueOrDo: [nil]</body><body package="WebServicesDemo">generalClientClass20	^#{MyServices20.WSGeneralServicesClient} valueOrDo: [nil]</body><body package="WebServicesDemo">namespace	^'MyServices'</body><body package="WebServicesDemo">package	^'TestLibraryDemo'</body><body package="WebServicesDemo">responderClass	^#{MyServices.MyLibraryResponder} valueOrDo: [nil]</body><body package="WebServicesDemo">responderClass20	^#{MyServices20.MyLibraryResponder} valueOrDo: [nil]</body><body package="WebServicesDemo">searchClientClass	^#{MyServices.WSSearchServicesClient} valueOrDo: [nil]</body><body package="WebServicesDemo">searchClientClass20	^#{MyServices20.WSSearchServicesClient} valueOrDo: [nil]</body><body package="WebServicesDemo">serverClass	^#{MyServices.MyLibraryResponder} valueOrDo: [nil]</body><body package="WebServicesDemo">serverClass20	^#{MyServices20.MyLibraryResponder} valueOrDo: [nil]</body><body package="WebServicesDemo">serviceMap	^'&lt;ns:serviceMaps xmlns:ns="urn:visualworks:serviceMap" xmlns:ns0="urn:webservices/demo/libraryServices/tests"&gt;	&lt;ns:serviceMap&gt;		&lt;ns:serviceClass&gt;WebServices.WSSearchServices&lt;/ns:serviceClass&gt;		&lt;ns:interface&gt;ns0:WSSearchServices&lt;/ns:interface&gt;		&lt;ns:operation name="SearchByTitle" selector="searchByExactTitle:includeAffiliatedLibraries:"&gt;&lt;/ns:operation&gt;		&lt;ns:operation name="SearchByTitles" selector="searchByExactTitles:includeAffiliatedLibraries:"&gt;&lt;/ns:operation&gt;		&lt;ns:operation name="SearchByWord" selector="searchByTitleWord:includeAffiliatedLibraries:"&gt;&lt;/ns:operation&gt;	&lt;/ns:serviceMap&gt;	&lt;ns:serviceMap&gt;		&lt;ns:serviceClass&gt;WebServices.WSGeneralServices&lt;/ns:serviceClass&gt;		&lt;ns:interface&gt;ns0:WSGeneralServices&lt;/ns:interface&gt;		&lt;ns:operation name="AvailableBooks" selector="availableBooks"&gt;&lt;/ns:operation&gt;		&lt;ns:operation name="LibraryServicesCollection" selector="libraryServicesCollection"&gt;&lt;/ns:operation&gt;		&lt;ns:operation name="LibraryServicesIds" selector="libraryServicesIds"&gt;&lt;/ns:operation&gt;		&lt;ns:operation name="HoldingByAcquisitionNumber" selector="holdingByAcquisitionNumber:"&gt;&lt;/ns:operation&gt;		&lt;ns:operation name="ProvidesServices" selector="providesServices"&gt;&lt;/ns:operation&gt;	&lt;/ns:serviceMap&gt;&lt;/ns:serviceMaps&gt;' readStream</body></methods><methods><class-id>WebServices.TestCreateWSApplication</class-id> <category>testing</category><body package="WebServicesDemo">test11CreateClientResponderClasses	"Test that the WsdlClassBuilder creates a server responder and client classes to run Web Services application"	| classBuilder classes source cl cl1 |	"Create the WSDL schema from the specified service classes. The service classes are expected to have	methods that contain a Web Services operation description in the form of pragmas."	classBuilder := WsdlClassBuilder new. 	classBuilder buildOptions classNamespace: 'Smalltalk'.	classBuilder 		package: self package;		responderNS: 'MyServices';		clientNS: 'MyServices'.	"Initialize class builder from the configuration descriptor"	classBuilder initializeConfigFrom: TestCreateWSDLSchema new testCreateWsdl11Schema.	"Create the responder"	classBuilder responderName:  'MyLibraryResponder'.	classBuilder createResponderClass.	self 		assert: (#{MyServices.MyLibraryResponder} valueOrDo: [nil]) notNil		description: 'checking that the server class is created'.	"Create client classes"	[classes := classBuilder createClientClasses.	] on: ClientClassExistExc do: [ :ex | ex resume ].	"Check that the client classes have been generated and their methods are correct"	self assert: classes size = 2.	self 		assert: ((cl := #{MyServices.WSGeneralServicesClient} valueOrDo: [nil]) notNil 					and: [ (cl1 := #{MyServices.WSSearchServicesClient} valueOrDo: [nil]) notNil ])		description: 'checking that the client classes are created'.      self 		assert: ('*^self executeSelector: #''AvailableBooks'' args: args*' match: (cl sourceCodeAt: #availableBooks))		description: 'checking that the client method source code matches our reference copy'.        source := cl1 sourceCodeAt: #'searchByExactTitle:includeAffiliatedLibraries:'.      self 		assert: ('*searchByExactTitle: aString includeAffiliatedLibraries: aBoolean*' match: source)		description: 'checking that the client method selector matches the service class selector'.</body><body package="WebServicesDemo">test11GeneralServices	"Test that the general client can send and receive WS messages"	| responder val generalClient |	"The responder and client classes must exist before we can run this test"	(self responderClass isNil		or: [ self generalClientClass isNil ])		ifTrue: [ self test11CreateClientResponderClasses ].	responder := self responderClass.	generalClient := self generalClientClass new.	[responder addToServer.	"General Services invocation"	self 		assert: ( generalClient providesServices  )		description: 'The #ProvidesServices operation returns true '.	self 		assert: ( (val :=  generalClient availableBooks  )  size = 10 )		description: 'The AvailableBooks operation returns collection of the WSBook instances '.	self assert:  (val first  isKindOf: WSBook).	self assert: ( val  first title = 'My Life in Germany' ).	self 		assert: (val := generalClient holdingByAcquisitionNumber: val  first acquisitionNumber) notNil		description: 'The HoldingByAcquisitionNumber operation returns an instance of the  Protocols.Library.Book with the specified acquisition number'.	self assert:  (val  isKindOf: Protocols.Library.Book).	self assert: (  val title = 'My Life in Germany' ).	] ensure: [responder flushResponders ]</body><body package="WebServicesDemo">test11SearchServices	"Test that the search client can send and receive WS messages "	| responder val searchClient |	"The responder and client classes must exist before we can run this test"	(self responderClass isNil		or: [ self searchClientClass isNil ])		ifTrue: [ self test11CreateClientResponderClasses ].	responder := self responderClass.	searchClient := self searchClientClass new.	[responder addToServer.	"Search Services invocation"	self 		assert: ((val := searchClient searchByTitleWord: 'and' includeAffiliatedLibraries: false) isKindOf:  ChoiceOfHoldings )		description: 'The SearchByWord operation result is described as a choice. The result is an instance of the  ChoiceOfHoldings where the #choiceValue key can be #book or #shipPlan and corresponding value is an instance of Protocols.Library.Book or Protocols.Library.ShipPlan'.	val choiceValue key = #shipPlan		ifTrue: [self assert: ( val choiceValue value isKindOf: Protocols.Library.ShipPlan )]		ifFalse: [self assert: ( val choiceValue value isKindOf: Protocols.Library.Book )].	self 		assert:			((searchClient 				searchByExactTitles: (OrderedCollection with: 'A Short History of Byzantium' with:  'My Life in Germany' )				includeAffiliatedLibraries: false)  size = 2)		description: 'The SearchByTitle operation returns collection of the Protocols.Library.Book instances '.	] ensure: [responder flushResponders ]</body><body package="WebServicesDemo">test20CreateClientResponderClasses	"Test that the WsdlClassBuilder creates a server responder and client classes to run Web Services application"	| classBuilder classes source cl cl1 |	"Initialize the class builder from Wsdl20ConfigurationDescriptor"	classBuilder := WsdlClassBuilder new. 	classBuilder 		package: 'Test20LibraryDemo';		responderNS: 'MyServices20';		clientNS: 'MyServices20'.	"Initialize class builder from the configuration descriptor"	classBuilder initializeConfigFrom: TestCreateWSDLSchema new testCreateWsdl20Schema.	"Create the responder "	classBuilder responderName:  'MyLibraryResponder'.	classBuilder createResponderClass.	self 		assert: (#{MyServices20.MyLibraryResponder} valueOrDo: [nil]) notNil		description: 'checking that the server class is created'.	"Create client classes"	[classes := classBuilder createClientClasses.	] on: ClientClassExistExc do: [ :ex | ex resume ].	"Check that the client classes have been generated and their methods are correct"	self assert: classes size = 2.	self 		assert: ((cl := #{MyServices20.WSGeneralServicesClient} valueOrDo: [nil]) notNil 					and: [ (cl1 := #{MyServices20.WSSearchServicesClient} valueOrDo: [nil]) notNil ])		description: 'checking that the client classes are created'.   self 		assert: ('*^self executeSelector: #''AvailableBooks'' args: args.*' match: (cl sourceCodeAt: #availableBooks))		description: 'checking that the client method source code matches our reference copy'.        source := cl1 sourceCodeAt: #'searchByExactTitle:includeAffiliatedLibraries:'.      self 		assert: ('*searchByExactTitle: aString includeAffiliatedLibraries: aBoolean*' match: source)		description: 'checking that the client method selector matches the service class selector'.</body><body package="WebServicesDemo">test20GeneralServices	"Test that the general client can send and receive WS messages"	| responder val generalClient |	"The responder and client classes must exist before we can run this test"	(self responderClass20 isNil		or: [ self generalClientClass20 isNil ])		ifTrue: [ self test20CreateClientResponderClasses ].	responder := self serverClass20.	generalClient := self generalClientClass20 new.	[responder addToServer.	"General Services invocation"	self 		assert: ( generalClient providesServices  )		description: 'The #ProvidesServices operation returns true '.	self 		assert: ( (val :=  generalClient availableBooks  )  size = 10 )		description: 'The AvailableBooks operation returns collection of the WSBook instances '.	self assert:  (val first  isKindOf: WSBook).	self assert: ( val  first title = 'My Life in Germany' ).	self 		assert: (val := generalClient holdingByAcquisitionNumber: val  first acquisitionNumber) notNil		description: 'The HoldingByAcquisitionNumber operation returns an instance of the  Protocols.Library.Book with the specified acquisition number'.	self assert:  (val  isKindOf: Protocols.Library.Book).	self assert: (  val title = 'My Life in Germany' ).	] ensure: [responder flushResponders ]</body><body package="WebServicesDemo">test20SearchServices	"Test that the search client can send and receive WS messages "	| responder val searchClient |	"The responder and client classes must exist before we can run this test"	(self responderClass20 isNil		or: [ self searchClientClass20 isNil ])		ifTrue: [ self test20CreateClientResponderClasses ].	responder := self serverClass20.	searchClient := self searchClientClass20 new.	[responder addToServer.	"Search Services invocation"	self 		assert: ((val := searchClient searchByTitleWord: 'and' includeAffiliatedLibraries: false) isKindOf:  ChoiceOfHoldings )		description: 'The SearchByWord operation result is described as a choice. The result is an instance of the  ChoiceOfHoldings where the #choiceValue key can be #book or #shipPlan and corresponding value is an instance of Protocols.Library.Book or Protocols.Library.ShipPlan'.	val choiceValue key = #shipPlan		ifTrue: [self assert: ( val choiceValue value isKindOf: Protocols.Library.ShipPlan )]		ifFalse: [self assert: ( val choiceValue value isKindOf: Protocols.Library.Book )].	self 		assert:			((searchClient 				searchByExactTitles: (OrderedCollection with: 'A Short History of Byzantium' with:  'My Life in Germany' )				includeAffiliatedLibraries: false)  size = 2)		description: 'The SearchByTitle operation returns collection of the Protocols.Library.Book instances '.	] ensure: [responder flushResponders]</body></methods><methods><class-id>WebServices.TestOneWayMEP</class-id> <category>accessing</category><body package="WebServicesDemo">createHelloWorldService	| methodStream |	methodStream := (String new: 100) writeStream.	methodStream 		nextPutAll: 'helloWorld'; cr; 		nextPutAll: '	^self'.	service compile: methodStream contents classified: 'public api'.</body><body package="WebServicesDemo">createHelloWorldServiceWithError	"Edit the method #helloWorld so it returns an error"	| methodStream |	methodStream := (String new: 100) writeStream.	methodStream 		nextPutAll: 'helloWorld'; cr; 		nextPutAll: '	^self error: ''hello'''.	service  compile: methodStream contents classified: 'public api'.</body><body package="WebServicesDemo">createPingService	| methodStream |	methodStream := (String new: 100) writeStream.	methodStream 		nextPutAll: 'ping: aString'; cr; 		nextPutAll: '	^self'.	service compile: methodStream contents classified: 'public api'.</body><body package="WebServicesDemo">createPingServiceWithError	| methodStream |	methodStream := (String new: 100) writeStream.	methodStream 		nextPutAll: 'ping: aString'; cr; 		nextPutAll: '	^self error: ''Wrong parameter'''.	service  compile: methodStream contents classified: 'public api'.</body><body package="WebServicesDemo">oneWayWsdl11^'&lt;?xml version="1.0"?&gt; &lt;definitions name="HelloWorldService" xmlns:tns="urn://OneWayWsdl11" xmlns:s0="http://tempuri.org/" targetNamespace="urn://OneWayWsdl11" xmlns:xsd="http://www.w3.org/1999/XMLSchema" xmlns:soap="http://schemas.xmlsoap.org/wsdl/soap/" xmlns="http://schemas.xmlsoap.org/wsdl/"&gt; 	&lt;message name="PingRequest"&gt;         &lt;part name="data" type="xsd:string"/&gt;	&lt;/message&gt; 	&lt;message name="HelloWorldRequest"/&gt; 	&lt;portType name="OneWayInterface"&gt; 		&lt;operation name="HelloWorld"&gt; 			&lt;input message="tns:HelloWorldRequest" name="HelloWorld"/&gt;  		&lt;/operation&gt; 		&lt;operation name="Ping"&gt; 			&lt;input message="tns:PingRequest" name="Ping"/&gt;  		&lt;/operation&gt; 	&lt;/portType&gt;	&lt;binding name="OneWayBinding" type="tns:OneWayInterface"&gt; 		&lt;soap:binding style="rpc" transport="http://schemas.xmlsoap.org/soap/http"/&gt; 		&lt;operation name="HelloWorld"&gt; 			&lt;soap:operation soapAction="urn:xmethodsHelloWorld#HelloWorld"/&gt; 			&lt;input&gt; 				&lt;soap:body use="literal" namespace="urn:xmethodsHelloWorld"/&gt; 			&lt;/input&gt; 		&lt;/operation&gt; 		&lt;operation name="Ping"&gt; 			&lt;soap:operation soapAction="urn:xmethodsHelloWorld#Ping"/&gt; 			&lt;input&gt; 				&lt;soap:body use="literal" namespace="urn:xmethodsHelloWorld"/&gt; 			&lt;/input&gt; 		&lt;/operation&gt; 	&lt;/binding&gt; 	&lt;service name="OneWayServices"&gt; 		&lt;port name="HelloWorldPort" binding="tns:OneWayBinding"&gt; 			&lt;soap:address location="http://localhost:4444/TestOneWayOperation"/&gt; 		&lt;/port&gt; 	&lt;/service&gt; &lt;/definitions&gt; '.</body><body package="WebServicesDemo">oneWayWsdl20^'&lt;?xml version="1.0" encoding="utf-8" ?&gt; &lt;description     xmlns="http://www.w3.org/ns/wsdl"    targetNamespace= "urn://OneWayWsdl20"     xmlns:tns= "urn://OneWayWsdl20"    xmlns:ns = "urn://OneWayWsdl20"    xmlns:wsoap= "http://www.w3.org/ns/wsdl/soap"    xmlns:soap="http://www.w3.org/2003/05/soap-envelope"    xmlns:whttp="http://www.w3.org/ns/wsdl/http"    xmlns:wsdlx= "http://www.w3.org/ns/wsdl-extensions"&gt;&lt;schemaBindings&gt;&lt;xmlToSmalltalkBinding  		xmlns:xsd="http://www.w3.org/2001/XMLSchema"	      targetNamespace="urn://OneWayWsdl20"      	xmlns="urn://OneWayWsdl20"&gt;       &lt;element  name="ping" ref="xsd:string"/&gt;      &lt;/xmlToSmalltalkBinding&gt;&lt;/schemaBindings&gt;   &lt;interface  name = "OneWayInterface"&gt;    &lt;operation name="HelloWorld"             pattern="http://www.w3.org/ns/wsdl/in-only"             style="http://www.w3.org/ns/wsdl/style/iri"&gt;        &lt;input messageLabel="In" element="#none" /&gt;    &lt;/operation&gt;   &lt;operation name="Ping"             pattern="http://www.w3.org/ns/wsdl/robust-in-only"             style="http://www.w3.org/ns/wsdl/style/iri"&gt;        &lt;input messageLabel="In" element="ns:ping" /&gt;    &lt;/operation&gt;  &lt;/interface&gt;   &lt;binding name="OneWayBinding"           interface="tns:OneWayInterface"          type="http://www.w3.org/ns/wsdl/soap"          wsoap:protocol="http://www.w3.org/2003/05/soap/bindings/HTTP/"          wsoap:version="1.2"          wsoap:mepDefault="http://www.w3.org/2003/05/soap/mep/request-response/"/&gt; 	&lt;service name="OneWayServices" interface="tns:OneWayInterface"&gt; 		&lt;endpoint 			name="HelloWorldPort" 			binding="tns:OneWayBinding"			address="http://localhost:4444/TestOneWayOperation20"/&gt; 	&lt;/service&gt; &lt;/description&gt; '.</body><body package="WebServicesDemo">package	^'WSTestOneWayRequest'.</body><body package="WebServicesDemo">responderWsdl11	| builder |	^#'TestOneWay.ResponderWsdl11' asQualifiedReference 		ifDefinedDo: [ :val | val new ] 		elseDo: [builder := WsdlClassBuilder readFrom: self oneWayWsdl11 readStream inNamespace: 'TestOneWay'.				builder 					package: self package;					responderName: 'ResponderWsdl11';					createResponderClass.								service := #'TestOneWay.OneWayInterface' asQualifiedReference					ifDefinedDo: [ :val | val ] 					elseDo: [builder createServiceClasses first ].				#'TestOneWay.ResponderWsdl11' asQualifiedReference value new].</body><body package="WebServicesDemo">responderWsdl20	| builder |	^#'TestOneWay.ResponderWsdl20' asQualifiedReference 		ifDefinedDo: [ :val | val new ] 		elseDo: [builder := WsdlClassBuilder readFrom: self oneWayWsdl20 readStream inNamespace: 'TestOneWay'.				builder 					package: self package;					responderName: 'ResponderWsdl20'; 					createResponderClass.				service := #'TestOneWay.OneWayInterface' asQualifiedReference					ifDefinedDo: [ :val | val ] 					elseDo: [builder createServiceClasses first ].				#'TestOneWay.ResponderWsdl20' asQualifiedReference value new].</body></methods><methods><class-id>WebServices.TestOneWayMEP</class-id> <category>tests</category><body package="WebServicesDemo">testWsdl11_One_Way"WSDL 1.1: Sending one-way request. For successful requests the server returns Http response with 202 code and an empty body. The Http response indicates that the request was received. Failed requests will raise HttpServerError"	| wsdlClient |	self createHelloWorldService.	wsdlClient := WsdlClient readFrom: self oneWayWsdl11 readStream.		[ responderWsdl11 addToServer.	" Test successful request "	self 		assert: ( wsdlClient executeSelector: #'HelloWorld' args: #() ) isNil		description: 'There is no value returned. The Http response body is empty '.	self 		assert: wsdlClient response transportEntity statusLine code = '202'		description: 'The server received the request. It replies with 202 code.' .	"Test failed request "	self createHelloWorldServiceWithError.	self 		should: [ wsdlClient executeSelector: #'HelloWorld' args: #()]			raise: HttpServerError.	] ensure: [ responderWsdl11 flushResponders ]</body><body package="WebServicesDemo">testWsdl20_In_Only" WSDL 2.0. The operation is described with #in-only MEP. For successful requests the server returns Http response with 202 code and an empty body. The Http response indicates that the request was received. For failed requests the server returns Http response with 500 code and an empty body. Failed requests will raise HttpServerError"	| wsdlClient  |	self createHelloWorldService.	wsdlClient := WsdlClient readFrom: self oneWayWsdl20 readStream.		[ responderWsdl20 addToServer.	" Test successful request "	self 		assert: ( wsdlClient executeSelector: #'HelloWorld' args: #() ) isNil		description: 'There is no value returned. The Http response body is empty '.	self 		assert: wsdlClient response transportEntity statusLine code = '202'		description: 'The server received the request. It replies with 202 code.' .	"Test failed request "	self createHelloWorldServiceWithError.	self 		should: [ wsdlClient executeSelector: #'HelloWorld' args: #()]			raise: HttpServerError.	] ensure: [ responderWsdl20 flushResponders ]</body><body package="WebServicesDemo">testWsdl20_Robust_In_Only" WSDL 2.0. The operation is described with #robust-in-only MEP. For successful requests the server returns Http response with 204 code and an empty body. For failed requests the server returns Http response with 500 code and the Soap SenderFault with details."	| wsdlClient  |	self createPingService.	wsdlClient := WsdlClient readFrom: self oneWayWsdl20 readStream.		[ responderWsdl20 addToServer.	" Test successful request "	self 		assert:  ( (wsdlClient executeSelector: #Ping  args: #('one') ) ) isNil		description: 'There is no value returned. The Http response body is empty '.	self 		assert: wsdlClient response transportEntity statusLine code = '204'		description: 'The server received the request. It replies with 204 code.' .	" Test failed request "	self createPingServiceWithError.	[ wsdlClient executeSelector: #Ping  args: #('one').	self assert: false ] 		on: SenderFault		do: [ :ex | 			self 				assert: ex description = 'SenderFault /Fault Code: env:Sender /Reason: Wrong parameter'				description: 'The request failed. The exception describes the details '].	self 		assert: wsdlClient response transportEntity statusLine code = '400'		description: 'The server received the request. The request failed and the server replies with 500 code and SenderFault body with details.' .	] ensure: [ responderWsdl20 flushResponders ]</body></methods><methods><class-id>WebServices.TestOneWayMEP</class-id> <category>initialize-release</category><body package="WebServicesDemo">setUp	| builder |	XMLObjectBinding configure.	WsdlBinding reset.	responderWsdl11 := #'TestOneWay.ResponderWsdl11' asQualifiedReference 		ifDefinedDo: [ :val | val  ] 		elseDo: [builder := WsdlClassBuilder readFrom: self oneWayWsdl11 readStream inNamespace: 'TestOneWay'.				builder 					package: self package;					responderName: 'ResponderWsdl11';					createResponderClass.				#'TestOneWay.ResponderWsdl11' asQualifiedReference value ].	responderWsdl20 := #'TestOneWay.ResponderWsdl20' asQualifiedReference 		ifDefinedDo: [ :val | val  ] 		elseDo: [builder := WsdlClassBuilder readFrom: self oneWayWsdl20 readStream inNamespace: 'TestOneWay'.				builder 					package: self package;					responderName: 'ResponderWsdl20'; 					createResponderClass.				#'TestOneWay.ResponderWsdl20' asQualifiedReference value ].	service := #'TestOneWay.OneWayInterface' asQualifiedReference					ifDefinedDo: [ :val | val ] 					elseDo: [builder createServiceClasses first ]</body></methods><methods><class-id>WebServices.TestSoapHeaders</class-id> <category>accessing</category><body package="WebServicesDemo">clientClass11	^#{ClientForAuthSearch11} valueOrDo: [nil]</body><body package="WebServicesDemo">clientClass20	^#{ClientForAuthSearch20} valueOrDo: [nil]</body><body package="WebServicesDemo">package	^'Test11SoapHeaders'</body><body package="WebServicesDemo">package20	^'Test20SoapHeaders'</body><body package="WebServicesDemo">responderClass11	^#{AuthSearchResponder11} valueOrDo: [nil]</body><body package="WebServicesDemo">responderClass20	^#{AuthSearchResponder20} valueOrDo: [nil]</body><body package="WebServicesDemo">serverClass20	^#{AuthSearchResponder20} valueOrDo: [nil]</body><body package="WebServicesDemo">x2OSpec	^'&lt;schemaBindings&gt;		&lt;xmlToSmalltalkBinding targetNamespace="urn:LibraryDemo/testSoapHeaders" defaultClassNamespace="WebServices" xmlns="urn:visualworks:VWSchemaBinding" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:tns="urn:LibraryDemo/testSoapHeaders"&gt;		&lt;object name="AuthenticationToken" smalltalkClass="AuthenticationToken"&gt;			&lt;element name="password" ref="xsd:string"/&gt;			&lt;element name="userID" ref="xsd:string"/&gt;		&lt;/object&gt;		&lt;object name="AuthenticationTokenExceptionHeader" smalltalkClass="AuthenticationTokenExceptionHeader"&gt;			&lt;element name="description" type="xsd:string"&gt;&lt;/element&gt;		&lt;/object&gt;		&lt;object name="AuthenticationTokenException" smalltalkClass="AuthenticationTokenException"&gt;			&lt;element name="password" ref="xsd:string"/&gt;			&lt;element name="userID" ref="xsd:string"/&gt;		&lt;/object&gt;		&lt;object name="Confirmation" smalltalkClass="Confirmation"&gt;			&lt;element name="return" ref="xsd:string"/&gt;		&lt;/object&gt;		&lt;object name="WrongPasswordException" smalltalkClass="WrongPasswordException"/&gt;		&lt;object name="Protocols.Library.Book" smalltalkClass="Protocols.Library.Book" baseType="tns:Protocols.Library.LoanedHolding" constraint="extension"&gt;				&lt;element name="dueDate" minOccurs="0" ref="xsd:date"/&gt;				&lt;element name="acquisitionDate" ref="xsd:date"/&gt;				&lt;element name="language" ref="xsd:string" conversionId="ByteSymbol"/&gt;				&lt;element name="authors" maxOccurs="unbounded" minOccurs="0" ref="tns:Protocols.Library.AuthorialName"/&gt;				&lt;element name="acquisitionNumber" ref="xsd:positiveInteger"/&gt;				&lt;element name="publisher" ref="xsd:string"/&gt;				&lt;element name="braille" ref="xsd:boolean"/&gt;				&lt;element name="title" ref="xsd:string"/&gt;				&lt;element name="catalogNumber" ref="tns:Protocols.Library.CatalogNumber"/&gt;				&lt;element name="pages" ref="xsd:short"/&gt;				&lt;element name="libraryName" ref="xsd:string"/&gt;				&lt;element name="collectionId" ref="xsd:string" conversionId="ByteSymbol"/&gt;				&lt;element name="publicationYear" ref="xsd:short"/&gt;				&lt;element name="acquisitionCost" ref="xsd:decimal"/&gt;				&lt;element name="statusId" ref="xsd:string" conversionId="ByteSymbol"/&gt;				&lt;element name="largePrint" ref="xsd:boolean"/&gt;			&lt;/object&gt;			&lt;object name="Protocols.Library.LoanedHolding" smalltalkClass="Protocols.Library.LoanedHolding" baseType="tns:Protocols.Library.Holding" constraint="extension"/&gt;			&lt;object name="Protocols.Library.Holding" smalltalkClass="Protocols.Library.Holding" baseType="tns:Protocols.Library.AbstractRandom" constraint="extension"/&gt;			&lt;object name="Protocols.Library.AbstractRandom" smalltalkClass="Protocols.Library.AbstractRandom"/&gt;			&lt;object name="Protocols.Library.CatalogNumber" smalltalkClass="Protocols.Library.CatalogNumber" baseType="tns:Protocols.Library.AbstractRandom" constraint="extension"&gt;				&lt;element name="part4" ref="xsd:string" conversionId="Character"/&gt;				&lt;element name="part1" ref="xsd:string"/&gt;				&lt;element name="part2" ref="xsd:base64Binary"/&gt;				&lt;element name="part3" ref="xsd:double"/&gt;			&lt;/object&gt;			&lt;object name="Protocols.Library.AuthorialName" smalltalkClass="Protocols.Library.AuthorialName"&gt;				&lt;element name="name" ref="tns:Protocols.Library.PersonName"/&gt;				&lt;element name="authorialType" ref="xsd:string" conversionId="ByteSymbol"/&gt;			&lt;/object&gt;			&lt;object name="Protocols.Library.PersonName" smalltalkClass="Protocols.Library.PersonName" baseType="tns:Protocols.Library.AbstractRandom" constraint="extension"&gt;				&lt;element name="middleNames" ref="xsd:string"/&gt;				&lt;element name="title" ref="xsd:string"/&gt;				&lt;element name="firstName" ref="xsd:string"/&gt;				&lt;element name="lastName" ref="xsd:string"/&gt;			&lt;/object&gt;		&lt;/xmlToSmalltalkBinding&gt;	&lt;/schemaBindings&gt;'</body></methods><methods><class-id>WebServices.TestSoapHeaders</class-id> <category>testing creating schemas</category><body package="WebServicesDemo">describeSearchServicesInterface: descriptor	|  interface interfaceOperation books |	"Provide parameters to create the WSDL schema. By default the schema is created in the document/literal style"	"Create &lt;interface&gt; descriptor"	interface := descriptor addInterfaceForServiceClass: WSAuthenticatedSearchService.	"Add operation descriptors to the interface "	"SearchByTitle operation "	(interfaceOperation := descriptor addInterfaceOperationNamed: 'SearchByTitle' toInterface: interface)			selector: #searchByTitle:;			documentation: 'The SearchByTitle operation returns a collection of holdings or empty collection if no holdings found'.	descriptor addInputParameterType: String toOperation: interfaceOperation.	books := descriptor newParameters.	books addReturnCollectionType: Protocols.Library.Book.	descriptor addOutputParameters: books  toOperation: interfaceOperation.	"AuthenticatedSearchByTitle operation"	(interfaceOperation := descriptor addInterfaceOperationNamed: 'AuthenticatedSearchByTitle' toInterface: interface)			selector: #authenticatedSearchByTitle:;			documentation: 'The AuthenticatedSearchByTitle operation returns a collection of holdings or empty collection if no holdings found'.	descriptor addInputParameterType: String toOperation: interfaceOperation.	descriptor addOutputParameters: books toOperation: interfaceOperation.	"AuthenticatedSearchByWord operation"	(interfaceOperation := descriptor addInterfaceOperationNamed: 'AuthenticatedSearchByWord' toInterface: interface)			selector: #authenticatedSearchByWord:;			documentation: 'To be able to make this request the message should include authentication token and access level. The AuthenticatedSearchByWord operation returns a collection of books or empty collection if no books found'.	descriptor addInputParameterType: String toOperation: interfaceOperation.	descriptor addOutputParameters: books toOperation: interfaceOperation.	^interface</body><body package="WebServicesDemo">testCreateWsdl11Schema	"This method creates the WSDL 1.1 Document/literal style specification  from service class methods "	| descriptor stream interface interfaceBinding service operation accessLevelHeader authTokenHeader headerFault confirmationHeader wsdl x2o |	"Provide parameters to create the WSDL schema. By default the schema is created in the document/literal style"	descriptor := Wsdl11ConfigurationDescriptor new.	descriptor buildOptions defaultClassNamespace: 'Smalltalk'.	descriptor targetNamespace: 'urn:LibraryDemo/11/testSoapHeaders'.	"Add domain types description as XMLObjectBinding object "	descriptor readImportedX2OBindingFrom: self x2OSpec readStream.	"Create &lt;portType&gt; descriptor"	interface := self describeSearchServicesInterface: descriptor.	"Create default descriptor for &lt;binding&gt; "	interfaceBinding := descriptor buildDefaultBindingDescriptorFor: interface.		"Add Soap headers to an operation."	"Create Soap header: AccessLevel"	accessLevelHeader := descriptor createSoapHeaderNamed: 'AccessLevel' type: String.	" Add header to the SearchByTitle operation binding"	operation := interfaceBinding operationNamed: 'SearchByTitle'  ifNone: [nil].	operation addInputSoapHeader: accessLevelHeader.		"Create Soap header: AuthenticationToken"	authTokenHeader := descriptor createSoapHeaderNamed: 'AuthenticationToken' type: AuthenticationToken.	"Add faults to the header."	headerFault := descriptor createSoapHeaderFaultNamed: 'AuthenticationTokenException' type: AuthenticationTokenException.	authTokenHeader addFault: headerFault.	headerFault := descriptor createSoapHeaderFaultNamed: 'WrongPasswordException' type: WrongPasswordException.	authTokenHeader addFault: headerFault.	operation := interfaceBinding operationNamed: 'AuthenticatedSearchByTitle'  ifNone: [nil].	operation addInputSoapHeader: authTokenHeader.		"Create Soap header: Confirmation"	confirmationHeader := descriptor createSoapHeaderNamed: 'Confirmation' type: Confirmation.	operation := interfaceBinding operationNamed: 'AuthenticatedSearchByWord'  ifNone: [nil].	operation 		addInputSoapHeader: authTokenHeader;		addInputSoapHeader: accessLevelHeader;		addOutputSoapHeader: confirmationHeader;		addOutputSoapHeader: accessLevelHeader.	"Set parameters to create endpoints for each services class"	service := descriptor addServiceNamed: 'TestLibraryServicesWithHeaders'.	service addPort: (descriptor 						createEndpointNamed: 'WSAuthenticatedSearchService' 						address:  'http://localhost:4444/testSoapHeadersServices' 						binding: interfaceBinding ).	"Validate the descriptor, register XMLObjectBinding for operation requests and responses and WsdlBinding"	descriptor complete.			stream := String new writeStream.	"Print the WSDL 1.1 specification on a stream.   "	descriptor printSpecOn:  stream.	wsdl := stream contents.	self 		assert: ( '*&lt;service name="TestLibraryServicesWithHeaders"&gt;		&lt;port name="WSAuthenticatedSearchService" binding="tns:WSAuthenticatedSearchService"&gt;			&lt;soap:address location="http://localhost:4444/testSoapHeadersServices"/&gt;		&lt;/port&gt;	&lt;/service&gt;*' match: wsdl )		description: 'checking that the schema has a port for each service class '.	self assert: ( '*&lt;operation name="AuthenticatedSearchByWord"&gt;			&lt;soap:operation soapAction="urn:LibraryDemo/11/testSoapHeaders#AuthenticatedSearchByWord" style="document"/&gt;			&lt;input&gt;				&lt;soap:header message="tns:AuthenticationTokenHeader" part="AuthenticationToken" use="literal"&gt;					&lt;soap:headerfault message="tns:AuthenticationTokenExceptionHeader" part="AuthenticationTokenException" use="literal"/&gt;					&lt;soap:headerfault message="tns:WrongPasswordExceptionHeader" part="WrongPasswordException" use="literal"/&gt;				&lt;/soap:header&gt;				&lt;soap:header message="tns:AccessLevelHeader" part="AccessLevel" use="literal"/&gt;				&lt;soap:body use="literal"/&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;soap:header message="tns:ConfirmationHeader" part="Confirmation" use="literal"/&gt;				&lt;soap:header message="tns:AccessLevelHeader" part="AccessLevel" use="literal"/&gt;				&lt;soap:body use="literal"/&gt;			&lt;/output&gt;		&lt;/operation&gt;*' match: wsdl )	description: 'checking that the AuthenticatedSearchByWord operation binding description includes header information'.	stream := String new writeStream.	"Print X2O specification on a stream.   "	descriptor printX2OSpecificationOn:  stream.	x2o := stream contents.	self assert: ( '*&lt;xmlToSmalltalkBinding targetNamespace="urn:LibraryDemo/11/testSoapHeaders_WSDLOperations" defaultClassNamespace="Smalltalk" xmlns="urn:visualworks:VWSchemaBinding" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:ns="urn:LibraryDemo/testSoapHeaders" xmlns:tns="urn:LibraryDemo/11/testSoapHeaders_WSDLOperations"&gt;	&lt;bindingImport namespace="urn:LibraryDemo/testSoapHeaders"/&gt;*' match: x2o )	description: 'checking that the X2O operation binding description imports X2O at urn:LibraryDemo/11/testSoapHeaders'.	self assert: ( '*	&lt;element name="AccessLevel" ref="xsd:string"/&gt;	&lt;element name="AuthenticationToken" ref="ns:AuthenticationToken"/&gt;	&lt;element name="AuthenticationTokenException" ref="ns:AuthenticationTokenException"/&gt;	&lt;element name="WrongPasswordException" ref="ns:WrongPasswordException"/&gt;	&lt;element name="Confirmation" ref="ns:Confirmation"/&gt;*' match: x2o )	description: 'checking that the X2O operation binding description includes headers and header fault description'.	^descriptor</body><body package="WebServicesDemo">testCreateWsdl20Schema	"This method creates the WSDL 2.0 specification  from service class methods "	| descriptor stream interface interfaceOperation interfaceBinding service operation accessLevelHeader authTokenHeader confirmationHeader wsdl x2o header soapFault books |	"Provide parameters to create the WSDL schema."	descriptor := Wsdl20ConfigurationDescriptor new.	descriptor 			targetNamespace: 'urn:LibraryDemo/20/testSoapHeaders';			defaultClassNamespace: 'Smalltalk'.	"Add domain types description as XMLObjectBinding object "	descriptor readImportedX2OBindingFrom: self x2OSpec readStream.	"Create &lt;interface&gt; descriptor"	interface := descriptor addInterfaceForServiceClass: WSAuthenticatedSearchService.	"Add interface fault description "	descriptor addFaultNamed: 'AuthenticationTokenException' type: AuthenticationTokenException toInterface: interface.	"Add operation descriptors to the interface "	"SearchByTitle operation "	(interfaceOperation := descriptor addInterfaceOperationNamed: 'SearchByTitle' toInterface: interface)			selector: #searchByTitle:;			documentation: 'The SearchByTitle operation returns a collection of holdings or empty collection if no holdings found'.	descriptor addInputParameterType: String toOperation: interfaceOperation.	books := descriptor newParameters.	books addReturnCollectionType: Protocols.Library.Book.	descriptor addOutputParameters: books  toOperation: interfaceOperation.	"AuthenticatedSearchByTitle operation"	(interfaceOperation := descriptor addInterfaceOperationNamed: 'AuthenticatedSearchByTitle' toInterface: interface)			selector: #authenticatedSearchByTitle:;			documentation: 'The AuthenticatedSearchByTitle operation returns a collection of holdings or empty collection if no holdings found'.	descriptor addInputParameterType:  String  toOperation: interfaceOperation.	descriptor addOutputParameters: books toOperation: interfaceOperation.	"Describe operation faults "	descriptor addOutfaultNamed: 'AuthenticationTokenException' toOperation: interfaceOperation.	"AuthenticatedSearchByWord operation"	(interfaceOperation := descriptor addInterfaceOperationNamed: 'AuthenticatedSearchByWord' toInterface: interface)			selector: #authenticatedSearchByWord:;			documentation: 'To be able to make this request the message should include authentication token and access level. The AuthenticatedSearchByWord operation returns a collection of books or empty collection if no books found'.	descriptor addInputParameterType:  String  toOperation: interfaceOperation.	descriptor addOutputParameters: books toOperation: interfaceOperation.	"Describe operation faults "	descriptor addOutfaultNamed: 'AuthenticationTokenException' toOperation: interfaceOperation.	"Create default descriptor for &lt;binding&gt; "	interfaceBinding := descriptor buildDefaultBindingDescriptorFor: interface.	"Create Soap binding fault with header "	(header := descriptor createSoapHeaderNamed: 'AuthenticationTokenExceptionHeader' type: AuthenticationTokenExceptionHeader)		mustUnderstand: true;		required: true.	(soapFault := descriptor addSoapFaultNamed: 'AuthenticationTokenException' toBinding: interfaceBinding)		addSoapFaultCodeNamed: 'Sender';		addSoapFaultSubcodeNamed:  'WrongAuthenticationToken'.	soapFault addSoapHeader: header.		"Add Soap headers to an operation."	"Create Soap header: AccessLevel. The header will be created with default options:	mustUnderstand='true' and required='true' "	accessLevelHeader := descriptor createSoapHeaderNamed: 'AccessLevel' type: String.	" Add header to the SearchByTitle operation binding"	operation := interfaceBinding operationNamed: 'SearchByTitle'  ifNone: [nil].	operation addInputSoapHeader: accessLevelHeader.		"Create Soap header: AuthenticationToken"	authTokenHeader := descriptor createSoapHeaderNamed: 'AuthenticationToken' type: AuthenticationToken.	operation := interfaceBinding operationNamed: 'AuthenticatedSearchByTitle'  ifNone: [nil].	operation addInputSoapHeader: authTokenHeader.		"Create Soap header: Confirmation"	(confirmationHeader := descriptor createSoapHeaderNamed: 'Confirmation' type: Confirmation) required: false.	operation := interfaceBinding operationNamed: 'AuthenticatedSearchByWord'  ifNone: [nil].	"Add input output headers to the operation "	operation 		addInputSoapHeader: authTokenHeader;		addInputSoapHeader: accessLevelHeader;		addOutputSoapHeader: confirmationHeader;		addOutputSoapHeader: accessLevelHeader.	"Set parameters to create endpoints for each services class"	service := descriptor addServiceNamed: 'TestLibraryServicesWithHeaders'  interface: interface.	service addPort: (descriptor 						createEndpointNamed: 'WSAuthenticatedSearchService' 						address:  'http://localhost:4450/testSoapHeadersServices' 						binding: interfaceBinding ).	"Validate the descriptor, register XMLObjectBinding for operation requests and responses and WsdlBinding"	descriptor complete.			stream := String new writeStream.	"Print the WSDL 1.1 specification on a stream.   "	descriptor printSpecOn:  stream.	wsdl := stream contents.	self 		assert: ( '*&lt;service name="TestLibraryServicesWithHeaders" interface="tns:WSAuthenticatedSearchService"&gt;		&lt;endpoint name="WSAuthenticatedSearchService" binding="tns:WSAuthenticatedSearchService" address="http://localhost:4450/testSoapHeadersServices"/&gt;	&lt;/service&gt;*' match: wsdl )		description: 'checking that the schema has a port for each service class '.	self assert: ( '*&lt;binding name="WSAuthenticatedSearchService" interface="tns:WSAuthenticatedSearchService" type="http://www.w3.org/ns/wsdl/soap" wsoap:version="1.2" wsoap:protocol="http://www.w3.org/2003/05/soap/bindings/HTTP/" wsoap:mepDefault="http://www.w3.org/2003/05/soap/mep/request-response/"&gt;		&lt;fault ref="tns:AuthenticationTokenException" wsoap:code="SOAP-ENV:Sender" wsoap:subcodes="tns:WrongAuthenticationToken"&gt;			&lt;wsoap:header element="ns:AuthenticationTokenExceptionHeader" mustUnderstand="true" required="true"/&gt;		&lt;/fault&gt;*' match: wsdl )	description: 'checking that the AuthenticatedSearchByWord operation binding description includes header and outfault information'.	self assert: ( '*&lt;operation wsoap:action="urn:LibraryDemo/20/testSoapHeaders#AuthenticatedSearchByWord" ref="tns:AuthenticatedSearchByWord"&gt;			&lt;input&gt;				&lt;wsoap:header element="ns:AuthenticationToken" mustUnderstand="true" required="true"/&gt;				&lt;wsoap:header element="ns:AccessLevel" mustUnderstand="true" required="true"/&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;wsoap:header element="ns:Confirmation" mustUnderstand="true" required="false"/&gt;				&lt;wsoap:header element="ns:AccessLevel" mustUnderstand="true" required="true"/&gt;			&lt;/output&gt;			&lt;outfault ref="tns:AuthenticationTokenException"/&gt;		&lt;/operation&gt;*' match: wsdl )	description: 'checking that the AuthenticatedSearchByWord operation binding description includes header and outfault information'.	stream := String new writeStream.	"Print X2O specification on a stream.   "	descriptor printX2OSpecificationOn:  stream.	x2o := stream contents.	self assert: ( '*&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;xmlToSmalltalkBinding targetNamespace="urn:LibraryDemo/20/testSoapHeaders_WSDLOperations" defaultClassNamespace="Smalltalk" xmlns="urn:visualworks:VWSchemaBinding" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:ns="urn:LibraryDemo/testSoapHeaders" xmlns:tns="urn:LibraryDemo/20/testSoapHeaders_WSDLOperations"&gt;	&lt;bindingImport namespace="urn:LibraryDemo/testSoapHeaders"/&gt;*' match: x2o )	description: 'checking that the X2O operation binding description imports X2O at urn:LibraryDemo/20/testSoapHeaders'.	self assert: ( '*&lt;element name="AccessLevel" ref="xsd:string"/&gt;	&lt;element name="AuthenticationToken" ref="ns:AuthenticationToken"/&gt;	&lt;element name="Confirmation" ref="ns:Confirmation"/&gt;*' match: x2o )	description: 'checking that the X2O operation binding description includes headers description'.	^descriptor</body></methods><methods><class-id>WebServices.TestSoapHeaders</class-id> <category>testing WSDL 2.0</category><body package="WebServicesDemo">test20CreateClientResponderClasses	"Test that the WsdlClassBuilder creates an Opentalk server and client classes to run a Web Services application"	| serverClass builder client script interceptorClass |	builder := WsdlClassBuilder new.	builder 		package: self package20;		clientNS:  'MyAuthServices20';		responderNS:  'MyAuthServices20'.	builder initializeConfigFrom: self  testCreateWsdl20Schema.	"Create the Opentalk server and client classes"	builder responderName: 'MyAuthSearchResponder'.	[serverClass := builder createResponderClass.	[builder createClientClasses] on: ClientClassExistExc do: [ :ex | ex resume].	] on: WSDuplicateBindingsError do: [ :ex | ex proceed ].	self 		assert: (  (interceptorClass := #{MyAuthServices20.ConfirmationClientInterceptor} valueOrDo: [nil]) notNil  )		description: 'checking that the client interceptor class for the #Confirmation Soap header has been created'.	self 		assert: ( interceptorClass headerNames first =  #Confirmation  )		description: 'checking that the interceptor class has class method with the supported header names '.	self 		assert: (  (interceptorClass := #{MyAuthServices20.ConfirmationResponderInterceptor} valueOrDo: [nil]) notNil  )		description: 'checking that the responder interceptor class for the #Confirmation Soap header has been created'.	self 		assert: ( interceptorClass headerNames first =  #Confirmation  )		description: 'checking that the interceptor class has class method with the supported header names '.	self 		assert: ( (#{MyAuthServices20.MyAuthSearchResponder} valueOrDo: [nil]) notNil  )		description: 'checking that the responder class has been created'.	self 		assert: ( (client := #{MyAuthServices20.WSAuthenticatedSearchServiceClient} valueOrDo: [nil]) notNil )		description: 'checking that the client class has been created'.	self 		assert: client new policy interceptorClasses size = 4 		description: 'checking that the client class has been created with three interceptor classes for Soap header and one class for the fault header'.	"The client can create a script that helps to provide the operation parameter types and create message headers"	script := client new createScript.	self 		assert: ( '*"Run operation #AuthenticatedSearchByWord""The request requires Soap header blocks. Add Soap headers to the request in interceptor classes: RefactoringBrowser newOnClass: MyAuthServices20.AuthenticationTokenClientInterceptor.RefactoringBrowser newOnClass: MyAuthServices20.AccessLevelClientInterceptor."		arg1 := "String".	[		value := client authenticatedSearchByWord: arg1.	]	on: WebServices.AuthenticationTokenException	do: [ :exception | Dialog warn: exception errorString ].*' match: script)		description: 'checking the #AuthenticatedSearchByWord operation description in the script'.</body><body package="WebServicesDemo">test20ServiceWithHeaders	"Test that the client can send and receive WS messages with headers"	| responder client value policy |	responder := self responderClass20.	client := self clientClass20 new.	[responder addToServer.	"Sending the first requst " 	"Set the processing policy data. The data will be used to create Soap header entries for the client request " 	policy := client policy.	"Set  DemoProcessingPolicy&gt;&gt;accessLevel for the client. Will be used to create #'AccessLevel' Soap Header entry "	policy accessLevel: '12345'.	"Set  DemoProcessingPolicy&gt;&gt;userID and #password for the client. Will be used to create #'AuthenticationToken' Soap Header entry "	policy		userID: 'UserID';		password: 'password'.	"Send the request"	value := client authenticatedSearchByWord: 'and'.	self 		assert: ( '*and*' match: value first title )		description: 'checking that the book has matching words in the title'.	"Sending the second requst " 	"Add the #AuthenticationToken header to the request. The provided userID and password are NOT accepted by the header processor on the server"	policy userID: 'ID#ABC'.	"The server returns a reply with #Confirmation header value: &lt;not confirmed&gt;. The client header processor raises the WrongConfirmationExc exception. See Demo20HeaderInterceptor&gt;&gt;receivingReply:in:"	self should: 	[client authenticatedSearchByWord: 'and']		raise: WrongConfirmationExc.	"Sending the third request"	"Add the #AuthenticationToken header to the request. The provided userIS and password are NOT accepted by the header processor on the server"	policy 		userID: 'aaa';		password: 'zzz'.	"The SOAP fault reply returns from the server. 	The client header exception processor raises the #AuthenticationTokenException exception in Demo20HeaderInterceptor&gt;&gt;receivingRequestEnvelope:in:"	[client authenticatedSearchByWord: 'and'.	] 	on: WebServices.AuthenticationTokenException		do: [ :exception | 			self assert: (exception userID = 'aaa' and: [ exception password = 'zzz' ]).]	] ensure: [ responder flushResponders ]</body><body package="WebServicesDemo">test20ServiceWithProcessEnv	"Test that the client can send and receive WS messages with headers. Setting Responder environmentWithHeaders to true will add the headers to the ProcessEnvironment current, and allow access to the header values in the service class methods. For an example of how to access header values in the method, see: WSAuthenticatedSearchService&gt;&gt;authenticatedSearchByTitle:"	| responder client value title |	responder := self responderClass20.	"Set an option to access headers in the service method"	responder responders asOrderedCollection first environmentWithHeaders: true.	client := self clientClass20 new.	title := 	'My Life in Germany'.	[responder addToServer.	client policy		accessLevel: '12345';		userID: 'UserID';		password: 'password'.	value := (client authenticatedSearchByTitle:  title ) first.	self assert: (  title = value  title ).	] ensure: [ responder flushResponders ]</body></methods><methods><class-id>WebServices.TestSoapHeaders</class-id> <category>testing WSDL 1.1</category><body package="WebServicesDemo">test11CreateClientResponderClasses	"Test that the WsdlClassBuilder creates an Opentalk server and client classes to run a Web Services application"	|  builder client script interceptorClass |	builder := WsdlClassBuilder new.	builder 		package: self package;		clientNS:  'MyAuthServices11';		responderNS:  'MyAuthServices11'.	builder initializeConfigFrom: self  testCreateWsdl11Schema.	"Create the Opentalk server and client classes"	builder responderName: 'MyAuthSearchResponder'.	[builder createResponderClass.	[builder createClientClasses] on: ClientClassExistExc do: [ :ex | ex resume].	] on: WSDuplicateBindingsError do: [ :ex | ex proceed ].	self 		assert: (  (interceptorClass := #{MyAuthServices11.ConfirmationClientInterceptor} valueOrDo: [nil]) notNil  )		description: 'checking that the client interceptor class for the #Confirmation Soap header has been created'.	self 		assert: (  (interceptorClass := #{MyAuthServices11.ConfirmationResponderInterceptor} valueOrDo: [nil]) notNil  )		description: 'checking that the responder interceptor class for the #Confirmation Soap header has been created'.	self 		assert: ( interceptorClass headerNames first =  #Confirmation  )		description: 'checking that the interceptor class has class method with the supported header names '.	self 		assert: ( (#{MyAuthServices11.MyAuthSearchResponder} valueOrDo: [nil]) notNil  )		description: 'checking that the responder class has been created'.	self 		assert: ( (client := #{MyAuthServices11.WSAuthenticatedSearchServiceClient} valueOrDo: [nil]) notNil )		description: 'checking that the client class has been created'.	self 		assert: client new policy interceptorClasses size = 5 		description: 'checking that the client class has been created with three interceptor classes'.	"The client can create a script that helps to provide the operation parameter types and create message headers"	script := client new createScript.	self 		assert: ( '*"Run operation #AuthenticatedSearchByWord""The request requires Soap header blocks. Add Soap headers to the request in interceptor classes: RefactoringBrowser newOnClass: MyAuthServices11.AuthenticationTokenClientInterceptor.RefactoringBrowser newOnClass: MyAuthServices11.AccessLevelClientInterceptor."		arg1 := "String".	[		value := client authenticatedSearchByWord: arg1.	]	on: WebServices.AuthenticationTokenException, WebServices.WrongPasswordException	do: [ :exception | Dialog warn: exception errorString ].*' match: script)		description: 'checking the #AuthenticatedSearchByWord operation description in the script'.</body><body package="WebServicesDemo">test11ServiceWithHeaders	"Test that the client can send and receive WS messages with headers"	| responder client value policy |	responder := self responderClass11.	client := self clientClass11 new.	[responder addToServer.	"Set the processing policy data. The data will be used to create Soap header entries for the client request " 	policy := client policy.	"Set  DemoProcessingPolicy&gt;&gt;accessLevel for the client. Will be used to create #'AccessLevel' Soap Header entry "	policy accessLevel: '12345'.	"Set  DemoProcessingPolicy&gt;&gt;userID and #password for the client. Will be used to create #'AuthenticationToken' Soap Header entry "	policy		userID: 'UserID';		password: 'password'.	"Send the request"	value := client authenticatedSearchByWord: 'and'.	self 		assert: ( '*and*' match: value first title )		description: 'checking that the book has matching words in the title'.	"Sending the second requst " 	"Add the #AuthenticationToken header to the request. The provided userID and password are NOT accepted by the header processor on the server"	policy userID: 'ID#ABC'.	"The server returns a reply with #Confirmation header value: &lt;not confirmed&gt;. The client header processor raises the WrongConfirmationExc exception. See DemoHeaderProcessor&gt;&gt;receivingReply:in::"	self should: 	[client authenticatedSearchByWord: 'and']		raise: WrongConfirmationExc.	"Sending the third request"	"Add the #AuthenticationToken header to the request. The provided userIS and password are NOT accepted by the header processor on the server"	policy 		userID: 'aaa';		password: 'zzz'.	"The SOAP fault reply returns from the server. 	The client header exception processor raises the #AuthenticationTokenException exception in DemoHeader11Processor&gt;&gt;receivingRequestEnvelope:in:"	[client authenticatedSearchByWord: 'and'.	] 	on: WebServices.AuthenticationTokenException		do: [ :exception | 			self assert: (exception userID = 'aaa' and: [ exception password = 'zzz' ]).]	] ensure: [ responder flushResponders ]</body><body package="WebServicesDemo">test11ServiceWithProcessEnv	"Test that the client can send and receive WS messages with headers. Setting MarshalerConfiguration environmentWithHeaders to true will add the headers to the ProcessEnvironment current, and allow access to the header values in the service class methods. For an example of how to access header values in the method, see: WSAuthenticatedSearchService&gt;&gt;authenticatedSearchByTitle:"	| responder client value title |	responder := self responderClass11.	"Set an option to access headers in the service method"	responder responders asOrderedCollection first environmentWithHeaders: true.	client := self clientClass11 new.	title := 	'My Life in Germany'.	[responder addToServer.	client policy		accessLevel: '12345';		userID: 'UserID';		password: 'password'.	value := (client authenticatedSearchByTitle:  title ) first.	self assert: (  title = value  title ).	] ensure: [responder  flushResponders]</body></methods><methods><class-id>WebServices.TestCreateWSDLSchema</class-id> <category>testing</category><body package="WebServicesDemo">describeGeneralServicesInterface: descriptor	"Create &lt;interface&gt; descriptor for WSGeneralServices service class"	| generalServicesInterface interfaceOperation parameters |	"Create interface description "	generalServicesInterface := descriptor addInterfaceForServiceClass: WSGeneralServices.	"Add operation descriptors to the interface"	"Describe HoldingByAcquisitionNumber operation. "	(interfaceOperation := descriptor addInterfaceOperationNamed: 'HoldingByAcquisitionNumber' toInterface: generalServicesInterface)			selector: #holdingByAcquisitionNumber:;			documentation: 'The HoldingByAcquisitionNumber operation returns a holding or exception if the holding not found'.	"Describe the operation  input parameters."	parameters := descriptor newParameters.	"Provide the parameter name and type. The type can be simple type as: String, LargePositiveInteger or a complex type described in X2O. List of available simple types is provided in XMLObjectBinding class&gt;&gt;simpleTypes  "	parameters addParameterNamed:  'holdingByAcquisitionNumber'  type: LargePositiveInteger.	descriptor addInputParameters: parameters toOperation: interfaceOperation.	"Describe return type "	parameters := descriptor newParameters.	"See X2O description:&lt;object name='Protocols.Library.Book' smalltalkClass='Protocols.Library.Book' ..&gt; "	parameters addReturnType: Protocols.Library.Book.	descriptor addOutputParameters: parameters  toOperation: interfaceOperation.	"Describe operation faults."	"Add Wsdl 1.1 fault.	By default #addFaultNamed:toOperation: method adds Wsdl 2.0 outfault. Use  #addOutfaultNamed:toOperation: and #addInfaultNamed:toOperation: to add specific faults to Wsdl 2.0 description"	descriptor addFaultNamed: 'holdingNotFound' type: Protocols.Library.HoldingNotFound toOperation: interfaceOperation.	"Describe ProvidesServices operation "	(interfaceOperation := descriptor addInterfaceOperationNamed: 'ProvidesServices' toInterface: generalServicesInterface)			selector: #providesServices;			documentation: 'The ProvidesServices operation checks if the library has some services. Returns true or false'.	descriptor addOutputParameterType: Boolean  toOperation: interfaceOperation.	"Describe AvailableBooks operation "	(interfaceOperation := descriptor addInterfaceOperationNamed: 'AvailableBooks' toInterface: generalServicesInterface)			selector: #availableBooks;			documentation: 'The AvailableBooks returns available books'.	parameters := descriptor newParameters.	parameters addReturnCollectionType: WebServices.WSBook.	descriptor addOutputParameters: parameters  toOperation: interfaceOperation.	^generalServicesInterface</body><body package="WebServicesDemo">describeSearchServicesInterface: descriptor	"Create &lt;interface&gt; descriptor for WSSearchServices service class"	| searchServicesInterface interfaceOperation parameters |	"Create interface description for  the service class: WSSearchServices"	searchServicesInterface := descriptor addInterfaceForServiceClass: WSSearchServices.	"Add operation descriptors to the interface"	"Describe SearchByTitle operation "	(interfaceOperation := descriptor addInterfaceOperationNamed: 'SearchByTitle' toInterface: searchServicesInterface)			selector: #searchByExactTitle:includeAffiliatedLibraries:;			documentation: 'The SearchByTitle operation returns a collection of holdings or empty collection if no holdings found'.	"Describe input parameters. Add each parameter with its type"	(parameters := descriptor newParameters)		addParameterNamed:  'searchByExactTitle'  type: String;		addParameterNamed:  'includeAffiliatedLibraries'  type: Boolean.	descriptor addInputParameters: parameters toOperation: interfaceOperation.	"Describe return type. "	parameters := descriptor newParameters.	"Return result as a collection of  Protocols.Library.Book "	parameters addReturnCollectionType: Protocols.Library.Book.	descriptor addOutputParameters: parameters  toOperation: interfaceOperation.	"Describe SearchByTitles operation "	(interfaceOperation := descriptor addInterfaceOperationNamed: 'SearchByTitles' toInterface: searchServicesInterface)			selector: #searchByExactTitles:includeAffiliatedLibraries:;			documentation: 'The SearchByTitles operation returns a collection of holdings or empty collection if no holdings found'.	"Describe input parameters "	(parameters := descriptor newParameters)		addParameterNamed:  'searchByExactTitles'  collectionType: String;		addParameterNamed:  'includeAffiliatedLibraries'  type: Boolean.	descriptor addInputParameters: parameters toOperation: interfaceOperation.	"Describe return type "	parameters := descriptor newParameters.	parameters addReturnCollectionType: Protocols.Library.Book.	descriptor addOutputParameters: parameters  toOperation: interfaceOperation.	"Describe SearchByWord operation "	(interfaceOperation := descriptor addInterfaceOperationNamed: 'SearchByWord' toInterface: searchServicesInterface)			selector: #searchByTitleWord:includeAffiliatedLibraries:;			documentation: 'The SearchByWord operation returns a collection of holdings or empty collection if no holdings found'.	"Describe input parameters "	(parameters := descriptor newParameters)		addParameterNamed:  'searchByTitleWord'  type: String;		addParameterNamed:  'includeAffiliatedLibraries'  type: Boolean.	descriptor addInputParameters: parameters toOperation: interfaceOperation.	"Describe return type. Add type that is described in X2O as &lt;struct name=ChoiceOfHoldings&gt; "	parameters := descriptor newParameters.	parameters addReturnType: ChoiceOfHoldings.	descriptor addOutputParameters: parameters  toOperation: interfaceOperation.	^searchServicesInterface</body><body package="WebServicesDemo">testCreateWsdl11RpcSchema	"This method creates the WSDL 1.1 Rpc/literal style specification"	| descriptor stream interface service wsdl x2o generalServicesBinding searchServicesBinding |	descriptor := Wsdl11ConfigurationDescriptor new.	descriptor 		defaultClassNamespace: 'Smalltalk';		targetNamespace: 'urn:LibraryDemo/rpc/testing';		useRpc;		readImportedX2OBindingFrom: self x2OSpec readStream.	"Create &lt;portType&gt; descriptor for WSGeneralServices service class"	interface := self  describeGeneralServicesInterface: descriptor.	"Create default descriptor for &lt;binding&gt; "	generalServicesBinding := descriptor buildDefaultBindingDescriptorFor: interface.	"Create &lt;portType&gt; descriptor for WSSearchServices service class"	interface := self describeSearchServicesInterface: descriptor.	"For the interface WSSearchServices create default descriptor for &lt;binding&gt; "	searchServicesBinding := descriptor buildDefaultBindingDescriptorFor: interface.	"Set parameters to create endpoints for each services class"	service := descriptor addServiceNamed: 'TestLibraryServices'.	service addPort: (descriptor 						createEndpointNamed: 'WSGeneralServices' 						address:  'http://localhost:4444/testGeneralServices' 						binding: generalServicesBinding ).	service addPort: (descriptor 						createEndpointNamed: 'WSSearchServices'  						address: 'http://localhost:4444/testSearchServices' 						binding: searchServicesBinding ).	"Validate the descriptor, register XMLObjectBinding for operation requests and responses and WsdlBinding"	descriptor complete.			stream := String new writeStream.	"Print the WSDL 1.1 specification on a stream.   "	descriptor printSpecOn:  stream.	wsdl := stream contents.	self 		assert: ( '*&lt;service name="TestLibraryServices"&gt;		&lt;port name="WSGeneralServices" binding="tns:WSGeneralServices"&gt;			&lt;soap:address location="http://localhost:4444/testGeneralServices"/&gt;		&lt;/port&gt;		&lt;port name="WSSearchServices" binding="tns:WSSearchServices"&gt;			&lt;soap:address location="http://localhost:4444/testSearchServices"/&gt;		&lt;/port&gt;	&lt;/service&gt;*' match: wsdl )		description: 'checking that the schema has a port for each service class '.	self assert: ( '*&lt;message name="SearchByTitle"&gt;		&lt;part name="searchByExactTitle" type="xsd:string"/&gt;		&lt;part name="includeAffiliatedLibraries" type="xsd:boolean"/&gt;	&lt;/message&gt;*' match: wsdl )	description: 'checking that messages reference types'.	self assert: ( '*&lt;portType name="WSGeneralServices"&gt;		&lt;operation name="HoldingByAcquisitionNumber" parameterOrder="holdingByAcquisitionNumber"&gt;			&lt;documentation&gt;The HoldingByAcquisitionNumber operation returns a holding or exception if the holding not found&lt;/documentation&gt;			&lt;input message="tns:HoldingByAcquisitionNumber"/&gt;			&lt;output message="tns:HoldingByAcquisitionNumberResponse"/&gt;			&lt;fault name="holdingNotFound" message="tns:HoldingNotFoundFault"/&gt;		&lt;/operation&gt;*' match: wsdl )	description: 'checking that we created the WSGeneralServices port type and the HoldingByAcquisitionNumber operation description includes fault information'.	self assert: ( '*&lt;portType name="WSSearchServices"&gt;		&lt;operation name="SearchByTitle" parameterOrder="searchByExactTitle includeAffiliatedLibraries"&gt;			&lt;documentation&gt;The SearchByTitle operation returns a collection of holdings or empty collection if no holdings found&lt;/documentation&gt;			&lt;input message="tns:SearchByTitle"/&gt;			&lt;output message="tns:SearchByTitleResponse"/&gt;		&lt;/operation&gt;*' match: wsdl )	description: 'checking that we created the WSSearchServices port type'.	self assert: ( '*&lt;binding name="WSGeneralServices" type="tns:WSGeneralServices"&gt;		&lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="rpc"/&gt;		&lt;operation name="HoldingByAcquisitionNumber"&gt;			&lt;soap:operation soapAction="urn:LibraryDemo/rpc/testing#HoldingByAcquisitionNumber" style="rpc"/&gt;			&lt;input&gt;				&lt;soap:body use="literal" namespace="urn:LibraryDemo/rpc/testing"/&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;soap:body use="literal" namespace="urn:LibraryDemo/rpc/testing"/&gt;			&lt;/output&gt;			&lt;fault name="holdingNotFound"&gt;				&lt;soap:fault name="holdingNotFound" use="literal"/&gt;			&lt;/fault&gt;		&lt;/operation&gt;*' match: wsdl )	description: 'checking that we created the WSGeneralServices binding and the HoldingByAcquisitionNumber operation binding description includes fault information'.	self assert: ( '*&lt;binding name="WSSearchServices" type="tns:WSSearchServices"&gt;		&lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="rpc"/&gt;		&lt;operation name="SearchByTitle"&gt;			&lt;soap:operation soapAction="urn:LibraryDemo/rpc/testing#SearchByTitle" style="rpc"/&gt;			&lt;input&gt;				&lt;soap:body use="literal" namespace="urn:LibraryDemo/rpc/testing"/&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;soap:body use="literal" namespace="urn:LibraryDemo/rpc/testing"/&gt;			&lt;/output&gt;		&lt;/operation&gt;*' match: wsdl )	description: 'checking that we created the WSSearchServices binding'.	stream := String new writeStream.	"Print X2O specification on a stream.   "	descriptor printX2OSpecificationOn:  stream.	x2o := stream contents.	self assert: ( '*&lt;xmlToSmalltalkBinding targetNamespace="urn:LibraryDemo/rpc/testing_WSDLOperations" defaultClassNamespace="Smalltalk" xmlns="urn:visualworks:VWSchemaBinding" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:ns="urn:LibraryDemo\DomainTypes"&gt;	&lt;bindingImport namespace="urn:LibraryDemo\DomainTypes"/&gt;	&lt;element name="holdingNotFound" ref="ns:Protocols.Library.HoldingNotFound"/&gt;	&lt;sequence_of name="CollectionOfWSBook" smalltalkClass="OrderedCollection"&gt;		&lt;element name="WSBook" maxOccurs="unbounded" minOccurs="0" ref="ns:WSBook"/&gt;	&lt;/sequence_of&gt;	&lt;sequence_of name="CollectionOfBook" smalltalkClass="OrderedCollection"&gt;		&lt;element name="Book" maxOccurs="unbounded" minOccurs="0" ref="ns:Protocols.Library.Book"/&gt;	&lt;/sequence_of&gt;	&lt;sequence_of name="CollectionOfString" smalltalkClass="OrderedCollection"&gt;		&lt;element name="String" maxOccurs="unbounded" minOccurs="0" ref="xsd:string"/&gt;	&lt;/sequence_of&gt;&lt;/xmlToSmalltalkBinding&gt;*' match: x2o )	description: 'checking the X2O operation types '.	^descriptor</body><body package="WebServicesDemo">testCreateWsdl11Schema	"This method creates the WSDL 1.1 Document/literal style specification"	| descriptor stream  service wsdl x2o generalServicesBinding searchServicesBinding generalServicesInterface searchServicesInterface |	"Provide parameters to create the WSDL schema. By default the schema is created in the document/literal style"	"Create  an instance of Wsdl11ConfigurationDescriptor to generate WSDL 1.1"	descriptor := Wsdl11ConfigurationDescriptor new.	descriptor 		defaultClassNamespace: 'Smalltalk';		targetNamespace: 'urn:LibraryDemo/11/doc/testing'.	"Add domain types, exception and Soap Headers description as XMLObjectBinding objects. "	descriptor readImportedX2OBindingFrom: self x2OSpec readStream.	"Create &lt;portType&gt; descriptor for WSGeneralServices service class"	generalServicesInterface := self describeGeneralServicesInterface: descriptor.	"For the WSGeneralServices interface create default descriptor for &lt;binding&gt; "	generalServicesBinding := descriptor buildDefaultBindingDescriptorFor: generalServicesInterface.	"Create &lt;portType&gt; descriptor for WSSearchServices service class"	searchServicesInterface := self describeSearchServicesInterface: descriptor.	"For the WSSearchServices interface create default descriptor for &lt;binding&gt; "	searchServicesBinding := descriptor buildDefaultBindingDescriptorFor: searchServicesInterface.	"Set parameters to create endpoints for each services class. Create &lt;service&gt; description."	service := descriptor addServiceNamed: 'TestLibraryServices'.	"Create port description and soap address for the service"	service addPort: (descriptor 						createEndpointNamed: 'WSGeneralServices' 						address:  'http://localhost:4444/testGeneralServices' 						binding: generalServicesBinding ).	service addPort: (descriptor 						createEndpointNamed: 'WSSearchServices'  						address: 'http://localhost:4444/testSearchServices' 						binding: searchServicesBinding ).	"Validate the descriptor, register XMLObjectBinding for operation requests and responses and WsdlBinding"	descriptor complete.			stream := String new writeStream.	"Print the WSDL 1.1 specification on a stream."	descriptor printSpecOn:  stream.	wsdl := stream contents.	self 		assert: ( '*&lt;service name="TestLibraryServices"&gt;		&lt;port name="WSGeneralServices" binding="tns:WSGeneralServices"&gt;			&lt;soap:address location="http://localhost:4444/testGeneralServices"/&gt;		&lt;/port&gt;		&lt;port name="WSSearchServices" binding="tns:WSSearchServices"&gt;			&lt;soap:address location="http://localhost:4444/testSearchServices"/&gt;		&lt;/port&gt;	&lt;/service&gt;*' match: wsdl )		description: 'checking that the schema has a port for each service class '.	self assert: ( '*&lt;portType name="WSGeneralServices"&gt;		&lt;operation name="HoldingByAcquisitionNumber"&gt;			&lt;documentation&gt;The HoldingByAcquisitionNumber operation returns a holding or exception if the holding not found&lt;/documentation&gt;			&lt;input message="tns:HoldingByAcquisitionNumber"/&gt;			&lt;output message="tns:HoldingByAcquisitionNumberResponse"/&gt;			&lt;fault name="holdingNotFound" message="tns:HoldingNotFoundFault"/&gt;		&lt;/operation&gt;*' match: wsdl )	description: 'checking that we created the WSGeneralServices port type and the HoldingByAcquisitionNumber operation description includes fault information'.	self assert: ( '*&lt;portType name="WSSearchServices"&gt;		&lt;operation name="SearchByTitle"&gt;			&lt;documentation&gt;The SearchByTitle operation returns a collection of holdings or empty collection if no holdings found&lt;/documentation&gt;			&lt;input message="tns:SearchByTitle"/&gt;			&lt;output message="tns:SearchByTitleResponse"/&gt;		&lt;/operation&gt;*' match: wsdl )	description: 'checking that we created the WSSearchServices port type'.	self assert: ( '*&lt;binding name="WSGeneralServices" type="tns:WSGeneralServices"&gt;		&lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/&gt;		&lt;operation name="HoldingByAcquisitionNumber"&gt;			&lt;soap:operation soapAction="urn:LibraryDemo/11/doc/testing#HoldingByAcquisitionNumber" style="document"/&gt;			&lt;input&gt;				&lt;soap:body use="literal"/&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;soap:body use="literal"/&gt;			&lt;/output&gt;			&lt;fault name="holdingNotFound"&gt;				&lt;soap:fault name="holdingNotFound" use="literal"/&gt;			&lt;/fault&gt;		&lt;/operation&gt;*' match: wsdl )	description: 'checking that we created the WSGeneralServices binding and the HoldingByAcquisitionNumber operation binding description includes fault information'.	self assert: ( '*&lt;binding name="WSSearchServices" type="tns:WSSearchServices"&gt;		&lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/&gt;		&lt;operation name="SearchByTitle"&gt;			&lt;soap:operation soapAction="urn:LibraryDemo/11/doc/testing#SearchByTitle" style="document"/&gt;			&lt;input&gt;				&lt;soap:body use="literal"/&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;soap:body use="literal"/&gt;			&lt;/output&gt;		&lt;/operation&gt;*' match: wsdl )	description: 'checking that we created the WSSearchServices binding'.	stream := String new writeStream.	"Print X2O specification on a stream.   "	descriptor printX2OSpecificationOn:  stream.	x2o := stream contents.	self assert: ( '*&lt;xmlToSmalltalkBinding targetNamespace="urn:LibraryDemo/11/doc/testing_WSDLOperations" defaultClassNamespace="Smalltalk" xmlns="urn:visualworks:VWSchemaBinding" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:ns="urn:LibraryDemo\DomainTypes" xmlns:tns="urn:LibraryDemo/11/doc/testing_WSDLOperations"&gt;	&lt;bindingImport namespace="urn:LibraryDemo\DomainTypes"/&gt;*' match: x2o )	description: 'checking that the X2O operation binding description imports X2O at LibraryDemo\DomainTypes'.	self assert: ( '*&lt;element name="HoldingByAcquisitionNumber"&gt;		&lt;struct name="HoldingByAcquisitionNumber"&gt;			&lt;sequence&gt;				&lt;element name="holdingByAcquisitionNumber" ref="xsd:positiveInteger"/&gt;			&lt;/sequence&gt;		&lt;/struct&gt;	&lt;/element&gt;	&lt;element name="HoldingByAcquisitionNumberResponse"&gt;		&lt;struct name="HoldingByAcquisitionNumberResponse"&gt;			&lt;sequence&gt;				&lt;element name="result" ref="ns:Protocols.Library.Book"/&gt;			&lt;/sequence&gt;		&lt;/struct&gt;	&lt;/element&gt;*' match: x2o )	description: 'checking that the X2O operation binding description includes HoldingByAcquisitionNumber request and response parameters'.	self assert: ( '*&lt;element name="SearchByTitle"&gt;		&lt;struct name="SearchByTitle"&gt;			&lt;sequence&gt;				&lt;element name="searchByExactTitle" ref="xsd:string"/&gt;				&lt;element name="includeAffiliatedLibraries" ref="xsd:boolean"/&gt;			&lt;/sequence&gt;		&lt;/struct&gt;	&lt;/element&gt;	&lt;sequence_of name="CollectionOfBook" smalltalkClass="OrderedCollection"&gt;		&lt;element name="Book" maxOccurs="unbounded" minOccurs="0" ref="ns:Protocols.Library.Book"/&gt;	&lt;/sequence_of&gt;	&lt;element name="SearchByTitleResponse"&gt;		&lt;struct name="SearchByTitleResponse"&gt;			&lt;sequence&gt;				&lt;element name="result" ref="tns:CollectionOfBook"/&gt;			&lt;/sequence&gt;		&lt;/struct&gt;	&lt;/element&gt;*' match: x2o )	description: 'checking that the X2O operation binding description includes SearchByTitle request and response parameters'.	^descriptor</body><body package="WebServicesDemo">testCreateWsdl20Schema	"This method creates the WSDL 2.0 specification. 	Default options: Style: iri. Binding: Soap. Transport: Http. Method: POST"	| descriptor stream service wsdl x2o generalServicesBinding searchServicesBinding generalServicesInterface searchServicesInterface |	"Provide parameters to create the WSDL 2.0 schema."	descriptor := Wsdl20ConfigurationDescriptor new.	descriptor 		targetNamespace: 'urn:LibraryDemo/20/testing';		defaultClassNamespace: 'Smalltalk'.	"Add domain types description as XMLObjectBinding object "	descriptor readImportedX2OBindingFrom: self x2OSpec readStream.	"Create &lt;interface&gt; descriptor for WSGeneralServices service class"	generalServicesInterface := self describeGeneralServicesInterface: descriptor.	"Add interface fault description. The fault types should be described in X2O spec "	descriptor addFaultNamed: 'holdingNotFound' type: Protocols.Library.HoldingNotFound toInterface: generalServicesInterface.	"For interface WSGeneralServices create default descriptor for &lt;binding&gt; "	generalServicesBinding := descriptor buildDefaultBindingDescriptorFor: generalServicesInterface.	"Describe Soap fault code and subcode. If the description is not provided the fault code and subcode will be set to #any. By default the fault will be added to HoldingByAcquisitionNumber operation. The #addSoapFaultCodeNamed: parameter will be used to create  wsoap:code=''SOAP-ENV:Sender'' binding attribute. The #addSoapFaultSubcodeNamed: parameter creates  wsoap:subcodes=''tns:InvalidRequest'' attribute where tns is WSDL schema targetNamespace "	(descriptor addSoapFaultNamed: 'holdingNotFound' toBinding: generalServicesBinding)		addSoapFaultCodeNamed: 'Sender';		addSoapFaultSubcodeNamed:  'InvalidRequest'.		"Create &lt;interface&gt; descriptor for WSSearchServices service class"	searchServicesInterface := self describeSearchServicesInterface: descriptor.	"For the WSSearchServices interface create default descriptor for &lt;binding&gt; "	searchServicesBinding := descriptor buildDefaultBindingDescriptorFor: searchServicesInterface.	"Set parameters to create endpoints for each services class"	service := descriptor addServiceNamed: 'TestLibraryGeneralServices' interface: generalServicesInterface.	service addPort: (descriptor 						createEndpointNamed: 'WSGeneralServices' 						address:  'http://localhost:4444/20/testGeneralServices' 						binding: generalServicesBinding ).	service := descriptor addServiceNamed: 'TestLibrarySearchServices' interface: searchServicesInterface.	service addPort: (descriptor 						createEndpointNamed: 'WSSearchServices'  						address: 'http://localhost:4444/20/testSearchServices' 						binding: searchServicesBinding ).	"Validate the descriptor, register XMLObjectBinding for operation requests and responses and WsdlBinding"	descriptor complete.			stream := String new writeStream.	"Print the WSDL 2.0 specification on a stream.   "	descriptor printSpecOn:  stream.	wsdl := stream contents.	self 		assert: ( '*&lt;service name="TestLibraryGeneralServices" interface="tns:WSGeneralServices"&gt;		&lt;endpoint name="WSGeneralServices" binding="tns:WSGeneralServices" address="http://localhost:4444/20/testGeneralServices"/&gt;	&lt;/service&gt;	&lt;service name="TestLibrarySearchServices" interface="tns:WSSearchServices"&gt;		&lt;endpoint name="WSSearchServices" binding="tns:WSSearchServices" address="http://localhost:4444/20/testSearchServices"/&gt;	&lt;/service&gt;*' match: wsdl )		description: 'checking that the schema has endpoints for each service class '.	self assert: ( '*&lt;interface name="WSGeneralServices"&gt;		&lt;fault name="holdingNotFound" element="ns:holdingNotFound"/&gt;		&lt;operation name="HoldingByAcquisitionNumber" pattern="http://www.w3.org/ns/wsdl/in-out"&gt;			&lt;documentation&gt;The HoldingByAcquisitionNumber operation returns a holding or exception if the holding not found&lt;/documentation&gt;			&lt;input messageLabel="In" element="ns:HoldingByAcquisitionNumber"/&gt;			&lt;output messageLabel="Out" element="ns:HoldingByAcquisitionNumberResponse"/&gt;			&lt;outfault ref="tns:holdingNotFound"/&gt;		&lt;/operation&gt;*' match: wsdl )	description: 'checking that we created the WSGeneralServices interface and the HoldingByAcquisitionNumber operation description includes fault information'.	self assert: ( '*&lt;interface name="WSSearchServices"&gt;		&lt;operation name="SearchByTitle" pattern="http://www.w3.org/ns/wsdl/in-out"&gt;			&lt;documentation&gt;The SearchByTitle operation returns a collection of holdings or empty collection if no holdings found&lt;/documentation&gt;			&lt;input messageLabel="In" element="ns:SearchByTitle"/&gt;			&lt;output messageLabel="Out" element="ns:SearchByTitleResponse"/&gt;		&lt;/operation&gt;*' match: wsdl )	description: 'checking that we created the WSSearchServices interface'.	self assert: ( '*&lt;binding name="WSGeneralServices" interface="tns:WSGeneralServices" type="http://www.w3.org/ns/wsdl/soap" wsoap:version="1.2" wsoap:protocol="http://www.w3.org/2003/05/soap/bindings/HTTP/" wsoap:mepDefault="http://www.w3.org/2003/05/soap/mep/request-response/"&gt;		&lt;fault ref="tns:holdingNotFound" wsoap:code="SOAP-ENV:Sender" wsoap:subcodes="tns:InvalidRequest"/&gt;		&lt;operation wsoap:action="urn:LibraryDemo/20/testing#HoldingByAcquisitionNumber" ref="tns:HoldingByAcquisitionNumber"&gt;			&lt;outfault ref="tns:holdingNotFound"/&gt;		&lt;/operation&gt;		&lt;operation wsoap:action="urn:LibraryDemo/20/testing#ProvidesServices" ref="tns:ProvidesServices"/&gt;		&lt;operation wsoap:action="urn:LibraryDemo/20/testing#AvailableBooks" ref="tns:AvailableBooks"/&gt;	&lt;/binding&gt;*' match: wsdl )	description: 'checking that we created the WSGeneralServices binding and the HoldingByAcquisitionNumber operation binding description includes fault information'.	self assert: ( '*&lt;binding name="WSSearchServices" interface="tns:WSSearchServices" type="http://www.w3.org/ns/wsdl/soap" wsoap:version="1.2" wsoap:protocol="http://www.w3.org/2003/05/soap/bindings/HTTP/" wsoap:mepDefault="http://www.w3.org/2003/05/soap/mep/request-response/"&gt;		&lt;operation wsoap:action="urn:LibraryDemo/20/testing#SearchByTitle" ref="tns:SearchByTitle"/&gt;		&lt;operation wsoap:action="urn:LibraryDemo/20/testing#SearchByTitles" ref="tns:SearchByTitles"/&gt;		&lt;operation wsoap:action="urn:LibraryDemo/20/testing#SearchByWord" ref="tns:SearchByWord"/&gt;	&lt;/binding&gt;*' match: wsdl )	description: 'checking that we created the WSSearchServices binding'.	stream := String new writeStream.	"Print X2O specification on a stream.   "	descriptor printX2OSpecificationOn:  stream.	x2o := stream contents.	self assert: ( '*&lt;xmlToSmalltalkBinding targetNamespace="urn:LibraryDemo/20/testing_WSDLOperations" defaultClassNamespace="Smalltalk" xmlns="urn:visualworks:VWSchemaBinding" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:ns="urn:LibraryDemo\DomainTypes" xmlns:tns="urn:LibraryDemo/20/testing_WSDLOperations"&gt;	&lt;bindingImport namespace="urn:LibraryDemo\DomainTypes"/&gt;*' match: x2o )	description: 'checking that the X2O operation binding description imports X2O at LibraryDemo\DomainTypes'.	self assert: ( '*&lt;element name="HoldingByAcquisitionNumber"&gt;		&lt;struct name="HoldingByAcquisitionNumber"&gt;			&lt;sequence&gt;				&lt;element name="holdingByAcquisitionNumber" ref="xsd:positiveInteger"/&gt;			&lt;/sequence&gt;		&lt;/struct&gt;	&lt;/element&gt;	&lt;element name="HoldingByAcquisitionNumberResponse"&gt;		&lt;struct name="HoldingByAcquisitionNumberResponse"&gt;			&lt;sequence&gt;				&lt;element name="result" ref="ns:Protocols.Library.Book"/&gt;			&lt;/sequence&gt;		&lt;/struct&gt;	&lt;/element&gt;	&lt;element name="ProvidesServicesResponse"&gt;		&lt;struct name="ProvidesServicesResponse"&gt;			&lt;sequence&gt;				&lt;element name="result" ref="xsd:boolean"/&gt;			&lt;/sequence&gt;		&lt;/struct&gt;	&lt;/element&gt;*' match: x2o )	description: 'checking that the X2O operation binding description includes HoldingByAcquisitionNumber request and response parameters'.	self assert: ( '*&lt;element name="SearchByTitle"&gt;		&lt;struct name="SearchByTitle"&gt;			&lt;sequence&gt;				&lt;element name="searchByExactTitle" ref="xsd:string"/&gt;				&lt;element name="includeAffiliatedLibraries" ref="xsd:boolean"/&gt;			&lt;/sequence&gt;		&lt;/struct&gt;	&lt;/element&gt;	&lt;sequence_of name="CollectionOfBook" smalltalkClass="OrderedCollection"&gt;		&lt;element name="Book" maxOccurs="unbounded" minOccurs="0" ref="ns:Protocols.Library.Book"/&gt;	&lt;/sequence_of&gt;	&lt;element name="SearchByTitleResponse"&gt;		&lt;struct name="SearchByTitleResponse"&gt;			&lt;sequence&gt;				&lt;element name="result" ref="tns:CollectionOfBook"/&gt;			&lt;/sequence&gt;		&lt;/struct&gt;	&lt;/element&gt;*' match: x2o )	description: 'checking that the X2O operation binding description includes SearchByTitle request and response parameters'.	^descriptor</body></methods><methods><class-id>WebServices.TestCreateWSDLSchema</class-id> <category>accessing</category><body package="WebServicesDemo">x2OSpec	^'&lt;schemaBindings&gt;		&lt;xmlToSmalltalkBinding targetNamespace="urn:LibraryDemo\DomainTypes" defaultClassNamespace="WebServices" xmlns="urn:visualworks:VWSchemaBinding" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:tns="urn:LibraryDemo\DomainTypes"&gt;	&lt;object name="ChoiceOfHoldings" smalltalkClass="ChoiceOfHoldings"&gt;		&lt;choice name="choiceValue"&gt;			&lt;element name="book" ref="tns:Protocols.Library.Book"/&gt;			&lt;element name="shipPlan" ref="tns:Protocols.Library.ShipPlan"/&gt;		&lt;/choice&gt;	&lt;/object&gt;	&lt;object name="Protocols.Library.Book" smalltalkClass="Protocols.Library.Book" baseType="tns:Protocols.Library.LoanedHolding" constraint="extension"&gt;		&lt;element name="dueDate" minOccurs="0" ref="xsd:date"/&gt;		&lt;element name="acquisitionDate" ref="xsd:date"/&gt;		&lt;element name="language" ref="xsd:string" conversionId="ByteSymbol"/&gt;		&lt;element name="authors" maxOccurs="unbounded" minOccurs="0" ref="tns:Protocols.Library.AuthorialName"/&gt;		&lt;element name="acquisitionNumber" ref="xsd:positiveInteger"/&gt;		&lt;element name="publisher" ref="xsd:string"/&gt;		&lt;element name="braille" ref="xsd:boolean"/&gt;		&lt;element name="title" ref="xsd:string"/&gt;		&lt;element name="catalogNumber" ref="tns:Protocols.Library.CatalogNumber"/&gt;		&lt;element name="pages" ref="xsd:short"/&gt;		&lt;element name="libraryName" ref="xsd:string"/&gt;		&lt;element name="collectionId" ref="xsd:string" conversionId="ByteSymbol"/&gt;		&lt;element name="publicationYear" ref="xsd:short"/&gt;		&lt;element name="acquisitionCost" ref="xsd:decimal"/&gt;		&lt;element name="statusId" ref="xsd:string" conversionId="ByteSymbol"/&gt;		&lt;element name="largePrint" ref="xsd:boolean"/&gt;	&lt;/object&gt;	&lt;object name="Protocols.Library.LoanedHolding" smalltalkClass="Protocols.Library.LoanedHolding" baseType="tns:Protocols.Library.Holding" constraint="extension"/&gt;	&lt;object name="Protocols.Library.Holding" smalltalkClass="Protocols.Library.Holding" baseType="tns:Protocols.Library.AbstractRandom" constraint="extension"/&gt;	&lt;object name="Protocols.Library.AbstractRandom" smalltalkClass="Protocols.Library.AbstractRandom"/&gt;	&lt;object name="Protocols.Library.HoldingNotFound" smalltalkClass="Protocols.Library.HoldingNotFound" baseType="tns:Protocols.Library.LibraryError" constraint="extension"/&gt;	&lt;object name="Protocols.Library.LibraryError" smalltalkClass="Protocols.Library.LibraryError"/&gt;	&lt;object name="Protocols.Library.LibraryService" smalltalkClass="Protocols.Library.LibraryService" baseType="tns:Protocols.Library.AbstractRandom" constraint="extension"&gt;		&lt;element name="serviceId" ref="xsd:string" conversionId="ByteSymbol"/&gt;		&lt;element name="library" ref="tns:WSLibrary"/&gt;		&lt;element name="serviceCharge" ref="xsd:decimal"/&gt;	&lt;/object&gt;	&lt;object name="Protocols.Library.AuthorialName" smalltalkClass="Protocols.Library.AuthorialName"&gt;		&lt;element name="name" ref="tns:Protocols.Library.PersonName"/&gt;		&lt;element name="authorialType" ref="xsd:string" conversionId="ByteSymbol"/&gt;	&lt;/object&gt;	&lt;object name="Protocols.Library.ShipPlan" smalltalkClass="Protocols.Library.ShipPlan" baseType="tns:Protocols.Library.RetainedHolding" constraint="extension"&gt;		&lt;element name="yearDrawn" ref="xsd:short"/&gt;		&lt;element name="scale" ref="xsd:float"/&gt;		&lt;element name="architects" maxOccurs="unbounded" minOccurs="0" ref="tns:Protocols.Library.AuthorialName"/&gt;		&lt;element name="numberOfSheets" ref="xsd:short"/&gt;		&lt;element name="shipName" ref="xsd:string"/&gt;	&lt;/object&gt;	&lt;object name="Protocols.Library.RetainedHolding" smalltalkClass="Protocols.Library.RetainedHolding" baseType="tns:Protocols.Library.Holding" constraint="extension"/&gt;	&lt;object name="WSBook" smalltalkClass="WSBook"&gt;		&lt;element name="title" ref="xsd:string"/&gt;		&lt;element name="acquisitionNumber" ref="xsd:positiveInteger"/&gt;		&lt;element name="statusId" ref="xsd:string" conversionId="ByteSymbol"/&gt;	&lt;/object&gt;	&lt;object name="Protocols.Library.CatalogNumber" smalltalkClass="Protocols.Library.CatalogNumber" baseType="tns:Protocols.Library.AbstractRandom" constraint="extension"&gt;		&lt;element name="part4" ref="xsd:string" conversionId="Character"/&gt;		&lt;element name="part1" ref="xsd:string"/&gt;		&lt;element name="part2" ref="xsd:base64Binary"/&gt;		&lt;element name="part3" ref="xsd:double"/&gt;	&lt;/object&gt;	&lt;object name="WSLibrary" smalltalkClass="WSLibrary" baseType="tns:Protocols.Library.Library" constraint="extension"&gt;		&lt;element name="personalPatrons" maxOccurs="5" ref="tns:Protocols.Library.Person"/&gt;		&lt;choiceRelation name="webSiteAddress"&gt;			&lt;element name="text" ref="xsd:string"/&gt;			&lt;element name="url" ref="xsd:anyURI"/&gt;		&lt;/choiceRelation&gt;		&lt;element name="ownedHoldingsColl" maxOccurs="unbounded" minOccurs="0" ref="tns:Protocols.Library.Book"/&gt;	&lt;/object&gt;	&lt;object name="Protocols.Library.Library" smalltalkClass="Protocols.Library.Library" baseType="tns:Protocols.Library.Agent" constraint="extension"&gt;		&lt;element name="affiliatedLibraries" maxOccurs="unbounded" minOccurs="0" ref="tns:WSLibrary"/&gt;		&lt;element name="reservedHoldings" maxOccurs="unbounded" minOccurs="0" ref="tns:Protocols.Library.Book"/&gt;		&lt;element name="libraryId" ref="xsd:string" conversionId="ByteSymbol"/&gt;		&lt;element name="loanedHoldings" maxOccurs="unbounded" minOccurs="0" ref="tns:Protocols.Library.Book"/&gt;		&lt;element name="libraryName" ref="xsd:string"/&gt;		&lt;element name="ownedHoldings" maxOccurs="unbounded" minOccurs="0" ref="tns:Protocols.Library.Book"/&gt;	&lt;/object&gt;	&lt;object name="Protocols.Library.Agent" smalltalkClass="Protocols.Library.Agent" baseType="tns:Protocols.Library.AbstractRandom" constraint="extension"&gt;		&lt;element name="serviceApprovals" maxOccurs="unbounded" minOccurs="0" ref="xsd:string" conversionId="ByteSymbol"/&gt;		&lt;element name="account" ref="tns:Protocols.Library.Account"/&gt;		&lt;element name="telephoneNumbers" maxOccurs="unbounded" minOccurs="0" ref="tns:Protocols.Library.TelephoneNumber"/&gt;		&lt;element name="emailAddresses" maxOccurs="unbounded" minOccurs="0" ref="tns:Protocols.Library.EmailAddress"/&gt;		&lt;element name="physicalAddress" ref="tns:WSPhysicalAddress"/&gt;		&lt;element name="borrowedHoldings" maxOccurs="unbounded" minOccurs="0" ref="tns:Protocols.Library.Book"/&gt;	&lt;/object&gt;	&lt;object name="Protocols.Library.PersonName" smalltalkClass="Protocols.Library.PersonName" baseType="tns:Protocols.Library.AbstractRandom" constraint="extension"&gt;		&lt;element name="middleNames" ref="xsd:string"/&gt;		&lt;element name="title" ref="xsd:string"/&gt;		&lt;element name="firstName" ref="xsd:string"/&gt;		&lt;element name="lastName" ref="xsd:string"/&gt;	&lt;/object&gt;	&lt;object name="Protocols.Library.Account" smalltalkClass="Protocols.Library.Account"&gt;		&lt;element name="balance" ref="xsd:decimal"/&gt;	&lt;/object&gt;	&lt;object name="Protocols.Library.Person" smalltalkClass="Protocols.Library.Person" baseType="tns:Protocols.Library.Patron" constraint="extension"&gt;		&lt;element name="ssn" ref="xsd:positiveInteger"/&gt;		&lt;element name="birthDate" ref="xsd:date"/&gt;		&lt;element name="sex" ref="xsd:string" conversionId="Character"/&gt;	&lt;/object&gt;	&lt;object name="Protocols.Library.Patron" smalltalkClass="Protocols.Library.Patron" baseType="tns:Protocols.Library.Agent" constraint="extension"&gt;		&lt;element name="patronId" ref="xsd:string" conversionId="ByteSymbol"/&gt;		&lt;element name="patronName" ref="tns:Protocols.Library.PersonName"/&gt;	&lt;/object&gt;	&lt;object name="Protocols.Library.EmailAddress" smalltalkClass="Protocols.Library.EmailAddress"&gt;		&lt;element name="address" ref="xsd:string"/&gt;		&lt;element name="description" ref="xsd:string"/&gt;	&lt;/object&gt;	&lt;object name="Protocols.Library.TelephoneNumber" smalltalkClass="Protocols.Library.TelephoneNumber" baseType="tns:Protocols.Library.AbstractRandom" constraint="extension"&gt;		&lt;element name="description" ref="xsd:string"/&gt;		&lt;element name="type" ref="xsd:string" conversionId="ByteSymbol"/&gt;		&lt;element name="number" ref="xsd:string"/&gt;	&lt;/object&gt;	&lt;object name="WSPhysicalAddress" smalltalkClass="WSPhysicalAddress" baseType="tns:Protocols.Library.PhysicalAddress" constraint="extension"/&gt;	&lt;object name="Protocols.Library.PhysicalAddress" smalltalkClass="Protocols.Library.PhysicalAddress" baseType="tns:Protocols.Library.AbstractRandom" constraint="extension"&gt;		&lt;element name="streetAddress1" ref="xsd:string"/&gt;		&lt;element name="city" ref="xsd:string"/&gt;		&lt;element name="streetAddress2" ref="xsd:string"/&gt;		&lt;element name="country" ref="xsd:string" conversionId="ByteSymbol"/&gt;		&lt;element name="postalCode" ref="xsd:string"/&gt;		&lt;element name="stateOrProvince" ref="xsd:string" conversionId="ByteSymbol"/&gt;	&lt;/object&gt;		&lt;/xmlToSmalltalkBinding&gt;	&lt;/schemaBindings&gt;'</body></methods><methods><class-id>WebServices.TestCreateWSDLSchema</class-id> <category>testing backward compatibility</category><body package="WebServicesDemo">testCreateDocStyleFromServiceClass	"Backward compatibility.This method creates the the WSDL Document/literal style specification from service class methods that have a pragma operation description."	| builder stream serviceClass |	serviceClass := WSGeneralServices.	"The WsdlBuilder builds the document style schema "	builder := WsdlBuilder 				buildFromService: serviceClass				classNamespace: 'WebServices'				targetNamespace: 'urn:LibraryDemo/srvcGeneral/srvcdoc'.	stream := String new writeStream.	"Print the WSDL schema on the stream "	builder printSpecOn: stream.	self 		assert: ( '*&lt;binding name="WSGeneralServices" type="tns:WSGeneralServices"&gt;		&lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="document"/&gt;*' match: stream contents)		description: 'checking that the schema has SOAP binding and the document style'.	self assert: ( '*&lt;operation name="LibraryServicesIds"&gt;			&lt;soap:operation soapAction="urn:LibraryDemo/srvcGeneral/srvcdoc#LibraryServicesIds" style="document"/&gt;			&lt;input&gt;				&lt;soap:body use="literal"/&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;soap:body use="literal"/&gt;			&lt;/output&gt;		&lt;/operation&gt;*' match: stream contents )		description: 'checking the operation description in the &lt;binding&gt;'.	"..add endpoint for the service"	builder 		wsdlServiceName:  'TestLibraryServices';		setPortAddress: 'http://localhost:4444/testGeneralServices'.			stream reset.	"Print the WSDL schema with XML to Object binding specification on the stream "	builder printSpecOn: stream.	self 		assert: ( '*&lt;service name="TestLibraryServices"&gt;		&lt;port name="WSGeneralServices" binding="tns:WSGeneralServices"&gt;			&lt;soap:address location="http://localhost:4444/testGeneralServices"/&gt;		&lt;/port&gt;	&lt;/service&gt;*' match: stream contents )		description: 'checking the service port description'.	stream reset.	"Print the WSDL schema with XML to Object binding specification on the stream "	builder printX2OSpecificationOn: stream.	self 		assert: ( '*&lt;object name="WSLibrary" smalltalkClass="WSLibrary" baseType="tns:Protocols.Library.Library" constraint="extension"&gt;*' match: stream contents)		description: 'checking the XML to Object binding description for the WSLibrary type'.</body><body package="WebServicesDemo">testCreateRPCStyleFromServiceClass	"Backward compatibility.This method creates the the WSDL Document/literal style specification  from service class methods that have pragma operation description."	| builder stream serviceClass |	serviceClass := WSGeneralServices.	"The WsdlBuilder builds the rpc style schema "	builder := WsdlBuilder new				useRPC;							buildFromService: serviceClass				classNamespace: 'WebServices'				targetNamespace: 'urn:LibraryDemo/srvcGeneral/rpc/srvcdoc'.	stream := String new writeStream.	builder printSpecOn: stream.	self 		assert: (	'*&lt;complexType name="CollectionOfByteSymbol"&gt;				&lt;sequence&gt;					&lt;element name="ByteSymbol" maxOccurs="unbounded" minOccurs="0" type="xsd:string"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;*' match: stream contents)		description: 'checking that the schema has correct return type for a collection'.	self 		assert: ('*&lt;binding name="WSGeneralServices" type="tns:WSGeneralServices"&gt;		&lt;soap:binding transport="http://schemas.xmlsoap.org/soap/http" style="rpc"/&gt;*' match: stream contents)		description: 'checking that the schema has SOAP binding and the rpc style'.	self 		assert: ( '*&lt;operation name="LibraryServicesIds"&gt;			&lt;soap:operation soapAction="urn:LibraryDemo/srvcGeneral/rpc/srvcdoc#LibraryServicesIds" style="rpc"/&gt;			&lt;input&gt;				&lt;soap:body use="literal" namespace="urn:LibraryDemo/srvcGeneral/rpc/srvcdoc"/&gt;			&lt;/input&gt;			&lt;output&gt;				&lt;soap:body use="literal" namespace="urn:LibraryDemo/srvcGeneral/rpc/srvcdoc"/&gt;			&lt;/output&gt;		&lt;/operation&gt;*' match: stream contents )		description: 'checking the operation description'.	"..add access point for the service"	builder wsdlServiceName: 'TestLibraryServices'.	builder setPortAddress:  'http://localhost:4444/testGeneralServices'.	stream reset.	"Print the WSDL schema "	builder printSpecOn: stream.	self 		assert: ( '*&lt;service name="TestLibraryServices"&gt;		&lt;port name="WSGeneralServices" binding="tns:WSGeneralServices"&gt;			&lt;soap:address location="http://localhost:4444/testGeneralServices"/&gt;		&lt;/port&gt;	&lt;/service&gt;*' match: stream contents )		description: 'checking the service port description'.	stream reset.	"Print the XML to Object Binding specification "	builder printX2OSpecificationOn: stream.	self 		assert: ( '*&lt;object name="WSLibrary" smalltalkClass="WSLibrary" baseType="tns:Protocols.Library.Library" constraint="extension"&gt;*' match: stream contents)		description: 'checking the XML to Object Binding description for a complex type'.	self 		assert: ('*&lt;element name="ownedHoldingsColl" maxOccurs="unbounded" minOccurs="0" ref="tns:Protocols.Library.Book"/&gt;*' match: stream contents)		description: 'checking the XML to Object Binding description for an element'.</body><body package="WebServicesDemo">testCreateWsdl20ServiceClass	"This method creates the the WSDL 2.0 specification  from service class methods that have pragma operation description."	| builder stream serviceClass |	serviceClass := WSGeneralServices.	"The WsdlBuilder builds the WSDL 2.0 schema "	builder := WsdlBuilder build20.   	builder 		buildFromService: serviceClass		classNamespace: 'WebServices'		targetNamespace: 'urn:LibraryDemo/srvcGeneral/rpc/srvcdoc'.	stream := String new writeStream.	builder printSpecOn: stream.	self 		assert: (	'*&lt;complexType name="CollectionOfByteSymbol"&gt;				&lt;sequence&gt;					&lt;element name="ByteSymbol" maxOccurs="unbounded" minOccurs="0" type="xsd:string"/&gt;				&lt;/sequence&gt;			&lt;/complexType&gt;*' match: stream contents)		description: 'checking that the schema has correct return type for a collection'.	self 		assert: ('*&lt;binding name="WSGeneralServices" interface="tns:WSGeneralServices" type="http://www.w3.org/ns/wsdl/soap" wsoap:version="1.2" wsoap:protocol="http://www.w3.org/2003/05/soap/bindings/HTTP/" wsoap:mepDefault="http://www.w3.org/2003/05/soap/mep/request-response/"&gt;*' match: stream contents)		description: 'checking that the schema has SOAP1.2 binding'.	self 		assert: ( '*&lt;operation wsoap:action="urn:LibraryDemo/srvcGeneral/rpc/srvcdoc#HoldingByAcquisitionNumber" ref="tns:HoldingByAcquisitionNumber"&gt;			&lt;outfault ref="tns:holdingNotFound"/&gt;		&lt;/operation&gt;*' match: stream contents )		description: 'checking the operation description'.	"..add access point for the service"	builder 		setPortAddress:  'http://localhost:3331/testGeneralServices'		for: serviceClass.	stream reset.	"Print the WSDL schema "	builder printSpecOn: stream.	self 		assert: ( '*&lt;service name="WSGeneralServices" interface="tns:WSGeneralServices"&gt;		&lt;endpoint name="WSGeneralServices" binding="tns:WSGeneralServices" address="http://localhost:3331/testGeneralServices"/&gt;	&lt;/service&gt;*' match: stream contents )		description: 'checking the service port description'.	stream reset.	"Print the XML to Object Binding specification "	builder printX2OSpecificationOn: stream.	self 		assert: ( '*&lt;object name="WSLibrary" smalltalkClass="WSLibrary" baseType="tns:Protocols.Library.Library" constraint="extension"&gt;*' match: stream contents)		description: 'checking the XML to Object Binding description for a complex type'.	self 		assert: ('*&lt;element name="ownedHoldingsColl" maxOccurs="unbounded" minOccurs="0" ref="tns:Protocols.Library.Book"/&gt;*' match: stream contents)		description: 'checking the XML to Object Binding description for an element'.</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class></st-source>