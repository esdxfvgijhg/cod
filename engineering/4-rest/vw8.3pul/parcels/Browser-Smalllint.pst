<?xml version="1.0"?><st-source><!-- Name: Browser-SmalllintNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Portions © 1998-2002 The Refactory, IncComment: This package contains the non-UI components of Smalllint (the CodeCritic).DbIdentifier: bear73DbTrace: 493945DbUsername: kgreekDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'Browser-Environments' '') #(#any 'Browser-Parser' ''))PackageName: Browser-SmalllintParcel: #('Browser-Smalllint')ParcelName: Browser-SmalllintPrerequisiteParcels: #(#('Browser-ChangeObjects' '') #('Browser-Environments' ''))PrintStringCache: (8.3 - 1,kgreek)Version: 8.3 - 1Date: 3:26:57 PM June 30, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (jun17.4) of June 23, 2017 on June 30, 2017 at 3:26:57 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>LintRule</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Lint</category><attributes><package>Browser-Smalllint</package></attributes></class><comment><class-id>Refactory.Browser.LintRule</class-id><body>LintRule is an abstract class that represents some check on the code.Subclasses must implement the following messages:	accessing		problemCount			"returns the number of problems this rule found"	private		viewResults			"opens an interface to view the problems"	testing		isEmpty			"did this rule find any problems"Instance Variables:	name	&lt;String&gt;	the display name of the rule</body></comment><class><name>BasicLintRule</name><environment>Refactory.Browser</environment><super>Refactory.Browser.LintRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>result openSymbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Lint</category><attributes><package>Browser-Smalllint</package></attributes></class><comment><class-id>Refactory.Browser.BasicLintRule</class-id><body>BasicLintRule represents a check on the code.Instance Variables:	openSymbol	&lt;ByteSymbol&gt;	what is performed when we are opening the results	result	&lt;ParseTreeEnvironment&gt;	some object that represents the results found (it must understand openEditor, isEmpty, problemCount, and copyEmpty). Most of the time, this is a ParseTreeEnvironment object.Shared Variables:	FilterDictionary	&lt;Dictionary&gt;	a dictionary that maps the name of lint rule to the filter environment</body></comment><class><name>TransformationRule</name><environment>Refactory.Browser</environment><super>Refactory.Browser.LintRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>changes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Lint</category><attributes><package>Browser-Smalllint</package></attributes></class><comment><class-id>Refactory.Browser.TransformationRule</class-id><body>TransformationRule is a LintRule that transforms code. While it doesn't have any subclassResponsibility methods, it is really abstract.Instance Variables:	changes	&lt;CompositeRefactoryChange&gt;	the changes we've made</body></comment><class><name>SmalllintFilterEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AndEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lintRuleName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Lint</category><attributes><package>Browser-Smalllint</package></attributes></class><comment><class-id>Refactory.Browser.SmalllintFilterEnvironment</class-id><body>SmalllintFilterEnvironment is a special environment that is used to filter out invalid Smalllint results.Instance Variables:	lintRuleName	&lt;String&gt;	the name of the lint rule that we are looking at</body></comment><class><name>MultiEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environmentDictionaries </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Smalllint</package></attributes></class><comment><class-id>Refactory.Browser.MultiEnvironment</class-id><body>MultiEnvironment is a special environment for the "Method defined in all subclasses, but not in superclass" lint rule. It's basically a hack to get a browser to display the results.Instance Variables:	environmentDictionaries	&lt;Dictionary key: String value: BrowserEnvironment&gt;	the individual results from each failure. Each value stores the methods that are defined in the subclasses</body></comment><class><name>SmalllintChecker</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rule environment context methodBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Lint</category><attributes><package>Browser-Smalllint</package></attributes></class><comment><class-id>Refactory.Browser.SmalllintChecker</class-id><body>SmalllintChecker represents the process that checks the lint rule over the selected code items (environment). It contains no GUI items and can be run in a headless mode.Instance Variables:	context	&lt;SmalllintContext&gt;	contains our cache as well as the item that we are currently checking	environment	&lt;BrowserEnvironment&gt;	the items that we are to run the checker over	methodBlock	&lt;BlockClosure&gt;	a block that is executed after each method is checked. This is used for updating the % done bar.	rule	&lt;LintRule&gt;	the lint rule that we are checking</body></comment><class><name>ParseTreeLintRule</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BasicLintRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>matcher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Lint</category><attributes><package>Browser-Smalllint</package></attributes></class><comment><class-id>Refactory.Browser.ParseTreeLintRule</class-id><body>ParseTreeLintRule is a lint rule that matches parse trees. When a match is found that creates a problem result.Instance Variables:	matcher	&lt;ParseTreeSearcher&gt;	used to find parse tree nodes that are causing the problem</body></comment><class><name>SmalllintContext</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class selector parseTree literals literalSemaphore literalProcess selectors compiledMethod selfMessages superMessages messages nameSpace </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Lint</category><attributes><package>Browser-Smalllint</package></attributes></class><comment><class-id>Refactory.Browser.SmalllintContext</class-id><body>SmalllintContext represents the current state of the SmalllintChecker. It contains the current item that is being checked (a compiled method or class). It also caches some items so that the checker process can run faster.Instance Variables:	class	&lt;ClassDescription&gt;	the class that is currently being checked	compiledMethod	&lt;CompiledMethod&gt;	the method that is being checked	literalProcess	&lt;Process&gt;	the process that is filling our caches	literals	&lt;Collection&gt;	all literals referenced in all methods	literalSemaphore	&lt;Semaphore&gt;	used to limit access to the literals collection until the literalProcess is finished	messages	&lt;Collection&gt;	all sent messages in the current method	namespace	&lt;NameSpace&gt;	the namespace that contains the class	parseTree	&lt;RBProgramNode&gt;	the parse tree for the method	selector	&lt;Symbol&gt;	the method name	selectors	&lt;Collection&gt;	all implemented selectors in the system	selfMessages	&lt;Collection&gt;	all self messages in the current method	superMessages	&lt;Collection&gt;	all super messages in the current method</body></comment><class><name>ParseTreeTransformationRule</name><environment>Refactory.Browser</environment><super>Refactory.Browser.TransformationRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class rewriteRule </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Lint</category><attributes><package>Browser-Smalllint</package></attributes></class><comment><class-id>Refactory.Browser.ParseTreeTransformationRule</class-id><body>ParseTreeTransformationRule is a LintRule that transforms code using parse tree rewrite rules.Instance Variables:	class	&lt;Behavior&gt;	the class we're looking at currently (only needed so we don't have to pass the class around)	rewriteRule	&lt;ParseTreeRewriter&gt;	the rule we're replacing the code withShared Variables:	RecursiveSelfRule	&lt;ParseTreeSearcher&gt;	a rule that checks our rewrites so we don't make directly recursive methods (e.g., "foo ^self foo")</body></comment><class><name>SubclassResponsibilityEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.SelectorEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Smalllint</package></attributes></class><comment><class-id>Refactory.Browser.SubclassResponsibilityEnvironment</class-id><body>SubclassResponsibilityEnvironment is a special selector environment that displays subclassResponsibility methods that haven't been written.</body></comment><class><name>CompositeLintRule</name><environment>Refactory.Browser</environment><super>Refactory.Browser.LintRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rules </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Lint</category><attributes><package>Browser-Smalllint</package></attributes></class><comment><class-id>Refactory.Browser.CompositeLintRule</class-id><body>CompositeLintRule groups LintRules into a single rule (composite pattern).Instance Variables:	rules	&lt;Collection of: LintRule&gt;	the rules that make up the composite</body></comment><class><name>ParseTreeEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.SelectorEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars>matcher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Lint</category><attributes><package>Browser-Smalllint</package></attributes></class><comment><class-id>Refactory.Browser.ParseTreeEnvironment</class-id><body>ParseTreeEnvironment is a special browser environment that causes the code tools to highlight the parse node causing the lint rule to fail.Instance Variables:	matcher	&lt;ParseTreeSearcher&gt;	used to return the parse node that is causing the failure</body></comment><class><name>BlockLintRule</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BasicLintRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classBlock methodBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Lint</category><attributes><package>Browser-Smalllint</package></attributes></class><comment><class-id>Refactory.Browser.BlockLintRule</class-id><body>BlockLintRule is a lint rule that runs arbitrary checks. These checks are represented by blocks. This allows one to represent virtually any type of check.UsageThe class method categories each have sets of different rules. Some of the rules originaly written as part of Smalllint have been found to be questionable or out of date. These are not removed, but placed in the deprecated category. If you want one of them nevertheless for your system, simply move it into the appropriate method category and it will show up in the tool.Instance Variables	classBlock	&lt;BlockClosure&gt;	a block that is run when we check a class	methodBlock	&lt;BlockClosure&gt;	a block that is run when we check a method</body></comment><shared-variable><name>FilterDictionary</name><environment>Refactory.Browser.BasicLintRule</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Browser-Smalllint</package></attributes></shared-variable><shared-variable><name>RecursiveSelfRule</name><environment>Refactory.Browser.ParseTreeTransformationRule</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Browser-Smalllint</package></attributes></shared-variable><methods><class-id>Refactory.Browser.LintRule</class-id> <category>accessing</category><body package="Browser-Smalllint">allRules	| allRules |	allRules := OrderedCollection withAll: self rules.	self rules do: [:each | allRules addAll: each allRules].	^allRules</body><body package="Browser-Smalllint">checkClass: aSmalllintContext</body><body package="Browser-Smalllint">checkMethod: aSmalllintContext</body><body package="Browser-Smalllint">name	^name</body><body package="Browser-Smalllint">name: aString 	name := aString</body><body package="Browser-Smalllint">problemCount	^self subclassResponsibility</body><body package="Browser-Smalllint">rules	^#()</body></methods><methods><class-id>Refactory.Browser.LintRule</class-id> <category>testing</category><body package="Browser-Smalllint">hasConflicts	^false</body><body package="Browser-Smalllint">isComposite	^false</body><body package="Browser-Smalllint">isEmpty	self subclassResponsibility</body><body package="Browser-Smalllint">notEmpty	^self isEmpty not</body></methods><methods><class-id>Refactory.Browser.LintRule</class-id> <category>initialize-release</category><body package="Browser-Smalllint">initialize</body><body package="Browser-Smalllint">resetResult</body></methods><methods><class-id>Refactory.Browser.LintRule</class-id> <category>printing</category><body package="Browser-Smalllint">displayName	| nameStream |	nameStream := WriteStream on: (String new: 64).	nameStream		nextPutAll: self name asString;		nextPutAll: ' ['.	self problemCount printOn: nameStream.	nameStream nextPut: $].	^nameStream contents</body><body package="Browser-Smalllint">printOn: aStream 	name isNil		ifTrue: [super printOn: aStream]		ifFalse: [aStream nextPutAll: name asString]</body></methods><methods><class-id>Refactory.Browser.LintRule</class-id> <category>private</category><body package="Browser-Smalllint">failedRules	^self isEmpty ifTrue: [#()] ifFalse: [Array with: self]</body></methods><methods><class-id>Refactory.Browser.LintRule class</class-id> <category>instance creation</category><body package="Browser-Smalllint">new	^super new initialize</body></methods><methods><class-id>Refactory.Browser.BasicLintRule</class-id> <category>private</category><body package="Browser-Smalllint">defaultResultClass	^SelectorEnvironment</body></methods><methods><class-id>Refactory.Browser.BasicLintRule</class-id> <category>accessing</category><body package="Browser-Smalllint">filteredResult	^(SmalllintFilterEnvironment onEnvironment: result		and: (self class filterDictionary at: self name ifAbsent: [result copyEmpty]) 				copy not)		label: result label;		lintRuleName: self name;		yourself</body><body package="Browser-Smalllint">problemCount	^self result problemCount</body><body package="Browser-Smalllint">result	^(self class filterDictionary includesKey: self name) 		ifTrue: [self filteredResult]		ifFalse: [result]</body></methods><methods><class-id>Refactory.Browser.BasicLintRule</class-id> <category>initialize-release</category><body package="Browser-Smalllint">initialize	super initialize.	openSymbol := #openWithFilters.	self resultClass: self defaultResultClass</body><body package="Browser-Smalllint">openUsing: aSymbol 	openSymbol := aSymbol</body><body package="Browser-Smalllint">resetResult	result := result copyEmpty.	result label: name</body><body package="Browser-Smalllint">result: aResult 	result := aResult copyEmpty</body><body package="Browser-Smalllint">resultClass: aClass 	result := aClass new</body></methods><methods><class-id>Refactory.Browser.BasicLintRule</class-id> <category>testing</category><body package="Browser-Smalllint">isEmpty	^self result isEmpty</body></methods><methods><class-id>Refactory.Browser.BasicLintRule</class-id> <category>copying</category><body package="Browser-Smalllint">postCopy	super postCopy.	self resetResult</body></methods><methods><class-id>Refactory.Browser.BasicLintRule class</class-id> <category>accessing</category><body package="Browser-Smalllint">addFilter: anEnvironment for: aString 	self filterDictionary at: aString put: anEnvironment copy</body><body package="Browser-Smalllint">filterDictionary	^FilterDictionary isNil 		ifTrue: [FilterDictionary := Dictionary new]		ifFalse: [FilterDictionary]</body><body package="Browser-Smalllint">filterDictionary: aDictionary 	FilterDictionary := aDictionary</body><body package="Browser-Smalllint">filterFor: aName 	^self filterDictionary at: aName ifAbsentPut: [SelectorEnvironment new]</body><body package="Browser-Smalllint">protocols	^ OrderedCollection		with: ( #Bugs &lt;&lt; #browser &gt;&gt; 'Bugs' ) -&gt; 'bugs'		with: ( #PossibleBugs &lt;&lt; #browser &gt;&gt; 'Possible bugs' ) -&gt; 'possible bugs'		with:			( #UnnecessaryCode &lt;&lt; #browser &gt;&gt; 'Unnecessary code' ) -&gt;					'unnecessary code'		with:			( #IntentionRevealing &lt;&lt; #browser &gt;&gt; 'Intention revealing' ) -&gt;					'intention revealing'.</body></methods><methods><class-id>Refactory.Browser.BasicLintRule class</class-id> <category>storing</category><body package="Browser-Smalllint">storeFiltersOn: aStream 	aStream		nextPut: $(;		nextPutAll: self fullName;		nextPutAll: ' filterDictionary: (';		nextPutAll: Dictionary fullName;		nextPutAll: ' new'.	self filterDictionary keysAndValuesDo: 			[:key :value | 			aStream nextPutAll: ' at: '.			key storeOn: aStream.			aStream nextPutAll: ' put: '.			value storeOn: aStream.			aStream				nextPutAll: ';';				cr].	aStream		tab;		nextPutAll: 'yourself))'</body></methods><methods><class-id>Refactory.Browser.TransformationRule</class-id> <category>accessing</category><body package="Browser-Smalllint">problemCount	^changes problemCount</body><body package="Browser-Smalllint">resetResult	changes := CompositeRefactoryChange named: (#Transformations &lt;&lt; #browser &gt;&gt; 'Transformations') asString</body></methods><methods><class-id>Refactory.Browser.TransformationRule</class-id> <category>testing</category><body package="Browser-Smalllint">hasConflicts	^true</body><body package="Browser-Smalllint">isEmpty	^changes changes isEmpty</body></methods><methods><class-id>Refactory.Browser.TransformationRule</class-id> <category>private</category><body package="Browser-Smalllint">viewResults	"I reset the result so that we don't fill up memory with methods to compile in the builder."	changes inspect.	self resetResult</body></methods><methods><class-id>Refactory.Browser.SmalllintFilterEnvironment</class-id> <category>actions</category><body package="Browser-Smalllint">addFilterForClass: aBehavior 	(BasicLintRule filterFor: lintRuleName) addClass: aBehavior.	andedEnvironment environment addClass: aBehavior</body><body package="Browser-Smalllint">addFilterForClass: aBehavior andSelector: aSymbol 	(BasicLintRule filterFor: lintRuleName) addClass: aBehavior		selector: aSymbol.	andedEnvironment environment addClass: aBehavior selector: aSymbol</body></methods><methods><class-id>Refactory.Browser.SmalllintFilterEnvironment</class-id> <category>testing</category><body package="Browser-Smalllint">canFilterSelectors	^environment isClassEnvironment not</body><body package="Browser-Smalllint">isForSmalllint	^true</body></methods><methods><class-id>Refactory.Browser.SmalllintFilterEnvironment</class-id> <category>initialize-release</category><body package="Browser-Smalllint">lintRuleName: aString 	lintRuleName := aString</body></methods><methods><class-id>Refactory.Browser.SmalllintFilterEnvironment</class-id> <category>comparing</category><body package="Browser-Smalllint">instVarsNotToCompare		^#(#lintRuleName)</body></methods><methods><class-id>Refactory.Browser.MultiEnvironment</class-id> <category>adding</category><body package="Browser-Smalllint">addClass: aClass into: aValue 	(environmentDictionaries at: aValue ifAbsentPut: [SelectorEnvironment new]) 		addClass: aClass</body><body package="Browser-Smalllint">addClass: aClass selector: aSymbol into: aValue 	(environmentDictionaries at: aValue ifAbsentPut: [SelectorEnvironment new]) 		addClass: aClass		selector: aSymbol</body></methods><methods><class-id>Refactory.Browser.MultiEnvironment</class-id> <category>accessing</category><body package="Browser-Smalllint">environmentNamed: aString 	^environmentDictionaries at: aString ifAbsent: [SelectorEnvironment new]</body><body package="Browser-Smalllint">environments	^environmentDictionaries keys</body><body package="Browser-Smalllint">problemCount	^environmentDictionaries size</body><body package="Browser-Smalllint">selectEnvironment: aValue 	environment := environmentDictionaries at: aValue				ifAbsent: [SelectorEnvironment new]</body></methods><methods><class-id>Refactory.Browser.MultiEnvironment</class-id> <category>initialize-release</category><body package="Browser-Smalllint">initialize	super initialize.	environmentDictionaries := Dictionary new.	environment := SelectorEnvironment new</body></methods><methods><class-id>Refactory.Browser.MultiEnvironment</class-id> <category>testing</category><body package="Browser-Smalllint">isEmpty	^environmentDictionaries isEmpty</body></methods><methods><class-id>Refactory.Browser.MultiEnvironment</class-id> <category>removing</category><body package="Browser-Smalllint">removeClass: aClass into: aValue 	(environmentDictionaries at: aValue ifAbsent: [SelectorEnvironment new]) 		removeClass: aClass</body><body package="Browser-Smalllint">removeClass: aClass selector: aSelector into: aValue 	(environmentDictionaries at: aValue ifAbsentPut: [SelectorEnvironment new]) 		removeClass: aClass		selector: aSelector</body></methods><methods><class-id>Refactory.Browser.SmalllintChecker</class-id> <category>private</category><body package="Browser-Smalllint">checkClass: aClass 	context selectedClass: aClass.	(environment definesClass: aClass) ifTrue: [rule checkClass: context]</body><body package="Browser-Smalllint">checkMethodsForClass: aClass 	^environment selectorsForClass: aClass		do: 			[:each | 			context selector: each.			rule checkMethod: context.			methodBlock value]</body></methods><methods><class-id>Refactory.Browser.SmalllintChecker</class-id> <category>accessing</category><body package="Browser-Smalllint">context: aSmalllintContext 	context := aSmalllintContext</body><body package="Browser-Smalllint">environment: aBrowserEnvironment 	environment := aBrowserEnvironment</body><body package="Browser-Smalllint">methodBlock: aBlock 	methodBlock := aBlock</body><body package="Browser-Smalllint">rule: aLintRule 	rule := aLintRule</body></methods><methods><class-id>Refactory.Browser.SmalllintChecker</class-id> <category>initialize-release</category><body package="Browser-Smalllint">initialize	methodBlock := [].	environment := SelectorEnvironment new.	context := SmalllintContext newNoCache</body><body package="Browser-Smalllint">release	context release.	super release</body></methods><methods><class-id>Refactory.Browser.SmalllintChecker</class-id> <category>actions</category><body package="Browser-Smalllint">run	rule resetResult.	environment classesDo: 			[:aClass | 			self checkClass: aClass.			self checkMethodsForClass: aClass]</body></methods><methods><class-id>Refactory.Browser.SmalllintChecker class</class-id> <category>instance creation</category><body package="Browser-Smalllint">new	^(super new)		initialize;		yourself</body><body package="Browser-Smalllint">newWithContext	^(self new)		context: SmalllintContext new;		yourself</body><body package="Browser-Smalllint">runRule: aLintRule onEnvironment: aBrowserEnvironment 	(self new)		rule: aLintRule;		environment: aBrowserEnvironment;		run.	^aLintRule</body></methods><methods><class-id>Refactory.Browser.ParseTreeLintRule</class-id> <category>accessing</category><body package="Browser-Smalllint">checkMethod: aSmalllintContext 	(matcher canMatchMethod: aSmalllintContext compiledMethod) 		ifFalse: [^self].	(matcher executeTree: aSmalllintContext parseTree initialAnswer: nil) 		notNil 			ifTrue: 				[result addClass: aSmalllintContext selectedClass					selector: aSmalllintContext selector]</body><body package="Browser-Smalllint">matcher	^matcher</body></methods><methods><class-id>Refactory.Browser.ParseTreeLintRule</class-id> <category>private</category><body package="Browser-Smalllint">defaultResultClass	^ParseTreeEnvironment</body></methods><methods><class-id>Refactory.Browser.ParseTreeLintRule</class-id> <category>initialize-release</category><body package="Browser-Smalllint">matcher: aParseTreeMatcher	matcher := aParseTreeMatcher</body><body package="Browser-Smalllint">resetResult	result := ParseTreeEnvironment new.	result		label: self name;		matcher: matcher</body></methods><methods><class-id>Refactory.Browser.ParseTreeLintRule class</class-id> <category>intention revealing</category><body package="Browser-Smalllint">anySatisfy	^self createParseTreeRule:			#('(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) isNil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) notNil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) = nil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) == nil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) ~= nil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) ~~ nil') 		name: (#anyAllSatisfyNotUsed &lt;&lt; #browser &gt;&gt; 'Uses detect:ifNone: instead of any/allSatisfy:') asString</body><body package="Browser-Smalllint">assignmentInIfTrue	^self createParseTreeRule: 			#('`@boolean 					ifTrue: [| `@temps1 | `@.Statements1. `var := `@object1] 					ifFalse: [| `@temps2 | `@.Statements2. `var := `@object2]' 			'`@boolean 					ifFalse: [| `@temps1 | `@.Statements1. `var := `@object1] 					ifTrue: [| `@temps2 | `@.Statements2. `var := `@object2]') 		name: (#SameAssignmentInConditionals &lt;&lt; #browser &gt;&gt; 'Assignment to same variable at end of ifTrue:ifFalse: blocks') asString</body><body package="Browser-Smalllint">atIfAbsent	^self createParseTreeRule: 				#('`@object 						at: `@atArg 						ifAbsent: [| `@temps | `@.Statements. `@object at: `@atArg put: `@putArg]' 				'`@object 						at: `@atArg 						ifAbsent: [| `@temps | 								`@.Statements. 								`@object at: `@atArg put: `@putArg. 								`@.xStatements1. 								`@putArg]') 		name: (#UsesAtIfAbsent &lt;&lt; #browser &gt;&gt; 'Uses at:ifAbsent: instead of at:ifAbsentPut:') asString</body><body package="Browser-Smalllint">collectionProtocol	^self createParseTreeRule: 			#(' | `@temps1 | `@.Statements3. `object := `@expr. `@.Statements4. `@collection do: [:`each | | `@temps2 | `@.Statements1. `object add: `@arg. `@.Statements2]. `@.Statements5' 			' | `@temps1 | `@.Statements3. `object := `@expr. `@.Statements4. 			 `@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@blockTemps | 							`@.BlockStatements1. 							`@object add: `each. 							`@.BlockStatements2]. 					`@.Statements2].			  `@.Statements5' 			' | `@temps1 | `@.Statements3. `object := `@expr. `@.Statements4. 			 `@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@blockTemps | 							`@.BlockStatements1. 							`@object add: `each. 							`@.BlockStatements2]. 					`@.Statements2].			  `@.Statements5') 		name: (#CollectionProtocolNotUsed &lt;&lt; #browser &gt;&gt; 'Uses do: instead of collect: or select:''s') asString</body><body package="Browser-Smalllint">collectSelectNotUsed	^self 		createParseTreeRule: #('`{:node | node isMessage and: [(#(#select: #collect: #reject:) includes: node selector) and: [node isUsed not and: [node arguments first isBlock]]]}')		name: (#CollectSelectResultIgnored &lt;&lt; #browser &gt;&gt; 'Doesn''t use the result of a collect:/select:') asString</body><body package="Browser-Smalllint">consistencyCheck	^self createParseTreeRule: 				#('`@object size == 0' 				'`@object size = 0' 				'`@object size &gt; 0' 				'`@object size &gt;= 1' 				'`@object == nil' 				'`@object = nil'				'`@collection at: 1'				'`@collection at: `@collection size') 		name: (#StandardProtocolNotUsed &lt;&lt; #browser &gt;&gt; 'Uses "size = 0", "= nil",  or "at: 1" instead of "isEmpty",  "isNil", or "first"') asString</body><body package="Browser-Smalllint">detectAndAnySatisfy	^self createParseTreeRule: 			#('`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@BlockTemps | `@.BlockStatements1. ^`each]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@BlockTemps | `@.BlockStatements1.  ^`each]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@BlockTemps | `@.BlockStatements1. ^true]. 					`@.Statements2]' 			'`@Collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@BlockTemps | `@.BlockStatements1.  ^true]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@BlockTemps | `@.BlockStatements1. ^false]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@BlockTemps | `@.BlockStatements1.  ^false]. 					`@.Statements2]') 		name: (#DoUsedInsteadOfAnyAllSatisfy &lt;&lt; #browser &gt;&gt; 'Uses do: instead of any/allSatisfy: or detect:''s') asString</body><body package="Browser-Smalllint">guardingClause	| detector matcher |	detector := self new.	detector name: (#GuardingClauses &lt;&lt; #browser &gt;&gt; 'Guarding clauses') asString.	matcher := ParseTreeSearcher new.	matcher 		matchesAnyMethodOf: 				#('`@MethodName: `@args 					| `@temps | 					`@.Statements. 					`@condition ifTrue: [| `@BlockTemps | `.Statement1. `.Statement2. `@.BStatements]' 			'`@MethodName: `@args 					| `@temps | 					`@.Statements. 					`@condition ifFalse: [| `@BlockTemps | `.Statement1. `.Statement2. `@.BStatements]')		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[aNode body statements last]				ifFalse: [answer]].	detector matcher: matcher.	^detector</body><body package="Browser-Smalllint">ifTrueReturns	| detector matcher |	detector := self new.	detector name: (#ConditionalReturns &lt;&lt; #browser &gt;&gt; 'ifTrue:/ifFalse: returns instead of and:/or:''s') asString.	matcher := ParseTreeSearcher new.	matcher 		matchesAnyOf: 			#('| `@temps | ``@.Statements. ``@object ifTrue: [^``@value1]. ^``@value2' 			'| `@temps | ``@.Statements. ``@object ifFalse: [^``@value1]. ^``@value2')		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[| node |					node := (aNode statements at: aNode statements size - 1) arguments first 								body statements 								last value.	"``@value1"					((node isLiteralNode and: [#(true false) includes: node value]) or: 							[node := aNode statements last value.							node isLiteralNode and: [#(true false) includes: node value]]) 						ifTrue: [aNode]						ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector</body><body package="Browser-Smalllint">indexOf	^self 		createParseTreeRule: 			#('(`@collection indexOf: `@object) = 0' 			'(`@collection indexOf: `@object) == 0' 			'(`@collection indexOf: `@object) ~= 0' 			'(`@collection indexOf: `@object) ~~ 0')		name: (#IndexOfInsteadOfIncludes &lt;&lt; #browser &gt;&gt; 'Uses indexOf: instead of includes:') asString</body><body package="Browser-Smalllint">literalArrayCharacters	| detector matcher |	detector := self new.	detector name: (#LiteralArrayWithOnlyChars &lt;&lt; #browser &gt;&gt; 'Literal array contains only characters') asString.	matcher := ParseTreeSearcher new.	matcher matches: '`#literal'		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[(aNode value class == Array and: [self isArrayOfCharacters: aNode value]) 						ifTrue: [aNode]						ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector</body><body package="Browser-Smalllint">minMax	| detector matcher |	detector := self new.	detector name: (#DoesNotUseMinMax &lt;&lt; #browser &gt;&gt; 'Uses ifTrue:/ifFalse: instead of min: or max:') asString.	matcher := ParseTreeSearcher new.	matcher 		matchesAnyOf: #('(`x `message: `@y) `ifTrue: [`x := `@y]' '(`@x `message: `@y) `ifTrue: [`@x] `ifFalse: [`@y]' '(`@x `message: `@y) `ifTrue: [`v := `@x] `ifFalse: [`v := `@y]')		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[((#(#ifTrue: #ifFalse: #ifTrue:ifFalse: #ifFalse:ifTrue:) 						includes: aNode selector) 							and: [#(#&lt; #&lt;= #&gt; #&gt;=) includes: aNode receiver selector]) 							ifTrue: [aNode]							ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector</body><body package="Browser-Smalllint">searchingLiteral	| detector matcher |	detector := self new.	detector name: (#ORsInsteadOfLiteral &lt;&lt; #browser &gt;&gt; 'Uses or''s instead of a searching literal') asString.	matcher := ParseTreeSearcher new.	matcher 		matchesAnyOf: #('``@object = `#literal or: [``@expression]' 						'``@object == `#literal or: [``@expression]' 						'`#literal = ``@object or: [``@expression]' 						'`#literal == ``@object or: [``@expression]' 						'``@expression | (``@object = `#literal)' 						'``@expression | (``@object == `#literal)' 						'``@expression | (`#literal = ``@object)' 						'``@expression | (`#literal == ``@object)')		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[(self isSearchingLiteralExpression: aNode) ifTrue: [aNode] ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector</body><body package="Browser-Smalllint">sizeCheck	^self createParseTreeRule: (#(#do: #collect: #reject: #select:) collect: 					[:each | 					'`@object size &gt; 0 ifTrue: [`@object ' , each						, ' [:`each | | `@temps | `@.Statements1]. `@.Statements2]'])				, (#(#do: #collect: #reject: #select:) collect: 							[:each | 							'`@object isEmpty ifFalse: [`@object ' , each								, ' [:`each | | `@temps | `@.Statements1]. `@.Statements2]'])		name: (#UnnecessarySizeCheck &lt;&lt; #browser &gt;&gt; 'Unnecessary size check') asString</body><body package="Browser-Smalllint">toDo	| detector matcher |	detector := self new.	detector name: (#DoesNotUseDoWithDoOrTimesRepeat &lt;&lt; #browser &gt;&gt; 'Uses to:do: instead of do:, with:do: or timesRepeat:') asString.	matcher := ParseTreeSearcher new.	matcher 		matches: '1 to: ``@object size do: [:`each | | `@temps | `@.Statements]'		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[| varName variableMatcher |					varName := aNode arguments last arguments first.	"`each"					variableMatcher := ParseTreeSearcher new.					variableMatcher matchesTree: varName						do: [:node :ans | ans and: [node parent isMessage and: [node parent selector == #at:]]].					(variableMatcher executeTree: aNode arguments last body initialAnswer: true) 						ifTrue: [aNode]						ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector</body><body package="Browser-Smalllint">toDoCollect	^self 		createParseTreeRule: #(			'| `@temps1 |			`@.Stmts1.			`collection := Array new: `@size.			`@.Stmts2.			1 to: `@size do: 					[:`i | 					| `@Btemps2 | 					`@.BStmts1. 					`collection at: `i put: `@obj.					`@.BStmt2].			`@.Stmts3'					"-------------"			 '| `@temps1 |			`@.Stmts1.			`collection := Array new: `@size.			`@.Stmts2.			1 to: `collection size do: 					[:`i | 					| `@Btemps2 | 					`@.BStmts1. 					`collection at: `i put: `@obj.					`@.BStmt2].			`@.Stmts3')		name: (#todoDoesntUseCollect &lt;&lt; #browser &gt;&gt; 'to:do: doesn''t use collect:') asString</body><body package="Browser-Smalllint">toDoWithIncrement	^self 		createParseTreeRule: #(				'`@i to: `@j do: [:`e | | `@temps | `@.Stmts. `x := `x + 1. `@.Stmts2]' 				'`@i to: `@j by: `@k do: [:`e | | `@temps | `@.Stmts. `x := `x + `@k. `@.Stmts2]')		name: (#toDoLoopIncrementsCounter &lt;&lt; #browser &gt;&gt; 'to:do: loop also increments a counter') asString</body><body package="Browser-Smalllint">whileTrue	^self createParseTreeRule: 			#('| `@temps | 				`@.Statements1. 				[`index &lt;= `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index + 1].				`@.Statements2' 			'| `@temps | 				`@.Statements1. 				[`index &lt; `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index + 1].				`@.Statements2'			'| `@temps | 				`@.Statements1. 				[`index &gt;= `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index - 1].				`@.Statements2' 			'| `@temps | 				`@.Statements1. 				[`index &gt; `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index - 1].				`@.Statements2') 		name: (#whileTrueInsteadOfToDo &lt;&lt; #browser &gt;&gt; 'Uses whileTrue: instead of to:do:') asString</body></methods><methods><class-id>Refactory.Browser.ParseTreeLintRule class</class-id> <category>bugs</category><body package="Browser-Smalllint">booleanPrecedence	^self createParseTreeRule: 			#('`@object1 | `@object2 = `@object3'			'`@object1 | `@object2 == `@object3'			'`@object1 &amp; `@object2 = `@object3'			'`@object1 &amp; `@object2 == `@object3'			'`@object1 | `@object2 ~= `@object3'			'`@object1 | `@object2 ~~ `@object3'			'`@object1 &amp; `@object2 ~= `@object3'			'`@object1 &amp; `@object2 ~~ `@object3')		name: (#PossiblyIncorrectBooleanPrecedence &lt;&lt; #browser &gt;&gt; 'Uses A | B = C instead of A | (B = C)') asString</body></methods><methods><class-id>Refactory.Browser.ParseTreeLintRule class</class-id> <category>private</category><body package="Browser-Smalllint">createMatcherFor: codeStrings method: aBoolean 	| matcher |	matcher := ParseTreeSearcher new.	aBoolean 		ifTrue: [matcher matchesAnyMethodOf: codeStrings do: [:aNode :answer | aNode]]		ifFalse: [matcher matchesAnyOf: codeStrings do: [:aNode :answer | aNode]].	^matcher</body><body package="Browser-Smalllint">isArrayOfCharacters: anArray 	anArray isEmpty ifTrue: [^false].	1 to: anArray size		do: [:each | (anArray at: each) class == Character ifFalse: [^false]].	^true</body><body package="Browser-Smalllint">isSearchingLiteralExpression: aMessageNode 	| equalNode expressionNode |	equalNode := aMessageNode selector = #| 				ifTrue: [aMessageNode arguments first]				ifFalse: [aMessageNode receiver].	expressionNode := equalNode receiver isLiteralNode 				ifTrue: [equalNode arguments first]				ifFalse: [equalNode receiver].	^self isSearchingLiteralExpression: aMessageNode for: expressionNode</body><body package="Browser-Smalllint">isSearchingLiteralExpression: aSearchingNode for: anObjectNode 	| argument arguments |	aSearchingNode isMessage ifFalse: [^false].	arguments := aSearchingNode arguments.	arguments size = 1 ifFalse: [^false].	argument := arguments first.	(#(#= #==) includes: aSearchingNode selector) 		ifTrue: 			[^(aSearchingNode receiver = anObjectNode 				and: [aSearchingNode arguments first isLiteralNode]) or: 						[aSearchingNode arguments first = anObjectNode 							and: [aSearchingNode receiver isLiteralNode]]].	aSearchingNode selector = #| 		ifTrue: 			[^(self isSearchingLiteralExpression: aSearchingNode receiver				for: anObjectNode) 					and: [self isSearchingLiteralExpression: argument for: anObjectNode]].	aSearchingNode selector = #or: ifFalse: [^false].	argument isBlock ifFalse: [^false].	argument body statements size = 1 ifFalse: [^false].	^(self isSearchingLiteralExpression: aSearchingNode receiver		for: anObjectNode) and: 				[self isSearchingLiteralExpression: argument body statements first					for: anObjectNode]</body><body package="Browser-Smalllint">modifiesTree: aCollectionTree in: aParseTree 	| notifier args |	notifier := ParseTreeSearcher new.	args := Array with: (RBPatternVariableNode named: '`@object').	notifier 		matchesAnyTreeOf: (#(#add: #addAll: #remove: #removeAll:) collect: 					[:each | 					RBMessageNode 						receiver: aCollectionTree copy						selector: each						arguments: args])		do: [:aNode :answer | true].	^notifier executeTree: aParseTree initialAnswer: false</body></methods><methods><class-id>Refactory.Browser.ParseTreeLintRule class</class-id> <category>instance creation</category><body package="Browser-Smalllint">createParseTreeRule: codeStrings method: aBoolean name: aName 	^(self new)		name: aName;		matcher: (self createMatcherFor: codeStrings method: aBoolean);		yourself</body><body package="Browser-Smalllint">createParseTreeRule: codeStrings name: aName 	^self 		createParseTreeRule: codeStrings		method: false		name: aName</body></methods><methods><class-id>Refactory.Browser.ParseTreeLintRule class</class-id> <category>unnecessary code</category><body package="Browser-Smalllint">asOrderedCollectionNotNeeded	^self 		createParseTreeRule: #('`@node addAll: `{:node | node isMessage and: [#(asOrderedCollection asArray) includes: node selector]}')		name: (#asArrayNotNeeded &lt;&lt; #browser &gt;&gt; '#asOrderedCollection/#asArray not needed') asString</body><body package="Browser-Smalllint">assignmentInBlock	^self createParseTreeRule: #(			'`@cursor showWhile: [| `@temps | `@.Statements1. `var := `@object]' 			'`@cursor showWhile: [| `@temps | `@.Statements1. ^`@object]' 			'[| `@temps | `@.Statements. `var := `@object] valueNowOrOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. ^`@object] valueNowOrOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. `var := `@object] valueOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. ^`@object] valueOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. `var := `@object] ensure: `@block' 			'[| `@temps | `@.Statements. ^`@object] ensure: `@block' 			'[| `@temps | `@.Statements. `var := `@object] ifCurtailed: `@block' 			'[| `@temps | `@.Statements. ^`@object] ifCurtailed: `@block' ) 		name: (#UnnecessaryAssignmentInBlock &lt;&lt; #browser &gt;&gt; 'Unnecessary assignment or return in block') asString</body><body package="Browser-Smalllint">endTrueFalse	| detector matcher |	detector := self new.	detector 		name: (#CheckForSameAtEndOfConditionals &lt;&lt; #browser &gt;&gt; 'Check for same statements at end of ifTrue:ifFalse: blocks') asString.	matcher := (ParseTreeSearcher new)				matchesAnyOf: 						#('`@object 								ifTrue: [| `@temps1 | `@.Statements1. `.Statement] 								ifFalse: [| `@temps2 | `@.Statements2. `.Statement]' 						'`@object 								ifTrue: [| `@temps1 | `.Statement. `@.Statements1] 								ifFalse: [| `@temps2 | `.Statement. `@.Statements2]' 						'`@object 								ifFalse: [| `@temps1 | `@.Statements1. `.Statement] 								ifTrue: [| `@temps2 | `@.Statements2. `.Statement]' 						'`@object 								ifFalse: [| `@temps1 | `.Statement. `@.Statements1] 								ifTrue: [| `@temps2 | `.Statement. `@.Statement2]') 					do: 						[:aNode :answer | 						answer isNil 							ifTrue: 								[| node |								node := aNode arguments first body statements last.								(node isVariable and: [node = aNode arguments last body statements last]) 									ifTrue: [nil]									ifFalse: [aNode]]							ifFalse: [answer]];				yourself.	detector matcher: matcher.	^detector</body><body package="Browser-Smalllint">equalsTrue	| detector matcher |	detector := self new.	detector name: (#UnnecessaryEqTrue &lt;&lt; #browser &gt;&gt; 'Unnecessary "= true"') asString.	matcher := (ParseTreeSearcher new)				matchesAnyOf: #('true' 'false')					do: 						[:aNode :answer | 						answer isNil 							ifTrue: 								[(aNode parent isMessage 									and: [#(#= #== #~= #~~) includes: aNode parent selector]) 										ifTrue: [aNode]										ifFalse: [nil]]							ifFalse: [answer]];				yourself.	detector matcher: matcher.	^detector</body><body package="Browser-Smalllint">extraBlock	^self 		createParseTreeRule: #('`{:node | node isMessage and: [node receiver isBlock and: [node parent isCascade not and: [#(#value #value: #value:value: #value:value:value: #valueWithArguments) includes: node selector]]]}')		name: (#BlockImmediatelyEvaluated &lt;&lt; #browser &gt;&gt; 'Block immediately evaluated') asString</body><body package="Browser-Smalllint">unnecessaryAssignment	^self 		createParseTreeRule: #('^`{:aNode | aNode isAssignment and: [(aNode whoDefines: aNode variable name) notNil]}')		name: (#UnnecessaryTempAssignment &lt;&lt; #browser &gt;&gt; 'Unnecessary assignment to a temporary variable') asString</body></methods><methods><class-id>Refactory.Browser.ParseTreeLintRule class</class-id> <category>possible bugs</category><body package="Browser-Smalllint">equalNotUsed	^self 		createParseTreeRule: #('`{:node | node isMessage and: [node isUsed not and: [#(#= #== #~= #~~ #&lt; #&gt; #&lt;= #&gt;=) includes: node selector]]}')		name: (#EqualResultNotUsed &lt;&lt; #browser &gt;&gt; 'Doesn''t use the result of a =, ~=, etc.') asString</body><body package="Browser-Smalllint">fileBlocks	^self createParseTreeRule: 				#('[| `@temps | 					`var := `@object.  					`@.statements] 							valueNowOrOnUnwindDo: 								[`var `@messages: `@args]' 				'[| `@temps | 					`var := `@object.  					`@.statements] 							valueOnUnwindDo: 								[`var `@messages: `@args]'				'[| `@temps | 					`var := `@object.  					`@.statements] 							ensure: 								[`var `@messages: `@args]' 				'[| `@temps | 					`var := `@object.  					`@.statements] 							ifCurtailed: 								[`var `@messages: `@args]') 		name: (#AssignmentInUnwindBlock &lt;&lt; #browser &gt;&gt; 'Assignment inside unwind blocks should be outside.') asString</body><body package="Browser-Smalllint">missingYourself	^self 		createParseTreeRule: #('`{:node | node isMessage and: [node parent isCascade and: [node isDirectlyUsed and: [node selector ~~ #yourself]]]}')		name: (#PossibleMissingYourself &lt;&lt; #browser &gt;&gt; 'Possible missing "; yourself"') asString</body><body package="Browser-Smalllint">modifiesCollection	| detector matcher |	detector := self new.	detector name: (#ModifiesWhileIterating &lt;&lt; #browser &gt;&gt; 'Modifies collection while iterating over it') asString.	matcher := (ParseTreeSearcher new)				matchesAnyOf: 						#('`@object do: [:`each | | `@temps | ``@.Statements]' 						'`@object collect: [:`each | | `@temps | ``@.Statements]' 						'`@object select: [:`each | | `@temps | ``@.Statements]' 						'`@object reject: [:`each | | `@temps | ``@.Statements]' 						'`@object inject: `@value into: [:`sum :`each | | `@temps | ``@.Statements]')					do: 						[:aNode :answer | 						answer isNil 							ifTrue: 								[(self modifiesTree: aNode receiver in: aNode arguments last) 									ifTrue: [aNode]									ifFalse: [nil]]							ifFalse: [answer]];				yourself.	detector matcher: matcher.	^detector</body><body package="Browser-Smalllint">returnInEnsure	| detector matcher returnMatcher |	detector := self new.	detector name: (#ReturnInEnsureColon &lt;&lt; #browser &gt;&gt; 'Contains a return in an ensure: block') asString.	returnMatcher := ParseTreeSearcher new.	returnMatcher matches: '^`@object' do: [:aNode :answer | true].	matcher := ParseTreeSearcher new.	matcher 		matchesAnyOf: #('``@rcv ensure: [| `@temps | ``@.Stmts]' 						'``@rcv valueNowOrOnUnwindDo: [| `@temps | ``@.Stmts]' 						'``@rcv ifCurtailed: [| `@temps | ``@.Stmts]' 						'``@rcv valueOnUnwindDo: [| `@temps | ``@.Stmts]')		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[(returnMatcher executeTree: aNode arguments first initialAnswer: false) 						ifTrue: [aNode]						ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector</body><body package="Browser-Smalllint">returnsIfTrue	^self createParseTreeRule: 				#('^`@condition ifTrue: [| `@temps | `@.statements]' 				'^`@condition ifFalse: [| `@temps | `@.statements]') 		name: (#ReturnsValueOfAsymmetricConditional &lt;&lt; #browser &gt;&gt; 'Returns value of ifTrue:/ifFalse: without ifFalse:/ifTrue: block') asString</body><body package="Browser-Smalllint">threeElementPoint	| detector matcher |	detector := self new.	detector name: (#PossibleThreeElementPoint &lt;&lt; #browser &gt;&gt; 'Possible three element point (e.g., x @ y + q @ r)') asString.	matcher := (ParseTreeSearcher new)				matches: '``@x @ ``@y'					do: 						[:aNode :answer | 						answer isNil 							ifTrue: 								[| current |								current := aNode parent.																[current isNil or: 										[current isMessage 											and: [current selector == #@ or: [current selector isInfix not]]]] 										whileFalse: [current := current parent].								(current isNil or: [current isMessage and: [current selector isInfix not]]) 									ifTrue: [nil]									ifFalse: [aNode]]							ifFalse: [answer]];				yourself.	detector matcher: matcher.	^detector</body><body package="Browser-Smalllint">usesAdd	^self 		createParseTreeRule: #('`{:node | node isMessage and: [(node selector == #add: or: [node selector == #addAll:]) and: [node isDirectlyUsed]]}')		name: (#UsesResultOfAdd &lt;&lt; #browser &gt;&gt; 'Uses the result of an add: message') asString</body></methods><methods><class-id>Refactory.Browser.ParseTreeLintRule class</class-id> <category>deprecated</category><body package="Browser-Smalllint">ifTrueBlocks	^self 		createParseTreeRule: #(				'`@condition ifTrue: `{:node | node isBlock not} ifFalse: `@block' 				'`@condition ifTrue: `@block ifFalse: `{:node | node isBlock not}' 				'`@condition ifFalse: `{:node | node isBlock not} ifTrue: `@block' 				'`@condition ifFalse: `@block ifTrue: `{:node | node isBlock not}' 				'`@condition ifTrue: `{:node | node isBlock not}' 				'`@condition ifFalse: `{:node | node isBlock not}')		name: (#NonBlockConditionals &lt;&lt; #browser &gt;&gt; 'Non-blocks in ifTrue:/ifFalse: messages') asString</body><body package="Browser-Smalllint">precedence	^self 		createParseTreeRule: #('`{:node | node isMessage and: [node hasParentheses not and: [#(#+ #-) includes: node selector]]} * `@C')		name: (#PossiblyWrongPrecedence &lt;&lt; #browser &gt;&gt; 'Inspect instances of "A + B * C" might be "A + (B * C)"') asString</body><body package="Browser-Smalllint">stringConcatenation	| detector matcher concatenationMatcher |	detector := self new.	detector name: (#ConcatenationInsteadOfStreams &lt;&lt; #browser &gt;&gt; 'String concatenation instead of streams') asString.	matcher := ParseTreeSearcher new.	concatenationMatcher := ParseTreeSearcher new.	concatenationMatcher matches: '`@receiver , `@argument'		do: [:aNode :answer | true].	matcher 		matchesAnyOf: #('``@collection do: [:`each | | `@temps | ``@.Statements]' '``@collection do: [:`each | | `@temps | ``@.Statements] separatedBy: [| `@temps1 | ``@.Statements1]' '``@number to: ``@endNumber do: [:`i | | `@temps | ``@.Statements]' '``@collection detect: [:`each | | `@temps | ``@.Statements]' '``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [| `@temps1 | ``@.Statements1]' '``@collection select: [:`each | | `@temps | ``@.Statements]' '``@collection inject: ``@value into: [:`each | | `@temps | ``@.Statements]')		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[(aNode arguments anySatisfy: 							[:each | 							each isBlock 								and: [concatenationMatcher executeTree: each initialAnswer: false]]) 						ifTrue: [aNode]						ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector</body><body package="Browser-Smalllint">unoptimizedAndOr	^self 		createParseTreeRule: #('(`@a and: `@b) and: `@c' '(`@a or: `@b) or: `@c')		name: (#UnoptimizedAndOr &lt;&lt; #browser &gt;&gt; 'Uses "(a and: [b]) and: [c]" instead of "a and: [b and: [c]]"') asString</body><body package="Browser-Smalllint">unoptimizedToDo	^self createParseTreeRule: #('(`@a to: `@b) do: `@c')		name: (#UnoptimizedToDo &lt;&lt; #browser &gt;&gt; 'Uses (to:)do: instead of to:do:') asString</body><body package="Browser-Smalllint">yourselfNotUsed	^self createParseTreeRule: #('`{:node | node parent isUsed not} yourself')		name: (#YourselfNotUsed &lt;&lt; #browser &gt;&gt; 'Doesn''t use the result of a yourself message') asString</body></methods><methods><class-id>Refactory.Browser.SmalllintContext</class-id> <category>private</category><body package="Browser-Smalllint">addLiteralsFor: aCompiledMethod	aCompiledMethod allLiteralsDo: [:each | self checkLiteral: each]</body><body package="Browser-Smalllint">buildParseTree	| tree |	tree := self selectedClass parseTreeFor: self selector.	tree isNil ifTrue: [^RBParser parseMethod: 'method'].	^tree</body><body package="Browser-Smalllint">checkLiteral: aLiteral 	| binding |	aLiteral isSymbol ifTrue: [literals add: aLiteral].	aLiteral isVariableBinding 		ifTrue: 			[binding := aLiteral nonDeferredBinding.			binding isNil ifTrue: [binding := Undeclared bindingFor: aLiteral key].			binding notNil 				ifTrue: 					[binding isForClass 						ifTrue: 							[literals add: binding value.							literals addAll: binding value environment withAllEnvironments].					binding isForNameSpace 						ifTrue: [literals addAll: binding value withAllEnvironments].					binding isForGeneral ifTrue: [literals add: binding]]].	aLiteral isBindingReference 		ifTrue: [self checkLiteral: aLiteral bindingOrNil].	aLiteral class == Array 		ifTrue: [aLiteral do: [:each | self checkLiteral: each]]</body><body package="Browser-Smalllint">computeLiterals	literalSemaphore := Semaphore new.	literalProcess := [self primitiveComputeLiterals] fork</body><body package="Browser-Smalllint">computeLiteralsForClass: aClass 	self		computeLiteralsForMethodsInClass: aClass;		computeLiteralsForMethodsInClass: aClass class;		computeLiteralsForNameSpace: aClass asNameSpace</body><body package="Browser-Smalllint">computeLiteralsForMethodsInClass: aClass 	(selectors addAll: aClass selectors) do: 			[:sel | 			self computeLiteralsForSelector: sel in: aClass.			Processor yield]</body><body package="Browser-Smalllint">computeLiteralsForNameSpace: aNameSpace 	aNameSpace bindingsDo: 			[:each | 			each isForGeneral ifTrue: [self computeLiteralsForSharedVariable: each].			each isForNameSpace ifTrue: [self computeLiteralsForNameSpace: each value].			each isForClass ifTrue: [self computeLiteralsForClass: each value]]</body><body package="Browser-Smalllint">computeLiteralsForSelector: aSelector in: aClass 	| method |	method := aClass compiledMethodAt: aSelector ifAbsent: [nil].	method isNil ifTrue: [^self].	self addLiteralsFor: method</body><body package="Browser-Smalllint">computeLiteralsForSharedVariable: aBinding 	aBinding hasInitializer ifTrue: [self addLiteralsFor: aBinding method]</body><body package="Browser-Smalllint">computeMessages	| searcher |	selfMessages := Set new.	superMessages := Set new.	messages := Set new.	searcher := ParseTreeSearcher new.	searcher		matches: 'self `@message: ``@args'			do: [:aNode :answer | selfMessages add: aNode selector];		matches: 'super `@message: ``@args'			do: [:aNode :answer | superMessages add: aNode selector];		matches: '``@receiver `@message: ``@args'			do: [:aNode :answer | messages add: aNode selector].	searcher executeTree: self parseTree initialAnswer: nil</body><body package="Browser-Smalllint">primitiveComputeLiterals	| semaphore |	literals := IdentitySet new: 25000.	literals addAll: self specialSelectors.	selectors := IdentitySet new.	self computeLiteralsForNameSpace: Root.	semaphore := literalSemaphore.	literalSemaphore := nil.	self signalProcesses: semaphore.	^literalProcess := nil</body><body package="Browser-Smalllint">signalProcesses: aSemaphore 	aSemaphore isNil ifTrue: [^self].	[aSemaphore isEmpty] whileFalse: [aSemaphore signal]</body><body package="Browser-Smalllint">specialSelectors	^(OpcodePool at: #SpecialSelectorDictionary) keys</body></methods><methods><class-id>Refactory.Browser.SmalllintContext</class-id> <category>accessing</category><body package="Browser-Smalllint">compiledMethod	^compiledMethod notNil		ifTrue: [compiledMethod]		ifFalse: [compiledMethod := class compiledMethodAt: selector]</body><body package="Browser-Smalllint">compiledMethod: aCompiledMethod	compiledMethod := aCompiledMethod</body><body package="Browser-Smalllint">instVarNames	^self selectedClass allInstVarNames</body><body package="Browser-Smalllint">literals	literalSemaphore isNil 		ifTrue: 			[literals isNil 				ifTrue: 					[self computeLiterals.					literalSemaphore wait]]		ifFalse: [literalSemaphore wait].	^literals</body><body package="Browser-Smalllint">messages	messages isNil ifTrue: [self computeMessages].	^messages</body><body package="Browser-Smalllint">methodSource	| source |	source := self selectedClass sourceCodeAt: self selector.	^source isNil ifTrue: [''] ifFalse: [source]</body><body package="Browser-Smalllint">nameSpace	^nameSpace</body><body package="Browser-Smalllint">parseTree	^parseTree isNil		ifTrue: [parseTree := self buildParseTree]		ifFalse: [parseTree]</body><body package="Browser-Smalllint">parseTree: aParseTree	parseTree := aParseTree</body><body package="Browser-Smalllint">protocol	^self selectedClass whichCategoryIncludesSelector: self selector</body><body package="Browser-Smalllint">protocols	^Array with: self protocol</body><body package="Browser-Smalllint">selectedClass	^class</body><body package="Browser-Smalllint">selectedClass: aBehavior 	class := aBehavior.	nameSpace := class environment.	self selector: nil</body><body package="Browser-Smalllint">selector	^selector</body><body package="Browser-Smalllint">selector: anObject 	selector := anObject.	parseTree := compiledMethod := selfMessages := superMessages := messages := nil</body><body package="Browser-Smalllint">selectors	literalSemaphore isNil 		ifTrue: 			[selectors isNil 				ifTrue: 					[self computeLiterals.					literalSemaphore wait]]		ifFalse: [literalSemaphore wait].	^selectors</body><body package="Browser-Smalllint">selfMessages	selfMessages isNil ifTrue: [self computeMessages].	^selfMessages</body><body package="Browser-Smalllint">superMessages	superMessages isNil ifTrue: [self computeMessages].	^superMessages</body></methods><methods><class-id>Refactory.Browser.SmalllintContext</class-id> <category>testing</category><body package="Browser-Smalllint">implements: aSelector 	^self selectors includes: aSelector</body><body package="Browser-Smalllint">isAbstract: aClass 	^(aClass isMeta or: 			[(self literals includes: aClass name) or: [self literals includes: aClass]]) 		not</body><body package="Browser-Smalllint">isAnnotatedMethod: aSymbol inClass: aClass	| method |	method := aClass compiledMethodAt: aSymbol ifAbsent: [^false].	^method attributeMessages notNil</body><body package="Browser-Smalllint">isTestCaseClass: aClass	^(Array with: #{SUnit.TestCase} with: #{XProgramming.SUnit.TestCase})		anySatisfy: 			[:each |			each ifDefinedDo: [:cls | aClass instanceBehavior includesBehavior: cls]				elseDo: [false]]</body><body package="Browser-Smalllint">isTestSelector: aSymbol inClass: aClass	^(self isTestCaseClass: aClass) and: [aSymbol beginsWith: #test]</body><body package="Browser-Smalllint">isUsedWithoutBeingReferencedClass: aClass	"returns true, if aClass can be used without being referenced in the context. This is true for all unit-test classes 	because they're selected in the browser"	^self isTestCaseClass: aClass</body><body package="Browser-Smalllint">isUsedWithoutBeingReferencedSelector: aSymbol inClass: aClass	^(self isAnnotatedMethod: aSymbol inClass: aClass)		or: [self isTestSelector: aSymbol inClass: aClass]</body><body package="Browser-Smalllint">uses: anObject	"overridden to make more educated guesses about classes and selectors"	(anObject isBehavior and: [self isUsedWithoutBeingReferencedClass: anObject])		ifTrue: [^true].	(anObject isSymbol		and: [self isUsedWithoutBeingReferencedSelector: anObject inClass: self selectedClass])			ifTrue: [^true].	^self literals includes: anObject</body></methods><methods><class-id>Refactory.Browser.SmalllintContext</class-id> <category>initialize-release</category><body package="Browser-Smalllint">initialize	self computeLiterals</body><body package="Browser-Smalllint">release	literalProcess notNil ifTrue: [literalProcess terminate].	super release</body></methods><methods><class-id>Refactory.Browser.SmalllintContext class</class-id> <category>instance creation</category><body package="Browser-Smalllint">new	^(super new)		initialize;		yourself</body><body package="Browser-Smalllint">newNoCache	^self basicNew</body></methods><methods><class-id>Refactory.Browser.ParseTreeTransformationRule</class-id> <category>initialize-release</category><body package="Browser-Smalllint">rewriteUsing: searchReplacer 	rewriteRule := searchReplacer.	self resetResult</body></methods><methods><class-id>Refactory.Browser.ParseTreeTransformationRule</class-id> <category>accessing</category><body package="Browser-Smalllint">checkMethod: aSmalllintContext 	(rewriteRule canMatchMethod: aSmalllintContext compiledMethod) 		ifFalse: [^self].	class := aSmalllintContext selectedClass.	(rewriteRule executeTree: aSmalllintContext parseTree) 		ifTrue: 			[(self class recursiveSelfRule executeTree: rewriteRule tree				initialAnswer: false) 					ifFalse: 						[changes 							compile: rewriteRule tree newSource							in: class							classified: aSmalllintContext protocol]]</body></methods><methods><class-id>Refactory.Browser.ParseTreeTransformationRule</class-id> <category>rules</category><body package="Browser-Smalllint">superSends	| rule |	rule := ParseTreeRewriter new.	rule 		replace: 'super'		with: 'self'		when: 			[:aNode | 			| message |			message := aNode parent.			message notNil and: 					[message isMessage and: 							[(class withAllSubclasses 								anySatisfy: [:each | each includesSelector: message selector]) not]]].	self rewriteUsing: rule</body></methods><methods><class-id>Refactory.Browser.ParseTreeTransformationRule class</class-id> <category>transformations</category><body package="Browser-Smalllint">assignmentInIfTrue	^self rewrite: #(			#('``@Boolean ifTrue: [`variable := ``@true] ifFalse: [`variable := ``@false]'			"-&gt;"			'`variable := ``@Boolean ifTrue: [``@true] ifFalse: [``@false]')			#('``@Boolean ifFalse: [`variable := ``@true] ifTrue: [`variable := ``@false]'			"-&gt;"			'`variable := ``@Boolean ifFalse: [``@true] ifTrue: [``@false]'))		methods: false		name: (#MoveAssignmentOutsideOfConditionals &lt;&lt; #browser &gt;&gt; 'Move variable assignment outside of single statement ifTrue:ifFalse: blocks') asString</body><body package="Browser-Smalllint">atIfAbsent	^self rewrite: #(			#('``@dictionary at: ``@key 					ifAbsent: [| `@temps | 							``@.Statements1.							``@dictionary at: ``@key put: ``@object.							``@.Statements2.							``@object]'			"-&gt;"			'``@dictionary at: ``@key					ifAbsentPut: [| `@temps |							``@.Statements1.							``@.Statements2.							``@object]')			#('``@dictionary at: ``@key					ifAbsent: [| `@temps |							``@.Statements.							``@dictionary at: ``@key put: ``@object]'			"-&gt;"			'``@dictionary at: ``@key					ifAbsentPut: [| `@temps |							``@.Statements.							``@object]'))		methods: false		name: (#ChangeIfAbsentToPut &lt;&lt; #browser &gt;&gt; 'at:ifAbsent: -&gt; at:ifAbsentPut:') asString</body><body package="Browser-Smalllint">betweenAnd	^self rewrite: #(			#('``@a &gt;= ``@b and: [``@a &lt;= ``@c]' "-&gt;" '``@a between: ``@b and: ``@c')			#('``@a &gt;= ``@b &amp; (``@a &lt;= ``@c)' "-&gt;" '``@a between: ``@b and: ``@c')			#('``@b &lt;= ``@a and: [``@a &lt;= ``@c]' "-&gt;" '``@a between: ``@b and: ``@c')			#('``@b &lt;= ``@a &amp; (``@a &lt;= ``@c)' "-&gt;" '``@a between: ``@b and: ``@c')			#('``@a &lt;= ``@c and: [``@a &gt;= ``@b]' "-&gt;" '``@a between: ``@b and: ``@c')			#('``@a &lt;= ``@c &amp; (``@a &gt;= ``@b)' "-&gt;" '``@a between: ``@b and: ``@c')			#('``@c &gt;= ``@a and: [``@a &gt;= ``@b]' "-&gt;" '``@a between: ``@b and: ``@c')			#('``@c &gt;= ``@a &amp; (``@a &gt;= ``@b)' "-&gt;" '``@a between: ``@b and: ``@c')			#('``@a &gt;= ``@b and: [``@c &gt;= ``@a]' "-&gt;" '``@a between: ``@b and: ``@c')			#('``@a &gt;= ``@b &amp; (``@c &gt;= ``@a)' "-&gt;" '``@a between: ``@b and: ``@c')			#('``@b &lt;= ``@a and: [``@c &gt;= ``@a]' "-&gt;" '``@a between: ``@b and: ``@c')			#('``@b &lt;= ``@a &amp; (``@c &gt;= ``@a)' "-&gt;" '``@a between: ``@b and: ``@c')			#('``@a &lt;= ``@c and: [``@b &lt;= ``@a]' "-&gt;" '``@a between: ``@b and: ``@c')			#('``@a &lt;= ``@c &amp; (``@b &lt;= ``@a)' "-&gt;" '``@a between: ``@b and: ``@c')			#('``@c &gt;= ``@a and: [``@b &lt;= ``@a]' "-&gt;" '``@a between: ``@b and: ``@c')			#('``@c &gt;= ``@a &amp; (``@b &lt;= ``@a)' "-&gt;" '``@a between: ``@b and: ``@c'))		methods: false		name: (#UseBetweenAnd &lt;&lt; #browser &gt;&gt; '"a &gt;= b and: [a &lt;= c]" -&gt; "a between: b and: c"') asString</body><body package="Browser-Smalllint">cascadedNextPutAlls	^self		rewrite: #(			#('``@rcvr nextPutAll: ``@object1 , ``@object2'					"-&gt;"				'``@rcvr nextPutAll: ``@object1; nextPutAll: ``@object2')			#('``@rcvr show: ``@object1 , ``@object2'					"-&gt;"				'``@rcvr show: ``@object1; show: ``@object2'))		methods: false		name: (#UseCascadedNextPutsAlls &lt;&lt; #browser &gt;&gt; 'Use cascaded nextPutAll:''s instead of #, in #nextPutAll:') asString</body><body package="Browser-Smalllint">detectIfNone	^self rewrite: #(			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) isNil'				"-&gt;"	'(``@collection anySatisfy: [:`each | | `@temps | ``@.Statements]) not')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) = nil'				"-&gt;"	'(``@collection anySatisfy: [:`each | | `@temps | ``@.Statements]) not')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) == nil'				"-&gt;"	'(``@collection anySatisfy: [:`each | | `@temps | ``@.Statements]) not')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) notNil'				"-&gt;"	'``@collection anySatisfy: [:`each | | `@temps | ``@.Statements]')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) ~= nil'				"-&gt;"	'``@collection anySatisfy: [:`each | | `@temps | ``@.Statements]')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) ~~ nil'				"-&gt;"	'``@collection anySatisfy: [:`each | | `@temps | ``@.Statements]'))		methods: false		name: (#detectifNoneAnySatisfy &lt;&lt; #browser &gt;&gt; 'detect:ifNone: -&gt; anySatisfy:') asString</body><body package="Browser-Smalllint">equalNil	^self		rewrite: #(			#('``@object = nil'	"-&gt;"	'``@object isNil') 			#('``@object == nil'	"-&gt;"	'``@object isNil') 			#('``@object ~= nil'	"-&gt;"	'``@object notNil') 			#('``@object ~~ nil'	"-&gt;"	'``@object notNil'))		methods: false		name: (#UseIsNilOrNotNil &lt;&lt; #browser &gt;&gt; '= nil -&gt; isNil AND ~= nil -&gt; notNil') asString</body><body package="Browser-Smalllint">guardClause	^self		rewrite: #(			#('`@methodName: `@args 					| `@temps | 					`@.Statements. 					`@condition ifTrue: [| `@trueTemps | `.Statement1. `.Statement2. `@.Statements1]'			"-&gt;"			'`@methodName: `@args					| `@temps `@trueTemps |					`@.Statements.					`@condition ifFalse: [^self].					`.Statement1.					`.Statement2.					`@.Statements1') 			#('`@methodName: `@args 					| `@temps | 					`@.Statements. 					`@condition ifFalse: [| `@falseTemps | `.Statement1. `.Statement2. `@.Statements1]'			"-&gt;"			'`@methodName: `@args					| `@temps `@falseTemps |					`@.Statements.					`@condition ifTrue: [^self].					`.Statement1.					`.Statement2.					`@.Statements1'))		methods: true		name: (#EliminateGuardingClauses &lt;&lt; #browser &gt;&gt; 'Eliminate guarding clauses') asString</body><body package="Browser-Smalllint">minMax	^self rewrite: #(			#('``@a &lt; ``@b ifTrue: [``@a] ifFalse: [``@b]'	"-&gt;"	'``@a min: ``@b')			#('``@a &lt;= ``@b ifTrue: [``@a] ifFalse: [``@b]'	"-&gt;"	'``@a min: ``@b')			#('``@a &gt; ``@b ifTrue: [``@a] ifFalse: [``@b]'	"-&gt;"	'``@a max: ``@b')			#('``@a &gt;= ``@b ifTrue: [``@a] ifFalse: [``@b]'	"-&gt;"	'``@a max: ``@b')			#('``@a &lt; ``@b ifTrue: [``@b] ifFalse: [``@a]'	"-&gt;"	'``@a max: ``@b')			#('``@a &lt;= ``@b ifTrue: [``@b] ifFalse: [``@a]'	"-&gt;"	'``@a max: ``@b')			#('``@a &gt; ``@b ifTrue: [``@b] ifFalse: [``@a]'	"-&gt;"	'``@a min: ``@b')			#('``@a &gt;= ``@b ifTrue: [``@b] ifFalse: [``@a]'	"-&gt;"	'``@a min: ``@b')			#('`a &lt; ``@b ifTrue: [`a := ``@b]'				"-&gt;"	'`a := `a max: ``@b')			#('`a &lt;= ``@b ifTrue: [`a := ``@b]'				"-&gt;"	'`a := `a max: ``@b')			#('`a &lt; ``@b ifFalse: [`a := ``@b]'				"-&gt;"	'`a := `a min: ``@b')			#('`a &lt;= ``@b ifFalse: [`a := ``@b]'			"-&gt;"	'`a := `a min: ``@b')			#('`a &gt; ``@b ifTrue: [`a := ``@b]'				"-&gt;"	'`a := `a min: ``@b')			#('`a &gt;= ``@b ifTrue: [`a := ``@b]'				"-&gt;"	'`a := `a min: ``@b')			#('`a &gt; ``@b ifFalse: [`a := ``@b]'				"-&gt;"	'`a := `a max: ``@b')			#('`a &gt;= ``@b ifFalse: [`a := ``@b]'			"-&gt;"	'`a := `a max: ``@b')			#('``@b &lt; `a ifTrue: [`a := ``@b]'				"-&gt;"	'`a := `a min: ``@b')			#('``@b &lt;= `a ifTrue: [`a := ``@b]'				"-&gt;"	'`a := `a min: ``@b')			#('``@b &lt; `a ifFalse: [`a := ``@b]'				"-&gt;"	'`a := `a max: ``@b')			#('``@b &lt;= `a ifFalse: [`a := ``@b]'			"-&gt;"	'`a := `a max: ``@b')			#('``@b &gt; `a ifTrue: [`a := ``@b]'				"-&gt;"	'`a := `a max: ``@b')			#('``@b &gt;= `a ifTrue: [`a := ``@b]'				"-&gt;"	'`a := `a max: ``@b')			#('``@b &gt; `a ifFalse: [`a := ``@b]'				"-&gt;"	'`a := `a min: ``@b')			#('``@b &gt;= `a ifFalse: [`a := ``@b]'			"-&gt;"	'`a := `a min: ``@b'))		methods: false		name: (#RewriteUsingMinMax &lt;&lt; #browser &gt;&gt; 'Rewrite ifTrue:ifFalse: using min:/max:') asString</body><body package="Browser-Smalllint">notElimination	^self		rewrite: #(			#('``@object not not'	"-&gt;"	'``@object') 			#('``@object not ifTrue: ``@block' 	"-&gt;"	'``@object ifFalse: ``@block') 			#('``@object not ifFalse: ``@block'	"-&gt;"	'``@object ifTrue: ``@block') 			#('``@collection select: [:`each | | `@temps | ``@.Statements. ``@object not]'				"-&gt;"	'``@collection reject: [:`each | | `@temps | ``@.Statements. ``@object]')			#('``@collection reject: [:`each | | `@temps | ``@.Statements. ``@object not]'				"-&gt;"	'``@collection select: [:`each | | `@temps | ``@.Statements. ``@object]')			#('[| `@temps | ``@.Statements. ``@object not] whileTrue: ``@block'				"-&gt;"	'[| `@temps | ``@.Statements. ``@object] whileFalse: ``@block')			#('[| `@temps | ``@.Statements. ``@object not] whileFalse: ``@block'				"-&gt;"	'[| `@temps | ``@.Statements. ``@object] whileTrue: ``@block')			#('[| `@temps | ``@.Statements. ``@object not] whileTrue'				"-&gt;"	'[| `@temps | ``@.Statements. ``@object] whileFalse')			#('[| `@temps | ``@.Statements. ``@object not] whileFalse'				"-&gt;"	'[| `@temps | ``@.Statements. ``@object] whileTrue')			#('(``@a &lt;= ``@b) not' "-&gt;" '``@a &gt; ``@b')			#('(``@a &lt; ``@b) not' "-&gt;" '``@a &gt;= ``@b')			#('(``@a = ``@b) not' "-&gt;" '``@a ~= ``@b')			#('(``@a == ``@b) not' "-&gt;" '``@a ~~ ``@b')			#('(``@a ~= ``@b) not' "-&gt;" '``@a = ``@b')			#('(``@a ~~ ``@b) not' "-&gt;" '``@a == ``@b')			#('(``@a &gt;= ``@b) not' "-&gt;" '``@a &lt; ``@b')			#('(``@a &gt; ``@b) not' "-&gt;" '``@a &lt;= ``@b'))					methods: false		name: (#EliminateUnnecessaryNots &lt;&lt; #browser &gt;&gt; 'Eliminate unnecessary not''s') asString</body><body package="Browser-Smalllint">showWhileBlocks	^self		rewrite: #(			#('``@cursor showWhile: [| `@temps | ``@.Statements. `var := ``@object]'				"-&gt;"	'`var := ``@cursor showWhile: [| `@temps | ``@.Statements. ``@object]') 			#('``@cursor showWhile: [| `@temps | ``@.Statements. ^``@object]'				"-&gt;"	'^``@cursor showWhile: [| `@temps | ``@.Statements. ``@object]'))		methods: false		name: (#MoveAssignmentOutOfShowWhile &lt;&lt; #browser &gt;&gt; 'Move assignment out of showWhile: blocks') asString</body><body package="Browser-Smalllint">streamLiterals	^self rewrite: #(			#('`#l `{:node | 				node parent isMessage and: 						[node parent selector = #writeStream or: 								[node parent selector = #on: and: 										[node parent receiver = (RBVariableNode named: ''WriteStream'') 											or: [node parent receiver = (RBVariableNode named: ''ReadWriteStream'')]]]]}'			"-&gt;"			'`{`#l value isEmpty 					ifTrue: 						[RBMessageNode 							receiver: (RBVariableNode named: (`#l value = '''' 											ifTrue: [''String'']											ifFalse: [`#l value class name asString]))							selector: #new]					ifFalse: [RBMessageNode receiver: `#l copy selector: #copy]}'))		methods: false		name: (#DoNotUseWriteStreamsOnLiterals &lt;&lt; #browser &gt;&gt; 'Convert write streams on literals to be write streams on non-literals') asString</body><body package="Browser-Smalllint">superSends	^(self new)		name: (#RewriteSuperMessagesToSelf &lt;&lt; #browser &gt;&gt; 'Rewrite super messages to self messages when both refer to same method') asString;		superSends;		yourself</body><body package="Browser-Smalllint">unwindBlocks	^self		rewrite: #(			#('[| `@temps | ``@.Statements. `var := ``@object] valueNowOrOnUnwindDo: ``@block'				"-&gt;"	'`var := [| `@temps | ``@.Statements. ``@object] valueNowOrOnUnwindDo: ``@block') 			#('[| `@temps | ``@.Statements. ^``@object] valueNowOrOnUnwindDo: ``@block'				"-&gt;"	'^[| `@temps | ``@.Statements. ``@object] valueNowOrOnUnwindDo: ``@block') 			#('[| `@temps | ``@.Statements. `var := ``@object] valueOnUnwindDo: ``@block'				"-&gt;"	'`var := [| `@temps | ``@.Statements. ``@object] valueOnUnwindDo: ``@block') 			#('[| `@temps | ``@.Statements. ^``@object] valueOnUnwindDo: ``@block'				"-&gt;"	'^[| `@temps | ``@.Statements. ``@object] valueOnUnwindDo: ``@block')			#('[| `@temps | ``@.Statements. `var := ``@object] ensure: ``@block'				"-&gt;"	'`var := [| `@temps | ``@.Statements. ``@object] ensure: ``@block') 			#('[| `@temps | ``@.Statements. ^``@object] ensure: ``@block'				"-&gt;"	'^[| `@temps | ``@.Statements. ``@object] ensure: ``@block') 			#('[| `@temps | ``@.Statements. `var := ``@object] ifCurtailed: ``@block'				"-&gt;"	'`var := [| `@temps | ``@.Statements. ``@object] ifCurtailed: ``@block') 			#('[| `@temps | ``@.Statements. ^``@object] ifCurtailed: ``@block'				"-&gt;"	'^[| `@temps | ``@.Statements. ``@object] ifCurtailed: ``@block'))		methods: false		name: (#MoveAssignmentOutOfEnsure &lt;&lt; #browser &gt;&gt; 'Move assignment out of ensure: blocks') asString</body></methods><methods><class-id>Refactory.Browser.ParseTreeTransformationRule class</class-id> <category>accessing</category><body package="Browser-Smalllint">initializeRecursiveSelfRule	RecursiveSelfRule := ParseTreeSearcher new.	RecursiveSelfRule 		matchesAnyMethodOf: 			#('`@methodName: `@args | `@temps | self `@methodName: `@args1' 			'`@methodName: `@args | `@temps | ^self `@methodName: `@args1')		do: [:aNode :answer | true].	^RecursiveSelfRule</body><body package="Browser-Smalllint">recursiveSelfRule	^RecursiveSelfRule isNil 		ifTrue: [self initializeRecursiveSelfRule]		ifFalse: [RecursiveSelfRule]</body></methods><methods><class-id>Refactory.Browser.ParseTreeTransformationRule class</class-id> <category>instance creation</category><body package="Browser-Smalllint">rewrite: stringArrays methods: aBoolean name: aName 	| rewriteRule |	rewriteRule := ParseTreeRewriter new.	stringArrays do: 			[:each | 			aBoolean 				ifTrue: [rewriteRule replaceMethod: each first with: each last]				ifFalse: [rewriteRule replace: each first with: each last]].	^(self new)		name: aName;		rewriteUsing: rewriteRule;		yourself</body></methods><methods><class-id>Refactory.Browser.SubclassResponsibilityEnvironment</class-id> <category>testing</category><body package="Browser-Smalllint">useProtocolNavigator	^true</body></methods><methods><class-id>Refactory.Browser.SubclassResponsibilityEnvironment</class-id> <category>accessing</category><body package="Browser-Smalllint">methodDefinitions	| defs |	defs := OrderedCollection new.	self classesDo: 			[:class | 			(self privateSelectorsForClass: class) do: 					[:sel | 					| impClass |					impClass := class whichClassIncludesSelector: sel.					impClass notNil 						ifTrue: 							[defs add: (MethodDefinition 										class: class										implementor: impClass										selector: sel)]]].	^defs</body></methods><methods><class-id>Refactory.Browser.CompositeLintRule</class-id> <category>accessing</category><body package="Browser-Smalllint">checkClass: aSmalllintContext 	rules do: 			[:each | 			each checkClass: aSmalllintContext.			Processor yield]</body><body package="Browser-Smalllint">checkMethod: aSmalllintContext 	rules do: 			[:each | 			each checkMethod: aSmalllintContext.			Processor yield]</body><body package="Browser-Smalllint">failedRules	^rules inject: OrderedCollection new		into: 			[:sum :each | 			sum				addAll: each failedRules;				yourself]</body><body package="Browser-Smalllint">problemCount	^rules inject: 0 into: [:count :each | count + each problemCount]</body><body package="Browser-Smalllint">rules	^rules</body></methods><methods><class-id>Refactory.Browser.CompositeLintRule</class-id> <category>testing</category><body package="Browser-Smalllint">hasConflicts	^rules anySatisfy: [:each | each hasConflicts]</body><body package="Browser-Smalllint">isComposite	^true</body><body package="Browser-Smalllint">isEmpty	^rules allSatisfy: [:each | each isEmpty]</body></methods><methods><class-id>Refactory.Browser.CompositeLintRule</class-id> <category>initialize-release</category><body package="Browser-Smalllint">initialize	super initialize.	rules := #()</body><body package="Browser-Smalllint">resetResult	rules do: [:each | each resetResult]</body><body package="Browser-Smalllint">rules: aCollection	rules := aCollection</body></methods><methods><class-id>Refactory.Browser.CompositeLintRule</class-id> <category>copying</category><body package="Browser-Smalllint">postCopy	super postCopy.	rules := rules collect: #copy</body></methods><methods><class-id>Refactory.Browser.CompositeLintRule class</class-id> <category>instance creation</category><body package="Browser-Smalllint">allRules	^self ruleFor: self protocol: 'all checks'</body><body package="Browser-Smalllint">ruleFor: aClass protocol: aProtocol 	| allRules prot label |	aProtocol isString		ifTrue:			[prot := aProtocol.			label := aProtocol asString copy.			label at: 1 put: label first asUppercase]		ifFalse:			[prot := aProtocol value.			label := aProtocol key].	allRules := aClass withAllSubclasses inject: OrderedCollection new				into: 					[:sum :each | 					sum						addAll: ((BrowserEnvironment new selectorsFor: prot asSymbol									in: each class) collect: [:selector | each perform: selector]);						yourself].	^self rules: (allRules asSortedCollection: [:a :b | a name &lt; b name])		name: label</body><body package="Browser-Smalllint">rules: aCollection 	^(self new)		rules: aCollection;		yourself</body><body package="Browser-Smalllint">rules: aCollection name: aString 	^(self new)		rules: aCollection;		name: aString;		yourself</body></methods><methods><class-id>Refactory.Browser.CompositeLintRule class</class-id> <category>all checks</category><body package="Browser-Smalllint">lintChecks	^self rules: (BasicLintRule protocols				collect: [:each | self ruleFor: BasicLintRule protocol: each])		name: (#CodeCriticChecks &lt;&lt; #browser &gt;&gt; 'Code Critic Checks') asString</body><body package="Browser-Smalllint">transformations	^self ruleFor: TransformationRule protocol: 'transformations'</body></methods><methods><class-id>Refactory.Browser.ParseTreeEnvironment</class-id> <category>initialize-release</category><body package="Browser-Smalllint">matcher: aParseTreeSearcher	matcher := aParseTreeSearcher</body></methods><methods><class-id>Refactory.Browser.BlockLintRule</class-id> <category>accessing</category><body package="Browser-Smalllint">checkClass: aSmalllintContext 	^classBlock value: aSmalllintContext value: result</body><body package="Browser-Smalllint">checkMethod: aSmalllintContext 	^methodBlock value: aSmalllintContext value: result</body></methods><methods><class-id>Refactory.Browser.BlockLintRule</class-id> <category>initialize-release</category><body package="Browser-Smalllint">classBlock: aBlock	classBlock := aBlock</body><body package="Browser-Smalllint">initialize	super initialize.	classBlock := [:context :aResult | ].	methodBlock := [:context :aResult | ]</body><body package="Browser-Smalllint">methodBlock: aBlock	methodBlock := aBlock</body></methods><methods><class-id>Refactory.Browser.BlockLintRule class</class-id> <category>possible bugs</category><body package="Browser-Smalllint">abstractClass	| detector subclassResponsibilitySymbol |	detector := self new.	detector name: (#ReferencesAnAbstractClass &lt;&lt; #browser &gt;&gt; 'References an abstract class') asString.	detector resultClass: ClassEnvironment.	subclassResponsibilitySymbol := 'subclassResponsibility' asSymbol.	detector classBlock: 			[:context :result | 			(context selectedClass whichSelectorsReferTo: subclassResponsibilitySymbol) 				notEmpty 					ifTrue: 						[(context uses: context selectedClass) 							ifTrue: [result addClass: context selectedClass]]].	^detector</body><body package="Browser-Smalllint">addRemoveDependents	| detector |	detector := self new.	detector resultClass: ClassEnvironment.	detector name: (#AddRemoveDependentMessageMismatch &lt;&lt; #browser &gt;&gt; 'Number of addDependent: messages &gt; removeDependent:') asString.	detector classBlock: 			[:context :result | 			| count |			count := 0.			((Set 				withAll: (context selectedClass whichSelectorsReferTo: #addDependent:))				addAll: (context selectedClass whichSelectorsReferTo: #removeDependent:);				yourself) do: 						[:sel | 						(context selectedClass compiledMethodAt: sel) messagesDo: 								[:each | 								each == #addDependent: ifTrue: [count := count + 1].								each == #removeDependent: ifTrue: [count := count - 1]]].			count &gt; 0 ifTrue: [result addClass: context selectedClass]].	^detector</body><body package="Browser-Smalllint">classInstVarNotInitialized	| detector |	detector := self new.	detector name: (#HasClassInstVarButNoInitialize &lt;&lt; #browser &gt;&gt; 'Has class instance variables but no initialize method') asString.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			context selectedClass isMeta 				ifTrue: 					[(context selectedClass instVarNames notEmpty 						and: [(context selectedClass includesSelector: #initialize) not]) 							ifTrue: [result addClass: context selectedClass]]].	^detector</body><body package="Browser-Smalllint">collectionCopyEmpty	| detector |	detector := self new.	detector 		name: (#SubclassDoesNotDefineCopyEmpty &lt;&lt; #browser &gt;&gt; 'Subclass of collection that has instance variable but doesn''t define copyEmpty') asString.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			(context selectedClass isVariable and: 					[(context selectedClass includesSelector: #copyEmpty:) not and: 							[context selectedClass instVarNames notEmpty 								and: [context selectedClass inheritsFrom: Collection]]]) 				ifTrue: [result addClass: context selectedClass]].	^detector</body><body package="Browser-Smalllint">definesEqualNotHash	| detector |	detector := self new.	detector name: (#DefinesEqButNotHash &lt;&lt; #browser &gt;&gt; 'Defines = but not hash') asString.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			((context selectedClass includesSelector: #=) 				and: [(context selectedClass includesSelector: #hash) not]) 					ifTrue: [result addClass: context selectedClass]].	^detector</body><body package="Browser-Smalllint">literalArrayContainsComma	| detector |	detector := self new.	detector name: (#LiteralArrayContainsComma &lt;&lt; #browser &gt;&gt; 'Literal array contains a #,') asString.	detector methodBlock: 			[:context :result | 			(context compiledMethod allLiterals 				anySatisfy: [:each | self doesLiteralArrayContainComma: each]) 					ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector</body><body package="Browser-Smalllint">refersToClass	| detector |	detector := self new.	detector name: (#RefersToClassName &lt;&lt; #browser &gt;&gt; 'Refers to class name instead of "self class"') asString.	detector classBlock: 			[:context :result | 			| sels className nonMeta |			className := context selectedClass instanceBehavior name.			nonMeta := context selectedClass instanceBehavior.			sels := context selectedClass 						whichSelectorsReferTo: (nonMeta environment bindingFor: nonMeta name).			sels do: [:each | result addClass: context selectedClass selector: each.					result addSearchString: className forClass: context selectedClass selector: each]].	^detector</body><body package="Browser-Smalllint">returnsBooleanAndOther	| detector matcher |	detector := self new.	detector name: (#ReturnsABooleanAndNot &lt;&lt; #browser &gt;&gt; 'Returns a boolean and non boolean') asString.	matcher := ParseTreeSearcher new.	matcher matches: '^``@xObject'		do: 			[:aNode :answer | 			answer				add: aNode value;				yourself].	detector methodBlock: 			[:context :result | 			| hasBool hasSelf |			hasBool := false.			hasSelf := context parseTree lastIsReturn not.			(matcher executeTree: context parseTree initialAnswer: Set new) do: 					[:each | 					hasBool := hasBool or: 									[(each isLiteralNode and: [#(true false) includes: each value]) 										or: [each isMessage and: [#(#and: #or:) includes: each selector]]].					hasSelf := hasSelf or: 									[(each isVariable and: [each name = 'self']) 										or: [each isLiteralNode and: [(#(true false) includes: each value) not]]]].			hasSelf &amp; hasBool 				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector</body><body package="Browser-Smalllint">sendsDifferentSuper	| detector |	detector := self new.	detector name: (#SendsDifferentSuperMessage &lt;&lt; #browser &gt;&gt; 'Sends different super message') asString.	detector methodBlock: 			[:context :result | 			| message |			(message := context superMessages 						detect: [:each | each ~= context selector]						ifNone: [nil]) notNil 				ifTrue: 					[result addSearchString: message forClass: context selectedClass selector: context selector.					result addClass: context selectedClass selector: context selector]].	^detector</body><body package="Browser-Smalllint">superSends	| detector |	detector := self new.	detector name: (#MissingSuperSends &lt;&lt; #browser &gt;&gt; 'Missing super sends') asString.	detector methodBlock: 			[:context :result | 			(context selectedClass isMeta not 				and: [self superMessages includes: context selector]) 					ifTrue: 						[(context selectedClass superclass notNil 							and: [context selectedClass superclass canUnderstand: context selector]) 								ifTrue: 									[(context superMessages includes: context selector) 										ifFalse: [result addClass: context selectedClass selector: context selector]]]].	^detector</body><body package="Browser-Smalllint">tempsReadBeforeWritten	| detector |	detector := self new.	detector name: (#TempsReadBeforeWritten &lt;&lt; #browser &gt;&gt; 'Temporaries read before written') asString.	detector methodBlock: 			[:context :result | 			(RBReadBeforeWrittenTester variablesReadBeforeWrittenIn: context parseTree) 				do: 					[:each | 					result addClass: context selectedClass selector: context selector.					result addSearchString: each forClass: context selectedClass selector: context selector]].	^detector</body><body package="Browser-Smalllint">tempVarOverridesInstVar	| detector matcher vars varName |	detector := self new.	detector name: (#InstVarOverriddenByTemp &lt;&lt; #browser &gt;&gt; 'Instance variable overridden by temporary variable') asString.	matcher := (ParseTreeSearcher new)				matchesArgument: '`xxxvar'					do: 						[:aNode :answer | 						answer or: 								[varName := aNode name.								vars includes: varName]];				yourself.	detector methodBlock: 			[:context :result | 			vars := context instVarNames.			(matcher executeTree: context parseTree initialAnswer: false) 				ifTrue: 					[result addClass: context selectedClass selector: context selector.					result addSearchString: varName forClass: context selectedClass selector: context selector]].	^detector</body><body package="Browser-Smalllint">usesTrue	| detector trueBinding falseBinding |	detector := self new.	trueBinding := self environment bindingFor: #True.	falseBinding := self environment bindingFor: #False.	detector name: (#UsesBooleanClasses &lt;&lt; #browser &gt;&gt; 'Uses True/False instead of true/false') asString.	detector methodBlock: 			[:context :result | 			| method |			method := context compiledMethod.			((method refersToLiteral: trueBinding) 				or: [method refersToLiteral: falseBinding]) 					ifTrue: 						[result addClass: context selectedClass selector: context selector.						result searchStrings: #('True' 'False')]].	^detector</body><body package="Browser-Smalllint">variableNotDefined	| detector |	detector := self new.	detector name: (#VarUsedButNotDefined &lt;&lt; #browser &gt;&gt; 'Variable used, but not defined anywhere') asString.	detector methodBlock: 			[:context :result | 			context compiledMethod withAllBlockMethodsDo: 					[:each | 					each literalsDo: 							[:lit | 							| binding |							lit isVariableBinding 								ifTrue: 									[(((binding := context selectedClass bindingFor: lit key) notNil 										and: [binding binding == lit binding]) or: 												[((binding := context selectedClass environment bindingFor: lit key) notNil 													and: [binding binding == lit binding]) or: 															[(binding := Undeclared bindingFor: lit key) notNil 																and: [binding binding == lit binding]]]) 										ifFalse: 											[result addClass: context selectedClass selector: context selector.											result addSearchString: lit key forClass: context selectedClass selector: context selector]]]]].	^detector</body></methods><methods><class-id>Refactory.Browser.BlockLintRule class</class-id> <category>unnecessary code</category><body package="Browser-Smalllint">classNotReferenced	| detector |	detector := self new.	detector name: (#ClassNotReferenced &lt;&lt; #browser &gt;&gt; 'Class not referenced') asString.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			(context selectedClass isMeta 				or: [context selectedClass subclasses notEmpty]) 					ifFalse: 						[((context uses: context selectedClass) 							or: [context uses: context selectedClass name]) 								ifFalse: 									[result										addClass: context selectedClass;										addClass: context selectedClass class]]].	^detector</body><body package="Browser-Smalllint">equivalentSuperclassMethods	| detector |	detector := self new.	detector name: (#IdenticalMethodsInSuperclass &lt;&lt; #browser &gt;&gt; 'Methods equivalently defined in superclass') asString.	detector methodBlock: 			[:context :result | 			context selectedClass superclass notNil 				ifTrue: 					[(context selectedClass superclass canUnderstand: context selector) 						ifTrue: 							[(((context selectedClass superclass 								whichClassIncludesSelector: context selector) 									compiledMethodAt: context selector) equivalentTo: context compiledMethod) 								ifTrue: [result addClass: context selectedClass selector: context selector]]]].	^detector</body><body package="Browser-Smalllint">implementedNotSent	| detector |	detector := self new.	detector		name: (#MethodsImpButNotSent &lt;&lt; #browser				&gt;&gt; 'Methods implemented but not sent') asString.	detector methodBlock: 			[:context :result |			(context uses: context selector)				ifFalse: [result addClass: context selectedClass selector: context selector]].	^detector</body><body package="Browser-Smalllint">instVarInSubclasses	| detector |	detector := self new.	detector		name: (#InstVarsInAllSubclasses &lt;&lt; #browser &gt;&gt; 'Instance variables defined in all subclasses') asString;		resultClass: VariableEnvironment;		openUsing: #openWithoutFilters.	detector classBlock: 			[:context :result | 			| subs |			subs := context selectedClass subclasses.			subs size &gt; 1 				ifTrue: 					[| sels |					sels := Bag new.					subs do: [:each | sels addAll: each instVarNames].					sels asSet do: 							[:val | 							| count |							count := sels occurrencesOf: val.							count == subs size 								ifTrue: [result addClass: context selectedClass instanceVariable: val]]]].	^detector</body><body package="Browser-Smalllint">justSendsSuper	| detector matcher |	detector := self new.	detector name: (#MethodJustSendsSuper &lt;&lt; #browser &gt;&gt; 'Method just sends super message') asString.	matcher := ParseTreeSearcher justSendsSuper.	detector methodBlock: 			[:context :result | 			((context parseTree isPrimitive not 				and: [matcher executeMethod: context parseTree initialAnswer: false])					and: [context parseTree tags isEmpty]) 					ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector</body><body package="Browser-Smalllint">onlyReadOrWritten	| detector |	detector := self new.	detector		name: (#InstVarOnlyReadOrWritten &lt;&lt; #browser &gt;&gt; 'Instance variables not read AND written') asString;		resultClass: VariableEnvironment;		openUsing: #openWithoutFilters.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					| isRead isWritten |					isRead := false.					isWritten := false.					allSubclasses detect: 							[:class | 							isRead ifFalse: [isRead := (class whichSelectorsRead: each) notEmpty].							isWritten 								ifFalse: [isWritten := (class whichSelectorsAssign: each) notEmpty].							isRead &amp; isWritten]						ifNone: [result addClass: context selectedClass instanceVariable: each]]].	^detector</body><body package="Browser-Smalllint">unreferencedVariables	| detector |	detector := self new.	detector		name: (#InstVarNotReferenced &lt;&lt; #browser &gt;&gt; 'Instance variables not referenced') asString;		resultClass: VariableEnvironment;		openUsing: #openWithoutFilters.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					allSubclasses 						detect: [:class | (class whichSelectorsAccess: each) notEmpty]						ifNone: [result addClass: context selectedClass instanceVariable: each]]].	^detector</body><body package="Browser-Smalllint">variableAssignedLiteral	| detector |	detector := self new.	detector		name: (#VariableAssignedSingleLiteral &lt;&lt; #browser &gt;&gt; 'Variable is only assigned a single literal value') asString;		resultClass: VariableEnvironment;		openUsing: #openWithoutFilters.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					| defClass selector |					(allSubclasses inject: 0						into: 							[:sum :class | 							| sels |							sels := class whichSelectorsAssign: each.							sels size == 1 								ifTrue: 									[selector := sels asArray first.									defClass := class].							sum + sels size]) 							== 1 							ifTrue: 								[| tree searcher |								searcher := ParseTreeSearcher new.								searcher matches: each , ' := ``@object'									do: [:aNode :answer | answer isNil and: [aNode value isLiteralNode]].								tree := defClass parseTreeFor: selector.								tree notNil 									ifTrue: 										[(searcher executeTree: tree initialAnswer: nil) == true 											ifTrue: [result addClass: context selectedClass instanceVariable: each]]]]].	^detector</body><body package="Browser-Smalllint">variableReferencedOnce	| detector |	detector := self new.	detector 		name: (#InstVarReferencedOnced &lt;&lt; #browser &gt;&gt; 'Variable referenced in only one method and always assigned first') asString.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					| defClass selector |					(allSubclasses inject: 0						into: 							[:sum :class | 							| sels |							sels := class whichSelectorsAccess: each.							sels size == 1 								ifTrue: 									[selector := sels asArray first.									defClass := class].							sum + sels size]) 							== 1 							ifTrue: 								[| tree |								tree := defClass parseTreeFor: selector.								tree notNil 									ifTrue: 										[(RBReadBeforeWrittenTester isVariable: each writtenBeforeReadIn: tree) 											ifTrue: 												[result addClass: defClass selector: selector.												result addSearchString: each forClass: defClass selector: selector]]]]].	^detector</body></methods><methods><class-id>Refactory.Browser.BlockLintRule class</class-id> <category>private</category><body package="Browser-Smalllint">badSelectors	^#(#become: #isKindOf: #changeClassTo: #changeClassToThatOf: #respondsTo: #isMemberOf: #performMethod: #performMethod:arguments: #performMethod:with: #performMethod:with:with: #performMethod:with:with:with: #allOwners #allOwnersWeakly: #firstOwner #instVarAt: #instVarAt:put: #nextInstance #nextObject #ownerAfter: #primBecome: #halt)</body><body package="Browser-Smalllint">classShouldNotOverride	^#(#== #class)</body><body package="Browser-Smalllint">doesLiteralArrayContainComma: aLiteral 	aLiteral class == Array ifFalse: [^false].	(aLiteral includes: #,) ifTrue: [^true].	^aLiteral anySatisfy: [:each | self doesLiteralArrayContainComma: each]</body><body package="Browser-Smalllint">longMethodSize	^10</body><body package="Browser-Smalllint">metaclassShouldNotOverride	^#(#name #comment)</body><body package="Browser-Smalllint">subclassOf: aClass overrides: aSelector 	^aClass subclasses anySatisfy: 			[:each | 			(each includesSelector: aSelector) 				or: [self subclassOf: each overrides: aSelector]]</body><body package="Browser-Smalllint">superMessages	^#(#release #postCopy #postBuildWith: #preBuildWith: #postOpenWith: #noticeOfWindowClose: #initialize #obsolete)</body><body package="Browser-Smalllint">utilityProtocols	"If a method is defined in one of these protocols, then don't check if its a utility method."	^#('*utilit*')</body></methods><methods><class-id>Refactory.Browser.BlockLintRule class</class-id> <category>intention revealing</category><body package="Browser-Smalllint">classNameInSelector	| detector |	detector := self new.	detector name: (#RedundantClassName &lt;&lt; #browser &gt;&gt; 'Redundant class name in selector') asString.	detector methodBlock: 			[:context :result | 			(context selectedClass isMeta and: 					[(context selector 						indexOfSubCollection: context selectedClass instanceBehavior name						startingAt: 1) &gt; 0]) 				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector</body><body package="Browser-Smalllint">missingSubclassResponsibility	| detector |	detector := self new.	detector		name: (#MethodDefinedInSubsButNotSupers &lt;&lt; #browser &gt;&gt; 'Method defined in all subclasses, but not in superclass') asString;		resultClass: MultiEnvironment;		openUsing: #openWithoutFilters.	detector classBlock: 			[:context :result | 			| subs |			subs := context selectedClass subclasses.			subs size &gt; 1 &amp; context selectedClass isMeta not 				ifTrue: 					[| sels |					sels := Bag new.					subs do: [:each | sels addAll: each selectors].					sels asSet do: 							[:each | 							((sels occurrencesOf: each) == subs size 								and: [(context selectedClass canUnderstand: each) not]) 									ifTrue: 										[| envName |										envName := context selectedClass name , '&gt;&gt;' , each.										subs do: 												[:subClass | 												result 													addClass: subClass													selector: each													into: envName]]]]].	^detector</body></methods><methods><class-id>Refactory.Browser.BlockLintRule class</class-id> <category>bugs</category><body package="Browser-Smalllint">overridesSpecialMessage	| detector |	detector := self new.	detector name: (#OverridesASpecialMessage &lt;&lt; #browser &gt;&gt; 'Overrides a "special" message') asString.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			((context selectedClass isMeta 				ifTrue: [self metaclassShouldNotOverride]				ifFalse: [self classShouldNotOverride]) anySatisfy: 						[:each | 						context selectedClass superclass notNil and: 								[(context selectedClass superclass canUnderstand: each) 									and: [context selectedClass includesSelector: each]]]) 				ifTrue: [result addClass: context selectedClass]].	^detector</body><body package="Browser-Smalllint">sentNotImplemented	| detector |	detector := self new.	detector name: (#MessagesSentButNotImplemented &lt;&lt; #browser &gt;&gt; 'Messages sent but not implemented') asString.	detector methodBlock: 			[:context :result | 			| message |			message := context messages 						detect: [:each | (context implements: each) not]						ifNone: [nil].			message isNil 				ifTrue: 					[message := context superMessages detect: 									[:each | 									context selectedClass superclass isNil 										or: [(context selectedClass superclass canUnderstand: each) not]]								ifNone: [nil].					message isNil 						ifTrue: 							[message := context selfMessages 										detect: [:each | (context selectedClass canUnderstand: each) not]										ifNone: [nil]]].			message notNil 				ifTrue: 					[result addSearchString: message forClass: context selectedClass selector: context selector.					result addClass: context selectedClass selector: context selector]].	^detector</body><body package="Browser-Smalllint">subclassResponsibilityNotDefined	| detector subclassResponsibilitySymbol |	detector := self new.	detector		name: (#NoSubclassResponsibility &lt;&lt; #browser &gt;&gt; 'Subclass responsibility not defined') asString;		resultClass: SubclassResponsibilityEnvironment;		openUsing: #openWithoutFilters.	subclassResponsibilitySymbol := CompiledCode 				specialSelectorIndexFor: #subclassResponsibility.	detector classBlock: 			[:context :result | 			context selectedClass subclasses isEmpty 				ifTrue: 					[context selectedClass allSelectors do: 							[:each | 							| impClass |							impClass := context selectedClass whichClassIncludesSelector: each.							((impClass compiledMethodAt: each) 								sendsSpecialSelector: subclassResponsibilitySymbol) 									ifTrue: [result addClass: context selectedClass selector: each]]]].	^detector</body><body package="Browser-Smalllint">undeclaredReference	| detector |	detector := self new.	detector name: (#ReferencesUndeclaredVariable &lt;&lt; #browser &gt;&gt; 'References an undeclared variable') asString.	detector methodBlock: 			[:context :result | 			| undeclared |			undeclared := Smalltalk.Undeclared localBindings detect: 							[:each | 							(context uses: each) and: [context compiledMethod refersToLiteral: each]]						ifNone: [nil].			undeclared notNil 				ifTrue: 					[result addSearchString: undeclared key forClass: context selectedClass selector: context selector.					result addClass: context selectedClass selector: context selector]].	^detector</body></methods><methods><class-id>Refactory.Browser.BlockLintRule class</class-id> <category>deprecated</category><body package="Browser-Smalllint">badMessage	| detector badMessages |	detector := self new.	detector name: (#SendsQuestionableMessage &lt;&lt; #browser &gt;&gt; 'Sends "questionable" message') asString.	badMessages := self badSelectors.	detector classBlock: 			[:context :result | 			| selectors |			selectors := badMessages inject: Set new						into: 							[:set :each | 							set								addAll: (context selectedClass whichSelectorsReferTo: each);								yourself].			selectors 				do: [:each | result addClass: context selectedClass selector: each].			selectors notEmpty ifTrue: [result searchStrings: badMessages]].	^detector</body><body package="Browser-Smalllint">collectionMessagesToExternalObject	| detector matcher smalllintContext |	detector := self new.	detector name: (#SendsAddRemoveToExternalCollection &lt;&lt; #browser &gt;&gt; 'Sends add:/remove: to external collection') asString.	matcher := ParseTreeSearcher new.	matcher 		matchesAnyOf: (#(#add: #remove: #addAll: #removeAll:) collect: 					[:each | 					('(`@Object `@message: `@args) &lt;1s&gt; `@Arg' expandMacrosWith: each) 						asString])		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[((aNode receiver selector copyFrom: 1						to: (aNode receiver selector size min: 2)) ~= 'as' 						and: 							[| receiver |							receiver := aNode receiver receiver.							receiver isVariable not or: 									[((#('self' 'super') includes: receiver name) or: 											[(smalllintContext selectedClass environment 												bindingFor: receiver name asSymbol) notNil]) 										not]]) 							ifTrue: [aNode]							ifFalse: [nil]]				ifFalse: [answer]].	detector methodBlock: 			[:context :result | 			smalllintContext := context.			((matcher canMatchMethod: context compiledMethod) 				and: [(matcher executeTree: context parseTree initialAnswer: nil) notNil]) 					ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector</body><body package="Browser-Smalllint">fullBlocks	| detector |	detector := self new.	detector name: (#MethodWithFullBlocks &lt;&lt; #browser &gt;&gt; 'Method with full blocks') asString.	detector methodBlock: 			[:context :result | 			context compiledMethod withAllBlockMethodsDo: 					[:method | 					method needsHybridFrame						ifTrue: [result addClass: context selectedClass selector: context selector]]].	^detector</body><body package="Browser-Smalllint">longMethods	| detector matcher |	detector := self new.	detector name: (#LongMethods &lt;&lt; #browser &gt;&gt; 'Long methods') asString.	matcher := ParseTreeSearcher new.	matcher matches: '`.Stmt'		do: 			[:aNode :answer | 			(aNode children inject: answer				into: [:sum :each | matcher executeTree: each initialAnswer: sum]) + 1].	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: 0) 				&gt;= self longMethodSize 					ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector</body><body package="Browser-Smalllint">utilityMethods	| detector |	detector := self new.	detector name: (#UtilityMethods &lt;&lt; #browser &gt;&gt; 'Utility methods') asString.	detector methodBlock: 			[:context :result | 			(context selectedClass isMeta | (context selector numArgs == 0) or: 					[context protocols anySatisfy: 							[:each | 							self utilityProtocols anySatisfy: [:protocol | protocol match: each]]]) 				ifFalse: 					[(self subclassOf: context selectedClass overrides: context selector) 						ifFalse: 							[(context superMessages isEmpty and: [context selfMessages isEmpty]) 								ifTrue: 									[(context parseTree isPrimitive or: 											[(context selectedClass allInstVarNames 												, context selectedClass allClassVarNames asArray) , #('self') 												anySatisfy: [:each | context parseTree references: each]]) 										ifFalse: [result addClass: context selectedClass selector: context selector]]]]].	^detector</body></methods><methods><class-id>Core.VariableBinding</class-id> <category>RefactoringBrowser</category><body package="Browser-Smalllint">nonDeferredBinding	^self</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>RefactoringBrowser</category><body package="Browser-Smalllint">equivalentTo: aCompiledMethod 	^self = aCompiledMethod or: 		[self numArgs == aCompiledMethod numArgs and: 			[| selfParseTree methodParseTree |			selfParseTree := mclass decompilerClass new 				decompile: (mclass defaultSelectorForMethod: self)				in: mclass				method: self.			methodParseTree := aCompiledMethod mclass decompilerClass new 				decompile: (aCompiledMethod mclass defaultSelectorForMethod: aCompiledMethod)				in: aCompiledMethod mclass				method: aCompiledMethod.			selfParseTree printString = methodParseTree printString]]</body></methods><methods><class-id>Refactory.Browser.AndEnvironment</class-id> <category>accessing</category><body package="Browser-Smalllint">problemCount	^environment isClassEnvironment 		ifTrue: [self numberClasses]		ifFalse: [super problemCount]</body></methods><methods><class-id>Refactory.Browser.ClassEnvironment</class-id> <category>accessing</category><body package="Browser-Smalllint">problemCount	^self numberClasses</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironment</class-id> <category>testing</category><body package="Browser-Smalllint">isForSmalllint	^false</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironment</class-id> <category>accessing</category><body package="Browser-Smalllint">problemCount	^self numberSelectors</body></methods><methods><class-id>Refactory.Browser.VariableEnvironment</class-id> <category>accessing</category><body package="Browser-Smalllint">problemCount	^self numberVariables</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoryChange</class-id> <category>accessing</category><body package="Browser-Smalllint">problemCount	^self changesSize</body></methods><methods><class-id>Kernel.DeferredBinding</class-id> <category>RefactoringBrowser</category><body package="Browser-Smalllint">nonDeferredBinding	| binding |	binding := method mclass bindingFor: key.	binding isNil ifTrue: [binding := method environment bindingFor: key].	^binding</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>DeferredBinding</name><environment>Kernel</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key resolved resolvedValue method </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>BrowserEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractBrowserEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><class><name>BrowserEnvironmentWrapper</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><class><name>VariableEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables instanceVariableReaders instanceVariableWriters selectorCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><class><name>ClassEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceBehaviorNames classBehaviorNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>SelectorEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classSelectors metaClassSelectors initializers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><class><name>VariableBinding</name><environment>Core</environment><super>Core.LookupKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value usage category environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>CompositeRefactoryChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>changes undoSingle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><class><name>AndEnvironment</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironmentWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>andedEnvironment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class></st-source>