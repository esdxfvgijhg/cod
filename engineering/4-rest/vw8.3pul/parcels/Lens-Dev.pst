<?xml version="1.0"?><st-source><!-- Name: Lens-DevNotice: Copyright 2008-2014 Cincom Systems, Inc.  All rights reserved.Comment: The Lens provides high-level facilities that simplify the task of database access. The Lens data modeler provides a mechanism for mapping table rows and columns to Smalltalk objects, as well as tools for creating and managing the mappings. It provides a runtime environment for handling object persistence in an object-oriented fashion, largely hiding the relational SQL activity underneath. This runtime environment supports object containers, object identity, database proxies, and a sophisticated query capability. The Lens also provides UI designer features that simplify the task of creating a user interface to your database accessing application.This package, Lens-Dev, provides the development tools such as the Data Modeler, the Mapping Tool, the Query Editor.  Along with this package and the appropriate EXDI Lens package one can develop VisualWorks applications that use the Lens.Further information on the EXDI and Lens can be found in the "VisualWorks Database Connect Developer's Guide" (the file dbadg.pdf located in the doc subdirectory of the VisualWorks installation). DbIdentifier: bear73DbTrace: 437366DbUsername: smichaelDbVersion: 8.0 - 2DevelopmentPrerequisites: #(#(#any 'LDM-Framework' '') #(#any 'UIPainter' '') #(#any 'Lens-Runtime' ''))PackageName: Lens-DevParcel: #('Lens-Dev')ParcelName: Lens-DevPrerequisiteParcels: #(#('LDM-Framework' '') #('UIPainter' '') #('Lens-Runtime' ''))PrintStringCache: (8.0 - 2,smichael)Version: 8.0 - 2Pre-Load Block: 	[ :pkg |  ]Post-Load Block: 	[ :pkg |  	(UIPalette activeSpecsList includes: #EmbeddedDetailSpec)	 	ifFalse: [UIPalette activeSpecsList add: #EmbeddedDetailSpec].	(UIPalette activeSpecsList includes: #LinkedDetailSpec)	 	ifFalse: [UIPalette activeSpecsList add: #LinkedDetailSpec].	#{Store.Policies} ifDefinedDo: [:class | class packagePolicy newClassUseCurrent: false].]Pre-Unload Block: 	[ :pkg |  ]Post-Unload Block: 	[UIPalette activeSpecsList remove: #EmbeddedDetailSpec ifAbsent: [].	UIPalette activeSpecsList remove: #LinkedDetailSpec ifAbsent: [].]Date: 3:36:29 PM June 20, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (jun14.3) of June 20, 2014 on June 20, 2014 at 3:36:29 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>LensKeyEditor</name><environment>Lens</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type nonKeyVariables keyVariables message1 message2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Support</category><attributes><package>Lens-Dev</package></attributes></class><comment><class-id>Lens.LensKeyEditor</class-id><body>Since editing the key of a type is required in several places this functionality is coded into this class.To allow the users to add a message to the window, two instance variables, message1 and message2 areprovided, their contents will be shown at the top of the dialog.</body></comment><class><name>LensNamespaceControl</name><environment>Lens</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectedList availableList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Tools</category><attributes><package>Lens-Dev</package></attributes></class><class><name>LensApplicationSpecEditor</name><environment>Lens</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>spec graphView dataModel addtype typesMenu fieldsDict fields there className generator ldmChanged newFields templatesMenuHolder accept subBuilder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Support</category><attributes><package>Lens-Dev</package></attributes></class><class><name>LensApplicationCreationDialog</name><environment>Lens</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>spec dataModel addtype typesMenu generator entities subBuilder lastAppType fixedAppType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Support</category><attributes><package>Lens-Dev</package></attributes></class><class><name>LensEditor</name><environment>Lens</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectedDataModelHolder selectedType ldmView referenceButton toReference generator valueClassesMenu mainMessage mappingEditor typeFilter originalFocusList originalPaintPreferences </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Tools</category><attributes><package>Lens-Dev</package></attributes></class><comment><class-id>Lens.LensEditor</class-id><body>The editor provides tools for modifying a LensDataModel. Most of the real work is done by the LensDataModelGenerator. It uses also two satellites, a LensTablesSelector which shows database tables and allows for creating classes for the tables, and a LensMappingEditor which allows for fine tuning of the type, it's variables and the tables and columns they are mapped to.</body></comment><class><name>LensReferenceNameDialog</name><environment>Lens</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nameSelector toEntity name1 replaced name2 referenceEntities name3 fromEntity </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Support</category><attributes><package>Lens-Dev</package></attributes></class><class><name>LensDFBasicsSliceModel</name><environment>Lens</environment><super>Tools.SpecModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Support</category><attributes><package>Lens-Dev</package></attributes></class><class><name>LensMappingEditor</name><environment>Lens</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>graphView toMap mapButton type selVar selCol columnTypeMenu editor lastType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Support</category><attributes><package>Lens-Dev</package></attributes></class><comment><class-id>Lens.LensMappingEditor</class-id><body>A satellite of the LensEditor to allow fine tuning of types and tables. Provides functionality to add, remove and change variables in the selected type, create and map new tables and create columns for new variables.We use a graphical browser to show the structure of the type and the mapping to the table's columns.The selected type follows whatever is selected in the LensEditor.</body></comment><class><name>LensApplicationSpec</name><environment>Lens</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name kind dataModel rowType fields editPolicy lockPolicy template superclass category appType selector nameSpace </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Support</category><attributes><package>Lens-Dev</package></attributes></class><comment><class-id>Lens.LensApplicationSpec</class-id><body>This class is private to the implementation of the ObjectLens.  Users should not use this class directly and should not subclass it.LensApplicationSpec contains the necessary information for automatically generating a new LensApplication subclass.Instance Variables	name	&lt;Symbol&gt;  the name of the application	kind		&lt;Symbol&gt;  one of #Form, #Table, #Matcher; designates the application's format	dataModel	&lt;Array with: &lt;className Symbol&gt; with: &lt;selector Symbol&gt;&gt;  elements are the class and selector respectively designating where the literal form of the application's data model may be found	rowType	&lt;Array of &lt;Array with: &lt;structureType Symbol&gt; with: &lt;tag Symbol&gt;&gt;&gt;  elements name the structureTypes for 'terms' in the application's row; subelements are respectively the name of the class that the LensStructureType annotates, and a tag that can be used to differentiate repeated occurances of the same structure type	fields	&lt;Array of &lt;Array with: &lt;Array with: &lt;tag Symbol&gt; | of: &lt;aspect Symbol&gt;&gt; with: &lt;structureVar Symbol&gt;&gt;&gt;  elements designate and type-describe the contents of fields in the application	editPolicy	&lt;Symbol | nil&gt;  Says whether and when editing starts: #neverEdit, #enableEditingExplicitly, or #enableEditingOnSelection	lockPolicy	&lt;Symbol | nil&gt;  Says whether and when the row object may be locked automatically: #lockOnAccept, #lockOnEdit, or #lockOnDisplay</body></comment><class><name>LensDFConnectionSliceModel</name><environment>Lens</environment><super>Tools.SpecModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Support</category><attributes><package>Lens-Dev</package></attributes></class><class><name>LensApplicationStructureView</name><environment>Lens</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>graphView focus selection finder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Tools</category><attributes><package>Lens-Dev</package></attributes></class><comment><class-id>Lens.LensApplicationStructureView</class-id><body>An auxiliary view for the finder. It shows the classes forming a database application as a graph.Instance Variables:graphView &lt;a LensGraphView&gt; the graph where the classes are shownfocus	&lt;aClass asValue&gt; the class to be used as starting point for the graph, changing this value holder will cause an update in the graphselection &lt;aClass&gt; the class currently selectedfinder &lt;a UIFinderVW2&gt; the finder we spun off, used to update the selection</body></comment><class><name>LensTablesSelector</name><environment>Lens</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>editor columnsList columnType columnCanBeNull tablesList pattern </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Support</category><attributes><package>Lens-Dev</package></attributes></class><class><name>QueryEditor</name><environment>Lens</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ldm tables from answer where orderBy groupBy unique distinct lock current oldCurrent tablesView menusValue selectedTables changing targetClass targetSelector classFinder pattern parameters fullObjects instanceVariablesMenu tmpCode functionsMenu mode ownRow editorKind menuAccessorName saved useStreaming alternateSQL alternateSQLText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Tools</category><attributes><package>Lens-Dev</package></attributes></class><comment><class-id>Lens.QueryEditor</class-id><body>My purpose is to provide an interface for the creation of QueryOperations. A QueryOperation contains enough information to execute a database command and get a stream as a result. QueryOperations are handy because they do not require a session nor a schema in their definition, so they may be bind to a schema and session later, at the time of the execution.This version does an attempt to help the user in knowing what are the building blocks that form the expressions, but it does NO ATTEMPT to help in having the correct SYNTAX for the expressions. To help in the syntax part a language sensitive editor would have to be created. If there is time, a new version of this tool will be created which uses trees to guide the user through the syntax of expressions.Also this version of the editor doesn't help in building QueryOperations that are connected to database stored procedures.To define a QueryOperation the folowing parts are needed:from - a collection of mapped classes names. The query is performed on the tables these classes are mapped toanswer (more properly called select) - a description of the form the resulting stream of objects should have. If it's not specified, then the whole objects are retrieved. Retrieving the whole objects is preffered because this way updates are possible and also updates in other tools are reflected here also (the objects are shared within a session)where (also called selectWhere) - This corresponds to the 'WHERE' clause in the corresponding SQL statement, the syntax used here is more or less a constrained Smalltalk expressionorderBy, groupBy - similar to the specification of column results, but defines the way the results are ordered and groupedThe query is stored in method in the instance side of a class. This method is used at run-time to fetch the method to be executed and also at edit-time to fetch the query operation to be edited.Instance Variables:schema &lt;Schema&gt; : the schema from which type information is retrieved (which classes are mapped). In the future this information could appear clipped in the mapped classes themselves.tables &lt;Collection of DBTypeBrowserElement&gt; a collection of all the mapped classes that appear in the schema. They are wrapped in DBTypeBrowserElements to make them easily browseable in the tree view.from, answer, where, orderBy, groupBy &lt;String or Text asValue&gt; these fields hold the text entered by the user for the specific blocks as explained above.unique, distinct, lock &lt;Boolean asValue&gt; For the corresponding attributes of the QueryOperationcurrent &lt;Symbol asValue&gt; This symbol represents the part being edited right now. Buttons are disabled or enabled according to it. Also the input is directed to the appropriate field by looking at this value.oldCurrent &lt;Symbol&gt; the latest value of current before the current one.tablesView &lt;DBTablesView&gt; this sub-application holds on to the tree of Objects and fields.menusValue &lt;ValueHolder&gt; this value holder is used as the model of all the menus used to edit. Whenever a new value is assigned to this variable, it is inserted in the current field.selectedTables &lt;Collection of elements from tables&gt; note that the types of Objects may be repeated, but new DBTypeBrowserElements are created for each one of them.changing &lt;Boolean&gt; an auxiliary variable to avoid infinite change propagation.targetClass &lt;Class or nil&gt; the target class where the method will be installedtargetSelector &lt;Symbol or nil&gt; the selector that will be used to install the method in the class.className &lt;String asValue&gt; the name of the target class.pattern &lt;String asValue&gt; the message pattern to be used in the method. Information is extracted from this pattern regarding the parameters to the query, which are the parameters passed to the method.parameters &lt;Collection of String&gt; the names of the parameters to the method.fullObjects &lt;Boolean asValue&gt; whether or not the query will fetch full objects. Fetching full objects is prefered.instanceVariablesMenu &lt;Menu asValue&gt; a holder for the menu that contains a list of the names of instance variables of the targetClass. These variables names can also be used in the query expressions.tmpCode &lt;String&gt; a temporary variable to hold the code between the time it's sent to the compiler and the time it gets back to us with an errortransporterClass &lt;IWSQLTransporter or a subClass of it&gt; The transporter class currently in use, the default is to use OracleTransporter. This is used to determine which functions are available.</body></comment><class><name>ClassCreateDialogReturn</name><environment>Lens</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>results className nameSpace </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Dialog-Support</category><attributes><package>Lens-Dev</package></attributes></class><shared-variable><name>LastDataModel</name><environment>Lens.LensApplicationCreationDialog</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Lens-Dev</package></attributes></shared-variable><shared-variable><name>LastDataModel</name><environment>Lens.LensApplicationSpecEditor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Lens-Dev</package></attributes></shared-variable><shared-variable><name>PermissableNameSpaces</name><environment>Lens.LensNamespaceControl</environment><private>false</private><constant>false</constant><category>class variables</category><attributes><package>Lens-Dev</package></attributes></shared-variable><shared-variable><name>LastDataApplicationNameSpace</name><environment>Lens.LensNamespaceControl</environment><private>false</private><constant>false</constant><category>class variables</category><attributes><package>Lens-Dev</package></attributes></shared-variable><shared-variable><name>LastDataModelerNameSpace</name><environment>Lens.LensNamespaceControl</environment><private>false</private><constant>false</constant><category>class variables</category><attributes><package>Lens-Dev</package></attributes></shared-variable><shared-variable><name>EnableChildSets</name><environment>Lens.LensEditor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Lens-Dev</package></attributes></shared-variable><methods><class-id>Lens.LensKeyEditor</class-id> <category>accessing</category><body package="Lens-Dev">annotation	^type</body><body package="Lens-Dev">keyVariables	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^keyVariables isNil ifTrue: [keyVariables := SelectionInList new] ifFalse: [keyVariables]</body><body package="Lens-Dev">message1	message1 isNil ifTrue: [message1 := (#GenKeyDefineKeyVariable &lt;&lt; #lensDev &gt;&gt; 'At least one key variable is required.') asString asValue].	^message1</body><body package="Lens-Dev">message1: s	self message1 value: s</body><body package="Lens-Dev">message2	message2 isNil ifTrue: [message2 := '' asValue].	^message2</body><body package="Lens-Dev">message2: s	self message2 value: s</body><body package="Lens-Dev">nonKeyVariables	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^nonKeyVariables isNil ifTrue: [nonKeyVariables := SelectionInList new] ifFalse: [nonKeyVariables]</body><body package="Lens-Dev">type	^type</body><body package="Lens-Dev">type: aLST	type := aLST</body><body package="Lens-Dev">variables	^type variables</body></methods><methods><class-id>Lens.LensKeyEditor</class-id> <category>actions</category><body package="Lens-Dev">addKeyVariable	"Move the non-key variable to the key variables list.  The selection	is set to the new entry in the key variables list and is approximately	maintained in the non-key variables list."	| nonKeyVars sel var keyVars |	nonKeyVars := self nonKeyVariables.	"Enforce-quietly: there must be a selection."	(sel := nonKeyVars selectionIndex) == nonKeyVars zeroIndex ifTrue:		[ ^false ].	"Check that the type of the variable is appropriate to be used as key"	var := nonKeyVars selection.	(self canBeKey: var) ifFalse: [^false].	"Remove the variable from the non-key variables list."	var := nonKeyVars list removeAtIndex: sel.	"Add it to the end of the key variables list."	(keyVars := self keyVariables) list addLast: var.	"Set the selections in the two lists."	nonKeyVars selectionIndex: (sel min: nonKeyVars list size).	keyVars selectionIndex: (keyVars list size)</body><body package="Lens-Dev">moveKeyVariableDown	"Moves the selected row one space down"	(self moveDownInList: self keyVariables)		ifFalse:	[ Dialog warn: (#CannotMoveFurtherDown &lt;&lt; #lensDev &gt;&gt; 'Cannot move further down.') for: builder window ]</body><body package="Lens-Dev">moveKeyVariableUp	"Moves the selected row one space up."	(self moveUpInList: self keyVariables)		ifFalse:	[ Dialog warn: (#CannotMoveFurtherUp &lt;&lt; #lensDev &gt;&gt; 'Cannot move further up.') for: builder window ]</body><body package="Lens-Dev">removeKeyVariable	"Move the key variable to the non-key variables list.  Inserting it	in its proper sequence based on the master variables list.  The selection	is set to the new entry in the non-key variables list and is approximately	maintained in the key variables list."	| keyVars nonKeyVars sel var varIndex vars successor |	keyVars := self keyVariables.	nonKeyVars := self nonKeyVariables.	"Enforce-quietly: there must be a selection."	(sel := keyVars selectionIndex) == keyVars zeroIndex ifTrue:		[ ^false ].	"Remove the variable from the key."	var := keyVars list removeAtIndex: sel.	"Find the successor in the variables list."	varIndex := ((vars := var objectType variables) indexOf: var).	varIndex := varIndex + 1.	[ varIndex &lt;= vars size	and: [ (nonKeyVars list includes: (successor := vars at: varIndex)) not ] ]		whileTrue:			[ varIndex := varIndex + 1.			successor := nil ].	"Add the variable to the non-key variables list."	successor isNil		ifTrue:	[ nonKeyVars list addLast: var ]		ifFalse:	[ nonKeyVars list add: var before: successor ].	"Set the selections in the two lists."	keyVars selectionIndex: (sel min: keyVars list size).	nonKeyVars selection: var</body></methods><methods><class-id>Lens.LensKeyEditor</class-id> <category>private</category><body package="Lens-Dev">canBeKey: aVar 	"Checks whether aVar is allowed to be an Id variable. It checks that the 	type of the variable is not Object and it is not encoded. Raises a dialog 	explaining the problem"	| win typ |	builder notNil ifTrue: [win := builder window].	((typ := aVar valueType) isNil or:		[aVar decodeSelector notNil or:			[typ isLensType not or:				[typ memberClass == Object]]])		ifTrue: 			[Dialog warn:(#GenKeyInvalidKey &lt;&lt; #lensDev &gt;&gt; 'Variables typed as Object, or as ''encodedtypes'' such as Date and ByteSymbol, shouldnot be used in keys.') for: win.			^false].	^true</body><body package="Lens-Dev">checkKey	keyVariables list isEmpty		ifTrue: 			[Dialog warn: (#GenKeySelectNonKeyVariable &lt;&lt; #lensDev &gt;&gt; 'Key must have at least one variable.Select a variable from the Non-Key variables listand press the left arrow button.') for: builder window.			^false].	^true</body><body package="Lens-Dev">moveDownInList: aSelectionInList	^self moveDownInList: aSelectionInList excludingUpTo: 0</body><body package="Lens-Dev">moveDownInList: aSelectionInList excludingUpTo: limitNum	"Moves the selected row one slot down.  Answer true if a change was made."	"The moves are done only if the rows until limitNum are not touched. This is to protect the order of variables in super classes"	| sel list var |	sel := aSelectionInList selectionIndex.	list := aSelectionInList list.	(sel &gt;= list size or: [sel &lt;= limitNum]) ifTrue:		[ ^false ].	var := list removeAtIndex: sel.	list add: var beforeIndex: sel + 1.	aSelectionInList selectionIndex: sel + 1.	^true</body><body package="Lens-Dev">moveUpInList: aSelectionInList	^self moveUpInList: aSelectionInList excludingUpTo: 0</body><body package="Lens-Dev">moveUpInList: aSelectionInList excludingUpTo: limitNum	"Moves the selected row one slot up.  Answer true if a change was made."	| sel list var |	sel := aSelectionInList selectionIndex.	list := aSelectionInList list.	(sel &lt;= (limitNum + 1)) ifTrue:		[ ^false ].	var := list removeAtIndex: sel.	list add: var beforeIndex: sel - 1.	aSelectionInList selectionIndex: sel - 1.	^true</body></methods><methods><class-id>Lens.LensKeyEditor</class-id> <category>initialize-release</category><body package="Lens-Dev">initialize	super initialize.	accept compute: [:v | v ifTrue: [self updateBack]]</body><body package="Lens-Dev">postOpenWith: aBuilder	"Make sure that the list we are getting are really lists"	| varsList keyList nonKeyList |	varsList := self variables.	"Build keyList and nonKeyList by partitioning varsList."	keyList := List new.	nonKeyList := varsList reject: [:var | var isId					ifTrue: 						[keyList add: var.						true]					ifFalse: [false]].	keyList size &gt; 1 ifTrue: [keyList := self annotation idVariable valueType variables asList].	self keyVariables list: keyList.	self nonKeyVariables list: nonKeyList asList</body><body package="Lens-Dev">updateBack	"Updates the type after an accept"	| keyList nonKeyList idSrc |	keyList := keyVariables list.	nonKeyList := nonKeyVariables list.	"Infer the nature of the key."	keyList isEmpty		ifTrue:			[^(Dialog confirm: (#GenKeyKeyMustHaveVariables &lt;&lt; #lensDev &gt;&gt; 'Key must have at least one variable...Do you want to go back to the Key Editor?') for: builder window) ifTrue: [self open] ifFalse: [false]]		ifFalse:			[ "Is it user defined or a sequence id?"			(keyList size == 1 and: [keyList first valueType isSerialNumber])				ifTrue:	[ idSrc := #sequenceId ]				ifFalse:	[ idSrc := #userDefinedId ] ].	"Update the key designations."	keyList do: [ :var | var isId: true ].	nonKeyList do: [ :var | var isId: false ].	"Modify the id definition."	self annotation idGeneratorType: idSrc.	keyList size == 1		ifTrue:			[ self annotation idVariable: keyList first]		ifFalse:			[ | valueType |			valueType := LensStructureType memberClass: Array variables: keyList asArray.			valueType dataModel: self annotation dataModel.			self annotation idVariable: (LensStructureVariable new 				objectType: self annotation;				isId: true;				setValueType: valueType) ].</body></methods><methods><class-id>Lens.LensNamespaceControl</class-id> <category>private</category><body package="Lens-Dev">baseNameSpaces	"Smalltalk and Lens"	| allNameSpaces |	allNameSpaces := Root allNameSpaces.	^(allNameSpaces select: [:ea | (ea == Smalltalk or: [ea == Lens])]).</body><body package="Lens-Dev">nameSpacesWithCorrectImports	"Namespaces which import both Smalltalk, Database and Lens"	| allNameSpaces |	allNameSpaces := Root allNameSpaces.	^allNameSpaces 		select: [:each | ((each importDefinitions includes: 				(GeneralNameSpaceImport path: #(Smalltalk)))				and:				[(each importDefinitions includes: 				(GeneralNameSpaceImport path: #(Database)))				and:				[each importDefinitions includes: 				(GeneralNameSpaceImport path: #(Lens))]])].</body></methods><methods><class-id>Lens.LensNamespaceControl</class-id> <category>resources</category><body package="Lens-Dev">leftArrow	^LensKeyEditor leftArrow</body><body package="Lens-Dev">rightArrow	^LensKeyEditor rightArrow</body></methods><methods><class-id>Lens.LensNamespaceControl</class-id> <category>interface-opening</category><body package="Lens-Dev">postBuildWith: aBuilder	|  nsListWithSmalltalkImport copyAv |	"Namespaces which import both Smalltalk, Database and Lens"	nsListWithSmalltalkImport := self nameSpacesWithCorrectImports.	self class permissableNameSpaces size = (self baseNameSpaces size)		ifTrue: [self availableList list: nsListWithSmalltalkImport.				self selectedList list: self baseNameSpaces.]		ifFalse: [self selectedList list: self class permissableNameSpaces.				copyAv := nsListWithSmalltalkImport copy.				self class permissableNameSpaces do: [:ea |					copyAv remove: ea ifAbsent: [].				self availableList list: copyAv.]]</body></methods><methods><class-id>Lens.LensNamespaceControl</class-id> <category>actions</category><body package="Lens-Dev">doCancel	"This stub method was generated by UIDefiner"	^self closeRequest</body><body package="Lens-Dev">doOK	self class permissableNameSpaces: self selectedList list.	self closeRequest.</body><body package="Lens-Dev">doReset	|  nsListWithSmalltalkImport |	"Namespaces which import both Smalltalk, Database and Lens"	nsListWithSmalltalkImport := self nameSpacesWithCorrectImports.	self availableList list: nsListWithSmalltalkImport.	self selectedList list: self baseNameSpaces.</body><body package="Lens-Dev">moveToAvailable	| sel selList avList |	(sel := self selectedList selection) isNil		ifFalse: [			(self baseNameSpaces includes: sel)				ifTrue: [^Dialog warn: (#GenKeyNoRemoveSmalltalkOrLens &lt;&lt; #lensDev &gt;&gt; 'You cannot remove Smalltalk or Lens from selected list.')]. 			selList := self selectedList list copy.			avList := self availableList list copy.			selList remove: sel.			avList addLast: sel.			self selectedList list: selList.			self availableList list: avList].</body><body package="Lens-Dev">moveToSelected	| sel selList avList |	(sel := self availableList selection) isNil		ifFalse: [ 			selList := self selectedList list copy.			avList := self availableList list copy.			selList addLast: sel.			avList remove: sel.			self selectedList list: selList.			self availableList list: avList].</body></methods><methods><class-id>Lens.LensNamespaceControl</class-id> <category>aspects</category><body package="Lens-Dev">availableList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^availableList isNil		ifTrue:			[availableList := SelectionInList new]		ifFalse:			[availableList]</body><body package="Lens-Dev">selectedList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^selectedList isNil		ifTrue:			[selectedList := SelectionInList new]		ifFalse:			[selectedList]</body></methods><methods><class-id>Lens.LensNamespaceControl class</class-id> <category>accessing</category><body package="Lens-Dev">allClassNames	"found in permissableNameSpaces"	"self allClassNames"	| allNS oc |	allNS := self permissableNameSpaces.	oc := OrderedCollection new.	allNS do: [:ns |		ns allClassNames do: [:cl |			(oc includes: cl) ifFalse: [oc add: cl]]].	^oc</body><body package="Lens-Dev">lastDataApplicationNameSpace	^LastDataApplicationNameSpace</body><body package="Lens-Dev">lastDataApplicationNameSpace: aNameSpace	LastDataApplicationNameSpace := aNameSpace</body><body package="Lens-Dev">lastDataModelerNameSpace	^LastDataModelerNameSpace</body><body package="Lens-Dev">lastDataModelerNameSpace: aNameSpace	LastDataModelerNameSpace := aNameSpace</body><body package="Lens-Dev">permissableNameSpaces	^PermissableNameSpaces</body><body package="Lens-Dev">permissableNameSpaces: aListOfNamespaces	PermissableNameSpaces := aListOfNamespaces</body></methods><methods><class-id>Lens.LensNamespaceControl class</class-id> <category>resources</category><body package="Lens-Dev">leftArrow	^LensKeyEditor leftArrow</body><body package="Lens-Dev">rightArrow	^LensKeyEditor rightArrow</body></methods><methods><class-id>Lens.LensNamespaceControl class</class-id> <category>class initialization</category><body package="Lens-Dev">initialize	"self initialize"	LastDataApplicationNameSpace := Smalltalk.	LastDataModelerNameSpace := Smalltalk.	self initializePermissableNameSpaces.</body><body package="Lens-Dev">initializePermissableNameSpaces	"self initializePermissableNameSpaces"	| oc |	oc := OrderedCollection new.	oc add: Smalltalk.	oc add: Lens.	PermissableNameSpaces := oc.</body></methods><methods><class-id>Lens.LensApplicationSpecEditor</class-id> <category>accessing</category><body package="Lens-Dev">addVarRef: varRef	fieldsDict at: varRef cascade put: varRef</body><body package="Lens-Dev">catalogLens	^generator catalogLens</body><body package="Lens-Dev">containers	spec rowType isNil ifTrue: [ spec rowType: OrderedCollection new].	^spec rowType</body><body package="Lens-Dev">dataModel: ldm 	dataModel := ldm.	generator lensDataModel: ldm.	ldm notNil		ifTrue: 			[spec dataModel at: 1 put: ldm applicationName.			spec dataModel at: 2 put: ldm selector asSymbol.			builder notNil				ifTrue: 					[(builder bindings at: #'spec dataModel 1' ifAbsent: ['' asValue])						changed: #value.					(builder bindings at: #'spec dataModel 2' ifAbsent: ['' asValue])						changed: #value]].</body><body package="Lens-Dev">deselected: aCascade 	(self isSelected: aCascade)		ifTrue: 			[there remove: aCascade.			fields remove: aCascade.			newFields remove: aCascade ifAbsent: nil]</body><body package="Lens-Dev">isSelected: aCascade	^there includes: aCascade</body><body package="Lens-Dev">newFields	^newFields</body><body package="Lens-Dev">selected: aCascade 	"Check that the cascade is not already there to avoid including twice the same field"	(there includes: aCascade)		ifFalse: 			[there add: aCascade.			fields addLast: aCascade.			newFields addLast: aCascade]</body><body package="Lens-Dev">selectedDataModel	^dataModel</body><body package="Lens-Dev">selectedType	^nil</body><body package="Lens-Dev">spec	^spec</body><body package="Lens-Dev">spec: aSpec	spec notNil ifTrue: [spec removeDependent: self].	spec := aSpec.	self startEditing.	spec notNil ifTrue: [spec addDependent: self].</body></methods><methods><class-id>Lens.LensApplicationSpecEditor</class-id> <category>private</category><body package="Lens-Dev">beautify: str 	| stream result c |	stream := (str copyFrom: 1 to: str size - 'Template' size) readStream.	result := WriteStream on: (String new: 60).	stream atEnd ifTrue: [^(#UnnamedTemplate &lt;&lt; #lensDev &gt;&gt; 'Unnamed Template') asString].	c := stream next.	result nextPut: c asUppercase.	[stream atEnd]		whileFalse: 			[c := stream next.			c isUppercase ifTrue: [result space].			result nextPut: c].	^result contents</body><body package="Lens-Dev">componentAt: aSymbol 	^builder isNil		ifTrue: [nil]		ifFalse: [builder componentAt: aSymbol]</body><body package="Lens-Dev">dataModelFor: anArray 	"arr is composed of a class name and a selector"	| ldm cl |	cl := (anArray at: 1) asQualifiedReference valueOrDo: [nil].	cl isNil		ifTrue: 			[Dialog warn: ((#GenKeyClassNameNotExist &lt;&lt; #lensDev &gt;&gt; 'The class:&lt;nn&gt;&lt;1s&gt;&lt;nnt&gt;does not exist')			expandMacrosWith: (anArray at: 1)) for: builder window.			^nil].	self errorSignal		handle: 			[:ex | 			Dialog warn: (#DataModelNotValidSelect &lt;&lt; #lensDev &gt;&gt; 'Data Model not valid.Select a different class') for: builder window.			^nil]		do: [ldm := LensDataModel readFromClass: cl methodName: (anArray at: 2)].	^ldm</body><body package="Lens-Dev">tagged: aCascade 	| a |	a := Array new: aCascade size + 1.	a at: 1 put: #@.	2 to: a size do: [:i | a at: i put: (aCascade at: i - 1)].	^a</body></methods><methods><class-id>Lens.LensApplicationSpecEditor</class-id> <category>changes</category><body package="Lens-Dev">addAReference: ref 	"Adds a type to the graphView"	ref reset.	dataModel structureTypes do: [:dm | dm name == ref referredName ifTrue: [ref referred: dm]].	ref application: self.	self containers addLast: ref.</body><body package="Lens-Dev">changedDataModel	"The selected data model has changed, if the selector and the class have already been entered then 	try to fetch the DataModel, update the types menu and clear the graph"	| clSym selSym |	self spec dataModel isNil		ifTrue: [^true].	clSym := (self spec dataModel at: 1) asQualifiedReference name."	clSym := self spec dataModel at: 1."	selSym := self spec dataModel at: 2.	(clSym size &gt; 0 and: [selSym size &gt; 0])		ifTrue: 			[self dataModel: (self dataModelFor:  self spec dataModel).			dataModel notNil ifTrue: [^true].			^true]		ifFalse: [^true]</body><body package="Lens-Dev">doneEditing	"Copy the data back into the original spec. If necessary, update the dataModel"	| rt nFields | 	rt := spec rowType.	rt do: [:t | t reset].	spec rowType: rt asArray.	spec fields: OrderedCollection new.	nFields := OrderedCollection new.	fields		do: 			[:f | 			| max fi |			fi := (fieldsDict at: f) referred.			max := fi fieldType maxColumnConstraint.			max isNil ifTrue: [fi column notNil ifTrue: [max := fi column maxColumnConstraint]].			spec fields addLast: (Array					with: (self tagged: f)					with: fi valueType memberClass name					with: max).			(newFields includes: f)				ifTrue: [nFields add: spec fields last]].	newFields := nFields.	(ldmChanged and: [dataModel notNil])		ifTrue: 			[dataModel compile.			dataModel databaseContext synchronizeDataDictionaryFor: dataModel in: self catalogLens.			dataModel writeSpec].	dataModel notNil ifTrue: [LastDataModel := self spec dataModel copy]</body><body package="Lens-Dev">enable: aBoolean group: ids 	"Enable or disable a collection of widgets whose names are given in ids"	builder notNil ifTrue: [ids			do: 				[:id | 				| comp |				comp := builder componentAt: id.				(comp isNil and: [subBuilder notNil])					ifTrue: [comp := subBuilder componentAt: id].				comp notNil ifTrue: [aBoolean						ifTrue: [comp enable]						ifFalse: [comp disable]]]]</body><body package="Lens-Dev">readySpec	"Return a new spec with a copy of the data from the old one"	| rt nFields newSpec | 	newSpec := spec copy.	rt := spec rowType collect: [:t | t copy reset].	newSpec rowType: rt asArray.	newSpec fields: OrderedCollection new.	nFields := OrderedCollection new.	fields		do: 			[:f | 			| max fi |			fi := (fieldsDict at: f) referred.			max := (fi valueType memberClass name == #Boolean)				ifTrue: [5]				ifFalse: [fi fieldType maxColumnConstraint].			max isNil ifTrue: [fi column notNil ifTrue: [max := fi column maxColumnConstraint]].			newSpec fields addLast: (Array					with: (self tagged: f)					with: fi valueType memberClass name					with: max).			(newFields includes: f)				ifTrue: [nFields add: newSpec fields last]].	newFields := nFields.	^newSpec</body><body package="Lens-Dev">setEnablement	| fName |	self enable: ((fName := spec fullName) size &gt; 0 and: [fName asString ~= ' ' and: [spec selector size &gt; 0]])		group: #(#generateIt)</body><body package="Lens-Dev">startEditing	(#(form table qbe) includes: spec kind) ifFalse: [spec kind: #form].	spec template isNil ifTrue: [spec template: #multipleRowEditorTemplate].	spec editPolicy isNil ifTrue: [spec editPolicy: #enableEditingExplicitly].	spec lockPolicy isNil ifTrue: [spec lockPolicy: #lockOnEdit].	self updateTemplatesMenu.	spec dataModel isNil ifTrue: [spec dataModel: LastDataModel copy].	self changedDataModel.	spec rowType isNil		ifTrue: [spec rowType: OrderedCollection new]		ifFalse: [spec rowType: (spec rowType collect: [:cr | (cr copy asContainerReference) application: self; yourself]) asOrderedCollection].	spec rowType do: [:rt | self addAReference: rt].	self updateSelectionInFields.	self updateGraph.	spec changed: #value.	self setEnablement</body><body package="Lens-Dev">startEditingCheckingDataModel	(#(form table qbe) includes: spec kind) ifFalse: [spec kind: #form].	spec template isNil ifTrue: [spec template: #multipleRowEditorTemplate].	spec editPolicy isNil ifTrue: [spec editPolicy: #enableEditingExplicitly].	spec lockPolicy isNil ifTrue: [spec lockPolicy: #lockOnEdit].	self updateTemplatesMenu.	spec dataModel isNil ifTrue: [spec dataModel: LastDataModel copy].	self changedDataModel.	dataModel isNil 		ifTrue: [spec rowType: OrderedCollection new.				spec name: ' '.				spec rowType do: [:rt | self addAReference: rt].				self updateSelectionInFields.				self updateGraph.				spec changed: #value.				self setEnablement.				Dialog warn: ((#GenKeyCanNotLoadDataForm &lt;&lt; #lensDev &gt;&gt; 'This Data Form cannot be loaded.Check the dataModelDesignator for thisData Form.')).				^false].	spec rowType isNil		ifTrue: [spec rowType: OrderedCollection new]		ifFalse: [spec rowType: (spec rowType collect: [:cr | (cr copy asContainerReference) application: self; yourself]) asOrderedCollection].	spec rowType do: [:rt | self addAReference: rt].	self updateSelectionInFields.	self updateGraph.	spec changed: #value.	self setEnablement.	^true</body><body package="Lens-Dev">updateClassesMenu</body><body package="Lens-Dev">updateGraph	graphView focus: self containers asSet.</body><body package="Lens-Dev">updateSelectionInFields	"The children of the containerReferences may be selected according to the information held in the 	fields of the spec"	fieldsDict := Dictionary new.	there := Set new.	fields := OrderedCollection new.	spec fields isNil ifTrue: [spec fields: OrderedCollection new].	spec fields		do: 			[:f | | k |			k := (f at: 1) copyFrom: 2 to: (f at: 1) size.			there add: k.			fields addLast: k].</body><body package="Lens-Dev">updateTemplatesMenu	| m cl sels meth nm |	cl := spec superclass isNil		ifTrue: [LensDataManager]		ifFalse: [Smalltalk at: spec superclass ifAbsent: [LensDataManager]].	sels := Set new.	m := Menu new.	cl class withAllSuperclasses do:		[:cls |		(cls whichSelectorsReferTo: #SpecCollection) do:			[:sel | sels add: sel]].	sels asSortedCollection do:		[:sel |		('*Template' match: sel asString)			ifTrue:				[meth := (cl class findSelector: sel) at: 2.				nm := (meth attributeMessages ifNil: [#()] ifNotNil: [:msgs | msgs])					detect: [:msg | msg selector == #specLabel:]					ifNone: [].				nm := nm					ifNil: [self beautify: sel]					ifNotNil: [UserMessage fromPragmaArgument: nm arguments first].				m addItemLabel: nm value: sel]].	templatesMenuHolder isNil		ifTrue: [templatesMenuHolder := m asValue]		ifFalse: [templatesMenuHolder value: m]</body></methods><methods><class-id>Lens.LensApplicationSpecEditor</class-id> <category>menu actions</category><body package="Lens-Dev">categoryListMenu	"Create a sorted menu of all classes in the same category"	| col sc menu |	spec category isNil ifTrue: [^Menu new].	col := OrderedCollection new.	(Smalltalk organization listAtCategoryNamed: spec category asSymbol)		do: 			[:cn | 			| cl |			cl := self class environment at: cn ifAbsent: nil.			(cl notNil and: [cl respondsTo: #rowType])				ifTrue: [col add: cn -&gt; cl]].	col := col asArray.	sc := SequenceableCollectionSorter on: col using: [:a1 :a2 | a1 key &lt;= a2 key].	sc sort.	menu := Menu				labelArray: (col collect: [:a | a key])				lines: Array new				values: (col collect: [:a | [self loadClassData: a value]]).	^menu</body><body package="Lens-Dev">existingClass	"Collect the name of an existing class, if the class does not exist go to the 	creation scenario"	| result nm nameSpace newApp |	result := LensEditor new openTargetClassNameDialogFor: className nameSpace: nil message: (#EnterTheNameOfTheClass &lt;&lt; #lensDev &gt;&gt; 'Enter the name of the class').	result isNil ifTrue: [^self].	nm := result className.	nameSpace := result nameSpace.	nm size &gt; 0		ifTrue: 			[(nm at: 1) isLowercase ifTrue: [nm at: 1 put: (nm at: 1) asUppercase].			newApp := nameSpace at: nm asSymbol ifAbsent: [nil].			newApp notNil				ifTrue: [self loadClassData: newApp]				ifFalse: [self newClass: nm]]</body><body package="Lens-Dev">loadClassData: cl 	"Loads the data from the given class"	| win |	cl isNil ifTrue: [^nil].	builder notNil ifTrue: [win := builder window].	((cl respondsTo: #dataModelDesignator)		and: [cl respondsTo: #rowType])		ifTrue: 			[spec name: cl name.			spec nameSpace: cl environment.			spec superclass: cl superclass name.			spec category: (cl environment organization categoryOfElement: cl name).			spec dataModel: cl dataModelDesignator copy.			spec rowType: (cl rowType collect: [:rt | rt asContainerReference]).			(self startEditingCheckingDataModel) 				ifFalse: [spec name: ' '.]]		ifFalse: [Dialog warn: ((#GenKeyNotSuitableCanvasClass &lt;&lt; #lensDev &gt;&gt; 'The class:&lt;nt&gt;&lt;1s&gt;&lt;n&gt;is not suitable for the generation of Data Form canvases.')			expandMacrosWith: cl name) for: win]</body><body package="Lens-Dev">newClass	^self newClass: nil</body><body package="Lens-Dev">newClass: nm	"Set the data model to be the data model of the currently selected class and 	start the application creation dialog"	| ldm newApp |	ldm := spec dataModel.	(ldm notNil and: [(ldm at: 1) size &gt; 0 and: [(ldm at: 2) size &gt; 0]])		ifTrue: [LensApplicationCreationDialog defaultDataModel: ldm].	newApp := UIFinderVW2				createNewApplication: nm				ofKind: #LensDataManager				inCategory: spec category				forClient: self.	newApp notNil ifTrue: [self loadClassData: newApp]</body></methods><methods><class-id>Lens.LensApplicationSpecEditor</class-id> <category>aspects</category><body package="Lens-Dev">graphView	^graphView</body></methods><methods><class-id>Lens.LensApplicationSpecEditor</class-id> <category>interface opening</category><body package="Lens-Dev">openDialogForClass: aClass 	"If the class is not nil open the interface as a dialog to allow the creation of one canvas"	aClass notNil		ifTrue: 			[self loadClassData: aClass.			((SimpleDialog new) 				postOpenBlock: [:view :bldr| self updateGraph];				openFor: self interface: #dialogWindowSpec)				ifTrue: [self generateIt]]</body><body package="Lens-Dev">postOpenWith: aBuilder 	"This message is sent by the builder after it has opened a completed 	window."	self updateGraph.	self setEnablement</body></methods><methods><class-id>Lens.LensApplicationSpecEditor</class-id> <category>actions</category><body package="Lens-Dev">generateIt	| targetClass sp win |	sp := self readySpec.	win := builder notNil ifTrue: [builder window].	(targetClass := spec name asQualifiedReference valueOrDo: [nil]) isNil		ifTrue: [^nil].	(targetClass class includesSelector: sp selector asSymbol)		ifTrue: [(Dialog confirm: ((#GenKeyDuplicateCanvas &lt;&lt; #lensDev &gt;&gt; 'The canvas #&lt;1s&gt; is already defined for this class.&lt;n&gt;Do you want to override it?')			expandMacrosWith: sp selector) for: win)				ifFalse: [^nil]].	FullSpec		store: (targetClass generateFullSpecFrom: sp usingTemplate: sp template)		toClass: targetClass class		methodName: sp selector.	UIPainter new openOnClass: targetClass andSelector: sp selector</body><body package="Lens-Dev">helpAction	VisualLauncher openHelpBrowser</body><body package="Lens-Dev">helpActionForDialog(SimpleHelp helpString: (#GenKeyCanvasHelp &lt;&lt; #lensDev &gt;&gt; 'Generating a CanvasThis dialog is used to generate an initial canvas for a Data Form.  A canvas defines the layout and components that will be visible on a window while accessing the database. The name of the Data Form class, which will already have been specified, is shown at the top of the dialog. 1.	Enter the name of the canvas to be generated.  By default, the canvas is saved under the canvas name windowSpec but any other name can be used.  If a canvas already exists with the same name, it is overwritten and previous work may be lost.  In this case, a warning dialog will appear that can be used to cancel generation.  The Canvas Composer (see the VisualWorks Launcher Database menubar item) can be used to generate an initial canvas under a different canvas name.2.	Specify the Edit Polity.  This controls whether and how the resulting data form can be edited. The Never option will disable editing of all fields on a canvas. The When Told option starts editing of a row after an Edit button has been clicked or when an Edit checkbox has been checked. The When Touched option starts editing of a row when any field is selected by the user.3.	Specify the Template to be used for generating the canvas; this defines the appearance and controls the generated canvas will have. Each template gives a generated canvas a different set of control buttons and different layout of fields. The resulting canvas can be edited using VisualWorks painting tools.  Generally, the canvas will open automatically for touch-up as soon as this dialog terminates.  Later, the same canvas can be edited again by selecting the Data Form class and canvas name in the Resource Finder, and pressing the Edit button.  Templates can be easily added to and removed from the system, but the following templates are standard equipment:	Multiple Row Editor		A form-based presentation with transport and editing controls (for editing a set of rows)	Multiple Row Viewer		A read-only form-based presentation with transport controls only (for displaying a set of rows)	Row Editor		A form-based presentation with editing controls only (for editing a single row)	Row Viewer		A read-only form-based presentation (for displaying a single row)	Tabular Editor		A tabular display with editing controls (for editing a set of rows)	Tabular Viewer		A read-only tabular display (for displaying a set of rows)4.	Specify the Entity fields to be included in the generated canvas, by selecting in the entity view at the bottom of the Canvas Composer. The user can navigate the entity view by clicking on any black arrow to expand the graph in the direction of the arrow. Clicking on any hollow arrow will shrink the graph. To select all the fields for a given entity, select the check box to the right of the entity name.5.	Press the OK button')) open</body><body package="Lens-Dev">sameCategory	^self</body></methods><methods><class-id>Lens.LensApplicationSpecEditor</class-id> <category>resources</category><body package="Lens-Dev">menuBar	| mb |	mb := self class menuBar.	(mb atNameKey: #sameCategory)		submenu: [self categoryListMenu].	^mb</body><body package="Lens-Dev">templatesMenu	templatesMenuHolder isNil ifTrue: [self updateTemplatesMenu].	^templatesMenuHolder</body></methods><methods><class-id>Lens.LensApplicationSpecEditor</class-id> <category>initialize-release</category><body package="Lens-Dev">initialize	super initialize.	spec := LensApplicationSpec new.	spec addDependent: self.	graphView := LensGraphView onPerspective: #dbtable.	typesMenu := nil asValue.	generator := LensDataModelGenerator new.	newFields := OrderedCollection new</body></methods><methods><class-id>Lens.LensApplicationSpecEditor</class-id> <category>updating</category><body package="Lens-Dev">update: anAspectSymbol with: aParameter from: aSender 	(anAspectSymbol == #value and: [aSender == spec])		ifTrue: [self setEnablement].	^self update: anAspectSymbol with: aParameter</body></methods><methods><class-id>Lens.LensApplicationSpecEditor class</class-id> <category>class initialization</category><body package="Lens-Dev">initialize	"LensApplicationSpecEditor initialize"	LastDataModel := Array new: 2</body></methods><methods><class-id>Lens.LensApplicationCreationDialog</class-id> <category>accessing</category><body package="Lens-Dev">containers	spec rowType isNil ifTrue: [ spec rowType: OrderedCollection new].	^spec rowType</body><body package="Lens-Dev">dataModel: ldm 	"A new Data Model has been selected. Update the containers, types and 	the spec. Make sure the entities list is empty and set the enablement of the 	'addType' button"	dataModel := ldm.	self containers removeAll: self containers copy.	self updateTypesMenu.	generator lensDataModel: ldm.	ldm notNil		ifTrue: 			[spec dataModel isNil ifTrue: [spec dataModel: (Array new: 2)].			spec dataModel at: 1 put: ldm applicationName.			spec dataModel at: 2 put: ldm selector asSymbol].	self entities list: #().	spec changed: #value.	self updateAddTypeButton</body><body package="Lens-Dev">fixedAppType	fixedAppType isNil ifTrue: [^false].	^fixedAppType</body><body package="Lens-Dev">fixedAppType: flag	fixedAppType := flag</body><body package="Lens-Dev">selectedDataModel	^dataModel</body><body package="Lens-Dev">selectedType	^nil</body><body package="Lens-Dev">spec	^spec</body><body package="Lens-Dev">spec: aSpec 	"If the given spec has an appType given we assume that what is wanted is to keep the type locked. If it is wanted otherwise the fixedAppType: message can be used to override"	spec notNil ifTrue: [spec removeDependent: self].	spec := aSpec.	spec lockPolicy isNil ifTrue: [spec lockPolicy: #lockOnAccept].	self startEditing.	spec addDependent: self.	fixedAppType isNil ifTrue: [spec appType notNil ifTrue: [self fixedAppType: true]]</body></methods><methods><class-id>Lens.LensApplicationCreationDialog</class-id> <category>changes</category><body package="Lens-Dev">addAReference: ref 	"Adds a type to the graphView"	ref reset.	dataModel structureTypes do: [:dm | dm name == ref referredName ifTrue: [ref referred: dm]].	ref application: self.	self containers addLast: ref.</body><body package="Lens-Dev">addAType	"Adds a type to the graphView"	| ty count tag contRef |	ty := addtype value.	count := 1.	self containers do: [:con | con referred == ty ifTrue: [count := count + 1]].	tag := ty name asString.	tag at: 1 put: (tag at: 1) asLowercase.	tag = ty name asString		ifTrue: [tag := tag, '_'].	count &gt; 1		ifTrue: [tag := tag , count printString]		ifFalse: [tag := tag copy].	self containers addLast: (contRef := LensContainerReference on: ty named: tag).	contRef application: self.	self entities list: self containers.	self setEnablement</body><body package="Lens-Dev">appTypeChanged	"If the application type for the class to be created has changed, then if it is 	a database application make sure the DataModel is loaded. Also set the 	subcanvas and the enablement of UI components"	spec appType == lastAppType ifTrue: [^nil].	lastAppType := spec appType.	lastAppType == #LensDataManager		ifTrue: 			[self setSubCanvasTo: #dataPanelSpec.			dataModel isNil ifTrue: [self changedDataModel]]		ifFalse: 			[spec rowType: OrderedCollection new.			self entities list: #().			lastAppType == #LensMainApplication				ifTrue: 					[((builder bindings at: #ultimateClient ifAbsent: [])						isKindOf: LensEditor)						ifTrue: [self setSubCanvasTo: #modelersMainApplicationSpec]						ifFalse: [self setSubCanvasTo: #mainApplicationSpec].					dataModel isNil ifTrue: [self changedDataModel]]				ifFalse: 					[self setEnablement.					self setSubCanvasTo: #emptySpec]]</body><body package="Lens-Dev">changedDataModel	"If the application type is a database application, then  if the selector and the class have 	already been entered then try to fetch the DataModel, update the types menu and clear the graph"	(self builder notNil and: [self builder window notNil and: [(spec appType == #LensDataManager or: [spec appType == #LensMainApplication])]])		ifTrue: 			[| clSym selSym |			self entities list: #().			self spec dataModel isNil ifTrue: [^true].			clSym := self spec dataModel at: 1.			selSym := self spec dataModel at: 2.			(clSym size &gt; 0 and: [selSym size &gt; 0])				ifTrue: 					[self dataModel: (self dataModelFor: self spec dataModel).					dataModel notNil ifTrue: [^true].					^true]				ifFalse: [^true]]</body><body package="Lens-Dev">checkClassName	"Check the class name. If the class exists ask whether the user 	really wants to redefine it"	| cn good ns |	cn := (builder componentAt: #specName) widget controller editValue.	ns := (builder aspectAt: #nameSpace) value.	good := false.	cn size == 0		ifFalse: 			[ns at: cn asSymbol ifAbsent: [good := true]."			[Smalltalk at: cn asSymbol ifAbsent: [good := true]."			good ifFalse: [good := Dialog confirm: ((#GenKeyCheckClassName &lt;&lt; #lensDev &gt;&gt; 'The class &lt;1s&gt; is already in the system.&lt;n&gt;Do you want to redefine it?')			expandMacrosWith: (ns at: cn asSymbol) displayString) for: builder window]].	good		ifTrue: 			[spec nameSpace: ns]		ifFalse: 			[spec name: nil.			spec nameSpace: nil.			spec changed: #value].	^good</body><body package="Lens-Dev">checkFields	^self checkClassName</body><body package="Lens-Dev">doneEditing	"Copy the data back into the original spec. If necessary, update the dataModel"	| rt |	rt := spec rowType.	rt do: [:t | t reset].	spec rowType: rt asArray.	dataModel notNil ifTrue: [LastDataModel := self spec dataModel copy]</body><body package="Lens-Dev">enable: aBoolean group: ids 	"Enable or disable a collection of widgets whose names are given in ids"	ids		do: 			[:id | 			| comp |			comp := builder componentAt: id.			(comp isNil and: [subBuilder notNil])				ifTrue: [comp := subBuilder componentAt: id].			comp notNil ifTrue: [aBoolean					ifTrue: [comp enable]					ifFalse: [comp disable]]]</body><body package="Lens-Dev">selectionInList	"A new element has been selected in the graph, if it's a 	LensContainerReference enable the delete button"	self builder notNil ifTrue: [self enable: self entities selection notNil group: #(#removeEntity )]</body><body package="Lens-Dev">setEnablement	self enable: self canEnableOK group: #(#accept )</body><body package="Lens-Dev">startEditing		(spec dataModel isNil and:			[spec superclass ~~ #LensMainApplication])		ifTrue: [spec dataModel: self class lastDataModel].	self changedDataModel.	spec rowType isNil		ifTrue: [spec rowType: OrderedCollection new]		ifFalse: [spec rowType: (spec rowType collect: [:cr | (cr copy asContainerReference) application: self; yourself]) asOrderedCollection].	spec rowType do: [:rt | self addAReference: rt].	spec changed: #value.</body><body package="Lens-Dev">updateAddTypeButton	| c |	c := self componentAt: #addType.	c notNil ifTrue: [(dataModel notNil and: [dataModel structureTypes size &gt; 0])			ifTrue: [c enable]			ifFalse: [c disable]]</body><body package="Lens-Dev">updateTypesMenu	"The types menu is composed of all the mapped types in the data model. 	They are presented in alphabetical order"	| c |	c := builder isNil				ifTrue: [nil]				ifFalse: [builder componentAt: #addType].	dataModel isNil		ifTrue: [c notNil ifTrue: [c disable]]		ifFalse: 			[| mb sortedTypes |			c notNil ifTrue: [c enable].			mb := MenuBuilder new.			sortedTypes := dataModel mappedTypes asSortedCollection: [:a :b | a name &lt;= b name].			sortedTypes do: [:mt | mb add: mt name -&gt; mt].			typesMenu value: mb menu]</body></methods><methods><class-id>Lens.LensApplicationCreationDialog</class-id> <category>resources</category><body package="Lens-Dev">typesMenu	^typesMenu</body></methods><methods><class-id>Lens.LensApplicationCreationDialog</class-id> <category>private</category><body package="Lens-Dev">canEnableOK	^spec name size &gt; 0 and: [ spec category size &gt; 0 and: [spec superclass size &gt; 0 and: [spec appType ~~ #LensDataManager or: [spec rowType size &gt; 0]]]]</body><body package="Lens-Dev">componentAt: aSymbol 	^builder isNil		ifTrue: [nil]		ifFalse: [builder componentAt: aSymbol]</body><body package="Lens-Dev">dataModelFor: anArray 	"arr is composed of a class name and a selector"	| ldm cl |	cl := (anArray at: 1) asQualifiedReference valueOrDo: [nil].	cl isNil		ifTrue: 			[Dialog warn: ((#GenKeyClassNameNotExist &lt;&lt; #lensDev &gt;&gt; 'The class:&lt;nn&gt;&lt;1s&gt;&lt;nnt&gt;does not exist')			expandMacrosWith: (anArray at: 1)) for: builder window.			^nil].	self errorSignal		handle: 			[:ex | 			Dialog warn: (#DataModelNotValidBrowse &lt;&lt; #lensDev &gt;&gt; 'Data Model not valid.Use "Browse..." to select a new one') for: builder window.			^nil]		do: [ldm := LensDataModel readFromClass: cl methodName: (anArray at: 2)].	^ldm</body><body package="Lens-Dev">disableOtherTypes	"Enable the radio button of only the option that is already in the spec"	spec notNil		ifTrue: 			[self enable: spec appType == #LensDataManager group: #(#specTypeData ).			self enable: spec appType == #SimpleDialog group: #(#specTypeDialog ).			self enable: spec appType == #ApplicationModel group: #(#specTypeWindow ).			self enable: spec appType == #LensMainApplication group: #(#specTypeMain )]</body><body package="Lens-Dev">finalizeSpec	"If the finished spec calls for a LensMainApplication, and the client that	was asking for this was a LensEditor, null out the datamodel field so that	no model designator method will be written in this case, as we are installing	a data model directly on the class."	| cl |	LensNamespaceControl lastDataApplicationNameSpace: (self builder aspectAt: #nameSpace) value.	(((cl := self class environment at: spec superclass asSymbol) == LensMainApplication or:		[cl inheritsFrom: LensMainApplication]) and:		[builder notNil and:			[(builder bindings at: #ultimateClient ifAbsent: []) isKindOf: LensEditor]])		ifTrue: [spec dataModel: nil]</body><body package="Lens-Dev">setSubCanvasTo: aSpec 	builder notNil		ifTrue: 			[| subC |			subC := (builder componentAt: #subCanvas) widget.			subC notNil				ifTrue: 					[subBuilder := self builderClass new.					subC						client: self						spec: aSpec						builder: subBuilder]]</body><body package="Lens-Dev">validateFields	"Make sure that the given fields make sense. Check that the superclass is 	indeed a sub-class of the right class. If not, popup a dialog but give the 	opportunity to continue"	| superCl expectedSuperCl |	spec appType asSymbol == spec superclass asSymbol ifTrue: [^true].	expectedSuperCl := self class environment at: spec appType asSymbol ifAbsent: [Object].	superCl := self class environment at: spec superclass asSymbol				ifAbsent: 					[Dialog warn: (#GenKeySuperClassNotExist &lt;&lt; #lensDev &gt;&gt; 'The given superclass does not exist').					^false].	(superCl = expectedSuperCl or: [superCl inheritsFrom: expectedSuperCl])		ifTrue: [^true].	^Dialog		confirm: ((#GenKeyInvalidSuperClass &lt;&lt; #lensDev &gt;&gt; 'The class &lt;1s&gt; does not inherit from the default superclass &lt;2s&gt;&lt;n&gt;The expected behavior for this kind of application class may not be correct.&lt;n&gt;Do you want to continue?')			expandMacrosWith: spec superclass			with: spec appType)		initialAnswer: false		for: self builder window</body></methods><methods><class-id>Lens.LensApplicationCreationDialog</class-id> <category>interface opening</category><body package="Lens-Dev">postOpenWith: aBuilder 	"If the appType is fixed then disable all the others"	self updateAddTypeButton.	self fixedAppType 		ifTrue: [self disableOtherTypes].	self appTypeChanged.	self setEnablement</body></methods><methods><class-id>Lens.LensApplicationCreationDialog</class-id> <category>actions</category><body package="Lens-Dev">helpActionForDialog(SimpleHelp helpString: (#GenKeyHelpActionForDialog &lt;&lt; #lensDev &gt;&gt; 'Creating a New Application ClassThis Dialog appears in different forms depending on the type of class to be created; it may appear as part of installing a newly created resource (e.g. a menu, or a Data Model) on a class that doesn''t yet exist.  In these cases, the type of the class to be created can depend on the type of resource to be installed.1.	Enter the name and category for the new application class.  A category is a subdivision of the classes in the system. It affects only how the new class will be presented in browsers.  For database applications, the default category is the category of the data model you worked with most recently.  The first letter of the class name will become capitalized, even if it is entered in lower case.2.	Use the ''Define As'' radio buttons to select the type of class to be created.  If the type of the class is already determined, some or all of these buttons may be disabled.  In this step, you are determining the superclass of the new application class.  There are four basic kinds:	Dialog		A window that will be used as a simple dialog	Application		A persistent window for an ordinary application	Data Form		A component that presents database objects	Main Application		A ''top level'' database application that holds a data model and uses Data Forms as its componentsThe application''s superclass is based on these choices, but for each general type you can also specify the specific superclass to be used, by entering its name.3.	If the class is either a Database Application or a Data Form, select the Data Model.  By default, the last Data Model you worked with is displayed.  To specify a different Data Model, use the Browse button to select from among all the Data Models currently installed in the system.4.	If the class is a Database Application, select the row Locking Policy to be used5.	If the class is a Data Form, select the Entities to be included in each row (what entities are available depends on the Data Model you selected).  The available entities are on a menu under the Add Entity menu button.  One generally selects only a single entity, unless the Data Form is intended to handle the result of a joined query.6.	Press the OK button')) open</body><body package="Lens-Dev">removeType	"A type is selected in the graph, remove it from the rowType"	| typ |	typ := entities selection.	typ notNil		ifTrue: 			[spec rowType remove: typ ifAbsent: [nil].			self entities list: self containers]</body></methods><methods><class-id>Lens.LensApplicationCreationDialog</class-id> <category>aspects</category><body package="Lens-Dev">addtype	addtype isNil		ifTrue: 			[addtype := nil asValue.			addtype onChangeSend: #addAType to: self].	^addtype</body><body package="Lens-Dev">entities		entities isNil		ifTrue: 			[entities := SelectionInList new.			entities selectionIndexHolder onChangeSend: #selectionInList to: self].	^entities</body></methods><methods><class-id>Lens.LensApplicationCreationDialog</class-id> <category>initialize release</category><body package="Lens-Dev">initialize	super initialize.	spec := LensApplicationSpec new.	spec addDependent: self.	spec lockPolicy: #lockOnAccept.	typesMenu := nil asValue.	accept onChangeSend: #doneEditing to: self. 	generator := LensDataModelGenerator new.</body></methods><methods><class-id>Lens.LensApplicationCreationDialog</class-id> <category>updating</category><body package="Lens-Dev">update: anAspectSymbol with: aParameter from: aSender 	(aSender == spec)		ifTrue: [self setEnablement].	^self update: anAspectSymbol with: aParameter</body></methods><methods><class-id>Lens.LensApplicationCreationDialog</class-id> <category>data model actions</category><body package="Lens-Dev">browseDataModel	"Ask the generator to load a new data model, selected by the user. Do so 	aborting the loading if there is any problem in the Data Model"	| ldm |	(ldm := generator loadDataModel: false) notNil		ifTrue: 			[self dataModel: ldm.			spec changed: #at with: 1.			spec changed: #at with: 2]</body></methods><methods><class-id>Lens.LensApplicationCreationDialog class</class-id> <category>class initialization</category><body package="Lens-Dev">defaultDataModel: anArray	LastDataModel := anArray copy</body><body package="Lens-Dev">initialize	"LensApplicationCreationDialog initialize"	LastDataModel := nil</body></methods><methods><class-id>Lens.LensApplicationCreationDialog class</class-id> <category>accessing</category><body package="Lens-Dev">categoryOfDefaultDataModel	"Returns the category of the class from the default data model"	(LastDataModel notNil and: [(LastDataModel at: 1) notNil])		ifTrue: 			[| cl |			cl := self environment at: (LastDataModel at: 1) asSymbol ifAbsent: [^nil].			cl notNil ifTrue: [^cl category]].	^nil</body><body package="Lens-Dev">lastDataModel	"Return the designator for the last data model used. Check first that the class 	exists and it responds to the message. Return nil otherwise"	LastDataModel notNil ifTrue: [		| className methodName |		className := LastDataModel at: 1.		methodName := LastDataModel at: 2.		className notNil ifTrue: [			| dataModelClass |			dataModelClass := className asQualifiedReference valueOrDo: [nil].			(dataModelClass notNil and: [dataModelClass respondsTo: methodName])				ifFalse: [LastDataModel := nil]]].	^LastDataModel</body></methods><methods><class-id>Lens.LensEditor</class-id> <category>actions</category><body package="Lens-Dev">addClassForTable: table 	"Generate a class for the given table. Use the generator to do it. If successful invalidate the data 	model and redisplay the graph having the new type selected"	| typ |	Cursor execute showWhile: [(typ := generator automaticClassForTable: table) notNil			ifTrue: 				[self selectedDataModel invalidate.				self computeValueClassesMenu.				self recomputeTableClassMap.				self select: typ]]</body><body package="Lens-Dev">addClassToDataModel	"Create the class if necessary"	^self addNewClassToDataModel: true</body><body package="Lens-Dev">addExistingClassToDataModel	^self addNewClassToDataModel: false</body><body package="Lens-Dev">addNewClassToDataModel	^self addNewClassToDataModel: true</body><body package="Lens-Dev">addNewClassToDataModel: shouldCreate 	"Adds a new to the Data Model, this class will be just added and mapped 	later. Popup a dialog allowing the user to enter the nameof the class to be 	added. The class will be created if it doesn't exist. A default annotation for 	the class will be created. Once everything is done, the newly created	entity is selected in the graph"	| cl res clName dm nameSpace |	(dm := self selectedDataModel) notNil		ifTrue: 			[res := self openTargetClassNameDialogFor: nil nameSpace: nil message: (#EnterClassNameC &lt;&lt; #lensDev &gt;&gt; 'Enter class name:').			(res notNil and: [(clName := res className) size &gt; 0])				ifTrue: 					[ | typ |					nameSpace := res nameSpace.					clName := clName asString.					clName at: 1 put: (clName at: 1) asUppercase.					(typ := dm typeNamed: clName asSymbol) notNil						ifTrue:							[^Dialog warn: ((#GenKeyNameUsedInDataModel &lt;&lt; #lensDev &gt;&gt; '&lt;1s&gt; is already in use in the data model')			expandMacrosWith: clName) for: builder window].					cl := nameSpace at: clName asSymbol ifAbsent: [nil].					(cl notNil and: [(typ := cl typeClass) == LensDataType or: [typ inheritsFrom: LensDataType]])						ifTrue:							[^Dialog warn: ((#GenKeyInvalidEntity &lt;&lt; #lensDev &gt;&gt; '&lt;1s&gt; is a basic data type and&lt;n&gt;should not be used as an Entity.')			expandMacrosWith: clName) for: builder window].					cl isNil ifTrue: [shouldCreate							ifTrue: [cl := self createClassNamed: clName nameSpace: nameSpace]							ifFalse: [^Dialog warn: ((#GenKeyClassNotExist &lt;&lt; #lensDev &gt;&gt; 'The class: &lt;1s&gt;&lt;n&gt;does not exist.')			expandMacrosWith: clName) for: builder window]].					cl notNil						ifTrue: 							[| newType |							Cursor execute showWhile: [								dm addStructureType: (newType := self typeFrom: cl).								self selectedDataModel invalidate.								self recomputeTableClassMap.								self select: newType.								self computeValueClassesMenu.								mappingEditor isNil ifTrue: [self showMapping]]]]]</body><body package="Lens-Dev">checkDataModel	"Check that the data model is in a consistent state by itself and also with 	respect to the database. The check is done even if the data model has	not been marked not updated. Mark the data model as not saved because	checking against the database at least may change the state of the	data model and potentially it may have changed some of the types"	self autoAcceptAll.	Cursor database showWhile:		[LensSession doNotProceedSignal			handle:				[:ex | ex return]			do: 				[| ldm cs oldValidity |				((ldm := self selectedDataModel) notNil and: [(cs := self catalogLens) notNil]) ifTrue:					[ldm isConsistent ifTrue: 						[oldValidity := ldm validity.						 ldm compile.						ldm databaseContext synchronizeDataDictionaryFor: ldm in: cs.						oldValidity ~~ #installed							ifTrue: [ldm saved: false].						Dialog warn: (#GenKeyDatataModelMatchDatabase &lt;&lt; #lensDev &gt;&gt; 'The Data Model matches the database') for: builder window]]]]</body><body package="Lens-Dev">checkTypeAgainstDatabase: type 	"Check that the type is in a consistent state by itself and also with 	respect to the database. Mark the data model as not saved because	checking against the database at least may change the state of the	data model and potentially it may have changed some of the types"	self autoAcceptAll.	Cursor database showWhile:		[LensSession doNotProceedSignal			handle:				[:ex | ex return]			do: 				[| ldm cs |				((ldm := self selectedDataModel) notNil and: [(cs := self catalogLens) notNil]) ifTrue:					[ldm compile.					ldm saved: false.					ldm databaseContext synchronizeDataDictionaryForType: type in: cs.					Dialog warn: (#GenKeyTableMatchDatabase &lt;&lt; #lensDev &gt;&gt; 'The table''s specification matches the database.') for: builder window]]]</body><body package="Lens-Dev">createClassNamed: clName	"Create a new class named clName. Make the superclass be Object and the category be the default category"	| theClass cat |	(cat := self generator defaultCategory) isNil ifTrue: [^nil].	theClass := self class defaultEntitySuperclass		subclass: clName asSymbol		instanceVariableNames: String new		classVariableNames: String new		poolDictionaries: String new		category: cat.	SourceFileManager default logChange: theClass definition.	^theClass</body><body package="Lens-Dev">createClassNamed: clName nameSpace: ns	"Create a new class named clName. Make the superclass be Object and the category be the default category"	| theClass cat |	(cat := self generator defaultCategory) isNil ifTrue: [^nil].	theClass := ns defineClass: clName asSymbol		superclass: self class defaultEntitySuperclass name asQualifiedReference		indexedType: #none		private: false		instanceVariableNames: ''		classInstanceVariableNames: ''		imports: ''		category: cat.	SourceFileManager default logChange: theClass definition.	^theClass</body><body package="Lens-Dev">editMainCanvas	"Edit the main application's canvas. The default 'windowSpec' is used"	| cl  |	cl := self selectedDataModel application.	UIPainter new openOnClass: cl andSelector: #windowSpec</body><body package="Lens-Dev">editProperties	"Use a generator to edit the properties of the current data model. If the generator ended with success, 	update the data model"	|  dataModel |	self autoAcceptAll.	(dataModel := generator editDataModelProperties) == nil ifTrue: [^self].	dataModel invalidate.	self selectedDataModel: dataModel</body><body package="Lens-Dev">helpAction	VisualLauncher openHelpBrowser</body><body package="Lens-Dev">inferReferences	"Try to infer the references between the tables already in the data model. 	Don't touch references already established"	self autoAcceptAll.	LensSession doNotProceedSignal handle: [:ex | ex return]		do: [generator inferReferences				ifTrue: 					[self selectedDataModel invalidate.					self recomputeTableClassMap]]</body><body package="Lens-Dev">inferReferencesFromSelection	"Try to infer the references between the selected entity and the other tables already in the data model. If a variable is selected then the type of the variable will be used, this is handled automatically by using the message 'self selectedType'"	self autoAcceptAll.	LensSession doNotProceedSignal handle: [:ex | ex return]		do: [(self selectedType notNil and: [self selectedType isKindOf: LensStructureType])				ifTrue: [(generator inferReferencesFrom: self selectedType)						ifTrue: [self selectedDataModel invalidate]]].	self recomputeTableClassMap</body><body package="Lens-Dev">loadDataModel	"Use the generator"	| ldm |	self changeRequest ifFalse: [^self].	ldm := generator loadDataModel.	ldm notNil		ifTrue: 			[self selectedDataModel: ldm]</body><body package="Lens-Dev">mapTable: theTable 	"The user selected an existing table the class should be mapped to it. After it is done make sure the 	mapping is redisplayed (to reflect the change in the mapping of the type) and reselect the type so the 	buttons that depend on the selected type are updated (at least the 'Map' button in the tables window)"	| typ |	typ := self selectedType.	typ notNil		ifTrue: 			[typ idVariables size == 0				ifTrue: 					[Dialog warn: ((#GenKeyDefineKey &lt;&lt; #lensDev &gt;&gt; 'Entity "&lt;1s&gt;" cannot be mapped without a key definition.&lt;n&gt;Use the Mapping Tool to define a key.')			expandMacrosWith: typ name) for: builder window.					^nil].			typ clearMappings.			typ table: theTable.			self selectedDataModel invalidate.			self redisplayMapping.			self select: typ]</body><body package="Lens-Dev">newDataModel	"Create a new dataModel."	| ldbg dataModel |	self changeRequest ifFalse: [^self].	ldbg := LensDataModelGenerator new.	(dataModel := ldbg newDataModel) == nil ifTrue:		[ ^self ].	self selectedDataModel: dataModel.	self selectedDataModel invalidate.</body><body package="Lens-Dev">newQuery	| ldm |	ldm := self selectedDataModel.	ldm notNil ifTrue: [		Cursor execute showWhile: [(QueryEditor new) ldm: ldm; open]]</body><body package="Lens-Dev">openLensNamespaceControl	LensNamespaceControl open</body><body package="Lens-Dev">regenerateAccessMethods	"Regenerate the access methods for the selected types"	ldmView selectionDo: [:e | e regenerateAccessMethods]</body><body package="Lens-Dev">regenerateAllAccessMethods	self selectedDataModel structureTypes do: [:st | st regenerateAccessMethods]</body><body package="Lens-Dev">removeClassFromDataModel	"The selected class is removed from the DataModel's structureTypes list"	| theType |	theType := self selectedType.	theType notNil		ifTrue: 			[| res |			res := Dialog						choose: ((#GenKeyRemoveEntityAndClass &lt;&lt; #lensDev &gt;&gt; 'Remove entity &lt;1s&gt; from the Data Model&lt;n&gt;and remove class &lt;2s&gt; from the system?')			expandMacrosWith: theType memberClass name			with: theType memberClass name)						labels: (Array with: (#RemoveEntityOnly &lt;&lt; #lensDev &gt;&gt; 'Remove Entity Only') with: (#RemoveBoth &lt;&lt; #lensDev &gt;&gt; 'Remove Both') with: (#Cancel &lt;&lt; #lensDev &gt;&gt; 'Cancel'))						values: #(#entity #class #abort )						default: #class						for: builder window.			res == #abort ifTrue: [^nil].			res == #class ifTrue: [theType memberClass removeFromSystem].			self selectedDataModel removeStructureType: theType uiWindow: builder window.			self selectedDataModel invalidate.			self recomputeTableClassMap]</body><body package="Lens-Dev">saveDataModel	"Save the data model into the class and selector"	| ldm win |	self autoAcceptAll.	builder notNil ifTrue: [win := builder window].	(ldm := self selectedDataModel) notNil		ifTrue: [ldm isConsistent			ifTrue: 				[ldm isCompiled					ifFalse:						[(LensSession doNotProceedSignal							handle:								[:ex |								Dialog warn: (#GenKeyUnableToCompileDataModel &lt;&lt; #lensDev &gt;&gt; 'Operation Terminated:Unable to compile Data Model') for: win.								ex returnWith: nil]							do: [ldm compile]) isNil ifTrue: [^self]].				generator reviseClasses.				self runInstallationDialog notNil					ifTrue: 						[ldm writeSpec.						ldm removeDesignator.						LensApplicationCreationDialog defaultDataModel: (Array with: ldm applicationName with: ldm selector).						UIFinderVW2 installed: (Array with: ldm application with: ldm selector).						ldm saved: true]]]</body><body package="Lens-Dev">updateAll	self autoAcceptAll.	self recomputeTableClassMap.	self computeValueClassesMenu</body></methods><methods><class-id>Lens.LensEditor</class-id> <category>private</category><body package="Lens-Dev">autoAcceptAll	"Notify dependent mappingTools that any pending edits should be updated"	selectedType changed: #autoAccept</body><body package="Lens-Dev">computeValueClassesMenu	"The Value Classes are all the valuetypes of the data model, but not those 	that are Identity Sets"	self selectedDataModel notNil		ifTrue: 			[| allNames mb grp |			allNames := self selectedDataModel valueTypes reject: [:t | t name == #IdentitySet].			mb := MenuBuilder new.			grp := allNames select: [:t | t isKindOf: LensDataType].			mb addLabels: (grp collect: [:each | each displayString])				andValues: grp.			mb line.			grp := allNames select: [:t | t isKindOf: LensEncodedType].			mb addLabels: (grp collect: [:each | each displayString])				andValues: grp.			mb line.			grp := allNames select: [:t | t isKindOf: LensStructureType].			mb addLabels: (grp collect: [:each | each displayString])				andValues: grp.			self valueClassesMenu value: mb menu]</body><body package="Lens-Dev">modelHasChildSets	| mdl |	(mdl := self selectedDataModel) isNil ifTrue: [^false].	^(mdl valueTypes detect: [:typ | typ isKindOf: LensCollectionType] ifNone: []) notNil</body><body package="Lens-Dev">newVariable	"An empty variable row, with the most likely defaults"	| var |	(var := LensStructureVariable new)			setValueType: (self selectedDataModel typeNamed: #Object).	var generatesAccessor: true.	var generatesMutator: true.	^var</body><body package="Lens-Dev">resetChildSets	(mappingEditor notNil and:		[mappingEditor builder notNil and:			[mappingEditor builder window notNil]])		ifTrue:			[self useChildSets				ifTrue: [mappingEditor enableChildSets]				ifFalse: [mappingEditor disableChildSets]]</body><body package="Lens-Dev">runInstallationDialog	| result |	result :=		self targetClass isNil			ifTrue:				[UIFinderVW2					openDestinationDialogForCategory: #'lens data model specs'					nameSpace: nil					defaultSelector: #dataModelSpec					creationData: (Array with: #LensMainApplication with: (self generator defaultCategory: false) with: self)]			ifFalse:				[UIFinderVW2					openDestinationDialogWithClass: self targetClass					nameSpace: self targetClass environment					andSelector: self targetSelector					andCategory: #'lens data model specs'					creationData: (Array with: #LensMainApplication with: (self generator defaultCategory: false) with: self)].	result isNil ifTrue: [^nil].	self targetClass: (result at: 1).	self targetSelector: (result at: 2).	selectedDataModelHolder changed: #value.	^result</body><body package="Lens-Dev">runInstallationDialogNew	| result |	result :=		self targetClass isNil			ifTrue:				[UIFinderVW2					openDestinationDialogForResource: #dataModel					defaultSelector: #dataModelSpec					creationData: (Array with: #{LensMainApplication} with: (self generator defaultCategory: false) with: self)]			ifFalse:				[UIFinderVW2					openDestinationDialogWithClass: self targetClass					andSelector: self targetSelector					andResource: #dataModel					creationData: (Array with: #{LensMainApplication} with: (self generator defaultCategory: false) with: self)].	result isNil ifTrue: [^nil].	self targetClass: (result at: 1).	self targetSelector: (result at: 2).	selectedDataModelHolder changed: #value.	^result</body><body package="Lens-Dev">select: anElement	"Ask the graph view (ldmView) to select the given element"	ldmView notNil ifTrue: [ldmView select: anElement]</body><body package="Lens-Dev">typeFrom: cl 	"Create a LensStructureType for the class cl."	| ann lst varNames |	ann := cl typeClass new.	ann memberClass: cl.	lst := ann variables.	varNames := cl allInstVarNames.	1 to: varNames size do:		[:index | | var |		(var := self newVariable)			name: (varNames at: index);			objectType: ann;			instVarIndex: index.		lst addLast: var].	ann dataModel: self selectedDataModel.	self selectedDataModel invalidate.	^ann</body><body package="Lens-Dev">useChildSets	^EnableChildSets or: [self modelHasChildSets]</body></methods><methods><class-id>Lens.LensEditor</class-id> <category>reference</category><body package="Lens-Dev">canReference: el	^el isKindOf: LensStructureVariable</body><body package="Lens-Dev">candidateToReference: els 	"els maybe candidate to be a reference to a table (another structureType 	really), enable/disable the 'reference' button accordingly"	els size &gt; 0		ifTrue: 			[els do: [:el | (self canReference: el)					ifFalse: [^self enableReferenceButton: false]].			self enableReferenceButton: true]		ifFalse: [self enableReferenceButton: false]</body><body package="Lens-Dev">enableReferenceButton: flag 	| b |	b := builder componentAt: #referenceButton.	flag		ifTrue: [b enable]		ifFalse: [b disable]</body><body package="Lens-Dev">reference: els to: aLST 	"Make the elements in the list els reference the type given by aLST. Use the 	generator to do the job and update the graph if the work was done"	| res |	res := self generator reference: els  in: els first objectType to: aLST.	res notNil		ifTrue: 			[self selectedDataModel invalidate.			self ldmView closeInOf: (res at: 1)				andOpenOutOf: (res at: 2)]</body><body package="Lens-Dev">referenceButtonPressed	"The reference button has been pressed, take the current selection and 	keep it until the next time something is selected"	referenceButton value		ifTrue: 			[toReference := OrderedCollection new.			ldmView selectionDo: [:p | toReference add: p]]</body><body package="Lens-Dev">selectionInGraph	"A selection happened in the graph view, check whether the selected elements can reference and 	update the reference button accordingly. Also update the selectedType accordingly"	| sel |	sel := OrderedCollection new.	ldmView selectionDo: [:p | sel add: p].	(sel size == 1 and: [referenceButton value])		ifTrue: 			[self reference: toReference to: sel first.			referenceButton value: false]		ifFalse: 			[referenceButton value: false.			self candidateToReference: sel].	sel size == 1		ifTrue: [(sel first isKindOf: LensStructureType)				ifTrue: [self selectedType: sel first]				ifFalse: [self selectedType: sel first objectType]]		ifFalse: [self selectedType: nil]</body></methods><methods><class-id>Lens.LensEditor</class-id> <category>accessing</category><body package="Lens-Dev">catalogLens	"Reuse the generato's catalog lens"	^generator catalogLens</body><body package="Lens-Dev">generator	^generator</body><body package="Lens-Dev">generator: aLensDataModelGenerator	generator := aLensDataModelGenerator</body><body package="Lens-Dev">selectedDataModel	"Answer the currently selected DataModel."	"Assume: selectedDataModelHolder has been initialized already."	^selectedDataModelHolder value</body><body package="Lens-Dev">selectedDataModel: aDataModel	"Set the currently selected DataModel."	"Assume: selectedDataModelHolder has been initialized already."	selectedDataModelHolder value: aDataModel.	self resetChildSets.	self changed: #dataModel</body><body package="Lens-Dev">selectedType	^selectedType value</body><body package="Lens-Dev">selection	"Returns the collection of elements selected in the graph view"	^ldmView selectionService selectedPerformers</body><body package="Lens-Dev">targetClass	self selectedDataModel notNil ifTrue: [^self selectedDataModel application].	^nil</body><body package="Lens-Dev">targetClass: cl	self selectedDataModel notNil ifTrue: [self selectedDataModel application: cl].</body><body package="Lens-Dev">targetSelector	self selectedDataModel notNil ifTrue: [^self selectedDataModel selector].	^nil</body><body package="Lens-Dev">targetSelector: sel	self selectedDataModel notNil ifTrue: [self selectedDataModel selector: sel].</body></methods><methods><class-id>Lens.LensEditor</class-id> <category>aspects</category><body package="Lens-Dev">dataModelNameAdaptor	"Returns a PluggableAdaptor whose value is the concatenation of the class 	name and the selector where the selectedDataModel is pickled"	^(PluggableAdaptor on: self selectedDataModelHolder)		getBlock: 			[:m | 			| o |			o := m value.			o isNil ifFalse: [o selector notNil					ifTrue: [o selector]					ifFalse: ['']]				ifTrue: ['']]		putBlock: [:m :v | ]		updateBlock: [:m :a :v | true]</body><body package="Lens-Dev">ldmView	^ldmView isNil		ifTrue: [ldmView := LensGraphView new]		ifFalse: [ldmView]</body><body package="Lens-Dev">mainMessage	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^mainMessage isNil		ifTrue: [mainMessage := String new asValue]		ifFalse: [mainMessage]</body><body package="Lens-Dev">selectedDataModelHolder	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^selectedDataModelHolder isNil ifTrue: [selectedDataModelHolder := nil asValue] ifFalse: [selectedDataModelHolder]</body><body package="Lens-Dev">selectorNameAdaptor	^(AspectAdaptor forAspect: #selector)			subjectChannel: self selectedDataModelHolder;			subjectSendsUpdates: false</body></methods><methods><class-id>Lens.LensEditor</class-id> <category>resources</category><body package="Lens-Dev">menuBar	| enableIfClassSelectionBlock enableIfLdm menu subMenu mi1 mi2 enableIfNotEmpty mi3 mi4 mi |	enableIfClassSelectionBlock :=		[ self selectedType notNil].	enableIfLdm := 		[ self selectedDataModel notNil].	enableIfNotEmpty :=		[ self selectedDataModel notNil and: [self selectedDataModel structureTypes size &gt; 0]].	menu := Menu new."Model'"	subMenu := Menu new.	mi1 := MenuItem labeled: (#New &lt;&lt; #lensDev &gt;&gt; 'New...').	mi2 := MenuItem labeled: (#Load &lt;&lt; #lensDev &gt;&gt; 'Load...').	subMenu addItemGroup: (Array with: mi1 with: mi2) values: #(#newDataModel #loadDataModel).	(mi1 := MenuItem labeled: (#Properties &lt;&lt; #lensDev &gt;&gt; 'Properties...'))		enabled: enableIfLdm.	(mi2 := MenuItem labeled: (#GenKeyInferForeignKeys &lt;&lt; #lensDev &gt;&gt; 'Infer All Foreign Key References'))		enabled: enableIfNotEmpty.	(mi3 := MenuItem labeled: (#CheckWithDatabase &lt;&lt; #lensDev &gt;&gt; 'Check With Database'))		enabled: enableIfLdm.	(mi4 := MenuItem labeled: (#Install &lt;&lt; #lensDev &gt;&gt; 'Install...'))		enabled: enableIfLdm.	subMenu addItemGroup: (Array with: mi1 with: mi2 with: mi3 with: mi4) values: #(editProperties inferReferences checkDataModel saveDataModel).	"(mi1 := MenuItem labeled: 'Regenerate Access Methods For Selected Entities')		enabled: enableIfClassSelectionBlock.	(mi2 := MenuItem labeled: 'Regenerate Access Methods For All Entities')		enabled: enableIfNotEmpty.	subMenu addItemGroup: (Array with: mi1 with: mi2) values: #(regenerateAccessMethods regenerateAllAccessMethods)."	(mi1 := MenuItem labeled: (#Model &lt;&lt; #lensDev &gt;&gt; 'Model')) submenu: subMenu.	menu addItem: mi1."Entity"	subMenu := Menu new.	(mi1 := MenuItem labeled: (#AddDot &lt;&lt; #lensDev &gt;&gt; 'Add...'))		enabled: enableIfLdm.	(mi2 := MenuItem labeled: (#RemoveDot &lt;&lt; #lensDev &gt;&gt; 'Remove...'))		enabled: enableIfClassSelectionBlock.	subMenu addItemGroup: (Array with: mi1 with: mi2) values: #(addClassToDataModel removeClassFromDataModel).	(mi1 := MenuItem labeled: (#InferForeignKeyReferences &lt;&lt; #lensDev &gt;&gt; 'Infer Foreign Key References'))		enabled: enableIfClassSelectionBlock.	(mi2 := MenuItem labeled: (#ShowReferences &lt;&lt; #lensDev &gt;&gt; 'Show References'))		enabled: enableIfClassSelectionBlock.	subMenu addItemGroup: (Array with: mi1 with: mi2) values: #(inferReferencesFromSelection openAllInGraph).	(mi1 := MenuItem labeled: (#BrowseClass &lt;&lt; #lensDev &gt;&gt; 'Browse Class'))		enabled: enableIfClassSelectionBlock.	subMenu addItemGroup: (Array with: mi1) values: #(browseClass).	(mi := MenuItem labeled: (#Entity &lt;&lt; #lensDev &gt;&gt; 'Entity')) submenu: subMenu.	menu addItem: mi."View"	subMenu := Menu new.	(mi1 := MenuItem labeled: (#DatabaseTables &lt;&lt; #lensDev &gt;&gt; 'Database Tables'))		enabled: enableIfLdm.	(mi2 := MenuItem labeled: (#Mappings &lt;&lt; #lensDev &gt;&gt; 'Mappings'))		enabled: enableIfLdm.	subMenu addItemGroup: (Array with: mi1 with: mi2 ) values: #(showTables showMapping).	(mi1 := MenuItem labeled: (#QueryEditor &lt;&lt; #lensDev &gt;&gt; 'Query Editor'))		enabled: enableIfNotEmpty.	(mi2 := MenuItem labeled: (#LensNamespaceControl &lt;&lt; #lensDev &gt;&gt; 'Lens Namespace Control'))		enabled: true.	subMenu addItemGroup: (Array with: mi1 with: mi2) values: #(newQuery openLensNamespaceControl).	(mi1 := MenuItem labeled: (#Update &lt;&lt; #lensDev &gt;&gt; 'Update'))		enabled: enableIfLdm.	subMenu addItemGroup: (Array with: mi1) values: #(updateAll).	(mi := MenuItem labeled: (#View &lt;&lt; #lensDev &gt;&gt; 'View')) submenu: subMenu.	menu addItem: mi."Help"	subMenu := Menu new.	subMenu addItemLabel: (#Topics &lt;&lt; #lensDev &gt;&gt; 'Topics') value: #helpAction.	(mi := MenuItem labeled: (#Help &lt;&lt; #lensDev &gt;&gt; 'Help')) submenu: subMenu.	menu addItem: mi.	^menu</body><body package="Lens-Dev">nameSpaceMenu	"menu of name spaces"	| nameSpaces names |	nameSpaces := LensNamespaceControl permissableNameSpaces.	names := (Array with: (nameSpaces collect: [:d | d name asText allBold])).	^Menu		labelList: names		values: nameSpaces</body><body package="Lens-Dev">valueClassesMenu	valueClassesMenu isNil ifTrue: [valueClassesMenu := Menu new asValue].	^valueClassesMenu</body></methods><methods><class-id>Lens.LensEditor</class-id> <category>view actions</category><body package="Lens-Dev">browseClass	| typ |	typ := self selectedType.	typ notNil ifTrue: [typ memberClass notNil ifTrue: [SmalltalkWorkbench browseClass: typ memberClass]]</body><body package="Lens-Dev">openAllInGraph	"Opens all the references in the graph starting from the selected elements"	ldmView selectionDo: [:e | ldmView browserModel body openAllFrom: e side: 1 levels: 20]</body><body package="Lens-Dev">showMapping	"Opens a mapping window for the class and the table selected. That window will continue tracking selection"	| uib mainRectangle rect |	self autoAcceptAll.	mappingEditor := LensMappingEditor new.	mappingEditor editor: self.	mappingEditor typeHolder: selectedType.	uib := mappingEditor allButOpenInterface: #windowSpec.	mainRectangle := self builder window getDisplayBox.	rect := Rectangle origin: (mainRectangle bottomLeft x) @ (mainRectangle bottomLeft y + 30) corner: (mainRectangle bottomLeft x + 450) @ (mainRectangle bottomRight y + 320).	uib openIn: rect.	mappingEditor postOpenWith: uib.	uib window application: self.	uib window beSlave.	mappingEditor changedType</body><body package="Lens-Dev">showTables	"Open a slave window that shows tables and their columns, allows the 	mapping of a column to a selected class or the creation of a new class for 	an existing table"	| uib mainRectangle rect tablesSelector |	tablesSelector := LensTablesSelector new.	tablesSelector editor: self.	uib := tablesSelector allButOpenInterface: #windowSpec.	(uib window) application: self; beSlave.	mainRectangle := self builder window getDisplayBox.	rect := Rectangle origin: mainRectangle topRight x + 12 @ mainRectangle topRight y corner: mainRectangle bottomRight x + 320 @ mainRectangle bottomRight y.	uib openIn: rect</body></methods><methods><class-id>Lens.LensEditor</class-id> <category>private-interfaces</category><body package="Lens-Dev">existingClassNamed: aString inNameSpace: aNameSpace fromController: aController	| clName allClassNames matchingClassNames |	(clName := aString asSymbol) isEmpty ifTrue: [^nil].	((allClassNames := aNameSpace classNames) includes: clName)		ifTrue: [^aNameSpace at: clName].	(clName findString: '*' startingAt: 1)		&gt; 0		ifTrue: 			[Cursor execute showWhile: [matchingClassNames := allClassNames select: [:cn | clName match: cn]].			matchingClassNames size = 0				ifTrue: 					[Dialog warn: (#NoMatchingClass &lt;&lt; #lensDev &gt;&gt; 'No matching class') for: aController view.					aController sensor window keyboardProcessor focusIsShifting: false.					^nil].			matchingClassNames size = 1				ifTrue: [clName := matchingClassNames at: 1]				ifFalse: [clName := Dialog							choose: (#FindWhichClass &lt;&lt; #lensDev &gt;&gt; 'Find which class?')							fromList: matchingClassNames							values: matchingClassNames							lines: 10							cancel:								[aController sensor window keyboardProcessor focusIsShifting: false.								^#cancel]							for: aController view]]		ifFalse:			[^(clName := allClassNames detect: [ :n | clName match: n ] ifNone: [ nil ]) notNil ifTrue: [ aNameSpace at: clName ] ifFalse: [ nil ]].	aController sensor window keyboardProcessor focusIsShifting: false.	^aNameSpace at: clName</body><body package="Lens-Dev">postClassCreateDialogResultsTo: results from: dBuilder	| ns |	results className: (dBuilder aspectAt: #className) value.	results nameSpace: (ns := (dBuilder aspectAt: #nameSpace) value).	LensNamespaceControl lastDataModelerNameSpace: ns.</body></methods><methods><class-id>Lens.LensEditor</class-id> <category>changes</category><body package="Lens-Dev">changeRequest	"Check if the data model needs installation and give the user the oportunity 	to abort the changeRequest"	| ldm |	self autoAcceptAll.	(ldm := self selectedDataModel) == nil		ifTrue: [^true].	(mappingEditor notNil 		and: [mappingEditor builder notNil 		and: [mappingEditor builder window notNil		and: [mappingEditor builder window key notNil]]])			ifTrue: [mappingEditor builder keyboardProcessor requestGlobalAutoAccept].	^ldm saved or: [Dialog confirm: (#GenKeyChangedDataModel &lt;&lt; #lensDev &gt;&gt; 'The Data Model has been altered, but not installed.Do you wish to discard the changes?') for: builder window]</body><body package="Lens-Dev">dataModelChanged	"Update the data model in the generator and also as the default for new Data Forms to be created. Recompute the graph to be displayed"	| ldm |	ldm := self selectedDataModel.	self generator lensDataModel: ldm.	(ldm notNil and: [ldm applicationName notNil and: [ldm selector size &gt; 0]])		ifTrue: [LensApplicationCreationDialog defaultDataModel: (Array with: ldm applicationName with: ldm selector)].	self recomputeTableClassMap.	selectedType value: nil</body><body package="Lens-Dev">recomputeTableClassMap	"Instead of a mapping we show the more interesting reference graph"	self selectedDataModel == nil		ifTrue: 			[ldmView focus: #().				self mainMessage value: (#GenKeyDataModelNotLoaded &lt;&lt; #lensDev &gt;&gt; '&lt; No Data Model Loaded &gt;Use the "Model" menu to loador create a new Data Model')]		ifFalse: 			[| st |			st := self selectedDataModel structureTypes asSet.			st size &gt; 0				ifTrue: [self mainMessage value: '']				ifFalse: [self mainMessage value: (#GenKeyEmptyDataModel &lt;&lt; #lensDev &gt;&gt; '&lt; Empty Data Model &gt;Use the "Entity" menu to create new entitiesor select the option "View-&gt;Database Tables"to create entities for existing tables')].			ldmView focus: st.			self computeValueClassesMenu.			self selectedType: nil]</body><body package="Lens-Dev">redisplayMapping 	"Change the selected type to nil and then to the selected type again. This is necessary because a redisplay will happen only if the selected type really changes"	| currentlySelectedType |	currentlySelectedType := selectedType value.	selectedType value: nil.	selectedType value: currentlySelectedType</body><body package="Lens-Dev">selectedType: aType 	"A new type is selected in the graph. Change the value and notify of the 	change"	selectedType value: aType.	self changed: #selectedType</body></methods><methods><class-id>Lens.LensEditor</class-id> <category>interface opening</category><body package="Lens-Dev">openOnClass: aClass andSelector: aSelector 	self open.	(aClass notNil and: [aSelector notNil])		ifTrue: [(aClass respondsTo: aSelector)				ifTrue: 					[| ldm |					ldm := aClass perform: aSelector.					(ldm isSequenceable and: 						[ldm first == #LensDataModel or: [ldm first value name == #LensDataModel]])						ifTrue: 							[ldm := LensDataModel								readFromClass: aClass								methodName: aSelector.							ldm compile.							self selectedDataModel: ldm]]]</body><body package="Lens-Dev">openTargetClassNameDialogFor: className nameSpace: nameSpaceName message: message 	"Open to collect the name of a class, existent or not. Use message to prompt 	the user"	| dialog clName results bldr |	results := ClassCreateDialogReturn new.	dialog := SimpleDialog new.	bldr := dialog builder.	bldr aspectAt: #className put: (clName := (className isNil					ifTrue: [String new]					ifFalse: [className asString]) asValue).	bldr aspectAt: #message put: message asText allBold asValue.	bldr aspectAt: #nameSpace put: ((nameSpaceName isNil					ifTrue: [LensNamespaceControl lastDataModelerNameSpace]					ifFalse: [nameSpaceName asSymbol]) asValue).	bldr aspectAt: #nameSpaceMenu put: self nameSpaceMenu asValue.	bldr aspectAt: #doAbort		put: 			[results := nil.			dialog close].	bldr aspectAt: #doOK put: [		self postClassCreateDialogResultsTo: results from: bldr.		results results: clName value.		results results size = 0			ifTrue: 				[(dialog builder componentAt: #ClassNameField) flash.				"results := nil"]			ifFalse: 				[ | tmp |				tmp := self existingClassNamed: clName value inNameSpace: results nameSpace fromController: (dialog builder componentAt: #ClassNameField) widget controller.							results := tmp notNil					ifTrue: [tmp == #cancel						ifTrue: [nil]						ifFalse: [results className: tmp name. results]]					ifFalse: [results]."					ifFalse: [clName value asSymbol]."				dialog close]].	dialog openFrom: (self class interfaceSpecFor: #classNameDialog).	^results</body><body package="Lens-Dev">postBuildWith: aBuilder 	(self builder window) application: self; beMaster.	ldmView builder component container scrollOffsetHolder grid: (10@10).</body><body package="Lens-Dev">postOpenWith: aBuilder 	"We want to hear about when the application closes."	super postOpenWith: aBuilder.	ldmView perspective: #lensDataModel.	self selectedDataModel notNil		ifTrue: [ldmView focus: self selectedDataModel mappedTypes asSet]		ifFalse: [self recomputeTableClassMap].	self enableReferenceButton: false.	aBuilder window application: self.	aBuilder window beMaster</body><body package="Lens-Dev">preBuildWith: aBuilder	builder		aspectAt: #referenceButton		put: referenceButton</body></methods><methods><class-id>Lens.LensEditor</class-id> <category>initialize-release</category><body package="Lens-Dev">closeRequest	^self changeRequest and: [super closeRequest]</body><body package="Lens-Dev">initialize	super initialize.	selectedType := nil asValue.	self generator: LensDataModelGenerator new.	ldmView := LensGraphView onPerspective: #dbtable.	ldmView browserModel selectionService compute: [self selectionInGraph].	ldmView browserModel visualBuilderClass: LDMProtoMapBuilder.	referenceButton := false asValue.	referenceButton onChangeSend: #referenceButtonPressed to: self.	self selectedDataModelHolder onChangeSend: #dataModelChanged to: self.</body><body package="Lens-Dev">release	"The application has been sent a close event."	generator release.	selectedType changed: #close.	super release.</body><body package="Lens-Dev">windowEvent: anEvent from: anApplicationWindow 	"Release resources when the application is closed."	super windowEvent: anEvent from: anApplicationWindow.	anEvent key == #close ifTrue: [ self release ]</body></methods><methods><class-id>Lens.LensEditor class</class-id> <category>private</category><body package="Lens-Dev">enableChildSets	EnableChildSets := true.	self allInstancesDo: [:inst | inst resetChildSets]</body><body package="Lens-Dev">obsolete	"The receiver was removed from the system and is now obsolete. Perform any necessary clean-up. Answer the receiver."	"When the receiver is removed, we disable any notion of it in the main launcher."	super obsolete.	#{VisualLauncher} isDefined		ifTrue: [#{VisualLauncher} value checkInstalledComponents]</body></methods><methods><class-id>Lens.LensEditor class</class-id> <category>fileIn/Out</category><body package="Lens-Dev">prerequisitesForLoading	"List those classes that must be filed or BOSSed into the system 	before I can be loaded."	| oc |	oc := super prerequisitesForLoading.	oc add: LDMRelationship; add: LDMPerspective.	^oc</body></methods><methods><class-id>Lens.LensEditor class</class-id> <category>class initialization</category><body package="Lens-Dev">initialize	"LensEditor initialize"	self initializeRelationships.	self initializePerspectives.	EnableChildSets := false.	"Initialize the system launchers."	#{VisualLauncher} isDefined		ifTrue: [#{VisualLauncher} value checkInstalledComponents]</body><body package="Lens-Dev">initializePerspectives	"self initializePerspectives"	^List new add: ((Array new: 9) at: 1 put: #LDMPerspective; at: 2 put: #arrRows:; at: 3 put: #(#(#V1 #V1 'containsType' false false true false false ) #(#V1 #V1 'references' false false true false false ) ); at: 4 put: #arrLabelHints:; at: 5 put: #(); at: 6 put: #arrRelDesc:; at: 7 put: ((Array new: 2) at: 1 put: ((Array new: 5) at: 1 put: 'containsType'; at: 2 put: true; at: 3 put: #solid; at: 4 put: ColorValue black; at: 5 put: 1; yourself); at: 2 put: ((Array new: 5) at: 1 put: 'references'; at: 2 put: true; at: 3 put: #solid; at: 4 put: ColorValue purple; at: 5 put: 3; yourself); yourself); at: 8 put: #name:; at: 9 put: #lensDataModel; yourself) decodeAsLiteralArray; yourself</body><body package="Lens-Dev">initializeRelationships	"self initializeRelationships"	^List new add: #(#LDMFirstOrderRel #name: 'containsType' #description: 'contains type' #reverse: #containsTypeR #token: #containsTypeRel ) decodeAsLiteralArray;add: #(#LDMFirstOrderRel #name: 'containsTypeR' #description: 'type is contained in' #reverse: #containsType #token: #containsTypeRRel ) decodeAsLiteralArray;add: #(#LDMFirstOrderRel #name: 'references' #description: 'references' #reverse: #referencesR #token: #referencesRel ) decodeAsLiteralArray;add: #(#LDMFirstOrderRel #name: 'referencesR' #description: 'is referenced by' #reverse: #references #token: #referencesRRel ) decodeAsLiteralArray; yourself</body></methods><methods><class-id>Lens.LensEditor class</class-id> <category>resources</category><body package="Lens-Dev">defaultEntitySuperclass	^Object</body></methods><methods><class-id>Lens.LensEditor class</class-id> <category>interface opening</category><body package="Lens-Dev">interfaceSpecFor: aSymbol	^UISpecification from: (self perform: aSymbol)</body></methods><methods><class-id>Lens.LensReferenceNameDialog</class-id> <category>aspects</category><body package="Lens-Dev">fromEntity	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^fromEntity isNil		ifTrue:			[fromEntity := String new asValue]		ifFalse:			[fromEntity]</body><body package="Lens-Dev">name1	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^name1 isNil		ifTrue:			[name1 := String new asValue]		ifFalse:			[name1]</body><body package="Lens-Dev">name2	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^name2 isNil		ifTrue:			[name2 := String new asValue]		ifFalse:			[name2]</body><body package="Lens-Dev">name3	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^name3 isNil		ifTrue:			[name3 := String new asValue]		ifFalse:			[name3]</body><body package="Lens-Dev">nameSelector	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^nameSelector isNil		ifTrue:			[nameSelector := #name1 asValue]		ifFalse:			[nameSelector]</body><body package="Lens-Dev">referenceEntities	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^referenceEntities isNil		ifTrue:			[referenceEntities := String new asValue]		ifFalse:			[referenceEntities]</body><body package="Lens-Dev">replaced	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^replaced isNil		ifTrue:			[replaced := String new asValue]		ifFalse:			[replaced]</body><body package="Lens-Dev">toEntity	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^toEntity isNil		ifTrue:			[toEntity := String new asValue]		ifFalse:			[toEntity]</body></methods><methods><class-id>Lens.LensReferenceNameDialog</class-id> <category>private</category><body package="Lens-Dev">enterName1	nameSelector value: #name1</body><body package="Lens-Dev">enterName2	nameSelector value: #name2</body><body package="Lens-Dev">enterName3	nameSelector value: #name3</body><body package="Lens-Dev">visible: aBoolean group: ids 	"Enable or disable a collection of widgets whose names are given in ids"	ids		do: 			[:id | 			| comp |			comp := builder componentAt: id.			comp notNil ifTrue: [aBoolean					ifTrue: [comp beVisible]					ifFalse: [comp beInvisible]]]</body></methods><methods><class-id>Lens.LensReferenceNameDialog</class-id> <category>accessing</category><body package="Lens-Dev">selectedName	^(self perform: nameSelector value) value</body></methods><methods><class-id>Lens.LensReferenceNameDialog</class-id> <category>interface opening</category><body package="Lens-Dev">postOpenWith: aBuilder 		super postOpenWith: aBuilder.	self visible: (self referenceEntities value size &gt; 0) group: #(a1 a2 a3 a4 a5 a6)</body></methods><methods><class-id>Lens.LensReferenceNameDialog class</class-id> <category>resources</category><body package="Lens-Dev">exclamation	^self builderClass defaultPolicy alertIcon</body></methods><methods><class-id>Lens.LensDFBasicsSliceModel</class-id> <category>private</category><body package="Lens-Dev">getSensibleNameFrom: aName 	| newName i |	i := 1.	newName := aName.	[self isNameUsed: newName]		whileTrue: 			[i := i + 1.			newName := aName , i printString].	^newName</body><body package="Lens-Dev">isNameUsed: newName 	"Go through the specs in the currently being edited canvas and find any 	usage of the name"	| fullSpec enum ctrlr newSym current |	newSym := newName asSymbol.	ctrlr := UIPainterController lastControllerWithSelectionChannel value.	ctrlr isNil ifTrue: [^false].	ctrlr primarySelection notNil ifTrue: [current := ctrlr primarySelection spec].	fullSpec := ctrlr model extractFullSpec.	fullSpec isNil ifTrue: [^false].	enum := AspectEnumerator new doSpec: fullSpec.	(enum details includesKey: newSym)		ifTrue: [current == (enum details at: newSym) ifFalse: [^true]].	(enum bindings includesKey: newSym)		ifTrue: [^true].	(enum actions includesKey: newSym)		ifTrue: [^true].	(enum clients includesKey: newSym)		ifTrue: [^true].	^false</body></methods><methods><class-id>Lens.LensDFBasicsSliceModel</class-id> <category>aspects</category><body package="Lens-Dev">contentKey	^(TypeConverter onSymbolValue: ((AspectAdaptor subjectChannel: self specChannel)			forAspect: #contentKey)) aspectToText</body><body package="Lens-Dev">specChannel	^specChannel</body></methods><methods><class-id>Lens.LensDFBasicsSliceModel</class-id> <category>actions</category><body package="Lens-Dev">generateOtherProperties	"Generate other properties starting from the given ones. 'low' is the basic 	name to be used to fill all other properties"	| spec low clName target |	spec := specChannel value.	(spec majorKey isNil or: [(clName := spec majorKey asString) isEmpty])		ifTrue: 			[Dialog warn: (#GenKeyNeedDataFormClass &lt;&lt; #lensDev &gt;&gt; 'The class of the Data Form is neededfor filling out the other properties') for: builder window.			^nil].	spec clientKey size == 0		ifTrue: 			[low := clName copy.			low at: 1 put: (low at: 1) asLowercase.			low = clName				ifTrue: [low := low, '_'].			low := self getSensibleNameFrom: low]		ifFalse: 			[low := spec clientKey asString].	(self isNameUsed: low)		ifTrue:			[Dialog warn: ((#GenKeyNameUsedInCanvas &lt;&lt; #lensDev &gt;&gt; 'The name: &lt;1s&gt; is aready used on this canvas.')			expandMacrosWith: low) for: builder window.			^nil].	spec clientKey: low copy asSymbol.	spec minorKey: #windowSpec.	spec name size == 0		ifTrue: [spec name: low copy asSymbol].	target := (self builder bindings at: #parentModel) selectionHolder value model targetClass.	((target isNil or:		[target notNil and:			[target inheritsFrom: LensDataManager]]) and:				[spec sourceType == #query])		ifTrue: [spec contentKey: ((#x1sQuery &lt;&lt; #lensDev &gt;&gt; '&lt;1s&gt;Query')			expandMacrosWith: low) asSymbol].	(spec isKindOf: LinkedDetailSpec)		ifTrue: [spec openAction: ((#x1sOpen &lt;&lt; #lensDev &gt;&gt; '&lt;1s&gt;Open')			expandMacrosWith: low) asSymbol].	spec fetchAction: ((#x1sFetch &lt;&lt; #lensDev &gt;&gt; '&lt;1s&gt;Fetch')			expandMacrosWith: low) asSymbol.	specChannel changed: #value</body></methods><methods><class-id>Lens.LensDFBasicsSliceModel class</class-id> <category>resources</category><body package="Lens-Dev">nameSpaceMenu	"menu of name spaces"	| nameSpaces names |	nameSpaces := LensNamespaceControl permissableNameSpaces.	names := (Array with: (nameSpaces collect: [:d | d name asText allBold])).	^Menu		labelList: names		values: nameSpaces</body></methods><methods><class-id>Lens.LensMappingEditor</class-id> <category>aspects</category><body package="Lens-Dev">columnEncodingMenu	| mb menu encoderList |	mb := MenuBuilder new.	mb addLabel: (#none &lt;&lt; #lensDev &gt;&gt; '(none)') asString value: (Association new value: nil).	encoderList := StreamEncoder availableEncodings asSortedStrings.	encoderList remove: #default.	encoderList remove: #Source.	encoderList do:		[:enc |		mb addLabel: enc asString value: (Association new value: enc)].	menu := mb menu.	^menu</body><body package="Lens-Dev">columnLength	^(PluggableAdaptor on: selCol)		getBlock: [:m | m value notNil				ifTrue: [m value maxColumnLength]				ifFalse: [nil]]		putBlock: [:m :v | m value notNil				ifTrue: 					[m value maxColumnLength: v.					self changedColumnLength.					self invalidateDataModel]]		updateBlock: [:m :a :p | true]</body><body package="Lens-Dev">columnNotNull	"If there is a variable associated with this column, mark also the variable accordingly"	^(PluggableAdaptor on: selCol)		getBlock: [:m | m value notNil				ifTrue: [m value isNotNil]				ifFalse: [nil]]		putBlock: [:m :v | m value notNil				ifTrue: 					[m value isNotNil: v.					selVar value notNil						ifTrue: 							[selVar value isNotNil: v.							selVar changed: #value].					self invalidateDataModel]]		updateBlock: [:m :a :p | true]</body><body package="Lens-Dev">columnType	^(PluggableAdaptor on: selCol)		getBlock: [:m | m value notNil				ifTrue: [m value dataType]				ifFalse: [nil]]		putBlock: [:m :v | m notNil				ifTrue: 					[m value dataType: v.					self enableLength.					self invalidateDataModel]]		updateBlock: [:m :a :p | true]</body><body package="Lens-Dev">columnTypeMenu	^columnTypeMenu</body><body package="Lens-Dev">graphView	^graphView</body><body package="Lens-Dev">variableCollection 	^(PluggableAdaptor on: selVar)		getBlock: 			[:m | 			| o |			o := m value.			o isNil ifFalse: [o isChildrenPointer]				ifTrue: [nil]]		putBlock: 			[:m :v | 			| o |			o := m value.			o isNil ifFalse: [self makeChildrenPointer: v ofVariable: o]]		updateBlock: [:m :a :v | true]</body><body package="Lens-Dev">variableNotNil	"If the variable has a column also mark it"	^(PluggableAdaptor on: selVar)		getBlock: 			[:m | 			| o |			o := m value.			o isNil ifFalse: [o isNotNil]				ifTrue: [nil]]		putBlock: 			[:m :v | 			| o |			o := m value.			o isNil ifFalse: [o isChildrenPointer					ifTrue: [Dialog warn: (#GenKeyNoNilCollectionVariable &lt;&lt; #lensDev &gt;&gt; 'Variables defined as collections must be ''Not Nil''') for: builder window]					ifFalse: 						[o isNotNil: v.						o column notNil							ifTrue: 								[o column isNotNil: v.								selCol changed: #value].						self invalidateDataModel]]]		updateBlock: [:m :a :v | true]</body><body package="Lens-Dev">variableValueType	"Return the adaptor to be used in the menu button for changing the type of a variable. When changing the type first check that the type is valid, then change the type and update the column's type menu. If the old type was compound then there may be need for redrawing the graph since the children of the variable have probably changed"	^(PluggableAdaptor on: selVar)		getBlock: 			[:m | 			| o |			o := m value.			o isNil ifFalse: [o isChildrenPointer					ifTrue: [o valueType elementType]					ifFalse: [o valueType]]				ifTrue: [nil]]		putBlock: 			[:m :v | 			| o | 			o := m value.			o isNil ifFalse: [(self checkValueType: v)					ifTrue: 						[| needRedraw |						needRedraw := o isCompound or: [v isLensStructureType].						o valueType: v.						selCol value notNil							ifTrue: 								[self computeColumnTypeMenu: selCol value.								selCol changed: #value].						self invalidateDataModel.						needRedraw							ifTrue: 								[self setFocus.								self select: o]]]]		updateBlock: [:m :a :v | true]</body></methods><methods><class-id>Lens.LensMappingEditor</class-id> <category>actions</category><body package="Lens-Dev">addVariable	"Add a variable to the type. After it is created, make sure to select it in the graph"	type value notNil		ifTrue: 			[| var name scanned |			name := Dialog request: (#GenKeyEnterVariableName &lt;&lt; #lensDev &gt;&gt; 'Enter the name of the new variable:') for: builder window.			(name isNil or: [name isEmpty])				ifTrue: [^self].			((scanned := Scanner new scanFieldNames: name) size ~= 1 or:					[scanned first size ~= name size])				ifTrue:					[Dialog warn: (#GenKeyDefineVariableName &lt;&lt; #lensDev &gt;&gt; 'Variable names must begin with alphabetic charactersand must not contain characters defined as selectors.') for: builder window.					^nil].			type value variables do: [:v | v name = name					ifTrue: 						[Dialog warn: ((#GenKeyDuplicateVariableName &lt;&lt; #lensDev &gt;&gt; 'There is already a variable with the name: &lt;1s&gt;')			expandMacrosWith: name) for: builder window.						^nil]].			self invalidateDataModel.			(var := editor newVariable) name: name.			type value variables: (type value variables copyWith: var).			editor generator reviseClassOfType: type value.			var generateAccessMethods.			self setFocus.			self select: var]</body><body package="Lens-Dev">checkTableWithDatabase	"Check the selected table against the database, this may create or alter the table definition"	(editor notNil and: [type value notNil])		ifTrue: [editor checkTypeAgainstDatabase: type value]</body><body package="Lens-Dev">createColumnForVariable: topVar 	"Check that all the leaves from the variable are properly mapped. For each one of them create a column. If a column existed just copy it (that is the best way to preserve the information), if not, create a new one"	| newColumns |	newColumns := OrderedCollection new.	topVar isMapped: true. 	topVar resetFieldType.	topVar forLeavesDo: [:var |		(var isMapped not or: [var fieldType isNil or: [var fieldType memberClass == Object]])			ifTrue: [				Dialog warn: (#GenKeyCheckMapping &lt;&lt; #lensDev &gt;&gt; 'Some variable is not properly mapped, the column can not be created now.Check that all the referenced entities are mapped and havetheir keys mapped') for: self builder window.				topVar isMapped: false.				^self]].	topVar		forLeavesDo: 			[:var | 			| col colName |			"Preserve column information if it is there"			var column isNil				ifTrue: [					colName := self getColumnNameFor: var name.					col := var createColumnNamed: colName ]				ifFalse: [ col := var column copy].			col table: type value table.			var column: col.			var isMapped: true.			var resetFieldType.			(col maxColumnConstraint isNil or: [col maxColumnConstraint isZero])				ifTrue: [(var fieldType memberClass inheritsFrom: Collection)						ifTrue: [col maxColumnConstraint: 10]].			topVar isId ifTrue: [col isNotNil: true].			newColumns add: col].	^newColumns</body><body package="Lens-Dev">createColumnVariable	"Define a column for the selected variable. Make sure the variable remains selected after the graph is updated"	| var |	(var := selVar value) notNil ifTrue: [var isMapped			ifTrue: [Dialog warn: (#GenKeyNoMapVariableForNewColumn &lt;&lt; #lensDev &gt;&gt; 'To create a column the variable must not be already mapped') for: builder window]			ifFalse: [var valueType name == #Object					ifTrue: [Dialog warn: (#GenKeyNoMapForObjectVariable &lt;&lt; #lensDev &gt;&gt; 'A variable of type ''Object'' cannot be mapped') for: builder window]					ifFalse: [var isChildrenPointer							ifTrue: [Dialog warn: (#GenKeyNoMapForCollectionVariable &lt;&lt; #lensDev &gt;&gt; 'A variable that is a collection cannot be mapped') for: builder window]							ifFalse: 								[| res |								res := self createColumnForVariable: var.								self invalidateDataModel.								self setFocus.								self select: var.								^res]]]].	^nil</body><body package="Lens-Dev">createTable	| ty |	(ty := type value) notNil ifTrue: [ty table notNil			ifTrue: [Dialog warn: (#GenKeyMappedClassForTable &lt;&lt; #lensDev &gt;&gt; 'The selected class is already mapped to a database table.To define a new table for the class, first unmap the class') for: builder window]			ifFalse: [ty idVariable isNil					ifTrue: [Dialog warn: (#GenKeyNoDefinedKeyInClass &lt;&lt; #lensDev &gt;&gt; 'The selected class doesn''t have a key defined.To define the key for the class, use the Key Editor') for: builder window]					ifFalse: 						[| tName table columns |						tName := editor selectedDataModel databaseContext class getDatabaseEntityNameFrom: ty name asString.						table := ty newTableNamed: tName.						columns := OrderedCollection new.						ty variablesDo: 							[:v | 							| cols |							(self isMappable: v)								ifTrue: 									[cols := self createColumnForVariable: v.									cols size &gt; 0										ifTrue: 											[columns addAll: cols.											cols do: [:col | col table: table]]]].						columns size == 0 ifTrue: [(Dialog confirm: (#GenKey61 &lt;&lt; #lensDev &gt;&gt; 'The selected type has no mappable variables.Do you want to continue and create the table?') for: builder window)								ifFalse: [^nil]].						Cursor execute							showWhile: 								[ty table: table.								table columns: columns.								self invalidateDataModel.								self setFocus]]]]</body><body package="Lens-Dev">editKey	"Open the key editor. When coming back invalidate the data model and 	update the graph view by sending setFocus"	type value notNil		ifTrue: 			[| ked selectedVariable |			selectedVariable := selVar value.			ked := LensKeyEditor new.			ked type: type value.			ked open				ifTrue: 					[self updateTypeReferencesClearingType: false.					self invalidateDataModel.					self setFocus.					selectedVariable notNil ifTrue: [self select: selectedVariable]]]</body><body package="Lens-Dev">flipAccessor	| aa |	aa := self builder aspectAt: #'selVar generatesAccessor'.	aa value: aa value not.	self invalidateDataModel</body><body package="Lens-Dev">flipCollection	| aa |	aa := self builder aspectAt: #variableCollection.	aa value: aa value not.	self invalidateDataModel</body><body package="Lens-Dev">flipMutator	| aa |	aa := self builder aspectAt: #'selVar generatesMutator'.	aa value: aa value not.	self invalidateDataModel</body><body package="Lens-Dev">getColumnNameFor: varName 	"Get an acceptable name for a column when given the variable name. First 	ask the context to give a name which complies with the database 	standards; then check that the same name is not used already in the table"	| nm colThere tab | 	nm := editor selectedDataModel databaseContext class getDatabaseEntityNameFrom: varName.	tab := type value table.	tab notNil ifTrue: [		[colThere := tab columns detect: [:each | each name = nm]					ifNone: [nil].		colThere isNil]			whileFalse: [nm := nm , '_|']].	^nm</body><body package="Lens-Dev">helpAction	VisualLauncher openHelpBrowser</body><body package="Lens-Dev">mapVariableAndColumn	"Check whether an unmapped variable is selected and a column is 	selected. If something is wrong give complete instructions"	| sel var col |	sel := OrderedCollection new.	graphView selectionDo: [:p | sel add: p].	(sel size == 2 and:		[(var := sel detect: [:s | self isMappable: s] ifNone: []) notNil and:			[(col := sel detect: [:s | s ~~ var] ifNone: []) notNil and:				[self map: var to: col]]])		ifFalse: [Dialog warn: (#GenKeyHowToMapVariableToColumn &lt;&lt; #lensDev &gt;&gt; 'To map a variable to an existing column, first select the variable,then select the column while holding the Ctrl key down.  Thevariable must not already be mapped and must be a simple variableof type other than Object.') for: builder window]</body><body package="Lens-Dev">qualifyTable	"Let the table qualify itself from our ldm. Oracle tables, for example, will take 	the username from the databaseContext and use it as their owner field"	| tab |	type value notNil ifTrue: [tab := type value table].	tab notNil		ifTrue: 			[tab qualify: editor selectedDataModel.			self invalidateDataModel.			self setFocus]</body><body package="Lens-Dev">removeVariable	selVar value notNil ifTrue: [selVar value isId			ifTrue: [Dialog warn: (#GenKeyNotRemoveVariable &lt;&lt; #lensDev &gt;&gt; 'Can not remove the variable. It is currently used in the key.First redefine the key for the Entity using the Key Editor') for: builder window]			ifFalse: 				[| ty vars |				selVar value flushAccessMethods.				ty := type value.				vars := ty variables asOrderedCollection.				vars remove: selVar value.				ty variables: vars asList.				editor generator reviseClassOfType: type value removed: selVar value name.				self invalidateDataModel.				self setFocus]]</body><body package="Lens-Dev">renameColumn	"Change the name of the column selected"	selCol value notNil		ifTrue: 			[| newName selectedVariable |			selectedVariable := selVar value.			newName := selCol value name copy asString.			newName := Dialog						request: (#GenKeyNewColumnName &lt;&lt; #lensDev &gt;&gt; 'Enter the new name for the column.  Note that theold column will not be removed from the database.')						initialAnswer: newName						for: builder window.			newName size &gt; 0 ifTrue: [				Cursor execute showWhile: [					selCol value name: newName.					self invalidateDataModel.					self setFocus.					selectedVariable notNil ifTrue: [self select: selectedVariable]]]]</body><body package="Lens-Dev">renameTable	"Change the name of the table. Since the type associated to the table may have a sequence that is derived from the name of the table we have to reset it also"	| tab |	type value notNil ifTrue: [tab := type value table].	tab notNil		ifTrue: 			[| newName |			newName := tab name copy asString.			newName := Dialog request:(#GenKeyNewTableName &lt;&lt; #lensDev &gt;&gt; 'Enter the new name for the table.  Note that theold table will not be removed from the database.') initialAnswer: newName for: builder window.			newName size &gt; 0				ifTrue: 					[Cursor execute showWhile: [						tab name: newName.						self invalidateDataModel.						self setFocus]]]</body><body package="Lens-Dev">renameVariable	"Changes the name of a variable. Checks that the new name is not empty, 	not the same name. It complains if there is already another variable with the 	same name"	| var name oldName scanned otherVar |	(var := self selVar value) notNil		ifTrue: 			[oldName := var name.			name := Dialog						request: (#GenKeyNewVariableName &lt;&lt; #lensDev &gt;&gt; 'Enter the new name for the variable:')						initialAnswer: oldName copy asString						onCancel: [^nil]						for: builder window.			name size == 0 ifTrue: [^self].			name = oldName ifTrue: [^self].			((scanned := Scanner new scanFieldNames: name) size ~= 1 or:					[scanned first size ~= name size])				ifTrue:					[Dialog warn: (#GenKeyDefineVariableName &lt;&lt; #lensDev &gt;&gt; 'Variable names must begin with alphabetic charactersand must not contain characters defined as selectors.') for: builder window.					^self].			otherVar := type value variableNamed: name ifNone: [nil].			otherVar notNil				ifTrue: 					[Dialog warn: ((#GenKeyDuplicateVariableNameCancel &lt;&lt; #lensDev &gt;&gt; 'There is already a variable named &lt;1s&gt;&lt;n&gt;in this entity; rename cancelled.')			expandMacrosWith: name) for: builder window.					^self].			Cursor execute showWhile: [self invalidateDataModel.				var flushAccessMethods.				var name: name.				editor generator reviseClassOfType: type value removed: oldName.				var generateAccessMethods.				self setFocus.				self select: var]]		ifFalse: [Dialog warn: (#FirstSelectAVariable &lt;&lt; #lensDev &gt;&gt; 'First select a variable') for: builder window]</body><body package="Lens-Dev">unQualifyTable	| tab |	type value notNil ifTrue: [tab := type value table].	tab notNil		ifTrue: 			[tab unqualify.			self invalidateDataModel.			self setFocus]</body><body package="Lens-Dev">unmapClass	"Make the class be unmapped"	type value notNil		ifTrue: 			[type value clearMappings.			self updateTypeReferencesClearingType: true. 			self invalidateDataModel.			self setFocus]</body><body package="Lens-Dev">unmapVariable	"Unmap the individual variable that is currently selected. Make it unmapped keeping the current type. After done mark the data model as dirty and update the graph view"	| var |	(var := selVar value) notNil		ifTrue: 			[var beUnmappedOfType: var valueType.			self invalidateDataModel.			self setFocus.			self select: var]</body><body package="Lens-Dev">updateAll	"Update the menus and the graph view"	self updateMenus.	self setFocus</body><body package="Lens-Dev">updateMenus	editor computeValueClassesMenu</body></methods><methods><class-id>Lens.LensMappingEditor</class-id> <category>aspect-support</category><body package="Lens-Dev">computeColumnTypeMenu: aColumn	| mb dtm columnTypes |	mb := MenuBuilder new.	columnTypes := Set new.	dtm := self getDataTypeMappings: aColumn.	dtm do: [:tm | columnTypes add: tm columnType].	columnTypes asSortedCollection do: [:aColType | mb add: aColType -&gt; aColType].	columnTypeMenu value: mb menu</body><body package="Lens-Dev">consistentDataTypeMappingsFor: varType	| fieldClass |	fieldClass := varType isLensEncodedType			ifFalse: [varType memberClass]			ifTrue: [varType fieldType memberClass].	^self ldm  databaseContext class dataTypeMappings select: [:dtm |		dtm fieldType memberClass == fieldClass]</body><body package="Lens-Dev">getDataTypeMappings: aColumn 	| var |	var := self variableFor: aColumn.	^var isNil		ifTrue: [self ldm databaseContext class dataTypeMappings]		ifFalse: [self consistentDataTypeMappingsFor: var fieldType]</body><body package="Lens-Dev">variableFor: aCol 	type value notNil ifTrue: [type value variablesDo: [:v | v column == aCol ifTrue: [^v]]].	^nil</body></methods><methods><class-id>Lens.LensMappingEditor</class-id> <category>accessing</category><body package="Lens-Dev">advancedOnes	^#(variableNotNil variableCollection generatesAccessor generatesMutator #mapButton methodsBox)</body><body package="Lens-Dev">editor: aLensEditor	editor := aLensEditor</body><body package="Lens-Dev">ldm	^editor selectedDataModel</body><body package="Lens-Dev">selCol	^selCol</body><body package="Lens-Dev">selCol: aColumn 	selCol value ~~ aColumn		ifTrue: 			[builder keyboardProcessor requestGlobalAccept.			self setSelCol: aColumn.			self setSelVar: (self variableFor: selCol value)]</body><body package="Lens-Dev">selVar	^selVar</body><body package="Lens-Dev">selVar: aVar 	selVar value ~~ aVar		ifTrue: 			[builder keyboardProcessor requestGlobalAccept.			self setSelVar: aVar.			aVar notNil ifTrue: [self setSelCol: aVar column]]</body><body package="Lens-Dev">setSelCol: aColumn 	aColumn notNil ifTrue: [self computeColumnTypeMenu: aColumn].	self enable: aColumn notNil group: #(#columnType #columnNotNull ).	selCol value: aColumn.	self enableLength</body><body package="Lens-Dev">setSelVar: aVar 	self enable: aVar notNil group: #(#variableName #variableValueType #variableNotNil #variableCollection #generatesAccessor #generatesMutator ).	selVar value: aVar</body><body package="Lens-Dev">type: aType	type := aType.	self changedType.</body><body package="Lens-Dev">typeHolder: aTypeHolder		type notNil ifTrue: [type removeDependent: self].	type := aTypeHolder.	type addDependent: self.</body></methods><methods><class-id>Lens.LensMappingEditor</class-id> <category>actions-support</category><body package="Lens-Dev">invalidateDataModel	editor selectedDataModel invalidate.</body><body package="Lens-Dev">isMappable: el 	^(el isKindOf: LensStructureVariable)		and: [el isCompound not and: [el isChildrenPointer not and: [el valueType memberClass ~~ Object and: [el isMapped not]]]]</body><body package="Lens-Dev">makeChildrenPointer: aBoolean ofVariable: variable 	"make the variable be a children set or cease being, all according to aBoolean"	aBoolean == variable isChildrenPointer ifTrue: ["Since they are the same, there's no change."		^self].	self invalidateDataModel.	aBoolean		ifTrue: 			["Change a simple reference to a children set."			| vt |			((vt := variable valueType) isKindOf: LensStructureType)				ifTrue: 					[| reverse |					reverse := self pointerFrom: vt to: variable objectType.					reverse notNil						ifTrue: [							variable setValueType: (IdentitySet of: vt).							variable generatesMutator: false.							variable inverse: reverse asSymbol.							(vt variableNamed: reverse) inverse: variable name asSymbol ]						ifFalse: [self variableCollection value: false]]				ifFalse: [Dialog warn: (#GenKeyNoMappedCollection &lt;&lt; #lensDev &gt;&gt; 'You cannot have a mapped collection of a basic class')]]		ifFalse:			["Change a parent pointer into a simple reference."			| vt reverse inv |			(((vt := variable valueType) isKindOf: LensCollectionType) and:				[(vt elementType isKindOf: LensStructureType) and:					[(reverse := variable inverse) notNil]])				ifTrue:					[(inv := vt elementType variableNamed: reverse ifNone: []) notNil						ifTrue: [inv inverse: nil]].			variable setValueType: vt elementType.			variable inverse: nil]</body><body package="Lens-Dev">map: el1 to: el2 	"Checks that el1 can really be mapped to el2 and sets up el2 to be the 	'column' of el1"	^((el1 isKindOf: LensStructureVariable)		and: [el1 isCompound not and: [el2 isKindOf: LensDatabaseTableColumn]])		ifTrue: 			[el1 column: el2.			el1 isMapped: true.			el1 resetFieldType.			self invalidateDataModel.			self setFocus.			self select: el1.			true]		ifFalse: [false]</body><body package="Lens-Dev">pointerFrom: type1 to: type2 	"Returns the name of the variable in type1 that references type2."	"Assume: there is only one."	| candidates |	candidates := OrderedCollection new.	type1 variables do: [:v | v valueType = type2 ifTrue: [candidates add: v name]].	candidates size == 0		ifTrue:			[Dialog				warn: ((#GenKeyNoReference &lt;&lt; #lensDev &gt;&gt; '&lt;1s&gt; does not have a reference to &lt;2s&gt;')			expandMacrosWith: type1 name			with: type2 name)				for: builder window.			^nil].	candidates size == 1 ifTrue: [^candidates first].	^Dialog		choose: ((#GenKeySelectForeignKey &lt;&lt; #lensDev &gt;&gt; 'SELECT the foreign key reference&lt;n&gt;from &lt;1s&gt;&lt;n&gt;on which to base the collection:')			expandMacrosWith: type1 name)		fromList: (candidates collect: [:c | c asString])		values: candidates		buttons: #()		values: #()		lines: 8		cancel: [nil]		for: builder window</body><body package="Lens-Dev">redisplay	Cursor execute showWhile: [graphView redisplay]</body></methods><methods><class-id>Lens.LensMappingEditor</class-id> <category>resources</category><body package="Lens-Dev">menuBar	| notEmpty selectedVar menu subMenu mi1 mi2 mi mi3  mappedType mi4 |	notEmpty := [type value notNil].	selectedVar := [selVar value notNil].	mappedType := [type value notNil and: [type value isMapped]].	menu := Menu new."Entity"	subMenu := Menu new.	(mi1 := MenuItem labeled: (#EditKey &lt;&lt; #lensDev &gt;&gt; 'Edit Key...'))		enabled: [type value notNil and: [type value variables size &gt; 0]].	subMenu addItem: mi1 value: #editKey.	(mi1 := MenuItem labeled: (#SelectSingleColumnKey &lt;&lt; #lensDev &gt;&gt; 'Select Single Column Key'))		enabled: [type value notNil and: [type value variables size &gt; 0]].	subMenu addItem: mi1 value: #selectSingleKey.	(mi1 := MenuItem labeled: (#SpecifyTable &lt;&lt; #lensDev &gt;&gt; 'Specify Table'))		enabled: [type value notNil and: [type value isMapped not]].	(mi2 := MenuItem labeled: (#Unmap &lt;&lt; #lensDev &gt;&gt; 'Unmap'))		enabled: [type value notNil and: [type value isMapped]].	subMenu addItemGroup: (Array with: mi1 with: mi2 ) values: #(createTable unmapClass).	(mi := MenuItem labeled: (#Entity &lt;&lt; #lensDev &gt;&gt; 'Entity')) submenu: subMenu.	menu addItem: mi."Variable"	subMenu := Menu new.	(mi1 := MenuItem labeled: (#AddDot &lt;&lt; #lensDev &gt;&gt; 'Add...'))		enabled: notEmpty.	(mi2 := MenuItem labeled: (#Rename &lt;&lt; #lensDev &gt;&gt; 'Rename...'))		enabled: selectedVar.	(mi3 := MenuItem labeled: (#Remove &lt;&lt; #lensDev &gt;&gt; 'Remove'))		enabled: selectedVar.	subMenu addItemGroup: (Array with: mi1 with: mi2 with: mi3) values: #(addVariable renameVariable removeVariable).	(mi1 := MenuItem labeled: (#SpecifyColumn &lt;&lt; #lensDev &gt;&gt; 'Specify Column'))		enabled: [type value notNil and: [type value isMapped and: [selVar value notNil and: [selVar value isMapped not]]]].	(mi2 := MenuItem labeled: (#RenameColumn &lt;&lt; #lensDev &gt;&gt; 'Rename Column...'))		enabled: [type value notNil and: [selCol value notNil]].	(mi3 := MenuItem labeled: (#MapToColumn &lt;&lt; #lensDev &gt;&gt; 'Map to Column'))		enabled: [true].	(mi4 := MenuItem labeled: (#Unmap &lt;&lt; #lensDev &gt;&gt; 'Unmap'))		enabled: [selVar value notNil and: [selVar value isMapped]].	subMenu addItemGroup: (Array with: mi1 with: mi2 with: mi3 with: mi4) values: #(createColumnVariable renameColumn mapVariableAndColumn unmapVariable).	(mi1 := MenuItem labeled: (#GenerateAccessor &lt;&lt; #lensDev &gt;&gt; 'Generate Accessor'))		enabled: [selVar value notNil];		indication: (self builder aspectAt: #'selVar generatesAccessor').	(mi2 := MenuItem labeled: (#GenerateMutator &lt;&lt; #lensDev &gt;&gt; 'Generate Mutator'))		enabled: [selVar value notNil];		indication: (self builder aspectAt: #'selVar generatesMutator').	subMenu addItemGroup: (Array with: mi1 with: mi2) values: #(flipAccessor flipMutator).	(mi := MenuItem labeled: (#Variable &lt;&lt; #lensDev &gt;&gt; 'Variable')) submenu: subMenu.	menu addItem: mi."Table"	subMenu := Menu new.	(mi1 := MenuItem labeled: (#QualifyName &lt;&lt; #lensDev &gt;&gt; 'Qualify Name'))		enabled: mappedType.	(mi2 := MenuItem labeled: (#UnqualifyName &lt;&lt; #lensDev &gt;&gt; 'Unqualify Name'))		enabled: mappedType.	subMenu addItemGroup: (Array with: mi1 with: mi2) values: #(qualifyTable unQualifyTable).	(mi1 := MenuItem labeled: (#Rename &lt;&lt; #lensDev &gt;&gt; 'Rename...'))		enabled: mappedType.	subMenu addItemGroup: (Array with: mi1) values: #(renameTable).	(mi1 := MenuItem labeled: (#CheckWithDatabase &lt;&lt; #lensDev &gt;&gt; 'Check With Database'))		enabled: mappedType.	subMenu addItemGroup: (Array with: mi1) values: #(checkTableWithDatabase).	(mi := MenuItem labeled: (#Table &lt;&lt; #lensDev &gt;&gt; 'Table')) submenu: subMenu.	menu addItem: mi.	"View"	subMenu := Menu new.	mi1 := MenuItem labeled: (#Update &lt;&lt; #lensDev &gt;&gt; 'Update'). 	subMenu addItemGroup: (Array with: mi1) values: #(updateAll).	(mi := MenuItem labeled: (#View &lt;&lt; #lensDev &gt;&gt; 'View')) submenu: subMenu.	menu addItem: mi."Help"	subMenu := Menu new.	subMenu addItemLabel: (#Topics &lt;&lt; #lensDev &gt;&gt; 'Topics') value: #helpAction.	(mi := MenuItem labeled: (#Help &lt;&lt; #lensDev &gt;&gt; 'Help')) submenu: subMenu.	menu addItem: mi.	^menu</body><body package="Lens-Dev">valueClassesMenu	^editor valueClassesMenu</body></methods><methods><class-id>Lens.LensMappingEditor</class-id> <category>interface opening</category><body package="Lens-Dev">postBuildWith: aBuilder 	| ctrl |	graphView focus: (Set new).	self setSelVar: nil.	self setSelCol: nil.	editor useChildSets ifTrue: [self enableChildSets].	ctrl := (graphView builder componentAt: #ldmBrowser) widget controller.	ctrl menuHolder value: self class popUpMenu.	ctrl performer: self.	graphView builder component container scrollOffsetHolder grid: (10@10).</body><body package="Lens-Dev">postOpenWith: aBuilder 	"We want to hear about when the application closes."	super postOpenWith: aBuilder.	aBuilder window application: self.	aBuilder window sendWindowEvents: #(#close ).	(type notNil and: [type value isNil]) ifTrue: [self setFocus]</body></methods><methods><class-id>Lens.LensMappingEditor</class-id> <category>initialize release</category><body package="Lens-Dev">initialize	graphView := LensGraphView onPerspective: #mappings.	graphView browserModel selectionService compute: [self selectionInGraph].	graphView browserModel visualBuilderClass: LDMProtoMapBuilder.	columnTypeMenu := (Menu labelArray: #() values: #()) asValue.	selVar := nil asValue.	selCol := nil asValue.</body><body package="Lens-Dev">release	type removeDependent: self.	^super closeRequest</body></methods><methods><class-id>Lens.LensMappingEditor</class-id> <category>changes</category><body package="Lens-Dev">changedColumnLength	"If the column length changes then the fieldType of the variable should be 	changed. Also if the variable is part of the key of the entity then the 	fieldTy[pe of the whole entity should be changed"	| var |	(var := selVar value) notNil		ifTrue: 			[var resetFieldTypeMax.			var isId ifTrue: [type value idVariable resetFieldType]]</body><body package="Lens-Dev">changedType	"The type we are showing have changed, show the new one"	type value ~~ lastType		ifTrue: 			[lastType := type value.			lastType notNil				ifTrue: 					[| tab |					tab := lastType table.					tab notNil ifTrue: [tab columns do: [:c | c table: tab]]].			self setFocus]</body><body package="Lens-Dev">selectionInGraph	| sel |	sel := OrderedCollection new.	graphView selectionDo: [:p | sel add: p].	sel size == 1		ifTrue: 			[| el |			el := sel first.			(el isKindOf: LensStructureVariable)				ifTrue: [self selVar: el]				ifFalse: [(el isKindOf: LensDatabaseTableColumn)						ifTrue: [self selCol: el]						ifFalse: 							[self selCol: nil.							self selVar: nil]]]		ifFalse: 			[self selCol: nil.			self selVar: nil]</body><body package="Lens-Dev">setFocus	Cursor execute showWhile: [type value notNil			ifTrue: 				[| f tab |				tab := type value table.				tab notNil					ifTrue: 						[f := tab columns copy asSet.						f add: tab]					ifFalse: [f := IdentitySet new].				f add: type value.				graphView focus: f]			ifFalse: [graphView focus: (IdentitySet with: (#GenKeyHowToEditEntity &lt;&lt; #lensDev &gt;&gt; '&lt; To edit an Entity select it in the Data Modeler &gt;') asString)]].	self selVar: nil.	self selCol: nil.</body></methods><methods><class-id>Lens.LensMappingEditor</class-id> <category>private</category><body package="Lens-Dev">canBeKey: aVar 	"Checks whether aVar is allowed to be an Id variable. It checks that the 	type of the variable is not Object and it is not encoded. Raises a dialog 	explaining the problem"	| win typ |	builder notNil ifTrue: [win := builder window].	((typ := aVar valueType) isNil or:		[aVar decodeSelector notNil or:			[typ isLensType not or:				[typ memberClass == Object]]])		ifTrue: 			[Dialog warn:(#GenKeyInvalidKey &lt;&lt; #lensDev &gt;&gt; 'Variables typed as Object, or as ''encodedtypes'' such as Date and ByteSymbol, shouldnot be used in keys.') for: win.			^false].	^true</body><body package="Lens-Dev">checkValueType: aType 	"Check if the given value type is acceptable and that if the variable is part 	of the key then the type is acceptable for keys, i.e. it is not Object and it is 	not decoded"	| win |	builder isNil ifFalse: [win := builder window].	self selVar value objectType = type value		ifFalse: 			[Dialog warn: (#GenKeyChangeVariableType &lt;&lt; #lensDev &gt;&gt; 'The type of a variable that is part of the reference to another entitymay be changed only in the original entity') for: win.			^false].	aType class == LensStructureType		ifTrue: 			[aType isMapped				ifFalse: 					[Dialog warn: ((#GenKeyMapEntityToTable &lt;&lt; #lensDev &gt;&gt; 'The Entity: &lt;1s&gt;&lt;n&gt;should be mapped to a table before&lt;n&gt;being used as the type of a variable')			expandMacrosWith: aType name) for: win.					^false].			aType idVariables size == 0				ifTrue: 					[Dialog warn: ((#GenKeyDefineEntityKey &lt;&lt; #lensDev &gt;&gt; 'The Entity: &lt;1s&gt;&lt;n&gt;should have a key defined before&lt;n&gt;being used as the type of a variable')			expandMacrosWith: aType name) for: win.					^false]].	self selVar value isId ifTrue: [(aType memberClass == Object or: [aType decodeSelector notNil or: [aType isLensType not]])			ifTrue: 				[Dialog warn: (#GenKeyInvalidValueForKeys &lt;&lt; #lensDev &gt;&gt; 'Variables used in keys should not be typedas Object or Boolean, or as ''encoded types''such as Date or ByteSymbol.') for: win.				^false]].	^true</body><body package="Lens-Dev">disableChildSets	(self builder componentAt: #variableCollection) beInvisible</body><body package="Lens-Dev">enable: aBoolean group: ids 	"Enable or disable a collection of widgets whose names are given in ids"	ids		do: 			[:id | 			| comp |			comp := builder componentAt: id.			comp notNil ifTrue: [aBoolean					ifTrue: [comp enable]					ifFalse: [comp disable]]]</body><body package="Lens-Dev">enableChildSets	(self builder componentAt: #variableCollection) beVisible</body><body package="Lens-Dev">enableLength	"Enable the columnLength field only if it makes sense to define a length"	self enable: (selCol value notNil			and: 				[| fieldType |				fieldType := self ldm fieldTypeForColumn: selCol value.				fieldType memberClass inheritsFrom: Collection])		group: #(#columnLength)</body><body package="Lens-Dev">select: anElement	"Ask the graph view to select the given element"	graphView notNil ifTrue: [graphView select: anElement]</body><body package="Lens-Dev">selectSingleKey	"changes the key to the single variable selected"	| keyList idSrc selectedVariable myType |	myType := type value.	myType isNil ifTrue: [^self].	(selectedVariable := selVar value) isNil ifTrue: [^self].	(self canBeKey: selectedVariable) ifFalse: [^self].	keyList := myType variables select: [:each | each isId].	keyList do: [:var | var isId: false].	selectedVariable isId: true.	selectedVariable valueType isSerialNumber		ifTrue:	[ idSrc := #sequenceId ]		ifFalse:	[ idSrc := #userDefinedId ].	myType idGeneratorType: idSrc.	myType idVariable: selectedVariable.	self updateTypeReferencesClearingType: false.	self invalidateDataModel.	self setFocus.	selectedVariable notNil ifTrue: [self select: selectedVariable].</body><body package="Lens-Dev">updateReferencesToType: aType clearType: flag 	"Update the references in the Data Model. The simplest thing to do here is to 	unmap the variables referencing this type"	| touched typesChanged |	touched := OrderedCollection new.	typesChanged := Set new.	aType dataModel structureTypes do: [:st | st variables do: [:var | var valueType = aType				ifTrue: 					[var beUnmappedOfType: (flag							ifTrue: [self ldm typeOf: Object]							ifFalse: [aType]).					var isId ifTrue: [typesChanged add: var objectType].					touched add: var]]].	typesChanged do: [:tp | touched addAll: (self updateReferencesToType: tp clearType: flag)].	^touched</body><body package="Lens-Dev">updateTypeReferencesClearingType: flag	| touched |	touched := self updateReferencesToType: type value clearType: flag.	touched size &gt; 0		ifTrue: 			[| str |			str := WriteStream on: (String new: 500).			str nextPutAll: (#TheReferences &lt;&lt; #lensDev &gt;&gt; 'The references:') asString; cr.			touched				do: 					[:var | 					str tab.					str nextPutAll: var objectType name.					str nextPutAll: ' --&gt; '.					str nextPutAll: var name.					str cr].			str nextPutAll: (#GenKeyNeedUpdate &lt;&lt; #lensDev &gt;&gt; 'need to be updated to be consistent with this change') asString.			Dialog warn: str contents for: builder window]</body></methods><methods><class-id>Lens.LensMappingEditor</class-id> <category>updating</category><body package="Lens-Dev">autoacceptChanges	"Make sure that any edits made in our window get autoaccepted"	(self builder notNil and: [self builder keyboardProcessor notNil])		ifTrue: [self builder keyboardProcessor requestGlobalAutoAccept]</body><body package="Lens-Dev">update: anAspectSymbol 	anAspectSymbol == #value		ifTrue: [self changedType]		ifFalse: [anAspectSymbol == #close			ifTrue: [self closeRequest]			ifFalse: [anAspectSymbol == #autoAccept				ifTrue: [self autoacceptChanges]]]</body></methods><methods><class-id>Lens.LensMappingEditor</class-id> <category>events</category><body package="Lens-Dev">windowEvent: anEvent from: anApplicationWindow 	"Release resources when  the application is closed."	super windowEvent: anEvent from: anApplicationWindow.	anEvent key == #close ifTrue: [ self release ]</body></methods><methods><class-id>Lens.LensApplicationSpec</class-id> <category>accessing</category><body package="Lens-Dev">appType	^appType</body><body package="Lens-Dev">appType: aSymbol	appType := aSymbol.	self superclass: aSymbol.	self changed: #value</body><body package="Lens-Dev">category 	category isNil ifTrue: [(category := LensApplicationCreationDialog categoryOfDefaultDataModel) isNil ifTrue: [category := #'UIApplications-New']].	^category</body><body package="Lens-Dev">category: aSymbol	category := aSymbol</body><body package="Lens-Dev">dataModel	^dataModel</body><body package="Lens-Dev">dataModel: modelDesignator	dataModel := modelDesignator.	self rowType: OrderedCollection new.	self changed: #value</body><body package="Lens-Dev">editPolicy	^editPolicy</body><body package="Lens-Dev">editPolicy: aValue	editPolicy := aValue</body><body package="Lens-Dev">fields	^fields</body><body package="Lens-Dev">fields: fieldSpecs	fields := fieldSpecs</body><body package="Lens-Dev">fullName	| cl |	^(self nameSpace isNil or: [(cl := (self nameSpace at: (name asSymbol) ifAbsent: [nil])) isNil])		ifTrue: [name]		ifFalse: [cl fullName]</body><body package="Lens-Dev">kind	^kind</body><body package="Lens-Dev">kind: kindSymbol	kind := kindSymbol</body><body package="Lens-Dev">lockPolicy	^lockPolicy</body><body package="Lens-Dev">lockPolicy: aValue	lockPolicy := aValue</body><body package="Lens-Dev">name	| cl |	^(self nameSpace isNil or: [(cl := (self nameSpace at: (name asSymbol) ifAbsent: [nil])) isNil])		ifTrue: [name]		ifFalse: [cl fullyQualifiedReference]</body><body package="Lens-Dev">name: aName 	"aName can either be nil or a new class name.  If aName's first letter	is lowercase, make it upper.  Then check to see if the class already	exists, if it does, use the newName that already existed as a class	name"	| newName |	(aName notNil and: [aName size &gt; 0])		ifTrue: 			[name := aName copy asString.			(aName at: 1) isLowercase				ifTrue: [name at: 1 put: (name at: 1) asUppercase].			name := name asSymbol]		ifFalse: [name := nil].	name notNil ifTrue: [newName := Smalltalk classNames detect: [ :n | name match: n ] ifNone: [ nil ]].	newName notNil ifTrue: [ name := newName ].	self changed: #name</body><body package="Lens-Dev">nameSpace	^nameSpace</body><body package="Lens-Dev">nameSpace: aNameSpace	nameSpace := aNameSpace</body><body package="Lens-Dev">privateName	"just return the name, ignoring nameSpace"	^name</body><body package="Lens-Dev">rowType	^rowType</body><body package="Lens-Dev">rowType: typeDesignators	rowType := typeDesignators</body><body package="Lens-Dev">selector	selector isNil ifTrue: [selector := #windowSpec].	^selector</body><body package="Lens-Dev">selector: sym	selector := sym</body><body package="Lens-Dev">superclass	^superclass</body><body package="Lens-Dev">superclass: aSuperclass	superclass := aSuperclass</body><body package="Lens-Dev">template	^template</body><body package="Lens-Dev">template: t	template := t</body></methods><methods><class-id>Lens.LensApplicationSpec</class-id> <category>private</category><body package="Lens-Dev">fieldsLiteralArray	| arr |	arr := Array new: fields size.	1 to: fields size		do: 			[:i | 			| cascade typ |			cascade := ((fields at: i)						at: 1) asArray.			typ := (fields at: i)						at: 2.			arr at: i put: (Array					with: cascade					with: typ					with: ((fields at: i)							at: 3))].	^arr</body><body package="Lens-Dev">fieldsLiteralArray: arr 	fields := OrderedCollection new: arr size.	1 to: arr size		do: 			[:i | 			(arr at: i)				at: 1 put: ((arr at: i)					at: 1) asOrderedCollection.			fields add: (arr at: i)].	^fields</body><body package="Lens-Dev">fromLiteralArrayEncoding: anArray	2 to: anArray size by: 2 do:		 [:i | self perform: (anArray at: i) with: (anArray at: i + 1)]</body><body package="Lens-Dev">literalArrayEncoding	| a |	a := Array new: 11.	a at: 1 put: self class fullyQualifiedReference.	a at: 2 put: #dataModel:.	a at: 3 put: self dataModel.	a at: 4 put: #fieldsLiteralArray:.	a at: 5 put: self fieldsLiteralArray.	a at: 6 put: #kind:.	a at: 7 put: self kind.	a at: 8 put: #rowTypeLiteralArray:.	a at: 9 put: self rowTypeLiteralArray.	a at: 10 put: #template:.	a at: 11 put: self template.	^a</body><body package="Lens-Dev">rowTypeLiteralArray	| arr |	arr := Array new: rowType size.	1 to: rowType size do: [:i |		arr at: i put: (rowType at: i) literalArrayEncoding].	^arr</body><body package="Lens-Dev">rowTypeLiteralArray: arr	rowType := OrderedCollection new: arr size.	1 to: arr size do: [:i |		rowType add: (arr at: i) decodeAsLiteralArray].	^rowType</body><body package="Lens-Dev">value	^self</body></methods><methods><class-id>Lens.LensApplicationSpec class</class-id> <category>private</category><body package="Lens-Dev">decodeFromLiteralArray: anArray	^self new fromLiteralArrayEncoding: anArray</body></methods><methods><class-id>Lens.LensDFConnectionSliceModel</class-id> <category>interface opening</category><body package="Lens-Dev">postBuildWith: aBuilder	| target |	((target := (aBuilder bindings at: #parentModel) selectionHolder value model targetClass) notNil			and: [(target inheritsFrom: LensDataManager) not])		ifTrue:			[((builder componentAt: #synchronizeCheckbox) disable; widget) model value: false]</body></methods><methods><class-id>Lens.LensDFConnectionSliceModel</class-id> <category>aspects</category><body package="Lens-Dev">specChannel	^specChannel</body></methods><methods><class-id>Lens.LensApplicationStructureView</class-id> <category>accessing</category><body package="Lens-Dev">finder	^finder</body><body package="Lens-Dev">finder: aUIFinder 	"Be sure to remove any preexisting dependency and not to make us dependent of nil"	finder notNil ifTrue: [finder removeDependent: self].	finder := aUIFinder.	finder notNil ifTrue: [finder addDependent: self]</body><body package="Lens-Dev">focus	"The focus is the class we are interested in looking at its structure, if the value of this valueHolder changes, we update the graph"	focus isNil		ifTrue: 			[focus := nil asValue.			focus onChangeSend: #changedFocus to: self].	^focus</body><body package="Lens-Dev">graphView	^graphView</body><body package="Lens-Dev">selection	^selection</body></methods><methods><class-id>Lens.LensApplicationStructureView</class-id> <category>events</category><body package="Lens-Dev">noticeOfWindowClose: aWindow 	self finder: nil.	^super noticeOfWindowClose: aWindow</body></methods><methods><class-id>Lens.LensApplicationStructureView</class-id> <category>updating</category><body package="Lens-Dev">update: aspect 	aspect == #update ifTrue: [self focus value: self focus value]</body><body package="Lens-Dev">update: aspect with: aParameter 	aspect == #update		ifTrue: [self focus value: self focus value]		ifFalse: [aspect == #recentlyVisited			ifTrue: [(self focus value notNil						and: [aParameter first notNil						and: [self focus value name = (aParameter at: 1) name]])					ifTrue: [self update]]]</body></methods><methods><class-id>Lens.LensApplicationStructureView</class-id> <category>actions</category><body package="Lens-Dev">showClass	"Ask for the class name, if found set it as the focus. Could be improved by 	having wildcards"	| nm |	nm := UIFinderVW2 openTargetClassNameDialogFor: (selection value isNil					ifTrue: ['']					ifFalse: [selection value name])				message: (#EnterClassName &lt;&lt; #lensDev &gt;&gt; 'Enter Class Name').	nm size &gt; 0		ifTrue: 			[| cl |			cl := self class environment at: nm asSymbol ifAbsent: [nil].			cl notNil				ifTrue: [self focus value: cl]				ifFalse: [Dialog warn: (#ClassNotFound &lt;&lt; #lensDev &gt;&gt; 'Class not found')]]</body><body package="Lens-Dev">update	self focus value: self focus value</body></methods><methods><class-id>Lens.LensApplicationStructureView</class-id> <category>initialize release</category><body package="Lens-Dev">initialize	super initialize.	graphView := LensGraphView onPerspective: #dbApplication.	graphView browserModel selectionService compute: [self selectionInGraph].	graphView browserModel visualBuilderClass: LDMProtoMapBuilder.	selection := nil asValue.</body></methods><methods><class-id>Lens.LensApplicationStructureView</class-id> <category>changes</category><body package="Lens-Dev">changedFocus	"Set the focus in the graph view, clean the selection"	self graphView focus: (Set with: focus value).	selection value: nil.	(self builder notNil and: [self builder window notNil])		ifTrue: [self builder window label: ((#DataFormsIn1s &lt;&lt; #lensDev &gt;&gt; 'Data Forms in &lt;1s&gt;')			expandMacrosWith: focus value name)]</body><body package="Lens-Dev">selectionInGraph	"A class has been selected in the graph, if the class is not nil then also set 	the selection in the finder"	graphView		selectionDo: 			[:aClass | 			selection value: aClass.			(aClass notNil and: [self finder notNil])				ifTrue: [self finder classNameList selection: aClass fullyQualifiedReference]]</body></methods><methods><class-id>Lens.LensApplicationStructureView class</class-id> <category>fileIn/Out</category><body package="Lens-Dev">prerequisitesForLoading	"LensApplicationStructure requires LDMPerspective	 since it is used in initializePerspectives."	^super prerequisitesForLoading		add: LDMPerspective;		yourself</body></methods><methods><class-id>Lens.LensApplicationStructureView class</class-id> <category>class initialization</category><body package="Lens-Dev">initialize	self initializePerspectives</body><body package="Lens-Dev">initializePerspectives	"self initializePerspectives"	^List new add: ((Array new: 9) at: 1 put: #LDMPerspective; at: 2 put: #arrRows:; at: 3 put: #(#(#F1 #V1 'references' true false false false false ) #(#V1 #V1 'references' false false true false false ) ); at: 4 put: #arrLabelHints:; at: 5 put: #(); at: 6 put: #arrRelDesc:; at: 7 put: ((Array new: 1) at: 1 put: ((Array new: 5) at: 1 put: 'references'; at: 2 put: true; at: 3 put: #solid; at: 4 put: ColorValue darkRed; at: 5 put: 2; yourself); yourself); at: 8 put: #name:; at: 9 put: #dbApplication; yourself) decodeAsLiteralArray; yourself</body></methods><methods><class-id>Lens.LensTablesSelector</class-id> <category>changes</category><body package="Lens-Dev">changedPattern	"For the 'tables' window, when the pattern changes we have to recompute 	the list of tables"	editor selectedDataModel notNil ifTrue: 		[| aPattern tables lens |		Cursor database			showWhile: 				[aPattern := self pattern value.				(aPattern size &gt; 0 and: [(lens := self catalogLens) notNil])					ifTrue: 						[| lensSession |                        lensSession := self catalogLens.                        lensSession revertAllObjects. "Revert the objects to force fetching so changes in the data dictionary are seen"						tables := lens dataModel databaseContext listTablesLike: aPattern in: lensSession.						tables == nil ifTrue: [tables := OrderedCollection new: 0]]					ifFalse: [tables := OrderedCollection new: 0].				self tablesList list: tables]]</body><body package="Lens-Dev">changedSelectedColumn	"The user has selected a column, we show the type and the 'NULL' 	properties of the column"	| sel |	sel := columnsList selection.	sel isNil		ifTrue: 			[columnType value: ''.			columnCanBeNull value: '']		ifFalse: 			[columnType value: sel dataType displayString.			sel isNotNil				ifTrue: [columnCanBeNull value: (#MustNotBeNull &lt;&lt; #lensDev &gt;&gt; 'Must Not be Null') asString]				ifFalse: [columnCanBeNull value: (#CanBeNull &lt;&lt; #lensDev &gt;&gt; 'Can be Null') asString]]</body><body package="Lens-Dev">changedTableSelection	"A different table has been selected, show all its columns"	| sel |	((sel := self tablesList selection) isNil or: [sel columns isNil])		ifTrue: [self columnsList list: OrderedCollection new]		ifFalse: [self columnsList list: sel columns].	self setEnablement</body><body package="Lens-Dev">setEnablement	"Enable or disable the map and create buttons. The create button is enabled 	if a table is selected. The map button is enabled if a table is selected and a 	type is selected in the editor, and the selected type is not already mapped"	| selTab selTyp |	selTab := self tablesList selection.	self enable: selTab notNil group: #(#createButton).	selTyp := editor selectedType.	self enable: (selTab notNil and: [selTyp notNil and: [selTyp isMapped not]])		group: #(#mapButton)</body></methods><methods><class-id>Lens.LensTablesSelector</class-id> <category>aspects</category><body package="Lens-Dev">columnCanBeNull	columnCanBeNull isNil ifTrue: [columnCanBeNull := '' asValue].	^columnCanBeNull</body><body package="Lens-Dev">columnType	columnType isNil ifTrue: [columnType := '' asValue].	^columnType</body><body package="Lens-Dev">columnsList	"The columnsList is initialized to a SelectionInList. Changes in selection are notified"	columnsList isNil		ifTrue: 			[columnsList := SelectionInList new.			columnsList list: #().			columnsList selectionIndexHolder onChangeSend: #changedSelectedColumn to: self].	^columnsList</body><body package="Lens-Dev">defaultPattern	| ldm usr |	editor notNil ifTrue:		[ldm := editor selectedDataModel.		ldm notNil ifTrue: [usr := ldm databaseContext username]].	^usr isNil		ifTrue: ['%']		ifFalse: [usr , '.%']</body><body package="Lens-Dev">pattern	pattern isNil ifTrue:		[ pattern := self defaultPattern asValue ].	^pattern</body><body package="Lens-Dev">tablesList	"Tha tables list is initialized to send an update when the selection in it changes"	tablesList isNil		ifTrue: 			[tablesList := SelectionInList new.			tablesList selectionIndexHolder onChangeSend: #changedTableSelection to: self].	^tablesList</body></methods><methods><class-id>Lens.LensTablesSelector</class-id> <category>update</category><body package="Lens-Dev">update: aspect 	"If the data model has changed in the editor assume that we're working with 	a completely new data model and reinitialize. If the selected type has 	changed then update the enablement of the buttons"	aspect == #dataModel		ifTrue: 			[self tablesList list: List new.	"Will also eliminate the columns list and any selections."			self pattern value: self defaultPattern]		ifFalse: [aspect == #selectedType				ifTrue: [self setEnablement]				ifFalse: [super update: aspect]]</body></methods><methods><class-id>Lens.LensTablesSelector</class-id> <category>accessing</category><body package="Lens-Dev">catalogLens	^editor catalogLens</body><body package="Lens-Dev">editor: aLensEditor	editor := aLensEditor.	editor addDependent: self</body></methods><methods><class-id>Lens.LensTablesSelector</class-id> <category>private</category><body package="Lens-Dev">enable: aBoolean group: ids 	"Enable or disable a collection of widgets whose names are given in 'ids'"	ids		do: 			[:id | 			| comp |			comp := builder componentAt: id.			comp notNil ifTrue: [aBoolean					ifTrue: [comp enable]					ifFalse: [comp disable]]]</body></methods><methods><class-id>Lens.LensTablesSelector</class-id> <category>initialize-release</category><body package="Lens-Dev">release	editor notNil ifTrue: [editor removeDependent: self]</body></methods><methods><class-id>Lens.LensTablesSelector</class-id> <category>actions</category><body package="Lens-Dev">addClassForTable	"Assume: there is a selected row."	| table |	table := self tablesList selection.	table == nil ifTrue: [^Dialog warn: (#firstSelectATable &lt;&lt; #lensDev &gt;&gt; 'first select a Table') for: builder window].	table columns size == 0 ifTrue: [^Dialog warn: (#GenKeyNoColumnTable &lt;&lt; #lensDev &gt;&gt; 'This table has no columns.At least one column is required to be used as key') for: builder window].	editor addClassForTable: table</body><body package="Lens-Dev">mapTable	"Assume: there is a selected row."	| table |	table := self tablesList selection.	table == nil ifTrue: [^Dialog warn: (#firstSelectATable &lt;&lt; #lensDev &gt;&gt; 'first select a Table') for: builder window].	editor mapTable: table</body></methods><methods><class-id>Lens.QueryEditor</class-id> <category>resources</category><body package="Lens-Dev">buildFunctionsMenu	"Builds the functions menu. The functions included depend on the specific transporter"	| mb transC |	mb := MenuBuilder new.	(transC := self transporterClass) isNil ifFalse: [transC functionsDictionaries			keysAndValuesDo: 				[:k :dict | 				mb beginSubMenuLabeled: k.				dict keysDo: [:functionK | mb add: ' ' , functionK -&gt; (self makeFunctionCallFor: functionK)].				mb endSubMenu]].	mb beginSubMenuLabeled: (#Arbitrary &lt;&lt; #lensDev &gt;&gt; 'Arbitrary').	#(#char #integer #float #date)		do: 			[:sy | 			| funK |			funK := sy , 'Function:'.			1 to: 5				do: 					[:i | 					mb add: ' ' , funK -&gt; (self makeFunctionCallFor: funK).					funK := funK , 'with:']].	mb endSubMenu.	^mb menu</body><body package="Lens-Dev">functionsMenu	functionsMenu isNil ifTrue: [functionsMenu := self buildFunctionsMenu asValue].	^functionsMenu</body><body package="Lens-Dev">instanceVariablesMenu	"Returns a menu holder which will contain a menu featuring the class instance variables"	^instanceVariablesMenu</body><body package="Lens-Dev">instanceVariablesMenuFor: aClass 	| mb |	mb := MenuBuilder new.	aClass instVarNames do: [:n | mb add: ' ',n -&gt; n copy].	instanceVariablesMenu value: mb menu</body><body package="Lens-Dev">makeFunctionCallFor: functionK 	| s res |	s := functionK readStream.	res := WriteStream on: (String new: 20).	res nextPutAll: (s upTo: $:); nextPut: $:.	s atEnd ifTrue: [^functionK].	[s atEnd]		whileFalse: 			[res nextPutAll: ' ? '.			res nextPutAll: (s upTo: $:); nextPut: $:].	res space.	^res contents</body></methods><methods><class-id>Lens.QueryEditor</class-id> <category>aspects</category><body package="Lens-Dev">aggregate	^menusValue</body><body package="Lens-Dev">answer	^answer</body><body package="Lens-Dev">character	^menusValue</body><body package="Lens-Dev">classFinder	^classFinder</body><body package="Lens-Dev">conversion	^menusValue</body><body package="Lens-Dev">current	^current</body><body package="Lens-Dev">date	^menusValue</body><body package="Lens-Dev">distinct	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^distinct isNil ifTrue: [distinct := false asValue] ifFalse: [distinct]</body><body package="Lens-Dev">from	^from</body><body package="Lens-Dev">fullObjects	^fullObjects</body><body package="Lens-Dev">groupBy	^groupBy</body><body package="Lens-Dev">lock	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^lock isNil ifTrue: [lock := false asValue] ifFalse: [lock]</body><body package="Lens-Dev">menusValue	^menusValue</body><body package="Lens-Dev">number	^menusValue</body><body package="Lens-Dev">orderBy	^orderBy</body><body package="Lens-Dev">other	^menusValue</body><body package="Lens-Dev">pattern	^pattern</body><body package="Lens-Dev">tablesView	^tablesView</body><body package="Lens-Dev">unique	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^unique isNil ifTrue: [unique := false asValue] ifFalse: [unique]</body><body package="Lens-Dev">where	^where</body></methods><methods><class-id>Lens.QueryEditor</class-id> <category>generate</category><body package="Lens-Dev">acceptAll	"InputFields and other text editors do not automatically accept their changes"	#(#whereField #answerField #groupByField #orderByField )		do: 			[:sy | 			| com |			com := self builder componentAt: sy.			com notNil ifTrue: [com widget controller accept]]</body><body package="Lens-Dev">acceptClassName	| selection |	selection := (BindingReference pathString: classFinder className value) valueOrDo: 						[^(builder componentAt: #classFinder) widget flash].	self targetClass: selection.	self markDirty</body><body package="Lens-Dev">checkClass	"Check that a class name was given. This situation can happen only for 	arbitrary queries, where the query editor was started without a target class"	(self targetClass isNil or: [classFinder className value size == 0])		ifTrue: 			[(builder componentAt: #classFinder) widget flash.			Dialog				warn: (#GenKeyNeedClassNameForQuery &lt;&lt; #lensDev						&gt;&gt; 'You must enter the name of the class&lt;n&gt;on which to install the query.')							expandMacros.			builder keyboardProcessor				focusedView: (classFinder builder componentAt: #className) widget.			^false].	^true</body><body package="Lens-Dev">checkPattern	"Check that the pattern make sense and give instructions if not"	| vw |	pattern value size == 0		ifTrue: 			[| newPattern |			menuAccessorName notNil				ifTrue: 					[newPattern := #queryFor1s &lt;&lt; #lensDev &gt;&gt; 'queryFor&lt;1s&gt;'								expandMacrosWith: menuAccessorName]				ifFalse: [newPattern := ''].			newPattern size == 0				ifTrue: 					[(vw := (builder componentAt: #pattern) widget) flash.					Dialog warn: #GenKeyEnterMessagePattern &lt;&lt; #lensDev								&gt;&gt; 'You must enter the message pattern for the query:its selector, including zero or more variable names'.					builder keyboardProcessor focusedView: vw.					^false]				ifFalse: 					[pattern value: newPattern.					^true]].	^true</body><body package="Lens-Dev">compileIt: s classifiedAs: protocol 	"Compile s classified in the given protocol"	QueryCompiler new		compile: s contents		class: self targetClass		classified: protocol		notifying: nil		ifFail: [^self]</body><body package="Lens-Dev">install	| s  | 	self acceptAll.	s := (String new: 100) writeStream.	(self checkClass and: [self checkPattern])		ifTrue: 			[s nextPutAll: pattern value.			s crtab;				nextPutAll: '"This method should only be modified using the Query Editor'; crtab;				nextPutAll: 'any other edits may be lost."';				cr.			"Put in a nice comment for re-opening the query editor."			s crtab; 				nextPutAll: '"QueryEditor new openOnClass: self andSelector: '; 				nextPutAll: targetSelector printString; 				nextPut: $"; cr.				"Now put the real method"			s crtab; 				nextPutAll: '&lt;resource: #query&gt;'; crtab;				nextPutAll: '| _qo |'; crtab; 				nextPutAll: '_qo := LensQuery new.'; crtab.			self putPatternInto: s.			self putContainerNamesInto: s.			self putAnswerInto: s.			self putWhereInto: s.			self putOrderByInto: s.			self putGroupByInto: s.			self distinct value ifTrue: [s nextPutAll: '_qo distinct.'; crtab].			self unique value ifTrue: [s nextPutAll: '_qo unique.'; crtab].			self lock value ifTrue: [s nextPutAll: '_qo locking.'; crtab].			self useStreaming value ifTrue: [s nextPutAll: '_qo useStreaming: true.'; crtab].			s nextPutAll: '_qo mode: '.			mode storeOn: s.			s nextPut: $.; crtab.			s nextPutAll: '^_qo'.			self warnInstall				ifTrue:					[self compileIt: s classifiedAs: #query.					self targetClass class removeSelector: #markedAsSystemClass.					UIFinderVW2 installed: (Array with: self targetClass with: self targetSelector).					saved := true]]</body><body package="Lens-Dev">loadIt	| query args |	args := OrderedCollection new.	targetSelector asString do: [:c | c == $: ifTrue: [args add: nil]].	query := self targetClass new			perform: targetSelector			withArguments: args asArray.	^self loadTheQuery: query</body><body package="Lens-Dev">loadQuery	self changeRequest ifFalse: [^self].	self runLoadDialog</body><body package="Lens-Dev">loadTheQuery: query  	self updateFromFrom: query.	pattern value: query description.	where value: query selectBlockSource.	answer value: query answerBlockSource.	self resetAnswerFields.	orderBy value: query orderByBlockSource.	groupBy value: query groupByBlockSource.	self distinct value: query isDistinct.	self unique value: query isUnique.	self lock value: query isLocking.	self useStreaming value: query useStreaming.	self mode: query mode</body><body package="Lens-Dev">putAnswerInto: s 	| clean |	clean := self removeLeadingSpaces: answer value.	answer value: clean.	clean size &gt; 0		ifTrue: 			[editorKind == #menu ifTrue: [selectedTables size &gt; 0					ifTrue: 						[| t |						t := selectedTables first.						clean := clean , ' , ' , t expressionString]].			s nextPutAll: '_qo answer: '.			self putBlockPreambleInto: s.			s nextPutAll: clean.			s nextPutAll: '].'; cr; tab].	s nextPutAll: '_qo answerBlockSource: '.	clean storeOn: s.	s nextPut: $.; cr; tab</body><body package="Lens-Dev">putBlockPreambleInto: s	s nextPut: $[.	selectedTables do: [:tab | s nextPut: $:; nextPutAll: tab name; space].	s nextPutAll: '| '.</body><body package="Lens-Dev">putContainerNamesInto: s 	s nextPutAll: '_qo arrayContainerNames: #('.	selectedTables		do: 			[:tab | 			s nextPut: $(.			tab name storeOn: s.			s space.			tab referred name storeOn: s.			s nextPut: $); space].	s nextPutAll: ').'; cr; tab</body><body package="Lens-Dev">putGroupByInto: s 	| clean |	clean := self removeLeadingSpaces: groupBy value.	groupBy value: clean.	clean size &gt; 0		ifTrue: 			[s nextPutAll: '_qo groupBy: '.			self putBlockPreambleInto: s.			s nextPutAll: clean.			s nextPutAll: '].'; cr; tab].	s nextPutAll: '_qo groupByBlockSource: '.	clean storeOn: s.	s nextPut: $.; cr; tab</body><body package="Lens-Dev">putOrderByInto: s 	| clean |	clean := self removeLeadingSpaces: orderBy value.	orderBy value: clean.	clean size &gt; 0		ifTrue: 			[s nextPutAll: '_qo orderBy: '.			self putBlockPreambleInto: s.			s nextPutAll: clean.			s nextPutAll: '].'; cr; tab].	s nextPutAll: '_qo orderByBlockSource: '.	clean storeOn: s.	s nextPut: $.; cr; tab</body><body package="Lens-Dev">putPatternInto: s 	| clean |	clean := self removeLeadingSpaces: pattern value.	pattern value: clean.	s nextPutAll: '_qo description: '.	clean storeOn: s.	s nextPut: $.; cr; tab</body><body package="Lens-Dev">putWhereInto: s 	| clean |	clean := self removeLeadingSpaces: where value asString.	where value: clean.	clean size &gt; 0		ifTrue: 			[s nextPutAll: '_qo selectWhere: '.			self putBlockPreambleInto: s.			s nextPutAll: clean.			s nextPutAll: '].'; cr; tab].	s nextPutAll: '_qo selectBlockSource: '.	clean storeOn: s.	s nextPut: $.; cr; tab</body><body package="Lens-Dev">removeLeadingSpaces: str 	| s |	str isNil ifTrue: [^''].	s := str readStream.	s skipSeparators.	^s upToEnd</body><body package="Lens-Dev">resetAnswerFields	fullObjects value: (answer value size &lt; 1)</body><body package="Lens-Dev">runInstallationDialog	"The assumption embodied here is that the source for resources 	while painting is a class: the send of targetClass: will also change 	the source instVar of the receiver's builder."	| result |	result := self targetClass isNil				ifTrue: [UIFinderVW2						openDestinationDialogForResource: #query						defaultSelector: #querySelectBlock]				ifFalse: [UIFinderVW2						openDestinationDialogWithClass: self targetClass						andSelector: (self targetSelector isNil								ifTrue: [#querySelectBlock]								ifFalse: [self targetSelector])						andResource: #query].	result isNil ifTrue: [^nil].	self targetClass: (result at: 1).	self targetSelector: (result at: 2).	^result</body><body package="Lens-Dev">runLoadDialog	"The assumption embodied here is that the source for resources 	while painting is a class: the send of targetClass: will also change 	the source instVar of the receiver's builder."	| result |	result := self targetClass isNil				ifTrue: [self openSourceDialogForClass: nil andCategory: #query]				ifFalse: [self openSourceDialogForClass: self targetClass andCategory: #query].	result isNil ifTrue: [^nil].	self loadClass: (result at: 1)		andSelector: (result at: 2).	^result</body><body package="Lens-Dev">updateFromFrom: query 		selectedTables := OrderedCollection new.	query containerNames		do: 			[:ref | 			| t cRef |			cRef := ref asContainerReference.			t := tables detect: [:tab | tab referredName = cRef referredName]						ifNone: 							[Dialog warn: ((#GenKeyUnfoundEntity &lt;&lt; #lensDev &gt;&gt; 'The entity &lt;1s&gt;&lt;n&gt;is not found In the current Data Model and will be ignored')			expandMacrosWith: ref referred displayString) for: (builder notNil									ifTrue: [builder window]									ifFalse: [nil]).							nil].			t notNil				ifTrue: 					[cRef referred: t referred.					selectedTables add: cRef]].	self updateFromField</body></methods><methods><class-id>Lens.QueryEditor</class-id> <category>evaluating</category><body package="Lens-Dev">blockWithBody: body	"Answer a block closure with the receiver's variables and the given body."	| stream bindings closure clean |	clean := self removeLeadingSpaces: body.	(clean isNil or: [clean isEmpty]) ifTrue: [^nil].	stream := (String new: 40) writeStream.	stream nextPut: $[.	selectedTables do: [:var |		stream nextPut: $:; nextPutAll: var name; space].	stream nextPut: $|; nextPutAll: clean; nextPut: $].	"use IWBindingHolder to temporarily hold the bindings for block compilation"	"bindings := IdentityDictionary new.	IWBindingHolder setClassVars: bindings."	closure := self class compilerClass new		evaluate: stream contents in: nil receiver: self class notifying: nil ifFail: [].	"IWBindingHolder setClassVars: nil."	^closure</body><body package="Lens-Dev">compileOperation	"Set the current operation's properties from the current query."	|   operation |	operation := QueryOperation new.	operation containerNames: (selectedTables collect: [:tab | tab]) asArray.	operation selectWhere: (self blockWithBody: where value).	operation answer: (self blockWithBody: answer value).	operation orderBy: (self blockWithBody: orderBy value).	operation groupBy: (self blockWithBody: groupBy value).	operation isDistinct: distinct value.	operation isUnique: unique value.	operation isLocking: lock value.	^operation</body></methods><methods><class-id>Lens.QueryEditor</class-id> <category>actions</category><body package="Lens-Dev">and	self insert: ' &amp; '</body><body package="Lens-Dev">ascending	self insert: ' ascending  '</body><body package="Lens-Dev">biggerOrEqual	self insert: ' &gt;= '</body><body package="Lens-Dev">biggerThan	self insert: ' &gt; '</body><body package="Lens-Dev">comma	self insert: ' , '</body><body package="Lens-Dev">defaultJoin	"Add the default joins between the classes selected in the 'from' part. If there is more than one way of joining the tables then show a list of the possible joins and let the user select the desired one or cancel the operation"	| joinPaths path win |	builder notNil ifTrue: [win := builder window].	joinPaths := OrderedCollection new.	1 to: selectedTables size - 1		do: 			[:i | 			| lastVar |			lastVar := selectedTables at: i.			i + 1 to: selectedTables size				do: 					[:j | 					| var |					var := selectedTables at: j.					self						addJoinPathFrom: var						to: lastVar						into: joinPaths.					self						addJoinPathFrom: lastVar						to: var						into: joinPaths]].	joinPaths := joinPaths asArray.	joinPaths isEmpty ifTrue: [^self].	path := joinPaths size &gt; 1				ifTrue: [Dialog 						choose: (#GenKeyMoreThanOneForeignKey &lt;&lt; #lensDev &gt;&gt; 'There is more than one foreign key reference on which to base a default join.Select which clause to use, or press Cancel to avoid any sensitivity to foreign keys.') 						fromList: joinPaths 						values: joinPaths 						lines: 5 						cancel: [0]						for: win]				ifFalse: [joinPaths first].	path = 0 ifTrue: [^self].	self insert: path</body><body package="Lens-Dev">defaultMixinJoin	"Add the default joins between the row of the parent class and the classes 	selected in the 'from' part. If there is more than one way of joining the tables	then show a list of the possible joins and let the user select the desired one	or cancel the operation"	| rowTables joinPaths path win |	builder notNil ifTrue: [win := builder window].	(ownRow isNil or: [ownRow children size == 0])		ifTrue: [^''].	rowTables := ownRow children asOrderedCollection.	joinPaths := OrderedCollection new.	1 to: rowTables size		do: 			[:i | 			| lastVar |			lastVar := rowTables at: i.			1 to: selectedTables size				do: 					[:j | 					| var |					var := selectedTables at: j.					self						addJoinPathFrom: var						to: lastVar						into: joinPaths.					self						addJoinPathInvertedFrom: lastVar						to: var						into: joinPaths]].	joinPaths := joinPaths asArray.	joinPaths isEmpty ifTrue: [^self].	path := joinPaths size &gt; 1				ifTrue: [Dialog 						choose: (#GenKeyMoreThanOneForegnKey &lt;&lt; #lensDev &gt;&gt; 'There is more than one foreign key reference on which to base a join.  Selectwhich clause to use, or Cancel for no sensitivity to row selection in the parent.') 						fromList: joinPaths 						values: joinPaths 						lines: 5 						cancel: [0]						for: win]				ifFalse: [joinPaths first].	path = 0 ifTrue: [^self].	self insert: path.	^path</body><body package="Lens-Dev">descending	self insert: ' descending  '</body><body package="Lens-Dev">different	self insert: ' ~= '</body><body package="Lens-Dev">divided	self insert: ' / '</body><body package="Lens-Dev">equal	self insert: ' = '</body><body package="Lens-Dev">erase	current value == #from		ifTrue: 			[selectedTables := OrderedCollection new.			self updateFromField]		ifFalse: [self editedField model value: '']</body><body package="Lens-Dev">helpAction	VisualLauncher openHelpBrowser</body><body package="Lens-Dev">helpActionForMenu	(#{HelpBrowser} valueOrDo: [^self error: (#helpUnavailable &lt;&lt; #lensDev &gt;&gt; 'help unavailable')])		openTo: #vwcb</body><body package="Lens-Dev">isLike	self insert: ' isLike: '</body><body package="Lens-Dev">isNilAction	self insert: ' isNil  '</body><body package="Lens-Dev">minus	self insert: ' - '</body><body package="Lens-Dev">multiplied	self insert: ' * '</body><body package="Lens-Dev">notAction	self insert: ' not'</body><body package="Lens-Dev">notNilAction	self insert: ' notNil  '</body><body package="Lens-Dev">openTypingAssistant	| spec newBuilder |	self dependents size &gt; 1		ifTrue:			[(self dependents detect: [:win | win receiveWindowEvents size = 3] ifNone: [^self]) raise.			^self].	newBuilder := self builderClass new.	newBuilder source: self.	newBuilder bindings: (builder bindings).	spec := self class interfaceSpecFor: #typingSpec.	newBuilder add: spec.	newBuilder window model: self.	newBuilder window application: self; beSlave.	builder window beMaster.	builder window application: self.	newBuilder openWithExtent: spec window bounds extent.	newBuilder window controller model: nil.	newBuilder namedComponents associations do: [:assn | builder namedComponents at: assn key put: assn value]</body><body package="Lens-Dev">or	self insert: ' | '</body><body package="Lens-Dev">plus	self insert: ' + '</body><body package="Lens-Dev">prenthesis	self wrapSelectionWith: ' ( ' and: ' ) '</body><body package="Lens-Dev">smallerOrEqual	self insert: ' &lt;= '</body><body package="Lens-Dev">smallerThan	self insert: ' &lt; '</body><body package="Lens-Dev">subQuery	"Open a query editor and when that editor is finished, get back the text to 	be inserted as an expression."</body></methods><methods><class-id>Lens.QueryEditor</class-id> <category>private</category><body package="Lens-Dev">addJoinPathFrom: var1 to: var2 into: pathCollection 	"Add all join paths found from var1 to var2 into the pathCollection."	var1 getChildren do: [:chld | 		chld referred valueType == var2 referred ifTrue: 			[pathCollection add: (self comparisonStringFor: chld and: var2)]]</body><body package="Lens-Dev">addJoinPathInvertedFrom: var1 to: var2 into: pathCollection	"Add all join paths found from var1 to var2 into the pathCollection."	var1 getChildren do: [:chld | 		chld referred valueType == var2 referred ifTrue: 			[pathCollection add: (self comparisonStringFor: var2 and: chld)]]</body><body package="Lens-Dev">addSelectedTable: t 	| count key newT |	editorKind == #menu ifTrue: [selectedTables := OrderedCollection new].	count := 1.	selectedTables do: [:tab | tab referred == t referred ifTrue: [count := count + 1]].	key := t name asString.	key at: 1 put: (key at: 1) asLowercase.	key = t name asString		ifTrue: [key := key, '_'].	count &gt; 1		ifTrue: [key := key , count printString]		ifFalse: [key := key copy].	newT := t copy.	newT name: key.	newT reset.	selectedTables add: newT</body><body package="Lens-Dev">allButtons	^#(#functions #number #character #date #conversion #aggregate #other #and #or #parenthesis #equal #different #biggerThan #smallerThan #biggerOrEqual #smallerOrEqual #comma #isNil #notNil #ascending #descending #subQuery #defaultJoin #plus #minus #multiplied #divided #isLike #not #variable)</body><body package="Lens-Dev">comparisonStringFor: var1 and: var2 	"Build the comparison string between var1 and var2. The cascades in the vars are set up so for 	expressions involving 'row' (i.e. they are used as values in the query) the first element of the cascade 	is a string and not a symbol. In this case we put a guarding 'ifPersistent' as a part of the comparison 	string; this guards against nil and against the row not being persistent (as is the case when creating)"	| stream guard1 guard2 |	stream := (String new: 180) writeStream.	guard1 := var1 cascade size &gt; 0 and: [var1 cascade first isSymbol not].	guard2 := var2 cascade size &gt; 0 and: [var2 cascade first isSymbol not].	guard1 ifTrue: [	stream 					nextPut: $(;					nextPutAll: var1 expressionString;					nextPutAll: ' isPersistent ifTrue: ['].	guard2 ifTrue: [	stream 					nextPut: $(;					nextPutAll: var2 expressionString;					nextPutAll: ' isPersistent ifTrue: ['].	stream 		nextPut: $(; space;		nextPutAll: var1 expressionString;		nextPutAll: ' = ';		nextPutAll: var2 expressionString;		nextPutAll: ' )'.	guard1 ifTrue: [stream nextPutAll: '] ifFalse: [false] )'].	guard2 ifTrue: [stream nextPutAll: '] ifFalse: [false] )'].	^stream contents</body><body package="Lens-Dev">disableFields	"Disables the fields that should not be edited in the different modes"	builder isNil ifFalse: [(#(#mixin #own ) includes: mode)			ifTrue: 				[self enable: false group: #(#from #fromField #answer #answerField #fullObjects #groupBy #groupByField).				current value: #where]			ifFalse: 				[self enable: true group: #(#from #fromField #answer #answerField #fullObjects #groupBy #groupByField).				current value: #from]]</body><body package="Lens-Dev">editedField	self builder notNil		ifTrue: 			[| com |			com := self builder componentAt: (current value , 'Field') asSymbol.			^com widget]		ifFalse: [^nil]</body><body package="Lens-Dev">enable: aBoolean group: ids 	"Enable or disable a collection of widgets whose names are given in 'ids'"	builder notNil ifTrue: [ids			do: 				[:id | 				| comp |				comp := builder componentAt: id.				comp notNil ifTrue: [aBoolean						ifTrue: [comp enable]						ifFalse: [comp disable]]]]</body><body package="Lens-Dev">enableOnly: ids 	"Enable or disable a collection of widgets whose names are given in 'ids'"	| out |	out := self allButtons asSet.	ids do: [:id | out remove: id ifAbsent: [nil]].	self enable: false group: out.	self enable: true group: ids</body><body package="Lens-Dev">getOwnRow	"The own row is used when building a query that will use in the conditions 	as parameter some data from the current row in the application (the parent)"	(ldm notNil and: [self targetClass notNil and: [self targetClass respondsTo: #rowType]])		ifTrue: 			[| rt chlds |			Object subclassResponsibilitySignal handle: [:ex | ^nil]				do: [rt := self targetClass rowType].			ownRow := LensVariableReference new.			ownRow name: #row.			ownRow setCascade: (OrderedCollection with: (#rowValue &lt;&lt; #lensDev &gt;&gt; 'row value') asString).			chlds := OrderedCollection new: rt size.			rt do: [:c | 				| cr |				cr := c asContainerReference.				cr referred: (ldm typeNamed: cr referredName).				cr referred notNil ifTrue: [ chlds add: cr ]].			chlds size == 1				ifTrue: [chlds do: [:c | c setCascade: ownRow cascade]]				ifFalse: [1 to: chlds size						do: 							[:i | 							| chld |							chld := chlds at: i.							chld position: i.							chld setCascade: (OrderedCollection with: ((#rowValueAt1s &lt;&lt; #lensDev &gt;&gt; '(row value at: &lt;1s&gt;)')			expandMacrosWith: i printString))]].			ownRow children: chlds asSet]</body><body package="Lens-Dev">insert: str 	"Inserts the string in the currently edited field at the current position"	| ctrlr fi |	self markDirty.	fi := self editedField.	(fi notNil and: [fi isVisible])		ifTrue: 			[ctrlr := fi controller.			ctrlr replaceSelectionWith: str , ' '.			ctrlr selectionStartIndex: ctrlr selectionStopIndex.			fi selectAt: ctrlr selectionStopIndex - 1]</body><body package="Lens-Dev">menuSelected	self insert: ' ',menusValue value</body><body package="Lens-Dev">selectedTable	"A table or field has been selected"	changing		ifFalse: 			[changing := true.			self markDirty.			current value == #from				ifTrue: 					[tablesView selectionDo: [:t | self addSelectedTable: t].					self updateFromField]				ifFalse: [tablesView selectionDo: [:t | t isString							ifTrue: [self insert: t]							ifFalse: [self insert: t expressionString]]].			tablesView browserModel selectionService deselectAll.			changing := false]</body><body package="Lens-Dev">setClassName: aName	| oldSaved |	oldSaved := saved.	classFinder className value: aName.	saved := oldSaved.</body><body package="Lens-Dev">targetClassName	self targetClass isNil		ifTrue: [^'']		ifFalse: [^self targetClass fullName]</body><body package="Lens-Dev">updateButtons	| cv |	cv := current value.	cv == #from		ifTrue: [self enableOnly: #()]		ifFalse: [cv == #answer				ifTrue: [self enableOnly: #(#variable #functions #plus #minus #divided #multiplied #number #character #date #conversion #aggregate #other #comma )]				ifFalse: [cv == #where						ifTrue: [self enableOnly: #(#variable #functions #plus #minus #divided #multiplied #number #character #date #conversion #aggregate #other #and #or #parenthesis #equal #different #biggerThan #smallerThan #biggerOrEqual #smallerOrEqual #isNil #notNil #isLike #not #subQuery #defaultJoin )]						ifFalse: [cv == #orderBy								ifTrue: [self enableOnly: #(#variable #functions #plus #minus #divided #multiplied #number #character #date #conversion #aggregate #other #comma #ascending #descending )]								ifFalse: [cv == #groupBy ifTrue: [self enableOnly: #(#variable #functions #plus #minus #divided #multiplied #number #character #date #conversion #aggregate #other #comma #ascending #descending )]]]]]</body><body package="Lens-Dev">updateFromField	| names |	names := ''.	selectedTables do: [:t | names := names , ' ' , t name].	from value: names</body><body package="Lens-Dev">updateTables: anyway 	current value == #from		ifTrue: 			[tablesView perspective: #identity.			tablesView focus: tables asSet]		ifFalse: [(anyway or: [oldCurrent == #from or: [ownRow notNil]])				ifTrue: 					[| st |					tablesView perspective: #dbtable2.					st := selectedTables asSet.					st addAll: parameters.					(current value == #where and: [mode ~~ #own])						ifTrue: [ownRow notNil ifTrue: [st add: ownRow]].					tablesView focus: st]]</body><body package="Lens-Dev">validateDistinct	| win |	builder notNil ifTrue: [win := builder window].	self distinct value ifFalse: [self lock value			ifTrue: 				[Dialog warn: (#GenKeyNoSelectLockQuery &lt;&lt; #lensDev &gt;&gt; 'A query cannot select distinctobjects and lock the results.') for: win.				^false]].	^true</body><body package="Lens-Dev">validateLock	| win |	builder notNil ifTrue: [win := builder window].	self lock value ifFalse: [self distinct value			ifTrue: 				[Dialog warn: (#GenKeyNoSelectLockQuery &lt;&lt; #lensDev &gt;&gt; 'A query cannot select distinctobjects and lock the results.') for: win.				^false]].	^true</body><body package="Lens-Dev">warnInstall	"Confirm that the user wants to install the query in the class and selector 	given."	^Dialog		choose: ((#GenKeyInstallClass &lt;&lt; #lensDev &gt;&gt; 'INSTALL on Application Class&lt;nnt&gt;&lt;1s&gt;&lt;nn&gt;and Selector&lt;nnt&gt;&lt;2s&gt;&lt;n&gt;')			expandMacrosWith: self targetClassName			with: self pattern value)		labels: (Array with: (#OK &lt;&lt; #lensDev &gt;&gt; 'OK') with: (#Cancel &lt;&lt; #lensDev &gt;&gt; 'Cancel'))		values: #(true false)		default: true		for: builder window</body><body package="Lens-Dev">wrapSelectionWith: str1 and: str2 	| ctrlr fi selLength |	self markDirty.	fi := self editedField.	ctrlr := fi controller.	selLength := ctrlr selectionStopIndex - ctrlr selectionStartIndex.	ctrlr replaceSelectionWith: ((#x1s2s3s &lt;&lt; #lensDev &gt;&gt; '&lt;1s&gt;&lt;2s&gt;&lt;3s&gt; ')			expandMacrosWith: str1			with: ctrlr selection asString			with: str2).	ctrlr selectionStartIndex: ctrlr selectionStopIndex.	selLength == 0		ifTrue: [fi selectAt: ctrlr selectionStopIndex - 3]		ifFalse: [fi selectAt: ctrlr selectionStopIndex - 1]</body></methods><methods><class-id>Lens.QueryEditor</class-id> <category>accessing</category><body package="Lens-Dev">editorKind	^editorKind</body><body package="Lens-Dev">ldm: aLensDataModel 	"The LensDataModel provides information regarding the types for the classes 	mapped to the database"	| types |	ldm := aLensDataModel.	types := (ldm mappedTypes asSortedCollection: [:t1 :t2 | t1 name &lt; t2 name]) asOrderedCollection.	tables := types collect: [:t | LensContainerReference on: t named: t name].	self getOwnRow</body><body package="Lens-Dev">menuAccessorName: str	menuAccessorName := str</body><body package="Lens-Dev">mode: aNewMode 	"Whenever the mode is changed make sure everything is in order and get 	back to the default input field"	mode := aNewMode.	self disableFields</body><body package="Lens-Dev">pattern: str	pattern value: str</body><body package="Lens-Dev">targetClass	^targetClass</body><body package="Lens-Dev">targetClass: aClass 	"Set's the target class for the editor and displays it's name"	"If the class has changed, we update the instance variables menu. Note that 	the instance variables menu won't get updated if the class changes"	targetClass ~~ aClass		ifTrue: 			[targetClass := aClass.			self instanceVariablesMenuFor: aClass.			self getOwnRow.			self setClassName: self targetClassName]</body><body package="Lens-Dev">targetSelector	^targetSelector</body><body package="Lens-Dev">targetSelector: aSymbol	targetSelector := aSymbol</body><body package="Lens-Dev">transporterClass	"Returns the transporter class for the context found in the currently 	loaded LensDataModel"	(ldm notNil and: [ldm databaseContext notNil])		ifTrue: [^ldm databaseContext class transporterClass].	^nil</body><body package="Lens-Dev">useStreaming	useStreaming isNil ifTrue: [useStreaming := false asValue].	^useStreaming</body></methods><methods><class-id>Lens.QueryEditor</class-id> <category>private-changes</category><body package="Lens-Dev">changedCurrent	"Changed the current editing field, update the editing aids to reflect the change"		self updateTables: false.	self updateButtons.	oldCurrent := current value</body><body package="Lens-Dev">changedFullObjects	builder notNil		ifTrue: 			[| field |			field := builder componentAt: #answerField.			field notNil ifTrue: [fullObjects value					ifTrue: 						[field beInvisible.						answer value: ''.						self enable: false group: #(#answer )]					ifFalse: 						[field beVisible.						self enable: true group: #(#answer )]]]</body><body package="Lens-Dev">changedPattern	"The message pattern has changed, we parse it and extract from it the 	parameters that can be used in the blocks"	targetSelector := Parser new parseSelector: pattern value</body></methods><methods><class-id>Lens.QueryEditor</class-id> <category>initialize release</category><body package="Lens-Dev">beArbitrary	self mode: #arbitrary</body><body package="Lens-Dev">beMenu	self mode: #menu</body><body package="Lens-Dev">beMixIn	self mode: #mixin</body><body package="Lens-Dev">beOwn	self mode: #own</body><body package="Lens-Dev">beSubquery	self mode: #subquery</body><body package="Lens-Dev">initialize	current := #from asValue.	current onChangeSend: #changedCurrent to: self.	selectedTables := OrderedCollection new.	tables := Set new.	from := '' asValue.	where := '' asValue.	answer := '' asValue.	orderBy := '' asValue.	groupBy := '' asValue.	unique := false asValue.	distinct := false asValue.	lock := false asValue.	menusValue := nil asValue.	menusValue onChangeSend: #menuSelected to: self.	tablesView := LensGraphView onPerspective: #dbtable.	tablesView browserModel selectionService compute: [self selectedTable].	changing := false.	classFinder := ClassFinder new.	classFinder className onChangeSend: #acceptClassName to: self.	pattern := '' asValue.	pattern compute: [self changedPattern].	parameters := OrderedCollection new.	fullObjects := true asValue.	fullObjects		compute: 			[self changedFullObjects.			current value: #answer].	instanceVariablesMenu := Menu new asValue.	saved := true</body><body package="Lens-Dev">mixinKind	editorKind := #mixin</body></methods><methods><class-id>Lens.QueryEditor</class-id> <category>interface opening</category><body package="Lens-Dev">followCurrentFocus: ctrlr 	#(#whereField #answerField #groupByField #orderByField )		do: 			[:sy | 			| com |			com := self builder componentAt: sy.			com notNil ifTrue: [com widget controller == ctrlr					ifTrue: 						[| s |						s := sy readStream.						current value: (s upTo: $F) asSymbol]]]</body><body package="Lens-Dev">loadClass: aClass andSelector: aSelector	"Try loading the existing query. We need also to load the data model to be 	used, if the clas understands dataModel we use it, otherwise we will ask 	the user to select a data model. For the selection we use the 	LensDataModelGenerator"	self targetClass: aClass.	aSelector notNil ifTrue: [self targetSelector: aSelector].	aClass notNil		ifTrue: 			[classFinder className value: aClass fullName.			(aClass respondsTo: #dataModel)				ifTrue: [self ldm: aClass dataModel]				ifFalse: 					[| gen selLdm |					gen := LensDataModelGenerator new.					(selLdm := gen loadDataModel) isNil						ifTrue: [^nil]						ifFalse: [self ldm: selLdm]].			aSelector size &gt; 0 ifTrue: [self loadIt]]</body><body package="Lens-Dev">openMenuQueryEditor	| labels |	editorKind := #menu.	fullObjects value: false.	current value: #from.	labels := answer value readStream.	labels := labels upTo: $,.	answer value: labels.	self openInterface: #menuButtonSpec</body><body package="Lens-Dev">openOnClass: aClass andSelector: aSelector 	"Load the query's data. If it is a 'menu' query then open the special menu 	queries interface. Otherwise open the regular interface"	(self loadClass: aClass andSelector: aSelector) notNil ifTrue: [mode == #menu			ifTrue: [^self openMenuQueryEditor]			ifFalse: [^self open]]</body><body package="Lens-Dev">postBuildWith: aBuilder 	self changedCurrent.	self changedFullObjects.	tablesView builder component container scrollOffsetHolder grid: (10@10).</body><body package="Lens-Dev">postOpenWith: aBuilder 	| dispatcher |	dispatcher := UIDispatcher new.	dispatcher focusIn: [:ctrlr | self followCurrentFocus: ctrlr].	#(#whereField #answerField #groupByField #orderByField )		do: 			[:sy | 			| com |			com := self builder componentAt: sy.			com notNil ifTrue: [com widget controller setDispatcher: dispatcher]].	self disableFields.	editorKind == #mixin ifTrue: [current value: #where].	self updateTables: true</body></methods><methods><class-id>Lens.QueryEditor</class-id> <category>menu-actions</category><body package="Lens-Dev">addOwnRow	ownRow isNil ifTrue: [self getOwnRow].	ownRow notNil ifTrue: [self updateTables: true]</body><body package="Lens-Dev">generateMenuAccessor	"Generates a method in the class instance side that returns a menu created 	from the query"	| s acName win |	builder notNil ifTrue: [win := builder window].	acName := ''.	menuAccessorName isNil		ifTrue: [self checkPattern				ifTrue: 					[acName := pattern value copy asString.					acName at: 1 put: (acName at: 1) asUppercase.					acName := 'menuFor' , acName]]		ifFalse: [acName := menuAccessorName copy].	acName := Dialog request: (#GenKeyEnterMenuAccessorPattern &lt;&lt; #lensDev &gt;&gt; 'Enter the pattern of the menu accessor method:') initialAnswer: acName for: win.	acName size &gt; 0		ifTrue: 			[s := WriteStream on: (String new: 240).			self checkPattern				ifTrue: 					[s nextPutAll: acName; cr.					s tab; nextPutAll: (#GenKeyGeneratedMenu &lt;&lt; #lensDev &gt;&gt; '"This method returns a menu generated from a query"') asString; cr; cr.					s tab; nextPutAll: '^self menuFromQuery: (self '; nextPutAll: pattern value; nextPutAll: ').'.					self compileIt: s classifiedAs: #resources.					menuAccessorName := acName]]</body><body package="Lens-Dev">generateTestBlock: b 	| s |	s := WriteStream on: (String new: 100).	s nextPutAll: (#GenKeyDefineLocalVariables &lt;&lt; #lensDev &gt;&gt; '"The block is compiled using the Smalltalk compiler. Local variables are defined here instead of arguments to the message and instance variables of the class"') asString; cr; cr.	s nextPutAll: '| '.	parameters do: [:p | s nextPutAll: p; space].	self targetClass notNil		ifTrue: [self targetClass allInstVarNames				do: [:n | s nextPutAll: n; space]].	s nextPut: $|; cr; cr; nextPut: $^.	self putBlockPreambleInto: s.	s nextPutAll: b.	s nextPutAll: ' ]'.	^s contents</body><body package="Lens-Dev">insertAndSelect: str at: position 	| contents s pos str2 win |	builder notNil ifTrue: [win := builder window].	s := tmpCode readStream.	s upTo: $^.	pos := position - s position.	contents := s upToEnd.	str2 := str asText emphasizeAllWith: #(#bold #underline ).	Dialog warn: ((#SyntaxErrorn1s &lt;&lt; #lensDev &gt;&gt; 'Syntax Error:&lt;n&gt;&lt;1s&gt;')			expandMacrosWith: (contents asText					replaceFrom: pos					to: pos - 1					with: str2)) for: win</body></methods><methods><class-id>Lens.QueryEditor</class-id> <category>changes</category><body package="Lens-Dev">changeRequest	"Check if the query was saved and give the user the oportunity to 	abort the  changeRequest"	^saved or:		[Dialog			confirm: (#GenKeyChangedQuery &lt;&lt; #lensDev &gt;&gt; 'The query has been altered, but not installed.Do you wish to discard the changes?')			for: (builder notNil ifTrue: [builder window] ifFalse: [nil])]</body><body package="Lens-Dev">markDirty		saved := false.</body></methods><methods><class-id>Lens.QueryEditor</class-id> <category>copied</category><body package="Lens-Dev">openSourceDialogForClass: aClass andCategory: aCategory	"Open to collect an existing class and a new or existing selector as the 	destination of a UI specification."	| dialog selList newSel results bui finder listBlock selectBlock |	dialog := SimpleDialog new.	bui := dialog builder.	bui aspectAt: #clientClass put: (finder := ClassFinder new).	listBlock := [:cl| cl isNil					ifTrue: [List new]					ifFalse: [cl organization listAtCategoryNamed: aCategory]].	bui aspectAt: #existingSelectors put:		((selList := SelectionInList new)			list: (listBlock value: aClass);			selection: nil asValue; yourself).	finder className		compute: 			[:v | 			| cl |			cl := finder selectedClass.			cl isNil				ifTrue:					[selList list: Array new.					(dialog builder componentAt: #clientClass) flash]				ifFalse:					[selList list: (listBlock value: cl)]].	bui aspectAt: #newSelector put: (newSel := String new asValue).	bui aspectAt: #doAbort put: [dialog close].	selectBlock := [(results :=			UIFinderVW2				resultsForClassName: finder selectedClassID				andSelectorList: selList				orSelectorNamed: newSel value				resource: #query) notNil			ifTrue: [dialog close]			ifFalse:				[(dialog builder					componentAt:						(finder foundClass							ifTrue: [#SelectorSIL]							ifFalse:[#clientClass])) flash]].	bui aspectAt: #doOK put: selectBlock.	dialog		postBuildBlock: 			[:sd :bldr | | ctrl uid |			ctrl := (bldr componentAt: #SelectorSIL) widget controller.			uid := ctrl dispatcher copy.			uid doubleClick: selectBlock].	dialog openFrom: (UIFinderVW2 interfaceSpecFor: #sourceDialog).	^results</body></methods><methods><class-id>Lens.ClassCreateDialogReturn</class-id> <category>accessing</category><body package="Lens-Dev">className	^className</body><body package="Lens-Dev">className: aValue	className := aValue</body><body package="Lens-Dev">nameSpace	^nameSpace</body><body package="Lens-Dev">nameSpace: aValue	nameSpace := aValue</body><body package="Lens-Dev">results	^results</body><body package="Lens-Dev">results: aValue	results := aValue</body></methods><methods><class-id>Kernel.LiteralBindingReference</class-id> <category>accessing</category><body package="Lens-Dev">name	^self asSymbol</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>controller delegated</category><body package="Lens-Dev">defineMenuAsQuery	controller defineMenuAsQuery</body><body package="Lens-Dev">doBrowseChildDataForm	controller doBrowseChildDataForm</body><body package="Lens-Dev">doDefineChildDataForm	controller doDefineChildDataForm</body><body package="Lens-Dev">doPaintChildDataForm	controller doPaintChildDataForm</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private</category><body package="Lens-Dev">initStringForClientDetail: detailSlot on: aStream	| spec |	aStream		nextPutAll: (spec := detailSlot value) majorKeyFullName asString;		space;		nextPutAll: 'new'.	spec lockPolicy ~~ #current		ifTrue:			[aStream				cr; tab; tab; tab; tab;				nextPutAll: 'lockPolicy: ';				nextPutAll: spec lockPolicy printString; nextPut: $;;				cr; tab; tab; tab; tab;				nextPutAll: 'yourself']</body><body package="Lens-Dev">mixinQueryContentsForDetail: aClassName named: selector 	"Returns a string to be compiled into a method that returns a default 	mixin QueryOperation for the rowType of aClassName. Since that class 	may not yet be defined, we emit here code that will build the appropriate 	query operation taking the rowType from aClassName"	| codeStream theClassName |	"because aClassName is a BindingReference"	theClassName := aClassName simpleName.	codeStream := String new writeStream.	codeStream		nextPutAll: selector asString;		cr; tab;		nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined. Any edits should	be made only using the Query Editor, any other changes may be lost."';		cr; cr; tab;		nextPutAll: '"QueryEditor new openOnClass: self andSelector: '.	selector storeOn: codeStream.	codeStream		nextPutAll: '"';		cr; cr; tab;		nextPutAll: '&lt;resource: #query&gt;'; cr; tab;		nextPutAll: '| _qo |';		cr; tab;		nextPutAll: '_qo := LensQuery new.';		cr; tab;		nextPutAll: '_qo description: '.	selector storeOn: codeStream.	codeStream		nextPut: $.;		cr; tab;		nextPutAll: '_qo containerNames: ('; nextPutAll: theClassName asString; nextPutAll: ' rowType).';		cr; tab.	self whereClauseForDetail: aClassName into: codeStream.	codeStream		nextPutAll: '_qo mode: #mixin.';		cr; tab;		nextPutAll: '^_qo'.	^codeStream contents</body><body package="Lens-Dev">ownQueryContents: aLensApplicationSpec 	"Returns a string to be compiled into a method that returns a default 	QueryOperation for the rowType defined in the spec"	| s |	s := WriteStream on: (String new: 400).	s nextPutAll: 'ownQuery'; cr; tab.	s nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	will be lost if the class is regenerated anew. Any edits should be made	only using the Query Editor, any other changes may be lost."'; cr; cr.	s tab; nextPutAll: '"QueryEditor new openOnClass: self andSelector: #ownQuery"'; cr; cr.	s tab; nextPutAll: '&lt;resource: #query&gt;'; cr.	s tab; nextPutAll: '| _qo |'; cr.	s tab; nextPutAll: '_qo := LensQuery new.'; cr.	s tab; nextPutAll: '_qo description: ''ownQuery''.'; cr.	s tab; nextPutAll: '_qo arrayContainerNames: #('.	aLensApplicationSpec rowType		do: 			[:ref | 			s nextPut: $(.			ref name storeOn: s.			s space.			ref referredName storeOn: s.			s nextPut: $); space].	s nextPutAll: ').'; cr.	s tab; nextPutAll: '_qo mode: #own.'; cr.	s tab; nextPutAll: '^_qo'.	^s contents</body><body package="Lens-Dev">writeDataManagerClassSideAccessors: anApplicationSpec on: aStream	aStream		nextPut: $!;		nextPutAll: aClass fullName;		nextPutAll: ' class methodsFor: ''accessing''!';		cr; cr.	self writeRowTypeMethod: anApplicationSpec on: aStream.	self writeDataModelDesignatorMethod: anApplicationSpec on: aStream.	aStream nextPutAll: ' !'</body><body package="Lens-Dev">writeDataModelDesignatorMethod: anApplicationSpec on: aStream	aStream		nextPutAll: 'dataModelDesignator';		cr; cr; tab;		nextPut: $^;		nextPutAll: anApplicationSpec dataModel printString;		nextPut: $!</body><body package="Lens-Dev">writeDBApplicationClassSideAccessors: anApplicationSpec on: aStream	aStream		nextPut: $!;		nextPutAll: aClass fullName;		nextPutAll: ' class methodsFor: ''accessing''!';		cr; cr.	self writeLockPolicyMethod: anApplicationSpec on: aStream.	anApplicationSpec dataModel notNil		ifTrue: [self writeDataModelDesignatorMethod: anApplicationSpec on: aStream].	aStream nextPutAll: ' !'</body><body package="Lens-Dev">writeLockPolicyMethod: anApplicationSpec on: aStream	aStream 		nextPutAll: 'lockPolicy';		cr; cr; tab;		nextPut: $^;		nextPutAll: anApplicationSpec lockPolicy printString;		nextPut: $!; cr; cr</body><body package="Lens-Dev">writeMainApplicationWindowSpecMethod: anApplicationSpec on: aStream	"Write the default windowSpec for a main application.  Go to great	pains to get the window label to be the name of the class."	| fs |	(fs :=		Object messageNotUnderstoodSignal			handle:				[:ex |				ex parameter selector == #windowSpec					ifTrue: [ex return: nil]					ifFalse: [ex reject]]			do:				[(aClass perform: #windowSpec) decodeAsLiteralArray]) isNil		ifTrue:			[fs :=				FullSpec from:					#(#FullSpec 						#window: 						#(#WindowSpec 							#bounds: #(#Rectangle 230 304 467 417 ) 							#flags: 4 							#menu: #menuBar ) 						#component: 						#(#SpecCollection 							#collection: #() ) )].	fs window label: anApplicationSpec name asString.	aStream		cr; cr;		nextPut: $!;		nextPutAll: aClass fullName;		nextPutAll: ' class methodsFor: ''interface specs''!';		cr; cr.	aStream		nextPutAll: 'windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^'.	fs class prettyPrintSpecArray: fs literalArrayEncoding on: aStream tabLevel: 1.	aStream nextPutAll: '! !'</body><body package="Lens-Dev">writeOwnQueryMethod: anApplicationSpec on: aStream	aStream cr; cr;		nextPut: $!;		nextPutAll: aClass fullName;		nextPutAll: ' methodsFor: ''query''!';		cr; cr;		nextPutAll: (self ownQueryContents: anApplicationSpec);		nextPutAll: '! !'</body><body package="Lens-Dev">writeRowTypeMethod: anApplicationSpec on: aStream	aStream		nextPutAll: 'rowType';		cr; cr; tab;		nextPutAll: '^rowType isNil';		cr; tab; tab;		nextPutAll: 'ifTrue: ';		cr; tab; tab; tab;		nextPutAll: '[rowType := ';		nextPutAll: anApplicationSpec rowType literalArrayEncoding printString;		cr; tab; tab; tab; tab;		nextPutAll: 'collect: [:elt | UIDataReference decodeFromLiteralArray: elt]]';		cr; tab; tab;		nextPutAll: 'ifFalse:';		cr; tab; tab; tab;		nextPutAll: '[rowType]';		nextPut: $!;		cr;		cr</body></methods><methods><class-id>Lens.EmbeddedDetailSpec class</class-id> <category>private-interface building</category><body package="Lens-Dev">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel.	env at: #sourceType put: (self adapt: inst forAspect: #sourceType channel: aChannel).	env at: #contentKey put: (TypeConverter onSymbolValue: (self adapt: inst forAspect: #contentKey channel: aChannel)) aspectToText.	env at: #fetchAction put: (TypeConverter onSymbolValue: (self adapt: inst forAspect: #fetchAction channel: aChannel)).	env at: #synchronize put: (self adapt: inst forAspect: #synchronize channel: aChannel).	env at: #lockPolicy put: (self adapt: inst forAspect: #lockPolicy channel: aChannel).	env at: #autoFetch put: (self adapt: inst forAspect: #autoFetch channel: aChannel).</body></methods><methods><class-id>Lens.EmbeddedDetailSpec class</class-id> <category>property slices</category><body package="Lens-Dev">basicSlice	^#(10 #(#(#{Kernel.UserMessage} #key: #Basics #defaultString: 'Basics' #catalogID: #lensDev) #embeddedBasicsSpec #LensDFBasicsSliceModel))</body></methods><methods><class-id>Lens.EmbeddedDetailSpec class</class-id> <category>private-interface building</category><body package="Lens-Dev">componentName	"Identification of component"	^(#EmbededDataForm &lt;&lt; #lens &gt;&gt; 'Embedded Data Form')</body></methods><methods><class-id>Lens.EmbeddedDetailSpec class</class-id> <category>property slices</category><body package="Lens-Dev">connectionSlice	^#(30 #(#(#{Kernel.UserMessage} #key: #Connection #defaultString: 'Connection' #catalogID: #lensDev) #embeddedConnectionSpec #LensDFConnectionSliceModel))</body></methods><methods><class-id>Lens.LensDataModelGenerator class</class-id> <category>resources</category><body package="Lens-Dev">dialectsMenu	"Derive a dialects menu from the LensContexts in the image."	| menu |	menu := Menu new.	((LensDatabaseContext allSubclasses select: [ :c | c kind notNil ]) asSortedCollection: [ :c1 :c2 | c1 kind &lt;= c2 kind ]) do:		[ :aContext |		menu addItemLabel: aContext kind asString value: aContext name ].	^menu</body></methods><methods><class-id>Lens.LensDataModelGenerator class</class-id> <category>interface opening</category><body package="Lens-Dev">interfaceSpecFor: aSymbol	^UISpecification from: (self perform: aSymbol)</body></methods><methods><class-id>Lens.LensDataModelGenerator class</class-id> <category>resources</category><body package="Lens-Dev">lensPolicyMenu	| policyNames |	policyNames := (LensPolicy registry asArray collect: [ :p | p name ]) asSortedCollection.	^(MenuBuilder new addLabels: policyNames andValues: policyNames) menu.</body></methods><methods><class-id>Lens.LensDataModelGenerator class</class-id> <category>instance creation</category><body package="Lens-Dev">on: aLensDataModel	"Answer a builder to operate on aLensDataModel."	^self new lensDataModel: aLensDataModel</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>classes management</category><body package="Lens-Dev">annotationLiteralArrayEncodingOf: typ 	"Returns a literal array encoding fro the given type that doesn't include the 	table nor the columns the type is mapped to"	| nt |	nt := typ copy.	nt table: nil.	nt setVariables: (nt variables			collect: 				[:v | 				| u |				u := v copy.				u isMapped					ifTrue: 						[u column: nil.						u privateIsMapped: false].				u]).	^nt literalArrayEncoding</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>aspects-data model</category><body package="Lens-Dev">applicationNameAdaptor	^applicationNameAdaptor isNil		ifTrue:	[ applicationNameAdaptor :=					BufferedValueHolder						subject: ((AspectAdaptor forAspect: #applicationName)									subjectChannel: self lensDataModelHolder;									subjectSendsUpdates: false)						triggerChannel: self accept ]		ifFalse:	[ applicationNameAdaptor ]</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>private-dialogs</category><body package="Lens-Dev">authenticate	| first username pwd exc bldr dlog |	catalogLens isNil ifTrue: [^nil].	first := true.	username := catalogLens connection username asValue.	username value isNil		ifTrue: [username value: (UISettings preferenceFor: #dbDevUsername)].	username value isNil		ifTrue: [username value: String new].	pwd := catalogLens connection password asValue.	pwd value isNil		ifTrue: [pwd value: (UISettings preferenceFor: #dbDevPassword)].	pwd value isNil		ifTrue: [pwd value: String new].	[first		ifFalse:			[catalogLens connection class connectionExceptionSignal				handle:					[:ex |					exc := ex.					(ex signal inheritsFrom: ExternalDatabaseConnection externalDatabaseErrorSignal)						ifTrue: [ex return]						ifFalse: [ex reject]]				do:					["Connect to the dbms."					catalogLens connect: pwd value.					^self]].	first		ifTrue:			[first := false]		ifFalse:			[exc signal == catalogLens connection class authenticationFailureSignal				ifTrue:					[Dialog warn: (#GenKeyBadUserNameOrPassword &lt;&lt; #lensDev &gt;&gt; 'Unable to connect: bad user name or password')]				ifFalse:					[Dialog warn: (#GenKeyUnableToConnectDatabase &lt;&lt; #lensDev &gt;&gt; 'Unable to connect to database server')]].	bldr := (dlog := SimpleDialog new) builder.	bldr aspectAt: #usernameHolder put: username.	bldr aspectAt: #passwordHolder put: pwd.	(dlog openFrom: (UISpecification from: LensSession connectSpec))		ifFalse: [^nil].	catalogLens username: username value] repeat.</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>classes management</category><body package="Lens-Dev">automaticClassForTable: aLensTable 	"Answer a new type (to represent a fully mapped aLensTable) or nil. 	The automatic rules for creating the type are: 	1) Class name is the table name modified to be class-like, 	if it exists then ask the user for a new name or to reuse the old one 	2) The superclass is always Object. 	3) The category is derived from the Lens data model application's class 	category. 	4) All columns are mapped. 	5) There must be a primary key from which to infer the id.  If none	is found, the user is prompted for setting the key 	6) Foreign keys are not translated into references. 	7) Accessors and Mutators are generated.	8) There must be at least one column (if not a deadlock occurs because of the required		definition of a key)" 	| inName allColumns key varNames type ldm valueTypes baseIndex idVars cl confirmedName vs theClass copiedColumns myWindow superclass cat theNameSpace |	myWindow := builder notNil					ifTrue: [builder window]					ifFalse: [nil].	"First get the columns and check that there is at least one column"	allColumns := aLensTable columns.	allColumns size == 0 ifTrue: [^Dialog warn: (#GenKeyTableMustHaveOneColumn &lt;&lt; #lensDev &gt;&gt; 'A table must contain at least one columnto create an entity from it') for: myWindow].	"Make up an appropriate class name."	inName := aLensTable internalName.	inName at: 1 put: (inName at: 1) asUppercase.	"prompt user to select the nameSpace which is to contain the mapped class"	theNameSpace := self openTargetClassNameDialogFor: nil nameSpace: nil message: (#GenKey15 &lt;&lt; #lensDev &gt;&gt; 'Choose NameSpace to contain mapped Class for Table').	theNameSpace isNil ifTrue: [^nil].	confirmedName := self confirmedClassName: inName nameSpace: theNameSpace.	confirmedName size == 0 ifTrue: [^nil].	confirmedName at: 1 put: (confirmedName at: 1) asUppercase.	((ldm := self lensDataModel) typeNamed: confirmedName asSymbol) notNil		ifTrue: [^Dialog warn: ((#GenKeyAlreadyInUseInDataModel &lt;&lt; #lensDev &gt;&gt; '&lt;1s&gt; is already in use in the Data Model')			expandMacrosWith: confirmedName) for: myWindow].	cl := theNameSpace at: confirmedName asSymbol ifAbsent: [nil].	cl isNil		ifTrue: 			[superclass := Object.			cat := self defaultCategory.			cat isNil ifTrue: [^nil]]		ifFalse: 			[superclass := cl superclass.			cat := cl category].	key := aLensTable getPrimaryKeyIn: self catalogLens.	varNames := allColumns collect: [:col | col internalName].	vs := String new writeStream.	varNames do: [:vn | vs nextPutAll: vn; space].	vs := vs contents.	theClass := theNameSpace defineClass: confirmedName		superclass: superclass name asQualifiedReference		indexedType: #none		private: false		instanceVariableNames: vs		classInstanceVariableNames: String new		imports: String new		category: cat.	SourceFileManager default logChange: theClass definition.	type := theClass typeClass new.	type memberClass: theClass dataModel: ldm.	valueTypes := ldm valueTypes.	baseIndex := (type variables findFirst: [:v | v name = varNames first])				- 1.	copiedColumns := OrderedCollection new: allColumns size.	1 to: allColumns size		do: 			[:i | 			"Search for variable in case we're inheriting in the type and the 			offset may not start at 1."			| var col valType |			var := type variables at: i + baseIndex.			var column: (copiedColumns add: (col := (allColumns at: i) copy)).			var isMapped: true.			var valueType: (valType := ldm fieldTypeForColumn: col).			var resetFieldType.			var generateAccessMethods.			(valueTypes includes: valType)				ifFalse: 					[ldm valueTypes add: valType.					valueTypes add: valType]].	key == nil		ifTrue: 			[ self getKeyFor: type]		ifFalse: 			["Set the type's identity, based on the key."			idVars := OrderedCollection new.			key columns do: [:idCol | idVars add: (type variables at: (allColumns indexOf: idCol))].			self changeType: type toUserId: idVars].	type generateAccessMethods.	type table: (aLensTable copy columns: copiedColumns).	^type</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>data model management</category><body package="Lens-Dev">canChangeDialect	"Changes of dialect are not allowed for data models that are not empty"	(oldDataModel notNil and: [ oldDataModel structureTypes size &gt; 0 ])		ifTrue: 			[Dialog warn: (#GenKeyDialectChanged &lt;&lt; #lensDev &gt;&gt; 'The dialect may be changed only for empty Data Models').			^false]		ifFalse: [^true]</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>accessing</category><body package="Lens-Dev">catalogLens	catalogLens isNil		ifTrue: 			[ self lensDataModel notNil ifTrue: 				[ LensSession doNotProceedSignal 					handle: [ :ex | ex return ]					do:						[catalogLens := (self lensDataModel getCatalogSession).						(self connectOrResume: #connect:) isNil							ifTrue: [catalogLens := nil]]]]		ifFalse:			[catalogLens isPaused ifTrue:				[(self connectOrResume: #resume:) isNil						ifTrue: [catalogLens := nil]]].	^catalogLens</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>data model management</category><body package="Lens-Dev">changePropertiesOfDataModel	"Edits the properties of the dataModel. Assumes the dataModel is already 	set in lensDataModel"	| dm databaseContext  |	super initialize.	dm := self lensDataModel.	(databaseContext := dm databaseContext copy) isNil		ifTrue: 			[(databaseContext := self someDatabaseContext) isNil 				ifTrue: [					^Dialog warn: (#GenKeyDatabaseConnectKitNotLoaded &lt;&lt; #lensDev &gt;&gt; 'No Database Connectivity kit loaded.Can not create a new Data Model')].			self initializeDatabaseContext: databaseContext].	dialect := nil.	self dialect value: databaseContext class name.	self dialect		compute: 			["Setup for taking the subCanvas from the context"			databaseContext := (self class environment at: self dialect value) new.			self initializeDatabaseContext: databaseContext.			self setUpContextPropertiesFor: databaseContext].	self		postBuildBlock: 			[:app :aBuilder | 			self setUpContextPropertiesFor: databaseContext].	cancel value: false.	accept value: false.	close value: false.	"open the dialog"	(self openFor: self interface: #editLensDataModelSpec)		ifFalse: [^nil].	"We got a green light."	dm databaseContext: databaseContext.	self flushCaches.	^dm</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>classes management</category><body package="Lens-Dev">changeType: type toUserId: newIdVars	| idVar |	idVar := type idVariable.	idVar notNil ifTrue:		[ (idVar valueType isLensDataType			ifTrue:				[ idVar == newIdVars first and: [newIdVars size == 1] ]			ifFalse:				[ ((idVar valueType variables detect: [:v | (newIdVars includes: v) not] ifNone: []) isNil) and:							[ idVar valueType variables size == newIdVars size ]])					ifTrue: [^self ] ].	"create new user id"	newIdVars size == 1		ifTrue:			[ idVar := newIdVars first ]		ifFalse:			[ | fieldType | 			fieldType := (LensStructureType memberClass: Array variables: newIdVars asArray)							dataModel: type dataModel.			idVar := LensStructureVariable new 				objectType: type; 				isId: true; 				isMapped: true; 				fieldAndValueType: fieldType ].	"Unset the id flag for old idVariables."	type idVariables do:		[ :var |		var isCompound			ifFalse:				[ self postChangeToObject: var selector: #isId value: false]			ifTrue:				[ (self pathsFromVariable: var isMapped: true) do:					[:path |					path do: [:a | self postChangeToObject: a selector: #isId value: false]]]].	"Set the id flag for new idVariables, and mark associated columns isNotNil."	newIdVars do:		[ :var |		var isCompound			ifFalse: [				self postChangeToObject: var selector: #isId value: true.				var column notNil ifTrue: [					self postChangeToObject: var column selector: #isNotNil value: true]]			ifTrue: [				(self pathsFromVariable: var isMapped: true) do:					[:path |					path do:						[:a |						a isDeclared ifTrue:							[ self postChangeToObject: a selector: #isId value: true ].						a column notNil ifTrue:							[ self postChangeToObject: a column selector: #isNotNil value: true ]]]]].	self postChangeToObject: type selector: #idVariable value: idVar.</body><body package="Lens-Dev">confirmedClassName: initial 	| nm cl |	cl := self class environment at: initial asSymbol ifAbsent: [nil].	cl isNil		ifTrue: [^initial]		ifFalse: 			[nm := Dialog request: (#GenKeyTableClassNameExist &lt;&lt; #lensDev &gt;&gt; 'A class named after this table already exists.Press OK to redefine it, or enter a new name.') initialAnswer: initial for: (builder notNil ifTrue: [builder window] ifFalse: [nil]).			^nm]</body><body package="Lens-Dev">confirmedClassName: initial nameSpace: aNameSpace	| nm cl |	cl := aNameSpace at: initial asSymbol ifAbsent: [nil].	cl isNil		ifTrue: [^initial]		ifFalse: 			[nm := Dialog request: (#GenKeyTableClassNameExist &lt;&lt; #lensDev &gt;&gt; 'A class named after this table already exists.Press OK to redefine it, or enter a new name.') initialAnswer: initial for: (builder notNil ifTrue: [builder window] ifFalse: [nil]).			^nm]</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>private-dialogs</category><body package="Lens-Dev">connectOrResume: connectSelector	"Log the user/operation onto the database for the current catalog data model.  connectSelector indicates whether this is the initial connection (#connect:) or a resume after pause/snapshot (#resume:)."	| first username pwd exc bldr dlog |	catalogLens isNil ifTrue: [^nil].	first := true.	username := catalogLens connection username asValue.	username value isNil		ifTrue: [username value: (UISettings preferenceFor: #dbDevUsername)].	username value isNil		ifTrue: [username value: String new].	pwd := catalogLens connection password asValue.	pwd value isNil		ifTrue: [pwd value: (UISettings preferenceFor: #dbDevPassword)].	pwd value isNil		ifTrue: [pwd value: String new].	[first		ifFalse:			[catalogLens connection class connectionExceptionSignal				handle:					[:ex |					exc := ex.					(ex signal inheritsFrom: ExternalDatabaseConnection externalDatabaseErrorSignal)						ifTrue: [ex return]						ifFalse: [ex reject]]				do:					["Connect to the dbms."					^catalogLens perform: connectSelector with: pwd value ]].	first		ifTrue:			[first := false]		ifFalse:			[exc signal == catalogLens connection class authenticationFailureSignal				ifTrue:					[Dialog warn: (#GenKeyBadUserNameOrPassword &lt;&lt; #lensDev &gt;&gt; 'Unable to connect: bad user name or password')]				ifFalse:					[Dialog warn: (#GenKeyUnableToConnectDatabase &lt;&lt; #lensDev &gt;&gt; 'Unable to connect to database server')]].	bldr := (dlog := SimpleDialog new) builder.	bldr aspectAt: #usernameHolder put: username.	bldr aspectAt: #passwordHolder put: pwd.	(dlog openFrom: (UISpecification from: LensSession connectSpec))		ifFalse: [^nil].	catalogLens username: username value] repeat.</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>accessing</category><body package="Lens-Dev">defaultCategory	^self defaultCategory: true</body><body package="Lens-Dev">defaultCategory: shouldPrompt	"Returns the category of the class of the ldm, if none then 	try using the default category, if not set yet then ask the user for it" 	self lensDataModel notNil ifTrue: 		[| app |		((app := self lensDataModel application) notNil and: [app category notNil]) ifTrue: [^app category]].	shouldPrompt &amp; defaultCategory isNil		ifTrue: 			[| cat |			cat := Dialog request: (#GenKeyNameCategory &lt;&lt; #lensDev &gt;&gt; 'While editing the Data Model some classes may be created.What category would you like them placed in?') initialAnswer: (#LensApplicationsNew &lt;&lt; #lensDev &gt;&gt; 'Lens-Applications-New')						for: (builder notNil								ifTrue: [builder window]								ifFalse: [nil]).			cat size &gt; 0				ifTrue: [defaultCategory := cat asSymbol]].	^defaultCategory</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>aspects-data model</category><body package="Lens-Dev">dialect	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^dialect isNil ifTrue: [dialect := nil asValue] ifFalse: [dialect]</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>data model management</category><body package="Lens-Dev">editDataModelProperties	"To edit the properties of the dataModel we copy it's editable properties into a new DataModel. After 	editing we check what were the changes and update accordingly"	| newDM |	oldDataModel := self lensDataModel.	newDM := LensDataModel new.	newDM application: oldDataModel application.	newDM databaseContext: oldDataModel databaseContext copy.	newDM selector: oldDataModel selector.	self lensDataModel: newDM.	self changePropertiesOfDataModel notNil		ifTrue: 			["check the new against the old and update it"			self updateDataModel: oldDataModel with: newDM.			self lensDataModel: oldDataModel.			oldDataModel := nil.			^self lensDataModel]		ifFalse: [^oldDataModel := nil]</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>aspects-classes</category><body package="Lens-Dev">extractedColumnList	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^extractedColumnList isNil ifTrue: [extractedColumnList := MultiSelectionInList new] ifFalse: [extractedColumnList]</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>initialize-release</category><body package="Lens-Dev">flushCaches	catalogLens notNil		ifTrue: 			[catalogLens disconnect.			catalogLens := nil]</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>private-dialogs</category><body package="Lens-Dev">getKeyFor: type 	"Open the key editor for the given type. Do not accept a result that does not 	lead to a key being defined. In case the key editor dialog is cancelled, explain	what can be done to get rid of the entity at this stage"	| ked |		[ked := LensKeyEditor new.	ked message1: (#NoKeyDefined &lt;&lt; #lensDev &gt;&gt; 'No key was identified in the database. One or more keys are required') asString.	ked message2: (#GenKeySelectVariable &lt;&lt; #lensDev &gt;&gt; 'to create the entity. Select the variable(s) to be used as key(s)') asString.	ked type: type.	ked open.	type idVariable isNil]		whileTrue: [Dialog warn: (#GenKeyEntityExists &lt;&lt; #lensDev &gt;&gt; 'The Entity already exists; a key is required to complete its definition.If you do not want the new Enity, define any key here and thenremove the entity by using the ''Entity-&gt;Remove...'' option fromthe Data Modeler''s menu.')]</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>reference</category><body package="Lens-Dev">inferReferences	"Infer from the database information which variables reference which tables 	and update the data model accordingly"	^self inferReferencesFrom: nil</body><body package="Lens-Dev">inferReferencesFrom: aType 	"Infer the references going out from the given aType. if aType is nil then infer all the references. 	Returns true if there was some change done. Either way all possible references are computed by 	asking the tables to return them. Then they are checked to see whether they apply to the case, either 	by matching aType or by matching some other type in the data model"	| didSomething ldm lens |	didSomething := false.	"Enforce-quietly: we have a data model and can get a connected LensSession."	((ldm := self lensDataModel) isNil or: [(lens := self catalogLens) isNil]) ifTrue:		[ ^false ].	"This may take a while, so put up the busy cursor."	Cursor database showWhile:		[ | refs |		"Ensure the data model's table information is current."		ldm setTables.		refs := OrderedCollection new.		"Get the foreign keys into refs."		ldm tables do: [:tab | refs addAll: (tab inferReferencesIn: lens)].		"For each foreign key."		1 to: refs size do:			[:index | | ref st1 st2 |			ref := refs at: index.			"Find the structure types which correspond to the tables on either side of the foreign key."			ldm structureTypes do:				[:st | 				st table = (ref at: 1) ifTrue: [st1 := st].				(st table isReferredToBy: (ref at: 3)) ifTrue: [st2 := st]].			"if both tables are mapped in this model and we're interested in the referencing side."			((st1 notNil and: [st2 notNil]) and: [aType isNil or: [st1 = aType]]) ifTrue:				[| vars cols |				vars := OrderedCollection new.				"Map the foreign key columns to variables."				1 to: (cols := ref at: 2) size do: 					[:colIndex | | refCol var |					refCol := cols at: colIndex.					"Find the variable that references this column."					st1 variablesDo:						[:v | v column notNil ifTrue:							[v column name = refCol ifTrue:								[var := v]]].					"If there was one."					var notNil ifTrue:						[vars addLast: var]].				"If we found all of the columns as mapped variables; and this reference does not already exist then make the reference."				(vars size == cols size and:					[(st1 variables detect: 						[:v | v isMapped and: [v isReferenceTo: st2 withVariables: vars]] ifNone: [nil]) isNil]) ifTrue:							[(self reference: vars in: st1 to: st2) notNil ifTrue:								[didSomething := true]]]]].	^didSomething</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>initialize-release</category><body package="Lens-Dev">initialize	super initialize.	lensDataModelHolder := nil asValue</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>private-dialogs</category><body package="Lens-Dev">initializeDatabaseContext: dbc 	dbc username size == 0 ifTrue: [dbc username: (UISettings preferenceFor: #dbDevUsername)].	((dbc respondsTo: #environment:)		and: [dbc environment size == 0])		ifTrue: [dbc environment: (UISettings preferenceFor: #dbDevEnvironment)]</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>accessing</category><body package="Lens-Dev">lensDataModel	"Answer the data model this builder is operating on."	^self lensDataModelHolder value</body><body package="Lens-Dev">lensDataModel: aLensDataModel	"Initialize the data model this builder is to operate on."	self lensDataModelHolder value == aLensDataModel		ifFalse:			[self lensDataModelHolder value: aLensDataModel.			self flushCaches]</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>aspects</category><body package="Lens-Dev">lensDataModelHolder	^lensDataModelHolder</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>aspects-data model</category><body package="Lens-Dev">lensPolicy	^lensPolicy isNil		ifTrue:	[ lensPolicy :=					BufferedValueHolder						subject: ((AspectAdaptor forAspect: #lensPolicyName)									subjectChannel: self lensDataModelHolder;									subjectSendsUpdates: false)						triggerChannel: self accept ]		ifFalse:	[ lensPolicy ]</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>data model management</category><body package="Lens-Dev">loadDataModel	"By default continue the loading if there was a warning"	^self loadDataModel: true</body><body package="Lens-Dev">loadDataModel: continueOnWarning 	"Display a dialog showing all classes which have at least one method in the class protocol used to hold 	data model specs. The current data model for the receiver is loaded from the selected method when 	the Load button is pressed."	| sd cbdm dmosc theClass ldm res win |	builder notNil ifTrue: [win := builder window].	sd := SimpleDialog new.	cbdm := SelectionInList new.	dmosc := SelectionInList new.	"Compute the list of class names which have data model specs"	cbdm list: (LensNamespaceControl allClassNames			select: 				[:aClassName | 				| aClass hit |				aClass := aClassName asQualifiedReference valueOrDo: [nil].				aClass notNil 					ifTrue: [						aClass class selectorsAndMethodsDo:							[:sel :meth |							meth resourceType == #dataModel ifTrue: [hit := sel]]].				hit notNil]).	cbdm list size == 0 ifTrue: [Dialog warn: (#GenKeyNoDataModel &lt;&lt; #lensDev &gt;&gt; 'There are no data models in the image.') for: win. ^nil].	"Arrange for auto select of first data model name when the class selection changes."	cbdm selectionIndexHolder compute: [:selIndex | 		cbdm selection notNil			ifTrue: 				["Set the list of data model names for the currently selected class"				| selectedClass dms |				selectedClass := cbdm selection asSymbol asQualifiedReference value class.				dms := OrderedCollection new.				selectedClass selectorsAndMethodsDo:					[:sel :meth |					meth resourceType == #dataModel ifTrue: [dms add: sel]].				dmosc list: dms.				dmosc list size &gt; 0 ifTrue: [dmosc selectionIndex: 1]]			ifFalse: [dmosc list: #()]].	"The Load button is enabled only if there is a selected data model name."	dmosc selectionIndexHolder compute: [:selIndex | 		selIndex &gt; 0			ifTrue: [(sd builder componentAt: #loadButton) enable]			ifFalse: [(sd builder componentAt: #loadButton) disable]].	"Finish priming the builder."	sd builder aspectAt: #classesBearingDataModels put: cbdm.	sd builder aspectAt: #dataModelsOnSelectedClass put: dmosc.	sd builder actionAt: #doubleClickAction put: [sd accept value: true].	sd postOpenBlock: [:dialog :itsBuilder | cbdm selectionIndex: 1.						(itsBuilder componentAt: #dataModelsOnSelectedClass) widget controller setDispatcher: (UIDispatcher new doubleClick: [sd accept value: true])].	"Open the interface, return immediately if cancel is pressed."	(sd openFor: self interface: #selectDataModelSpec)		ifFalse: [			^nil].	"The Load button was pressed so we must have a selection."	Cursor execute		showWhile: 			[			theClass := cbdm selection asSymbol asQualifiedReference value.			res := Object errorSignal						handle: 							[:ex | 							(continueOnWarning and: [ex signal == LensDataModel dataDefinitionWarningSignal])								ifTrue: [ ex reject ] 								ifFalse: [									Dialog										warn: ((#x1snLoadingTerminated &lt;&lt; #lensDev &gt;&gt; '&lt;1s&gt;&lt;n&gt;Loading terminated')			expandMacrosWith: ex errorString) for: win.									ex returnWith: nil]]						do: 							[ldm := LensDataModel									readFromClass: theClass									methodName: dmosc selection.							ldm compile.							true]].	res notNil		ifTrue: [^ldm]		ifFalse: [^nil]</body><body package="Lens-Dev">makeNewApplicationClassUsing: classInfo	|  newClass |	newClass := (classInfo at: 2)		subclass: (classInfo at: 1)		instanceVariableNames: String new		classVariableNames: String new		poolDictionaries: String new		category: (classInfo at: 3).	SourceFileManager default logChange: newClass definition.	^newClass</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>resources</category><body package="Lens-Dev">nameSpaceMenu	"menu of name spaces"	| nameSpaces names |	nameSpaces := LensNamespaceControl permissableNameSpaces.	names := (Array with: (nameSpaces collect: [:d | d name asText allBold])).	^Menu		labelList: names		values: nameSpaces</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>data model management</category><body package="Lens-Dev">newDataModel	"Create a new dataModel. It's like changing the properties of an empty one"	oldDataModel := nil.	self lensDataModel: LensDataModel new.	^self changePropertiesOfDataModel</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>reference</category><body package="Lens-Dev">newNameReference: els in: aReferencingLST to: aReferencedLST 	"Ask the user to provide a new name for the variable referencing aReferencedLST. By 	default the name is constructed from aReferencedLST's name by lowercasing the first 	letter. Returns nil on cancel"	"SInce it may be important for the user to know that a reference that is a part 	of another reference is lost if the later is defined, we check that and notify 	the user of the danger. The variable alreadyReference will collect elements 	from 'els' that are already references. If its size is greater than 0 then we 	print the adequate warning message"	| s nm alreadyReference dialog |	dialog := LensReferenceNameDialog new.	dialog fromEntity value: aReferencingLST name.	dialog toEntity value: aReferencedLST name.	s := WriteStream on: (String new: 200).	alreadyReference := OrderedCollection new.	els		do: 			[:e | 			s nextPutAll: e name; nextPut: $,; space.			e valueType isLensStructureType ifTrue: [alreadyReference add: e]].	s skip: -2.	dialog replaced value: s contents.	alreadyReference size &gt; 0		ifTrue: 			[s := WriteStream on: (String new: 200).			alreadyReference do: [:v | s nextPutAll: v name; nextPut: $,; space].			s skip: -2.			dialog referenceEntities value: s contents].	dialog name1 value: els first name copy asString.	nm := aReferencedLST name copy asString.	nm at: 1 put: (nm at: 1) asLowercase.	nm = aReferencedLST name asString		ifTrue: [nm := nm, '_'].	dialog name2 value: nm copy.	[dialog open]		whileTrue: 			[| newNm |			"Make sure that name has been entered, does not include a space or a tab - and if it already is the name of an existing variable that that variable is a non-id variable being converted to a reference. (Non id variables will be subsumed under the new reference and thus will not cause conflicts."			((newNm := dialog selectedName) size == 0 or:				[(newNm includes: Character space) or: [(newNm includes: Character tab) or:						[(aReferencingLST variables detect:							[ :var | var name = newNm and: [var isId  or: [(els includes:  var) not]]] ifNone: [nil]) notNil]]])				ifTrue: 					[Dialog warn: 'To generate the reference a name must be given.This name should not contain spaces or tabs andshould not be the name of any existing variable.' for: builder window.					dialog initialize]				ifFalse: [^newNm]].	^nil</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>interface-opening</category><body package="Lens-Dev">openTargetClassNameDialogFor: className nameSpace: nameSpaceName message: message 	"Open to collect the name of a namespace. Use message to prompt 	the user"	| dialog results bldr |	results := ClassCreateDialogReturn new.	dialog := SimpleDialog new.	bldr := dialog builder.	bldr aspectAt: #message put: message asText allBold asValue.	bldr aspectAt: #nameSpace put: ((nameSpaceName isNil					ifTrue: [LensNamespaceControl lastDataModelerNameSpace]					ifFalse: [nameSpaceName asSymbol]) asValue).	bldr aspectAt: #nameSpaceMenu put: self nameSpaceMenu asValue.	bldr aspectAt: #doAbort		put: 			[results := nil.			dialog close].	bldr aspectAt: #doOK put: [		self postClassCreateDialogResultsTo: results from: bldr.		results results: results nameSpace.		results := results nameSpace.		dialog close].	dialog openFrom: (self class interfaceSpecFor: #nameSpaceDialog).	^results</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>classes management</category><body package="Lens-Dev">pathsFromVariable: var isMapped: isMapped	"Answer all paths emanating from att, where attributes are expected to be mapped	if isMapped is true, otherwise just mappable."	| paths subvars valType fieldType |	paths := OrderedCollection new.	subvars := #().	isMapped 		ifTrue: [			var isMapped ifTrue: [				var fieldType isLensStructureType 					ifFalse: [						var isDeclared ifTrue: [							paths add: (OrderedCollection with: var)]]					ifTrue: [subvars := var fieldType variables]]]		ifFalse: [			valType := var valueType.			valType isMapped				ifTrue: [					fieldType := var isMapped 						ifTrue: [var fieldType]						ifFalse: [valType computeFieldType].					fieldType isLensStructureType						ifTrue: [subvars := fieldType variables]						ifFalse: [paths add: (OrderedCollection with: var)]]				ifFalse: [valType isLensStructureType					ifTrue: [subvars := valType variables]					ifFalse: [var isDeclared 						ifTrue: [							paths add: (OrderedCollection with: var)]]]].	subvars do: [ :var2 |		(self pathsFromVariable: var2  isMapped: isMapped) do: [:p |			p addFirst: var.			paths add: p]].	^paths</body><body package="Lens-Dev">postChangeToObject: object selector: s value: v	(object perform: s) == v ifTrue: [^self].	object perform: (s , ':') asSymbol with: v.</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>private-interfaces</category><body package="Lens-Dev">postClassCreateDialogResultsTo: results from: dBuilder	| ns |	results nameSpace: (ns := (dBuilder aspectAt: #nameSpace) value).	LensNamespaceControl lastDataModelerNameSpace: ns.</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>reference</category><body package="Lens-Dev">reference: els in: aReferencingLST to: aReferencedLST	"Make the elements in the list els reference the type given by aLST. 	Remember to remove the old variables and flush their accessor methods. 	Then create the new variable and put it into the class"	"The real number of columns represented by 'els' may 	be greater than 'els size'. In elsRealSize we compute the real number fo 	columns and only then check that the numbers match"	aReferencedLST class == LensStructureType ifTrue: [Cursor execute			showWhile: 				[| newVar nm mVars fieldT ftNum elsRealSize |				fieldT := aReferencedLST computeFieldType.				fieldT memberClass == Array					ifTrue: 						[ftNum := 0.						fieldT variables do: [:v | v forLeavesDo: [:ignore | ftNum := ftNum + 1]]]					ifFalse: [ftNum := 1].				elsRealSize := 0.				els do: [:e | e forLeavesDo: [:ignore | elsRealSize := elsRealSize + 1]].				ftNum ~~ elsRealSize					ifTrue: 						[Dialog warn: ((#GenKeySelectReferenceVariable &lt;&lt; #lensDev &gt;&gt; 'To reference a ''&lt;1s&gt;''&lt;n&gt;you need to select &lt;2s&gt; variables')			expandMacrosWith: aReferencedLST name			with: ftNum printString) for: builder window.						^nil].				newVar := LensStructureVariable new.				nm := self newNameReference: els in: aReferencingLST to: aReferencedLST.				nm size = 0 ifTrue: [^nil].				newVar name: nm.				mVars := aReferencingLST variables asOrderedCollection.				"Consider a variable as subsumed in the newly created reference if that variable is part				of the new reference, and is not an id variable or part of any other reference."				els					do: 						[:e |						(e isId and: [e isReference not]) ifFalse:							["If e is not in mVars then e must be part of some other multi-key reference -							so it's ok if we can't remove it."							(mVars remove: e ifAbsent: [nil]) notNil ifTrue:								[e flushAccessMethods]]].				aReferencingLST variables: mVars asArray.				aReferencingLST variables: ((aReferencingLST variables asOrderedCollection) add: newVar; asArray).				newVar setValueType: aReferencedLST.				newVar isMapped: true.				newVar resetFieldType.				ftNum == 1					ifTrue: [newVar column: els first column]					ifFalse: 						[| i |						i := 1.						newVar							forLeavesDo: 								[:var | 								var column: (els at: i) column.								i := i + 1]].				self updateClassFromAnnotation: aReferencingLST.				newVar generateAccessMethods.				^Array with: els with: (Array with: newVar with: aReferencingLST)]].	^nil</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>initialize-release</category><body package="Lens-Dev">release	self flushCaches</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>classes management</category><body package="Lens-Dev">reviseClasses	self lensDataModel notNil ifTrue: [self lensDataModel structureTypes do: [:st | self reviseClassOfType: st]]</body><body package="Lens-Dev">reviseClassOfType: typ 	self reviseClassOfType: typ removed: nil</body><body package="Lens-Dev">reviseClassOfType: typ removed: aVariableName 	"Make sure that the instance variables of the class and the access 	methods match the current LensObjectVariables." 	| cl oldNames newVariables adds  newLocalNames inames vs theClass ns |	cl := typ memberClass.	newVariables := typ variables collect: [:v | v name].	oldNames := cl allInstVarNames.	adds := newVariables reject: [:vn | oldNames includes: vn].	(adds size &gt; 0 or: [aVariableName notNil])		ifTrue: 			[inames := cl superclass allInstVarNames.			newLocalNames := newVariables  reject: [:vn | inames includes: vn].			vs := String new writeStream.			newLocalNames do: [:vn | vs nextPutAll: vn; space].			vs := vs contents.			ns := cl environment.			theClass := ns defineClass: cl name asSymbol				superclass: cl superclass name asQualifiedReference				indexedType: cl behaviorType				private: ((ns bindingFor: cl name asSymbol) isPrivate)				instanceVariableNames: vs				classInstanceVariableNames: cl class instanceVariablesString				imports: cl asNameSpace importString				category: cl category.			SourceFileManager default logChange: theClass definition].</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>aspects-data model</category><body package="Lens-Dev">selectorNameAdaptor	^selectorNameAdaptor isNil		ifTrue:	[ selectorNameAdaptor := 					BufferedValueHolder						subject: ((AspectAdaptor forAspect: #selector)									subjectChannel: self lensDataModelHolder;									subjectSendsUpdates: false)						triggerChannel: self accept ]		ifFalse:	[ selectorNameAdaptor ]</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>data model management</category><body package="Lens-Dev">setUpContextPropertiesFor: databaseContext 	"Set up the context properties subCanvas with the appropriate spec and 	binding dictionary"	| sub bld |	(sub := builder componentAt: #contextProperties) isNil ifTrue: [^nil].	sub := sub widget.	bld := builder newSubBuilder.	bld bindings: (databaseContext class bindingsForInstance: databaseContext).	sub		client: self		spec: databaseContext class propertiesSpec decodeAsLiteralArray		builder: bld</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>private-dialogs</category><body package="Lens-Dev">someDatabaseContext	"Returns an instance of some subclass LensDatabaseContext or nil if none"	LensDatabaseContext allSubclasses do: [:sc | ^sc new].	^nil</body></methods><methods><class-id>Lens.LensDataModelGenerator</class-id> <category>data model management</category><body package="Lens-Dev">updateDataModel: dm1 with: dm2 	"dm1 is an existing dataModel, dm2 may have changed the database context and/or the policy. 	Update dm1 accordingly"	| dbc1 dbc2 |	(dbc1 := dm1 databaseContext) class ~~ (dbc2 := dm2 databaseContext) class		ifTrue: [dm1 databaseContext: dbc2]		ifFalse: [dbc1 copyParametersFrom: dbc2].	dm1 application: dm2 application.	dm1 selector: dm2 selector</body><body package="Lens-Dev">validateApplicationName	| comp ev classInfo cat |	comp := (self builder componentAt: #applicationName) widget.	ev := comp editValue copy.	ev size == 0 ifTrue: [^false].	ev at: 1 put: (ev at: 1) asUppercase.	(self class environment includesKey: ev asSymbol)		ifTrue: [^true].	"Failed validation, ask the user about creating a new class."	cat := Dialog				request: ((#GenKeyCreateNewClass &lt;&lt; #lensDev &gt;&gt; 'The class &lt;1s&gt; does not exist.&lt;n&gt;Creating a new class in category:')			expandMacrosWith: ev)				initialAnswer: (#LensApplicationsNew &lt;&lt; #lensDev &gt;&gt; 'Lens-Applications-New')				for: (builder notNil						ifTrue: [builder window]						ifFalse: [nil]).	cat size == 0 ifTrue: [^false].	classInfo := Array				with: ev asSymbol				with: LensMainApplication				with: cat asSymbol.	self makeNewApplicationClassUsing: classInfo.	^true</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>commands</category><body package="Lens-Dev">defineMenuAsQuery	"Open a query editor for editing a query that can be used to generate a 	menu"	| cl qe spec |	(cl := self model targetClass) isNil		ifTrue: 			[Dialog warn: (#GenKeyUnInstalledCanvas &lt;&lt; #lensDev &gt;&gt; 'The canvas isn''t installed on any class') for: view.			^self].	qe := QueryEditor new.	qe beMenu.	spec := self selectionList first spec.	spec notNil ifTrue: [spec menu notNil ifTrue: [qe menuAccessorName: spec menu asString]].	qe openOnClass: cl andSelector: nil</body><body package="Lens-Dev">doBrowseChildDataForm	| spec clName cl |	spec := self selectionList first spec.	(clName := spec majorKey) isNil		ifTrue:			[^Dialog warn: (#GenKeyNoClassForProperty &lt;&lt; #lensDev &gt;&gt; 'The selected data form''s properties don''t specify a class') for: view].	cl := self class environment at: clName ifAbsent: [^Dialog warn: (#GenKeyUndefinedClassForProperty &lt;&lt; #lensDev &gt;&gt; 'The selected data form''s properties specify an undefined class') for: view].	SmalltalkWorkbench browseClass: cl</body><body package="Lens-Dev">doDefineChildDataForm	"After defining the class bring a dialog canvas composer to give the utility of defining the interface just there"	| spec className  org newClass ed |	spec := self selectionList first spec.	(className := spec majorKey) isNil		ifTrue: 			[Dialog warn: (#GenKeyNoClassForProperty &lt;&lt; #lensDev &gt;&gt; 'The selected data form''s properties don''t specify a class') for: view.			^self].	(self class environment at: spec majorKey ifAbsent: []) notNil		ifTrue: 			[(Dialog				choose: ((#GenKeyRedefineClass &lt;&lt; #lensDev &gt;&gt; 'Class &lt;1s&gt;&lt;nn&gt;is already defined.  Redefine it?')			expandMacrosWith: className asString)				labels: (Array with: (#Redefine &lt;&lt; #lensDev &gt;&gt; 'Redefine') with: (#Cancel &lt;&lt; #lensDev &gt;&gt; 'Cancel'))				values: #(#proceed #cancel )				default: #cancel				for: view)				~~ #proceed ifTrue: [^self].			(org := Smalltalk organization categoryOfElement: className) isNil ifTrue: [org := #'LensApplications-New']]		ifFalse: [org := (model targetClass isNil or: [org := Smalltalk organization categoryOfElement: model targetClass name]) isNil						ifTrue: [#'LensApplications-New']						ifFalse: [org]].	newClass := UIFinderVW2 createNewApplication: className ofKind: #LensDataManager inCategory: org forClient: self.	newClass notNil		ifTrue:			[ed := LensApplicationSpecEditor new.			ed spec selector: spec minorKey.			ed openDialogForClass: newClass.			UIFinderVW2 installed: (Array with: newClass name with: #windowSpec)]</body><body package="Lens-Dev">doPaintChildDataForm	| spec clName cl canvasName |	spec := self selectionList first spec.	(clName := spec majorKey) isNil ifTrue: [^Dialog warn: (#GenKeyNoClassForProperty &lt;&lt; #lensDev &gt;&gt; 'The selected data form''s properties don''t specify a class') for: view].	cl := self class environment at: clName ifAbsent: [^Dialog warn: (#GenKeyUndefinedClassForProperty &lt;&lt; #lensDev &gt;&gt; 'The selected data form''s properties specify an undefined class') for: view].	(canvasName := spec minorKey) isNil ifTrue: [^Dialog warn: (#GenKeyNoCanvasForProperty &lt;&lt; #lensDev &gt;&gt; 'The selected data form''s properties don''t specify a canvas') for: view].	cl messageNotUnderstoodSignal handle: [:ex | ex parameter selector == canvasName			ifTrue: [^Dialog warn: (#GenKeyUndefinedCanvasForProperty &lt;&lt; #lensDev &gt;&gt; 'The selected data form''s properties specify an undefined canvas') for: view]			ifFalse: [ex reject]]		do: [cl perform: canvasName].	UIPainter new openOnClass: cl andSelector: canvasName</body></methods><methods><class-id>Tools.UIFinderVW2 class</class-id> <category>private</category><body package="Lens-Dev">createClassUsing: applicationSpec 	| newClass suprClass |	applicationSpec name size = 0 ifTrue: [^nil].	(suprClass := applicationSpec superclass asSymbol asQualifiedReference 		valueOrDo: [nil]) isNil 			ifTrue: [^nil].	newClass := applicationSpec nameSpace 		defineClass: applicationSpec name asSymbol		superclass: suprClass name asQualifiedReference		indexedType: #none		private: false		instanceVariableNames: String new		classInstanceVariableNames: String new		imports: String new		category: applicationSpec category.	SourceFileManager default logChange: newClass definition.	"The new class name may have been changed by class validation code."	applicationSpec name: newClass name.	(UIDefiner new setClass: newClass)		defineEssentialsFor: applicationSpec.	self installed: (Array with: newClass with: applicationSpec selector).	^newClass</body><body package="Lens-Dev">createNewApplication: clName nameSpace: nameSpace ofKind: aKind inCategory: categ forClient: anApplication	"Using the creation dialog ask the user for all the parameters required for the creation of an 	ApplicationModel. All the UI roads to create an applicationModel should go through this method. 	After the class is created if it has an #initialize method it is called"	| appSpec dialog newClass a |	(self doesSystemHaveClassNamed: #LensApplicationSpec )		ifFalse: [a := self openNewClassDialogForName: clName					subClassing: nil					inCategory: nil.				a == nil ifTrue: [^nil].				^self createNewClassUsing: a].	appSpec := (self getClassNamed: #LensApplicationSpec) new.	appSpec name: clName.	appSpec appType: aKind.	appSpec category: categ.	dialog := (self getClassNamed: #LensApplicationCreationDialog) new.	anApplication notNil		ifTrue: [dialog builder aspectAt: #ultimateClient put: anApplication].	dialog builder aspectAt: #nameSpace put: ((nameSpace isNil					ifTrue: [Lens.LensNamespaceControl lastDataApplicationNameSpace]					ifFalse: [nameSpace]) asValue).	dialog builder aspectAt: #nameSpaceMenu put: self nameSpaceMenu asValue.	dialog spec: appSpec.	dialog open		ifTrue: 			[dialog finalizeSpec.			newClass := self createClassUsing: appSpec.			newClass isNil ifTrue: [^nil].			(self does: newClass inheritFromClassNamed: #LensApplicationModel)				ifTrue: [newClass initialize].			^newClass]		ifFalse: [^nil]</body><body package="Lens-Dev">createNewApplication: clName ofKind: aKind inCategory: categ forClient: anApplication	"Using the creation dialog ask the user for all the parameters required for the creation of an 	ApplicationModel. All the UI roads to create an applicationModel should go through this method. 	After the class is created if it has an #initialize method it is called"	| appSpec dialog newClass a |	(self doesSystemHaveClassNamed: #LensApplicationSpec )		ifFalse: [a := self openNewClassDialogForName: clName					subClassing: nil					inCategory: nil.				a == nil ifTrue: [^nil].				^self createNewClassUsing: a].	appSpec := (self getClassNamed: #LensApplicationSpec) new.	appSpec name: clName.	appSpec appType: aKind.	appSpec category: categ.	dialog := (self getClassNamed: #LensApplicationCreationDialog) new.	anApplication notNil		ifTrue: [dialog builder aspectAt: #ultimateClient put: anApplication].	dialog builder aspectAt: #nameSpace 		put: (Lens.LensNamespaceControl lastDataApplicationNameSpace asValue).	dialog builder aspectAt: #nameSpaceMenu put: self nameSpaceMenu asValue.	dialog spec: appSpec.	dialog open		ifTrue: 			[dialog finalizeSpec.			newClass := self createClassUsing: appSpec.			newClass isNil ifTrue: [^nil].			(self does: newClass inheritFromClassNamed: #LensApplicationModel)				ifTrue: [newClass initialize].			^newClass]		ifFalse: [^nil]</body><body package="Lens-Dev">createNewClassUsing: anArray 	| newClass  |	newClass := self environment defineClass: (anArray at: 1) asSymbol		superclass: (anArray at: 2) name asQualifiedReference		indexedType: #none		private: false		instanceVariableNames: String new		classInstanceVariableNames: String new		imports: String new		category: (anArray at: 3).	SourceFileManager default logChange: newClass definition.	self installed: (Array with: newClass with: #windowSpec).	^newClass</body><body package="Lens-Dev">doesSystemHaveClassNamed: aSymbol	^(aSymbol asQualifiedReference valueOrDo: [nil]) notNil</body></methods><methods><class-id>Tools.UIFinderVW2 class</class-id> <category>resources</category><body package="Lens-Dev">nameSpaceMenu	"menu of name spaces"	| nameSpaces names |	nameSpaces := Lens.LensNamespaceControl permissableNameSpaces.	names := (Array with: (nameSpaces collect: [:d | d name asText allBold])).	^Menu		labelList: names		values: nameSpaces</body></methods><methods><class-id>Tools.UIFinderVW2 class</class-id> <category>private</category><body package="Lens-Dev">newOrExistingClassNamed: aString nameSpace: aNameSpace fromController: aController  creationData: creationData	| clName allClassNames matchingClassNames  newClass |	(clName := aString asSymbol) isEmpty ifTrue: [^nil].	((allClassNames := aNameSpace classNames) includes: clName)		ifTrue: [^aNameSpace at: clName].	aController sensor window keyboardProcessor focusIsShifting: false.	(clName findString: '*' startingAt: 1)		&gt; 0		ifTrue: 			[Cursor execute showWhile: [matchingClassNames := allClassNames select: [:cn | clName match: cn]].			matchingClassNames size = 0				ifTrue: 					[Dialog warn: (#NoMatchingClass &lt;&lt; #lensDev &gt;&gt; 'No matching class') for: aController view.					^nil].			matchingClassNames size = 1				ifTrue: [clName := matchingClassNames at: 1]				ifFalse: [clName := Dialog								choose: (#FindWhichClass &lt;&lt; #lensDev &gt;&gt; 'Find which class?')								fromList: matchingClassNames								values: matchingClassNames								lines: 10								cancel: [^nil]								for: aController view]]		ifFalse: [clName := allClassNames detect: [:cn | clName match: cn]						ifNone: 							[newClass := self										createNewApplication: clName										nameSpace: aNameSpace										ofKind:  (creationData at: 1)										inCategory: (creationData at: 2)										forClient: (creationData at: 3).							^newClass isNil								ifTrue: [nil]								ifFalse: [newClass]]].	^aNameSpace at: clName</body></methods><methods><class-id>Tools.UIFinderVW2 class</class-id> <category>interface opening</category><body package="Lens-Dev">openDestinationDialogForCategory: resourceCat nameSpace: nameSpace defaultSelector: defaultSelector creationData: creationData	"Open to collect an existing class and a new or existing selector as 	the destination for a static resource."	| dialog clName selList newSel results builder ctrl uid |	dialog := SimpleDialog new.	builder := dialog builder.	builder aspectAt: #nameSpace		put: (nameSpace isNil				ifTrue: [Lens.LensNamespaceControl lastDataModelerNameSpace]				ifFalse: [nameSpace]) asValue.	builder aspectAt: #nameSpaceMenu put: self nameSpaceMenu asValue.	builder aspectAt: #clientClass put: (clName := String new asValue).	builder aspectAt: #existingSelectors		put: (selList := SelectionInList with: List new).	builder aspectAt: #newSelector put: (newSel := String new asValue).	clName compute: 			[:v |			| cl nsv ctrlr ns |			ns := (builder aspectAt: #nameSpace) value.			ctrlr := (dialog builder componentAt: #ClassNameField) widget controller.			cl := self						newOrExistingClassNamed: v						nameSpace: ns						fromController: ctrlr						creationData: creationData.			cl isNil				ifTrue: 					[selList list: Array new.					(dialog builder componentAt: #ClassNameField) flash]				ifFalse: 					[clName value == cl name ifFalse: [clName setValue: cl name].					selList list: (cl class organization listAtCategoryNamed: resourceCat).					(selList list isEmpty and: [defaultSelector notNil])						ifTrue: [newSel value: defaultSelector].					(selList list includes: (nsv := newSel value asSymbol))						ifTrue: 							[selList selection: nsv.							newSel value: String new]]].	builder aspectAt: #doAbort put: [dialog close].	dialog postBuildBlock: 			[:sd :bldr |			| ns |			ns := (builder aspectAt: #nameSpace) value.			ctrl := (bldr componentAt: #SelectorSIL) widget controller.			uid := ctrl dispatcher copy.			uid doubleClick: 					[(results := self								resultsForClassName: clName value								nameSpace: ns								andSelectorList: selList								orSelectorNamed: newSel value) notNil						ifTrue: [dialog close]						ifFalse: 							[(dialog builder								componentAt: ((ns at: clName value asSymbol ifAbsent: [nil]) isNil										ifTrue: [#ClassNameField]										ifFalse: 											[selList list isEmpty ifTrue: [#NewSelectorField] ifFalse: [#SelectorSIL]]))									flash]].			ctrl setDispatcher: uid].	builder aspectAt: #doOK		put: 			[| ns |			ns := (builder aspectAt: #nameSpace) value.			(results := self						resultsForClassName: clName value						nameSpace: ns						andSelectorList: selList						orSelectorNamed: newSel value) notNil				ifTrue: [dialog close]				ifFalse: 					[(dialog builder						componentAt: ((ns at: clName value asSymbol ifAbsent: [nil]) isNil								ifTrue: [#ClassNameField]								ifFalse: 									[selList list isEmpty ifTrue: [#NewSelectorField] ifFalse: [#SelectorSIL]]))							flash]].	dialog openFrom: (self interfaceSpecFor: #unknownDestinationDialog2).	^results</body><body package="Lens-Dev">openDestinationDialogWithClass: aClass nameSpace: nameSpace andSelector: aSelector andCategory: aCategory  creationData: creationData	"Open either to confirm the current destination class or collect some 	other existing class and a new or existing selector as the destination of a 	static resource."	| dialog clName selList newSel results builder ctrl uid |	newSel := nil asValue.	dialog := SimpleDialog new.	builder := dialog builder.	builder aspectAt: #nameSpace put: ((nameSpace isNil					ifTrue: [Lens.LensNamespaceControl lastDataModelerNameSpace]					ifFalse: [nameSpace]) asValue).	builder aspectAt: #nameSpaceMenu put: self nameSpaceMenu asValue.	builder aspectAt: #clientClass put: (clName := aClass name asValue).	builder aspectAt: #existingSelectors put: ((selList := SelectionInList new) list: (aClass class organization listAtCategoryNamed: aCategory); yourself).	clName		compute: 			[:v | 			| cl nsv ctrlr ns |			ns := (builder aspectAt: #nameSpace) value.			(builder componentAt: #cancelButton) widget controller isControlWanted ifTrue: [ ^nil ].			ctrlr := (dialog builder componentAt: #ClassNameField) widget controller.			cl := self newOrExistingClassNamed: v nameSpace: ns fromController: ctrlr creationData: creationData.			cl isNil				ifTrue: 					[selList list: Array new.					(dialog builder componentAt: #ClassNameField) flash]				ifFalse: 					[clName value == cl name ifFalse: [clName setValue: cl name].					selList list: (cl class organization listAtCategoryNamed: aCategory).					(newSel value isEmpty and: [aSelector notNil])						ifTrue: [newSel value: aSelector asSymbol]						ifFalse: [newSel value: nil].					(newSel value isNil not and: [selList list includes: (nsv := newSel value asSymbol)])						ifTrue: 							[selList selection: nsv.							newSel value: String new]]].	builder aspectAt: #newSelector put: (newSel := ((selList list includes: aSelector) not					ifTrue: [aSelector isNil							ifTrue: [String new]							ifFalse: [aSelector asString]]					ifFalse: [String new]) asValue).	builder aspectAt: #doAbort put: [dialog close].	dialog		postBuildBlock: 			[:sd :bldr | | ns |			ns := (builder aspectAt: #nameSpace) value.			ctrl := (bldr componentAt: #SelectorSIL) widget controller.			uid := ctrl dispatcher copy.			uid doubleClick: [(results := self							resultsForClassName: clName value							andSelectorList: selList							orSelectorNamed: newSel value) notNil					ifTrue: [dialog close]					ifFalse: [(dialog builder componentAt: ((ns at: clName value asSymbol ifAbsent: [nil]) isNil								ifTrue: [#ClassNameField]								ifFalse: [#NewSelectorField])) flash]].			ctrl setDispatcher: uid].	builder aspectAt: #doOK put: [ | ns |					ns := (builder aspectAt: #nameSpace) value.					(results := self					resultsForClassName: clName value					nameSpace: ns					andSelectorList: selList					orSelectorNamed: newSel value) notNil			ifTrue: [dialog close]			ifFalse: [(dialog builder componentAt: ((ns at: clName value asSymbol ifAbsent: [nil]) isNil						ifTrue: [#ClassNameField]						ifFalse: [#NewSelectorField])) flash]].	selList selection: (aSelector isNil			ifTrue: [nil]			ifFalse: [aSelector asSymbol]).	dialog openFrom: (self interfaceSpecFor: #knownDestinationDialog2).	^results</body><body package="Lens-Dev">openNewClassDialogForName: aClassName subClassing: aSuperName inCategory: aCategory 	"Open a dialog to confirm or collect the basic information required 	to create a new class."	| dialog className catName superName superPick results builder |	dialog := SimpleDialog new.	builder := dialog builder.	builder		aspectAt: #className		put:			(className :=				(aClassName isNil					ifTrue: [String new]					ifFalse: [aClassName asString]) asValue).	builder		aspectAt: #classCategory		put:			(catName :=				(aCategory isNil					ifTrue: [(#UIApplicationsNew &lt;&lt; #lensDev &gt;&gt; 'UIApplications-New') asString copy]					ifFalse: [aCategory asString]) asValue).	builder		aspectAt: #superClassName		put:			(superName :=				(aSuperName isNil					ifTrue: [String new]					ifFalse: [aSuperName asString]) asValue).	builder		aspectAt: #superPick		put:			(superPick :=				(superName value isEmpty					ifTrue: [#ApplicationModel]					ifFalse: [#Other]) asValue).	superPick		compute:			[:v |			v = #Other				ifTrue:					[(dialog builder componentAt: #superClassNameField) enable]				ifFalse:					[superName value: String new.					(dialog builder componentAt: #superClassNameField) disable]].	superName		compute: 			[:v | 			| cl ctrlr |			ctrlr := (dialog builder componentAt: #superClassNameField) widget controller.			"ctrlr enableDefault."			cl := self superClassNamed: v fromController: ctrlr.			cl notNil				ifTrue: 					[superName value == cl name						ifFalse: [superName setValue: cl name]]].	builder		aspectAt: #doAbort		put:			[results := nil.			dialog close].	builder		aspectAt: #doOK		put:			[((results :=				self					resultsForClassName: className value					andSuperclass:						(superPick value == #Other							ifTrue: [superName value]							ifFalse: [superPick value])					andCategory: catName value) includes: nil) not				ifTrue:					[dialog close]				ifFalse:					[(results at: 1) isNil						ifTrue:							[(dialog builder componentAt: #classNameField) flash].					(results at: 2) isNil						ifTrue:							[(dialog builder componentAt: #superClassNameField) flash].					(results at: 3) isNil						ifTrue:							[(dialog builder componentAt: #classCategoryField) flash]]].	dialog allButOpenFrom: (self interfaceSpecFor: #classCreationDialog).	superPick value: superPick value.	dialog builder openDialog.	^results</body></methods><methods><class-id>Tools.UIFinderVW2 class</class-id> <category>private</category><body package="Lens-Dev">resultsForClassName: className nameSpace: aNameSpace andSelectorList: selectorList orSelectorNamed: selectorName 	| cl sel |	^((cl := aNameSpace at: className asSymbol ifAbsent: [nil]) isNil or:			[(sel := self					selectorOnClass: cl					inList: selectorList					orNamed: selectorName) isNil])		ifTrue: [nil]		ifFalse: [Array with: cl with: sel]</body><body package="Lens-Dev">selectorOnClass: aClass inList: aSelectorList orNamed: selectorName 	| selector protocolSymbol |	selectorName isNil ifTrue: [^nil].	^(selector := selectorName asSymbol) isEmpty		ifTrue: [(selector := aSelectorList selection) isNil				ifTrue: [nil]				ifFalse: [selector]]		ifFalse: [((protocolSymbol := aClass organization categoryOfElement: selector) notNil and: [protocolSymbol ~= #'interface specs' and: [(Dialog confirm: (#GenKeyDuplicateSelector &lt;&lt; #lensDev &gt;&gt; 'That selector is already defined.	   Redefine anyway?')) not]])				ifTrue: [nil]				ifFalse: [selector]]</body></methods><methods><class-id>Lens.LinkedDetailSpec class</class-id> <category>private-interface building</category><body package="Lens-Dev">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel.	env at: #clientKey put: (TypeConverter onSymbolValue: (self adapt: inst forAspect: #clientKey channel: aChannel)).	env at: #majorKey put: (TypeConverter onSymbolValue: (self adapt: inst forAspect: #majorKey channel: aChannel)).	env at: #minorKey put: (TypeConverter onSymbolValue: (self adapt: inst forAspect: #minorKey channel: aChannel)).	env at: #sourceType put: (self adapt: inst forAspect: #sourceType channel: aChannel).	env at: #contentKey put: (TypeConverter onSymbolValue: (self adapt: inst forAspect: #contentKey channel: aChannel)) aspectToText.	env at: #openAction put: (TypeConverter onSymbolValue: (self adapt: inst forAspect: #openAction channel: aChannel)).	env at: #fetchAction put: (TypeConverter onSymbolValue: (self adapt: inst forAspect: #fetchAction channel: aChannel)).	env at: #synchronize put: (self adapt: inst forAspect: #synchronize channel: aChannel).	env at: #lockPolicy put: (self adapt: inst forAspect: #lockPolicy channel: aChannel).	env at: #autoOpen put: (self adapt: inst forAspect: #autoOpen channel: aChannel).	env at: #autoFetch put: (self adapt: inst forAspect: #autoFetch channel: aChannel).</body></methods><methods><class-id>Lens.LinkedDetailSpec class</class-id> <category>property slices</category><body package="Lens-Dev">basicSlice	^#(10 #(#(#{Kernel.UserMessage} #key: #Basics #defaultString: 'Basics' #catalogID: #lensDev) #linkedBasicsSpec #LensDFBasicsSliceModel))</body></methods><methods><class-id>Lens.LinkedDetailSpec class</class-id> <category>private-interface building</category><body package="Lens-Dev">componentName	"Identification of component"	^(#linkedDataForm &lt;&lt; #lens &gt;&gt; 'Linked Data Form')</body></methods><methods><class-id>Lens.LinkedDetailSpec class</class-id> <category>property slices</category><body package="Lens-Dev">connectionSlice	^#(22 #(#(#{Kernel.UserMessage} #key: #Connection #defaultString: 'Connection' #catalogID: #lensDev) #linkedConnectionSpec #LensDFConnectionSliceModel))</body><body package="Lens-Dev">flyByHelpSlice	"Empty means no page"	^#(1 #())</body></methods><methods><class-id>Lens.LinkedDetailSpec class</class-id> <category>private-interface building</category><body package="Lens-Dev">specGenerationBlock	^[:ctrlr :point | | label |		LinkedDetailSpec			model: nil			label: (label := (#AppLink &lt;&lt; #lensDev &gt;&gt; 'App Link') asString)			layout: ((ctrlr gridPoint: point)				extent:					(ctrlr currentMode value class						placementExtentFor: LinkedDetailSpec						withLabel: label						inBuilder: ctrlr builder))			properties: #(#canDefault )]</body></methods><methods><class-id>Lens.LensKeyEditor class</class-id> <category>resources</category><body package="Lens-Dev">downArrow	"UIMaskEditor new openOnClass: self andSelector: #downArrow"	&lt;resource: #image&gt;	^Image extent: 15@15 depth: 1 palette: CoveragePalette monoMaskPalette bits: #[0 0 0 0 3 128 0 0 3 128 0 0 3 128 0 0 3 128 0 0 3 128 0 0 3 128 0 0 3 128 0 0 3 128 0 0 31 240 0 0 15 224 0 0 7 192 0 0 3 128 0 0 1 0 0 0 0 0 0 0 ] pad: 32</body><body package="Lens-Dev">leftArrow	"UIMaskEditor new openOnClass: self andSelector: #leftArrow"	&lt;resource: #image&gt;	^Image extent: 15@15 depth: 1 palette: CoveragePalette monoMaskPalette bits: #[0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 12 0 0 0 28 0 0 0 63 252 0 0 127 252 0 0 63 252 0 0 28 0 0 0 12 0 0 0 4 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ] pad: 32</body><body package="Lens-Dev">minusImage	"UIMaskEditor new openOnClass: self andSelector: #minusImage"	&lt;resource: #image&gt;	^Image extent: 15@15 depth: 1 palette: CoveragePalette monoMaskPalette bits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 31 240 0 0 31 240 0 0 31 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ] pad: 32</body><body package="Lens-Dev">plusImage	"UIMaskEditor new openOnClass: self andSelector: #plusImage"	&lt;resource: #image&gt;	^Image extent: 15@15 depth: 1 palette: CoveragePalette monoMaskPalette bits: #[0 0 0 0 0 0 0 0 0 0 0 0 3 128 0 0 3 128 0 0 3 128 0 0 31 240 0 0 31 240 0 0 31 240 0 0 3 128 0 0 3 128 0 0 3 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ] pad: 32</body><body package="Lens-Dev">rightArrow	"UIMaskEditor new openOnClass: self andSelector: #rightArrow"	&lt;resource: #image&gt;	^Image extent: 15@15 depth: 1 palette: CoveragePalette monoMaskPalette bits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 64 0 0 0 96 0 0 0 112 0 0 127 248 0 0 127 252 0 0 127 248 0 0 0 112 0 0 0 96 0 0 0 64 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ] pad: 32</body><body package="Lens-Dev">upArrow	"UIMaskEditor new openOnClass: self andSelector: #upArrow"	&lt;resource: #image&gt;	^Image extent: 15@15 depth: 1 palette: CoveragePalette monoMaskPalette bits: #[0 0 0 0 1 0 0 0 3 128 0 0 7 192 0 0 15 224 0 0 31 240 0 0 3 128 0 0 3 128 0 0 3 128 0 0 3 128 0 0 3 128 0 0 3 128 0 0 3 128 0 0 3 128 0 0 0 0 0 0 ] pad: 32</body></methods><methods><class-id>Lens.LensKeyEditor class</class-id> <category>interface specs</category><body package="Lens-Dev">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #KeyEditor #defaultString: 'Key Editor' #catalogID: #lensDev) 			#min: #(#Point 472 222 ) 			#bounds: #(#Rectangle 497 295 969 517 ) 			#menu: #menuBar ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ActionButtonSpec 					#layout: #(#Rectangle 4 79 36 111 ) 					#model: #moveKeyVariableUp 					#label: #upArrow 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 4 112 36 144 ) 					#model: #moveKeyVariableDown 					#label: #downArrow 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -2 0.5 79 0 30 0.5 111 0 ) 					#model: #addKeyVariable 					#label: #leftArrow 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -2 0.5 112 0 30 0.5 144 0 ) 					#model: #removeKeyVariable 					#label: #rightArrow 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 40 0 76 0 -6 0.5 -44 1 ) 					#model: #keyVariables 					#multipleSelections: false ) 				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 34 0.5 76 0 -12 1 -44 1 ) 					#model: #nonKeyVariables 					#multipleSelections: false ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -82 0.5 -35 1 -16 0.5 -5 1 ) 					#model: #accept 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#requestValueChangeSelector: #checkKey ) 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #lensDev) 					#isDefault: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 16 0.5 -35 1 82 0.5 -5 1 ) 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #lensDev) 					#defaultable: true ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 3 0 1 0 -1 1 25 0 ) 					#flags: 0 					#model: #message1 					#tabable: false 					#isReadOnly: true ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 3 0 26 0 -1 1 51 0 ) 					#flags: 0 					#model: #message2 					#tabable: false 					#isReadOnly: true ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 40 0 77 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #KeyVariables #defaultString: 'Key Variables:' #catalogID: #lensDev) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 38 0.5 77 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #NonkeyVariables #defaultString: 'Non-key Variables:' #catalogID: #lensDev) ) ) ) )</body></methods><methods><class-id>Lens.LensNamespaceControl class</class-id> <category>interface specs</category><body package="Lens-Dev">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #LensNameSpaceControl #defaultString: 'Lens NameSpace Control' #catalogID: #lensDev) 			#bounds: #(#{Rectangle} 342 283 751 485 ) 			#isEventDriven: true ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{SequenceViewSpec} 					#layout: #(#{Rectangle} 41 44 165 146 ) 					#name: #selectedList 					#model: #selectedList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{SequenceViewSpec} 					#layout: #(#{Rectangle} 246 44 370 146 ) 					#name: #availableList 					#model: #availableList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{LabelSpec} 					#layout: #(#{Point} 270 12 ) 					#label: #(#{Kernel.UserMessage} #key: #Available #defaultString: 'Available' #catalogID: #lensDev) ) 				#(#{LabelSpec} 					#layout: #(#{Point} 65 12 ) 					#label: #(#{Kernel.UserMessage} #key: #Selected #defaultString: 'Selected' #catalogID: #lensDev) ) 				#(#{ActionButtonSpec} 					#layout: #(#{Rectangle} 270 161 322 186 ) 					#name: #okButton 					#model: #doOK 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #lensDev) 					#defaultable: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{Rectangle} 334 161 385 186 ) 					#name: #cancelButton 					#model: #doCancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #lensDev) 					#defaultable: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{Rectangle} 179 51 231 76 ) 					#name: #moveToSelectedButton 					#model: #moveToSelected 					#label: #leftArrow 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{Rectangle} 179 87 231 112 ) 					#name: #moveToAvailableButton 					#model: #moveToAvailable 					#label: #rightArrow 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{Rectangle} 179 123 231 148 ) 					#name: #resetButton 					#model: #doReset 					#label: #(#{Kernel.UserMessage} #key: #Reset #defaultString: 'Reset' #catalogID: #lensDev) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Lens.LensApplicationSpecEditor class</class-id> <category>resources</category><body package="Lens-Dev">editPoliciesMenu	"MenuEditor new openOnClass: self andSelector: #editPoliciesMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(		#(#{UI.MenuItem} #rawLabel: #(#{Kernel.UserMessage} #key: #Never #defaultString: 'Never' #catalogID: #lensDev) )		#(#{UI.MenuItem} #rawLabel: #(#{Kernel.UserMessage} #key: #WhenTold #defaultString: 'When Told' #catalogID: #lensDev) )		#(#{UI.MenuItem} #rawLabel: #(#{Kernel.UserMessage} #key: #IfTouched #defaultString: 'If Touched' #catalogID: #lensDev) ) )		#(3 )		#(#neverEdit #enableEditingExplicitly #enableEditingOnSelection ) ) decodeAsLiteralArray</body><body package="Lens-Dev">menuBar	"MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #DataForm #defaultString: 'Data Form' #catalogID: #lensDev) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #New #defaultString: 'New...' #catalogID: #lensDev) 							#value: #newClass ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Existing #defaultString: 'Existing...' #catalogID: #lensDev) 							#value: #existingClass ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #InSameCategory #defaultString: 'In Same Category' #catalogID: #lensDev) 							#nameKey: #sameCategory 							#value: #sameCategory ) ) #(3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Help #defaultString: 'Help' #catalogID: #lensDev) 				#value: #Help 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Topics #defaultString: 'Topics' #catalogID: #lensDev) 							#value: #helpAction ) ) #(1 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Lens.LensApplicationSpecEditor class</class-id> <category>interface specs</category><body package="Lens-Dev">dialogWindowSpec	"Tools.UIPainter new openOnClass: self andSelector: #dialogWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Generate Canvas' 			#min: #(#{Core.Point} 329 368 ) 			#bounds: #(#{Graphics.Rectangle} 640 512 969 880 ) 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 39 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Class 						#defaultString: 'Class:' 						#catalogID: #lensDev ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 70 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Canvas 						#defaultString: 'Canvas:' 						#catalogID: #lensDev ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 102 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #TemplateC 						#defaultString: 'Template:' 						#catalogID: #lensDev ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 133 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #EditPolicy 						#defaultString: 'Edit Policy:' 						#catalogID: #lensDev ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 125 0 45 0 -10 1 70 0 ) 					#name: #specSelector 					#model: #'spec selector' 					#type: #symbol ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 125 0 77 0 -10 1 101 0 ) 					#name: #templatesMenu 					#model: #'spec template' 					#menu: #templatesMenu ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 125 0 109 0 -10 1 133 0 ) 					#name: #templatesMenu 					#model: #'spec editPolicy' 					#menu: #editPoliciesMenu ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 163 0 -8 1 -49 1 ) 					#name: #graphView 					#flags: 0 					#majorKey: #{Lens.LensGraphView} 					#minorKey: #windowSpec 					#clientKey: #graphView ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -104 0.5 -35 1 -38 0.5 -5 1 ) 					#name: #accept 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #lensDev ) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -33 0.5 -35 1 33 0.5 -5 1 ) 					#name: #cancelButton 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #lensDev ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 38 0.5 -35 1 104 0.5 -5 1 ) 					#name: #helpButton 					#model: #helpActionForDialog 					#label: 					#(#{Kernel.UserMessage} 						#key: #Help 						#defaultString: 'Help' 						#catalogID: #lensDev ) 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 125 0 14 0 -10 1 39 0 ) 					#name: #specName 					#flags: 0 					#model: #'spec fullName' 					#tabable: false 					#isReadOnly: true ) ) ) )</body><body package="Lens-Dev">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #CanvasComposer #defaultString: 'Canvas Composer' #catalogID: #lensDev) 			#min: #(#Point 294 330 ) 			#bounds: #(#Rectangle 592 285 921 653 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 29 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Class #defaultString: 'Class:' #catalogID: #lensDev) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 60 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Canvas #defaultString: 'Canvas:' #catalogID: #lensDev) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 92 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #TemplateC #defaultString: 'Template:' #catalogID: #lensDev) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 124 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #EditPolicy #defaultString: 'Edit Policy:' #catalogID: #lensDev) ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 125 0 4 0 -10 1 29 0 ) 					#name: #specName 					#flags: 0 					#model: #'spec fullName' 					#tabable: false 					#isReadOnly: true ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 125 0 35 0 -10 1 60 0 ) 					#name: #specSelector 					#model: #'spec selector' 					#type: #symbol ) 				#(#MenuButtonSpec 					#layout: #(#LayoutFrame 125 0 68 0 -10 1 92 0 ) 					#name: #templatesMenu 					#model: #'spec template' 					#menu: #templatesMenu ) 				#(#MenuButtonSpec 					#layout: #(#LayoutFrame 125 0 100 0 -10 1 124 0 ) 					#name: #templatesMenu 					#model: #'spec editPolicy' 					#menu: #editPoliciesMenu ) 				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 10 0 130 0 -8 1 -49 1 ) 					#name: #graphView 					#flags: 0 					#majorKey: #LensGraphView 					#minorKey: #windowSpec 					#clientKey: #graphView ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -52 0.5 -35 1 52 0.5 -5 1 ) 					#name: #generateIt 					#flags: 40 					#model: #generateIt 					#label: #(#{Kernel.UserMessage} #key: #Generate #defaultString: 'Generate' #catalogID: #lensDev) 					#isDefault: true ) ) ) )</body></methods><methods><class-id>Lens.LensApplicationCreationDialog class</class-id> <category>interface specs</category><body package="Lens-Dev">dataPanelSpec	"UIPainter new openOnClass: self andSelector: #dataPanelSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #ApplicationClassCreation #defaultString: 'Application Class Creation' #catalogID: #lensDev) 			#min: #(#Point 363 138 ) 			#bounds: #(#Rectangle 97 197 460 335 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 0 0 2 0 -4 0.5 -9 1 ) 					#label: #(#{Kernel.UserMessage} #key: #DataModel #defaultString: 'Data Model' #catalogID: #lensDev) ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 6 0 0 0.25 -11 0.5 25 0.25 ) 					#name: #dataModelClass 					#flags: 0 					#model: #'spec dataModel 1' 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #changedDataModel ) 					#tabable: false 					#isReadOnly: true 					#type: #string ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 6 0 -5 0.5 -11 0.5 20 0.5 ) 					#name: #dataModelSelector 					#flags: 0 					#model: #'spec dataModel 2' 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #changedDataModel ) 					#tabable: false 					#isReadOnly: true 					#type: #string ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 40 0 -40 1 -40 0.5 -16 1 ) 					#name: #browseDataModel 					#model: #browseDataModel 					#label: #(#{Kernel.UserMessage} #key: #Browse #defaultString: 'Browse...' #catalogID: #lensDev) ) 				#(#MenuButtonSpec 					#layout: #(#LayoutFrame 7 0.5 27 0 5 0.75 51 0 ) 					#name: #addType 					#model: #addtype 					#label: #(#{Kernel.UserMessage} #key: #Add #defaultString: 'Add' #catalogID: #lensDev) 					#menu: #typesMenu ) 				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 8 0.5 56 0 -6 1 -15 1 ) 					#name: #entities 					#model: #entities ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 10 0.75 27 0 -6 1 51 0 ) 					#name: #removeEntity 					#flags: 40 					#model: #removeType 					#label: #(#{Kernel.UserMessage} #key: #Remove #defaultString: 'Remove' #catalogID: #lensDev) ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 1 0.5 2 0 0 1.0 -8 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Entities #defaultString: 'Entities' #catalogID: #lensDev) ) ) ) )</body><body package="Lens-Dev">emptySpec	"UIPainter new openOnClass: self andSelector: #emptySpec"	&lt;resource: #canvas&gt;	^#(#FullSpec #window: #(#WindowSpec #label: '' #min: #(#Point 40 20 ) #bounds: #(#Rectangle732 20 1079 359 ) ) #component: #(#SpecCollection #collection: #() ) )</body><body package="Lens-Dev">mainApplicationSpec	"UIPainter new openOnClass: self andSelector: #mainApplicationSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 363 138 ) 			#bounds: #(#Rectangle 542 652 905 790 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 0 0 2 0 -4 0.5 -10 1 ) 					#label: #(#{Kernel.UserMessage} #key: #DataModel #defaultString: 'Data Model' #catalogID: #lensDev) ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 6 0 -11 0.3 -11 0.5 14 0.3 ) 					#name: #dataModelClass 					#flags: 0 					#model: #'spec dataModel 1' 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #changedDataModel ) 					#tabable: false 					#isReadOnly: true 					#type: #string ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 6 0 -22 0.6 -11 0.5 0 0.625 ) 					#name: #dataModelSelector 					#flags: 0 					#model: #'spec dataModel 2' 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #changedDataModel ) 					#tabable: false 					#isReadOnly: true 					#type: #string ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 1 0.5 2 0 0 1 -10 1 ) 					#label: #(#{Kernel.UserMessage} #key: #UpdateLocking #defaultString: 'Update Locking' #catalogID: #lensDev) ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 45 0 -40 1 -45 0.5 -16 1 ) 					#name: #browseDataModel 					#model: #browseDataModel 					#label: #(#{Kernel.UserMessage} #key: #Browse #defaultString: 'Browse...' #catalogID: #lensDev) ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin 12 0.5 31 0 ) 					#model: #'spec lockPolicy' 					#label: #(#{Kernel.UserMessage} #key: #LockOnAccept #defaultString: 'Lock On Accept' #catalogID: #lensDev) 					#select: #lockOnAccept ) 				#(#RadioButtonSpec 					#layout: #(#LayoutOrigin 12 0.5 61 0 ) 					#model: #'spec lockPolicy' 					#label: #(#{Kernel.UserMessage} #key: #LockOnEdit #defaultString: 'Lock On Edit' #catalogID: #lensDev) 					#select: #lockOnEdit ) ) ) )</body><body package="Lens-Dev">modelersMainApplicationSpec	"UIPainter new openOnClass: self andSelector: #modelersMainApplicationSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 40 20 ) 			#bounds: #(#Rectangle 71 516 418 855 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 0 0 2 0 0 1.0 78 0 ) 					#label: #(#{Kernel.UserMessage} #key: #UpdateLocking #defaultString: 'Update Locking' #catalogID: #lensDev) ) 				#(#RadioButtonSpec 					#layout: #(#Point 15 22 ) 					#model: #'spec lockPolicy' 					#label: #(#{Kernel.UserMessage} #key: #LockOnAccept #defaultString: 'Lock On Accept' #catalogID: #lensDev) 					#select: #lockOnAccept ) 				#(#RadioButtonSpec 					#layout: #(#Point 15 43 ) 					#model: #'spec lockPolicy' 					#label: #(#{Kernel.UserMessage} #key: #LockOnEdit #defaultString: 'Lock On Edit' #catalogID: #lensDev) 					#select: #lockOnEdit ) ) ) )</body><body package="Lens-Dev">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Create New Class' 			#min: #(#{Core.Point} 379 420 ) 			#max: #(#{Core.Point} 379 420 ) 			#bounds: #(#{Graphics.Rectangle} 640 512 1019 932 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 7 0 32 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #NameSpace 						#defaultString: 'Name Space:' 						#catalogID: #lensDev ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 7 0 116 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Category 						#defaultString: 'Category:' 						#catalogID: #lensDev ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 126 0 -10 1 230 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #DefineAs 						#defaultString: 'Define As' 						#catalogID: #lensDev ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 7 0 88 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Superclass 						#defaultString: 'Superclass:' 						#catalogID: #lensDev ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 100 0 37 0 -10 1 62 0 ) 					#name: #specName 					#model: #'spec name' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #setEnablement ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 100 0 93 0 -10 1 118 0 ) 					#name: #specCategory 					#model: #'spec category' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #setEnablement ) ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 100 148 ) 					#name: #specTypeDialog 					#model: #'spec appType' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #appTypeChanged ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Dialog 						#defaultString: 'Dialog' 						#catalogID: #lensDev ) 					#select: #SimpleDialog ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 218 148 ) 					#name: #specTypeWindow 					#model: #'spec appType' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #appTypeChanged ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Application 						#defaultString: 'Application' 						#catalogID: #lensDev ) 					#select: #ApplicationModel ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 100 172 ) 					#name: #specTypeData 					#model: #'spec appType' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #appTypeChanged ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #DataForm 						#defaultString: 'Data Form' 						#catalogID: #lensDev ) 					#select: #LensDataManager ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 218 172 ) 					#name: #specTypeMain 					#model: #'spec appType' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #appTypeChanged ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #DatabaseApplication 						#defaultString: 'Database Application' 						#catalogID: #lensDev ) 					#select: #LensMainApplication ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 100 0 65 0 -10 1 90 0 ) 					#name: #specSuperclass 					#model: #'spec superclass' 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #setEnablement ) ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 215 0 -10 1 -36 1 ) 					#name: #subCanvas 					#flags: 0 ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -110 0.5 -35 1 -44 0.5 -5 1 ) 					#name: #accept 					#model: #accept 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: #checkFields ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #lensDev ) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -33 0.5 -35 1 33 0.5 -5 1 ) 					#name: #cancelButton 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #lensDev ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 44 0.5 -35 1 110 0.5 -5 1 ) 					#name: #helpButton 					#model: #helpActionForDialog 					#label: 					#(#{Kernel.UserMessage} 						#key: #Help 						#defaultString: 'Help' 						#catalogID: #lensDev ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 7 0 60 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Name 						#defaultString: 'Name:' 						#catalogID: #lensDev ) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 100 9 369 34 ) 					#name: #nameSpaceField 					#model: #nameSpace 					#menu: #nameSpaceMenu ) ) ) )</body></methods><methods><class-id>Lens.LensEditor class</class-id> <category>resources</category><body package="Lens-Dev">dialectsMenu	"UIMenuEditor new openOnClass: self andSelector: #dialectsMenu"	&lt;resource: #menu&gt;	^#(#PopUpMenu #(#(#{Kernel.UserMessage} #key: #Oracle7 #defaultString: 'Oracle7' #catalogID: #lensDev) ) #() #(#Oracle7Context ) ) decodeAsLiteralArray</body></methods><methods><class-id>Lens.LensEditor class</class-id> <category>interface specs</category><body package="Lens-Dev">classNameDialog	"UIPainter new openOnClass: self andSelector: #classNameDialog"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: ' ' 			#min: #(#{Point} 386 169 ) 			#max: #(#{Point} 386 169 ) 			#bounds: #(#{Rectangle} 257 337 643 506 ) ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 0 0 8 0 0 1 32 0 ) 					#name: #message 					#flags: 0 					#isOpaque: true 					#model: #message 					#tabable: false 					#alignment: #center 					#isReadOnly: true ) 				#(#{LabelSpec} 					#layout: #(#{Point} 9 49 ) 					#label: #(#{Kernel.UserMessage} #key: #Namespace #defaultString: 'Namespace:' #catalogID: #lensDev) ) 				#(#{LabelSpec} 					#layout: #(#{Point} 54 80 ) 					#label: #(#{Kernel.UserMessage} #key: #Class #defaultString: 'Class:' #catalogID: #lensDev) ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 100 0 78 0 -10 1 103 0 ) 					#name: #ClassNameField 					#model: #className 					#tabable: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutFrame} -82 0.5 -35 1 -8 0.5 -5 1 ) 					#name: #okButton 					#model: #doOK 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #lensDev) 					#isDefault: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutFrame} 8 0.5 -35 1 82 0.5 -5 1 ) 					#name: #cancelButton 					#model: #doAbort 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #lensDev) 					#defaultable: true ) 				#(#{MenuButtonSpec} 					#layout: #(#{LayoutFrame} 100 0 46 0 -10 1 72 0 ) 					#name: #nameSpaceField 					#model: #nameSpace 					#menu: #nameSpaceMenu ) ) ) )</body><body package="Lens-Dev">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #DataModeler #defaultString: 'Data Modeler' #catalogID: #lensDev) 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 363 426 813 742 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 54 0 0 1.0 0 1.0 ) 					#name: #ldmView 					#flags: 0 					#majorKey: #LensGraphView 					#minorKey: #windowSpec 					#clientKey: #ldmView ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 2 1 81 26 ) 					#name: #referenceButton 					#model: #referenceButton 					#label: #(#{Kernel.UserMessage} #key: #Reference #defaultString: 'Reference' #catalogID: #lensDev) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 180 0 1 0 -3 1 26 0 ) 					#flags: 0 					#model: #'selectedDataModelHolder applicationName' 					#tabable: false 					#isReadOnly: true 					#type: #string ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 85 0 27 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #ApplicationC #defaultString: 'Application:' #catalogID: #lensDev) ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 6 0 61 0 -24 1 -20 1 ) 					#flags: 36 					#model: #mainMessage 					#isReadOnly: true 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 85 0 52 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #DataModelC #defaultString: 'Data Model:' #catalogID: #lensDev) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 180 0 26 0 -3 1 51 0 ) 					#flags: 0 					#model: #'selectedDataModelHolder selector' 					#tabable: false 					#isReadOnly: true 					#type: #string ) ) ) )</body></methods><methods><class-id>Lens.LensReferenceNameDialog class</class-id> <category>interface specs</category><body package="Lens-Dev">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 379 327 ) 			#max: #(#Point 640 327 ) 			#bounds: #(#Rectangle 522 293 901 620 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#RadioButtonSpec 					#layout: #(#Point 42 143 ) 					#name: #nameSelector1 					#model: #nameSelector 					#tabable: false 					#select: #name1 ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 70 0 141 0 -10 1 165 0 ) 					#name: #name1 					#model: #name1 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#focusInSelector: #enterName1 ) 					#tabable: true 					#isReadOnly: false ) 				#(#RadioButtonSpec 					#layout: #(#Point 42 172 ) 					#name: #nameSelector2 					#model: #nameSelector 					#tabable: false 					#select: #name2 ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 70 0 170 0 -10 1 194 0 ) 					#name: #name2 					#model: #name2 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#focusInSelector: #enterName2 ) 					#tabable: true 					#isReadOnly: false ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -174 0.5 -35 1 -12 0.5 -5 1 ) 					#name: #accept 					#model: #accept 					#label: #(#{Kernel.UserMessage} #key: #AcceptReference #defaultString: 'Accept Reference' #catalogID: #lensDev) 					#isDefault: true 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 12 0.5 -35 1 156 0.5 -5 1 ) 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #SkipReference #defaultString: 'Skip Reference' #catalogID: #lensDev) 					#defaultable: true ) 				#(#LabelSpec 					#layout: #(#Point 8 6 ) 					#label: #(#{Kernel.UserMessage} #key: #GenKey82 #defaultString: 'Creating a reference from entity:' #catalogID: #lensDev) ) 				#(#LabelSpec 					#layout: #(#Point 8 50 ) 					#label: #(#{Kernel.UserMessage} #key: #ToEntity #defaultString: 'To entity:' #catalogID: #lensDev) ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 32 0 23 0 -3 1 47 0 ) 					#flags: 0 					#model: #fromEntity 					#tabable: false 					#isReadOnly: true ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 32 0 67 0 -3 1 91 0 ) 					#flags: 0 					#model: #toEntity 					#tabable: false 					#isReadOnly: true ) 				#(#LabelSpec 					#layout: #(#Point 8 95 ) 					#label: #(#{Kernel.UserMessage} #key: #GenKey81 #defaultString: 'Enter the name for the variable replacing:' #catalogID: #lensDev) ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 32 0 114 0 -3 1 138 0 ) 					#flags: 0 					#model: #replaced 					#tabable: false 					#isReadOnly: true ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 15 0 224 0 0 1 ) 					#name: #a2 					#label: #(#{Kernel.UserMessage} #key: #NoteThat #defaultString: 'Note that:' #catalogID: #lensDev) ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 115 0 195 0 -3 1 219 0 ) 					#name: #a3 					#flags: 0 					#model: #referenceEntities 					#tabable: false 					#isReadOnly: true ) 				#(#LabelSpec 					#layout: #(#Point 30 220 ) 					#name: #a4 					#label: #(#{Kernel.UserMessage} #key: #GenKey80 #defaultString: 'Is (Are) already a foreign key' #catalogID: #lensDev) ) 				#(#LabelSpec 					#layout: #(#Point 30 241 ) 					#name: #a5 					#label: #(#{Kernel.UserMessage} #key: #GenKey79 #defaultString: 'reference. Creating this new reference' #catalogID: #lensDev) ) 				#(#LabelSpec 					#layout: #(#Point 30 262 ) 					#name: #a6 					#label: #(#{Kernel.UserMessage} #key: #GenKey78 #defaultString: 'would make it (them) inaccessible.' #catalogID: #lensDev) ) ) ) )</body></methods><methods><class-id>Lens.LensDFBasicsSliceModel class</class-id> <category>interface specs</category><body package="Lens-Dev">embeddedBasicsSpec	"UIPainter new openOnClass: self andSelector: #embeddedBasicsSpec"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: ' ' 			#min: #(#{Point} 40 20 ) 			#bounds: #(#{Rectangle} 293 336 610 606 ) ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #EmbeddedDataForm #defaultString: 'Embedded Data Form' #catalogID: #lensDev) ) 				#(#{DividerSpec} 					#layout: #(#{LayoutFrame} 6 0 96 0 -6 1 100 0 ) ) 				#(#{LabelSpec} 					#layout: #(#{LayoutFrame} -90 0.5 83 0 95 0.5 109 0 ) 					#isOpaque: true 					#label: ' ' ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 10 0 78 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Class #defaultString: 'Class:' #catalogID: #lensDev) ) 				#(#{LabelSpec} 					#layout: #(#{Point} 10 122 ) 					#label: #(#{Kernel.UserMessage} #key: #Name #defaultString: 'Name:' #catalogID: #lensDev) ) 				#(#{GroupBoxSpec} 					#layout: #(#{Rectangle} 25 196 282 223 ) ) 				#(#{LabelSpec} 					#layout: #(#{LayoutFrame} 0 0.302013 165 0 3 1 218 0 ) 					#isOpaque: true 					#label: ' ' ) 				#(#{LabelSpec} 					#layout: #(#{LayoutFrame} 9 0 157 0 0 1.0 181 0 ) 					#isOpaque: true 					#label: ' ' ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 10 0 175 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Canvas #defaultString: 'Canvas:' #catalogID: #lensDev) ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 10 0 206 0 0 1 ) 					#isOpaque: true 					#label: #(#{Kernel.UserMessage} #key: #Source #defaultString: 'Source:' #catalogID: #lensDev) ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 86 0 53 0 -10 1 78 0 ) 					#model: #'specChannel majorKey' 					#menu: #fieldMenu 					#type: #symbol ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutFrame} -86 0.5 83 0 91 0.5 113 0 ) 					#model: #generateOtherProperties 					#label: #(#{Kernel.UserMessage} #key: #GenerateProperties #defaultString: 'Generate Properties' #catalogID: #lensDev) 					#isDefault: false ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 86 0 118 0 -10 1 143 0 ) 					#model: #'specChannel clientKey' 					#menu: #fieldMenu 					#type: #symbol ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 86 0 150 0 -10 1 175 0 ) 					#model: #'specChannel minorKey' 					#menu: #fieldMenu 					#type: #symbol ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 86 0 181 0 -10 1 206 0 ) 					#isOpaque: true 					#model: #contentKey 					#menu: #fieldMenu ) 				#(#{RadioButtonSpec} 					#layout: #(#{LayoutOrigin} 0 0.305296 209 0 ) 					#model: #'specChannel sourceType' 					#label: #(#{Kernel.UserMessage} #key: #Aspect #defaultString: 'Aspect' #catalogID: #lensDev) 					#select: #singular ) 				#(#{RadioButtonSpec} 					#layout: #(#{LayoutOrigin} 0 0.657321 209 0 ) 					#model: #'specChannel sourceType' 					#label: #(#{Kernel.UserMessage} #key: #Query #defaultString: 'Query' #catalogID: #lensDev) 					#select: #query ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 10 0 262 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #ID #defaultString: 'ID:' #catalogID: #lensDev) ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 86 0 236 0 -10 1 261 0 ) 					#model: #'specChannel name' 					#menu: #fieldMenu 					#type: #symbol ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 10 0 48 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #NameSpace #defaultString: 'Name Space:' #catalogID: #lensDev) ) 				#(#{MenuButtonSpec} 					#layout: #(#{Rectangle} 110 25 311 50 ) 					#model: #'specChannel nameSpace' 					#menu: #nameSpaceMenu ) ) ) )</body><body package="Lens-Dev">linkedBasicsSpec	"UIPainter new openOnClass: self andSelector: #linkedBasicsSpec"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: ' ' 			#min: #(#{Point} 298 267 ) 			#max: #(#{Point} 298 343 ) 			#bounds: #(#{Rectangle} 300 316 598 659 ) ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{GroupBoxSpec} 					#layout: #(#{Rectangle} 25 196 282 223 ) ) 				#(#{LabelSpec} 					#layout: #(#{LayoutFrame} 0 0.302013 191 0 3 1 244 0 ) 					#isOpaque: true 					#label: ' ' ) 				#(#{LabelSpec} 					#layout: #(#{LayoutFrame} 9 0 183 0 0 1.0 207 0 ) 					#isOpaque: true 					#label: ' ' ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #LinkedDataForm #defaultString: 'Linked Data Form' #catalogID: #lensDev) ) 				#(#{LabelSpec} 					#layout: #(#{Point} 10 122 ) 					#label: #(#{Kernel.UserMessage} #key: #Name #defaultString: 'Name:' #catalogID: #lensDev) ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 10 0 175 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Canvas #defaultString: 'Canvas:' #catalogID: #lensDev) ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 10 0 261 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Label #defaultString: 'Label:' #catalogID: #lensDev) ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 10 0 293 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Action #defaultString: 'Action:' #catalogID: #lensDev) ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 10 0 206 0 0 1 ) 					#isOpaque: true 					#label: #(#{Kernel.UserMessage} #key: #Source #defaultString: 'Source:' #catalogID: #lensDev) ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 10 0 323 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #ID #defaultString: 'ID:' #catalogID: #lensDev) ) 				#(#{DividerSpec} 					#layout: #(#{LayoutFrame} 6 0 96 0 -6 1 100 0 ) ) 				#(#{LabelSpec} 					#layout: #(#{LayoutFrame} -89 0.5 83 0 95 0.5 109 0 ) 					#isOpaque: true 					#label: ' ' ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 10 0 78 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Class #defaultString: 'Class:' #catalogID: #lensDev) ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 85 0 53 0 -11 1 78 0 ) 					#model: #'specChannel majorKey' 					#menu: #fieldMenu 					#type: #symbol ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutFrame} -86 0.5 83 0 91 0.5 113 0 ) 					#model: #generateOtherProperties 					#label: #(#{Kernel.UserMessage} #key: #GenerateProperties #defaultString: 'Generate Properties' #catalogID: #lensDev) 					#isDefault: false ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 86 0 118 0 -10 1 143 0 ) 					#model: #'specChannel clientKey' 					#menu: #fieldMenu 					#type: #symbol ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 86 0 150 0 -10 1 175 0 ) 					#model: #'specChannel minorKey' 					#menu: #fieldMenu 					#type: #symbol ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 86 0 181 0 -10 1 206 0 ) 					#isOpaque: true 					#model: #contentKey 					#menu: #fieldMenu ) 				#(#{RadioButtonSpec} 					#layout: #(#{LayoutOrigin} 0 0.305369 209 0 ) 					#model: #'specChannel sourceType' 					#label: #(#{Kernel.UserMessage} #key: #Aspect #defaultString: 'Aspect' #catalogID: #lensDev) 					#select: #singular ) 				#(#{RadioButtonSpec} 					#layout: #(#{LayoutOrigin} 0 0.657718 209 0 ) 					#model: #'specChannel sourceType' 					#label: #(#{Kernel.UserMessage} #key: #Query #defaultString: 'Query' #catalogID: #lensDev) 					#select: #query ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 86 0 236 0 -90 1 261 0 ) 					#model: #'specChannel label' 					#menu: #fieldMenu ) 				#(#{CheckBoxSpec} 					#layout: #(#{AlignmentOrigin} -85 1 258 0 0 1 ) 					#model: #'specChannel hasImageOrientedLabel' 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Image #defaultString: 'Image' #catalogID: #lensDev) ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 86 0 267 0 -10 1 292 0 ) 					#model: #'specChannel openAction' 					#menu: #fieldMenu 					#type: #symbol ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 86 0 297 0 -10 1 322 0 ) 					#model: #'specChannel name' 					#menu: #fieldMenu 					#type: #symbol ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 10 0 45 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Namespace #defaultString: 'Namespace:' #catalogID: #lensDev) ) 				#(#{MenuButtonSpec} 					#layout: #(#{Rectangle} 108 22 288 47 ) 					#model: #'specChannel nameSpace' 					#menu: #nameSpaceMenu ) ) ) )</body></methods><methods><class-id>Lens.LensMappingEditor class</class-id> <category>resources</category><body package="Lens-Dev">popUpMenu	"MenuEditor new openOnClass: self andSelector: #popUpMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #SelectSingleColumnKey #defaultString: 'Select Single Column Key' #catalogID: #lensDev) 				#value: #selectSingleKey ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Lens.LensMappingEditor class</class-id> <category>interface specs</category><body package="Lens-Dev">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #MappingTool #defaultString: 'Mapping Tool' #catalogID: #lensDev) 			#min: #(#Point 431 316 ) 			#bounds: #(#Rectangle 4 151 454 467 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 0 0 103 0 0 1 0 1 ) 					#name: #graphView 					#flags: 0 					#majorKey: #LensGraphView 					#minorKey: #windowSpec 					#clientKey: #graphView ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 7 0.5 54 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Type #defaultString: 'Type:' #catalogID: #lensDev) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 7 0.5 85 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Length #defaultString: 'Length:' #catalogID: #lensDev) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 8 0 54 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Type #defaultString: 'Type:' #catalogID: #lensDev) ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 4 0.5 4 0 -4 1 92 0 ) 					#name: #columnBox 					#label: #(#{Kernel.UserMessage} #key: #Column #defaultString: 'Column' #catalogID: #lensDev) ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 4 0 4 0 -5 0.5 92 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Variable #defaultString: 'Variable' #catalogID: #lensDev) ) 				#(#MenuButtonSpec 					#layout: #(#LayoutFrame 60 0 28 0 -13 0.5 53 0 ) 					#name: #variableValueType 					#model: #variableValueType 					#menu: #valueClassesMenu ) 				#(#CheckBoxSpec 					#layout: #(#AlignmentOrigin 131 0 85 0 0 1 ) 					#name: #variableNotNil 					#model: #variableNotNil 					#label: #(#{Kernel.UserMessage} #key: #NotNil #defaultString: 'Not Nil' #catalogID: #lensDev) ) 				#(#MenuButtonSpec 					#layout: #(#LayoutFrame 60 0.5 28 0 -13 1 53 0 ) 					#name: #columnType 					#model: #columnType 					#menu: #columnTypeMenu ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 75 0.5 62 0 -100 1 84 0 ) 					#name: #columnLength 					#model: #columnLength 					#alignment: #right 					#type: #number ) 				#(#CheckBoxSpec 					#layout: #(#AlignmentOrigin -96 1 85 0 0 1 ) 					#name: #columnNotNull 					#model: #columnNotNull 					#label: #(#{Kernel.UserMessage} #key: #NotNull #defaultString: 'Not Null' #catalogID: #lensDev) ) 				#(#CheckBoxSpec 					#layout: #(#AlignmentOrigin 17 0 85 0 0 1 ) 					#name: #variableCollection 					#flags: 16 					#model: #variableCollection 					#label: #(#{Kernel.UserMessage} #key: #Collection #defaultString: 'Collection' #catalogID: #lensDev) ) ) ) )</body></methods><methods><class-id>Lens.LensDFConnectionSliceModel class</class-id> <category>interface specs</category><body package="Lens-Dev">embeddedConnectionSpec	"UIPainter new openOnClass: self andSelector: #embeddedConnectionSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 273 242 ) 			#max: #(#Point 640 242 ) 			#bounds: #(#Rectangle 269 398 556 640 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 56 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #FetchC #defaultString: 'Fetch:' #catalogID: #lensDev) ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 60 0 -10 1 132 0 ) 					#label: #(#{Kernel.UserMessage} #key: #FetchOn #defaultString: 'Fetch On' #catalogID: #lensDev) ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 135 0 -10 1 233 0 ) 					#label: #(#{Kernel.UserMessage} #key: #UpdateLocking #defaultString: 'Update Locking' #catalogID: #lensDev) ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 74 0 30 0 -10 1 55 0 ) 					#model: #'specChannel fetchAction' 					#menu: #fieldMenu 					#type: #symbol ) 				#(#CheckBoxSpec 					#layout: #(#Point 22 80 ) 					#name: #synchronizeCheckbox 					#model: #'specChannel synchronize' 					#label: #(#{Kernel.UserMessage} #key: #ParentsRowChange #defaultString: 'Parent''s Row Change' #catalogID: #lensDev) ) 				#(#CheckBoxSpec 					#layout: #(#Point 22 103 ) 					#model: #'specChannel autoFetch' 					#label: #(#{Kernel.UserMessage} #key: #Opening #defaultString: 'Opening' #catalogID: #lensDev) ) 				#(#RadioButtonSpec 					#layout: #(#Point 22 155 ) 					#model: #'specChannel lockPolicy' 					#label: #(#{Kernel.UserMessage} #key: #LockOnAccept #defaultString: 'Lock On Accept' #catalogID: #lensDev) 					#select: #lockOnAccept ) 				#(#RadioButtonSpec 					#layout: #(#Point 22 179 ) 					#model: #'specChannel lockPolicy' 					#label: #(#{Kernel.UserMessage} #key: #LockOnEdit #defaultString: 'Lock On Edit' #catalogID: #lensDev) 					#select: #lockOnEdit ) 				#(#RadioButtonSpec 					#layout: #(#Point 22 203 ) 					#model: #'specChannel lockPolicy' 					#label: #(#{Kernel.UserMessage} #key: #ContinueCurrentPolicy #defaultString: 'Continue Current Policy' #catalogID: #lensDev) 					#select: #current ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #EmbeddedDataForm #defaultString: 'Embedded Data Form' #catalogID: #lensDev) ) ) ) )</body><body package="Lens-Dev">linkedConnectionSpec	"UIPainter new openOnClass: self andSelector: #linkedConnectionSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 267 270 ) 			#max: #(#Point 640 270 ) 			#bounds: #(#Rectangle 279 496 566 766 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #LinkedDataForm #defaultString: 'Linked Data Form' #catalogID: #lensDev) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 56 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #FetchC #defaultString: 'Fetch:' #catalogID: #lensDev) ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 135 0 -10 1 233 0 ) 					#label: #(#{Kernel.UserMessage} #key: #UpdateLocking #defaultString: 'Update Locking' #catalogID: #lensDev) ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 74 0 30 0 -10 1 55 0 ) 					#model: #'specChannel fetchAction' 					#menu: #fieldMenu 					#type: #symbol ) 				#(#RadioButtonSpec 					#layout: #(#Point 22 155 ) 					#model: #'specChannel lockPolicy' 					#label: #(#{Kernel.UserMessage} #key: #LockOnAccept #defaultString: 'Lock On Accept' #catalogID: #lensDev) 					#select: #lockOnAccept ) 				#(#RadioButtonSpec 					#layout: #(#Point 22 179 ) 					#model: #'specChannel lockPolicy' 					#label: #(#{Kernel.UserMessage} #key: #LockOnEdit #defaultString: 'Lock On Edit' #catalogID: #lensDev) 					#select: #lockOnEdit ) 				#(#RadioButtonSpec 					#layout: #(#Point 22 203 ) 					#model: #'specChannel lockPolicy' 					#label: #(#{Kernel.UserMessage} #key: #ContinueCurrentPolicy #defaultString: 'Continue Current Policy' #catalogID: #lensDev) 					#select: #current ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 60 0 -10 1 132 0 ) 					#label: #(#{Kernel.UserMessage} #key: #FetchOn #defaultString: 'Fetch On' #catalogID: #lensDev) ) 				#(#CheckBoxSpec 					#layout: #(#Point 22 80 ) 					#name: #synchronizeCheckbox 					#model: #'specChannel synchronize' 					#label: #(#{Kernel.UserMessage} #key: #ParentsRowChange #defaultString: 'Parent''s Row Change' #catalogID: #lensDev) ) 				#(#CheckBoxSpec 					#layout: #(#Point 22 103 ) 					#model: #'specChannel autoFetch' 					#label: #(#{Kernel.UserMessage} #key: #Opening #defaultString: 'Opening' #catalogID: #lensDev) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 238 ) 					#model: #'specChannel autoOpen' 					#label: #(#{Kernel.UserMessage} #key: #OpenWithParent #defaultString: 'Open with Parent' #catalogID: #lensDev) ) ) ) )</body></methods><methods><class-id>Lens.LensApplicationStructureView class</class-id> <category>interface specs</category><body package="Lens-Dev">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 99 48 ) 			#max: #(#Point 640 480 ) 			#bounds: #(#Rectangle 481 415 843 528 ) 			#menu: #menuBar ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 0 0 0 0 0 1 0 1 ) 					#name: #graphView 					#flags: 0 					#majorKey: #LensGraphView 					#minorKey: #windowSpec 					#clientKey: #graphView ) ) ) )</body></methods><methods><class-id>Lens.LensTablesSelector class</class-id> <category>interface specs</category><body package="Lens-Dev">dialogSpec	"UIPainter new openOnClass: self andSelector: #dialogSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #DatabaseTables #defaultString: 'Database Tables' #catalogID: #lensDev) 			#min: #(#Point 20 20 ) 			#bounds: #(#Rectangle 614 510 897 811 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#InputFieldSpec 					#layout: #(#LayoutFrame 85 0 13 0 -60 1 34 0 ) 					#model: #pattern ) 				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 2 0 60 0 -2 0.5 -50 1 ) 					#model: #tablesList ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 5 0 -40 1 68 0 -5 1 ) 					#name: #createButton 					#flags: 40 					#model: #accept 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #lensDev) 					#isDefault: false 					#defaultable: true ) 				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 2 0.5 60 0 -2 1 -50 1 ) 					#model: #columnsList ) 				#(#LabelSpec 					#layout: #(#Point 5 40 ) 					#label: #(#{Kernel.UserMessage} #key: #Tables #defaultString: 'Tables' #catalogID: #lensDev) ) 				#(#LabelSpec 					#layout: #(#LayoutOrigin 2 0.5 40 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Columns #defaultString: 'Columns' #catalogID: #lensDev) ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 50 0.5 -46 1 0 1 -26 1 ) 					#flags: 0 					#model: #columnType 					#tabable: false 					#isReadOnly: true ) 				#(#LabelSpec 					#layout: #(#LayoutOrigin 2 0.5 -44 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Type #defaultString: 'Type:' #catalogID: #lensDev) ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 2 0.5 -24 1 0 1 -2 1 ) 					#name: #columnCanBeNull 					#flags: 0 					#model: #columnCanBeNull 					#tabable: false 					#isReadOnly: true ) 				#(#LabelSpec 					#layout: #(#Point 4 12 ) 					#label: #(#{Kernel.UserMessage} #key: #Pattern #defaultString: 'Pattern:' #catalogID: #lensDev) ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 65 0 -40 1 128 0 -5 1 ) 					#name: #cancelButton 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #lensDev) 					#isDefault: false 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -56 1 9 0 -1 1 39 0 ) 					#model: #changedPattern 					#label: #(#{Kernel.UserMessage} #key: #Fetch #defaultString: 'Fetch' #catalogID: #lensDev) 					#isDefault: true ) ) ) )</body><body package="Lens-Dev">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #DatabaseTables #defaultString: 'Database Tables' #catalogID: #lensDev) 			#min: #(#Point 264 140 ) 			#bounds: #(#Rectangle 601 363 904 664 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#InputFieldSpec 					#layout: #(#LayoutFrame 85 0 13 0 -60 1 34 0 ) 					#model: #pattern ) 				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 2 0 60 0 -2 0.5 -53 1 ) 					#flags: 15 					#model: #tablesList ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 72 0 -41 1 138 0 -9 1 ) 					#name: #mapButton 					#flags: 40 					#model: #mapTable 					#label: #(#{Kernel.UserMessage} #key: #Map #defaultString: 'Map' #catalogID: #lensDev) 					#isDefault: false ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 4 0 -41 1 70 0 -9 1 ) 					#name: #createButton 					#flags: 40 					#model: #addClassForTable 					#label: #(#{Kernel.UserMessage} #key: #Create #defaultString: 'Create' #catalogID: #lensDev) 					#isDefault: false ) 				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 2 0.5 60 0 -2 1 -53 1 ) 					#flags: 15 					#model: #columnsList ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 5 0 61 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Tables #defaultString: 'Tables' #catalogID: #lensDev) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 2 0.5 61 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Columns #defaultString: 'Columns' #catalogID: #lensDev) ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 54 0.5 -50 1 0 1.0 -26 1 ) 					#flags: 0 					#model: #columnType 					#tabable: false 					#isReadOnly: true ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 2 0.5 -26 1 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Type #defaultString: 'Type:' #catalogID: #lensDev) ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 2 0.5 -25 1 0 1.0 -1 1 ) 					#name: #columnCanBeNull 					#flags: 0 					#model: #columnCanBeNull 					#tabable: false 					#isReadOnly: true ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 4 0 34 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Pattern #defaultString: 'Pattern:' #catalogID: #lensDev) ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -56 1 9 0 -1 1 39 0 ) 					#model: #changedPattern 					#label: #(#{Kernel.UserMessage} #key: #Fetch #defaultString: 'Fetch' #catalogID: #lensDev) 					#isDefault: true ) ) ) )</body></methods><methods><class-id>Lens.QueryEditor class</class-id> <category>resources</category><body package="Lens-Dev">aggregateMenu	"UIMenuEditor new openOnClass: self andSelector: #aggregateMenu"	&lt;resource: #menu&gt;	^#(#PopUpMenu #(#(#{Kernel.UserMessage} #key: #Average #defaultString: 'Average' #catalogID: #lensDev) #(#{Kernel.UserMessage} #key: #Count #defaultString: 'Count' #catalogID: #lensDev) #(#{Kernel.UserMessage} #key: #Max #defaultString: 'Max' #catalogID: #lensDev) #(#{Kernel.UserMessage} #key: #Min #defaultString: 'Min' #catalogID: #lensDev) #(#{Kernel.UserMessage} #key: #StandardDeviation #defaultString: 'StandardDeviation' #catalogID: #lensDev) #(#{Kernel.UserMessage} #key: #Sum #defaultString: 'Sum' #catalogID: #lensDev) #(#{Kernel.UserMessage} #key: #Variance #defaultString: 'Variance' #catalogID: #lensDev) ) #() #(#Average #Count #Max #Min #StandardDeviation #Sum #Variance ) ) decodeAsLiteralArray</body><body package="Lens-Dev">eraseImage	"UIMaskEditor new openOnClass: self andSelector: #eraseImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 19@19 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 1 0 0 0 1 0 0 0 33 6 0 0 16 24 0 0 0 0 0 0 1 128 0 0 2 71 0 0 100 32 0 0 4 56 0 0 2 84 0 0 1 170 0 0 16 213 0 0 32 168 128 0 0 84 64 0 0 34 32 0 0 17 0 0 0 8 128 0 0 4 64 0 ])</body><body package="Lens-Dev">menuBar	"MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Query #defaultString: 'Query' #catalogID: #lensDev) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Load #defaultString: 'Load...' #catalogID: #lensDev) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Install #defaultString: 'Install...' #catalogID: #lensDev) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #GenerateMenuAccessor #defaultString: 'Generate Menu Accessor...' #catalogID: #lensDev) ) ) #(2 1 ) #(#loadQuery #install #generateMenuAccessor ) ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Help #defaultString: 'Help' #catalogID: #lensDev) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Topics #defaultString: 'Topics' #catalogID: #lensDev) ) ) #(1 ) #(#helpAction ) ) ) ) #(2 ) #(nil #Help ) ) decodeAsLiteralArray</body><body package="Lens-Dev">menuMenuBar	"MenuEditor new openOnClass: self andSelector: #menuMenuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Query #defaultString: 'Query' #catalogID: #lensDev) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Install #defaultString: 'Install...' #catalogID: #lensDev) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #GenerateMenuAccessor #defaultString: 'Generate Menu Accessor...' #catalogID: #lensDev) ) ) #(2 ) #(#install #generateMenuAccessor ) ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Help #defaultString: 'Help' #catalogID: #lensDev) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Topics #defaultString: 'Topics' #catalogID: #lensDev) ) ) #(1 ) #(#helpAction ) ) ) ) #(2 ) #(nil #Help ) ) decodeAsLiteralArray</body></methods><methods><class-id>Lens.QueryEditor class</class-id> <category>interface specs</category><body package="Lens-Dev">menuButtonSpec	"UIPainter new openOnClass: self andSelector: #menuButtonSpec"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #MenuQueryEditor #defaultString: 'Menu Query Editor' #catalogID: #lensDev) 			#min: #(#{Point} 401 270 ) 			#bounds: #(#{Rectangle} 390 376 860 691 ) 			#flags: 4 			#menu: #menuMenuBar ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{SubCanvasSpec} 					#layout: #(#{LayoutFrame} 6 0 128 0 -6 1 -4 1 ) 					#name: #tablesView 					#flags: 0 					#majorKey: #LensGraphView 					#minorKey: #windowSpec 					#clientKey: #tablesView ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 10 0 25 0 0 1 ) 					#name: #class 					#label: #(#{Kernel.UserMessage} #key: #Class #defaultString: 'Class:' #catalogID: #lensDev) ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 202 0 25 0 0 1 ) 					#name: #pattern 					#label: #(#{Kernel.UserMessage} #key: #MessagePattern #defaultString: 'Message Pattern:' #catalogID: #lensDev) ) 				#(#{SubCanvasSpec} 					#layout: #(#{Rectangle} 10 27 189 52 ) 					#name: #classFinder 					#flags: 0 					#majorKey: #{ClassFinder} 					#minorKey: #nameOnlySpec 					#clientKey: #classFinder ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 202 0 27 0 -8 1 52 0 ) 					#name: #pattern 					#model: #pattern 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: #markDirty ) 					#tabable: true 					#isReadOnly: false ) 				#(#{RadioButtonSpec} 					#layout: #(#{AlignmentOrigin} 11 0 86 0 0 1 ) 					#name: #from 					#model: #current 					#label: #(#{Kernel.UserMessage} #key: #From #defaultString: 'From:' #catalogID: #lensDev) 					#select: #from ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 115 0 60 0 -7 1 85 0 ) 					#name: #fromField 					#model: #from 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: #markDirty ) 					#isReadOnly: true ) 				#(#{RadioButtonSpec} 					#layout: #(#{AlignmentOrigin} 11 0 119 0 0 1 ) 					#name: #answer 					#model: #current 					#label: #(#{Kernel.UserMessage} #key: #Labels #defaultString: 'Labels:' #catalogID: #lensDev) 					#select: #answer ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 115 0 93 0 -7 1 118 0 ) 					#name: #answerField 					#model: #answer 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: #markDirty ) ) ) ) )</body><body package="Lens-Dev">typingSpec	"Tools.UIPainter new openOnClass: self andSelector: #typingSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #QueryAssistant 				#defaultString: 'Query Assistant' 				#catalogID: #lensDev ) 			#min: #(#{Core.Point} 294 209 ) 			#max: #(#{Core.Point} 294 209 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 806 593 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 220 140 254 172 ) 					#name: #biggerOrEqual 					#model: #biggerOrEqual 					#tabable: false 					#label: '&gt;=' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 184 140 218 172 ) 					#name: #different 					#model: #different 					#tabable: false 					#label: '~=' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 148 140 182 172 ) 					#name: #smallerOrEqual 					#model: #smallerOrEqual 					#tabable: false 					#label: '&lt;=' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 4 106 74 138 ) 					#name: #ascending 					#model: #ascending 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #Asc 						#defaultString: 'Asc' 						#catalogID: #lensDev ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 76 106 146 138 ) 					#name: #descending 					#model: #descending 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #Desc 						#defaultString: 'Desc' 						#catalogID: #lensDev ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 4 140 146 172 ) 					#name: #defaultJoin 					#model: #defaultJoin 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #DefaultJoin 						#defaultString: 'Default Join' 						#catalogID: #lensDev ) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 4 38 146 70 ) 					#name: #aggregate 					#model: #aggregate 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #Aggregate 						#defaultString: 'Aggregate' 						#catalogID: #lensDev ) 					#menu: #aggregateMenu ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 184 38 218 70 ) 					#name: #or 					#model: #or 					#tabable: false 					#label: '|' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 220 38 254 70 ) 					#name: #parenthesis 					#model: #prenthesis 					#tabable: false 					#label: '()' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 256 38 290 70 ) 					#name: #comma 					#model: #comma 					#tabable: false 					#label: ',' ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 4 4 146 36 ) 					#name: #functions 					#model: #menusValue 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #Functions 						#defaultString: 'Functions' 						#catalogID: #lensDev ) 					#menu: #functionsMenu ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 148 4 182 36 ) 					#name: #plus 					#model: #plus 					#tabable: false 					#label: '+' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 256 4 290 36 ) 					#name: #divided 					#model: #divided 					#tabable: false 					#label: '/' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 220 4 254 36 ) 					#name: #multiplied 					#model: #multiplied 					#tabable: false 					#label: '*' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 184 4 218 36 ) 					#name: #minus 					#model: #minus 					#tabable: false 					#label: '-' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 184 106 218 138 ) 					#name: #equal 					#model: #equal 					#tabable: false 					#label: '=' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 220 106 254 138 ) 					#name: #biggerThan 					#model: #biggerThan 					#tabable: false 					#label: '&gt;' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 148 106 182 138 ) 					#name: #smallerThan 					#model: #smallerThan 					#tabable: false 					#label: '&lt;' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 76 72 146 104 ) 					#name: #notNil 					#model: #notNilAction 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #notNil 						#defaultString: 'notNil' 						#catalogID: #lensDev ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 4 72 74 104 ) 					#name: #isNil 					#model: #isNilAction 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #isNil 						#defaultString: 'isNil' 						#catalogID: #lensDev ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 220 72 290 104 ) 					#name: #not 					#model: #notAction 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #not 						#defaultString: 'not' 						#catalogID: #lensDev ) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 148 174 290 206 ) 					#name: #variable 					#model: #menusValue 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #Variable 						#defaultString: 'Variable' 						#catalogID: #lensDev ) 					#menu: #instanceVariablesMenu ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 256 124 290 156 ) 					#name: #erase 					#model: #erase 					#tabable: false 					#label: #eraseImage 					#hasCharacterOrientedLabel: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 4 174 146 206 ) 					#name: #defaultJoin 					#model: #defaultMixinJoin 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #DefRestrict 						#defaultString: 'Def. Restrict' 						#catalogID: #lensDev ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 148 72 218 104 ) 					#name: #isLike 					#model: #isLike 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #isLike 						#defaultString: 'isLike:' 						#catalogID: #lensDev ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 148 38 182 70 ) 					#name: #and 					#model: #and 					#tabable: false 					#label: '&amp;' ) ) ) )</body><body package="Lens-Dev">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #QueryEditor #defaultString: 'Query Editor' #catalogID: #lensDev) 			#min: #(#{Point} 514 400 ) 			#bounds: #(#{Rectangle} 394 472 908 872 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 9 0 -125 1 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Class #defaultString: 'Class:' #catalogID: #lensDev) ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 9 0 -70 1 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #MessagePattern #defaultString: 'Message Pattern:' #catalogID: #lensDev) ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 115 0 3 0 -40 1 28 0 ) 					#name: #fromField 					#flags: 0 					#model: #from 					#isReadOnly: true ) 				#(#{SubCanvasSpec} 					#layout: #(#{LayoutFrame} 232 0 222 0 -4 1 -3 1 ) 					#name: #tablesView 					#flags: 0 					#majorKey: #LensGraphView 					#minorKey: #windowSpec 					#clientKey: #tablesView ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutFrame} -29 1 6 0 -4 1 28 0 ) 					#name: #erase 					#model: #erase 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: #markDirty ) 					#tabable: false 					#label: #eraseImage 					#hasCharacterOrientedLabel: false ) 				#(#{SubCanvasSpec} 					#layout: #(#{LayoutFrame} 9 0 -124 1 214 0 -99 1 ) 					#name: #classFinder 					#flags: 0 					#majorKey: #{ClassFinder} 					#minorKey: #nameOnlySpec 					#clientKey: #classFinder ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 9 0 -69 1 215 0 -44 1 ) 					#name: #pattern 					#model: #pattern 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: #markDirty ) 					#tabable: true 					#isReadOnly: false ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutFrame} 8 0 -35 1 214 0 -5 1 ) 					#model: #openTypingAssistant 					#label: #(#{Kernel.UserMessage} #key: #QueryAssistant #defaultString: 'Query Assistant' #catalogID: #lensDev) ) 				#(#{RadioButtonSpec} 					#layout: #(#{AlignmentOrigin} 11 0 28 0 0 1 ) 					#name: #from 					#model: #current 					#label: #(#{Kernel.UserMessage} #key: #From #defaultString: 'From:' #catalogID: #lensDev) 					#select: #from ) 				#(#{RadioButtonSpec} 					#layout: #(#{AlignmentOrigin} 10 0 59 0 0 1 ) 					#name: #answer 					#model: #current 					#label: #(#{Kernel.UserMessage} #key: #Select #defaultString: 'Select:' #catalogID: #lensDev) 					#select: #answer ) 				#(#{CheckBoxSpec} 					#layout: #(#{AlignmentOrigin} 115 0 59 0 0 1 ) 					#name: #fullObjects 					#model: #fullObjects 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: #markDirty ) 					#label: #(#{Kernel.UserMessage} #key: #FullObjects #defaultString: 'Full Objects' #catalogID: #lensDev) ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 240 0 35 0 -4 1 60 0 ) 					#name: #answerField 					#model: #answer 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: #markDirty ) ) 				#(#{RadioButtonSpec} 					#layout: #(#{Point} 10 83 ) 					#name: #where 					#model: #current 					#label: #(#{Kernel.UserMessage} #key: #Where #defaultString: 'Where:' #catalogID: #lensDev) 					#select: #where ) 				#(#{TextEditorSpec} 					#layout: #(#{LayoutFrame} 115 0 67 0 -4 1 119 0 ) 					#name: #whereField 					#model: #where 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: #markDirty ) ) 				#(#{RadioButtonSpec} 					#layout: #(#{AlignmentOrigin} 10 0 151 0 0 1 ) 					#name: #orderBy 					#model: #current 					#label: #(#{Kernel.UserMessage} #key: #OrderBy #defaultString: 'Order By:' #catalogID: #lensDev) 					#select: #orderBy ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 115 0 126 0 -4 1 151 0 ) 					#name: #orderByField 					#model: #orderBy 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: #markDirty ) ) 				#(#{RadioButtonSpec} 					#layout: #(#{AlignmentOrigin} 9 0 182 0 0 1 ) 					#name: #groupBy 					#model: #current 					#label: #(#{Kernel.UserMessage} #key: #GroupBy #defaultString: 'Group By:' #catalogID: #lensDev) 					#select: #groupBy ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 115 0 158 0 -4 1 183 0 ) 					#name: #groupByField 					#model: #groupBy 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: #markDirty ) ) 				#(#{CheckBoxSpec} 					#layout: #(#{Point} 10 189 ) 					#name: #distinct 					#model: #distinct 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: #markDirty ) 					#label: #(#{Kernel.UserMessage} #key: #Distinct #defaultString: 'Distinct' #catalogID: #lensDev) ) 				#(#{CheckBoxSpec} 					#layout: #(#{Point} 106 189 ) 					#name: #lock 					#model: #lock 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: #markDirty ) 					#label: #(#{Kernel.UserMessage} #key: #LockResult #defaultString: 'Lock Result' #catalogID: #lensDev) ) 				#(#{CheckBoxSpec} 					#layout: #(#{Point} 232 189 ) 					#name: #unique 					#model: #unique 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: #markDirty ) 					#label: #(#{Kernel.UserMessage} #key: #Unique #defaultString: 'Unique' #catalogID: #lensDev) ) 				#(#{CheckBoxSpec} 					#layout: #(#{Point} 320 189 ) 					#model: #useStreaming 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#valueChangeSelector: #markDirty ) 					#label: #(#{Kernel.UserMessage} #key: #FetchOnDemand #defaultString: 'Fetch On Demand' #catalogID: #lensDev) ) ) ) )</body></methods><methods><class-id>Lens.EmbeddedDetailSpec class</class-id> <category>resources</category><body package="Lens-Dev">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 7) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); at: 3 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 4 put: ColorValue white; at: 5 put: ColorValue cyan; at: 6 put: ColorValue blue; at: 7 put: ColorValue red; yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@L3L3L3L3L3L3L3L2@@@@@CDQDQDQDQDQDQDQD @@@@@1DQDQDQDQDQDQDQH@@@@@LQ@@@@@@@@@@@@DR@@@@@CDPUUUUUUUUUUTAD @@@@@1D@@@@@@@@@@@@QH@@@@@LQ@3L3L3L3L3L0DR@@@@@CDPL3L3@@@@@@LAD @@@@@1DC@@@0L3L3LC@QH@@@@@LQ@3L3L@@@@@@0DR@@@@@CDPL3L3L3L3L3LAD @@@@@1DFY&amp;Y&amp;Y&amp;Y&amp;Y&amp;@QH@@@@@LQA%UUUUUUUUU DR@@@@@CDPYTQ@QDPDQEXAD @@@@@1DFT@@@@@@@AV@QH@@@@@LQA%QDADQ@QDU DR@@@@@CDPYP@@@@@@@EXAD @@@@@1DFUDPDQDADQV@QH@@@@@LQA%UUUUUUUUU DR@@@@@CDPY&amp;Y&amp;Y&amp;Y&amp;Y&amp;XAD @@@@@1D@@@@@@@@@@@@QH@@@@@LQDQDQDQDQDQDQDR@@@@@CDQDQDQDQDQDQDQD @@@@@"H"H"H"H"H"H"H"H@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body><body package="Lens-Dev">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 143 255 252 192 143 255 252 192 143 255 252 192 136 0 4 192 136 31 244 192 139 208 20 192 136 31 244 192 136 0 4 192 143 255 252 192 143 255 252 192 142 33 28 192 143 255 252 192 142 33 28 192 143 255 252 192 142 33 28 192 143 255 252 192 143 255 252 192 143 255 252 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192 ])</body><body package="Lens-Dev">selectionPopUpMenu	"UIMenuEditor new openOnClass: self andSelector: #selectionPopUpMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: #(#{UserMessage} #key: #createchilddataform #catalogID: #lens #defaultString: 'create child data form' ) )			#(#MenuItem 				#rawLabel: #(#{UserMessage} #key: #paintchilddataform #catalogID: #lens #defaultString: 'paint child data form' ) )			#(#MenuItem 				#rawLabel: #(#{UserMessage} #key: #browsechilddataform #catalogID: #lens #defaultString: 'browse child data form') ) ) #(3 ) #(#doDefineChildDataForm #doPaintChildDataForm #doBrowseChildDataForm ) ) decodeAsLiteralArray</body><body package="Lens-Dev">selectionPullDownMenu	"UIMenuEditor new openOnClass: self andSelector: #selectionPullDownMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: #(#{UserMessage} #key: #CreateChildDataForm #catalogID: #lens defaultString: 'Create Child Data Form' )) 			#(#MenuItem 				#rawLabel: #(#{UserMessage} #key: #PaintChildDataForm #catalogID: #lens defaultString: 'Paint Child Data Form' ) )			#(#MenuItem 				#rawLabel: #(#{UserMessage} #key: #BrowseChildDataForm #catalogID: #lens defaultString: 'Browse Child Data Form') ) ) #(3 ) #(#doDefineChildDataForm #doPaintChildDataForm #doBrowseChildDataForm ) ) decodeAsLiteralArray</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - launcher</category><body package="Lens-Dev">newDatabaseApplicationCommand	&lt;command: #newDatabaseApplication&gt;	^Command		label: #newDatabaseApplication &lt;&lt; #lensDev &gt;&gt; 'New Database &amp;Application...'		group: #launcher		bindings: #()</body><body package="Lens-Dev">newDataFormCommand	&lt;command: #newDataForm&gt;	^Command		label: #newDataForm &lt;&lt; #lensDev &gt;&gt; 'New Data &amp;Form...'		group: #launcher		bindings: #()</body><body package="Lens-Dev">openCanvasComposerCommand	&lt;command: #openCanvasComposer&gt;	^Command		label: #canvasComposer &lt;&lt; #lensDev &gt;&gt; 'Canvas &amp;Composer'		group: #launcher		bindings: #()</body><body package="Lens-Dev">openDataModelerCommand	&lt;command: #openDataModeler&gt;	^Command		label: (#dataModeler &lt;&lt; #lensDev &gt;&gt; 'Data &amp;Modeler')		group: #launcher		bindings: #()</body></methods><methods><class-id>Lens.LensDataModelGenerator class</class-id> <category>interface specs</category><body package="Lens-Dev">editLensDataModelSpec	"UIPainter new openOnClass: self andSelector: #editLensDataModelSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #DataModel #defaultString: 'Data Model' #catalogID: #lensDev) 			#min: #(#Point 40 20 ) 			#bounds: #(#Rectangle 536 348 874 611 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 16 0 107 0 -16 1 -49 1 ) 					#name: #contextProperties 					#flags: 0 ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -82 0.5 -35 1 -16 0.5 -5 1 ) 					#model: #accept 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #lensDev) 					#isDefault: true 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 16 0.5 -35 1 82 0.5 -5 1 ) 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #lensDev) 					#defaultable: true ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 71 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #SQLDialect #defaultString: 'SQL Dialect:' #catalogID: #lensDev) ) 				#(#MenuButtonSpec 					#layout: #(#Rectangle 122 47 260 70 ) 					#model: #dialect 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#requestValueChangeSelector: #canChangeDialect ) 					#menu: #dialectsMenu ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 81 0 -10 1 -40 1 ) 					#label: #(#{Kernel.UserMessage} #key: #DatabaseLogin #defaultString: 'Database Login' #catalogID: #lensDev) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 10 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #DataModelProperties #defaultString: 'Data Model Properties' #catalogID: #lensDev) ) ) ) )</body><body package="Lens-Dev">nameSpaceDialog	"UIPainter new openOnClass: self andSelector: #nameSpaceDialog"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: ' ' 			#min: #(#{Point} 386 169 ) 			#max: #(#{Point} 386 169 ) 			#bounds: #(#{Rectangle} 196 275 582 444 ) ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 0 0 8 0 0 1 32 0 ) 					#name: #message 					#flags: 0 					#isOpaque: true 					#model: #message 					#tabable: false 					#alignment: #center 					#isReadOnly: true ) 				#(#{LabelSpec} 					#layout: #(#{Point} 9 49 ) 					#label: #(#{Kernel.UserMessage} #key: #Namespace #defaultString: 'Namespace:' #catalogID: #lensDev) ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutFrame} -82 0.5 -35 1 -8 0.5 -5 1 ) 					#name: #okButton 					#model: #doOK 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #lensDev) 					#isDefault: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutFrame} 8 0.5 -35 1 82 0.5 -5 1 ) 					#name: #cancelButton 					#model: #doAbort 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #lensDev) 					#defaultable: true ) 				#(#{MenuButtonSpec} 					#layout: #(#{LayoutFrame} 100 0 46 0 -10 1 72 0 ) 					#name: #nameSpaceField 					#model: #nameSpace 					#menu: #nameSpaceMenu ) ) ) )</body><body package="Lens-Dev">selectDataModelSpec	"UIPainter new openOnClass: self andSelector: #selectDataModelSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#bounds: #(#Rectangle 652 242 1036 471 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 10 0 58 0 -4 0.5 -40 1 ) 					#model: #classesBearingDataModels ) 				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 4 0.5 58 0 -10 1 -40 1 ) 					#name: #dataModelsOnSelectedClass 					#model: #dataModelsOnSelectedClass 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#doubleClickSelector: #acceptDataModelSelection ) ) 				#(#LabelSpec 					#layout: #(#Point 12 35 ) 					#label: #(#{Kernel.UserMessage} #key: #ApplicationClass #defaultString: 'Application Class' #catalogID: #lensDev) ) 				#(#LabelSpec 					#layout: #(#LayoutOrigin 6 0.5 35 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Selector #defaultString: 'Selector' #catalogID: #lensDev) ) 				#(#LabelSpec 					#layout: #(#Point 10 12 ) 					#label: #(#{Kernel.UserMessage} #key: #SELECTADataModel #defaultString: 'SELECT a Data Model' #catalogID: #lensDev) ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -82 0.5 -35 1 -16 0.5 -5 1 ) 					#name: #loadButton 					#model: #accept 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #lensDev) 					#isDefault: true 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 16 0.5 -35 1 82 0.5 -5 1 ) 					#name: #cancelButton 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #lensDev) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - tools - database</category><body package="Lens-Dev">menuItemCanvasComposer	&lt;menuItemForCommand: #openCanvasComposer		nameKey: nil		menu: #(#menuBar #tools #database)		position: 20.2&gt;	| panGen |	panGen := LensApplicationSpecEditor new.	panGen spec: LensApplicationSpec new.	panGen open</body><body package="Lens-Dev">menuItemDataModeler	&lt;menuItemForCommand: #openDataModeler		icon: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #database)		nameKey: nil		menu: #(#launcherToolBar)		position: 100.2		helpText: #(#OpenDataModeler #menus 'Open the Data Modeler Tool')&gt;	&lt;menuItemForCommand: #openDataModeler		icon: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #database)		nameKey: nil		menu: #(#menuBar #tools #database)		position: 20.1&gt;	self openApplicationForClassNamed: #{LensEditor}</body><body package="Lens-Dev">menuItemNewDatabaseApplication	"Create a new database application and then open a painter on its canvas"	&lt;menuItemForCommand: #newDatabaseApplication		nameKey: nil		menu: #(#menuBar #tools #database)		position: 20.4&gt;	self applicationForClassNamed: #UIFinderVW2		do:		[:uiFinder| | newClass |		newClass := uiFinder						createNewApplication: nil						ofKind: #LensMainApplication						inCategory: nil						forClient: self.		newClass notNil ifTrue:			[self applicationForClassNamed: #UIPainter				do: [:uiPainter| uiPainter new openOnClass: newClass andSelector: #windowSpec]]]</body><body package="Lens-Dev">menuItemNewDataForm	"Create the new data form and then give the oportunity to immediately define a canvas for it"	&lt;menuItemForCommand: #newDataForm		nameKey: nil		menu: #(#menuBar #tools #database)		position: 20.3&gt;	self applicationForClassNamed: #UIFinderVW2		do:		[:uiFinder| | newClass |		newClass := uiFinder						createNewApplication: nil						ofKind: #LensDataManager						inCategory: nil						forClient: self.		LensApplicationSpecEditor new openDialogForClass: newClass]</body></methods><methods><class-id>Tools.UIFinderVW2 class</class-id> <category>interface specs</category><body package="Lens-Dev">knownDestinationDialog2	"UIPainter new openOnClass: self andSelector: #knownDestinationDialog2"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: ' ' 			#min: #(#{Point} 242 341 ) 			#max: #(#{Point} 242 352 ) 			#bounds: #(#{Rectangle} 290 292 532 633 ) ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 10 0 81 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #INSTALLOnClass #defaultString: 'INSTALL on Class:' #catalogID: #lensDev) ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 10 0 130 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #andSelector #defaultString: 'and Selector:' #catalogID: #lensDev) ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 10 0 270 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #orEnterNewSelector #defaultString: 'or enter new Selector:' #catalogID: #lensDev) ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 10 0 81 0 -10 1 106 0 ) 					#name: #ClassNameField 					#model: #clientClass 					#tabable: true ) 				#(#{SequenceViewSpec} 					#layout: #(#{LayoutFrame} 10 0 136 0 -10 1 243 0 ) 					#name: #SelectorSIL 					#model: #existingSelectors ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 10 0 270 0 -10 1 295 0 ) 					#name: #NewSelectorField 					#model: #newSelector 					#tabable: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutFrame} -82 0.5 -35 1 -16 0.5 -5 1 ) 					#name: #okButton 					#model: #doOK 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #lensDev) 					#isDefault: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutFrame} 16 0.5 -35 1 82 0.5 -5 1 ) 					#name: #cancelButton 					#model: #doAbort 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #lensDev) 					#defaultable: true ) 				#(#{MenuButtonSpec} 					#layout: #(#{Rectangle} 10 32 232 57 ) 					#name: #nameSpaceField 					#model: #nameSpace 					#menu: #nameSpaceMenu ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 10 0 32 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #NameSpace #defaultString: 'Name Space:' #catalogID: #lensDev) ) ) ) )</body><body package="Lens-Dev">unknownDestinationDialog2	"UIPainter new openOnClass: self andSelector: #unknownDestinationDialog2"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: ' ' 			#min: #(#{Point} 242 341 ) 			#max: #(#{Point} 242 352 ) 			#bounds: #(#{Rectangle} 290 292 532 633 ) ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 10 0 81 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #INSTALLOnClass #defaultString: 'INSTALL on Class:' #catalogID: #lensDev) ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 10 0 130 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #andSelector #defaultString: 'and Selector:' #catalogID: #lensDev) ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 10 0 270 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #orEnterNewSelector #defaultString: 'or enter new Selector:' #catalogID: #lensDev) ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 10 0 81 0 -10 1 106 0 ) 					#name: #ClassNameField 					#model: #clientClass 					#tabable: true ) 				#(#{SequenceViewSpec} 					#layout: #(#{LayoutFrame} 10 0 136 0 -10 1 243 0 ) 					#name: #SelectorSIL 					#model: #existingSelectors ) 				#(#{InputFieldSpec} 					#layout: #(#{LayoutFrame} 10 0 270 0 -10 1 295 0 ) 					#name: #NewSelectorField 					#model: #newSelector 					#tabable: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutFrame} -82 0.5 -35 1 -16 0.5 -5 1 ) 					#name: #okButton 					#model: #doOK 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #lensDev) 					#isDefault: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutFrame} 16 0.5 -35 1 82 0.5 -5 1 ) 					#name: #cancelButton 					#model: #doAbort 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #lensDev) 					#defaultable: true ) 				#(#{MenuButtonSpec} 					#layout: #(#{Rectangle} 10 32 232 57 ) 					#name: #nameSpaceField 					#model: #nameSpace 					#menu: #nameSpaceMenu ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 10 0 32 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #NameSpace #defaultString: 'Name Space:' #catalogID: #lensDev) ) ) ) )</body></methods><methods><class-id>Lens.LinkedDetailSpec class</class-id> <category>resources</category><body package="Lens-Dev">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 7) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); at: 3 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 4 put: ColorValue white; at: 5 put: ColorValue cyan; at: 6 put: ColorValue blue; at: 7 put: ColorValue red; yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@L3L3L3L3L3L3L3L2@@@@@CDQDQDQDQDQDQDQD @@@@@1DQDQDQDQDQDQDQH@@@@@LP@@@@@@@@@@@QDR@@@@@CDEUUUUUUUUUPDQD @@@@@1@@@@@@@@@@@ADQH@@@@@LPL3L3L3L3L3@QDR@@@@@CDCL3L@@@@@@0DQD @@@@@1@0@C@3L3L0LADQH@@@@@LPL3L0@@@@@C@QDR@@@@@CDCL3L3L3L3L0DQD @@@@@1@3L5UUUUUUUUTQH@@@@@LPY&amp;MTQ@QDADQEDR@@@@@CDFY#T@@@@@@@AQD @@@@@1@6L5QDADPDQDTQH@@@@@LPM&amp;Y @@@@@@@EDR@@@@@CDCH"UDPDQ@QDQQD @@@@@1@3L%UUUUUUUUTQH@@@@@LPL3H"H"H"H"H"DR@@@@@CDCL3L3L3L3L0DQD @@@@@1@@@@@@@@@@@ADQH@@@@@LQDQDQDQDQDQDQDR@@@@@CDQDQDQDQDQDQDQD @@@@@"H"H"H"H"H"H"H"H@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body><body package="Lens-Dev">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 159 255 240 192 159 255 240 192 159 255 240 192 144 0 16 192 144 127 208 192 151 64 80 192 144 127 208 192 144 0 16 192 144 255 252 192 158 136 132 192 158 255 252 192 148 136 132 192 151 255 252 192 144 136 132 192 144 255 252 192 144 0 16 192 144 0 16 192 159 255 240 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192 ])</body><body package="Lens-Dev">selectionPopUpMenu	"UIMenuEditor new openOnClass: self andSelector: #selectionPopUpMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: #(#{UserMessage} #key: #createchilddataform #catalogID: #lens #defaultString: 'create child data form' ) ) 			#(#MenuItem 				#rawLabel: #(#{UserMessage} #key: #paintchilddataform #catalogID: #lens #defaultString: 'paint child data form' ) ) 			#(#MenuItem 				#rawLabel: #(#{UserMessage} #key: #browsechilddataform #catalogID: #lens #defaultString: 'browse child data form') ) ) #(3 ) #(#doDefineChildDataForm #doPaintChildDataForm #doBrowseChildDataForm ) ) decodeAsLiteralArray</body><body package="Lens-Dev">selectionPullDownMenu	"UIMenuEditor new openOnClass: self andSelector: #selectionPullDownMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: #(#{UserMessage} #key: #CreateChildDataForm #catalogID: #lens defaultString: 'Create Child Data Form' ) ) 			#(#MenuItem 				#rawLabel: #(#{UserMessage} #key: #PaintChildDataForm #catalogID: #lens defaultString: 'Paint Child Data Form' ) ) 			#(#MenuItem 				#rawLabel: #(#{UserMessage} #key: #BrowseChildDataForm #catalogID: #lens defaultString: 'Browse Child Data Form') ) ) #(3 ) #(#doDefineChildDataForm #doPaintChildDataForm #doBrowseChildDataForm ) ) decodeAsLiteralArray</body></methods><initialize><class-id>Lens.LensNamespaceControl</class-id></initialize><initialize><class-id>Lens.LensApplicationSpecEditor</class-id></initialize><initialize><class-id>Lens.LensApplicationCreationDialog</class-id></initialize><initialize><class-id>Lens.LensEditor</class-id></initialize><initialize><class-id>Lens.LensApplicationStructureView</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>UIPainterTool</name><environment>Tools</environment><super>Tools.UIPainterWatcher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selection selectionKind controller currentSpecCopy currentSpecBindings specChannel subBuilder lock slice lastSlice slicesMenu sliceInfo client statusBarText list sliceChanging sliceTabChanging canvasTree menuBar currentView </inst-vars><class-inst-vars></class-inst-vars><imports>			private Smalltalk.TextConstants.*			</imports><category>UIPainter-Tools</category><attributes><package>UIPainter</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>LensDataModelGenerator</name><environment>Lens</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lensDataModelHolder extractedColumnList applicationNameAdaptor dialect lensPolicy selectorNameAdaptor catalogLens defaultCategory oldDataModel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Lens-Private-Tools-Support</category><attributes><package>Lens-Runtime</package></attributes></class><class><name>LiteralBindingReference</name><environment>Kernel</environment><super>Kernel.GeneralBindingReference</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>UIPainterController</name><environment>Tools</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentMode oldPoint showGrid gridStep griddedHorizontally griddedVertically fenced primarySelection selections handles canvasHasChanged </inst-vars><class-inst-vars></class-inst-vars><imports>			private Smalltalk.TextConstants.*			</imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><class><name>UIDefiner</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>aClass initializeModels excludedBindings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock transcriptView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>SpecModel</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>specChannel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIPainter</package></attributes></class></st-source>