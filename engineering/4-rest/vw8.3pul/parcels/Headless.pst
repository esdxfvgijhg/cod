<?xml version="1.0"?><st-source><!-- Name: HeadlessNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: Contains support code necessary to run VisualWorks images headless, that is, without a GUI. Headless applications are typically used in a server environment.Further information on headless application support can be found in the "Application Developer''s Guide" (located in the /doc subdirectory of the VisualWorks installation).DevelopmentPrerequisites: #(#(#any 'Standard IO Streams' ''))IsFunctional: falsePackageName: HeadlessParcel: #('Headless')ParcelName: HeadlessPrerequisiteParcels: #(#('Standard IO Streams' ''))Version: 8.3 - 1Date: 12:05:13 PM July 28, 2017 --><time-stamp>From VisualWorksÂ®, 8.3 of July 28, 2017 on July 28, 2017 at 12:05:13 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>HeadlessFont</name><environment>Graphics</environment><super>Graphics.ImplementationFont</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>Headless</package></attributes></class><comment><class-id>Graphics.HeadlessFont</class-id><body>HeadlessFont acts as a stand-in for actual font behavior in lieu of a WindowingSystem in a HeadlessImage.</body></comment><class><name>AbstractStreamTranscript</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream transcript </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Headless-Support</category><attributes><package>Headless</package></attributes></class><comment><class-id>OS.AbstractStreamTranscript</class-id><body>AbstractStreamTranscript is an abstract superclass for classes that send Transcript output to some form of stream. Instances are intended to be dependents of Transcript.  Transcript (an instance of TextCollector) will send out change notifications (#value, #appendEntry and #update) when it has been changed.   By adding an instance of this class as a dependent to Transcript, it can respond to those messages and will store any new output to its stream instance variable.   Subclasses of AbstractStreamTranscript are used by the default instance of HeadlessImage to control where output for Transcript is directed.On instance creation, this class will set its transcript instance variable to be Transcript.    It then will refer to the instance variable when it receives the appendEntry message in order to ask the Transcript what was just written to the transcript.  If a different instance of TextCollector (other than the system global Transcript) is intended to be used, one can set it with #transcript:.Instance Variables:	stream		&lt;ReadAppendStream&gt; The stream for writing the result of nextEntry	transcript	&lt;TextCollector&gt; See above</body></comment><class><name>FileTranscript</name><environment>OS</environment><super>OS.AbstractStreamTranscript</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Headless-Support</category><attributes><package>Headless</package></attributes></class><comment><class-id>OS.FileTranscript</class-id><body>FileTranscript will set its stream instance variable to be associated with a specific filename.  To set the filename (and create the stream), use #filename: method.  The stream's encoding will be UTF8.Note, the stream is not closed automatically.  It will close automatically when the image exits, but if the file is detached without quitting the image, then users of FileTranscript are expected to send #release to an instance of FileTranscript to ensure that the stream is closedInstance Variables:	filename	&lt;Filename&gt;	The filename to use for the stream</body></comment><class><name>StandardOutTranscript</name><environment>OS</environment><super>OS.AbstractStreamTranscript</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>Headless-Support</category><attributes><package>Headless</package></attributes></class><comment><class-id>OS.StandardOutTranscript</class-id><body>When an instance of StandardOutTranscript is created, it sets its stream instance variable to be the stream associated with standard out.  Therefore, once the instance of this class is added as a dependent to Transcript it will echo Transcript's output to standard out.  For convenience, a singleton instance of StandardOutTranscript can be used be sending the class side message #current.Class Instance Variables:	current		&lt;StandardOutTranscript&gt;	A singleton instance of StandardOutTranscript</body></comment><class><name>HeadlessImage</name><environment>Core</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isTerminating startupFilename transcriptFilename currentlyHeadless shouldSaveHeadless transcriptToStandardOut transcriptToStandardOutHeadless transcriptToFile transcriptToFileHeadless suspendedProcesses stackDumpStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Headless-Support</category><attributes><package>Headless</package></attributes></class><comment><class-id>Core.HeadlessImage</class-id><body>HeadlessImage is a Subsystem that when resumed will decide whether the WindowSystem can be activated.  The instance variable, currentlyHeadless, controls the activation of WindowSystem.  When currentlyHeadless is false, none of the windows will be displayed and the image will be "headless", so that it can run in a graphic-less environment.Window system interface code checks if it can access a window system and if it can not #cannotSend will be sent to the current instance of HeadlessSystem.  In #cannotSend, the current context stack will be dumped to the Transcript.  Depending on the value of the isTerminating instance variable the image will either continue running (false) or it will suspend the process and save the image headfull.  To debug such a process, the headless image must be saved headfull and restarted. Then the process monitor can be used to debug the offending process.  On image start-up, if the image is headless it will optionally reads in a startup file.  The file must contain Smalltalk expressions in file-in format. The instance method protocol #'command-line options'  contains command line options to pass at image start-up to configure the behavior of the headless image.The Transcript might be handled differently when the image is headless versus headfull.  Depending on the return values of the methods, shouldSendTranscriptToStandardOut and shouldSendTranscriptToFile, the output for Transcript might be sent to the stream associated with standard out or a file, or both.   This occurs in the #setupTranscript method which will be called with either the BasicHeadfulGraphicsSystem or BasicHeadlessSystem is activated.Instance Variables:	isTerminating 		&lt;Boolean&gt;	If true, then whenever an error occurs that attempts to interact with the windowing system (cannotSend is sent to the default instance of HeadlessImage), save the image in a headfull state with the offending process suspended.	startupFilename		&lt;String | nil&gt; The name of the startup file. When nil, no startup file is filed in.	transcriptFilename	&lt;String | nil&gt; The name of the transcript file. When nil, no transcript file is used.	currentlyHeadless			&lt;Boolean&gt;		Indicates whether the image is currently running headless.	shouldSaveHeadless 		&lt;Boolean&gt; 	When we save this image, should it be saved as headless or not	transcriptToStandardOut 	&lt;Boolean&gt;	If true, echo Transcript output to standard out when headfull or headless.	transcriptToStandardOutHeadless 	&lt;Boolean&gt;	If true, echo Transcript output to standard out only when headless.	transcriptToFile  	&lt;Boolean&gt;	If true, echo Transcript output to a file when headfull or headless	transcriptToFileHeadless 	&lt;Boolean&gt;	If true, echo Transcript output to a file only when headless	suspendedProcesses	&lt;Dictionary of: Process&gt;	When cannotSend is sent to Headless image, the process that sent the message is saved in this dictionary	stackDumpStream 	&lt;WriteStream&gt;	Where do we dump the stack to. If nil, we use the Transcript.</body></comment><class><name>BasicHeadlessSystem</name><environment>Core</environment><super>Graphics.BasicGraphicsSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>oldNotifier headlessNotifier </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Headless</category><attributes><package>Headless</package></attributes></class><comment><class-id>Core.BasicHeadlessSystem</class-id><body>This handles early setup of a headless image. If this activates, then BasicHeadfullGraphicsSystem will not.Instance Variables:	notifier	&lt;Notifier-like-thing&gt;	What object should we install as Notifier current in order to deal with unhandled exceptions properly. This should be able to respond to #openException: and #openContext:label:proceedable.	oldNotifier	&lt;Notifier-like-thing&gt;	If we replace the notifier with our own (by default HeadlessImage current) in order to handle headless exceptions, keep track of the old one so we can either put it back or delegate to it if necessary.</body></comment><class><name>HeadlessFontPolicy</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>Headless</package></attributes></class><comment><class-id>Graphics.HeadlessFontPolicy</class-id><body>HeadlessFontPolicy stands in for the default FontPolicy behavior for a HeadlessScreen whenever an image has no WindowingSystem.</body></comment><class><name>HeadlessError</name><environment>Core</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Headless-Support</category><attributes><package>Headless</package></attributes></class><comment><class-id>Core.HeadlessError</class-id><body>The image is running headless, and this process has violated the rules of headlessness. Usually, by atttempting to access the display. </body></comment><class><name>HeadlessScreen</name><environment>Graphics</environment><super>Graphics.Screen</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Headless-Support</category><attributes><package>Headless</package></attributes></class><comment><class-id>Graphics.HeadlessScreen</class-id><body>I am a subclass of Screen for the express purpose of not activating the Screen.</body></comment><methods><class-id>Graphics.HeadlessFont</class-id> <category>accessing</category><body package="Headless">ascent	^0.</body><body package="Headless">descent	^0.</body><body package="Headless">encode: aCharacter	^0</body><body package="Headless">encodingType	^#'not for display'</body><body package="Headless">height	^0.</body><body package="Headless">isCompositeFont	^false</body><body package="Headless">name	^'not for display'.</body><body package="Headless">pixelSize	^0.</body><body package="Headless">spaceWidth	^0</body><body package="Headless">widthAt: anIndex	^0</body><body package="Headless">widthOf: aCharacter	^0</body><body package="Headless">widthTable	^#()</body></methods><methods><class-id>Graphics.HeadlessFont</class-id> <category>displaying</category><body package="Headless">displayString: string from: start to: stop at: aPoint on: aGraphicsContext 	"Render the string onto the graphicsContext"</body></methods><methods><class-id>Graphics.HeadlessFont</class-id> <category>testing</category><body package="Headless">isAccessible	"Answer whether the font can currently be used for display"	^false</body></methods><methods><class-id>Graphics.HeadlessFont</class-id> <category>installing</category><body package="Headless">installOn: aGraphicsContext</body></methods><methods><class-id>OS.AbstractStreamTranscript</class-id> <category>accessing</category><body package="Headless">stream	^stream</body><body package="Headless">stream: aStream	stream := aStream</body><body package="Headless">transcript	^transcript</body><body package="Headless">transcript: aTextCollector	transcript := aTextCollector</body></methods><methods><class-id>OS.AbstractStreamTranscript</class-id> <category>private</category><body package="Headless">appendEntry	[stream nextPutAll: transcript nextEntry asString.	stream flush] on: Error do: [:ex | ex return].</body><body package="Headless">updateContents	"This is currently only used for the Transcript clear operation. We ignore this by default."</body></methods><methods><class-id>OS.AbstractStreamTranscript</class-id> <category>initialize-release</category><body package="Headless">initialize	transcript := Transcript.</body></methods><methods><class-id>OS.AbstractStreamTranscript</class-id> <category>updating</category><body package="Headless">update: aParameter 	HeadlessImage isActive ifFalse: [^self].	aParameter == #appendEntry 		ifTrue: [^self appendEntry].	aParameter == #update		ifTrue: [^self updateContents].</body></methods><methods><class-id>OS.AbstractStreamTranscript class</class-id> <category>instance creation</category><body package="Headless">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>OS.FileTranscript</class-id> <category>initialize-release</category><body package="Headless">release	[stream close] on: Error do: [:ex | ex return].</body></methods><methods><class-id>OS.FileTranscript</class-id> <category>accessing</category><body package="Headless">filename	^filename</body><body package="Headless">filename: aFilename	filename := aFilename asFilename.	[stream := (filename withEncoding: #'utf-8') readAppendStream]		on: Error		do: [:ex |			stream := NullStream new.			ex return].</body></methods><methods><class-id>OS.FileTranscript class</class-id> <category>instance creation</category><body package="Headless">named: aStringOrFilename	^self new filename: aStringOrFilename.</body></methods><methods><class-id>OS.StandardOutTranscript</class-id> <category>initialize-release</category><body package="Headless">initialize	super initialize.	stream := OS.Stdout.</body></methods><methods><class-id>OS.StandardOutTranscript class</class-id> <category>instance creation</category><body package="Headless">current	current isNil ifTrue: [current := self new].	^current.</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>accessing</category><body package="Headless">isHeadless: aBoolean	WindowingSystem canActivate: aBoolean not.</body><body package="Headless">isTerminating: aBoolean	isTerminating := aBoolean</body><body package="Headless">shouldSaveHeadless	^shouldSaveHeadless.</body><body package="Headless">shouldSaveHeadless: aBoolean	shouldSaveHeadless := aBoolean.	DeploymentOptionsSystem current suppressSplashScreenAndHerald: aBoolean.</body><body package="Headless">stackDumpStream	stackDumpStream isNil ifTrue: [^Transcript].	^stackDumpStream</body><body package="Headless">stackDumpStream: aWriteStream	stackDumpStream := aWriteStream</body><body package="Headless">startupFilename	"Nil means no startup file whatsoever."	^startupFilename</body><body package="Headless">startupFilename: aStringOrNil 	"Nil means no startup file whatsoever."	startupFilename := aStringOrNil</body><body package="Headless">suspendedProcesses	suspendedProcesses isNil ifTrue: [suspendedProcesses := Dictionary new].	^suspendedProcesses</body><body package="Headless">transcriptFilename	"Nil means no transcript file whatsoever."	^transcriptFilename</body><body package="Headless">transcriptFilename: aStringOrNil 	"Nil means no transcript file whatsoever."	transcriptFilename := aStringOrNil</body><body package="Headless">transcriptToFile	transcriptToFile isNil ifTrue: [transcriptToFile := false].	^transcriptToFile.</body><body package="Headless">transcriptToFile: aBoolean	transcriptToFile := aBoolean</body><body package="Headless">transcriptToFileHeadless	transcriptToFileHeadless isNil ifTrue: [transcriptToFileHeadless := true].	^transcriptToFileHeadless.</body><body package="Headless">transcriptToFileHeadless: aBoolean	transcriptToFileHeadless := aBoolean.</body><body package="Headless">transcriptToStandardOut	transcriptToStandardOut == nil ifTrue: [transcriptToStandardOut := false].	^transcriptToStandardOut.</body><body package="Headless">transcriptToStandardOut: aBoolean	transcriptToStandardOut := aBoolean.</body><body package="Headless">transcriptToStandardOutHeadless	transcriptToStandardOutHeadless == nil ifTrue: [transcriptToStandardOutHeadless := true].	^transcriptToStandardOutHeadless.</body><body package="Headless">transcriptToStandardOutHeadless: aBoolean	transcriptToStandardOutHeadless := aBoolean.</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>saving</category><body package="Headless">saveHeadfull: prefix	"Returns true if we just did the snapshot, false if we are restarting the image. This saves another image headfully, but we continue to run as the image we were before. It's different this way than a normal 'save as...' operation."	^self saveHeadless: false to: prefix.</body><body package="Headless">saveHeadless: prefix	"Returns true if we just did the snapshot, false if we are restarting the image. This saves another image headless, but we continue to run as the image we were before. It's different this way than a normal 'save as...' operation."	^self saveHeadless: true to: prefix.</body><body package="Headless">saveHeadless: beHeadless to: prefix 	"Returns true if we just did the snapshot, false if we are restarting the image. Put our image prefix back the way it was if we're continuing to run."	self shouldSaveHeadless: beHeadless.	^Snapshot new saveDetachedTo: prefix thenQuit: false</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>private</category><body package="Headless">defaultDebugImageName	^ 'headless-debug'.</body><body package="Headless">defaultStartupFilename	^ 'headless-startup.st'</body><body package="Headless">defaultTranscriptFilename	^ 'headless-transcript.log'</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>actions</category><body package="Headless">pauseAction	super pauseAction.	currentlyHeadless := self isHeadless.	WindowingSystem canActivate: shouldSaveHeadless not.</body><body package="Headless">readStartupFile	| rcFile |	startupFilename isNil ifTrue: [^self].	ImageConfigurationSystem allowFilein ifFalse: [^self].	rcFile := Filename named: startupFilename.	(rcFile exists and: [rcFile isReadable])		ifTrue: [[rcFile fileIn] fork].</body><body package="Headless">resumeAction	super resumeAction.	WindowingSystem canActivate: currentlyHeadless not.	shouldSaveHeadless := currentlyHeadless.</body><body package="Headless">setUp	super setUp.	shouldSaveHeadless := false.	self isHeadless ifTrue: [		self readStartupFile].</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>testing</category><body package="Headless">isActivationInProcess	"Answer true if the system is running as a ``Smalltalk server'' within	 some process.  Answer false if the system is running as a stand-alone	 Smalltalk environment.  This will depend on whether the system was	 loaded as a DLL or shared library by some process, or not.  If the	 primitive fails then presumably the engine does not support being	 used as a DLL or shared library, so in this case return false."	&lt;primitive: 1059&gt;	^false</body><body package="Headless">isHeadless	WindowingSystem isActive ifTrue: [^false].	^WindowingSystem canActivate not.</body><body package="Headless">isTerminating	^isTerminating</body><body package="Headless">shouldSendTranscriptToFile	self transcriptFilename isNil ifTrue: [^false].	^self isHeadless		ifTrue: [self transcriptToFileHeadless]		ifFalse: [self transcriptToFile]</body><body package="Headless">shouldSendTranscriptToStandardOut	^self isHeadless 		ifTrue: [self transcriptToStandardOutHeadless]		ifFalse: [self transcriptToStandardOut]</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>initializing</category><body package="Headless">initialize	super initialize.	isTerminating := true.	self transcriptFilename: self defaultTranscriptFilename.	self startupFilename: self defaultStartupFilename.	currentlyHeadless := true.	shouldSaveHeadless := false.	transcriptToStandardOut := false.	transcriptToFile := false.	transcriptToStandardOutHeadless := true.	transcriptToFileHeadless := true.</body><body package="Headless">setupTranscript	"The Transcript is handled differently when the image is headless versus 	headful. In headless mode, the Transcript can go to either standard out, a file, or both"	"First, clean out any old file transcripts"	Transcript dependents		do:			[:each | (each isKindOf: FileTranscript) ifTrue: [Transcript removeDependent: each. each release]].	self shouldSendTranscriptToStandardOut		ifTrue:			[(Transcript dependents includes: StandardOutTranscript current)				ifFalse: [Transcript addDependent: StandardOutTranscript current]]		ifFalse: [Transcript removeDependent: StandardOutTranscript current].	self shouldSendTranscriptToFile ifTrue: [		Transcript addDependent: (FileTranscript named: self transcriptFilename)].</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>exception handling</category><body package="Headless">openContext: haltContext label: aString proceedable: aBoolean	^self isHeadless		ifTrue:			[self dumpStackToTranscript: haltContext label: aString.			self isTerminating				ifTrue: [ObjectMemory quit]				ifFalse: [Processor activeProcess terminateWithExtremePrejudice]]		ifFalse:			[self isActivationInProcess ifTrue:				[Notifier checkDump: haltContext label: aString].			BasicHeadlessSystem current oldNotifier openContext: haltContext label: aString proceedable: aBoolean]</body><body package="Headless">openException: anException	"Act as a notifier, dumping stack"	^self openContext: thisContext label: anException errorString proceedable: anException willProceed.</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>debugging</category><body package="Headless">becomeHeadfull	"WARNING: May cause stability problems.	This changes an image from headless to headful mode, manually running the things that need to be run in order to do this. Because we are running these things manually this is fragile code, and it won't take into account any possible user actions. However, it can be very useful in debugging, so we include it. See also ObjectMemory&gt;&gt;installSystemWithPriority:"	| workspace message workspaceClass |	self isHeadless ifFalse: [^self].	WindowingSystem canActivate: true.	"We must explicitly activate the basic graphics, because the things that prereq them have already activated successfully"	BasicHeadfullGraphicsSystem activate.	WindowingSystem activate.	DevelopmentSystem activate.	self setupTranscript.	Notifier beDevelopment.	message := #headlessWarning &lt;&lt; #headless &gt;&gt; 'WARNING: This image has been switched out of headless mode. It may be unstable. We recommend not saving this image and using it only for debugging. See HeadlessImage&gt;&gt;becomeHeadfull'.	workspaceClass := (#{Tools.Workspace} ifDefinedDo: [:theClass | theClass] elseDo: [#{SimpleWorkspace} valueOrDo: [Transcript cr; show: message. ^self ]]).	workspace := workspaceClass		with: message asString		labeled: #WARNING &lt;&lt; #headless &gt;&gt; 'WARNING'.	workspace open.</body><body package="Headless">debug: text	"Display the text on the Transcript, doing the right thing if it happens	to be file based. This method is provided purely as a courtesy for	debugging, and is not essential for headless operation."	Transcript cr; show: text.</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>checking head</category><body package="Headless">cannotSend	"The image is running headless, and this process has violated the	rules of headlessness. Raise the exception indicating a violation	of headlessness. If the exception is not caught, suspend and save	this process for later debugging. Optionally, save the image so it	can be debugged."	| now |	[HeadlessError raise] on: Signal noHandlerSignal		do: [:ex | ex return].	now := Time dateAndTimeNow.	self suspendedProcesses at: now put: Processor activeProcess.	Transcript 		cr;		show: '-------------------';		print: now;		show: '------';		cr;		show: thisContext printStack;		show: '---------------------------------------------------';		cr;		endEntry.	"Optionally save the image right now so it can be debugged."	isTerminating 		ifTrue: 			[			[| justSnapped |			justSnapped := self saveHeadfull: self defaultDebugImageName.			justSnapped ifTrue: [ObjectMemory quit]] 					fork].	Processor activeProcess suspend</body><body package="Headless">checkHeadless	"This method is intended to be sent from those methods that should not be 	executed in a headless environment. If the image is not running headless, 	return without side-effect; otherwise, trigger the exception mechanism."	self isHeadless ifTrue: [self cannotSend]</body><body package="Headless">dumpStackToTranscript: aContext label: aString	"Dump a stack trace to the Transcript starting at aContext. If the debugger or runtime packager dumper facilities are available, use them. Otherwise print a simple stack trace."	(self dumpStackToTranscriptUsingDebuggerService: aContext label: aString) ifTrue: [^self].	(self dumpStackToTranscriptUsingRTPDumper: aContext label: aString) ifTrue: [^self].	self dumpStackToTranscriptBasic: aContext label: aString.</body><body package="Headless">dumpStackToTranscriptBasic: aContext label: aString	"Dump a stack trace to the Transcript starting at aContext."	self stackDumpStream 		cr;		nextPutAll: '---------------------------------------------------'; cr;		nextPutAll: aString printString;		cr;		nextPutAll: aContext printStack;		nextPutAll: '---------------------------------------------------'; cr;		flush</body><body package="Headless">dumpStackToTranscriptUsingDebuggerService: aContext label: aString	"Dump a stack trace to the Transcript starting at aContext, using the PDP debugger's facilities, if they're present. Refer to them using a string so that we don't encourage the tracing mechanism to include them if it wouldn't otherwise do so."	^self dumpStackToTranscriptUsingDebuggerService: aContext label: aString stopWhen: nil.</body><body package="Headless">dumpStackToTranscriptUsingDebuggerService: aContext label: aString stopWhen: aBlock	"Dump a stack trace to the Transcript starting at aContext, using the PDP debugger's facilities, if they're present. Refer to them using a string so that we don't encourage the tracing mechanism to include them if it wouldn't otherwise do so."	| debuggerService dumpPolicy shortList |	debuggerService := Smalltalk at: 'DebuggerService' ifAbsent: [^false].	"Make up values for proceedable and interrupted. We're not planning to make use of them anyway, just dump a stack"	[ | debugger output |	  (debugger := debuggerService new) process: [] newProcess context: aContext interrupted: false.	  dumpPolicy := ContextDumpPolicy new.	  output := String new writeStream.	  dumpPolicy stream: output.	  dumpPolicy errorMessage: aString.	  shortList := self truncateContextList: debugger contextList using: aBlock.	  dumpPolicy stack: shortList.	  dumpPolicy numberToDump: shortList size.	  dumpPolicy printVerbose.	  self stackDumpStream nextPutAll: output contents; flush]		on: Error do: [:ex | self dumpStackToTranscriptBasic: ex initialContext label: 'error printing stack: ', ex description asString. ^false].	^true.</body><body package="Headless">dumpStackToTranscriptUsingRTPDumper: aContext label: aString	"Dump a stack trace to the Transcript starting at aContext using the Runtime Packager's runtime facilities. Refer to them using a string so that we don't encourage the tracing mechanism to include them if it wouldn't otherwise do so."	| rtpDumper dumper |	rtpDumper := Smalltalk at: 'RuntimePackager.RuntimeFullDumper' ifAbsent: [^false].	self stackDumpStream cr; show: aString printString.	[dumper := rtpDumper new.	dumper dumpStream: self stackDumpStream.	dumper dumpExceptionReport: nil context: aContext]		on: Error do: [:ex | self dumpStackToTranscriptBasic: ex initialContext label: 'error printing stack: ', ex description asString. ^false].	^true.</body><body package="Headless">truncateContextList: aList using: aBlock	"Truncate the list of contexts we are going to print based on some arbitrary criteria. The motivating example is to trim the stack at an unboundMethod, hiding the mechanisms of compiling and getting the code to run when they're not of interest."	| newList |	aBlock isNil ifTrue: [^aList].	newList := OrderedCollection new: aList size.	aList do: [:each |		(aBlock value: each)			ifTrue: [				newList add: each.				^newList]			ifFalse: [				newList add: each]].	^newList.</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>prerequisites</category><body package="Headless">prerequisiteSystems	^Array with: BasicSystem.</body></methods><methods><class-id>Core.HeadlessImage class</class-id> <category>accessing</category><body package="Headless">default	^self current.</body></methods><methods><class-id>Core.HeadlessImage class</class-id> <category>testing</category><body package="Headless">isHeadless	^self current isHeadless.</body></methods><methods><class-id>Core.BasicHeadlessSystem</class-id> <category>actions</category><body package="Headless">setUp	"Note that we explicitly don't call super setUp here, because our superclass is going to set up by activating exactly one of its subclasses"	HeadlessImage isHeadless		ifTrue:			[HeadlessScreen preInstall.			Notifier current == self headlessNotifier ifFalse: [oldNotifier := Notifier current].			Notifier current: self headlessNotifier]		ifFalse: [			"If we're the ones who set the notifier differently, then put it back. Otherwise leave it alone"			(Notifier current == self headlessNotifier)				ifTrue: [Notifier current: oldNotifier]].	HeadlessImage current setupTranscript.</body></methods><methods><class-id>Core.BasicHeadlessSystem</class-id> <category>accessing</category><body package="Headless">headlessNotifier	^headlessNotifier isNil ifTrue: [HeadlessImage current] ifFalse: [headlessNotifier].</body><body package="Headless">headlessNotifier: aNotifier	headlessNotifier := aNotifier</body><body package="Headless">oldNotifier	^oldNotifier.</body></methods><methods><class-id>Core.BasicHeadlessSystem</class-id> <category>testing</category><body package="Headless">canActivate	^super canActivate and: [HeadlessImage isHeadless].</body></methods><methods><class-id>Graphics.HeadlessFontPolicy</class-id> <category>accessing</category><body package="Headless">defaultFont	^HeadlessFont new.</body><body package="Headless">findFont: aQuery	^HeadlessFont new.</body><body package="Headless">graphicsDevice	^HeadlessScreen default</body><body package="Headless">preferredFontSize	^1.</body></methods><methods><class-id>Core.HeadlessError</class-id> <category>defaults</category><body package="Headless">defaultMessageText	^(#exceptHeadlessError &lt;&lt; #dialogs &gt;&gt; 'Attempted to access display in headless image').</body></methods><methods><class-id>Graphics.HeadlessScreen</class-id> <category>accessing</category><body package="Headless">bounds	"This message should never be sent when running headless."	HeadlessImage default checkHeadless.</body><body package="Headless">contentsFromUser	"From super:	Answer an Image with the contents of a user-specified area on	my screen.  The palette of the returned image may differ from the	receiver's default color palette.  For example, the captured image may	potentially use pixel values that are unallocated in the default color	palette."	"Clients have no business sending this in a headless image."	^HeadlessImage default cannotSend</body><body package="Headless">defaultColorPolicy	^PaintPolicy new</body><body package="Headless">defaultFontPolicy	^HeadlessFontPolicy new</body><body package="Headless">isOpen	"From super:	Answer whether the receiver is open."	"Since we are headless, always answer false."	^false</body></methods><methods><class-id>Graphics.HeadlessScreen</class-id> <category>user interaction</category><body package="Headless">dragShape: shape offset: offsetPoint gridPhase: gridPhasePoint gridSpacing: gridSpacingPoint boundedBy: boundsRectangleOrNil whileButton: button isDown: isDownBoolean 	"Override the Screen implementation for the purpose of trapping this 	operation when running headless"	^HeadlessImage default cannotSend</body><body package="Headless">flush	^self</body></methods><methods><class-id>Graphics.HeadlessScreen</class-id> <category>initializing</category><body package="Headless">initialize	"Don't call super initialize. Set the resolution, because it's hard-coded anyway"	resolution := 75@75.	self installPaintPolicies.</body></methods><methods><class-id>Graphics.HeadlessScreen</class-id> <category>accessing - platform names</category><body package="Headless">platformName	^'Unknown'</body></methods><methods><class-id>Graphics.HeadlessScreen class</class-id> <category>system startup</category><body package="Headless">install	"This method should be unnecessary because I assume that the	only place #install is sent to Screen is in Screen&gt;initialize.  Let's	test that assumption..."	HeadlessImage default cannotSend</body><body package="Headless">open: aNameOrNil	"Link up to a display, permitting the creation of windows and pixmaps"	"Only a single screen is currently supported."	^self new.</body><body package="Headless">preSnapshot	"From super:	Prepare to snapshot"	"When running headless, nothing needs to be done."	^self</body></methods><methods><class-id>Graphics.HeadlessScreen class</class-id> <category>class initialization</category><body package="Headless">initialize	"Do nothing. Note that Screen sends itself #install in its version	of this method. Since we do not send #install here, we don't need	to override it in this subclass."	"HeadlessScreen initialize"	^self</body></methods><methods><class-id>Graphics.HeadlessScreen class</class-id> <category>private</category><body package="Headless">registry	^Dictionary new.</body></methods><methods><class-id>Core.Process</class-id> <category>changing process state</category><body package="Headless">terminateWithExtremePrejudice	"Terminate the receiver process, by sending the Process terminateSignal.	 Handle and discard any errors encountered running unwind blocks."	"If the receiver is the active process then raise the terminateSignal	 which should be caught by the handler in Process class&gt;&gt;forBlock:priority:.	 The handler will return, causing all unwind blocks to run, and then will	 invoke finalTerminate, actually terminating the receiver."	Processor activeProcess == self ifTrue:		[[Process terminateSignal raise]			on: Error,  UnhandledException			do:				[:ex| | unwindingContext |				unwindingContext := thisContext findNextUnwindUpTo: nil.				(unwindingContext notNil				and: [unwindingContext sender notNil])					ifTrue: [thisContext terminateTo: unwindingContext sender]					ifFalse: [ex return]].		^self finalTerminate].	"If the receiver is not the active process and its suspendedContext is nil then	 it is already suspended."	suspendedContext == nil ifTrue: [^self].	"Suspend the receiver, then place a block atop the receiver's stack to	 invoke this method as the active process, and resume the receiver."	interruptProtect critical:		[| savedContext interruptContext |		myList == nil ifFalse: [self suspend].		savedContext := suspendedContext.		interruptContext := [self terminateWithExtremePrejudice] newContext.		interruptContext sender: savedContext.		suspendedContext := interruptContext.		self resume]</body></methods><methods><class-id>Kernel.ObjectMemory class</class-id> <category>deprecated</category><body package="Headless">saveHeadless: beHeadless to: imageFilePrefix	^HeadlessImage default saveHeadless: beHeadless to: imageFilePrefix.</body></methods><methods><class-id>Tools.Notifier class</class-id> <category>private</category><body package="Headless">checkDump: aContext label: labelText	"Check if we should dump a stack trace to a file."	UHEFilename isNil ifTrue: [^self].	[| file |	 [file := UHEFilename asFilename newReadWriteStream.	  file cr; nextPutAll: 'DUMP:'; cr; nextPutAll: labelText; cr; cr.	  file nextPutAll: aContext printStack]			ensure: [file close]]		on: Object errorSignal		do: [:ex| ex return].	"UHEFilename := 'uhedump.txt'.	self checkDump: thisContext label: 'thisContext'.	UHEFilename := nil"</body></methods><methods><class-id>Core.HeadlessImage</class-id> <category>command-line options</category><body package="Headless">listAllOptions	"List all available command-line options in the system"	&lt;option: '-listOptions'&gt;	| sortedSubsystems options alreadyProcessedOptions |	Stdout		nextPutAll: 'VisualWorks command-line options summary (case-insensitive):';		cr.	alreadyProcessedOptions := Set new.	sortedSubsystems := Subsystem withAllSubclasses asSortedCollection: [:a :b | a name &lt;= b name].	sortedSubsystems do: [:each |		options := each current commandLineOptions.		options := options reject: [:eachOption | alreadyProcessedOptions includes: eachOption option].		options := options asSortedCollection: [:a :b | a option &lt;= b option].		options isEmpty ifFalse: [			Stdout cr; nextPutAll: '  ', each name, ':'; cr.			options do: [:eachOption |				Stdout nextPutAll: '    ', eachOption option; cr]].		options do: [:eachOption | alreadyProcessedOptions add: eachOption option]].	Stdout flush.	ObjectMemory quit.</body><body package="Headless">noStartupFile	&lt;option: '-nohlstrc'&gt;	startupFilename := nil.</body><body package="Headless">noTerminateOnErrorOption	&lt;option: '-no-terminate-on-error'&gt;	self isTerminating: false.</body><body package="Headless">startupFileName: aStream	&lt;option: '-hlstrc'&gt;	| fileNames |	fileNames := CommandLineInterest argumentsFrom: aStream.	fileNames isEmpty ifFalse: [		startupFilename := fileNames first].</body><body package="Headless">terminateOnErrorOption	&lt;option: '-terminate-on-error'&gt;	self isTerminating: true.</body></methods><methods><class-id>Core.FinalizationSystem</class-id> <category>prerequisites</category><body package="Headless">headlessPrerequisite	&lt;prerequisites&gt;	^Array with: HeadlessImage.</body></methods><methods><class-id>Graphics.BasicGraphicsSystem</class-id> <category>command-line options</category><body package="Headless">headless	"Run without a windowing system. Note that we allow setting headless/headfull from a command-line option, but only on real startup. If we're setting up one of these systems later on, ignore the option."	&lt;option: '-headless'&gt;	EarlyInterestNotificationSystem isActive ifFalse: [		HeadlessImage default isHeadless: true].</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - file</category><body package="Headless">menuItemFileSaveHeadlessImageAs	&lt;vwPrivileged&gt;	&lt;menuItemForCommand: #saveHeadlessImageAs		nameKey: nil		menu: #(#menuBar #file)		position: 30.1&gt;	| prefix |	prefix := Snapshot new getImagePrefix.	prefix isEmpty ifTrue: [^self].	HeadlessImage current saveHeadless: prefix.</body></methods><methods><class-id>Graphics.BasicGraphicsSystem</class-id> <category>command-line options</category><body package="Headless">transcriptFileName: aStream 	&lt;option: '-transcript'&gt;	| fileNames |	fileNames := CommandLineInterest argumentsFrom: aStream.	fileNames do: 			[:each | 			each asUppercase = 'STDOUT' 				ifTrue: [					HeadlessImage current 						transcriptToStandardOut: true;						transcriptToStandardOutHeadless: true]				ifFalse: [					HeadlessImage current 							transcriptToFile: true;						transcriptToFileHeadless: true;						transcriptFilename: each]]</body><body package="Headless">nogui	"Run without a windowing system"	&lt;option: '-nogui'&gt;	self headless.</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - launcher</category><body package="Headless">saveHeadlessImageAsCommand	&lt;command: #saveHeadlessImageAs&gt;	^Command		label: (#saveHeadlessAsDot &lt;&lt; #menus &gt;&gt; 'Save Headless As...')		group: #launcher		bindings: #()</body></methods><methods><class-id>Graphics.BasicGraphicsSystem</class-id> <category>command-line options</category><body package="Headless">gui	"Run with a windowing system"	&lt;option: '-gui'&gt;	self headful.</body></methods><methods><class-id>Graphics.WindowingSystem</class-id> <category>prerequisites</category><body package="Headless">headlessPrerequisite	&lt;prerequisites&gt;	^Array with: HeadlessImage.</body></methods><methods><class-id>Graphics.BasicGraphicsSystem</class-id> <category>command-line options</category><body package="Headless">headful	"Run with a windowing system. Note that we allow setting headless/headfull from a command-line option, but only on real startup. If we're setting up one of these systems later on, ignore the option."	&lt;option: '-headfull'&gt;	&lt;option: '-headful'&gt;	EarlyInterestNotificationSystem isActive ifFalse: [		HeadlessImage default isHeadless: false].</body></methods><initialize><class-id>Graphics.HeadlessScreen</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Subsystem</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state canActivate prerequisites </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class><class><name>WindowingSystem</name><environment>Graphics</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>Screen</name><environment>Graphics</environment><super>Graphics.HostGraphicsDevice</super><private>false</private><indexed-type>none</indexed-type><inst-vars>boundingBox subRegions resolution rendererName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>ImplementationFont</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>Graphics-Fonts</package></attributes></class><class><name>Process</name><environment>Core</environment><super>Core.Link</super><private>false</private><indexed-type>none</indexed-type><inst-vars>suspendedContext priority myList systemRecords interruptProtect environment isSystem name debugger locale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>FinalizationSystem</name><environment>Core</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class><class><name>BasicGraphicsSystem</name><environment>Graphics</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class></st-source>