<?xml version="1.0"?><st-source><!-- Name: Compression-ZLibNotice: Copyright 2008-2015 Cincom Systems, Inc.  All rights reserved.Comment: Contains classes to support compressing and decompressing zlib data streams.    The zlib library is included in the object engine to enable image decompression on loading.  ZLibInterface provides the interface to the library.  GZipReadStream and GZipWriteStream use ZLibInterface to provide the ability to decompress or compress a stream.  See the class comments for futher details.For performance, our implementation exploits an undocumented feature of zlib that can suppress the header and checksum generation:  see comments in implementors of #windowBits for more information.  This method can be overridden (e.g. in subclasses) to restore the default behaviour if desired (e.g. when compressing PDF streams).Further information about the zlib library can be found at, http://www.gzip.org/DbIdentifier: bear73DbTrace: 467885DbUsername: lkooymanDbVersion: 8.1 - 2DevelopmentPrerequisites: #(#(#any 'DLLCC' ''))PackageName: Compression-ZLibParcel: #('Compression-ZLib')ParcelName: Compression-ZLibPrintStringCache: (8.1 - 2,lkooyman)Version: 8.1 - 2Date: 1:23:31 PM June 26, 2015 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.1 (jun15.4) of June 26, 2015 on June 26, 2015 at 1:23:31 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>ZLib</name><environment>OS</environment><private>false</private><imports>			Core.*			External.*			OS.*			</imports><category>Net-Namespace</category><attributes><package>Compression-ZLib</package></attributes></name-space><comment><name-space-id>OS.ZLib</name-space-id><body>The ZLib NameSpace contains the VisualWorks ZLib library interface and supporting classes.</body></comment><class><name>InflateStream</name><environment>OS.ZLib</environment><super>Core.ReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputBuffer inputLimit interface sourceStream superPosition eof </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Compression-ZLib</category><attributes><package>Compression-ZLib</package></attributes></class><comment><class-id>OS.ZLib.InflateStream</class-id><body>InflateStream is a stream that decompresses using the same zlib facilities the engine uses to decompress compressed images.  InflateStreams are created on some input ByteArray or read stream answering bytes.  Reading the stream answers the decompressed form of the compressed data in the original collection or stream.  By default the data are a stream of bytes, but if sent text the stream will supply a stream of single-byte characters.Internally, the stream's collection is the output buffer and is used to hold a BufferSize's worth of decompressed data for accessing via next et al by clients of the stream.  The output bufffer is filled on demand from pastEnd.  position is therefore only the position into the output buffer, not the actual position in the output stream.subclass responsibilities	checkHeaderInstance Variables:	inputBuffer	&lt;ByteArray&gt; fixed-space buffer for passing input from the sourceStream to the decompression routines, i.e. it contains chunks of the compressed data	inputLimit	&lt;Integer&gt; index of the last valid data in inputBuffer	interface	&lt;ZLibInterface&gt; the external interface to the ZLib C code in the engine	sourceStream	&lt;ReadStream&gt; the data to decompress	superPosition	&lt;Integer&gt; the position in the decompressed output	eof	&lt;Boolean&gt; an flag indicating whether we have reached the end of the compressed data (i.e. ZLib signalled Z_STREAM_END)Shared Class Variables:	BufferSize	&lt;Integer&gt; maximum number of bytes to be processed with one zlib call</body></comment><class><name>GZipReadStream</name><environment>OS.ZLib</environment><super>OS.ZLib.InflateStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>checkCrc crc </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Compression-ZLib</category><attributes><package>Compression-ZLib</package></attributes></class><comment><class-id>OS.ZLib.GZipReadStream</class-id><body>GZipReadStream is a concrete subclass of InflateStream that decompresses data in the format used by gzip.  GZip's home site is http://www.gzip.org/.  To use, create a stream on some compressed data in gzip format and read from the stream to get decompressed data.  For example	| input |	(input := 'myfile.gz' asFilename readStream) binary.	(GZipReadStream on: input) contents</body></comment><class><name>DeflateStream</name><environment>OS.ZLib</environment><super>Core.WriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outputBuffer interface destinationStream compressionLevel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Compression-ZLib</category><attributes><package>Compression-ZLib</package></attributes></class><comment><class-id>OS.ZLib.DeflateStream</class-id><body>DeflateStream is an abstract read stream that compresses byte streams using the same zlib facilities the engine uses to decompress compressed images.  A DeflateStream is created on some sequenceable collection of bytes (e.g. ByteArray) or write stream of bytes.  Writing to the stream via nextPut: et al causes compressed data to be written to the collection or stream.  By default the data are a stream of bytes, but if sent text the stream will accept a stream of single-byte characters.Internally, the stream's collection is the input buffer and is used to hold up to a BufferSize's worth of uncompressed data for accessing via nextPut: et al by clients of the stream.  Its concrete subclasses add the decoding of appropriate header information.subclass responsibilities	writeHeader	finishOutputInstance Variables:	outputBuffer	&lt;ByteArray&gt;	fixed-space buffer for passing output from the compression routines to the destinationStream	interface	&lt;ZLibInterface&gt;	the external interface to the ZLib C code in the engine	destinationStream	&lt;WriteStream&gt;	the stream holding the compressed data	compressionLevel	&lt;Integer | nil&gt;	the compression level to use in compressing the input dataShared Class Variables:	BufferSize	&lt;Integer&gt; maximum number of bytes to be processed with one zlib call</body></comment><class><name>GZipWriteStream</name><environment>OS.ZLib</environment><super>OS.ZLib.DeflateStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>crc </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Compression-ZLib</category><attributes><package>Compression-ZLib</package></attributes></class><comment><class-id>OS.ZLib.GZipWriteStream</class-id><body>GZipWriteStream is a concrete subclass of DeflateStream that compresses data in the format used by gzip.  GZip's home site is http://www.gzip.org/.  To use, create a GZipWriteStream on some output stream or data write to the GZipWrite stream to store compressed data on the output stream.	| output |	(output := 'myfile.gz' asFilename writeStream) binary.	(GZipWriteStream bestCompressionOn: output) nextPutAll: 'hello world' asByteArray readStream; close</body></comment><class><name>ZLibInterface</name><environment>OS.ZLib</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>zstream errno heap </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.ZLib.ZLibInterfaceDictionary.*			</imports><category>Compression-ZLib</category><attributes><includeFiles><item>zlib.h</item></includeFiles><includeDirectories><item>/usr/include</item></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Compression-ZLib</package></attributes></class><comment><class-id>OS.ZLib.ZLibInterface</class-id><body>ZLibInterface provides a low level binding to the zlib library which is included in the engine to support image decompression on loading.  ZLib is written by Jean-loup Gailly and Mark Adler.  ZLib's home site is http://www.gzip.org/zlib/ and is described in http://www.gzip.org/zlib/manual.html.The data format used by the zlib library is described by RFCs (Request for Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).The clients of this class must have a thorough understanding of the zlib library and its appropriate use.  We recommend you make use of the compression streams InflateStream, DeflateStream and their subclasses.</body></comment><shared-variable><name>BufferSize</name><environment>OS.ZLib.InflateStream</environment><private>false</private><constant>true</constant><category>constants</category><initializer>16384</initializer><attributes><package>Compression-ZLib</package></attributes></shared-variable><shared-variable><name>GZipDeflated</name><environment>OS.ZLib</environment><private>false</private><constant>true</constant><category>Constants</category><initializer>		"Compression method"		16r8</initializer><attributes><package>Compression-ZLib</package></attributes></shared-variable><shared-variable><name>GZipReservedFlags</name><environment>OS.ZLib</environment><private>false</private><constant>true</constant><category>Constants</category><initializer>		"Reserved" 		16rC0</initializer><attributes><package>Compression-ZLib</package></attributes></shared-variable><shared-variable><name>GZipAsciiFlag</name><environment>OS.ZLib</environment><private>false</private><constant>true</constant><category>Constants</category><initializer>		"Contents is ASCII"		16r1</initializer><attributes><package>Compression-ZLib</package></attributes></shared-variable><shared-variable><name>GZipExtraField</name><environment>OS.ZLib</environment><private>false</private><constant>true</constant><category>Constants</category><initializer>		"Archive has extra fields"		16r4</initializer><attributes><package>Compression-ZLib</package></attributes></shared-variable><shared-variable><name>ZLibInterfaceDictionary</name><environment>OS.ZLib</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>Compression-ZLib</package></attributes></shared-variable><shared-variable><name>GZipContinueFlag</name><environment>OS.ZLib</environment><private>false</private><constant>true</constant><category>Constants</category><initializer>		"Part of a multi-part archive"		16r2</initializer><attributes><package>Compression-ZLib</package></attributes></shared-variable><shared-variable><name>GZipNameFlag</name><environment>OS.ZLib</environment><private>false</private><constant>true</constant><category>Constants</category><initializer>		"Archive has original file name"		16r8</initializer><attributes><package>Compression-ZLib</package></attributes></shared-variable><shared-variable><name>GZipEncryptFlag</name><environment>OS.ZLib</environment><private>false</private><constant>true</constant><category>Constants</category><initializer>		"Archive is encrypted"		16r20</initializer><attributes><package>Compression-ZLib</package></attributes></shared-variable><shared-variable><name>GZipMagic</name><environment>OS.ZLib</environment><private>false</private><constant>true</constant><category>Constants</category><initializer>		"GZIP magic number"		16r8B1F</initializer><attributes><package>Compression-ZLib</package></attributes></shared-variable><shared-variable><name>GZipCommentFlag</name><environment>OS.ZLib</environment><private>false</private><constant>true</constant><category>Constants</category><initializer>		"Archive has comment"		16r10</initializer><attributes><package>Compression-ZLib</package></attributes></shared-variable><shared-variable><name>BufferSize</name><environment>OS.ZLib.DeflateStream</environment><private>false</private><constant>true</constant><category>constants</category><initializer>16384</initializer><attributes><package>Compression-ZLib</package></attributes></shared-variable><shared-variable><name>HeapCache</name><environment>OS.ZLib.ZLibInterface</environment><private>false</private><constant>false</constant><category>cache</category><initializer>Dictionary new</initializer><attributes><package>Compression-ZLib</package></attributes></shared-variable><shared-variable><name>HeapMutex</name><environment>OS.ZLib.ZLibInterface</environment><private>false</private><constant>false</constant><category>cache</category><initializer>Semaphore forMutualExclusion</initializer><attributes><package>Compression-ZLib</package></attributes></shared-variable><shared-variable><name>HeapSize</name><environment>OS.ZLib.ZLibInterface</environment><private>false</private><constant>true</constant><category>constants</category><initializer>"ZLib limits its memory usage to 256K.  We allow an				additional 32k for heap overhead; a 12.5% overhead."			9 * 32 * 1024</initializer><attributes><package>Compression-ZLib</package></attributes></shared-variable><methods><class-id>OS.ZLib.InflateStream</class-id> <category>testing</category><body package="Compression-ZLib">atEnd	"Answer true if the position is greater than or equal to the limit, 	otherwise answer false. "	^self basicAtEnd and: [self endTest]</body></methods><methods><class-id>OS.ZLib.InflateStream</class-id> <category>private</category><body package="Compression-ZLib">basicAtEnd	"Answer true if the position is greater than or equal to the limit,	otherwise answer false. Fail if position or readLimit is not a SmallInteger and answer true.	Only called by atEnd which will continue processing if true is returned in order to	handle streaming across buffer boundries."	&lt;primitive: 67&gt;	^true</body><body package="Compression-ZLib">checkHeader	self subclassResponsibility</body><body package="Compression-ZLib">endTest	"Answer true if the receiver is at the end of the data, if not get the next buffer.	Used by atEnd"	position &lt; readLimit ifTrue: [^false].	self nextBuffer ifFalse:		[^true].	^position = readLimit</body><body package="Compression-ZLib">fillInputBuffer	"Fill the input buffer with as much data as possible.	 First move any unconsumed data to the beginning of the buffer,	 then read into the buffer if there is room, and reset the input pointers."	| remaining consumed |	(remaining := interface avail_in) &gt; 0 ifTrue:		[consumed := interface next_in datum - inputBuffer fixedHeapAddress.		 consumed &gt; 0 ifTrue:			[inputBuffer replaceFrom: 1 to: remaining with: inputBuffer startingAt: consumed + 1.			 inputLimit := remaining]].	remaining &lt; BufferSize ifTrue:		[[sourceStream next: BufferSize - remaining into: inputBuffer startingAt: remaining + 1.		  inputLimit := BufferSize]			on: IncompleteNextCountError			do: [:ex| inputLimit := ex parameter + remaining]].	interface		next_in: inputBuffer fixedHeapAddress;		avail_in: inputLimit</body><body package="Compression-ZLib">nextBuffer	| result |	interface next_out datum = 0 ifTrue:		[interface			next_out: collection fixedHeapAddress;			avail_out: BufferSize].	(interface avail_out &gt; 0 and: [eof not]) ifTrue:		[self fillInputBuffer.		 superPosition := interface total_out.		 eof := (result := interface inflateNoFlush) = interface Z_STREAM_END].	readLimit := interface next_out datum - collection fixedHeapAddress.	interface next_out: 0.	position := 0.	^readLimit &gt; 0</body><body package="Compression-ZLib">on: aCollectionOrStream 	sourceStream := aCollectionOrStream isSequenceable 				ifTrue: [aCollectionOrStream readStream]				ifFalse: [aCollectionOrStream].	self setupBufferAndLimits.	self checkHeader</body><body package="Compression-ZLib">pastEnd	"Raise a signal if the receiver is at the end of the data, if not get the next buffer	and return the next element."	position &lt; readLimit ifTrue:		[^collection at: (position := position + 1)].	^self nextBuffer 		ifTrue: [collection at: (position := position + 1)]		ifFalse: [self class endOfStreamSignal raiseRequestFrom: self]</body><body package="Compression-ZLib">setupBufferAndLimits	"Initialize the ioBuffer and limits."	| result |	interface := ZLibInterface newUsingEngineAllocator.	inputBuffer := interface class cachedHeap: BufferSize.	collection := interface class cachedHeap: BufferSize.	result := interface		cInflateInit2: interface zstream		windowBits: self windowBits		version: interface version		streamSize: interface z_stream dataSize.	result ~= interface Z_OK ifTrue:		[self error: #ZlibInflateInit2Failed &lt;&lt; #dialogs &gt;&gt; 'zlib inflateInit2 initialization failed'].	position := superPosition := 0.	readLimit := 0.	writeLimit := -1.	eof := false</body><body package="Compression-ZLib">windowBits	"The windowBits parameter is the base two logarithm of the window size (the size of the history buffer).  It should be in the range 8..15 for this version of the library.  The default value is 15 for inflateInit.  Using negative windowBits is an undocumented feature of zlib to suppress the header and checksum checks."	^interface MAX_WBITS negated</body></methods><methods><class-id>OS.ZLib.InflateStream</class-id> <category>accessing</category><body package="Compression-ZLib">contents	| contents |	contents := (self contentsSpecies new: sourceStream size) writeStream.	[self atEnd] whileFalse: [contents nextPut: self next].	^contents contents</body><body package="Compression-ZLib">next: anInteger into: aSequenceableCollection startingAt: startIndex 	"Store the next anInteger elements of the receiver into aSequenceableCollection 	 starting at startIndex in aSequenceableCollection. Answer aSequenceableCollection."	| howManyRead increment newHowManyRead |	howManyRead := 0.	[howManyRead &lt; anInteger] whileTrue:		[self atEnd ifTrue:			[^Stream incompleteNextCountSignal raiseRequestWith: howManyRead].		increment := (readLimit - position) min: (anInteger - howManyRead).		newHowManyRead := howManyRead + increment.		aSequenceableCollection			replaceFrom: startIndex + howManyRead			to: startIndex - 1 + newHowManyRead			with: collection			startingAt: position + 1.		position := position + increment.		howManyRead := newHowManyRead].	^aSequenceableCollection</body><body package="Compression-ZLib">sourceStream	^sourceStream</body></methods><methods><class-id>OS.ZLib.InflateStream</class-id> <category>positioning</category><body package="Compression-ZLib">position	"Answer the receiver's position."		^position + superPosition</body><body package="Compression-ZLib">position: anInteger	self error: 'decompression streams are not positionable'</body><body package="Compression-ZLib">skip: anInteger	"Set position to position+anInteger, reading the next buffer if necessary."		| howManyRead increment |	howManyRead := 0.	[howManyRead &lt; anInteger] whileTrue:		[self atEnd ifTrue:			[^Stream incompleteNextCountSignal raiseRequestWith: howManyRead].		"The brackets in the next line are unnecessary, but left in for clarity."		increment := (readLimit - position) min: (anInteger - howManyRead).		position := position + increment.		howManyRead := howManyRead + increment].</body></methods><methods><class-id>OS.ZLib.InflateStream</class-id> <category>nonhomogeneous positioning</category><body package="Compression-ZLib">padTo: bsize 	"Pad (skip) to next boundary of bsize characters, and answer how many characters	were skipped."	| rem |	rem := bsize - (self position \\ bsize).	rem = bsize ifTrue: [^0].	self skip: rem.	^rem</body></methods><methods><class-id>OS.ZLib.InflateStream</class-id> <category>stream modes</category><body package="Compression-ZLib">binary	"Change the stream to receive bytes.  Note that the following	 test avoids changing collection's class when collection is nil."	(collection isKindOf: ByteEncodedString) ifTrue: [collection changeClassTo: ByteArray]</body><body package="Compression-ZLib">text	"Change the stream to receive characters.  Note that the following	 test avoids changing collection's class when collection is nil."	collection class == ByteArray ifTrue: [collection changeClassTo: String defaultPlatformClass]</body></methods><methods><class-id>OS.ZLib.InflateStream</class-id> <category>status</category><body package="Compression-ZLib">close	self sourceStream close.	interface release.	interface class releaseHeap: inputBuffer.	interface class releaseHeap: collection.</body></methods><methods><class-id>OS.ZLib.GZipReadStream</class-id> <category>accessing</category><body package="Compression-ZLib">checkCrc: aBoolean	checkCrc := aBoolean</body><body package="Compression-ZLib">crc	^crc</body></methods><methods><class-id>OS.ZLib.GZipReadStream</class-id> <category>private</category><body package="Compression-ZLib">checkCrcAndLength	"This class futzing is insanity; see AR46615"	| fileCrcAndLength endOfCompressedInput |	fileCrcAndLength := UninterpretedBytes new: 8.	endOfCompressedInput := interface next_in datum - inputBuffer fixedHeapAddress.	inputLimit - endOfCompressedInput &gt;= 8		ifTrue: [ fileCrcAndLength replaceBytesFrom: 1 to: 8 with: inputBuffer startingAt: endOfCompressedInput  + 1 ]		ifFalse: [ | footerSplit |			"This means that some (possibly none) of the footer (crcAndLength) is already in the input buffer and some is still sitting in the sourceStream. We need to figure out what is the split and put the two pieces together. It's also possible to just skip back in the sourceStream based on the split value, but I don't think that imposing positionability on the sourceStream just to make this one bit a little easier is worth it."			footerSplit := inputLimit - endOfCompressedInput. "how much of the footer is already in the inputBuffer"			fileCrcAndLength replaceBytesFrom: 1 to: footerSplit with: inputBuffer startingAt: endOfCompressedInput + 1.			sourceStream next: 8 - footerSplit into: fileCrcAndLength startingAt: footerSplit + 1].	crc ~= (fileCrcAndLength unsignedLongAt: 1 bigEndian: false) ifTrue:		[self error: 'file crc error'].	interface total_out ~= (fileCrcAndLength unsignedLongAt: 5 bigEndian: false) ifTrue:		[self error: 'file length error']</body><body package="Compression-ZLib">checkHeader	| header flags |	checkCrc := true.	crc := interface cCrc32: 0 buffer: 0 length: 0.	header := (sourceStream next: 10) asByteArray.	((header at: 1) ~= (GZipMagic digitAt: 1)	or: [(header at: 2) ~= (GZipMagic digitAt: 2)	or: [(header at: 3) ~= GZipDeflated]]) ifTrue:		[self error: 'input stream is not in gzip format'.		 ^false].	flags := header at: 4.	(flags anyMask: GZipEncryptFlag) ifTrue:		[self error:'Cannot decompress encrypted stream'.		 ^false].	(flags anyMask: GZipReservedFlags) ifTrue:		[self error:'Cannot decompress stream with unknown flags'.		 ^false].	(flags anyMask: GZipContinueFlag) ifTrue: "Number of multi-part archive - ignored"		[sourceStream next; next]. 	(flags anyMask: GZipExtraField) ifTrue: "Extra fields - ignored"		[sourceStream next: sourceStream nextWord].	(flags anyMask: GZipNameFlag) ifTrue: "Original file name - ignored"		[sourceStream skipThrough: 0].	(flags anyMask: GZipCommentFlag) ifTrue: "Comment - ignored"		[sourceStream skipThrough: 0].	^true</body><body package="Compression-ZLib">nextBuffer	| notAtEnd |	notAtEnd := super nextBuffer.	checkCrc ifTrue:		[readLimit &gt; 0 ifTrue:			[crc := interface cCrc32: crc buffer: collection fixedHeapAddress length: readLimit].		 notAtEnd ifFalse:			[self checkCrcAndLength]].	^notAtEnd</body></methods><methods><class-id>OS.ZLib.DeflateStream</class-id> <category>testing</category><body package="Compression-ZLib">atEnd	"The receiver is always at the end."	^true</body></methods><methods><class-id>OS.ZLib.DeflateStream</class-id> <category>accessing</category><body package="Compression-ZLib">compressionLevel	compressionLevel == nil ifTrue:		[compressionLevel := ZLibInterface Z_DEFAULT_COMPRESSION].	^compressionLevel</body><body package="Compression-ZLib">compressionLevel: anInteger	(anInteger between: ZLibInterface Z_BEST_SPEED and: ZLibInterface Z_BEST_COMPRESSION) ifFalse:		[self error: 'invalid compression level'].	compressionLevel := anInteger</body><body package="Compression-ZLib">flush	"Write any unwritten information."	self writeBuffer: true</body><body package="Compression-ZLib">next: anInteger putAll: aSequenceableCollection startingAt: startIndex 	"Store the anInteger elements of aSequenceableCollection starting	at startIndex into the next anInteger elements of the receiver.	Answer aSequenceableCollection"	| howManyWritten |	anInteger &gt; 1 ifFalse:		[anInteger = 1 ifTrue: [self nextPut: (aSequenceableCollection at: startIndex)].		^aSequenceableCollection].	position &gt;= writeLimit ifTrue: [self writeBuffer: false].	howManyWritten := 0.	[| increment newPosition |	increment := (writeLimit - position) min: (anInteger - howManyWritten).	newPosition := position + increment.	collection			replaceFrom: position + 1			to: newPosition			with: aSequenceableCollection			startingAt: startIndex + howManyWritten.	position := newPosition.	howManyWritten := howManyWritten + increment.	howManyWritten &lt; anInteger] whileTrue:		[self writeBuffer: false].	^aSequenceableCollection</body><body package="Compression-ZLib">nextPutBufferFrom: aStream	"Read the next buffer's worth from aStream.  Avoid copying overhead by reading	 directly into the collection if possible."	position &gt; 0 ifTrue: [self writeBuffer: false].	[aStream next: BufferSize into: collection startingAt: 1.	 position := BufferSize]		on: IncompleteNextCountError		do: [:ex| position := ex parameter].	self writeBuffer: aStream atEnd</body></methods><methods><class-id>OS.ZLib.DeflateStream</class-id> <category>private</category><body package="Compression-ZLib">finishBuffer	| result |	self writeBuffer: false.	[	interface avail_out &lt; BufferSize ifTrue: [			destinationStream next: BufferSize - interface avail_out putAll: outputBuffer startingAt: 1.			interface next_out: outputBuffer fixedHeapAddress; avail_out: BufferSize].		result := interface cDeflate: interface zstream flush: interface Z_FINISH.		(result ~= interface Z_OK and: [result ~= interface Z_STREAM_END]) ifTrue: [			"ignore the second of two consecutive flushes:"			(interface avail_out == BufferSize and: [result = interface Z_BUF_ERROR])				ifTrue: [result := interface Z_OK]				ifFalse: [self error: #ZLibDeflateError &lt;&lt; #dialogs &gt;&gt; 'deflate error']].		interface avail_out ~= BufferSize or: [result ~= interface Z_STREAM_END]	] whileTrue.</body><body package="Compression-ZLib">finishOutput	self subclassResponsibility</body><body package="Compression-ZLib">on: aCollectionOrStream	destinationStream := (aCollectionOrStream isSequenceable) 					ifTrue: [aCollectionOrStream writeStream]					ifFalse:[aCollectionOrStream].	self writeHeader.	self setupBufferAndLimits</body><body package="Compression-ZLib">on: aCollectionOrStream compressionLevel: anInteger	self compressionLevel: anInteger.	self on: aCollectionOrStream</body><body package="Compression-ZLib">pastEndPut: anObject 	"Compress (flush) the collection."	self writeBuffer: false.	self nextPut: anObject</body><body package="Compression-ZLib">setupBufferAndLimits	"Initialize the ioBuffer and limits."	| result |	interface := ZLibInterface newUsingEngineAllocator.	outputBuffer := interface class cachedHeap: BufferSize.	collection := interface class cachedHeap: BufferSize.	result := interface		cDeflateInit2: interface zstream		level: self compressionLevel		method: interface Z_DEFLATED		windowBits: self windowBits		memLevel: interface DEF_MEM_LEVEL		strategy: interface Z_DEFAULT_STRATEGY		version: interface version		streamSize: interface z_stream dataSize.	result ~= interface Z_OK ifTrue:		[self error: 'zlib deflateInit: initialization failed'].	interface		next_out: outputBuffer fixedHeapAddress;		avail_out: BufferSize.	position := 0.	readLimit := -1.	writeLimit := BufferSize</body><body package="Compression-ZLib">windowBits	"The windowBits parameter is the base two logarithm of the window size (the size of the history buffer).  It should be in the range 8..15. Larger values of this parameter result in better compression at the expense of memory usage.  The default value is 15 for deflateInit.  Using negative windowBits is an undocumented feature of zlib to suppress the header and checksum generation."	^interface MAX_WBITS negated</body><body package="Compression-ZLib">writeBuffer: flush	| result maxedOut |	maxedOut := false.	interface avail_in: position; next_in: collection fixedHeapAddress.	[interface avail_in &gt; 0 or: [maxedOut]] whileTrue:		[result := interface cDeflate: interface zstream flush: (flush ifTrue: [ interface Z_SYNC_FLUSH ] ifFalse: [ interface Z_NO_FLUSH ]).		 maxedOut := interface avail_out = 0.		 (result = interface Z_OK or: [result = interface Z_BUF_ERROR and: [maxedOut]]) ifFalse:			[self error: #ZLibDeflateError &lt;&lt; #dialogs &gt;&gt; 'deflate error'].		 interface avail_out &lt; BufferSize ifTrue:			[destinationStream next: BufferSize - interface avail_out putAll: outputBuffer startingAt: 1.			 interface next_out: outputBuffer fixedHeapAddress; avail_out: BufferSize]].	position := 0.	writeLimit := BufferSize.	flush ifTrue: [ destinationStream flush ]</body><body package="Compression-ZLib">writeHeader	self subclassResponsibility</body></methods><methods><class-id>OS.ZLib.DeflateStream</class-id> <category>positioning</category><body package="Compression-ZLib">position	"Answer the receiver's position."		^position + interface total_in</body><body package="Compression-ZLib">position: anInteger	self error: 'compression streams are not positionable'</body></methods><methods><class-id>OS.ZLib.DeflateStream</class-id> <category>stream modes</category><body package="Compression-ZLib">binary	"Change the stream to receive bytes.  Note that the following	 test avoids changing collection's class when collection is nil."	(collection isKindOf: ByteEncodedString) ifTrue: [collection changeClassTo: ByteArray]</body><body package="Compression-ZLib">text	"Change the stream to receive characters.  Note that the following	 test avoids changing collection's class when collection is nil."	collection class == ByteArray ifTrue: [collection changeClassTo: String defaultPlatformClass]</body></methods><methods><class-id>OS.ZLib.DeflateStream</class-id> <category>status</category><body package="Compression-ZLib">close	"Close the destination stream and write any unwritten information."	self finishBuffer.	self finishOutput.	destinationStream close.	interface release.	interface class releaseHeap: outputBuffer.	interface class releaseHeap: collection.</body></methods><methods><class-id>OS.ZLib.DeflateStream class</class-id> <category>instance creation</category><body package="Compression-ZLib">bestCompressionOn: aCollectionOrStream	^self basicNew on: aCollectionOrStream compressionLevel: ZLibInterface Z_BEST_COMPRESSION</body><body package="Compression-ZLib">on: aCollectionOrStream compressionLevel: anInteger	^self basicNew on: aCollectionOrStream compressionLevel: anInteger</body></methods><methods><class-id>OS.ZLib.GZipWriteStream</class-id> <category>private</category><body package="Compression-ZLib">finishOutput	| total_in |	1 to: 4 do: [:i| destinationStream nextPut: (crc digitAt: i)].	total_in := interface total_in.	1 to: 4 do: [:i| destinationStream nextPut: (total_in digitAt: i)].</body><body package="Compression-ZLib">setupBufferAndLimits	super setupBufferAndLimits.	crc := interface cCrc32: 0 buffer: 0 length: 0</body><body package="Compression-ZLib">writeBuffer: flush	position &gt; 0 ifTrue:		[crc := interface cCrc32: crc buffer: collection fixedHeapAddress length: position].	^super writeBuffer: flush.</body><body package="Compression-ZLib">writeHeader	destinationStream		nextPut: (GZipMagic digitAt: 1);		nextPut: (GZipMagic digitAt: 2);		nextPut: GZipDeflated;		next: 7 put: 0</body></methods><methods><class-id>OS.ZLib.ZLibInterface</class-id> <category>types</category><body package="Compression-ZLib">Bytef	&lt;C: typedef unsigned char Bytef&gt;</body><body package="Compression-ZLib">alloc_func	&lt;C: typedef voidpf (*alloc_func)(voidpf, uInt, uInt)&gt;</body><body package="Compression-ZLib">free_func	&lt;C: typedef void (*free_func)(voidpf, voidpf)&gt;</body><body package="Compression-ZLib">gzFile	&lt;C: typedef void * gzFile&gt;</body><body package="Compression-ZLib">uInt	&lt;C: typedef unsigned int uInt&gt;</body><body package="Compression-ZLib">uLong	&lt;C: typedef unsigned long uLong&gt;</body><body package="Compression-ZLib">voidpf	&lt;C: typedef void * voidpf&gt;</body><body package="Compression-ZLib">z_off_t	&lt;C: typedef long z_off_t&gt;</body><body package="Compression-ZLib">z_stream	&lt;C: typedef struct {		Bytef	*next_in;		uInt		avail_in;		uLong	total_in;		Bytef	*next_out;		uInt		avail_out;		uLong	total_out;		char	*msg;		void		*state;		alloc_func	zalloc;		free_func	zfree;		voidpf		opaque;		int		data_type;		uLong	adler;		uLong	reserved;	} z_stream&gt;</body><body package="Compression-ZLib">z_streamp	&lt;C: typedef z_stream * z_streamp&gt;</body></methods><methods><class-id>OS.ZLib.ZLibInterface</class-id> <category>accessing-zstream</category><body package="Compression-ZLib">avail_in	^self zstream memberAt: #'avail_in'</body><body package="Compression-ZLib">avail_in: anInteger	^self zstream memberAt: #'avail_in' put: anInteger</body><body package="Compression-ZLib">avail_out	^self zstream memberAt: #'avail_out'</body><body package="Compression-ZLib">avail_out: anInteger	^self zstream memberAt: #'avail_out' put: anInteger</body><body package="Compression-ZLib">data_type	^self zstream memberAt: #'data_type'</body><body package="Compression-ZLib">next_in	^self zstream memberAt: #'next_in'</body><body package="Compression-ZLib">next_in: aPointer	^self zstream memberAt: #'next_in' put: aPointer</body><body package="Compression-ZLib">next_out	^self zstream memberAt: #'next_out'</body><body package="Compression-ZLib">next_out: aPointer	^self zstream memberAt: #'next_out' put: aPointer</body><body package="Compression-ZLib">opaque: aPointerOrNil	^self zstream memberAt: #'opaque' put: aPointerOrNil</body><body package="Compression-ZLib">total_in	^self zstream memberAt: #'total_in'</body><body package="Compression-ZLib">total_in: anInteger	^self zstream memberAt: #'total_in' put: anInteger</body><body package="Compression-ZLib">total_out	^self zstream memberAt: #'total_out'</body><body package="Compression-ZLib">total_out: anInteger	^self zstream memberAt: #'total_out' put: anInteger</body><body package="Compression-ZLib">zalloc	^self zstream memberAt: #'zalloc'</body><body package="Compression-ZLib">zalloc: aFunctionPointerOrNil	^self zstream memberAt: #'zalloc' put: aFunctionPointerOrNil</body><body package="Compression-ZLib">zfree	^self zstream memberAt: #'zfree'</body><body package="Compression-ZLib">zfree: aFunctionPointerOrNil	^self zstream memberAt: #'zfree' put: aFunctionPointerOrNil</body></methods><methods><class-id>OS.ZLib.ZLibInterface</class-id> <category>deflating</category><body package="Compression-ZLib">deflate: flushCode	errno := self cDeflate: self zstream flush: flushCode.	((errno == self Z_OK) or: [errno == self Z_STREAM_END])		ifFalse: [self error:  (self errorStringFor: errno)].	^errno</body><body package="Compression-ZLib">deflateFinish	^self deflate: self Z_FINISH</body><body package="Compression-ZLib">deflateFullFlush	^self deflate: self Z_FULL_FLUSH</body><body package="Compression-ZLib">deflateNoFlush	^self deflate: self Z_NO_FLUSH</body><body package="Compression-ZLib">deflateSyncFlush	^self deflate: self Z_SYNC_FLUSH</body></methods><methods><class-id>OS.ZLib.ZLibInterface</class-id> <category>deflate-setup teardown</category><body package="Compression-ZLib">deflateEnd	errno := self cDeflateEnd: self zstream.	errno ~~ self Z_OK ifTrue:		[self error: (self errorStringFor: errno)].	^errno</body><body package="Compression-ZLib">deflateInit	^self deflateInit: self Z_DEFAULT_COMPRESSION</body><body package="Compression-ZLib">deflateInit: levelCode	"Initialize the zlib compression engine."	errno := self 			cDeflateInit: self zstream 			level: levelCode			version: self zlibVersion			streamSize: self z_stream dataSize.	errno ~~ self Z_OK ifTrue:		[self error: (self errorStringFor: errno)].	^errno</body><body package="Compression-ZLib">deflateInitBestCompression	^self deflateInit: self Z_BEST_COMPRESSION</body><body package="Compression-ZLib">deflateInitBestSpeed	^self deflateInit: self Z_BEST_SPEED</body><body package="Compression-ZLib">deflateInitNoCompression	^self deflateInit: self Z_NO_COMPRESSION</body></methods><methods><class-id>OS.ZLib.ZLibInterface</class-id> <category>accessing-zlib constants</category><body package="Compression-ZLib">DEF_MEM_LEVEL	^8</body><body package="Compression-ZLib">MAX_WBITS	^15</body><body package="Compression-ZLib">SEEK_CUR	^1</body><body package="Compression-ZLib">SEEK_END	^2</body><body package="Compression-ZLib">SEEK_SET	^0</body><body package="Compression-ZLib">Z_ASCII	^1</body><body package="Compression-ZLib">Z_BEST_COMPRESSION	^9</body><body package="Compression-ZLib">Z_BEST_SPEED	^1</body><body package="Compression-ZLib">Z_BINARY	^0</body><body package="Compression-ZLib">Z_BUF_ERROR	^-5</body><body package="Compression-ZLib">Z_DATA_ERROR	^-3</body><body package="Compression-ZLib">Z_DEFAULT_COMPRESSION	^-1</body><body package="Compression-ZLib">Z_DEFAULT_STRATEGY	^0</body><body package="Compression-ZLib">Z_DEFLATED	^8</body><body package="Compression-ZLib">Z_ERRNO	^-1</body><body package="Compression-ZLib">Z_FILTERED	^1</body><body package="Compression-ZLib">Z_FINISH	^4</body><body package="Compression-ZLib">Z_FULL_FLUSH	^3</body><body package="Compression-ZLib">Z_HUFFMAN_ONLY	^2</body><body package="Compression-ZLib">Z_MEM_ERROR	^-4</body><body package="Compression-ZLib">Z_NEED_DICT	^2</body><body package="Compression-ZLib">Z_NO_COMPRESSION	^0</body><body package="Compression-ZLib">Z_NO_FLUSH	^0</body><body package="Compression-ZLib">Z_OK	^0</body><body package="Compression-ZLib">Z_PARTIAL_FLUSH	^1</body><body package="Compression-ZLib">Z_STREAM_END	^1</body><body package="Compression-ZLib">Z_STREAM_ERROR	^-2</body><body package="Compression-ZLib">Z_SYNC_FLUSH	^2</body><body package="Compression-ZLib">Z_UNKNOWN	^2</body><body package="Compression-ZLib">Z_VERSION_ERROR	^-6</body><body package="Compression-ZLib">errorStringFor: errorCode	^(errorCode between: self Z_VERSION_ERROR and: self Z_NEED_DICT)		ifTrue: [(self cZError: errorCode) copyCStringFromHeap]		ifFalse: ['unknown error ', errorCode printString]	"| i |	 i := self new.	 (i Z_VERSION_ERROR to: i Z_NEED_DICT) collect: [:ec| i errorStringFor: ec]"</body></methods><methods><class-id>OS.ZLib.ZLibInterface</class-id> <category>accessing</category><body package="Compression-ZLib">errno	"Answer the last c call return code issued."	^errno</body><body package="Compression-ZLib">version	^self zlibVersion copyCStringFromHeap</body><body package="Compression-ZLib">zstream	zstream == nil ifTrue: 		[zstream := self z_stream gcCalloc].	^zstream</body></methods><methods><class-id>OS.ZLib.ZLibInterface</class-id> <category>inflating</category><body package="Compression-ZLib">inflate: flushCode	errno := self cInflate: self zstream flush: flushCode.	((errno == self Z_OK) or: [errno == self Z_STREAM_END])		ifFalse: [self error:  (self errorStringFor: errno)].	^errno</body><body package="Compression-ZLib">inflateFinish	^self inflate: self Z_FINISH</body><body package="Compression-ZLib">inflateFullFlush	^self inflate: self Z_FULL_FLUSH</body><body package="Compression-ZLib">inflateNoFlush	^self inflate: self Z_NO_FLUSH</body><body package="Compression-ZLib">inflateSyncFlush	^self inflate: self Z_SYNC_FLUSH</body></methods><methods><class-id>OS.ZLib.ZLibInterface</class-id> <category>inflate-setup teardown</category><body package="Compression-ZLib">inflateEnd	errno := self cInflateEnd: self zstream.	errno == self Z_OK		ifFalse: [self error: (self errorStringFor: errno)].	^errno</body><body package="Compression-ZLib">inflateInit	errno := self			cInflateInit: self zstream 			version: self zlibVersion			streamSize: self z_stream dataSize.	errno ~~ self Z_OK ifTrue:		[self error: (self errorStringFor: errno)].	^errno</body></methods><methods><class-id>OS.ZLib.ZLibInterface</class-id> <category>instance initialization</category><body package="Compression-ZLib">initializeForEngineAllocator	heap := self class cachedHeap: HeapSize.	zstream := self cOEConflateInitHeapObj: heap</body></methods><methods><class-id>OS.ZLib.ZLibInterface</class-id> <category>initialize-release</category><body package="Compression-ZLib">release	self class releaseHeap: heap</body></methods><methods><class-id>OS.ZLib.ZLibInterface class</class-id> <category>accessing-zlib constants</category><body package="Compression-ZLib">MAX_WBITS	^15</body><body package="Compression-ZLib">Z_BEST_COMPRESSION	^9</body><body package="Compression-ZLib">Z_BEST_SPEED	^1</body><body package="Compression-ZLib">Z_DEFAULT_COMPRESSION	^-1</body><body package="Compression-ZLib">Z_DEFLATED	^8</body></methods><methods><class-id>OS.ZLib.ZLibInterface class</class-id> <category>instance creation</category><body package="Compression-ZLib">newUsingEngineAllocator	^self new initializeForEngineAllocator</body></methods><methods><class-id>OS.ZLib.ZLibInterface class</class-id> <category>cache</category><body package="Compression-ZLib">cachedHeap: size	^HeapMutex critical: [		| queue cache |		queue := HeapCache at: size ifAbsentPut: [OrderedCollection new].		cache := queue isEmpty ifTrue: [nil] ifFalse: [queue removeLast].			"If somehow, through an image snapshot, a buffer gets moved			out of Fixed Space, it is no longer suitable."		cache isFixedArgument ifFalse: [cache := nil].		cache notNil			ifTrue:				[| byteStride width height |					"A fairly fast if not intuitive way to zero out a large ByteArray					as long as the ByteArray's size is a multiple of 4."				byteStride := cache size bitAnd: 0 - cache size.				(byteStride bitAnd: -4) = byteStride					ifFalse: [self error: 'can''t use RasterOp on this size of ByteArray'].				width := byteStride * 8.	"width in bits"				height := cache size / byteStride.				cache					copyBitsWidth: width atX: 0 y: 0					from: cache width: width atX: 0 y: 0					width: width height: height rule: Graphics.RasterOp writeZeros.				cache]			ifFalse: [ByteArray newInFixedSpace: size]]</body><body package="Compression-ZLib">releaseHeap: oldValue	oldValue isFixedArgument ifFalse: [^self].	^HeapMutex critical: [		| queue |		oldValue changeClassTo: ByteArray.		queue := HeapCache at: oldValue size ifAbsentPut: [OrderedCollection new].		queue addLast: oldValue]</body></methods><methods><class-id>OS.ZLib.ZLibInterface</class-id> <category>procedures</category><body package="Compression-ZLib">cAdler32: crc buffer: collection length: length	&lt;C: unsigned long  adler32(unsigned long crc, unsigned char *collection, unsigned int length)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">cCrc32: crc buffer: collection length: length	&lt;C: unsigned long  crc32(unsigned long crc, unsigned char *collection, unsigned int length)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">cDeflate: zstreampDestcopy: zstreampSrc	&lt;C: int deflateCopy( z_streamp, z_streamp )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">cDeflate: zstreampflush: flushCode	&lt;C: int deflate( z_streamp, int )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">cDeflate: zstreampsetDictionary: dictlength: dictLength	&lt;C: int deflateSetDictionary( z_streamp, Bytef *, uInt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">cDeflateEnd: zstreamp	&lt;C: int deflateEnd( z_streamp )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">cDeflateInit2: zstreamplevel: levelCodemethod: compressionMethodwindowBits: log2WindowSizememLevel: amtOfMemToUsestrategy: compressionStrategyversion: versionstreamSize: size	&lt;C: int deflateInit2_( z_streamp, int, int, int, int, int, char *, int )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">cDeflateInit: zstreamplevel: levelCodeversion: versionstreamSize: size	&lt;C: int deflateInit_( z_streamp, int, char *, int )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">cDeflateParams: zstreamplevel: levelCodestrategy: strategyCode	&lt;C: int deflateParams( z_streamp, int, int )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">cDeflateReset: zstreamp	&lt;C: int deflateReset( z_streamp )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">cInflate: zstreampflush: flushCode	&lt;C: int inflate( z_streamp, int )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">cInflate: zstreampsetDictionary: dictlength: dictLength	&lt;C: int inflateSetDictionary( z_streamp, Bytef *, uInt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">cInflateEnd: zstreamp	&lt;C: int inflateEnd( z_streamp )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">cInflateInit2: zStreamwindowBits: windowSizeversion: versionStringstreamSize: size	&lt;C: int inflateInit2_( z_streamp zStream, int windowSize, char *versionString, int size)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">cInflateInit: zstreampversion: versionstreamSize: size	&lt;C: int inflateInit_( z_streamp, char *, int )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">cInflateReset: zstreamp	&lt;C: int inflateReset( z_streamp )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">cInflateSync: zstreamp	&lt;C: int inflateSync( z_streamp )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">cOEConflateInitAlloc: heapBaseAddress length: numBytes	&lt;C: z_stream *oeConflateInitAlloc(void *heapBaseAddress, unsigned long numBytes)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">cOEConflateInitHeapObj: aFixedSpaceObject	"Configure a FixedSpace object for use by	 the oeConflateAlloc/oeConflateFree allocation functions provided by the engine.	 Answer a suitable z_stream * for passing to deflate, inflate et al.  The fixed-space	 object must be at least of size 32k + 12 + sizeof(z_stream).  ZLib itself limits its	 memory usage to 256K, so the maximum size the buffer need be is 256K + 12 + sizeof(z_stream)"	 	&lt;C: z_stream *oeConflateInitHeapObj(_oop aFixedSpaceObject)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">cZError: errorCode	&lt;C: const char * zError( int errorCode )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">gzclose: a_gzfile	&lt;C: int gzclose( gzFile )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">gzdopen: fdmode: mode	&lt;C: gzFile gzdopen( int, char * )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">gzeof: a_gzfile	&lt;C: int gzeof( gzFile )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">gzflush: a_gzfileflush: flushCode	&lt;C: int gzflush( gzFile, int )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">gzopen: pathmode: mode	&lt;C: gzFile gzopen( char * path, char * mode )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">gzread: a_gzfilebuffer: byteObjectbufferSize: len	&lt;C: int gzread( gzFile, char *, int )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">gzrewind: a_gzfile	&lt;C: int gzrewind( gzFile )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">gzseek: a_gzfileoffset: offsetwhence: whenceCode	&lt;C: int gzseek( gzFile, z_off_t, int )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">gzsetparams: a_gzfilelevel: levelCodestrategy: strategyCode	&lt;C: int gzsetparams( gzFile, int, int )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">gztell: a_gzfile	&lt;C: z_off_t gztell( gzFile )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">gzwrite: a_gzfilebuffer: byteObjectbufferSize: len	&lt;C: int gzwrite( gzFile, char *, int )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Compression-ZLib">zlibVersion	&lt;C: char * zlibVersion()&gt;	^self externalAccessFailedWith: _errorCode</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>WriteStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>ReadStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class></st-source>