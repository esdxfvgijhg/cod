<?xml version="1.0"?><st-source><!-- Name: Debugger-ProbesNotice: Copyright 2003-2016 Cincom Systems, Inc.  All rights reserved.Comment: PDP Probes for VW 7DbIdentifier: bear73DbTrace: 489474DbUsername: willowDbVersion: 8.2 - 4DevelopmentPrerequisites: #(#(#any 'Debugger-Compiler-Modifications' ''))PackageName: Debugger-ProbesParcel: #('Debugger-Probes')ParcelName: Debugger-ProbesPrerequisiteParcels: #(#('Debugger-Compiler-Modifications' ''))PrintStringCache: (8.2 - 4,willow)Version: 8.2 - 4Post-Load Block: 	[:package | |imp|CraftedSmalltalk.CodeProbe initializeMethods.CraftedSmalltalk.DisplayActionProbe initializeMethods.CraftedSmalltalk.ProbeTestExpressionEditor initializeLibrary.CraftedSmalltalk.ProbeActionExpressionEditor initializeLibrary.imp := GeneralNameSpaceImport path: #(#CraftedSmalltalk).Smalltalk addImport: imp]Post-Unload Block: 	[''Remove the import that we added''|imp|imp := GeneralNameSpaceImport path: #(#CraftedSmalltalk).Smalltalk removeImport: imp]Date: 3:26:58 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.4) of June 23, 2017 on June 30, 2017 at 3:26:58 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>CraftedSmalltalk</name><environment>Smalltalk</environment><private>true</private><imports>			private Smalltalk.*			</imports><category>CraftedSt</category><attributes><package>Debugger-Probes</package></attributes></name-space><class><name>AbstractCodeProbe</name><environment>CraftedSmalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>probeRecord parent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.AbstractCodeProbe</class-id><body>AbstractCodeProbe	Version 1.0Copyright 1995,1996 Crafted SmalltalkAll Rights ReservedAbstractCodeProbe is the abstract class of all the software probes.  Itprimarily provides the methods for accessing the information withinthe probe record.Instance Variables:	probeRecord		&lt;ProbeInsertionRecord&gt;	The probe record.	parent				&lt;CodeProbe&gt;	The probe from which the receiver was copied.Class Variables:	DoClone	&lt;Boolean&gt;	This specifies what type of copying will be done when							a probe is copied.</body></comment><class><name>CodeProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.AbstractCodeProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testMethod testSource variables labelString permanent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.CodeProbe</class-id><body>CodeProbe	Version 1.1Copyright 1995,1998 Crafted SmalltalkAll Rights ReservedAn instance of CodeProbe is used as a breakpoint probe.  It provides mostof a probe's functionallity.Instance Variables:	testMethod		&lt;CompiledMethod&gt;	The method that is executed to determine if the probe should be activated.	testSource		&lt;String&gt;	Souce for the test method.	variables		&lt;Dictionary&gt;	Dictionary of the probe's local debug variables.	labelString		&lt;ValueHolder of: (nil | String)&gt;	Window label	permanent		&lt;Boolean&gt;		Permanent or temp probeClass Variables:	DebugActiveMethod		&lt;CompiledMethod&gt;	Used to initialize an unconditional test method.												The result returned is the value of the #DebugActive global debug variable.												This is set the by visual launcher probe menu command "enable debugging".	DefaultTestMethod		&lt;CompiledMethod&gt;	The defauld method used to initialize an unconditional test method	DefaultTestSource		&lt;String&gt;			The source string of the default test method.	TrueTestMethod			&lt;CompiledMethod&gt;	Used to initialize an unconditional test method	FalseTestMethod		&lt;CompiledMethod&gt;	Used to initialize a conditional test method</body></comment><class><name>DisplayProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.CodeProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars>windowID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.DisplayProbe</class-id><body>DisplayProbe	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedThe super class of all the watchpoint probes.Instance Variables:	windowID		&lt;Symbol&gt;	ID of the watch window</body></comment><class><name>DisplayVariableProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.DisplayProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars>index name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.DisplayVariableProbe</class-id><body>DisplayVariableProbe	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedThe super class of the probes that display the contents of a defined variable.Instance Variables:	index		&lt;Integer&gt;	The variable index.	name		&lt;String&gt;	The variable name.</body></comment><class><name>SilentProbeExprCompilerErrorHandler</name><environment>CraftedSmalltalk</environment><super>Kernel.CompilerErrorHandler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Compiler</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.SilentProbeExprCompilerErrorHandler</class-id><body>SilentProbeExprCompilerErrorHandler	Version 1.1Copyright 1997,1998 Crafted SmalltalkAll Rights ReservedThis class is used to handle errors that may generated by the automatic compilation ofprobe expressions.</body></comment><class><name>CodeProbeEditor</name><environment>CraftedSmalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalProbe workingCopyProbe closeAction probedMethod probedClass testEditor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.CodeProbeEditor</class-id><body>An instance of CodeProbeEditor is the model for a code probe editor panel.  It servestwo purposes; to build the panel, and to perform the appropriate action when thepanel is closed.Instance Variables:	originalProbe			&lt;CodeProbe&gt;	The probe for which the editor was opened.	workingCopyProbe		&lt;CodeProbe&gt;					A copy of the object ivar.  This is the actual probe that is operated on.					This is used so a cancel actually works.	closeAction			&lt;BlockClosure&gt;						This block is performed when the panel is closed via the Done button.	probedMethod		&lt;ProbedCompiledMethod&gt;	The probed method.	probedClass		&lt;Metaclass&gt;	The class containing the probed method.	testEditor			&lt;ProbeExpressionEditor&gt;	The editor for the test expression.</body></comment><class><name>DisplayProbeEditor</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.CodeProbeEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.DisplayProbeEditor</class-id><body>DisplayProbeEditor	Version 1.0Copyright 1995,1996 Crafted SmalltalkAll Rights ReservedAn instance of DisplayProbeEditor is the model for a display probe editor panel.  It servestwo purposes; to build the panel, and to perform the appropriate action when thepanel is closed.</body></comment><class><name>ActionProbeEditor</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.DisplayProbeEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>actionEditor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ActionProbeEditor</class-id><body>ActionProbeEditor	Version 1.1Copyright 1995,1996,1997 Crafted SmalltalkAll Rights ReservedAn instance of ActionProbeEditor is the model for a display action probe editor panel.  It servestwo purposes; to build the panel, and to perform the appropriate action when thepanel is closed.Instance Variables:	actionEditor		&lt;ProbeExpressionEditor&gt;	The editor for the watch expression.</body></comment><class><name>WatchLog</name><environment>CraftedSmalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>eventHandlers counter counterSemaphore </class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.WatchLog</class-id><body>WatchLog is used to register interest in 'watch' events that can be spawned from tools such as watch probes or code spy.</body></comment><class><name>RawRemoteVariable</name><environment>CraftedSmalltalk</environment><super>Kernel.RemoteVariable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>slot </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Compiler</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.RawRemoteVariable</class-id><body>RawRemoteVariable	Version 1.1Copyright 1995,1997 Crafted SmalltalkAll Rights ReservedInstances of RawRemoteVariable provide for accessing temporary variables ofan outer context without forcing Context to create a local scope and checkingvariable names.  The index of the variable is assumed to includecompiler generated temps.  This class was provided to improveaccessing speed of the temps.</body></comment><class><name>DisplayMethodVarProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.DisplayVariableProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars>slot </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.DisplayMethodVarProbe</class-id><body>DisplayMethodVarProbe	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedWhen activated an instance of a DisplayMethodVarProbe displays thecontents of a method temporary variable.</body></comment><class><name>PDPManager</name><environment>CraftedSmalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>watchWindows lastID methodDependents debugVariables defaultToPermanentProbe </class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.PDPManager</class-id><body>PDPManager	Version 2.0Copyright 1997, 2002 Crafted SmalltalkAll Rights ReservedThe PDPManager manages global functions related to the debug package.</body></comment><class><name>ProbeExpressionEditor</name><environment>CraftedSmalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>probedMethod probedClass probe textMenu </inst-vars><class-inst-vars>expressionLibrary </class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProbeExpressionEditor</class-id><body>ProbeExpressionEditor is the abstract super class for the probe expression editors.  It is responsible for most of the probe expression editing activity.  It provides the menu commands for accessing and defining variables.  It also provides proper variable scope so the expressions will be able to refer to variables within an instance of probedClass.ProbeExpressionEditor allows a client to store and retrieve expressions in its class instance variable, expressionLibrary, a dictionary.  This Dictionary can is accessed by methods in the class side method protocol: #'expression library'.  Expressions are stored as strings and are accessed by the name a client decides is appropriate (the current implementation converts any expression names into symbols).Instance Variables:	probedMethod		&lt;ProbedCompiledMethod | nil&gt;	The method being probed.	probedClass		&lt;Class&gt;	The class of the method being probed	probe				&lt;Probe&gt;	The probe being operated on.	textMenu			&lt;Menu&gt;		The text menu.  A new text menu is supplied					because additional commands are provided.Class Instance Variables:	expressionLibrary	&lt;Dictionary of: Symbol-&gt;String&gt; The current collection of stored expressions </body></comment><class><name>ProbeActionExpressionEditor</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.ProbeExpressionEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProbeActionExpressionEditor</class-id><body>The ProbeActionExpressionEditor tailors the ProbeExpressionEditor for action expressions.  Most of the specialization is for accessing the action expression and method.</body></comment><class><name>ProcessTerminatedDuringSimulation</name><environment>CraftedSmalltalk</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Dbgr support</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProcessTerminatedDuringSimulation</class-id><body>ProcessTerminatedDuringSimulation The ProcessTerminatedDuringSimulation exception is raised ifthe process is terminated during byte code simulation.</body></comment><class><name>WatchVariableProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.CodeProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.WatchVariableProbe</class-id><body>WatchVariableProbe  is used to output the value of a variable within the context of execution to the watches logging tools without interrupting the flow of execution</body></comment><class><name>TopOfStackVariable</name><environment>CraftedSmalltalk</environment><super>Kernel.VariableDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Compiler</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.TopOfStackVariable</class-id><body>TopOfStackVariableThe TopOfStackVariable supports the TopOFStack pseudo variable inprobe expressions.  It provides the expression with access to the objecton the top of the debugged context stack.</body></comment><class><name>DebuggerException</name><environment>CraftedSmalltalk</environment><super>Core.ControlInterrupt</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Dbgr support</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.DebuggerException</class-id><body>Abstract class for exceptions used by the debugging system itself.</body></comment><class><name>StepIntoBlockNotification</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.DebuggerException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Dbgr support</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.StepIntoBlockNotification</class-id><body>The StepIntoBlockNotification is used by the debugger when stepping into a block, see the class references for the actual usage.</body></comment><class><name>ProbedCompiledBlock</name><environment>CraftedSmalltalk</environment><super>Kernel.CompiledBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>probeStart </inst-vars><class-inst-vars></class-inst-vars><imports>			OpcodePool.*			</imports><category>CraftedSt-VM</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProbedCompiledBlock</class-id><body>Instances of ProbedCompiledBlock replace CompiledBlocks in a ProbedCompiledMethod.Instance Variables:	probeStart			&lt;Integer&gt;	The starting index of the probes.</body></comment><class><name>DebugStepIntoBlockClosure</name><environment>CraftedSmalltalk</environment><super>Kernel.BlockClosure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.DebugStepIntoBlockClosure</class-id><body>DebugStepIntoBlockClosure The DebugStepIntoBlockClosure is used by the debugger to stepinto a block closure.  It is substituted for the block closuresin the message send.</body></comment><class><name>WatchLogEvent</name><environment>CraftedSmalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver method description timestamp counter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.WatchLogEvent</class-id><body>WatchLogEvent represents a logged event from a watch expression.Instance Variables:	counter	&lt;Integer&gt;	The counter value of this event, sequential to other events	description	&lt;String&gt;	The message being logged	method	&lt;MethodDefinition&gt;	The method that sourced the event	receiver	&lt;Object&gt;	The object that raised the event	timestamp	&lt;Timestamp&gt;	When the event occurred</body></comment><class><name>ProbedCompiledMethod</name><environment>CraftedSmalltalk</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>original methodHolder probeStart </inst-vars><class-inst-vars>removedProbedMethodsHolder </class-inst-vars><imports>			OpcodePool.*			</imports><category>CraftedSt-VM</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id><body>An instance of ProbedCompiledMethod replaces a CompiledMethod when a probe isinserted.Instance Variables:	original				&lt;CompiledMethod&gt;	The compiled method being replaced by the receiver.	methodHolder		&lt;MethodNodeHolder&gt;					The MethodNodeHolder used to create the receiver.  It is cached					because the likelyhood of being needed again is high.	probeStart			&lt;Integer&gt;	The starting index of the probes.</body></comment><class><name>PCAdjustmentMap</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>segments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>Kernel.PCAdjustmentMap</class-id><body>I use facilities provided by CompiledCodeSegment to map from original PC values to adjusted PC values, when the code segments have had their bytes adjusted (either through probe insertion or other means). It uses at: to perform this mapping, so that it can be used interchangeably with a Dictionary in this role.Instance Variables	segments	&lt;(SequencableCollection of: CompiledCodeSegment)&gt;	</body></comment><class><name>CRC32Function</name><environment>CraftedSmalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-VM</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.CRC32Function</class-id><body>The CRC32Function provides a function to calculate 32 bit CRCs ofa ByteArray.Shared Variables:	CRC32Table	&lt;Array&gt;		Precalculated CRC table</body></comment><class><name>DisplayActionProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.DisplayProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars>actionMethod actionSource </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.DisplayActionProbe</class-id><body>DisplayActionProbe	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedInstances of DisplayActionProbe are used to display the result of a Smalltalk expression.Instance Variables:	actionMethod			&lt;CompiledMethod&gt;					The method that is evaluated to obtain a string to display.	actionSource		&lt;String&gt;	Source code of the action method.Class Variables:	ActionMethod		&lt;CompiledMethod&gt; Used to initialize the action method.</body></comment><class><name>WatchActionProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.CodeProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.WatchActionProbe</class-id><body>WatchActionProbe is used to output a log message in to the watches logging tools without interrupting the flow of execution in a method and having access to all the contextual information at the point the probe is inserted.</body></comment><class><name>PrintTimeoutError</name><environment>CraftedSmalltalk</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Dbgr support</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.PrintTimeoutError</class-id><body>PrintTimeoutErrorThis exception is raised (in some inspectors) when printing an objecttakes so long that it becomes highly probable that the printingsuffers from infinite recursion.</body></comment><class><name>BreakInterrupt</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.DebuggerException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Dbgr support</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.BreakInterrupt</class-id><body>BreakInterruptBreakInterrupt is the exception that is raised to causea breakpoint action.</body></comment><class><name>AuxCodeInfoExtractor</name><environment>CraftedSmalltalk</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>depth jumpStack maxDepth visited </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-VM</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.AuxCodeInfoExtractor</class-id><body>An instance of a AuxCodeInfoExtractor is used to extract stack depth and jumpdestinations from a compiled method.Instance Variables:	depth			&lt;Integer&gt;  Current stack depth	jumpStack		&lt;OrderedCollection of: Association&gt;				The key is the pc of a jump instruction and the value is the stack depth.	maxDepth		&lt;Integer&gt;	Maximum stack depth used in the method	visited			&lt;Array of: Boolean&gt;				A visitation record of every instruction in the method.  It is used to make sure				that every instruction in every branch is visited.</body></comment><class><name>PDPWeakCollection</name><environment>CraftedSmalltalk</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessLock elements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools support</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.PDPWeakCollection</class-id><body>PDPWeakCollection	Version 1.1Copyright 1995,1996,1997 Crafted SmalltalkAll Rights ReservedPDPWeakCollection is a collection that uses a WeakArray to containthe elements.  Complete collection protocol has not been implemented.Instance Variables:	elements	&lt;WeakArray&gt;	The collection of objects.	accessLock		&lt;RecursionLock&gt;  Protects elements from conflicting access					during use and element expiration.</body></comment><class><name>ProbeCharacterStyle</name><environment>CraftedSmalltalk</environment><super>Core.Association</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools support</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProbeCharacterStyle</class-id><body>ProbeCharacterStyle	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedThe purpose of this class is to prevent the caching of character styles,actually associations, when used to retain probe information.  Thecaching of styles began in VW 2.0 so this class is not needed forOW 4.1 and VW 1.0 but its use simplifies the overall code.</body></comment><class><name>DisplayInstanceVarProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.DisplayVariableProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.DisplayInstanceVarProbe</class-id><body>DisplayInstanceVarProbe	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedWhen activated an instance of a DisplayInstanceVarProbe displays thecontents of an instance variable.</body></comment><class><name>ProbeClone</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.AbstractCodeProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProbeClone</class-id><body>ProbeClone	Version 1.0Copyright 1995,1996 Crafted SmalltalkAll Rights ReservedA ProbeClone is a copy of a probe and is used only in temporary methods.It exists so when a user modifies a probe in the debugger that the actualprobe contained in the probed method in the method dictionary is modifiedand not simply the probe in the temporary method.</body></comment><class><name>MethodActionRecord</name><environment>CraftedSmalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>action class selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools support</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.MethodActionRecord</class-id><body>MethodActionRecord	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedInstances of MethodActionRecord are used by Browser's class probe panels to conveyinformation to the methods inserting the probes into the selected methods.Instance Variables:	action		&lt;Integer&gt;		class		&lt;Class&gt;	selector		&lt;Symbol&gt;</body></comment><class><name>RemovedProbedMethodsBrowser</name><environment>CraftedSmalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methods methodList hiddenMethods selectedMethods showHidden textHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.RemovedProbedMethodsBrowser</class-id><body>RemovedProbedMethodsBrowser	Version 1.0Copyright 1997 Crafted SmalltalkAll Rights ReservedThe RemovedProbedMethodsBrowser is used to browse and manage ProbedCompiledMethodsthat were removed as a result of recompiling a class.  With a RemovedProbedMethodsBrowser theuser can browse and select methods so that their probes may be reinserted.Instance Variables:	methods			&lt;SortedCollection of: ProbedCompiledMethod&gt;					The list of methods to be used for browsing or probe reinsertion.	methodList			&lt;MultiSelectionInList of: ProbedCompiledMethod&gt;	The list of methods being displayed.	hiddenMethods		&lt;SortedCollection of: ProbedCompiledMethod&gt;					A list of methods that were removed from "methods".	selectedMethods	&lt;Array of: ProbedCompiledMethod&gt;	The list of methods selected by the user.	showHidden			&lt;Boolean&gt;		If true, "hiddenMethods" is displayed instead of "methods"	textHolder			&lt;ValueHolder on: Text&gt;	Holds the selected method's source text.</body></comment><class><name>PDPTransientWarning</name><environment>CraftedSmalltalk</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>labelText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools support</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.PDPTransientWarning</class-id><body>PDPTransientWarningPDPTransientWarning opens a window that presentsa short message and then closes automatically in 1.5 seconds.Instance Variables:	labelText	&lt;Text&gt;	The message.</body></comment><class><name>PDPParser</name><environment>CraftedSmalltalk</environment><super>Kernel.Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Compiler</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.PDPParser</class-id><body>PDPParser	Version 1.0Copyright 1997 Crafted SmalltalkAll Rights ReservedThe PDPParser is used to create probe expressions.  The expressions are compiledas special forms of doit expressions.</body></comment><class><name>ProbedAnnotatedMethod</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.ProbedCompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-VM</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProbedAnnotatedMethod</class-id><body>ProbedAnnotatedMethod	Version 1.0Copyright 1995,1996 Crafted SmalltalkAll Rights ReservedThis class combines the functionality of the ProbedCompiledMethod classand the AnnotatedMethod class.  Here is one place where multiple inheritancewould be nice.</body></comment><class><name>PDPWeakDictionary</name><environment>CraftedSmalltalk</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyArray valueArray tally accessLock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Dbgr support</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id><body>PDPWeakDictionary	Version 1.1Copyright 1995,1997 Crafted SmalltalkAll Rights ReservedPDPWeakDictionary is a partial implementation of an identity dictionary.  It was done so that either thekeys or the values could be weak references.Instance Variables:	accessLock		&lt;RecursionLock&gt;  Protects elements from conflicting access					during use and element expiration.	keyArray		&lt;Array | WeakArray&gt;	The keys.	valueArray		&lt;Array | WeakArray&gt;	The values.	tally			&lt;Integer&gt;	The number of items in the dictionary.Class Variables:		"Copied from Set"	ImproperCreationSizeSignal		&lt;Signal&gt;				Used to indicate an attempt to create an instance with an inappropriate size.	PrimeMap						&lt;ByteArray&gt;				Used to map the first some integers to primes, used in calculating instance				sizes -- prime numbers make good hash divisors.  Each byte contains				the distance from the index'th odd number to the nearest higher prime.	MaxMapped						&lt;Integer&gt;	Last integer that is mapped by PrimeMap.</body></comment><class><name>ProbeTestExpressionEditor</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.ProbeExpressionEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProbeTestExpressionEditor</class-id><body>The ProbeTestExpressionEditor tailors the ProbeExpressionEditor for test expressions.  Most of the specialization is for accessing the test expression and method.</body></comment><class><name>OneshotProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.CodeProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars>armed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.OneshotProbe</class-id><body>I am a specialized, but common, variant of a standard CodeProbe. I add a "latch" to be used for firing just once.Instance Variables:	armed	&lt;Boolean&gt;	am I active or not?</body></comment><class><name>ProbeCreationSpec</name><environment>CraftedSmalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>probeClass conditional permanent selectWindowParams isAutoProbe </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Tools support</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProbeCreationSpec</class-id><body>ProbeCreationSpec	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedInstances of ProbeCreationSpec specify the type of probe to be created.,Instance Variables:	probeClass					&lt;Class&gt;	The class of the probe to create.	conditional					&lt;Boolean&gt;	If true the probe will have a conditional expression.	permanent					&lt;Boolean&gt;	If true the probe will be a permanent probe.	selectWindowParams		&lt;Boolean&gt;	If true the select windows panel will be opened.</body></comment><class><name>WatchWindowHolder</name><environment>CraftedSmalltalk</environment><super>UI.TextCollector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>window label doLogging displayBox labelView </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.WatchWindowHolder</class-id><body>WatchWindowHolder	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedWatchWindowHolder is a specialized text collector for watch windows.  Italso holds additional information about the window that is reused aftera window is closed then reopenedInstance Variables:	window			&lt;ScheduledWindow | nil&gt;	The watch window.	label			&lt;String&gt;	The watch window label.	doLogging		&lt;Boolean&gt;		Specifies whether logging or replacement is done.	displayBox		&lt;Rectangle&gt;	The watch window display box.	labelView		&lt;BorderedWrapper | nil&gt;	The watch window label view.</body></comment><class><name>ProbeExprCompiler</name><environment>CraftedSmalltalk</environment><super>Kernel.Compiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>compileForProbes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Compiler</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProbeExprCompiler</class-id><body>ProbeExprCompiler	Version 1.1Copyright 1995,1998 Crafted SmalltalkAll Rights ReservedSpecializes the compiler to work with probed methods and probe expressions.Instance Variables:	compileForProbes		&lt;Boolean&gt;  Instructs the compiler to force all blocks to be full blocks.</body></comment><class><name>BranchLimit</name><environment>CraftedSmalltalk</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-VM</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.BranchLimit</class-id><body>BranchLimitThis exception is raised if inserting a probe into a methodwould cause a jump instruction to try to jump farther thanthe bytecode set permits.</body></comment><class><name>WatchWindowView</name><environment>CraftedSmalltalk</environment><super>UI.TextCollectorView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.WatchWindowView</class-id><body>WatchWindowHolder	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedWatchWindowView is a specialized TextCollectorView that handles being updatedin a replace rather than log mode of operation.</body></comment><class><name>DisplayTOSProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.DisplayProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.DisplayTOSProbe</class-id><body>DisplayTOSProbe	Version 1.0Copyright 1995 Crafted SmalltalkAll Rights ReservedAn instance of DisplayTOSProbe displays the top of the context stackwhen the probe is activated.</body></comment><class><name>WatchPropertyEvent</name><environment>CraftedSmalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver method property value timestamp counter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.WatchPropertyEvent</class-id><body>WatchPropertyEvent represents a change in an object's state as an event from a watch variable.Instance Variables:	counter	&lt;Integer&gt;	The counter value of this event, sequential to other events	method	&lt;MethodDefinition&gt;	The method that sourced the event	receiver	&lt;Object&gt;	The object that raised the event	timestamp	&lt;Timestamp&gt;	When the event occurred	property	&lt;Symbol&gt;	The property being changed	value		&lt;Object&gt;	The new value of the property</body></comment><class><name>ProbeInsertionRecord</name><environment>CraftedSmalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pc blockIndex characterIndex mclass selector mapEntry atEnd bytesInBytecodes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><comment><class-id>CraftedSmalltalk.ProbeInsertionRecord</class-id><body>Instances of ProbeInsertionRecord record where a probe is inserted.Instance Variables:	pc					&lt;Integer&gt;	The probe insertion pc.	blockIndex			&lt;Integer&gt;	The block index of the probe.	characterIndex		&lt;Integer&gt;	The character index of the probe.	mclass				&lt;Class&gt;	The class in which the ProbedCompiledMethod was compiled.	selector				&lt;Symbol&gt;	The selector of the ProbedCompiledMethod.	mapEntry			&lt;VisibleMapEntry&gt;	The map entry for the node in which the probe is inserted.	atEnd				&lt;Boolean&gt;	True if the probe is inserted at the end of node	bytesInBytecodes	&lt;Integer&gt;	How many bytes the probe had to add to the method's bytecodes in order to be invoked.</body></comment><shared-variable><name>OneshotTestMethod</name><environment>CraftedSmalltalk.CodeProbe</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>nil</initializer><attributes><package>Debugger-Probes</package></attributes></shared-variable><shared-variable><name>FalseTestMethod</name><environment>CraftedSmalltalk.CodeProbe</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>Debugger-Probes</package></attributes></shared-variable><shared-variable><name>DefaultTestSource</name><environment>CraftedSmalltalk.CodeProbe</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>Debugger-Probes</package></attributes></shared-variable><shared-variable><name>TrueTestMethod</name><environment>CraftedSmalltalk.CodeProbe</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>Debugger-Probes</package></attributes></shared-variable><shared-variable><name>DefaultTestMethod</name><environment>CraftedSmalltalk.CodeProbe</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>Debugger-Probes</package></attributes></shared-variable><shared-variable><name>DebugActiveMethod</name><environment>CraftedSmalltalk.CodeProbe</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>Debugger-Probes</package></attributes></shared-variable><shared-variable><name>ActionMethod</name><environment>CraftedSmalltalk.DisplayActionProbe</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>Debugger-Probes</package></attributes></shared-variable><shared-variable><name>CRC32Table</name><environment>CraftedSmalltalk.CRC32Function</environment><private>false</private><constant>false</constant><category>table</category><attributes><package>Debugger-Probes</package></attributes></shared-variable><shared-variable><name>PrimeMap</name><environment>CraftedSmalltalk.PDPWeakDictionary</environment><private>false</private><constant>false</constant><category>vars</category><attributes><package>Debugger-Probes</package></attributes></shared-variable><shared-variable><name>MaxMapped</name><environment>CraftedSmalltalk.PDPWeakDictionary</environment><private>false</private><constant>false</constant><category>vars</category><attributes><package>Debugger-Probes</package></attributes></shared-variable><shared-variable><name>PDPVersionNumber</name><environment>CraftedSmalltalk</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Debugger-Probes</package></attributes></shared-variable><shared-variable><name>DoClone</name><environment>CraftedSmalltalk.AbstractCodeProbe</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>Debugger-Probes</package></attributes></shared-variable><methods><class-id>CraftedSmalltalk.AbstractCodeProbe</class-id> <category>comparing</category><body package="Debugger-Probes">= aProbe	^[self baseParent == aProbe baseParent]		on: MessageNotUnderstood		do: [:ex | false]</body><body package="Debugger-Probes">basicHash	^super hash</body><body package="Debugger-Probes">hash	^self baseParent basicHash</body></methods><methods><class-id>CraftedSmalltalk.AbstractCodeProbe</class-id> <category>accessing</category><body package="Debugger-Probes">baseParent	parent == nil		ifTrue: [^self].	^parent baseParent</body><body package="Debugger-Probes">blockMethodIndex	^probeRecord blockMethodIndex</body><body package="Debugger-Probes">characterIndex	^probeRecord characterIndex</body><body package="Debugger-Probes">insertionPC	^probeRecord insertionPC</body><body package="Debugger-Probes">mclass	^probeRecord mclass</body><body package="Debugger-Probes">methodString	^probeRecord methodString</body><body package="Debugger-Probes">parent: aProbe	parent := aProbe</body><body package="Debugger-Probes">probeRecord	^probeRecord</body><body package="Debugger-Probes">reinsertAfterLoadInto: aMethod	probeRecord := aMethod probeRecordFor: probeRecord insertionRange.	^(self postLoadIntoMethod: aMethod) and:		[aMethod addProbe: self.		self recompileExpressionsUsingProbedMethod: aMethod].</body><body package="Debugger-Probes">reinsertInto: aMethod	probeRecord := aMethod probeRecordFor: probeRecord insertionRange.	aMethod addProbe: self.</body><body package="Debugger-Probes">selector	^probeRecord selector</body></methods><methods><class-id>CraftedSmalltalk.AbstractCodeProbe</class-id> <category>initialize-release</category><body package="Debugger-Probes">forClass: aClass	probeRecord isNil		ifTrue: [probeRecord := ProbeInsertionRecord new mclass: aClass]</body><body package="Debugger-Probes">record: aProbeRecord	probeRecord := aProbeRecord</body></methods><methods><class-id>CraftedSmalltalk.AbstractCodeProbe</class-id> <category>saving-loading</category><body package="Debugger-Probes">loadFrom: aStream	probeRecord := ProbeInsertionRecord createFrom: aStream.</body><body package="Debugger-Probes">postLoadIntoMethod: probedMethod	"Ignore, return true"	^true</body><body package="Debugger-Probes">saveOn: aStream	aStream nextPutAll: 'ProbeType: '; nextPutAll: self class shortName;cr.	probeRecord saveOn: aStream.</body><body package="Debugger-Probes">storeOn: aStream	"You really cannot restore a probe using #readFrom: so #storeOn:	does not make sense, but the decompiler uses #storeOn: so we	use this representation for the decompiler."	aStream		nextPutAll: '(';		store: self class.	aStream nextPutAll: ') '</body><body package="Debugger-Probes">unknowLoadField: someString on: aStream expected: fieldName	self class unknowLoadField: someString on: aStream expected: fieldName</body></methods><methods><class-id>CraftedSmalltalk.AbstractCodeProbe</class-id> <category>expression compiling</category><body package="Debugger-Probes">recompileExpressionsUsingProbedMethod: aMethod	self subclassResponsibility</body></methods><methods><class-id>CraftedSmalltalk.AbstractCodeProbe</class-id> <category>copying</category><body package="Debugger-Probes">basicMethodDcopyUsing: copyDict	^DoClone		ifTrue: [ProbeClone parent: self]		ifFalse: [(self basicDcopyUsing: copyDict) parent: self]</body><body package="Debugger-Probes">postDcopyUsing: copyDict	probeRecord := probeRecord shallowCopy</body></methods><methods><class-id>CraftedSmalltalk.AbstractCodeProbe class</class-id> <category>compiler</category><body package="Debugger-Probes">evaluatorClass	^ProbeExprCompiler"Smalltalk Professional Debug Package Version 1.6 (c) 1995,1998 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.AbstractCodeProbe class</class-id> <category>class initialization</category><body package="Debugger-Probes">initialize	DoClone := false."Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.AbstractCodeProbe class</class-id> <category>copy setup</category><body package="Debugger-Probes">setClone	DoClone := true"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes">setCopy	DoClone := false</body></methods><methods><class-id>CraftedSmalltalk.AbstractCodeProbe class</class-id> <category>saving-loading</category><body package="Debugger-Probes">unknowLoadField: someString on: aStream expected: fieldName	Object errorSignal raiseErrorString:		((#UnknownField1sAtPosition2p3sExpected &lt;&lt; #pdp &gt;&gt; 'Unknown field "&lt;1s&gt;" at position &lt;2p&gt;. "&lt;3s&gt;" was expected. Please correct the probe file.')			expandMacrosWith: someString			with: aStream position - someString size			with: fieldName)</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>responses</category><body package="Debugger-Probes">actOn: aContext	(self test: aContext)		ifTrue: [^self breakOn: aContext label: self labelString].</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>accessing</category><body package="Debugger-Probes">addVariable: aSymbol	variables isNil		ifTrue: [variables := Dictionary new].	^variables at: aSymbol put: nil.</body><body package="Debugger-Probes">editorLabelString	^(#EditBreakpoint &lt;&lt; #pdp &gt;&gt; 'Edit Breakpoint') asString</body><body package="Debugger-Probes">inspectString	^self labelString</body><body package="Debugger-Probes">labelString	labelString value isNil		ifTrue: [self createLabelString].	^labelString value</body><body package="Debugger-Probes">labelString: aString	labelString value: aString</body><body package="Debugger-Probes">mode	^#infinite</body><body package="Debugger-Probes">reportString	^testMethod == FalseTestMethod		ifTrue: [(#TestExprFailedRecompile &lt;&lt; #pdp &gt;&gt; 'Test expression failed recompile (probe disabled)') asString]		ifFalse: ['']</body><body package="Debugger-Probes">setTemporary	permanent := false</body><body package="Debugger-Probes">testMethodAndSource	^testMethod -&gt; testSource</body><body package="Debugger-Probes">testMethodAndSource: anAssoc	testMethod := anAssoc key.	testSource := anAssoc value string.</body><body package="Debugger-Probes">testSource	testSource notNil		ifTrue: [^testSource].	testMethod isNil		ifTrue: [^String new].	^testMethod getSource string</body><body package="Debugger-Probes">variableNames	variables isNil		ifTrue: [^#()].	^variables keys asArray</body><body package="Debugger-Probes">variables	variables isNil ifTrue: [^Dictionary new].	^variables</body><body package="Debugger-Probes">workingCopy	^self shallowCopy postWorkingCopy</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>accessing - emphasis</category><body package="Debugger-Probes">basicEmphasis	^ProbeCharacterStyle key: #probe value: self</body><body package="Debugger-Probes">emphasis	^permanent		ifTrue: [self basicEmphasis]		ifFalse: [self tempEmphasis]</body><body package="Debugger-Probes">emphasize: aText	^aText		emphasizeFrom: self characterIndex		to: self characterIndex		with: self emphasis</body><body package="Debugger-Probes">tempEmphasis	^ProbeCharacterStyle key: #tempProbe value: self</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>private</category><body package="Debugger-Probes">basicLabelString	^labelString value</body><body package="Debugger-Probes">basicTestMethod	^testMethod</body><body package="Debugger-Probes">basicTestSource	^testSource</body><body package="Debugger-Probes">quietlyCycleMode: aNewMode	aNewMode = self mode ifTrue: [^self].	self become: ((OneshotProbe new updateMiscFromProbe: self)		quietlyCycleMode: aNewMode;		testMethodAndSource: testMethod -&gt; testSource;		yourself)</body><body package="Debugger-Probes">test: aContext	"Answer whether this probe should act for aContext"	PDPManager debugActive ifFalse: [^false].		^(self isPermanent or: [Processor activeProcess isUnderDebug]) and:		[(testMethod isNil) or:			[testMethod				valueWithReceiver: aContext homeReceiver				arguments: (Array with: aContext with: self)]]</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>initialize-release</category><body package="Debugger-Probes">clearLabelString	labelString value: nil.</body><body package="Debugger-Probes">createLabelString	labelString value: ((#BreakIn1sAt2s &lt;&lt; #pdp &gt;&gt; 'Break in &lt;1s&gt; at &lt;2s&gt;')			expandMacrosWith: self methodString			with: self characterIndex printString).</body><body package="Debugger-Probes">finishSetup	(self mclass includesBehavior: Object)		ifTrue: [^self].	self recompileIfKnownMethods.</body><body package="Debugger-Probes">ifNecessaryCopy: aMethod andRebindFrom: oldVariables	"This method returns a new method with rebound variables if	rebinding is needed.  Otherwise, the original method is returned."	| nuMethod keepCopy vars |	variables == nil		ifTrue: [^aMethod].	nuMethod := aMethod copy.	keepCopy := false.	vars := OrderedCollection new.	oldVariables associationsDo: [:ac | vars add: ac].	nuMethod withAllBlockMethodsDo:		[:meth |		1 to: meth numLiterals do:			[:i | | lit |			lit := meth at: i.			(vars contains: [:obj | obj == lit])				ifTrue:					[keepCopy := true.					meth at: i put: (variables bindingFor: lit key)]]].	keepCopy		ifFalse: [^aMethod].	^nuMethod</body><body package="Debugger-Probes">initialize	permanent := true.	labelString := ValueHolder new.</body><body package="Debugger-Probes">postWorkingCopy	variables := variables shallowCopy.	labelString := labelString shallowCopy</body><body package="Debugger-Probes">recompileIfKnownMethods	self isKnownMethod		ifFalse: [^self].	testMethod := CodeProbe compileProbeMethod: testSource inClass: self mclass.</body><body package="Debugger-Probes">setAction	testMethod := DefaultTestMethod.	testSource := DefaultTestSource.</body><body package="Debugger-Probes">setAlwaysAction	testMethod := TrueTestMethod.	testSource := self class trueString.</body><body package="Debugger-Probes">setNoAction	testMethod := FalseTestMethod.	testSource := self class falseString.</body><body package="Debugger-Probes">updateExpressionsFromTemplate: aProbe	| origMethod |	testSource := aProbe basicTestSource.	origMethod := aProbe basicTestMethod.	testMethod := aProbe isKnownMethod		ifTrue: [origMethod]		ifFalse: [self ifNecessaryCopy: origMethod andRebindFrom: aProbe variables].</body><body package="Debugger-Probes">updateExpressionsFromWorkingCopy: aProbe	self testMethodAndSource: aProbe testMethodAndSource.</body><body package="Debugger-Probes">updateFromTemplate: aProbe	self updateMiscFromTemplate: aProbe.	self updateExpressionsFromTemplate: aProbe.</body><body package="Debugger-Probes">updateFromWorkingCopy: aProbe	self updateMiscFromWorkingCopy: aProbe.	self updateExpressionsFromWorkingCopy: aProbe.</body><body package="Debugger-Probes">updateInstanceVarIndexForMethod: probedMethod	"Ignore, return true"	^true</body><body package="Debugger-Probes">updateMiscFromProbe: aProbe	probeRecord := aProbe probeRecord.	self labelString: aProbe basicLabelString.</body><body package="Debugger-Probes">updateMiscFromTemplate: aProbe	| nuVars |	self updateMiscFromProbe: aProbe.	variables == nil		ifTrue: [^self]. 	nuVars := Dictionary new.	variables keysAndValuesDo: [:aKey :aValue | nuVars at: aKey put: aValue].	variables := nuVars.</body><body package="Debugger-Probes">updateMiscFromWorkingCopy: aProbe	self updateMiscFromProbe: aProbe.	variables := aProbe variables.	variables == nil		ifTrue: [^self]. 	variables isEmpty		ifTrue: [variables := nil].</body><body package="Debugger-Probes">updateTempVarForMethod: probedMethod	"Ignore, return true"	^true</body><body package="Debugger-Probes">updateTempVarIndexForMethod: probedMethod	"Ignore, return true"	^true</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>editor creation</category><body package="Debugger-Probes">createEditorOn: probedMethod	^self createEditorOn: probedMethod class: probedMethod mclass</body><body package="Debugger-Probes">createEditorOn: probedMethod class: probedClass 	self forClass: probedClass.	^self createTestEditorOn: probedMethod class: probedClass</body><body package="Debugger-Probes">createTestEditorOn: probedMethod class: probedClass 	^(CodeProbeEditor on: self in: probedMethod class: probedClass) createTestEditor</body><body package="Debugger-Probes">makeConditional: probeSpec replacing: unprobedMethod with: probedMethod	probeSpec isConditional		ifTrue:			[self setNoAction.			self finishSetup.]		ifFalse:			[self setAction.			self finishSetup.			unprobedMethod mclass addSelector: probedMethod selector withMethod: probedMethod.			PDPManager				changedMethodFrom: unprobedMethod				to: probedMethod				by: nil.			^self].	self openEditorOn: probedMethod andReplace: unprobedMethod</body><body package="Debugger-Probes">modifyIn: aProbedMethod	| topView |	topView := self createEditorOn: aProbedMethod.	topView model closeAction: [].	topView open</body><body package="Debugger-Probes">openEditorOn: probedMethod andReplace: unprobedMethod	| topView |	topView := self createEditorOn: probedMethod.	topView model closeAction:		[unprobedMethod mclass addSelector: probedMethod selector withMethod: probedMethod.		PDPManager			changedMethodFrom: unprobedMethod			to: probedMethod			by: nil].	topView open</body><body package="Debugger-Probes">unconditionallyInsertInto: probedMethod replacing: unprobedMethod	self setAction.	self finishSetup.	unprobedMethod mclass addSelector: probedMethod selector withMethod: probedMethod.	PDPManager		changedMethodFrom: unprobedMethod		to: probedMethod		by: nil.</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>testing</category><body package="Debugger-Probes">isKnownMethod	^testMethod == TrueTestMethod or: [testMethod == DebugActiveMethod or: [testSource = CodeProbe falseString]]</body><body package="Debugger-Probes">isOneshot		^false</body><body package="Debugger-Probes">isPermanent	^permanent</body><body package="Debugger-Probes">isTemporary	^permanent not</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>saving-loading</category><body package="Debugger-Probes">loadFrom: aStream	super loadFrom: aStream.	self loadLabelStringFrom: aStream.	self loadVariablesFrom: aStream.	self loadTestExpressionFrom: aStream.</body><body package="Debugger-Probes">loadLabelStringFrom:  aStream	| fieldName |	fieldName := aStream upTo: Character space.	fieldName = 'LabelString:'		ifFalse:			[^self unknowLoadField: fieldName on: aStream expected: 'LabelString:'].	labelString := (String readFrom: aStream) asValue.	aStream next.	"swallow cr"</body><body package="Debugger-Probes">loadTestExpressionFrom:  aStream	| fieldName |	fieldName := aStream upTo: Character space.	fieldName = 'TestExpr:'		ifFalse:			[^self unknowLoadField: fieldName on: aStream expected: 'TestExpr:'].	testSource := String readFrom: aStream.	aStream next.	"swallow cr"</body><body package="Debugger-Probes">loadVariablesFrom: aStream	| fieldName numVars varName defaultVal |	fieldName := aStream upTo: Character space.	fieldName = 'Variables:'		ifFalse:			[^self unknowLoadField: fieldName on: aStream expected: 'Variables:'].	numVars := Number readFrom: aStream.	aStream next.	"swallow cr"	[numVars = 0]		whileFalse:			[varName := (aStream upTo: Character tab) asSymbol.			self addVariable: varName.			defaultVal := aStream nextChunk.			aStream next.	"swallow cr"			defaultVal isEmpty				ifFalse:					[defaultVal := Compiler evaluate: defaultVal.					self variableAt: varName put: defaultVal].			numVars := numVars - 1].</body><body package="Debugger-Probes">saveLabelStringOn:  aStream	aStream nextPutAll: 'LabelString: '.	self labelString printOn: aStream.	aStream cr.</body><body package="Debugger-Probes">saveOn:  aStream	super saveOn: aStream.	self saveLabelStringOn: aStream.	self saveVariablesOn: aStream.	self saveTestExpressionOn: aStream.</body><body package="Debugger-Probes">saveTestExpressionOn:  aStream	aStream nextPutAll: 'TestExpr: '.	self testSource printOn: aStream.	aStream cr.</body><body package="Debugger-Probes">saveVariablesOn: aStream	| varNames |	aStream nextPutAll: 'Variables: '.	varNames := self variableNames.	varNames size printOn: aStream.	aStream cr.	varNames do: [:str | aStream nextPutAll: str; tab; nextPut: $!; cr.]</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>expression compiling</category><body package="Debugger-Probes">makeSafeTestMethod	testMethod := FalseTestMethod</body><body package="Debugger-Probes">recompileExpressionsUsingProbedMethod: aMethod	^self recompileTestExpressionUsingProbedMethod: aMethod</body><body package="Debugger-Probes">recompileTestExpressionUsingProbedMethod: aMethod	| src meth |	self isKnownMethod		ifTrue: [^true].	src := self testSource.	self makeSafeTestMethod.		"Reset the method to a sane value in case of failure."	meth := ProbeExprCompiler new		compileProbeExpression: src		forProbe: self		inClass: aMethod mclass		beginScope: (aMethod scopeForProbe: self)		notifying: nil		ifFail: [^false].	self testMethodAndSource: meth-&gt;src.	^true</body><body package="Debugger-Probes">recompileTestExpressionUsingProbedMethod: aMethod handler: aHandler	| src meth |	self isKnownMethod		ifTrue: [^true].	src := self testSource.	self makeSafeTestMethod.		"Reset the method to a sane value in case of failure."	meth := ProbeExprCompiler new		compileProbeExpression: src		forProbe: self		inClass: aMethod mclass		beginScope: (aMethod scopeForProbe: self)		notifying: nil		ifFail: [^false]		handler: aHandler.	self testMethodAndSource: meth-&gt;src.	^true</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>public</category><body package="Debugger-Probes">variableAt: aSymbol	^variables at: aSymbol</body><body package="Debugger-Probes">variableAt: aSymbol put: anObject	^variables at: aSymbol put: anObject</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe class</class-id> <category>class initialization</category><body package="Debugger-Probes">compileProbeMethod: aString inClass: aClass	| newMethod |	newMethod := ProbeExprCompiler new		compileProbeExpression: aString asString		forProbe: self new		inClass: aClass		beginScope: (NameScope forClass: aClass)		notifying: nil		ifFail: [^nil].	newMethod isNil		ifTrue: [^nil].	^newMethod"Smalltalk Professional Debug Package Version 1.6 (c) 1995,1997,1998 Crafted Smalltalk"</body><body package="Debugger-Probes">debugActiveString	^'^DebugActive'"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes">falseString	^'false'"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes">initializeMethods	"self initializeMethods"		DefaultTestMethod := DebugActiveMethod := self		compileProbeMethod: self debugActiveString		inClass: Object.	DefaultTestSource := self debugActiveString.	FalseTestMethod := self		compileProbeMethod: self falseString		inClass: Object.	TrueTestMethod := self		compileProbeMethod: self trueString		inClass: Object</body><body package="Debugger-Probes">trueString	^'true'"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe class</class-id> <category>instance creation</category><body package="Debugger-Probes">createFrom: aStream	| fieldName className |	fieldName := aStream upTo: Character space.	fieldName = 'ProbeType:'		ifFalse:			[^self unknowLoadField: fieldName on: aStream expected: 'ProbeType:'].	className := (aStream upTo: Character cr) asSymbol.	^className asQualifiedReference value new loadFrom: aStream."Smalltalk Professional Debug Package Version 2.51 (c) 2000 Crafted Smalltalk"</body><body package="Debugger-Probes">new	^super new initialize"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe class</class-id> <category>defaults</category><body package="Debugger-Probes">defaultConditionalProbe	^false"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes">defaultProbeType	^#Breakpoint"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes">defaultSelectWinParams	^false"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes">defaultTempProbe	^PDPManager isPermanentProbeDefault not"Smalltalk Professional Debug Package Version 3.0 (c) 2001 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe class</class-id> <category>testing</category><body package="Debugger-Probes">needsSafeRebinding	^true</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe class</class-id> <category>user interaction</category><body package="Debugger-Probes">newDefaultMethodFrom: aString inClass: aClass	| dm |	dm := self compileProbeMethod: aString inClass: aClass.	dm isNil		ifTrue: [^Dialog warn: (#MethodDidNotCompileDiscarded &lt;&lt; #pdp &gt;&gt; 'Method did not compile,&lt;n&gt;change discarded.') expandMacros].	DefaultTestMethod := dm.	DefaultTestSource := aString."Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes">selectBrowserProbeType	^self selectProbeType: false asTemp: false"Smalltalk Professional Debug Package Version 2.6 (c) 2001 Crafted Smalltalk"</body><body package="Debugger-Probes">selectDebuggerProbeTypeAsTemp: forceTemp	^self selectProbeType: true asTemp: forceTemp"Smalltalk Professional Debug Package Version 2.6 (c) 2001 Crafted Smalltalk"</body><body package="Debugger-Probes">selectProbeType: fromDebugger asTemp: forceTempProbe	| panel buttonSpacing bottom aModel em col1Width col2Width col2Start totalWidth col1End basicTypeModel conditionalModel permanenceModel result winParam testBlock builder buttonSpec breakButtonW varWatchButtonW expWatchButtonW winParamButtonW condButtonW tempButtonW indent col2End extent yPosition acceptButtonW cancelButtonW tempProbe buttonWidth |	conditionalModel := ValueHolder with: self defaultConditionalProbe.	"get default setting"	winParam := ValueHolder with: self defaultSelectWinParams.	"get default setting"	basicTypeModel := ValueHolder with: self defaultProbeType.	"get default setting"	tempProbe := forceTempProbe or: [self defaultTempProbe].	permanenceModel := ValueHolder with: tempProbe.	panel := SimpleDialog new.	builder := panel builder.	builder add: (WindowSpec label: #InsertProbe &lt;&lt; #pdp &gt;&gt; 'Insert Probe').	em := 'm' asComposedText preferredExtent.	buttonSpacing := (em y / 2) truncated.	buttonSpec := RadioButtonSpec				model: basicTypeModel				label: #Breakpoint &lt;&lt; #pdp &gt;&gt; 'Breakpoint'				select: #Breakpoint				layout: (0 @ 0 extent: 1 @ 1).	builder add: buttonSpec.	breakButtonW := builder wrapper.	buttonSpec := RadioButtonSpec				model: basicTypeModel				label: #VariableWatch &lt;&lt; #pdp &gt;&gt; 'Variable Watch'				select: #Variable				layout: (0 @ 0 extent: 1 @ 1).	builder add: buttonSpec.	varWatchButtonW := builder wrapper.	buttonSpec := RadioButtonSpec				model: basicTypeModel				label: #ExpressionWatch &lt;&lt; #pdp &gt;&gt; 'Expression Watch'				select: #Expression				layout: (0 @ 0 extent: 1 @ 1).	builder add: buttonSpec.	expWatchButtonW := builder wrapper.	col1Width := expWatchButtonW preferredWidth.	buttonSpec := CheckBoxSpec				model: winParam				label: #WindowParameters &lt;&lt; #pdp &gt;&gt; 'Window Parameters'				layout: (0 @ 0 extent: 1 @ 1).	builder add: buttonSpec.	winParamButtonW := builder wrapper.	winParamButtonW widget isEnabled: winParam value.	col1Width := col1Width max: winParamButtonW preferredWidth.	buttonSpec := CheckBoxSpec				model: conditionalModel				label: #Conditional &lt;&lt; #pdp &gt;&gt; 'Conditional'				layout: (0 @ 0 extent: 1 @ 1).	builder add: buttonSpec.	condButtonW := builder wrapper.	col2Width := condButtonW preferredWidth.	fromDebugger		ifTrue: 			[buttonSpec := CheckBoxSpec						model: permanenceModel						label: #Temporary &lt;&lt; #pdp &gt;&gt; 'Temporary'						layout: (0 @ 0 extent: 1 @ 1).			builder add: buttonSpec.			tempButtonW := builder wrapper.			tempButtonW widget isEnabled: forceTempProbe not.			col2Width := col2Width max: tempButtonW preferredWidth].	indent := em x * 2.	col1End := col1Width + indent.	col2Start := col1End + em x.	col2End := col2Start + col2Width.	totalWidth := col2End + indent.	yPosition := em y.	extent := breakButtonW preferredExtent.	bottom := yPosition + extent y.	breakButtonW layout: (LayoutFrame				leftFraction: 0				offset: indent				rightFraction: 0				offset: col1End				topFraction: 0				offset: yPosition				bottomFraction: 0				offset: bottom).	extent := condButtonW preferredExtent.	condButtonW layout: (LayoutFrame				leftFraction: 0				offset: col2Start				rightFraction: 0				offset: col2End				topFraction: 0				offset: yPosition				bottomFraction: 0				offset: yPosition + extent y).	yPosition := bottom + buttonSpacing.	extent := varWatchButtonW preferredExtent.	bottom := yPosition + extent y.	varWatchButtonW layout: (LayoutFrame				leftFraction: 0				offset: indent				rightFraction: 0				offset: col1End				topFraction: 0				offset: yPosition				bottomFraction: 0				offset: bottom).	yPosition := bottom + buttonSpacing.	extent := expWatchButtonW preferredExtent.	bottom := yPosition + extent y.	expWatchButtonW layout: (LayoutFrame				leftFraction: 0				offset: indent				rightFraction: 0				offset: col1End				topFraction: 0				offset: yPosition				bottomFraction: 0				offset: bottom).	fromDebugger		ifTrue: 			[extent := tempButtonW preferredExtent.			tempButtonW layout: (LayoutFrame						leftFraction: 0						offset: col2Start						rightFraction: 0						offset: col2End						topFraction: 0						offset: yPosition						bottomFraction: 0						offset: yPosition + extent y)].	yPosition := bottom + buttonSpacing.	extent := winParamButtonW preferredExtent.	bottom := yPosition + extent y.	winParamButtonW layout: (LayoutFrame				leftFraction: 0				offset: indent				rightFraction: 0				offset: col1End				topFraction: 0				offset: yPosition				bottomFraction: 0				offset: bottom).	aModel := PluggableAdaptor on: ValueHolder newBoolean.	basicTypeModel addDependent: aModel.	conditionalModel addDependent: aModel.	testBlock :=			[basicTypeModel value == #Variable and: [conditionalModel value not]].	aModel		getBlock: [:m | testBlock value]		putBlock: [:m :v | ]		updateBlock: 			[:m :a :p |			winParamButtonW widget isEnabled: testBlock value.			true].	yPosition := bottom + (3 * buttonSpacing).	"add okButton"	buttonSpec := ActionButtonSpec				model: #accept				label: #InsertDots &lt;&lt; #pdp &gt;&gt; 'Insert...'				layout: (0 @ 0 extent: 1 @ 1).	builder add: buttonSpec.	acceptButtonW := builder wrapper.	"add cancel button"	buttonSpec := ActionButtonSpec				model: #cancel				label: #Cancel &lt;&lt; #pdp &gt;&gt; 'Cancel'				layout: (0 @ 0 extent: 1 @ 1).	builder add: buttonSpec.	cancelButtonW := builder wrapper.	extent := cancelButtonW preferredExtent max: acceptButtonW preferredExtent.	buttonWidth := extent x + (em x * 2).	bottom := yPosition + extent y.	cancelButtonW layout: (LayoutFrame				leftFraction: 1				offset: indent negated - buttonWidth				rightFraction: 1				offset: indent negated				topFraction: 0				offset: yPosition				bottomFraction: 0				offset: bottom).	acceptButtonW layout: (LayoutFrame				leftFraction: 1				offset: (indent negated - buttonWidth) * 2				rightFraction: 1				offset: indent negated * 2 - buttonWidth				topFraction: 0				offset: yPosition				bottomFraction: 0				offset: bottom).	yPosition := buttonSpacing + bottom.	builder window model: panel.	panel accept onChangeSend: #close to: panel.	panel cancel onChangeSend: #close to: panel.	builder openDialogWithExtent: totalWidth @ yPosition.	panel cancel value ifTrue: [^nil].	result := (ProbeCreationSpec new)				probeClass: basicTypeModel value;				conditional: conditionalModel value.	result selectWindowParams: winParam value &amp; testBlock value.	^fromDebugger		ifTrue: [result permanent: permanenceModel value not]		ifFalse: [result]	"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes">setDefaultMethodToDebugActive	DefaultTestMethod := DebugActiveMethod.	DefaultTestSource := self debugActiveString."Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes">setDefaultMethodToFalse	DefaultTestMethod := FalseTestMethod.	DefaultTestSource := self falseString."Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes">setDefaultMethodToTrue	DefaultTestMethod := TrueTestMethod.	DefaultTestSource := self trueString."Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.DisplayProbe</class-id> <category>editor creation</category><body package="Debugger-Probes">createDisplayEditorOn: probedMethod class: probedClass		^(DisplayProbeEditor on: self in: probedMethod class: probedClass) createEditor</body><body package="Debugger-Probes">createEditorOn: probedMethod class: probedClass	self forClass: probedClass.	^self createDisplayEditorOn: probedMethod class: probedClass</body><body package="Debugger-Probes">makeConditional: probeSpec replacing: unprobedMethod with: probedMethod	probeSpec isConditional		ifTrue:			[self setNoAction.			self finishSetup.]		ifFalse:			[self setAction.			probeSpec selectWindowParams				ifTrue: [self openWindowParamSelector].			self finishSetup.			unprobedMethod mclass addSelector: probedMethod selector withMethod: probedMethod.			^PDPManager				changedMethodFrom: unprobedMethod				to: probedMethod				by: nil].	self openEditorOn: probedMethod andReplace: unprobedMethod</body><body package="Debugger-Probes">openWindowParamSelector	^(DisplayProbeEditor on: self in: nil class: nil) openWindowParamSelector</body></methods><methods><class-id>CraftedSmalltalk.DisplayProbe</class-id> <category>initialize-release</category><body package="Debugger-Probes">finishSetup	super finishSetup.	self setLabel</body><body package="Debugger-Probes">initialize	super initialize.	windowID := ''.</body><body package="Debugger-Probes">setLabel	(PDPManager getWatchWindow: windowID for: self ) label: self labelString</body><body package="Debugger-Probes">updateMiscFromProbe: aProbe	super updateMiscFromProbe: aProbe.	windowID := aProbe windowID.</body></methods><methods><class-id>CraftedSmalltalk.DisplayProbe</class-id> <category>saving-loading</category><body package="Debugger-Probes">loadFrom: aStream	super loadFrom: aStream.	self loadWindowIDFrom: aStream.</body><body package="Debugger-Probes">loadWindowIDFrom: aStream	| fieldName |	fieldName := aStream upTo: Character space.	fieldName = 'WindowID:'		ifFalse:			[^self unknowLoadField: fieldName on: aStream expected: 'WindowID:'].	windowID := Object evaluatorClass evaluate: (aStream upTo: Character cr).</body><body package="Debugger-Probes">saveOn: aStream	super saveOn: aStream.	self saveWindowIDOn: aStream.</body><body package="Debugger-Probes">saveWindowIDOn: aStream	aStream nextPutAll: 'WindowID: '.	windowID printOn: aStream.	aStream cr.</body></methods><methods><class-id>CraftedSmalltalk.DisplayProbe</class-id> <category>accessing</category><body package="Debugger-Probes">windowID	^windowID</body><body package="Debugger-Probes">windowID: anObject	windowID := anObject.</body></methods><methods><class-id>CraftedSmalltalk.DisplayVariableProbe</class-id> <category>saving-loading</category><body package="Debugger-Probes">loadFrom: aStream	super loadFrom: aStream.	self loadVarNameFrom: aStream.</body><body package="Debugger-Probes">loadVarNameFrom: aStream	| fieldName |	fieldName := aStream upTo: Character space.	fieldName = 'VariableName:'		ifFalse:			[^self unknowLoadField: fieldName on: aStream expected: 'VariableName:'].	name := Object evaluatorClass evaluate: (aStream upTo: Character cr).</body><body package="Debugger-Probes">saveOn: aStream	super saveOn: aStream.	self saveVarNameOn: aStream.</body><body package="Debugger-Probes">saveVarNameOn: aStream	aStream nextPutAll: 'VariableName: '.	name printOn: aStream.	aStream cr.</body></methods><methods><class-id>CraftedSmalltalk.DisplayVariableProbe</class-id> <category>initialize-release</category><body package="Debugger-Probes">name: aString index: anIndex	name := aString.	index := anIndex.</body></methods><methods><class-id>CraftedSmalltalk.DisplayVariableProbe</class-id> <category>accessing</category><body package="Debugger-Probes">reportString	^index = 0		ifTrue: [(#InvalidVarRefProbeRemoved &lt;&lt; #pdp &gt;&gt; 'Invalid variable reference (probe removed)') asString]		ifFalse: [super reportString]</body><body package="Debugger-Probes">variableIndex	^index</body><body package="Debugger-Probes">variableName	^name</body></methods><methods><class-id>CraftedSmalltalk.DisplayVariableProbe class</class-id> <category>instance creation</category><body package="Debugger-Probes">name: aString index: anIndex	^self new name: aString index: anIndex"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.SilentProbeExprCompilerErrorHandler</class-id> <category>error handling</category><body package="Debugger-Probes">error: type with: message at: sourcePosition	Transcript cr;		nextPutAll: ((#ErrorIn1sDash2sAt3p &lt;&lt; #pdp &gt;&gt; 'Error in &lt;1s&gt; - &lt;2s&gt; at: &lt;3p&gt;')			expandMacrosWith: self methodString;			with: message;			with: sourcePosition);		endEntry.	^self abort</body><body package="Debugger-Probes">error: type with: message in: node from: codeStream	| msg |	msg := message isVariableBinding		ifTrue: [message key]		ifFalse: [message isString			ifTrue: [message]			ifFalse: ['?']].	Transcript cr;		nextPutAll: ((#ErrorDash1s2sIn3s &lt;&lt; #pdp &gt;&gt; 'Error - &lt;1s&gt; "&lt;2s&gt;" in &lt;3s&gt;')			expandMacrosWith: type			with: msg			with: self methodString);		endEntry.	^self abort</body></methods><methods><class-id>CraftedSmalltalk.SilentProbeExprCompilerErrorHandler</class-id> <category>private</category><body package="Debugger-Probes">methodString	selector isNil		ifTrue: [^(#UnboundMethod &lt;&lt; #pdp &gt;&gt; 'Unbound method') asString].	^class shortName , '&gt;&gt;' , selector string</body></methods><methods><class-id>CraftedSmalltalk.CodeProbeEditor</class-id> <category>actions</category><body package="Debugger-Probes">accept	self install.	self closeRequest</body><body package="Debugger-Probes">cancel	self closeRequest.</body></methods><methods><class-id>CraftedSmalltalk.CodeProbeEditor</class-id> <category>accessing</category><body package="Debugger-Probes">closeAction: aBlock	closeAction := aBlock</body><body package="Debugger-Probes">object: aProbe	originalProbe := aProbe.	^workingCopyProbe := aProbe workingCopy.</body><body package="Debugger-Probes">testEditor	testEditor == nil		ifFalse: [^testEditor].	testEditor := ProbeTestExpressionEditor new				probe: workingCopyProbe				on: probedMethod				class: probedClass.	^testEditor</body></methods><methods><class-id>CraftedSmalltalk.CodeProbeEditor</class-id> <category>interface opening</category><body package="Debugger-Probes">createEditor	^self createEditorOn: #testEditorSpec</body><body package="Debugger-Probes">createEditorOn: aSpec	^(self allButOpenInterface: aSpec) window</body><body package="Debugger-Probes">createTestEditor	^(self allButOpenInterface: #testEditorSpec) window</body><body package="Debugger-Probes">postBuildWith: aBuilder	aBuilder window label: workingCopyProbe editorLabelString</body></methods><methods><class-id>CraftedSmalltalk.CodeProbeEditor</class-id> <category>private</category><body package="Debugger-Probes">install	originalProbe updateFromWorkingCopy: workingCopyProbe.	originalProbe finishSetup.	closeAction value</body></methods><methods><class-id>CraftedSmalltalk.CodeProbeEditor</class-id> <category>initialize-release</category><body package="Debugger-Probes">on: aProbe in: aMethod class: aClass	self object: aProbe.	probedMethod := aMethod.	probedClass := aClass</body></methods><methods><class-id>CraftedSmalltalk.CodeProbeEditor class</class-id> <category>instance creation</category><body package="Debugger-Probes">on: aProbe in: aMethod class: aClass	^self new on: aProbe in: aMethod class: aClass"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.DisplayProbeEditor</class-id> <category>interface opening</category><body package="Debugger-Probes">createEditor	^self createEditorOn: #displayEditorSpec</body><body package="Debugger-Probes">hookUpWindowParameters	self hookUpWindowParametersTo: builder</body><body package="Debugger-Probes">hookUpWindowParametersTo: aBuilder	| idHolder |	idHolder := ValueHolder with: workingCopyProbe windowID.	aBuilder aspectAt: #windowID put: idHolder.	aBuilder		aspectAt: #openWatchWindow		put: [(aBuilder componentAt: #idEntry) widget controller accept.			idHolder value isEmpty				ifTrue: [Dialog warn: (#ValidWindowIDRequired &lt;&lt; #pdp &gt;&gt; 'A valid window ID must be first entered.')]				ifFalse:					[workingCopyProbe setLabel.					PDPManager openWatchWindow: workingCopyProbe windowID for: workingCopyProbe]].	idHolder		onChangeSend: #value		to: [workingCopyProbe windowID: idHolder value string asSymbol].	aBuilder		aspectAt: #selectID		put: [|result|			(result := self selectWindowID) isNil				ifFalse: [idHolder value: result]].	aBuilder		aspectAt: #changeLabel		put: [self openLabelEditor].</body><body package="Debugger-Probes">invokePostOpen</body><body package="Debugger-Probes">openWindowParamSelector	| dialog oldGuess |	dialog := SimpleDialog new.	dialog builder source: self.	self hookUpWindowParametersTo: dialog builder.	oldGuess := SimpleDialog classPool at: #GuessParentWindow.	SimpleDialog guessParentWindow: false.	dialog allButOpenFrom: (UISpecification from: self class windowParmOpenSpec).	SimpleDialog guessParentWindow: oldGuess.	dialog builder openDialog.	dialog accept value		ifTrue: [originalProbe updateFromWorkingCopy: workingCopyProbe]</body><body package="Debugger-Probes">preBuildWith: aBuilder 	"This message is sent by the builder prior to beginning construction 	of either a SubCanvas or a complete window."	self hookUpWindowParameters</body></methods><methods><class-id>CraftedSmalltalk.DisplayProbeEditor</class-id> <category>actions</category><body package="Debugger-Probes">openLabelEditor	| label |	label := Dialog request: (#EnterNewWindowLabel &lt;&lt; #pdp &gt;&gt; 'Enter new window label') initialAnswer: workingCopyProbe labelString.	label isEmpty		ifFalse: [workingCopyProbe labelString: label].</body><body package="Debugger-Probes">selectWindowID	| entries list |	entries := OrderedCollection new.	list := OrderedCollection new.	PDPManager windowHolders associationsDo:		[:ac|		entries add: ac key.		list add: '&lt;' , ac key printString , '&gt; ' , ac value label asString].	list isEmpty		ifTrue:			[Dialog warn: (#ThereAreNoWindowsAvailable &lt;&lt; #pdp &gt;&gt; 'There are no windows available.').			^nil].	^Dialog 		choose: (#SelectWindowIDWindow &lt;&lt; #pdp &gt;&gt; 'Select Window&lt;ID&gt;		Window') 		fromList: list		values: entries 		lines: 20		cancel: []</body></methods><methods><class-id>CraftedSmalltalk.ActionProbeEditor</class-id> <category>accessing</category><body package="Debugger-Probes">actionEditor	actionEditor == nil		ifFalse: [^actionEditor].	actionEditor := ProbeActionExpressionEditor new				probe: workingCopyProbe				on: probedMethod				class: probedClass.	^actionEditor</body></methods><methods><class-id>CraftedSmalltalk.ActionProbeEditor</class-id> <category>interface opening</category><body package="Debugger-Probes">createEditor	^self createEditorOn: #actionEditorSpec</body></methods><methods><class-id>CraftedSmalltalk.WatchLog class</class-id> <category>class initialization</category><body package="Debugger-Probes">initialize	"self initialize"		counter := -1.	counterSemaphore := Semaphore forMutualExclusion</body></methods><methods><class-id>CraftedSmalltalk.WatchLog class</class-id> <category>private-events</category><body package="Debugger-Probes">myEventTable	^eventHandlers</body><body package="Debugger-Probes">myEventTable: anEventTable	eventHandlers := anEventTable</body></methods><methods><class-id>CraftedSmalltalk.WatchLog class</class-id> <category>logging</category><body package="Debugger-Probes">log: aDescription for: aReceiver from: aMethodDefinition	"Trigger a #log event for aReceiver from aMethodDefinition with a description of aDescription"	self triggerEvent: #log		with: ((WatchLogEvent new)				description: aDescription;				receiver: aReceiver;				method: aMethodDefinition;				timestamp: Timestamp now;				counter: self nextCounterValue;				yourself)</body><body package="Debugger-Probes">object: anObject for: aReceiver from: aMethodDefinition property: aProperty	"Trigger an event for aReceiver's property aProperty of value anObject from aMethodDefinition"	self triggerEvent: #object		with: ((WatchPropertyEvent new)				receiver: aReceiver;				method: aMethodDefinition;				property: aProperty;				value: anObject;				timestamp: Timestamp now;				counter: self nextCounterValue;				yourself)</body></methods><methods><class-id>CraftedSmalltalk.WatchLog class</class-id> <category>accessing</category><body package="Debugger-Probes">nextCounterValue	^counterSemaphore critical: [counter := counter + 1]</body></methods><methods><class-id>CraftedSmalltalk.RawRemoteVariable</class-id> <category>accessing</category><body package="Debugger-Probes">debuggerIndex	^slot value debuggerIndex</body><body package="Debugger-Probes">nesting	^slot value nesting</body></methods><methods><class-id>CraftedSmalltalk.RawRemoteVariable</class-id> <category>private</category><body package="Debugger-Probes">doItContextVar	^VariableNode new name: 'DOITCONTEXT'</body></methods><methods><class-id>CraftedSmalltalk.RawRemoteVariable</class-id> <category>code generation</category><body package="Debugger-Probes">emitLoad: codeStream from: var	| builder node |	builder := ProgramNodeBuilder new.	node := builder		newMessageReceiver: self doItContextVar		selector: #getTempVar:		arguments: (Array with: (builder newLiteralValue: slot value)).	node sourcePosition: var sourcePosition.	node emitValue: codeStream</body><body package="Debugger-Probes">emitStore: codeStream value: value from: assignment 	| builder node |	builder := ProgramNodeBuilder new.	node := builder				newMessageReceiver: self doItContextVar				selector: #put:intoTempVar:				arguments: (Array						with: value						with: (builder newLiteralValue: slot value)).	node sourcePosition: assignment sourcePosition.	^node emitValue: codeStream</body><body package="Debugger-Probes">emitStorePop: codeStream value: value from: assignment	| builder node |	builder := ProgramNodeBuilder new.	node := builder				newMessageReceiver: self doItContextVar				selector: #put:intoTempVar:				arguments: (Array						with: value						with: (builder newLiteralValue: slot value)).	node sourcePosition: assignment sourcePosition.	^node emitEffect: codeStream</body></methods><methods><class-id>CraftedSmalltalk.RawRemoteVariable</class-id> <category>initialize-release</category><body package="Debugger-Probes">slot: aSlot	slot := aSlot.</body></methods><methods><class-id>CraftedSmalltalk.DisplayMethodVarProbe</class-id> <category>responses</category><body package="Debugger-Probes">actOn: aContext 	(self test: aContext)		ifTrue:			[PDPManager				display: (aContext getTempVar: slot) debugString				on: windowID				for: self]</body></methods><methods><class-id>CraftedSmalltalk.DisplayMethodVarProbe</class-id> <category>initialize-release</category><body package="Debugger-Probes">createLabelString	labelString value:		((#MethodTemp1sIn2sAt3p &lt;&lt; #pdp &gt;&gt; 'Method temp %&lt;&lt;1s&gt;%&gt; in &lt;2s&gt; at &lt;3p&gt;')			expandMacrosWith: self variableName			with: self methodString			with: self characterIndex)</body><body package="Debugger-Probes">updateMiscFromProbe: aProbe	super updateMiscFromProbe: aProbe.	slot := aProbe slot.	name := aProbe variableName.</body><body package="Debugger-Probes">updateTempVarForMethod: probedMethod	"Update the receiver's slot for the named temporary variable.	Return true if the tVar still exists, otherwise return false."	slot := ((probedMethod scopeForProbe: self) variableList				detect: [:assoc | assoc key = name]				ifNone: [nil]) value.	^slot notNil</body></methods><methods><class-id>CraftedSmalltalk.DisplayMethodVarProbe</class-id> <category>accessing</category><body package="Debugger-Probes">editorLabelString	^((#EditTempVarWatchOn1s &lt;&lt; #pdp &gt;&gt; 'Edit Temporary Variable Watch on: %&lt;&lt;1s&gt;%&gt;')			expandMacrosWith: name)</body><body package="Debugger-Probes">slot	^slot</body><body package="Debugger-Probes">slot: aSlot	slot := aSlot value.	name :=  aSlot key.</body></methods><methods><class-id>CraftedSmalltalk.DisplayMethodVarProbe</class-id> <category>saving-loading</category><body package="Debugger-Probes">postLoadIntoMethod: probedMethod	^self updateTempVarForMethod: probedMethod</body></methods><methods><class-id>CraftedSmalltalk.DisplayMethodVarProbe class</class-id> <category>instance creation</category><body package="Debugger-Probes">slot: aSlot	^self new slot: aSlot"Smalltalk Professional Debug Package Version 2.5 (c) 1999 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPManager class</class-id> <category>utilities</category><body package="Debugger-Probes">about	| dialog builder |	dialog := SimpleDialog new.	builder := dialog builder.	builder labelAt: #versionLabel put: ((#Version1s &lt;&lt; #pdp &gt;&gt; 'Version &lt;1s&gt;')			expandMacrosWith: self versionString).	builder aspectAt: #ok put: [dialog close].	dialog allButOpenFrom: (UISpecification from: self aboutSpec).	dialog builder openDialog"Smalltalk Professional Debug Package Version 2.5 (c) 1999 Crafted Smalltalk"</body><body package="Debugger-Probes">browseAllProbedMethods	"Create and schedule a MessageListBrowser for all probed methods."	^MethodCollector new		openListBrowserOn: self allProbedMethodDefinitions		label: (#ProbedMethods &lt;&lt; #pdp &gt;&gt; 'Probed Methods')		initialSelection: nil"Smalltalk Professional Debug Package Version 2.5 (c) 1999 Crafted Smalltalk"</body><body package="Debugger-Probes">findSelectedProbeEmphasisIn: aText		| evalBlock |	evalBlock := [:emp | emp class == ProbeCharacterStyle ifTrue: [^emp]].	aText runs values		do:			[:aValue | 			(aValue isKindOf: Array)				ifTrue: [aValue do: [:obj | evalBlock value: obj]]				ifFalse: [evalBlock value: aValue]].	^nil	"Smalltalk Professional Debug Package Version 3.1 (c) 2003 Crafted Smalltalk"</body><body package="Debugger-Probes">purgeUnusedDebugVariables	"PDPManager purgeUnusedDebugVariables"	 | warray index da |	da := debugVariables bindingFor: #DebugActive.  "Hold onto binding so it will not be removed."	warray := WeakArray new: debugVariables size.	index := 1.	debugVariables associationsDo:		[:ac |		warray at: index put: ac.		index := index + 1].	debugVariables := Dictionary new.	ObjectMemory garbageCollect.	warray do: [:ac | ac == warray tombstone ifFalse: [debugVariables add: ac]]</body><body package="Debugger-Probes">purgeUnusedWatchWindows	"PDPManager purgeUnusedWatchWindows"	| ids newWatches ac |	ObjectMemory garbageCollect.	ids := Set new.	DisplayProbe withAllSubclasses do:			[:probeClass |			probeClass allInstances do: [:aProbe | ids add: aProbe windowID]].	newWatches := Dictionary new.	ids do:		[:anID |		ac := watchWindows associationAt: anID ifAbsent: [nil].		ac isNil			ifFalse: [newWatches add: ac]].	watchWindows := newWatches."Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes">toggleDebugging	self debugActive: self debugActive not."Smalltalk Professional Debug Package Version 3.1 (c) 2002 Crafted Smalltalk"</body><body package="Debugger-Probes">togglePermTempProbeType	defaultToPermanentProbe := defaultToPermanentProbe not."Smalltalk Professional Debug Package Version 3.0 (c) 2001 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPManager class</class-id> <category>accessing</category><body package="Debugger-Probes">addDebugVariable: aSymbol	self addDebugVariable: aSymbol value: nil"Smalltalk Professional Debug Package Version 3.1 (c) 1995-2002 Crafted Smalltalk"</body><body package="Debugger-Probes">addDebugVariable: aSymbol value: anObject	debugVariables at: aSymbol put: anObject"Smalltalk Professional Debug Package Version 3.1 (c) 2002 Crafted Smalltalk"</body><body package="Debugger-Probes">debugActive	^debugVariables at: #DebugActive"Smalltalk Professional Debug Package Version 1.51 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes">debugActive: aBoolean	debugVariables at: #DebugActive put: aBoolean"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes">debugVariableNames	^debugVariables keys asArray"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes">debugVariables	^debugVariables"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes">isPermanentProbeDefault	^defaultToPermanentProbe</body><body package="Debugger-Probes">permanentProbeIsDefault	^defaultToPermanentProbe</body><body package="Debugger-Probes">permanentProbeIsDefault: aBoolean	defaultToPermanentProbe := aBoolean</body><body package="Debugger-Probes">versionString	^'3.1'</body></methods><methods><class-id>CraftedSmalltalk.PDPManager class</class-id> <category>private</category><body package="Debugger-Probes">allProbedMethodDefinitions	ObjectMemory garbageCollect.	^ProbedCompiledMethod allInstalledProbedMethods collect: [:meth | MethodDefinition class: meth mclass selector: meth selector]."Smalltalk Professional Debug Package Version 3.1 (c) 2002 Crafted Smalltalk"</body><body package="Debugger-Probes">newWatchWindow	^WatchWindowHolder new"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes">nextWindowID	| id |	lastID := lastID + 1.	id := lastID printString asSymbol.	watchWindows at: id put: self newWatchWindow.	^id"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPManager class</class-id> <category>probes - recompiling</category><body package="Debugger-Probes">basicReinsertProbesAndIndices: probesAndIndices into: probedMethod	| probesInError |	probesInError := OrderedCollection new.	probesAndIndices do:		[:ac | | probe index newRecord |		probe := ac key baseParent copy.		index := ac value.		newRecord := probedMethod probeRecordFor: (index to: index).		probe record: newRecord.		(probe updateTempVarForMethod: probedMethod)			ifTrue: [probedMethod addProbe: probe]			ifFalse:				[newRecord updateMethod: probedMethod.		"update mclass and selector for reporting"				probesInError add: probe]].	probesInError addAll: probedMethod recompileProbes.	ProbedCompiledMethod reportOnFailedProbes: probesInError."Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes">getProbesAndIndicesFrom: aText	| runs values result emphasis position |	result := OrderedCollection new.	runs := aText runs runs.	values := aText runs values.	position := 1.	1 to: runs size do:		[:i |		emphasis := values at: i.		(emphasis isKindOf: Array)			ifTrue:				[emphasis do:	"There should be only one probe in the emphasis if any."					[:emp | 					emp class == ProbeCharacterStyle						ifTrue: [result add: emp value -&gt; position]]]			ifFalse:				[emphasis class == ProbeCharacterStyle					ifTrue: [result add: emphasis value -&gt; position]].		position := position + (runs at: i)].	^result"Smalltalk Professional Debug Package Version 3.1 (c) 2003 Crafted Smalltalk"</body><body package="Debugger-Probes">reinsertProbesAfterMethod: newMethod recompileFor: aText	| oldProbes |	newMethod isNil		ifTrue: [^self].	newMethod isProbeable		ifFalse: [^newMethod].	oldProbes := self getProbesAndIndicesFrom: aText.	oldProbes isEmpty		ifTrue: [^newMethod].	(Dialog		choose: (#RemoveOrKeepOldProbes &lt;&lt; #pdp &gt;&gt; 'Remove or keep old probes?')		labels: (Array with: (#Remove &lt;&lt; #pdp &gt;&gt; 'Remove') with: (#Keep &lt;&lt; #pdp &gt;&gt; 'Keep'))		values: #(false true)		default: true)		ifFalse: [^newMethod].	^self reinsertProbesAndIndices: oldProbes into: newMethod."Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes">reinsertProbesAndIndices: probesAndIndices into: newMethod	| probedMethod |	probedMethod := newMethod newFullProbedMethod.	self basicReinsertProbesAndIndices: probesAndIndices into: probedMethod.	probedMethod hasAnyProbes		ifFalse: [^newMethod].	probedMethod noNotifyInstall.	^probedMethod"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes">spawnRemovedProbedMethodsBrowser	| removedMethods answer |	removedMethods := ProbedCompiledMethod removedMethods.	removedMethods isEmpty		ifTrue: [^self].	answer := Dialog 				choose: (#ProbesRemovedWhatToDo &lt;&lt; #pdp &gt;&gt; 'Probes were removed due to class recompliation.		What do you want to do with them?')				labels: (Array with: (#ReinstallAll &lt;&lt; #pdp &gt;&gt; 'Reinstall All') with: (#SelectivelyReinstall &lt;&lt; #pdp &gt;&gt; 'Selectively Reinstall') with: (#Discard &lt;&lt; #pdp &gt;&gt; 'Discard'))				values: #(0 1 2)				default: 0.	answer = 2		ifTrue: [^self].	answer = 0		ifTrue:			[[ProbedCompiledMethod recompileAndInsertProbesFrom: removedMethods] fork.			^self].	[RemovedProbedMethodsBrowser onMethods: removedMethods] fork."Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPManager class</class-id> <category>synchronizing tools</category><body package="Debugger-Probes">cancelMethodChangeNotificationFor: aTool	methodDependents remove: aTool ifAbsent: []</body><body package="Debugger-Probes">changedMethodFrom: oldMethod to: newMethod by: aBrowser 	| coll |	coll := OrderedCollection new.	methodDependents do: [:ab | coll add: ab].	coll do:		[:activeTool |		activeTool			changedMethodFrom: oldMethod			to: newMethod			by: aBrowser]"Smalltalk Professional Debug Package Version 3.0 (c) 2002 Crafted Smalltalk"</body><body package="Debugger-Probes">notifyOnMethodChanged: aTool	methodDependents add: aTool</body><body package="Debugger-Probes">revokeMethodChangeNotificationFor: aTool	methodDependents remove: aTool ifAbsent: []</body></methods><methods><class-id>CraftedSmalltalk.PDPManager class</class-id> <category>watch windows</category><body package="Debugger-Probes">display: aString on: windowID for: aProbe		(self getWatchWindow: windowID for: aProbe) showString: aString."Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes">getWatchWindow: windowID for: aProbe 	| windowKey |	windowKey := windowID.	(windowKey isNil or: [windowKey isEmpty])		ifTrue: [aProbe windowID: (windowKey := self nextWindowID)].	(watchWindows includesKey: windowKey)		ifFalse: [watchWindows at: windowKey put: ((self newWatchWindow) label: aProbe labelString; yourself)].	^watchWindows at: windowKey"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes">openWatchWindow: windowID for: aProbe	| window |	window := self getWatchWindow: windowID for: aProbe.	window reopen."Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes">windowHolders	^watchWindows"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPManager class</class-id> <category>launcher menu</category><body package="Debugger-Probes">getEnableProbeDebuggingLabel	^self debugActive		ifTrue: [(#Disable_Probes &lt;&lt; #pdp &gt;&gt; 'Disable &amp;Probes')]		ifFalse: [(#Enable_Probes &lt;&lt; #pdp &gt;&gt; 'Enable &amp;Probes')]."Smalltalk Professional Debug Package Version 1.51 (c) 1995,1997 Crafted Smalltalk"</body><body package="Debugger-Probes">getPermTempProbeLabel	^defaultToPermanentProbe		ifTrue: [(#DefaultTo_TempProbes &lt;&lt; #pdp &gt;&gt; 'Default to &amp;Temp Probes')]		ifFalse: [(#DefaultTo_PermProbes &lt;&lt; #pdp &gt;&gt; 'Default to &amp;Perm Probes')]."Smalltalk Professional Debug Package Version 3.0 (c) 2001 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPManager class</class-id> <category>class initialization</category><body package="Debugger-Probes">initialize	"PDPManager initialize."	debugVariables := Dictionary new.	self addDebugVariable: #DebugActive value: true.	watchWindows isNil		ifTrue:			[watchWindows := Dictionary new.			lastID := 0].	methodDependents := PDPWeakCollection new: 5.	defaultToPermanentProbe := false."Smalltalk Professional Debug Package Version 3.1 (c) 1997 - 2002 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.ProbeExpressionEditor</class-id> <category>text</category><body package="Debugger-Probes">accept: aText from: aController	^self acceptText: aText from: aController.</body><body package="Debugger-Probes">text	^self subclassResponsibility</body><body package="Debugger-Probes">textAccepted: aController	^self acceptText: aController text from: aController</body><body package="Debugger-Probes">value	^self text</body><body package="Debugger-Probes">value: aText	^self acceptText: aText from: self textController.</body></methods><methods><class-id>CraftedSmalltalk.ProbeExpressionEditor</class-id> <category>private</category><body package="Debugger-Probes">acceptText: aText from: aController	| newMethod |	newMethod := ProbeExprCompiler new		compileProbeExpression: aText		forProbe: probe		inClass: probedClass		beginScope: self scope		notifying: aController		ifFail: [^false].	newMethod == nil		ifTrue: [^false].	self newMethodAndSource: newMethod-&gt;aText asString.	self changed: #value.	^true</body><body package="Debugger-Probes">newMethodAndSource: anAssociation	^self subclassResponsibility</body><body package="Debugger-Probes">scope	^probedMethod isNil		ifTrue: [NameScope forClass: probedClass]		ifFalse: [probedMethod variableMapAt: probe blockMethodIndex]</body></methods><methods><class-id>CraftedSmalltalk.ProbeExpressionEditor</class-id> <category>menu messages</category><body package="Debugger-Probes">addGlobalVariable	| name |	name := (Dialog request: (#EnterTheVariableNameC &lt;&lt; #pdp &gt;&gt; 'Enter the variable name:')) asSymbol.	(PDPManager debugVariables includesKey: name)		ifTrue: [^Dialog warn: (#ThatVariableAreadyExists &lt;&lt; #pdp &gt;&gt; 'That variable aready exists.')].	PDPManager addDebugVariable: name.</body><body package="Debugger-Probes">addLocalVariable	| name |	name := (Dialog request: (#EnterTheVariableNameC &lt;&lt; #pdp &gt;&gt; 'Enter the variable name:')) asSymbol.	(probe variables includes: name)		ifTrue: [^Dialog warn: (#ThatVariableAreadyExists &lt;&lt; #pdp &gt;&gt; 'That variable aready exists.')].	probe addVariable: name.</body><body package="Debugger-Probes">insertExpression: existingText from: aController	| expressionNames newName expressionText |	expressionNames := self class expressionNames asArray.	expressionNames isEmpty		ifTrue: [^Dialog warn: (#TheExpressionLibraryIsEmpty &lt;&lt; #pdp &gt;&gt; 'The expression library is empty')].	newName := Dialog 		choose: (#SelectTheExpressionToInsertC &lt;&lt; #pdp &gt;&gt; 'Select the expression to insert:') 		fromList: expressionNames 		values: expressionNames 		lines: 12 		cancel: [^self].	expressionText := (self class atExpName: newName asSymbol) asText.	aController replaceSelectionWith: expressionText</body><body package="Debugger-Probes">insertVariable: a from: aController	| result |	result := self variableMenu startUp.	result = 0		ifTrue: [^self].	aController replaceSelectionWith: result asText.</body><body package="Debugger-Probes">inspectGlobalVariables	PDPManager debugVariables isEmpty		ifTrue: [^Dialog warn: (#NoVariablesToInspect &lt;&lt; #pdp &gt;&gt; 'No variables to inspect')].	PDPManager debugVariables inspect</body><body package="Debugger-Probes">inspectLocalVariables	probe variables isEmpty		ifTrue: [^Dialog warn: (#NoVariablesToInspect &lt;&lt; #pdp &gt;&gt; 'No variables to inspect')].	probe variables inspect</body><body package="Debugger-Probes">saveExpression: existingText from: aController	| name textOrSelection |	name := Dialog		request: #EnterTheExpressionNameC &lt;&lt; #pdp &gt;&gt; 'Enter the expression name:'.	name isEmpty ifTrue: [^self].	(self class includesExpressionName: name) ifTrue:		[(Dialog			confirm:				(#ExprExistsRedefineQ &lt;&lt; #pdp					&gt;&gt; 'That expression aready exists.&lt;n&gt;Do you wish to redefine it?')					expandMacros			initialAnswer: false)				ifFalse: [^self]].	textOrSelection := aController hasRangeSelection		ifTrue: [aController selection]		ifFalse: [aController text].	self class		atExpName: name		put: textOrSelection asString</body></methods><methods><class-id>CraftedSmalltalk.ProbeExpressionEditor</class-id> <category>initialize-release</category><body package="Debugger-Probes">buildTextMenu	"Build the receiver's text menu."	textMenu := Menu				labelList: TextEditorController editGroupLabels , ((OrderedCollection new)								add: (Array											with: #DoIt &lt;&lt; #pdp &gt;&gt; 'Do it'											with: #PrintIt &lt;&lt; #pdp &gt;&gt; 'Print it'											with: #InspectIt &lt;&lt; #pdp &gt;&gt; 'Inspect it');								add: (Array with: #Accept &lt;&lt; #pdp &gt;&gt; 'Accept'											with: #Cancel &lt;&lt; #pdp &gt;&gt; 'Cancel');								add: (Array											with: #InsertVar &lt;&lt; #pdp &gt;&gt; 'Insert Var'											with: #DefineDebugVar &lt;&lt; #pdp &gt;&gt; 'Define Debug Var'											with: #InspectDebugVars &lt;&lt; #pdp &gt;&gt; 'Inspect Debug Vars'											with: #ResetMethod &lt;&lt; #pdp &gt;&gt; 'Reset Method');								add: (Array with: #InsertExpression &lt;&lt; #pdp &gt;&gt; 'Insert Expression'											with: #SaveExpression &lt;&lt; #pdp &gt;&gt; 'Save Expression');								add: (Array with: #Hardcopy &lt;&lt; #pdp &gt;&gt; 'Hardcopy');								asArray)				values: TextEditorController editGroupSelectors						, #(#doIt #printIt #inspectIt #accept:from: #cancel #insertVariable:from:)							, (Array									with: (Menu labelArray: (Array with: #Local &lt;&lt; #pdp &gt;&gt; 'Local'													with: #Global &lt;&lt; #pdp &gt;&gt; 'Global')											values: (Array with: [self addLocalVariable] with: [self addGlobalVariable])))							, (Array									with: (Menu labelArray: (Array with: #Local &lt;&lt; #pdp &gt;&gt; 'Local'													with: #Global &lt;&lt; #pdp &gt;&gt; 'Global')											values: (Array with: [self inspectLocalVariables]													with: [self inspectGlobalVariables]))									with: self resetMethodMenu)							, #(#insertExpression:from: #saveExpression:from: #hardcopy)</body><body package="Debugger-Probes">initialize	super initialize.	self buildTextMenu.</body><body package="Debugger-Probes">probe: aProbe on: aMethod class: aClass	probedMethod := aMethod.	probedClass := aClass.	probe := aProbe.</body><body package="Debugger-Probes">resetMethodMenu	self subclassResponsibility</body></methods><methods><class-id>CraftedSmalltalk.ProbeExpressionEditor</class-id> <category>evaluation</category><body package="Debugger-Probes">doItReceiver	^probe</body></methods><methods><class-id>CraftedSmalltalk.ProbeExpressionEditor</class-id> <category>accessing</category><body package="Debugger-Probes">editor	^self</body><body package="Debugger-Probes">nameScope	^NameScope forClass: probedClass</body><body package="Debugger-Probes">probe	^probe</body><body package="Debugger-Probes">probedClass	^probedClass</body><body package="Debugger-Probes">textController	^(builder componentAt: #textEditor) widget controller</body><body package="Debugger-Probes">turnOffAutoAccept	self textController autoAccept: false.</body></methods><methods><class-id>CraftedSmalltalk.ProbeExpressionEditor</class-id> <category>menus</category><body package="Debugger-Probes">textMenu	"Answer a Menu of operations on the source code that 	is to be displayed when the operate menu button is 	pressed."	^textMenu</body><body package="Debugger-Probes">variableMenu	"Return a menu of all available variable references."	| tnames inames dnames labels values |	tnames := probedMethod isNil		ifTrue: [#()]		ifFalse: 	[(probedMethod variableMapAt: probe blockMethodIndex) tempNames reject: [:name | name first = $.]].	tnames := tnames asSet asSortedCollection.	tnames := tnames , #('TopOFStack').	inames := self scope allInstVarNames.	dnames := probe variableNames , PDPManager debugVariableNames.	labels := #('Method Temp').	values := Array with: (Menu labelArray: tnames values: tnames).	inames isEmpty		ifFalse:			[labels := labels , #('Instance').			values := values , (Array with: (Menu labelArray: inames values: inames))].	dnames isEmpty		ifFalse:			[labels := labels , #('Debug').			values := values , (Array with: (Menu labelArray: dnames values: dnames))].	^Menu 		labelArray: labels		values: values</body></methods><methods><class-id>CraftedSmalltalk.ProbeExpressionEditor class</class-id> <category>expression library</category><body package="Debugger-Probes">atExpName: aString	^expressionLibrary at: aString asSymbol</body><body package="Debugger-Probes">atExpName: aString put: anExpression	^expressionLibrary at: aString asSymbol put: anExpression</body><body package="Debugger-Probes">clearLibrary	(Dialog 		confirm: (#ThisWillRemoveAllExprsContinueQ &lt;&lt; #pdp &gt;&gt; 'This will remove all expressions from the library.					Continue?'))		ifFalse: [^self].	self initializeLibrary</body><body package="Debugger-Probes">expressionNames	^expressionLibrary keys</body><body package="Debugger-Probes">includesExpressionName: aString	^expressionLibrary includesKey: aString asSymbol"Smalltalk Professional Debug Package Version 1.51 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes">initializeLibrary	expressionLibrary := Dictionary new</body><body package="Debugger-Probes">inspectLibrary	expressionLibrary inspect</body><body package="Debugger-Probes">libraryFileComment	self subclassResponsibility</body><body package="Debugger-Probes">readLibrary	| string |	string := Dialog				requestFileName: (#EnterTheNameOfTheExpressionFile &lt;&lt; #pdp &gt;&gt; 'Enter the name of the expression file')				default: ''				version: #mustBeOld.	string isEmpty		ifTrue: [^self].	self readLibraryFromFile: string asFilename</body><body package="Debugger-Probes">readLibraryFromFile: aFilename	| strm |	strm := aFilename readStream.	[(Object readFrom: strm) associationsDo: [:ac | self atExpName: ac key put: ac value]]		ensure: [strm close]</body><body package="Debugger-Probes">saveLibrary	| string |	string := Dialog				requestFileName: (#EnterTheNameOfTheExpressionFile &lt;&lt; #pdp &gt;&gt; 'Enter the name of the expression file')				default: ''				version: #new.	string isEmpty		ifTrue: [^self].	self saveLibraryToFile: string asFilename</body><body package="Debugger-Probes">saveLibraryToFile: aFilename	| strm |	strm := aFilename writeStream.	[strm nextPutAll: self libraryFileComment.	strm cr; cr.	expressionLibrary storeOn: strm]		ensure: [strm close]</body></methods><methods><class-id>CraftedSmalltalk.ProbeActionExpressionEditor</class-id> <category>private</category><body package="Debugger-Probes">newMethodAndSource: anAssociation	probe actionMethodAndSource: anAssociation.</body></methods><methods><class-id>CraftedSmalltalk.ProbeActionExpressionEditor</class-id> <category>menu messages</category><body package="Debugger-Probes">resetMethod	probe resetActionMethod.	self changed: #value.</body></methods><methods><class-id>CraftedSmalltalk.ProbeActionExpressionEditor</class-id> <category>initialize-release</category><body package="Debugger-Probes">resetMethodMenu	^#resetMethod</body></methods><methods><class-id>CraftedSmalltalk.ProbeActionExpressionEditor</class-id> <category>text</category><body package="Debugger-Probes">text	^probe actionSource asText</body></methods><methods><class-id>CraftedSmalltalk.ProbeActionExpressionEditor class</class-id> <category>expression library</category><body package="Debugger-Probes">libraryFileComment	^(#WatchExpressionLibraryFile &lt;&lt; #pdp &gt;&gt; '"Watch expression library file."') asString</body></methods><methods><class-id>CraftedSmalltalk.WatchVariableProbe</class-id> <category>responses</category><body package="Debugger-Probes">actOn: aContext 	| value |	PDPManager debugActive ifFalse: [^self].	testMethod ifNil: [^self].	value := testMethod valueWithReceiver: aContext homeReceiver arguments: (Array with: aContext with: self).	WatchLog object: value for: aContext homeReceiver from: (MethodDefinition class: self probeRecord mclass selector: self probeRecord selector) property: self testSource</body></methods><methods><class-id>CraftedSmalltalk.TopOfStackVariable</class-id> <category>accessing</category><body package="Debugger-Probes">debuggerIndex	^0</body></methods><methods><class-id>CraftedSmalltalk.TopOfStackVariable</class-id> <category>code generation</category><body package="Debugger-Probes">emitLoad: codeStream from: var	| builder node |	builder := ProgramNodeBuilder new.	node := builder		newMessageReceiver: self newDoitContextNode		selector: #top.	node sourcePosition: var sourcePosition.	node emitValue: codeStream</body><body package="Debugger-Probes">emitStore: codeStream value: value from: assignment	(self storeNode: value from: assignment) emitValue: codeStream</body><body package="Debugger-Probes">emitStorePop: codeStream value: value from: assignment	(self storeNode: value from: assignment) emitEffect: codeStream</body></methods><methods><class-id>CraftedSmalltalk.TopOfStackVariable</class-id> <category>code generation-private</category><body package="Debugger-Probes">emitStore: codeStream from: var	"TopOfStackVariable implements the public message emitStore:value:from:,	not the private message. "	self shouldNotImplement</body><body package="Debugger-Probes">emitStorePop: codeStream from: var	"TopOfStackVariable implements the public message emitStorePop:value:from:,	not the private message. "	self shouldNotImplement</body></methods><methods><class-id>CraftedSmalltalk.TopOfStackVariable</class-id> <category>private</category><body package="Debugger-Probes">newDoitContextNode	^VariableNode new name: ProbeExprCompiler doitContextVarName</body><body package="Debugger-Probes">storeNode: valueNode from: assignment	| builder node |	builder := ProgramNodeBuilder new.	node := builder		newMessageReceiver: self newDoitContextNode		selector: #storeTop:		arguments: (Array with: valueNode).	node sourcePosition: assignment sourcePosition.	^node</body></methods><methods><class-id>CraftedSmalltalk.DebuggerException</class-id> <category>private - actions</category><body package="Debugger-Probes">defaultAction	"What to do when the exception is unhandled."	| emergencyHandler |	self aboutToDebug.	(emergencyHandler := UnhandledException emergencyHandler) == nil ifFalse:		[^emergencyHandler value: self value: initialContext].	^Notifier openException: self</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledBlock</class-id> <category>private - probes</category><body package="Debugger-Probes">addProbeToLiterals: aProbe	| probeIndex |	[probeIndex := (probeStart to: self size)			detect: [:i | (self basicAt: i) == nil]			ifNone: [nil].	probeIndex == nil]		whileTrue: [self grow].	self basicAt: probeIndex put: aProbe.	^probeIndex</body><body package="Debugger-Probes">basicAddProbe: aProbe	"Add aProbe to the receiver."	| probeIndex |	probeIndex := self addProbeToLiterals: aProbe.	^(self insertProbeBytecodesFor: probeIndex)		ifNil: [BranchLimit raiseSignal]</body><body package="Debugger-Probes">basicIncludesProbe: targetProbe	| probeIndex aProbe |	probeIndex := probeStart.	[aProbe := self basicAt: probeIndex.	targetProbe = aProbe or: [probeIndex = self size]]		whileFalse: [probeIndex := probeIndex + 1].	^targetProbe = aProbe</body><body package="Debugger-Probes">basicRemoveProbe: aProbe	"Add aProbe to the receiver."	| probeIndex someProbe probeRecord pc newBytes segments map |	probeIndex := probeStart.		[someProbe := self basicAt: probeIndex.	aProbe = someProbe]			whileFalse: [probeIndex := probeIndex + 1].	probeRecord := (self basicAt: probeIndex) probeRecord.	self basicAt: probeIndex put: nil.	"Make position empty."	pc := probeRecord insertionPC.	segments := JumpDecomposer new forMethod: self.	self sourceMap do: [:me | me registerPCsWith: segments].	self probesDo: [:prb | prb probeRecord registerPCsWith: segments].	segments := segments decompose.	segments do: 			[:seg |			(pc between: seg oldBasePC and: seg oldBasePC + seg bytes size)				ifTrue: 					[seg						removeBytesAt: pc + 1 - seg oldBasePC						size: probeRecord bytesInBytecodes						segments: segments]].	newBytes := segments first class composeSegments: segments.	map := PCAdjustmentMap fromSegments: segments.	bytes := (ByteArray new: newBytes size + 4)				replaceFrom: 1				to: 4				with: bytes				startingAt: 1.	bytes		replaceFrom: 5		to: bytes size		with: newBytes		startingAt: 1.	bytes at: 4		put: ((AuxCodeInfoExtractor new)				method: self;				run;				maxDepth).	^map</body><body package="Debugger-Probes">insertProbeBytecodesFor: probeIndex	| newBytes probeRecord pc fragment segments map |	probeRecord := (self basicAt: probeIndex) probeRecord.	pc := probeRecord insertionPCFor: self.	fragment := (AssemblerCodeStream new)				initializeLiteralsFrom: self;				pushConstant: (self basicAt: probeIndex);				pushContext;				sendNonImmediate: #actOn: numArgs: 1;				pop;				bytes.	segments := JumpDecomposer new forMethod: self.	self sourceMap do: [:me | me registerPCsWith: segments].	self probesDo: [:aProbe | aProbe probeRecord registerPCsWith: segments].	segments := segments decompose.	segments do: 			[:seg |			(pc between: seg oldBasePC and: seg oldBasePC + seg bytes size)				ifTrue: 					[seg						insertBytesAt: pc + 1 - seg oldBasePC						bytes: fragment						for: probeRecord						segments: segments]].	newBytes := [segments first class composeSegments: segments]				on: ByteCodeStream branchLimitSignal				do: [:x | ^nil].	map := PCAdjustmentMap fromSegments: segments.	probeRecord bytesInBytecodes: fragment size.	bytes := (ByteArray new: newBytes size + 4)				replaceFrom: 1				to: 4				with: bytes				startingAt: 1.	bytes		replaceFrom: 5		to: bytes size		with: newBytes		startingAt: 1.	bytes at: 4		put: ((AuxCodeInfoExtractor new)				method: self;				run;				maxDepth).	^map</body><body package="Debugger-Probes">probesDo: aBlock 	probeStart to: self size do: 		[:i | 		| aProbe |		aProbe := self basicAt: i.		aProbe == nil			ifFalse: [aBlock value: aProbe]]</body><body package="Debugger-Probes">probeSize	| count |	count := 0.	probeStart to: self basicSize do: 		[:i | 		(self basicAt: i) isNil			ifFalse: [count := count + 1]].	^count</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledBlock</class-id> <category>initialize-release</category><body package="Debugger-Probes">copyFrom: oldSelf	"Copy all the instance variable from oldSelf to the receiver.	This is used to grow a new method."	1 to: oldSelf basicSize do:		[ :i | self basicAt: i put: (oldSelf basicAt: i)].	1 to: self class instSize do:		[ :i | self instVarAt: i put: (oldSelf instVarAt: i)].</body><body package="Debugger-Probes">from: aCompiledBlock	"Recursively create a new ProbedCompiledBlock from aCompliedBlock."	| flags |	probeStart := aCompiledBlock numLiterals + 2.	self at: probeStart - 1 put: #actOn:.	1 to: aCompiledBlock numLiterals do: 		[:i | | lit cl bm |		lit := aCompiledBlock literalAt: i.		cl := lit class.		cl == CompiledBlock			ifTrue: 				[self literalAt: i put: (lit := ProbedCompiledBlock from: lit).				lit outerMethod: self]			ifFalse:				[cl == BlockClosure					ifTrue: 						[self literalAt: i put: (lit := lit copy).						bm := ProbedCompiledBlock from: lit method.						lit method: bm.						bm outerMethod: self]					ifFalse: [self literalAt: i put: lit]]].	flags := 16rE0 + (aCompiledBlock usesContextInstVars ifTrue: [16] ifFalse: [0]).	bytes := (ByteArray				with: flags				with: aCompiledBlock numArgs				with: aCompiledBlock numTempsOnly				with: aCompiledBlock frameSize) , aCompiledBlock bytes.	^self</body><body package="Debugger-Probes">grow	| newSelf |	newSelf := self class new: self basicSize + 7.	newSelf copyFrom: self.	newSelf become: self</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledBlock</class-id> <category>testing</category><body package="Debugger-Probes">basicHasAnyProbes	^(probeStart to: self size)		anySatisfy: [:i | (self basicAt: i) notNil]</body><body package="Debugger-Probes">isProbed	^true</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledBlock</class-id> <category>accessing</category><body package="Debugger-Probes">sourceMap	^self homeMethod methodHolder sourceMap at: self blockMethodIndex</body><body package="Debugger-Probes">variableMap	^self homeMethod methodHolder variableMap at: self blockMethodIndex</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledBlock</class-id> <category>copying</category><body package="Debugger-Probes">basicMethodDcopyUsing: copyDict	^self basicDcopyUsing: copyDict</body><body package="Debugger-Probes">postDcopyUsing: copyDict	outerMethod := outerMethod basicDcopyUsing: copyDict.	1 to: self basicSize do: [ :i | self basicAt: i put: ((self basicAt: i) basicMethodDcopyUsing: copyDict)]</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledBlock class</class-id> <category>instance creation</category><body package="Debugger-Probes">from: aCompiledBlockMethod	^(self new: aCompiledBlockMethod basicSize + 7) from: aCompiledBlockMethod"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.DebugStepIntoBlockClosure</class-id> <category>evaluating</category><body package="Debugger-Probes">value	Processor activeProcess isStepIntoBlock		ifTrue: 			[BlockClosure adoptInstance: self.			StepIntoBlockNotification				raiseRequestWith: (MethodContext						sender: thisContext						receiver: self						method: (BlockClosure compiledMethodAt: #value )						arguments: #()) step].	^super value</body><body package="Debugger-Probes">value: arg	Processor activeProcess isStepIntoBlock		ifTrue: 			[BlockClosure adoptInstance: self.			StepIntoBlockNotification				raiseRequestWith: (MethodContext						sender: thisContext						receiver: self						method: (BlockClosure compiledMethodAt: #value:)						arguments:  ( Array with: arg ) ) step].	^super value: arg</body><body package="Debugger-Probes">value: arg1 value: arg2	Processor activeProcess isStepIntoBlock		ifTrue: 			[BlockClosure adoptInstance: self.			StepIntoBlockNotification				raiseRequestWith: (MethodContext						sender: thisContext						receiver: self						method: (BlockClosure compiledMethodAt: #value:value:)						arguments: ( Array with: arg1 with: arg2 )) step].	^super value: arg1 value: arg2</body><body package="Debugger-Probes">value: arg1 value: arg2 value: arg3	Processor activeProcess isStepIntoBlock		ifTrue: 			[BlockClosure adoptInstance: self.			StepIntoBlockNotification				raiseRequestWith: (MethodContext						sender: thisContext						receiver: self						method: (BlockClosure compiledMethodAt: #value:value:value:)						arguments: ( Array with: arg1 with: arg2 with: arg3 ) ) step].	^super value: arg1 value: arg2 value: arg3</body><body package="Debugger-Probes">valueWithArguments: anArray	"Override evaluation to raise a signal if the receiver is being evaluated	 in the context of the debugger's current debug process."	Processor activeProcess isStepIntoBlock		ifTrue: 			[BlockClosure adoptInstance: self.			StepIntoBlockNotification				raiseRequestWith: (MethodContext						sender: thisContext						receiver: self						method: (BlockClosure compiledMethodAt: #valueWithArguments:)						arguments: ( Array with: anArray ) ) step].	^super valueWithArguments: anArray</body></methods><methods><class-id>CraftedSmalltalk.DebugStepIntoBlockClosure class</class-id> <category>instance creation</category><body package="Debugger-Probes">new	"This class exists only for the use of the debugger."	^self shouldNotImplement</body></methods><methods><class-id>CraftedSmalltalk.WatchLogEvent</class-id> <category>accessing</category><body package="Debugger-Probes">counter	^counter</body><body package="Debugger-Probes">counter: anObject	counter := anObject</body><body package="Debugger-Probes">description	^description</body><body package="Debugger-Probes">description: anObject	description := anObject</body><body package="Debugger-Probes">method	^method</body><body package="Debugger-Probes">method: anObject	method := anObject</body><body package="Debugger-Probes">receiver	^receiver</body><body package="Debugger-Probes">receiver: anObject	receiver := anObject</body><body package="Debugger-Probes">timestamp	^timestamp</body><body package="Debugger-Probes">timestamp: anObject	timestamp := anObject</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>probe management</category><body package="Debugger-Probes">addProbe: aProbe	"Add aProbe to the receiver."	^(self blockAt: aProbe blockMethodIndex) basicAddProbe: aProbe</body><body package="Debugger-Probes">loadProbesFrom: aStream	| fieldName numVars aProbe probesInError |	fieldName := aStream upTo: Character space.	fieldName = 'Probes:'		ifFalse:			[^AbstractCodeProbe unknowLoadField: fieldName on: aStream expected: 'Probes:'].	probesInError := OrderedCollection new.	numVars := Number readFrom: aStream.	aStream next.	"swallow cr"	[numVars = 0]		whileFalse:			[aProbe := CodeProbe createFrom: aStream.			(aProbe reinsertAfterLoadInto: self)				ifFalse: [probesInError add: aProbe].			numVars := numVars - 1].	^probesInError</body><body package="Debugger-Probes">recompileProbes	| probesInError |	probesInError := OrderedCollection new.	self probesDo:		[:aProbe |		(aProbe recompileExpressionsUsingProbedMethod: self)			ifFalse: [probesInError add: aProbe]].	^probesInError</body><body package="Debugger-Probes">reinsertProbe: aProbe	"This method is for reinserting probes into a method after loading from a file.	  DO NOT use when changing the method source code!	Returns false if there is a problem with the probe, true otherwise."	^(aProbe updateInstanceVarIndexForMethod: self) and:		[aProbe reinsertInto: self.		aProbe recompileExpressionsUsingProbedMethod: self]</body><body package="Debugger-Probes">reinsertProbesFrom: origProbedMethod	"This method is for reinserting probes into a method that has been recompiled	because of a change in class definition.  DO NOT use when changing the method	source code!"	| probesInError |	probesInError := OrderedCollection new.	origProbedMethod probesDo:		[:aProbe |		(self reinsertProbe: aProbe)			ifFalse: [probesInError add: aProbe]].	^probesInError</body><body package="Debugger-Probes">removeProbe: targetProbe	"Remove aProbe from the receiver."	^(self blockAt: targetProbe blockMethodIndex)		basicRemoveProbe: targetProbe</body><body package="Debugger-Probes">saveOn: aStream	| permProbes |	permProbes := OrderedCollection new.	self allProbesDo: [:aProbe | aProbe isPermanent ifTrue: [permProbes add: aProbe]].	permProbes isEmpty		ifTrue: [^self].	self printNameOn: aStream inClass: mclass.	aStream cr;		nextPutAll: 'CRC: '.	(CRC32Function crc32Of: (self getSource string asByteArrayEncoding: #UTF8)) printOn: aStream.	aStream cr.	aStream nextPutAll: 'Probes: '.	permProbes size printOn: aStream.	aStream cr.	permProbes do: [:aProbe | aProbe saveOn: aStream].</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>accessing - probes</category><body package="Debugger-Probes">allProbesDo: aBlock	self withAllProbedBlockMethodsDo: [:pBlock | pBlock probesDo: aBlock]</body><body package="Debugger-Probes">includesProbe: targetProbe	"Return true if the receiver contains targetProbe."	^(self blockAt: targetProbe blockMethodIndex) basicIncludesProbe: targetProbe.</body><body package="Debugger-Probes">jumpRecordFor: selectionRange blkIndex: blkIndex	"Get the probe record corresponding to selectionRange."	^methodHolder node jumpRecordFor: selectionRange blkIndex: blkIndex</body><body package="Debugger-Probes">probeRecordFor: selectionRange	"Get the probe record corresponding to selectionRange."	^methodHolder node probeRecordFor: selectionRange</body><body package="Debugger-Probes">probesDo: aBlock 	probeStart to: self size do: 		[:i | 		| aProbe |		aProbe := self basicAt: i.		aProbe == nil			ifFalse: [aBlock value: aProbe]]</body><body package="Debugger-Probes">scopeForProbe: aProbe	^self variableMapAt: aProbe blockMethodIndex</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>private - probes</category><body package="Debugger-Probes">addProbeToLiterals: aProbe	| probeIndex |	[probeIndex := (probeStart to: self size)			detect: [:i | (self basicAt: i) == nil]			ifNone: [nil].	probeIndex == nil]		whileTrue: [self grow].	self basicAt: probeIndex put: aProbe.	^probeIndex</body><body package="Debugger-Probes">basicAddProbe: aProbe	"Add aProbe to the receiver."	| probeIndex |	probeIndex := self addProbeToLiterals: aProbe.	^(self insertProbeBytecodesFor: probeIndex)		ifNil: [BranchLimit raiseSignal]</body><body package="Debugger-Probes">basicHasAnyProbes	^(probeStart to: self size)		anySatisfy: [:i | (self basicAt: i) notNil]</body><body package="Debugger-Probes">basicIncludesProbe: targetProbe	| probeIndex aProbe |	probeIndex := probeStart.	[aProbe := self basicAt: probeIndex.	targetProbe = aProbe or: [probeIndex = self size]]		whileFalse: [probeIndex := probeIndex + 1].	^targetProbe = aProbe</body><body package="Debugger-Probes">basicRemoveProbe: aProbe	"Add aProbe to the receiver."	| probeIndex someProbe probeRecord pc newBytes segments map |	probeIndex := probeStart.		[someProbe := self basicAt: probeIndex.	aProbe = someProbe]			whileFalse: [probeIndex := probeIndex + 1].	probeRecord := (self basicAt: probeIndex) probeRecord.	self basicAt: probeIndex put: nil.	"Make position empty."	pc := probeRecord insertionPC.	segments := JumpDecomposer new forMethod: self.	self sourceMap do: [:me | me registerPCsWith: segments].	self probesDo: [:prb | prb probeRecord registerPCsWith: segments].	segments := segments decompose.	segments do: 			[:seg |			(pc between: seg oldBasePC and: seg oldBasePC + seg bytes size)				ifTrue: 					[seg						removeBytesAt: pc + 1 - seg oldBasePC						size: probeRecord bytesInBytecodes						segments: segments]].	newBytes := segments first class composeSegments: segments.	map := PCAdjustmentMap fromSegments: segments.	bytes := (ByteArray new: newBytes size + 4)				replaceFrom: 1				to: 4				with: bytes				startingAt: 1.	bytes		replaceFrom: 5		to: bytes size		with: newBytes		startingAt: 1.	bytes at: 4		put: ((AuxCodeInfoExtractor new)				method: self;				run;				maxDepth).	^map</body><body package="Debugger-Probes">insertProbeBytecodesFor: probeIndex	| newBytes probeRecord pc fragment segments map |	probeRecord := (self basicAt: probeIndex) probeRecord.	pc := probeRecord insertionPCFor: self.	fragment := (AssemblerCodeStream new)				initializeLiteralsFrom: self;				pushConstant: (self basicAt: probeIndex);				pushContext;				sendNonImmediate: #actOn: numArgs: 1;				pop;				bytes.	segments := JumpDecomposer new forMethod: self.	self sourceMap do: [:me | me registerPCsWith: segments].	self probesDo: [:aProbe | aProbe probeRecord registerPCsWith: segments].	segments := segments decompose.	segments do: 			[:seg |			(pc between: seg oldBasePC and: seg oldBasePC + seg bytes size)				ifTrue: 					[seg						insertBytesAt: pc + 1 - seg oldBasePC						bytes: fragment						for: probeRecord						segments: segments]].	newBytes := [segments first class composeSegments: segments]				on: ByteCodeStream branchLimitSignal				do: [:x | ^nil].	map := PCAdjustmentMap fromSegments: segments.	probeRecord bytesInBytecodes: fragment size.	bytes := (ByteArray new: newBytes size + 4)				replaceFrom: 1				to: 4				with: bytes				startingAt: 1.	bytes		replaceFrom: 5		to: bytes size		with: newBytes		startingAt: 1.	bytes at: 4		put: ((AuxCodeInfoExtractor new)				method: self;				run;				maxDepth).	^map</body><body package="Debugger-Probes">probeSize	| count |	count := 0.	probeStart to: self basicSize do: 		[:i | 		(self basicAt: i) isNil			ifFalse: [count := count + 1]].	^count</body><body package="Debugger-Probes">totalProbes	| total |	total := 0.	self withAllProbedBlockMethodsDo: [:aBlock | total := aBlock probeSize + total].	^total</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>accessing</category><body package="Debugger-Probes">collectReferencesTo: variable	^methodHolder node collectReferencesTo: variable</body><body package="Debugger-Probes">installedMethod	^mclass compiledMethodAt: self selector ifAbsent: [nil].</body><body package="Debugger-Probes">methodHolder	^methodHolder</body><body package="Debugger-Probes">newFullProbedMethod	^self dcopy</body><body package="Debugger-Probes">newNormalProbedMethod	^self dcopy</body><body package="Debugger-Probes">newTempFullProbedMethod	^self newTempProbedMethod</body><body package="Debugger-Probes">newTempProbedMethod	| nuMethod |	AbstractCodeProbe setClone.	nuMethod := self dcopy.	nuMethod originalMethod: self.	AbstractCodeProbe setCopy.	^nuMethod</body><body package="Debugger-Probes">originalMethod	^original originalMethod</body><body package="Debugger-Probes">originalMethod: aMethod	original := aMethod</body><body package="Debugger-Probes">permanentMethod	^original</body><body package="Debugger-Probes">selector	^methodHolder selector</body><body package="Debugger-Probes">sourceInfoIfCached	^methodHolder</body><body package="Debugger-Probes">sourceMap	^methodHolder sourceMap at: 1</body><body package="Debugger-Probes">sourceMapAt: index	^methodHolder sourceMap at: index</body><body package="Debugger-Probes">variableMap	^methodHolder variableMap at: 1</body><body package="Debugger-Probes">variableMapAt: index	^methodHolder variableMap at: index</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>copying</category><body package="Debugger-Probes">copy	^self class registerMethod: super copy.</body><body package="Debugger-Probes">dcopy	^self class registerMethod: super dcopy.</body><body package="Debugger-Probes">postDcopyUsing: copyDict	methodHolder := methodHolder basicDcopyUsing: copyDict.	1 to: self basicSize do: [ :i | self basicAt: i put: ((self basicAt: i) basicMethodDcopyUsing: copyDict)]</body><body package="Debugger-Probes">shallowCopy	^self class registerMethod: super shallowCopy.</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>initialize-release</category><body package="Debugger-Probes">copyFrom: oldSelf	1 to: oldSelf basicSize do:		[ :i | self basicAt: i put: (oldSelf basicAt: i)].	1 to: self class instSize do:		[ :i | self instVarAt: i put: (oldSelf instVarAt: i)].</body><body package="Debugger-Probes">from: aCompiledMethod full: fullFlag	| adjustedMethod compiler |	original := aCompiledMethod.	mclass := aCompiledMethod mclass.	sourceCode := aCompiledMethod sourcePointer.	(mclass compilerClass == Compiler		or: [(mclass compilerClass respondsTo: #treatsAsSimpleSmalltalk:)			and: [mclass compilerClass treatsAsSimpleSmalltalk: self getSource]])		ifFalse: [^self error: (#CannotInsertIncompatibleCompiler &lt;&lt; #pdp &gt;&gt; 'Cannot insert probe, selected class uses incompatible compiler.')].	compiler := ProbeExprCompiler new.	fullFlag		ifTrue: [compiler setCompileForProbes].	methodHolder := compiler			parse: aCompiledMethod getSource			in: mclass			environment: aCompiledMethod environment			allowReceiver: true			noPattern: aCompiledMethod usuallyHasSelector not			notifying: nil.	adjustedMethod := methodHolder generate.	probeStart := adjustedMethod numLiterals + 2.	self at: probeStart - 1 put: #actOn:.	1 to: adjustedMethod numLiterals do: 		[:i | | lit cl bm |		lit := adjustedMethod literalAt: i.		cl := lit class.		cl == CompiledBlock			ifTrue: 				[self literalAt: i put: (lit := ProbedCompiledBlock from: lit).				lit outerMethod: self]			ifFalse:				[cl == BlockClosure					ifTrue: 						[self literalAt: i put: (lit := lit copy).						bm := ProbedCompiledBlock from: lit method.						lit method: bm.						bm outerMethod: self]					ifFalse: [self literalAt: i put: lit]]].	self initializeBytes.	^self</body><body package="Debugger-Probes">grow	| newSelf |	newSelf := self class new: self basicSize + 7.	newSelf copyFrom: self.	newSelf become: self</body><body package="Debugger-Probes">install	self noNotifyInstall.	PDPManager		changedMethodFrom: original		to: self		by: nil.</body><body package="Debugger-Probes">noNotifyInstall	mclass addSelector: self selector withMethod: self.</body><body package="Debugger-Probes">revert	"Restore the original method. Returns true if successful, otherwise false."	self installedMethod == self		ifFalse: [^false].	mclass		addSelector: self selector		withMethod: original.	PDPManager		changedMethodFrom: original		to: self		by: nil.	^true</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>testing</category><body package="Debugger-Probes">hasAnyProbes	self withAllProbedBlockMethodsDo: [:aBlock | aBlock basicHasAnyProbes ifTrue: [^true]].	^false</body><body package="Debugger-Probes">isInSystem	^mclass notNil and: [self installedMethod == self]</body><body package="Debugger-Probes">isPartiallyBound	^self installedMethod originalMethod == self originalMethod</body><body package="Debugger-Probes">isProbed	^true</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>source code management</category><body package="Debugger-Probes">highlightProbesIn: sourceText	"Return sourceText with probe locations emphasized."	self allProbesDo: [:aProbe | aProbe emphasize: sourceText].	^sourceText</body><body package="Debugger-Probes">sourcePointer: sourceRef	"Update the original method's source pointer as well as my own.	Changing the source pointer (e.g. by creating a new sources file) must be propagated,	otherwise the original method cannot be reinstalled with its original source code."	super sourcePointer: sourceRef.	self originalMethod sourcePointer: sourceRef</body><body package="Debugger-Probes">sourceText	^self highlightProbesIn: (self getSource asText makeSelectorBoldIn: mclass)</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>printing</category><body package="Debugger-Probes">printNameOn: aStream inClass: aClass	| selector class |	aClass isNil		ifTrue:			[| who |			mclass isNil				ifTrue:					[aStream nextPutAll: (#ParenUnboundMethodParen &lt;&lt; #pdp &gt;&gt; '(Unbound method)') asString.					^self].			who := self who.			who isNil				ifTrue:					[class := mclass.					selector := class defaultSelectorForMethod: self]				ifFalse:					[class := who first.					selector := who at: 2]]		ifFalse:			[class := aClass.			selector := self selector].	aStream nextPutAll: class shortName.	mclass == class 		ifFalse: 			[aStream nextPut: $(.			aStream nextPutAll: mclass shortName.			aStream nextPut: $)].	aStream nextPutAll: '&gt;&gt;'.	aStream nextPutAll: selector</body><body package="Debugger-Probes">who 	"Answer an Array of the class in which the receiver is defined and	the selector to which it corresponds.  If the receiver is not defined	in any class, answer nil."	mclass isNil		ifTrue: [^nil].	^Array with: mclass with: self selector</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>fileIn/Out</category><body package="Debugger-Probes">representBinaryOn: bosWriter	" The stored representation of	CompiledMethods is special.  Overriding this method	helps prevent bossing out of probed methods. "	^bosWriter representCompiledMethod: original</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>tracing</category><body package="Debugger-Probes">traceFrom: aTracer	self error: (#ParcellingOutAProbedMethodErrorMessage &lt;&lt; #pdp &gt;&gt; 'An attempt was made to parcel out a ProbedCompiledMethod.  You must remove the probes from the target methods before parceling them out.')</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>private - bytes</category><body package="Debugger-Probes">initializeBytes	| adjustedMethod flags |	adjustedMethod := methodHolder generate.	flags := 16rC0 + (adjustedMethod usesContextInstVars ifTrue: [16] ifFalse: [0]).	bytes := (ByteArray				with: flags 				with: original numArgs				with: adjustedMethod numTempsOnly				with: adjustedMethod frameSize) , adjustedMethod bytes.</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod class</class-id> <category>utilities</category><body package="Debugger-Probes">allInstalledProbedMethods	^(self allProbedMethods select: [:meth | meth isInSystem]) asArray</body><body package="Debugger-Probes">allProbedMethods	^self allInstances asOrderedCollection addAll: (ProbedAnnotatedMethod allInstances);yourself</body><body package="Debugger-Probes">readProbesFromFile	| fileName libStream |	fileName := Dialog requestFileName: (#NameOfProbeLibrary &lt;&lt; #pdp &gt;&gt; 'Name of probe library') default: '*.prb' version: #mustBeOld.	fileName isEmpty		ifTrue: [^self].	libStream := fileName asFilename readStream lineEndAuto.	[self probeMethodsFrom: libStream]		ensure: [libStream close]</body><body package="Debugger-Probes">registerMethod: aMethod	^aMethod</body><body package="Debugger-Probes">revertAllProbedMethodsInSystem	self allInstalledProbedMethods do: [:each | each revert]</body><body package="Debugger-Probes">saveProbesToFile	| fileName libStream |	fileName := Dialog requestNewFileName: (#NameOfProbeLibrary &lt;&lt; #pdp &gt;&gt; 'Name of probe library') default: '*.prb'.	fileName isEmpty		ifTrue: [^self].	libStream := fileName asFilename writeStream.	[self allInstalledProbedMethods do: [:pMeth | pMeth saveOn: libStream]]		ensure: [libStream close]"Smalltalk Professional Debug Package Version 2.5 (c) 1999 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod class</class-id> <category>recompiling</category><body package="Debugger-Probes">dontKeepRemovedMethods	removedProbedMethodsHolder := PluggableAdaptor on: ValueHolder new.	removedProbedMethodsHolder		getBlock: [:m | Array new]		putBlock: [:m :v | v]		updateBlock: [:m :a :p | false]"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes">keepRemovedMethods	removedProbedMethodsHolder := PluggableAdaptor on: (ValueHolder with: OrderedCollection new).	removedProbedMethodsHolder		getBlock: [:m | m value]		putBlock: [:m :v | m value addAll: v]		updateBlock: [:m :a :p | false]"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes">recompileAndInsertProbesFrom: probedMethods	| probesInError |	probesInError := OrderedCollection new.	probedMethods do:		[:meth | | newProbedMethod |		newProbedMethod := meth installedMethod newFullProbedMethod.		probesInError addAll: (newProbedMethod reinsertProbesFrom: meth).		newProbedMethod hasAnyProbes			ifTrue: [newProbedMethod install]].	self reportOnFailedProbes: probesInError."Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes">removedMethods	^removedProbedMethodsHolder value"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes">removedMethods: methods	^removedProbedMethodsHolder value: methods"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body><body package="Debugger-Probes">reportOnFailedProbes: probesInError	| writeStream |	probesInError isEmpty		ifTrue: [^self].	writeStream := WriteStream on: (String new: 200).	writeStream nextPutAll: (#TheFollowingProbesFailedToRecompile &lt;&lt; #pdp &gt;&gt; 'The following probes failed to recompile correctly.') asString.	probesInError do: [:aProbe |		writeStream nextPutAll: aProbe methodString;			nextPutAll: ((#SpProbeAt1pDash2s &lt;&lt; #pdp &gt;&gt; ' probe at &lt;1p&gt; - &lt;2s&gt;&lt;n&gt;') 				expandMacrosWith: aProbe characterIndex printString				with: aProbe reportString)].	[ComposedTextView		open: writeStream contents asText asValue		label: (#FailedProbeRecompileReport &lt;&lt; #pdp &gt;&gt; 'Failed probe recompile report')] fork"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod class</class-id> <category>instance creation</category><body package="Debugger-Probes">from: aCompiledMethod full: fullFlag	^(self new: aCompiledMethod basicSize + 7) from: aCompiledMethod full: fullFlag"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes">probeMethodsFrom: aStream	| aClassName selector meth cls |	[aStream atEnd] whileFalse: 			[aClassName := aStream upTo: $&gt;.			aStream next == $&gt;				ifFalse: 					[^UserNotification						raiseSignal: #CannotUnderstandClassselector &lt;&lt; #pdp &gt;&gt; 'Cannot understand class&gt;&gt;selector'].			selector := aStream upTo: Character cr.			cls := Compiler evaluate: aClassName.			cls isNil				ifTrue: 					[^UserNotification						raiseSignal: (#BadClassNameC1s &lt;&lt; #pdp &gt;&gt; 'Bad class name: &lt;1s&gt;' expandMacrosWith: aClassName)].			meth := cls compiledMethodAt: selector asSymbol						ifAbsent: 							[^UserNotification raiseSignal: (#x1sDoesNotHaveMethod2s &lt;&lt; #pdp &gt;&gt; '&lt;1s&gt; does not have method #&lt;2s&gt;'										expandMacrosWith: aClassName										with: selector)].			(self readMethodCRCFrom: aStream)				= (CRC32Function crc32Of: (meth getSource string asByteArrayEncoding: #UTF8))					ifTrue: 						[(meth isProbed and: 								[(Dialog									confirm: (#ReplaceProbeQuery &lt;&lt; #pdp &gt;&gt; 'Include probes in &lt;1p&gt;&gt;&gt;&lt;2s&gt;' expandMacrosWith: cls with: selector))										not])							ifTrue: [self skipNextProbeIn: aStream]							ifFalse: 								[meth := meth newFullProbedMethod.								meth loadProbesFrom: aStream.								meth install]]					ifFalse: 						[UserNotification							raiseSignal: (#CannotInsertProbesMethodChanged &lt;&lt; #pdp &gt;&gt; 'Cannot insert probe,  &lt;1p&gt;&gt;&gt;&lt;2s&gt; has changed.'									expandMacrosWith: cls									with: selector).						self skipNextProbeIn: aStream]]</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod class</class-id> <category>class initialization</category><body package="Debugger-Probes">initialize	self dontKeepRemovedMethods."Smalltalk Professional Debug Package Version 3.1 (c) 2002 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod class</class-id> <category>private</category><body package="Debugger-Probes">readMethodCRCFrom:  aStream	| fieldName result |	fieldName := aStream upTo: Character space.	fieldName = 'CRC:'		ifFalse:			[^AbstractCodeProbe unknowLoadField: fieldName on: aStream expected: 'CRC:'].	result := Number readFrom: aStream.	aStream next.	"swallow cr"	^result"Smalltalk Professional Debug Package Version 2.5 (c) 1999 Crafted Smalltalk"</body><body package="Debugger-Probes">skipNextProbeIn: aStream	| numVars |	aStream skipThroughAll: 'Probes:'.	aStream skipSeparators.	numVars := Number readFrom: aStream.	aStream next.	"swallow cr"	[numVars = 0]		whileFalse:			[CodeProbe createFrom: aStream.			numVars := numVars - 1].</body></methods><methods><class-id>Kernel.PCAdjustmentMap</class-id> <category>accessing</category><body package="Debugger-Probes">addSegments: aSegmentSequence	segments addAll: aSegmentSequence</body><body package="Debugger-Probes">at: anOriginalPC	"Scan my segments, for a segment which includes anOriginalPC and is willing to give us the adjusted one, including any changes that have occured in the bytecodes of the segment."	segments		do: [:each | (each adjustedPCFromOriginal: anOriginalPC) ifNotNil: [:newPC | ^newPC]].	self error: 'unmappable PC'</body></methods><methods><class-id>Kernel.PCAdjustmentMap</class-id> <category>initialize-release</category><body package="Debugger-Probes">initialize	segments := OrderedCollection new</body></methods><methods><class-id>Kernel.PCAdjustmentMap class</class-id> <category>instance creation</category><body package="Debugger-Probes">fromSegments: aSegmentSequence	^self new addSegments: aSegmentSequence</body><body package="Debugger-Probes">new	^super new initialize</body></methods><methods><class-id>CraftedSmalltalk.CRC32Function class</class-id> <category>converting</category><body package="Debugger-Probes">crc32Of: aByteArray	^self crc32Of: aByteArray initial: 0"Smalltalk Professional Debug Package Version 2.5 (c) 1999 Crafted Smalltalk"</body><body package="Debugger-Probes">crc32Of: aByteArray initial: initialCRC	| crc |	crc := initialCRC.	1 to: aByteArray size do:		[:i |		crc := (CRC32Table at: ((aByteArray at: i) bitXor: (crc quo: 16r1000000)) + 1) bitXor: ((crc bitAnd: 16rffffff) * 256)].	^crc"Smalltalk Professional Debug Package Version 2.5 (c) 1999 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.CRC32Function class</class-id> <category>class initialization</category><body package="Debugger-Probes">initialize	self initializeCRC32Table</body><body package="Debugger-Probes">initializeCRC32Table	| ans |	CRC32Table := Array new: 256.	0 to: 255 do:		[:i |		ans := i * 16r1000000.		1 to: 8 do:			[:j |			ans := ans * 2.			ans &lt; 16r100000000				ifFalse: [ans := ans bitXor: 16r4c11db7.].			ans := ans bitAnd: 16rffffffff].		CRC32Table at: i + 1 put: ans]."Smalltalk Professional Debug Package Version 2.5 (c) 1999 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.DisplayActionProbe</class-id> <category>accessing</category><body package="Debugger-Probes">actionMethod	^actionMethod</body><body package="Debugger-Probes">actionMethodAndSource	^actionMethod -&gt; actionSource</body><body package="Debugger-Probes">actionMethodAndSource: anAssoc	actionMethod := anAssoc key.	actionSource := anAssoc value string.</body><body package="Debugger-Probes">actionSource	actionSource notNil		ifTrue: [^actionSource].	actionMethod isNil		ifTrue: [^String new].	^actionMethod getSource string</body><body package="Debugger-Probes">basicActionMethod	^actionMethod</body><body package="Debugger-Probes">basicActionSource	^actionSource</body><body package="Debugger-Probes">compileExpression: aString inClass: aClass scope: aScope	| aMethod |	aMethod := ProbeExprCompiler new				compileProbeExpression: aString				forProbe: self				inClass: aClass				beginScope: aScope				notifying: nil				ifFail: [nil].	self actionMethodAndSource: aMethod -&gt; aString</body><body package="Debugger-Probes">editorLabelString	^(#EditExpressionWatch &lt;&lt; #pdp &gt;&gt; 'Edit Expression Watch') asString</body><body package="Debugger-Probes">reportString	| str |	^(str := super reportString) isEmpty		ifTrue: [(#ActionExprFailedRecompileDisabled &lt;&lt; #pdp &gt;&gt; 'Action expression failed recompile (probe disabled)') asString]		ifFalse:			[actionMethod == ActionMethod				ifTrue: [(#TestOrActionExprFailedRecompileDisabled &lt;&lt; #pdp &gt;&gt; 'Test expression or action expression failed recompile (probed disabled)') asString]				ifFalse: [str]]</body></methods><methods><class-id>CraftedSmalltalk.DisplayActionProbe</class-id> <category>responses</category><body package="Debugger-Probes">actOn: aContext 	(self test: aContext)		ifTrue:			[PDPManager				display: (actionMethod							valueWithReceiver: aContext homeReceiver							arguments: (Array with: aContext with: self))				on: windowID				for: self]</body></methods><methods><class-id>CraftedSmalltalk.DisplayActionProbe</class-id> <category>editor creation</category><body package="Debugger-Probes">createEditorOn: probedMethod class: probedClass	self forClass: probedClass.	^(ActionProbeEditor on: self in: probedMethod class: probedClass) createEditor</body><body package="Debugger-Probes">makeConditional: probeSpec replacing: unprobedMethod with: probedMethod	probeSpec isConditional		ifTrue: [self setNoAction]		ifFalse: [self setAction].	self finishSetup.	self openEditorOn: probedMethod andReplace: unprobedMethod</body></methods><methods><class-id>CraftedSmalltalk.DisplayActionProbe</class-id> <category>initialize-release</category><body package="Debugger-Probes">createLabelString	labelString value:		((#ExpressionAt1pIn2s &lt;&lt; #pdp &gt;&gt; 'Expression at &lt;1p&gt; in &lt;2s&gt;')			expandMacrosWith: self characterIndex			with: self methodString)</body><body package="Debugger-Probes">initialize	super initialize.	actionMethod := ActionMethod.	actionSource := self class initialSource.</body><body package="Debugger-Probes">recompileIfKnownMethods	super recompileIfKnownMethods.	self isDefautActionMethod		ifFalse: [^self].	actionMethod := CodeProbe compileProbeMethod: actionSource inClass: self mclass.</body><body package="Debugger-Probes">resetActionMethod	actionMethod := ActionMethod.	actionSource := self class initialSource.</body><body package="Debugger-Probes">updateExpressionsFromTemplate: aProbe	super updateExpressionsFromTemplate: aProbe.	actionSource := aProbe basicActionSource.	actionMethod := self ifNecessaryCopy: aProbe basicActionMethod andRebindFrom: aProbe variables</body><body package="Debugger-Probes">updateExpressionsFromWorkingCopy: aProbe	super updateExpressionsFromWorkingCopy: aProbe.	self actionMethodAndSource: aProbe actionMethodAndSource.</body></methods><methods><class-id>CraftedSmalltalk.DisplayActionProbe</class-id> <category>testing</category><body package="Debugger-Probes">isDefautActionMethod	^actionMethod == ActionMethod</body></methods><methods><class-id>CraftedSmalltalk.DisplayActionProbe</class-id> <category>saving-loading</category><body package="Debugger-Probes">loadActionExpressionFrom:  aStream	| fieldName |	fieldName := aStream upTo: Character space.	fieldName = 'ActionExpr:'		ifFalse:			[^self unknowLoadField: fieldName on: aStream expected: 'ActionExpr:'].	actionSource := String readFrom: aStream.	aStream next.	"swallow cr"	actionMethod := nil.</body><body package="Debugger-Probes">loadFrom: aStream	super loadFrom: aStream.	self loadActionExpressionFrom:  aStream.</body><body package="Debugger-Probes">saveActionExpressionOn:  aStream	aStream nextPutAll: 'ActionExpr: '.	self actionSource printOn: aStream.	aStream cr.</body><body package="Debugger-Probes">saveOn: aStream	super saveOn: aStream.	self saveActionExpressionOn:  aStream.</body></methods><methods><class-id>CraftedSmalltalk.DisplayActionProbe</class-id> <category>expression compiling</category><body package="Debugger-Probes">recompileActionExpressionUsingProbedMethod: aMethod	| src meth |	self isDefautActionMethod		ifTrue: [^true].	src := self actionSource.	actionMethod := ActionMethod.		"Reset the method to a sane value in case of failure."	meth := ProbeExprCompiler new		compileProbeExpression: src		forProbe: self		inClass: aMethod mclass		beginScope: (aMethod scopeForProbe: self)		notifying: nil		ifFail: [^false].	self actionMethodAndSource: meth-&gt;src.	^true</body><body package="Debugger-Probes">recompileExpressionsUsingProbedMethod: aMethod	^(super recompileExpressionsUsingProbedMethod: aMethod) and: 		[self recompileActionExpressionUsingProbedMethod: aMethod]</body></methods><methods><class-id>CraftedSmalltalk.DisplayActionProbe class</class-id> <category>initialization</category><body package="Debugger-Probes">initializeMethods	ActionMethod := self compileProbeMethod: self initialSource inClass: Object."Smalltalk Professional Debug Package Version 1.5 (c) 1995,1997 Crafted Smalltalk"</body><body package="Debugger-Probes">initialSource	^'^'''''"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.DisplayActionProbe class</class-id> <category>testing</category><body package="Debugger-Probes">needsSafeRebinding	^true</body></methods><methods><class-id>CraftedSmalltalk.WatchActionProbe</class-id> <category>expression compiling</category><body package="Debugger-Probes">recompileTestExpressionUsingProbedMethod: aMethod	self addVariable: #log.	^super recompileTestExpressionUsingProbedMethod: aMethod</body><body package="Debugger-Probes">recompileTestExpressionUsingProbedMethod: aMethod handler: aHandler	self addVariable: #log.	^super recompileTestExpressionUsingProbedMethod: aMethod handler: aHandler</body></methods><methods><class-id>CraftedSmalltalk.WatchActionProbe</class-id> <category>responses</category><body package="Debugger-Probes">actOn: aContext 	| stream result |	PDPManager debugActive ifFalse: [^self].	testMethod ifNil: [^self].	self variableAt: #log put: (stream := String new writeStream).	result := [testMethod valueWithReceiver: aContext homeReceiver arguments: (Array with: aContext with: self)]		ensure: [self variableAt: #log put: nil].	result == stream		ifTrue: [			stream position = 0 ifTrue: [^self].			WatchLog				log: stream contents				for: aContext homeReceiver				from: (MethodDefinition class: self probeRecord mclass selector: self probeRecord selector)]		ifFalse: [			WatchLog				object: result				for: aContext homeReceiver				from: (MethodDefinition class: self probeRecord mclass selector: self probeRecord selector) property: '']</body></methods><methods><class-id>CraftedSmalltalk.BreakInterrupt class</class-id> <category>class initialization</category><body package="Debugger-Probes">initialize	notifierString := (#BreakDash &lt;&lt; #pdp &gt;&gt; 'Break-').</body></methods><methods><class-id>CraftedSmalltalk.AuxCodeInfoExtractor</class-id> <category>opcodes-data movement</category><body package="Debugger-Probes">dupFirst	self push</body><body package="Debugger-Probes">dupLast	self pop</body><body package="Debugger-Probes">dupNext	"no action"</body><body package="Debugger-Probes">pop	self pop: 1</body><body package="Debugger-Probes">push	self push: 1</body><body package="Debugger-Probes">pushConstant: value	self push</body><body package="Debugger-Probes">pushContext	self push</body><body package="Debugger-Probes">pushCopiedValues: count	self push: count</body><body package="Debugger-Probes">pushInst: index	self push</body><body package="Debugger-Probes">pushLocal: index	self push</body><body package="Debugger-Probes">pushLocalIndirect: majorIndex index: minorIndex	self push.</body><body package="Debugger-Probes">pushNewArray: size	self push</body><body package="Debugger-Probes">pushReceiver	self push</body><body package="Debugger-Probes">pushStatic: assoc	self push</body><body package="Debugger-Probes">storeInst: index	"no action"</body><body package="Debugger-Probes">storeLocal: index	"no action"</body><body package="Debugger-Probes">storePopInst: index	self pop</body><body package="Debugger-Probes">storePopLocal: index	self pop</body><body package="Debugger-Probes">storePopLocalIndirect: majorIndex index: minorIndex	self pop.</body></methods><methods><class-id>CraftedSmalltalk.AuxCodeInfoExtractor</class-id> <category>private-jumps</category><body package="Debugger-Probes">endBranch	| state |	(jumpStack isEmpty)		ifTrue: [^pc := method bytesSize + 1].	state := jumpStack removeLast.	pc := state key.	depth := state value.</body></methods><methods><class-id>CraftedSmalltalk.AuxCodeInfoExtractor</class-id> <category>opcodes-control</category><body package="Debugger-Probes">jump: delta	delta &lt; 0		ifFalse: [pc := pc + delta]</body><body package="Debugger-Probes">jump: delta if: condition		self pop.	jumpStack add: pc-&gt;depth.	pc := pc + delta.</body><body package="Debugger-Probes">loopHead</body><body package="Debugger-Probes">makeCopyingBlock: meth count: count	self pop: count - 1</body><body package="Debugger-Probes">makeFullBlock: meth	self push</body><body package="Debugger-Probes">makeFullCopyingBlock: meth count: count	self pop: count - 1</body><body package="Debugger-Probes">methodPrimitive: index	self push</body><body package="Debugger-Probes">methodReturnTop: levels	self endBranch</body><body package="Debugger-Probes">primitiveReturn</body><body package="Debugger-Probes">returnTop	self endBranch</body><body package="Debugger-Probes">send: selector numArgs: na	self pop: na</body><body package="Debugger-Probes">sendNoCheck: selector numArgs: na	self pop: na</body><body package="Debugger-Probes">sendNonImmediate: selector numArgs: na	self pop: na</body><body package="Debugger-Probes">sendSuper: selector numArgs: na	self pop: na + 1</body></methods><methods><class-id>CraftedSmalltalk.AuxCodeInfoExtractor</class-id> <category>accessing</category><body package="Debugger-Probes">maxDepth	^maxDepth</body></methods><methods><class-id>CraftedSmalltalk.AuxCodeInfoExtractor</class-id> <category>private-stack</category><body package="Debugger-Probes">pop: count	depth := depth - count</body><body package="Debugger-Probes">push: count	depth := depth + count.	maxDepth &gt; depth		ifFalse: [maxDepth := depth].</body></methods><methods><class-id>CraftedSmalltalk.AuxCodeInfoExtractor</class-id> <category>decoding</category><body package="Debugger-Probes">depthAt: aPC		[pc = aPC]		whileFalse:			[visited at: pc put: true.			self interpretNextInstructionFor: self.			(visited at: pc)				ifTrue: [self endBranch]].	^depth</body><body package="Debugger-Probes">run		[self atEnd]		whileFalse:			[visited at: pc put: true.			self interpretNextInstructionFor: self.			(visited at: pc)				ifTrue: [self endBranch]]</body></methods><methods><class-id>CraftedSmalltalk.AuxCodeInfoExtractor</class-id> <category>private</category><body package="Debugger-Probes">method: aMethod	super method: aMethod.	visited := Array new: method bytesSize + 1 withAll: false.	jumpStack := OrderedCollection new.	depth := method numTemps.	maxDepth := depth.</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakCollection</class-id> <category>accessing</category><body package="Debugger-Probes">add: anObject	"Add anObject to the collection."	accessLock		critical:			[| index |			index := elements				indexOf: nil				replaceWith: anObject 				startingAt: 1 				stoppingAt: elements size.			index == 0				ifTrue:					[index := elements size + 1.					self basicGrow.					elements at: index put: anObject]].	^anObject</body><body package="Debugger-Probes">remove: anElement ifAbsent: aBlock	"Remove anElement as one of the receiver's elements.  If several of the	elements are equal to anElement, only one is removed. If no element is equal to	anElement, answer the result of evaluating anExceptionBlock.  Otherwise,	answer the argument, anElement."	accessLock		critical:			[| index |			index := elements				indexOf: anElement				replaceWith: nil				startingAt: 1 				stoppingAt: elements size.			index == 0				ifTrue: aBlock].	^anElement</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakCollection</class-id> <category>private - unprotected</category><body package="Debugger-Probes">basicDo: aBlock	1 to: elements size do:		[:i | | d |		((d := elements at: i) == nil or: [d == elements tombstone])			ifFalse: 				[aBlock value: d]].</body><body package="Debugger-Probes">basicGrow	self resizeElements: elements size + self growSize</body><body package="Debugger-Probes">elementExpired	"An element has expired.  Shrink the element array if necessary."	| size |	elements nilAllCorpsesAndDo: [:a |].	size := elements size.	"Don't shrink collection below minimum size."	size &gt; self minSize		ifFalse: [^self].	"If the empty space is more than 80% of the available space then	we should consider shrinking."	self size &gt; (size * 0.2)		ifTrue: [^self].	self resizeElements: (self minSize max: (size / 2) truncated).</body><body package="Debugger-Probes">resizeElements: aSize	"We compress by replacing the current elements WeakArray	with a new compressed copy."	| wa i |	wa := WeakArray new: aSize.	i := 0.	self basicDo:		[:ele |		i := i + 1.		wa at: i put: ele].	elements removeDependent: self.	elements := wa.	elements addDependent: self.</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakCollection</class-id> <category>enumerating</category><body package="Debugger-Probes">do: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument."	accessLock critical: [self basicDo: aBlock]</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakCollection</class-id> <category>private</category><body package="Debugger-Probes">growSize	"Return the size to increase the collection by when it becomes too small."	^10</body><body package="Debugger-Probes">minSize	"Return the minimum collection size."	^6</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakCollection</class-id> <category>initialize-release</category><body package="Debugger-Probes">initialize 	"Initialize the receiver."	self initialize: self minSize.</body><body package="Debugger-Probes">initialize: aNumber	"Initialize the receiver to provide aNumber of initially empty elements."	accessLock := RecursionLock new.	elements := WeakArray new: aNumber.	elements addDependent: self.</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakCollection</class-id> <category>updating</category><body package="Debugger-Probes">update: aSymbol with: aParameter from: anObject	"Handle expiration notification."	aSymbol == #ElementExpired &amp; (anObject == elements)		ifTrue: [^accessLock critical: [self elementExpired]].</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakCollection class</class-id> <category>instance creation</category><body package="Debugger-Probes">new	"Return an instance of this class with no empty	space."	^super new initialize: 6"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes">new: aNumber	"Return an instance of this class with aNumber	of empty slots."	^super new initialize: aNumber"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.ProbeCharacterStyle</class-id> <category>testing</category><body package="Debugger-Probes">isCharStyleCacheable	^false</body></methods><methods><class-id>CraftedSmalltalk.DisplayInstanceVarProbe</class-id> <category>responses</category><body package="Debugger-Probes">actOn: aContext 	(self test: aContext)		ifTrue:			[PDPManager				display: (aContext homeReceiver instVarAt: index) debugString				on: windowID				for: self]</body></methods><methods><class-id>CraftedSmalltalk.DisplayInstanceVarProbe</class-id> <category>initialize-release</category><body package="Debugger-Probes">createLabelString	labelString value:		((#Ivar1sIn2sAt3p &lt;&lt; #pdp &gt;&gt; 'Ivar %&lt;&lt;1s&gt;%&gt; in &lt;2s&gt; at &lt;3p&gt;')			expandMacrosWith: self variableName			with: self methodString			with: self characterIndex)</body><body package="Debugger-Probes">updateInstanceVarIndexForMethod: probedMethod	"Update the receiver's index for the named instance variable.	Return true if the iVar still exists, otherwise return false."	index := probedMethod mclass allInstVarNames indexOf: name.	^index ~~ 0</body><body package="Debugger-Probes">updateMiscFromProbe: aProbe	super updateMiscFromProbe: aProbe.	index := aProbe variableIndex.	name := aProbe variableName.</body></methods><methods><class-id>CraftedSmalltalk.DisplayInstanceVarProbe</class-id> <category>accessing</category><body package="Debugger-Probes">editorLabelString	^((#EditIVarWatchProbeOn1s &lt;&lt; #pdp &gt;&gt; 'Edit Instance Variable Watch on: %&lt;&lt;1s&gt;%&gt;')			expandMacrosWith: name)</body></methods><methods><class-id>CraftedSmalltalk.DisplayInstanceVarProbe</class-id> <category>saving-loading</category><body package="Debugger-Probes">postLoadIntoMethod: probedMethod	^self updateInstanceVarIndexForMethod: probedMethod</body></methods><methods><class-id>CraftedSmalltalk.ProbeClone</class-id> <category>responses</category><body package="Debugger-Probes">actOn: aContext	^parent actOn: aContext</body></methods><methods><class-id>CraftedSmalltalk.ProbeClone</class-id> <category>editor creation</category><body package="Debugger-Probes">createEditorOn: probedMethod	^parent createEditorOn: probedMethod</body><body package="Debugger-Probes">createEditorOn: probedMethod class: probedClass 	^parent createEditorOn: probedMethod class: probedClass</body><body package="Debugger-Probes">modifyIn: aProbedMethod	^parent modifyIn: aProbedMethod</body></methods><methods><class-id>CraftedSmalltalk.ProbeClone</class-id> <category>accessing</category><body package="Debugger-Probes">emphasis	^parent emphasis value: self</body><body package="Debugger-Probes">emphasize: aText	^aText		emphasizeFrom: parent characterIndex		to: parent characterIndex		with: self emphasis</body><body package="Debugger-Probes">mode	^parent mode</body><body package="Debugger-Probes">testSource	^parent testSource</body></methods><methods><class-id>CraftedSmalltalk.ProbeClone</class-id> <category>testing</category><body package="Debugger-Probes">isPermanent	^parent isPermanent</body><body package="Debugger-Probes">isTemporary	^parent isTemporary</body></methods><methods><class-id>CraftedSmalltalk.ProbeClone</class-id> <category>initialize-release</category><body package="Debugger-Probes">parent: aProbe	parent := aProbe.	probeRecord := parent probeRecord copy.</body></methods><methods><class-id>CraftedSmalltalk.ProbeClone</class-id> <category>private</category><body package="Debugger-Probes">quietlyCycleMode: aNewMode	parent quietlyCycleMode: aNewMode</body><body package="Debugger-Probes">test: aContext	^parent test: aContext</body></methods><methods><class-id>CraftedSmalltalk.ProbeClone class</class-id> <category>instance creation</category><body package="Debugger-Probes">parent: aProbe	"Return a new instance of the receiver with aProbe as	its parent."	^self new parent: aProbe"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.MethodActionRecord</class-id> <category>initialize-release</category><body package="Debugger-Probes">action: anInteger class: aClass selector: aSymbol	action := anInteger.		class := aClass.	selector := aSymbol</body></methods><methods><class-id>CraftedSmalltalk.MethodActionRecord</class-id> <category>accessing</category><body package="Debugger-Probes">compiledMethod	^class compiledMethodAt: selector</body><body package="Debugger-Probes">methodClass	^class</body><body package="Debugger-Probes">methodClass: aClass	class := aClass</body><body package="Debugger-Probes">nameString	^class shortName , '&gt;&gt;' , selector</body><body package="Debugger-Probes">printString	action == nil		ifTrue: [^self nameString].	^(#('r' 'rw' 'w') at: action) , ' ' , class shortName , '&gt;&gt;' , selector</body><body package="Debugger-Probes">replaceMethod: aCompiledMethod	class addSelector: selector withMethod: aCompiledMethod</body><body package="Debugger-Probes">setRead	action := #r</body><body package="Debugger-Probes">setReadWrite	action := #rw</body><body package="Debugger-Probes">setWrite	action := #w</body></methods><methods><class-id>CraftedSmalltalk.MethodActionRecord</class-id> <category>testing</category><body package="Debugger-Probes">isRead	^action &lt; 3</body><body package="Debugger-Probes">isWrite	^action &gt; 1</body></methods><methods><class-id>CraftedSmalltalk.MethodActionRecord class</class-id> <category>instance creation</category><body package="Debugger-Probes">action: anInteger class: aClass selector: aSymbol	^self new action: anInteger class: aClass selector: aSymbol"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.RemovedProbedMethodsBrowser</class-id> <category>private</category><body package="Debugger-Probes">changedMethodList	methodList list: (showHidden		ifTrue: [hiddenMethods]		ifFalse: [methods]).</body><body package="Debugger-Probes">changedSelection	textHolder value: (selectedMethods size ~= 1		ifTrue: [Text new]		ifFalse: [selectedMethods first sourceText])</body><body package="Debugger-Probes">clearMethods	methods := self newMethodCollection.</body><body package="Debugger-Probes">menu	^selectedMethods isEmpty		ifTrue:			[showHidden				ifTrue:					[Menu						labelArray: (Array with: #ShowNormal &lt;&lt; #pdp &gt;&gt; 'Show Normal')						values: #(showNormal)]				ifFalse:					[Menu						labelArray: (Array with: (#ReinsertProbes &lt;&lt; #pdp &gt;&gt; 'Reinsert Probes') with: (#ShowHidden &lt;&lt; #pdp &gt;&gt; 'Show Hidden'))						values: #(reinsertProbes showHidden)]]		ifFalse:			[showHidden				ifTrue:					[Menu						labelArray: (Array with: (#ShowNormal &lt;&lt; #pdp &gt;&gt; 'Show Normal') with: (#Unhide &lt;&lt; #pdp &gt;&gt; 'Unhide'))						values: #(showNormal unhide)]				ifFalse:					[Menu						labelArray: (Array with: (#ReinsertProbes &lt;&lt; #pdp &gt;&gt; 'Reinsert Probes') with: (#ShowHidden &lt;&lt; #pdp &gt;&gt; 'Show Hidden') with: (#Hide &lt;&lt; #pdp &gt;&gt; 'Hide'))						values: #(reinsertProbes showHidden hide)]]</body><body package="Debugger-Probes">newMethodCollection	^SortedCollection sortBlock:		[:a :b |			a mclass name &lt; b mclass name or:				[a mclass name = b mclass name and:					[a selector &lt; b selector]]]</body></methods><methods><class-id>CraftedSmalltalk.RemovedProbedMethodsBrowser</class-id> <category>menu commands</category><body package="Debugger-Probes">hide	hiddenMethods addAll: selectedMethods.	methods removeAll: selectedMethods.	selectedMethods := #().	self changedMethodList</body><body package="Debugger-Probes">reinsertProbes	ProbedCompiledMethod recompileAndInsertProbesFrom: methods.	hiddenMethods isEmpty		ifTrue: [^builder window topComponent controller close].	self clearMethods.	self changedMethodList.</body><body package="Debugger-Probes">showHidden	showHidden := true.	self changedMethodList</body><body package="Debugger-Probes">showNormal	showHidden := false.	self changedMethodList</body><body package="Debugger-Probes">unhide	methods addAll: selectedMethods.	hiddenMethods removeAll: selectedMethods.	selectedMethods := #().	self changedMethodList</body></methods><methods><class-id>CraftedSmalltalk.RemovedProbedMethodsBrowser</class-id> <category>initialize - release</category><body package="Debugger-Probes">initialize	self clearMethods.	showHidden := false.	selectedMethods := #().	hiddenMethods := self newMethodCollection.	textHolder := '' asText asValue.	methodList := MultiSelectionInList new.	methodList selectionIndexHolder onChangeSend: #newSelection to: self.	methodList selectionIndexHolder value: selectedMethods.</body><body package="Debugger-Probes">on: aCollection	methods addAll: aCollection.</body></methods><methods><class-id>CraftedSmalltalk.RemovedProbedMethodsBrowser</class-id> <category>accessing</category><body package="Debugger-Probes">menuHolder	^[self menu]</body><body package="Debugger-Probes">methodList	methodList list: (showHidden		ifTrue: [hiddenMethods]		ifFalse: [methods]).	^methodList</body><body package="Debugger-Probes">textHolder	^textHolder</body></methods><methods><class-id>CraftedSmalltalk.RemovedProbedMethodsBrowser</class-id> <category>selecting</category><body package="Debugger-Probes">newSelection	selectedMethods := methodList selections.	self changedSelection</body></methods><methods><class-id>CraftedSmalltalk.RemovedProbedMethodsBrowser class</class-id> <category>interface opening</category><body package="Debugger-Probes">onMethods: aCollection	self openOn: (self new on: aCollection)"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPTransientWarning</class-id> <category>interface opening</category><body package="Debugger-Probes">on: aString	labelText := aString.	self openInterface: #windowSpec.</body><body package="Debugger-Probes">postBuildWith: aBuilder	(aBuilder componentAt: #warning) labelString: labelText.	aBuilder window displayBox: (0 @ 0 extent: aBuilder component preferredExtent + (50 @ 40)).</body><body package="Debugger-Probes">postOpenWith: aBuilder	[(Delay forMilliseconds: 1500) wait.	aBuilder window topComponent model close] forkAt: Processor activePriorityPlusOne.</body></methods><methods><class-id>CraftedSmalltalk.PDPTransientWarning class</class-id> <category>instance creation</category><body package="Debugger-Probes">on: aString	self new on: aString"Smalltalk Professional Debug Package Version 2.5 (c) 1999 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPParser</class-id> <category>expression types-^value/error</category><body package="Debugger-Probes">method: fromDoIt context: ctxt 	"pattern [ | temporaries ] block =&gt; MethodNode"	| start pat messageComment methodNode tempNodes |	start := mark.	pat := Array 			with: #DOIT:PROBE:			with: (Array					with: (builder newParameterVariable: (builder newVariableName: 'DOITCONTEXT'))					with: (builder newParameterVariable: (builder newVariableName: 'ThisProbe'))).	"pat={selector, arguments}"	messageComment := currentComment.	currentComment := nil.	methodNode := builder newMethodSelector: (pat at: 1).	tempNodes := tokenType == #verticalBar		ifTrue: [self temporaries]		ifFalse:			[newLanguage				ifTrue: [nil]				ifFalse: [#()]].	self statementsArgs: (pat at: 2) temps: tempNodes.	tokenType == #doIt		ifFalse: [^self expected: (#NothingMore &lt;&lt; #pdp &gt;&gt; 'Nothing more')].	methodNode block: parseNode.	methodNode addComment: messageComment.	methodNode sourcePosition: (start to: self endOfLastToken).	^methodNode</body></methods><methods><class-id>CraftedSmalltalk.ProbedAnnotatedMethod</class-id> <category>comparing</category><body package="Debugger-Probes">= aMethod	"Compare the receiver to another object.  Answer true if the	 other object is an exactly equivalent method.  Override to	 ensure we compare attributes."	| list |	super = aMethod ifFalse: [^false].	list := aMethod attributeMessages.	list size = self attributeMessages size ifFalse:		[^false].	list := OrderedCollection withAll: list.	self attributeMessages do:		[:msg | list remove: msg ifAbsent: [^false]].	^true</body></methods><methods><class-id>CraftedSmalltalk.ProbedAnnotatedMethod</class-id> <category>accessing-literals</category><body package="Debugger-Probes">allLiteralsDo: aBlock	super allLiteralsDo: aBlock.	self attributeMessages do:		[:msg |		aBlock value: msg selector.		self traverse: msg arguments with: aBlock].</body><body package="Debugger-Probes">allSymbolLiteralsDo: aBlock	super allSymbolLiteralsDo: aBlock.	self attributeMessages do:		[:msg |		aBlock value: msg selector.		self traverse: msg arguments with:			[:sublit|			sublit isSymbol ifTrue: [aBlock value: sublit]]].</body></methods><methods><class-id>CraftedSmalltalk.ProbedAnnotatedMethod</class-id> <category>accessing</category><body package="Debugger-Probes">attributeAt: key ifAbsent: exceptionBlock	attributes == nil ifTrue: [^exceptionBlock value].	^self attributes at: key ifAbsent: exceptionBlock</body><body package="Debugger-Probes">attributeMessages	attributes class == IdentityDictionary		ifTrue: [self attributes: attributes].	^attributes</body><body package="Debugger-Probes">attributeMessages: anArray	attributes := anArray == nil ifFalse: [anArray asArray]</body><body package="Debugger-Probes">attributes	"Answer the receiver's attribute dictionary. If no attributes are defined, answer nil."	^attributes class == Array		ifTrue: [self messagesToDict: attributes]		ifFalse: [attributes]</body><body package="Debugger-Probes">attributes: aDictionary	| list |	list := Array new.	aDictionary keysAndValuesDo: [:key :value |		(key includes: $_) ifTrue: [self error: (#BadOldstyleKey &lt;&lt; #pdp &gt;&gt; 'Bad old-style key')].		list := list copyWith: (Message				selector: (key copyWith: $:) asSymbol				argument: value)].	self attributeMessages: list</body><body package="Debugger-Probes">environment	"Answer the NameSpace in which this compiled code	was compiled.  If not known, answer nil."	| messages |	messages := self attributeMessages.	messages == nil		ifFalse:			[1 to: messages size do: [:i | | msg |				msg := messages at: i.				(CompiledCode nameSpaceSelectors includes: msg selector)					ifTrue:						[msg arguments first == nil ifTrue: [self error: 'Nil environment'].						^msg arguments first]]].	^super environment</body><body package="Debugger-Probes">hasEnvironment	"Return true if we have an environment specified other than that of our class"	| messages |	messages := self attributeMessages.	^messages notNil		and: [messages anySatisfy: [:msg |			CompiledCode nameSpaceSelectors includes: msg selector]]</body><body package="Debugger-Probes">resourceType	self attributeMessages do:		[:msg |		msg selector == #resource: ifTrue: [^msg arguments first]].	^nil</body></methods><methods><class-id>CraftedSmalltalk.ProbedAnnotatedMethod</class-id> <category>private</category><body package="Debugger-Probes">copyStateFromOldVersion: oldMethod	"This message is sent by CodeRegenerator to a newly	generated method, to allow the method to copy over	the source pointer and any other information that the	CodeRegenerator would not know how to preserve."	super copyStateFromOldVersion: oldMethod.	self attributeMessages: oldMethod attributeMessages</body><body package="Debugger-Probes">messagesToDict: list	| d |	d := IdentityDictionary new.	list do:		[:msg |		d at: (self class transformSelectorToKey: msg selector)			put: (msg arguments size = 0 ifTrue: [nil] ifFalse: [msg arguments first])].	^d</body></methods><methods><class-id>CraftedSmalltalk.ProbedAnnotatedMethod</class-id> <category>initialize-release</category><body package="Debugger-Probes">from: aCompiledMethod full: fullFlag	self attributeMessages: aCompiledMethod attributeMessages.	^super from: aCompiledMethod full: fullFlag</body></methods><methods><class-id>CraftedSmalltalk.ProbedAnnotatedMethod</class-id> <category>binary storage</category><body package="Debugger-Probes">isCodeReaderEquivalentTo: aNewlyLoadedMethod	"Override to ensure we compare attributes."	| theirAttributes |	(super isCodeReaderEquivalentTo: aNewlyLoadedMethod) ifFalse: [^false].	theirAttributes := aNewlyLoadedMethod attributeMessages.	theirAttributes size = self attributeMessages size ifFalse: [^false].	self attributeMessages		with: theirAttributes		do:			[:ourMsg :theirMsg |			(ourMsg isCodeReaderEquivalentTo: theirMsg) ifFalse: [^false]].	^true</body></methods><methods><class-id>CraftedSmalltalk.ProbedAnnotatedMethod</class-id> <category>testing</category><body package="Debugger-Probes">isAnnotated	^true</body><body package="Debugger-Probes">refersToLiteral: aLiteral	"Answer true if this method (or any submethod)	refers to the given literal, directly or indirectly as an element of an array. 	We do not include special selector references.	We duplicate the code of literalsDo: for speed."	^(super refersToLiteral: aLiteral) or:		[self attributeMessages contains:			[:msg |			(msg selector refersToLiteral: aLiteral) or:				[msg arguments refersToLiteral: aLiteral]]]</body></methods><methods><class-id>CraftedSmalltalk.ProbedAnnotatedMethod class</class-id> <category>utilities</category><body package="Debugger-Probes">transformKeyToSelector: key	| new |	new := key copyWith: $:.	new replaceAll: $_ with: $:.	^new asSymbol</body><body package="Debugger-Probes">transformSelectorToKey: selector	| new |	new := selector asString.	new replaceAll: $: with: $_.	new last = $_ ifTrue: [new := new copyFrom: 1 to: new size-1].	^new asSymbol</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id> <category>adding</category><body package="Debugger-Probes">add: anAssociation 	"Include newObject as one of the receiver's elements.  Answer newObject."	self at: anAssociation key put: anAssociation value.	^anAssociation</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id> <category>initialize-release</category><body package="Debugger-Probes">allWeak: size	accessLock := RecursionLock new.	valueArray := WeakArray new: size.	valueArray addDependent: self.	keyArray := WeakArray new: size.	keyArray addDependent: self.	tally := 0</body><body package="Debugger-Probes">normal: size	accessLock := RecursionLock new.	valueArray := Array new: size.	keyArray := Array new: size.	tally := 0</body><body package="Debugger-Probes">weakKeys: size	accessLock := RecursionLock new.	valueArray := Array new: size.	keyArray := WeakArray new: size.	keyArray addDependent: self.	tally := 0</body><body package="Debugger-Probes">weakValues: size	accessLock := RecursionLock new.	valueArray := WeakArray new: size.	valueArray addDependent: self.	keyArray := Array new: size.	tally := 0</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id> <category>accessing</category><body package="Debugger-Probes">associationAt: key ifAbsent: aBlock 	"Answer an Association consisting of key and the value of	the receiver at that key.  If key is not found, evaluate aBlock."	^accessLock critical: [self unprotAssociationAt: key ifAbsent: aBlock]</body><body package="Debugger-Probes">at: key 	"Answer the value at key.  If key is not found, raise a signal."	^self at: key ifAbsent: [self keyNotFoundError: key]</body><body package="Debugger-Probes">at: key ifAbsent: aBlock 	"Answer the value at key.  If key is not found, answer the	result of evaluating aBlock."	^accessLock critical: [self unprotAt: key ifAbsent: aBlock]</body><body package="Debugger-Probes">at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	^accessLock critical: [self unprotAt: key put: anObject]</body><body package="Debugger-Probes">capacity	"Answer how much space the receiver has to contain elements."	^self collectionSize</body><body package="Debugger-Probes">keyAtIdentityValue: value ifAbsent: exceptionBlock	"Answer the key whose value is identical to the argument, value.	If there is none, answer the result of evaluating exceptionBlock."	self keysAndValuesDo:		[:aKey :aValue | value == aValue ifTrue: [^aKey]].	^exceptionBlock value</body><body package="Debugger-Probes">keyAtValue: value ifAbsent: exceptionBlock	"Answer the key whose value equals the argument, value.	If there is none, answer the result of evaluating exceptionBlock.""Note that this method still does an identity comparison. It will change in a future build to equality"	self keysAndValuesDo:		[:aKey :aValue | value == aValue ifTrue: [^aKey]].	^exceptionBlock value</body><body package="Debugger-Probes">size	"Answer how many elements the receiver contains."	^tally</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id> <category>dictionary enumerating</category><body package="Debugger-Probes">associationsDo: aBlock 	"Evaluate aBlock for associations consisting of the receiver's keys and 	their values."	accessLock critical: [self unprotAssociationsDo: aBlock]</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id> <category>private - unprotected</category><body package="Debugger-Probes">changeCapacityTo: newCapacity	"Change the size of the receiver to newCapacity.	-Note that #rehash uses this -- don't optimize the case where	the receiver doesn't change in size."	| newKeys newValues |	newKeys := keyArray class new: newCapacity.	newValues := valueArray class new: newCapacity.	"Copy named instance variables."	1 to: newKeys class instSize do:		[ :i |  newKeys instVarAt: i put: (keyArray instVarAt: i)].	1 to: newValues class instSize do:		[ :i |  newValues instVarAt: i put: (valueArray instVarAt: i)].	"Copy indexed variables"	1 to: keyArray size do:		[:index | |key nuIndex probe|		((key := keyArray at: index) == nil or: [key = WeakArray tombstone])	"Keys cannot be nil or 0"			ifFalse:				[nuIndex  := self initialIndexFor: key hash boundedBy: newCapacity.				[(probe := newKeys at: nuIndex) == nil or: [probe == key]]					whileFalse:						[(nuIndex := nuIndex + 1) &gt; newCapacity							ifTrue: [nuIndex := 1]].				newKeys at: nuIndex put: key.				newValues at: nuIndex put: (valueArray at: index)]].	valueArray := newValues.	keyArray := newKeys.</body><body package="Debugger-Probes">finalize: array	| deadIndex deadIndices|	deadIndex := array size.	deadIndices := OrderedCollection new.	[deadIndex &gt;= 1]		whileTrue: 			[deadIndex := array						indexOf: array tombstone						replaceWith: nil						startingAt: deadIndex						stoppingAt: 1.			deadIndex == 0				ifFalse: 					[deadIndices add: deadIndex.					deadIndex := deadIndex - 1]].	self removeAndCleanUpIndices: deadIndices.</body><body package="Debugger-Probes">findKeyOrNil: key 	"Look for the key in the receiver.  If it is found, answer	the index of the association containting the key, otherwise	answer the index of the first unused slot."	| index length probe pass |	length := keyArray size.	pass := 1.	index := self initialIndexFor: key identityHash boundedBy: length.	[(probe := keyArray at: index) == nil or: [probe == key]] whileFalse: 			[(index := index + 1) &gt; length 				ifTrue: 					[index := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [^self grow findKeyOrNil: key]]].	^index</body><body package="Debugger-Probes">rehash	"Rebuild the receiver to insure that it is hashed correctly."	"Note that this routine depends on implementors of #changeCapacityTo:	not 'optimizing' the case where the receiver doesn't need to change."	self changeCapacityTo: self capacity</body><body package="Debugger-Probes">removeAndCleanUpIndices: indices 	"Remove the keys in indices and rehash"	indices do: 			[:index | 			keyArray at: index put: nil.			valueArray at: index put: nil.			tally := tally - 1].	self rehash</body><body package="Debugger-Probes">unprotAssociationAt: key ifAbsent: aBlock 	"Answer an Association consisting of key and the value of	the receiver at that key.  If key is not found, evaluate aBlock."	| index storedKey |	index := self findKeyOrNil: key.	^(storedKey := keyArray at: index) == nil		ifTrue: [aBlock value]		ifFalse:			[Association 				key: storedKey				value: (valueArray at: index)]</body><body package="Debugger-Probes">unprotAssociationsDo: aBlock 	"Evaluate aBlock for associations consisting of the receiver's keys and 	their values."	1 to: keyArray size do: 		[:index | 		(keyArray at: index) == nil 			ifFalse: [aBlock value: (Association 										key: (keyArray at: index)										value: (valueArray at: index))]]</body><body package="Debugger-Probes">unprotAt: key ifAbsent: aBlock 	"Answer the value at key.  If key is not found, answer the	result of evaluating aBlock."	| index |	index := self findKeyOrNil: key.	^(keyArray at: index) == nil		 ifTrue: [aBlock value]		ifFalse: [valueArray at: index]</body><body package="Debugger-Probes">unprotAt: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	| index |	key == nil ifTrue: [^self subscriptBoundsError: key].	index := self findKeyOrNil: key.	(keyArray at: index)  == nil		ifTrue:			[tally := tally + 1.			keyArray at: index put: key].	valueArray at: index put: anObject.	self fullCheck.	^anObject</body><body package="Debugger-Probes">unprotDo: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument."	1 to: keyArray size do: 		[:index | 		(keyArray at: index) == nil ifFalse: [aBlock value: (valueArray at: index)]]</body><body package="Debugger-Probes">unprotIncludesKey: key 	"Answer whether the receiver has a key equal to the argument, key."	| index |	index := self findKeyOrNil: key.	^(keyArray at: index) notNil</body><body package="Debugger-Probes">unprotKeysAndValuesDo: aBlock 	"Evaluate aBlock with each of the receiver's key/value pairs as the 	arguments."	1 to: keyArray size do: 		[:index |		| key |		(key := keyArray at: index) == nil			ifFalse: [aBlock value: key value: (valueArray at: index)]]</body><body package="Debugger-Probes">unprotRemoveKey: key ifAbsent: aBlock	"Remove key from the receiver.  If key is not in the receiver, 	answer the result of evaluating aBlock.  Otherwise, answer the value 	associated with key."	| index value |	index := self findKeyOrNil: key.	(keyArray at: index) == nil ifTrue: [^aBlock value].	value := valueArray at: index.	self removeAndCleanUpIndices: (Array with: index).	^value</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id> <category>private</category><body package="Debugger-Probes">collectionSize	^keyArray basicSize</body><body package="Debugger-Probes">fullCheck	"If there is insufficient capacity in the receiver to do efficient lookups,	then grow."	"Require 25% free slots."	keyArray size - self size &lt;= (keyArray size // 4)		ifTrue: [self grow]</body><body package="Debugger-Probes">grow	"The receiver becomes roomier."	self changeCapacityTo: self capacity + self growSize</body><body package="Debugger-Probes">initialIndexFor: aHashValue boundedBy: length	"Find the place where we should start the search.	Optimize for relatively small dictionaries."	length &gt; 1023  "maxHash will definitely be larger than this"		ifTrue:			[" For very large dictionaries, spread out the hash. "			| maxHash |			maxHash := ObjectMemory maximumIdentityHashValue.			length &gt; maxHash				ifTrue: [^aHashValue * (length // maxHash + 1) \\ length + 1]].	^aHashValue \\ length + 1</body><body package="Debugger-Probes">keyNotFoundError: key	"Raise a signal indicating that the key was	not found."	^Dictionary keyNotFoundSignal raiseWith: key</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id> <category>enumerating</category><body package="Debugger-Probes">do: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument."	accessLock critical: [self unprotDo: aBlock]</body><body package="Debugger-Probes">keysAndValuesDo: aBlock 	"Evaluate aBlock with each of the receiver's key/value pairs as the 	arguments."	accessLock critical: [self unprotKeysAndValuesDo: aBlock]</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id> <category>dictionary testing</category><body package="Debugger-Probes">includesKey: key 	"Answer whether the receiver has a key equal to the argument, key."	^accessLock critical: [self unprotIncludesKey: key]</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id> <category>dictionary removing</category><body package="Debugger-Probes">remove: anObject ifAbsent: exceptionBlock 	"Provide an error notification that Dictionaries can not respond to	remove: messages."	self shouldNotImplement</body><body package="Debugger-Probes">removeKey: key ifAbsent: aBlock	"Remove key from the receiver.  If key is not in the receiver, 	answer the result of evaluating aBlock.  Otherwise, answer the value 	associated with key."	^accessLock critical: [self unprotRemoveKey: key ifAbsent: aBlock]</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id> <category>updating</category><body package="Debugger-Probes">update: anAspectSymbol with: aParameter from: aSender 	anAspectSymbol == #ElementExpired		ifFalse: [^self].	aSender == keyArray | (aSender == valueArray)		ifFalse: [^self].	accessLock critical: [self finalize: aSender]</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary class</class-id> <category>instance creation</category><body package="Debugger-Probes">allWeak	^self allWeak: self createSize"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes">allWeak: anInteger 	"Create an instance of a Set."	anInteger &gt;= 0 ifFalse: [self improperCreationSizeSignal raiseWith: anInteger].	^super new allWeak: (self goodSizeFrom: anInteger)"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes">new: anInteger 	"Create an instance of a Set."	anInteger &gt;= 0 ifFalse: [self improperCreationSizeSignal raiseWith: anInteger].	^super new normal: (self goodSizeFrom: anInteger)"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes">weakKeys	^self weakKeys: self createSize"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes">weakKeys: anInteger 	"Create an instance of a Set."	anInteger &gt;= 0 ifFalse: [self improperCreationSizeSignal raiseWith: anInteger].	^super new weakKeys: (self goodSizeFrom: anInteger)"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes">weakValues	^self weakValues: self createSize"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes">weakValues: anInteger 	"Create an instance of a Set."	anInteger &gt;= 0 ifFalse: [self improperCreationSizeSignal raiseWith: anInteger].	^super new weakValues: (self goodSizeFrom: anInteger)"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary class</class-id> <category>private</category><body package="Debugger-Probes">createSize	^4"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body><body package="Debugger-Probes">goodSizeFrom: requestedSize 	"Given a size request, round it up to a size which will give best 	hash clustering (such as next prime)."	"Just ensure oddness if out-of-range."	^(requestedSize &lt;= 7 or: [requestedSize &gt; ((PrimeMap size bitShift: 1) + 1)])		ifTrue: [requestedSize bitOr: 1]		ifFalse: [(PrimeMap at: (requestedSize bitShift: -1)) + (requestedSize bitOr: 1)]"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.PDPWeakDictionary class</class-id> <category>class initialization</category><body package="Debugger-Probes">improperCreationSizeSignal	^Set improperCreationSizeSignal"Smalltalk Professional Debug Package Version 2.5 (c) 1995,1999 Crafted Smalltalk"</body><body package="Debugger-Probes">initialize	"Initialize signal and size table."	"PDPWeakDictionary initialize"	" the improperCreationSize signal has been delegated to	'Set improperCreationSizeSignal'."	self makeSizeTable"Smalltalk Professional Debug Package Version 2.5 (c) 1995 - 1999 Crafted Smalltalk"</body><body package="Debugger-Probes">makeSizeTable	"Construct a prefered size table mapping the first 1024 odd integers	to the next prime."	| primes pos sz |	MaxMapped := 2049.	primes := OrderedCollection with: 3.	3 to: MaxMapped + 100 "Slop to insure we get next prime over MaxMapped" by: 2 do: 			[:cand |			primes detect: [:p | cand \\ p = 0] ifNone: [primes add: cand]].	primes := primes asArray.	sz := MaxMapped // 2.	PrimeMap := ByteArray new: sz.	pos := 1.	1 to: sz do: [:i |		| n p |		n := i * 2 + 1.		[(p := primes at: pos) &gt;= n] whileFalse: [pos := pos + 1].		PrimeMap at: i put: p - n]"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.ProbeTestExpressionEditor</class-id> <category>private</category><body package="Debugger-Probes">newMethodAndSource: anAssociation	probe testMethodAndSource: anAssociation.</body></methods><methods><class-id>CraftedSmalltalk.ProbeTestExpressionEditor</class-id> <category>initialize-release</category><body package="Debugger-Probes">resetMethodMenu	^Menu		labelList: (Array with: (Array with: (#default &lt;&lt; #pdp &gt;&gt; 'default') with: (#true &lt;&lt; #pdp &gt;&gt; 'true') with: (#false &lt;&lt; #pdp &gt;&gt; 'false')))		values: #(setTestMethodToDefault setTestMethodToTrue setTestMethodToFalse)</body></methods><methods><class-id>CraftedSmalltalk.ProbeTestExpressionEditor</class-id> <category>menu messages</category><body package="Debugger-Probes">setTestMethodToDefault	probe setAction.	self changed: #value.</body><body package="Debugger-Probes">setTestMethodToFalse	probe setNoAction.	self changed: #value.</body><body package="Debugger-Probes">setTestMethodToTrue	probe setAlwaysAction.	self changed: #value.</body></methods><methods><class-id>CraftedSmalltalk.ProbeTestExpressionEditor</class-id> <category>text</category><body package="Debugger-Probes">text	^probe testSource asText</body></methods><methods><class-id>CraftedSmalltalk.ProbeTestExpressionEditor class</class-id> <category>expression library</category><body package="Debugger-Probes">libraryFileComment	^(#TestExpressionLibraryFile &lt;&lt; #pdp &gt;&gt; '"Test expression library file."') asString</body></methods><methods><class-id>CraftedSmalltalk.OneshotProbe</class-id> <category>initialize-release</category><body package="Debugger-Probes">initialize		super initialize.	armed := true</body></methods><methods><class-id>CraftedSmalltalk.OneshotProbe</class-id> <category>testing</category><body package="Debugger-Probes">isArmed	^armed</body><body package="Debugger-Probes">isOneshot		^true</body></methods><methods><class-id>CraftedSmalltalk.OneshotProbe</class-id> <category>accessing</category><body package="Debugger-Probes">disarm	| compiledMethod |		armed := false.	self mclass ifNil: [^self].	compiledMethod := self mclass compiledMethodAt: self selector ifAbsent: [^self].	PDPManager changedMethodFrom: compiledMethod to: compiledMethod by: nil</body><body package="Debugger-Probes">mode	^self isArmed		ifTrue: [#once]		ifFalse: [#disabled]</body><body package="Debugger-Probes">rearm		| compiledMethod |		armed := true.	self mclass ifNil: [^self].	compiledMethod := self mclass compiledMethodAt: self selector ifAbsent: [^self].	PDPManager changedMethodFrom: compiledMethod to: compiledMethod by: nil</body></methods><methods><class-id>CraftedSmalltalk.OneshotProbe</class-id> <category>private</category><body package="Debugger-Probes">quietlyCycleMode: aNewMode	aNewMode = self mode ifTrue: [^self].	aNewMode = #disabled ifTrue: [armed := false].	aNewMode = #once ifTrue: [armed := true].	aNewMode = #infinite ifTrue: [		self become:			((CodeProbe new updateMiscFromProbe: self)				testMethodAndSource: testMethod -&gt; testSource;				yourself)]</body><body package="Debugger-Probes">test: anObject		^self isArmed and: [super test: anObject]</body></methods><methods><class-id>CraftedSmalltalk.OneshotProbe</class-id> <category>responses</category><body package="Debugger-Probes">actOn: aContext	(self test: aContext)		ifTrue: 			["Disarm right away so that nothing goes wrong with any following code"			self disarm.			^self breakOn: aContext label: self labelString]</body></methods><methods><class-id>CraftedSmalltalk.ProbeCreationSpec</class-id> <category>accessing</category><body package="Debugger-Probes">conditional: aBoolean	conditional := aBoolean</body><body package="Debugger-Probes">permanent: aBoolean	permanent := aBoolean</body><body package="Debugger-Probes">probeClass	^probeClass</body><body package="Debugger-Probes">probeClass: aClass	probeClass := aClass</body><body package="Debugger-Probes">selectWindowParams	^selectWindowParams</body><body package="Debugger-Probes">selectWindowParams: aBoolean	selectWindowParams := aBoolean</body><body package="Debugger-Probes">setConditional	conditional := true</body><body package="Debugger-Probes">setIsAutoProbe	isAutoProbe := true.</body><body package="Debugger-Probes">setPermanent	permanent := true</body><body package="Debugger-Probes">setTemporary	permanent := false</body><body package="Debugger-Probes">setUnconditional	conditional := false</body></methods><methods><class-id>CraftedSmalltalk.ProbeCreationSpec</class-id> <category>initialize-release</category><body package="Debugger-Probes">initialize	isAutoProbe := false.</body><body package="Debugger-Probes">type: type conditional: cond permanent: perm	permanent := perm.	probeClass := type.	conditional := cond.</body></methods><methods><class-id>CraftedSmalltalk.ProbeCreationSpec</class-id> <category>testing</category><body package="Debugger-Probes">isAutoProbe	^isAutoProbe</body><body package="Debugger-Probes">isConditional	^conditional</body><body package="Debugger-Probes">isPermanent	^permanent</body></methods><methods><class-id>CraftedSmalltalk.ProbeCreationSpec class</class-id> <category>instance creation</category><body package="Debugger-Probes">new	^super new initialize</body><body package="Debugger-Probes">type: type conditional: cond permanent: perm	^self new type: type conditional: cond permanent: perm"Smalltalk Professional Debug Package Version 1.10 (c) 1995 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.WatchWindowHolder</class-id> <category>private</category><body package="Debugger-Probes">createWindow	| aView subViews visual labelBottom |	window := ScheduledWindow				model: self				label: #WatchWindow &lt;&lt; #pdp &gt;&gt; 'Watch window'				minimumSize: 200 @ 100.	aView := WatchWindowView model: self.	aView controller performer: self.	aView controller		menuHolder: (ValueHolder with: (Menu						labelList: #(#(#again #undo) #(#copy #cut #paste) #('do it' 'print it' 'inspect') #(#cancel) #(#hardcopy) #('log on' 'log off'))						values: #(#again #undo #copySelection #cut #paste #doIt #printIt #inspectIt #cancel #hardcopy #doLog #dontLog))).	subViews := CompositePart new.	visual := label asText allBold asParagraph.	labelBottom := visual preferredHeight + 4.	labelView := BorderedWrapper				on: visual				in: (LayoutFrame						leftFraction: 0						offset: 0						rightFraction: 1						offset: 0						topFraction: 0						offset: 0						bottomFraction: 0						offset: labelBottom)				border: LookPreferences defaultBorder.	subViews add: labelView.	subViews add: (LookPreferences edgeDecorator on: aView)		in: (LayoutFrame				leftFraction: 0				offset: 0				rightFraction: 1				offset: 0				topFraction: 0				offset: labelBottom				bottomFraction: 1				offset: 0).	window component: subViews.	^window</body><body package="Debugger-Probes">reopen	window notNil		ifTrue: [^self].	self createWindow.	displayBox isNil		ifTrue: [window open]		ifFalse: [window openIn: displayBox]</body></methods><methods><class-id>CraftedSmalltalk.WatchWindowHolder</class-id> <category>accessing</category><body package="Debugger-Probes">doLog	doLogging := true.	self endEntry.</body><body package="Debugger-Probes">dontLog	self endEntry.	doLogging := false.</body><body package="Debugger-Probes">label	window isNil		ifTrue: [^label].	^window label</body><body package="Debugger-Probes">label: aString	window isNil		ifFalse: [labelView component: aString asText allBold asParagraph].	label := aString</body><body package="Debugger-Probes">showString: aString	self reopen.	doLogging		ifTrue: 			[self show: (aString copyWith: Character cr)	"Assemble the string with it's cr here rather than in transcript's API so we get a transaction to put the string and its return out all at once."]		ifFalse: 			[value := aString asText.			self changed: #update]</body></methods><methods><class-id>CraftedSmalltalk.WatchWindowHolder</class-id> <category>initialize-release</category><body package="Debugger-Probes">initialize	super initialize.	doLogging := true.</body></methods><methods><class-id>CraftedSmalltalk.WatchWindowHolder</class-id> <category>managing</category><body package="Debugger-Probes">removeDependent: anObject	window == anObject		ifTrue:			[displayBox := window displayBox.			labelView := window := nil].	super removeDependent: anObject</body></methods><methods><class-id>CraftedSmalltalk.ProbeExprCompiler</class-id> <category>public access</category><body package="Debugger-Probes">compileProbeExpression: textOrStream forProbe: aProbe inClass: aClass beginScope: scope notifying: aRequestor ifFail: failBlock 	"Compiles the sourceStream into a parse tree, then generates code 	into a method.  If receiver is not nil, then the text can refer to	instance variables of that receiver (the Inspector uses this).  If 	aContext is not nil, the text can refer to temporaries in that context	(the Debugger uses this).  If aRequestor is not nil, then it will	receive a notify:at: message if an error is deteted. 		Finally, the compiled method is returned"	| lastLocalScope method scope1 handler methodNode staticScope |	class := aClass.	lastLocalScope := scope.	[lastLocalScope outerScope class == StaticScope]		whileFalse: [lastLocalScope := lastLocalScope outerScope].	staticScope := lastLocalScope outerScope.	scope1 := StaticScope variables: PDPManager debugVariables.	scope1 outerScope: staticScope.	aProbe variables isEmpty		ifFalse: [scope1 := (StaticScope variables: aProbe variables) outerScope: scope1].	lastLocalScope outerScope: scope1.	self from: textOrStream		class: class		context: (self scopeForProbeExpressionsOuterScope: scope)		notifying: aRequestor.	handler := requestor isNil		ifTrue: [SilentProbeExprCompilerErrorHandler new]		ifFalse: [self interactiveCompilerErrorHandlerClass new].	[methodNode := handler		forClass: targetClass		on: sourceStream		for: requestor		onFailDo: [^failBlock value]		do: [:src |			self				translate: src				ifFail: [^failBlock value]				handler: handler]]		valueNowOrOnUnwindDo: [lastLocalScope outerScope: staticScope].	method := methodNode generate.	method allLiteralsDo: [:obj | (obj isVariableBinding and: [obj isDeferred]) ifTrue: [obj resolveBinding]].	^method</body><body package="Debugger-Probes">compileProbeExpression: textOrStream forProbe: aProbe inClass: aClass beginScope: scope notifying: aRequestor ifFail: failBlock handler: handler	"Compiles the sourceStream into a parse tree, then generates code 	into a method.  If receiver is not nil, then the text can refer to	instance variables of that receiver (the Inspector uses this).  If 	aContext is not nil, the text can refer to temporaries in that context	(the Debugger uses this).  If aRequestor is not nil, then it will	receive a notify:at: message if an error is deteted. 		Finally, the compiled method is returned"	| lastLocalScope method scope1 methodNode staticScope |	class := aClass.	lastLocalScope := scope.	[lastLocalScope outerScope class == StaticScope]		whileFalse: [lastLocalScope := lastLocalScope outerScope].	staticScope := lastLocalScope outerScope.	scope1 := StaticScope variables: PDPManager debugVariables.	scope1 outerScope: staticScope.	aProbe variables isEmpty		ifFalse: [scope1 := (StaticScope variables: aProbe variables) outerScope: scope1].	lastLocalScope outerScope: scope1.	self from: textOrStream		class: class		context: (self scopeForProbeExpressionsOuterScope: scope)		notifying: aRequestor.	[methodNode := handler		forClass: targetClass		on: sourceStream		for: requestor		onFailDo: [^failBlock value]		do: [:src |			self				translate: src				ifFail: [^failBlock value]				handler: handler]]		valueNowOrOnUnwindDo: [lastLocalScope outerScope: staticScope].	method := methodNode generate.	method allLiteralsDo: [:obj | (obj isVariableBinding and: [obj isDeferred]) ifTrue: [obj resolveBinding]].	^method</body><body package="Debugger-Probes">evaluate: textOrStream in: aContext allowReceiver: allowSelf	receiver: receiver environment: env	notifying: aRequestor ifFail: failBlock	"This method should be sent to this compiler class only by	a TextController that is part of a probe expression editor."	| value method editor |	Cursor execute show.	editor := aRequestor performer.	[method := self		compileProbeExpression: textOrStream		forProbe: editor probe		inClass: editor probedClass		beginScope: editor nameScope		notifying: aRequestor		ifFail: 			[Cursor normal show.			^failBlock value].	value := method mclass basicNew performMethod: method with: nil with: nil]		ensure: [Cursor normal show].	^value</body><body package="Debugger-Probes">evaluate: textOrStream in: aContext receiver: receiver notifying: aRequestor ifFail: failBlock	"This method should be sent to this compiler class only by	a TextController that is part of a probe expression editor."	| value method editor |	Cursor execute show.	editor := aRequestor performer.	[method := self		compileProbeExpression: textOrStream		forProbe: editor probe		inClass: editor probedClass		beginScope: editor nameScope		notifying: aRequestor		ifFail: 			[Cursor normal show.			^failBlock value].	value := method mclass basicNew performMethod: method with: nil with: nil]		ensure: [Cursor normal show].	^value</body></methods><methods><class-id>CraftedSmalltalk.ProbeExprCompiler</class-id> <category>private</category><body package="Debugger-Probes">newCodeStream	"Return an appropriate code stream"	| stream |	stream := super newCodeStream.	compileForProbes == true		ifTrue: [stream makeFullBlock: true].	^stream</body><body package="Debugger-Probes">scopeForClass	^(context isKindOf: NameScope)		ifTrue: [context]		ifFalse: [super scopeForClass]</body><body package="Debugger-Probes">scopeForProbeExpressionsOuterScope: aScope	| localScope temps |	localScope := LocalScope new.	localScope addVariable: TopOfStackVariable new named: 'TopOfStack'.	temps := aScope temps reject: [:var | var key first = $.].	temps do:		[:var |		localScope			addVariable: (RawRemoteVariable new slot: var)			named: var key].	localScope outerScope: aScope.	^localScope</body><body package="Debugger-Probes">translate: aStream ifFail: failBlock handler: handler	"This method is used only to compile or evaluate probe expressions."	| methodNode holder codeStream method |	"Make special provisions for compiling methods	in classes that still use the old parser."	methodNode :=		PDPParser new			parse: aStream			class: class			environment: self environment			noPattern: false			context: context			notifying: handler			builder: ProgramNodeBuilder new			saveComments: false			ifFail: [^failBlock value].	(BlockAnalyzer new analyze: methodNode inClass: class context: context)		storeHintsForStandardSmalltalk.	handler selector: methodNode selector.  "save selector in case of error"	codeStream := self newCodeStream.	codeStream		class: targetClass outerScope: self scopeForClass;		requestor: handler.	methodNode emitValue: codeStream inContext: nil.	method := codeStream makeMethod: methodNode.	method := method withAdditionalPropertiesFrom: methodNode.	holder := self newMethodHolder.	holder node: methodNode.	holder method: method.	^holder</body></methods><methods><class-id>CraftedSmalltalk.ProbeExprCompiler</class-id> <category>accessing</category><body package="Debugger-Probes">setCompileForProbes	compileForProbes := true</body></methods><methods><class-id>CraftedSmalltalk.ProbeExprCompiler class</class-id> <category>accessing</category><body package="Debugger-Probes">doitContextVarName	^'DOITCONTEXT'"Smalltalk Professional Debug Package Version 1.5 (c) 1997 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.WatchWindowView</class-id> <category>updating</category><body package="Debugger-Probes">updateRequest	^true</body></methods><methods><class-id>CraftedSmalltalk.DisplayTOSProbe</class-id> <category>responses</category><body package="Debugger-Probes">actOn: aContext 	(self test: aContext)		ifTrue:			[PDPManager				display: aContext top debugString				on: windowID				for: self]</body></methods><methods><class-id>CraftedSmalltalk.DisplayTOSProbe</class-id> <category>initialize-release</category><body package="Debugger-Probes">createLabelString	labelString value: 		((#TopOfStackAt1pIn2s &lt;&lt; #pdp &gt;&gt; 'Top of Stack at &lt;1p&gt; in &lt;2s&gt;')			expandMacrosWith: self characterIndex			with: self methodString)</body></methods><methods><class-id>CraftedSmalltalk.DisplayTOSProbe</class-id> <category>accessing</category><body package="Debugger-Probes">editorLabelString	^(#EditTopOfStackWatchProbe &lt;&lt; #pdp &gt;&gt; 'Edit Top of Stack Watch') asString</body></methods><methods><class-id>CraftedSmalltalk.WatchPropertyEvent</class-id> <category>accessing</category><body package="Debugger-Probes">counter	^counter</body><body package="Debugger-Probes">counter: anObject	counter := anObject</body><body package="Debugger-Probes">method	^method</body><body package="Debugger-Probes">method: anObject	method := anObject</body><body package="Debugger-Probes">property	^property</body><body package="Debugger-Probes">property: anObject	property := anObject</body><body package="Debugger-Probes">receiver	^receiver</body><body package="Debugger-Probes">receiver: anObject	receiver := anObject</body><body package="Debugger-Probes">timestamp	^timestamp</body><body package="Debugger-Probes">timestamp: anObject	timestamp := anObject</body><body package="Debugger-Probes">value	^value</body><body package="Debugger-Probes">value: anObject	value := anObject</body></methods><methods><class-id>CraftedSmalltalk.ProbeInsertionRecord</class-id> <category>accessing</category><body package="Debugger-Probes">atEnd	^atEnd</body><body package="Debugger-Probes">blockMethodIndex	^blockIndex</body><body package="Debugger-Probes">bytesInBytecodes	^bytesInBytecodes</body><body package="Debugger-Probes">bytesInBytecodes: anObject	bytesInBytecodes := anObject</body><body package="Debugger-Probes">characterIndex	^characterIndex</body><body package="Debugger-Probes">fixPCFor: aPC amount: delta	aPC &gt; pc		ifTrue: [^self].	pc := pc + delta</body><body package="Debugger-Probes">fixPCFor: aPC amount: delta doEqualPC: doEqualNot	aPC &gt; pc		ifTrue: [^self].	aPC = pc &amp; doEqualNot		ifTrue: [^self].	pc := pc + delta</body><body package="Debugger-Probes">getLastEntryFrom: aProbedCompiledMethod	| map i nuEntry end anEntry |	atEnd		ifTrue: [^self].	map := aProbedCompiledMethod sourceMapAt: blockIndex.	i := mapEntry index + 1.	end := map size.	nuEntry := mapEntry.	[i &lt; end and: [(anEntry := map at: i) key == pc]]		whileTrue:			[anEntry end notNil				ifTrue: [nuEntry := anEntry].			i := i + 1].	nuEntry == mapEntry		ifTrue: [^self].	mapEntry := nuEntry.	pc := mapEntry key.	characterIndex := mapEntry value first min: mapEntry value last.</body><body package="Debugger-Probes">insertionPC	^pc</body><body package="Debugger-Probes">insertionPCFor: aMethod	mclass := aMethod homeMethod mclass.	selector := aMethod homeMethod selector.	mapEntry := aMethod sourceMap at: self mapIndex.	pc := atEnd		ifTrue: [mapEntry end]		ifFalse: [mapEntry key].	^pc</body><body package="Debugger-Probes">insertionRange	^characterIndex to: characterIndex</body><body package="Debugger-Probes">mapIndex	^mapEntry index</body><body package="Debugger-Probes">mclass	^mclass</body><body package="Debugger-Probes">mclass: aClass	mclass := aClass.</body><body package="Debugger-Probes">methodString	^mclass name , '&gt;&gt;' , selector asString</body><body package="Debugger-Probes">registerPCsWith: aPCRegistry	aPCRegistry register: self atPC: pc</body><body package="Debugger-Probes">selector	^selector</body><body package="Debugger-Probes">sourcePosition	^mapEntry sourcePosition</body><body package="Debugger-Probes">updateMethod: aProbedMethod	mclass := aProbedMethod homeMethod mclass.	selector := aProbedMethod homeMethod selector.</body><body package="Debugger-Probes">updatePCs: block	| new |	new := block value: pc.	new == nil ifFalse: [pc := new].</body></methods><methods><class-id>CraftedSmalltalk.ProbeInsertionRecord</class-id> <category>initialize-release</category><body package="Debugger-Probes">characterIndex: ci blockIndex: bli mapEntry: me atEnd: endFlag	characterIndex := ci.	blockIndex := bli.	mapEntry := me.	atEnd := endFlag.	mapEntry == nil		ifTrue: [^self].	pc := atEnd		ifTrue: [mapEntry end]		ifFalse: [mapEntry key]</body></methods><methods><class-id>CraftedSmalltalk.ProbeInsertionRecord</class-id> <category>comparing</category><body package="Debugger-Probes">= aRecord	^aRecord class == self class and: [(aRecord characterIndex = characterIndex) &amp; (aRecord insertionPC = pc) &amp; (aRecord blockMethodIndex = blockIndex)]</body><body package="Debugger-Probes">hash	^(blockIndex - 1 * 100 + characterIndex) * 100 + pc</body></methods><methods><class-id>CraftedSmalltalk.ProbeInsertionRecord</class-id> <category>saving-loading</category><body package="Debugger-Probes">loadFrom: aStream	| fieldName |	fieldName := aStream upTo: Character space.	fieldName = 'CharacterPosition:'		ifFalse:			[^AbstractCodeProbe unknowLoadField: fieldName on: aStream expected: 'CharacterPosition:'].	characterIndex := Number readFrom: aStream.	aStream next.	"swallow cr"</body><body package="Debugger-Probes">saveOn: aStream	aStream nextPutAll: 'CharacterPosition: '.	characterIndex printOn: aStream.	aStream cr.</body></methods><methods><class-id>CraftedSmalltalk.ProbeInsertionRecord</class-id> <category>testing</category><body package="Debugger-Probes">pcRangeExcludes: aLocation	^mapEntry pcRangeExcludes: aLocation</body></methods><methods><class-id>CraftedSmalltalk.ProbeInsertionRecord class</class-id> <category>instance creation</category><body package="Debugger-Probes">characterIndex: ci blockIndex: bli mapEntry: me atEnd: endFlag	^self new characterIndex: ci blockIndex: bli mapEntry: me atEnd: endFlag"Smalltalk Professional Debug Package Version 1.5 (c) 1995,1997 Crafted Smalltalk"</body><body package="Debugger-Probes">createFrom: aStream	^self new loadFrom: aStream</body></methods><methods><class-id>Kernel.MethodInfoRecord</class-id> <category>copying</category><body package="Debugger-Probes">postDcopyUsing: copyDict	"Complete the deep copy operation.  We don't copy bindings."	completeMap := completeMap basicDcopyUsing: copyDict.	topNode := topNode basicDcopyUsing: copyDict.</body></methods><methods><class-id>CraftedSmalltalk.CodeProbeEditor class</class-id> <category>interface specs</category><body package="Debugger-Probes">testEditorSpec	"Tools.UIPainter new openOnClass: self andSelector: #testEditorSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ProbeEditor 				#defaultString: 'Probe Editor' 				#catalogID: #pdp ) 			#min: #(#{Core.Point} 462 301 ) 			#bounds: #(#{Graphics.Rectangle} 730 422 1326 849 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -220 1 -35 1 -120 1 -10 1 ) 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #pdp ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -110 1 -35 1 -10 1 -10 1 ) 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #pdp ) 					#defaultable: true ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 0 0 -10 1 -45 1 ) 					#flags: 0 					#majorKey: #{CraftedSmalltalk.ProbeTestExpressionEditor} 					#minorKey: #testEditorSpec 					#clientKey: #testEditor ) ) ) )</body></methods><methods><class-id>CraftedSmalltalk.DisplayProbeEditor class</class-id> <category>interface specs</category><body package="Debugger-Probes">displayEditorSpec	"Tools.UIPainter new openOnClass: self andSelector: #displayEditorSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ProbeEditor 				#defaultString: 'Probe Editor' 				#catalogID: #pdp ) 			#min: #(#{Core.Point} 522 374 ) 			#bounds: #(#{Graphics.Rectangle} 720 450 1242 824 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 0 0 -180 1 -65 1 ) 					#flags: 0 					#majorKey: #{CraftedSmalltalk.ProbeTestExpressionEditor} 					#minorKey: #testEditorSpec 					#clientKey: #testEditor ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} -160 1 10 0 0 1 241 0 ) 					#flags: 0 					#majorKey: #{CraftedSmalltalk.DisplayProbeEditor} 					#minorKey: #windowParamSpec ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -220 1 -45 1 -120 1 -15 1 ) 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #pdp ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -110 1 -45 1 -10 1 -15 1 ) 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #pdp ) 					#defaultable: true ) ) ) )</body><body package="Debugger-Probes">windowParamSpec	"UIPainter new openOnClass: self andSelector: #windowParamSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#bounds: #(#Rectangle 578 310 725 471 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#CompositeSpecCollection 					#collection: #(						#(#LabelSpec 							#layout: #(#AlignmentOrigin 0 0.506944 0 0 0.5 0 ) 							#label: #(#{Kernel.UserMessage} #key: #WindowID #defaultString: 'Window ID' #catalogID: #pdp) ) 						#(#InputFieldSpec 							#layout: #(#Rectangle 0 24 144 54 ) 							#name: #idEntry 							#model: #windowID ) 						#(#ActionButtonSpec 							#layout: #(#Rectangle 0 60 144 90 ) 							#model: #selectID 							#label: #(#{Kernel.UserMessage} #key: #SelectIDDots #defaultString: 'Select ID...' #catalogID: #pdp) 							#defaultable: true ) 						#(#ActionButtonSpec 							#layout: #(#Rectangle 0 96 144 126 ) 							#model: #openWatchWindow 							#label: #(#{Kernel.UserMessage} #key: #OpenWindow #defaultString: 'Open Window' #catalogID: #pdp) 							#defaultable: true ) 						#(#ActionButtonSpec 							#layout: #(#Rectangle 0 132 144 162 ) 							#model: #changeLabel 							#label: #(#{Kernel.UserMessage} #key: #ChangeLabel #defaultString: 'Change label' #catalogID: #pdp) 							#defaultable: true ) ) 					#compositeSpec: 					#(#CompositeSpec 						#layout: #(#Rectangle 1 -5 145 157 ) ) ) ) ) )</body><body package="Debugger-Probes">windowParmOpenSpec	"UIPainter new openOnClass: self andSelector: #windowParmOpenSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #WindowParameters #defaultString: 'Window Parameters' #catalogID: #pdp) 			#bounds: #(#Rectangle 975 471 1236 761 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -40 0.3 -45 1 40 0.3 -15 1 ) 					#model: #accept 					#label: #(#{Kernel.UserMessage} #key: #Done #defaultString: 'Done' #catalogID: #pdp) 					#defaultable: true ) 				#(#SubCanvasSpec 					#layout: #(#LayoutFrame -75 0.5 48 0 75 0.5 217 0 ) 					#flags: 0 					#majorKey: #DisplayProbeEditor 					#minorKey: #windowParamSpec ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -40 0.7 -45 1 40 0.7 -15 1 ) 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #pdp) 					#defaultable: true ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 11 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #SelectWindowParameters #defaultString: 'Select Window Parameters' #catalogID: #pdp) ) ) ) )</body></methods><methods><class-id>CraftedSmalltalk.ActionProbeEditor class</class-id> <category>interface specs</category><body package="Debugger-Probes">actionEditorSpec	"Tools.UIPainter new openOnClass: self andSelector: #actionEditorSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ProbeEditor 				#defaultString: 'Probe Editor' 				#catalogID: #pdp ) 			#min: #(#{Core.Point} 494 500 ) 			#bounds: #(#{Graphics.Rectangle} 737 348 1231 848 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 0 0 -180 1 -10 0.5 ) 					#flags: 0 					#majorKey: #{CraftedSmalltalk.ProbeTestExpressionEditor} 					#minorKey: #testEditorSpec 					#clientKey: #testEditor ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 -10 0.5 -180 1 -60 1 ) 					#flags: 0 					#majorKey: #{CraftedSmalltalk.ProbeActionExpressionEditor} 					#minorKey: #watchExpressionEditorSpec 					#clientKey: #actionEditor ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} -170 1 10 0 0 1 255 0 ) 					#flags: 0 					#majorKey: #{CraftedSmalltalk.DisplayProbeEditor} 					#minorKey: #windowParamSpec ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -220 1 -45 1 -120 1 -15 1 ) 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #pdp ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -110 1 -45 1 -10 1 -15 1 ) 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #pdp ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>CraftedSmalltalk.PDPManager class</class-id> <category>interface specs</category><body package="Debugger-Probes">aboutSpec	"UIPainter new openOnClass: self andSelector: #aboutSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeType #specifiedSize #positionType #screenCenter #openType #advanced ) 			#label: #(#{Kernel.UserMessage} #key: #AboutSPDP #defaultString: 'About SPDP' #catalogID: #pdp) 			#min: #(#{Core.Point} 319 180 ) 			#max: #(#{Core.Point} 319 180 ) 			#bounds: #(#{Graphics.Rectangle} 644 506 963 686 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 5 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #SmalltalkProfessionalDebugPackage #defaultString: 'Smalltalk Professional Debug Package' #catalogID: #pdp) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 30 0 0.5 0 ) 					#label: #versionLabel ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 140 0 0.5 0 ) 					#model: #ok 					#label: #(#{Kernel.UserMessage} #key: #Ok #defaultString: 'Ok' #catalogID: #pdp) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 58 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Copyright2002CraftedSmalltalk #defaultString: 'Copyright 2002, Crafted Smalltalk ' #catalogID: #pdp) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 64 90 ) 					#label: #(#{Kernel.UserMessage} #key: #EmailCTraymondcraftedsmalltalkcom #defaultString: 'Email:   traymond@craftedsmalltalk.com' #catalogID: #pdp) ) ) ) )</body></methods><methods><class-id>CraftedSmalltalk.ProbeActionExpressionEditor class</class-id> <category>interface specs</category><body package="Debugger-Probes">watchExpressionEditorSpec	"Tools.UIPainter new openOnClass: self andSelector: #watchExpressionEditorSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #pdp ) 			#bounds: #(#{Graphics.Rectangle} 732 439 1328 866 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 30 0 0 1 0 1 ) 					#name: #textEditor 					#model: #editor 					#menu: #textMenu 					#performer: #editor 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0 30 0 0 1 ) 					#name: #actionEditor 					#label: 					#(#{Kernel.UserMessage} 						#key: #WatchExpressionC 						#defaultString: 'Watch Expression:' 						#catalogID: #pdp ) ) ) ) )</body></methods><methods><class-id>CraftedSmalltalk.RemovedProbedMethodsBrowser class</class-id> <category>interface specs</category><body package="Debugger-Probes">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #RemovedProbedMethods #defaultString: 'Removed Probed Methods' #catalogID: #pdp) 			#bounds: #(#Rectangle 422 622 958 1068 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#SequenceViewSpec 					#layout: #(#LayoutFrame 0 0 0 0 0 1 0 0.3 ) 					#model: #methodList 					#menu: #menuHolder 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#TextEditorSpec 					#layout: #(#LayoutFrame 0 0 0 0.3 0 1 0 1 ) 					#model: #textHolder ) ) ) )</body></methods><methods><class-id>CraftedSmalltalk.PDPTransientWarning class</class-id> <category>interface specs</category><body package="Debugger-Probes">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #Warning #defaultString: 'Warning' #catalogID: #pdp) 			#bounds: #(#Rectangle 469 621 773 725 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 0 0.5 0.5 0.5 ) 					#name: #warning 					#label: #(#{Kernel.UserMessage} #key: #warning #defaultString: 'warning' #catalogID: #pdp) ) ) ) )</body></methods><methods><class-id>CraftedSmalltalk.ProbeTestExpressionEditor class</class-id> <category>interface specs</category><body package="Debugger-Probes">testEditorSpec	"Tools.UIPainter new openOnClass: self andSelector: #testEditorSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #pdp ) 			#bounds: #(#{Graphics.Rectangle} 720 450 1316 877 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 30 0 0 1 0 1 ) 					#name: #textEditor 					#model: #editor 					#menu: #textMenu 					#performer: #editor 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0 30 0 0 1 ) 					#name: #testEditor 					#label: 					#(#{Kernel.UserMessage} 						#key: #TriggerConditionC 						#defaultString: 'Trigger Condition:' 						#catalogID: #pdp ) ) ) ) )</body></methods><initialize><class-id>CraftedSmalltalk.AbstractCodeProbe</class-id></initialize><initialize><class-id>CraftedSmalltalk.WatchLog</class-id></initialize><initialize><class-id>CraftedSmalltalk.PDPManager</class-id></initialize><initialize><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id></initialize><initialize><class-id>CraftedSmalltalk.CRC32Function</class-id></initialize><initialize><class-id>CraftedSmalltalk.BreakInterrupt</class-id></initialize><initialize><class-id>CraftedSmalltalk.PDPWeakDictionary</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CompiledBlock</name><environment>Kernel</environment><super>Kernel.CompiledCode</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>outerMethod </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>VariableDefinition</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Names and Scopes</category><attributes><package>System-Compiler-Names and Scopes</package></attributes></class><class><name>RemoteVariable</name><environment>Kernel</environment><super>Kernel.VariableDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contextNode index </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Names and Scopes</category><attributes><package>System-Compiler-Names and Scopes</package></attributes></class><class><name>TextCollectorView</name><environment>UI</environment><super>UI.ComposedTextView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>appendEntryMutex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>MethodInfoRecord</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bindings completeMap topNode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Support</category><attributes><package>System-Compiler-Support</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>GenericException</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messageText originator initialContext firstUnwindContext handlerContext parameter proceedBlock isResumable signal searchContext </inst-vars><class-inst-vars>notifierString </class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>InstructionStream</name><environment>Kernel</environment><super>Kernel.InstructionClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method pc </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>CompilerErrorHandler</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>failBlock retryBlock class selector errorHandlers environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Support</category><attributes><package>System-Compiler-Support</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>ControlInterrupt</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isInterrupt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Parser</name><environment>Kernel</environment><super>Kernel.Scanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder requestor oldLanguage newLanguage extendedLanguage parseNode failBlock endTemps targetClass environment topEnvironment bindingRefs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class><class><name>Association</name><environment>Core</environment><super>Core.LookupKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>TextCollector</name><environment>UI</environment><super>UI.ValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>entryStream characterLimit writeSequencer nextEntry autoFlush </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>Compiler</name><environment>Kernel</environment><super>Kernel.SmalltalkCompiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class></st-source>