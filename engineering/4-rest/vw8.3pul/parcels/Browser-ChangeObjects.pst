<?xml version="1.0"?><st-source><!-- Name: Browser-ChangeObjectsNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Portions © 1998-2002 The Refactory, IncComment: This package contains the low level source code changes that the Refactoring Browser. These low level changes are undoable and can be composed to create larger operations. All changes in the Refactoring Browser are performed using these low level changes.DbIdentifier: bear73DbTrace: 500022DbUsername: cgundelDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'Browser-Namespace' '') #(#any 'Browser-Parser' '') #(#any 'Browser-Environments' ''))PackageName: Browser-ChangeObjectsParcel: #('Browser-ChangeObjects')ParcelName: Browser-ChangeObjectsPrerequisiteDescriptions: #(#(#name 'Browser-Namespace' #componentType #package) #(#name 'Browser-Parser' #componentType #package) #(#name 'Browser-Environments' #componentType #package))PrerequisiteParcels: #(#('Browser-Namespace' '') #('Browser-Parser' '') #('Browser-Environments' ''))PrintStringCache: (8.3 - 1,cgundel)Version: 8.3 - 1Pre-Unload Block: 	[:t1 | Refactory.Browser.RefactoryChangeManager nuke]Date: 3:26:53 PM June 30, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (jun17.4) of June 23, 2017 on June 30, 2017 at 3:26:53 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>RefactoryChange</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.RefactoryChange</class-id><body>RefactoryChange is an abstract class that represent some change to a class or method. They are used in combination with CompositeRefactoryChange to give transaction-like behavior. All change objects have the ability to undo themselves.  With the exception of encapsulated composite secondary changes constructed for undo operations, the name property is inherited so the undo/redo menu indicators reference the original action.  However, the displayString used in various inspectors represents the action the object will actually perform, and includes a tag designating it as an undo operation when appropriate.Subclasses must implement the following messages:	accessing		changeObject		renameChangesForObject:to:	private		executeNotifying:Instance Variables:	name	&lt;String&gt;	the name that is displayed for undo/redo</body></comment><class><name>CompositeRefactoryChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>changes undoSingle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.CompositeRefactoryChange</class-id><body>CompositeRefactoryChange represents a series of changes (RefactoryChange) that need to be performed. It provides transaction-like behavior by defering all changes until it is told to commit them.Instance Variables	changes	&lt;SequenceableCollection of: RefactoryChange&gt;	my changes	undoSingle		&lt;Boolean&gt;	the undo of this composite change is a single change object, namely the most significant (first) in the computed undo stack</body></comment><class><name>RefactoryObjectChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectName isMeta priorChangeType isUndo </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.RefactoryObjectChange</class-id><body>RefactoryObjectChange is the abstract superclass of all "atomic" changes (i.e., changes that affect one object).Subclasses must implement the following messages:	private		primitiveExecute		Performs the change.Instance Variables	isMeta	&lt;Boolean&gt;	True if this change applies to the metaclass.	objectName	&lt;CharacterArray&gt;	Name of the object being changed.	priorChangeType	&lt;Symbol | nil&gt; The state of the definition in the prior package before being refactored, if it was captured, either #none, #change or #add.	isUndo	&lt;Boolean&gt;	We may use different behavior if we are a do vs an undo, this is initially false, and gets updated when I become an undo if needed</body></comment><class><name>MoveObjectChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryObjectChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetNamespace </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.MoveObjectChange</class-id><body>MoveObjectChange moves a class, namespace or shared variable to another namespace.Instance Variables:	targetNamespace	&lt;String&gt;	the namespace's name where we are moving to</body></comment><class><name>PackageChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryObjectChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.PackageChange</class-id><body>PackageChange is the abstract superclass of changes that manipulate a packages contents.Subclasses must implement the following messages:	private		currentPackageInstance Variables	packageName	&lt;String&gt;	The package being changed.</body></comment><class><name>MoveMethodToPackageChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.PackageChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.MoveMethodToPackageChange</class-id><body>MoveMethodToPackageChange moves a method from its current package into a new package.Instance Variables:	selector	&lt;Symbol&gt;	The selector of the method to be moved.</body></comment><class><name>MigrateObjectChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.MoveObjectChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.MigrateObjectChange</class-id><body>I'm a special kind of move. The two differences are: a) We make sure that all of my object's bindings are currently stuffed with a value and b) we take care NOT to flush the bindings after the move.</body></comment><class><name>ExecuteCodeChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryObjectChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definition category isPrivate controller package nameSpaceName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.ExecuteCodeChange</class-id><body>ExecuteCodeChange is a special type of change where some code is executed to perform the change (e.g., defining a class). It is abstract. The appropriate subclass is resolved by matching against known selector patterns from the definition string.Subclasses must implement the following messages:	private		fillOutDefinitionInstance Variables	category	&lt;String&gt;	the category the object will be in	controller	&lt;Controller | nil&gt;	the controller for the view that is defining the object, can be nil if no view is defining the object (e.g., undo/redo)	definition	&lt;String&gt;	the code that is executed	isPrivate	&lt;Boolean&gt;	is the object private?	nameSpaceName	&lt;String&gt;	where the object is being compiled into	package	&lt;Store.PackageModel&gt;	the default package for the item</body></comment><class><name>AddClassChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ExecuteCodeChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclassName instanceVariableNames classInstanceVariableNames imports indexedType attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.AddClassChange</class-id><body>AddClassChange is a change that represents adding or recompiling a class.Inherited	definedObject	&lt;Behavior&gt;	the class that was definedInstance Variables	classInstanceVariableNames	&lt;SequenceableCollection of: String&gt;	our class instance variable names	imports	&lt;Collection of: NameSpaceImport&gt;	the imports for the class	indexedType	&lt;Symbol&gt;	#bytes, #none, or #objects	instanceVariableNames	&lt;SequenceableCollection of: String&gt;	our instance variables	superclassName	&lt;String | nil&gt;	the name of our superclass	attributes	&lt;Array&gt;	our extraAttributesForDefinition, or that which will become it on execution</body></comment><class><name>CommentChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryObjectChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.CommentChange</class-id><body>CommentChange represents a change to a Class or NameSpace comment.Instance Variables:	comment	&lt;String&gt;	the new comment</body></comment><class><name>RefactoryVariableChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryObjectChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.RefactoryVariableChange</class-id><body>RefactoryVariableChange is the abstract superclass of all changes that deal with variables.Subclasses must implement the following messages:	private		changeSymbolInstance Variables:	variable	&lt;String&gt;	The name of the variable to be changed.</body></comment><class><name>AddNameSpaceChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ExecuteCodeChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>imports </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.AddNameSpaceChange</class-id><body>AddNamespaceChange is a change that represent adding or recompiling a Namespace.Inherited	definedObject	&lt;NameSpace&gt;	Namespace actually defined.Instance Variables	imports	&lt;Array of: String&gt;	The new namespace's import list.</body></comment><class><name>MoveMethodToOverrideInPackageChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.MoveMethodToPackageChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>oldPackageName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.MoveMethodToOverrideInPackageChange</class-id><body>MoveMethodToOverrideInPackageChange is used explicitly when doing the move part of a method override.Instance Variables:	oldPackageName	&lt;String&gt;	The name of the package where the move came from</body></comment><class><name>RemoveInstanceVariableChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryVariableChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.RemoveInstanceVariableChange</class-id><body>RemoveInstanceVariableChange is a change that recompiles a class without an instance variable.</body></comment><class><name>CodeComponentCommentChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.CommentChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.CodeComponentCommentChange</class-id><body>CodeComponentCommentChange represents a change to a code component's (Parcel, Package, etc.) comment.Instance Variables:	type	&lt;Symbol&gt;	#parcel or #package</body></comment><class><name>OverrideChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryObjectChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>override </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.OverrideChange</class-id><body>OverrideChange is the abstract superclass of the changes that deal with overrides.Instance Variables:	override	&lt;Override&gt;	The override that is being changed.</body></comment><class><name>RestoreOverrideChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.OverrideChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.RestoreOverrideChange</class-id><body>RestoreOverrideChange restores a system override.</body></comment><class><name>AddOverrideChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.OverrideChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.AddOverrideChange</class-id><body>AddOverrideChange adds an override.</body></comment><class><name>MoveClassDefinitionToPackageChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.PackageChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.MoveClassDefinitionToPackageChange</class-id><body>MoveClassDefinitionToPackageChange moves a class definition from its current package into a new package.</body></comment><class><name>RenameObjectChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.CompositeRefactoryChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>oldName newName isUndo </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.RenameObjectChange</class-id><body>RenameObjectChange is a special change that renames a class, namespace or shared variable.  In addition to the primary change, this may also include secondary changes to rename the various embedded objects.Instance Variables:	newName	&lt;String&gt;	new name for the object	oldName	&lt;String&gt;	old name of the object	isUndo	&lt;Boolean&gt;	We may use different behavior if we are a do vs an undo, this is initially false, and gets updated when I become an undo</body></comment><class><name>RemoveObjectChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryObjectChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.RemoveObjectChange</class-id><body>RemoveObjectChange is the abstract superclass of changes that remove "Global" objects from the system</body></comment><class><name>RemoveSharedVariableChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RemoveObjectChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.RemoveSharedVariableChange</class-id><body>RemoveSharedVariableChange removes a shared variable from the system</body></comment><class><name>AddSharedVariableChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ExecuteCodeChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isConstant initializer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.AddSharedVariableChange</class-id><body>AddSharedVariableChange is a change that represents the addition of a shared variable to a class or namespace.  Its definedObject / changeObject is a bindingReferenceInherited	definedObject	&lt;GeneralBindingReference&gt;	The reference to the newly compiled variable.  In our siblings, this is a class or namespace, but a binding reference is sufficiently polymorphic with those to serve in callers.Instance Variables	initializer	&lt;String&gt;	The initialize method for the new variable.	isConstant	&lt;Boolean&gt;	True if the new variable is a constant.</body></comment><class><name>CodeComponentPropertyChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>componentName componentType propertyKey propertyValue priorChangeType isUndo </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.CodeComponentPropertyChange</class-id><body>A change object to change properties fields on Packages, and Bundles.Because this class is not in the RefactoryObjectChange hierarchy it requires its own isUndo instance variable so that we can correctly restore the component's change set when reverting a change.Instance Variables:	componentName	&lt;Symbol&gt;	name of the component	componentType	&lt;#bundle | #package&gt;	used to figure out where to get the codeComponent by name from	propertyKey	&lt;Symbol&gt;	the key of the property	propertyValue	&lt;Object&gt;	the value of the property	priorChangeType	&lt;Symbol | nil&gt; The state of the property in the prior package before being refactored, if it was captured,		either #none or the property name itself	isUndo	&lt;Boolean&gt;	whether or not this is an undo operation</body></comment><class><name>RemoveClassChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RemoveObjectChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.RemoveClassChange</class-id><body>RemoveClassChange removes a class from the system</body></comment><class><name>MoveNameSpaceToPackageChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.PackageChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.MoveNameSpaceToPackageChange</class-id><body>MoveNamespaceToPackageChange moves a namespace into a new package.</body></comment><class><name>RenameInstanceVariableChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryVariableChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>newName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.RenameInstanceVariableChange</class-id><body>RenameInstanceVariableChange is a special change that renames an instance variable around other changes.Instance Variables	className	&lt;String&gt;		class name that defines the variable	isMeta		&lt;Boolean&gt;	is meta class?	newName	&lt;String&gt;		new name for the variable	oldName	&lt;String&gt;		old name for the variable</body></comment><class><name>RefactoryProtocolChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryObjectChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>protocol isData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.RefactoryProtocolChange</class-id><body>RefactoryProtocolChange is the abstract superclass of the changes that manipulate the method protocols.Instance Variables:	isData	&lt;Boolean&gt;	True if this protocol is for shared variables.	protocol	&lt;String&gt;	The protocol being changed.</body></comment><class><name>RemoveProtocolChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryProtocolChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.RemoveProtocolChange</class-id><body>RemoveProtocolChange removes a protocol from the system.Note: This doesn't remove the objects in the protocol, so it must only be used to remove an already empty protocol.</body></comment><class><name>AddInstanceVariableChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryVariableChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.AddInstanceVariableChange</class-id><body>AddInstanceVariableChange is a change that recompiles a class with a new instance variable added to it.</body></comment><class><name>CurrentPackageChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.CurrentPackageChange</class-id><body>CurrentPackageChange represents changing the current package. While this change does not change any code, it is useful for undoing the setting of the current package.Instance Variables:	packageName	&lt;String&gt;	the name of the package to make current</body></comment><class><name>RemoveNameSpaceChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RemoveObjectChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.RemoveNameSpaceChange</class-id><body>RemoveNamespaceChange removes a namespace from the system.</body></comment><class><name>AddMethodChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryObjectChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source selector protocols controller definedSelector package tool </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.AddMethodChange</class-id><body>AddMethodChange adds a method to a class. If this is used to replace and existing method, the new method will live in the same package and parcels as the original.Instance Variables:	controller	&lt;Controller | nil&gt;		Who to notify on a syntax error.	definedSelector	&lt;Symbol | nil&gt;	The selector of the added method if the source compiled.	package	&lt;Store.PackageModel&gt;			The package that the new method is added to.	protocols	&lt;Collection of: Symbol&gt;	The protocols that the new methods is in.	selector	&lt;Symbol&gt;	The selector of the method to be added.	source	&lt;String&gt;	The source code of the added method.	tool		&lt;CodeTool | DebuggerService&gt;	The tool initiating the changeShared Variables:	EagerAutoCategorization &lt;Boolean&gt; When we inheritProtocol, do we do so always, or only if it's a new method on the reciever?</body></comment><class><name>RemoveOverrideChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.OverrideChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.RemoveOverrideChange</class-id><body>RemoveOverrideChange removes an override.</body></comment><class><name>AddProtocolChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryProtocolChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.AddProtocolChange</class-id><body>AddProtocolChange adds a new protocol to a class</body></comment><class><name>MoveToProtocolChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AddProtocolChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>symbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.MoveToProtocolChange</class-id><body>MoveToProtocolChange moves an object from another protocol into this one.Instance Variables:	symbol	&lt;Symbol&gt;	The name of the object to move into this protocol</body></comment><class><name>RenameProtocolChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryProtocolChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>newProtocol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.RenameProtocolChange</class-id><body>RenameProtocolChange changes the name of an existing protocolInstance Variables:	newProtocol	&lt;String&gt;	The new name of the protocol</body></comment><class><name>RemoveMethodChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryObjectChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.RemoveMethodChange</class-id><body>RemoveMethodChange is the change that removes a method from the system.Instance Variables:	selector	&lt;Symbol&gt;	The method to remove</body></comment><class><name>RefactoryChangeManager</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>undo redo isPerformingRefactoring </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.RefactoryChangeManager</class-id><body>RefactoryChangeManager is a singleton that manages all changes performed by the RB. It holds the undo and redo list of changes.Instance Variables:	isPerformingRefactoring	&lt;Boolean&gt;	are we currently executing a change? If we are not currently executing a change and we notice that a change has occurred, then we must clear the undo/redo lists.	redo	&lt;OrderedCollection&gt;	the list of redo changes	undo	&lt;OrderedCollection&gt;	the list of undo changesShared Variables:	Instance	&lt;RefactoryChangeManager&gt;	our sole instance	UndoSize	&lt;Integer&gt;	the maximum size of the undo/redo list</body></comment><class><name>MoveSharedVariableToPackageChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.PackageChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.MoveSharedVariableToPackageChange</class-id><body>MoveSharedVariableToPackageChange moves a shared variable into a new package.</body></comment><class><name>RefactoryChangeFailureNotification</name><environment>Refactory.Browser</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><comment><class-id>Refactory.Browser.RefactoryChangeFailureNotification</class-id><body>RefactoryChangeFailureNotification is signaled when one of the changes fails. When this is raised, the change is not marked as an undoable change. Since something went wrong, we don't know how to undo that.</body></comment><shared-variable><name>EagerAutoCategorization</name><environment>Refactory.Browser.AddMethodChange</environment><private>false</private><constant>false</constant><category>settings</category><initializer>false</initializer><attributes><package>Browser-ChangeObjects</package></attributes></shared-variable><shared-variable><name>Instance</name><environment>Refactory.Browser.RefactoryChangeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Browser-ChangeObjects</package></attributes></shared-variable><shared-variable><name>UndoSize</name><environment>Refactory.Browser.RefactoryChangeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Browser-ChangeObjects</package></attributes></shared-variable><methods><class-id>Refactory.Browser.RefactoryChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">addAttributesTo: aString for: anObject 	| parseTree |	parseTree := RBParser parseExpression: aString onError: [:s :p | ^aString].	parseTree isMessage ifFalse: [^aString].	('*:attributes:' match: parseTree selector) ifTrue: [^aString].	^aString , ' attributes: ' 		, (self attributesForObject: anObject) asArray 				storeString</body><body package="Browser-ChangeObjects">asCompositeChange	^(CompositeRefactoryChange new)		changes: (OrderedCollection with: self);		name: self name;		yourself</body><body package="Browser-ChangeObjects">attributesForObject: anObject 	^SourceFileFormat attributesFor: anObject excluding: #()</body><body package="Browser-ChangeObjects">classRootsFor: aNameSpace 	| classes |	classes := Set new.	aNameSpace bindingsDo: 			[:each | 			each isForNameSpace 				ifTrue: [classes addAll: (self classRootsFor: each value)]				ifFalse: [each isForClass ifTrue: [classes add: each value]]].	^classes 		reject: [:each | each allSuperclasses anySatisfy: [:spr | classes includes: spr]]</body></methods><methods><class-id>Refactory.Browser.RefactoryChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">changeForClass: aRBClass selector: aSelector 	^nil</body><body package="Browser-ChangeObjects">changeForMetaclass: aSymbol selector: aSelector 	^nil</body><body package="Browser-ChangeObjects">changeObject	self subclassResponsibility</body><body package="Browser-ChangeObjects">changes	^#()</body><body package="Browser-ChangeObjects">changesSize	^1</body><body package="Browser-ChangeObjects">definingNamespace	"The namespace (strictly speaking; we don't include classes in this set) that houses the receiver's change. It is used by the show refactorings dialog which allows changes to be filtered/removed by namespace."		^nil</body><body package="Browser-ChangeObjects">name	^name isNil ifTrue: [self changeString] ifFalse: [name]</body><body package="Browser-ChangeObjects">originalCode	^''</body><body package="Browser-ChangeObjects">renameChangesForObject: aClassName to: newClassName	"We're in the middle of performing a rename operation. If we stored 	the class name, we need to change the class name to the new 	name to perform the compiles."</body><body package="Browser-ChangeObjects">withAllChanges	| changes index |	changes := OrderedCollection with: self.	index := 1.	[index &lt;= changes size] whileTrue: 			[changes addAll: (changes at: index) changes.			index := index + 1].	^changes</body></methods><methods><class-id>Refactory.Browser.RefactoryChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">changeString	^self class name</body><body package="Browser-ChangeObjects">displayString	^name isNil ifTrue: [self changeString] ifFalse: [name]</body></methods><methods><class-id>Refactory.Browser.RefactoryChange</class-id> <category>performing-changes</category><body package="Browser-ChangeObjects">execute	^self executeNotifying: []</body><body package="Browser-ChangeObjects">executeWithMessage: aString 	| tally controller model done |	model := 0 asValue.	done := 0.	tally := self changesSize.	controller := aString isNil 				ifTrue: [nil]				ifFalse: [ProgressWidgetView progressOpenOn: model label: aString].	model value: 0.	^	[self executeNotifying: 			[done := done + 1.			model value: done asFloat / tally]] 			ensure: [controller notNil ifTrue: [controller closeAndUnschedule]]</body></methods><methods><class-id>Refactory.Browser.RefactoryChange</class-id> <category>private</category><body package="Browser-ChangeObjects">changeVariable: variableName thatBeginsWith: startString toBeginWith: newStartString 	|  prefix |	prefix := startString.	(variableName = startString or: [		((variableName beginsWith: 'Smalltalk.') and:[(startString beginsWith: 'Smalltalk.') not]) ifTrue:[prefix := 'Smalltalk.',startString].		((variableName beginsWith: 'Smalltalk.') not and:[(startString beginsWith: 'Smalltalk.')]) ifTrue:[prefix := startString copyFrom: 11 to: startString size].	variableName beginsWith: prefix])		ifTrue: 			[^newStartString 				, (variableName copyFrom: prefix size + 1 to: variableName size)].	^variableName</body><body package="Browser-ChangeObjects">executeNotifying: aBlock 	self subclassResponsibility</body><body package="Browser-ChangeObjects">packageForClass: aClass selector: aSymbol 	| registry |	registry := self storeRegistry.	registry isNil ifTrue: [^nil].	^registry containingPackageForSelector: aSymbol class: aClass</body><body package="Browser-ChangeObjects">packageForClassDefinition: aClass 	| registry |	registry := self storeRegistry.	registry isNil ifTrue: [^nil].	^registry containingPackageForClass: aClass</body><body package="Browser-ChangeObjects">packageForNameSpace: aNameSpace 	| registry |	registry := self storeRegistry.	registry isNil ifTrue: [^nil].	^registry containingPackageForNameSpaceSymbol: aNameSpace absoluteSymbol</body><body package="Browser-ChangeObjects">packageForSharedVariable: aName in: aNameSpace 	| registry |	registry := self storeRegistry.	registry isNil ifTrue: [^nil].	^registry containingPackageForDataKey: aName		symbol: aNameSpace absoluteSymbol</body><body package="Browser-ChangeObjects">setPackage: package while: aBlock 	| policiesRef |	(package isNil or: [package isBundle]) ifTrue: [^aBlock value].	policiesRef := #{Store.Policies}.	policiesRef isDefined ifFalse: [^aBlock value].	policiesRef value packagePolicy forcePackage: package while: aBlock</body><body package="Browser-ChangeObjects">storeRegistry	^#{Store.Registry} valueOrDo: [nil]</body></methods><methods><class-id>Refactory.Browser.RefactoryChange</class-id> <category>initialize-release</category><body package="Browser-ChangeObjects">name: aString	name := aString</body></methods><methods><class-id>Refactory.Browser.RefactoryChange</class-id> <category>comparing</category><body package="Browser-ChangeObjects">= aRefactoryClassChange 	^self class = aRefactoryClassChange class</body><body package="Browser-ChangeObjects">hash	^self class hash</body></methods><methods><class-id>Refactory.Browser.RefactoryChange</class-id> <category>private-inspector accessing</category><body package="Browser-ChangeObjects">removeChange: aChange	"Do nothing by default, subclasses may do more"</body></methods><methods><class-id>Refactory.Browser.RefactoryChange</class-id> <category>testing</category><body package="Browser-ChangeObjects">isEmpty	^false</body></methods><methods><class-id>Refactory.Browser.RefactoryChange</class-id> <category>utility-undo</category><body package="Browser-ChangeObjects">classChangesUndoForRemoveNameSpace: aNameSpace	| changes classes |	changes := CompositeRefactoryChange				named: (#ClassUndoForRemoveNS1s &lt;&lt; #browser &gt;&gt; 'Class Changes in Undo for Remove NameSpace: &lt;1s&gt;'				expandMacrosWith: aNameSpace name).	classes := self classRootsFor: aNameSpace asNameSpace.	classes do: [:each | changes addChange: (self undoForRemoveClass: each)].	^changes compressed</body><body package="Browser-ChangeObjects">nameSpaceChangesUndoForRemoveNameSpace: aNameSpace		| changes |	changes := CompositeRefactoryChange				named: (#NameSpaceUndoForRemoveNS1s &lt;&lt; #browser &gt;&gt; 'NameSpace Changes in Undo for Remove NameSpace: &lt;1s&gt;'				expandMacrosWith: aNameSpace name).	aNameSpace asNameSpace bindingsDo: [:each | 		each isForNameSpace ifTrue: [			(changes defineNameSpace: each value definition) package: (self packageForNameSpace: each value).			changes addChangesIfNotEmpty: (self nameSpaceChangesUndoForRemoveNameSpace: each value)]].	^changes compressed</body><body package="Browser-ChangeObjects">sharedVariableChangesUndoForRemoveNameSpace: aNameSpace		| changes |	changes := CompositeRefactoryChange named: ((aNameSpace isBehavior		ifTrue: [#SharedUndoForRemoveClassAsNS1s &lt;&lt; #browser &gt;&gt; 'SharedVariable Changes in Undo for Remove Class as NameSpace: &lt;1s&gt;']		ifFalse: [#SharedUndoForRemoveNS1s &lt;&lt; #browser &gt;&gt; 'SharedVariable Changes in Undo for Remove NameSpace: &lt;1s&gt;'])				expandMacrosWith: aNameSpace name).	aNameSpace asNameSpace bindingsDo: [:each | 		each isForNameSpace ifTrue: [			changes addChangesIfNotEmpty: (self sharedVariableChangesUndoForRemoveNameSpace: each value)].		each isForGeneral ifTrue: [			(changes defineSharedVariable: (self addAttributesTo: (aNameSpace definitionOfStatic: each)					for: (aNameSpace asNameSpace fullyQualifiedReferenceOf: each key)))						package: (self packageForSharedVariable: each key in: aNameSpace)]].	^changes compressed</body><body package="Browser-ChangeObjects">undoForRemoveClass: aClass		| changes |	changes := CompositeRefactoryChange				named: (#ChangesForRemoveClass1s &lt;&lt; #browser &gt;&gt; 'Changes for Remove Class: &lt;1s&gt;'				expandMacrosWith: aClass name).	(aClass withAllSubclasses reject: [:each | each isMeta]) do: [:each | 		(changes defineClass: (self addAttributesTo: each definition for: each)) package: (self packageForClassDefinition: each).		changes addChange: (CommentChange object: each comment: each comment asString).		changes addChangesIfNotEmpty: (self undoForRemoveNameSpace: each).		each selectors do: [:selector | 			(changes compile: (each sourceCodeAt: selector) in: each)  copyAttributesFrom: selector].		each class selectors do: [:selector | 			(changes compile: (each class sourceCodeAt: selector) in: each class) copyAttributesFrom: selector in: each class]].	^changes</body><body package="Browser-ChangeObjects">undoForRemoveNameSpace: aNameSpace		| changes |	changes := CompositeRefactoryChange named:				((aNameSpace isBehavior					ifTrue: [#ChangesForRemoveClassAsNameSpace1s &lt;&lt; #browser &gt;&gt; 'Changes for Remove Class as NameSpace: &lt;1s&gt;']					ifFalse: [#ChangesForRemoveNameSpace1s &lt;&lt; #browser &gt;&gt; 'Changes for Remove NameSpace: &lt;1s&gt;'])				expandMacrosWith: aNameSpace name).	aNameSpace isBehavior ifFalse: [		(changes defineNameSpace: (self addAttributesTo: aNameSpace definition for: aNameSpace))			package: (self packageForNameSpace: aNameSpace).		changes addChange: (CommentChange object: aNameSpace comment: aNameSpace comment asString)].	changes addChangesIfNotEmpty: (self nameSpaceChangesUndoForRemoveNameSpace: aNameSpace).	changes addChangesIfNotEmpty: (self classChangesUndoForRemoveNameSpace: aNameSpace).	changes addChangesIfNotEmpty: (self sharedVariableChangesUndoForRemoveNameSpace: aNameSpace).	changes addChangesIfNotEmpty: (self undoForRemoveOverrides:				(Override overridesForClassOrNameSpace: aNameSpace)).	^changes compressed</body><body package="Browser-ChangeObjects">undoForRemoveOverrides: overrides	| changes |	changes := CompositeRefactoryChange				named: #ChangesForRemoveOverrides &lt;&lt; #browser &gt;&gt; 'Changes for Remove Overrides'.	overrides isNil ifFalse: [		overrides do: [:each | changes addChange: (AddOverrideChange for: each)]].	^changes</body></methods><methods><class-id>Refactory.Browser.RefactoryChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoryChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">addChange: aRefactoryChange 	changes add: aRefactoryChange.	^aRefactoryChange</body><body package="Browser-ChangeObjects">addChangesIfNotEmpty: aRefactoryChange	aRefactoryChange isEmpty ifTrue: [^nil].	changes add: aRefactoryChange.	^aRefactoryChange</body><body package="Browser-ChangeObjects">changeForClass: aRBClass selector: aSelector 	changes reverseDo: 			[:each | 			| change |			change := each changeForClass: aRBClass selector: aSelector.			change notNil ifTrue: [^change]].	^nil</body><body package="Browser-ChangeObjects">changeForMetaclass: aSymbol selector: aSelector 	changes reverseDo: 			[:each | 			| change |			change := each changeForMetaclass: aSymbol selector: aSelector.			change notNil ifTrue: [^change]].	^nil</body><body package="Browser-ChangeObjects">changeObject	"Composite Changes don't really have one of these"	^nil</body><body package="Browser-ChangeObjects">changesSize	^changes inject: 0 into: [:sum :each | sum + each changesSize]</body><body package="Browser-ChangeObjects">priorChangeType: aSymbol	changes do: [:each | each priorChangeType: aSymbol]</body><body package="Browser-ChangeObjects">renameChangesForObject: aClassName to: newClassName 	^(self copy)		changes: (self changes 					collect: [:each | each renameChangesForObject: aClassName to: newClassName]);		yourself</body><body package="Browser-ChangeObjects">undoAsSingleChange	undoSingle := true.</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoryChange</class-id> <category>refactory-changes</category><body package="Browser-ChangeObjects">addInstanceVariable: variableName to: aClass 	^self addChange: (AddInstanceVariableChange add: variableName to: aClass)</body><body package="Browser-ChangeObjects">compile: source in: class 	^self addChange: (AddMethodChange compile: source in: class)</body><body package="Browser-ChangeObjects">compile: source in: class classified: aProtocol 	^self addChange: (AddMethodChange 				compile: source				in: class				classified: aProtocol)</body><body package="Browser-ChangeObjects">defineClass: aString 	^self addChange: (AddClassChange definition: aString)</body><body package="Browser-ChangeObjects">defineNameSpace: aString 	^self addChange: (AddNameSpaceChange definition: aString)</body><body package="Browser-ChangeObjects">defineSharedVariable: aString 	^self addChange: (AddSharedVariableChange definition: aString)</body><body package="Browser-ChangeObjects">moveObjectNamed: objectName to: nameSpaceName 	^self addChange: (MoveObjectChange move: objectName to: nameSpaceName)</body><body package="Browser-ChangeObjects">pruneEmptiedMethodCategories	"Within the scope of the methods I may be removing, determine which method categories are being completely emptied out, and queue changes to remove those as well."		| removedMethods |	removedMethods := ((changes		select: [:each | each isKindOf: RemoveMethodChange]) groupedBy:			#changeObject) collect: [:eachSet | eachSet collect: #selector].	removedMethods		keysAndValuesDo:			[:eachClass :selectors | 			(selectors				groupedBy:					[:eachSelector | eachClass organization categoryOfElement: eachSelector])				keysAndValuesDo:					[:eachCategory :categorizedSelectors | 					(eachClass organization listAtCategoryNamed: eachCategory) size						= categorizedSelectors size						ifTrue: [self removeMethodCategory: eachCategory from: eachClass]]]</body><body package="Browser-ChangeObjects">pruneEmptiedSharedVariableCategories	"Within the scope of the shares I may be removing, determine which share categories are being completely emptied out, and queue changes to remove those as well."	| removedShares |	removedShares := ((changes				select: [:each | each isKindOf: RemoveSharedVariableChange]) groupedBy: 						[:each |						each bindingReference makeUnambiguous finalNameSpaceName							asQualifiedReference value])				collect: [:eachSet | eachSet collect: #bindingReference].	removedShares keysAndValuesDo: 			[:eachScope :bindings |			(bindings groupedBy: 					[:eachBinding |					eachScope asNameSpace organization						categoryOfElement: eachBinding simpleName])				keysAndValuesDo: 					[:eachCategory :categorizedBindings |					(eachScope asNameSpace organization listAtCategoryNamed: eachCategory)						size = categorizedBindings size						ifTrue: [self removeSharedVariableCategory: eachCategory from: eachScope]]]</body><body package="Browser-ChangeObjects">removeClass: aClass 	self addChange: (RemoveClassChange removeClassName: aClass unambiguousName)</body><body package="Browser-ChangeObjects">removeClassNamed: aSymbol 	self addChange: (RemoveClassChange removeClassName: aSymbol)</body><body package="Browser-ChangeObjects">removeInstanceVariable: variableName from: aClass 	^self 		addChange: (RemoveInstanceVariableChange remove: variableName from: aClass)</body><body package="Browser-ChangeObjects">removeMethod: aSelector from: aClass 	^self addChange: (RemoveMethodChange remove: aSelector from: aClass)</body><body package="Browser-ChangeObjects">removeMethodCategory: aSymbol from: aClass 	^self 		addChange: (RemoveProtocolChange class: aClass protocol: aSymbol)</body><body package="Browser-ChangeObjects">removeNameSpaceNamed: aString 	^self addChange: (RemoveNameSpaceChange objectName: aString)</body><body package="Browser-ChangeObjects">removeObject: aClassOrNamespace		aClassOrNamespace isNameSpace		ifTrue: [self removeNameSpaceNamed: aClassOrNamespace unambiguousName]		ifFalse: [self removeClassNamed: aClassOrNamespace unambiguousName]</body><body package="Browser-ChangeObjects">removeSharedVariableCategory: aSymbol from: aNameSpace 	^self 		addChange: (RemoveProtocolChange nameSpace: aNameSpace protocol: aSymbol)</body><body package="Browser-ChangeObjects">removeSharedVariableNamed: aString 	^self addChange: (RemoveSharedVariableChange objectName: aString)</body><body package="Browser-ChangeObjects">restoreOverriddenMethod: aSelector for: aClass 	^self addChange: (RestoreOverrideChange 				for: (Override overridesForSelector: aSelector class: aClass) last)</body><body package="Browser-ChangeObjects">restoreOverriddenObject: aClassOrNamespace		self		addChange:			(RestoreOverrideChange				for: (Override overridesForClassOrNameSpace: aClassOrNamespace) last)</body><body package="Browser-ChangeObjects">restoreOverriddenShareReference: aBindingReference		self		addChange:			(RestoreOverrideChange				for:					(Override						overridesForDataKey: aBindingReference simpleName						in: aBindingReference environment) last)</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoryChange</class-id> <category>private-inspector accessing</category><body package="Browser-ChangeObjects">changes	^changes</body><body package="Browser-ChangeObjects">changes: aCollection 	changes := aCollection</body><body package="Browser-ChangeObjects">removeChange: aChange 	changes remove: aChange ifAbsent: [changes do: [:each | each removeChange: aChange]]</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoryChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">displayString	"Add an indication when this is an undo action to aid in debugging."	| stream |	stream := WriteStream on: String new.	self isUndo ifTrue: [stream nextPutAll: (#UndoTag &lt;&lt; #browser &gt;&gt; '[UNDO] ') asString].	stream nextPutAll: super displayString asString.	^stream contents asText allBold</body><body package="Browser-ChangeObjects">printOn: aStream	"Add an indication when this is a composite change to aid in debugging."	name isNil 		ifTrue: [super printOn: aStream]		ifFalse: [aStream nextPutAll: ('Composite: (' , name asString , ')')]</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoryChange</class-id> <category>comparing</category><body package="Browser-ChangeObjects">= aRefactoryBuilder 	super = aRefactoryBuilder ifFalse: [^false].	changes size = aRefactoryBuilder changes size ifFalse: [^false].	changes with: aRefactoryBuilder changes		do: [:each :change | each = change ifFalse: [^false]].	^true</body><body package="Browser-ChangeObjects">hash	^changes size</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoryChange</class-id> <category>initialize-release</category><body package="Browser-ChangeObjects">initialize	super initialize.	changes := OrderedCollection new.	undoSingle := false.</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoryChange</class-id> <category>copying</category><body package="Browser-ChangeObjects">postCopy	"Never inherit the undoSingle indicator."	super postCopy.	undoSingle := false.	changes := changes collect: [:each | each copy]</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoryChange</class-id> <category>private</category><body package="Browser-ChangeObjects">compressed	"Pull up any composite change that is the sole child of another composite change.	 These interfere with undo/redo sequences and create increasing chains of redundant changes."	| compressed |	self isEmpty ifTrue: [^self].	compressed := self changes reject: [:ea | ea isEmpty].	[compressed size = 1 and: [compressed first class == CompositeRefactoryChange]]		whileTrue: [compressed := compressed first].	^(compressed class == CompositeRefactoryChange)		ifTrue: [compressed]		ifFalse: [self changes: compressed]</body><body package="Browser-ChangeObjects">executeNotifying: aBlock	"Execute the collection of changes, extracting the undo returned by each in sequence.	 If the undo of this composite is a single change, answer the first (primary) undo change.	 Otherwise answer a new composite with a reverse change sequence."	| undos purged |	undos := changes collect: [:each | 		[each executeNotifying: aBlock] 			on: RefactoryChangeFailureNotification			do: [:ex | each == changes first ifTrue: [ex pass] ifFalse: [ex resume]]].	(undos anySatisfy: [:each | each isNil]) ifTrue: [^nil].	undoSingle ifTrue: [		^(undos first class == CompositeRefactoryChange)			ifTrue: [undos first changes first]			ifFalse: [undos first]].	"Purge any empty composites created when an inverse change is a NOOP."	purged := undos reverse reject: [:ea | ea isEmpty].	[purged size = 1 and: [purged first class == CompositeRefactoryChange]]		whileTrue: [purged := purged first].	^((purged class == CompositeRefactoryChange)		ifTrue: [purged]		ifFalse: [CompositeRefactoryChange new changes: purged])			name: self name.</body><body package="Browser-ChangeObjects">isUndo	^changes allSatisfy: [:ea | ea isUndo]</body><body package="Browser-ChangeObjects">isUndo: aBoolean	^changes do: [:ea | ea isUndo: aBoolean]</body><body package="Browser-ChangeObjects">withCleanReversedChanges: aCollection	"Install the changes in aCollection in reverse sequence.	 Purge any empty composites created when an inverse change is a NOOP."	| purged |	purged := aCollection reverse reject: [:ea | ea isEmpty].	[purged size = 1 and: [purged first class == CompositeRefactoryChange]]		whileTrue: [purged := purged first].	^((purged class == CompositeRefactoryChange)		ifTrue: [purged]		ifFalse: [CompositeRefactoryChange new changes: purged])			name: self name.</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoryChange</class-id> <category>testing</category><body package="Browser-ChangeObjects">isEmpty	^changes isEmpty</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoryChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">named: aString 	^(self new)		name: aString;		yourself</body></methods><methods><class-id>Refactory.Browser.RefactoryObjectChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">changeClass: aBehavior 	isMeta := aBehavior isMeta.	self objectName: aBehavior instanceBehavior unambiguousName</body><body package="Browser-ChangeObjects">changeObject	"This handles the most common case where the object may be a NameSpace, a Class or Metaclass, or a SharedVariable binding.	 Subclasses override this method to return their specific object: Package/Bundle, protocol organizer, etc."	| binding |		(binding := self bindingReference bindingOrNil) ifNil: [^nil].	binding isForNameSpace ifTrue: [^binding value].	binding isForClass ifTrue: [^isMeta ifTrue: [binding value class] ifFalse: [binding value]].	^binding</body><body package="Browser-ChangeObjects">definingNamespace	^self changeObject environment</body><body package="Browser-ChangeObjects">methodSourceFor: aSymbol 	(self changeObject includesSelector: aSymbol) ifFalse: [^nil].	^self changeObject sourceCodeAt: aSymbol</body><body package="Browser-ChangeObjects">objectName	^objectName</body><body package="Browser-ChangeObjects">objectName: aString 	objectName := aString</body><body package="Browser-ChangeObjects">priorChangeType: aSymbol	priorChangeType := aSymbol</body><body package="Browser-ChangeObjects">renameChangesForObject: aClassName to: newClassName 	| newString |	newString := self 				changeVariable: self objectName				thatBeginsWith: aClassName				toBeginWith: newClassName.	self objectName = newString 		ifFalse: 			[^(self copy)				objectName: newString;				yourself].	^self</body></methods><methods><class-id>Refactory.Browser.RefactoryObjectChange</class-id> <category>private</category><body package="Browser-ChangeObjects">bindingReference	^self objectName asQualifiedReference makeUnambiguous</body><body package="Browser-ChangeObjects">currentChangeType	"This is the default.  Subclasses override this method to capture their own state from the package change set."		^#none</body><body package="Browser-ChangeObjects">currentPackage	"Most subclasses need to find the package from which to collect the current changeSet state,	 or to reset the changeSet to its prior state during undo.	 Subclasses must override this method to provide their current package as needed."	^nil</body><body package="Browser-ChangeObjects">executeNotifying: aBlock	| undo |	undo := self asUndoOperation.	self primitiveExecute.	aBlock value.	^undo</body><body package="Browser-ChangeObjects">isMeta	^isMeta</body><body package="Browser-ChangeObjects">isMeta: aBoolean 	isMeta := aBoolean</body><body package="Browser-ChangeObjects">isUndo	^isUndo</body><body package="Browser-ChangeObjects">isUndo: aBoolean	isUndo := aBoolean</body><body package="Browser-ChangeObjects">primitiveExecute	^self subclassResponsibility</body><body package="Browser-ChangeObjects">resetToPriorState	"I do nothing by myself, but subclasses may"</body></methods><methods><class-id>Refactory.Browser.RefactoryObjectChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">changeString	^self displayClassName</body><body package="Browser-ChangeObjects">displayClassName	^isMeta == true		ifTrue: [self objectName , ' class']		ifFalse: [self objectName asString]</body><body package="Browser-ChangeObjects">displayString	"Add an indication when this is an undo action to aid in debugging.	 Use the changeString (rather than the name used by the Undo/Redo button display, and which must be inherited)	 as this is more indicative of the actual work to be performed by this object."	| stream |	stream := WriteStream on: String new.	self isUndo ifTrue: [stream nextPutAll: (#UndoTag &lt;&lt; #browser &gt;&gt; '[UNDO] ') asString].	stream nextPutAll: self changeString.	^stream contents asText allBold</body><body package="Browser-ChangeObjects">printOn: aStream	aStream nextPutAll: self displayString</body></methods><methods><class-id>Refactory.Browser.RefactoryObjectChange</class-id> <category>comparing</category><body package="Browser-ChangeObjects">= aRefactoryClassChange 	^super = aRefactoryClassChange and: 			[self objectName = aRefactoryClassChange objectName 				and: [isMeta = aRefactoryClassChange isMeta]]</body><body package="Browser-ChangeObjects">hash	^self objectName hash</body></methods><methods><class-id>Refactory.Browser.RefactoryObjectChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">asUndoOperation	^nil</body></methods><methods><class-id>Refactory.Browser.RefactoryObjectChange</class-id> <category>initialize-release</category><body package="Browser-ChangeObjects">initialize	super initialize.	isMeta := false.	isUndo := false</body></methods><methods><class-id>Refactory.Browser.RefactoryObjectChange</class-id> <category>copying</category><body package="Browser-ChangeObjects">postCopy	"Do not inherit the isUndo flag."		super postCopy.	isUndo := false.</body></methods><methods><class-id>Refactory.Browser.MoveObjectChange</class-id> <category>private</category><body package="Browser-ChangeObjects">currentChangeType	| targetPackage |	^(targetPackage := self currentPackage) isNil		ifTrue: [#none]		ifFalse: [	 		| targetObject |			((targetObject := self changeObject) isNameSpace)				ifTrue: [targetPackage currentChangeForNameSpace: targetObject]				ifFalse: [targetObject isBehavior					ifTrue: [targetPackage currentChangeForClass: targetObject]					ifFalse: [						| binding |						binding := self bindingReference bindingOrNil.						targetPackage currentChangeForShared: binding key in: binding environment]]].</body><body package="Browser-ChangeObjects">currentPackage	| targetObject |	(targetObject := self changeObject) ifNil: [^nil].	^(targetObject isForNameSpace)		ifTrue: [Store.Registry packageForNameSpace: targetObject]		ifFalse: [targetObject isBehavior			ifTrue: [Store.Registry packageForClass: targetObject]			ifFalse: [Store.Registry packageForDataKey: targetObject key owner: targetObject environment]]</body><body package="Browser-ChangeObjects">nameSpace	^targetNamespace asQualifiedReference value</body><body package="Browser-ChangeObjects">nameSpaceName	^targetNamespace</body><body package="Browser-ChangeObjects">originalNameSpace	^self originalNameSpaceName asQualifiedReference value</body><body package="Browser-ChangeObjects">primitiveExecute	self bindingReference relocateTo: self nameSpace.	isUndo ifTrue: [self resetToPriorState]</body><body package="Browser-ChangeObjects">resetToPriorState	| targetPackage |	(targetPackage := Store.Registry packageForNameSpace: self originalNameSpace) isNil ifFalse: [		| targetObject |		((targetObject := self changeObject) isNameSpace)			ifTrue: [targetPackage applyChangeType: priorChangeType nameSpace: targetObject]			ifFalse: [targetObject isBehavior				ifTrue: [targetPackage applyChangeType: priorChangeType class: targetObject]				ifFalse: [					| key |					key := self simpleObjectName asSymbol.					targetPackage applyChangeType: priorChangeType forSharedNamed: key in: self nameSpace]]].</body></methods><methods><class-id>Refactory.Browser.MoveObjectChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">originalNameSpaceName	| index |	index := objectName lastIndexOf: $..	^index isZero		ifTrue: [objectName]		ifFalse: [objectName first: index - 1]</body><body package="Browser-ChangeObjects">renameChangesForObject: aClassName to: newClassName 	| change newObjectName renamedNameSpace |	change := super renameChangesForObject: aClassName to: newClassName.	newObjectName := self 				changeVariable: objectName				thatBeginsWith: aClassName				toBeginWith: newClassName.	renamedNameSpace := self 				changeVariable: targetNamespace				thatBeginsWith: aClassName				toBeginWith: newClassName.	(objectName ~= newObjectName or: [renamedNameSpace ~= targetNamespace]) 		ifTrue: [change move: newObjectName to: targetNamespace].	^change</body><body package="Browser-ChangeObjects">simpleObjectName	^objectName allButFirst: (objectName lastIndexOf: $.)</body></methods><methods><class-id>Refactory.Browser.MoveObjectChange</class-id> <category>initialize-release</category><body package="Browser-ChangeObjects">move: anUnambiguousName to: anUnambiguousTargetName 	objectName := anUnambiguousName.	targetNamespace := anUnambiguousTargetName</body></methods><methods><class-id>Refactory.Browser.MoveObjectChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">asUndoOperation	^(self copy)		move: targetNamespace , '.' , self simpleObjectName to: self originalNameSpaceName;		name: self name;		priorChangeType: self currentChangeType;		isUndo: isUndo not</body></methods><methods><class-id>Refactory.Browser.MoveObjectChange</class-id> <category>comparing</category><body package="Browser-ChangeObjects">= aMoveObjectChange 	^super = aMoveObjectChange 		and: [targetNamespace = aMoveObjectChange nameSpaceName]</body></methods><methods><class-id>Refactory.Browser.MoveObjectChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">move: objectName to: nameSpaceName 	^(self new)		move: objectName to: nameSpaceName;		yourself</body></methods><methods><class-id>Refactory.Browser.PackageChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">package	^self storeRegistry packageNamed: packageName</body><body package="Browser-ChangeObjects">package: aPackage 	packageName := aPackage name</body><body package="Browser-ChangeObjects">storeChangeSet	^#{Store.XChangeSet} value current</body></methods><methods><class-id>Refactory.Browser.PackageChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">asUndoOperation	| oldPackage |	oldPackage := self currentPackage.	oldPackage isNil ifTrue: [^nil].	^(self copy) 		package: oldPackage;		priorChangeType: self currentChangeType;		isUndo: isUndo not</body></methods><methods><class-id>Refactory.Browser.MoveMethodToPackageChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">changeObject	"The object can only be a Class."	| binding |	(binding := self bindingReference bindingOrNil) ifNil: [^nil].	^isMeta ifTrue: [binding value class] ifFalse: [binding value].</body><body package="Browser-ChangeObjects">selector	^selector</body><body package="Browser-ChangeObjects">selector: aSymbol 	selector := aSymbol</body></methods><methods><class-id>Refactory.Browser.MoveMethodToPackageChange</class-id> <category>private</category><body package="Browser-ChangeObjects">currentChangeType	| targetPackage |	^(targetPackage := self currentPackage) isNil		ifTrue: [#none]		ifFalse: [targetPackage currentChangeForSelector: selector class: self changeObject].</body><body package="Browser-ChangeObjects">currentPackage	| targetObject |	(targetObject := self changeObject) ifNil: [^nil].	^self packageForClass: targetObject selector: self selector</body><body package="Browser-ChangeObjects">primitiveExecute	self storeChangeSet		moveSelector: self selector		class: self changeObject		toPackage: self package.	self recompileMethod.	isUndo ifTrue: [self resetToPriorState]</body><body package="Browser-ChangeObjects">recompileMethod	self changeObject		recompile: self selector		in:			(self package				environmentFor: self selector				in: self changeObject)</body><body package="Browser-ChangeObjects">resetToPriorState	| targetPackage |	(targetPackage := self currentPackage) isNil ifFalse: [		targetPackage applyChangeType: priorChangeType selector: selector class: self changeObject].</body></methods><methods><class-id>Refactory.Browser.MoveMethodToPackageChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">class: aClass selector: aSelector package: aPackage 	^(self new)		changeClass: aClass;		selector: aSelector;		package: aPackage;		yourself</body></methods><methods><class-id>Refactory.Browser.MigrateObjectChange</class-id> <category>private</category><body package="Browser-ChangeObjects">primeBinding: aVariableBinding	aVariableBinding isForClass		ifTrue: [^self primeClassBindings: aVariableBinding value].	aVariableBinding isForNameSpace		ifTrue: [^self primeNamespaceBindings: aVariableBinding value].	self primeGeneralBinding: aVariableBinding</body><body package="Browser-ChangeObjects">primeBindings	self primeBinding: self bindingReference binding</body><body package="Browser-ChangeObjects">primeClassBindings: aClass	aClass		selectorsAndMethodsDo:			[:ignored :method | self primeCodeBindings: method].	aClass class		selectorsAndMethodsDo:			[:ignored :method | self primeCodeBindings: method].	aClass asNameSpace bindingsDo: [:each | self primeBinding: each]</body><body package="Browser-ChangeObjects">primeCodeBindings: aCompiledCode	aCompiledCode		allLiteralsDo:			[:each | 			each isBindingReference ifTrue: [each bindingOrNil ifNotNil: [each value]].			(each isVariableBinding and: [each isDeferred]) ifTrue: [each value]]</body><body package="Browser-ChangeObjects">primeGeneralBinding: aBindingReference	aBindingReference binding initializer		ifNotNil: [:code | self primeCodeBindings: code method]</body><body package="Browser-ChangeObjects">primeNamespaceBindings: aNamespace	aNamespace bindingsDo: [:each | self primeBinding: each]</body><body package="Browser-ChangeObjects">primitiveExecute	self primeBindings.	self quietlyRelocate</body><body package="Browser-ChangeObjects">quietlyRelocate	SystemUtils modifySystem: [self bindingReference relocateTo: self nameSpace]</body></methods><methods><class-id>Refactory.Browser.ExecuteCodeChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">category	category isNil ifTrue: [self fillOutDefinition].	^category</body><body package="Browser-ChangeObjects">definingNamespace	^self nameSpace</body><body package="Browser-ChangeObjects">isPrivate	isPrivate isNil ifTrue: [self fillOutDefinition].	^isPrivate</body><body package="Browser-ChangeObjects">nameSpace	^self nameSpaceName asQualifiedReference value</body><body package="Browser-ChangeObjects">nameSpaceName	nameSpaceName isNil ifTrue: [self fillOutDefinition].	^nameSpaceName</body><body package="Browser-ChangeObjects">objectName	objectName isNil ifTrue: [self fillOutDefinition].	^objectName</body><body package="Browser-ChangeObjects">package	^package</body><body package="Browser-ChangeObjects">renameChangesForObject: aClassName to: newClassName 	| newChange tree newReceiver |	newChange := super renameChangesForObject: aClassName to: newClassName.	tree := RBParser parseExpression: newChange definition				onError: [:s :e | ^newChange].	tree isMessage ifFalse: [^newChange].	tree receiver isVariable ifFalse: [^newChange].	newReceiver := self 				changeVariable: tree receiver name				thatBeginsWith: aClassName				toBeginWith: newClassName.	newReceiver = tree receiver name ifTrue: [^newChange].	tree receiver: (RBVariableNode named: newReceiver).	^(newChange copy)		definition: tree formattedCode;		fillOutDefinition;		yourself</body></methods><methods><class-id>Refactory.Browser.ExecuteCodeChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">changeString	^((#Define1s &lt;&lt; #browser &gt;&gt; 'Define &lt;1s&gt;')			expandMacrosWith: self displayClassName)</body><body package="Browser-ChangeObjects">originalCode	| ref binding |	ref := self objectName asQualifiedReference.	binding := ref bindingOrNil.	^binding isNil ifTrue: [''] ifFalse: [ref definition]</body><body package="Browser-ChangeObjects">printOn: aStream 	aStream nextPutAll: definition</body></methods><methods><class-id>Refactory.Browser.ExecuteCodeChange</class-id> <category>private</category><body package="Browser-ChangeObjects">bindingReference	"Before the add is performed, the binding reference may reference an object that does not yet exist.	 Therefore we cannot use an unambiguous reference which needs to find an existing object."		^self objectName asQualifiedReference</body><body package="Browser-ChangeObjects">compilationScope	^self package		ifNil: [self nameSpace]		ifNotNil: [:pkg | pkg environment ifNil: [self nameSpace]]</body><body package="Browser-ChangeObjects">controller	^controller</body><body package="Browser-ChangeObjects">controller: aController 	controller := aController</body><body package="Browser-ChangeObjects">currentPackage	"These changes must establish their perferred package since they are adding a new object."	^package</body><body package="Browser-ChangeObjects">definition	^definition</body><body package="Browser-ChangeObjects">fillOutDefinition	self subclassResponsibility</body><body package="Browser-ChangeObjects">namesIn: aString 	| names stream nameStream |	names := OrderedCollection new.	stream := ReadStream on: aString.		[stream skipSeparators.	stream atEnd] whileFalse: 				[nameStream := WriteStream on: (String new: 10).				[stream atEnd or: [stream peek isSeparator]] 					whileFalse: [nameStream nextPut: stream next].				names add: nameStream contents].	^names</body><body package="Browser-ChangeObjects">parseImports: aString 	| imports stream drillDown private importName |	imports := OrderedCollection new.	stream := aString readStream.		[stream skipSeparators.	stream atEnd] whileFalse: 				[drillDown := false.				private := false.				importName := stream upToSeparator.				[importName = 'drillDown' or: [importName = 'private']] whileTrue: 						[importName = 'drillDown' 							ifTrue: [drillDown := true]							ifFalse: [private := true].						stream skipSeparators.						importName := stream upToSeparator].				importName notEmpty 					ifTrue: 						[imports 							add: (((importName last = $* 									ifTrue: [GeneralNameSpaceImport]									ifFalse: [SpecificNameSpaceImport]) path: (importName tokensBasedOn: $.))									drillDown: drillDown;									private: private;									yourself)]].	^imports</body><body package="Browser-ChangeObjects">primitiveExecute	| object |	[self setPackage: self package while: [		object := Compiler			evaluate: definition			for: nil			in: self compilationScope			notifying: self controller			logged: false].	object isNil ifTrue: [RefactoryChangeFailureNotification raise]]		on: RedefinitionNotification		do: [:note | RedefinitionNotification interactiveHandler: note forcedPackage: self package].	^object</body></methods><methods><class-id>Refactory.Browser.ExecuteCodeChange</class-id> <category>initialize-release</category><body package="Browser-ChangeObjects">definition: aString 	definition := aString</body><body package="Browser-ChangeObjects">initialize	super initialize.	package := nil</body><body package="Browser-ChangeObjects">package: aPackageModel 	package := aPackageModel</body></methods><methods><class-id>Refactory.Browser.ExecuteCodeChange</class-id> <category>comparing</category><body package="Browser-ChangeObjects">= anExecuteCodeChange 	^self class = anExecuteCodeChange class 		and: [definition = anExecuteCodeChange definition]</body><body package="Browser-ChangeObjects">hash	^definition hash</body></methods><methods><class-id>Refactory.Browser.ExecuteCodeChange</class-id> <category>testing</category><body package="Browser-ChangeObjects">isValidCreationMessage: aMessageNode	((aMessageNode receiver isVariable		or: [aMessageNode receiver isLiteralNode]) 			or: [(self isValidMessageName: aMessageNode)]) ifFalse: [^false].	^aMessageNode arguments allSatisfy: [:each | each isLiteralNode].</body><body package="Browser-ChangeObjects">isValidMessageName: aMessageNode 	^false</body></methods><methods><class-id>Refactory.Browser.ExecuteCodeChange class</class-id> <category>private</category><body package="Browser-ChangeObjects">classDefinitionMessages	^#(#defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category: #defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes: #subclass:instanceVariableNames:classVariableNames:poolDictionaries: #subclass:instanceVariableNames:classVariableNames:poolDictionaries:category: #variableByteSubclass:classVariableNames:poolDictionaries: #variableByteSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category: #variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries: #variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:)</body><body package="Browser-ChangeObjects">nameSpaceDefinitionMessages	^#(#defineNameSpace:private:imports:category: #defineNameSpace:private:imports:category:attributes:)</body><body package="Browser-ChangeObjects">sharedVariableDefinitionMessages	^#(#defineStatic:private:constant:category:initializer: #defineStatic:private:constant:category:initializer:attributes: #defineSharedVariable:private:constant:category:initializer: #defineSharedVariable:private:constant:category:initializer:attributes:)</body></methods><methods><class-id>Refactory.Browser.ExecuteCodeChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">definition: aString 	^self definition: aString for: nil</body><body package="Browser-ChangeObjects">definition: aString for: aController 	| message |	message := RBParser parseExpression: aString.	message isMessage ifFalse: [^nil].	(self classDefinitionMessages includes: message selector) 		ifTrue: 			[^(AddClassChange new)				definition: aString;				controller: aController;				yourself].	(self nameSpaceDefinitionMessages includes: message selector) 		ifTrue: 			[^(AddNameSpaceChange new)				definition: aString;				controller: aController;				yourself].	(self sharedVariableDefinitionMessages includes: message selector) 		ifTrue: 			[^(AddSharedVariableChange new)				definition: aString;				controller: aController;				yourself].	^self 		error: #unknownDefinitionType &gt;&gt; 'Unknown Definition Type' &lt;&lt; #browser</body></methods><methods><class-id>Refactory.Browser.AddClassChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">attributes	"In VisualWorks, extraAttributesForDefinition is undefined for a metaclass (but an instance of me would fail precondition checks if it were meta), returns an empty array for most classes and returns an array of the required attributes for subclasses of certain classes."	attributes isNil ifTrue: [self fillOutDefinition].	^attributes</body><body package="Browser-ChangeObjects">changeObject	"The object can only be a Class."	| binding |	(binding := self bindingReference bindingOrNil) ifNil: [^nil].	^isMeta ifTrue: [binding value class] ifFalse: [binding value].</body><body package="Browser-ChangeObjects">classInstanceVariableNames	classInstanceVariableNames isNil ifTrue: [self fillOutDefinition].	^classInstanceVariableNames</body><body package="Browser-ChangeObjects">imports	imports isNil ifTrue: [self fillOutDefinition].	^imports</body><body package="Browser-ChangeObjects">indexedType	indexedType isNil ifTrue: [self fillOutDefinition].	^indexedType</body><body package="Browser-ChangeObjects">instanceVariableNames	instanceVariableNames isNil ifTrue: [self fillOutDefinition].	^instanceVariableNames</body><body package="Browser-ChangeObjects">renameChangesForObject: aClassName to: newClassName 	| newChange tree newSuperclass superclass |	newChange := super renameChangesForObject: aClassName to: newClassName.	tree := RBParser parseExpression: newChange definition				onError: [:s :e | ^newChange].	tree isMessage ifFalse: [^newChange].	tree arguments size &lt; 2 ifTrue: [^newChange].	superclass := tree arguments at: 2.	(superclass isLiteralNode and: [superclass value isBindingReference]) 		ifFalse: [^newChange].	newSuperclass := self 				changeVariable: superclass value asString				thatBeginsWith: aClassName				toBeginWith: newClassName.	newSuperclass = superclass value asString ifTrue: [^newChange].	tree arguments at: 2		put: (RBLiteralNode 				value: (LiteralBindingReference pathString: newSuperclass)).	^(newChange copy)		definition: tree formattedCode;		fillOutDefinition;		yourself</body><body package="Browser-ChangeObjects">superclassName	objectName isNil ifTrue: [self fillOutDefinition].	^superclassName</body></methods><methods><class-id>Refactory.Browser.AddClassChange</class-id> <category>testing</category><body package="Browser-ChangeObjects">isNewDefinitionFormat: aParseTree	^aParseTree selector keywords first = 'defineClass:'</body><body package="Browser-ChangeObjects">isValidMessageName: aMessageNode 	^self class classDefinitionMessages includes: aMessageNode selector</body></methods><methods><class-id>Refactory.Browser.AddClassChange</class-id> <category>private</category><body package="Browser-ChangeObjects">currentChangeType	| targetPackage |	^(targetPackage := self currentPackage) isNil		ifTrue: [#none]		ifFalse: [targetPackage currentChangeForSymbol: self bindingReference absoluteName asSymbol].</body><body package="Browser-ChangeObjects">fillOutDefinition	| parseTree |	parseTree := RBParser parseExpression: definition				onError: [:str :pos | ^self parseDefinitionError].	parseTree isMessage ifFalse: [^self parseDefinitionError].	(self isValidCreationMessage: parseTree) 		ifFalse: [^self parseDefinitionError].	(self isNewDefinitionFormat: parseTree) 		ifTrue: [self fillOutUsingNewFormat: parseTree]		ifFalse: [self fillOutUsingOldFormat: parseTree]</body><body package="Browser-ChangeObjects">fillOutUsingNewFormat: parseTree 	nameSpaceName := parseTree receiver name.	superclassName := (parseTree arguments at: 2) value isNil 				ifTrue: [nil]				ifFalse: [(parseTree arguments at: 2) value asString].	objectName := nameSpaceName , '.' , parseTree arguments first value.	indexedType := (parseTree arguments at: 3) value.	isPrivate := (parseTree arguments at: 4) value.	instanceVariableNames := self namesIn: (parseTree arguments at: 5) value.	classInstanceVariableNames := self 				namesIn: (parseTree arguments at: 6) value.	imports := self parseImports: (parseTree arguments at: 7) value.	category := parseTree arguments size &lt; 8 				ifTrue: [#Unknown]				ifFalse: [(parseTree arguments at: 8) value asSymbol].	attributes := parseTree arguments size &lt; 9 				ifTrue: [#()]				ifFalse: [(parseTree arguments at: 9) value].</body><body package="Browser-ChangeObjects">fillOutUsingOldFormat: parseTree 	nameSpaceName := 'Smalltalk'.	superclassName := parseTree receiver isVariable 				ifTrue: [parseTree receiver name asSymbol]				ifFalse: [parseTree receiver value].	objectName := 'Smalltalk.' , parseTree arguments first value.	isPrivate := false.	indexedType := ('variableByte' match: parseTree selector) 				ifTrue: [#bytes]				ifFalse: 					[('variable' match: parseTree selector) ifTrue: [#objects] ifFalse: [#none]].	instanceVariableNames := self namesIn: (parseTree arguments at: 2) value.	classInstanceVariableNames := #().	"classVariableNames := self namesIn: (parseTree arguments at: 3) value."	imports := self namesIn: (parseTree arguments at: 4) value.	category := parseTree arguments size &lt; 5 				ifTrue: [#Unknown]				ifFalse: [(parseTree arguments at: 5) value asSymbol]</body><body package="Browser-ChangeObjects">parseDefinitionError	nameSpaceName := 'Root'.	objectName := #_UnknownClass.	instanceVariableNames := #().	classInstanceVariableNames := #()</body><body package="Browser-ChangeObjects">primitiveExecute		| result |	result := super primitiveExecute.	isUndo ifTrue: [self resetToPriorState].	^result</body><body package="Browser-ChangeObjects">resetToPriorState	| targetPackage |	(targetPackage := self currentPackage) isNil ifFalse: [		targetPackage applyChangeType: priorChangeType class: self changeObject].</body></methods><methods><class-id>Refactory.Browser.AddClassChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">asUndoOperation	"The undo for adding a class is a simple RemoveClassChange,	 unless the change would recompile the definition for an existing class,	 in which case it is a simple AddClassChange.	 There are no other corresponding objects to consider."		| reference binding change |	reference := self bindingReference.	binding := reference bindingOrNil.	change := (binding notNil and: [binding value environment = self nameSpace])		ifTrue: [(self class definition: reference definition) package: (self packageForClassDefinition: binding value)]		ifFalse: [RemoveClassChange removeClassName: self objectName].	change		name: self name;		priorChangeType: self currentChangeType;		isUndo: isUndo not.	^change</body></methods><methods><class-id>Refactory.Browser.CommentChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">comment	^comment</body><body package="Browser-ChangeObjects">comment: aString 	comment := aString</body><body package="Browser-ChangeObjects">priorChangeType: aSymbol	"A CommentChange must use #noComment instead of #none.	 See the rather complex usage in PackageModel for #applyChangeType:class: and #applyChangeType:nameSpace:"	| type |	(type := aSymbol) == #none ifTrue: [type := #noComment].	super priorChangeType: type</body></methods><methods><class-id>Refactory.Browser.CommentChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">changeString	^((#Comment1s &lt;&lt; #browser &gt;&gt; 'Comment &lt;1s&gt;')			expandMacrosWith: objectName)</body><body package="Browser-ChangeObjects">printOn: aStream 	aStream		nextPutAll: objectName;		nextPutAll: ' comment: ';		print: comment;		nextPut: $!</body></methods><methods><class-id>Refactory.Browser.CommentChange</class-id> <category>private</category><body package="Browser-ChangeObjects">currentChangeType	| targetObject |	^(targetObject := self changeObject) isNameSpace		ifTrue: [(self packageForNameSpace: targetObject) currentChangeForNameSpaceComment: targetObject]		ifFalse: [targetObject isBehavior 			ifTrue: [(self packageForClassDefinition: targetObject) currentChangeForClassComment: targetObject]			ifFalse: [#none]].</body><body package="Browser-ChangeObjects">currentPackage	| targetObject |	(targetObject := self changeObject) ifNil: [^nil].	^targetObject isNameSpace		ifTrue: [self packageForNameSpace: targetObject]		ifFalse: [self packageForClassDefinition: targetObject]</body><body package="Browser-ChangeObjects">primitiveExecute	self changeObject comment: comment.	isUndo ifTrue: [self resetToPriorState].</body><body package="Browser-ChangeObjects">resetToPriorState	| targetObject |	(targetObject := self changeObject) isNameSpace		ifTrue: [(self packageForNameSpace: targetObject) applyChangeType: priorChangeType nameSpace: targetObject]		ifFalse: [(self packageForClassDefinition: targetObject) applyChangeType: priorChangeType class: targetObject].</body></methods><methods><class-id>Refactory.Browser.CommentChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">asUndoOperation	^(self copy) 		comment: self changeObject comment;		priorChangeType: self currentChangeType;		isUndo: isUndo not</body></methods><methods><class-id>Refactory.Browser.CommentChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">object: aClassOrNameSpace comment: aString 	^(self new)		objectName: aClassOrNameSpace unambiguousName;		comment: aString;		yourself</body></methods><methods><class-id>Refactory.Browser.RefactoryVariableChange</class-id> <category>comparing</category><body package="Browser-ChangeObjects">= aRefactoryVariableChange 	^super = aRefactoryVariableChange 		and: [variable = aRefactoryVariableChange variable]</body><body package="Browser-ChangeObjects">hash	^self class hash bitXor: variable hash</body></methods><methods><class-id>Refactory.Browser.RefactoryVariableChange</class-id> <category>private</category><body package="Browser-ChangeObjects">changeSymbol	self subclassResponsibility</body><body package="Browser-ChangeObjects">currentChangeType	| targetPackage |	^(targetPackage := self currentPackage) isNil		ifTrue: [#none]		ifFalse: [targetPackage currentChangeForClass: self changeObject instanceBehavior].</body><body package="Browser-ChangeObjects">currentPackage	| targetObject |	(targetObject := self changeObject) ifNil: [^nil].	^self packageForClassDefinition: targetObject instanceBehavior</body><body package="Browser-ChangeObjects">primitiveExecute	self changeObject perform: self changeSymbol with: self variable.	isUndo ifTrue: [self resetToPriorState].</body><body package="Browser-ChangeObjects">resetToPriorState	| targetPackage |	(targetPackage := self currentPackage) isNil ifFalse: [		targetPackage applyChangeType: priorChangeType class: self changeObject instanceBehavior].</body><body package="Browser-ChangeObjects">variable	^variable</body></methods><methods><class-id>Refactory.Browser.RefactoryVariableChange</class-id> <category>initialize-release</category><body package="Browser-ChangeObjects">class: aBehavior variable: aString 	self changeClass: aBehavior.	variable := aString</body></methods><methods><class-id>Refactory.Browser.AddNameSpaceChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">changeObject	"The object can only be a NameSpace."	| binding |	(binding := self bindingReference bindingOrNil) ifNil: [^nil].	^binding value.</body><body package="Browser-ChangeObjects">imports	imports isNil ifTrue: [self fillOutDefinition].	^imports</body><body package="Browser-ChangeObjects">newNameSpaceName	^self objectName</body></methods><methods><class-id>Refactory.Browser.AddNameSpaceChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">asUndoOperation	"If the change would recompile the definition for an existing namespace, the undo is a simple inverse AddNameSpaceChange.	 Otherwise, the undo for adding a namespace is either a RemoveNameSpaceChange if we are dealing only with a namespace,	 or a composite containing a RemoveNameSpaceChange, plus the changes to remove the class in case this is a class as namespace."		| reference binding change |	reference := self bindingReference.	binding := reference bindingOrNil.	change := (binding notNil and: [binding isForNameSpace])		ifTrue: [(self class definition: reference definition) package: (self packageForNameSpace: binding value)]		ifFalse: [			| compositeChange |			compositeChange := CompositeRefactoryChange new.			compositeChange removeNameSpaceNamed: self objectName.			binding notNil ifTrue: [				binding isForClass					ifTrue: [compositeChange addChange: (self undoForRemoveClass: binding value)]					ifFalse: [(compositeChange defineNameSpace: reference definition)								package: (self packageForNameSpace: binding value)]].			change := compositeChange changesSize = 1					ifTrue: [compositeChange changes first]					ifFalse: [compositeChange]].	change		name: self name;		priorChangeType: self currentChangeType;		isUndo: isUndo not.	^change.</body></methods><methods><class-id>Refactory.Browser.AddNameSpaceChange</class-id> <category>private</category><body package="Browser-ChangeObjects">currentChangeType	| targetPackage |	^(targetPackage := self currentPackage) isNil		ifTrue: [#none]		ifFalse: [targetPackage currentChangeForSymbol: self bindingReference absoluteName asSymbol].</body><body package="Browser-ChangeObjects">fillOutDefinition	| parseTree |	parseTree := RBParser parseExpression: definition				onError: [:str :pos | ^self parseDefinitionError].	parseTree isMessage ifFalse: [^self parseDefinitionError].	(self isValidCreationMessage: parseTree) 		ifFalse: [^self parseDefinitionError].	nameSpaceName := parseTree receiver name.	objectName := nameSpaceName , '.' , parseTree arguments first value.	isPrivate := (parseTree arguments at: 2) value.	imports := self parseImports: (parseTree arguments at: 3) value.	category := (parseTree arguments at: 4) value asSymbol</body><body package="Browser-ChangeObjects">parseDefinitionError	nameSpaceName := 'Root'.	objectName := #_UnknownNameSpace.	imports := #()</body><body package="Browser-ChangeObjects">primitiveExecute		| result |	result := super primitiveExecute.	isUndo ifTrue: [self resetToPriorState].	^result</body><body package="Browser-ChangeObjects">resetToPriorState	| targetPackage |	(targetPackage := self currentPackage) isNil ifFalse: [		targetPackage applyChangeType: priorChangeType nameSpace: self changeObject].</body></methods><methods><class-id>Refactory.Browser.AddNameSpaceChange</class-id> <category>testing</category><body package="Browser-ChangeObjects">isValidMessageName: aMessageNode 	^self class nameSpaceDefinitionMessages includes: aMessageNode selector</body></methods><methods><class-id>Refactory.Browser.AddNameSpaceChange</class-id> <category>initialize-release</category><body package="Browser-ChangeObjects">initialize	super initialize.	imports := nil</body></methods><methods><class-id>Refactory.Browser.MoveMethodToOverrideInPackageChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">oldPackageName: anObject	oldPackageName := anObject</body></methods><methods><class-id>Refactory.Browser.MoveMethodToOverrideInPackageChange</class-id> <category>private</category><body package="Browser-ChangeObjects">currentChangeType	"Collect this before updating the isUndo flag."	| targetPackage |	^(targetPackage := (isUndo ifTrue: [self currentPackage] ifFalse: [self package])) isNil		ifTrue: [#none]		ifFalse: [targetPackage currentChangeForSelector: selector class: self changeObject].</body><body package="Browser-ChangeObjects">oldPackage	^oldPackageName isNil 		ifTrue: [nil]		ifFalse: [self storeRegistry packageNamed: oldPackageName]</body><body package="Browser-ChangeObjects">primitiveExecute	self storeChangeSet		moveDefinedSelector: self selector		class: self changeObject		toPackage: self package.	self recompileMethod.	isUndo ifTrue: [self resetToPriorState]</body><body package="Browser-ChangeObjects">resetToPriorState		| oldModel |	oldModel := self oldPackage modelAtSymbol: self changeObject instanceBehavior absoluteSymbol ifAbsent: [nil].	(oldModel notNil and: [oldModel isExtension]) 		ifTrue: [			self oldPackage removeOverriddenSelector: selector class: self changeObject.			self package applyChangeType: priorChangeType selector: selector class: self changeObject]		ifFalse: [self oldPackage applyChangeType: priorChangeType selector: selector class: self changeObject].</body></methods><methods><class-id>Refactory.Browser.MoveMethodToOverrideInPackageChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">asUndoOperation	| originalPackage |	originalPackage := self currentPackage.	originalPackage isNil ifTrue: [^nil].	^(self copy)		oldPackageName: packageName;		package: originalPackage;		priorChangeType: self currentChangeType;		isUndo: isUndo not</body></methods><methods><class-id>Refactory.Browser.RemoveInstanceVariableChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">changeString	^(#RemoveInstVar1sFrom2s &lt;&lt; #browser &gt;&gt; 'Remove instance variable named, &lt;1s&gt;, from &lt;2s&gt;') 		expandMacrosWith: variable		with: self displayClassName</body><body package="Browser-ChangeObjects">printOn: aStream 	aStream		nextPutAll: self displayClassName;		space;		nextPutAll: self changeSymbol;		space;		nextPutAll: variable;		nextPut: $!</body></methods><methods><class-id>Refactory.Browser.RemoveInstanceVariableChange</class-id> <category>private</category><body package="Browser-ChangeObjects">changeSymbol	^#removeInstVarName:</body></methods><methods><class-id>Refactory.Browser.RemoveInstanceVariableChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">asUndoOperation	| change |	change := AddInstanceVariableChange add: variable to: self changeObject.	change		name: self name;		priorChangeType: self currentChangeType;		isUndo: isUndo not.	^change</body></methods><methods><class-id>Refactory.Browser.RemoveInstanceVariableChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">remove: aVariable from: aBehavior 	^(self new)		class: aBehavior variable: aVariable;		yourself</body></methods><methods><class-id>Refactory.Browser.CodeComponentCommentChange</class-id> <category>initialize-release</category><body package="Browser-ChangeObjects">type: aSymbol 	type := aSymbol</body></methods><methods><class-id>Refactory.Browser.CodeComponentCommentChange</class-id> <category>private</category><body package="Browser-ChangeObjects">currentPackage	^self changeObject</body><body package="Browser-ChangeObjects">resetToPriorState	"I don't reset to prior state for packages/bundles"</body></methods><methods><class-id>Refactory.Browser.CodeComponentCommentChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">changeObject	^type = #package 		ifTrue: [self storeRegistry packageNamed: self objectName]		ifFalse: [self storeRegistry bundleNamed: self objectName]</body></methods><methods><class-id>Refactory.Browser.CodeComponentCommentChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">bundle: aBundleModel comment: aString 	^(self new)		objectName: aBundleModel name;		type: #bundle;		comment: aString;		yourself</body><body package="Browser-ChangeObjects">codeComponent: aCodeComponent comment: aString		aCodeComponent isPackage		ifTrue: [^self package: aCodeComponent comment: aString].	aCodeComponent isBundle		ifTrue: [^self bundle: aCodeComponent comment: aString].	self error: #UnknownCodeComponent &lt;&lt; #browser &gt;&gt; 'Unknown code component'</body><body package="Browser-ChangeObjects">package: aPackageModel comment: aString 	^(self new)		objectName: aPackageModel name;		type: #package;		comment: aString;		yourself</body></methods><methods><class-id>Refactory.Browser.OverrideChange</class-id> <category>initialize-release</category><body package="Browser-ChangeObjects">override: anOverride	override := anOverride</body></methods><methods><class-id>Refactory.Browser.OverrideChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">override	^override</body></methods><methods><class-id>Refactory.Browser.OverrideChange</class-id> <category>comparing</category><body package="Browser-ChangeObjects">= anObject 	^super = anObject and: [self override = anObject override]</body></methods><methods><class-id>Refactory.Browser.OverrideChange</class-id> <category>private</category><body package="Browser-ChangeObjects">bindingReference	^override bindingReference</body><body package="Browser-ChangeObjects">currentChangeType	^override existingChangeType</body></methods><methods><class-id>Refactory.Browser.OverrideChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">for: anOverride 	^(self new)		override: anOverride;		yourself</body></methods><methods><class-id>Refactory.Browser.RestoreOverrideChange</class-id> <category>private</category><body package="Browser-ChangeObjects">hasPreviousChangeForThisMethod	override sources do: [:each |		each isParcel ifFalse: [			(each hasAddOrChangeForSelector: override selector class: override implementingClass) ifTrue: [^true]]].	^false</body><body package="Browser-ChangeObjects">primitiveExecute	| hadChange |	override isForMethod ifTrue: [hadChange := self hasPreviousChangeForThisMethod].	override reinstall.	Override removeOverrideAfterReinstall: override.	override isForMethod ifTrue: [hadChange ifFalse: [self removeNewChangesForThisUndoneMethod]].</body><body package="Browser-ChangeObjects">removeNewChangesForThisUndoneMethod	| currentPackage |	currentPackage := Store.Registry containingPackageForSelector: override selector class: override implementingClass.	currentPackage 		removeChangeTypes: #(#remove #change #add) 		forClass: override implementingClass		selector: override selector</body></methods><methods><class-id>Refactory.Browser.RestoreOverrideChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">asUndoOperation	"A Restore is three parts to its undo.		1) Move (back where it will be overridden)		2) AddOverrideChange (Make it an override)		3) Add&lt;Definition&gt;Change (if the definition has changed, and even if not, to update the change state)"	| change |	change := CompositeRefactoryChange named: self name.	change addChange: override undoMoveChangeObject.	change addChange: (AddOverrideChange for: override).	change addChange: (override addDefinitionChange).	change 		priorChangeType: self currentChangeType;		isUndo: isUndo not.	^change</body></methods><methods><class-id>Refactory.Browser.RestoreOverrideChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">changeString	^((#RestoreOverrideFor1s &lt;&lt; #browser &gt;&gt; 'Restore Override for &lt;1s&gt;')			expandMacrosWith: override printString)</body></methods><methods><class-id>Refactory.Browser.AddOverrideChange</class-id> <category>private</category><body package="Browser-ChangeObjects">primitiveExecute	override installAndRestoreStateTo: priorChangeType</body></methods><methods><class-id>Refactory.Browser.AddOverrideChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">asUndoOperation	| change |	change := RemoveOverrideChange for: override.	change		name: self name;		priorChangeType: self currentChangeType;		isUndo: isUndo not.	^change</body></methods><methods><class-id>Refactory.Browser.AddOverrideChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">changeString	^((#AddOverrideFor1s &lt;&lt; #browser &gt;&gt; 'Add Override for &lt;1s&gt;')			expandMacrosWith: override printString)</body></methods><methods><class-id>Refactory.Browser.MoveClassDefinitionToPackageChange</class-id> <category>private</category><body package="Browser-ChangeObjects">currentChangeType	| targetPackage |	^(targetPackage := self currentPackage) isNil		ifTrue: [#none]		ifFalse: [targetPackage currentChangeForClass: self changeObject].</body><body package="Browser-ChangeObjects">currentPackage	| targetObject |	(targetObject := self changeObject) ifNil: [^nil].	^self packageForClassDefinition: targetObject</body><body package="Browser-ChangeObjects">primitiveExecute	self storeChangeSet 		moveClassDefinition: self changeObject		toPackage: self package.	isUndo ifTrue: [self resetToPriorState]</body><body package="Browser-ChangeObjects">resetToPriorState	| targetPackage |	(targetPackage := self currentPackage) isNil ifFalse: [		targetPackage applyChangeType: priorChangeType class: self changeObject].</body></methods><methods><class-id>Refactory.Browser.MoveClassDefinitionToPackageChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">changeObject	"The object can only be a Class."	| binding |	(binding := self bindingReference bindingOrNil) ifNil: [^nil].	^isMeta ifTrue: [binding value class] ifFalse: [binding value].</body></methods><methods><class-id>Refactory.Browser.MoveClassDefinitionToPackageChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">class: aClass package: aPackage 	^(self new)		changeClass: aClass;		package: aPackage;		yourself</body></methods><methods><class-id>Refactory.Browser.RenameObjectChange</class-id> <category>private</category><body package="Browser-ChangeObjects">executeNotifying: aBlock	"Notify the block for the primary change as well as each in the list of secondary changes, which may be empty."		[| undos |	self bindingReference renameTo: newName.	aBlock value.	undos := changes collect: [:each | 		(each renameChangesForObject: oldName asString to: self newUnambiguousName) 			executeNotifying: aBlock].	(undos anySatisfy: [:each | each isNil]) ifTrue: [^nil].	^(self copy)		changes: undos reverse;		rename: self newUnambiguousName to: oldName asQualifiedReference simpleName;		isUndo: isUndo not] 			on: RefactoryChangeFailureNotification			do: [:ex | ex resume]</body><body package="Browser-ChangeObjects">isUndo	"The change itself does not currently use isUndo when resetting its prior state.	 The secondary changes, however, may indicate this and must be taken into consideration.	 This method is only used here when prepending the [UNDO] tag for display purposes in debugging."	changes isEmpty ifTrue: [^isUndo].	^isUndo and: [super isUndo]</body><body package="Browser-ChangeObjects">isUndo: aBoolean	"The change itself does not currently use isUndo when resetting its prior state.	 This property is only used here when prepending the [UNDO] tag for display purposes in debugging."	isUndo := aBoolean.	super isUndo: aBoolean.</body><body package="Browser-ChangeObjects">newName	^newName</body><body package="Browser-ChangeObjects">newUnambiguousName	^oldName asQualifiedReference environment unambiguousName , '.' , newName</body><body package="Browser-ChangeObjects">oldName	^oldName</body></methods><methods><class-id>Refactory.Browser.RenameObjectChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">bindingReference	^oldName asQualifiedReference</body><body package="Browser-ChangeObjects">renameChangesForObject: aClassName to: newClassName 	| change newString |	change := super renameChangesForObject: aClassName to: newClassName.	newString := self 				changeVariable: oldName				thatBeginsWith: aClassName				toBeginWith: newClassName.	oldName = newString ifFalse: [change rename: newClassName to: newString].	^change</body></methods><methods><class-id>Refactory.Browser.RenameObjectChange</class-id> <category>comparing</category><body package="Browser-ChangeObjects">= aRenameClassChange 	^super = aRenameClassChange and: 			[oldName = aRenameClassChange oldName 				and: [newName = aRenameClassChange newName]]</body></methods><methods><class-id>Refactory.Browser.RenameObjectChange</class-id> <category>initialize-release</category><body package="Browser-ChangeObjects">initialize	super initialize.	isUndo := false.</body><body package="Browser-ChangeObjects">rename: oldString to: newString	oldName := oldString.	newName := newString.</body></methods><methods><class-id>Refactory.Browser.RenameObjectChange</class-id> <category>testing</category><body package="Browser-ChangeObjects">isEmpty	"Even if the changes are empty, there is always the primary change."		^false</body></methods><methods><class-id>Refactory.Browser.RenameObjectChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">changeString	^#Rename1sTo2s &lt;&lt; #browser &gt;&gt; 'Rename &lt;1s&gt; to &lt;2s&gt;'		expandMacrosWith: oldName		with: newName</body><body package="Browser-ChangeObjects">displayString	"Add an indication when this is an undo action to aid in debugging.	 Use the changeString (rather than the name) which is more indicative of the work to be performed by this object."	| stream |	stream := WriteStream on: String new.	self isUndo ifTrue: [stream nextPutAll: (#UndoTag &lt;&lt; #browser &gt;&gt; '[UNDO] ') asString].	stream nextPutAll: self changeString.	^stream contents asText allBold</body></methods><methods><class-id>Refactory.Browser.RenameObjectChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">rename: oldString to: newString 	^(self new)		rename: oldString to: newString;		yourself</body></methods><methods><class-id>Refactory.Browser.RemoveObjectChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">printOn: aStream 	aStream		nextPutAll: '#{';		nextPutAll: objectName;		nextPutAll: '} removeFromSystem';		nextPut: $!</body></methods><methods><class-id>Refactory.Browser.RemoveObjectChange</class-id> <category>private</category><body package="Browser-ChangeObjects">primitiveExecute	| result |	result := self bindingReference removeFromSystem.	isUndo ifTrue: [self resetToPriorState].	^result</body></methods><methods><class-id>Refactory.Browser.RemoveObjectChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">objectName: aString 	^(self new)		objectName: aString;		yourself</body></methods><methods><class-id>Refactory.Browser.RemoveSharedVariableChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">changeString	^((#RemoveSharedVariable1s &lt;&lt; #browser &gt;&gt; 'Remove shared variable &lt;1s&gt;')			expandMacrosWith: objectName)</body></methods><methods><class-id>Refactory.Browser.RemoveSharedVariableChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">asUndoOperation	"The undo is a simple AddSharedVariabelChange, unless there are overrides,	 in which case we convert to a composite change and append the relevant override changes."		| binding definition change overrides compositeChange |	binding := self changeObject.	definition := self bindingReference definition.	change := (AddSharedVariableChange definition: definition)		package: (self packageForSharedVariable: binding key in: binding environment).	overrides := Override overridesForStatic: binding in: binding environment.	overrides isNil ifFalse: [		compositeChange := change asCompositeChange.		compositeChange addChange: (self undoForRemoveOverrides: overrides).		change := compositeChange].	change		name: self name;		priorChangeType: self currentChangeType;		isUndo: isUndo not.	^change</body></methods><methods><class-id>Refactory.Browser.RemoveSharedVariableChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">changeObject	"The object can only be a SharedVariable."	^self bindingReference bindingOrNil</body></methods><methods><class-id>Refactory.Browser.RemoveSharedVariableChange</class-id> <category>private</category><body package="Browser-ChangeObjects">currentChangeType	| targetPackage |	^(targetPackage := self currentPackage) isNil		ifTrue: [#none]		ifFalse: [ 			| binding |			binding := self changeObject.			targetPackage currentChangeForShared: binding key in: binding environment].</body><body package="Browser-ChangeObjects">currentPackage	| binding |	(binding := self changeObject) ifNil: [^nil].	^self packageForSharedVariable: binding key in: (Root whoDefinesBinding: binding)</body><body package="Browser-ChangeObjects">resetToPriorState	| targetPackage |	(targetPackage := self currentPackage) isNil ifFalse: [		| binding |		binding := self changeObject.		targetPackage applyChangeType: priorChangeType forSharedNamed: binding key in: binding environment].</body></methods><methods><class-id>Refactory.Browser.AddSharedVariableChange</class-id> <category>initialize-release</category><body package="Browser-ChangeObjects">initialize	super initialize.	isConstant := false.	initializer := nil</body></methods><methods><class-id>Refactory.Browser.AddSharedVariableChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">changeObject	"This is the object in which the SharedVariable is defined, either the binding reference of the NameSpace or the Class."	| bindingRef env |	bindingRef := self bindingReference.	env := bindingRef environment.	^env isNameSpace ifTrue: [bindingRef] ifFalse: [env]</body><body package="Browser-ChangeObjects">initializer	initializer isNil ifTrue: [self fillOutDefinition].	^initializer</body><body package="Browser-ChangeObjects">isConstant	isConstant isNil ifTrue: [self fillOutDefinition].	^isConstant</body><body package="Browser-ChangeObjects">nameSpace	"If the shared variable is defined directly in a namespace, then I return that namespace.  If the shared variable is defined in a class, I return the namespace of that class.  The environment returned by e.g. the shared variable's bindingReference would not do this:  it would return the class in that case.  However my superclass uses #nameSpace as the environment for compiling the do-it.  This same environment is also used in the CompiledInitializer.  Hence if this change is for a shared variable defined in a class, we must return the enviroment of the class instead of the class itself, i.e. the class' namespace.	The creator of this method wrote, 'I know, this sounds crazy.  7.4.1 is very close and I want to limit the number of changes we are making right now.  Besides, who reads method comments anyway?'  Actually, it sounds quite sensible - or at least, one can see that sometimes you want the class of the shared var and at other times the namespace of that class;  this is one of the latter times."	| nameSpaceOrBehavior |	nameSpaceOrBehavior := super nameSpace.	^nameSpaceOrBehavior isBehavior		ifTrue: [nameSpaceOrBehavior environment]		ifFalse: [nameSpaceOrBehavior]</body></methods><methods><class-id>Refactory.Browser.AddSharedVariableChange</class-id> <category>testing</category><body package="Browser-ChangeObjects">isValidMessageName: aMessageNode 	^self class sharedVariableDefinitionMessages 		includes: aMessageNode selector</body></methods><methods><class-id>Refactory.Browser.AddSharedVariableChange</class-id> <category>private</category><body package="Browser-ChangeObjects">currentChangeType	| targetPackage |	^(targetPackage := self currentPackage) isNil		ifTrue: [#none]		ifFalse: [	 		| binding |			binding := self bindingReference bindingOrNil.			targetPackage currentChangeForShared: binding key in: binding environment].</body><body package="Browser-ChangeObjects">currentPackage	| binding |	(binding := self bindingReference bindingOrNil) ifNil: [^nil].	^self packageForSharedVariable: binding key in: (Root whoDefinesBinding: binding)</body><body package="Browser-ChangeObjects">fillOutDefinition	| parseTree |	parseTree := RBParser parseExpression: definition				onError: [:str :pos | ^self parseDefinitionError].	parseTree isMessage ifFalse: [^self parseDefinitionError].	(self isValidCreationMessage: parseTree) 		ifFalse: [^self parseDefinitionError].	nameSpaceName := parseTree receiver name.	objectName := nameSpaceName , '.' , parseTree arguments first value.	isPrivate := (parseTree arguments at: 2) value.	isConstant := (parseTree arguments at: 3) value.	category := (parseTree arguments at: 4) value asSymbol.	initializer := (parseTree arguments at: 5) value</body><body package="Browser-ChangeObjects">parseDefinitionError	nameSpaceName := 'Root'.	objectName := #_UnknownSharedVariable</body><body package="Browser-ChangeObjects">primitiveExecute		| result |	result := super primitiveExecute.	isUndo ifTrue: [self resetToPriorState].	^result</body><body package="Browser-ChangeObjects">resetToPriorState	| targetPackage |	(targetPackage := self currentPackage) isNil ifFalse: [		| binding |		binding := self bindingReference bindingOrNil.		targetPackage applyChangeType: priorChangeType forSharedNamed: binding key in: binding environment].</body></methods><methods><class-id>Refactory.Browser.AddSharedVariableChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">asUndoOperation	"The undo for adding a shared variable is a simple RemoveSharedVariableChange,	 unless the change would recompile the definition for an existing shared,	 in which case it is a simple AddSharedVariableChange.	 There are no other associated objects to consider."		| reference binding change |	reference := self bindingReference.	binding := reference bindingOrNil.	change := (binding notNil and: [binding isForGeneral])		ifTrue: [			(self class definition: reference definition)				package: (self packageForSharedVariable: binding key in: binding environment)]		ifFalse: [RemoveSharedVariableChange objectName: self objectName].	change		name: self name;		priorChangeType: self currentChangeType;		isUndo: isUndo not.	^change</body></methods><methods><class-id>Refactory.Browser.CodeComponentPropertyChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">changeObject		^self codeComponent</body><body package="Browser-ChangeObjects">codeComponent		componentType = #package		ifTrue: [^self storeRegistry packageNamed: componentName].	componentType = #bundle		ifTrue: [^self storeRegistry bundleNamed: componentName].	self shouldNotImplement</body><body package="Browser-ChangeObjects">codeComponent: aCodeComponent		componentName := aCodeComponent name.	aCodeComponent isPackage ifTrue: [componentType := #package].	aCodeComponent isBundle ifTrue: [componentType := #bundle]</body><body package="Browser-ChangeObjects">componentName	^componentName</body><body package="Browser-ChangeObjects">componentType	^componentType</body><body package="Browser-ChangeObjects">installedPropertyValue		^self codeComponent propertyAt: propertyKey</body><body package="Browser-ChangeObjects">priorChangeType: aSymbol	priorChangeType := aSymbol</body><body package="Browser-ChangeObjects">propertyAt: aSymbol put: anObject		propertyKey := aSymbol.	propertyValue := anObject</body><body package="Browser-ChangeObjects">propertyKey	^propertyKey</body><body package="Browser-ChangeObjects">propertyKey: anObject	propertyKey := anObject</body><body package="Browser-ChangeObjects">propertyValue	^propertyValue</body><body package="Browser-ChangeObjects">propertyValue: anObject	propertyValue := anObject</body></methods><methods><class-id>Refactory.Browser.CodeComponentPropertyChange</class-id> <category>private</category><body package="Browser-ChangeObjects">currentChangeType	^self codeComponent currentChangeForProperty: self propertyKey</body><body package="Browser-ChangeObjects">executeNotifying: aBlock	| undo |	undo := self asUndoOperation.	self primitiveExecute.	aBlock value.	^undo</body><body package="Browser-ChangeObjects">isUndo	^isUndo</body><body package="Browser-ChangeObjects">isUndo: aBoolean	isUndo := aBoolean</body><body package="Browser-ChangeObjects">primitiveExecute		self codeComponent propertyAt: propertyKey put: propertyValue.	isUndo ifTrue: [self resetToPriorState]</body><body package="Browser-ChangeObjects">resetToPriorState	self codeComponent applyChangeType: priorChangeType forProperty: self propertyKey</body></methods><methods><class-id>Refactory.Browser.CodeComponentPropertyChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">asUndoOperation	"In order to clear the package/bundle change set, we need to track whether this is an Undo operation."		^(self copy)		propertyValue: self installedPropertyValue;		priorChangeType: self currentChangeType;		isUndo: isUndo not</body></methods><methods><class-id>Refactory.Browser.CodeComponentPropertyChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">changeString		^#Property1s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; Property' expandMacrosWith:			componentName</body><body package="Browser-ChangeObjects">displayString	"Add an indication when this is an undo action to aid in debugging.	 Use the changeString (rather than the name) which is more indicative of the work to be performed by this object."	| stream |	stream := WriteStream on: String new.	self isUndo ifTrue: [stream nextPutAll: (#UndoTag &lt;&lt; #browser &gt;&gt; '[UNDO] ') asString].	stream nextPutAll: self changeString.	^stream contents asText allBold</body></methods><methods><class-id>Refactory.Browser.CodeComponentPropertyChange</class-id> <category>comparing</category><body package="Browser-ChangeObjects">= aCodeComponentPropertyChange		^super = aCodeComponentPropertyChange		and:			[componentType = aCodeComponentPropertyChange componentType				and:					[componentName = aCodeComponentPropertyChange componentName						and:							[propertyKey = aCodeComponentPropertyChange propertyKey								and: [propertyValue = aCodeComponentPropertyChange propertyValue]]]]</body><body package="Browser-ChangeObjects">hash		^(super hash bitXor: propertyKey hash) hashMultiply		bitXor: componentName hash</body></methods><methods><class-id>Refactory.Browser.CodeComponentPropertyChange</class-id> <category>initialize-release</category><body package="Browser-ChangeObjects">initialize	isUndo := false</body></methods><methods><class-id>Refactory.Browser.CodeComponentPropertyChange</class-id> <category>copying</category><body package="Browser-ChangeObjects">postCopy	"Do not inherit the isUndo flag."		super postCopy.	isUndo := false.</body></methods><methods><class-id>Refactory.Browser.CodeComponentPropertyChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">component: aCodeComponent	^self new codeComponent: aCodeComponent</body></methods><methods><class-id>Refactory.Browser.RemoveClassChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">asUndoOperation	| change |	change := self undoForRemoveClass: self bindingReference value.	"Override subgroup name with primary object name."	change 		name: self name;		undoAsSingleChange;		priorChangeType: self currentChangeType;		isUndo: isUndo not.	^change</body></methods><methods><class-id>Refactory.Browser.RemoveClassChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">changeString	^((#RemoveClass1s &lt;&lt; #browser &gt;&gt; 'Remove class &lt;1s&gt;')			expandMacrosWith: objectName)</body></methods><methods><class-id>Refactory.Browser.RemoveClassChange</class-id> <category>private</category><body package="Browser-ChangeObjects">currentChangeType	| targetPackage |	^(targetPackage := self currentPackage) isNil		ifTrue: [#none]		ifFalse: [targetPackage currentChangeForClass: self changeObject].</body><body package="Browser-ChangeObjects">currentPackage	| targetObject |	(targetObject := self changeObject) ifNil: [^nil].	^self packageForClassDefinition: targetObject</body><body package="Browser-ChangeObjects">resetToPriorState	| targetPackage |	(targetPackage := self currentPackage) isNil ifFalse: [		targetPackage applyChangeType: priorChangeType class: self changeObject].</body></methods><methods><class-id>Refactory.Browser.RemoveClassChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">changeObject	"The object can only be a Class."	| binding |	(binding := self bindingReference bindingOrNil) ifNil: [^nil].	^isMeta ifTrue: [binding value class] ifFalse: [binding value].</body></methods><methods><class-id>Refactory.Browser.RemoveClassChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">remove: aClass 	^(self new)		changeClass: aClass;		yourself</body><body package="Browser-ChangeObjects">removeClassName: aSymbol 	^(self new)		objectName: aSymbol;		yourself</body></methods><methods><class-id>Refactory.Browser.MoveNameSpaceToPackageChange</class-id> <category>private</category><body package="Browser-ChangeObjects">currentChangeType	| targetPackage |	^(targetPackage := self currentPackage) isNil		ifTrue: [#none]		ifFalse: [targetPackage currentChangeForNameSpace: self changeObject].</body><body package="Browser-ChangeObjects">currentPackage	| targetObject |	(targetObject := self changeObject) ifNil: [^nil].	^self packageForNameSpace: targetObject</body><body package="Browser-ChangeObjects">primitiveExecute	self storeChangeSet 		moveNameSpaceDefinition: self changeObject		toPackage: self package.	isUndo ifTrue: [self resetToPriorState]</body><body package="Browser-ChangeObjects">resetToPriorState	| targetPackage |	(targetPackage := self currentPackage) isNil ifFalse: [		targetPackage applyChangeType: priorChangeType nameSpace: self changeObject].</body></methods><methods><class-id>Refactory.Browser.MoveNameSpaceToPackageChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">changeObject	"The object can only be a NameSpace."	| binding |	(binding := self bindingReference bindingOrNil) ifNil: [^nil].	^binding value.</body></methods><methods><class-id>Refactory.Browser.MoveNameSpaceToPackageChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">nameSpace: aNameSpace package: aPackage 	^(self new)		objectName: aNameSpace fullName;		package: aPackage;		yourself</body></methods><methods><class-id>Refactory.Browser.RenameInstanceVariableChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">changeString	^#RenameInstVar1sTo2sFor3s &lt;&lt; #browser 		&gt;&gt; 'Rename instance variable named &lt;1s&gt; to &lt;2s&gt; for &lt;3s&gt;' 			expandMacrosWith: variable			with: newName			with: self displayClassName</body><body package="Browser-ChangeObjects">printOn: aStream 	| keywords |	keywords := self changeSymbol keywords.	aStream		nextPutAll: self displayClassName;		space;		nextPutAll: keywords first;		space;		nextPutAll: variable;		space;		nextPutAll: (keywords at: 2);		space;		nextPutAll: newName;		nextPut: $!</body></methods><methods><class-id>Refactory.Browser.RenameInstanceVariableChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">asUndoOperation	| change |	change := self class rename: newName to: variable in: self changeObject.	change		name: self name;		priorChangeType: self currentChangeType;		isUndo: isUndo not.	^change</body><body package="Browser-ChangeObjects">newName	^newName</body></methods><methods><class-id>Refactory.Browser.RenameInstanceVariableChange</class-id> <category>private</category><body package="Browser-ChangeObjects">changeSymbol	^#changeInstVarName:to:</body><body package="Browser-ChangeObjects">newName: aString 	newName := aString</body><body package="Browser-ChangeObjects">primitiveExecute	self changeObject 		perform: self changeSymbol		with: self variable		with: newName.	isUndo ifTrue: [self resetToPriorState].</body></methods><methods><class-id>Refactory.Browser.RenameInstanceVariableChange</class-id> <category>comparing</category><body package="Browser-ChangeObjects">= aRenameInstanceVariableChange 	^super = aRenameInstanceVariableChange 		and: [newName = aRenameInstanceVariableChange newName]</body><body package="Browser-ChangeObjects">hash	^super hash bitXor: newName hash</body></methods><methods><class-id>Refactory.Browser.RenameInstanceVariableChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">rename: aVariable to: aNewName in: aClass 	^(self new)		class: aClass variable: aVariable;		newName: aNewName;		yourself</body></methods><methods><class-id>Refactory.Browser.RefactoryProtocolChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">isData	^isData</body><body package="Browser-ChangeObjects">isData: aBoolean 	isData := aBoolean</body><body package="Browser-ChangeObjects">protocol	^protocol</body><body package="Browser-ChangeObjects">protocol: aSymbol 	protocol := aSymbol</body></methods><methods><class-id>Refactory.Browser.RefactoryProtocolChange</class-id> <category>private</category><body package="Browser-ChangeObjects">logProtocolChange: aString 	SourceFileManager default logChange: aString</body><body package="Browser-ChangeObjects">protocolObject	"This is the object which understands how to manage its protocol organization.	 For a SharedVariable protocol this is either a NameSpace or a NameSpaceOfClass.	 For a method protocol this is the Class."		^self isData 		ifTrue: [self bindingReference value asNameSpace]		ifFalse: [self changeObject]</body></methods><methods><class-id>Refactory.Browser.RefactoryProtocolChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">class: aClass protocol: aSymbol 	^(self new)		changeClass: aClass;		protocol: aSymbol;		isData: false;		yourself</body><body package="Browser-ChangeObjects">nameSpace: aNameSpace protocol: aSymbol 	^(self new)		objectName: aNameSpace unambiguousName;		protocol: aSymbol;		isData: true;		yourself</body></methods><methods><class-id>Refactory.Browser.RemoveProtocolChange</class-id> <category>private</category><body package="Browser-ChangeObjects">primitiveExecute	self protocolObject organization removeCategory: self protocol.	self logProtocolChange: self protocolObject printString 		, ' organization removeCategory: ' 		, self protocol storeString.	self protocolObject reorganize</body></methods><methods><class-id>Refactory.Browser.RemoveProtocolChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">changeString	^((#GenKey5 &lt;&lt; #browser &gt;&gt; 'Remove protocol, &lt;1s&gt;, from &lt;2s&gt;')			expandMacrosWith: self protocol			with: self protocolObject printString)</body></methods><methods><class-id>Refactory.Browser.RemoveProtocolChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">asUndoOperation	"If a protocol would not need to be added, answer an empty composite which will be purged at the composite level."	| change |	(self protocolObject organization categories includes: self protocol) 		ifFalse: [^CompositeRefactoryChange new].	change := self isData 		ifTrue: [AddProtocolChange nameSpace: self changeObject protocol: self protocol]		ifFalse: [AddProtocolChange class: self changeObject protocol: self protocol].	change 		name: self name;		priorChangeType: self currentChangeType;		isUndo: isUndo not.	^change</body></methods><methods><class-id>Refactory.Browser.AddInstanceVariableChange</class-id> <category>private</category><body package="Browser-ChangeObjects">changeSymbol	^#addInstVarName:</body></methods><methods><class-id>Refactory.Browser.AddInstanceVariableChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">changeString	^(#AddInstVar1sFrom2s &lt;&lt; #browser &gt;&gt; 'Add instance variable named, &lt;1s&gt;, to &lt;2s&gt;') expandMacrosWith: variable		with: self displayClassName</body><body package="Browser-ChangeObjects">printOn: aStream 	aStream		nextPutAll: self displayClassName;		space;		nextPutAll: self changeSymbol;		space;		nextPutAll: variable;		nextPut: $!</body></methods><methods><class-id>Refactory.Browser.AddInstanceVariableChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">asUndoOperation	| change |	change := RemoveInstanceVariableChange remove: variable from: self changeObject.	change		name: self name;		priorChangeType: self currentChangeType;		isUndo: isUndo not.	^change</body></methods><methods><class-id>Refactory.Browser.AddInstanceVariableChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">add: aVariable to: aBehavior 	^(self new)		class: aBehavior variable: aVariable;		yourself</body></methods><methods><class-id>Refactory.Browser.CurrentPackageChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">changeObject	^nil</body><body package="Browser-ChangeObjects">package	^packageName isNil 		ifTrue: [nil]		ifFalse: [self storeRegistry packageNamed: packageName]</body></methods><methods><class-id>Refactory.Browser.CurrentPackageChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">changeString	^((#GenKey2 &lt;&lt; #browser &gt;&gt; 'Make &lt;1s&gt; the default package for changes.')			expandMacrosWith: (packageName isNil					ifTrue: [(#none1 &lt;&lt; #browser &gt;&gt; '(none)')]					ifFalse: [packageName]))</body></methods><methods><class-id>Refactory.Browser.CurrentPackageChange</class-id> <category>initialize-release</category><body package="Browser-ChangeObjects">package: aPackage 	packageName := aPackage isNil ifTrue: [nil] ifFalse: [aPackage name]</body></methods><methods><class-id>Refactory.Browser.CurrentPackageChange</class-id> <category>private</category><body package="Browser-ChangeObjects">asUndoOperation		^(self class package: self storeRegistry currentPackage)		name: self name</body><body package="Browser-ChangeObjects">executeNotifying: aBlock	| undo |	undo := self asUndoOperation.	self storeRegistry currentPackage: self package.	aBlock value.	^undo</body></methods><methods><class-id>Refactory.Browser.CurrentPackageChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">package: aPackage 	^(self new)		package: aPackage;		yourself</body></methods><methods><class-id>Refactory.Browser.RemoveNameSpaceChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">asUndoOperation	| change |	change := self undoForRemoveNameSpace: self changeObject.	"Override subgroup name with primary object name."	change 		name: self name;		undoAsSingleChange;		priorChangeType: self currentChangeType;		isUndo: isUndo not.	^change</body></methods><methods><class-id>Refactory.Browser.RemoveNameSpaceChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">changeString	^((#RemoveNameSpace1s &lt;&lt; #browser &gt;&gt; 'Remove name space &lt;1s&gt;')			expandMacrosWith: objectName)</body></methods><methods><class-id>Refactory.Browser.RemoveNameSpaceChange</class-id> <category>private</category><body package="Browser-ChangeObjects">currentChangeType	| targetPackage |	^(targetPackage := self currentPackage) isNil		ifTrue: [#none]		ifFalse: [targetPackage currentChangeForNameSpace: self changeObject].</body><body package="Browser-ChangeObjects">currentPackage	| targetObject |	(targetObject := self changeObject) ifNil: [^nil].	^self packageForNameSpace: targetObject</body><body package="Browser-ChangeObjects">resetToPriorState	| targetPackage |	(targetPackage := self currentPackage) isNil ifFalse: [		targetPackage applyChangeType: priorChangeType nameSpace: self changeObject].</body></methods><methods><class-id>Refactory.Browser.RemoveNameSpaceChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">changeObject	"The object can only be a NameSpace."	| binding |	(binding := self bindingReference bindingOrNil) ifNil: [^nil].	^binding value.</body></methods><methods><class-id>Refactory.Browser.AddMethodChange</class-id> <category>initialize-release</category><body package="Browser-ChangeObjects">class: aClass protocol: aProtocol source: aString 	self changeClass: aClass.	self protocols: aProtocol.	source := aString</body><body package="Browser-ChangeObjects">class: aClass source: aString 	self changeClass: aClass.	source := aString.	self protocols: self currentProtocol</body><body package="Browser-ChangeObjects">copyAttributesFrom: aSelector 	self copyAttributesFrom: aSelector in: self changeObject</body><body package="Browser-ChangeObjects">copyAttributesFrom: aSelector in: class		class isNil ifTrue: [^self].	package := self packageForClass: class selector: aSelector</body><body package="Browser-ChangeObjects">initialize	super initialize.	package := nil</body><body package="Browser-ChangeObjects">package: aPackageModel 	package := aPackageModel</body><body package="Browser-ChangeObjects">protocols: aCollection 	protocols := aCollection isString 				ifTrue: [Array with: aCollection]				ifFalse: [aCollection].	protocols isNil 		ifTrue: [protocols := Array with: ClassOrganizer defaultProtocol]</body></methods><methods><class-id>Refactory.Browser.AddMethodChange</class-id> <category>comparing</category><body package="Browser-ChangeObjects">= anAddMethodChange 	^super = anAddMethodChange 		and: [self parseTree = anAddMethodChange parseTree]</body><body package="Browser-ChangeObjects">hash	^self parseTree hash</body></methods><methods><class-id>Refactory.Browser.AddMethodChange</class-id> <category>private</category><body package="Browser-ChangeObjects">currentChangeType	| targetPackage |	^(targetPackage := self currentPackage) isNil		ifTrue: [#none]		ifFalse: [targetPackage currentChangeForSelector: selector class: self changeObject].</body><body package="Browser-ChangeObjects">currentPackage	| targetObject |	(targetObject := self changeObject) ifNil: [^nil].	^self packageForClass: targetObject selector: self selector</body><body package="Browser-ChangeObjects">currentProtocol	^self changeObject organization categoryOfElement: self selector</body><body package="Browser-ChangeObjects">executeNotifying: aBlock	| undo |	undo := self asUndoOperation.	self primitiveExecute.	aBlock value.	#{CraftedSmalltalk.PDPManager} ifDefinedDo: [:managerClass |		managerClass reinsertProbesAfterMethod: self method recompileFor: source asText.		managerClass			changedMethodFrom: undo method			to: self method			by: self tool].	^undo</body><body package="Browser-ChangeObjects">inheritProtocol	"Search for my selector in the super class chain and match it if found, otherwise leave as is."		| targetClass |	(targetClass := self changeObject) ifNil: [^self].	((targetClass includesSelector: self selector)		and: [EagerAutoCategorization not]) ifTrue: [^self].	targetClass := targetClass superclass.	[targetClass notNil]		whileTrue:			[(targetClass organization categoryOfElement: self selector)				ifNotNil: [:protocol | ^self protocols: (Array with: protocol)].			targetClass := targetClass superclass]</body><body package="Browser-ChangeObjects">parseSelector	| class |	class := self changeObject.	^class isNil		ifTrue: [RBParser parseMethodPattern: source]		ifFalse: [class parserClass new parseSelector: source]</body><body package="Browser-ChangeObjects">parseTree	^RBParser parseMethod: source onError: [:str :pos | ^nil]</body><body package="Browser-ChangeObjects">primitiveExecute	self		setPackage: self package		while:			[definedSelector := self changeObject				compile: source				classified: self protocol				notifying: self controller				environment: self environment].	definedSelector isNil		ifTrue:			[RefactoryChangeFailureNotification raiseSignal.			^nil].	isUndo ifTrue: [self resetToPriorState].	^definedSelector</body><body package="Browser-ChangeObjects">resetToPriorState	| targetPackage |	(targetPackage := self currentPackage) isNil ifFalse: [		targetPackage applyChangeType: priorChangeType selector: selector class: self changeObject].</body></methods><methods><class-id>Refactory.Browser.AddMethodChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">category	^self protocols first</body><body package="Browser-ChangeObjects">category: aStringOrNil	self protocols: aStringOrNil</body><body package="Browser-ChangeObjects">changeForClass: aSymbol selector: aSelector 	^(isMeta not and: [self selector = aSelector and: [objectName = aSymbol]]) 		ifTrue: [self]		ifFalse: [nil]</body><body package="Browser-ChangeObjects">changeForMetaclass: aSymbol selector: aSelector 	^(isMeta and: [self selector = aSelector and: [objectName = aSymbol]]) 		ifTrue: [self]		ifFalse: [nil]</body><body package="Browser-ChangeObjects">controller	^controller</body><body package="Browser-ChangeObjects">controller: aController 	controller := aController</body><body package="Browser-ChangeObjects">definedSelector	^definedSelector</body><body package="Browser-ChangeObjects">environment	"Return the environment in which our method should be compiled. If we return nil, then the method should be compiled in its default environment, i.e. the namespace of the class. The rules are- if the method itself defines an environment, use it.- if there is no environment defined by this package, use the default (return nil)- if there is no package defined, use the default (return nil)- if the package holds the class definition use the default (return nil), otherwise we would effectively be forcing all classes in a package to be in the default namespace, since we would override the scope of all methods.- if the method is an extension, return the environment of the package."	| method |	self changeObject ifNil: [^nil].	method := self changeObject		compiledMethodAt: selector		ifAbsent: [nil].	(method notNil and: [method environment ~= self changeObject environment])		ifTrue: [^method environment].	package ifNil: [^nil].	package environment ifNil: [^nil].	(package		includesDefinitionOf: self changeObject instanceBehavior absoluteName)		ifTrue: [^nil].	^package environment</body><body package="Browser-ChangeObjects">forClassBehavior	self isMeta: true</body><body package="Browser-ChangeObjects">forInstanceBehavior	self isMeta: false</body><body package="Browser-ChangeObjects">package	^package</body><body package="Browser-ChangeObjects">protocol	^self protocols first</body><body package="Browser-ChangeObjects">protocols	^protocols</body><body package="Browser-ChangeObjects">selector	"This may still return nil."		^selector ifNil: [selector := self parseSelector]</body><body package="Browser-ChangeObjects">source: aSourceString	source := aSourceString</body><body package="Browser-ChangeObjects">tool	^tool ifNil: [		controller ifNil: [^nil].		^controller performer]</body><body package="Browser-ChangeObjects">tool: anObject	tool := anObject</body></methods><methods><class-id>Refactory.Browser.AddMethodChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">asUndoOperation	"The undo is a simple RemoveMethodChange, unless the add is for an existing method,	 in which case it is a simple AddMethodChange.	 If the undo would remove the only method in a protocol,	 we convert to a composite change and append a RemoveProtocolChange."	| change |	change := (self changeObject includesSelector: self selector)		ifTrue: [			| oldProtocol |			oldProtocol := self currentProtocol.			oldProtocol isNil ifTrue: [oldProtocol := #accessing].			(self class				compile: (self methodSourceFor: self selector)				in: self changeObject				classified: oldProtocol)				copyAttributesFrom: self selector;				yourself]		ifFalse: [RemoveMethodChange remove: selector from: self changeObject].	(self changeObject organization categories includes: self protocol)		ifFalse: [			| compositeChange |			compositeChange := change asCompositeChange.			compositeChange addChange: (RemoveProtocolChange class: self changeObject						protocol: self protocol).			change := compositeChange].	change		name: self name;		priorChangeType: self currentChangeType;		isUndo: isUndo not.	^change</body></methods><methods><class-id>Refactory.Browser.AddMethodChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">changeString		^#Compile1s2s &lt;&lt; #browser &gt;&gt; 'Compile &lt;1s&gt;%&gt;%&gt;&lt;2s&gt;'		expandMacrosWith: self displayClassName		with: (self selector ifNil: ['!unparsable-selector!'])</body><body package="Browser-ChangeObjects">originalCode	self changeObject isNil ifTrue: [^''].	^(self changeObject includesSelector: self selector) 		ifTrue: [self methodSourceFor: self selector]		ifFalse: ['']</body><body package="Browser-ChangeObjects">printOn: aStream 	aStream nextPutAll: source</body></methods><methods><class-id>Refactory.Browser.AddMethodChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">compile: aString in: aClass 	^(self new)		class: aClass source: aString;		yourself</body><body package="Browser-ChangeObjects">compile: aString in: aBehavior classified: aProtocol 	^(self new)		class: aBehavior			protocol: aProtocol			source: aString;		yourself</body><body package="Browser-ChangeObjects">compile: aString in: aBehavior classified: aProtocol for: aController 	^(self 		compile: aString		in: aBehavior		classified: aProtocol)		controller: aController;		yourself</body><body package="Browser-ChangeObjects">compile: aString in: aClass for: aController 	^(self compile: aString in: aClass)		controller: aController;		yourself</body></methods><methods><class-id>Refactory.Browser.AddMethodChange class</class-id> <category>accessing</category><body package="Browser-ChangeObjects">eagerAutoCategorization		^EagerAutoCategorization</body><body package="Browser-ChangeObjects">eagerAutoCategorization: aBoolean		EagerAutoCategorization := aBoolean</body></methods><methods><class-id>Refactory.Browser.RemoveOverrideChange</class-id> <category>private</category><body package="Browser-ChangeObjects">primitiveExecute	Override removeOverride: override.	isUndo ifTrue: [override applyChangeType: priorChangeType].</body></methods><methods><class-id>Refactory.Browser.RemoveOverrideChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">asUndoOperation	| change |	change := AddOverrideChange for: override.	change		name: self name;		priorChangeType: self currentChangeType;		isUndo: isUndo not.	^change</body></methods><methods><class-id>Refactory.Browser.RemoveOverrideChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">changeString	^((#RemoveOverrideFor1s &lt;&lt; #browser &gt;&gt; 'Remove Override for &lt;1s&gt;')			expandMacrosWith: override printString)</body></methods><methods><class-id>Refactory.Browser.AddProtocolChange</class-id> <category>private</category><body package="Browser-ChangeObjects">primitiveExecute	self protocolObject organization addCategory: self protocol.	self 		logProtocolChange: self protocolObject printString 				, ' organization addCategory: ' , self protocol printString.	self protocolObject reorganize</body></methods><methods><class-id>Refactory.Browser.AddProtocolChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">changeString	^((#AddProtocol1sTo2s &lt;&lt; #browser &gt;&gt; 'Add protocol, &lt;1s&gt;, to &lt;2s&gt;')			expandMacrosWith: self protocol			with: self protocolObject printString)</body></methods><methods><class-id>Refactory.Browser.AddProtocolChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">asUndoOperation	"The undo is a simple RemoveProtocolChange, unless the add is for an existing protocol,	 in which case it is a simple AddProtocolChange."	| change |	change := (self protocolObject organization categories includes: self protocol) 		ifTrue: [self copy]		ifFalse: [self isData 			ifTrue: [RemoveProtocolChange nameSpace: self changeObject protocol: self protocol]			ifFalse: [RemoveProtocolChange class: self changeObject protocol: self protocol]].	change 		name: self name;		priorChangeType: self currentChangeType;		isUndo: isUndo not.	^change</body></methods><methods><class-id>Refactory.Browser.MoveToProtocolChange</class-id> <category>testing</category><body package="Browser-ChangeObjects">includesProtocol	^self protocolObject organization categories includes: self protocol</body></methods><methods><class-id>Refactory.Browser.MoveToProtocolChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">symbol	^symbol</body><body package="Browser-ChangeObjects">symbol: aSymbol 	symbol := aSymbol</body></methods><methods><class-id>Refactory.Browser.MoveToProtocolChange</class-id> <category>private</category><body package="Browser-ChangeObjects">currentChangeType	| targetObject |	targetObject := self protocolObject.	^self isData		ifTrue: [self currentPackage currentChangeForShared: symbol in: targetObject]		ifFalse: [self currentPackage currentChangeForSelector: symbol class: targetObject]</body><body package="Browser-ChangeObjects">currentPackage	| targetObject |	(targetObject := self protocolObject) ifNil: [^nil].	^(targetObject isNameSpace)		ifTrue: [self packageForSharedVariable: self symbol in: targetObject]		ifFalse: [self packageForClass: targetObject selector: self symbol]</body><body package="Browser-ChangeObjects">primitiveExecute	self includesProtocol ifTrue: [super primitiveExecute].	self protocolObject classifySymbol: symbol under: self protocol.	self logProtocolChange: self protocolObject printString 		, ' classifySymbol: ' , symbol printString 		, ' under: ' , self protocol printString.	isUndo ifTrue: [self resetToPriorState]</body><body package="Browser-ChangeObjects">resetToPriorState	| targetObject |	(targetObject := self protocolObject) isNameSpace		ifTrue: [self currentPackage applyChangeType: priorChangeType forSharedNamed: symbol in: targetObject]		ifFalse: [self currentPackage applyChangeType: priorChangeType selector: symbol class: targetObject].</body></methods><methods><class-id>Refactory.Browser.MoveToProtocolChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">changeString	^((#Move1sTo2sIn3s &lt;&lt; #browser &gt;&gt; 'Move &lt;1s&gt;, to &lt;2s&gt; in &lt;3s&gt;')			expandMacrosWith: symbol			with: self protocol			with: self protocolObject printString)</body></methods><methods><class-id>Refactory.Browser.MoveToProtocolChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">asUndoOperation	"The undo is a simple inverse MoveToProtocolChange.	 If the protocol if it would be empty after the move,	 we convert to a composite change and append a RemoveProtocolChange."	| change compositeChange category |	category := self protocolObject organization categoryOfElement: self symbol.	change := (self copy) protocol: category.	self includesProtocol ifFalse: [		compositeChange := change asCompositeChange.		compositeChange addChange: (self isData 			ifTrue: [RemoveProtocolChange nameSpace: self changeObject protocol: self protocol]			ifFalse: [RemoveProtocolChange class: self changeObject protocol: self protocol]).		change := compositeChange].	change		name: self name;		priorChangeType: self currentChangeType;		isUndo: isUndo not.	^change</body></methods><methods><class-id>Refactory.Browser.MoveToProtocolChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">class: aClass protocol: protocolSymbol symbol: aSymbol 	^(self class: aClass protocol: protocolSymbol)		symbol: aSymbol;		yourself</body><body package="Browser-ChangeObjects">nameSpace: aNameSpace protocol: protocolSymbol symbol: aSymbol 	^(self nameSpace: aNameSpace protocol: protocolSymbol)		symbol: aSymbol;		yourself</body></methods><methods><class-id>Refactory.Browser.RenameProtocolChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">asUndoOperation	| change |	change := (self copy)		protocol: self newProtocol;		newProtocol: self protocol;		name: self name;		priorChangeType: self currentChangeType;		isUndo: isUndo not.	^change</body></methods><methods><class-id>Refactory.Browser.RenameProtocolChange</class-id> <category>private</category><body package="Browser-ChangeObjects">currentChangeType	^self isData		ifTrue: [self currentChangesForTargetShareds]		ifFalse: [self currentChangesForTargetSelectors]</body><body package="Browser-ChangeObjects">currentChangesForTargetSelectors	| dictionary changeProtocol selectors |	dictionary := Dictionary new.	changeProtocol := self isUndo ifTrue: [self newProtocol] ifFalse: [self protocol].	selectors := self protocolObject organization listAtCategoryNamed: changeProtocol asSymbol.	selectors do: [:each |		| currentPackage |		currentPackage := self packageForClass: self protocolObject selector: each.		dictionary at: each put: (currentPackage currentChangeForSelector: each class: self protocolObject)].	^dictionary</body><body package="Browser-ChangeObjects">currentChangesForTargetShareds	| dictionary changeProtocol sharedNames |	dictionary := Dictionary new.	changeProtocol := self isUndo ifTrue: [self newProtocol] ifFalse: [self protocol].	sharedNames := self protocolObject organization listAtCategoryNamed: changeProtocol asSymbol.	sharedNames do: [:each |		| currentPackage |		currentPackage := self packageForSharedVariable: each in: self protocolObject.		dictionary at: each put: (currentPackage currentChangeForShared: each in: self protocolObject)].	^dictionary</body><body package="Browser-ChangeObjects">executeNotifying: aBlock	| undo changeDictionary |	changeDictionary := self protocolObject isNameSpace		ifTrue: [self currentChangesForTargetShareds]		ifFalse: [self currentChangesForTargetSelectors].	undo := super executeNotifying: aBlock.	undo priorChangeType: changeDictionary.	^undo</body><body package="Browser-ChangeObjects">primitiveExecute	(self protocolObject renameCategory: self protocol to: self newProtocol) ifTrue: [		self logProtocolChange: self protocolObject printString 			, ' organization renameCategory: ' , self protocol printString 			, ' to: ' , self newProtocol printString].	isUndo ifTrue: [self resetToPriorState]</body><body package="Browser-ChangeObjects">resetPriorStateForSelectors	priorChangeType keysAndValuesDo:		[:key :value |		| currentPackage |		currentPackage := self packageForClass: self protocolObject selector: key.		currentPackage applyChangeType: value selector: key class: self protocolObject]</body><body package="Browser-ChangeObjects">resetPriorStateForShareds	priorChangeType keysAndValuesDo:		[:key :value |		| currentPackage |		currentPackage := self packageForSharedVariable: key in: self protocolObject.		currentPackage applyChangeType: value forSharedNamed: key in: self protocolObject]</body><body package="Browser-ChangeObjects">resetToPriorState	self protocolObject isNameSpace		ifTrue: [self resetPriorStateForShareds]		ifFalse: [self resetPriorStateForSelectors].</body></methods><methods><class-id>Refactory.Browser.RenameProtocolChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">changeString	^((#RenameProtocol1sTo2sIn3s &lt;&lt; #browser &gt;&gt; 'Rename protocol, &lt;1s&gt;, to &lt;2s&gt; in &lt;3s&gt;')			expandMacrosWith: self protocol			with: self newProtocol			with: self protocolObject printString)</body></methods><methods><class-id>Refactory.Browser.RenameProtocolChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">newProtocol	^newProtocol</body><body package="Browser-ChangeObjects">newProtocol: aSymbol 	newProtocol := aSymbol</body></methods><methods><class-id>Refactory.Browser.RenameProtocolChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">class: aClass oldProtocol: oldSymbol newProtocol: newSymbol 	^(self new)		changeClass: aClass;		protocol: oldSymbol;		newProtocol: newSymbol;		isData: false;		yourself</body><body package="Browser-ChangeObjects">nameSpace: aNameSpace oldProtocol: oldSymbol newProtocol: newSymbol 	^(self new)		objectName: aNameSpace fullName;		protocol: oldSymbol;		newProtocol: newSymbol;		isData: true;		yourself</body></methods><methods><class-id>Refactory.Browser.RemoveMethodChange</class-id> <category>comparing</category><body package="Browser-ChangeObjects">= aRemoveMethodChange 	^super = aRemoveMethodChange 		and: [selector = aRemoveMethodChange selector]</body><body package="Browser-ChangeObjects">hash	^selector hash</body></methods><methods><class-id>Refactory.Browser.RemoveMethodChange</class-id> <category>private</category><body package="Browser-ChangeObjects">currentChangeType	| targetPackage |	^(targetPackage := self currentPackage) isNil		ifTrue: [#none]		ifFalse: [targetPackage currentChangeForSelector: selector class: self changeObject].</body><body package="Browser-ChangeObjects">currentPackage	| targetObject |	(targetObject := self changeObject) ifNil: [^nil].	^self packageForClass: targetObject selector: self selector</body><body package="Browser-ChangeObjects">primitiveExecute	self changeObject removeSelector: selector.	isUndo ifTrue: [self resetToPriorState]</body><body package="Browser-ChangeObjects">resetToPriorState	| targetPackage |	(targetPackage := self currentPackage) isNil ifFalse: [		targetPackage applyChangeType: priorChangeType selector: selector class: self changeObject].</body><body package="Browser-ChangeObjects">selector	^selector</body></methods><methods><class-id>Refactory.Browser.RemoveMethodChange</class-id> <category>initialize-release</category><body package="Browser-ChangeObjects">selector: aSymbol 	selector := aSymbol</body></methods><methods><class-id>Refactory.Browser.RemoveMethodChange</class-id> <category>converting</category><body package="Browser-ChangeObjects">asUndoOperation	| change |	change := (AddMethodChange compile: (self methodSourceFor: self selector) in: self changeObject)		copyAttributesFrom: self selector.	change		name: self name;		priorChangeType: self currentChangeType;		isUndo: isUndo not.	^change</body></methods><methods><class-id>Refactory.Browser.RemoveMethodChange</class-id> <category>printing</category><body package="Browser-ChangeObjects">changeString	^(#RemoveMethod2s1s &lt;&lt; #browser &gt;&gt; 'Remove method, &lt;2s&gt;&gt;&gt;&lt;1s&gt;') expandMacrosWith: selector		with: self displayClassName</body><body package="Browser-ChangeObjects">originalCode	^(self changeObject includesSelector: self selector) 		ifTrue: [self methodSourceFor: self selector]		ifFalse: ['']</body><body package="Browser-ChangeObjects">printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' removeSelector: #';		nextPutAll: selector;		nextPut: $!</body></methods><methods><class-id>Refactory.Browser.RemoveMethodChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">changeObject	"The object can only be a Class."	| binding |	(binding := self bindingReference bindingOrNil) ifNil: [^nil].	^isMeta ifTrue: [binding value class] ifFalse: [binding value].</body><body package="Browser-ChangeObjects">methodDefinition		^MethodDefinition		class: self changeObject		selector: selector</body><body package="Browser-ChangeObjects">referenceEnvironment		^BrowserEnvironment new referencesTo: self selector</body></methods><methods><class-id>Refactory.Browser.RemoveMethodChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">remove: aSymbol from: aClass 	^(self new)		changeClass: aClass;		selector: aSymbol;		yourself</body></methods><methods><class-id>Refactory.Browser.RefactoryChangeManager</class-id> <category>private</category><body package="Browser-ChangeObjects">clearUndoRedoList	undo := OrderedCollection new.	redo := OrderedCollection new</body></methods><methods><class-id>Refactory.Browser.RefactoryChangeManager</class-id> <category>initialize-release</category><body package="Browser-ChangeObjects">connectToChanges	ChangeSet addDependent: self</body><body package="Browser-ChangeObjects">disconnectFromChanges	ChangeSet removeDependent: self</body><body package="Browser-ChangeObjects">initialize	undo := OrderedCollection new.	redo := OrderedCollection new.	isPerformingRefactoring := false.	self connectToChanges</body><body package="Browser-ChangeObjects">release	super release.	self disconnectFromChanges</body></methods><methods><class-id>Refactory.Browser.RefactoryChangeManager</class-id> <category>testing</category><body package="Browser-ChangeObjects">hasRedoableOperations	^redo notEmpty</body><body package="Browser-ChangeObjects">hasUndoableOperations	^undo notEmpty</body></methods><methods><class-id>Refactory.Browser.RefactoryChangeManager</class-id> <category>public access</category><body package="Browser-ChangeObjects">addUndo: aRefactoringChange 	aRefactoringChange isNil ifTrue: [^self clearUndoRedoList].	undo addLast: aRefactoringChange.	undo size &gt; UndoSize ifTrue: [undo removeFirst].	redo := OrderedCollection new</body><body package="Browser-ChangeObjects">ignoreChangesWhile: aBlock 	isPerformingRefactoring ifTrue: [^aBlock value].	isPerformingRefactoring := true.	aBlock ensure: [isPerformingRefactoring := false]</body><body package="Browser-ChangeObjects">performChange: aRefactoringChange 	self ignoreChangesWhile: 			[[self addUndo: aRefactoringChange execute] 				on: RefactoryChangeFailureNotification				do: [:ex | ex return]]</body><body package="Browser-ChangeObjects">performChange: aRefactoringChange withMessage: aString 	self ignoreChangesWhile: 			[[self addUndo: (aRefactoringChange executeWithMessage: aString)] 				on: RefactoryChangeFailureNotification				do: [:ex | ex return]]</body><body package="Browser-ChangeObjects">redoChange	^redo last</body><body package="Browser-ChangeObjects">redoOperation	redo isEmpty ifTrue: [^self].	self ignoreChangesWhile: 			[| change undoChange |			change := redo removeLast.			undoChange := change execute.			undoChange isNil 				ifTrue: [self clearUndoRedoList]				ifFalse: [undo add: undoChange]]</body><body package="Browser-ChangeObjects">undoChange	^undo last</body><body package="Browser-ChangeObjects">undoOperation	undo isEmpty ifTrue: [^self].	self ignoreChangesWhile: 			[| change redoChange |			change := undo removeLast.			redoChange := change execute.			redoChange isNil 				ifTrue: [self clearUndoRedoList]				ifFalse: [redo add: redoChange]]</body></methods><methods><class-id>Refactory.Browser.RefactoryChangeManager</class-id> <category>updating</category><body package="Browser-ChangeObjects">update: anAspectSymbol with: aParameter from: aSender 	| changeType |	(aSender == ChangeSet and: [isPerformingRefactoring not]) ifFalse: [^self].	changeType := (anAspectSymbol isString 				ifTrue: [anAspectSymbol asString]				ifFalse: ['class']) asLowercase.	(changeType indexOfSubCollection: 'class' startingAt: 1) 		+ (changeType indexOfSubCollection: 'selector' startingAt: 1) &gt; 0 		ifTrue: [self clearUndoRedoList]</body></methods><methods><class-id>Refactory.Browser.RefactoryChangeManager class</class-id> <category>class initialization</category><body package="Browser-ChangeObjects">initialize	self nuke.	UndoSize := 5</body><body package="Browser-ChangeObjects">obsolete	self nuke.	super obsolete.</body><body package="Browser-ChangeObjects">undoSize	^UndoSize</body><body package="Browser-ChangeObjects">undoSize: anInteger 	UndoSize := anInteger max: 0</body></methods><methods><class-id>Refactory.Browser.RefactoryChangeManager class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">instance	Instance isNil 		ifTrue: 			[Instance := self basicNew.			Instance initialize].	^Instance</body><body package="Browser-ChangeObjects">new	^self shouldNotImplement</body></methods><methods><class-id>Refactory.Browser.RefactoryChangeManager class</class-id> <category>public access</category><body package="Browser-ChangeObjects">nuke	Instance notNil ifTrue: [Instance release].	Instance := nil</body></methods><methods><class-id>Refactory.Browser.MoveSharedVariableToPackageChange</class-id> <category>private</category><body package="Browser-ChangeObjects">currentChangeType	| targetPackage |	^(targetPackage := self currentPackage) isNil		ifTrue: [#none]		ifFalse: [	 		| binding |			binding := self changeObject.			targetPackage currentChangeForShared: binding key in: binding environment].</body><body package="Browser-ChangeObjects">currentPackage	| binding |	(binding := self changeObject) ifNil: [^nil].	^self packageForSharedVariable: binding key in: (Root whoDefinesBinding: binding)</body><body package="Browser-ChangeObjects">primitiveExecute	| binding |	binding := self changeObject.	self storeChangeSet 		moveDataKey: binding key		owner: binding environment		toPackage: self package.	isUndo ifTrue: [self resetToPriorState]</body><body package="Browser-ChangeObjects">resetToPriorState	| targetPackage |	(targetPackage := self currentPackage) isNil ifFalse: [		| binding |		binding := self changeObject.		targetPackage applyChangeType: priorChangeType forSharedNamed: binding key in: binding environment].</body></methods><methods><class-id>Refactory.Browser.MoveSharedVariableToPackageChange</class-id> <category>accessing</category><body package="Browser-ChangeObjects">changeObject	"The object can only be a SharedVariable."	^self bindingReference bindingOrNil</body></methods><methods><class-id>Refactory.Browser.MoveSharedVariableToPackageChange class</class-id> <category>instance creation</category><body package="Browser-ChangeObjects">sharedVariableNamed: aString package: aPackage 	^(self new)		objectName: aString;		package: aPackage;		yourself</body></methods><methods><class-id>Kernel.Override class</class-id> <category>RefactoringBrowser</category><body package="Browser-ChangeObjects">removeClassOrNameSpaceOverride: override		| list |	list := self overriddenClassesAndNameSpaces at: override object ifAbsent: [^self].	list remove: override ifAbsent: [].	list isEmpty ifTrue: [self overriddenClassesAndNameSpaces removeKey: override object].	override sources do: [:each | override removeFrom: each]</body><body package="Browser-ChangeObjects">removeClassOrNameSpaceOverrideAfterReinstall: override		| list |	list := self overriddenClassesAndNameSpaces at: override object ifAbsent: [^self].	list remove: override ifAbsent: [].	list isEmpty ifTrue: [self overriddenClassesAndNameSpaces removeKey: override object].</body><body package="Browser-ChangeObjects">removeMethodOverride: override 	| dict list |	dict := self overriddenMethods at: override owner ifAbsent: [^self].	list := dict at: override selector ifAbsent: [^self].	list remove: override ifAbsent: [].	list isEmpty ifTrue: [dict removeKey: override selector].	dict isEmpty ifTrue: [self overriddenMethods removeKey: override owner].	override sources do: [:each | override removeFrom: each].</body><body package="Browser-ChangeObjects">removeMethodOverrideAfterReinstall: override 	| dict list |	dict := self overriddenMethods at: override owner ifAbsent: [^self].	list := dict at: override selector ifAbsent: [^self].	list remove: override ifAbsent: [].	list isEmpty ifTrue: [dict removeKey: override selector].	dict isEmpty ifTrue: [self overriddenMethods removeKey: override owner].</body><body package="Browser-ChangeObjects">removeOverride: override		override isForMethod ifTrue: [^self removeMethodOverride: override].	override isForGeneral ifTrue: [^self removeSharedVariableOverride: override].	^self removeClassOrNameSpaceOverride: override</body><body package="Browser-ChangeObjects">removeOverrideAfterReinstall: override		override isForMethod ifTrue: [^self removeMethodOverrideAfterReinstall: override].	override isForGeneral ifTrue: [^self removeSharedVariableOverrideAfterReinstall: override].	^self removeClassOrNameSpaceOverrideAfterReinstall: override</body><body package="Browser-ChangeObjects">removeSharedVariableOverride: override 	| dict list |	dict := self overriddenStatics at: override owner ifAbsent: [^self].	list := dict at: override key ifAbsent: [^self].	list remove: override ifAbsent: [].	list isEmpty ifTrue: [dict removeKey: override key].	dict isEmpty ifTrue: [self overriddenStatics removeKey: override owner].	override sources do: [:each | override removeFrom: each].</body><body package="Browser-ChangeObjects">removeSharedVariableOverrideAfterReinstall: override 	| dict list |	dict := self overriddenStatics at: override owner ifAbsent: [^self].	list := dict at: override key ifAbsent: [^self].	list remove: override ifAbsent: [].	list isEmpty ifTrue: [dict removeKey: override key].	dict isEmpty ifTrue: [self overriddenStatics removeKey: override owner].</body></methods><methods><class-id>Kernel.Override</class-id> <category>accessing</category><body package="Browser-ChangeObjects">addDefinitionChange	self subclassResponsibility</body><body package="Browser-ChangeObjects">adoptChangeObject	| changes |	changes := Refactory.Browser.CompositeRefactoryChange new.	changes addChange: (Refactory.Browser.RemoveOverrideChange for: self).	^changes</body><body package="Browser-ChangeObjects">undoMoveChangeObject	self subclassResponsibility</body></methods><methods><class-id>Kernel.NameSpaceImport</class-id> <category>testing</category><body package="Browser-ChangeObjects">isDrillDown	^drillDown</body><body package="Browser-ChangeObjects">isPrivate	^private</body></methods><methods><class-id>Kernel.OverridenNameSpace</class-id> <category>accessing</category><body package="Browser-ChangeObjects">addDefinitionChange	"These must always set the package"	^(Refactory.Browser.AddNameSpaceChange definition: self object definition)		package: (Store.Registry containingPackageForNameSpace: self object)</body><body package="Browser-ChangeObjects">adoptChangeObject	| changes |	changes := super adoptChangeObject.	changes addChange: (Refactory.Browser.MoveNameSpaceToPackageChange				nameSpace: self object				package: self package).	^changes</body><body package="Browser-ChangeObjects">undoMoveChangeObject	^(Refactory.Browser.MoveNameSpaceToPackageChange 		nameSpace: self object		package: (Store.Registry containingPackageForNameSpace: self object))</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>accessing</category><body package="Browser-ChangeObjects">addDefinitionChange	"These must always set the package"	^(Refactory.Browser.AddClassChange definition: self object definition)		package: (Store.Registry containingPackageForClass: self object)</body><body package="Browser-ChangeObjects">adoptChangeObject	| changes |	changes := super adoptChangeObject.	changes addChange: (Refactory.Browser.MoveClassDefinitionToPackageChange				class: self object				package: self package).	^changes</body><body package="Browser-ChangeObjects">undoMoveChangeObject	^(Refactory.Browser.MoveClassDefinitionToPackageChange 		class: self object		package: (Store.Registry containingPackageForClass: self object))</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>accessing</category><body package="Browser-ChangeObjects">addDefinitionChange	"These must always set the package"	^(Refactory.Browser.AddMethodChange 		compile: self object getSource		in: self implementingClass		classified: self protocol)			package: (Store.Registry containingPackageForSelector: self selector class: self implementingClass)</body><body package="Browser-ChangeObjects">adoptChangeObject	| changes |	changes := super adoptChangeObject.	changes addChange: (Refactory.Browser.MoveMethodToOverrideInPackageChange				class: self implementingClass				selector: self selector				package: self package).	^changes</body><body package="Browser-ChangeObjects">undoMoveChangeObject	| currentPackage |	^(Refactory.Browser.MoveMethodToOverrideInPackageChange 		class: self implementingClass		selector: self selector		package: (currentPackage := Store.Registry containingPackageForSelector: self selector class: self implementingClass))			oldPackageName: (sources detect: #isPackage ifNone: [currentPackage]) name.</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>accessing</category><body package="Browser-ChangeObjects">addDefinitionChange	"These must always set the package"	^(Refactory.Browser.AddSharedVariableChange definition: self bindingReference definition)		package: (Store.Registry containingPackageForDataKey: self key symbol: self owner absoluteSymbol)</body><body package="Browser-ChangeObjects">adoptChangeObject	| changes |	changes := super adoptChangeObject.	changes addChange: (Refactory.Browser.MoveSharedVariableToPackageChange				sharedVariableNamed: self fullName				package: self package).	^changes</body><body package="Browser-ChangeObjects">undoMoveChangeObject	| change |	change := Refactory.Browser.MoveSharedVariableToPackageChange 		sharedVariableNamed: self fullName		package: (Store.Registry containingPackageForDataKey: self key symbol: self owner absoluteSymbol).	^change</body></methods><initialize><class-id>Refactory.Browser.RefactoryChangeManager</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Override</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sources definition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>OverridenClass</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>comment documentation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>OverridenMethod</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector protocol instVarNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>NameSpaceImport</name><environment>Kernel</environment><super>Kernel.BindingReference</super><private>false</private><indexed-type>none</indexed-type><inst-vars>drillDown private </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>OverridenNameSpace</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment documentation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>OverridenStatic</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>method </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class></st-source>