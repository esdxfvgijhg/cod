<?xml version="1.0"?><st-source><!-- Name: UniqueObjectTableNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: This package implements a unique object table, which is similar to the SymbolTable except that this implementation is not specifically tailored for symbols.  Internally, the collection is structured as a weak hash bucketed set.  It cannot store the integer zero.  It does not support explicit removals.  Objects get removed from these tables when they are no longer referenced by the image via garbage collection.DbIdentifier: bear73DbTrace: 400869DbUsername: nrossDbVersion: 7.10 - 1PackageName: UniqueObjectTableParcel: #('UniqueObjectTable')PrintStringCache: (7.10 - 1,nross)Version: 7.10 - 1Date: 7:23:10 AM April 3, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (mar13.5) of April 3, 2013 on April 3, 2013 at 7:23:10 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>UniqueObjectTable</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mutex hashBucketTombstone policy </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>UniqueObjectTable</package></attributes></class><comment><class-id>Core.UniqueObjectTable</class-id><body>This class implements a unique object table, which is similar to the SymbolTable except that this class is not specifically tailored for symbols.  Internally, this collection is structured as a weak hash bucketed set.  It cannot store the integer zero.  It does not support explicit removals.  Objects get removed from these tables when they are no longer referenced by the image via garbage collection.Subclasses must implement the following messages:	private - internment		createUniqueObjectFor:	private - object collection		allStoredUniqueObjectClassesObject hashing and comparison can be specified by refining hashOf: and is:equivalentTo:.Instance Variables	hashBucketTombstone	&lt;Object&gt;	The cached answer to WeakArray&gt;&gt;tombstone	mutex	&lt;Semaphore&gt;	A mutual exclusion semaphore to ensure thread safety	policy &lt;UniqueObjectTablePolict&gt;	The performance policy that controls the management of hash buckets</body></comment><class><name>UniqueObjectTablePolicy</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>hashBucketGrowthIncrement hashBucketStorageMargin initialHashBucketSize targetObjectsPerHashBucket </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>UniqueObjectTable</package></attributes></class><comment><class-id>Core.UniqueObjectTablePolicy</class-id><body>Instances of UniqueObjectTablePolicy provide performance configuration capabilities to instances of UniqueObjectTable.Instance Variables	hashBucketGrowthIncrement	&lt;Integer&gt;	The number of slots to add to a hash bucket when it needs to grow	hashBucketStorageMargin	&lt;Integer&gt;	The number of slots to initially pad new hash buckets with past the number of target objects per hash bucket	targetObjectsPerHashBucket	&lt;Integer&gt;	The target number of objects per hash bucket.  This amount is used when rehashing to choose the number of hash buckets to create	initialHashBucketSize	&lt;Integer&gt;	The initial number of slots each hash bucket has upon creation.</body></comment><methods><class-id>Core.UniqueObjectTable</class-id> <category>private - policies</category><body package="UniqueObjectTable">compactPolicy	"Set the performance configuration so that memory	conservation is given higher priority than performance"	^UniqueObjectTablePolicy new		hashBucketGrowthIncrement: 1;		hashBucketStorageMargin: 0;		targetObjectsPerHashBucket: 10;		initialHashBucketSize: 0;		yourself</body><body package="UniqueObjectTable">defaultPolicy	"Set the performance configuration so that memory	requirements and performance are balanced"	^UniqueObjectTablePolicy new		hashBucketGrowthIncrement: 1;		hashBucketStorageMargin: 2;		targetObjectsPerHashBucket: 10;		initialHashBucketSize: 12;		yourself</body><body package="UniqueObjectTable">fastPolicy	"Answer the performance configuration so that performance	is given higher priority than memory conservation"	^UniqueObjectTablePolicy new		hashBucketGrowthIncrement: 5;		hashBucketStorageMargin: 5;		targetObjectsPerHashBucket: 5;		initialHashBucketSize: 10;		yourself</body></methods><methods><class-id>Core.UniqueObjectTable</class-id> <category>private - rehashing</category><body package="UniqueObjectTable">newUniqueObjectTableOfClass: aClass	^self		newUniqueObjectTableOfClass: aClass		andSize: self suggestedHashBuckets</body><body package="UniqueObjectTable">newUniqueObjectTableOfClass: aClass andSize: anInteger	^aClass		newBasicInstanceOfSize: anInteger		withPolicy: self policy copy</body><body package="UniqueObjectTable">quickRehashIntoUniqueObjectTableOfClass: aClass	self critical:		[			| newHashTable |			newHashTable := self newUniqueObjectTableOfClass: aClass.			self allUniqueObjectsDo: [:each | newHashTable rememberUniqueObject: each].			self become: newHashTable		]</body><body package="UniqueObjectTable">rehashIntoUniqueObjectTableOfClass: aClass	self critical:		[			| newHashTable allExistingUniqueObjectsPerClass allExistingUniqueObjectCount suggestedNewHashBuckets |			ObjectMemory globalGarbageCollect.			allExistingUniqueObjectsPerClass := self allExistingUniqueObjectsPerClass.			allExistingUniqueObjectCount := allExistingUniqueObjectsPerClass				inject: 0				into: [:total :eachBucket | total + eachBucket size].			suggestedNewHashBuckets := self suggestedHashBucketsForNumberOfUniqueObjects: allExistingUniqueObjectCount.			newHashTable := self newUniqueObjectTableOfClass: aClass andSize: suggestedNewHashBuckets.			allExistingUniqueObjectsPerClass do:				[:eachBucket |					eachBucket do: [:each | newHashTable rememberUniqueObject: each]				].			self become: newHashTable		]</body></methods><methods><class-id>Core.UniqueObjectTable</class-id> <category>private - accessing</category><body package="UniqueObjectTable">hashBucketTombstone	^hashBucketTombstone</body><body package="UniqueObjectTable">hashBucketTombstone: anObject	hashBucketTombstone := anObject</body><body package="UniqueObjectTable">mutex	^mutex</body><body package="UniqueObjectTable">mutex: aSemaphore	mutex := aSemaphore</body><body package="UniqueObjectTable">policy	^policy</body><body package="UniqueObjectTable">policy: anObject	policy := anObject</body></methods><methods><class-id>Core.UniqueObjectTable</class-id> <category>private - hash buckets - creation</category><body package="UniqueObjectTable">newHashBucket	"Keep the average number of probes for a lookup constant,	regardless of the number of symbols."	^self newHashBucketOfSize: self initialHashBucketSize</body><body package="UniqueObjectTable">newHashBucketOfSize: anInteger	| answer |	answer := WeakArray new: anInteger.	answer atAllPut: 0.	^answer</body><body package="UniqueObjectTable">obtainHashBucketTombstone	^self newHashBucket tombstone</body></methods><methods><class-id>Core.UniqueObjectTable</class-id> <category>private - performance</category><body package="UniqueObjectTable">hashBucketGrowthIncrement	^self policy hashBucketGrowthIncrement</body><body package="UniqueObjectTable">hashBucketStorageMargin	^self policy hashBucketStorageMargin</body><body package="UniqueObjectTable">initialHashBucketSize	^self policy initialHashBucketSize</body><body package="UniqueObjectTable">suggestedHashBuckets	^self suggestedHashBucketsForNumberOfUniqueObjects: self numberOfRememberedUniqueObjects</body><body package="UniqueObjectTable">suggestedHashBucketsForNumberOfUniqueObjects: anInteger	^Set goodSizeFrom: anInteger // self targetObjectsPerHashBucket + 1</body><body package="UniqueObjectTable">targetHashBucketSize	^self policy targetHashBucketSize</body><body package="UniqueObjectTable">targetObjectsPerHashBucket	^self policy targetObjectsPerHashBucket</body></methods><methods><class-id>Core.UniqueObjectTable</class-id> <category>private - internment</category><body package="UniqueObjectTable">createUniqueObjectFor: anObject	self subclassResponsibility</body><body package="UniqueObjectTable">privateUniqueObjectFor: anObject withHashValue: hashValue	"A second lookup is needed in case the process evaluating	this code is interrupted between the first lookup and the	beginning of the critical block.  If the second lookup is not	attempted, then a unique object could be interned twice."	^self critical:		[			| answer |			answer := self existingUniqueObjectFor: anObject withHashValue: hashValue.			answer isNil ifTrue:				[					answer := self createUniqueObjectFor: anObject.					self rememberUniqueObject: answer withHashValue: hashValue				].			answer		]</body><body package="UniqueObjectTable">rememberUniqueObject: anObject	self		rememberUniqueObject: anObject		withHashValue: (self hashOf: anObject)</body><body package="UniqueObjectTable">rememberUniqueObject: anObject withHashValue: hashValue	| hashBucketIndex hashBucket hashBucketSize storageIndex newHashBucket |	hashBucketIndex := self hashBucketIndexForHashValue: hashValue.	hashBucket := self at: hashBucketIndex.	hashBucketSize := hashBucket size.	storageIndex := hashBucket		indexOf: self hashBucketTombstone		replaceWith: anObject		startingAt: 1		stoppingAt: hashBucketSize.	storageIndex &gt; 0 ifTrue: [^self].	newHashBucket := self newHashBucketOfSize: hashBucketSize + self hashBucketGrowthIncrement.	newHashBucket		replaceFrom: 1		to: hashBucketSize		with: hashBucket.	newHashBucket at: hashBucketSize + 1 put: anObject.	self at: hashBucketIndex put: newHashBucket</body></methods><methods><class-id>Core.UniqueObjectTable</class-id> <category>private</category><body package="UniqueObjectTable">critical: aBlock	^self mutex critical: aBlock</body><body package="UniqueObjectTable">initializationPolicy	^self defaultPolicy</body><body package="UniqueObjectTable">initialize	self initializeWithPolicy: self initializationPolicy</body><body package="UniqueObjectTable">initializeWithPolicy: aPolicy	super initialize.	self policy: aPolicy.	self mutex: Semaphore forMutualExclusion.	self hashBucketTombstone: self obtainHashBucketTombstone.	1 to: self size do: [:each | self at: each put: self newHashBucket]</body></methods><methods><class-id>Core.UniqueObjectTable</class-id> <category>public - accessing</category><body package="UniqueObjectTable">existingUniqueObjectFor: anObject	"Do not create a unique object if none is available"	| hashBucket |	hashBucket := self hashBucketFor: anObject.	^hashBucket		detect: [:one | one = anObject]		ifNone: [nil]</body><body package="UniqueObjectTable">uniqueObjectFor: anObject	"Create unique objects as needed"	| firstLookup hashValue |	hashValue := self hashOf: anObject.	firstLookup := self existingUniqueObjectFor: anObject withHashValue: hashValue.	firstLookup notNil ifTrue: [^firstLookup].	^self privateUniqueObjectFor: anObject withHashValue: hashValue</body></methods><methods><class-id>Core.UniqueObjectTable</class-id> <category>private - hash buckets</category><body package="UniqueObjectTable">allHashBucketsDo: aBlock	1 to: self size do:		[:eachIndex |			| hashBucket |			hashBucket := self at: eachIndex.			aBlock value: hashBucket		]</body><body package="UniqueObjectTable">hashBucketFor: aCharacterArray	| index |	index := self hashBucketIndexFor: aCharacterArray.	^self at: index</body><body package="UniqueObjectTable">hashBucketForHashValue: aHashValue	| index |	index := self hashBucketIndexForHashValue: aHashValue.	^self at: index</body><body package="UniqueObjectTable">hashBucketIndexFor: aCharacterArray	^self hashBucketIndexForHashValue: (self hashOf: aCharacterArray)</body><body package="UniqueObjectTable">hashBucketIndexForHashValue: aHashValue	^aHashValue \\ self size + 1</body></methods><methods><class-id>Core.UniqueObjectTable</class-id> <category>private - object collection</category><body package="UniqueObjectTable">allExistingUniqueObjectsPerClass	^self allStoredUniqueObjectClasses collect: [:each | each allInstances]</body><body package="UniqueObjectTable">allStoredUniqueObjectClasses	self subclassResponsibility</body></methods><methods><class-id>Core.UniqueObjectTable</class-id> <category>public - management</category><body package="UniqueObjectTable">availableStorageSlots	| answer |	answer := 0.	self allHashBucketsDo:		[:eachHashBucket |			answer := answer + eachHashBucket size		].	^answer</body><body package="UniqueObjectTable">normalizedHashBucketSizeChiSquared	"Answer a number representing the effectiveness of the hash buckets	in terms of deviation from the expected average hash bucket size.  The	ideal value is zero.  The greater the value, the higher the benefit to be	obtained from rehashing the symbol table.  For this to be meaningful,	the hash function for stored objects should be of high quality.  If	rehashing the unique object table does not reduce this value to almost	zero, then it could be an indication of low quality stored object hashing.	It is suggested that unique object tables be rehashed if the answer to	this message becomes larger than about 1"	| expectedAverage answer |	answer := 0.0d.	expectedAverage := self availableStorageSlots asDouble / self size.	expectedAverage := expectedAverage max: self targetHashBucketSize asDouble.	self allHashBucketsDo:		[:eachHashBucket |			| eachDeviation |			eachDeviation := eachHashBucket size - expectedAverage.			eachDeviation abs &gt; 1.0d ifTrue: [answer := eachDeviation squared + answer]		].	^answer / self size</body><body package="UniqueObjectTable">numberOfRememberedUniqueObjects	| answer |	answer := 0.	self allUniqueObjectsDo: [:each | answer := answer + 1].	^answer</body></methods><methods><class-id>Core.UniqueObjectTable</class-id> <category>public - performance - presets</category><body package="UniqueObjectTable">setCompactPolicy	"Set the performance configuration so that memory	conservation is given higher priority than performance.	Rehash the receiver for this to take effect"	self policy: self compactPolicy</body><body package="UniqueObjectTable">setDefaultPolicy	"Set the performance configuration so that memory	requirements and performance are balanced.	Rehash the receiver for this to take effect"	self policy: self defaultPolicy</body><body package="UniqueObjectTable">setFastPolicy	"Set the performance configuration so that performance	is given higher priority than memory conservation.	Rehash the receiver for this to take effect"	self policy: self fastPolicy</body></methods><methods><class-id>Core.UniqueObjectTable</class-id> <category>private - comparing</category><body package="UniqueObjectTable">hashOf: anObject	^anObject hash</body><body package="UniqueObjectTable">is: anObject equivalentTo: anotherObject	^anObject = anotherObject</body></methods><methods><class-id>Core.UniqueObjectTable</class-id> <category>public - enumerating</category><body package="UniqueObjectTable">allUniqueObjectsDo: aBlock	| tombstone |	tombstone := self hashBucketTombstone.	self allHashBucketsDo:		[:eachHashBucket |			eachHashBucket do:				[:eachValue |					tombstone == eachValue ifFalse:						[aBlock value: eachValue]				]		]</body><body package="UniqueObjectTable">quickRehash	self quickRehashIntoUniqueObjectTableOfClass: self class</body><body package="UniqueObjectTable">rehash	self rehashIntoUniqueObjectTableOfClass: self class</body></methods><methods><class-id>Core.UniqueObjectTable</class-id> <category>public - testing</category><body package="UniqueObjectTable">hasExistingUniqueObjectFor: anObject	| correspondingUniqueObject |	correspondingUniqueObject := self existingUniqueObjectFor: anObject.	^correspondingUniqueObject notNil</body></methods><methods><class-id>Core.UniqueObjectTable</class-id> <category>private - testing</category><body package="UniqueObjectTable">existingUniqueObjectFor: anObject withHashValue: hashValue	"Do not create a unique object if none is available"	| hashBucket |	hashBucket := self hashBucketForHashValue: hashValue.	^hashBucket		detect:			[:aUniqueObject |				aUniqueObject ~~ self hashBucketTombstone					and: [self is: anObject equivalentTo: aUniqueObject]			]		ifNone: [nil]</body></methods><methods><class-id>Core.UniqueObjectTable class</class-id> <category>private - instance creation</category><body package="UniqueObjectTable">newBasicInstance	^self newBasicInstanceOfSize: 128</body><body package="UniqueObjectTable">newBasicInstanceOfSize: anInteger	| answer |	answer := super new: anInteger.	answer initialize.	^answer</body><body package="UniqueObjectTable">newBasicInstanceOfSize: anIntegerwithPolicy: aPolicy	| answer |	answer := super new: anInteger.	answer initializeWithPolicy: aPolicy.	^answer</body><body package="UniqueObjectTable">release	"Be extremely careful when sending this message"	self current: nil</body></methods><methods><class-id>Core.UniqueObjectTable class</class-id> <category>instance creation</category><body package="UniqueObjectTable">new	self current notNil ifTrue: [^self current].	self current: self newBasicInstance.	^self current</body><body package="UniqueObjectTable">new: anInteger	self shouldNotImplement</body><body package="UniqueObjectTable">quickRehash	self new quickRehash</body><body package="UniqueObjectTable">rehash	self new rehash</body></methods><methods><class-id>Core.UniqueObjectTable class</class-id> <category>private - accessing</category><body package="UniqueObjectTable">current	^current</body><body package="UniqueObjectTable">current: anInstance	"Be extremely careful when sending this message"	current := anInstance</body></methods><methods><class-id>Core.UniqueObjectTablePolicy</class-id> <category>accessing - parameters</category><body package="UniqueObjectTable">hashBucketGrowthIncrement	^hashBucketGrowthIncrement</body><body package="UniqueObjectTable">hashBucketGrowthIncrement: anInteger	hashBucketGrowthIncrement := anInteger</body><body package="UniqueObjectTable">hashBucketStorageMargin	^hashBucketStorageMargin</body><body package="UniqueObjectTable">hashBucketStorageMargin: anInteger	hashBucketStorageMargin := anInteger</body><body package="UniqueObjectTable">initialHashBucketSize	^initialHashBucketSize</body><body package="UniqueObjectTable">initialHashBucketSize: anInteger	initialHashBucketSize := anInteger</body><body package="UniqueObjectTable">targetObjectsPerHashBucket	^targetObjectsPerHashBucket</body><body package="UniqueObjectTable">targetObjectsPerHashBucket: anInteger	targetObjectsPerHashBucket := anInteger</body></methods><methods><class-id>Core.UniqueObjectTablePolicy</class-id> <category>private</category><body package="UniqueObjectTable">initialize	"Use default values"	self hashBucketGrowthIncrement: 1.	self hashBucketStorageMargin: 2.	self targetObjectsPerHashBucket: 10.	self initialHashBucketSize: self targetHashBucketSize</body></methods><methods><class-id>Core.UniqueObjectTablePolicy</class-id> <category>accessing</category><body package="UniqueObjectTable">targetHashBucketSize	^self targetObjectsPerHashBucket + self hashBucketStorageMargin</body></methods><methods><class-id>Core.UniqueObjectTablePolicy</class-id> <category>printing</category><body package="UniqueObjectTable">printOn: aStream	aStream		nextPutAll: self class name;		nextPutAll: '[t: ';		print: self targetObjectsPerHashBucket;		nextPutAll: ', m: ';		print: self hashBucketStorageMargin;		nextPutAll: ', g: ';		print: self hashBucketGrowthIncrement;		nextPutAll: ', i: ';		print: self initialHashBucketSize;		nextPut: $]</body></methods><methods><class-id>Core.UniqueObjectTablePolicy class</class-id> <category>instance creation</category><body package="UniqueObjectTable">new	^super new initialize</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>