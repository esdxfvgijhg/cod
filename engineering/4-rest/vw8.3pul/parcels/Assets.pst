<?xml version="1.0"?><st-source><!-- Name: AssetsNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: Assets are libraries of resources for an application, things such as Images, Masked Images (OpaqueImages), Strings, Bytes, etc. Said libraries support a framework for deriving these objects from external files found in a directory associated with the object and keeping them up to date. They also provide caching of computed assets so that access is fast as possible.The intent is that an application creates a subclass of Assets and then adds class side methods to retrieve different "assets". Usually, these methods are annotated with method tags which indicate resource files which may be imported and integrated as smalltalk code.A runtime application only needs this package as a prerequisite. Developers can use the package Assets-IDE to develop Asset libraries and keep them up date.PackageName: AssetsParcel: #('Assets')ParcelName: AssetsVersion: 7.10 - 1Date: 12:05:13 PM July 28, 2017 --><time-stamp>From VisualWorksÂ®, 8.3 of July 28, 2017 on July 28, 2017 at 12:05:13 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>Assets</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>lastDirectory </class-inst-vars><imports></imports><category>Assets</category><attributes><package>Assets</package></attributes></class><comment><class-id>Core.Assets</class-id><body>I (and subclasses) am a library of of assets (images, icons, strings, etc), to be used by an application. My methods which return Smallalk objects, can be tagged to specify a file "links" external files in as Smalltalk objects during development time. The method used to turn the file contents into a Smalltalk object is a negotiation between the file's type (extension) and methods provided by the receiver.Implementation Details:Asset classes are singletons. There is never a need to create instances of them. Assets are retrieved by simply sending the name of the asset to the them.A preliminary asset method might look like this:myIcon	&lt;file: 'somePath.png'&gt;After it has been "integrated, it would look something like:myIcon	&lt;file: 'somePath.png'&gt;	&lt;md5sum: #[1 2 3 4 5 6 7 8]&gt;	^[CachedImage on: (Image extent: 2@2 depth: 1 bitsPerPixel: 1 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[0 0 0 0 0 0 0 0])] onceThe following is an explanation of the various parts:- File Specifier: (&lt;file: 'somePath.png'&gt;)The first tag is used to link the method with an external resource. The external resource is specified by the argument which is path to a file. The method that is used to "integrate" the external source file into a reproducible Smalltak object, is determined by the file's extension type. In this case, 'png'. Each import type needs to have a method called import_&lt;extension&gt;: if it is to integrate that file type. For example, the one used in this case is import_png: By default, there is support for gif, jpeg, jpg, bmp, and png. You can add to this set or override them, in either your own subclass or by extending the base Assets class.- Remembered Hash: (&lt;md5sum: #[1 2 3 4 5 6 7 8]&gt;)The second tag (i.e. md5sum:) shows up after we have "integrated" the external file with the method. It is a snapshot of the md5sum of the external file at the time of integration. It can then be used to determine at future points which assets need to be reintegrated because the hash of their external files no longer matches that of the method.- Once Block: (^[....] once)Though the return value of an asset method is an object generated by importing from an external resouce file, it is considered a must that after that fact, the method be able to reproduce the object without the resource file. This is necessary because applications shouldn't require big directories full of files. Applications must be able to be loaded from Store or Parcel without external file references.The code to recreate the object goes in the block. The message once is special. It is like value, in that returns the value of the block. But the value returned is that as rememebered from the first time the block was sent this message. For example, if the contents of the block were to create a new OpaqueImage of moderate size, each time we asked for this asset, performance would be dismal. It would a waste of both cpu cycles and memory. This technique is more than 100 times faster than the former 'ListIconLibrary visualFor: aSymbol' technique.</body></comment><class><name>CachedBlockClosure</name><environment>Kernel</environment><super>Kernel.BlockClosure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cachedValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Assets</category><attributes><package>Assets</package></attributes></class><comment><class-id>Kernel.CachedBlockClosure</class-id><body>I'm a BlockClosure with an added instance variable for storing the once upon a time result of evaluating myself when I was simple BlockClosure. This is triggered by sending #once to a normal BlockClosure. Future sends of once will simply return this value rather than evaluate myself. When sent value, I revert back to a BlockClosure. Instance Variables:	cachedValue	&lt;Object &gt;	result of having sent value to myself when i was just a BlockClosure</body></comment><methods><class-id>Core.Assets class</class-id> <category>sidewards compatibility</category><body package="Assets">visualFor: aSelector	"Allow the receiver to be used by legacy VisualWorks frameworks including ResourceRetriever."		^self perform: aSelector</body></methods><methods><class-id>Kernel.CachedBlockClosure</class-id> <category>private</category><body package="Assets">becomeCached	"I am already"</body><body package="Assets">becomeUncached	"convert myself back to my uncaching superclass"	| withoutCache |	withoutCache := ((self copy changeClassTo: Array) allButLast: 1) 				changeClassTo: BlockClosure.	self become: withoutCache</body><body package="Assets">privateOnce	^cachedValue</body></methods><methods><class-id>Kernel.CachedBlockClosure</class-id> <category>evaluating</category><body package="Assets">value	"uncache myself and resend"	self becomeUncached.	^self value</body></methods><methods><class-id>Kernel.CachedBlockClosure</class-id> <category>tracing</category><body package="Assets">traceFrom: aTracer	"We need to revert back to original block form when parcelling. Our cached value could be any number of non-traceable things."		self becomeUncached.	self traceFrom: aTracer</body></methods><methods><class-id>Kernel.CachedBlockClosure class</class-id> <category>utility</category><body package="Assets">uncacheAll	self allInstances do: [:each | each becomeUncached]</body></methods><methods><class-id>Kernel.CachedBlockClosure class</class-id> <category>initialize-release</category><body package="Assets">obsolete	"Removal of this from the system, should revert all blocks that may be cached back to normal 'every-time' blocks."	self uncacheAll.	super obsolete</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>private</category><body package="Assets">becomeUncached	"do nothing"</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>accessing</category><body package="Assets">once	^self privateOnce</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>private</category><body package="Assets">privateOnce	self becomeCached.	^self once</body></methods><methods><class-id>Core.ByteArray class</class-id> <category>instance creation</category><body package="Assets">fromNibbleString: aString	"Same thing as fromHexString:, but that was taken already."		| map index stop result writeIndex |	result := ByteArray new: aString size // 2.	map := #(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 0 1 2 3 4 5 6 7 8 9 nil nil nil nil nil nil nil 10 11 12 13 14 15 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 10 11 12 13 14 15).	index := 1.	stop := aString size.	writeIndex := 0.	[index &lt;= stop]		whileTrue:			[| char |			char := aString at: index.			char isSeparator				ifTrue: [index := index + 1]				ifFalse:					[writeIndex := writeIndex + 1.					result						at: writeIndex						put:							((map at: char codePoint) bitShift: 4)								+ (map at: (aString at: index + 1) codePoint).					index := index + 2]].	^result size = writeIndex		ifTrue: [result]		ifFalse: [result copyFrom: 1 to: writeIndex]</body></methods><methods><class-id>Core.ByteArray</class-id> <category>printing</category><body package="Assets">printNibblesOn: aStream 	"Print hexadecimal nibble values on aStream."	"| ws |	ws := String new writeStream.	#[16r89 16r0F] printNibblesOn: ws.	ws contents"	| chars |	chars := '0123456789ABCDEF'.	self do: 			[:each | 			aStream				nextPut: (chars at: (each bitShift: -4) + 1);				nextPut: (chars at: (each bitAnd: 16rF) + 1)]</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>private</category><body package="Assets">becomeCached	"convert myself to my caching subclass with the result of my value loaded in the cache"	| withCache |	withCache := ((self copy changeClassTo: Array) copyWith: self value) 				changeClassTo: CachedBlockClosure.	self become: withCache</body></methods><methods><class-id>Core.Assets class</class-id> <category>private-support</category><body package="Assets">housekeepingTags	&lt;pragmas: #class&gt;	^#(#md5sum: #file:)</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class></st-source>