<?xml version="1.0"?><st-source><!-- Name: Debugger-Browser ExtensionsNotice: Copyright 2003-2017 Cincom Systems, Inc.  All rights reserved.Comment: PDP RB extensions for VW 7.DbIdentifier: bear73DbTrace: 501592DbUsername: smichaelDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'Debugger-UI' '') #(#any 'Browser-RefactoringUI' ''))Fragments: Dictionary ()PackageName: Debugger-Browser ExtensionsParcel: #('Debugger-Browser Extensions')ParcelName: Debugger-Browser ExtensionsPrerequisiteParcels: #(#('Debugger-UI' '') #('Browser-RefactoringUI' ''))PrintStringCache: (8.3 - 1,smichael)Version: 8.3 - 1Post-Load Block: 	[:package | ]Date: 3:26:59 PM June 30, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (jun17.4) of June 23, 2017 on June 30, 2017 at 3:26:59 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DocumentBreakpoint</name><environment>Refactory.Browser</environment><super>Text2.DocumentMarkupOpen</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Debugger-Browser Extensions</package></attributes></class><comment><class-id>Refactory.Browser.DocumentBreakpoint</class-id><body>DocumentBreakpoint represents a segment in a document that contains a breakpoint. The breakpoint can represent a disabled, once-only or infinite breakpoint. The contents between these two segments is interpreted as the conditional breakpoint source.Instance Variables	mode	&lt;Symbol&gt;			#disabled, #once or #infinite</body></comment><class><name>DocumentVariableWatch</name><environment>Refactory.Browser</environment><super>Text2.DocumentMarkupOpen</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Debugger-Browser Extensions</package></attributes></class><comment><class-id>Refactory.Browser.DocumentVariableWatch</class-id><body>DocumentVariableWatch represents a segment in a document that contains a watch for a variable in the context of execution. The contents inside the markup pair is the variable name to watch.</body></comment><class><name>DocumentActionWatch</name><environment>Refactory.Browser</environment><super>Text2.DocumentMarkupOpen</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Debugger-Browser Extensions</package></attributes></class><comment><class-id>Refactory.Browser.DocumentActionWatch</class-id><body>DocumentActionWatch represents a segment in a document that contains a watch expression. The contents inside the markup pair represent the action to perform, which should write out to a variable called 'log' which is a WriteStream.</body></comment><class><name>FlowBreakpoint</name><environment>Refactory.Browser</environment><super>Text2.FlowMarkupOpen</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Debugger-Browser Extensions</package></attributes></class><comment><class-id>Refactory.Browser.FlowBreakpoint</class-id><body>FlowBreakpoint represents a DocumentBreakpoint on a line. It reacts to clicks to change the DocumentBreakpoint mode.</body></comment><methods><class-id>Refactory.Browser.DocumentBreakpoint</class-id> <category>accessing</category><body package="Debugger-Browser Extensions">description	^(self perform: self mode), ' ['</body><body package="Debugger-Browser Extensions">mode	^mode</body><body package="Debugger-Browser Extensions">styleTag	self mode = #disabled ifTrue: [^#(markup breakpoint disabled)].	#{CraftedSmalltalk.PDPManager} ifDefinedDo: [:managerClass |		managerClass debugActive ifFalse: [^#(markup breakpoint disabled)]].	^#(markup breakpoint)</body></methods><methods><class-id>Refactory.Browser.DocumentBreakpoint</class-id> <category>initialize-release</category><body package="Debugger-Browser Extensions">initialize: aMode	mode := aMode</body><body package="Debugger-Browser Extensions">initialize: aMode style: aDocumentStyle	style := Text2.DocumentStyle intern: aDocumentStyle.	mode := aMode</body></methods><methods><class-id>Refactory.Browser.DocumentBreakpoint</class-id> <category>copying</category><body package="Debugger-Browser Extensions">copyNextMode	| newMode |	mode = #once ifTrue: [newMode := #infinite].	mode = #infinite ifTrue: [newMode := #disabled].	mode = #disabled ifTrue: [newMode := #once].	^self class forMode: newMode style: style</body></methods><methods><class-id>Refactory.Browser.DocumentBreakpoint</class-id> <category>printing</category><body package="Debugger-Browser Extensions">printOn: aStream	aStream nextPutAll: '[breakpoint]'</body></methods><methods><class-id>Refactory.Browser.DocumentBreakpoint</class-id> <category>actions</category><body package="Debugger-Browser Extensions">censor: aSourceCodeProbe in: aDocument	| empty |	empty := String new: aSourceCodeProbe size - 1 withAll: Character space.	aDocument replaceBetween: aSourceCodeProbe first and: aSourceCodeProbe last with: empty</body><body package="Debugger-Browser Extensions">create: aSourceCodeProbe in: aDocument record: aProbeRecord	| testSource probeClass probe |	testSource := (aDocument copyBetween: aSourceCodeProbe first + 1 and: aSourceCodeProbe last - 1) asString.	testSource isEmpty ifTrue: [testSource := CodeProbe trueString].	probeClass := self mode = #infinite ifTrue: [CodeProbe] ifFalse: [OneshotProbe].	probe := probeClass new		record: aProbeRecord;		testMethodAndSource: nil -&gt; testSource;		yourself.	self mode = #disabled ifTrue: [probe disarm].	^probe</body><body package="Debugger-Browser Extensions">removalSize: aSourceCodeProbe	^aSourceCodeProbe size - 1</body><body package="Debugger-Browser Extensions">remove: aSourceCodeProbe in: aDocument	aDocument replaceBetween: aSourceCodeProbe first and: aSourceCodeProbe last with: ''.	^self removalSize: aSourceCodeProbe</body></methods><methods><class-id>Refactory.Browser.DocumentBreakpoint</class-id> <category>private</category><body package="Debugger-Browser Extensions">disabled	^'0'</body><body package="Debugger-Browser Extensions">infinite	OSSystemSupport concreteClass == UnixSystemSupport ifTrue: [^'inf'].	^String with: 16r221E asCharacter</body><body package="Debugger-Browser Extensions">once	^'1'</body></methods><methods><class-id>Refactory.Browser.DocumentBreakpoint class</class-id> <category>instance creation</category><body package="Debugger-Browser Extensions">forMode: aMode	"Return a new DocumentImage for anImage with aDocumentStyle styling."	^self new initialize: aMode</body><body package="Debugger-Browser Extensions">forMode: aMode style: aDocumentStyle	"Return a new DocumentImage for anImage with aDocumentStyle styling."	^self new initialize: aMode style: aDocumentStyle</body></methods><methods><class-id>Refactory.Browser.DocumentBreakpoint class</class-id> <category>accessing</category><body package="Debugger-Browser Extensions">breakpointDocumentForMode: aBreakpointMode condition: aTestSource	| segments testSource |	testSource := aTestSource = CodeProbe trueString ifTrue: [''] ifFalse: [aTestSource].	segments := OrderedCollection with: (Refactory.Browser.DocumentBreakpoint forMode: aBreakpointMode).	aTestSource isEmpty ifFalse: [segments add: (Text2.DocumentSpan fromString: testSource)].	segments add: Text2.DocumentMarkupClose new.	^Text2.Document fromSegments: segments</body></methods><methods><class-id>Refactory.Browser.DocumentVariableWatch</class-id> <category>actions</category><body package="Debugger-Browser Extensions">censor: aSourceCodeProbe in: aDocument	aDocument replaceBetween: aSourceCodeProbe last - 1 and: aSourceCodeProbe last with: ' '.	aDocument replaceBetween: aSourceCodeProbe first and: aSourceCodeProbe first + 1 with: ' '</body><body package="Debugger-Browser Extensions">create: aSourceCodeProbe in: aDocument record: aProbeRecord	| testSource |	testSource := (aDocument copyBetween: aSourceCodeProbe first + 1 and: aSourceCodeProbe last - 1) asString.	testSource isEmpty ifTrue: [self error: 'invalid variable watch, no variable between markup nodes'].	^WatchVariableProbe new		record: aProbeRecord;		testMethodAndSource: nil -&gt; testSource;		yourself</body><body package="Debugger-Browser Extensions">removalSize: aSourceCodeProbe	^2</body><body package="Debugger-Browser Extensions">remove: aSourceCodeProbe in: aDocument	aDocument replaceBetween: aSourceCodeProbe last - 1 and: aSourceCodeProbe last with: ''.	aDocument replaceBetween: aSourceCodeProbe first and: aSourceCodeProbe first + 1 with: ''.	^self removalSize: aSourceCodeProbe</body></methods><methods><class-id>Refactory.Browser.DocumentVariableWatch</class-id> <category>accessing</category><body package="Debugger-Browser Extensions">description	OSSystemSupport concreteClass == UnixSystemSupport ifTrue: [^'{watch}'].	^'∂ '</body><body package="Debugger-Browser Extensions">styleTag	^#(markup watch)</body></methods><methods><class-id>Refactory.Browser.DocumentVariableWatch class</class-id> <category>accessing</category><body package="Debugger-Browser Extensions">variableWatchDocumentFor: aVariableName	| segments |	segments := OrderedCollection with: Refactory.Browser.DocumentVariableWatch new.	aVariableName isEmpty ifFalse: [segments add: (Text2.DocumentSpan fromString: aVariableName)].	segments add: (Text2.DocumentMarkupClose description: '').	^Text2.Document fromSegments: segments</body></methods><methods><class-id>Refactory.Browser.DocumentActionWatch</class-id> <category>accessing</category><body package="Debugger-Browser Extensions">description	OSSystemSupport concreteClass == UnixSystemSupport ifTrue: [^'{watch} [:log | '].	^'∂ [:log│'</body><body package="Debugger-Browser Extensions">styleTag	^#(markup watch)</body></methods><methods><class-id>Refactory.Browser.DocumentActionWatch</class-id> <category>printing</category><body package="Debugger-Browser Extensions">printOn: aStream	aStream nextPutAll: '[breakpoint]'</body></methods><methods><class-id>Refactory.Browser.DocumentActionWatch</class-id> <category>actions</category><body package="Debugger-Browser Extensions">censor: aSourceCodeProbe in: aDocument	| empty |	empty := String new: aSourceCodeProbe size - 1 withAll: Character space.	aDocument replaceBetween: aSourceCodeProbe first and: aSourceCodeProbe last with: empty</body><body package="Debugger-Browser Extensions">create: aSourceCodeProbe in: aDocument record: aProbeRecord	| testSource |	testSource := (aDocument copyBetween: aSourceCodeProbe first + 1 and: aSourceCodeProbe last - 1) asString.	^WatchActionProbe new		record: aProbeRecord;		testMethodAndSource: nil -&gt; testSource;		yourself</body><body package="Debugger-Browser Extensions">removalSize: aSourceCodeProbe	^aSourceCodeProbe size - 1</body><body package="Debugger-Browser Extensions">remove: aSourceCodeProbe in: aDocument	aDocument replaceBetween: aSourceCodeProbe first and: aSourceCodeProbe last with: ''.	^self removalSize: aSourceCodeProbe</body></methods><methods><class-id>Refactory.Browser.DocumentActionWatch class</class-id> <category>accessing</category><body package="Debugger-Browser Extensions">actionWatchDocumentFor: aTestSource	| segments |	segments := OrderedCollection with: Refactory.Browser.DocumentActionWatch new.	aTestSource isEmpty ifFalse: [segments add: (Text2.DocumentSpan fromString: aTestSource)].	segments add: Text2.DocumentMarkupClose new.	^Text2.Document fromSegments: segments</body></methods><methods><class-id>Refactory.Browser.FlowBreakpoint</class-id> <category>accessing</category><body package="Debugger-Browser Extensions">action	"Return the action for this segment"	^self</body><body package="Debugger-Browser Extensions">cursor	"Return the mouse cursor for this segment"	^UI.Cursor fingerPointer</body><body package="Debugger-Browser Extensions">mode	^segment mode</body></methods><methods><class-id>Refactory.Browser.FlowBreakpoint</class-id> <category>private</category><body package="Debugger-Browser Extensions">applyView: aSourceCodeEditor segment: aFlowSegment	aSourceCodeEditor invalidateSelectionWhile: [		aSourceCodeEditor flow			replaceBetween: self start			and: self stop			with: segment copyNextMode asDocument].	aSourceCodeEditor triggerProbesChanged</body></methods><methods><class-id>Refactory.Browser.FlowBreakpoint</class-id> <category>printing</category><body package="Debugger-Browser Extensions">debugString	^'[breakpoint]'</body></methods><methods><class-id>Refactory.Browser.FlowBreakpoint</class-id> <category>testing</category><body package="Debugger-Browser Extensions">isSimilarTo: aFlowSegment	^(super isSimilarTo: aFlowSegment) and: [self mode = aFlowSegment mode]</body></methods><methods><class-id>Refactory.Browser.FlowBreakpoint class</class-id> <category>accessing</category><body package="Debugger-Browser Extensions">documentSegmentClass	^DocumentBreakpoint</body></methods><methods><class-id>Refactory.Browser.RemoveMethodChange</class-id> <category>accessing</category><body package="Debugger-Browser Extensions">method	^nil</body></methods><methods><class-id>Refactory.Browser.RefactoryChange</class-id> <category>accessing</category><body package="Debugger-Browser Extensions">method	^nil</body></methods><methods><class-id>CraftedSmalltalk.WatchVariableProbe</class-id> <category>converting</category><body package="Debugger-Browser Extensions">augmentDocument: aDocument at: aPosition	aDocument		replaceBetween: aPosition and: aPosition + self testSource size		with: (Refactory.Browser.DocumentVariableWatch variableWatchDocumentFor: self testSource)</body></methods><methods><class-id>Refactory.Browser.RefactoringBrowser</class-id> <category>testing</category><body package="Debugger-Browser Extensions">isClassSelected	^navigator isClassSelected</body></methods><methods><class-id>Refactory.Browser.BrowserCodeTool class</class-id> <category>instance creation</category><body package="Debugger-Browser Extensions">new	| browser |	browser := super new.	PDPManager notifyOnMethodChanged: browser.	^browser"Smalltalk Professional Debug Package Version 2.6 (c) 2001 Crafted Smalltalk"</body></methods><methods><class-id>Refactory.Browser.BrowserCodeTool</class-id> <category>probes</category><body package="Debugger-Browser Extensions">addBreakpoint		self addBreakpoint: CodeProbe new</body><body package="Debugger-Browser Extensions">addBreakpoint: aProbe		| probedMethod unprobedMethod aController |	aController := self textController.	unprobedMethod := self selectedMethod.	probedMethod := unprobedMethod newFullProbedMethod.	probedMethod ifNil: [^self].	PDPManager debugActive		ifFalse:			[Transcript show: #ProbesAreDisabled &lt;&lt; #pdp &gt;&gt; 'Probes are disabled'].	aProbe record: (probedMethod probeRecordFor: aController selectionRange).	probedMethod addProbe: aProbe.	aProbe unconditionallyInsertInto: probedMethod replacing: unprobedMethod</body><body package="Debugger-Browser Extensions">addOneshotBreakpoint		self addBreakpoint: OneshotProbe new</body><body package="Debugger-Browser Extensions">allMethodProbes	"Return all probes in the current method, regardless of selection status."		| probedMethod probes |	probedMethod := self selectedMethod.	probedMethod isProbed ifFalse: [^#()].	probes := OrderedCollection new.	probedMethod allProbesDo: [:each | probes add: each].	^probes</body><body package="Debugger-Browser Extensions">areProbeCommandsLegal		^self selectors size = 1 and: [self textController textHasChanged not]</body><body package="Debugger-Browser Extensions">basicReinsertProbesAndIndices: probesAndIndices into: probedMethod	| probesInError |	probesInError := OrderedCollection new.	probesAndIndices do:		[:ac | | probe index newRecord |		probe := ac key baseParent copy.		index := ac value.		newRecord := probedMethod probeRecordFor: (index to: index).		probe record: newRecord.		(probe updateTempVarIndexForMethod: probedMethod)			ifTrue: [probedMethod addProbe: probe]			ifFalse:				[newRecord updateMethod: probedMethod.		"update mclass and selector for reporting"				probesInError add: probe]].	probesInError addAll: probedMethod recompileProbes.	ProbedCompiledMethod reportOnFailedProbes: probesInError.</body><body package="Debugger-Browser Extensions">basicRemoveProbe: aProbe	| probedMethod replacementMethod |	probedMethod := self selectedMethod.	probedMethod totalProbes = 1		ifTrue: [^probedMethod revert].	replacementMethod := probedMethod newFullProbedMethod.	replacementMethod removeProbe: aProbe.	probedMethod mclass addSelector: self selector withMethod: replacementMethod.</body><body package="Debugger-Browser Extensions">changedMethodFrom: oldMethod to: newMethod by: aBrowser 	"This message notifies the receiver that the method text for	aSelector has changed and should be updated."	| widget |	builder isNil		ifTrue: [^self].	widget := builder componentAt: #textEditor.	widget isNil		ifTrue: [^self].	widget isOpen		ifFalse:  [^self].	(newMethod selector == self selector and: [newMethod mclass == self methodClass])		ifFalse: [^self].	(aBrowser ~~ self and: [self isEditing])		ifTrue: [self textNoChange: self text allItalic]		ifFalse: [self updateContents].</body><body package="Debugger-Browser Extensions">findSelectedProbeEmphasisIn: aText from: aController	^PDPManager findSelectedProbeEmphasisIn:			(aText				copyFrom: aController selectionStartIndex				to: aController selectionStopIndex + 1)</body><body package="Debugger-Browser Extensions">makeProbeTyped: probeType using: aProbeRecord at: selectionRange method: probedMethod	"Prompts the user to select a probe and returns an Association where the key is the probe	and the value is the conditional flag."	| probe probeRecord |	probeRecord := aProbeRecord isNil		ifTrue: [probedMethod probeRecordFor: selectionRange]		ifFalse: [aProbeRecord].	probeType == #Breakpoint		ifTrue: [probe := CodeProbe new].	probeType == #Variable		ifTrue:			[probe := self				promptForProbeVariableClass: self selectedClass				method: probedMethod				record: probeRecord.			probe isNil				ifTrue: [^nil]].	probeType == #Expression		ifTrue: [probe := DisplayActionProbe new].	probe record: probeRecord.	^probe</body><body package="Debugger-Browser Extensions">modifyProbe		| probedMethod candidates selectedText |	probedMethod := self selectedMethod.	selectedText := self textController text		copyFrom: self textController selectionStartIndex		to: self textController selectionStopIndex + 1.	candidates := self probesInText: selectedText.	candidates isEmpty		ifTrue: [candidates := self probesInText: self textController text].	candidates first modifyIn: probedMethod</body><body package="Debugger-Browser Extensions">probesInText: aText	"Find all the probes embedded in the emphases of aText. Sort them by their distance from the current insertion point since every user of this so far has wanted that."		| probes searchBlock |	probes := OrderedCollection new.	searchBlock := [:emphasis | emphasis class == ProbeCharacterStyle ifTrue: [probes add: emphasis value]].	aText runs values		do:			[:value | 			(value isKindOf: Array)				ifTrue: [value do: [:obj | searchBlock value: obj]]				ifFalse: [searchBlock value: value]].	probes		sort:			[:a :b | 			(a characterIndex - self textController selectionStartIndex) abs				&lt; (b characterIndex - self textController selectionStartIndex)].	^probes</body><body package="Debugger-Browser Extensions">probesNearCursor	"Return all probes that are near the cursor (when nothing is selected), where 'near' is defined as within 7 characters of the position either way. If we have multiple, only return the closest."		| probes nearCursorText |	self textController hasRangeSelection ifTrue: [^#()].	nearCursorText := self textController text		copyFrom: (self textController selectionStartIndex - 7 max: 1)		to:			(self textController selectionStopIndex + 7				min: self textController text size).	probes := self probesInText: nearCursorText.	probes		sort:			[:a :b | 			(a characterIndex - self textController selectionStartIndex) abs				&lt; (b characterIndex - self textController selectionStartIndex)].	^probes isEmpty		ifTrue: [probes]		ifFalse: [probes first: 1]</body><body package="Debugger-Browser Extensions">probesToActUpon		| probedMethod victims |	probedMethod := self selectedMethod.	probedMethod isProbed ifFalse: [^#()].	"Give precedence to selected probes"	victims := self selectedProbes.	victims isEmpty ifFalse: [^victims].	"If we have no selection, give probes *near* the cursor a chance, choose the closest."	victims := self probesNearCursor.	victims isEmpty ifFalse: [^victims].	"OK, just return 'em all then."	^self allMethodProbes</body><body package="Debugger-Browser Extensions">promptForProbeVariableClass: aClass method: probedMethod record: probeRecord	"Prompts the user to select a probe and returns an Association where the key is the probe	and the value is the conditional flag."	| legalTempNames legalTemps ivarNames dialog aBuilder ivar tmpVar windoe wVar varType |	windoe := self interfaceWindow.	wVar := ValueHolder newString.	legalTemps := OrderedCollection new.	(probedMethod variableMapAt: probeRecord blockMethodIndex) temps do:		[:var |		(var key first == $. or: [legalTemps contains: [:lvar | lvar key = var key]])			ifFalse: [legalTemps add: var]].	legalTempNames := legalTemps collect: [:ac | ac key].	ivarNames := aClass allInstVarNames.	dialog := SimpleDialog new.	dialog initializeBuilderFor: windoe.	aBuilder := dialog builder.	aBuilder		aspectAt: #TOS		put: [varType := #tos.			wVar value: 'Top of Stack'].	aBuilder		aspectAt: #iVar		put: [ivar := (Menu				labelArray: ivarNames				values: ivarNames) startUp.			ivar ~~ 0				ifTrue:					[wVar value: ivar.					varType := #inst]].	aBuilder		aspectAt: #tVar		put: [tmpVar := (Menu				labelArray: legalTempNames				values: legalTemps) startUp.			tmpVar ~~ 0				ifTrue:					[wVar value: tmpVar key.					varType := #tmp]].	aBuilder		aspectAt: #wVar		put: wVar.	dialog builder add: (UISpecification from: self class watchVarSpec).	dialog initializeWindowFor: windoe.	ivarNames isEmpty		ifTrue: [(aBuilder componentAt: #IvarSwitch) disable].	legalTemps isEmpty		ifTrue: [(aBuilder componentAt: #TempSwitch) disable].	dialog preOpen.	dialog builder openDialogWithExtent: dialog builder window displayBox extent.	dialog accept value		ifFalse: [^nil].	varType == nil		ifTrue: [^nil].	varType == #tos		ifTrue: [^DisplayTOSProbe new].	varType == #inst		ifTrue: [^DisplayInstanceVarProbe name: ivar index: (ivarNames indexOf: ivar)].	^DisplayMethodVarProbe slot: tmpVar</body><body package="Debugger-Browser Extensions">rearmOneshotProbes		self probesToActUpon do: [:each | each isOneshot ifTrue: [each rearm]].	self updateContents</body><body package="Debugger-Browser Extensions">removeProbe		| victims probedMethod |	probedMethod := self selectedMethod.	victims := self probesToActUpon.	victims do: [:each | self basicRemoveProbe: each].	"The following is necessary because apparently the method cache is not completely flushed."	ObjectMemory garbageCollect.	PDPManager changedMethodFrom: probedMethod to: probedMethod by: self</body><body package="Debugger-Browser Extensions">selectedMethod	^self methodClass compiledMethodAt: self selector</body><body package="Debugger-Browser Extensions">selectedProbes	"Return all probes in the current selection."		| selectedText |	self textController hasRangeSelection ifFalse: [^#()].	selectedText := self textController text		copyFrom: self textController selectionStartIndex		to: self textController selectionStopIndex + 1.	^self probesInText: selectedText</body></methods><methods><class-id>Refactory.Browser.CodeTool</class-id> <category>testing</category><body package="Debugger-Browser Extensions">areProbeCommandsLegal	^false</body></methods><methods><class-id>CraftedSmalltalk.WatchActionProbe</class-id> <category>converting</category><body package="Debugger-Browser Extensions">augmentDocument: aDocument at: aPosition	aDocument		insertAt: aPosition		with: (Refactory.Browser.DocumentActionWatch actionWatchDocumentFor: self testSource)</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>converting</category><body package="Debugger-Browser Extensions">asSourceCodeDocument	| document probes position |	document := Text2.Document fromString: (self mclass sourceCodeForMethod: self at: self selector) string.	probes := SortedCollection sortBlock: [:a :b | a characterIndex &gt; b characterIndex].	self allProbesDo: [:probe | probes add: probe].	probes do: [:probe |		position := probe probeRecord sourcePosition first - 1.		probe augmentDocument: document at: position].	^document</body></methods><methods><class-id>CraftedSmalltalk.ProbeClone</class-id> <category>converting</category><body package="Debugger-Browser Extensions">augmentDocument: aDocument at: aPosition	parent augmentDocument: aDocument at: aPosition</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe class</class-id> <category>resources</category><body package="Debugger-Browser Extensions">breakpointGlyph	^DebuggerIcons breakpoint</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>converting</category><body package="Debugger-Browser Extensions">augmentDocument: aDocument at: aPosition	aDocument		insertAt: aPosition		with: (Refactory.Browser.DocumentBreakpoint			breakpointDocumentForMode: self mode			condition: self testSource)</body></methods><methods><class-id>CraftedSmalltalk.CodeProbe</class-id> <category>accessing</category><body package="Debugger-Browser Extensions">breakpointGlyph		^self class breakpointGlyph</body></methods><methods><class-id>CraftedSmalltalk.OneshotProbe class</class-id> <category>resources</category><body package="Debugger-Browser Extensions">breakpointGlyph	^DebuggerIcons oneShotBreakpoint</body><body package="Debugger-Browser Extensions">disabledBreakpointGlyph		^DebuggerIcons disabledBreakpoint</body></methods><methods><class-id>CraftedSmalltalk.OneshotProbe</class-id> <category>accessing - emphasis</category><body package="Debugger-Browser Extensions">basicEmphasis		| key |	key := self isArmed		ifTrue: [#armedOneshotProbe]		ifFalse: [#disarmedOneshotProbe].	^ProbeCharacterStyle key: key value: self</body></methods><methods><class-id>CraftedSmalltalk.OneshotProbe</class-id> <category>accessing</category><body package="Debugger-Browser Extensions">breakpointGlyph		^self isArmed		ifTrue: [self class breakpointGlyph]		ifFalse: [self class disabledBreakpointGlyph]</body></methods><methods><class-id>CraftedSmalltalk.OneshotProbe</class-id> <category>accessing - emphasis</category><body package="Debugger-Browser Extensions">tempEmphasis		^self basicEmphasis</body></methods><methods><class-id>Refactory.Browser.AddMethodChange</class-id> <category>accessing</category><body package="Debugger-Browser Extensions">method		self selector ifNil: [^nil].	^self changeObject		ifNotNil:			[:changeObject | 			changeObject				compiledMethodAt: self selector				ifAbsent: [nil]]</body></methods><methods><class-id>Refactory.Browser.SourceCodeEditor class</class-id> <category>private-events</category><body package="Debugger-Browser Extensions">constructEventsTriggered	^super constructEventsTriggered		add: #probesUpdated;		yourself</body></methods><methods><class-id>Refactory.Browser.SourceCodeEditor</class-id> <category>testing</category><body package="Debugger-Browser Extensions">canInsertBreakpoint	^self canProbeCode</body><body package="Debugger-Browser Extensions">canInsertWatchExpression	^self canProbeCode</body><body package="Debugger-Browser Extensions">canInsertWatchVariable	^self canProbeCode and: [self isVariableReferenceNode]</body><body package="Debugger-Browser Extensions">canProbeCode	^self doItExpectPattern and: [		self canEvaluateCode and: [			self isReadOnly not and: [				self doItReceiverClass notNil and: [					self doItReceiverClass isExternalInterface not]]]]</body></methods><methods><class-id>Refactory.Browser.SourceCodeEditor</class-id> <category>private - probes</category><body package="Debugger-Browser Extensions">createProbe: aSourceCodeProbe in: aDocument record: aProbeRecord	^(self documentSegmentForMarkup: aSourceCodeProbe in: aDocument)		create: aSourceCodeProbe in: aDocument record: aProbeRecord</body></methods><methods><class-id>Refactory.Browser.SourceCodeEditor</class-id> <category>private - evaluation</category><body package="Debugger-Browser Extensions">debug: aCompiledMethod	"Open the debugger on the first expression of the argument CompiledMethod.	This method partly duplicates the logic of #evaluateExpressionDo: but it is necessary	because of problems with automatic stepping through that method."	| doItReceiver doItContext guineaPig context |	doItReceiver := self doItReceiver.	doItContext := self doItContext.	guineaPig := doItContext isNil		ifTrue: [[doItReceiver performMethod: aCompiledMethod] newProcess]		ifFalse: [[doItReceiver performMethod: aCompiledMethod with: doItContext] newProcess].	"The following is executed in another process because the 'send' message will use the	 process debugger ivar and we don't want it to use the one from the active process if we're an editor	 inside of a debugger'."				["Need to manually push copied values from the closure into the context	  before stepping because they are not getting pushed during the simulation!"	context := guineaPig suspendedContext.	context receiver pushCopiedValues: context.	[context method == aCompiledMethod] whileFalse: [context := context send].	guineaPig suspendedContext: context] forkAt: Processor activePriorityPlusOne.	Notifier developmentNotifier		openOnProcess: guineaPig		interrupted: true		label: #DebugIt &lt;&lt; #pdp &gt;&gt; 'Debug It'</body></methods><methods><class-id>Refactory.Browser.SourceCodeEditor</class-id> <category>testing</category><body package="Debugger-Browser Extensions">hasNoProbesSelected	^self hasProbesSelected not</body><body package="Debugger-Browser Extensions">hasProbes	^self probes notEmpty</body><body package="Debugger-Browser Extensions">hasProbesSelected	"Return if the current selection overlaps or contains a probe, but not just touching."	| interval |	interval := self selectionInterval.	^self probes anySatisfy: [:aSourceCodeProbe |		| insideInterval start stop |		start := aSourceCodeProbe first + 1.		stop := aSourceCodeProbe last - 1.		insideInterval := start to: stop.		"Does the probe overlap or contain the selection interval?"		(insideInterval includes: interval first) or: [(insideInterval includes: interval last) or: [			"Does the selection interval overlap or contain the probe?"			(interval includes: start) or: [interval includes: stop]]]]</body><body package="Debugger-Browser Extensions">isTouchingProbe	"Returns true if the cursor is inside or touches the edges of a breakpoint."		| start stop |	start := self selectionStartPosition.	stop := self selectionStopPosition.	^self probes anySatisfy: [:aSourceCodeProbe |		(aSourceCodeProbe includes: start) or: [aSourceCodeProbe includes: stop]]</body></methods><methods><class-id>Refactory.Browser.SourceCodeEditor</class-id> <category>accessing - probes</category><body package="Debugger-Browser Extensions">probes	"Returns the intervals for all probes."		^self probesIn: document</body></methods><methods><class-id>Refactory.Browser.SourceCodeEditor</class-id> <category>private - probes</category><body package="Debugger-Browser Extensions">probesIn: aDocument	"Return the breakpoint ranges."		^self markupIn: aDocument</body></methods><methods><class-id>Refactory.Browser.SourceCodeEditor</class-id> <category>accessing - probes</category><body package="Debugger-Browser Extensions">selectedProbes	"Return the probe ranges that overlap with the current selection."		| interval |	self hasSelection ifFalse: [^#()].	interval := self selectionInterval.	^self probes select: [:aSourceCodeProbe |		| insideInterval |		insideInterval := (aSourceCodeProbe first + 1) to: (aSourceCodeProbe last - 1).		aSourceCodeProbe = interval or: [(insideInterval includes: interval first) or: [insideInterval includes: interval last]]]</body></methods><methods><class-id>Refactory.Browser.SourceCodeEditor</class-id> <category>private - probes</category><body package="Debugger-Browser Extensions">translateCompiledToSourceInterval: anInterval	^self translateCompiledToSourceInterval: anInterval in: document</body><body package="Debugger-Browser Extensions">translateCompiledToSourceInterval: anInterval in: aDocument	| first last |	first := anInterval first.	last := anInterval last.	(self probesIn: aDocument) do: [:aSourceCodeProbe |		aSourceCodeProbe first &lt;= first			ifTrue: [				| segment removalSize |				segment := self documentSegmentForMarkup: aSourceCodeProbe in: aDocument.				removalSize := segment removalSize: aSourceCodeProbe.				first := first + removalSize].		aSourceCodeProbe first &lt;= last			ifTrue: [				| segment removalSize |				segment := self documentSegmentForMarkup: aSourceCodeProbe in: aDocument.				removalSize := segment removalSize: aSourceCodeProbe.				last := last + removalSize]].	^first to: last</body><body package="Debugger-Browser Extensions">translateSourceToCompiledInterval: anInterval	^self translateSourceToCompiledInterval: anInterval in: document</body><body package="Debugger-Browser Extensions">translateSourceToCompiledInterval: anInterval in: aDocument	| first last |	first := anInterval first.	last := anInterval last.	(self probesIn: aDocument) reverseDo: [:aSourceCodeProbe |		aSourceCodeProbe last &lt;= first			ifTrue: [				| segment removalSize |				segment := self documentSegmentForMarkup: aSourceCodeProbe in: aDocument.				removalSize := segment removalSize: aSourceCodeProbe.				first := first - removalSize.				last := last - removalSize]].	^first to: last</body><body package="Debugger-Browser Extensions">triggerProbesChanged	| compiledMethodWithProbes |	(compiledMethodWithProbes := self compileMethod: #OnSave retry: [self triggerProbesChanged]) ifNil: [^self].	self triggerEvent: #probesUpdated with: compiledMethodWithProbes</body></methods><methods><class-id>Refactory.Browser.BrowserCodeTool class</class-id> <category>interface specs</category><body package="Debugger-Browser Extensions">watchVarSpec	"Tools.UIPainter new openOnClass: self andSelector: #watchVarSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #InsertVariableWatch 				#defaultString: 'Insert Variable Watch' 				#catalogID: #pdp ) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 720 450 1237 595 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 318 98 407 128 ) 					#model: #accept 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #pdp ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 419 98 504 128 ) 					#model: #cancel 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #pdp ) 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 143 55 503 82 ) 					#model: #wVar 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 9 20 132 49 ) 					#model: #TOS 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #TopOfStack 						#defaultString: 'Top of Stack' 						#catalogID: #pdp ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 143 19 332 49 ) 					#name: #IvarSwitch 					#model: #iVar 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #InstanceVariableDots 						#defaultString: 'Instance Variable...' 						#catalogID: #pdp ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 342 19 503 50 ) 					#name: #TempSwitch 					#model: #tVar 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #TempVariableDots 						#defaultString: 'Temp Variable...' 						#catalogID: #pdp ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 14 61 ) 					#name: #Label1 					#label: 					#(#{Kernel.UserMessage} 						#key: #WatchC 						#defaultString: 'Watch:' 						#catalogID: #pdp ) ) ) ) )</body></methods><methods><class-id>Refactory.Browser.BrowserCodeTool</class-id> <category>probes</category><body package="Debugger-Browser Extensions">addBreakpointItem		&lt;itemInMenu: #(#mainMenu) position: 25.10&gt;	^(MenuItem labeled: #InsertBreakpoint &lt;&lt; #pdp &gt;&gt; 'Insert Breakpoint')		enablement: #areProbeCommandsLegal;		value: [self addBreakpoint];		labelImage: CodeProbe breakpointGlyph</body><body package="Debugger-Browser Extensions">addOneshotBreakpointItem		&lt;itemInMenu: #(#mainMenu) position: 25.15&gt;	^(MenuItem		labeled: #NewOneShotBreakpoint &lt;&lt; #pdp &gt;&gt; 'Insert Oneshot Breakpoint')		value: [self addOneshotBreakpoint];		enablement: #areProbeCommandsLegal;		labelImage: OneshotProbe breakpointGlyph</body><body package="Debugger-Browser Extensions">addProbe		&lt;menuItem: #(#InsertProbeDots #pdp 'Insert Probe...') nameKey: nil		enablement: #areProbeCommandsLegal indication: nil menu: #(#mainMenu)		position: 25.2&gt;	| probedMethod unprobedMethod probe probeSpec aController |	aController := self textController.	self selector isNil		ifTrue:			[^Dialog				warn:					#InsertProbeValidWhenMethodSelected &lt;&lt; #pdp &gt;&gt;							'The "insert probe" operation is onlyvalid when a method is selected.'].	aController textHasChanged		ifTrue:			[^Dialog				warn:					(#ProbeCannotBeInsertedSourceChanged &lt;&lt; #pdp &gt;&gt;							'A probe cannot be inserted because&lt;1s&gt;     the source code has changed.'						expandMacrosWith: (String with: Character cr))].	probeSpec := CodeProbe selectBrowserProbeType.	probeSpec == nil ifTrue: [^nil].	unprobedMethod := self selectedMethod.	probedMethod := unprobedMethod newFullProbedMethod.	probedMethod isNil ifTrue: [^self].	PDPManager debugActive		ifFalse:			[PDPTransientWarning				on: #ProbesAreDisabled &lt;&lt; #pdp &gt;&gt; 'Probes are disabled'].	probe := self		makeProbeTyped: probeSpec probeClass		using: nil		at: aController selectionRange		method: probedMethod.	probe isNil ifTrue: [^self].	probedMethod addProbe: probe.	probe makeConditional: probeSpec replacing: unprobedMethod with:			probedMethod</body><body package="Debugger-Browser Extensions">modifyProbeItem		&lt;itemInMenu: #(#mainMenu) position: 25.3&gt;	^(MenuItem labeled: #EditProbeDots &gt;&gt; 'Edit Probe...' &lt;&lt; #pdp)		value: [self modifyProbe];		enablement:				[self areProbeCommandsLegal and: [self selectedMethod isProbed]]</body><body package="Debugger-Browser Extensions">rearmOneshotProbesItem		&lt;itemInMenu: #(#mainMenu) position: 25.16&gt;	^(MenuItem labeled: #RearmProbes &gt;&gt; 'Rearm Oneshot Probes' &lt;&lt; #pdp)		value: [self rearmOneshotProbes];		visible:				[self areProbeCommandsLegal						and:							[self probesToActUpon								anySatisfy: [:each | each isOneshot and: [each isArmed not]]]]</body><body package="Debugger-Browser Extensions">removeProbeItem		&lt;itemInMenu: #(#mainMenu) position: 25.4&gt;	^(MenuItem labeled: #RemoveProbe &gt;&gt; 'Remove Probe' &lt;&lt; #pdp)		value: [self removeProbe];		visible: [self areProbeCommandsLegal and: [self probesToActUpon size = 1]]</body><body package="Debugger-Browser Extensions">removeProbesItem		&lt;itemInMenu: #(#mainMenu) position: 25.4&gt;	^(MenuItem labeled: #RemoveProbes &gt;&gt; 'Remove Probes' &lt;&lt; #pdp)		value: [self removeProbe];		visible: [self areProbeCommandsLegal and: [self probesToActUpon size &gt; 1]]</body></methods><methods><class-id>Refactory.Browser.SourceCodeEditor</class-id> <category>actions - evaluating</category><body package="Debugger-Browser Extensions">debugIt	&lt;state: #active command: #debugIt&gt;	&lt;menu: #(contextMenu) position: 40.25 insert: #(		command: #debugIt		visibility: #canEvaluateCode		enablement: #canEvaluateSelection)&gt;			| compiled |	self hasSelection ifFalse: [self selectParagraph].	compiled := self compileExpression: #OnSave retry: [:start :stop |		self selectBetween: start and: stop.		self debugIt].	compiled ifNil: [^self].	SourceFileManager default logChange: self selection asString.	^self debug: compiled</body></methods><methods><class-id>Refactory.Browser.SourceCodeEditor</class-id> <category>actions - probes</category><body package="Debugger-Browser Extensions">insertActionWatch	&lt;state: #active command: #insertActionWatch&gt;	&lt;menu: #(contextMenu) position: 50.2 insert: #(		command: #insertActionWatch		visibility: #canInsertWatchExpression		enablement: #hasNoProbesSelected)&gt;	| unprobedMethod probedMethod record position watchDocument watchChange selectionInterval expressionSource |	self isWorkspace ifTrue: [^self].	self doItExpectPattern ifFalse: [^self].		selectionInterval := self selectionInterval.	expressionSource := self selection asString.	(unprobedMethod := self compileMethod: #OnSave) == nil ifTrue: [^self].	probedMethod := unprobedMethod isProbed		ifTrue: [unprobedMethod]		ifFalse: [unprobedMethod newFullProbedMethod].	record := (probedMethod probeRecordFor: ((selectionInterval first + 1) to: selectionInterval last)).	position := (self translateCompiledToSourceInterval: record sourcePosition in: document) first - 1.		self hasSelection ifTrue: [self expandSelectionToIncludeOverlappingMarkup].	watchDocument := DocumentActionWatch actionWatchDocumentFor: expressionSource.	watchChange := (self		newChange: #insertActionWatch		between: position and: position		with: watchDocument)			inputPosition: selectionInterval last;			anchorPosition: selectionInterval first;			newInputPosition: position + 1;			newAnchorPosition: position + 1;			yourself.	self performChange: watchChange.	self triggerProbesChanged</body><body package="Debugger-Browser Extensions">insertBreakpoint	&lt;state: #active command: #insertBreakpoint&gt;	&lt;menu: #(contextMenu) position: 50.3 insert: #(		command: #insertBreakpoint		visibility: #canInsertBreakpoint		enablement: #hasNoProbesSelected)&gt;	| unprobedMethod probedMethod record position watchDocument watchChange selectionInterval |	CraftedSmalltalk.PDPManager debugActive ifFalse: [		CraftedSmalltalk.PDPTransientWarning on: #ProbesAreDisabled &lt;&lt; #pdp &gt;&gt; 'Probes are disabled'].	selectionInterval := self selectionInterval.	(unprobedMethod := self compileMethod: #OnSave) == nil ifTrue: [^self].	probedMethod := unprobedMethod isProbed		ifTrue: [unprobedMethod]		ifFalse: [unprobedMethod newFullProbedMethod].	record := (probedMethod probeRecordFor: ((selectionInterval first + 1) to: selectionInterval last)).	position := (self translateCompiledToSourceInterval: record sourcePosition in: document) first - 1.		self hasSelection ifTrue: [self expandSelectionToIncludeOverlappingMarkup].	watchDocument := DocumentBreakpoint breakpointDocumentForMode: #once condition: ''.	watchChange := UI.DocumentViewChange new		type: #insertBreakpoint;		inputPosition: selectionInterval last;		anchorPosition: selectionInterval first;		newInputPosition: position + 1;		newAnchorPosition: position + 1;		newCursorDirection: #rightToLeft;		originalStyle: currentStyle;		replacementStyle: currentStyle;		start: position;		stop: position;		original: Document new;		replacement: watchDocument;		direction: #leftToRight;		isAccepted: isAccepted;		yourself.	self performChange: watchChange.	self triggerProbesChanged</body><body package="Debugger-Browser Extensions">insertVariableWatch	&lt;state: #active command: #insertVariableWatch&gt;	&lt;menu: #(contextMenu) position: 50.1 insert: #(		command: #insertVariableWatch		visibility: #canInsertWatchVariable		enablement: #hasNoProbesSelected)&gt;	| unprobedMethod probedMethod record position watchDocument watchChange selectionInterval variableName |	self isWorkspace ifTrue: [^self].	self doItExpectPattern ifFalse: [^self].	self hasSelection ifFalse: [self selectOuterScope].	selectionInterval := self selectionInterval.	variableName := self selection asString.	(unprobedMethod := self compileMethod: #OnSave) == nil ifTrue: [^self].	probedMethod := unprobedMethod isProbed		ifTrue: [unprobedMethod]		ifFalse: [unprobedMethod newFullProbedMethod].	record := (probedMethod probeRecordFor: ((selectionInterval first + 1) to: selectionInterval last)).	position := (self translateCompiledToSourceInterval: record sourcePosition in: document) first - 1.		self hasSelection ifTrue: [self expandSelectionToIncludeOverlappingMarkup].	watchDocument := DocumentVariableWatch variableWatchDocumentFor: variableName.	watchChange := (self		newChange: #insertVariableWatch		between: selectionInterval first and: selectionInterval last		with: watchDocument)			inputPosition: selectionInterval last;			anchorPosition: selectionInterval first;			newInputPosition: position + 1;			newAnchorPosition: position + 1;			yourself.	self performChange: watchChange.	self triggerProbesChanged</body></methods><methods><class-id>Refactory.Browser.SourceCodeEditor</class-id> <category>private - evaluation</category><body package="Debugger-Browser Extensions">installMethodProbes: unprobedMethod decorated: decorated between: start and: stop reason: aReason	&lt;compilation: 1&gt;		| probes probedMethod probePositions offset offsets errorHandler isValid source |	(probes := self probesIn: document) isEmpty ifTrue: [^unprobedMethod].	"Remove all the markup but record how much space was subtracted"	source := document copy.	offsets := OrderedCollection new.	probes reverseDo: [:aSourceCodeProbe |		offsets addFirst: (self removeMarkup: aSourceCodeProbe in: source)].	"Compute the probe positions based off of the removed whitespace"	offset := 0.	probePositions := OrderedCollection new.	probes with: offsets do: [:aSourceCodeProbe :anOffset |		probePositions add: aSourceCodeProbe first - offset.		offset := offset + anOffset].	"Create a probed method to insert the breakpoints into"	unprobedMethod sourcePointer: source asString.	probedMethod := unprobedMethod newFullProbedMethod.	"Compile each breakpoint expression and style as required in to the gaps"	isValid := true.	probes with: probePositions do: [:aSourceCodeProbe :position |		| record probe |		record := probedMethod probeRecordFor: (position + 1 to: position).		probe := self createProbe: aSourceCodeProbe in: document record: record.		errorHandler := self errorHandlerClass new initialize: decorated editor: self selector: parseTree selector offset: aSourceCodeProbe first + 1 reason: aReason.		(probe recompileTestExpressionUsingProbedMethod: probedMethod handler: errorHandler) ifFalse: [			isValid := false].		self styleMarkupIn: decorated.		probedMethod addProbe: probe].		isValid ifFalse: [^nil].	^probedMethod</body></methods><methods><class-id>Refactory.Browser.SourceCodeEditor</class-id> <category>actions - probes</category><body package="Debugger-Browser Extensions">removeAllProbes	&lt;state: #active command: #removeAllProbes&gt;	&lt;menu: #(contextMenu) position: 50.5 insert: #(		command: #removeAllProbes		visibility: #canProbeCode		enablement: #hasProbes)&gt;	self invalidateSelectionWhile: [		highlights := nil.		self probes reverseDo: [:aSourceCodeProbe |			self collapse: (flow cursorAtPosition: aSourceCodeProbe first).			(self documentSegmentForMarkup: aSourceCodeProbe in: document)				remove: aSourceCodeProbe in: flow]].	self triggerProbesChanged</body><body package="Debugger-Browser Extensions">removeProbe	&lt;state: #active command: #removeProbe&gt;	&lt;menu: #(contextMenu) position: 50.4 insert: #(		command: #removeProbe		visibility: #canProbeCode		enablement: #isTouchingProbe)&gt;	self hasSelection ifFalse: [self expandToIncludeTouchingMarkup].	self invalidateSelectionWhile: [		highlights := nil.		self selectedProbes reverseDo: [:aSourceCodeProbe |			self collapse: (flow cursorAtPosition: aSourceCodeProbe first).			(self documentSegmentForMarkup: aSourceCodeProbe in: document)				remove: aSourceCodeProbe in: flow]].	self triggerProbesChanged</body><body package="Debugger-Browser Extensions">toggleBreakpoint	&lt;state: #active command: #toggleBreakpoint&gt;	| segment |	segment := flow segmentLeftOfCursor: self inputCursor ifAbsent: [^self].	(segment isKindOf: FlowBreakpoint) ifFalse: [		segment := flow segmentRightOfCursor: self inputCursor ifAbsent: [^self].		(segment isKindOf: FlowBreakpoint) ifFalse: [^self]].	segment applyView: self segment: segment</body></methods><methods><class-id>Refactory.Browser.BrowserNavigator</class-id> <category>class probes</category><body package="Debugger-Browser Extensions">browseProbedMethods	"Open a method browser on all the probed methods belonging	to the selected class."		&lt;menuItem: #(#BrowseProbedMethods #pdp 'Browse Probed Methods') nameKey:			#browseProbedMethods enablement: #isClassSelected indication: nil menu:			#(#classMenu) position: 75.3&gt;	| probedMethods |	probedMethods := OrderedCollection new.	self selectedClass		selectorsAndMethodsDo:			[:ignored :eachMethod | eachMethod isProbed ifTrue: [probedMethods add: eachMethod definition]].	probedMethods isEmpty ifTrue: [^self].	^MethodCollector new		openListBrowserOn: probedMethods		label: #ProbedMethods &lt;&lt; #pdp &gt;&gt; 'Probed Methods'		initialSelection: nil</body><body package="Debugger-Browser Extensions">removeClassProbes	&lt;menuItem: #(#FromThisClassOnly #pdp 'From This Class Only')			nameKey: nil			menu: #(#classMenu #removeClassProbesMenu)			position: 10.1&gt;	(Dialog		choose: ((#ThisWillRemoveAllProbesFromClassMethods &lt;&lt; #pdp &gt;&gt; 'This will remove all the probes from&lt;n&gt;the methods belonging to class &lt;1s&gt;')			expandMacrosWith: self selectedClass name)		labels: (Array with: (#Proceed &lt;&lt; #pdp &gt;&gt; 'Proceed') with: (#Cancel &lt;&lt; #pdp &gt;&gt; 'Cancel'))		values: #(true false)		default: false)		ifFalse: [^self].	self selectedClass selectorsAndMethodsDo: [:ingored :eachMethod | eachMethod revert].</body><body package="Debugger-Browser Extensions">removeClassProbesMenu	&lt;submenu: #(#removeClassProbes #pdp 'Remove Class Probes')			nameKey: #removeClassProbesMenu			visibility: #isClassSelected			menu: #(#classMenu)			position: 75.2&gt;	^self</body><body package="Debugger-Browser Extensions">removeProbesInClassTree	&lt;menuItem: #(#FromThisClassAndSubclasses #pdp 'From This Class and Subclasses')			nameKey: nil			menu: #(#classMenu #removeClassProbesMenu)			position: 10.2&gt;	(Dialog		choose: ((#ThisWillRemoveAllProbesFromClass1sAndSubs &lt;&lt; #pdp &gt;&gt; 'This will remove all the probes from the methods&lt;n&gt;belonging to class &lt;1s&gt; and its subclasses.')			expandMacrosWith: self selectedClass name)		labels: (Array with: (#Proceed &lt;&lt; #pdp &gt;&gt; 'Proceed') with: (#Cancel &lt;&lt; #pdp &gt;&gt; 'Cancel'))		values: #(true false)		default: false)		ifFalse: [^self].	self selectedClass withAllSubclasses do: [:cl | cl selectorsAndMethodsDo: [:ignored :eachMethod | eachMethod revert]].</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>CodeTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>codeModel menu </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tools</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>BrowserCodeTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserTextTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>modified initialLookPrefs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tools</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>RefactoryChange</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><class><name>CodeProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.AbstractCodeProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testMethod testSource variables labelString permanent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><class><name>BrowserNavigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractBrowserNavigator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>history future </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>FlowMarkupOpen</name><environment>Text2</environment><super>Text2.FlowSegment</super><private>false</private><indexed-type>none</indexed-type><inst-vars>position segment capWidth </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Graphics-Text2-Flow</package></attributes></class><class><name>OneshotProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.CodeProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars>armed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Debugger-Probes</package></attributes></class><class><name>RefactoringBrowser</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractRefactoringBrowser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>policyClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-RB UI</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>SourceCodeEditor</name><environment>Refactory.Browser</environment><super>UI.DocumentView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>decorations plugins theme evaluator needsRedecoration warning parseTree parserClass acceptAnimationCancel language errorHandlerClass timingStatistics compilerClass </inst-vars><class-inst-vars>defaultTheme compilationPragmas evaluationPragmas enablement </class-inst-vars><imports>			private Text2.*			</imports><category></category><attributes><package>Browser-SourceCodeUI</package></attributes></class><class><name>AddMethodChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryObjectChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source selector protocols controller definedSelector package tool </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><class><name>WatchActionProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.CodeProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Debugger-Probes</package></attributes></class><class><name>DocumentMarkupOpen</name><environment>Text2</environment><super>Text2.DocumentSegment</super><private>true</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Graphics-Text2-Document</package></attributes></class><class><name>ProbeClone</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.AbstractCodeProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><class><name>RemoveMethodChange</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RefactoryObjectChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Change Objects</category><attributes><package>Browser-ChangeObjects</package></attributes></class><class><name>WatchVariableProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.CodeProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Debugger-Probes</package></attributes></class><class><name>ProbedCompiledMethod</name><environment>CraftedSmalltalk</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>original methodHolder probeStart </inst-vars><class-inst-vars>removedProbedMethodsHolder </class-inst-vars><imports>			OpcodePool.*			</imports><category>CraftedSt-VM</category><attributes><package>Debugger-Probes</package></attributes></class></st-source>