<?xml version="1.0"?><st-source><!-- Name: Debugger-SupportNotice: Copyright 2003-2017 Cincom Systems, Inc.  All rights reserved.Comment: PDP Support for VW 7DbIdentifier: bear73DbTrace: 501982DbUsername: smichaelDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'Debugger-Probes' ''))PackageName: Debugger-SupportParcel: #('Debugger-Support')ParcelName: Debugger-SupportPrerequisiteParcels: #(#('Debugger-Probes' ''))PrintStringCache: (8.3 - 1,smichael)Version: 8.3 - 1Post-Load Block: 	[ :pkg |  SyntaxError flushMenus.Processor initializePausedCollection.]Date: 3:26:58 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.4) of June 23, 2017 on June 30, 2017 at 3:26:58 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>DebuggerService</name><environment>CraftedSmalltalk</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>processHandle oldCursor receiverInspector contextInspector stackInspector sourceMap currentContext pendingEvents continueInDebuggerCtx finishBlock selector tags stepProbes label serviceProcess selectionRange contextStackPolicy dontUpdateInspectors doSend doSendLoop doStepIntoBlock debugOperationIsActive doItProcess </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Debugger-Support</package></attributes></class><comment><class-id>CraftedSmalltalk.DebuggerService</class-id><body>DebuggerService is the service portion of the debugger. The debugger service is responsible for controlling the execution of the process being debugged and providing the context stack to the debugger client.Public API	The public commands for performing debug operations are found in the "debug commands" protocol.	At the conclusion of performing a command the debugger service may perform several "self changed:" sends. Each changed send will indicate what aspect of the debugger has changed. The method #eventOrder contains an array specifying the sequence in which the aspect changes will be broadcast, also see #processEvents.Instance Variables	contextInspector	&lt;ContextInspector&gt;	contextStackPolicy	&lt;ContextListPolicy&gt;		loopControlContext	&lt;WeakArray of: Context&gt;	The context is used in the "nextLoop" debug command as the guard context. Execution of a loop may continue as long as the context does not exit. 	currentContext	&lt;Context&gt;	The currently selected context.	dontUpdateInspectors	&lt;Boolean&gt;	This is used by the debugger to prevent the inspectors from being updated when stepping into a block. Normally, the inspectors are updated when the current context changes, however when stepping into a block the current context may change before the operation has completed. This prevents the inspectors from flashing while the operation is still being performed.	finishBlock	&lt;BlockClosure&gt;	The finish block is used to finish debug operations.	label	&lt;String&gt;	A string used as the window title for the debugger.	oldCursor	&lt;Cursor&gt;	The active cursor at the time the debugger is opened on a process. When the process is resumed this cursor is restored.	pendingEvents	&lt;(Collection of: (Symbol | Array))&gt;	This is a collection of the events that must be forwarded to the client.	processHandle	&lt;ProcessHandle&gt;	The process handle of the process being debugged.	receiverInspector	&lt;PrimitiveObjectInspector&gt;	selectionRange	&lt;(SequenceableCollection of: Interval)&gt;	The selection interval used to insert or select a probe.	selector	&lt;Symbol&gt;	The selector of the selected context.	serviceProcess	&lt;Process&gt;	The process used to perform execution of a debug command.	sourceMap	&lt;(SortedCollection of: SourceMapEntry)&gt;	The source map of the selected method context. This maps the context pc to character position in the source code.	stackInspector	&lt;StackInspector&gt;	stepProbes	&lt;OrderedCollection of: CodeProbe&gt;	A collection of probes used to stop execution of the "run to caret" command. This really should be a single probe and not a collection.	tags	&lt;(PDPWeakCollection of: Context)&gt;	A collection of bookmarked contexts.	doSend &lt;Boolean&gt;	doSendLoop  &lt;Boolean&gt;	doStepIntoBlock  &lt;Boolean&gt;	debugOperationIsActive  &lt;Boolean&gt;	doItProcess	&lt;Process&gt;Shared Variables	DefaultToPermanentProbe &lt;Boolean&gt;	If true, default is to create permanent probe for breakpoints added.	EventFaithfulDebugging  	&lt;Boolean&gt;		Use event faithful debugging if true.	TempMethods			&lt;PDPWeakDictionary&gt;	Temporary dictionary for methods with probes.	</body></comment><shared-variable><name>ClientClass</name><environment>CraftedSmalltalk.DebuggerService</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Debugger-Support</package></attributes></shared-variable><shared-variable><name>EventFaithfulDebugging</name><environment>CraftedSmalltalk.DebuggerService</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Debugger-Support</package></attributes></shared-variable><shared-variable><name>TempMethods</name><environment>CraftedSmalltalk.DebuggerService</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Debugger-Support</package></attributes></shared-variable><shared-variable><name>DefaultToPermanentProbe</name><environment>CraftedSmalltalk.DebuggerService</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Debugger-Support</package></attributes></shared-variable><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>private-stack manipulation</category><body package="Debugger-Support">byteStep	"Steps the context one instruction.	Returns true if the context did not change, otherwise	it returns false."	| currContext |	currContext := currentContext pdpCompleteCallee: currentContext step.	currContext == currentContext		ifTrue: [^true].	self resetContext: currContext.	^false</body><body package="Debugger-Support">cutbackTo: aContext finishWith: aBlock	| resumeContext unwindContext |	resumeContext := processHandle topContext.	(resumeContext == aContext or: [(resumeContext hasSender: aContext) not])		ifTrue: [^aBlock value.].		"Don't do unwind."	processHandle prepareForSimulation.	unwindContext := [self unwind: resumeContext to: aContext] newContext.	unwindContext stepUntilVisibleEffect.	unwindContext sender: resumeContext.	self performDebugOperation:		[self forceResetContext: unwindContext.		"Do the unwind.  We use simulation because if a non-local return		is done by an unwind the sending chain is terminated, whereas		when done by simulation it is not terminated."		self privateSimulateStepIntoBlock.		(currentContext hasSender: aContext)			ifTrue: [finishBlock := aBlock.].		nil].</body><body package="Debugger-Support">finishStep	"Step until reaching the next map entry.  Update code highlight and	inspectors."		| stopPC ctx |	stopPC := self stopPC.	[stopPC == currentContext pc		ifTrue: [true]		ifFalse:			[ctx := currentContext pdpStepUntilPC: stopPC.			ctx == currentContext				ifFalse:					[self resetContext: ctx.					^self finishStep].			stopPC == currentContext pc]]		whileFalse:			[self byteStep.			stopPC := self stopPC].	self schedulePCUpdate.	self scheduleInspectorUpdate</body><body package="Debugger-Support">forceResetContext: aContext 	"Makes aContext the top context.  This differs from #resetContext: because	it forces the source code to be reaquired and it forces the context list to	be regenerated.  This is necessary if the aContext was already the top	context but it was changed in some important aspect."	processHandle topContext: aContext.	self context: aContext.	self scheduleContextListUpdate.</body><body package="Debugger-Support">getContinueInDebugCtx	| ctx |	ctx := continueInDebuggerCtx at: 1.	(ctx isNil | (ctx == 0) or: [(processHandle topContext hasSender: ctx) not])		ifTrue: [continueInDebuggerCtx at: 1 put: (ctx := currentContext)].	^ctx</body><body package="Debugger-Support">homeContext	| ctx |	(ctx := currentContext supposedHome) == nil		ifFalse: [^ctx].	self error: (#BlockHomeNotOnStack &lt;&lt; #pdp &gt;&gt; 'Block''s home context is not on the current process''s stack.').	^currentContext</body><body package="Debugger-Support">homeContextForCutback	^self homeContextForCutbackOf: currentContext</body><body package="Debugger-Support">homeContextForCutbackOf: aContext	| ctx |	((ctx := aContext supposedHome) notNil and: [ctx == aContext or: [aContext hasSender: ctx]])		ifTrue: [^ctx].	self error: (#UnableToRestartHomeNotOnStack &lt;&lt; #pdp &gt;&gt; 'Unable to restart: block''s home context not on the current process''s stack.').	^aContext</body><body package="Debugger-Support">makeContextProceedable	currentContext := currentContext stepUntilProceedable.</body><body package="Debugger-Support">resetContext: aContext 	"Used when a new context becomes top-of-stack, for instance when the	method of the selected context is re-compiled, or the simulator steps or	returns to a new method."	processHandle topContext == aContext		ifTrue: [^self].	processHandle topContext: aContext.	currentContext == aContext 		ifFalse: [self context: aContext].	self scheduleContextListUpdate.</body><body package="Debugger-Support">resumeProcess	oldCursor show.	processHandle topContext: currentContext.	processHandle resumeProcess.</body><body package="Debugger-Support">revertBlock	"If the selected context is a block, then restart from beginning of the block or its home."	| index |	currentContext isBlockContext		ifFalse: [^true].	index := Dialog		choose: (#IWillRestartFromTheBeginningOf &lt;&lt; #pdp &gt;&gt; 'I will restart from the beginning of')		labels: (Array with: (#TheBlock &lt;&lt; #pdp &gt;&gt; 'The Block') with: (#TheMethod &lt;&lt; #pdp &gt;&gt; 'The Method') with: (#Cancel &lt;&lt; #pdp &gt;&gt; 'Cancel'))		values: #(#method #block #cancel)		default: #method		for: self interfaceWindow.	index = #method		ifTrue: [^true].	index = #block		ifTrue: 			[self context: self homeContextForCutback.			 ^true].	^false</body><body package="Debugger-Support">selectContext: aContext 	currentContext == aContext		ifTrue: [^self].	(aContext isNil or: [self isTerminated or: [processHandle topContext == aContext or:		[processHandle topContext hasSender: aContext]]])		ifFalse:			[^tags remove: aContext ifAbsent: []].	self context: aContext.</body><body package="Debugger-Support">unwind: resumeContext to: aContext	[resumeContext unwindUpTo: aContext] ensure:			[resumeContext terminateTo: aContext]</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>private</category><body package="Debugger-Support">basicInstallCompiledMethod: aCompiledMethod	| oldMethod change newMethod |	oldMethod := self selectedMethod.	change := Refactory.Browser.AddMethodChange		compile: aCompiledMethod getSource		in: oldMethod mclass		classified: (oldMethod mclass whichCategoryIncludesSelector: selector).	change tool: self.	change package: (Store.Registry containingPackageForSelector: selector class: oldMethod mclass).	Refactory.Browser.RefactoryChangeManager instance performChange: change.	change definedSelector ifNil: [^nil].	newMethod := oldMethod mclass compiledMethodAt: change definedSelector.	aCompiledMethod isProbed ifTrue: [		aCompiledMethod mclass addSelector: change selector withMethod: aCompiledMethod.		newMethod := aCompiledMethod].	change definedSelector ~~ selector		ifTrue: 			[self spawnBrowserOnMethod: newMethod.			self context: currentContext.	"Reselect current context and refresh display"			self processEvents.			^nil].	PDPManager changedMethodFrom: oldMethod to: newMethod by: self.		self basicMethodChanged: newMethod selector: change selector.	^newMethod -&gt; change selector</body><body package="Debugger-Support">basicResetOnMethodChange: newSelector in: classOfMethod context: aContext	"Get a new compiled method for aContext and cut the execution	stack back to aContext."	| newMethod newContext oldHomeContext savContext |	newMethod := classOfMethod compiledMethodAt: newSelector.	oldHomeContext := self homeContextForCutbackOf: aContext.	self		cutbackTo: oldHomeContext		finishWith:			[self performDebugOperation:				[newContext := oldHomeContext resizedWith: newMethod.				savContext := currentContext.				processHandle interrupted: true.				self forceResetContext: newContext.				(newContext hasSender: savContext)					ifTrue: [self context: savContext].	"restore selected context"				self scheduleTextUpdate.				self resetPCSelection.]].</body><body package="Debugger-Support">findOldestContextUsing: oldMethods	| ctx oldestContext |	ctx := processHandle topContext.	[ctx == nil] whileFalse: 			[ctx isBlockContext				ifFalse: 					[(oldMethods						anySatisfy: [:each | each originalMethod == ctx method originalMethod])							ifTrue: [oldestContext := ctx]].			ctx := ctx sender].	^oldestContext</body><body package="Debugger-Support">finishRequest	self processEvents.	self requestComplete.	serviceProcess := nil.</body><body package="Debugger-Support">performDebugBlockClosure: aBlockClosure	self isTerminated		ifTrue: [^self finishRequest].	serviceProcess :=		[Processor activeProcess debugger: self.		aBlockClosure ensure: [			self finishRequest]] newProcess.	serviceProcess resume</body><body package="Debugger-Support">performDebugOperation: operationBlock	| exp debugBlock finBlock |	"Handle recursive calls, this can get us into trouble if we are not careful."	Processor activeProcess hasActiveDebugOperation		ifTrue: [^operationBlock value].	[currentContext == nil		ifTrue: [^self].	debugBlock :=		[	[	[operationBlock value.]					on: ControlInterrupt , ContextEmergencyError					do: [:ex | self emergencyRestart: ex].			]				on: Error				do: [:ex |					exp := ex. 					self class openOnException: exp].		].	debugOperationIsActive := true.	(processHandle performDebugOperation: debugBlock)		ifFalse:			[debugOperationIsActive := false.			^self scheduleCloseAction].	debugOperationIsActive := false.	finishBlock notNil		ifTrue:			[finBlock := finishBlock.			finishBlock := nil.	"Prevent looping in case block resends this method"			finBlock value].	exp isNil		ifTrue: [^self].	(Dialog confirm: (#SimulationErrorRestartQ &lt;&lt; #pdp &gt;&gt; 'Simulation error. Restart the method?')			for: nil)		ifTrue: [currentContext restart.]		ifFalse: [self class openOnException: exp].	exp := nil.	] repeat.</body><body package="Debugger-Support">performDebugRequest: aSym	self isTerminated		ifTrue: [^self finishRequest].	serviceProcess :=		[Processor activeProcess debugger: self.		self perform: aSym.		self finishRequest] fork.</body><body package="Debugger-Support">performDebugRequest: aSym withArguments: anArray	self isTerminated		ifTrue: [^self finishRequest].	serviceProcess :=		[Processor activeProcess debugger: self.		self perform: aSym withArguments: anArray.		self finishRequest] fork.</body><body package="Debugger-Support">resetOnMethodChange: newSelector in: classOfMethod context: aContext	"Get a new compiled method for aContext and cut the execution	stack back to aContext."	self		performDebugRequest: #basicResetOnMethodChange:in:context:		withArguments: (Array with: newSelector with: classOfMethod with: aContext)</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>probes</category><body package="Debugger-Support">addBreakpointAt: anInterval	| status |	selectionRange := anInterval.	status := self		basicAddProbe: (ProbeCreationSpec							type: #Breakpoint							conditional: false							permanent: self selectedMethod isPartiallyBound &amp; DefaultToPermanentProbe)		using: nil.	status key		ifTrue:			[PDPManager				changedMethodFrom: self selectedMethod				to: self selectedMethod				by: self.			self removePCUpdate]		ifFalse:			[status value notNil				ifTrue: [self scheduleMessage: status value]].	self processEvents.</body><body package="Debugger-Support">addProbeAt: anInterval	| status |	selectionRange := anInterval.	status := self basicAddProbe: nil using: nil.	status key		ifTrue:			[PDPManager				changedMethodFrom: self selectedMethod				to: self selectedMethod				by: self.			self removePCUpdate]		ifFalse:			[status value notNil				ifTrue: [self scheduleMessage: status value]].	self processEvents.</body><body package="Debugger-Support">addStepProbe: aProbe with: aContext	stepProbes add: aProbe -&gt; aContext</body><body package="Debugger-Support">basicAddProbe: aProbeSpec using: aProbeRecord	^DebugProbeInserter addProbe: aProbeSpec using: aProbeRecord for: self</body><body package="Debugger-Support">findSelectedProbeEmphasisIn: aText	^PDPManager findSelectedProbeEmphasisIn: (aText copyFrom: selectionRange first to: selectionRange last + 1)</body><body package="Debugger-Support">modifyProbeAt: anInterval from: aText	| emphasis probedMethod |	selectionRange := anInterval.	probedMethod := self selectedMethod.	probedMethod isProbed		ifFalse: [^self].	emphasis := self findSelectedProbeEmphasisIn: aText.	emphasis isNil		ifTrue: [^self scheduleMessage: (#ReselectBreakpointAndReissue &lt;&lt; #pdp &gt;&gt; 'Reselect breakpoint and reissue command.')].	emphasis value modifyIn: probedMethod.</body><body package="Debugger-Support">probesUpdated: aCompiledMethod	| existingMethod oldProbes newProbes |	existingMethod := self selectedMethod.	existingMethod isProbed ifTrue: [		oldProbes := SortedCollection sortBlock: [:a1 :a2 | a1 insertionPC &gt; a2 insertionPC].		existingMethod allProbesDo: [:p | oldProbes add: p].		oldProbes do: [:aProbe |			(DebugProbeInserter for: self) basicRemoveProbe: aProbe]].		aCompiledMethod isProbed ifTrue: [		newProbes := SortedCollection sortBlock: [:a1 :a2 | a1 insertionPC &gt; a2 insertionPC].		aCompiledMethod allProbesDo: [:p | newProbes add: p].		newProbes do: [:aProbe | (DebugProbeInserter for: self) basicAddProbe: aProbe]].		"The DebugProbeInserter can have installed a different method in to the mclass, so fetch it"	existingMethod := self selectedMethod.	PDPManager changedMethodFrom: existingMethod to: existingMethod by: self.	self resetPCSelection.	self processEvents</body><body package="Debugger-Support">removeAllProbes	"Removes all the probes from the selected method."	| probedMethod allProbes oldOriginal |	probedMethod := self selectedMethod.	probedMethod isProbed		ifFalse: [^self].	allProbes := OrderedCollection new.	probedMethod allProbesDo: [:p | allProbes add: p].	(DebugProbeInserter for: self) removeAllProbes: allProbes from: currentContext.	oldOriginal := (self selectedClass compiledMethodAt: selector) originalMethod.	self selectedClass addSelector: selector withMethod: oldOriginal.	PDPManager		changedMethodFrom: probedMethod		to: oldOriginal		by: self.	self processEvents.</body><body package="Debugger-Support">removeProbeAt: anInterval from: aText	| emphasis probedMethod |	selectionRange := anInterval.	probedMethod := self selectedMethod.	probedMethod isProbed		ifFalse: [^self].	emphasis := self findSelectedProbeEmphasisIn: aText.	emphasis isNil		ifTrue: [^self scheduleMessage: (#ReselectBreakpointAndReissue &lt;&lt; #pdp &gt;&gt; 'Reselect breakpoint and reissue command.')].	(DebugProbeInserter for: self) basicRemoveProbe: emphasis value.	"The following is necessary because apparently the method cache is not completely flushed."	ObjectMemory garbageCollect.	PDPManager			changedMethodFrom: probedMethod			to: probedMethod			by: self.	self resetPCSelection.	self removePCUpdate.	self processEvents.</body><body package="Debugger-Support">removeStepProbes	(DebugProbeInserter for: self) removeStepProbes: stepProbes.	stepProbes := OrderedCollection new.</body><body package="Debugger-Support">tempMethods	^TempMethods</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>testing</category><body package="Debugger-Support">areTextProbeCommandsLegal	^selector notNil</body><body package="Debugger-Support">contextHasHome	^currentContext home notNil</body><body package="Debugger-Support">doesContextHaveInterimValues	^currentContext hasInterimValues</body><body package="Debugger-Support">hasActiveDebugOperation	^debugOperationIsActive</body><body package="Debugger-Support">hasHomeContextStepped	^currentContext home ~~ currentContext or: [(sourceMap at: 1) key &lt; currentContext pc]</body><body package="Debugger-Support">hasLoopControlContext	| ctx |	ctx := continueInDebuggerCtx at: 1.	^ctx notNil and: 		[ctx ~~ 0 and: 		[processHandle topContext == ctx or:			[processHandle topContext hasSender: ctx]]]</body><body package="Debugger-Support">hasSuspendedOperations	| context receiverClass |	context := processHandle topContext.	[context isNil]		whileFalse:			[receiverClass := self _objectClass: context homeReceiver.			((receiverClass includesBehavior: DebuggerService) and: [processHandle isInDebugSession])				ifTrue: [^true].			context := context sender].	^false</body><body package="Debugger-Support">isDebugger	^true</body><body package="Debugger-Support">isFullStack	^contextStackPolicy isFullStack</body><body package="Debugger-Support">isInstalledMethodSourceOutOfSync	| meth inMeth |	meth := self selectedMethod.	inMeth := meth mclass compiledMethodAt: selector ifAbsent: [^false].	^inMeth getSource ~= meth getSource</body><body package="Debugger-Support">isMethodContextSelected	^currentContext home == currentContext</body><body package="Debugger-Support">isProbedMethod	^currentContext method isProbed</body><body package="Debugger-Support">isStoreLoaded	^#{Store.DbRegistry} isDefined</body><body package="Debugger-Support">isTerminated	^processHandle isTerminated</body><body package="Debugger-Support">isTopContextSelected	^currentContext == self interruptedContext</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>context list</category><body package="Debugger-Support">context: aContext 	"Set aContext to be the currently viewed context.  	This involves resetting all the inspectors, the viewed 	source code, and the exception handling signals."	| oldContext |	oldContext := currentContext.	currentContext := aContext.	currentContext == nil		ifTrue:			[self refreshInspectorsFromCurrentContext.			self scheduleTextUpdate.			selector := nil.			^self].	selector := currentContext method isProbed		ifTrue: [currentContext method homeMethod selector]		ifFalse: [currentContext selector].	[(oldContext == nil or: [oldContext method ~~ currentContext method])		ifTrue: [sourceMap := [currentContext sourceMap. "will compute tempNames"]						on: Error						do: [:x | x return: SortedCollection new]].	]		on: Metaclass obsoleteSignal 		do: [:ex | ].	dontUpdateInspectors		ifFalse: [self refreshInspectorsFromCurrentContext].	self scheduleTextUpdate.	self schedulePCUpdate.	currentContext == processHandle topContext		ifFalse: [^self].	currentContext atEnd		ifTrue: [^self].	"The following only has an effect when the context is entered.	It positions the pc just before the first/next executable statement."	currentContext pc = self stopPC		ifTrue: [^self].	self performDebugOperation: [self privateStep].</body><body package="Debugger-Support">refreshInspectorsFromCurrentContext	| receiver |	receiver := currentContext isNil		ifTrue: [nil]		ifFalse: [currentContext intendedReceiver].	(self _object: receiver eqeq: nil)		ifTrue:			[receiverInspector setObject: nil.			receiverInspector empty]		ifFalse: [receiverInspector setObject: receiver].	contextInspector inspect: currentContext.	stackInspector context: currentContext isTop: currentContext == processHandle topContext.	self scheduleResetInspectorFields</body><body package="Debugger-Support">selectContextAt: anIndex	self performDebugRequest: #selectContext: withArguments: (Array with: (contextStackPolicy contextSelectedAt: anIndex)).	self processEvents.</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>tags</category><body package="Debugger-Support">addTag	(tags includes: currentContext)		ifTrue: [^self].	tags add: currentContext.</body><body package="Debugger-Support">hasTags	^tags size &gt; 0</body><body package="Debugger-Support">isCurrentContextTagged	^tags includes: currentContext</body><body package="Debugger-Support">isTagged: aString	tags detect: [:c | c printString = aString] ifNone: [^false].	^true</body><body package="Debugger-Support">removeTag	tags remove: currentContext ifAbsent: []</body><body package="Debugger-Support">selectTag: aString	| ctx |	ctx := tags detect: [:c | c printString = aString] ifNone: [^self].	self selectContext: ctx.	self scheduleContextListSelectionUpdate.	self processEvents.</body><body package="Debugger-Support">tagMenuList	| col |	col := tags asSortedCollection: [:a :b | a hasSender: b].	col := col reject: [:ctx | ctx hasExited].	tags := PDPWeakCollection withAll: col.	^col collect: [:ctx | ctx printString].</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>accessing</category><body package="Debugger-Support">clearDoSend	doSend := false.</body><body package="Debugger-Support">clearDoSendLoop	doSendLoop := false.</body><body package="Debugger-Support">context	"Answer the currently viewed context."	^currentContext</body><body package="Debugger-Support">contextInspector	^contextInspector</body><body package="Debugger-Support">contextList		^contextStackPolicy contextList</body><body package="Debugger-Support">contextListForUI	^contextStackPolicy filteredStack</body><body package="Debugger-Support">indexOfCurrentContext	^contextStackPolicy indexOfCurrentContext</body><body package="Debugger-Support">interfaceWindow	^nil</body><body package="Debugger-Support">interruptedContext	"Answer the suspended context of the interrupted process."	^processHandle topContext</body><body package="Debugger-Support">isSend	^doSend</body><body package="Debugger-Support">isSendLoop	^doSendLoop</body><body package="Debugger-Support">isStepIntoBlock	^doStepIntoBlock</body><body package="Debugger-Support">label	self isTerminated		ifTrue: [^(#TerminatedProcess &lt;&lt; #pdp &gt;&gt; 'Terminated Process') asString].	^label</body><body package="Debugger-Support">label: aString	label := aString</body><body package="Debugger-Support">mayProceed	^true</body><body package="Debugger-Support">pcRange	^CompiledCode nPCMapErrorSignal		handle: [:ex | false -&gt; ex errorString]		do: [true -&gt; self privatePcRange].</body><body package="Debugger-Support">receiverInspector	^receiverInspector</body><body package="Debugger-Support">selectedClass	"Answer the class object that is currently selected."	^ currentContext == nil		ifTrue: [nil]		ifFalse: [currentContext mclass]</body><body package="Debugger-Support">selectedMethod	| ctx |	currentContext isNil		ifTrue: [^nil].	ctx := currentContext supposedHome.	ctx isNil		ifTrue: [^currentContext method homeMethod].	^ctx method</body><body package="Debugger-Support">selectionRange	^selectionRange</body><body package="Debugger-Support">selector	^selector</body><body package="Debugger-Support">setDoSend	doSend := true.</body><body package="Debugger-Support">setDoSendLoop	doSendLoop := true.</body><body package="Debugger-Support">sourceCode	currentContext isNil ifTrue: [^''].	^[currentContext sourceCode]		on: MethodDictionary keyNotFoundSignal		do:  [:ex |			(#noSourceCodeFor1s &lt;&lt; #pdp &gt;&gt; 'no source code for &lt;1s&gt;')			expandMacrosWith: currentContext printString].</body><body package="Debugger-Support">stackFilterPatterns: patternArrays convertSelector: convertSym matchSelector: matchSym displayAllLimit: aNumber	contextStackPolicy patterns: patternArrays.	contextStackPolicy conversionSymbol: convertSym.	contextStackPolicy matchSymbol: matchSym.	contextStackPolicy displayAllLimit: aNumber.</body><body package="Debugger-Support">stackInspector	^stackInspector</body><body package="Debugger-Support">text	| theText meth |	currentContext isNil		ifTrue: [^Text new].	^[theText := currentContext sourceCode asText.	currentContext method homeMethod usuallyHasSelector		ifTrue: [theText makeSelectorBoldIn: currentContext mclass].	(meth := self selectedMethod) isProbed		ifTrue: [meth highlightProbesIn: theText].	theText] 		on: MethodDictionary keyNotFoundSignal		do:  [:ex |			((#noSourceCodeFor1s &lt;&lt; #pdp &gt;&gt; 'no source code for &lt;1s&gt;')			expandMacrosWith: currentContext printString) asText emphasizeAllWith: #italic;				yourself].</body><body package="Debugger-Support">topContext	^processHandle topContext</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>return commands</category><body package="Debugger-Support">evaluateExpressionInReceiver: string	| status object |	status := true.	object := currentContext receiver class evaluatorClass new				evaluate: string				in: currentContext				receiver: currentContext receiver				notifying: nil				ifFail: [status := false].	^status -&gt; object</body><body package="Debugger-Support">returnLastDoIt: rtnMsg	self completeReturn: rtnMsg with: processHandle proceedValue</body><body package="Debugger-Support">returnNewExpr: rtnMsg with: object	self completeReturn: rtnMsg with: object</body><body package="Debugger-Support">returnSelf: rtnMsg	self completeReturn: rtnMsg with: currentContext receiver</body><body package="Debugger-Support">returnTOS: rtnMsg	self completeReturn: rtnMsg with: currentContext top</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>private-reflection protocol</category><body package="Debugger-Support">_object: anObject eqeq: anOtherObject	"Answer true if the arguments are actually the same object."	&lt;primitive: 210&gt;	^self primitiveFailed</body><body package="Debugger-Support">_objectClass: anObject	"Answer the object which is the argument's class.."	&lt;primitive: 211&gt;	^self primitiveFailed</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>private-event processing</category><body package="Debugger-Support">changedLabel	self changed: #windowLabel with: label</body><body package="Debugger-Support">changedPC	| range |	range := self pcRange.	range key		ifFalse: [^self changed: #showMessage with: range value].	self changed: #pcRange with: range.</body><body package="Debugger-Support">closeDebugger	self changed: #closeDebugger</body><body package="Debugger-Support">debuggerSelectedTopContext	self changed: #debuggerSelectedTopContext</body><body package="Debugger-Support">eventOrder	^#(#debuggerSelectedTopContext #changedLabel #updateContextList #updateContextListSelection #updateText #changedPC #resetInspectorFields #updateInspectors #closeDebugger)</body><body package="Debugger-Support">processEvents	self eventOrder do:		[:event |		(pendingEvents remove: event ifAbsent: [nil]) == nil			ifFalse: [self perform: event]].	pendingEvents do: [:ar | self perform: (ar at: 1) with: (ar at:2)].	"Presently, this is for #showMessage only."	pendingEvents := Set new.</body><body package="Debugger-Support">removePCUpdate	pendingEvents remove: #changedPC ifAbsent: []</body><body package="Debugger-Support">requestComplete	self changed: #requestComplete</body><body package="Debugger-Support">scheduleCloseAction	pendingEvents add: #closeDebugger</body><body package="Debugger-Support">scheduleContextListSelectionUpdate	pendingEvents add: #updateContextListSelection.</body><body package="Debugger-Support">scheduleContextListUpdate	pendingEvents add: #updateContextList.</body><body package="Debugger-Support">scheduleInspectorUpdate	pendingEvents add: #updateInspectors</body><body package="Debugger-Support">scheduleLabelUpdate	pendingEvents add: #changedLabel.</body><body package="Debugger-Support">scheduleMessage: aString	pendingEvents add: (Array with: #showMessage: with: aString asString).</body><body package="Debugger-Support">schedulePCUpdate	pendingEvents add: #changedPC</body><body package="Debugger-Support">scheduleResetInspectorFields	pendingEvents add: #resetInspectorFields</body><body package="Debugger-Support">scheduleTextUpdate	pendingEvents add: #updateText.	pendingEvents add: #changedPC</body><body package="Debugger-Support">showMessage: aString	self changed: #showMessage with: aString.</body><body package="Debugger-Support">updateContextList	contextStackPolicy computeContextList.	self changed: #contextList with: self indexOfCurrentContext</body><body package="Debugger-Support">updateContextListSelection	self changed: #contextSelection with: self indexOfCurrentContext</body><body package="Debugger-Support">updateText	self changed: #text</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>private-menu messages</category><body package="Debugger-Support">basicContinue	"Continue execution from the interrupted state of the top context."	currentContext := processHandle topContext.	processHandle interrupted not		ifTrue:			[currentContext pc.			currentContext push: processHandle proceedValue].	self performDebugOperation: [self makeContextProceedable].	self resumeProcess.</body><body package="Debugger-Support">basicFirstLoop	self performDebugOperation: [self privateFirstLoop].</body><body package="Debugger-Support">basicJumpToCaret	"Finds the closest proper point before the caret and causes the context to jump to it,	then completely pops the context stack.  Proper jump points cannot be inside a loop,	or cannot be after loop preperation, and must have a stack depth of 0.  Also, jumps	into or out of blocks are not permitted."	| probeRecord theContext |	self checkContextSelection.	currentContext sourceInfo:		[:nodeHolder :i |		probeRecord := nodeHolder node							jumpRecordFor: selectionRange							blkIndex: currentContext method blockMethodIndex].	probeRecord isNil		ifTrue: [^self scheduleMessage:(#JumpPointIsNotInBlock &lt;&lt; #pdp &gt;&gt; 'Jump point is not in the same block. Try again.')].	currentContext == processHandle topContext		ifFalse:			[(Dialog				confirm: (#TopSendNotSelected &lt;&lt; #pdp &gt;&gt; 'You do not have the top message send selected.Abandon the message sends from the selection up to the top message sendand proceed with the jump operation?')				initialAnswer: false)				ifFalse: [^self]].	currentContext == processHandle topContext		ifTrue: [self performDebugOperation: [self finishJumpToCaretUsing: probeRecord]]		ifFalse:			["Simulate a return from context that has 'context' as its			immediate sender, and unwind all child active sends."			theContext := currentContext.			self				cutbackTo: theContext				finishWith:					[self performDebugOperation:						[theContext push: nil.		"simulate a return value"						processHandle interrupted: true.						self resetContext: theContext.						self finishStep.						self finishJumpToCaretUsing: probeRecord]]].	self schedulePCUpdate.	self scheduleInspectorUpdate.</body><body package="Debugger-Support">basicMakeFullMethod	self performDebugOperation: [self privateMakeFullMethod].</body><body package="Debugger-Support">basicMoreStack	contextStackPolicy moreStack		ifFalse: [^self].	self scheduleContextListUpdate.</body><body package="Debugger-Support">basicNextLoop	self performDebugOperation: [self privateNextLoop].</body><body package="Debugger-Support">basicPause	"Continue execution from the interrupted state of the top context."	currentContext := processHandle topContext.	processHandle interrupted not		ifTrue:			[currentContext pc.			currentContext push: processHandle proceedValue].	self performDebugOperation: [self makeContextProceedable].	processHandle topContext: currentContext.	processHandle pauseProcess.	self scheduleCloseAction.</body><body package="Debugger-Support">basicProceed	"Proceed from the interrupted state of the currently selected context.	Instructions pending execution in methods entered after the selected	context are not executed."	| pushValue theContext |	self checkContextSelection.	pushValue := (currentContext ~= processHandle topContext) | (processHandle interrupted not).	theContext := currentContext.	self		cutbackTo: theContext		finishWith:			[pushValue				ifTrue:					[theContext pc.					theContext push: processHandle proceedValue].			processHandle topContext: theContext.			currentContext := theContext.			self performDebugOperation: [self makeContextProceedable. nil].			self resumeProcess].</body><body package="Debugger-Support">basicReenter	"Reset to the initial state of the currently selected context, i.e. as if the context had just been entered."	| theContext |	self checkContextSelection.	self revertBlock ifFalse: [^self].	theContext := currentContext.	self		cutbackTo: theContext		finishWith:			[self performDebugOperation:				[theContext restart.				processHandle interrupted: true.				self forceResetContext: theContext.				theContext pdpStepUntilPC: self stopPC.				self schedulePCUpdate.				nil]].	processHandle cleanModalWindowChain.</body><body package="Debugger-Support">basicRestart	"Proceed from the initial state of the currently selected context.	The argument is a controller on a view of the receiver.  That view	is closed."	| theContext |	self checkContextSelection.	self revertBlock ifFalse: [^self].	theContext := currentContext.	self		cutbackTo: theContext		finishWith:			[theContext restart.			processHandle interrupted: true.			processHandle topContext: theContext.			currentContext := theContext.			self performDebugOperation:				[self makeContextProceedable.				nil].			processHandle topContext: currentContext.			self resumeProcess].</body><body package="Debugger-Support">basicSelectHomeContext	| ctx |	ctx := currentContext supposedHome.	ctx isNil		ifTrue: [^self scheduleMessage: (#TheHomeContextIsNotOnTheStack &lt;&lt; #pdp &gt;&gt; 'The home context is not on the stack.')].	self context: ctx.	self scheduleContextListSelectionUpdate.	self processEvents.</body><body package="Debugger-Support">basicSend	self performDebugOperation: [self privateSend].</body><body package="Debugger-Support">basicSkipToCaret	self performDebugOperation: [self privateSkipToCaret].</body><body package="Debugger-Support">basicStep	self performDebugOperation: [self privateStep].</body><body package="Debugger-Support">basicStepIntoBlock	self performDebugOperation: [self privateStepIntoBlock].</body><body package="Debugger-Support">finishJumpToCaretUsing: probeRecord	| targetPC |	processHandle prepareForSimulation.	currentContext pc = 1		ifTrue: [self resetContext: currentContext. "In case of restart, set the context to be the top."].	currentContext clearStack.  "This statement must preceed the 'AuxCode...' depth test stmt."	targetPC := probeRecord insertionPC.	"On the surface the following looks incomplete.  However, the obtained targetPC is always	at the beginning of a statement.  The only way the stack depth at the beginning of a statement	cannot be 0 is if it was preceeded by a popPush code."	(targetPC &gt; 1 and: [currentContext isPopPushAt: targetPC - 1])		ifTrue:			[((AuxCodeInfoExtractor on: currentContext method) depthAt: targetPC) ~= currentContext stackP				ifTrue:					[currentContext push: nil.	"push dummy onto stack"					targetPC := targetPC - 1]].	currentContext jump: targetPC - currentContext pc.	currentContext pc = self stopPC		ifFalse: [self privateStep].</body><body package="Debugger-Support">privateFirstLoop	"Sets the controlling context to the selected context and executes continually in the	debugger until an break occurs or the method returns."	self checkContextSelection.	self setLoopControlContext.	self privateNextLoop.</body><body package="Debugger-Support">privateMakeFullMethod	"This method assumes the selected context is a method context.	It cuts back the context stack to the context and replaces	the context's method with a temporary new full probed method."	| tempMethod newMethod newContext theContext |	tempMethod := TempMethods at: currentContext ifAbsent: [].	newMethod := (currentContext method mclass compiledMethodAt: selector) newTempFullProbedMethod.	tempMethod notNil		ifTrue:			[tempMethod allProbesDo:				[:aProbe |				aProbe isTemporary 					ifTrue: [aProbe reinsertInto: newMethod]]].	theContext := currentContext.	self		cutbackTo: theContext		finishWith:			[self performDebugOperation:				[newContext := theContext resizedWith: newMethod.				TempMethods at: newContext put: newMethod.				sourceMap := newContext visibleSourceMap.				processHandle interrupted: true.				self forceResetContext: newContext.				nil]].</body><body package="Debugger-Support">privateNextLoop	"Executes continually in the debugger until an break occurs or the method returns."	| currContext parentContext |	self checkContextSelection.	processHandle prepareForSimulation.	currentContext pc = 1		ifTrue: [self resetContext: currentContext. "In case of restart, set the context to be the top."].	currContext := parentContext := self getContinueInDebugCtx.	currContext == processHandle topContext		ifFalse: [currContext := currContext pdpCompleteCallee: processHandle topContext].	currContext == parentContext		ifTrue: [currContext := currContext stepForever].	currContext == processHandle topContext		ifTrue: [self context: currContext]		ifFalse: [self resetContext: currContext].	self scheduleInspectorUpdate.</body><body package="Debugger-Support">privateRunTillBreak	| localCurrentContext homeContext |	homeContext := currentContext supposedHome.	localCurrentContext := currentContext.		[currentContext == processHandle topContext		ifFalse: 			[localCurrentContext := currentContext						pdpCompleteCallee: processHandle topContext].	localCurrentContext == currentContext		ifTrue: 			[			[localCurrentContext := localCurrentContext stepForever.			processHandle topContext: localCurrentContext.			(localCurrentContext supposedHome == homeContext				and: [localCurrentContext willExitMethod]) not				and: [localCurrentContext hasSender: homeContext]]					whileTrue: 						[localCurrentContext := localCurrentContext									pdpCompleteCallee: localCurrentContext step.						processHandle topContext: localCurrentContext]].	self removeStepProbes]			on: ControlInterrupt , ContextEmergencyError			do: 				[:ex |				ex restartDo: 						[self emergencyRestart: ex.						self removeStepProbes.						self scheduleTextUpdate.						^nil]].	^localCurrentContext</body><body package="Debugger-Support">privateSend	"The top context on the stack must be selected.  This being so, either some message	is about to be sent in that context, or that context is about to return.  Send is only	effective in the former case.  It will cause the next message to be sent.  The send is	actually simulated, so that the debugger will regain control at the beginning of the	method which is invoked (unless it is a primitive).  In this way, you can step your	way deeper into a computation" 	| newCtx  |	self checkContextSelection.	currentContext ~~ processHandle topContext		ifTrue: [^self].	processHandle prepareForSimulation.	newCtx :=  currentContext pdpStepUntilVisibleEffect.	newCtx := newCtx == currentContext		ifTrue: [currentContext send]		ifFalse: [currentContext pdpCompleteCallee: newCtx].	newCtx == currentContext		ifTrue: [^self finishStep].	self resetContext: newCtx.	currentContext pdpStepUntilPC: self stopPC.	self schedulePCUpdate.</body><body package="Debugger-Support">privateSimulateStepIntoBlock	"The top context on the stack must be selected.  Keep sending until a	child block of the selected context's home method is entered." 	| newCtx  |	newCtx := currentContext sendIntoBlockStartingWithCallee: processHandle topContext pdpStepUntilVisibleEffect.	self forceResetContext: newCtx.	self finishStep</body><body package="Debugger-Support">privateSkipToCaret	"Executes and stops at the beginning of a statement that the user 	indicates by a caret. The breakPC is one after the last executed pc."	| localCurrentContext probeRecord breakMethod probe stopPC status |	self checkContextSelection.	processHandle prepareForSimulation.	currentContext pc = 1		ifTrue: 			[self resetContext: currentContext	"In case of restart, set the context to be the top."].	probeRecord := currentContext				sourceInfo: [:nodeHolder :i | nodeHolder node probeRecordFor: selectionRange].	breakMethod := currentContext method homeMethod				blockAt: probeRecord blockMethodIndex.	breakMethod == currentContext method		ifTrue: 			[localCurrentContext := currentContext.			currentContext == processHandle topContext				ifFalse: 					[localCurrentContext := currentContext								pdpCompleteCallee: processHandle topContext.					processHandle topContext: localCurrentContext].			stopPC := probeRecord insertionPC.			localCurrentContext == currentContext				ifTrue: 					[localCurrentContext := localCurrentContext stepUntilSkipPC: stopPC.					processHandle topContext: localCurrentContext]]		ifFalse: 			[breakMethod homeMethod isProbeable				ifFalse: 					[^self scheduleMessage: #CannotInsertProbeIntoThisMethodType &lt;&lt; #pdp								&gt;&gt; 'Sorry, probes cannot be inserted into this method type.'].			status := self						basicAddProbe: (ProbeCreationSpec								type: #Breakpoint								conditional: false								permanent: false) setIsAutoProbe						using: probeRecord.			status key ifFalse: [^self scheduleMessage: status value].			probe := status value.			self addStepProbe: probe with: currentContext supposedHome.			localCurrentContext := self privateRunTillBreak ifNil: [^self]].	self context: localCurrentContext.	self		scheduleContextListUpdate;		scheduleInspectorUpdate</body><body package="Debugger-Support">privateStep	"Step will cause the next message to be sent, or the expression to be 	assigned, or the return to be executed.  In either case, the debugger 	regains control so that you can step your way down through a method, 	and out to the caller when it returns."	self checkContextSelection.	processHandle prepareForSimulation.	currentContext pc = 1		ifTrue:			["In case of restart, set the context to be the top."			self resetContext: currentContext].	currentContext == processHandle topContext		ifTrue: [self byteStep] 		ifFalse: [self resetContext: (currentContext pdpCompleteCallee: processHandle topContext)].	self finishStep.</body><body package="Debugger-Support">privateStepIntoBlock	| closures origMethod |	self checkContextSelection.	processHandle prepareForSimulation.	currentContext pc = 1 		ifTrue: 			[self resetContext: currentContext	"In case of restart, set the context to be the top."].	(currentContext ~~ processHandle topContext 		or: [currentContext supposedHome isNil]) 			ifTrue: [^self privateSimulateStepIntoBlock].	origMethod := currentContext method homeMethod originalMethod.	closures := currentContext messageObjects select: 					[:obj | 					((self _objectClass: obj) includesBehavior: BlockClosure) 						and: [obj method homeMethod originalMethod == origMethod]].	closures do: [:cl | cl changeClassTo: DebugStepIntoBlockClosure].		[| startContext currContext |	doStepIntoBlock := true.	dontUpdateInspectors := true.	startContext := currentContext.	self byteStep.	self finishStep.	currContext := startContext stepToCtxtWithSameParentAs: currentContext.	currContext == currentContext ifFalse: [self resetContext: currContext].	dontUpdateInspectors := false.	self refreshInspectorsFromCurrentContext] 			on: ControlInterrupt , ContextEmergencyError			do: 				[:ex | 				ex restartDo: 						[closures do: [:cl | cl changeClassTo: BlockClosure].						doStepIntoBlock := false.						self emergencyRestart: ex.						dontUpdateInspectors := false.						self refreshInspectorsFromCurrentContext.						self scheduleTextUpdate]].	doStepIntoBlock := false.	closures do: [:cl | cl changeClassTo: BlockClosure]</body><body package="Debugger-Support">setLoopControlContext	^continueInDebuggerCtx at: 1 put: currentContext</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>doIt/accept/explain</category><body package="Debugger-Support">abortDoIt	doItProcess isNil		ifTrue: [^self].	[doItProcess interruptWith:			[Object userInterruptSignal 					interruptWith: thisContext sender sender					errorString: (#OperationAborted &lt;&lt; #pdp &gt;&gt; 'Operation aborted') asString]]		on: Error		do: [:ex | ]	"Ignore error"</body><body package="Debugger-Support">acceptTextFrom: textController	| result |	result := self compileText: textController text from: textController.	result isNil		ifTrue: [^nil].	self methodChanged: result key selector: result value.	^true</body><body package="Debugger-Support">basicMethodChanged: newMethod selector: aSelector	| classOfMethod newContext |	classOfMethod := currentContext mclass.	newContext := self homeContextForCutback.	self		cutbackTo: newContext		finishWith:			[self performDebugOperation:				[newContext := newContext resizedWith: newMethod.				(classOfMethod compiledMethodAt: aSelector) == newMethod					ifFalse: [TempMethods at: newContext put: newMethod].				sourceMap := newContext visibleSourceMap.				processHandle interrupted: true.				self forceResetContext: newContext]].	self scheduleTextUpdate.	self processEvents.	^true</body><body package="Debugger-Support">browseMethod	"Ideally, this should be inlined, left for now to support the Diggy plugin."		self browseSelectedContext</body><body package="Debugger-Support">compileDoItFrom: textController	"Compile the current text selection as an expression and answer	the resulting method. Signal CompilationError if compilation fails."	| compiler strm |	strm := ReadStream		on: textController text asString		from: textController selectionStartIndex		to: textController selectionStopIndex - 1.	compiler := self doItReceiver class evaluatorClass new.	^compiler		compile: strm		in: self doItContext		allowReceiver: true		class: self doItReceiver class		environment: self doItEnvironment		noPattern: true		notifying: textController		ifFail: [CompilationError raise]		handler: (compiler interactiveCompilerErrorHandlerClass new editor: textController)</body><body package="Debugger-Support">compileText: theText from: textController	| oldMethod classOfMethod newSelector newMethod package previousNamespace |	oldMethod := self selectedMethod.	classOfMethod := oldMethod mclass.	package := Store.Registry containingPackageForSelector: oldMethod selector				class: classOfMethod.	previousNamespace := package environmentFor: oldMethod selector				in: classOfMethod.	Store.Policies packagePolicy forcePackage: package		while: 			[newSelector := classOfMethod						compile: theText						classified: nil						notifying: textController						environment: previousNamespace].	newSelector == nil ifTrue: [^nil].	"must fix this, nothing happens"	newMethod := classOfMethod compiledMethodAt: newSelector.	newSelector ~~ selector		ifTrue: 			[self spawnBrowserOnMethod: newMethod.			self context: currentContext.	"Reselect current context and refresh display"			self processEvents.			^nil].	oldMethod isProbed		ifTrue: 			[newMethod := PDPManager reinsertProbesAfterMethod: newMethod						recompileFor: theText].	PDPManager changedMethodFrom: oldMethod to: newMethod by: self.	^newMethod -&gt; newSelector</body><body package="Debugger-Support">debugFrom: textController	| code rcvr proc |	[code := self compileDoItFrom: textController]		on: CompilationError		do: [:ex | ^self].	rcvr := self doItReceiver.	proc := [rcvr performMethod: code with: currentContext.] newProcess.	"The following is executed in another process because the 'send' message will use the	process debugger ivar and in this case we don't want it use the one from the active process."	[| ctx |	ctx := proc suspendedContext.	ctx receiver pushCopiedValues: ctx.	[ctx method == code]		whileFalse: [ctx := ctx send].	proc suspendedContext: ctx.] forkAt: Processor activePriorityPlusOne.	Notifier developmentNotifier		openOnProcess: proc		interrupted: true		label: (#DebugIt &lt;&lt; #pdp &gt;&gt; 'Debug It').</body><body package="Debugger-Support">doItContext	"Answer the context in which a text selection can be evaluated."	^currentContext</body><body package="Debugger-Support">doItEnvironment	"Answer the object that should be informed of the result of evaluating a	text selection."	currentContext == nil ifTrue: [^ nil].	^currentContext method environment</body><body package="Debugger-Support">doItExpectPattern	"Answer if the source code is expected to have a selector pattern, ie: is a method and not a script."	^self selector ~= #unboundMethod and: [self selector ~= #'(initializer)']</body><body package="Debugger-Support">doItReceiver	"Answer the object that should be informed of the result of evaluating a	text selection."	currentContext == nil ifTrue: [^ nil].	^currentContext homeReceiver</body><body package="Debugger-Support">doItReceiverClass	"Answer the class that should be informed of the result of evaluating a	text selection."	currentContext == nil ifTrue: [^nil].	^currentContext mclass</body><body package="Debugger-Support">doItValue: anObject 	"Set the value to be returned when the interrupted process proceeds."	processHandle proceedValue: anObject</body><body package="Debugger-Support">evaluateTextFrom: textController action: aSymbol	| code |	[code := self compileDoItFrom: textController]		on: CompilationError		do: [:ex | ^self requestComplete].	doItProcess :=		[| result |		[result := self doItReceiver performMethod: code with: currentContext.		self doItValue: result.		self changed: #evaluationResult with: (Array with: aSymbol with: result with: textController)]			ensure:				[self requestComplete.				doItProcess := nil]] fork.</body><body package="Debugger-Support">explainFor: aController	"Try to shed some light on what kind of entity the controller's current selection is.	The selection must be a single token or construct."	Explainer		explain: aController selection string		class: self selectedClass		selector: selector		methodText: self text		for: self</body><body package="Debugger-Support">explainSpecial: string for: explainer	"Answer with a string explaining the code view selection if it is 	displaying one of the special edit functions."	^nil</body><body package="Debugger-Support">formatFor: aController 	| theText |	theText := (Refactory.Browser.RBParser parseMethod: aController text				onError: 					[:aString :position | 					^aController 						insertAndSelect: (#x1s &lt;&lt; #pdp &gt;&gt; '&lt;1s&gt; -%&gt;' expandMacrosWith: aString)						at: position]) 					formattedCode.	theText isNil ifTrue: [^nil].	theText := theText asText makeSelectorBoldIn: currentContext mclass.	aController		selectFrom: 1 to: aController text size;		deselect;		replaceSelectionWith: theText asText;		selectAt: 1.	aController view selectionStopIndex: aController text size + 1.	aController view invalidate</body><body package="Debugger-Support">installCompiledMethod: aCompiledMethod	self performDebugRequest: #basicInstallCompiledMethod: withArguments: (Array with: aCompiledMethod)</body><body package="Debugger-Support">methodChanged: newMethod selector: aSelector	self		performDebugRequest: #basicMethodChanged:selector:		withArguments: (Array with: newMethod with: aSelector)</body><body package="Debugger-Support">spawnBrowserOnMethod: aMethod 	Refactory.Browser.RefactoringBrowser 		openOnEnvironment: (Refactory.Browser.SelectorEnvironment 				onMethods: (Array 						with: (Refactory.Browser.RBMethodDefinition class: aMethod mclass								selector: aMethod selector)))</body><body package="Debugger-Support">updateWhile: aBlockClosure	| oldMethod newMethod oldSelector newSelector senderSelector |	oldMethod := self selectedMethod.	oldSelector := selector.	senderSelector := currentContext sender selector.	self performDebugBlockClosure: [		newSelector := aBlockClosure value.		newSelector == nil ifFalse: [			newMethod := oldMethod mclass compiledMethodAt: newSelector.			newMethod ~~ oldMethod ifTrue: [				oldSelector numArgs ~= newSelector numArgs					ifTrue: [						self selectContext: currentContext sender.						self basicResetOnMethodChange: senderSelector in: self selectedClass context: currentContext]					ifFalse: [self basicMethodChanged: newMethod selector: newSelector]]]]</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>must fix</category><body package="Debugger-Support">changedMethodFrom: oldMethod to: newMethod by: aBrowser 	"This message notifies the receiver that the method text for	some method has changed and should be updated."	| oldestContext message answer aSelector aClass |	self isTerminated		ifTrue: [^self].	serviceProcess notNil	"If not nil then we are executing a debug operation."		ifTrue: [^self].	(oldMethod isNil or: [processHandle isInDebugSession not])		ifTrue: [^self].	aSelector := newMethod selector.	aClass := newMethod mclass.	(aBrowser == self and:		[aClass == self selectedClass and:			[aSelector  == self selector]])				ifTrue:					[self scheduleTextUpdate.					^self resetPCSelection].	(oldestContext := self findOldestContextUsing: (Array with: oldMethod originalMethod)) == nil		ifTrue: [^self].	message := (#Method1sInClass2sChangedWhatToDo &lt;&lt; #pdp &gt;&gt; 'The method &lt;1s&gt; in class &lt;2s&gt; has changed, and is in the debugger sender chain.&lt;n&gt;What do you want to do?')		expandMacrosWith: aSelector		with: aClass shortName.	answer := Dialog				choose:  message asParagraph centered				labels: (Array with: (#ExitDebugger &lt;&lt; #pdp &gt;&gt; 'Exit Debugger') with: (#IgnoreChange &lt;&lt; #pdp &gt;&gt; 'Ignore Change') with: (#ResendMessage &lt;&lt; #pdp &gt;&gt; 'Resend Message'))				values: #(0 1 2)				default: 0.	answer = 0		ifTrue: [^self closeDebugger].	self scheduleContextListUpdate.	answer = 2		ifTrue: [self resetOnMethodChange: aSelector in: aClass context: oldestContext].	self processEvents</body><body package="Debugger-Support">makeProbeTyped: probeType using: aProbeRecord at: anInterval method: probedMethod	"Prompts the user to select a probe and returns an Association where the key is the probe	and the value is the conditional flag."	| probe probeRecord |	probeRecord := aProbeRecord isNil		ifTrue: [probedMethod probeRecordFor: anInterval]		ifFalse: [aProbeRecord].	probeType == #Breakpoint		ifTrue: [probe := CodeProbe new].	probeType == #Variable		ifTrue:			[probe := self				promptForProbeVariableClass: self selectedClass				method: probedMethod				record: probeRecord.			probe isNil				ifTrue: [^nil]].	probeType == #Expression		ifTrue: [probe := DisplayActionProbe new].	probe record: probeRecord.	^probe</body><body package="Debugger-Support">promptForProbeVariableClass: aClass method: probedMethod record: probeRecord	"Prompts the user to select a probe and returns an Association where the key is the probe	and the value is the conditional flag."	| legalTempNames legalTemps ivarNames dialog aBuilder ivar tmpVar windoe wVar varType |	windoe := self interfaceWindow.	wVar := ValueHolder newString.	legalTemps := OrderedCollection new.	(probedMethod variableMapAt: probeRecord blockMethodIndex) temps do:		[:var |		(var key first == $. or: [legalTemps contains: [:lvar | lvar key = var key]])			ifFalse: [legalTemps add: var]].	legalTempNames := legalTemps collect: [:ac | ac key].	ivarNames := aClass allInstVarNames.	dialog := SimpleDialog new.	dialog initializeBuilderFor: windoe.	aBuilder := dialog builder.	aBuilder		aspectAt: #TOS		put: [varType := #tos.			wVar value: 'Top of Stack'].	aBuilder		aspectAt: #iVar		put: [ivar := (Menu				labelArray: ivarNames				values: ivarNames) startUp.			ivar ~~ 0				ifTrue:					[wVar value: ivar.					varType := #inst]].	aBuilder		aspectAt: #tVar		put: [tmpVar := (Menu				labelArray: legalTempNames				values: legalTemps) startUp.			tmpVar ~~ 0				ifTrue:					[wVar value: tmpVar key.					varType := #tmp]].	aBuilder		aspectAt: #wVar		put: wVar.	dialog builder add: (UISpecification from: self class watchVarSpec).	dialog initializeWindowFor: windoe.	ivarNames isEmpty		ifTrue: [(aBuilder componentAt: #IvarSwitch) disable].	legalTemps isEmpty		ifTrue: [(aBuilder componentAt: #TempSwitch) disable].	dialog preOpen.	dialog builder openDialogWithExtent: dialog builder window displayBox extent.	dialog accept value		ifFalse: [^nil].	varType == nil		ifTrue: [^nil].	varType == #tos		ifTrue: [^DisplayTOSProbe new].	varType == #inst		ifTrue: [^DisplayInstanceVarProbe name: ivar index: (ivarNames indexOf: ivar)].	^DisplayMethodVarProbe slot: tmpVar</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>debug commands</category><body package="Debugger-Support">abortDebugOperationInProcess: proc	self pauseDebugOperation.</body><body package="Debugger-Support">abortDebuggingFor: aProcess	processHandle process == aProcess		ifFalse: [^self].	self ctrlyAbort.</body><body package="Debugger-Support">continue	self performDebugRequest: #basicContinue.</body><body package="Debugger-Support">ctrlyAbort	self pauseDebugOperation</body><body package="Debugger-Support">firstLoop	self performDebugRequest: #basicFirstLoop.</body><body package="Debugger-Support">jumpToCaretAt: selectionInterval	selectionRange := selectionInterval.	self performDebugRequest: #basicJumpToCaret</body><body package="Debugger-Support">makeFullMethod	self performDebugRequest: #basicMakeFullMethod.</body><body package="Debugger-Support">moreStack	self performDebugRequest: #basicMoreStack.</body><body package="Debugger-Support">nextLoop	self performDebugRequest: #basicNextLoop.</body><body package="Debugger-Support">pause	self performDebugRequest: #basicPause.</body><body package="Debugger-Support">pauseDebugOperation	doItProcess notNil		ifTrue: [^self abortDoIt].	serviceProcess isNil		ifTrue: [^self].	processHandle pauseDebugOperation.</body><body package="Debugger-Support">proceed	self performDebugRequest: #basicProceed.</body><body package="Debugger-Support">reenter	self performDebugRequest: #basicReenter.</body><body package="Debugger-Support">restart	self performDebugRequest: #basicRestart.</body><body package="Debugger-Support">return	self performDebugRequest: #basicReturn.</body><body package="Debugger-Support">selectHomeContext	self performDebugRequest: #basicSelectHomeContext.</body><body package="Debugger-Support">send	self performDebugRequest: #basicSend.</body><body package="Debugger-Support">skipToCaretAt: selectionInterval	selectionRange := selectionInterval.	self performDebugRequest: #basicSkipToCaret.</body><body package="Debugger-Support">step	self performDebugRequest: #basicStep.</body><body package="Debugger-Support">stepIntoBlock	self performDebugRequest: #basicStepIntoBlock.</body><body package="Debugger-Support">terminate	processHandle terminate</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>spelling correction</category><body package="Debugger-Support">basicDefineMethod	| contextSelector |	contextSelector := self context selector.	contextSelector == #doesNotUnderstand: ifTrue:		[^self defineMethodForDoesNotUnderstand].	contextSelector == #subclassResponsibility ifTrue:		[^self defineMethodForSubclassResponsibility].	Dialog warn: (#UnhandledSelectorForDefineIt &lt;&lt; #pdp &gt;&gt; 'Unhandled selector "&lt;1p&gt;" for Define It' expandMacrosWith: contextSelector)</body><body package="Debugger-Support">canCorrectSpelling	"Spelling can be corrected if the context above the selected context is	#doesNotUnderstand and selected context is not sending a special messge and	the selected context is also not #doesNotUnderstand."	| ctx sel |	ctx := self contextFirstSendingDNU.	ctx == self topContext		ifTrue: [^false].	sel := self getSentSelectorFor: ctx.	^(#(#doesNotUnderstand: #perform: #perform:with: #perform:with:with: #perform:with:with:with: #perform:withArguments: #_object:perform:withArguments:)		includes:  sel) not</body><body package="Debugger-Support">canDefineMethod	^#(doesNotUnderstand: subclassResponsibility) includes: self topContext selector</body><body package="Debugger-Support">compileTemplate: aSelector inClass: aClass	| keyWords strm nArg |	keyWords := aSelector keywords.	strm := WriteStream on: (String new: 64).	nArg := 1.	keyWords do: 			[:str |			strm nextPutAll: str.			str last = $:				ifTrue: 					[strm space.					strm nextPutAll: 'arg'.					nArg printOn: strm].			nArg := nArg + 1]		separatedBy: [strm space].	strm		nextPutAll: '	"Dummy method template.  This was installed by the debugger	define method command."	^self halt'.	aClass		compile: strm contents		classified: nil		notifying: nil</body><body package="Debugger-Support">contextFirstSendingDNU	^contextStackPolicy contextList detect: [:ctx | ctx selector ~~ #doesNotUnderstand: ] ifNone: [nil].</body><body package="Debugger-Support">correctDNUWith: guess 	self performDebugRequest: #privateCorrectDNUWith: withArguments: (Array with:guess)</body><body package="Debugger-Support">correctTextWith: guess	| text msgRange nuSelectorStream offset positions tStream start partStart |	text := self text.	msgRange := self pcRange value.	nuSelectorStream := ReadStream on: guess keywords.	offset := msgRange first.	positions := Parser new keywordPositionsIn: (text copyFrom: offset to: msgRange last).	offset := offset - 1.	"because positions are based on 1 we must adjust offset"	tStream := TextStream on: (String new: text size).	start := 1.	positions isNil		ifTrue: [positions := Array with: 1 -&gt; msgRange size].	positions do:		[:ac |		partStart := ac key + offset.		tStream nextPutAllText: (text copyFrom: start to: partStart - 1).		tStream nextPutAllText: nuSelectorStream next asText.		start := partStart + ac value].			" a probe in the selector will get lost."	tStream nextPutAllText: (text copyFrom: start to: text size).	^tStream contents.</body><body package="Debugger-Support">defineMethod	self performDebugRequest: #basicDefineMethod.</body><body package="Debugger-Support">defineMethodForDoesNotUnderstand	| message newContext protocol |	message := self context localAt: 1.	(protocol := self selectProtocolFor: message) isEmpty ifTrue: [^self].	self context homeReceiverClass compile: message methodStubSource classified: protocol.	newContext := MethodContext					sender: self context					receiver: self context receiver					method: (self context homeReceiverClass compiledMethodAt: message selector)					arguments: message arguments.	newContext stepUntilVisibleEffect.	processHandle topContext: newContext.	self selectContext: newContext.	self updateContextList</body><body package="Debugger-Support">defineMethodForSubclassResponsibility	| message contextSendingSubclassResponsibility arguments newContext |	contextSendingSubclassResponsibility := self context sender.	arguments := (1 to: contextSendingSubclassResponsibility method numArgs)					collect: [:i| contextSendingSubclassResponsibility localAt: i].	message := Message					selector: contextSendingSubclassResponsibility method selector					arguments: arguments.	contextSendingSubclassResponsibility homeReceiverClass		compile: message methodStubSource		classified: contextSendingSubclassResponsibility method definition protocol.	newContext := MethodContext					sender: contextSendingSubclassResponsibility sender					receiver: contextSendingSubclassResponsibility receiver					method: (contextSendingSubclassResponsibility homeReceiverClass compiledMethodAt: message selector)					arguments: arguments.	newContext stepUntilVisibleEffect.	processHandle topContext: newContext.	self selectContext: newContext.	self updateContextList</body><body package="Debugger-Support">defineMethodStubAndAdvance	"Define a method body for the message which is not understood in the class of the receiver,	 containing a single self halt statement. Then proceed to the halt."	"nil zork" "nil zork: 1" "nil zork: 1 zork: $1" "nil zork: 1 zork: 1 zork: 1"	| client |	self class clientClass		openFullViewOn: self		label: (#errHalt &lt;&lt; #dialogs &gt;&gt; 'Halt encountered.')		clientInto: [:theClient| client := theClient].	client defineMethod</body><body package="Debugger-Support">dnuSelector	^(processHandle topContext localAt: 1) selector</body><body package="Debugger-Support">existingProtocolsFor: aMessageSelector	"Answer a dictionary mapping protocols to collections of implementors"		| existingImplementors |	existingImplementors := (MethodCollector new implementorsOf: aMessageSelector) select.	^(existingImplementors groupedBy: #protocol)		removeKey: ClassOrganizer defaultProtocol ifAbsent: [];		yourself</body><body package="Debugger-Support">getSentSelectorFor: aContext	"We get the selector this way instead of getting from the message	held by the dnu context because we want the actual message sent.	In the case of a #perform: we want the #perform:, not its argument."	| presendPC pc sel |	presendPC := self presendPCFor: aContext.	pc := aContext pc.	aContext jump: presendPC - pc.	sel := aContext peekForSelector.	aContext jump: pc - presendPC.	^sel</body><body package="Debugger-Support">mostPopularProtocol: aDictionary	aDictionary isEmpty ifTrue: [^String new].	^(aDictionary associations sorted: [:a :b | a value size &gt;= b value size])		first key</body><body package="Debugger-Support">possibleDNUCorrections	| oldSelector oldFirst oldArgs selectors |	oldSelector := self dnuSelector.	oldFirst := oldSelector first.	oldArgs := oldSelector numArgs.	selectors := (self _objectClass: processHandle topContext receiver) allSelectors select: 		[:sel |		sel first = oldFirst and:			[sel numArgs = oldArgs and: 				[(sel spellAgainst: oldSelector) &gt; 10]]].	^selectors</body><body package="Debugger-Support">prepareDNUForResend	| theContext |	theContext := self contextFirstSendingDNU.	theContext restackMessage: (processHandle topContext localAt: 1) to: processHandle topContext receiver.	theContext jump: (self presendPCFor: theContext) - theContext pc.	self forceResetContext: theContext.	processHandle interrupted: true.	^theContext.</body><body package="Debugger-Support">presendPCFor: aContext	"Find the pc before the message send."	| pc i size map |	map := currentContext == aContext		ifTrue: [sourceMap]		ifFalse: [aContext sourceMap].	pc:= aContext pc.	 "When selecting a context in middle of the stack,	the pc points to the byte code after the send."	i := 1. 	size := map size.	[i &lt;= size and: [(map at: i) key &lt; pc]] 		whileTrue: [i := i + 1].	i &gt; 1		ifTrue: [pc := (map at: i - 1) key].	pc := pc - 1.	i := map indexForInserting: (Association key: pc value: nil).	i &lt; 1		ifTrue: [^0].	i &gt; map size		ifTrue: [^0].	^(map at: i) key</body><body package="Debugger-Support">privateCorrectDNUWith: guess	| newText methodAndSelector oldMethod blockIndex method newSourceMap oldSourceMap maxPC pcMap minPC |	self selectContext: self contextFirstSendingDNU.	newText := self correctTextWith: guess.	methodAndSelector := self compileText: newText from: nil.	methodAndSelector isNil ifTrue: [^false].	method := currentContext method.	oldMethod := method homeMethod.	self prepareDNUForResend.	blockIndex := method blockMethodIndex.	newSourceMap := methodAndSelector key sourceMapAt: blockIndex.	oldSourceMap := oldMethod sourceMapAt: blockIndex.	maxPC := (oldSourceMap collect: #pcEnd) fold: [:a :b | a max: b].	minPC := (oldSourceMap collect: #pcStart) fold: [:a :b | a min: b].	pcMap := Dictionary new.	minPC to: maxPC		do: 			[:pc |			(oldSourceMap detect: [:each | each includesPC: pc] ifNone: [nil])				ifNotNil: 					[:entry |					| delta |					delta := (newSourceMap at: (oldSourceMap indexOf: entry)) pcStart - entry pcStart.					pcMap at: pc put: pc + delta]].	(DebugProbeInserter for: self)		adjustDynamicsReplacing: oldMethod		with: methodAndSelector key		from: blockIndex		atPC: currentContext pc		pcMap: pcMap</body><body package="Debugger-Support">promptForProtocolInitial: aString	^(IncrementalSearchDialog		requestProtocol: (#PickProtocol &lt;&lt; #pdp &gt;&gt; 'Specify a protocol for the new method:')		initialAnswer: aString		inClass: self context homeReceiverClass		ifClassNameProvided: [:ignored | ]) ifNil: [String new]</body><body package="Debugger-Support">selectProtocolFor: message	| existingProtocols |	existingProtocols := self existingProtocolsFor: message selector.	existingProtocols size = 1 ifTrue: [^existingProtocols keys any].	^self promptForProtocolInitial: (self mostPopularProtocol: existingProtocols)</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>stack manipulation</category><body package="Debugger-Support">checkContextSelection  	"Determine whether the currently selected context has been set, 	and if not, set it."	currentContext == nil ifTrue: [currentContext := processHandle topContext]</body><body package="Debugger-Support">emergencyRestart: exp 	"Respond to an Context&gt;&gt;emergencySignal arising during simulation."	| aContext anException sender cMClass |	anException := exp.	exp creator == ContextEmergencyError 		ifTrue: [anException := exp parameter].	(ControlInterrupt handles: anException) 		ifTrue: 			[(aContext := anException parameter) isNil 				ifTrue: [aContext := anException initialContext].			label := anException errorString]		ifFalse: 			[aContext := anException initialContext.			label := #UnhandledExceptionC1s &lt;&lt; #pdp &gt;&gt; 'Unhandled exception: &lt;1s&gt;' 						expandMacrosWith: anException errorString].	(StepIntoBlockNotification handles: anException) 		ifTrue: 			[sender := aContext sender.			cMClass := sender mclass.			[sender mclass == cMClass] whileTrue: [sender := sender sender].			aContext sender: sender].	"undo all grabs for event driven"	InputState default ungrabBecauseOfError.	self scheduleLabelUpdate.	processHandle topContext: aContext.	processHandle interrupted: (UserInterrupt , StepIntoBlockNotification 				handles: anException).	self context: aContext.	self scheduleContextListUpdate.	(StepIntoBlockNotification handles: anException) 		ifFalse: 			[anException initialContext == aContext 				ifFalse: [anException initialContext unwindUpTo: aContext]].	currentContext pc = self stopPC ifTrue: [^self].	self step</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>actions</category><body package="Debugger-Support">browseClass	"Ideally, this should be inlined, left for now to support the Diggy plugin."		self browseSelectedContext</body><body package="Debugger-Support">browseSelectedContext	"Open a browser on the current receiver object. Select the method. If we find that the method is further up the heirarhcy, but not in object, select that class (doing so after the fact leaves the hierarchy receiver centered) and the method there."		| state receiverClass browser implementingClass |	state := Refactory.Browser.NavigatorState new.	receiverClass := currentContext _objectClass: currentContext homeReceiver.	state classOrNameSpace: receiverClass.	state selector: self selectedMethod selector.	browser := Refactory.Browser.RefactoringBrowser		openHierarchyWithSelection: state.	implementingClass := self selectedMethod mclass.	(implementingClass ~= receiverClass		and:			[implementingClass ~= Object				or:					[(Store.Registry						containingPackageForSelector: self selectedMethod selector						class: Object) ~= (Store.Registry containingPackageForClass: Object)]])		ifTrue:			[(browser navigator)				selectClass: implementingClass;				setSelector: self selectedMethod selector]</body><body package="Debugger-Support">correctSpelling	"Attempt to correct the spelling of the not-understood message and resend."	| oldSelector oldFirst oldArgs selectors guess   msg |	processHandle topContext selector == #doesNotUnderstand:		ifFalse: [^self].	msg := processHandle topContext localAt: 1.	oldSelector := msg selector.	oldFirst := oldSelector first.	oldArgs := oldSelector numArgs.	selectors := (self _objectClass: processHandle topContext receiver) allSelectors select: 		[:sel | sel first = oldFirst and: [sel numArgs = oldArgs and: 				[(sel spellAgainst: oldSelector) &gt; 10]]].	selectors isEmpty ifTrue: [^Dialog warn: (#CouldntCorrect &lt;&lt; #pdp &gt;&gt; 'Couldn''t correct')].	selectors := selectors asArray.	guess := Dialog				choose: (#CorrectToDots &lt;&lt; #pdp &gt;&gt; 'Correct to...')				fromList: selectors				values: selectors				lines: 8				cancel: [^'']				for: nil.	(Dialog confirm: ((#RetryWithSelectorCnt1s &lt;&lt; #pdp &gt;&gt; 'Retry with Selector:&lt;nt&gt;&lt;1s&gt;')			expandMacrosWith: guess) for: nil)		ifFalse: [^self].	msg setSelector: guess arguments: msg arguments.	^self basicProceed</body><body package="Debugger-Support">inspectCurrentContext	currentContext inspect</body><body package="Debugger-Support">revert	| mclass oldMethod newMethod |	mclass := self selectedClass.	selector isNil | mclass isNil ifTrue: [^false].	^#{Store.DbRegistry} ifDefinedDo: 			[:dbRegistry |			dbRegistry doIfOnlineImage: 					[oldMethod := self selectedMethod.					(Store.XChangeSet current revertSelector: selector class: mclass)						ifFalse: [^false].					newMethod := mclass compiledMethodAt: selector.					PDPManager changedMethodFrom: oldMethod to: newMethod by: self.					self methodChanged: newMethod selector: selector].			true]		elseDo: [false]</body><body package="Debugger-Support">stackForCopy	| cp |	cp := ContextDumpPolicy new.	cp stack: contextStackPolicy contextList.	cp errorMessage: label.	^cp copyStackString</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>private-inspectors</category><body package="Debugger-Support">openInspectors	"Further initialization when opening notify view to debug view"	receiverInspector := PrimitiveObjectInspector inspect: nil.	contextInspector := ContextInspector inspect: nil.	stackInspector := StackInspector inspect: nil.</body><body package="Debugger-Support">resetInspectorFields	receiverInspector resetFieldsForDebugger.	contextInspector resetFields.	stackInspector resetFields.</body><body package="Debugger-Support">updateInspectors	receiverInspector update.	contextInspector update.	stackInspector updateAsTop: currentContext == processHandle topContext.</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>private-pc selection</category><body package="Debugger-Support">privatePcRange	"Answer the indices in the source code for the method corresponding	to the selected context's program counter value."	| pc i size end |	self context == nil		ifTrue: [^1 to: 0].	(sourceMap == nil or: [sourceMap size = 0])		 ifTrue: [^1 to: 0].	pc:= self context pc.	(self context == processHandle topContext and: [processHandle interrupted])		ifFalse: "When selecting a context in middle of the stack or the context 'halt',				the pc points to the byte code after the send."			[i := 1. 			size := sourceMap size.			[i &lt;= size and: [(sourceMap at: i) key &lt; pc]] 				whileTrue: [i := i + 1].			i &gt; 1 ifTrue: [pc := (sourceMap at: i - 1) key]].	pc := pc - 1.	i := sourceMap indexForInserting: (Association key: pc value: nil).	i &lt; 1 ifTrue: [^1 to: 0].	i &gt; sourceMap size		ifTrue:			[end := sourceMap inject: 0 into:				[:prev :this | prev max: this value last].			^ end+1 to: end].	^(sourceMap at: i) value</body><body package="Debugger-Support">resetPCSelection	sourceMap := currentContext visibleSourceMap.	self schedulePCUpdate.</body><body package="Debugger-Support">stopPC	"Returns the next pc in the map."	| i |	i := sourceMap indexForInserting: (currentContext pc - 1) -&gt; nil.	^(i &gt; sourceMap size		ifTrue: [currentContext method bytesSize]		ifFalse: [(sourceMap at: i) key])</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>initialize-release</category><body package="Debugger-Support">basicPrepareTopContext	self context: processHandle topContext.	pendingEvents add: #debuggerSelectedTopContext.</body><body package="Debugger-Support">initialize	pendingEvents := Set new.	continueInDebuggerCtx := WeakArray new: 1.	tags := PDPWeakCollection new.	stepProbes := OrderedCollection new.	debugOperationIsActive := doSend := doSendLoop := doStepIntoBlock := dontUpdateInspectors := false.	contextStackPolicy := ContextListPolicy debugger: self.	self openInspectors.	PDPManager notifyOnMethodChanged: self.</body><body package="Debugger-Support">onHandle: aProcessHandle	processHandle := aProcessHandle.	processHandle process debugger: self.	oldCursor := Cursor currentCursor.	contextStackPolicy computeContextList.</body><body package="Debugger-Support">prepareForErrorCondition	processHandle prepareForErrorCondition</body><body package="Debugger-Support">prepareTopContext	self performDebugRequest: #basicPrepareTopContext.</body><body package="Debugger-Support">process: aProcess context: aContext interrupted: aBoolean	self onHandle: (ProcessHandle on: aProcess at: aContext interrupted: aBoolean)</body><body package="Debugger-Support">process: aProcess context: aContext interrupted: aBoolean proceedable: proceedBoolean	self onHandle: (ProcessHandle on: aProcess at: aContext interrupted: aBoolean)</body><body package="Debugger-Support">removeAllDependents	dependents := nil.</body><body package="Debugger-Support">removeDependent: aDependent 	super removeDependent: aDependent.	self dependents isEmpty ifTrue: [processHandle terminate]</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService</class-id> <category>private-return</category><body package="Debugger-Support">basicCompleteReturn: rtnMsg with: rtnValue	| theContext currContext |	theContext := currentContext.	self		cutbackTo: theContext		finishWith:			[self performDebugOperation:				[processHandle interrupted: true.				currContext := theContext pdpCompleteCallee: (theContext perform: rtnMsg with: rtnValue).				self forceResetContext: currContext.				self finishStep.				nil]].</body><body package="Debugger-Support">completeReturn: rtnMsg with: rtnValue	self performDebugRequest: #basicCompleteReturn:with: withArguments: (Array with: rtnMsg with: rtnValue)</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService class</class-id> <category>instance creation</category><body package="Debugger-Support">breakOn: anException	"NOTICE:	This method assumes that the process is cut back and will require	a return object to be pushed on the stack."	self openOn: anException parameter exception: anException interrupted: false."Smalltalk Professional Debug Package Version 3.0 (c) 2001 Crafted Smalltalk"</body><body package="Debugger-Support">context: aContext proceedable: aBoolean interrupted: interrupted	| aDebugger |	aDebugger := self new.	aDebugger		process: Processor activeProcess		context: aContext		interrupted: interrupted.	^aDebugger</body><body package="Debugger-Support">interruptOn: anException	"NOTICE:	This method assumes that the process is NOT cut back and will	NOT require a return object to be pushed on the stack."	self openOn: anException parameter exception: anException interrupted: true"Smalltalk Professional Debug Package Version 3.0 (c) 2001 Crafted Smalltalk"</body><body package="Debugger-Support">new	^super new initialize"Smalltalk Professional Debug Package Version 3.0 (c) 2001 Crafted Smalltalk"</body><body package="Debugger-Support">openOnProcess: aProcess interrupted: aBoolean label: aString	^self		openOnHandle:			(ProcessHandle				on: aProcess				interrupted: aBoolean)		label: aString"Smalltalk Professional Debug Package Version 3.0 (c) 2001 Crafted Smalltalk"</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService class</class-id> <category>private</category><body package="Debugger-Support">enableWindowsIfNotEventFaithfulFor: aProcess	EventFaithfulDebugging ifTrue: [^self].	aProcess windowManager ifNotNil: [:value | value launchBaseProcess].</body><body package="Debugger-Support">resyncEvents	EventQueue allInstancesDo: [:each | each restoreReadSynchSignals].</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService class</class-id> <category>class initialization</category><body package="Debugger-Support">initialize	"self initialize"	ClientClass := DebuggerClient2.	TempMethods := PDPWeakDictionary weakKeys.	EventFaithfulDebugging := false.	DefaultToPermanentProbe := true.</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService class</class-id> <category>instance creation - compatibility</category><body package="Debugger-Support">dumpStackForContext: haltContext label: aString proceedable: aBoolean interrupted: interrupted	| dbr |	thisContext unwindDebuggerSupportUpTo: haltContext.	dbr := self context: haltContext proceedable: aBoolean interrupted: interrupted.	dbr label: aString.	^dbr stackForCopy.</body><body package="Debugger-Support">getDisplayPoint	| windowManager |	windowManager:= Processor activeProcess environmentAt: #WindowManager.	^[(windowManager isNil or: [windowManager activeController isNil])		ifTrue: [Screen default bounds center]		ifFalse: [windowManager activeController view displayBox center]]			on: Error			do: [:exception | exception return: Screen default bounds center]</body><body package="Debugger-Support">openContext: haltContext label: aString proceedable: aBoolean	"Create and schedule an instance of me viewing a Debugger on haltContext.	The view will be labeled with aString, and will show a short sender stack."	self openContext: haltContext label: aString proceedable: aBoolean interrupted: false</body><body package="Debugger-Support">openContext: haltContext label: aString proceedable: aBoolean interrupted: interrupted	"Create and schedule an instance of me viewing a Debugger on haltContext.	The view will be labeled with aString, and will show a short sender stack."	| displayPoint contentsString dbr |	self prepareForDebugging.	contentsString := self shortStackFor: haltContext ofSize: 5.	displayPoint := self getDisplayPoint.	thisContext unwindDebuggerSupportUpTo: haltContext.	dbr := self context: haltContext proceedable: aBoolean interrupted: interrupted.	Processor activeProcess		suspendResumable: false		do: [:proc |			self openDebugger: dbr				contents: contentsString				label: aString				proceed: aBoolean				displayAt: displayPoint.			self enableWindowsIfNotEventFaithfulFor: proc].</body><body package="Debugger-Support">openDebugger: aDebugger contents: aString1 label: aString2 proceed: mayProceed displayAt: aPoint	self prepareForDebugging.	Processor activeProcess priority: Processor userSchedulingPriority.	self logErrorFor: aDebugger label: aString2.	aDebugger prepareForErrorCondition.	aDebugger label: aString2.	self clientClass openFullViewOn: aDebugger label: aString2</body><body package="Debugger-Support">openException: exception	exception ifUnhandledOpenDebugger		ifTrue: [self openOnException: exception]		ifFalse: [self			openContext: exception parameter			label: exception errorString			proceedable: exception willProceed			interrupted: exception isInterrupt]</body><body package="Debugger-Support">prepareForDebugging	"undo all grabs for event driven and	Make sure that controllers without views are removed"	| manager |	InputState default ungrabBecauseOfError.	manager := self activeWindowManager.	manager ifNotNil: [manager purgeInvalidWindows].</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService class</class-id> <category>private - instance creation</category><body package="Debugger-Support">debugException: anException	self openOnException: anException</body><body package="Debugger-Support">onHandle: aProcessHandle	^self new onHandle: aProcessHandle"Smalltalk Professional Debug Package Version 1.6 (c) 1998 Crafted Smalltalk"</body><body package="Debugger-Support">openOn: aContext exception: anException interrupted: aBoolean	| service |	self prepareForDebugging.	thisContext unwindDebuggerSupportUpTo: aContext.	service := self context: aContext proceedable: true interrupted: aBoolean.	service prepareForErrorCondition.	service label: anException description.	Processor activeProcess		suspendResumable: false		do: [:proc |			self clientClass openFullViewOn: service label: anException description.			self enableWindowsIfNotEventFaithfulFor: proc]</body><body package="Debugger-Support">openOnException: anException	self openOn: anException topOfContextStack		exception: anException		interrupted: anException isInterrupt</body><body package="Debugger-Support">openOnHandle: aProcessHandle label: aString	| service |	self prepareForDebugging.	service := self onHandle: aProcessHandle.	service label: aString.	service prepareForErrorCondition.	^self clientClass openFullViewOn: service label: aString</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService class</class-id> <category>utility</category><body package="Debugger-Support">activeWindowManager	^Processor activeProcess environment at: #WindowManager ifAbsent: [nil]</body><body package="Debugger-Support">getActiveUserProcess	"Returns the highest priority user process waiting to run."	Processor runableProcesses do:		[:p |		p isSystemProcess not			ifTrue: [^p]].	^nil</body><body package="Debugger-Support">getCurrentWindowProcess	Window currentWindow isNil		ifTrue: [^nil].	^Window currentWindow windowProcess</body><body package="Debugger-Support">interruptAllUserProcesses	| interruptor |	interruptor :=		[Processor pauseUserProcesses.		[InputState default ungrabBecauseOfError.		WindowManager beEffectivelyModeless.		ProcessMonitorService open] forkAt: Processor userSchedulingPriority.]		newProcess.	interruptor setIsSystemProcess.	interruptor resume</body><body package="Debugger-Support">interruptAllUserProcessesSuchThat: aBlock with: aStringUserMessage 	| interruptor |	interruptor := 			[Processor pauseUserProcessesSuchThat: aBlock.						[| procMonitor |			InputState default ungrabBecauseOfError.			WindowManager beEffectivelyModeless.						[procMonitor := ProcessMonitorService open window.			procMonitor 				label: procMonitor label asString , ' ' , aStringUserMessage asString] 					on: MessageNotUnderstood					do: 						[:ex | 						EventQueue allInstancesDo: [:each | each restoreReadSynchSignals].						Processor proceedUserProcesses.						Processor interruptAllUserProcessesSuchThat: aBlock with: aStringUserMessage. 						ex return]] 					forkAt: Processor userSchedulingPriority] 					newProcess.	interruptor setIsSystemProcess.	interruptor resume	"DebuggerService interruptAllUserProcessesSuchThat:[:p| true] with: 'yo!'"</body><body package="Debugger-Support">limitString: string lengthTo: maxLen andLinesTo: maxLines	| outStr inStr done lineCnt charCnt char str |	str := string asString.	outStr := WriteStream on: (String new: str size).	inStr := ReadStream on: str.	done := false.	lineCnt := charCnt := 0.	[done or: [inStr atEnd]]		whileFalse:			[char := inStr next.			char = Character cr				ifTrue:					[lineCnt := lineCnt + 1.					done := lineCnt = maxLines].			done				ifFalse:					[outStr nextPut: char.					charCnt := charCnt + 1.					done := charCnt = maxLen]].	done		ifTrue: [outStr nextPutAll: '...'].	^outStr contents</body><body package="Debugger-Support">logErrorFor: aDebugger label: label	"Log the error to a file in case the notifier can't come up."	"If you want to enable logging of notifiers, change the first 'false'	to 'true', which will cause logging to be enabled.  Then edit the	file name (the default is 'visual.err') to whatever file you want to	write the logs to.  Make sure that the file is writable, and that	there is enough disk space.  If there is any error writing the log	file, the error will be silently ignored--otherwise the system would	go into infinite recursion and run out of memory."	| end printSymbol |	false		ifFalse: [^self].	end := 10.	"Number of stack items to be dumped.  Set to nil to dump full stack.""	printSymbol := #printSimple."	printSymbol := #printVerbose. 	[| file cp |	file := 'visual.err' asFilename appendStream.	[file cr; cr.	cp := ContextDumpPolicy new initialize.	cp stream: file.	cp errorMessage: label.	cp stack: aDebugger contextList	.	cp numberToDump: end.	cp perform: printSymbol.	file cr]		ensure: [file close]	]		on: Object errorSignal		do: [:ex | ex inspect. ex return].</body><body package="Debugger-Support">shortStackFor: aContext ofSize: anInteger	"Answer a string with the simple descriptions of anInteger number of	non-nil stackframes starting with aContext"	| shortStackStream ctx |	shortStackStream := WriteStream on: (String new: 400).	ctx := aContext.	anInteger timesRepeat: 		[ctx isNil ifFalse:			[shortStackStream nextPutAll: (ctx printString contractTo: 50); cr.			ctx := ctx sender]].	shortStackStream position &gt; 0 ifTrue: [shortStackStream skip: -1].	^shortStackStream contents</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService class</class-id> <category>utilitiy</category><body package="Debugger-Support">interruptActiveUserProcess	| proc |	proc := self getActiveUserProcess.	proc isNil		ifTrue: [proc := self getCurrentWindowProcess].	proc isNil		ifTrue: [^self interruptAllUserProcesses].	proc isUnderDebug		ifTrue: [^proc debugger abortDebugOperationInProcess: proc].	proc interruptWith:		[Object userInterruptSignal			interruptWith: thisContext sender sender			errorString: (#UserInterrupt &lt;&lt; #pdp &gt;&gt; 'User Interrupt')]</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService class</class-id> <category>defaults</category><body package="Debugger-Support">clientClass	"Instances of this class are the application models created	when the service receives a request to open a debugger.	DebuggerClient2 is the default debugger application.	Subclasses may redefine this to substitute their applications."	^ClientClass ifNil: [DebuggerClient2]</body></methods><methods><class-id>Core.RunArray</class-id> <category>accessing</category><body package="Debugger-Support">remove: aValue	| index val end |	cacheRun := cacheRunStart := 1.  "Clear cache"	index := 1.	end := values size.	[index &gt; end or: [(val := values at: index) = aValue]]		whileFalse:			[val class == Array				ifTrue:					[(val indexOf: aValue) = 0						ifFalse:							[val size = 1								ifTrue:									[values at: index put: aValue.									index := index -1]								ifFalse: [^values at: index put: (val copyWithout: aValue)]]].			index := index + 1].	(values at: index) == aValue		ifFalse: [^self].	values at: index put: nil.</body></methods><methods><class-id>Kernel.CompiledBlock</class-id> <category>accessing</category><body package="Debugger-Support">blockMethodIndex	"Returns the block method index of the receiver."	| index |	index := 1.	self homeMethod withAllBlockMethodsDo:		[:meth |		meth = self ifTrue: [^index].		index := index + 1]</body></methods><methods><class-id>Kernel.CompiledBlock</class-id> <category>testing</category><body package="Debugger-Support">isFullBlock	"Returns true if the receiver is used in a full closure."	^outerMethod createsFullBlockFor: self</body><body package="Debugger-Support">isFullBlockChain	"Returns true if all the blocks from the receiver to the compiled method	are used in full block closures."	^self isFullBlock and: [outerMethod isFullBlockChain]</body></methods><methods><class-id>Kernel.CompiledBlock</class-id> <category>accessing</category><body package="Debugger-Support">nesting	^outerMethod nesting + 1</body></methods><methods><class-id>Kernel.CompiledMainBlock</class-id> <category>accessing</category><body package="Debugger-Support">nesting	^0</body><body package="Debugger-Support">originalMethod	^self</body></methods><methods><class-id>Kernel.Parser</class-id> <category>private</category><body package="Debugger-Support">keywordPositions	"This method expects the first token to be the first part of a keyword message.	It also expects the last part to be followed by a variable or expression."	| keywordPositions |	tokenType == #keyword		ifFalse: [^nil].	keywordPositions := Array with: mark -&gt; token size.	[self scanToken.	self primaryExpression		ifFalse: [^nil].	"this could return keywordPositions, but nil may catch errors"	self messagePart: 2 repeat: true.	tokenType == #keyword]		whileTrue:			[keywordPositions := keywordPositions copyWith: mark -&gt; token size].	^keywordPositions</body></methods><methods><class-id>Kernel.Parser</class-id> <category>public access</category><body package="Debugger-Support">keywordPositionsIn: aString	| failure |	failure := [^self error: (#UnexpectedError &lt;&lt; #pdp &gt;&gt; 'Unexpected error')].	self		init: aString readStream		notifying: (SilentCompilerErrorHandler new failBlock: failure)		saveComments: false		failBlock: failure.	builder := ProgramNodeBuilder new.	^self keywordPositions</body><body package="Debugger-Support">parseSelector: aString notifying: aController	"Answer with the selector for this method string"	| handler |	handler := InteractiveCompilerErrorHandler new.	^handler		forClass: Object		on: (ReadStream on: aString asString)		for: aController		onFailDo: [^nil]		do: [:src |			self				initPattern: src contents				notifying: handler				saveComments: false				return: [:pattern | pattern at: 1]]</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - pdp</category><body package="Debugger-Support">toggleDebuggingLabel	^PDPManager getEnableProbeDebuggingLabel</body></methods><methods><class-id>Core.Object</class-id> <category>copying</category><body package="Debugger-Support">basicDcopyUsing: copyDict	"Basic deep copy operation."	^copyDict		at: self		ifAbsent:			[(copyDict at: self put: self shallowCopy)				postDcopyUsing: copyDict;				yourself]</body><body package="Debugger-Support">basicMethodDcopy	"Ignore."	^self</body><body package="Debugger-Support">basicMethodDcopyUsing: copyDict	"In general don't copy.  Subclasses that do need to copy will override."	^self</body></methods><methods><class-id>Core.Object</class-id> <category>error handling</category><body package="Debugger-Support">breakOn: aContext label: aString	"This is a simple message to use for inserting breakpoints during debugging.	The debugger is opened by raising a signal."	BreakInterrupt		raiseRequestWith: aContext		errorString: aString</body></methods><methods><class-id>Core.Object</class-id> <category>copying</category><body package="Debugger-Support">dcopy	"Answer a deep copy of the receiver.  References to shared	objects in the graph reachable from the receiver are preserved.	 This deep copy is used to implement breakpoints in the debugger.	 It may be suitable for other uses, but be careful changing its semantics	 as doing so may break the debugger."	^self basicDcopyUsing: IdentityDictionary new</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="Debugger-Support">debugString	^self printString</body><body package="Debugger-Support">forStackDumpPrintUsing: aPolicy	^aPolicy printObject: self</body><body package="Debugger-Support">inspectString	^self debugString</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Debugger-Support">isBlockContext	^false</body><body package="Debugger-Support">isCharStyleCacheable	^true</body></methods><methods><class-id>Core.Object</class-id> <category>copying</category><body package="Debugger-Support">postDcopyUsing: copyDict	"Complete the deep copy operation."	| class |	class := self class.	class isVariable ifTrue:		[1 to: self basicSize do: [ :i | self basicAt: i put: ((self basicAt: i) basicDcopyUsing: copyDict)]].	1 to: class instSize do: [ :i | self instVarAt: i put: ((self instVarAt: i) basicDcopyUsing: copyDict)]</body></methods><methods><class-id>Kernel.Context</class-id> <category>private-debugger</category><body package="Debugger-Support">clearStack	stackp :=  self initialStackDepthForProbes.</body></methods><methods><class-id>Kernel.Context</class-id> <category>accessing-debugger</category><body package="Debugger-Support">findParentContextWithHomeMethod: aMethod	| ctx |	ctx := self.	[ctx == nil]		whileFalse: 			[ctx method homeMethod originalMethod == aMethod ifTrue: [^ctx].			ctx := ctx sender].	^nil</body><body package="Debugger-Support">getTempVar: aVar	"Answer the argument or temporary value of the variable."		#{SeasideDynamicVariable}		ifDefinedDo: [:class | (aVar isKindOf: class) ifTrue: [^aVar binding]].	self		nestingAt: self nesting - aVar nesting		do: [:ctx | ^ctx slotAt: aVar debuggerIndex].	self error: #IndexIsOutOfRange &lt;&lt; #pdp &gt;&gt; 'Index is out of range'</body><body package="Debugger-Support">growBy: aNumber	| newStk |	newStk := Array new: aNumber abs + self localSize.	1 to: self localSize do: [:i | newStk at: i put: (self localAt: i)].	self		instVarAt: 6		put: newStk.</body></methods><methods><class-id>Kernel.Context</class-id> <category>testing</category><body package="Debugger-Support">hasExited	^sender isNil and: [self atEnd]</body><body package="Debugger-Support">hasInterimValues	^stackp &gt; method numLocals</body></methods><methods><class-id>Kernel.Context</class-id> <category>accessing</category><body package="Debugger-Support">homeReceiverClass	^(self _objectClass: self homeReceiver)</body></methods><methods><class-id>Kernel.Context</class-id> <category>private-debugger</category><body package="Debugger-Support">initialStackDepthForProbes	^method numTemps.</body></methods><methods><class-id>Kernel.Context</class-id> <category>accessing-debugger</category><body package="Debugger-Support">intendedReceiver	"Answer the receiver to which the home method was sent."	^self subclassResponsibility</body></methods><methods><class-id>Kernel.Context</class-id> <category>private-simulation</category><body package="Debugger-Support">isSendLoop	^Processor activeProcess isDebugSendLoop</body></methods><methods><class-id>Kernel.Context</class-id> <category>accessing-debugger</category><body package="Debugger-Support">messageObjects	| count objects |	objects := OrderedCollection new.	self pdpWillSend		ifFalse: [^objects].	count := self peekForSelector numArgs.	self sendsAdd1		ifTrue: [count := count - 1].	self hasReceiverOnStackForSend		ifFalse:			[objects add: receiver.			count := count - 1].	"no receiver on stack"	0 to: count do: [:i | objects add: (self localAt: stackp - i)].	^objects</body><body package="Debugger-Support">nesting	^method nesting</body></methods><methods><class-id>Kernel.Context</class-id> <category>private-simulation</category><body package="Debugger-Support">onlySlowSendsForClass: rclass selector: selector	"Don't simulate calls on error:."	(rclass includesBehavior: Process)		ifTrue: [^selector == #primTerminate].	(rclass includesBehavior: GenericException)		ifTrue: [^selector ~~ #aboutToDebug].	(rclass includesBehavior: Context)		ifTrue: [^#(#nonlocalReturn:through: #evaluateUnwind #resumeWith:) includes: selector].	^#(#evaluateUnwindBlockFor: #valueAsUnwindBlockFrom:) includes: selector</body></methods><methods><class-id>Kernel.Context</class-id> <category>simulation-debugger</category><body package="Debugger-Support">pdpCompleteCallee: aContext	"Simulate the execution of bytecodes until a return to the receiver,	or until a return to a non-context in case of block up arrow return."	| currentContext previousContext |	self == aContext ifTrue: [^self].	currentContext := aContext.	previousContext := nil.		[[currentContext == previousContext or: [(currentContext isKindOf: Context) and: [currentContext hasSender: self]]] whileTrue: 			[previousContext := currentContext.			currentContext := currentContext step]]			on: GetBaseContextForException			do: [:ex | ex proceedWith: self].	"check for handler context"	(currentContext isMemberOf: Array) ifTrue: [currentContext := currentContext at: 1].	^currentContext</body></methods><methods><class-id>Kernel.Context</class-id> <category>accessing-debugger</category><body package="Debugger-Support">pdpSlotAccessors	"Answer an OrderedCollection of the name strings of the temporary 	variables for this context and all its enclosing scopes. Note that this 	does not include compiler-generated temporary variables."	| slots |	slots := OrderedCollection new.	self localScope temps do:		[:var | | name |		(var key first = $.)			ifFalse:				[name := var key.				var value class == LocalVariable					ifTrue: [name := '.' , name].				slots add: (Array with: name with: var value)]].	^slots</body></methods><methods><class-id>Kernel.Context</class-id> <category>simulation-debugger</category><body package="Debugger-Support">pdpStepUntilPC: stopPC	"Simulate the execution of bytecodes until pc is equal to stopPC"	[| ctx |	ctx := self.	[ctx == self and: [self pc &lt; stopPC and: [self willReturn not and: [(self isJump: pc) not]]]]			whileTrue: [ctx := self pdpCompleteCallee: self step].	^ctx]		on: Error		do: [:ex | CodeSimulationError signalWith: self]</body><body package="Debugger-Support">pdpStepUntilVisibleEffect	"Simulate the execution of bytecodes until either sending a message 	or assigning a expression or returning a value to the receiver or calling 	a primitive (that is, until reaching a point that has meaning at the source	level)."	^[[self pdpWillSend or: [self willAssign or: [self willReturn or: [self willDoPrimitive or: [self willJump]]]]]		whileFalse:			[| c |			c := self step.			c == self ifFalse: [^c]].	self]		on: Core.Error		do: [:ex | CodeSimulationError signalWith: self]</body></methods><methods><class-id>Kernel.Context</class-id> <category>private-debugger</category><body package="Debugger-Support">probeMethod: aMethod	self changeToVPC.	method := aMethod.</body></methods><methods><class-id>Kernel.Context</class-id> <category>accessing-debugger</category><body package="Debugger-Support">put: obj intoTempVar: aVar 	"Answer the argument or temporary value of the variable."	self nestingAt: self nesting - aVar nesting do: [:ctx | ^ctx slotAt: aVar debuggerIndex put: obj].	self error: (#IndexIsOutOfRange &lt;&lt; #pdp &gt;&gt; 'Index is out of range')</body></methods><methods><class-id>Kernel.Context</class-id> <category>private-debugger</category><body package="Debugger-Support">restackMessage: aMessage to: obj	self push: obj.	aMessage arguments do: [:arg | self push: arg]</body></methods><methods><class-id>Kernel.Context</class-id> <category>private-simulation</category><body package="Debugger-Support">return: value 	| caller |	caller := sender.	caller isNil		ifTrue: [^self cannotReturn: value]		ifFalse: 			[self terminate.			^caller push: value]</body></methods><methods><class-id>Kernel.Context</class-id> <category>simulation-debugger</category><body package="Debugger-Support">safelyInterpretNextInstructionFor: aContext 	| interrupted ctx |	interrupted := false.	[ctx := self interpretNextInstructionFor: aContext]		on: UserInterrupt		do:	[:ex | 			interrupted := true.			ex resume].	interrupted		ifTrue: [UserInterrupt signalWith: ctx].	^ctx</body></methods><methods><class-id>Kernel.Context</class-id> <category>private-simulation</category><body package="Debugger-Support">send: selector receiver: rcvr class: rclass super: flag numArgs: na	"Don't simulate calls on error:."	(flag | self class doSend or: [self onlySlowSendsForClass: rclass selector: selector])		ifFalse: [^self sendFast: selector receiver: rcvr numArgs: na].	(self isSendLoop and: [(rclass includesBehavior: GenericException) and: [selector == #aboutToDebug]])		ifTrue: [^ContextEmergencyError signalWith: rcvr].	self findMethod: selector		class: rclass		ifFound:			[:meth :mclass |			flag ifTrue: [self pop].  "remove class for super"			^self runMethod: meth numArgs: na contextClass: MethodContext].	self findMethod: #doesNotUnderstand:		class:  (self _objectClass: rcvr)		ifFound:			[:meth :mclass |			| args |			flag ifTrue: [self pop].  "remove class for super"			args := Array new: na.			na to: 1 by: -1 do: [:i | args at: i put: self topPop].			self push: (Message selector: selector arguments: args).			^self runMethod: meth numArgs: 1 contextClass: MethodContext].	self error: ((#MessageNotFoundC1s &lt;&lt; #pdp &gt;&gt; 'Message not found: &lt;1s&gt;')			expandMacrosWith: selector printString).	"To continue, just return the receiver of the message."	flag ifTrue: [self pop].  "remove class for super"	stackp := stackp - na.	self localAt: stackp put: rcvr</body></methods><methods><class-id>Kernel.Context</class-id> <category>private-debugger</category><body package="Debugger-Support">sendFast: selector receiver: rcvr numArgs: na	"Execute a send by using perform to invoke VM. Before doing perform, insert extra contexts 	between the receiver and the perform context. The extra contexts holds an exception handling 	block and an unwind block. The exception handling block is used to repropagate the signal 	through the  client process contexts chain. The unwind block is used to catch control flow after 	an uparrow block return occurs in executing the send."	| args context interrupted excpt rtnCtx |	args := Array new: na.	1 to: na do: [:i | args at: i put: (self localAt: stackp - na + i)].	stackp := stackp - na - 1.	(self checkHandlerBlock: rcvr value: selector)		ifTrue: 			[selector == #aboutToDebug				ifTrue: 					["emergency handler"					self class emergencySignal raiseWith: rcvr]				ifFalse: 					["Since we started culling the handler blocks the block argument count does not necessarily match the number of arguments passed in (the one exception instance). So we need to cull the arguments to match the block. (AR#61430)"					| culledArgs |					culledArgs := rcvr method numArgs isZero ifTrue: [#()] ifFalse: [args].					context := self class baseContextSignal raiseRequest.					((args at: 1) handlerContext hasSender: context)						ifTrue: [^self blockContextFrom: rcvr args: culledArgs]						ifFalse: [^Array with: (self blockContextFrom: rcvr args: culledArgs)]]].	interrupted := false.		[| savedSender invisibleContext stubCtx ctx |	invisibleContext := thisContext.	savedSender := thisContext sender.		[	[invisibleContext sender: self.		[stubCtx := thisContext.	context := self				push: (self _object: rcvr perform: selector withArguments: args)]			on: Signal genericSignal			do: 				[:ex |				ex checkInitialContextIf: stubCtx with: self.				self removeContextsTo: stubCtx.				excpt := ex.				rtnCtx := thisContext sender sender.				thisContext sender: invisibleContext]]			ifCurtailed: 				[| restoreStack |				restoreStack := true.				ctx := thisContext unwindRequestorContext home.				ctx method == (BlockContext compiledMethodAt: #nonlocalReturn:through:)					ifTrue: [context := ctx uparrowReturn]					ifFalse: [ctx method == (GenericException compiledMethodAt: #nonlocalReturn:evaluate:finalAction:into:)						ifTrue: [context := ctx simulateGeneralizedExceptionUnwind]						ifFalse: [ctx method == (Context compiledMethodAt: #unwindDebuggerSupportUpTo:)							ifTrue:								[restoreStack := false.								context := ctx localAt: 1]							ifFalse: [self error: 'Stack being unwound through non-standard mechanism']]].				(restoreStack and: [context hasSender: stubCtx])					ifTrue:						[| c2 |						c2 := context.						[c2 sender == stubCtx] whileFalse: [c2 := c2 sender].						c2 sender: self].				thisContext sender: invisibleContext]]			on: UserInterrupt			do: 				[:ex |				interrupted := true.				ex resume].	invisibleContext sender: savedSender]			value.	excpt notNil ifTrue: [context := excpt rePropagateReturnTo: rtnCtx].	interrupted ifTrue: [UserInterrupt signalWith: context].	^context</body></methods><methods><class-id>Kernel.Context</class-id> <category>simulation-debugger</category><body package="Debugger-Support">sendIntoBlockStartingWithCallee: aContext 	"Simulate the execution of bytecodes until we encounter a context 	whose home method is the same as my homeMethod, or until a 	return to a non-context in case of block up arrow return."	| ctxt guardMethod proc |	guardMethod := self method homeMethod originalMethod.	proc := Processor activeProcess.	proc setDoSend.	proc setDoSendLoop.	[	ctxt := aContext == self				ifTrue: [self step]				ifFalse: [aContext].	[(ctxt isKindOf: Context) and:		[(ctxt hasSender: self) and:				[guardMethod ~~ ctxt method homeMethod originalMethod]]]		whileTrue: [ctxt := ctxt step].	] ensure:		[proc clearDoSend.		proc clearDoSendLoop].	"check for handler context"	(ctxt isMemberOf: Array)		ifTrue: [ctxt := ctxt at: 1].	^ctxt</body></methods><methods><class-id>Kernel.Context</class-id> <category>accessing-debugger</category><body package="Debugger-Support">sourceMap	"Answer a sourceMap for PC selection in the current code."		^self visibleSourceMap.</body></methods><methods><class-id>Kernel.Context</class-id> <category>simulation-debugger</category><body package="Debugger-Support">step	"Simulate the execution of the receiver's next bytecode.	Answer the context that would be the active context	after this bytecode."	^[self safelyInterpretNextInstructionFor: self] on: Error		do: [:ex | CodeSimulationError raiseFrom: self]</body><body package="Debugger-Support">stepForever	"Simulate the execution of the receiver's next bytecode 	until a return or an exception is raised, a break occurs. 	Answer the context that would be the active context 	after this bytecode."	^[| ctx |	ctx := self.	[ctx ~~ self or: [self willReturn]]		whileFalse: [ctx := self pdpCompleteCallee: (self safelyInterpretNextInstructionFor: self)].	ctx]		on: Core.Error		do: [:ex | CodeSimulationError signalWith: self]</body><body package="Debugger-Support">stepUntilSkipPC: stopPC	"Simulate the execution of bytecodes until pc is equal to stopPC"	^[| ctx |	ctx := self.	[ctx == self and: [self pc &lt; stopPC and: [self willReturn not]]]			whileTrue: [ctx := self pdpCompleteCallee: self step].	ctx]		on: Core.Error		do: [:ex | CodeSimulationError signalWith: self]</body></methods><methods><class-id>Kernel.Context</class-id> <category>private-debugger</category><body package="Debugger-Support">storeTop: anObject	^self localAt: stackp put: anObject</body></methods><methods><class-id>Kernel.Context</class-id> <category>accessing-debugger</category><body package="Debugger-Support">supposedHome	^self subclassResponsibility</body></methods><methods><class-id>Kernel.Context</class-id> <category>simulation-primitive support</category><body package="Debugger-Support">tryPrimitive: index receiver: rcvr numArgs: numArgs boundByMethod: primMethod	"Evaluate the primitive with the given index. Return new context if successful, nil if failed"	(index &gt;= 86 and: [index &lt;= 89]) ifTrue:		[index = 86 ifTrue: ["^self primWait: rcvr"].		index = 88 ifTrue: ["^self primSuspend: rcvr"].		index = 89 ifTrue: [^self primFlushVMmethodCache: rcvr]].	index = 184 ifTrue: "Context _object:perform:withArguments:"		[^self primObjectPerform: (self localAt: stackp - 2) selector: (self localAt: stackp - 1) arguments: self top].	((#(375 394 395) includes: index)	 and: [(primMethod isLinkedFor: rcvr class) not]) ifTrue:		["unlinked fast DLLCC call invokes unboundMethod:with:"		^self primUnlinkedCallCExternalMethod: primMethod receiver: rcvr numArgs: numArgs].	(index &gt;= 500 and: [index &lt;= 523]) ifTrue:		[index = 500 ifTrue: "BlockClosure valueWithArguments:"			[^self primBlockValue: rcvr arguments: self top].		index &lt; 510 ifTrue: "BlockClosure value:*"			[^self primBlockValue: rcvr numArgs: numArgs].		index = 510 ifTrue: "Object perform:withArguments:"			[^self primPerform: rcvr selector: (self localAt: stackp - 1) arguments: self top].		index &lt; 520 ifTrue: "Object perform:with:*"			[^self primPerform: rcvr selector: (self localAt: stackp - numArgs + 1) numArgs: numArgs - 1].		index = 522 ifTrue: "Behavior flushVMmethodCacheEntriesFor:"			[^self primFlushVMmethodCacheEntries: rcvr].		index = 523 ifTrue: "CompiledMethod valueWithReceiver:arguments:"			[^self primPerformMethod: rcvr]].	index = 538 ifTrue: "DeferredBinding rebindTo:value:changeTo:"		[^self primRebindTo: rcvr].	index = 312		ifTrue:			[ProcessTerminatedDuringSimulation signalWith: [self													doPrimitive: index													receiver: rcvr													numArgs: numArgs													boundByMethod: primMethod]].	^self doPrimitive: index receiver: rcvr numArgs: numArgs boundByMethod: primMethod</body></methods><methods><class-id>Kernel.Context</class-id> <category>accessing-debugger</category><body package="Debugger-Support">visibleSourceMap	"Answer a sourceMap for PC selection in the current code."		self sourceInfo: [:methodHolder :index | 			^(methodHolder visibleSourceMap at: index) asSortedCollection]</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>copying</category><body package="Debugger-Support">basicDcopyUsing: copyDict	"Don't copy"	^self</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>printing</category><body package="Debugger-Support">forStackDumpPrintUsing: aPolicy	aPolicy printString: self</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>accessing</category><body package="Debugger-Support">blockMethodIndex	"Returns the block method index of the receiver.	Which is 1 in the case of a CompiledMethod."	^1</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>testing</category><body package="Debugger-Support">isFullBlockChain	"Returns true if all the blocks from the receiver to the compiled method	are used in full block closures.  For a CompiledMethod return true."	^true</body><body package="Debugger-Support">isPartiallyBound	^self isBound</body><body package="Debugger-Support">isProbeable	"Return true if the receiver can be converted to a probed method."	^true</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>accessing</category><body package="Debugger-Support">newFullProbedMethod	^self probedMethodClass from: self full: true</body><body package="Debugger-Support">newNormalProbedMethod	^self probedMethodClass from: self full: false</body><body package="Debugger-Support">newTempFullProbedMethod	^self newFullProbedMethod</body><body package="Debugger-Support">newTempProbedMethod	^self newNormalProbedMethod</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>printing</category><body package="Debugger-Support">printNameOn: aStream inClass: aClass	| selector class |	aClass isNil		ifTrue:			[| who |			mclass isNil				ifTrue:					[aStream nextPutAll: (#ParenUnboundMethodParen &lt;&lt; #pdp &gt;&gt; '(Unbound method)') asString.					^self].			who := self who.			who isNil				ifTrue:					[class := mclass.					selector := class defaultSelectorForMethod: self]				ifFalse:					[class := who first.					selector := who at: 2]]		ifFalse:			[class := aClass.			selector := class					selectorAtMethod: self					setClass: [:mc | ]].	aStream print: class.	mclass == class 		ifFalse: 			[aStream nextPut: $(.			aStream print: mclass.			aStream nextPut: $)].	aStream nextPutAll: '&gt;&gt;'.	aStream nextPutAll: selector</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>accessing</category><body package="Debugger-Support">probedMethodClass	^ProbedCompiledMethod</body><body package="Debugger-Support">revert	"Ignore, this is overriden by ProbedCompiledMethod."	^self</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>copying</category><body package="Debugger-Support">basicDcopyUsing: copyDict	"Don't copy"	^self</body></methods><methods><class-id>Core.Message</class-id> <category>compilation</category><body package="Debugger-Support">methodStubSource	"Return a String of a method body for the message which contains a single self halt statement."	"nil zork" "nil zork: 1" "nil zork: 1 zork: $1" "nil zork: 1 zork: 1 zork: 1"	| str na |	str := (String new: 1024) writeStream.	(na := args size) = 0		ifTrue: [str nextPutAll: selector]		ifFalse:			[| argNames |			argNames := OrderedCollection new: na.			args				with: selector keywords				do:	[:arg :keyword| | argName |					argName := ((arg isBehavior											ifTrue: ['a', arg basicPrintString]											ifFalse: [arg basicPrintString]) copyWithout: Character space) copyWithout: $. .					(argNames includes: argName) ifTrue:						[| newName n |						n := 2.						[newName := argName, n printString.						argNames includes: newName]							whileTrue: [n := n + 1].						argName := newName].					argNames add: argName.					str nextPutAll: keyword; space; nextPutAll: argName.					str space]].	str crtab; nextPutAll: 'self halt'.	^str contents	"(Message			selector: #with:with:			arguments: (Array with: Store.PackageModel with: Store.PackageModel)) methodStubSource"</body></methods><methods><class-id>Kernel.AnnotatedMethod</class-id> <category>accessing</category><body package="Debugger-Support">probedMethodClass	^ProbedAnnotatedMethod</body></methods><methods><class-id>Kernel.SyntaxError</class-id> <category>text</category><body package="Debugger-Support">debug	"Open a debugger on the stack"	self changeRequest		ifFalse: [^self].	DebuggerService openOnHandle: processHandle label: (#SyntaxError &lt;&lt; #pdp &gt;&gt; 'Syntax Error')</body><body package="Debugger-Support">textMenu	"Answer a Menu of operations on the text that is to be 	displayed when the operate menu button is pressed."	"SyntaxError flushMenus"	TextMenu == nil		ifTrue: 			[TextMenu := Menu						labelList: TextEditorController editGroupLabels , (Array										with: (Array												with: #DoIt &lt;&lt; #pdp &gt;&gt; 'Do it'												with: #PrintIt &lt;&lt; #pdp &gt;&gt; 'Print it'												with: #InspectIt &lt;&lt; #pdp &gt;&gt; 'Inspect it')										with: (Array with: #Accept &lt;&lt; #pdp &gt;&gt; 'Accept'												with: #Cancel &lt;&lt; #pdp &gt;&gt; 'Cancel')										with: (Array with: #Proceed &lt;&lt; #pdp &gt;&gt; 'Proceed'												with: #Debug &lt;&lt; #pdp &gt;&gt; 'Debug')										with: (Array with: #Hardcopy &lt;&lt; #pdp &gt;&gt; 'Hardcopy'))						values: TextEditorController editGroupSelectors								, #(#doIt #printIt #inspectIt #accept #cancel #proceed #debug #hardcopy)].	^TextMenu</body></methods><methods><class-id>Core.Process</class-id> <category>debugging</category><body package="Debugger-Support">debug	self isUnderDebug ifFalse: [self privateDebug]</body><body package="Debugger-Support">debugDebugger	self debug</body><body package="Debugger-Support">hasActiveDebugOperation	^self isUnderDebug and: [debugger hasActiveDebugOperation]</body><body package="Debugger-Support">privateDebug	Processor activeProcess == self		ifTrue:			[self				suspendResumable: false				do: [:proc | proc privateDebug].			^self		"We should never reach this."].	suspendedContext isNil		ifTrue: [^self].	"nothing to debug"	Processor removePausedProcess: self.	[myList isNil		ifTrue: [self resume].	self uninterruptablyDo: [self suspend]] valueUnpreemptively.	[DebuggerService		openOnHandle: (ProcessHandle			on: self			at: suspendedContext			interrupted: true)		label: (#DebugProcess &lt;&lt; #pdp &gt;&gt; 'Debug process').] forkAt: Processor userSchedulingPriority</body></methods><methods><class-id>Core.Process</class-id> <category>changing process state</category><body package="Debugger-Support">proceed	^Processor resumePausedProcess: self</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>accessing</category><body package="Debugger-Support">blockAt: anIndex 	| i |	i := 1.	self		withAllBlockMethodsDo: 			[:aBlock | 			i = anIndex				ifTrue: [^aBlock].			i := i + 1]</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>copying</category><body package="Debugger-Support">postCopy	"Finish doing whatever is required, 	beyond a shallowCopy, to implement 'copy'. 	Answer the receiver. 	Subclasses may add functionality, 	but they should always do super postCopy first."	super postCopy.	1 to: self numLiterals do: 		[:i | | lit cl |		lit := self literalAt: i.		cl := lit class.		((lit isKindOf: CompiledBlock) or: [cl == BlockClosure])			ifTrue: 				[self literalAt: i put: (lit := lit copy).				cl = BlockClosure					ifTrue: [lit method outerMethod: self]					ifFalse: [lit outerMethod: self]]			ifFalse: [self literalAt: i put: lit]].	^self</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>accessing</category><body package="Debugger-Support">sourceInfo: aBlock	"Invoke aBlock with the methodNodeHolder and the index."	| homeMethod methodHolder index |	homeMethod := self homeMethod.	methodHolder := homeMethod sourceInfoIfCached. 	methodHolder == nil ifTrue:		[methodHolder := self compilerClass new			parse: self getSource			in: self mclass			environment: self environment			allowReceiver: homeMethod usuallyAllowsReceiver			noPattern: homeMethod usuallyHasSelector not			notifying: nil.		methodHolder == nil ifTrue:			[methodHolder := self compilerClass new				parse: self getSource				in: self mclass				environment: self environment				allowReceiver: homeMethod usuallyAllowsReceiver				noPattern: true				notifying: nil].		homeMethod cacheSourceInfo: methodHolder].	index := homeMethod withAllBlockMethods identityIndexOf: self.	^aBlock value: methodHolder value: index</body><body package="Debugger-Support">sourceMapAt: index	^self sourceInfo: [:methodHolder :x | 			^(methodHolder sourceMap at: index) asSortedCollection]</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>enumerating</category><body package="Debugger-Support">withAllProbedBlockMethodsDo: aBlock	"Recursively enumerate the collection of methods	(including block methods) that are included in	this method."	self isProbed ifFalse: [^self].	aBlock value: self.	self literalsDo:		[:lit | | cl |		cl := lit class.		(lit isKindOf: CompiledBlock)			ifTrue: [lit withAllProbedBlockMethodsDo: aBlock]			ifFalse:				[cl == BlockClosure					ifTrue: [lit method withAllProbedBlockMethodsDo: aBlock]]]</body></methods><methods><class-id>Kernel.InstructionStream</class-id> <category>testing</category><body package="Debugger-Support">atEnd	"Answer true iff there are no more	bytecodes in the stream."	self changeToVPC.	^pc &gt; method bytesSize</body><body package="Debugger-Support">hasReceiverOnStackForSend	| byte |	self changeToVPC.	byte := self baseBytecodeAt: pc.	(byte between: OpSendSelf0 and: OpSendSelf0+MaxSendSelf0)		ifTrue: [^false].	(byte = OpXSuper or: [byte = OpXXSuper])		ifTrue: [^false].	^true</body><body package="Debugger-Support">isPopPushAt: nextPC	"This is almost the same as isPopFirst:"	| byte |	byte := self baseBytecodeAt: nextPC.	byte &lt; OpPopLoadTemp			ifTrue: [^byte = OpPopLoadReceiver].	^byte &lt;= (OpPopLoadTemp + MaxPopLoadTemp)</body><body package="Debugger-Support">pdpWillSend	"Answer whether the next bytecode is a message-send."	| byte |	self changeToVPC.	byte := self baseBytecodeAt: pc.	byte &lt; FirstShortSend 			ifTrue: [^false].	(byte between: FirstShortSend and:  LastShortSend) 			ifTrue: [^true].		"special send or short send"	byte = OpSendAdd1 ifTrue: [^true].	(byte between: OpXNoCheckSend and: OpXNonImmediateSpecialSend) 			ifTrue: [^true].		"long sends"	byte = OpXNoCheckSpecialSend 			ifTrue: [^true].	(byte between: OpXSpecialSend and: OpXXNoCheckSend) 			ifTrue: [^true].	(byte between: OpXXSend and: OpXXSuper) 			ifTrue: [^true].	^false</body><body package="Debugger-Support">sendsAdd1	"Answer whether the next bytecode sends an add1"	self changeToVPC.	^(method byteAt: pc) = OpSendAdd1</body><body package="Debugger-Support">willJump	"Answer whether the next bytecode is a junp."	^self isJump: self pc</body></methods><methods><class-id>Kernel.MarkedMethod</class-id> <category>testing</category><body package="Debugger-Support">isProbeable	"Return false.  The receiver cannot be converted to a probed method."	^false</body></methods><methods><class-id>Kernel.MarkedMethod</class-id> <category>accessing</category><body package="Debugger-Support">newFullProbedMethod	^nil</body></methods><methods><class-id>Core.Symbol</class-id> <category>copying</category><body package="Debugger-Support">basicDcopyUsing: copyDict	"Don't copy"	^self</body></methods><methods><class-id>Core.Behavior</class-id> <category>probes</category><body package="Debugger-Support">revertAllProbedMethods	"Make sure all original methods in the class have been restored.	This must be done before changing the class structure, i.e. adding	an instance variable."	| pcms |	pcms := OrderedCollection new.	2 to: methodDict basicSize by: 2 do:		[:i | | cm |		cm := methodDict basicAt: i.		cm isProbed			ifTrue:				[methodDict basicAt: i put: cm originalMethod.				pcms add: cm.				PDPManager					changedMethodFrom: cm					to: cm originalMethod					by: nil]].	^pcms</body><body package="Debugger-Support">revertAllProbedMethodsInTree	"Make sure all original methods in the class tree have been restored.	This must be done before changing the class structure, i.e. adding	an instance variable."	| pcms |	pcms := OrderedCollection new.	pcms addAll: self revertAllProbedMethods.	self allSubclassesDo: [:cl | pcms addAll: cl revertAllProbedMethods].	^pcms</body></methods><methods><class-id>Core.Boolean</class-id> <category>copying</category><body package="Debugger-Support">basicDcopyUsing: copyDict	"Don't copy"	^self</body></methods><methods><class-id>Kernel.ProcessorScheduler</class-id> <category>debugging</category><body package="Debugger-Support">interruptActiveUserProcess	| proc deb |	proc := self runableProcesses			detect: [:p | p isSystemProcess not]			ifNone: [nil].	(proc isNil and: [Window currentWindow notNil])		ifTrue: [proc := Window currentWindow windowProcess].	proc isNil		ifTrue: [^self interruptAllUserProcesses].	(deb := proc environmentAt: #debugger) notNil		ifTrue: [^deb abortDebugOperationInProcess: proc].	proc isUnderDebug		ifTrue: [^DebuggerService abortDebuggingFor: proc].	proc interruptWith: 			[Object userInterruptSignal 				interruptWith: thisContext sender sender				errorString: (#exceptUserInterrupt &lt;&lt; #dialogs &gt;&gt; 'User Interrupt')]</body></methods><methods><class-id>Kernel.ProcessorScheduler</class-id> <category>accessing</category><body package="Debugger-Support">isPaused: aProcess	^pausedProcesses includes: aProcess</body><body package="Debugger-Support">isRunable: aProcess	^(quiescentProcessLists at: aProcess priority) includes: aProcess</body></methods><methods><class-id>Kernel.ProcessorScheduler</class-id> <category>process state change</category><body package="Debugger-Support">pauseUserProcesses	| proc procs |	procs := OrderedCollection new.	"First, abort any debugging."	Process allInstances do:		[:p | 		p isUnderDebug			ifTrue: [p debugger ctrlyAbort]			ifFalse: [procs add: p]].	procs := procs reject: [:p | p isSystemProcess].	"Next, pause all runable processes, in priority order"	[(proc := self nextProcessForPausing) notNil]		whileTrue:			[procs remove: proc ifAbsent: [].			self pauseProcess: proc].	"These remaining processes should be blocked or suspended."	procs do: [:p | self pauseProcess: p]</body><body package="Debugger-Support">proceedUserProcesses	pausedProcesses shallowCopy do: [:p | p proceed].</body><body package="Debugger-Support">removePausedProcess: aProcess	pausedProcesses remove: aProcess ifAbsent: [].</body><body package="Debugger-Support">resumePausedProcess: aProcess	pausedProcesses remove: aProcess ifAbsent: [].	^aProcess resume.</body></methods><methods><class-id>UI.ComposedTextView</class-id> <category>updating</category><body package="Debugger-Support">updateTheDisplay	"This is used by the browsers only."	| text changedString |	text := self getContents asText.	changedString := displayContents text string ~= text string.	(changedString or: [displayContents text runs ~= text runs])		ifFalse: 			[self controller.	"Make sure we have a controller"			self resetController.			^self].	"If nothing changed, exit"	self isOpen		ifTrue: 			[displayContents setCompositionWidth: self wrappingBox width.			displayContents text: text asText copy]		ifFalse: 			[displayContents setCompositionWidth: ComposedText defaultCompositionWidth.			displayContents setText: text asText copy].	changedString ifTrue: [self setToTop].	self startBlock: nil.	self stopBlock: nil.	selectionShowing := true.	self controller.	"Make sure we have a controller"	self resetController.	"redisplay now so selection updates will display correctly"	self invalidateRectangle: self bounds repairNow: true</body></methods><methods><class-id>Graphics.CharacterAttributes</class-id> <category>private</category><body package="Debugger-Support">queryCacheAt: aStyle for: aFontPolicy put: query	"Store the cached query for aStyle."	aStyle isCharStyleCacheable		ifFalse: [^self].	queryCache size &gt;= QueryCacheLimit		ifTrue: [self invalidateOnlyQueryCache].	policyCache at: 1 put: aFontPolicy.	queryCache at: aStyle put: query</body></methods><methods><class-id>Kernel.ClassBuilder</class-id> <category>accessing</category><body package="Debugger-Support">revertProbedMethods	| removed |	removed := OrderedCollection new.	records do:		[:rec | rec targetClass ifNotNil: [removed addAll: rec targetClass revertAllProbedMethodsInTree]].	^removed"Smalltalk Professional Debug Package Version 3.1 (c) 2002 Crafted Smalltalk".</body></methods><methods><class-id>Kernel.GeneralBindingReference</class-id> <category>copying</category><body package="Debugger-Support">basicDcopyUsing: copyDict	"Don't copy"	^self</body></methods><methods><class-id>Kernel.ProgramNode</class-id> <category>copying</category><body package="Debugger-Support">postDcopyUsing: copyDict	"Complete the deep copy operation."	sourcePosition := sourcePosition basicDcopyUsing: copyDict.	4 to: self class instSize do: [ :i | self instVarAt: i put: ((self instVarAt: i) basicDcopyUsing: copyDict)]</body></methods><methods><class-id>Tools.ProcessHandle</class-id> <category>control</category><body package="Debugger-Support">destroyProcess	process := nil.</body></methods><methods><class-id>Tools.ProcessHandle</class-id> <category>testing</category><body package="Debugger-Support">isInDebugSession	^process notNil</body><body package="Debugger-Support">isTerminated	^process isNil or: [process isTerminated]</body></methods><methods><class-id>Tools.ProcessHandle</class-id> <category>control</category><body package="Debugger-Support">pauseDebugOperation	process isNil		ifTrue: [^self].	[process interruptWith:			[Object userInterruptSignal 					interruptWith: thisContext sender sender					errorString: (#OperationAborted &lt;&lt; #pdp &gt;&gt; 'Operation aborted') asString]]		on: Error		do: [:ex | ]	"Ignore error"</body></methods><methods><class-id>Tools.ProcessHandle</class-id> <category>access</category><body package="Debugger-Support">prepareForErrorCondition	controller ifNotNil: [controller shutdownBecauseOfError].	modalWindowChain := WindowManager modalWindowChain reverse.	WindowManager beEffectivelyModeless.</body><body package="Debugger-Support">prepareForSimulation	interrupted		ifTrue: [^self].	resumeContext push: proceedValue.	interrupted := true. "simulation leaves same state as interrupting"</body><body package="Debugger-Support">topContext: aContext	"Set aContext to be the context in which to continue the process, if possible."	resumeContext := aContext.	process suspendedContext: aContext.</body></methods><methods><class-id>Core.Collection</class-id> <category>printing</category><body package="Debugger-Support">forStackDumpPrintUsing: aPolicy	aPolicy printCollection: self.</body></methods><methods><class-id>Core.Text</class-id> <category>emphasis</category><body package="Debugger-Support">allItalic	"Set the emphasis for all characters in the receiver to be italic."	self emphasizeAllWith: #italic</body></methods><methods><class-id>Core.Character</class-id> <category>copying</category><body package="Debugger-Support">basicDcopyUsing: copyDict	"Don't copy"	^self</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>copying</category><body package="Debugger-Support">basicDcopyUsing: copyDict	"Don't copy"	^self</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>copying</category><body package="Debugger-Support">basicMethodDcopyUsing: copyDict	^self basicDcopyUsing: copyDict</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>testing</category><body package="Debugger-Support">isClean	^outerContext isNil and: [method numCopiedValues = 0]</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>private</category><body package="Debugger-Support">method: aMethod	method := aMethod</body></methods><methods><class-id>Kernel.BlockContext</class-id> <category>accessing-debugger</category><body package="Debugger-Support">findHomeContextByMatchingHomeMethod	| meth ctx |	meth := self method homeMethod originalMethod.	ctx := self sender.	[ctx == nil]		whileFalse: 			[ctx isBlockContext				ifFalse: [ctx method originalMethod == meth ifTrue: [^ctx]].			ctx := ctx sender].	^nil</body></methods><methods><class-id>Kernel.BlockContext</class-id> <category>private-debugger</category><body package="Debugger-Support">initialStackDepthForProbes	^super initialStackDepthForProbes + method numCopiedValues</body></methods><methods><class-id>Kernel.BlockContext</class-id> <category>accessing-debugger</category><body package="Debugger-Support">intendedReceiver	"Answer the receiver to which the home method was sent."		^self supposedHome		ifNotNil: [:homeContext | homeContext receiver]		ifNil:			["No home receiver, look for a compiler generated temp."			(self localScope temps				detect: [:var | var key = 'self' ]				ifNone: [nil]) ifNotNil: [:selfVar | self getTempVar: selfVar value]]</body></methods><methods><class-id>Kernel.BlockContext</class-id> <category>private</category><body package="Debugger-Support">nestingAt: level do: aBlock 	| outer |	level = 0		ifTrue: [^aBlock value: self].	(outer := self outerContext) == nil		ifTrue: [^self error: (#LevelCountingError &lt;&lt; #pdp &gt;&gt; 'Level counting error')].	^outer nestingAt: level - 1 do: aBlock</body></methods><methods><class-id>Kernel.BlockContext</class-id> <category>simulation-control</category><body package="Debugger-Support">stepToCtxtWithSameParentAs: ctxt	"Step to a context with the same original method as ctxt,	or until ctxt has exited."	| parentCtxt |	self hasExited		ifFalse: [^ctxt].	parentCtxt := ctxt findParentContextWithHomeMethod: self method homeMethod originalMethod.	parentCtxt isNil		ifTrue: [^ctxt].	"No parent."	^parentCtxt sendIntoBlockStartingWithCallee: ctxt."Smalltalk Professional Debug Package Version 3.1 (c) 2003 Crafted Smalltalk"</body></methods><methods><class-id>Kernel.BlockContext</class-id> <category>accessing-debugger</category><body package="Debugger-Support">supposedHome	| ctx |	(ctx := self home) == nil		ifFalse: [^ctx].	^self findHomeContextByMatchingHomeMethod</body></methods><methods><class-id>Kernel.BlockContext</class-id> <category>testing</category><body package="Debugger-Support">willExitMethod	"Answer whether the next bytecode will cause an exit from the method."	self changeToVPC.	^(self baseBytecodeAt: pc) = Kernel.OpcodePool.OpHomeReturn</body></methods><methods><class-id>Kernel.MethodContext</class-id> <category>accessing-debugger</category><body package="Debugger-Support">intendedReceiver	"Answer the receiver to which the home method was sent."	^receiver</body></methods><methods><class-id>Kernel.MethodContext</class-id> <category>private</category><body package="Debugger-Support">nestingAt: level do: aBlock	level &gt; 0		ifTrue: [^self error: (#LevelCountingError &lt;&lt; #pdp &gt;&gt; 'Level counting error')].	^aBlock value: self</body></methods><methods><class-id>Kernel.MethodContext</class-id> <category>simulation-control</category><body package="Debugger-Support">stepToCtxtWithSameParentAs: ctxt	^ctxt</body></methods><methods><class-id>Kernel.MethodContext</class-id> <category>accessing-debugger</category><body package="Debugger-Support">supposedHome	^self</body></methods><methods><class-id>Kernel.MethodContext</class-id> <category>testing</category><body package="Debugger-Support">willExitMethod	"Answer whether the next bytecode will cause an exit from the method."	^self willReturn</body></methods><methods><class-id>CraftedSmalltalk.DebuggerService class</class-id> <category>interface specs</category><body package="Debugger-Support">watchVarSpec	"UIPainter new openOnClass: self andSelector: #watchVarSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #pdp) 			#bounds: #(#Rectangle 466 311 979 522 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#LayoutOrigin -103 0.5 15 0 ) 					#label: #(#{Kernel.UserMessage} #key: #SelectWatchVariable #defaultString: 'Select Watch Variable' #catalogID: #pdp) ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 121 166 210 196 ) 					#model: #accept 					#tabable: false 					#label: #(#{Kernel.UserMessage} #key: #Done #defaultString: 'Done' #catalogID: #pdp) 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 304 168 389 198 ) 					#model: #cancel 					#tabable: false 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #pdp) 					#defaultable: true ) 				#(#DividerSpec 					#layout: #(#LayoutFrame 0 0 150 0 0 1.0 154 0 ) ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 131 98 385 130 ) 					#model: #wVar 					#tabable: false 					#isReadOnly: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 9 51 132 80 ) 					#model: #TOS 					#tabable: false 					#label: #(#{Kernel.UserMessage} #key: #TopOfStack #defaultString: 'Top of Stack' #catalogID: #pdp) 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 143 50 332 80 ) 					#name: #IvarSwitch 					#model: #iVar 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InstanceVariableDots #defaultString: 'Instance Variable...' #catalogID: #pdp) 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Rectangle 342 50 503 81 ) 					#name: #TempSwitch 					#model: #tVar 					#tabable: false 					#label: #(#{Kernel.UserMessage} #key: #TempVariableDots #defaultString: 'Temp Variable...' #catalogID: #pdp) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - pdp</category><body package="Debugger-Support">menuItemBrowseAllProbedMethods	&lt;menuItemForCommand: #browseProbedMethods		icon: nil		nameKey: nil		menu: #(#menuBar #probes)		position: 30.1&gt;	PDPManager browseAllProbedMethods</body><body package="Debugger-Support">menuItemClearTestExpressionLibrary	&lt;menuItemForCommand: #clearTestExpressionLibrary		icon: nil		nameKey: nil		menu: #(#menuBar #probes #testLibrary)		position: 20.2&gt;	ProbeTestExpressionEditor clearLibrary</body><body package="Debugger-Support">menuItemClearWatchExpressionLibrary	&lt;menuItemForCommand: #clearWatchExpressionLibrary		icon: nil		nameKey: nil		menu: #(#menuBar #probes #watchLibrary)		position: 20.2&gt;	ProbeActionExpressionEditor clearLibrary</body><body package="Debugger-Support">menuItemInspectDebugVars	&lt;menuItemForCommand: #inspectDebugVariables		icon: nil		nameKey: nil		menu: #(#menuBar #probes)		position: 30.2&gt;	PDPManager debugVariables inspect</body><body package="Debugger-Support">menuItemInspectTestExpressionLibrary	&lt;menuItemForCommand: #inspectTestExpressionLibrary		icon: nil		nameKey: nil		menu: #(#menuBar #probes #testLibrary)		position: 20.1&gt;	ProbeTestExpressionEditor inspectLibrary</body><body package="Debugger-Support">menuItemInspectWatchExpressionLibrary	&lt;menuItemForCommand: #inspectWatchExpressionLibrary		icon: nil		nameKey: nil		menu: #(#menuBar #probes #watchLibrary)		position: 20.1&gt;	ProbeActionExpressionEditor inspectLibrary</body><body package="Debugger-Support">menuItemLoadTestExpressionLibrary	&lt;menuItemForCommand: #loadTestExpressionLibrary		icon: nil		nameKey: nil		menu: #(#menuBar #probes #testLibrary)		position: 10.1&gt;	ProbeTestExpressionEditor readLibrary</body><body package="Debugger-Support">menuItemLoadWatchExpressionLibrary	&lt;menuItemForCommand: #loadWatchExpressionLibrary		icon: nil		nameKey: nil		menu: #(#menuBar #probes #watchLibrary)		position: 10.1&gt;	ProbeActionExpressionEditor readLibrary</body><body package="Debugger-Support">menuItemPurgeUnusedVars	&lt;menuItemForCommand: #removeUnusedDebugVariables		icon: nil		nameKey: nil		menu: #(#menuBar #probes)		position: 20.3&gt;	(Dialog confirm: (#PurgeUnusedDebugVariables &lt;&lt; #pdp &gt;&gt; 'Purge unused debug variables?'))			ifTrue: [PDPManager purgeUnusedDebugVariables]</body><body package="Debugger-Support">menuItemPurgeUnusedWatches	&lt;menuItemForCommand: #removeUnusedWatchWindows		icon: nil		nameKey: nil		menu: #(#menuBar #probes)		position: 20.2&gt;	(Dialog confirm: (#PurgeUnusedWatches &lt;&lt; #pdp &gt;&gt; 'Purge unused watches?'))			ifTrue: [PDPManager purgeUnusedWatchWindows]</body><body package="Debugger-Support">menuItemReadProbeLibrary	&lt;menuItemForCommand: #loadProbeLibrary		icon: nil		nameKey: nil		menu: #(#menuBar #probes #probeLibrary)		position: 10.1&gt;	ProbedCompiledMethod readProbesFromFile</body><body package="Debugger-Support">menuItemRemoveAllProbes	&lt;menuItemForCommand: #removeAllProbes		icon: nil		nameKey: nil		menu: #(#menuBar #probes)		position: 20.1&gt;	(Dialog confirm: (#RemoveAllProbesFromSystem &lt;&lt; #pdp &gt;&gt; 'Remove all probes from system?'))		ifTrue: [ProbedCompiledMethod revertAllProbedMethodsInSystem]</body><body package="Debugger-Support">menuItemSaveProbeLibrary	&lt;menuItemForCommand: #saveProbeLibrary		icon: nil		nameKey: nil		menu: #(#menuBar #probes #probeLibrary)		position: 10.2&gt;	ProbedCompiledMethod saveProbesToFile</body><body package="Debugger-Support">menuItemSaveTestExpressionLibrary	&lt;menuItemForCommand: #saveTestExpressionLibrary		icon: nil		nameKey: nil		menu: #(#menuBar #probes #testLibrary)		position: 10.2&gt;	ProbeTestExpressionEditor saveLibrary</body><body package="Debugger-Support">menuItemSaveWatchExpressionLibrary	&lt;menuItemForCommand: #saveWatchExpressionLibrary		icon: nil		nameKey: nil		menu: #(#menuBar #probes #watchLibrary)		position: 10.2&gt;	ProbeActionExpressionEditor saveLibrary</body><body package="Debugger-Support">menuItemToggleDebugging	"Dynamic menu label overrides static label in Command."	&lt;menuItemForCommand: #toggleDebugging		label: #toggleDebuggingLabel		nameKey: nil		menu: #(#menuBar #probes)		position: 10.1&gt;	PDPManager toggleDebugging.	#{Refactory.Browser.SourceCodeEditor} ifDefinedDo: [:sceClass |		sceClass allGeneralInstancesDo: [:sce | sce redecorateProbes]]</body><body package="Debugger-Support">submenuProbeLibrary	&lt;submenu: #(#Probe_Library #pdp 'Probe &amp;Library')		nameKey: #probeLibrary		menu: #(#menuBar #probes)		position: 50.1&gt;	^self</body><body package="Debugger-Support">submenuTestLibrary	&lt;submenu: #(#_TestLibrary #pdp '&amp;Test Library')		nameKey: #testLibrary		menu: #(#menuBar #probes)		position: 50.3&gt;	^self</body><body package="Debugger-Support">submenuWatchLibrary	&lt;submenu: #(#_WatchLibrary #pdp '&amp;Watch Library')		nameKey: #watchLibrary		menu: #(#menuBar #probes)		position: 50.2&gt;	^self</body><body package="Debugger-Support">topMenuDebug	&lt;vwPrivileged&gt;	&lt;submenu: #(#_Debug #menus '&amp;Debug')		nameKey: #probes		menu: #(#menuBar)		position: 40.0&gt;	^self</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - debugger</category><body package="Debugger-Support">browseProbedMethodsCommand	&lt;command: #browseProbedMethods&gt;	^Command		label: (#_BrowseProbes &lt;&lt; #pdp &gt;&gt; 'Browse Probes')		group: #debugger		bindings: #()</body><body package="Debugger-Support">clearTestExpressionLibraryCommand	&lt;command: #clearTestExpressionLibrary&gt;	^Command		label: (#_ClearTestExpressionLibrary &lt;&lt; #pdp &gt;&gt; 'Clear Test Expression Library')		group: #debugger		bindings: #()</body><body package="Debugger-Support">clearWatchExpressionLibraryCommand	&lt;command: #clearWatchExpressionLibrary&gt;	^Command		label: (#_ClearWatchExpressionLibrary &lt;&lt; #pdp &gt;&gt; 'Clear Watch Expression Library')		group: #debugger		bindings: #()</body><body package="Debugger-Support">insertActionWatchCommand	&lt;command: #insertActionWatch&gt;	^Command		label: (#insertActionWatch &lt;&lt; #menus &gt;&gt; 'Insert Watch Expression')		group: #debugger		bindings: #()</body><body package="Debugger-Support">insertBreakpointCommand	&lt;command: #insertBreakpoint&gt;	^Command			label: (#InsertBreakpoint &lt;&lt; #menus &gt;&gt; 'Insert Breakpoint')			group: #debugger			bindings: #(				#isMacOSX #(command $/)				#isMSWindows #(ctrl $/)				#isX11 #(ctrl $/)			)</body><body package="Debugger-Support">insertVariableWatchCommand	&lt;command: #insertVariableWatch&gt;	^Command		label: (#insertVariableWatch &lt;&lt; #menus &gt;&gt; 'Insert Watch Variable')		group: #debugger		bindings: #()</body><body package="Debugger-Support">inspectDebugVariablesCommand	&lt;command: #inspectDebugVariables&gt;	^Command		label: (#_InspectDebugVariables &lt;&lt; #pdp &gt;&gt; 'Inspect Debug Variables')		group: #debugger		bindings: #()</body><body package="Debugger-Support">inspectTestExpressionLibraryCommand	&lt;command: #inspectTestExpressionLibrary&gt;	^Command		label: (#_InspectTestExpressionLibrary &lt;&lt; #pdp &gt;&gt; 'Inspect Test Expression Library')		group: #debugger		bindings: #()</body><body package="Debugger-Support">inspectWatchExpressionLibraryCommand	&lt;command: #inspectWatchExpressionLibrary&gt;	^Command		label: (#_InspectWatchExpressionLibrary &lt;&lt; #pdp &gt;&gt; 'Inspect Watch Expression Library')		group: #debugger		bindings: #()</body><body package="Debugger-Support">loadProbeLibraryCommand	&lt;command: #loadProbeLibrary&gt;	^Command		label: (#_LoadProbeLibrary &lt;&lt; #pdp &gt;&gt; 'Load Probe Library')		group: #debugger		bindings: #()</body><body package="Debugger-Support">loadTestExpressionLibraryCommand	&lt;command: #loadTestExpressionLibrary&gt;	^Command		label: (#_LoadTestExpressionLibrary &lt;&lt; #pdp &gt;&gt; 'Load Test Expression Library')		group: #debugger		bindings: #()</body><body package="Debugger-Support">loadWatchExpressionLibraryCommand	&lt;command: #loadWatchExpressionLibrary&gt;	^Command		label: (#_LoadWatchExpressionLibrary &lt;&lt; #pdp &gt;&gt; 'Load Watch Expression Library')		group: #debugger		bindings: #()</body><body package="Debugger-Support">removeAllProbesCommand	&lt;command: #removeAllProbes&gt;	^Command		label: (#RemoveAllProbes &lt;&lt; #menus &gt;&gt; 'Remove All Probes')		group: #debugger		bindings: #()</body><body package="Debugger-Support">removeProbeCommand	&lt;command: #removeProbe&gt;	^Command		label: (#RemoveProbe &lt;&lt; #menus &gt;&gt; 'Remove Probe')		group: #debugger		bindings: #(			#isMacOSX #(command $/)			#isMSWindows #(ctrl $/)			#isX11 #(ctrl $/)		)</body><body package="Debugger-Support">removeUnusedDebugVariablesCommand	&lt;command: #removeUnusedDebugVariables&gt;	^Command		label: (#RemoveUnusedDebug_VariablesDots &lt;&lt; #pdp &gt;&gt; 'Remove Unused Debug Variables')		group: #debugger		bindings: #()</body><body package="Debugger-Support">removeUnusedWatchWindowsCommand	&lt;command: #removeUnusedWatchWindows&gt;	^Command		label: (#RemoveUnused_WatchWindowsDots &lt;&lt; #pdp &gt;&gt; 'Remove Unused Watch Windows')		group: #debugger		bindings: #()</body><body package="Debugger-Support">saveProbeLibraryCommand	&lt;command: #saveProbeLibrary&gt;	^Command		label: (#_SaveProbeLibrary &lt;&lt; #pdp &gt;&gt; 'Save Probe Library')		group: #debugger		bindings: #()</body><body package="Debugger-Support">saveTestExpressionLibraryCommand	&lt;command: #saveTestExpressionLibrary&gt;	^Command		label: (#_SaveTestExpressionLibrary &lt;&lt; #pdp &gt;&gt; 'Save Test Expression Library')		group: #debugger		bindings: #()</body><body package="Debugger-Support">saveWatchExpressionLibraryCommand	&lt;command: #saveWatchExpressionLibrary&gt;	^Command		label: (#_SaveWatchExpressionLibrary &lt;&lt; #pdp &gt;&gt; 'Save Watch Expression Library')		group: #debugger		bindings: #()</body><body package="Debugger-Support">toggleBreakpointCommand	&lt;command: #toggleBreakpoint&gt;	^Command			label: (#ToggleBreakpointMode &lt;&lt; #menus &gt;&gt; 'Toggle Breakpoint Mode')			group: #debugger			bindings: #(				#isMacOSX #(command shift B)				#isMSWindows #(ctrl shift B)				#isX11 #(ctrl shift B)			)</body><body package="Debugger-Support">toggleDebuggingCommand	&lt;command: #toggleDebugging&gt;	^Command		label: 'Toggle Debugging' "In reality, a computed label showing enable/disable as appropriate"		group: #debugger		bindings: #()</body></methods><methods><class-id>Graphics.CharacterAttributes class</class-id> <category>class initialization</category><body package="Debugger-Support">pdpAttributesFor: aDictionary		&lt;stylesWithOrder: 2&gt;	aDictionary		at: #probe		put:			[:query :family | 			query				underline: true;				color: ColorValue red].	aDictionary		at: #tempProbe		put:			[:query :family | 			query				underline: true;				color: ColorValue yellow].	aDictionary		at: #armedOneshotProbe		put:			[:query :family | 			query				underline: true;				color: ColorValue orange].	aDictionary		at: #disarmedOneshotProbe		put:			[:query :family | 			query				underline: true;				color: ColorValue gray]</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-debugger</category><body package="Debugger-Support">debugger10EditContextListPolicy	&lt;setting: #(tools debugger editContextListPolicy)&gt;	^ExternalSetting new		label: #EditContextListPresentation &lt;&lt; #labels &gt;&gt; 'Context list presentation';		editorClass: CraftedSmalltalk.ContextListPolicyEditor;		helpText: #EditContextListPresentationHelpText &lt;&lt; #dialogs &gt;&gt; 'Opens an editor that allows to define special highlighting of contexts in the context list of the debugger. This setting is not saved together with the settings of the image.'</body><body package="Debugger-Support">debugger40usePermanentProbes	&lt;setting: #(tools debugger usePermanentProbes)&gt;	^(BooleanSetting on: CraftedSmalltalk.PDPManager aspect: #permanentProbeIsDefault)		label: #UsePermanentProbesByDefault &lt;&lt; #labels &gt;&gt; 'Use permanent probes by default';		default: true;		helpText: #UsePermanentProbesHelpText &lt;&lt; #dialogs &gt;&gt; 'Determines the default type of probes, and breakpoints created by the Insert Breakpoint command.'</body><body package="Debugger-Support">debugger50showToolbarBelowContexts	&lt;setting: #(tools debugger showToolbarBelowContexts)&gt;	^(BooleanSetting on: #{CraftedSmalltalk.DebuggerClient2.PlaceToolbarBelowContexts})		label: #ShowToolbarBelowContexts &lt;&lt; #labels &gt;&gt; 'Show toolbar below the context list';		default: false;		helpText: #ShowToolbarBelowContextsHelpText &lt;&lt; #dialogs &gt;&gt; 'Determines whether the toolbar is located in the standard place below the menu, or between the context list and the method text view.'</body><body package="Debugger-Support">debugger70EventFaithfulDebugging	&lt;setting: #(tools debugger useEventFaithfulDebugging)&gt;	^(BooleanSetting on: #{CraftedSmalltalk.DebuggerService.EventFaithfulDebugging})		default: false;		label: #UseEventFaithfulDebugging &lt;&lt; #labels &gt;&gt; 'Use event faithful debugging';		helpText: #UseEventFaithfulDebuggingHelpText &lt;&lt; #dialogs &gt;&gt; 'Event faithful debugging insures that events are processed properly while debugging, but causes windows to freeze.  If you are not concerned with debugging widgets, dialogs, or display code, then you may want this to be turned off.  Additionally, if you are concerned about debugging THAPI you should have this enabled.'</body><body package="Debugger-Support">debuggerPage	&lt;settingsPage: #(tools debugger)&gt;	^ModularSettingsPage new		label: #Debugger &lt;&lt; #labels &gt;&gt; 'Debugger';		icon: (ListIconLibrary visualFor: #bug);		settings: (self settingsWithPrefix: #(tools debugger))</body></methods><initialize><class-id>CraftedSmalltalk.DebuggerService</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CharacterAttributes</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attributes sharedAttributes defaultQuery queryCache policyCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Fonts</category><attributes><package>Graphics-Fonts</package></attributes></class><class><name>CompiledCode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>bytes </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>CompiledMainBlock</name><environment>Kernel</environment><super>Kernel.CompiledCode</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>AnnotatedMethod</name><environment>Kernel</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Process</name><environment>Core</environment><super>Core.Link</super><private>false</private><indexed-type>none</indexed-type><inst-vars>suspendedContext priority myList systemRecords interruptProtect environment isSystem name debugger locale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>MarkedMethod</name><environment>Kernel</environment><super>Kernel.AnnotatedMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>markType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>SmallInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars>minVal maxVal maxBits maxBytes </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>InstructionStream</name><environment>Kernel</environment><super>Kernel.InstructionClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method pc </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Message</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector args </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Parser</name><environment>Kernel</environment><super>Kernel.Scanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder requestor oldLanguage newLanguage extendedLanguage parseNode failBlock endTemps targetClass environment topEnvironment bindingRefs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>GeneralBindingReference</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>path cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>ComposedTextView</name><environment>UI</environment><super>UI.AutoScrollingView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>artist textStyle displayContents startBlock stopBlock selectionShowing displaySelection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>ClassBuilder</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>records </inst-vars><class-inst-vars></class-inst-vars><imports>			Behavior.*			</imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>RunArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runs values cacheRun cacheRunStart </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>ProcessorScheduler</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>quiescentProcessLists activeProcess pausedProcesses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>Context</name><environment>Kernel</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sender receiver stackp stack </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>BlockContext</name><environment>Kernel</environment><super>Kernel.Context</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Text</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string runs </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>CompiledBlock</name><environment>Kernel</environment><super>Kernel.CompiledCode</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>outerMethod </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>ProgramNode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourcePosition comment compilerHints blockIndex mapEntry returnMapEntry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>SyntaxError</name><environment>Kernel</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class badText processHandle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>GeneralNameSpace</name><environment>Kernel</environment><super>Core.KeyedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>organization bindings specificImports generalImports </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>MethodContext</name><environment>Kernel</environment><super>Kernel.Context</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>ProcessHandle</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>process controller interrupted resumeContext proceedValue modalWindowChain </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class></st-source>