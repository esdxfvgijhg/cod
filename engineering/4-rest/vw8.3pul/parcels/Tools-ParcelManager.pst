<?xml version="1.0"?><st-source><!-- Name: Tools-Parcel ManagerNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: The Parcel Manager is a tool for exploring the available parcels (loadable components of VisualWorks) and loading them. To start it, use the System -> Parcel Manager item of the Visual Launcher menu, or press F3 while in the Launcher window.The Parcel Manager provides three ways of looking at parcels, corresponding to the three tabs on the left hand side of the window.• Suggestions is a list of parcels organized by category, such as “Developer Tools” or “Graphics.” A category may include both supported VisualWorks components, and third-party contributions (goodies). (To distinguish supported parcels from goodies, they are shown using different icons).• Directories shows the directories from the parcel search, organized hierarchically under three top-level items: “VisualWorks” for supported VisualWorks components, “Goodies” for third party contributions, and “Preview” for VisualWorks component still being worked on.• Loaded shows parcels that are already loaded, again categorized. When a parcel category or directory is selected, its parcels are displayed in the list on the right. The list can show the parcels arranged in either alphabetical order, or as a tree revealing the prerequisite relationship between them.All lists support multiple selection, allowing the user to select multiple parcels from many categories or directories, to see their comments all at once.DbIdentifier: bear73DbTrace: 502044DbUsername: jkottDbVersion: 8.3 - 8PackageName: Tools-Parcel ManagerParcel: #('Tools-Parcel Manager')ParcelName: Tools-Parcel ManagerPrintStringCache: (8.3 - 8,jkott)Version: 8.3 - 8Date: 3:26:57 PM June 30, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (jun17.4) of June 23, 2017 on June 30, 2017 at 3:26:57 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ParcelManagerTool</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>manager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Parcel Manager</category><attributes><package>Tools-Parcel Manager</package></attributes></class><comment><class-id>Tools.ParcelManagerTool</class-id><body>This is an abstract superclass of subapplications of the Parcel Manager window.Instance Variables:	manager	&lt;ParcelManager&gt;	The ParcelManager serviced by this tool.</body></comment><class><name>ParcelCommentTool</name><environment>Tools</environment><super>Tools.ParcelManagerTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>textHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Parcel Manager</category><attributes><package>Tools-Parcel Manager</package></attributes></class><comment><class-id>Tools.ParcelCommentTool</class-id><body>This is the application model that shows the selected parcel's comments when the Comment tab is selected in the lower right corner of the parcel manager window. Like other application models for that part of the manager, it responds to message #parcels: to accept the list of parcels to show.Instance Variables:	textHolder	&lt;ValueHolder on: Text&gt;	The aspect of the text widget displaying the comment.</body></comment><class><name>ParcelPrereqReference</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>item </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Parcel Manager</category><attributes><package>Tools-Parcel Manager</package></attributes></class><comment><class-id>Tools.ParcelPrereqReference</class-id><body>ParcelPrereqReferences are used to keep track of prerequisites of a parcel. A ParcelPrereqItem contains ParcelPrereqReference instances as it  prerequisites. ParcelPrereqReferences refer to the actual parcels. Each parcel knows the references to it (a parcel is a factory of references to it), which allows traversal of the prerequisite graph in both directions.A ParcelPrereqReference is normally created by sending a message #newReference to the parcel.Instance Variables:	item	&lt;ParcelPrereqItem&gt;	The parcel this is a reference to.</body></comment><class><name>ParcelDirectoriesTool</name><environment>Tools</environment><super>Tools.ParcelManagerTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>directoryListHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Parcel Manager</category><attributes><package>Tools-Parcel Manager</package></attributes></class><comment><class-id>Tools.ParcelDirectoriesTool</class-id><body>This is a model of the hierarchical view of parcel directories that appears when the 'Directories' tab is selected on the left-hand side notebook. When a selection is made, the tool notifies the manager by sending a message #selectedGroups:.Instance Variables:	directoryListHolder	&lt;SelectionInList&gt;	The model of the tree view of directories.</body></comment><class><name>ParcelFavoritesTool</name><environment>Tools</environment><super>Tools.ParcelManagerTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>folderTreeHolder </inst-vars><class-inst-vars></class-inst-vars><imports>			XML.XMLParser			</imports><category>Tools-Parcel Manager</category><attributes><package>Tools-Parcel Manager</package></attributes></class><comment><class-id>Tools.ParcelFavoritesTool</class-id><body>This is the model for the list of parcel categories that appears when the 'Suggestions' tab is selected. Methods on the class side define the categories that appear in the list (which is actually a tree widget) and their content. In this release, categories and parcels in them are hard-coded. In future releases, an information field will be added to parcel files, and the list will be compiled automatically.Instance Variables:	folderTreeHolder	&lt;MultiSelectionInTree&gt;	The aspect of the list of categories.</body></comment><class><name>ParcelLoadedTool</name><environment>Tools</environment><super>Tools.ParcelFavoritesTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Parcel Manager</category><attributes><package>Tools-Parcel Manager</package></attributes></class><comment><class-id>Tools.ParcelLoadedTool</class-id><body>This is the model of the list of categories of currently loaded parcels. It appears when 'Loaded' tab is selected on the left-hand side notebook. The class side methods compute the list current at the time when they are invoked.</body></comment><class><name>ParcelGroup</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name description subgroups items </inst-vars><class-inst-vars></class-inst-vars><imports>			XML.Element			XML.Attribute			XML.Document			</imports><category>Tools-Parcel Manager</category><attributes><package>Tools-Parcel Manager</package></attributes></class><comment><class-id>Tools.ParcelGroup</class-id><body>I am a group of parcels. I hold onto a collection of parcels I contain, as well as onto a collection of subgroups (that is, groups form a tree-like structure).Instance Variables:	description	&lt;String&gt;	A description of parcels I contain.	items	&lt;Collection of: &lt;ParcelFileItem|ParcelInImageItem&gt;&gt;	The items I contain.	name	&lt;String&gt;	My name, displayed in various lists.	subgroups	&lt;Collection of: &lt;ParcelGroup&gt;&gt;	Parcel groups I contain.</body></comment><class><name>TopLevelParcelGroup</name><environment>Tools</environment><super>Tools.ParcelGroup</super><private>false</private><indexed-type>none</indexed-type><inst-vars>visualWorksGroup goodiesGroup previewGroup </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Parcel Manager</category><attributes><package>Tools-Parcel Manager</package></attributes></class><comment><class-id>Tools.TopLevelParcelGroup</class-id><body>TopLevelParcelGroup is used by the directory tree view of parcels as the top-level item. It is also responsible for retrieving the actual data from the disk. Its direct subgroups include two predefined ones:VisualWorks group includes all parcel directories listed in the parcel path of Settings which start with $(VISUALWORKS). They are assumed to be directories that contain VisualWorks components. However, directories that start with $(VISUALWORKS) and contain 'goodies' are excluded from this group.  Parcels that belong to these directories are shown in the lists with a "wrapped package" icon to indicate that they are standard supported components of VisualWorks.Goodies group includes all the directories which start with $(VISUALWORKS)\goodies and are assumed to contain goodies--unsupported parcels both from ParcPlace and 3rd party.There may be other subgroups, for other directories in the parcel path, such as '.'.All parcels belonging to directories other than VisualWorks are shown in the list with a "shopping bag" icon to distinguish them from supported parcels.Instance Variables:	goodiesGroup	&lt;ParcelDirectory&gt;	description of goodiesGroup	visualWorksGroup	&lt;ParcelGroup&gt;	description of visualWorksGroup</body></comment><class><name>ParcelPrereqCollector</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>knownItems topItems parentItem path </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Parcel Manager</category><attributes><package>Tools-Parcel Manager</package></attributes></class><comment><class-id>Tools.ParcelPrereqCollector</class-id><body>ParcelPrereqCollector reveals the prerequisite relationship between parcels. Parcels supplied to it using #addParcel: and #addAllParcels: are wrapped into ParcelPrereqItems. Parcels which are not prerequisites of other parcels end up in the 'topItems' collection. Other parcels are contained somewhere in prerequisite trees of those parcels.Instance Variables:	knownItems	&lt;(Collection of: ParcelPrereqItem)&gt;	A collection of items created on all parcels added so far.	topItems	&lt;(Collection of: (ParcelFileItem | ParcelInImageItem | ParcelPrereqItem))&gt;	Items of parcels added so far, that are not prerequisites of any other known parcels.	parentItem	&lt;ParcelPrereqItem | nil&gt;	Private - last argument used in #protectedPrequisitesFor:	path &lt;(Collection of: ParcelPrereqItem)&gt;	Private - prerequisite path to item used in #protectedPrequisitesFor:</body></comment><class><name>ParcelFileItem</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename properties </inst-vars><class-inst-vars></class-inst-vars><imports>			XML.Element			</imports><category>Tools-Parcel Manager</category><attributes><package>Tools-Parcel Manager</package></attributes></class><comment><class-id>Tools.ParcelFileItem</class-id><body>I represent a parcel file on the disk. I am used by various lists in the Parcel Manager to show that parcel.Instance Variables:	filename	&lt;Filename&gt;	The filename of the parcel path. 	properties	&lt;Dictionary | nil&gt;	If not nil, a dictionary of parcel properties loaded from the file.  If nil, either the properties have not been read yet, or the file is inaccessible.</body></comment><class><name>ParcelSelectionTool</name><environment>Tools</environment><super>Tools.ParcelManagerTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Parcel Manager</category><attributes><package>Tools-Parcel Manager</package></attributes></class><comment><class-id>Tools.ParcelSelectionTool</class-id><body>This is the abstract superclass of the tools that display a list of parcels and allow the user select one or more parcel. When parcel selection changes, the tool notifies the manager with a message #selectedParcels:.Subclasses must implement the following messages:	accessing		selectAll		selections		selections:</body></comment><class><name>ParcelListTool</name><environment>Tools</environment><super>Tools.ParcelSelectionTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parcelListHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Parcel Manager</category><attributes><package>Tools-Parcel Manager</package></attributes></class><comment><class-id>Tools.ParcelListTool</class-id><body>This is the model of an alphabetical list of parcels which is visible when the 'Alphabetical' tab is selected in the top right corner of the parcel manager is selected. It expects to receive a list of parcels to display as an argument of the #parcels: message.Instance Variables:	parcelListHolder	&lt;MultiSelectionInList&gt;	description of parcelListHolder</body></comment><class><name>ParcelDirectory</name><environment>Tools</environment><super>Tools.ParcelGroup</super><private>false</private><indexed-type>none</indexed-type><inst-vars>path </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Parcel Manager</category><attributes><package>Tools-Parcel Manager</package></attributes></class><comment><class-id>Tools.ParcelDirectory</class-id><body>ParcelDirectory is a special kind of ParcelGroup, which obtains its items and subgroups from a directory. Parcel files in the directory become items, and subdirectories become subgroups, if requested.Instance Variables:	path	&lt;Filename&gt;	The path to the directory.</body></comment><class><name>ParcelInImageItem</name><environment>Tools</environment><super>Tools.ParcelFileItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parcel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Parcel Manager</category><attributes><package>Tools-Parcel Manager</package></attributes></class><comment><class-id>Tools.ParcelInImageItem</class-id><body>I represent a parcel that is currently loaded.Instance Variables:	parcel	&lt;CodeComponent | Pundle&gt;	description of parcel</body></comment><class><name>ParcelPrereqItem</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parcel prerequisiteNames prerequisiteReferences references </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Parcel Manager</category><attributes><package>Tools-Parcel Manager</package></attributes></class><comment><class-id>Tools.ParcelPrereqItem</class-id><body>ParcelPrereqItem is a wrapper on a parcel item (i.e. ParcelFileItem or ParcelInImageItem) keeping track of prerequisites of parcel it represents.Instance Variables:	parcel	&lt;ParcelFileItem | ParcelInImageItem&gt;	The actual parcel (or rather, an item on the actual parcel).	prerequisiteNames	&lt;Collection of: String&gt;	Names of parcels which are prerequisites of this one.	prerequisiteReferences	&lt;Collection of: ParcelPrereqReference&gt;	References to the prerequisite parcels.	references	&lt;Collection of: ParcelPrereqReference&gt;	Existing references to this parcel.</body></comment><class><name>ParcelPrereqTreeTool</name><environment>Tools</environment><super>Tools.ParcelSelectionTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>itemTree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Parcel Manager</category><attributes><package>Tools-Parcel Manager</package></attributes></class><comment><class-id>Tools.ParcelPrereqTreeTool</class-id><body>This is the model of the parcel selection tool that arranges the parcels into a tree to show their prerequisite relationship.Instance Variables:	itemTree	&lt;MultiSelectionInTree&gt;	The aspect of the tree view.</body></comment><class><name>ParcelPropertiesTool</name><environment>Tools</environment><super>Tools.ParcelManagerTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>textHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Parcel Manager</category><attributes><package>Tools-Parcel Manager</package></attributes></class><comment><class-id>Tools.ParcelPropertiesTool</class-id><body>This is the application model that shows the selected parcel's properties when the Properties tab is selected in the lower right corner of the parcel manager window. Like other application models for that part of the manager, it responds to message #parcels: to accept the list of parcels to show.Instance Variables:	textHolder	&lt;ValueModel&gt;	description of textHolder</body></comment><class><name>ParcelManager</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>categoryHolder parcelHolder detailHolder statusTextHolder categorySubapplication parcelSubapplication detailSubapplication selectedGroups displayedParcels selectedParcels </inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.RefactoringBrowser			private Refactory.Browser.NavigatorState			</imports><category>Tools-Parcel Manager</category><attributes><package>Tools-Parcel Manager</package></attributes></class><comment><class-id>Tools.ParcelManager</class-id><body>This is the top-level application model of the parcel manager. Instance Variables:	categoryHolder	&lt;SelectionInList&gt;	This is the aspect of the left hand side notebook. It selects the kind of categorization we want to use when looking at parcels.	parcelHolder	&lt;SelectionInList&gt;	This is the aspect of the top right notebook. It selects how we want to arrange the current parcel list: alphabetically or hierarchicaly in prerequisite order.	detailHolder	&lt;SelectionInList&gt;	This is the aspect of the bottom right notebook. It selects what kind of information we want to see about the selected parcel(s).	statusTextHolder	&lt;ValueHolder on: String&gt;	The aspect of the status bar text.	categorySubapplication	&lt;ParcelManagerTool&gt;	The current application installed in the categorization notebook.	parcelSubapplication	&lt;ParcelListTool | ParcelPrereqTreeTool&gt;	The current application installed in the parcel list view notebook.	detailSubapplication	&lt;ParcelCommentTool | ParcelPropertiesTool&gt;	The current application installed in the parcel detail view notebook.	selectedGroups	&lt;Collection of: ParcelGroup&gt;	Groups currently selected.	displayedParcels	&lt;Collection of: &lt;ParcelFileItem|ParcelInImageItem&gt;&gt;	Parcels currently displayed in the parcel list view.	selectedParcels	&lt;Collection of: &lt;ParcelFileItem|ParcelInImageItem&gt;&gt;	Parcels currently selected.</body></comment><methods><class-id>Tools.ParcelManagerTool</class-id> <category>utilities</category><body package="Tools-Parcel Manager">orderedSelectionsOf: aMultiSelectionInList	"Since multi selection in list reports #selections as a Set,	they come out unordered.  It really is more useful to be able	to get them in the order they appear in the list. This is what	this method is doing."	| list |	list := aMultiSelectionInList list.	^aMultiSelectionInList selectionIndexes asSortedCollection 		collect: [:each | list at: each]</body></methods><methods><class-id>Tools.ParcelManagerTool</class-id> <category>initialize-release</category><body package="Tools-Parcel Manager">manager: aParcelManager	manager := aParcelManager</body></methods><methods><class-id>Tools.ParcelManagerTool</class-id> <category>actions</category><body package="Tools-Parcel Manager">refresh</body></methods><methods><class-id>Tools.ParcelManagerTool</class-id> <category>private</category><body package="Tools-Parcel Manager">adjustReadOnlyWidgetBackground: aSymbol with: aBuilder	"The default policy of giving distinguished backgrounds colors to	read-only widgets looks bad in some cases. Change the	specified widget to use regular text colors."	| preferences |	(aBuilder componentAt: aSymbol) ifNotNil:		[:wrapper |		preferences := LookPreferences new 			backgroundColor: SymbolicPaint textDataBackground asColorValue.		preferences := preferences			foregroundColor: SymbolicPaint textDataForeground asColorValue.		wrapper widgetState colors: preferences]</body></methods><methods><class-id>Tools.ParcelManagerTool class</class-id> <category>accessing</category><body package="Tools-Parcel Manager">tabLabel	self subclassResponsibility</body></methods><methods><class-id>Tools.ParcelCommentTool</class-id> <category>aspects</category><body package="Tools-Parcel Manager">textHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^textHolder isNil		ifTrue:			[textHolder := String new asValue]		ifFalse:			[textHolder]</body></methods><methods><class-id>Tools.ParcelCommentTool</class-id> <category>private</category><body package="Tools-Parcel Manager">multipleParcelInformation: parcelFileCollection	| stream |	stream := TextStream on: (String new: 100).	parcelFileCollection do:		[:each |		stream 			nextPutAllText: each displayString asText allBold;			nextPutAll: ': ';			nextPutAllText: (self singleParcelInformation: each);			cr; cr].	^stream contents</body><body package="Tools-Parcel Manager">parcelInformationFor: parcelFileCollection	parcelFileCollection size = 0 ifTrue: [^String new].	parcelFileCollection size = 1 ifTrue: [^self singleParcelInformation: parcelFileCollection first].	^self multipleParcelInformation: parcelFileCollection</body><body package="Tools-Parcel Manager">singleParcelInformation: aParcelFile	^aParcelFile commentOrErrorText</body></methods><methods><class-id>Tools.ParcelCommentTool</class-id> <category>accessing</category><body package="Tools-Parcel Manager">parcels: parcelFileCollection	self textHolder value: (self parcelInformationFor: parcelFileCollection)</body></methods><methods><class-id>Tools.ParcelCommentTool</class-id> <category>initialize-release</category><body package="Tools-Parcel Manager">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self adjustReadOnlyWidgetBackground: #text with: aBuilder</body></methods><methods><class-id>Tools.ParcelCommentTool class</class-id> <category>accessing</category><body package="Tools-Parcel Manager">tabLabel	^(#Comment &lt;&lt; #labels &gt;&gt; 'Comment') asString</body></methods><methods><class-id>Tools.ParcelPrereqReference</class-id> <category>accessing</category><body package="Tools-Parcel Manager">allSiblings	^item references copyWithout: self</body><body package="Tools-Parcel Manager">item	^item</body><body package="Tools-Parcel Manager">name	^self item name</body><body package="Tools-Parcel Manager">refersTo: aPrereqItem	^item = aPrereqItem</body><body package="Tools-Parcel Manager">withAllSiblings	^item references</body></methods><methods><class-id>Tools.ParcelPrereqReference</class-id> <category>initialize-release</category><body package="Tools-Parcel Manager">item: anItem	item := anItem</body></methods><methods><class-id>Tools.ParcelDirectoriesTool</class-id> <category>notifications</category><body package="Tools-Parcel Manager">directorySelected	manager selectedGroups: (self orderedSelectionsOf: self directoryListHolder)</body></methods><methods><class-id>Tools.ParcelDirectoriesTool</class-id> <category>initialize-release</category><body package="Tools-Parcel Manager">initialize	self directoryListHolder list:		(TreeModel 			on: TopLevelParcelGroup current			displayRoot: false			childrenWith: [:item | item sortedSubgroups]).	self directoryListHolder selectionIndexHolder		onChangeSend: #directorySelected to: self</body><body package="Tools-Parcel Manager">postBuildWith: aBuilder	| treeView |	treeView := (aBuilder componentAt: #directoryTree) widget.	treeView controller expandFullyRoot</body></methods><methods><class-id>Tools.ParcelDirectoriesTool</class-id> <category>aspects</category><body package="Tools-Parcel Manager">directoryListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^directoryListHolder isNil		ifTrue:			[directoryListHolder := MultiSelectionInTree new]		ifFalse:			[directoryListHolder]</body></methods><methods><class-id>Tools.ParcelDirectoriesTool class</class-id> <category>accessing</category><body package="Tools-Parcel Manager">description	^(#AllDirectoriesSystemSearchesParcel &lt;&lt; #dialogs &gt;&gt; 'All directories the system searches to load parcels') asString</body><body package="Tools-Parcel Manager">tabLabel	^(#Directories &lt;&lt; #labels &gt;&gt; 'Directories') asString</body></methods><methods><class-id>Tools.ParcelFavoritesTool</class-id> <category>notifications</category><body package="Tools-Parcel Manager">folderSelected	manager selectedGroups: (self orderedSelectionsOf: self folderTreeHolder)</body></methods><methods><class-id>Tools.ParcelFavoritesTool</class-id> <category>aspects</category><body package="Tools-Parcel Manager">folderTreeHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^folderTreeHolder isNil		ifTrue:			[folderTreeHolder := MultiSelectionInTree new]		ifFalse:			[folderTreeHolder]</body></methods><methods><class-id>Tools.ParcelFavoritesTool</class-id> <category>initialize-release</category><body package="Tools-Parcel Manager">initialize	self folderTreeHolder list:		(TreeModel 			on: self class topLevelGroup 			displayRoot: false 			childrenWith: [:item | item subgroups]).	self folderTreeHolder selectionIndexHolder		onChangeSend: #folderSelected to: self</body></methods><methods><class-id>Tools.ParcelFavoritesTool class</class-id> <category>favorites list</category><body package="Tools-Parcel Manager">addApplicationDeploymentFolderTo: aGroup	self		addTo: aGroup		subgroupNamed: #ApplicationDeployment &lt;&lt; #labels				&gt;&gt; 'Deploying Applications'		description: #ApplicationDeploymentDesc &lt;&lt; #labels				&gt;&gt; 'Parcels useful for building end user applications'		withFilesNamed: #('$(VISUALWORKS)\packaging\RuntimePackager.pcl' '$(VISUALWORKS)\parcels\Headless.pcl' '$(VISUALWORKS)\packaging\ImageCompression.pcl' '$(VISUALWORKS)\parcels\ScriptingSupport.pcl' '$(VISUALWORKS)\parcels\Smalltalk Archive.pcl')</body><body package="Tools-Parcel Manager">addBrowserExtensionsFolderTo: aGroup	self		addTo: aGroup		subgroupNamed: #BrowserExtensions &lt;&lt; #labels &gt;&gt; 'Browser Extensions'		description: #BrowserExtensionsDesc &lt;&lt; #labels				&gt;&gt; 'Enhancements to the code browser'		withFilesNamed: #('$(VISUALWORKS)\parcels\RBTabbedToolsets.pcl' '$(VISUALWORKS)\contributed\ExtraEmphases.pcl' '$(VISUALWORKS)\contributed\RBClassDefinitionTool.pcl' '$(VISUALWORKS)\contributed\RBBytecodeTool.pcl' '$(VISUALWORKS)\contributed\RBPrimitivesBrowsing.pcl' '$(VISUALWORKS)\parcels\RBRegexExtensions.pcl' '$(VISUALWORKS)\contributed\VB-Sketch-Browser History.pcl' '$(VISUALWORKS)\contributed\VB-Sketch-DontModeMeIn.pcl' '$(VISUALWORKS)\contributed\ClassCloning.pcl' '$(VISUALWORKS)\contributed\RBCustomBrowserUI.pcl' '$(VISUALWORKS)\contributed\RBDynamicRefactoringUI.pcl')</body><body package="Tools-Parcel Manager">addDatabaseFolderTo: aGroup	self		addTo: aGroup		subgroupNamed: #Database &lt;&lt; #labels &gt;&gt; 'Database'		description: #DatabaseDesc &lt;&lt; #labels &gt;&gt; 'Database interfaces'		withFilesNamed: #('$(VISUALWORKS)\database\ODBCThapiEXDI.pcl' '$(VISUALWORKS)\database\ODBCEXDI.pcl' '$(VISUALWORKS)\database\OracleEXDI.pcl' '$(VISUALWORKS)\database\OracleThapiEXDI.pcl' '$(VISUALWORKS)\database\PostgreSQL3EXDI.pcl' '$(VISUALWORKS)\contributed\InterBase\IBEXDI.pcl' '$(VISUALWORKS)\database\DB2EXDI.pcl' '$(VISUALWORKS)\database\DB2ThapiEXDI.pcl' '$(VISUALWORKS)\glorp\Glorp.pcl' '$(VISUALWORKS)\database\CTLibThapiEXDI.pcl' '$(VISUALWORKS)\database\CTLibEXDI.pcl' '$(VISUALWORKS)\database\MySQLEXDI.pcl' '$(VISUALWORKS)\database\SQLite3EXDI.pcl')</body><body package="Tools-Parcel Manager">addDeveloperToolsFolderTo: aGroup	self		addTo: aGroup		subgroupNamed: #DeveloperTools &lt;&lt; #labels &gt;&gt; 'Developer Tools'		description: #DeveloperToolsDesc &lt;&lt; #labels				&gt;&gt; 'System components to make a developer''s life easier'		withFilesNamed: #('$(VISUALWORKS)\contributed\ProgrammingExtensions.pcl' '$(VISUALWORKS)\icc\ADvance2.pcl' '$(VISUALWORKS)\contributed\Searchlight-Tools.pcl' '$(VISUALWORKS)\contributed\PDPMenuShortcutEditor.pcl' '$(VISUALWORKS)\contributed\Out.pcl' '$(VISUALWORKS)\preview\parcels\Diggy.pcl' '$(VISUALWORKS)\contributed\OEProfiler.pcl' '$(VISUALWORKS)\advanced\ATProfilingCore.pcl' '$(VISUALWORKS)\advanced\ATProfilingUI.pcl' '$(VISUALWORKS)\contributed\Heeg\GHTools.pcl' '$(VISUALWORKS)\parcels\UIPainter.pcl' '$(VISUALWORKS)\contributed\FileDifferator.pcl' '$(VISUALWORKS)\parcels\Tools-StartupOrderingTool.pcl' '$(VISUALWORKS)\dllcc\DLLCC.pcl' '$(VISUALWORKS)\dllcc\DLLCC-Tools.pcl')</body><body package="Tools-Parcel Manager">addDistributedComputingFolderTo: aGroup	self		addTo: aGroup		subgroupNamed: #DistributedComputing &lt;&lt; #labels &gt;&gt; 'Distributed Computing'		description: #DistributedComputingDescr &lt;&lt; #labels				&gt;&gt; 'Various frameworks, protocols and tools for distributed computing'		withFilesNamed: #(			'$(VISUALWORKS)\opentalk\Opentalk-STST.pcl' 			'$(VISUALWORKS)\preview\opentalk\iiop\Opentalk-IIOP.pcl' 			'$(VISUALWORKS)\opentalk\Opentalk-Core-Services.pcl' 			'$(VISUALWORKS)\opentalk\Opentalk-Groups.pcl' 			'$(VISUALWORKS)\opentalk\Opentalk-Tools-Monitor.pcl' 			'$(VISUALWORKS)\dst\DST_Core_Services.pcl' 			'$(VISUALWORKS)\dst\DST_COS_Services.pcl' 			'$(VISUALWORKS)\dst\DST_I3.pcl' 			'$(VISUALWORKS)\dst\DST_Tools_Development.pcl')</body><body package="Tools-Parcel Manager">addExamplesFolderTo: aGroup	"Kinda silly, we read the whole directory, then print the files as strings, so the 'utility' method can reparse them as filenames."	| parcelFileList names |	parcelFileList := (LogicalFilename				fromComponents: #('$(VISUALWORKS)' 'examples')) filenamesMatching: '*.pcl'.	names := parcelFileList				collect: [:each | each componentStrings fold: [:a :b | a , '\' , b]].	self		addTo: aGroup		subgroupNamed: #Examples &lt;&lt; #IDE &gt;&gt; 'Examples'		description: #ExampleParcelsDesc &lt;&lt; #IDE				&gt;&gt; 'Various example parcels for the VisualWorks class libraries.'		withFilesNamed: names</body><body package="Tools-Parcel Manager">addGraphicsFolderTo: aGroup	self		addTo: aGroup		subgroupNamed: #Graphics &lt;&lt; #labels &gt;&gt; 'Graphics and UI'		description: #GraphicsDesc &lt;&lt; #labels				&gt;&gt; 'User interface, drawing, and image processing tools and frameworks'		withFilesNamed: #('$(VISUALWORKS)\parcels\BGOK.pcl' '$(VISUALWORKS)\parcels\ImageReaders.pcl' '$(VISUALWORKS)\contributed\HotDraw\HotDraw.pcl' '$(VISUALWORKS)\contributed\GFST\GFST-Demo.pcl' '$(VISUALWORKS)\contributed\GFST\GFST-Base.pcl' '$(VISUALWORKS)\contributed\ExtraEmphases.pcl' '$(VISUALWORKS)\contributed\ExtraActivity.pcl' '$(VISUALWORKS)\parcels\UIPainter.pcl' '$(VISUALWORKS)\preview\cairo\CairoGraphics.pcl' '$(VISUALWORKS)\contributed\Pango.pcl' '$(VISUALWORKS)\contributed\OpenGL-Linux.pcl' '$(VISUALWORKS)\contributed\OpenGL-Lessons.pcl' '$(VISUALWORKS)\contributed\OpenGL-Windows.pcl' '$(VISUALWORKS)\contributed\OpenGL-MacOSX.pcl')</body><body package="Tools-Parcel Manager">addJapaneseLocaleTo: aGroup 	self		addTo: aGroup		subgroupNamed: (#JapaneseLocale &lt;&lt; #labels &gt;&gt; 'Japanese Locale')		description: (#JapaneseLocale &lt;&lt; #labels &gt;&gt; 'Japanese Locale')		withFilesNamed:			#(			'$(VISUALWORKS)\japanese\JapaneseLocale.pcl'			'$(VISUALWORKS)\japanese\JaUIPainter.pcl'			'$(VISUALWORKS)\japanese\JaCTLibEXDI.pcl'			'$(VISUALWORKS)\japanese\JaOracleEXDI.pcl'			'$(VISUALWORKS)\japanese\JaWebToolkit.pcl'			'$(VISUALWORKS)\japanese\JaURISupport.pcl'			'$(VISUALWORKS)\japanese\JaVisualWave.pcl'			)</body><body package="Tools-Parcel Manager">addLibrariesFolderTo: aGroup	self		addTo: aGroup		subgroupNamed: #OtherLibraries &lt;&lt; #labels &gt;&gt; 'Other Libraries'		description: #OtherLibrariesDesc &lt;&lt; #labels				&gt;&gt; 'Additional libraries for application development'		withFilesNamed: #(					'$(VISUALWORKS)\advanced\ATParserCompiler.pcl'					'$(VISUALWORKS)\advanced\ATMetaNumerics.pcl'					'$(VISUALWORKS)\contributed\SmaCC\SmaCC Runtime.pcl'					'$(VISUALWORKS)\contributed\Regex11.pcl'					'$(VISUALWORKS)\contributed\Spellchecker2.pcl'					'$(VISUALWORKS)\parcels\BOSS.pcl'					'$(VISUALWORKS)\parcels\XPath.pcl'					'$(VISUALWORKS)\parcels\Compression-ZLib.pcl'					'$(VISUALWORKS)\parcels\Compression-Zip.pcl'					'$(VISUALWORKS)\preview\parcels\UUID.pcl'					'$(VISUALWORKS)\contributed\TAR.pcl')</body><body package="Tools-Parcel Manager">addNetworkingFolderTo: aGroup	self		addTo: aGroup		subgroupNamed: #Networking &lt;&lt; #labels &gt;&gt; 'Networking'		description: #NetworkingDesc &lt;&lt; #labels				&gt;&gt; 'Frameworks and tools for web serving and other network communication issues'		withFilesNamed: #(			'$(VISUALWORKS)\net\NetClients.pcl'			'$(VISUALWORKS)\net\IMAP.pcl'			'$(VISUALWORKS)\net\IMAPS.pcl'			'$(VISUALWORKS)\net\Mail.pcl'			'$(VISUALWORKS)\net\MIME.pcl'			'$(VISUALWORKS)\net\NetConfigTool.pcl'			'$(VISUALWORKS)\net\HTTP.pcl'			'$(VISUALWORKS)\net\HTTPS.pcl'			'$(VISUALWORKS)\net\FTP.pcl'			'$(VISUALWORKS)\net\POP3.pcl'			'$(VISUALWORKS)\net\SMTP.pcl'			'$(VISUALWORKS)\net\WebSupport.pcl'			'$(VISUALWORKS)\net\POP3S.pcl'			'$(VISUALWORKS)\net\SMTPS.pcl'			'$(VISUALWORKS)\net\MQ-Domain.pcl'			'$(VISUALWORKS)\net\MQ-Browser.pcl'			'$(VISUALWORKS)\net\LDAP.pcl'			'$(VISUALWORKS)\net\LDAPS.pcl'		)</body><body package="Tools-Parcel Manager">addOSWindowsFolderTo: aGroup	self		addTo: aGroup		subgroupNamed: #OSWindows &lt;&lt; #labels &gt;&gt; 'OS-Windows'		description: #OSWindowsDesc &lt;&lt; #labels				&gt;&gt; 'Windows-specific utilities and add-ons'		withFilesNamed: #('$(VISUALWORKS)\com\ActiveX-All.pcl' '$(VISUALWORKS)\contributed\WindowsGoodies.pcl' '$(VISUALWORKS)\contributed\Windows-Shortcuts.pcl' '$(VISUALWORKS)\com\Com-All.pcl' '$(VISUALWORKS)\contributed\Registry.pcl' '$(VISUALWORKS)\DotNETConnect\DotNETConnectInstaller.pcl')</body><body package="Tools-Parcel Manager">addPlatformConnectivityFolderTo: aGroup	self		addTo: aGroup		subgroupNamed: #PlatformConnectivity &lt;&lt; #labels &gt;&gt; 'Platform Connectivity'		description: #PlatformConnectivityDesc &lt;&lt; #labels				&gt;&gt; 'Interfaces to other languages and system services'		withFilesNamed: #('$(VISUALWORKS)\com\ActiveX-All.pcl' '$(VISUALWORKS)\dllcc\DLLCC.pcl' '$(VISUALWORKS)\com\Com-All.pcl' '$(VISUALWORKS)\DotNETConnect\DotNETConnectInstaller.pcl' '$(VISUALWORKS)\contributed\ObjectiveCConnect.pcl' '$(VISUALWORKS)\contributed\JNIPort\JNIPort.pcl' '$(VISUALWORKS)\net\MQ-Domain.pcl')</body><body package="Tools-Parcel Manager">addPopularFolderTo: aGroup	self		addTo: aGroup		subgroupNamed: #Popular &lt;&lt; #dialogs &gt;&gt; 'Popular'		description: #PopularParcelsDesc &lt;&lt; #dialogs				&gt;&gt; 'Frequently used components and add-ons '		withFilesNamed: #('$(VISUALWORKS)\parcels\UIPainter.pcl' '$(VISUALWORKS)\dllcc\DLLCC.pcl' '$(VISUALWORKS)\dllcc\DLLCC-Tools.pcl' '$(VISUALWORKS)\parcels\RBSUnitExtensions.pcl' '$(VISUALWORKS)\contributed\SUnitTools.pcl' '$(VISUALWORKS)\parcels\RBTabbedToolsets.pcl' '$(VISUALWORKS)\store\StoreForPostgreSQL.pcl' '$(VISUALWORKS)\contributed\Searchlight-Tools.pcl')</body><body package="Tools-Parcel Manager">addSeasideDevelopmentTo: aGroup 	self		addTo: aGroup		subgroupNamed: (#SeasideWebDev &lt;&lt; #labels &gt;&gt; 'Seaside Web Development')		description: (#SeasideWebDev &lt;&lt; #labels &gt;&gt; 'Seaside Web Development')		withFilesNamed:			#(			'$(VISUALWORKS)\seaside\Seaside-All.pcl'			'$(VISUALWORKS)\seaside\Seaside-Examples-All.pcl'			'$(VISUALWORKS)\seaside\Seaside-Testing-All.pcl'			)</body><body package="Tools-Parcel Manager">addSecurityFolderTo: aGroup	self		addTo: aGroup		subgroupNamed: #Security &lt;&lt; #labels &gt;&gt; 'Security'		description: #SecurityDesc &lt;&lt; #labels				&gt;&gt; 'Cryptographic algorithms and security technologies: encryption, signatures, hashes, certificates, etc'		withFilesNamed: #(			'$(VISUALWORKS)\security\X509.pcl' 			'$(VISUALWORKS)\security\TLS.pcl' 			'$(VISUALWORKS)\security\TLS-Classic.pcl' 			'$(VISUALWORKS)\security\PKCS5.pcl' 			'$(VISUALWORKS)\security\PKCS8.pcl' 			'$(VISUALWORKS)\security\LinuxPAM.pcl' 			'$(VISUALWORKS)\net\ASN1.pcl' 			'$(VISUALWORKS)\security\Security-Xtreams.pcl' 			'$(VISUALWORKS)\xtreams\Xtreams-Crypto.pcl'		)</body><body package="Tools-Parcel Manager">addTestingFolderTo: aGroup	self		addTo: aGroup		subgroupNamed: #Testing &lt;&lt; #dialogs &gt;&gt; 'Testing'		description: #TestingParcelsDesc &lt;&lt; #dialogs &gt;&gt; 'Tools and frameworks for doing code testing'		withFilesNamed: #(				'$(VISUALWORKS)\advanced\ATBenchmarks.pcl'				'$(VISUALWORKS)\contributed\SUnit\SUnit.pcl'				'$(VISUALWORKS)\contributed\SUnit\SUnitResourcePatterns.pcl'				'$(VISUALWORKS)\parcels\RBSUnitExtensions.pcl'				'$(VISUALWORKS)\parcels\RBSUnitShowResult.pcl'								'$(VISUALWORKS)\contributed\SUnitToo.pcl'				'$(VISUALWORKS)\contributed\SUnitTools.pcl'				'$(VISUALWORKS)\contributed\SUnitToolsoverage.pcl'				'$(VISUALWORKS)\contributed\SUnit-Bridge2SU2.pcl')</body><body package="Tools-Parcel Manager">addTo: aGroup subgroupNamed: aString description: descriptionString withFilesNamed: stringCollection	| folder |	folder := ParcelGroup		named: aString asString		description: descriptionString asString.	stringCollection do: 		[:each | 		folder addItem: 			(ParcelFileItem filename: 				(Filename fromComponents: (each tokensBasedOn: $\)))].	aGroup addSubgroup: folder</body><body package="Tools-Parcel Manager">addToysFolderTo: aGroup	self		addTo: aGroup		subgroupNamed: (#Toys &lt;&lt; #labels &gt;&gt; 'Toys')		description: (#ToysDesc &lt;&lt; #labels &gt;&gt; 'Games and eye candy')		withFilesNamed:			#(			'$(VISUALWORKS)\contributed\Gremlin.pcl'			'$(VISUALWORKS)\contributed\Tetris.pcl'			'$(VISUALWORKS)\contributed\GoldenMonkey.pcl'			'$(VISUALWORKS)\contributed\Reversi.pcl'			'$(VISUALWORKS)\contributed\WinMineGame.pcl'			'$(VISUALWORKS)\contributed\Xonix\Xonix.pcl'			'$(VISUALWORKS)\contributed\BugTraffic\BugTraffic.pcl'			'$(VISUALWORKS)\contributed\JavaAsteroids\JavaAsteroids.pcl'			'$(VISUALWORKS)\contributed\Steroids\Steroids.pcl'			'$(VISUALWORKS)\contributed\SpiderSolitaire.pcl'			)</body><body package="Tools-Parcel Manager">addVersionControlFolderTo: aGroup	self		addTo: aGroup		subgroupNamed: #VersionControlFolderLabel &lt;&lt; #labels &gt;&gt; 'Version Control '		description: #VersionControlFolderLabelDesc &lt;&lt; #labels				&gt;&gt; 'Version control backends and utilities'		withFilesNamed: #('$(VISUALWORKS)\store\StoreForOracle.pcl' '$(VISUALWORKS)\store\StoreForDB2.pcl' '$(VISUALWORKS)\store\StoreForSqlServer.pcl' '$(VISUALWORKS)\store\StoreForPostgreSQL.pcl' '$(VISUALWORKS)\contributed\InterBase\StoreForInterBase.pcl' '$(VISUALWORKS)\store\StoreForThreadedOracle.pcl' '$(VISUALWORKS)\store\StoreForSQLite3.pcl' '$(VISUALWORKS)\store\Store-GarbageCollection.pcl')				, #('$(VISUALWORKS)\parcels\RBStoreExtensions.pcl' '$(VISUALWORKS)\contributed\StoreForGlorpReplicationUI.pcl')</body><body package="Tools-Parcel Manager">addVersionControlUtilitiesFolderTo: aGroup	self		addTo: aGroup		subgroupNamed: #VersionControlUtilitiesFolderLabel &lt;&lt; #labels				&gt;&gt; 'Version Control Utilities'		description: #VersionControlUtilitiesFolderLabelDesc &lt;&lt; #labels				&gt;&gt; 'Utilities for the Store Version Control System'		withFilesNamed: #('$(VISUALWORKS)\contributed\ExportDatabaseUI.pcl' '$(VISUALWORKS)\parcels\RBStoreExtensions.pcl' '$(VISUALWORKS)\contributed\StoreForGlorpReplicationUI.pcl')</body><body package="Tools-Parcel Manager">addWebDevelopmentFolderTo: aGroup	self		addTo: aGroup		subgroupNamed: #WebDevelopment &lt;&lt; #labels &gt;&gt; 'Web Development'		description: #ApplicationServerDesc &lt;&lt; #labels &gt;&gt; 'VisualWorks Web Application Server'		withFilesNamed: #(				'$(VISUALWORKS)\web\WebToolkit.pcl' 				'$(VISUALWORKS)\web\WebToolkit-Compatibility-API.pcl'				'$(VISUALWORKS)\contributed\WikiWorks\WikiWorks.pcl'),				#('$(VISUALWORKS)\seaside\Seaside-All.pcl' 				'$(VISUALWORKS)\seaside\Seaside-Examples-All.pcl' 				'$(VISUALWORKS)\seaside\Seaside-Testing-All.pcl'),				#('$(VISUALWORKS)\www\SiouX-Server.pcl' 				'$(VISUALWORKS)\www\SiouX-Http.pcl' 				'$(VISUALWORKS)\www\SiouX-Http2.pcl' 				'$(VISUALWORKS)\www\SiouX-Sessions.pcl'				'$(VISUALWORKS)\www\SiouX-WebSocket.pcl' 				'$(VISUALWORKS)\www\SiouX-Server-Secure.pcl'								'$(VISUALWORKS)\www\SiouX-Net-Http.pcl' 				'$(VISUALWORKS)\www\SiouX-Tools.pcl'				'$(VISUALWORKS)\www\SiouX-Servlet.pcl'				'$(VISUALWORKS)\examples\SiouX-Examples.pcl'				'$(VISUALWORKS)\examples\SiouX-Servlet-Demo.pcl'				'$(VISUALWORKS)\www\AppeX-Support.pcl'				'$(VISUALWORKS)\www\AppeX-Server.pcl'				'$(VISUALWORKS)\www\AppeX-Client.pcl'				'$(VISUALWORKS)\www\AppeX-GenericJavascript.pcl'				'$(VISUALWORKS)\www\AppeX-Internationalization.pcl'				'$(VISUALWORKS)\www\AppeX-ThirdPartyLibraries.pcl'				'$(VISUALWORKS)\www\AppeX-ActiveRecord.pcl'				'$(VISUALWORKS)\www\AppeX-Scaffolding.pcl'				'$(VISUALWORKS)\www\AppeX-Tools.pcl'				'$(VISUALWORKS)\www\AppeX-Scaffolding-Tool.pcl'				'$(VISUALWORKS)\www\AppeX-ServerMonitor.pcl'								'$(VISUALWORKS)\examples\AppeX-Examples.pcl' 				'$(VISUALWORKS)\examples\AppeX-Examples-Mobile.pcl' 				'$(VISUALWORKS)\examples\AppeX-Examples-Seaside.pcl' 								'$(VISUALWORKS)\contributed\AppeX-Examples-Amber.pcl' 				'$(VISUALWORKS)\contributed\AppeX-Examples-Dart.pcl' 				'$(VISUALWORKS)\examples\AppeX-Examples-Scaffolding.pcl' 				'$(VISUALWORKS)\examples\AppeX-Examples-HTTP2.pcl' 				'$(VISUALWORKS)\examples\AppeX-Examples-LinuxPAM.pcl' 	)</body><body package="Tools-Parcel Manager">addWebServicesFolderTo: aGroup 	self		addTo: aGroup		subgroupNamed: (#WebServices &lt;&lt; #labels &gt;&gt; 'Web Services')		description: (#WebServicesDescr &lt;&lt; #labels &gt;&gt; 'Frameworks, protocols and tools for Web Services')		withFilesNamed:			#(			'$(VISUALWORKS)\webservices\WebServicesClient.pcl'			'$(VISUALWORKS)\webservices\WebServicesServer.pcl'			'$(VISUALWORKS)\webservices\WSDLWizard.pcl'			'$(VISUALWORKS)\webservices\XMLObjectBindingWizard.pcl'			'$(VISUALWORKS)\webservices\WSDLTool.pcl'			'$(VISUALWORKS)\webservices\XMLObjectBindingTool.pcl'			'$(VISUALWORKS)\webservices\XMLObjectMarshalers.pcl'			'$(VISUALWORKS)\examples\WebServicesDemo.pcl'			'$(VISUALWORKS)\examples\WebServicesTimeDemo.pcl'			'$(VISUALWORKS)\examples\WSSecurityDemo.pcl'			'$(VISUALWORKS)\examples\WSAttachmentDemo.pcl'			)</body></methods><methods><class-id>Tools.ParcelFavoritesTool class</class-id> <category>accessing</category><body package="Tools-Parcel Manager">description	^(#SuggestionsDesc &lt;&lt; #dialogs &gt;&gt; 'A categorized collections of the parcels you might want to load or know about') asString</body><body package="Tools-Parcel Manager">reportErrorReading: suggestionsFile 	Transcript		cr;		show: (#ErrorReadingSuggestions1s &lt;&lt; #dialogs 					&gt;&gt; 'Error reading parcel suggestions file "&lt;1s&gt;"; using hardcoded suggestions instead.' 						expandMacrosWith: suggestionsFile asResolvedString)</body><body package="Tools-Parcel Manager">tabLabel	^(#Suggestions &lt;&lt; #labels &gt;&gt; 'Suggestions') asString</body><body package="Tools-Parcel Manager">topLevelGroup	"The group name is superceded by the tabLabel for display in the UI."	| top |	top := ParcelGroup named: ''.	self		addBrowserExtensionsFolderTo: top;		addPlatformConnectivityFolderTo: top;		addTestingFolderTo: top;		addDeveloperToolsFolderTo: top;		addApplicationDeploymentFolderTo: top;		addVersionControlFolderTo: top;		addWebDevelopmentFolderTo: top;		addDatabaseFolderTo: top;		addDistributedComputingFolderTo: top;		addWebServicesFolderTo: top;		addGraphicsFolderTo: top;		addNetworkingFolderTo: top;		addOSWindowsFolderTo: top;		addSecurityFolderTo: top;		addLibrariesFolderTo: top;		addToysFolderTo: top;		addJapaneseLocaleTo: top;		addExamplesFolderTo: top.	top sort.	"The Popular category is always to be at the 'top', add it after the sort, and shove it on top."	self addPopularFolderTo: top.	top subgroups addFirst: top subgroups removeLast.	^top</body></methods><methods><class-id>Tools.ParcelLoadedTool</class-id> <category>actions</category><body package="Tools-Parcel Manager">refresh	| selections |	selections := self folderTreeHolder selectionIndexes.	self folderTreeHolder list:		(TreeModel 			on: self class topLevelGroup 			displayRoot: false 			childrenWith: [:item | item subgroups]).	self folderTreeHolder selectionIndexes: selections</body><body package="Tools-Parcel Manager">selectGoodiesFolder	self folderTreeHolder selectionIndex: 2</body><body package="Tools-Parcel Manager">selectOtherFolder	self folderTreeHolder selectionIndex: 3</body><body package="Tools-Parcel Manager">selectPreviewFolder	self folderTreeHolder selectionIndex: 4</body><body package="Tools-Parcel Manager">selectVisualWorksFolder	self folderTreeHolder selectionIndex: 1</body></methods><methods><class-id>Tools.ParcelLoadedTool class</class-id> <category>accessing</category><body package="Tools-Parcel Manager">tabLabel	^(#Loaded &lt;&lt; #labels &gt;&gt; 'Loaded') asString</body><body package="Tools-Parcel Manager">topLevelGroup	| parcels visualworks goodies other previews |	parcels := Parcel parcels collect: [:each | ParcelInImageItem new parcel: each].	visualworks := ParcelGroup named: (#VisualWorksParcels &lt;&lt; #labels &gt;&gt; 'VisualWorks Parcels').	goodies := ParcelGroup named: (#Contributed &lt;&lt; #labels &gt;&gt; 'Contributed').	previews := ParcelGroup named: (#Previews &lt;&lt; #labels &gt;&gt; 'Previews').	other := ParcelGroup named: (#OtherParcels &lt;&lt; #labels &gt;&gt; 'Other Parcels').	parcels do: 		[:each |		each isGoodie			ifTrue: [goodies addItem: each]			ifFalse: [each isPreview				ifTrue: [previews addItem: each]				ifFalse: [each isVisualWorksParcel					ifTrue: [visualworks addItem: each]					ifFalse: [other addItem: each]]]].	^ParcelGroup new		addSubgroup: visualworks;		addSubgroup: goodies;		addSubgroup: other;		addSubgroup: previews;		yourself</body></methods><methods><class-id>Tools.ParcelGroup</class-id> <category>accessing</category><body package="Tools-Parcel Manager">addItem: aParcelItem	items add: aParcelItem</body><body package="Tools-Parcel Manager">addItems: aCollection	items addAll: aCollection</body><body package="Tools-Parcel Manager">addSubgroup: aParcelGroup	subgroups add: aParcelGroup</body><body package="Tools-Parcel Manager">addSubgroups: aCollection	subgroups addAll: aCollection</body><body package="Tools-Parcel Manager">description	^description isNil		ifTrue: [self name]		ifFalse: [description]</body><body package="Tools-Parcel Manager">findGroup: aBlock	(aBlock value: self) ifTrue: [^self].	subgroups do: 		[:each | | found |		found := each findGroup: aBlock.		found notNil ifTrue: [^found]].	^nil</body><body package="Tools-Parcel Manager">items	^items</body><body package="Tools-Parcel Manager">name	^name == nil		ifTrue: [nil]		ifFalse: [name asString]</body><body package="Tools-Parcel Manager">sort	subgroups sort: [:a :b | a name &lt; b name]</body><body package="Tools-Parcel Manager">sortedSubgroups	^subgroups asSortedCollection: [:a :b | a name &lt;= b name]</body><body package="Tools-Parcel Manager">subgroups	^subgroups</body></methods><methods><class-id>Tools.ParcelGroup</class-id> <category>initialize-release</category><body package="Tools-Parcel Manager">description: aString	description := aString</body><body package="Tools-Parcel Manager">initialize	items := OrderedCollection new.	subgroups := OrderedCollection new</body><body package="Tools-Parcel Manager">name: aString	name := aString</body><body package="Tools-Parcel Manager">retrieveParcelFiles</body></methods><methods><class-id>Tools.ParcelGroup</class-id> <category>testing</category><body package="Tools-Parcel Manager">isDirectory	^false</body></methods><methods><class-id>Tools.ParcelGroup</class-id> <category>enumeration</category><body package="Tools-Parcel Manager">allItemsDo: aBlock	self itemsDo: aBlock.	subgroups do: [:each | each allItemsDo: aBlock]</body><body package="Tools-Parcel Manager">itemsDo: aBlock	items do: aBlock</body><body package="Tools-Parcel Manager">subgroupsDo: aBlock	subgroups do: aBlock</body><body package="Tools-Parcel Manager">withAllSubgroupsDo: aBlock	aBlock value: self.	subgroups do: [:each | each withAllSubgroupsDo: aBlock]</body></methods><methods><class-id>Tools.ParcelGroup</class-id> <category>printing</category><body package="Tools-Parcel Manager">displayString	^name notNil 		ifTrue: [self name]		ifFalse: [super displayString]</body><body package="Tools-Parcel Manager">printOn: aStream	super printOn: aStream.	aStream 		nextPutAll: ' (';		print: self name;		nextPutAll: ')'</body></methods><methods><class-id>Tools.ParcelGroup</class-id> <category>xml representation</category><body package="Tools-Parcel Manager">asXmlDocument	^XML.Document new 		addNode: self asXmlElement;		yourself</body><body package="Tools-Parcel Manager">asXmlElement	^Element 		tag: 'group'		attributes:			(Array				with: (Attribute name: 'name' value: name)				with: (Attribute name: 'description' value: description))		elements:			(Array				with: (Element tag: 'subgroups' elements: self subgroupsAsXmlElements)				with: (Element tag: 'items' elements: self itemsAsXmlElements))</body><body package="Tools-Parcel Manager">itemsAsXmlElements	^items isEmpty		ifTrue: [nil]		ifFalse: [items collect: [:each | each asXmlElement]]</body><body package="Tools-Parcel Manager">subgroupsAsXmlElements	^subgroups isEmpty		ifTrue: [nil]		ifFalse: [subgroups collect: [:each | each asXmlElement]]</body></methods><methods><class-id>Tools.ParcelGroup class</class-id> <category>instance creation</category><body package="Tools-Parcel Manager">named: aString	^self new name: aString; yourself</body><body package="Tools-Parcel Manager">named: aString description: anotherString	^self new 		name: aString; 		description: anotherString;		yourself</body><body package="Tools-Parcel Manager">new	^super new initialize</body></methods><methods><class-id>Tools.ParcelGroup class</class-id> <category>xml reading</category><body package="Tools-Parcel Manager">fromXmlElement: anElement	"Answer a group created from the element.	Signal an error in case of any problems with the element contents."	| groupName description subgroups items |	anElement tag type = 'group' ifFalse: [self invalidXmlElement].	groupName := anElement valueOfAttribute: 'name' ifAbsent: [self invalidXmlElement].	description := anElement valueOfAttribute: 'description' ifAbsent: [self invalidXmlElement].	subgroups := anElement elementNamed: 'subgroups'.	items := anElement elementNamed: 'items'.	subgroups := subgroups realElements collect:		[:each | self fromXmlElement: each].	items := items realElements collect:		[:each | ParcelFileItem fromXmlElement: each].	^(self named: groupName description: description)		addSubgroups: subgroups;		addItems: items;		yourself</body><body package="Tools-Parcel Manager">invalidXmlElement	self error: #InvalidXmlInParcelGroup &lt;&lt; #dialogs &gt;&gt; 'Invalid XML in parcel group definition'</body></methods><methods><class-id>Tools.TopLevelParcelGroup</class-id> <category>accessing</category><body package="Tools-Parcel Manager">goodiesGroup	^goodiesGroup</body><body package="Tools-Parcel Manager">sortedSubgroups	| extraGroups home sorted |	extraGroups := subgroups copy.	extraGroups		remove: visualWorksGroup;		remove: goodiesGroup;		remove: previewGroup.	home := extraGroups detect: [:some | some name = '.'] ifNone: [nil].	sorted := OrderedCollection new.	home notNil ifTrue:		[extraGroups remove: home.		sorted add: home].	sorted 		add: visualWorksGroup;		add: goodiesGroup;		add: previewGroup.	sorted addAll: (extraGroups asSortedCollection: [:a :b | a name &lt;= b name]).	^sorted asArray</body><body package="Tools-Parcel Manager">visualWorksGroup	^visualWorksGroup</body></methods><methods><class-id>Tools.TopLevelParcelGroup</class-id> <category>private</category><body package="Tools-Parcel Manager">findOrCreateGroupFor: aFilename	| group |	group := self findGroup: [:some | some isDirectory and: [some path = aFilename]].	group notNil ifTrue: [^group].	group := ParcelDirectory path: aFilename.	aFilename isVisualWorksFile		ifTrue: [visualWorksGroup addSubgroup: group]		ifFalse: [self addSubgroup: group].	^group</body></methods><methods><class-id>Tools.TopLevelParcelGroup</class-id> <category>initialize-release</category><body package="Tools-Parcel Manager">addEntry: aFilename	(aFilename asString includes: $*) ifTrue:		[^self addWildcardEntry: aFilename].	(self subgroups anySatisfy: [:grp |			grp isDirectory and: [grp path asString = aFilename asString]])		ifFalse:			[aFilename exists ifFalse: [^self].			aFilename isVisualWorksFile 				ifTrue: 					[visualWorksGroup addSubgroup: (ParcelDirectory path: aFilename)]				ifFalse:					[self addSubgroup: (ParcelDirectory path: aFilename)]]</body><body package="Tools-Parcel Manager">addWildcardEntry: aFilename	| directory group groups subGroups |	directory := aFilename directory.	^(directory asString includes: $*) 		ifTrue:			[groups := self addWildcardEntry: directory.			subGroups := OrderedCollection new.			groups do: [:each |				each retrieveSubdirectories.				subGroups addAll: each subgroups].			subGroups]		ifFalse:			[group := self findOrCreateGroupFor: directory.			group retrieveSubdirectories.			group subgroups]</body><body package="Tools-Parcel Manager">initialize	super initialize.	visualWorksGroup := ParcelGroup 		named: (#VisualWorks &lt;&lt; #dialogs &gt;&gt; 'VisualWorks')		description: (#ParcelsSuppliedWithVisualWorks &lt;&lt; #labels &gt;&gt; 'Parcels supplied with VisualWorks.').	self addSubgroup: visualWorksGroup.	goodiesGroup := ParcelDirectory 		path: (Filename fromComponents: #('$(VISUALWORKS)' 'contributed')) 		name: (#Contributed &lt;&lt; #dialogs &gt;&gt; 'Contributed')		description: (#ContributedGroupDescription &lt;&lt; #labels &gt;&gt; 'Third party applications and components. Not supported by Cincom.').	self addSubgroup: goodiesGroup.	previewGroup := ParcelDirectory 		path: (Filename fromComponents: #('$(VISUALWORKS)' 'preview')) 		name: (#Preview &lt;&lt; #dialogs &gt;&gt; 'Preview')		description: (#PreviewGroupDescription &lt;&lt; #dialogs &gt;&gt; 'VisualWorks components still in active development and not yet released officially.').	self addSubgroup: previewGroup</body></methods><methods><class-id>Tools.TopLevelParcelGroup class</class-id> <category>utilities</category><body package="Tools-Parcel Manager">current	"Return the top group for the system as it is at the moment."	"self current"	| topLevel |	topLevel := self new.	(UISettings preferenceFor: #parcelPath) do:		[:each | topLevel addEntry: each].	^topLevel</body><body package="Tools-Parcel Manager">reportUncommentedParcels	"self reportUncommentedParcels"	| top |	Transcript cr; show: (#UncommentedParcels &lt;&lt; #dialogs &gt;&gt; '*** Uncommented parcels ***'); cr.	top := self current.	top withAllSubgroupsDo: 		[:each | 		each isDirectory ifTrue: [each retrieveParcelFiles]].	top allItemsDo:		[:each |		each comment isNil ifTrue:			[Transcript tab; show: each filename asString; cr]].	Transcript show: (#Done &lt;&lt; #dialogs &gt;&gt; '*** done ***')</body></methods><methods><class-id>Tools.ParcelPrereqCollector</class-id> <category>collecting</category><body package="Tools-Parcel Manager">addAllParcels: aParcelCollection	aParcelCollection do: [:each | self addParcel: each].	knownItems do:[:each| each noteIfCircular].</body><body package="Tools-Parcel Manager">addParcel: aParcelFileItem	| item |	item := ParcelPrereqItem new parcel: aParcelFileItem.	self		addKnownPrerequisitesToItem: item;		addItemToKnownPrerequisites: item.	knownItems add: item.	(item references isEmpty or:[ item isCircular]) ifTrue: [topItems add: item].</body></methods><methods><class-id>Tools.ParcelPrereqCollector</class-id> <category>private</category><body package="Tools-Parcel Manager">addItemToKnownPrerequisites: anItem	| itemName |	itemName := anItem name.	knownItems do:		[:each |		(each prerequisitesIncludeName: itemName) ifTrue:			[each addPrerequisiteReference: anItem newReference]]</body><body package="Tools-Parcel Manager">addKnownPrerequisitesToItem: anItem	knownItems do:		[:each |		(anItem prerequisitesIncludeName: each name) ifTrue:			[anItem addPrerequisiteReference: each newReference]].	topItems := topItems reject:		[:any | anItem prerequisitesInclude: any]</body><body package="Tools-Parcel Manager">sorted: parcelCollection	^(parcelCollection asSortedCollection:		[:a :b | a displayString &lt;= b displayString]) 			asArray</body><body package="Tools-Parcel Manager">topLevelOtherItems	^topItems reject: [:each | each isVisualWorksParcel]</body><body package="Tools-Parcel Manager">topLevelVWItems	^topItems select: [:each | each isVisualWorksParcel]</body></methods><methods><class-id>Tools.ParcelPrereqCollector</class-id> <category>initialize-release</category><body package="Tools-Parcel Manager">initialize	knownItems := OrderedCollection new.	topItems := OrderedCollection new</body></methods><methods><class-id>Tools.ParcelPrereqCollector</class-id> <category>accessing</category><body package="Tools-Parcel Manager">asTopLevelItem	^ParcelPrereqItem new prerequisiteItems: 		(self sorted: self topLevelVWItems),		(self sorted: self topLevelOtherItems)</body><body package="Tools-Parcel Manager">protectedPrequisitesFor: aParcelPrereqItem	"Answer the non-circular prerequsites of aParcelPrereqItem"	parentItem		ifNil: 			[parentItem := aParcelPrereqItem.			path := IdentitySet new]		ifNotNil: 			[(parentItem prerequisiteItems includes: aParcelPrereqItem)				ifTrue: [path add: parentItem]				ifFalse: [path := IdentitySet new].			parentItem := aParcelPrereqItem].	^aParcelPrereqItem isCircular		ifTrue: [(aParcelPrereqItem prerequisiteItems asSet - path) asOrderedCollection]		ifFalse: [aParcelPrereqItem prerequisiteItems]</body></methods><methods><class-id>Tools.ParcelPrereqCollector class</class-id> <category>instance creation</category><body package="Tools-Parcel Manager">new	^super new initialize</body><body package="Tools-Parcel Manager">on: parcelHandleCollection	^self new		addAllParcels: parcelHandleCollection;		yourself</body></methods><methods><class-id>Tools.ParcelFileItem</class-id> <category>parcel attributes</category><body package="Tools-Parcel Manager">comment	^(self property: #comment or: [^nil]) first</body><body package="Tools-Parcel Manager">commentOr: aBlock	^(self property: #comment or: [^aBlock value]) first</body><body package="Tools-Parcel Manager">commentOrErrorText	| comment |	^self isAccessible		ifFalse: [(#CannotReadParcelFile &lt;&lt; #dialogs &gt;&gt; 'Cannot read the parcel file') asText emphasizeAllWith: #italic]		ifTrue: 			[comment := self property: #comment or: [nil].			comment notNil				ifTrue: [comment first]				ifFalse: [(#ThisParcelHasNoComment &lt;&lt; #dialogs &gt;&gt; 'This parcel has no comment') asText emphasizeAllWith: #italic]]</body><body package="Tools-Parcel Manager">environment	^nil.</body><body package="Tools-Parcel Manager">format	^self property: #format or: nil</body><body package="Tools-Parcel Manager">name	^self property: #parcel or: nil</body><body package="Tools-Parcel Manager">nameOr: aBlock	^self property: #parcel or: aBlock</body><body package="Tools-Parcel Manager">prerequisites	^self property: #prerequisiteParcels or: nil</body><body package="Tools-Parcel Manager">prerequisitesOr: aBlock	^self property: #prerequisiteParcels or: aBlock</body><body package="Tools-Parcel Manager">propertiesDictionary	^properties</body><body package="Tools-Parcel Manager">timestamp	^self property: #timestamp or: nil</body><body package="Tools-Parcel Manager">version	^self property: #version or: nil</body><body package="Tools-Parcel Manager">versionOr: aBlock	^self property: #version or: aBlock</body></methods><methods><class-id>Tools.ParcelFileItem</class-id> <category>private</category><body package="Tools-Parcel Manager">baseIconKey	^self isAccessible 		ifTrue: [self isLoaded			ifTrue: [#loadedParcel]			ifFalse: [#unloadedParcel]]		ifFalse: [#missingParcel]</body><body package="Tools-Parcel Manager">goodieIconKey	^self isAccessible 		ifTrue: [self isLoaded			ifTrue: [#loadedGoodieParcel]			ifFalse: [#unloadedGoodieParcel]]		ifFalse: [#missingGoodieParcel]</body><body package="Tools-Parcel Manager">iconKey	^self isVisualWorksParcel		ifTrue: [self baseIconKey]		ifFalse: [self goodieIconKey]</body><body package="Tools-Parcel Manager">prerequisitePathWarning	^self prerequisitePath		ifNil: [String new]		ifNotNil: 			[:path |			| pathStream |			pathStream := String new writeStream.			path do: 					[:item |					pathStream						space;						nextPutAll: item name]				separatedBy: [pathStream nextPut: $,].			#cyclicPrequisitesWarning &lt;&lt; #dialogs				&gt;&gt; '--Cyclic Prequisites Detected!:&lt;1s&gt;'					expandMacrosWith: pathStream contents]</body><body package="Tools-Parcel Manager">property: aSymbol or: aBlock	^properties isNil ifTrue: [aBlock value] ifFalse: [properties at: aSymbol ifAbsent: aBlock]</body><body package="Tools-Parcel Manager">retrieveParcelProperties	properties := [CodeReader new readInfoFromFileNamed: self filename]		on: OsError, CodeReader fileFormatSignal 		do: [:ex | ex return: nil]</body></methods><methods><class-id>Tools.ParcelFileItem</class-id> <category>testing</category><body package="Tools-Parcel Manager">isAccessible	"True if info has been loaded from the parcel file; so we know the file is there."	^properties notNil</body><body package="Tools-Parcel Manager">isCircular	^self property: #cyclicPrerequisites  or: false</body><body package="Tools-Parcel Manager">isGoodie	^'*contributed*' match: self filename asString</body><body package="Tools-Parcel Manager">isLoaded	"Answer true if there is a parcel loaded by that name."	| name version loadedParcel |	name := self name.	version := self version.	name isNil ifTrue: [^false].	loadedParcel := Parcel parcelNamed: name.	^loadedParcel notNil 		and: [version isNil or: [loadedParcel version = version]]</body><body package="Tools-Parcel Manager">isPreview	^'*preview*' match: self filename asString</body><body package="Tools-Parcel Manager">isVisualWorksParcel	| nameString |	nameString := self filename asString.	^('*VISUALWORKS*' match: nameString) 		and: [self isGoodie not and: [self isPreview not]]</body><body package="Tools-Parcel Manager">sourceExists	^self sourceFilename		ifNil: [false]		ifNotNil: [:sourceFilename | sourceFilename exists and: [sourceFilename isReadable]]</body></methods><methods><class-id>Tools.ParcelFileItem</class-id> <category>printing</category><body package="Tools-Parcel Manager">description	"Description shows up in the status bar when the parcel is selected."	^(#ParcelStatusDesc &lt;&lt; #dialogs &gt;&gt; '&lt;1?VisualWorks Parcel:Unsupported Goodie&gt; (&lt;2s&gt;): &lt;3s&gt;')		expandMacrosWith: self isVisualWorksParcel		with: self statusString		with: filename asFilename asString</body><body package="Tools-Parcel Manager">displayString	"Display string shows up in various lists."	| name version |	name := self nameOr: [filename tail].	version := self versionOr: ['?'].	^name, ' [', version, ']'</body><body package="Tools-Parcel Manager">printOn: aStream	super printOn: aStream.	aStream		nextPutAll: ' (';		print: (filename ifNotNil: [filename asString]);		nextPutAll: ')'</body><body package="Tools-Parcel Manager">statusString	^self isAccessible 		ifTrue: [self isLoaded ifTrue: [(#loaded &lt;&lt; #labels &gt;&gt; 'loaded')] ifFalse: [(#notLoaded &lt;&lt; #labels &gt;&gt; 'not loaded')]]		ifFalse: [(#parcelFileIsNotFound &lt;&lt; #dialogs &gt;&gt; 'parcel file is not found')]</body></methods><methods><class-id>Tools.ParcelFileItem</class-id> <category>accessing</category><body package="Tools-Parcel Manager">basicIcon	^ListIconLibrary visualFor: self iconKey</body><body package="Tools-Parcel Manager">filename	^filename</body><body package="Tools-Parcel Manager">iconForLists	^self isCircular 		ifTrue:[VisualStack with: self basicIcon with: (ListIconLibrary visualFor: #warningOverlay) ]		ifFalse:[self basicIcon]</body><body package="Tools-Parcel Manager">isCircular: aBoolean	properties ifNotNil:[properties at: #cyclicPrerequisites put: aBoolean]</body><body package="Tools-Parcel Manager">parcelInImage	"Answer the parcel in the image, if it is loaded."	^self name ifNotNil: [:name | Parcel parcelNamed: name]</body><body package="Tools-Parcel Manager">prerequisitePath	^self property: #prerequisitePath or: nil</body><body package="Tools-Parcel Manager">prerequisitePath: aCollection	properties ifNotNil:[properties at: #prerequisitePath put: aCollection]</body><body package="Tools-Parcel Manager">sourceFilename	| extension baseString |	extension := self filename asFilename extension.	baseString := self filename asResolvedString.	baseString := baseString copyFrom: 1 to: baseString size - extension size.	^(baseString, Parcel sourceExtension) asFilename</body></methods><methods><class-id>Tools.ParcelFileItem</class-id> <category>initialize-release</category><body package="Tools-Parcel Manager">filename: aFilename	filename := aFilename.	self retrieveParcelProperties</body></methods><methods><class-id>Tools.ParcelFileItem</class-id> <category>comparing</category><body package="Tools-Parcel Manager">= anotherObject	^self name = anotherObject name</body><body package="Tools-Parcel Manager">hash	^self name hash</body></methods><methods><class-id>Tools.ParcelFileItem</class-id> <category>xml representation</category><body package="Tools-Parcel Manager">asXmlElement	^Element		tag: 'parcel'		elements:			(Array with:				(Element					tag: 'filename'					elements: self filenameAsXmlElements))</body><body package="Tools-Parcel Manager">filenameAsXmlElements	^filename componentStrings collect:		[:each |		Element			tag: 'filename-component'			elements: (Array with: (XML.Text text: each))]</body></methods><methods><class-id>Tools.ParcelFileItem class</class-id> <category>instance creation</category><body package="Tools-Parcel Manager">filename: aFilename	^self new		filename: aFilename;		yourself</body><body package="Tools-Parcel Manager">fromFileNamed: aString in: directoryFilename	^self new		filename: (directoryFilename construct: aString);		yourself</body><body package="Tools-Parcel Manager">name: aString	^self filename: aString asFilename</body></methods><methods><class-id>Tools.ParcelFileItem class</class-id> <category>xml reading</category><body package="Tools-Parcel Manager">fromXmlElement: anElement	| filenameElement components |	filenameElement := anElement elementNamed: 'filename'.	components := filenameElement realElements collect:		[:each | each tag type = 'filename-component'			ifTrue: [each children first text]			ifFalse: [self invalidXmlElement]].	^self filename: (PortableFilename fromComponents: components)</body><body package="Tools-Parcel Manager">invalidXmlElement	self error: #InvalidXmlInParcelItem &lt;&lt; #dialogs &gt;&gt; 'Invalid XML in parcel item definition'</body></methods><methods><class-id>Tools.ParcelSelectionTool</class-id> <category>accessing</category><body package="Tools-Parcel Manager">selectAll	"Subclasses should redefine this to select all displayed parcels."	self subclassResponsibility</body><body package="Tools-Parcel Manager">selections	"Subclasses should redefine this to return a collection of	currently selected parcels."	self subclassResponsibility</body><body package="Tools-Parcel Manager">selections: parcelCollection	"Try to select the parcels in the argument collection. 	Not all of them are necessarily displayed now."	self subclassResponsibility</body></methods><methods><class-id>Tools.ParcelSelectionTool</class-id> <category>notifications</category><body package="Tools-Parcel Manager">parcelDoubleClicked: aSequenceController	| selectedParcels |	selectedParcels := self selections.	((selectedParcels allSatisfy: [:each | each isLoaded])		and: [self confirmUnloadOf: selectedParcels])			ifTrue: [^manager unloadParcels: selectedParcels].	((selectedParcels allSatisfy: [:each | each isLoaded not])		and: [self confirmLoadOf: selectedParcels])			ifTrue: [^manager loadParcels: selectedParcels]</body><body package="Tools-Parcel Manager">parcelSelected	manager selectedParcels: self selections</body></methods><methods><class-id>Tools.ParcelSelectionTool</class-id> <category>actions</category><body package="Tools-Parcel Manager">browseParcels	manager browseParcels</body><body package="Tools-Parcel Manager">loadParcels	manager loadParcels: self selections</body><body package="Tools-Parcel Manager">openChanges	manager openChanges</body><body package="Tools-Parcel Manager">openConflicts	manager openConflicts</body><body package="Tools-Parcel Manager">unloadParcels	manager unloadParcels: self selections</body></methods><methods><class-id>Tools.ParcelSelectionTool</class-id> <category>testing</category><body package="Tools-Parcel Manager">canBrowse	^self canUnload "since that means all selections are loaded"</body><body package="Tools-Parcel Manager">canLoad	| selections |	selections := self selections.	^selections isEmpty not and:		[selections allSatisfy: 			[:each | each isLoaded not and: [each isAccessible]]]</body><body package="Tools-Parcel Manager">canUnload	| selections |	selections := self selections.	^selections isEmpty not and:		[selections allSatisfy: [:each | each isLoaded]]</body><body package="Tools-Parcel Manager">selectionsHaveSource	| selections |	selections := self selections.	^selections notEmpty and:		[selections allSatisfy: [:each | each sourceExists]]</body></methods><methods><class-id>Tools.ParcelSelectionTool</class-id> <category>private</category><body package="Tools-Parcel Manager">confirmLoadOf: parcelCollection	| message |	message := parcelCollection size = 1 		ifTrue:			[(#Load1sQ &lt;&lt; #dialogs &gt;&gt; 'Load "&lt;1s&gt;"?') expandMacrosWith: parcelCollection first displayString]		ifFalse:			[(#LoadSelectedParcelsQ &lt;&lt; #dialogs &gt;&gt; 'Load selected parcels?')].	^Dialog confirm: message</body><body package="Tools-Parcel Manager">confirmUnloadOf: parcelCollection	| message |	message := parcelCollection size = 1 		ifTrue:			[(#Unload1sQ &lt;&lt; #dialogs &gt;&gt; 'Unload "&lt;1s&gt;"?') expandMacrosWith: parcelCollection first displayString]		ifFalse:			[(#UnloadSelectedParcelsQ &lt;&lt; #dialogs &gt;&gt; 'Unload selected parcels?')].	^Dialog confirm: message</body><body package="Tools-Parcel Manager">popupMenu	| menu |	menu := self class basicParcelMenu.	(menu atNameKey: #load) enabled: [self canLoad].	(menu atNameKey: #unload) enabled: [self canUnload].	(menu atNameKey: #openChanges) enabled: [self selectionsHaveSource].	(menu atNameKey: #openConflicts) enabled: [self selectionsHaveSource].	(menu atNameKey: #browse) enabled: [self canBrowse].	^menu</body></methods><methods><class-id>Tools.ParcelListTool</class-id> <category>accessing</category><body package="Tools-Parcel Manager">parcelStatusWarning	| warning |	warning := String new.	self parcelListHolder selectionDo:[:each| warning := warning, '.  ', each prerequisitePathWarning].	^warning</body><body package="Tools-Parcel Manager">parcels: parcelCollection 	| collector |	collector := ParcelPrereqCollector new.	collector addAllParcels: parcelCollection.	self parcelListHolder list: (self sorted: parcelCollection) asList.</body><body package="Tools-Parcel Manager">selectAll	self parcelListHolder selectAll</body><body package="Tools-Parcel Manager">selections	^self orderedSelectionsOf: self parcelListHolder</body><body package="Tools-Parcel Manager">selections: parcelCollection	self parcelListHolder selections: parcelCollection</body><body package="Tools-Parcel Manager">warningForParcelNamed: aString	^(self parcelListHolder list detect: [:any | any name = aString] ifNone: [^String new]) prerequisitePathWarning</body></methods><methods><class-id>Tools.ParcelListTool</class-id> <category>private</category><body package="Tools-Parcel Manager">createItemOf: aView at: index reversing: aBoolean 	| item label |	item := aView sequence at: index.	label := self createLabelAndIconOf: item for: aView.	^aBoolean 		ifTrue: [(ReversingWrapper on: label) reverse: true asValue]		ifFalse: [label]</body><body package="Tools-Parcel Manager">createLabelAndIconOf: item for: aView 	^(ExtendedLabelAndIcon		with: item displayString		attributes: aView textStyle		offset: 0 @ 0)			icon: item iconForLists; 			yourself</body><body package="Tools-Parcel Manager">selectedVisualBlock	^[:view :index | 	BoundedWrapper on: 		(self createItemOf: view at: index reversing: true)]</body><body package="Tools-Parcel Manager">sorted: parcelCollection 	^(parcelCollection 		asSortedCollection: [:a :b | a displayString &lt;= b displayString])			asArray</body><body package="Tools-Parcel Manager">unselectedVisualBlock		^[:view :index | 	BoundedWrapper on: 		(self createItemOf: view at: index reversing: false)]</body></methods><methods><class-id>Tools.ParcelListTool</class-id> <category>initialize-release</category><body package="Tools-Parcel Manager">initialize	self parcelListHolder selectionIndexHolder		onChangeSend: #parcelSelected to: self</body><body package="Tools-Parcel Manager">postBuildWith: aBuilder 	| listWidget |	listWidget := (aBuilder componentAt: #parcelList) widget.	listWidget visualBlock: self unselectedVisualBlock.	listWidget selectedVisualBlock: self selectedVisualBlock</body></methods><methods><class-id>Tools.ParcelListTool</class-id> <category>aspects</category><body package="Tools-Parcel Manager">parcelListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^parcelListHolder isNil		ifTrue:			[parcelListHolder := MultiSelectionInList new]		ifFalse:			[parcelListHolder]</body></methods><methods><class-id>Tools.ParcelListTool class</class-id> <category>accessing</category><body package="Tools-Parcel Manager">tabLabel	^(#Alphabetical &lt;&lt; #labels &gt;&gt; 'Alphabetical') asString</body></methods><methods><class-id>Tools.ParcelDirectory</class-id> <category>initialize-release</category><body package="Tools-Parcel Manager">initialize	super initialize.	items := nil</body><body package="Tools-Parcel Manager">path: aPathname	path := aPathname.	name := aPathname tail</body><body package="Tools-Parcel Manager">retrieveParcelFiles	| fileNames |	fileNames := [path asFilename directoryContents]		on: OsError		do: [:ex | items := Array new. ^self].	items := (self selectParcelsAmong: fileNames)</body><body package="Tools-Parcel Manager">retrieveSubdirectories	| fileNames |	subgroups isEmpty ifFalse: [^self].	fileNames := [path asFilename directoryContents]		on: OsError		do: [:ex | ^self].	subgroups addAll: (self selectDirectoriesAmong: fileNames)</body></methods><methods><class-id>Tools.ParcelDirectory</class-id> <category>testing</category><body package="Tools-Parcel Manager">isDirectory	^true</body></methods><methods><class-id>Tools.ParcelDirectory</class-id> <category>accessing</category><body package="Tools-Parcel Manager">description	^description isNil		ifTrue: [(#Directory1s &lt;&lt; #dialogs &gt;&gt; 'Directory "&lt;1s&gt;"') expandMacrosWith: path asFilename asString]		ifFalse: [description]</body><body package="Tools-Parcel Manager">items	items isNil ifTrue: [self retrieveParcelFiles].	^items</body><body package="Tools-Parcel Manager">path	^path</body></methods><methods><class-id>Tools.ParcelDirectory</class-id> <category>private</category><body package="Tools-Parcel Manager">selectDirectoriesAmong: aCollection	| parcels |	parcels := OrderedCollection new.	aCollection		do:			[:each | 			| file |			file := path construct: each.			file isDirectory ifTrue: [parcels add: (ParcelDirectory path: file)]].	^parcels</body><body package="Tools-Parcel Manager">selectParcelsAmong: aCollection 	| pattern parcels |	pattern := '*' , Parcel fileExtension.	parcels := OrderedCollection new.	aCollection do: 			[:each | 			(pattern match: each) 				ifTrue: [parcels add: (ParcelFileItem fromFileNamed: each in: path)]].	^parcels</body></methods><methods><class-id>Tools.ParcelDirectory class</class-id> <category>instance creation</category><body package="Tools-Parcel Manager">path: aFilename	^self new		path: aFilename;		yourself</body><body package="Tools-Parcel Manager">path: aFilename name: aString	^self new		path: aFilename;		name: aString;		yourself</body><body package="Tools-Parcel Manager">path: aFilename name: aString description: anotherString	^self new		path: aFilename;		name: aString;		description: anotherString;		yourself</body></methods><methods><class-id>Tools.ParcelInImageItem</class-id> <category>testing</category><body package="Tools-Parcel Manager">isAccessible	^true "tentatively"</body><body package="Tools-Parcel Manager">isGoodie	^self filenameComponents includes: 'contributed'</body><body package="Tools-Parcel Manager">isLoaded	^parcel isLoaded</body><body package="Tools-Parcel Manager">isPreview	^self filenameComponents includes: 'preview'</body></methods><methods><class-id>Tools.ParcelInImageItem</class-id> <category>initialize-release</category><body package="Tools-Parcel Manager">parcel: aParcel	parcel := aParcel.	self retrieveParcelProperties.</body></methods><methods><class-id>Tools.ParcelInImageItem</class-id> <category>accessing</category><body package="Tools-Parcel Manager">commentOr: aBlock	^parcel comment</body><body package="Tools-Parcel Manager">commentOrErrorText	^parcel comment</body><body package="Tools-Parcel Manager">environment	parcel isNil ifTrue: [^nil].	^parcel environment.</body><body package="Tools-Parcel Manager">filename	| components |	components := self filenameComponents.	^components isEmpty		ifTrue: [String new]		ifFalse: 			[LogicalFilename fromComponents: ((components copy) 						at: components size put: components last , '.pcl';						yourself)]</body><body package="Tools-Parcel Manager">filenameComponents	^parcel propertyAt: #parcel ifAbsent: [Array new]</body><body package="Tools-Parcel Manager">name	^parcel name</body><body package="Tools-Parcel Manager">nameOr: aBlock	^parcel name</body><body package="Tools-Parcel Manager">parcel	^parcel</body><body package="Tools-Parcel Manager">parcelInImage	^parcel</body><body package="Tools-Parcel Manager">prerequisitesOr: aBlock	^parcel propertyAt: #prerequisiteParcels ifAbsent: aBlock</body><body package="Tools-Parcel Manager">propertiesDictionary	^parcel properties</body><body package="Tools-Parcel Manager">sourceFilename	| baseComponents |	baseComponents := self filenameComponents.	baseComponents isEmpty ifTrue: [^nil].	^((LogicalFilename fromComponents: baseComponents)		asResolvedString, Parcel sourceExtension) asFilename</body></methods><methods><class-id>Tools.ParcelInImageItem</class-id> <category>printing</category><body package="Tools-Parcel Manager">description	^(#ParcelInImageItemDesc &lt;&lt; #dialogs &gt;&gt; '&lt;1?VisualWorks Parcel:Unsupported Goodie&gt;: &lt;2s&gt;')		expandMacrosWith: self isVisualWorksParcel		with: self filename asString</body><body package="Tools-Parcel Manager">displayString	| name version |	name := parcel name.	version := parcel version.	version isNil ifTrue: [version := '?'].	^name, ' [', version, ']'</body></methods><methods><class-id>Tools.ParcelPrereqItem</class-id> <category>accessing</category><body package="Tools-Parcel Manager">addPrerequisiteReference: anItemReference	prerequisiteReferences add: anItemReference</body><body package="Tools-Parcel Manager">iconForLists	^self isCircular 		ifTrue:[VisualStack with: parcel basicIcon with: (ListIconLibrary visualFor: #warningOverlay) ]		ifFalse:[parcel basicIcon]</body><body package="Tools-Parcel Manager">name	^parcel nameOr: [String new]</body><body package="Tools-Parcel Manager">newReference	| reference |	reference := ParcelPrereqReference new item: self.	references add: reference.	^reference</body><body package="Tools-Parcel Manager">noteIfCircular	self isCircular		ifTrue: 			[parcel isCircular: true.			parcel prerequisitePath: self prerequisitePath]		ifFalse: [parcel isCircular: false]</body><body package="Tools-Parcel Manager">parcel	^parcel</body><body package="Tools-Parcel Manager">prerequisiteCount	^prerequisiteReferences size</body><body package="Tools-Parcel Manager">prerequisiteItems	^self prerequisiteReferences collect: [:each | each item]</body><body package="Tools-Parcel Manager">prerequisitePathTo: aParcelPrereqItem ignoring: aCollection	| prerequisites |	(aCollection includes: self) ifTrue: [^nil].	prerequisites := self prerequisiteItems.	(prerequisites includes: aParcelPrereqItem) ifTrue: [^Array with: aParcelPrereqItem].	aCollection add: self.	prerequisites do: 			[:each |			(each prerequisitePathTo: aParcelPrereqItem ignoring: aCollection)				ifNotNil: [:path | ^(Array with: each) , path]].	^nil</body><body package="Tools-Parcel Manager">prerequisiteReferences	^(prerequisiteReferences asSortedCollection: 		[:a :b | 		(prerequisiteNames indexOf: a name) &lt;= 			(prerequisiteNames indexOf: b name)]) 				asArray</body><body package="Tools-Parcel Manager">prerequisitesInclude: anItem	^prerequisiteReferences anySatisfy: [:any | any refersTo: anItem]</body><body package="Tools-Parcel Manager">prerequisitesIncludeName: aString	^prerequisiteNames includes: aString</body><body package="Tools-Parcel Manager">referenceCount	^references size</body><body package="Tools-Parcel Manager">references	^references</body></methods><methods><class-id>Tools.ParcelPrereqItem</class-id> <category>testing</category><body package="Tools-Parcel Manager">isCircular	^self prerequisitePath notNil</body><body package="Tools-Parcel Manager">isGoodie	^parcel isGoodie</body><body package="Tools-Parcel Manager">isLoaded	^parcel isLoaded</body><body package="Tools-Parcel Manager">isOneOfMany	^self referenceCount &gt; 1</body><body package="Tools-Parcel Manager">isPreview	^parcel isPreview</body><body package="Tools-Parcel Manager">isVisualWorksParcel	^parcel isVisualWorksParcel</body><body package="Tools-Parcel Manager">prerequisitePath	^self prerequisitePathTo: self ignoring: IdentitySet new</body></methods><methods><class-id>Tools.ParcelPrereqItem</class-id> <category>initialize-release</category><body package="Tools-Parcel Manager">parcel: aParcelFileItem	parcel :=   aParcelFileItem.	prerequisiteNames := parcel prerequisitesOr: [OrderedCollection new].	prerequisiteNames := prerequisiteNames collect: [:each | each first].	prerequisiteReferences := OrderedCollection new.	references := OrderedCollection new</body><body package="Tools-Parcel Manager">prerequisiteItems: aCollection	prerequisiteReferences := aCollection collect: 		[:each | ParcelPrereqReference new item: each].	prerequisiteNames := aCollection collect: [:each | each name]</body></methods><methods><class-id>Tools.ParcelPrereqItem</class-id> <category>printing</category><body package="Tools-Parcel Manager">displayString	^parcel displayString</body><body package="Tools-Parcel Manager">printOn: aStream	super printOn: aStream.	aStream 		space;		print: self name;		space;		print: self prerequisiteCount</body></methods><methods><class-id>Tools.ParcelPrereqItem</class-id> <category>comparing</category><body package="Tools-Parcel Manager">= anotherItem	^parcel = anotherItem parcel</body><body package="Tools-Parcel Manager">hash	^parcel hash</body></methods><methods><class-id>Tools.ParcelPrereqItem</class-id> <category>private</category><body package="Tools-Parcel Manager">prerequisitePathWarning	^self prerequisitePath		ifNil: [String new]		ifNotNil: 			[:path |			| pathStream |			pathStream := String new writeStream.			path do: 					[:item |					pathStream						space;						nextPutAll: item name]				separatedBy: [pathStream nextPut: $,].			#cyclicPrequisitesWarning &lt;&lt; #dialogs				&gt;&gt; '--Cyclic Prequisites Detected!:&lt;1s&gt;'					expandMacrosWith: pathStream contents]</body></methods><methods><class-id>Tools.ParcelPrereqTreeTool</class-id> <category>aspects</category><body package="Tools-Parcel Manager">itemTree	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^itemTree isNil		ifTrue:			[itemTree := MultiSelectionInTree new]		ifFalse:			[itemTree]</body></methods><methods><class-id>Tools.ParcelPrereqTreeTool</class-id> <category>initialize-release</category><body package="Tools-Parcel Manager">initialize	self itemTree selectionIndexHolder		onChangeSend: #parcelSelected to: self</body><body package="Tools-Parcel Manager">parcels: aCollection 	| collector |	collector := ParcelPrereqCollector new.	collector addAllParcels: aCollection.	self itemTree list: (TreeModel 		on: collector asTopLevelItem		displayRoot: false		childrenWith: [:item | collector protectedPrequisitesFor: item]).	builder notNil 		ifTrue: [(builder componentAt: #itemTree) widget controller expandFullyRoot]</body><body package="Tools-Parcel Manager">postBuildWith: aBuilder	(aBuilder componentAt: #itemTree) widget controller		expandFullyRoot</body></methods><methods><class-id>Tools.ParcelPrereqTreeTool</class-id> <category>accessing</category><body package="Tools-Parcel Manager">parcelStatusWarning	^self itemTree selection prerequisitePathWarning</body><body package="Tools-Parcel Manager">selectAll	self itemTree selectAll</body><body package="Tools-Parcel Manager">selections	^(self orderedSelectionsOf: self itemTree) collect: [:each | each parcel]</body><body package="Tools-Parcel Manager">selections: parcelCollection	self itemTree selections: 		(parcelCollection collect: [:each | ParcelPrereqItem new parcel: each])</body><body package="Tools-Parcel Manager">warningForParcelNamed: aString	^(self  itemTree list detect:[:any| any name = aString] ifNone:[^String new]) prerequisitePathWarning</body></methods><methods><class-id>Tools.ParcelPrereqTreeTool class</class-id> <category>accessing</category><body package="Tools-Parcel Manager">tabLabel	^(#PrerequisiteTree &lt;&lt; #labels &gt;&gt; 'Prerequisite Tree') asString</body></methods><methods><class-id>Tools.ParcelPropertiesTool</class-id> <category>private</category><body package="Tools-Parcel Manager">multipleParcelInformation: parcelFileCollection	| stream |	stream := TextStream on: (String new: 100).	parcelFileCollection do:		[:each |		stream 			nextPutAllText: each name asText allBold;			nextPutAll: ': '; cr;			nextPutAllText: (self singleParcelInformation: each);			cr; cr].	^stream contents</body><body package="Tools-Parcel Manager">parcelInformationFor: parcelFileCollection	parcelFileCollection size = 0 ifTrue: [^String new].	parcelFileCollection size = 1 ifTrue: [^self singleParcelInformation: parcelFileCollection first].	^self multipleParcelInformation: parcelFileCollection</body><body package="Tools-Parcel Manager">singleParcelInformation: aParcelFile	| stream info keys |	stream := TextStream on: (String new: 100).	info := aParcelFile propertiesDictionary.	info isNil		ifTrue: 			[^(#CannotReadParcelFile &lt;&lt; #dialogs &gt;&gt; 'Cannot read the parcel file')				asText emphasizeAllWith: #italic].	keys := info keys asSortedCollection copyWithout: #comment.	keys := keys copyWithout: #prerequisitePath.	keys do: 			[:each |			| value |			stream				nextPutAllText: each asText allBold;				nextPutAll: ': '.			value := info at: each.			value isString				ifTrue: [stream nextPutAll: value]				ifFalse: [stream print: value]]		separatedBy: [stream cr].	stream		cr;		addEmphasis: #color -&gt; ColorValue red;		nextPutAll: (manager warningForParcelNamed: aParcelFile name).	^stream contents</body></methods><methods><class-id>Tools.ParcelPropertiesTool</class-id> <category>accessing</category><body package="Tools-Parcel Manager">parcels: parcelFileCollection	self textHolder value: (self parcelInformationFor: parcelFileCollection)</body></methods><methods><class-id>Tools.ParcelPropertiesTool</class-id> <category>aspects</category><body package="Tools-Parcel Manager">textHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^textHolder isNil		ifTrue:			[textHolder := String new asValue]		ifFalse:			[textHolder]</body></methods><methods><class-id>Tools.ParcelPropertiesTool</class-id> <category>initialize-release</category><body package="Tools-Parcel Manager">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self adjustReadOnlyWidgetBackground: #text with: aBuilder</body></methods><methods><class-id>Tools.ParcelPropertiesTool class</class-id> <category>accessing</category><body package="Tools-Parcel Manager">tabLabel	^(#Properties &lt;&lt; #labels &gt;&gt; 'Properties') asString</body></methods><methods><class-id>Tools.ParcelManager</class-id> <category>aspects</category><body package="Tools-Parcel Manager">categoryHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^categoryHolder isNil		ifTrue:			[categoryHolder := SelectionInList new]		ifFalse:			[categoryHolder]</body><body package="Tools-Parcel Manager">detailHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^detailHolder isNil		ifTrue:			[detailHolder := SelectionInList new]		ifFalse:			[detailHolder]</body><body package="Tools-Parcel Manager">parcelHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^parcelHolder isNil		ifTrue:			[parcelHolder := SelectionInList new]		ifFalse:			[parcelHolder]</body><body package="Tools-Parcel Manager">statusTextHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^statusTextHolder isNil		ifTrue:			[statusTextHolder := String new asValue]		ifFalse:			[statusTextHolder]</body></methods><methods><class-id>Tools.ParcelManager</class-id> <category>private</category><body package="Tools-Parcel Manager">checkForDanglingReferences: aParcel	aParcel hasDanglingReferencesIfUnloaded ifTrue:		[^Dialog confirm: ((#ParcelHasDanglingRefs &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; has dangling references.&lt;n&gt;Do you really want to unload the parcel''s code?')			expandMacrosWith: aParcel name)].	^true</body><body package="Tools-Parcel Manager">createCategoryClient: aClass	categorySubapplication := aClass new.	categorySubapplication manager: self.	^categorySubapplication</body><body package="Tools-Parcel Manager">createDetailClient: aClass	detailSubapplication := aClass new.	detailSubapplication 		manager: self;		parcels: selectedParcels.	^detailSubapplication</body><body package="Tools-Parcel Manager">createParcelClient: aClass 	parcelSubapplication := aClass new.	parcelSubapplication		manager: self;		parcels: displayedParcels.	^parcelSubapplication</body><body package="Tools-Parcel Manager">descriptionOfGroups: groupCollection	groupCollection isEmpty ifTrue: [^(#NoSelection &lt;&lt; #dialogs &gt;&gt; 'No selection')].	groupCollection size = 1 ifTrue: [^groupCollection first description].	^((#x1sGroupsSelected &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; groups selected')			expandMacrosWith: groupCollection size printString)</body><body package="Tools-Parcel Manager">descriptionOfParcel: aParcelFile	^aParcelFile description , self parcelStatusWarning</body><body package="Tools-Parcel Manager">descriptionOfParcels: parcelCollection	parcelCollection size = 1 ifTrue: [^self descriptionOfParcel: parcelCollection first].	^((#x1sParcelsSelected &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; parcels selected')			expandMacrosWith: parcelCollection size printString)</body><body package="Tools-Parcel Manager">displayLoadFailureSummary: filenameCollection	| messageStream |	messageStream := String new writeStream.	messageStream nextPutAll: (#LoadFailureSummary &lt;&lt; #dialogs &gt;&gt; 'The following parcels could not be loaded due to OS errors:') asString; cr.	filenameCollection do: [:each | messageStream nextPutAll: each asString; cr].	^Dialog warn: messageStream contents</body><body package="Tools-Parcel Manager">parcelStatusWarning	^parcelSubapplication parcelStatusWarning</body><body package="Tools-Parcel Manager">parcelsSortedForUnload: parcelCollection	| parcels |	parcels := (parcelCollection collect: [:each | Parcel parcelNamed: each name]) 		reject: [:some | some isNil].	^(SystemUtils sortForLoading: parcels) reverse</body><body package="Tools-Parcel Manager">postUnloadParcel	(Dialog confirm: (#removeCategoriesAndPurge &lt;&lt; #dialogs &gt;&gt; 'Remove empty categories and purge Undeclared?')) ifTrue: 		[Cursor execute showWhile: 			[Root allNameSpaces do: [:ns | ns organization removeEmptyCategories].			ClassOrganizer allInstancesDo: [:clo | clo removeEmptyCategories].			Undeclared purgeUnusedBindings]]</body><body package="Tools-Parcel Manager">refreshAll	self		refreshToolbar;		refreshStatusBar.	builder window component invalidate "to force icon repaint"</body><body package="Tools-Parcel Manager">refreshStatusBar	self statusTextHolder value: self statusBarText</body><body package="Tools-Parcel Manager">refreshToolbar	| toolbar sourceExists |	toolbar := builder componentAt: #toolbarMenu.	toolbar isNil ifTrue: [^self].	(toolbar componentAt: #load) isEnabled: self canLoad.	(toolbar componentAt: #unload) isEnabled: self canUnload.	sourceExists := self selectionsHaveSource.	(toolbar componentAt: #openChanges) isEnabled: sourceExists.	(toolbar componentAt: #openConflicts) isEnabled: sourceExists.	(toolbar componentAt: #browse) isEnabled: self canBrowse.	(toolbar componentAt: #selectAll) isEnabled: self anyParcelsDisplayed</body><body package="Tools-Parcel Manager">statusBarText	^selectedParcels isEmpty 		ifTrue: [self descriptionOfGroups: selectedGroups]		ifFalse: [self descriptionOfParcels: selectedParcels]</body><body package="Tools-Parcel Manager">warningForParcelNamed: aString	^parcelSubapplication  warningForParcelNamed: aString</body></methods><methods><class-id>Tools.ParcelManager</class-id> <category>notifications</category><body package="Tools-Parcel Manager">categoryTabSelected	| clientClass |	clientClass := self categoryHolder selection.	clientClass isNil ifTrue: [^self].	self selectedGroups: Array new.	Cursor wait showWhile:		[(builder componentAt: #categoryNotebook) widget			client: (self createCategoryClient: clientClass)			spec: #windowSpec			builder: builder newSubBuilder]</body><body package="Tools-Parcel Manager">detailTabSelected	| clientClass |	clientClass := self detailHolder selection.	clientClass isNil ifTrue: [^self].	(builder componentAt: #detailNotebook) widget		client: (self createDetailClient: clientClass)		spec: #windowSpec		builder: builder newSubBuilder</body><body package="Tools-Parcel Manager">parcelTabSelected	| clientClass oldSelections |	clientClass := self parcelHolder selection.	clientClass isNil ifTrue: [^self].	oldSelections := selectedParcels.	(builder componentAt: #parcelNotebook) widget		client: (self createParcelClient: clientClass)		spec: #windowSpec		builder: builder newSubBuilder.	parcelSubapplication selections: oldSelections</body><body package="Tools-Parcel Manager">selectedGroups: aGroupCollection 	Cursor wait showWhile:		[selectedGroups := aGroupCollection.		displayedParcels := OrderedCollection new.		aGroupCollection do: [:each | displayedParcels addAll: each items].		parcelSubapplication notNil 			ifTrue: [parcelSubapplication parcels: displayedParcels].		self refreshStatusBar]</body><body package="Tools-Parcel Manager">selectedParcels: aCollection	"Sent by the subapplication that manages parcel lists, whenever a	new set of parcels selected."	selectedParcels := aCollection.	detailSubapplication notNil ifTrue: 		[detailSubapplication parcels: selectedParcels].	self 		refreshToolbar;		refreshStatusBar</body></methods><methods><class-id>Tools.ParcelManager</class-id> <category>initialize-release</category><body package="Tools-Parcel Manager">initialize	selectedGroups := 	displayedParcels := 	selectedParcels := Array new.	self 		initializeCategoryModel;		initializeParcelModel;		initializeDetailModel</body><body package="Tools-Parcel Manager">initializeCategoryModel	self categoryHolder 		list: (List with: ParcelFavoritesTool with: ParcelDirectoriesTool with: ParcelLoadedTool).	self categoryHolder selectionIndexHolder 		onChangeSend: #categoryTabSelected		to: self.</body><body package="Tools-Parcel Manager">initializeDetailModel	self detailHolder 		list: (List with: ParcelCommentTool with: ParcelPropertiesTool).	self detailHolder selectionIndexHolder onChangeSend: #detailTabSelected		to: self</body><body package="Tools-Parcel Manager">initializeParcelModel	self parcelHolder 		list: (List with: ParcelListTool with: ParcelPrereqTreeTool).	self parcelHolder selectionIndexHolder onChangeSend: #parcelTabSelected		to: self</body><body package="Tools-Parcel Manager">postBuildWith: aBuilder	#(categoryNotebook parcelNotebook detailNotebook) do:		[:each | 		(aBuilder componentAt: each) widget tabBar component "ugh"			displayStringSelector: #tabLabel].	self categoryHolder selectionIndex: 1.	self parcelHolder selectionIndex: 1.	self detailHolder selectionIndex: 1</body><body package="Tools-Parcel Manager">postOpenWith: aBuilder	self refreshToolbar; refreshStatusBar</body></methods><methods><class-id>Tools.ParcelManager</class-id> <category>testing</category><body package="Tools-Parcel Manager">anyParcelsDisplayed	^displayedParcels isEmpty not</body><body package="Tools-Parcel Manager">canBrowse	^selectedParcels size = 1 and: [self canUnload "that is, it is loaded"]</body><body package="Tools-Parcel Manager">canLoad	^selectedParcels isEmpty not and:		[selectedParcels allSatisfy: 			[:each | each isLoaded not and: [each isAccessible]]]</body><body package="Tools-Parcel Manager">canUnload	^selectedParcels isEmpty not and:		[selectedParcels allSatisfy: [:each | each isLoaded]]</body><body package="Tools-Parcel Manager">selectionsHaveSource	^selectedParcels notEmpty and:		[selectedParcels allSatisfy: [:each | each sourceExists]]</body></methods><methods><class-id>Tools.ParcelManager</class-id> <category>actions</category><body package="Tools-Parcel Manager">aboutVisualWorks	AboutVisualWorksDialog open</body><body package="Tools-Parcel Manager">browseParcels		| state modules |	modules := ((selectedParcels collect: #parcelInImage) collect: #pundleInImage) reject: #isNil.	modules isEmpty ifTrue: [^self].	state := NavigatorState new.	state pundles: modules.	RefactoringBrowser openWithSelection: state</body><body package="Tools-Parcel Manager">helpTopics	'topic:vw.help.tools.parcelManager' asURI open</body><body package="Tools-Parcel Manager">loadParcelFromFile	| filename parcel parcelHandle |	filename := Dialog requestFileName: (#OpenParcel &lt;&lt; #dialogs &gt;&gt; 'Open parcel') default: '*.pcl'.	filename isEmpty ifTrue: [^self].	Notice 		show: (#LoadingParcelFromFileN1S &lt;&lt; #dialogs &gt;&gt; 'Loading Parcel from file&lt;n&gt;&lt;1s&gt;' expandMacrosWith: filename asString)		while: 			[parcel := Parcel loadParcelFrom: filename].	parcel isNil ifTrue: [^self].	self categoryHolder selection: ParcelLoadedTool.	parcelHandle := ParcelInImageItem new parcel: parcel.	parcelHandle isVisualWorksParcel		ifTrue: [categorySubapplication selectVisualWorksFolder]		ifFalse: [parcelHandle isGoodie			ifTrue: [categorySubapplication selectGoodiesFolder]			ifFalse: [parcelHandle isPreview				ifTrue: [categorySubapplication selectPreviewFolder]				ifFalse: [categorySubapplication selectOtherFolder]]].	parcelSubapplication selections: (Array with: parcelHandle)</body><body package="Tools-Parcel Manager">loadParcels	self loadParcels: selectedParcels</body><body package="Tools-Parcel Manager">loadParcels: parcelCollection	Notice 		show: (#LoadingParcelOrParcels &lt;&lt; #dialogs &gt;&gt; 'Loading &lt;1?Parcels:Parcel&gt;' expandMacrosWith: parcelCollection size &gt; 1)		while: 			[ | paths |			paths := parcelCollection collect: [:each | each filename].			paths do: [:each | 				[Parcel loadParcelFrom: each]					on: OsError					do: [:ex | Dialog 						report: (#ErrorLoadingParcel1S &lt;&lt; #dialogs &gt;&gt; 'Error loading parcel &lt;1s&gt;' expandMacrosWith: each asString)						withTextSignalledBy: ex]]].	self refreshAll</body><body package="Tools-Parcel Manager">openChanges	selectedParcels do:		[:each | ChangeList openOnFileNamed: each sourceFilename]</body><body package="Tools-Parcel Manager">openConflicts	selectedParcels do:		[:each |		| changeList |		changeList := ChangeList new.		changeList			checkSystem: #exact;			showConflicts: true;			scanFilename: each sourceFilename.		changeList open]</body><body package="Tools-Parcel Manager">selectAll	parcelSubapplication selectAll</body><body package="Tools-Parcel Manager">unloadParcels	self unloadParcels: selectedParcels</body><body package="Tools-Parcel Manager">unloadParcels: parcelCollection	Notice 		show: (#UnloadingParcelOrParcels &lt;&lt; #dialogs &gt;&gt; 'Unloading &lt;1?Parcels:Parcel&gt;' expandMacrosWith: parcelCollection size &gt; 1)		while: 			[ | parcels |			parcels := self parcelsSortedForUnload: parcelCollection.			parcels do: 				[:parcel |				(self checkForDanglingReferences: parcel) ifFalse: [^self].				(Parcel unloadParcelNamed: parcel name) ifTrue:					[self postUnloadParcel]]].	categorySubapplication refresh.	self refreshAll</body></methods><methods><class-id>Tools.ParcelManager class</class-id> <category>generated resources</category><body package="Tools-Parcel Manager">browseIcon	^ToolbarIconLibrary default enablementVisualFor: #parcelBrowser</body><body package="Tools-Parcel Manager">changeListConflictsIcon	^ToolbarIconLibrary default enablementVisualFor: #changeListConflicts</body><body package="Tools-Parcel Manager">changeListIcon	^ToolbarIconLibrary default enablementVisualFor: #changeList</body><body package="Tools-Parcel Manager">loadIcon	^ToolbarIconLibrary default enablementVisualFor: #loadParcel</body><body package="Tools-Parcel Manager">selectAllIcon	^ToolbarIconLibrary default enablementVisualFor: #selectAll</body><body package="Tools-Parcel Manager">unloadIcon	^ToolbarIconLibrary default enablementVisualFor: #unloadParcel</body></methods><methods><class-id>Tools.ParcelManager class</class-id> <category>interface opening</category><body package="Tools-Parcel Manager">open	"Override to use the currently-open manager, if one exists."	^self raiseSingleInstance ifNil: [super open]</body></methods><methods><class-id>OS.LogicalFilename</class-id> <category>testing</category><body package="Tools-Parcel Manager">isVisualWorksFile	^components first isString not		and: [components first name = 'VISUALWORKS']</body></methods><methods><class-id>OS.Filename</class-id> <category>testing</category><body package="Tools-Parcel Manager">isVisualWorksFile	"We always specify files that we want to later recognize	as VW components as logical filenames, so this guy is not."	^false</body></methods><methods><class-id>Tools.VisualLauncher class</class-id> <category>generated resources</category><body package="Tools-Parcel Manager">cardfile	^ToolbarIconLibrary visualFor: #cardfile</body></methods><methods><class-id>Tools.ParcelCommentTool class</class-id> <category>interface specs</category><body package="Tools-Parcel Manager">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 512 384 712 584 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #text 					#model: #textHolder 					#isReadOnly: true 					#tabRequiresControl: true ) ) ) )</body></methods><methods><class-id>Tools.ParcelDirectoriesTool class</class-id> <category>interface specs</category><body package="Tools-Parcel Manager">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: '' 			#bounds: #(#{Graphics.Rectangle} 506 344 1024 768 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TreeViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #directoryTree 					#model: #directoryListHolder 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight 					#useIcons: #folder 					#rootExpander: false ) ) ) )</body></methods><methods><class-id>Tools.ParcelFavoritesTool class</class-id> <category>interface specs</category><body package="Tools-Parcel Manager">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 512 384 981 765 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TreeViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #folderTree 					#model: #folderTreeHolder 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight 					#useIcons: #folder 					#useChildImages: true 					#useLines: false ) ) ) )</body></methods><methods><class-id>Tools.ParcelSelectionTool class</class-id> <category>resources</category><body package="Tools-Parcel Manager">basicParcelMenu	"MenuEditor new openOnClass: self andSelector: #basicParcelMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Load #defaultString: '&amp;Load' #catalogID: #menus) 				#nameKey: #load 				#value: #loadParcels 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #loadParcel ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Unload #defaultString: '&amp;Unload' #catalogID: #menus) 				#nameKey: #unload 				#value: #unloadParcels 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #unloadParcel ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_OpenInChangeList #defaultString: '&amp;Open in Change List' #catalogID: #menus) 				#nameKey: #openChanges 				#value: #openChanges 				#labelImage: #(#{UI.ResourceRetriever} #{ParcelManager} #changeListIcon ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_CompareWithSystem #defaultString: '&amp;Compare with System' #catalogID: #menus) 				#nameKey: #openConflicts 				#value: #openConflicts 				#labelImage: #(#{UI.ResourceRetriever} #{ParcelManager} #changeListConflictsIcon ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Browse #defaultString: 'Browse' #catalogID: #menus) 				#nameKey: #browse 				#value: #browseParcels 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #parcelBrowser ) ) ) #(2 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.ParcelListTool class</class-id> <category>interface specs</category><body package="Tools-Parcel Manager">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 512 384 891 739 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #parcelList 					#model: #parcelListHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: 						#parcelDoubleClicked: ) 					#menu: #popupMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body></methods><methods><class-id>Tools.ParcelPrereqTreeTool class</class-id> <category>interface specs</category><body package="Tools-Parcel Manager">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec}		#window: #(#{UI.WindowSpec}			#label: #(#{Kernel.UserMessage}				#key: #UnlabeledCanvas				#defaultString: 'Unlabeled Canvas'				#catalogID: #labels)			#bounds: #(#{Graphics.Rectangle} 512 384 712 584))		#component: #(#{UI.SpecCollection}			#collection: #(#(#{UI.TreeViewSpec}				#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1)				#name: #itemTree				#model: #itemTree				#callbacksSpec: #(#{UI.UIEventCallbackSubSpec}					#doubleClickSelector: #parcelDoubleClicked:)				#menu: #popupMenu				#multipleSelections: true				#useModifierKeys: true				#selectionType: #highlight				#useIcons: #other				#iconSelectors: #(#iconForLists)				#rootExpander: false))))</body></methods><methods><class-id>Tools.ParcelPropertiesTool class</class-id> <category>interface specs</category><body package="Tools-Parcel Manager">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 512 384 712 584 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #text 					#model: #textHolder 					#isReadOnly: true 					#tabRequiresControl: true ) ) ) )</body></methods><methods><class-id>Tools.ParcelManager class</class-id> <category>interface specs</category><body package="Tools-Parcel Manager">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ParcelManager 				#defaultString: 'Parcel Manager' 				#catalogID: #labels ) 			#min: #(#{Core.Point} 400 270 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 930 470 1630 970 ) 			#flags: 4 			#menu: #menuBar 			#toolBar: #toolbarMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.32 -25 1 ) 					#name: #categoryNotebook 					#model: #categoryHolder 					#labels: #() ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.32 0 0 2 0.32 -25 1 ) 					#name: #splitter1 					#horizontal: false 					#minAboveSize: 120 					#minBelowSize: 120 					#aboveWidgets: 'categoryNotebook' 					#belowWidgets: 'parcelNotebook splitter2 detailNotebook' ) 				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.32 0 0 0 1 -3 0.4 ) 					#name: #parcelNotebook 					#model: #parcelHolder 					#labels: #() ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.32 -3 0.4 0 1 0 0.4 ) 					#name: #splitter2 					#horizontal: true 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'parcelNotebook' 					#belowWidgets: 'detailNotebook' ) 				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.32 0 0.4 0 1 -25 1 ) 					#name: #detailNotebook 					#model: #detailHolder 					#labels: #() ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -25 1 0 1 0 1 ) 					#name: #statusText 					#model: #statusTextHolder 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>Tools.ParcelManager class</class-id> <category>resources</category><body package="Tools-Parcel Manager">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #menus ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #LoadParcelFileDot 								#defaultString: '&amp;Load Parcel File...' 								#catalogID: #menus ) 							#nameKey: #loadFromFile 							#value: #loadParcelFromFile ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Close 								#defaultString: '&amp;Close' 								#catalogID: #menus ) 							#nameKey: #close 							#value: #closeRequest ) ) #(1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Parcel 					#defaultString: '&amp;Parcel' 					#catalogID: #menus ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_SelectAll 								#defaultString: '&amp;Select All' 								#catalogID: #menus ) 							#value: #selectAll 							#enablementSelector: #anyParcelsDisplayed 							#shortcutKeyCharacter: $A 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ParcelManager} #selectAllIcon ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Load 								#defaultString: '&amp;Load' 								#catalogID: #menus ) 							#value: #loadParcels 							#enablementSelector: #canLoad 							#shortcutKeyCharacter: $L 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ParcelManager} #loadIcon ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Unload 								#defaultString: '&amp;Unload' 								#catalogID: #menus ) 							#value: #unloadParcels 							#enablementSelector: #canUnload 							#shortcutKeyCharacter: $U 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ParcelManager} #unloadIcon ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_OpenInChangeList 								#defaultString: '&amp;Open in Change List' 								#catalogID: #menus ) 							#nameKey: #openChanges 							#value: #openChanges 							#enablementSelector: #selectionsHaveSource 							#labelImage: #(#{UI.ResourceRetriever} #{ParcelManager} #changeListIcon ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_CompareWithSystem 								#defaultString: '&amp;Compare with System' 								#catalogID: #menus ) 							#nameKey: #openConflicts 							#value: #openConflicts 							#enablementSelector: #selectionsHaveSource 							#labelImage: #(#{UI.ResourceRetriever} #{ParcelManager} #changeListConflictsIcon ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Browse 								#defaultString: '&amp;Browse' 								#catalogID: #menus ) 							#value: #browseParcels 							#enablementSelector: #canBrowse 							#shortcutKeyCharacter: $B 							#shortcutModifiers: 2 							#labelImage: #(#{UI.ResourceRetriever} #{ParcelManager} #browseIcon ) ) ) #(1 2 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #menus ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ParcelManager 								#defaultString: '&amp;Parcel Manager' 								#catalogID: #menus ) 							#value: #helpTopics 							#shortcutKeyCharacter: #F1 							#shortcutModifiers: 0 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #help ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_AboutVisualWorksDot 								#defaultString: '&amp;About VisualWorks...' 								#catalogID: #menus ) 							#value: #aboutVisualWorks ) ) #(1 1 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="Tools-Parcel Manager">toolbarMenu	"MenuEditor new openOnClass: self andSelector: #toolbarMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Load #defaultString: 'Load' #catalogID: #menus) 				#nameKey: #load 				#value: #loadParcels 				#labelImage: #(#{UI.ResourceRetriever} #{ParcelManager} #loadIcon ) 				#helpText: #(#{Kernel.UserMessage} #key: #LoadParcels #defaultString: 'Load Parcels' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Unload #defaultString: 'Unload' #catalogID: #menus) 				#nameKey: #unload 				#value: #unloadParcels 				#labelImage: #(#{UI.ResourceRetriever} #{ParcelManager} #unloadIcon ) 				#helpText: #(#{Kernel.UserMessage} #key: #UnloadParcels #defaultString: 'Unload Parcels' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #OpenInChangeList #defaultString: 'Open in Change List' #catalogID: #menus) 				#nameKey: #openChanges 				#value: #openChanges 				#labelImage: #(#{UI.ResourceRetriever} #{ParcelManager} #changeListIcon ) 				#helpText: #(#{Kernel.UserMessage} #key: #OpenInChangeList #defaultString: 'Open in Change List' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #CompareWithSystem #defaultString: 'Compare with System' #catalogID: #menus) 				#nameKey: #openConflicts 				#value: #openConflicts 				#labelImage: #(#{UI.ResourceRetriever} #{ParcelManager} #changeListConflictsIcon ) 				#helpText: #(#{Kernel.UserMessage} #key: #CompareWithSystem #defaultString: 'Compare with System' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Browse #defaultString: 'Browse' #catalogID: #menus) 				#nameKey: #browse 				#value: #browseParcels 				#labelImage: #(#{UI.ResourceRetriever} #{ParcelManager} #browseIcon ) 				#helpText: #(#{Kernel.UserMessage} #key: #BrowseParcel #defaultString: 'Browse Parcel' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #SelectAll #defaultString: 'Select All' #catalogID: #menus) 				#nameKey: #selectAll 				#value: #selectAll 				#enablementSelector: #anyParcelsDisplayed 				#shortcutKeyCharacter: $A 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{ParcelManager} #selectAllIcon ) 				#helpText: #(#{Kernel.UserMessage} #key: #SelectAll #defaultString: 'Select All' #catalogID: #menus) ) ) #(2 2 2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - tools</category><body package="Tools-Parcel Manager">menuItemOpenParcelManager	&lt;vwPrivileged&gt;	&lt;menuItemForCommand: #openParcelManager		icon: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #parcelManager )		nameKey: nil		menu: #(#menuBar #tools)		position: 10.3&gt;	self openApplicationForClassNamed: #{ParcelManager}</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>toolbar</category><body package="Tools-Parcel Manager">toolbarItemOpenParcelManager	&lt;vwPrivileged&gt;	&lt;menuItemForCommand: #openParcelManager		icon: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #parcelManager )		nameKey: nil		menu: #(#launcherToolBar)		position: 10.3		helpText: #(#OpenAParcelManager #menus 'Open a Parcel Manager')&gt;	self openApplicationForClassNamed: #{ParcelManager}</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - launcher</category><body package="Tools-Parcel Manager">openParcelManagerCommand	&lt;command: #openParcelManager&gt;	^Command		label: (#_ParcelManager &lt;&lt; #menus &gt;&gt; '&amp;Parcel Manager')		group: #launcher		bindings: #(			isMSWindows #(F3)			isMacOSX #(F3)			isX11 #(F3)		)</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>LogicalFilename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>Filename</name><environment>OS</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>osName publicName logicalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class></st-source>