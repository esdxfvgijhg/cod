<?xml version="1.0"?><st-source><!-- Name: XMLNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: XML provides a support framework for working with XML documents using either the DOM (Document Object Model) or SAX (Simple API for XML) APIs.Further information on XML support can be found in the "Application Developer's Guide" (located in the /doc subdirectory of the VisualWorks installation).DevelopmentPrerequisites: #(#(#any 'URISupport' ''))HideSource: falseIsFunctional: falsePackageName: XMLPackageName:: XMLParcel: #('XML')PrerequisiteParcels: #(#('URISupport' ''))SaveSource: trueVersion: 8.0 - 1Date: 12:05:12 PM July 28, 2017 --><time-stamp>From VisualWorksÂ®, 8.3 of July 28, 2017 on July 28, 2017 at 12:05:12 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>XML</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			XML.SAX.*			</imports><category>XML-NameSpace</category><attributes><package>XML</package></attributes></name-space><comment><name-space-id>XML</name-space-id><body>The XML NameSpace contains the VisualWorks XML Framework, including parsing and generation.  XMLParser is the parser.  XMLNodeBuilder is the generator.</body></comment><name-space><name>SAX</name><environment>XML</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>XML-SAX</category><attributes><package>XML</package></attributes></name-space><class><name>AttributeType</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isExternal </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Attributes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.AttributeType</class-id><body>AttributeType is an abstract superclass that represents the type of an XML attribute.The XML 1.0 specification specifies that XML attribute types are of three kinds: a string type, a set of tokenized types, and enumerated types. The string type may take any literal string as a value, the tokenized types have varying lexical and semantic constraints and the enumerated type attibutes can take one of a list of values provided in the declaration.Subclasses of AttributeType represent the various types of XML attributes, e.g., CDATA, for string types, and ID for tokenized types.</body></comment><class><name>ENTITY_AT</name><environment>XML</environment><super>XML.AttributeType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Attributes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.ENTITY_AT</class-id><body>A concrete subclass of AttributeType, this class represents the ENTITY attribute type.This is a tokenized type of attribute that signifies to the XML parser that for the purposes of validating, the values of entity type attributes must match the name of an unparsed entity declared in the document type definition.</body></comment><class><name>Pattern</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>followSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Patterns</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.Pattern</class-id><body>The element structure of an XML document may, for validation purposes, be constrained using element type and attribute-list declarations. An element type declaration constrains the element's content by constraining which element types can appear as children of the element. The constraint includes a content model, a simple grammar or pattern governing the allowed types of child elements and the order in which they are allowed to appear. These content models are represented by this XML.Pattern class and its subclasses.Constraint rules or patterns may be complex (ComplexPattern and its subclasses) or simple (ConcretePattern and its subclasses). Subclasses must implement the following protocol:	coercing		alternateHeads		pushDownFollowSet	testing		isSimpleInstance Variables:	followSet	&lt;OrderedCollection&gt;  A list of the Patterns which may follow this one in an element's content.</body></comment><class><name>ConcretePattern</name><environment>XML</environment><super>XML.Pattern</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Patterns</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.ConcretePattern</class-id><body>A subclass of Pattern, this class is the superclass to what are considered 'simple' patterns or constraint rules in the element content declarations.Subclasses of ConcretePattern include AnyPattern, EmptyPattern, InitialPattern, NamePattern, PCDATAPattern and TerminalPattern.Subclasses must implement the following messages:	testing		matches:</body></comment><class><name>AnyPattern</name><environment>XML</environment><super>XML.ConcretePattern</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Patterns</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.AnyPattern</class-id><body>A subclass of ConcretePattern, this class represents the ANY element content constraint in an element type declaration.According to the XML 1.0 specification the ANY pattern/rule is used to indicate to the validatingparser that the element can contain any elements in any order, as long as it doesn't break any of the other rules of XML and the types of any child elements have been declared.</body></comment><class><name>Node</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent flags userData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.Node</class-id><body>Class Node is an abstract superclass that represents a logical component of an XML Document.Logically, an XML document is composed of declarations, elements, comments, character references, and processing instructions, all of which are indicated in the document by explicit markup. The concrete subclasses of XML.Node represent these various components.Subclasses must implement the following messages:	printing		printCanonicalOn:		printHTMLOn:		printNoIndentOn:endSpacing:spacing:Instance Variables:	parent	&lt;XML.Node | nil&gt; 			All nodes except for Documents are contained by other nodes--this provides a pointer from the node to the node that contains it.	flags	&lt;SmallInteger&gt; 			Provides a compact representation for any boolean attributes that the node might have. Likely to be removed in the near future.	userData		&lt;Object | Dictionary&gt;		used by clients to add annotations to the element. If accessed only through the #clientData message, will be a Dictionary.</body></comment><class><name>Text</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text stripped </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.Text</class-id><body>A subclass of Node, this class represents an XML textual object, i.e. a sequence of legal characters as defined in the XML 1.0 specification. Instances of XML.Text may represent either markup or character data.Instance Variables:	text			&lt;CharacterArray | nil&gt;	the actual data of the Text.	stripped	&lt;Boolean&gt;	Will be true if the text contains only white space and if the parser has determined that the client would not be interested in the data.</body></comment><class><name>CDATA</name><environment>XML</environment><super>XML.Text</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.CDATA</class-id><body>CDATA is a subclass of Text in XML, that represents text that was or should be wrapped in &lt;![CDATA[...]]&gt; brackets rather than having each &lt;, &gt;, or &amp; quoted separately. In the case where a human is looking at raw XML data without any sort of filter, this may make the text more readable.</body></comment><class><name>SAXException</name><environment>XML</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars>wrappedException </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Exceptions</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.SAXException</class-id><body>A special exception indicating an error in a SAX-compliant parser.All errors when parsing XML *should* be converted to SAXExceptions. Errors generated by the parser will usually be instances of subclasses of SAXException. Errors generated by user code, if caught, will usually be instances of other types of Exception, and will be wrapped in an instance of SAXException to simplify the task of an exception handler outside the parser.Instance Variables:	wrappedException	&lt;Exception&gt;  another exception, which has been wrapped so that a handler for SAXException will catch it.</body></comment><class><name>SAXParseException</name><environment>XML</environment><super>XML.SAXException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Exceptions</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.SAXParseException</class-id><body>This exception is raised when parsing XML and encountering violations of XML well-formedness or validity.</body></comment><class><name>MalformedSignal</name><environment>XML</environment><super>XML.SAXParseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Exceptions</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.MalformedSignal</class-id><body>This exception is raised when parsing XML and encountering violations of XML well-formedness.</body></comment><class><name>BadCharacterSignal</name><environment>XML</environment><super>XML.MalformedSignal</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Exceptions</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.BadCharacterSignal</class-id><body>This exception is raised when parsing XML and encountering characters that XML declares to be illegal. We call this out as a separate exception because we want the option of ignoring it in Smalltalk source code, even though this means the XML is unprocessable by other XML processors.</body></comment><class><name>Attribute</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.Attribute</class-id><body>XML elements may have name-value pairs called attributes associated with them. This class instantiates a single XML attribute. Attribute is a subclass of Node, both because the W3C DOM model defines it that way, and because it provides a uniform API for applications such as XSLT that want to do similar sorts of processing on attributes and other node types.Instance Variables:	name	&lt;XML.Node | XML.NodeTag&gt;		tag name	value	&lt;Object&gt;							tag value</body></comment><class><name>NMTOKENS_AT</name><environment>XML</environment><super>XML.AttributeType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Attributes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.NMTOKENS_AT</class-id><body>A concrete subclass of AttributeType, this class represents the NMTOKENS attribute type.This is a tokenized type of attribute and for the purposes of validation, values of each NMTOKENS type attributes must match each Nmtoken, which is any mixture of legal name characters as defined in the XML 1.0 specification.</body></comment><class><name>SAXDriver</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>locator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-SAX</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.SAXDriver</class-id><body>This class includes supports for the Simple API for XML (SAX), an event-driven API for parsing XML documents.All methods defined in this class, other than those defined in the "private" protocol, are Smalltalk-equivalent bindings of the SAX 2.0 API, and can be overridden according to the needs of subclasses.Instance Variables:	locator	&lt;nil&gt; place holder for SAX's Locator, which allows better error recovery.</body></comment><class><name>NullSAXDriver</name><environment>XML</environment><super>XML.SAXDriver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-SAX</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.NullSAXDriver</class-id><body>The XML parser requires some sort of SAXDriver to receive events. If the client desires to simply do syntax checking on the document without further processing, and wants minimal overhead, NullSAXDriver will do the minimal possible processing while implementing the entire SAX API.</body></comment><class><name>XMLNodeBuilder</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tagStack tags </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Parsing</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.XMLNodeBuilder</class-id><body>XMLNodeBuilder is an abstract superclass used by the XML parser when distilling an XML document into its component elements.Since XML elements are tag delimited and nest properly within each other in a well-formed XML document, this class contains code to process the tags and build a tree of xml elements.XMLNodeBuilder is part of an older parser API which we are in the process of removing. Consider using SAXDriver, which transforms the XML document into events rather than nodes. SAXDriver has a subclass named DOM_SAXDriver which can be used in the same way as XMLNodeBuilder to create a tree of XML nodes.Instance Variables:	tagStack		&lt;OrderedCollection&gt;			Stack showing the nesting of XML elements within the document at the current stage of parsing.	tags			&lt;Dictionary&gt;		Currently not used. A map to make sure that within a document, tag identifiers are unique instances in order to save space.</body></comment><class><name>NodeBuilder</name><environment>XML</environment><super>XML.XMLNodeBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Parsing</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.NodeBuilder</class-id><body>A subclass of XMLNodeBuilder, this class is used by the XML parser to distill an XML document into its component elements.This NodeBuilder class in particular is used to create instances of the various XML elements that are included in the scanned-in XML document or document string.This class can be subclassed in order to instantiate custom node types. The main method to override would be NodeBuilder&gt;&gt;tag:attributes:elements:position:stream:, since most of the other methods in XMLNodeBuilder's "building" protocol are very secondary in importance compared to this method. But consider subclassing DOM_SAXDriver rather than this class, and using the SAX protocol to do your parsing.</body></comment><class><name>ComplexPattern</name><environment>XML</environment><super>XML.Pattern</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Patterns</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.ComplexPattern</class-id><body>A subclass of Pattern, this class is the superclass to what are considered 'complex' patterns or rules in the element content declarations.Subclasses of ComplexPattern include ChoicePattern, MixedPattern, ModifiedPattern and SequencePattern.</body></comment><class><name>ChoicePattern</name><environment>XML</environment><super>XML.ComplexPattern</super><private>false</private><indexed-type>none</indexed-type><inst-vars>items </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Patterns</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.ChoicePattern</class-id><body>A subclass of ComplexPattern, this class represents the 'choice' element content constraint in an element type declaration.According to the XML 1.0 specification, the 'choice' pattern/rule signifies that any content particle in a choice list (declared in the DTD) may appear in the element content at the location where the choice list appears in the grammar.Instance Variables:	items	&lt;Collection&gt;				Collection of content particles</body></comment><class><name>AttributeDef</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name default type flags </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Attributes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.AttributeDef</class-id><body>XML documents may contain attribute-list declarations that are used to define the set of attributes pertaining to a given element type. These attribute-list declarations are also used to establish type constraints for the attributes and to provide default values for attributes. Attribute-list declarations contain attribute definitions and this class is used to instantiate these definitions.An attribute definition in a DTD specifies the name (in an AttributeDef instance, this is the name instance variable) of the attribute, the data type of the attribute (type instance variable) and an optional default value (default instance variable) for the attribute.Instance Variables:	name	&lt;XML.NodeTag&gt; 		name of attribute	default	&lt;Object&gt;  				default value, if any	type	&lt;XML.AttributeType&gt;	type used for validation	flags	&lt;Integer&gt;				encoding for fixed, implied and required type attributes</body></comment><class><name>ModifiedPattern</name><environment>XML</environment><super>XML.ComplexPattern</super><private>false</private><indexed-type>none</indexed-type><inst-vars>node modification </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Patterns</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.ModifiedPattern</class-id><body>XML element content declarations can have certain optional characters following an elementname or pattern. These characters govern whether the element or the content particle may occurone or more (+), zero or more (*), or zero or one (?) times in the element content. This classrepresents these patterns or rules.Instance Variables:	node			&lt;XML.Pattern&gt;		The base pattern which the ModifiedPattern influences.	modification	&lt;Character&gt;		Optional character denoting content element occurances</body></comment><class><name>DOM_SAXDriver</name><environment>XML</environment><super>XML.SAXDriver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stack document newNamespaces stateForCDATA </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-SAX</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.DOM_SAXDriver</class-id><body>This class represents a specialized type of SAX (Simple API for XML) processor that follows the 'object model' for processing XML documents to build a Document Object Model (DOM) tree from the processed XML document.As a way to distinguish between the two, SAX is an event driven API for reading XML documents. Character groups within the document are mapped to one or more callbacks to a SAXDriver, but no assumption is made that any objects will necessarily be created as a result of those events. DOM, on the other hand, is an object API for reading XML. Character groups within the document are mapped to subclasses of Node.SAX is very useful for speed and memory conservation if the document can be processed linearly. DOM is very useful if a substantial amount of non-linear processing is required.Instance Variables:	stack		&lt;OrderedCollection&gt;		A stack containing the various elements that contain the current parse position.	document		&lt;XML.Document&gt;		The Document or DocumentFragment which models the entire XML document being parsed.	newNamespaces		&lt;Dictionary&gt;		maps qualifiers to namespaces for the next element	stateForCDATA		&lt;nil | #normal | #cdata&gt;		records whether to pay attention to CDATA, and whether we're in it or not.</body></comment><class><name>Comment</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.Comment</class-id><body>A concrete subclass of XML.Node, this class represents an XML comment.XML comments may appear anywhere in an XML document outside other markup or within the document type declaration at places allowed by grammar. XML comments are delimited by the start-tag '&lt;!--' and the end-tag '--&gt;'. According to the XML 1.0 specification, for compatibilty, double-hyphens (the string '--') must not occur within comments.Instance Variables:	text		&lt;String&gt;  	contents of the comment element</body></comment><class><name>Entity</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name text systemID publicID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.Entity</class-id><body>An XML document may consist of one or many storage units called entities. All XML entities have content and are idententified by name.Entities may be either parsed or unparsed, i.e., the XML processor is not required to interpret an unparsed entity. This class and its subclasses GeneralEntity and ParameterEntity represent parsed entities. Entity is the abstract superclass for the other two types. GeneralEntity identifies entities which can be used in the document's body, and ParameterEntity identifies those that can only be used within the DTD. These entities are invoked by name using entity references and their contents are held in the text instance variable.Entities may also be internal or external. If the content of the entity is given in the declaration (within the document) itself then the entity is called an internal entity. If the entity is not internal to the document and is declared elsewhere it's called an external entity. External entities have a system identifier (systemID instance variable) that is an URI which may be used to retrieve the entity. In addition to a system identifier, an external entity declaration may include a public identifier (publicID instance variable). The XML parser is allowed to try to use the publicID to try to generate an alternative URI to retrive the entity's contents.Subclasses must implement the following messages:	accessing		entityTypeInstance Variables:	name		&lt;XML.NodeTag&gt;  						Identifies the entity in an entity reference	text			&lt;nil | String&gt;						The entity's contents	systemID	&lt;String&gt;						URI used to retrieve an external entity's contents	publicID	&lt;String&gt;						Alternative URI used to retrieve an external entity's contents</body></comment><class><name>GeneralEntity</name><environment>XML</environment><super>XML.Entity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ndata definedExternally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.GeneralEntity</class-id><body>This class represents a general entity which is a parsed entity for use within the XML document content.Instance Variables:	ndata	&lt;Notation&gt;			Some general entities may have a notation associated with them which identifies how they are to be processed--this instace variable identifies that Notation.</body></comment><class><name>SAXWriter</name><environment>XML</environment><super>XML.SAXDriver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>output textMap attrMap hasOpenTag normalizeText notations newNamespaces </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-SAX</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.SAXWriter</class-id><body>SAXWriter is a kind of SAXDriver that converts SAX events back into textutal XML documents.Instance Variables:	attrMap	&lt;Dictionary&gt;	Lists the characters that are not allowed to appear literally in attributes, and maps them to their quoted form.	hasOpenTag	&lt;Boolean&gt;	True if we are inside an element that has no content as yet. This allows us to know when we reach the end tag whether we can write the element as &lt;x/&gt; rather than &lt;x&gt;&lt;/x&gt;.	newNamespaces	&lt;nil | Dictionary&gt;	Maps namespace qualifiers to URIs, for namespaces which the current element defines differently than its parent.	normalizeText	&lt;Boolean&gt;	Should be true in almost all cases--can be false only if the "XML" document being parsed is actually not XML, in which case it may be legal to not quote characters such as $&lt;.	notations	&lt;Collection&gt;	List of notations defined in the document being parsed.	output	&lt;Stream&gt;	Stream on which the XML is rendered as text.	textMap	&lt;Dictionary&gt;	Lists the characters that are not allowed to appear literally in text, and maps them to their quoted form.</body></comment><class><name>EmptyPattern</name><environment>XML</environment><super>XML.ConcretePattern</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Patterns</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.EmptyPattern</class-id><body>A subclass of ConcretePattern, this class represents the EMPTY element content constraint in an element type declaration.According to the XML 1.0 specification the EMPTY element declaration indicates that the element has no content.</body></comment><class><name>NMTOKEN_AT</name><environment>XML</environment><super>XML.AttributeType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Attributes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.NMTOKEN_AT</class-id><body>A concrete subclass of AttributeType, this class represents the NMTOKEN attribute type.This is a tokenized type of attribute and for the purposes of validation, values of NMTOKEN type attributes must match a Nmtoken, which is any mixture of legal name characters as defined in the XML 1.0 specification.</body></comment><class><name>StreamWrapper</name><environment>XML</environment><super>Core.Link</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream isInternal resource usedAsExternal entity cr lf parser line column </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Parsing</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.StreamWrapper</class-id><body>This class is used by the XML parser to wrap both internal and external streams with proper encoding before handing them to the parser for processing.The streams passed to the parser may be either EncodedStreams or simple text streams (such as a ReadStream on a String). If they are EncodedStreams, this wrapper class silently checks the &lt;?xml?&gt; declaration at the beginning of the stream to make sure that the EncodedStream is using the right encoding, and if not, it changes the encoding of the stream.Instance Variables:	stream			&lt;EncodedStream&gt;  stream being wrapped	isInternal		&lt;Boolean&gt;  true if the stream is internal and hencer doesn't need careful line-end treatment	resource		&lt;XML.InputSource&gt; source of the data being parsed	usedAsExternal	&lt;Boolean&gt;  flag used to override protocol and say how stream is being used?	entity			&lt;Entity | nil&gt;  if wrapping on behalf of an Entity this is it?	cr				&lt;Character&gt;  cache of Character cr	lf				&lt;Character&gt;  cache of Character lf	parser		&lt;XML.XMLParser&gt; the parser reading this stream	line		&lt;Integer&gt; line number of the current parse location	column		&lt;Integer&gt; column number on the current line</body></comment><class><name>ParameterEntity</name><environment>XML</environment><super>XML.Entity</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resolvedURI </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.ParameterEntity</class-id><body>This class represents a parameter entity which is a parsed entity for use within the document type definition.Instance Variables:	resolvedURI	&lt;nil | Net.URI&gt;  if the entity is external, its web address.</body></comment><class><name>Enumeration_AT</name><environment>XML</environment><super>XML.AttributeType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Attributes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.Enumeration_AT</class-id><body>A concrete subclass of AttributeType, this class represents the Enumeration attribute type.Enumerated attributes can take one of a list of values provided in the declaration.Instance Variables:	values	&lt;Collection&gt;		A list of the possible values which the attribute may have.</body></comment><class><name>Document</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root nodes dtd ids </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.Document</class-id><body>This class represents an XML document entity and serves as the root of the document entity tree. Each XML document has one entity (root) called the document entity, which serves as the starting point for the XML processor and may contain the whole document (nodes collection). According to the XML 1.0 specification, XML documents may and should begin with an XML declaration which specifies the version of XML (xmlVersion instance variable) being used. The XML document type declaration which must appear before the first element in a document contains or points to markup declarations that provide the grammar for this document. This grammar is known as document type definition or DTD (dtd instance variable). An XML document is valid if it has an associated document type declaration and if the document complies with the constraints expressed in itInstance Variables:	root	&lt;XML.Element&gt;							The outer-most element of the XML document.	nodes	&lt;Collection&gt;  							The root Element as well as all other PIs and Comments which precede or follow it.	dtd		&lt;XML.DocumentType&gt;				Associated document type definition 	ids		&lt;KeyedCollection | Dictionary&gt;  		Map which converts ID names to Elements, allowing a simple cross reference within the document.</body></comment><class><name>DocumentFragment</name><environment>XML</environment><super>XML.Document</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.DocumentFragment</class-id><body>DocumentFragment is a subclass of Document which can be used to model documents which do not correctly conform to the XML standard. Such fragments may contain text that is not contained within any element, or may contain more than one element at the top level.At present it is not possible to represent a Document fragment that contains the start tag but not the end tag of an element, or contains the end tag but not the start tag.</body></comment><class><name>DocumentType</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attributeDefs elementDefs generalEntities parameterEntities notations declaredRoot </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Parsing</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.DocumentType</class-id><body>This class represents an XML document type definition or DTD.The document type declaration can point to an external subset containing markup declarations, or can contain the markup declarations directly in an internal subset, or can do both. The DTD for a document consists of both subsets taken together.Instance Variables:	attributeDefs		&lt;Dictionary&gt;			Type definitions of the attributes for each element.	elementDefs		&lt;Dictionary&gt;		Type definitions for the elements that are legal in the document.	generalEntities		&lt;Dictionary&gt;		Definitions for the general entities that can be used in the body of the document.	parameterEntities	&lt;Dictionary&gt;		Definitions for the parameter entities that can be used in the DTD of the document.	notations			&lt;Dictionary&gt;		Notations defined in the DTD.	declaredRoot 		&lt;XML.NodeTag&gt;		The NodeTag which the DTD declares will be the root element of the document--a document cannot be valid if this does not match the tag of the root element.</body></comment><class><name>InvalidSignal</name><environment>XML</environment><super>XML.SAXParseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Exceptions</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.InvalidSignal</class-id><body>This exception is raised when parsing XML and encountering violations of XML validity.</body></comment><class><name>IDREF_AT</name><environment>XML</environment><super>XML.AttributeType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Attributes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.IDREF_AT</class-id><body>A concrete subclass of AttributeType, this class represents the IDREF attribute type.This is a tokenized type of attribute and for an XML document to be valid, values of IDREF type attributes must match the value of some ID attribute on some element in the XML document.ID and IDREF attributes together provide a simple inside-the-document linking mechanism with every IDREF attribute required to point to an ID attribute as stated above.</body></comment><class><name>PCDATAPattern</name><environment>XML</environment><super>XML.ConcretePattern</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Patterns</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.PCDATAPattern</class-id><body>This class represents a content constraint or pattern in an element type declaration indicating that the element content includes parsed character data.Parsed character data is typically used in mixed content type patterns and is signified by the presence of the string '#PCDATA' in the element content declaration.</body></comment><class><name>TerminalPattern</name><environment>XML</environment><super>XML.ConcretePattern</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Patterns</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.TerminalPattern</class-id><body>Since an element's content declaration may include multiple constraint rules or patterns, instances of this class are used to indicate to the XML parser, the last or terminal rule in the declaration.</body></comment><class><name>NamePattern</name><environment>XML</environment><super>XML.ConcretePattern</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Patterns</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.NamePattern</class-id><body>This class represents a content constraint in an element type declaration such that the declaration includes the names of the element types that may appear as children in the element's content.Instance Variables:	name	&lt;XML.NodeTag&gt;		The tag of the element which is permitted by this pattern to appear in the content of some other element.</body></comment><class><name>SAXDispatcher</name><environment>XML</environment><super>XML.SAXDriver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contentHandler dtdHandler entityResolver errorHandler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-SAX</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.SAXDispatcher</class-id><body>SAXDispatcher allows the SAX implementation to support mixing and matching of event handlers. For example, the same contentHandler could be used with different errorHandlers for different ciecumstances, or with different entityResolvers depending on what transport protocols are loaded.This class is primarily private, used by such methods as XMLParser&gt;&gt;contentHandler:, but its use by client code is not discouraged. To use it, create a SAXDispatcher, fill in its various handler types with instances of other SAXDrivers, and then store the SAXDispatcher in the parser using the #handlers: message.Instance Variables:	contentHandler	&lt;XML.SAXDriver&gt; 		handles all content events	dtdHandler			&lt;XML.SAXDriver&gt; 		handles entity and notation declarations	entityResolver		&lt;XML.SAXDriver&gt;		handles resolution of PUBLIC and SYSTEM paths												into InputSources, to allow non-standard resolution	errorHandler		&lt;XML.SAXDriver&gt;		handles all errors</body></comment><class><name>SAXNotSupportedException</name><environment>XML</environment><super>XML.SAXException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Exceptions</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.SAXNotSupportedException</class-id><body>Raised when the XML parser recognizes a feature or property identifier, but cannot perform the requested operation (e.g., setting a state or value).</body></comment><class><name>Element</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tag attributes namespaces elements definition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.Element</class-id><body>A concrete subclass of XML.Node, this represents a single XML document element.XML document element boundaries are either delimited by start-tags and end-tags, or, for empty elements, by an empty-element tag. Each element has a type, identified by name, sometimes called its "generic identifier" (GI), and may have a set of attribute specifications. Each attribute specification has a name and a value.Instance Variables:	tag				&lt;String | NodeTag&gt; 			the tag name of this element	attributes		&lt;Collection&gt;					A list of the attributes that appeared in the element's start tag, usually excluding those attributes that define namespace mappings.	namespaces	&lt;Dictionary&gt;					A map from namespace qualifiers to URIs, used to resolve qualifiers within the scope of this element.	elements		&lt;SequenceableCollection&gt;	The Element, Text, Comment, and PI nodes that appear within this Element but are not contained by a child Element.	definition		&lt;Object&gt;  						suspect this is unused</body></comment><class><name>IDREFS_AT</name><environment>XML</environment><super>XML.AttributeType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Attributes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.IDREFS_AT</class-id><body>A concrete subclass of AttributeType, this class represents the IDREFS attribute type.This is a tokenized type of attribute and for an XML document to be valid, each of the values of IDREFS type attributes must match each of the values of some ID attribute on some element in the XML document.</body></comment><class><name>ResolveEmptyResource</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.ResolveEmptyResource</class-id><body>ResolveEmptyResource represents an empty resolved entity body during entity resolution. See PluggableEntityResolver.</body></comment><class><name>NodeTag</name><environment>XML</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>namespace type qualifier </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Parsing</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.NodeTag</class-id><body>NodeTag is used as the "tag" of an Element or Attribute. It acts as the name or identifier of its owner. It is subclassed from Magnitude as a convenience to allow NodeTags to easily understand sorting protocol.In XML all elements or nodes are delimited by start and end tags (or empty-element tags) and instances of this class are used to represent these element tags. The name of the tag (type instance variable) gives the element type.Instance Variables:	namespace	&lt;String&gt;		A URI in string form that uniquely identifies the XML namespace to which the type belongs. May be an empty string if the type is outside all namespaces.	type			&lt;String&gt;		Name of tag, used to indicate element or attribute type.	qualifier		&lt;String&gt;		In XML documents, the namespace is mapped to a qualifier, which is used as a prefix for the type. The namespace is assumed to be unique across all documents, but is quite clumsy. The qualifier is not unique across documents, but is unambiguous at the point where it is used and is short enough to be convenient. The qualifier may be the empty string if the namespace is empty or if the namespace is the current default namespace.</body></comment><class><name>XMLFilter</name><environment>XML</environment><super>XML.SAXDispatcher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-SAX</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.XMLFilter</class-id><body>XMLFilter allows a parser to be wrapped in a SAX event handler such that any attempt to get or set the parser's properties, or start a parse, can be intercepted by the event handler. It can thus add new features or properties, or change how the features are implemented, or modify the events coming back from the parser.One example of how this might be used is that a feature (such as namespace processing), if it were not implement in the parser, could be implemented as a SAXDriver. By letting that driver masquerade as a parser, we can let that driver be composed with other kinds of SAXDrivers in a chain, and thus compose independent features together.Instance Variables:	parent	&lt;XML.XMLParser | XML.XMLFilter&gt;  the wrapped parser, which may itself be a filter</body></comment><class><name>SAXNotRecognizedException</name><environment>XML</environment><super>XML.SAXException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Exceptions</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.SAXNotRecognizedException</class-id><body>Raised when the XML parser finds an unrecognized feature or property identifier.</body></comment><class><name>SAXCanonicalWriter</name><environment>XML</environment><super>XML.SAXWriter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>baseURI </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-SAX</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.SAXCanonicalWriter</class-id><body>SAXCanonicalWriter is a subclass of SAXWriter that translates XML into a textual form conforming to the Sun Canonical XML specification used by the OASIS (http://www.oasis-open.org/) consortium in their XML conformance tests.Instance Variables:	baseURI	&lt;URI&gt;	When parsing, this remembers the URI of the document so that relative URIs (in Notations, for example) can be resolved to absolute URIs.</body></comment><class><name>PluggableEntityResolver</name><environment>XML</environment><super>XML.SAXDriver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.PluggableEntityResolver</class-id><body>PluggableEntityResolver handles SAX entity resolves such as fetching DTDs during the parsing of an a document into XMLNodeBuilder events, allowing developers to customize what content they return for a given URI (systemID) or publicID.This class gives us a nice pluggable API for configuring what to do when we are asked for an external entity. Often HTML entities are used in XHTML documents, so instead of returning an empty resource the blocks can return any streams they want. The stream that is returned from the block can be a network resource stream - the StreamWrappers used in the XML parsing framework will close the stream when it is done.The block arguments are optional, but when accepted come in the regular entity order of publicID and systemID, eg: XML.PluggableEntityResolver withBlock: [:publicID :systemID | ...your code goes here...]The block should return a stream but can also return one of two special classes - ResolveDefaultResource and ResolveEmptyResource. ResolveDefaultResource will cascade the regular resolution behaviour up the SAX entity resolver tree, while ResolveEmptyResource will immediately return an empty stream so that no further processing takes place.The following examples require the HTTP parcel to be loaded."This example avoids downloading the XHTML DTD which can take a while when we just want to grab a quick xhtml document off the internet"(XML.XMLParser on: 'http://www.w3.org' asURI)	validate: false;	entityResolver: (XML.PluggableEntityResolver withBlock: [XML.ResolveEmptyResource]);	scanDocument"This example logs a record of all accessed external entities as an XML document is parsed"(XML.XMLParser on: 'http://www.w3.org' asURI)	validate: false;	entityResolver: (XML.PluggableEntityResolver withBlock: [:publicID :systemID |		Core.Transcript cr; show: publicID; tab; show: systemID.		XML.ResolveDefaultResource]);	scanDocument"This example asks the user if they want the user-agent to download the resource. Note the cascading nature of downloads in this example."(XML.XMLParser on: 'http://www.w3.org' asURI)	validate: false;	entityResolver: (XML.PluggableEntityResolver withBlock: [:publicID :systemID |		(UI.Dialog confirm: 'Download the resource: ', systemID, ' ?')			ifTrue:	[XML.ResolveDefaultResource]			ifFalse:	[XML.ResolveEmptyResource]]);	scanDocumentInstance Variables:	block	&lt;BlockClosure&gt;	resolving block takes two optional arguments, publicID and systemID</body></comment><class><name>NOTATION_AT</name><environment>XML</environment><super>XML.AttributeType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Attributes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.NOTATION_AT</class-id><body>A concrete subclass of AttributeType, this class represents the NOTATION attribute type.A NOTATION attribute identifies a notation element, declared in the DTD with associated system and/or public identifiers, to be used in interpreting the element to which the attribute is attached.Instance Variables:	typeNames	&lt;SequenceableCollection&gt;	A list of the legal notation names that may be used for this attribute type.</body></comment><class><name>Notation</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name publicID systemID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.Notation</class-id><body>A concrete subclass of Node, this class represents an XML Notation declaration.Notations are XML elements/nodes which identify by name the format of unparsed entities, the format of elements which bear a notation attribute or the application to which a processing instruction is addressed.Notations are delimited in the DTD by the start-tag '&lt;!NOTATION' and end-tag '&gt;'The name instance variable provides a name or identifier for the notation, for use in entity andattribute specifications. The publicID instance variable provides an external identifier which allowsthe XML processor or the client application to locate a helper application capable of processingdata in the given notation. The systemID variable allows the parser to optionally resolve thepublicID into the system identifier, file name, or other information needed to allow the application to call a processor for data in the notation.Instance Variables:	name		&lt;String&gt;		A unique identifier for the Notation within the document.	publicID	&lt;String&gt;		The public ID of the Notation, which seems to not be heavily used at present.	systemID	&lt;String&gt;		A URI for the notation, which can be used to point to an application which can process resources of this notation type, or can be used as a key in a local map to find the application which should be used.</body></comment><class><name>Locator</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parser </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-SAX</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.Locator</class-id><body>Locators allow SAX drivers to ask the parser where we are in the current parse, for error reporting.Instance Variables:	parser			&lt;XML.XMLParser&gt;  the current parser</body></comment><class><name>PI</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name text </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.PI</class-id><body>A concrete subclass of Node, this class represents the XML Processing Instruction element.Processing instructions allow XML documents to contain instructions for applications.  XML processing instructions are delimited by the start-tag '&lt;?' and the end-tag '?&gt;'. According to the XML 1.0 specification, the target names "XML", "xml" and so on are reserved for standardization.Instance Variables:	name		&lt;String&gt;					the target of this processing instruction, used to identify the application					to which this processing instruction is directed.	text			&lt;String&gt;					the processing instructions themselves</body></comment><class><name>XMLParser</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceStack hereChar hereCharNumBytes lastSource currentSource dtd unresolvedIDREFs definedIDs latestID sax elementStack validating flags eol buffer nameBuffer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Parsing</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.XMLParser</class-id><body>XMLParser represents the main XML processor in the VisualWorks environment.As an XML processor, an instance of XMLParser is typically created by a Smalltalk application, and then used to scan and process an XML document, providing the application with access to its content and structure.Class XMLParser tries to follow the guidelines laid out in the W3C XML Version 1.0 specification.Instance Variables:	sourceStack	&lt;XML.StreamWrapper&gt;	stack of input streams that handles inclusion.	hereChar		&lt;Character&gt;  				the current character being parsed	hereCharNumBytes	&lt;Integer&gt;  				the number of bytes used to represent hereChar if the data source is byte-oriented, or 1 if it's character oriented	lastSource		&lt;XML.StreamWrapper&gt;	record of previous source used to check correct nesting	currentSource	&lt;XML.StreamWrapper&gt;	current input stream (the top of sourceStack)	dtd				&lt;XML.DocumentType&gt;	the document type definition for the current document	unresolvedIDREFs		&lt;Set&gt;				collection of IDREfs that have yet to be resolved.												Used for validation	definedIDs		&lt;Set&gt;						IDs that have already been seen.	latestID		&lt;nil | String&gt;				the ID of the last start tag we found.	sax				&lt;XML.SAXDriver&gt;			the output	elementStack	&lt;OrderedCollection&gt;		a list of the elements that enclose the current parse location												(bookkeeping info)	validating	&lt;Boolean&gt;						if true then the parse validates the XML	flags		&lt;SmallInteger&gt;				sundry boolean values that are not accessed often enough												to need separate instance variables.	eol			&lt;Character&gt;					the end-of-line character in the source stream	buffer		&lt;WriteStream&gt;					temporary storage for data read from the input,												to save reallocating the stream	nameBuffer	&lt;WriteStream&gt;				alternate buffer when "buffer" may be in use</body></comment><class><name>WarningSignal</name><environment>XML</environment><super>XML.SAXParseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Exceptions</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.WarningSignal</class-id><body>This exception is raised during parsing of XML when we encounter questionable things which the XML spec does not call errors, but requires the parser to report to the client.</body></comment><class><name>ElementContext</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tag type namespaces isExternal </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Parsing</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.ElementContext</class-id><body>This class includes some functionality to support XML namespaces. XML namespaces provide a simple method for qualifying element and attribute names used in XML documents Instance Variables:	tag				&lt;XML.NodeTag&gt;					The name of the current element.	type			&lt;nil | XML.ConcretePattern&gt;		A type definition for the current element, used to validate the contents.	namespaces	&lt;Dictionary&gt;						A map from namespace qualifiers to namespace URIs, which is used to interpret the meaning of namespace qualifiers within the scope of the element.</body></comment><class><name>SAXElementContext</name><environment>XML</environment><super>XML.ElementContext</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attributes nodes stream startPosition id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-SAX</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.SAXElementContext</class-id><body>This class holds all the descriptive information that SAXBuilderDriver needs to remember from the startElement until the endElement, to send the right information to the builder.Instance Variables:	attributes	&lt;Collection&gt; 	nodes	&lt;Array&gt; 	stream	&lt;XML.StreamWrapper&gt; 	startPosition	&lt;Integer&gt; 	id	&lt;nil | String&gt; </body></comment><class><name>InputSource</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>uri encoding stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Resources</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.InputSource</class-id><body>An InputSource represents a data source which may have been fetched locally or from the net, and which has various properties. An InputSource may be created by a SAXDriver in response to the #resolveEntity:systemID: message.In release 5i.4, we record the URI and the data, and if possible the encoding. In future we may want to also incorporate things like the MIME type or other attributes.Instance Variables	uri				&lt;nil | XML.URI | String &gt;	The URI of the data source, if known.  For performance,													FileURLs may be supplied as strings and lazily expanded.	encoding		&lt;nil | Symbol&gt; 	If the transport protocol specified an encoding,										this should take precedence over the encoding										contained in the &lt;?xml?&gt; declaration	stream		&lt;Stream&gt;			the data source</body></comment><class><name>SAXBuilderDriver</name><environment>XML</environment><super>XML.SAXDriver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder document elementStack newNamespaces </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-SAX</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.SAXBuilderDriver</class-id><body>This class converts SAX events into XMLNodeBuilder events, allowing old builders to still be used with the new parser.This is essentially a private class for XMLParser to allow the parser to pretend to still support the old NodeBuilder API.Instance Variables:	builder				&lt;XML.XMLNodeBuilder&gt;		The client's NodeBuilder, which creates XML Nodes.	document			&lt;XML.Document&gt;				The Document which models the entire XML document.	elementStack		&lt;OrderedCollection&gt;			A stack of proxies for the various elements that are in scope at the current stage of parsing.	newNamespaces	&lt;Dictionary&gt;					maps qualifiers to namespaces for the next element</body></comment><class><name>MixedPattern</name><environment>XML</environment><super>XML.ComplexPattern</super><private>false</private><indexed-type>none</indexed-type><inst-vars>items </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Patterns</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.MixedPattern</class-id><body>A subclass of ComplexPattern, this class represents the 'mixed' element content constraint in an element type declaration.An element type has mixed content when elements of that type may contain both other child elements and character data (text) as specified in the element content declaration.Note: For mixed content type elements, one can't control the order in which the child elements, mixed in among the text, appear.Instance Variables:	items	&lt;SequenceableCollection&gt;  A list of NamedPatterns (as well as one PCDATAPattern) which can appear as content in the context controlled by the MixedPattern.</body></comment><class><name>ResolveDefaultResource</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.ResolveDefaultResource</class-id><body>ResolveDefaultResource represents the default resolving behavior during entity resolution. See PluggableEntityResolver. The default resolving behavior is to ask the systemURI for a #resource, which with HTTP means a http get.</body></comment><class><name>SequencePattern</name><environment>XML</environment><super>XML.ComplexPattern</super><private>false</private><indexed-type>none</indexed-type><inst-vars>items </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Patterns</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.SequencePattern</class-id><body>This class represents the 'sequence' element content constraint in an element type declaration.According to the XML 1.0 specification, the 'sequence' pattern/rule signifies that content particles occuring in a sequence list (declared in the DTD) must each appear in the element content in the order given in the list.Instance Variables:	items	&lt;SequenceableCollection&gt;		Collection of content particles</body></comment><class><name>CharacterTable</name><environment>XML</environment><super>Core.LargeWordArray</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.CharacterTable</class-id><body>Class CharacterTable is an optimization of its superclass (LargeWordArray) that allows a smallish character table to masquerade as a large table.When the #at: primitive fails, the failure code checks to see if the index exceeded the size of the collection. If so, it answers the collection's default value, which means that characters whose Unicode values exceed a particular value will all be classified the same.</body></comment><class><name>ID_AT</name><environment>XML</environment><super>XML.AttributeType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Attributes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.ID_AT</class-id><body>A concrete subclass of AttributeType, this class represents the ID attribute type. This is also a tokenized type of attribute and values of ID type attributes must match legal names as defined in the XML 1.0 specification. For an XML document to be valid, ID values must uniquely identify the elements which bear them; i.e. a name must not appear more than once in an XML document as a value of this type. Also for validity purposes, an ID attribute must have a declared default of #IMPLIED or #REQUIRED in the DTD.ID and IDREF attributes together provide a simple inside-the-document linking mechanism with every IDREF attribute required to point to an ID attribute.</body></comment><class><name>ENTITIES_AT</name><environment>XML</environment><super>XML.AttributeType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Attributes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.ENTITIES_AT</class-id><body>A concrete subclass of AttributeType, this class represents the ENTITIES attribute type.This is a tokenized type of attribute that signifies to the XML parser that for the purposes of validating, the values of entities type attributes must match each of the names of unparsed entities declared in the document type definition.</body></comment><class><name>CDATA_AT</name><environment>XML</environment><super>XML.AttributeType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Attributes</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.CDATA_AT</class-id><body>A concrete subclass of AttributeType, this class represents the CDATA attribute type.CDATA attributes are genericly typed attributes which, at the level of interpretation done by XMLParser, have no constraints or semantics applied to their contents.</body></comment><class><name>InitialPattern</name><environment>XML</environment><super>XML.ConcretePattern</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isExternal </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Patterns</category><attributes><package>XML</package></attributes></class><comment><class-id>XML.InitialPattern</class-id><body>Since an element's content declaration may include multiple constraint rules or patterns, instances of this class are used to indicate to the XML parser, the initial or first rule in the declaration.</body></comment><shared-variable><name>CharacterClasses</name><environment>XML</environment><private>false</private><constant>true</constant><category>XML-Parsing</category><initializer>| ch sets t pc |			ch := CharacterTable new: 16r110000.			sets := Array with: (16r20 to: 16rD7FF)					with: (16rE000 to: 16rFFFD)					with: (16r10000 to: ch size-1).			pc := XMLParser.			t := Time millisecondsToRun: [				sets do: [:s || startS endS |					startS := s first.					endS := s last.					startS to: endS do: [:i || n |						n := 1.						(pc isNameStartChar: i) ifTrue: [n := n bitOr: 6].						(pc isNameChar: i) ifTrue: [n := n bitOr: 2].						ch at: i+1 put: n]]].			ch at: 9+1 put: 1.			ch at: 10+1 put: 1.			ch at: 13+1 put: 1.			ch at: $_ asInteger+1 put: 7.			ch at: $- asInteger+1 put: 3.			ch at: $. asInteger+1 put: 3.			Transcript cr; show: 'Time = ', t printString.			ch compress.			ch</initializer><attributes><package>XML</package></attributes></shared-variable><shared-variable><name>PredefinedEntities</name><environment>XML</environment><private>false</private><constant>false</constant><category>XML-Parsing</category><initializer>Dictionary new		at: 'amp' put: (GeneralEntity new name: 'amp'; text: '&amp;#38;');		at: 'lt' put: (GeneralEntity new name: 'lt'; text: '&amp;#60;');		at: 'gt' put: (GeneralEntity new name: 'gt'; text: (String with: $&gt;));		at: 'apos' put: (GeneralEntity new name: 'apos'; text: (String with: $'));		at: 'quot' put: (GeneralEntity new name: 'quot'; text: (String with: $"));		yourself</initializer><attributes><package>XML</package></attributes></shared-variable><shared-variable><name>XML_URI</name><environment>XML</environment><private>false</private><constant>false</constant><category>XML-Parsing</category><initializer> 'http://www.w3.org/XML/1998/namespace' </initializer><attributes><package>XML</package></attributes></shared-variable><shared-variable><name>SAXExternalParameterEntities</name><environment>XML.SAX</environment><private>false</private><constant>false</constant><category>Constants</category><initializer> 'http://xml.org/sax/features/external-parameter-entities' </initializer><attributes><package>XML</package></attributes></shared-variable><shared-variable><name>SAXValidate</name><environment>XML.SAX</environment><private>false</private><constant>false</constant><category>Constants</category><initializer> 'http://xml.org/sax/features/validation' </initializer><attributes><package>XML</package></attributes></shared-variable><shared-variable><name>SAXNamespacePrefixes</name><environment>XML.SAX</environment><private>false</private><constant>false</constant><category>Constants</category><initializer> 'http://xml.org/sax/features/namespace-prefixes' </initializer><attributes><package>XML</package></attributes></shared-variable><shared-variable><name>SAXNamespace</name><environment>XML.SAX</environment><private>false</private><constant>false</constant><category>Constants</category><initializer> 'http://xml.org/sax/features/namespaces' </initializer><attributes><package>XML</package></attributes></shared-variable><shared-variable><name>XMLSignal</name><environment>XML.SAX</environment><private>false</private><constant>true</constant><category>Signals</category><initializer> XML.SAXException </initializer><attributes><package>XML</package></attributes></shared-variable><shared-variable><name>SAXExternalGeneralEntities</name><environment>XML.SAX</environment><private>false</private><constant>false</constant><category>Constants</category><initializer> 'http://xml.org/sax/features/external-general-entities' </initializer><attributes><package>XML</package></attributes></shared-variable><methods><class-id>XML.AttributeType</class-id> <category>validating</category><body package="XML">completeValidationAgainst: aParser from: anAttributeDef	^self</body><body package="XML">simpleValidateValueOf: anAttribute for: aParser	| v |	v := anAttribute value copy.	v replaceAll: Character cr with: Character space.	v replaceAll: Character lf with: Character space.	v replaceAll: Character tab with: Character space.	anAttribute value: v</body><body package="XML">stringAsTokens: aString	| list str buffer hasToken |	list := OrderedCollection new.	str := aString readStream.	buffer := (String new: 8) writeStream.	hasToken := str atEnd not.	[[str atEnd or: [str peek isSeparator]]		whileFalse: [buffer nextPut: str next].	hasToken ifTrue: [list add: buffer contents. buffer reset].	str atEnd]			whileFalse:				[hasToken := true.				str skipSeparators].	^list</body><body package="XML">validateDefinition: anAttributeDefinition for: aParser	anAttributeDefinition hasDefault		ifTrue: [self validateValueOf: anAttributeDefinition for: aParser]</body><body package="XML">validateValueOf: anAttribute for: aParser	"We're going to do this the hard way for now. Most of this has been	done already, except for compressing multiple space characters that	were character references."	| v v1 |	v := anAttribute value.	[v1 := v copyReplaceAll: '  ' with: ' '.	v1 = v] whileFalse: [v := v1].	(v size &gt; 1 and: [v first = Character space])		ifTrue: [v := v copyFrom: 2 to: v size].	(v size &gt; 1 and: [v last = Character space])		ifTrue: [v := v copyFrom: 1 to: v size-1].	anAttribute value: v</body></methods><methods><class-id>XML.AttributeType</class-id> <category>testing</category><body package="XML">isExternal	^isExternal</body><body package="XML">isID	^false</body></methods><methods><class-id>XML.AttributeType</class-id> <category>accessing</category><body package="XML">isExternal: aBoolean	isExternal := aBoolean</body></methods><methods><class-id>XML.ENTITY_AT</class-id> <category>validating</category><body package="XML">completeValidationAgainst: aParser from: anAttributeDef	^anAttributeDef hasDefault		ifTrue: [self validateValueOf: anAttributeDef for: aParser]</body><body package="XML">validateDefinition: anAttributeDefinition for: aParser	^self</body><body package="XML">validateValueOf: anAttribute for: aParser	| v ent |	super validateValueOf: anAttribute for: aParser.	v := anAttribute value.	(v includes: Character space)		ifTrue: [aParser invalid: (#spaceInEntityAttribute &lt;&lt; #xml &gt;&gt; 'white space must not occur in ENTITY attributes')].	(aParser isValidName: v)		ifFalse: [aParser invalid: ((#invalidEntityAttribute &lt;&lt; #xml &gt;&gt; 'An ENTITY attribute (&lt;1s&gt;="&lt;2s&gt;") does not match the required syntax of a Name.')					expandMacrosWith: anAttribute tag asString					with: v)].	ent := aParser dtd generalEntityAt: v.	ent == nil		ifTrue: [aParser invalid: ((#attributeUsesUndefinedEntity &lt;&lt; #xml &gt;&gt; 'Undeclared unparsed entity "&lt;1s&gt;" used by attribute type "&lt;2s&gt;"')						expandMacrosWith: v						with: anAttribute tag asString)]		ifFalse: [ent isParsed			ifTrue: [aParser invalid: ((#parsedEntityTreatedAsUnparsed &lt;&lt; #xml &gt;&gt; 'The entity "&lt;1s&gt;" used by attribute type "&lt;2s&gt;" is a parsed entity and should be unparsed')							expandMacrosWith: v							with: anAttribute tag asString)]			ifFalse: []]</body></methods><methods><class-id>XML.Pattern</class-id> <category>initialize</category><body package="XML">followSet: aCollection	followSet := aCollection</body><body package="XML">initialize	followSet := OrderedCollection new: 2</body></methods><methods><class-id>XML.Pattern</class-id> <category>coercing</category><body package="XML">addFollow: aNode	followSet add: aNode</body><body package="XML">addFollows: aList	followSet addAll: aList</body><body package="XML">alternateHeads	^self subclassResponsibility</body><body package="XML">followSet	^followSet</body><body package="XML">normalize	| list done t r result |	list := OrderedCollection			with: (result := InitialPattern new addFollow: self)			with: self			with: TerminalPattern new.	self addFollow: list last.	done := OrderedCollection new.	[list isEmpty]		whileFalse:			[t := list removeFirst.			r := t pushDownFollowSet.			r == nil				ifTrue: [done add: t]				ifFalse: [list addAll: r]].	list := done.	done := OrderedCollection new.	[list isEmpty]		whileFalse:			[t := list removeFirst.			t normalizeFollowSet				ifTrue: [done add: t]				ifFalse: [list add: t]].	done do: [:p |		p isSimple ifFalse: [self error: (#incompleteNormalizationOfPattern &lt;&lt; #xml &gt;&gt; 'Incomplete translation')].		p followSet do: [:p1 |			p1 isSimple ifFalse: [self error: (#incompleteNormalizationOfPattern &lt;&lt; #xml &gt;&gt; 'Incomplete translation')]]].	^result</body><body package="XML">normalizeFollowSet	| changed oldFollow newFollow |	oldFollow := IdentitySet withAll: followSet.	newFollow := IdentitySet new.	oldFollow do: [:pat |		newFollow addAll: pat alternateHeads].	changed := newFollow size ~= oldFollow size or: [(newFollow - oldFollow) size &gt; 0].	followSet := newFollow asOrderedCollection.	^changed not</body><body package="XML">normalizeFor: aParser	| list done t r result |	list := OrderedCollection			with: (result := InitialPattern new addFollow: self)			with: self			with: TerminalPattern new.	self addFollow: list last.	done := OrderedCollection new.	[list isEmpty]		whileFalse:			[t := list removeFirst.			r := t pushDownFollowSet.			done add: t.			r == nil				ifFalse: [list addAll: r]].	done do: [:nd || replacements |		replacements := nd alternateHeads.		(replacements size = 1 and: [replacements first == nd])			ifFalse: [done do: [:nd2 |				nd2 replaceFollowSet: nd with: replacements]]].	done := IdentitySet new.	list := OrderedCollection with: result.	[list isEmpty]		whileFalse:			[t := list removeLast.			t isSimple				ifFalse: [aParser malformed: (#incompleteNormalizationOfPattern							&lt;&lt; #xml &gt;&gt; 'Incomplete translation')].			(self duplicatesNeedTested and: [t hasDuplicatesInFollowSet])				ifTrue: [aParser warn: (#nondeterministicContentModel							&lt;&lt; #xml &gt;&gt; 'Nondeterministic content model &lt;1s&gt;'								expandMacrosWith: self printString)].			done add: t.			t followSet do: [:t1 |				(done includes: t1) ifFalse: [list add: t1]]].	^result</body><body package="XML">pushDownFollowSet	^self subclassResponsibility</body><body package="XML">replaceFollowSet: node with: nodes	(followSet includes: node)		ifTrue: [followSet := (IdentitySet withAll: followSet)						remove: node;						addAll: nodes;						asArray].</body></methods><methods><class-id>XML.Pattern</class-id> <category>testing</category><body package="XML">duplicatesNeedTested	^true</body><body package="XML">isSimple	^self subclassResponsibility</body></methods><methods><class-id>XML.Pattern</class-id> <category>copying</category><body package="XML">postCopy	super postCopy.	followSet := OrderedCollection new: 2.</body></methods><methods><class-id>XML.Pattern class</class-id> <category>instance creation</category><body package="XML">new	^super new initialize</body></methods><methods><class-id>XML.ConcretePattern</class-id> <category>accessing</category><body package="XML">followSetDescription	| s |	s := (String new: 32) writeStream.	s nextPut: $(.	followSet do: [:n | s nextPutAll: n printString]		separatedBy: [s space].	s nextPut: $).	^s contents</body></methods><methods><class-id>XML.ConcretePattern</class-id> <category>testing</category><body package="XML">canTerminate	^followSet contains: [:p | p isTerminator]</body><body package="XML">couldBeText	^false</body><body package="XML">hasDuplicatesInFollowSet	1 to: followSet size do: [:i || p1 p2 ns tp |		p1 := followSet at: i.		p1 class == NamePattern			ifTrue:				[ns := p1 name namespace.				tp := p1 name type.				i+1 to: followSet size do: [:j |					p2 := followSet at: j.					(p2 class == NamePattern and:							[p2 name type = tp and:							[p2 name namespace = ns]])						ifTrue: [^true]]]].	^false</body><body package="XML">isSimple	^true</body><body package="XML">isTerminator	^false</body><body package="XML">matchesTag: aNodeTag	self subclassResponsibility</body></methods><methods><class-id>XML.ConcretePattern</class-id> <category>coercing</category><body package="XML">alternateHeads	^Array with: self</body><body package="XML">pushDownFollowSet	^nil</body></methods><methods><class-id>XML.ConcretePattern</class-id> <category>validation</category><body package="XML">validateTag: elementTag	| types |	types := IdentitySet new.	self followSet do: [:i |		(i matchesTag: elementTag)			ifTrue: [types add: i]].	^types isEmpty		ifTrue: [nil]		ifFalse: [types]</body><body package="XML">validateText: characters from: start to: stop testBlanks: testBlanks	self followSet do: [:i |		i couldBeText			ifTrue: [^i]].	testBlanks		ifTrue:			[start to: stop do: [:i |				(characters at: i) asInteger &gt; 16r0020					ifTrue: [^nil]].			^self].	^nil</body></methods><methods><class-id>XML.ConcretePattern</class-id> <category>printing</category><body package="XML">printOn: aStream	aStream nextPutAll: self description</body></methods><methods><class-id>XML.AnyPattern</class-id> <category>accessing</category><body package="XML">description	^'ANY'</body></methods><methods><class-id>XML.AnyPattern</class-id> <category>coercing</category><body package="XML">alternateHeads	^followSet copyWith: self</body><body package="XML">pushDownFollowSet	self addFollow: self.	^nil</body></methods><methods><class-id>XML.AnyPattern</class-id> <category>testing</category><body package="XML">couldBeText	^true</body><body package="XML">matchesTag: aNodeTag	^true</body></methods><methods><class-id>XML.Node</class-id> <category>initialize</category><body package="XML">initialize	flags := 0.</body></methods><methods><class-id>XML.Node</class-id> <category>accessing</category><body package="XML">children	^self shouldNotImplement</body><body package="XML">clientData	"The userData protocol allows access to the raw userData	instance variable, for code that expects to have complete	control over the use of this instance variable. For code that	expects to be sharing the instance variable with other code,	it can be accessed through #clientData, which will return a	Dictionary in which different programs can store their userData	under different keys."	userData == nil		ifTrue: [userData := Dictionary new].	^userData</body><body package="XML">discard	self flags: (self flags bitOr: 1)</body><body package="XML">document	^parent document</body><body package="XML">expandedName	^''</body><body package="XML">flags	^flags</body><body package="XML">flags: flagBits	flags := flagBits</body><body package="XML">parent	^parent</body><body package="XML">parent: aNode	parent := aNode</body><body package="XML">selectNodes: aBlock	^#()</body><body package="XML">tag	^nil</body><body package="XML">userData	^userData</body><body package="XML">userData: anObject	userData := anObject</body></methods><methods><class-id>XML.Node</class-id> <category>printing</category><body package="XML">canonicalPrintString	| s |	s := (String new: 1024) writeStream.	self printCanonicalOn: s.	^s contents</body><body package="XML">noIndentPrintString	| s |	s := (String new: 1024) writeStream.	self printNoIndentOn: s.	^s contents</body><body package="XML">printCanonical: text on: aStream	"Print myself on the stream in the form described by James	Clark's canonical XML."	| d |	d := Dictionary new.	d at: Character cr put: '&amp;#13;';		at: Character lf put: '&amp;#10;';		at: Character tab put: '&amp;#9;';		at: $&amp; put: '&amp;amp;';		at: $&lt; put: '&amp;lt;';		at: $&gt; put: '&amp;gt;';		at: $" put: '&amp;quot;'.	text do: [:c |		aStream nextPutAll: (d at: c ifAbsent: [String with: c])].</body><body package="XML">printCanonicalOn: aStream	"Print myself on the stream in the form described by James	Clark's canonical XML."	self saxDo: (SAXCanonicalWriter new output: aStream).</body><body package="XML">printHTMLOn: aStream	"Print myself on the stream in a form usual for HTML."	self subclassResponsibility</body><body package="XML">printNoIndentOn: aStream	"Print myself on the stream with line breaks between adjacent	elements, but no indentation."	self printNoIndentOn: aStream		endSpacing: [:node :list | aStream cr]		spacing: [:node :list | aStream cr]</body><body package="XML">printOn: aStream	self printOn: aStream depth: 0</body><body package="XML">printQuoted: text on: aStream	"Print myself on the stream in the form described by James	Clark's canonical XML."	| d |	d := Dictionary new.	d at: $&amp; put: '&amp;amp;';		at: $&lt; put: '&amp;lt;';		at: $&gt; put: '&amp;gt;'.	text do: [:c |		aStream nextPutAll: (d at: c ifAbsent: [String with: c])].</body><body package="XML">simpleDescription	^self printString</body></methods><methods><class-id>XML.Node</class-id> <category>testing</category><body package="XML">hasAncestor: aNode	| p |	p := self parent.	[p == nil] whileFalse:		[p == aNode ifTrue: [^true].		p := p parent].	^false</body><body package="XML">hasSubNodes	^false</body><body package="XML">isAttribute	^false</body><body package="XML">isBlankText	^false</body><body package="XML">isComment	^false</body><body package="XML">isContent	^false</body><body package="XML">isDiscarded	^(self flags bitAnd: 1) = 1</body><body package="XML">isDocument	^false</body><body package="XML">isElement	^false</body><body package="XML">isLike: aNode	^self class == aNode class</body><body package="XML">isProcessingInstruction	^false</body><body package="XML">isText	^false</body><body package="XML">precedes: aNode	| n1 n2 |	aNode document == self document		ifFalse: [self error: (#nodesNotInSameDocument &lt;&lt; #xml &gt;&gt; 'These nodes can''t be ordered. They are not in the same document.')].	aNode == self document		ifTrue: [^false].	self == self document		ifTrue: [^true].	n1 := self.	n2 := aNode.	(n2 hasAncestor: n1) ifTrue: [^true].	(n1 hasAncestor: n2) ifTrue: [^false].	[n1 parent == n2 parent] whileFalse:		[[n1 parent hasAncestor: n2 parent] whileTrue: [n1 := n1 parent].		[n2 parent hasAncestor: n1 parent] whileTrue: [n2 := n2 parent].		n1 parent == n2 parent			ifFalse: [n1 := n1 parent. n2 := n2 parent]].	^(n1 parent indexOf: n1) &lt; (n1 parent indexOf: n2)</body></methods><methods><class-id>XML.Node</class-id> <category>enumerating</category><body package="XML">nodesDo: aBlock	aBlock value: self</body></methods><methods><class-id>XML.Node</class-id> <category>namespaces</category><body package="XML">findNamespaceAt: qualifier	| ns node |	qualifier = 'xml' ifTrue: [^XML_URI].	ns := nil.	node := self.	[node isElement and: [ns == nil]]		whileTrue:			[ns := node namespaceAt: qualifier.			node := node parent].	^ns</body><body package="XML">findQualifierAtNamespace: ns	| qual node |	qual := nil.	node := self.	[node isElement and: [qual == nil]]		whileTrue:			[qual := node qualifierAtNamespace: ns.			node := node parent].	^qual</body><body package="XML">namespaceAt: qualifier	^nil</body><body package="XML">qualifierAtNamespace: ns	^nil</body></methods><methods><class-id>XML.Node class</class-id> <category>instance creation</category><body package="XML">new	^super new initialize</body></methods><methods><class-id>XML.Text</class-id> <category>accessing</category><body package="XML">characterData	^self text</body><body package="XML">characterDataOnto: str	str nextPutAll: self text</body><body package="XML">description	^(#text &lt;&lt; #xml &gt;&gt; 'text') asString</body><body package="XML">strip: aBoolean	stripped := aBoolean.</body><body package="XML">text	^text</body><body package="XML">text: aText	text := aText.	stripped == nil ifTrue: [stripped := false].</body></methods><methods><class-id>XML.Text</class-id> <category>printing</category><body package="XML">printHTMLOn: aStream	text == nil ifTrue: [^self].	self isStripped		ifFalse: [self printCanonical: text on: aStream.]</body><body package="XML">printOn: aStream depth: indent	text == nil		ifTrue: [aStream nextPutAll: '&amp;nil;']		ifFalse: [self printQuoted: text on: aStream].</body></methods><methods><class-id>XML.Text</class-id> <category>testing</category><body package="XML">isBlankText	^(text contains: [:i | i isSeparator not]) not</body><body package="XML">isContent	^true</body><body package="XML">isStripped	^stripped</body><body package="XML">isText	^true</body></methods><methods><class-id>XML.Text</class-id> <category>enumerating</category><body package="XML">saxDo: aDriver	aDriver characters: text from: 1 to: text size</body></methods><methods><class-id>XML.Text class</class-id> <category>instance creation</category><body package="XML">text: aString	^self new text: aString</body></methods><methods><class-id>XML.CDATA</class-id> <category>printing</category><body package="XML">printNoIndentOn: aStream endSpacing: endSpacingBlock spacing: spacingBlock	self printOn: aStream depth: 0</body><body package="XML">printOn: aStream depth: indent	aStream nextPutAll: '&lt;![CDATA['.	text == nil		ifFalse: [aStream nextPutAll: text].	aStream nextPutAll: ']]&gt;'.</body></methods><methods><class-id>XML.CDATA</class-id> <category>accessing</category><body package="XML">description	^(#cdata &lt;&lt; #xml &gt;&gt; 'cdata') asString</body></methods><methods><class-id>XML.CDATA</class-id> <category>enumerating</category><body package="XML">saxDo: aDriver	aDriver startCDATA.	super saxDo: aDriver.	aDriver endCDATA</body></methods><methods><class-id>XML.SAXException</class-id> <category>accessing</category><body package="XML">wrappedException	^wrappedException</body><body package="XML">wrappedException: anException	wrappedException := anException</body></methods><methods><class-id>XML.SAXException class</class-id> <category>testing</category><body package="XML">mayResume	^true</body></methods><methods><class-id>XML.Attribute</class-id> <category>initialize</category><body package="XML">name: nm value: val	name := nm isString			ifTrue: [NodeTag new qualifier: '' ns: '' type: nm]			ifFalse: [nm].	value := val</body><body package="XML">tag: aTag	name := aTag</body></methods><methods><class-id>XML.Attribute</class-id> <category>accessing</category><body package="XML">characterData	^self value</body><body package="XML">expandedName	^name expandedName</body><body package="XML">key	^name</body><body package="XML">tag	^name</body><body package="XML">value	^value</body><body package="XML">value: aValue	value := aValue</body></methods><methods><class-id>XML.Attribute</class-id> <category>printing</category><body package="XML">printCanonicalOn: aStream	aStream nextPutAll: self tag asString, '="'.	self printCanonical: value on: aStream.	aStream nextPutAll: '"'.</body><body package="XML">printOn: aStream	self printCanonicalOn: aStream</body><body package="XML">simpleDescription	^'@', self key</body></methods><methods><class-id>XML.Attribute</class-id> <category>testing</category><body package="XML">isAttribute	^true</body><body package="XML">isLike: aNode	^self class == aNode class		and: [self tag isLike: aNode tag]</body></methods><methods><class-id>XML.Attribute class</class-id> <category>instance creation</category><body package="XML">name: nm value: val	^self new name: nm value: val</body></methods><methods><class-id>XML.NMTOKENS_AT</class-id> <category>validating</category><body package="XML">validateValueOf: anAttribute for: aParser	| v all |	super validateValueOf: anAttribute for: aParser.	v := anAttribute value.	(all := self stringAsTokens: v) do: [:nm |		(aParser isValidNmToken: nm)			ifFalse: [aParser invalid: ((#invalidNmtokensAttribute &lt;&lt; #xml &gt;&gt; 'An NMTOKENS attribute (&lt;1s&gt;="&lt;2s&gt;") does not match the required syntax of a list of NmTokens.')					expandMacrosWith: anAttribute tag asString					with: v)]].	all size = 0 ifTrue: [aParser invalid: #EmptyNmtokens &lt;&lt; #xml &gt;&gt; 'Attribute has empty list of NMTOKENS'].</body></methods><methods><class-id>XML.SAXDriver</class-id> <category>other</category><body package="XML">comment: data from: start to: stop</body><body package="XML">endCDATA</body><body package="XML">idOfElement: elementID	"Notify the client what was the ID of the latest startElement"</body><body package="XML">sourcePosition: position inStream: streamWrapper	"Non-standard API to ease transition from	builders to SAX."</body><body package="XML">startCDATA</body></methods><methods><class-id>XML.SAXDriver</class-id> <category>content handler</category><body package="XML">characters: aString</body><body package="XML">characters: aString from: start to: stop	^self characters: (aString copyFrom: start to: stop)</body><body package="XML">endDocument</body><body package="XML">endDocumentFragment	"Nonstandard extension to SAX"</body><body package="XML">endElement: namespaceURI localName: localName qName: name	"indicates the end of an element. See startElement"</body><body package="XML">endPrefixMapping: prefix 	"End the scope of a prefix-URI mapping.	See startPrefixMapping for details. This event will always 	occur after the corresponding endElement event, but the 	order of endPrefixMapping events is not otherwise 	guaranteed. 		Parameters: 	prefix - The prefix that was being mapped.	"	^self</body><body package="XML">ignorableWhitespace: aString</body><body package="XML">ignorableWhitespace: aString from: start to: stop	^self ignorableWhitespace: (aString copyFrom: start to: stop)</body><body package="XML">processingInstruction: targetString data: dataString</body><body package="XML">setDocumentLocator: aLocator	locator := aLocator</body><body package="XML">skippedEntity: name 	"Receive notification of a skipped entity. 		The Parser will invoke this method once for each entity skipped.	Non-validating processors may skip entities if they have not seen	the declarations (because, for example, the entity was declared	in an external DTD subset). 		Parameters: 	name - The name of the skipped entity. If it is a parameter		entity, the name will begin with '%', and if it is the external		DTD subset, it will be the string '[dtd]'.	"	^self</body><body package="XML">startDocument</body><body package="XML">startDocumentFragment	"Nonstandard extension to SAX"</body><body package="XML">startElement: namespaceURI localName: localName qName: name attributes: attributes	"Receive notification of the beginning of an element.      Parameters:            namespaceURI &lt;String&gt; The Namespace URI, Nil if the element has no Namespace URI            localName &lt;String&gt; The local name of the element (without prefix)            name &lt;String&gt; Literal name of the element as it appears, nil if processing namespaces.            attributes &lt;SequenceableCollection of: XML.Attribute&gt; The attributes attached to the element.	Example		&lt;doc xmlns='http://www.doc.org/' xmlns:other='http://www.other.com/'&gt;			&lt;a&gt;A text&lt;/a&gt;			&lt;other:b&gt;BA text&lt;/other:b&gt;			&lt;c other:cat='meow'&gt;C text&lt;/c&gt;			&lt;d xmlns='http:/nested/'&gt;&lt;/d&gt;		&lt;/doc&gt;	Parameter values to this method for each element of the above XML:	local name: 'doc' namespace: 'http://www.doc.org/' name: 'doc'	local name: 'a' namespace: 'http://www.doc.org/' name: 'a'	local name: 'b' namespace: 'http://www.other.com/' name: 'other:b'	local name: 'c' namespace: 'http://www.doc.org/' name: 'c'	local name: 'd' namespace: 'http:/nested/' name: 'd'	Note the attribute object also have namespaces"</body><body package="XML">startPrefixMapping: prefix uri: uri 	"Begin the scope of a prefix-URI Namespace mapping. 	The information from this event is not necessary for 	normal Namespace processing: the SAX XML reader will 	automatically replace prefixes for element and attribute 	names when the http://xml.org/sax/features/namespaces 	feature is true (the default). 		There are cases, however, when applications need to use 	prefixes in character data or in attribute values, where 	they cannot safely be expanded automatically; the 	start/endPrefixMapping event supplies the information to 	the application to expand prefixes in those contexts itself, 	if necessary. 		Note that start/endPrefixMapping events are not 	guaranteed to be properly nested relative to each-other: 	all startPrefixMapping events will occur before the 	corresponding startElement event, and all 	endPrefixMapping events will occur after the 	corresponding endElement event, but their order is not 	otherwise guaranteed. 		There should never be start/endPrefixMapping events for 	the 'xml' prefix, since it is predeclared and immutable. 		Parameters: 	prefix - The Namespace prefix being declared. 	uri - The Namespace URI the prefix is mapped to.	"	^self</body></methods><methods><class-id>XML.SAXDriver</class-id> <category>error handler</category><body package="XML">fatalError: anException	anException raiseSignal</body><body package="XML">nonFatalError: anException	anException raiseSignal</body><body package="XML">warning: anException	Transcript cr; show: anException messageText</body></methods><methods><class-id>XML.SAXDriver</class-id> <category>DTD handler</category><body package="XML">notationDecl: nameString publicID: publicIDString systemID: systemIDString 	"Receive notification of a notation declaration event. 		It is up to the application to record the notation for later	reference, if necessary. 		If a system identifier is present, and it is a URL, the SAX	parser must resolve it fully before passing it to the application."</body><body package="XML">unparsedEntityDecl: name publicID: publicID systemID: systemID notationName: notation 	"Receive notification of an unparsed entity declaration 	event. 		Note that the notation name corresponds to a notation 	reported by the notationDecl event. It is up to the 	application to record the entity for later reference, if 	necessary. 		If the system identifier is a URL, the parser must resolve it 	fully before passing it to the application.	"	^self</body></methods><methods><class-id>XML.SAXDriver</class-id> <category>entity resolver</category><body package="XML">resolveEntity: publicID systemID: systemID	^nil</body></methods><methods><class-id>XML.SAXDriver</class-id> <category>accessing</category><body package="XML">contentHandler	^self</body><body package="XML">document	^nil</body><body package="XML">dtdHandler	^self</body><body package="XML">entityResolver	^self</body><body package="XML">errorHandler	^self</body></methods><methods><class-id>XML.SAXDriver</class-id> <category>private</category><body package="XML">invalid: aMessage	"Allows a SAX driver to act like a parser when accessing a DocumentType"	self nonFatalError: (InvalidSignal new messageText: aMessage)</body><body package="XML">isValidating	"Allows a SAX driver to act like a parser when accessing a DocumentType"	^false</body><body package="XML">malformed: aMessage	"Allows a SAX driver to act like a parser when accessing a DocumentType"	self fatalError: (MalformedSignal new messageText: aMessage)</body><body package="XML">warn: aMessage	"Allows a SAX driver to act like a parser when accessing a DocumentType"	self warning: (WarningSignal new messageText: aMessage)</body></methods><methods><class-id>XML.NullSAXDriver</class-id> <category>content handler</category><body package="XML">characters: aString from: start to: stop	^self</body><body package="XML">ignorableWhitespace: aString from: start to: stop	^self</body></methods><methods><class-id>XML.XMLNodeBuilder</class-id> <category>initialize</category><body package="XML">initialize	tagStack := OrderedCollection new.	tags := Dictionary new.</body></methods><methods><class-id>XML.XMLNodeBuilder</class-id> <category>accessing</category><body package="XML">currentTag	^tagStack last tag</body><body package="XML">popTag	tagStack removeLast</body><body package="XML">pushTag: tag	tagStack addLast: (ElementContext new tag: tag).</body></methods><methods><class-id>XML.XMLNodeBuilder</class-id> <category>building</category><body package="XML">attribute: name value: value	^Attribute name: name value: value</body><body package="XML">comment: aText	^Comment new text: aText</body><body package="XML">makeText: text	^Text text: text</body><body package="XML">notation: name value: val	^Notation new name: name identifiers: val</body><body package="XML">pi: nm text: text	^PI new name: nm text: text</body></methods><methods><class-id>XML.XMLNodeBuilder class</class-id> <category>instance creation</category><body package="XML">new	^super new initialize</body></methods><methods><class-id>XML.NodeBuilder</class-id> <category>building</category><body package="XML">tag: tag attributes: attributes elements: elements position: p stream: stream	^Element tag: tag attributes: attributes elements: elements</body></methods><methods><class-id>XML.ComplexPattern</class-id> <category>testing</category><body package="XML">isSimple	^false</body></methods><methods><class-id>XML.ChoicePattern</class-id> <category>initialize</category><body package="XML">on: aList	items := aList</body></methods><methods><class-id>XML.ChoicePattern</class-id> <category>coercing</category><body package="XML">alternateHeads	^items</body><body package="XML">pushDownFollowSet	items do: [:i | i addFollows: followSet].	^items</body></methods><methods><class-id>XML.ChoicePattern</class-id> <category>printing</category><body package="XML">description	| str |	str := String new writeStream.	str nextPutAll: '('.	items do: [:ch | str nextPutAll: ch description] separatedBy: [str nextPutAll: ' | '].	str nextPutAll: ')'.	^str contents</body><body package="XML">printOn: aStream	aStream nextPutAll: self description</body></methods><methods><class-id>XML.ChoicePattern</class-id> <category>copying</category><body package="XML">postCopy	super postCopy.	items := items collect: [:i | i copy].</body></methods><methods><class-id>XML.ChoicePattern class</class-id> <category>instance creation</category><body package="XML">on: aList	^self new on: aList</body></methods><methods><class-id>XML.AttributeDef</class-id> <category>accessing</category><body package="XML">default	^default</body><body package="XML">default: n	flags := 0.	default := nil.	n = #required		ifTrue: [flags := 1]		ifFalse: [n = #implied			ifTrue: [flags := 2]			ifFalse:				[n class == Association					ifFalse: [self error: (#invalidAttributeDefault &lt;&lt; #xml &gt;&gt; 'Invalid default')].				n key ifTrue: [flags := 4].				default := n value]]</body><body package="XML">hasDefault	^(self isImplied or: [self isRequired]) not</body><body package="XML">isFixed	^(flags bitAnd: 4) = 4</body><body package="XML">isImplied	^(flags bitAnd: 2) = 2</body><body package="XML">isRequired	^(flags bitAnd: 1) = 1</body><body package="XML">name	^name</body><body package="XML">name: n	name := n</body><body package="XML">tag	^name</body><body package="XML">type	^type</body><body package="XML">type: n	type := n</body></methods><methods><class-id>XML.AttributeDef</class-id> <category>validating</category><body package="XML">completeValidationAgainst: aParser	^self type completeValidationAgainst: aParser from: self</body><body package="XML">selfValidateFor: aParser	type validateDefinition: self for: aParser</body><body package="XML">validateValueOf: anAttribute for: aParser	type validateValueOf: anAttribute for: aParser.	(self isFixed not or: [anAttribute value = self default])		ifFalse: [aParser invalid: ((#invalidFixedAttribute &lt;&lt; #xml &gt;&gt; 'The attribute "&lt;1s&gt;" was declared FIXED, but the value used in the document ("&lt;2s&gt;") did not match the default ("&lt;3s&gt;")')						expandMacrosWith: anAttribute tag asString						with: anAttribute value						with: self default)].</body></methods><methods><class-id>XML.AttributeDef</class-id> <category>private</category><body package="XML">value	^self default</body><body package="XML">value: str	default := str</body></methods><methods><class-id>XML.ModifiedPattern</class-id> <category>initialize</category><body package="XML">on: aNode type: t	node := aNode.	modification := t.</body></methods><methods><class-id>XML.ModifiedPattern</class-id> <category>coercing</category><body package="XML">alternateHeads	^(modification = $* or: [modification = $?])		ifTrue: [(followSet copyWith: node) replaceAll: self with: node]		ifFalse: [Array with: node]</body><body package="XML">pushDownFollowSet	(modification = $+ or: [modification = $*])		ifTrue: [node addFollow: self].	node addFollows: followSet.	^Array with: node</body></methods><methods><class-id>XML.ModifiedPattern</class-id> <category>printing</category><body package="XML">description	^node description copyWith: modification</body><body package="XML">printOn: aStream	aStream nextPutAll: self description</body></methods><methods><class-id>XML.ModifiedPattern</class-id> <category>copying</category><body package="XML">postCopy	super postCopy.	node := node copy</body></methods><methods><class-id>XML.ModifiedPattern class</class-id> <category>instance creation</category><body package="XML">on: aNode type: t	^self new on: aNode type: t</body></methods><methods><class-id>XML.DOM_SAXDriver</class-id> <category>other</category><body package="XML">comment: data from: start to: stop	document == nil ifTrue: [self startDocument].	stack last addNode: (Comment new text: (data copyFrom: start to: stop))</body><body package="XML">endCDATA	stateForCDATA == nil		ifFalse: [stateForCDATA := #normal].</body><body package="XML">idOfElement: elementID	"Notify the client what was the ID of the latest startElement"	document atID: elementID put: stack last</body><body package="XML">startCDATA	stateForCDATA == nil		ifFalse: [stateForCDATA := #cdata].</body></methods><methods><class-id>XML.DOM_SAXDriver</class-id> <category>content handler</category><body package="XML">characters: aString	stateForCDATA == #cdata		ifTrue: [stack last addNode: (CDATA text: aString)]		ifFalse: [stack last addNode: (Text text: aString)]</body><body package="XML">endDocument	document := stack removeLast.	document isDocument ifFalse: [self error: #unexpectedEndOfDocument &lt;&lt; #xml &gt;&gt; 'End of Document not expected'].	stack isEmpty ifFalse: [self error: #unexpectedEndOfDocument &lt;&lt; #xml &gt;&gt; 'End of Document not expected'].</body><body package="XML">endDocumentFragment	document := stack removeLast.	document isDocument ifFalse: [self error: #unexpectedEndOfDocument &lt;&lt; #xml &gt;&gt; 'End of Document not expected'].	stack isEmpty ifFalse: [self error: #unexpectedEndOfDocument &lt;&lt; #xml &gt;&gt; 'End of Document not expected'].</body><body package="XML">endElement: namespaceURI localName: localName qName: name	"indicates the end of an element. See startElement"	stack removeLast condenseList</body><body package="XML">ignorableWhitespace: aString	stack last addNode: (Text text: aString)</body><body package="XML">processingInstruction: targetString data: dataString	document == nil ifTrue: [self startDocument].	stack last addNode: (PI name: targetString text: dataString)</body><body package="XML">startDocument	document := Document new.	document dtd: DocumentType new.	stack := OrderedCollection with: document</body><body package="XML">startDocumentFragment	document := DocumentFragment new.	document dtd: DocumentType new.	stack := OrderedCollection with: document</body><body package="XML">startElement: namespaceURI localName: localName qName: name attributes: attributes	| element tag |	document == nil ifTrue: [self startDocument].	tag := NodeTag new		qualifier: ((name includes: $:)				ifTrue: [name copyUpTo: $:]				ifFalse: [''])		ns: namespaceURI		type: localName.	element := Element			tag: tag			attributes: attributes			elements: OrderedCollection new.	element namespaces: newNamespaces.	newNamespaces := nil.	stack size = 1 ifTrue: [document dtd declaredRoot: name].	stack last addNode: element.	stack addLast: element</body><body package="XML">startPrefixMapping: prefix uri: uri 	newNamespaces == nil		ifTrue: [newNamespaces := Dictionary new].	newNamespaces at: prefix put: uri.</body></methods><methods><class-id>XML.DOM_SAXDriver</class-id> <category>DTD handler</category><body package="XML">notationDecl: name publicID: publicID systemID: systemID	| notation |	notation := Notation new name: name identifiers: (Array with: publicID with: systemID).	document dtd notationAt: name put: notation from: self</body></methods><methods><class-id>XML.DOM_SAXDriver</class-id> <category>accessing</category><body package="XML">document	^document</body><body package="XML">recordCDATA: flag	flag		ifTrue: [stateForCDATA == nil			ifTrue: [stateForCDATA := #normal]]		ifFalse: [stateForCDATA := nil]</body></methods><methods><class-id>XML.DOM_SAXDriver</class-id> <category>compat</category><body package="XML">endElement	| namespaceURI localName name tag |	tag := stack last tag.	tag isString		ifTrue:			[localName := name := tag.			namespaceURI := '']		ifFalse:			[localName := tag type.			name := tag asString.			namespaceURI := tag namespace].	^self endElement: namespaceURI localName: localName qName: name</body><body package="XML">startElement: tag atts: attrs	| namespaceURI localName name attributes |	tag isString		ifTrue:			[localName := name := tag.			namespaceURI := '']		ifFalse:			[localName := tag type.			name := tag asString.			namespaceURI := tag namespace].	attributes := attrs == nil		ifTrue: [#()]		ifFalse: [attrs].	^self startElement: namespaceURI localName: localName qName: name attributes: attributes</body></methods><methods><class-id>XML.Comment</class-id> <category>printing</category><body package="XML">printHTMLOn: aStream	self printOn: aStream</body><body package="XML">printOn: aStream depth: indent	aStream nextPutAll: '&lt;!--', (text == nil ifTrue: [''] ifFalse: [text]), '--&gt;'</body></methods><methods><class-id>XML.Comment</class-id> <category>accessing</category><body package="XML">text	^text</body><body package="XML">text: aText	text := aText</body></methods><methods><class-id>XML.Comment</class-id> <category>testing</category><body package="XML">isComment	^true</body></methods><methods><class-id>XML.Comment</class-id> <category>enumerating</category><body package="XML">saxDo: aDriver	aDriver comment: text from: 1 to: text size</body></methods><methods><class-id>XML.Entity</class-id> <category>accessing</category><body package="XML">entityType	^self subclassResponsibility</body><body package="XML">externalFrom: anArray	anArray class == Array		ifFalse: [self error: (#invalidIDForExternal &lt;&lt; #xml &gt;&gt; 'External ID is expected to be an Array')].	anArray size = 2		ifTrue:			[publicID := anArray at: 1.			systemID := anArray at: 2]		ifFalse:			[self error: (#wrongNumberOfIdentifiers &lt;&lt; #xml &gt;&gt; 'External ID has too many or too few identifiers')]</body><body package="XML">name	^name</body><body package="XML">name: aName	name := aName</body><body package="XML">publicID	^publicID</body><body package="XML">streamFor: aParser	(aParser hasExpanded: self)		ifTrue: [aParser malformed: (#recursiveDefinitions &lt;&lt; #xml &gt;&gt; 'Can''t expand this entity; it is defined recursively')].	text == nil		ifTrue:			[| str input |			input := aParser saxDriver				resolveEntity: self publicID				systemID: self systemID.			input == nil ifTrue: [input := systemID asURI resource].			aParser pushSource: (str := StreamWrapper								resource: input								entity: self								from: aParser).			str textDecl.			aParser getNextChar]		ifFalse:			[aParser pushSource: (StreamWrapper								resource: (InputSource uri: nil encoding: nil stream: text readStream)								entity: self								from: aParser).			aParser getNextChar].</body><body package="XML">systemID	^systemID</body><body package="XML">text: aString	text := aString</body></methods><methods><class-id>XML.Entity</class-id> <category>testing</category><body package="XML">isExternal	^publicID notNil or: [systemID notNil]</body><body package="XML">isParsed	^true</body></methods><methods><class-id>XML.Entity</class-id> <category>printing</category><body package="XML">printOn: aStream	self basicPrintOn: aStream.	text == nil		ifTrue: [aStream nextPutAll: '(',self systemID,')']		ifFalse: [aStream nextPutAll: '(',text,')']</body></methods><methods><class-id>XML.GeneralEntity</class-id> <category>accessing</category><body package="XML">entityType	^'generic'</body><body package="XML">isDefinedExternally	^definedExternally</body><body package="XML">isDefinedExternally: aBoolean	definedExternally := aBoolean</body><body package="XML">ndata: aNotifierNameOrNil	ndata := aNotifierNameOrNil</body></methods><methods><class-id>XML.GeneralEntity</class-id> <category>testing</category><body package="XML">isParsed	^ndata == nil</body></methods><methods><class-id>XML.GeneralEntity</class-id> <category>validation</category><body package="XML">completeValidationAgainst: aParser	ndata isNil		ifFalse: [aParser dtd notationAt: ndata ifAbsent:				[aParser invalid: ((#entityUsesUndefinedNotation &lt;&lt; #xml &gt;&gt; 'Unparsed entity "&lt;1s&gt;" uses an undeclared notation "&lt;2s&gt;"')						expandMacrosWith: name						with: ndata)]]</body></methods><methods><class-id>XML.SAXWriter</class-id> <category>content handler</category><body package="XML">characters: aString from: start to: stop	| ch mapped |	self closeOpenTag.	normalizeText		ifTrue: [start to: stop do: [:i |				ch := aString at: i.				mapped := textMap at: ch ifAbsent: [nil].				mapped == nil					ifTrue: [output nextPut: ch]					ifFalse: [output nextPutAll: mapped]]]		ifFalse: [output next: stop+1-start putAll: aString startingAt: start]</body><body package="XML">comment: data from: start to: stop	self closeOpenTag.	output nextPutAll: '&lt;!--';		next: stop+1-start putAll: data startingAt: start;		nextPutAll: '--&gt;'</body><body package="XML">endElement: namespaceURI localName: localName qName: name	hasOpenTag == true		ifTrue: [output nextPutAll: '/&gt;']		ifFalse: [output nextPutAll: '&lt;/', name, '&gt;'].	hasOpenTag := false.</body><body package="XML">processingInstruction: targetString data: dataString	self closeOpenTag.	output nextPutAll: '&lt;?';		nextPutAll: targetString;		space;		nextPutAll: dataString;		nextPutAll: '?&gt;'</body><body package="XML">startDocument	hasOpenTag := false</body><body package="XML">startDocumentFragment	"Nonstandard extension to SAX"	hasOpenTag := false</body><body package="XML">startElement: namespaceURI localName: localName qName: name attributes: attributes	| val |	notations == nil ifFalse: [self emitDTD: name].	self closeOpenTag.	output nextPutAll: '&lt;'.	output nextPutAll: name.	(self sort: attributes) do: [:att |		output space.		output nextPutAll: att tag asString.		output nextPutAll: '="'.		1 to: att value size do: [:i || ch mapped |			ch := att value at: i.			mapped := attrMap at: ch ifAbsent: [nil].			mapped == nil				ifTrue: [output nextPut: ch]				ifFalse: [output nextPutAll: mapped]].		output nextPutAll: '"'].	newNamespaces == nil		ifFalse: [newNamespaces keys asSortedCollection do: [:key |				output space.				output nextPutAll: (key isEmpty ifTrue: ['xmlns'] ifFalse: ['xmlns:', key]).				output nextPutAll: '="'.				val := newNamespaces at: key.				1 to: val size do: [:i || ch mapped |					ch := val at: i.					mapped := attrMap at: ch ifAbsent: [nil].					mapped == nil						ifTrue: [output nextPut: ch]						ifFalse: [output nextPutAll: mapped]].				output nextPutAll: '"']].	newNamespaces := nil.	hasOpenTag := true</body><body package="XML">startPrefixMapping: prefix uri: uri 	newNamespaces == nil		ifTrue: [newNamespaces := Dictionary new].	newNamespaces at: prefix put: uri.</body></methods><methods><class-id>XML.SAXWriter</class-id> <category>initialize</category><body package="XML">minimalCharacterMapping	textMap := Dictionary new		at: $&lt; put: '&amp;lt;';		at: $&amp; put: '&amp;amp;';			"Added &gt; because in rare cases, like text that contains ]]&gt;,			the &gt; must be quoted."		at: $&gt; put: '&amp;gt;';		yourself.	attrMap := Dictionary new		at: $&lt; put: '&amp;lt;';		at: $&amp; put: '&amp;amp;';		at: $" put: '&amp;quot;';		yourself.</body><body package="XML">normalizeText: aBoolean	normalizeText := aBoolean</body><body package="XML">output: aStream	output := aStream.	normalizeText := true.	notations := nil.	textMap == nil ifTrue: [self minimalCharacterMapping].</body></methods><methods><class-id>XML.SAXWriter</class-id> <category>DTD handler</category><body package="XML">notationDecl: nameString publicID: publicIDString systemID: systemIDString 	notations == nil ifTrue: [notations := OrderedCollection new].	notations add: (Array with: nameString with: publicIDString with: systemIDString)</body></methods><methods><class-id>XML.SAXWriter</class-id> <category>private</category><body package="XML">closeOpenTag	hasOpenTag == true		ifTrue:			[output nextPutAll: '&gt;'.			hasOpenTag := false].</body><body package="XML">emitDTD: name	| list |	output nextPutAll: '&lt;!DOCTYPE ';		nextPutAll: name;		nextPutAll: ' [';		cr.	list := notations asSortedCollection: [:a1 :a2 | a1 first &lt; a2 first].	list do: [:notation |		self emitNotation: notation.		output cr].	output nextPutAll: ']&gt;'; cr.	notations := nil.</body><body package="XML">emitNotation: array	output nextPutAll: '&lt;!NOTATION ';		nextPutAll: (array at: 1);		space;		nextPutAll: ((array at: 2) == nil ifTrue: ['SYSTEM'] ifFalse: ['PUBLIC']).	(array at: 2) == nil		ifFalse: [output nextPutAll: ' ''';				nextPutAll: (array at: 2);				nextPutAll: ''''].	(array at: 3) == nil		ifFalse: [output nextPutAll: ' ''';				nextPutAll: (array at: 3);				nextPutAll: ''''].	output nextPutAll: '&gt;'.</body><body package="XML">sort: attributes	^attributes asSortedCollection: [:a1 :a2 | a1 tag asString &lt; a2 tag asString]</body></methods><methods><class-id>XML.SAXWriter</class-id> <category>other</category><body package="XML">endCDATA	normalizeText := true.	output nextPutAll: ']]&gt;'.</body><body package="XML">startCDATA	self closeOpenTag.	normalizeText ifFalse: [self error: #NestedCDATANotPermitted &lt;&lt; #xml &gt;&gt; 'nested CDATA sections are not permitted'].	normalizeText := false.	output nextPutAll: '&lt;![CDATA['.</body></methods><methods><class-id>XML.EmptyPattern</class-id> <category>coercing</category><body package="XML">alternateHeads	^followSet</body></methods><methods><class-id>XML.EmptyPattern</class-id> <category>testing</category><body package="XML">matchesTag: aNodeTag	^false</body></methods><methods><class-id>XML.EmptyPattern</class-id> <category>accessing</category><body package="XML">description	^'EMPTY'</body></methods><methods><class-id>XML.NMTOKEN_AT</class-id> <category>validating</category><body package="XML">validateValueOf: anAttribute for: aParser	| v |	super validateValueOf: anAttribute for: aParser.	v := anAttribute value.	(v includes: Character space)		ifTrue: [aParser invalid: (#spaceInNmtokenAttribute &lt;&lt; #xml &gt;&gt; 'white space must not occur in NMTOKEN attributes')].	(aParser isValidNmToken: v)		ifFalse: [aParser invalid: ((#invalidNmtokenAttribute &lt;&lt; #xml &gt;&gt; 'An NMTOKEN attribute (&lt;1s&gt;="&lt;2s&gt;") does not match the required syntax of an NmToken.')					expandMacrosWith: anAttribute tag asString					with: v)]</body></methods><methods><class-id>XML.StreamWrapper</class-id> <category>initialize</category><body package="XML">isInternal: aBoolean	isInternal := aBoolean</body><body package="XML">resource: anInputSource entity: ent from: aParser	resource := anInputSource.	stream := resource stream.	isInternal := resource hasURI not.	entity := ent.	cr := Character cr.	lf := Character lf.	parser := aParser.	line := 1.	column := 0.</body><body package="XML">usedAsExternal	^usedAsExternal</body><body package="XML">usedAsExternal: aBoolean	usedAsExternal := aBoolean</body></methods><methods><class-id>XML.StreamWrapper</class-id> <category>accessing</category><body package="XML">checkEncoding	| encoding |	encoding := [stream encoding] on: Error do: [:ex | ex returnWith: #null].	encoding = #'UTF-8'		ifTrue:			[| c1 c2 pos |			pos := stream position.			stream setBinary: true.			c1 := stream next.			c2 := stream next.			stream setBinary: false.			(c2 notNil and: [c1 * c2 = 16rFD02])				ifTrue: [stream encoder: (UTF16StreamEncoder new									forByte1: c1 byte2: c2)]				ifFalse: [stream position: pos]]</body><body package="XML">close	stream close</body><body package="XML">column	^column</body><body package="XML">column: n	column := n</body><body package="XML">contents	| s |	s := (String new: 100) writeStream.	[self atEnd]		whileFalse: [s nextPut: self next].	^s contents</body><body package="XML">entity	^entity</body><body package="XML">line	^line</body><body package="XML">line: n	line := n</body><body package="XML">stream	^stream</body><body package="XML">uri	^resource uri</body></methods><methods><class-id>XML.StreamWrapper</class-id> <category>streaming</category><body package="XML">next	| ch |	ch := stream next.	isInternal		ifFalse:			[column := column+1.			ch == cr				ifTrue:					[stream peekFor: lf.					ch := parser eol.					line := line+1.					column := 0]				ifFalse: [ch == lf					ifTrue:						[ch := parser eol.						line := line+1.						column := 0]]].	"Originally we tested ch to make sure it was less than 16r110000,	but now CharacterClasses' implementation of #at: answers 0 for	large values of ch. If primitive failure code can not be trusted to do	this, then the bounds check would have to be added back."	(ch isNil or: [(CharacterClasses at: ch asInteger+1) &gt; 0])		ifFalse: [parser errorHandler fatalError: (BadCharacterSignal new messageText:((#illegalUnicodeCharacter &lt;&lt; #xml &gt;&gt; 'A character with Unicode value &lt;1p&gt; is not legal') expandMacrosWith: ch asInteger))].	^ch</body><body package="XML">skip: n	stream skip: n.	column := column-1.</body></methods><methods><class-id>XML.StreamWrapper</class-id> <category>testing</category><body package="XML">atEnd	^stream atEnd</body><body package="XML">hasURI	^resource hasURI</body><body package="XML">isInternal	^isInternal</body></methods><methods><class-id>XML.StreamWrapper</class-id> <category>declaration</category><body package="XML">encodingDecl	| enc |	^stream peek = $e		ifTrue:			[| encoding |			self mustFind: 'encoding'.			self skipSpace.			self mustFind: '='.			self skipSpace.			encoding := self quotedString.			parser validateEncoding: encoding.			((stream respondsTo: #encoding)					and: [stream encoding asLowercase ~= encoding asLowercase])				ifTrue:					[enc := (StreamEncoder new: encoding asSymbol)								initializeForFiles.					stream encoder: enc].			true]		ifFalse: [false]</body><body package="XML">mustFind: str	(self skipIf: str)		ifFalse: [parser expected: str].</body><body package="XML">quotedString	(stream peekFor: $")		ifTrue: [^(stream upTo: $") asString].	(stream peekFor: $')		ifTrue: [^(stream upTo: $') asString].	parser malformed: (#expectedQuotedString &lt;&lt; #xml &gt;&gt; 'Quoted string expected but not found')</body><body package="XML">sdDecl	^stream peek = $s		ifTrue:			[| word |			self mustFind: 'standalone'.			self skipSpace.			self mustFind: '='.			self skipSpace.			word := self quotedString.			(#('yes' 'no') includes: word)				ifFalse: [parser malformed: (#expectedYesOrNo &lt;&lt; #xml &gt;&gt; '"yes" or "no" expected, but not found')].			parser declaredStandalone: word = 'yes'.			true]		ifFalse: [false]</body><body package="XML">skipIf: str	| p |	p := stream position.	1 to: str size do: [:i |		(stream peekFor: (str at: i))			ifFalse:				[stream position: p.				^false]].	column := column+str size.	^true</body><body package="XML">skipSpace	| space |	space := false.	[#(9 10 13 32) includes: self next asInteger]		whileTrue: [space := true].	self skip: -1.	^space</body><body package="XML">textDecl	self checkEncoding.	^(self skipIf: '&lt;?xml')		ifTrue:			[| hasSpace |			hasSpace := self skipSpace.			hasSpace				ifTrue: [self versionInfo == nil					ifFalse: [hasSpace := self skipSpace]].			hasSpace				ifTrue: [self encodingDecl					ifFalse: [parser expected: 'encoding']]				ifFalse: [self encodingDecl					ifTrue: [parser expectedWhitespace]					ifFalse: [parser expected: 'encoding']].			self skipSpace.			self mustFind: '?&gt;'.			true]		ifFalse: [false]</body><body package="XML">versionInfo	| version |	^stream peek = $v		ifTrue:			[self mustFind: 'version'.			self skipSpace.			self mustFind: '='.			self skipSpace.			version := self quotedString.			version = '1.0' ifFalse: [parser malformed: (#expectedVersion1 &lt;&lt; #xml &gt;&gt; 'XML version 1.0 expected')].			version]		ifFalse: [nil]</body><body package="XML">xmlDecl	self checkEncoding.	^(self skipIf: '&lt;?xml')		ifTrue:			[| hasSpace version |			(self skipSpace)				ifTrue: [version := self versionInfo]				ifFalse: [version := nil].			version = nil ifTrue: [parser expected: 'version'].			parser xmlVersion: version.			hasSpace := self skipSpace.			hasSpace				ifTrue: [self encodingDecl					ifTrue: [hasSpace := self skipSpace]]				ifFalse: [self encodingDecl					ifTrue: [parser expectedWhitespace]].			hasSpace				ifTrue: [self sdDecl					ifTrue: [hasSpace := self skipSpace]]				ifFalse: [self sdDecl					ifTrue: [parser expectedWhitespace]].			self mustFind: '?&gt;'.			true]		ifFalse: [false]</body></methods><methods><class-id>XML.StreamWrapper class</class-id> <category>instance creation</category><body package="XML">emptyWithExtraSpace: space from: aParser	| txt |	txt := space ifTrue: ['  '] ifFalse: [''].	^self resource: (InputSource uri: nil encoding: nil stream: txt readStream)			entity: nil			from: aParser</body><body package="XML">resource: anInputSource entity: entity from: aParser	^self new resource: anInputSource entity: entity from: aParser</body></methods><methods><class-id>XML.ParameterEntity</class-id> <category>accessing</category><body package="XML">entityType	^'parameter'</body><body package="XML">streamFor: aParser addSpaces: spaces	| myText textStr input |	(aParser hasExpanded: self)		ifTrue: [aParser malformed: (#recursiveDefinitions &lt;&lt; #xml &gt;&gt; 'Can''t expand this entity; it is defined recursively')].	text == nil		ifTrue:			[| str |			input := aParser saxDriver				resolveEntity: self publicID				systemID: self systemID.			input == nil ifTrue: [input := systemID asURI resource].			resolvedURI := input uri.			str := StreamWrapper						resource: input						entity: self						from: aParser.			[str textDecl.			textStr := (String new: 32) writeStream.			[str atEnd] whileFalse: [textStr nextPut: str next].			text := textStr contents]				ensure: [str close]].	myText := text.	spaces ifTrue: [myText := ' ', text, ' '].	aParser pushSource: (StreamWrapper						resource: (InputSource							uri: resolvedURI							encoding: nil							stream: myText readStream)						entity: self						from: aParser).	aParser getNextChar.</body></methods><methods><class-id>XML.Enumeration_AT</class-id> <category>accessing</category><body package="XML">values	^values</body><body package="XML">values: aList	values := aList</body></methods><methods><class-id>XML.Enumeration_AT</class-id> <category>validating</category><body package="XML">validateValueOf: anAttribute for: aParser	| v |	super validateValueOf: anAttribute for: aParser.	v := anAttribute value.	(values includes: v)		ifFalse: [aParser invalid: ((#invalidEnumerationAttribute &lt;&lt; #xml &gt;&gt; 'An attribute (&lt;1s&gt;="&lt;2s&gt;") should have had a value from &lt;3p&gt;.')					expandMacrosWith: anAttribute tag asString					with: v					with: values asArray)]</body></methods><methods><class-id>XML.Enumeration_AT class</class-id> <category>instance creation</category><body package="XML">withAll: list	^self new values: list</body></methods><methods><class-id>XML.Document</class-id> <category>initialize</category><body package="XML">initialize	super initialize.	nodes := OrderedCollection new.	ids := Dictionary new</body></methods><methods><class-id>XML.Document</class-id> <category>accessing</category><body package="XML">addNamespaceDefinitions	| d tag |	d := Dictionary new.	self nodesDo: [:aNode |		tag := aNode tag.		tag isNil			ifFalse:				[(d at: tag qualifier ifAbsent: [tag namespace]) = tag namespace					ifFalse: [self error: (#sameQualifierInMultipleNamespaces &lt;&lt; #xml &gt;&gt; 'Using the same tag for multiple namespaces is not currently supported')].				d at: tag qualifier put: tag namespace]].	(d at: '' ifAbsent: ['']) = ''		ifTrue: [d removeKey: '' ifAbsent: []].	d removeKey: 'xml' ifAbsent: [].	d removeKey: 'xmlns' ifAbsent: [].	self root == nil ifFalse: [self root namespaces: d]</body><body package="XML">addNode: aNode	nodes add: aNode.	aNode parent: self.	aNode isElement		ifTrue: [root == nil			ifTrue: [root := aNode]			ifFalse: [self error: (#onlyOneTopLevelElement &lt;&lt; #xml &gt;&gt; 'It is illegal to have more than one element node at the top level in a document')]]</body><body package="XML">atID: id ifAbsent: aBlock	^ids at: id ifAbsent: aBlock</body><body package="XML">atID: id put: element	ids at: id put: element</body><body package="XML">children	^nodes</body><body package="XML">document	^self</body><body package="XML">dtd	^dtd</body><body package="XML">dtd: aDTD	dtd := aDTD</body><body package="XML">elements	^nodes</body><body package="XML">indexOf: aChild	aChild parent == self ifFalse: [^nil].	^self children identityIndexOf: aChild ifAbsent: [nil]</body><body package="XML">root	^root</body><body package="XML">selectNodes: aBlock	^nodes select: aBlock</body></methods><methods><class-id>XML.Document</class-id> <category>testing</category><body package="XML">hasSubNodes	^nodes size &gt; 0</body><body package="XML">isContent	^true</body><body package="XML">isDocument	^true</body></methods><methods><class-id>XML.Document</class-id> <category>printing</category><body package="XML">printHTMLOn: aStream	nodes do: [:n | n printHTMLOn: aStream]</body><body package="XML">printOn: aStream	nodes do: [:n | n printOn: aStream. aStream cr]</body><body package="XML">printSunCanonicalOn: aStream	self dtd notNil		ifTrue: [self dtd printCanonicalOn: aStream].	nodes do: [:n | n printCanonicalOn: aStream]</body></methods><methods><class-id>XML.Document</class-id> <category>enumerating</category><body package="XML">nodesDo: aBlock	aBlock value: self.	1 to: self elements size do: [:i |		(self elements at: i) nodesDo: aBlock]</body><body package="XML">saxDo: aDriver	aDriver startDocument.	self dtd == nil ifFalse: [self dtd saxDo: aDriver].	1 to: self children size do: [:i |		(self children at: i) saxDo: aDriver].	aDriver endDocument</body></methods><methods><class-id>XML.DocumentFragment</class-id> <category>accessing</category><body package="XML">addNode: aNode	nodes add: aNode.	aNode parent: self.	aNode isElement		ifTrue: [root == nil			ifTrue: [root := aNode]]</body></methods><methods><class-id>XML.DocumentFragment</class-id> <category>enumerating</category><body package="XML">saxDo: aDriver	aDriver startDocumentFragment.	self dtd == nil ifFalse: [self dtd saxDo: aDriver].	1 to: self children size do: [:i |		(self children at: i) saxDo: aDriver].	aDriver endDocumentFragment</body></methods><methods><class-id>XML.DocumentType</class-id> <category>initialize</category><body package="XML">initialize	notations := Dictionary new.	elementDefs := Dictionary new.	attributeDefs := Dictionary new.	generalEntities := Dictionary new.	parameterEntities := Dictionary new.</body></methods><methods><class-id>XML.DocumentType</class-id> <category>accessing</category><body package="XML">attributeFor: key subKey: k2 from: anErrorReporter	| val |	(val := attributeDefs at: key asString ifAbsent: []) == nil		ifTrue: [anErrorReporter invalid: ((#undefinedAttribute &lt;&lt; #xml &gt;&gt; 'The attribute "&lt;1s&gt; &lt;2s&gt;" has not been defined')							expandMacrosWith: key asString							with: k2 asString)].	^val at: k2 asString		ifAbsent: [anErrorReporter invalid: ((#undefinedAttribute &lt;&lt; #xml &gt;&gt; 'The attribute "&lt;1s&gt; &lt;2s&gt;" has not been defined')							expandMacrosWith: key asString							with: k2 asString)]</body><body package="XML">attributeFor: key subKey: k2 put: value from: anErrorReporter	| dict |	dict := attributeDefs at: key asString ifAbsentPut: [Dictionary new].	(dict includesKey: k2 asString)		ifTrue: [^anErrorReporter warn: ((#multipleAttributeDefinitions &lt;&lt; #xml &gt;&gt; 'The attribute "&lt;1s&gt; &lt;2s&gt;" has been defined more than once')					expandMacrosWith: key asString					with: k2 asString)].	(value type isID and: [dict contains: [:attr | attr type isID]])		ifTrue: [^anErrorReporter invalid: ((#multipleIdAttributes &lt;&lt; #xml &gt;&gt; 'The element &lt;1s&gt; has two attributes typed as ID') expandMacrosWith: key asString)].	dict at: k2 asString put: value</body><body package="XML">attributesFor: key	^attributeDefs at: key asString ifAbsent: [Dictionary new]</body><body package="XML">attributeTypeFor: key subKey: k2 from: anErrorReporter	| val |	(val := attributeDefs at: key asString ifAbsent: []) == nil		ifTrue: [^CDATA_AT new].	^(val at: k2 asString		ifAbsent: [^CDATA_AT new]) type</body><body package="XML">declaredRoot	^declaredRoot</body><body package="XML">declaredRoot: aTag	declaredRoot := aTag</body><body package="XML">elementFor: key from: anErrorReporter	| val |	(val := elementDefs at: key asString ifAbsent: []) == nil		ifTrue: [anErrorReporter warn: ((#undefinedElement &lt;&lt; #xml &gt;&gt; 'The element "&lt;1s&gt;" has not been defined')							expandMacrosWith: key asString)].	^val</body><body package="XML">elementFor: key put: value from: anErrorReporter	(elementDefs includesKey: key asString)		ifTrue:			[| msg |			msg := ((#multipleElementDefinitions &lt;&lt; #xml &gt;&gt; 'The element "&lt;1s&gt;" has been defined more than once')						expandMacrosWith: key asString).			anErrorReporter isValidating				ifTrue: [anErrorReporter invalid: msg]				ifFalse: [anErrorReporter warn: msg]].	elementDefs at: key asString put: value</body><body package="XML">generalEntityAt: key	"We do some tricks to make sure that, if the value	is predefined in the parser, we use the predefined	value. We could just store the predefined values	in with the general ones, but we don't want to show	warnings if the user (very correctly) defines them.	An enhancement would be to let the user use his own	values rather than the predefined ones, but we know	that the predefined ones will be correct--we don't know	that his will be."	| val |	val := PredefinedEntities at: key ifAbsent: [].	val == nil		ifTrue: [val := generalEntities at: key ifAbsent: []].	^val</body><body package="XML">generalEntityAt: key put: value from: anErrorReporter	(generalEntities includesKey: key)		ifTrue: [^anErrorReporter warn: ((#multipleEntityDefinitions &lt;&lt; #xml &gt;&gt; 'The general entity "&lt;1s&gt;" has been defined more than once')						expandMacrosWith: key)].	generalEntities at: key put: value</body><body package="XML">notationAt: name from: anErrorReporter	^notations at: name ifAbsent: [anErrorReporter invalid: (#UndeclaredNotation &lt;&lt; #xml &gt;&gt; 'Reference to an undeclared Notation') asString]</body><body package="XML">notationAt: name ifAbsent: aBlock	^notations at: name ifAbsent: aBlock</body><body package="XML">notationAt: name put: notation from: anErrorReporter	(notations includesKey: name)		ifTrue: [anErrorReporter invalid: (#duplicateNotationDefinitions &lt;&lt; #xml &gt;&gt; 'Duplicate definitions for a Notation')].	notations at: name put: notation</body><body package="XML">parameterEntityAt: key	^parameterEntities at: key ifAbsent: []</body><body package="XML">parameterEntityAt: key put: value from: anErrorReporter	(parameterEntities includesKey: key)		ifTrue: [^anErrorReporter warn: ((#multiplePEntityDefinitions &lt;&lt; #xml &gt;&gt; 'The parameter entity "&lt;1s&gt;" has been defined more than once')						expandMacrosWith: key)].	parameterEntities at: key put: value</body></methods><methods><class-id>XML.DocumentType</class-id> <category>private</category><body package="XML">completeValidationAgainst: aParser	generalEntities keysAndValuesDo: [:eName :entity |		entity completeValidationAgainst: aParser].	attributeDefs keysAndValuesDo: [:eName :attribs |		attribs keysAndValuesDo: [:aName :attrib |			attrib completeValidationAgainst: aParser]]</body></methods><methods><class-id>XML.DocumentType</class-id> <category>printing</category><body package="XML">printCanonicalOn: aStream	"Jumping through hoops to get Notations printed	just as Sun desires--Are public IDs really supposed	to have their white space normalized? If so, we	should move normalization to the parser."	| s s1 |	notations isEmpty ifTrue: [^self].	aStream nextPutAll: '&lt;!DOCTYPE ';		nextPutAll: declaredRoot asString;		nextPutAll: ' ['; cr.	(notations asSortedCollection: [:n1 :n2 | n1 name &lt; n2 name])		do: [:n |			aStream nextPutAll: '&lt;!NOTATION ';				nextPutAll: n name; space.			n publicID == nil				ifTrue: [aStream nextPutAll: 'SYSTEM']				ifFalse:					[s := n publicID copy.					s replaceAll: Character cr with: Character space.					s replaceAll: Character lf with: Character space.					s replaceAll: Character tab with: Character space.					[s1 := s copyReplaceAll: '  ' with: ' '.					s1 = s] whileFalse: [s := s1].					aStream						nextPutAll: 'PUBLIC ''';						nextPutAll: s;						nextPut: $'].			n systemID == nil				ifFalse: [aStream						nextPutAll: ' ''';						nextPutAll: n systemID;						nextPut: $'].			aStream nextPutAll: '&gt;'; cr].	aStream nextPutAll: ']&gt;'; cr.</body></methods><methods><class-id>XML.DocumentType</class-id> <category>enumerating</category><body package="XML">saxDo: aDriver	notations == nil		ifFalse: [notations do: [:n |					aDriver notationDecl: n name publicID: n publicID systemID: n systemID]]</body></methods><methods><class-id>XML.DocumentType class</class-id> <category>instance creation</category><body package="XML">new	^super new initialize</body></methods><methods><class-id>XML.IDREF_AT</class-id> <category>validating</category><body package="XML">validateValueOf: anAttribute for: aParser	| v |	super validateValueOf: anAttribute for: aParser.	v := anAttribute value.	(v includes: Character space)		ifTrue: [aParser invalid: (#spaceInIdrefAttribute &lt;&lt; #xml &gt;&gt; 'white space must not occur in IDREF attributes')].	(aParser isValidName: v)		ifFalse: [aParser invalid: ((#invalidIdrefAttribute &lt;&lt; #xml &gt;&gt; 'An IDREF attribute (&lt;1s&gt;="&lt;2s&gt;") does not match the required syntax of a Name.')					expandMacrosWith: anAttribute tag asString					with: v)].	aParser rememberIDREF: v</body></methods><methods><class-id>XML.PCDATAPattern</class-id> <category>accessing</category><body package="XML">description	^'#PCDATA'</body></methods><methods><class-id>XML.PCDATAPattern</class-id> <category>testing</category><body package="XML">couldBeText	^true</body><body package="XML">matchesTag: aNodeTag	^false</body></methods><methods><class-id>XML.TerminalPattern</class-id> <category>accessing</category><body package="XML">description	^(#CloseTag &lt;&lt; #xml &gt;&gt; '&lt;/ close tag &gt;')</body></methods><methods><class-id>XML.TerminalPattern</class-id> <category>testing</category><body package="XML">isTerminator	^true</body><body package="XML">matchesTag: aNodeTag	^false</body></methods><methods><class-id>XML.NamePattern</class-id> <category>initialize</category><body package="XML">named: aName	name := aName</body></methods><methods><class-id>XML.NamePattern</class-id> <category>accessing</category><body package="XML">description	^(#xmlElementTag &lt;&lt; #xml &gt;&gt; '%&lt;&lt;1s&gt;%&gt;') expandMacrosWith: name</body><body package="XML">name	^name</body></methods><methods><class-id>XML.NamePattern</class-id> <category>testing</category><body package="XML">matchesTag: aNodeTag	^name isLike: aNodeTag</body></methods><methods><class-id>XML.NamePattern class</class-id> <category>instance creation</category><body package="XML">named: aName	^self new named: aName</body></methods><methods><class-id>XML.SAXDispatcher</class-id> <category>accessing</category><body package="XML">contentHandler	^contentHandler</body><body package="XML">contentHandler: aSAXDriver	contentHandler := aSAXDriver</body><body package="XML">document	^contentHandler document</body><body package="XML">dtdHandler	^dtdHandler</body><body package="XML">dtdHandler: aSAXDriver	dtdHandler := aSAXDriver</body><body package="XML">entityResolver	^entityResolver</body><body package="XML">entityResolver: aSAXDriver	entityResolver := aSAXDriver</body><body package="XML">errorHandler	^errorHandler</body><body package="XML">errorHandler: aSAXDriver	errorHandler := aSAXDriver</body><body package="XML">handlers: aSAXDriver	self contentHandler: aSAXDriver.	self dtdHandler: aSAXDriver.	self errorHandler: aSAXDriver.	self entityResolver: aSAXDriver</body></methods><methods><class-id>XML.SAXDispatcher</class-id> <category>other</category><body package="XML">comment: data from: start to: stop	contentHandler comment: data from: start to: stop</body><body package="XML">endCDATA	contentHandler endCDATA</body><body package="XML">idOfElement: elementID	contentHandler idOfElement: elementID</body><body package="XML">sourcePosition: position inStream: stream	contentHandler sourcePosition: position inStream: stream</body><body package="XML">startCDATA	contentHandler startCDATA</body></methods><methods><class-id>XML.SAXDispatcher</class-id> <category>content handler</category><body package="XML">characters: aString from: start to: stop	contentHandler characters: aString from: start to: stop</body><body package="XML">endDocument	contentHandler endDocument</body><body package="XML">endDocumentFragment	contentHandler endDocumentFragment</body><body package="XML">endElement: namespaceURI localName: localName qName: name	contentHandler endElement: namespaceURI localName: localName qName: name</body><body package="XML">endPrefixMapping: prefix	contentHandler endPrefixMapping: prefix</body><body package="XML">ignorableWhitespace: aString from: start to: stop	contentHandler ignorableWhitespace: aString from: start to: stop</body><body package="XML">processingInstruction: targetString data: dataString	contentHandler processingInstruction: targetString data: dataString</body><body package="XML">setDocumentLocator: aLocator	contentHandler setDocumentLocator: aLocator</body><body package="XML">skippedEntity: name	contentHandler skippedEntity: name</body><body package="XML">startDocument	contentHandler startDocument</body><body package="XML">startDocumentFragment	contentHandler startDocumentFragment</body><body package="XML">startElement: namespaceURI localName: localName qName: name attributes: attributes	contentHandler startElement: namespaceURI localName: localName qName: name attributes: attributes</body><body package="XML">startPrefixMapping: prefix uri: uri	contentHandler startPrefixMapping: prefix uri: uri</body></methods><methods><class-id>XML.SAXDispatcher</class-id> <category>DTD handler</category><body package="XML">notationDecl: nameString publicID: publicIDString systemID: systemIDString	dtdHandler notationDecl: nameString publicID: publicIDString systemID: systemIDString</body><body package="XML">unparsedEntityDecl: name publicID: publicID systemID: systemID notationName: notation	dtdHandler unparsedEntityDecl: name publicID: publicID systemID: systemID notationName: notation</body></methods><methods><class-id>XML.SAXDispatcher</class-id> <category>initialize</category><body package="XML">initialize	contentHandler := NullSAXDriver new.	dtdHandler := contentHandler.	entityResolver := contentHandler.	errorHandler := contentHandler.</body></methods><methods><class-id>XML.SAXDispatcher</class-id> <category>entity resolver</category><body package="XML">resolveEntity: publicID systemID: systemID	^entityResolver resolveEntity: publicID systemID: systemID</body></methods><methods><class-id>XML.SAXDispatcher</class-id> <category>error handler</category><body package="XML">fatalError: anException	errorHandler fatalError: anException</body><body package="XML">nonFatalError: anException	errorHandler nonFatalError: anException</body><body package="XML">warning: anException	errorHandler warning: anException</body></methods><methods><class-id>XML.SAXDispatcher class</class-id> <category>instance creation</category><body package="XML">new	^super new initialize</body></methods><methods><class-id>XML.Element</class-id> <category>initialize</category><body package="XML">initialize	super initialize.	tag := (#undefined &lt;&lt; #xml &gt;&gt; 'undefined') asString.	attributes := #().</body></methods><methods><class-id>XML.Element</class-id> <category>accessing</category><body package="XML">addAttribute: anAttribute	anAttribute parent: self.	attributes == nil		ifTrue: [attributes := OrderedCollection new: 5]		ifFalse: [attributes class == Array			ifTrue: [attributes := attributes asOrderedCollection]].	attributes addLast: anAttribute</body><body package="XML">anyElementNamed: elementName	"This will return the receiver if its name matches the requirement."	| list |	list := self anyElementsNamed: elementName.	list size &gt; 1 ifTrue: [self error: (#noUniqueElement &lt;&lt; #xml &gt;&gt; 'There is not a unique element with this tag')].	^list isEmpty ifFalse: [list first]</body><body package="XML">anyElementsNamed: elementName	"This includes the receiver as one of the possibilities."	| list |	list := OrderedCollection new.	self nodesDo: [:e |		(e isElement and: [e tag isLike: elementName])			ifTrue: [list add: e]].	^list</body><body package="XML">attributes	^attributes == nil		ifTrue: [#()]		ifFalse: [attributes]</body><body package="XML">characterData	| str all |	all := self elements.	all size = 0 ifTrue: [^''].	(all size = 1 and: [all first isContent]) ifTrue: [^all first characterData].	str := (String new: 128) writeStream.	self characterDataOnto: str.	^str contents</body><body package="XML">characterDataOnto: str	self elements do: [:i |		i isContent ifTrue: [i characterDataOnto: str]].</body><body package="XML">children	^elements == nil		ifTrue: [#()]		ifFalse: [elements]</body><body package="XML">definition	^definition</body><body package="XML">definition: aPattern	definition := aPattern</body><body package="XML">description	^(#elementDescription &lt;&lt; #xml &gt;&gt; 'an %&lt;&lt;1s&gt;&gt; element') expandMacrosWith: tag</body><body package="XML">elementNamed: elementName	| list |	list := self elementsNamed: elementName.	list size = 1 ifFalse: [self error: (#noUniqueElement &lt;&lt; #xml &gt;&gt; 'There is not a unique element with this tag')].	^list first</body><body package="XML">elements	^elements == nil		ifTrue: [#()]		ifFalse: [elements]</body><body package="XML">elementsNamed: elementName	^self elements select: [:e | e isElement and: [e tag isLike: elementName]]</body><body package="XML">expandedName	^tag expandedName</body><body package="XML">indexOf: aChild	aChild parent == self ifFalse: [^nil].	^aChild isAttribute		ifTrue: [-1]		ifFalse: [elements identityIndexOf: aChild ifAbsent: [nil]]</body><body package="XML">namespaces: aDictionaryOrNil	namespaces := aDictionaryOrNil</body><body package="XML">realElements	^elements notNil		ifTrue: [elements select: [:elt | elt isElement]]		ifFalse: [OrderedCollection new]</body><body package="XML">selectNodes: aBlock	^self attributes, self elements select: aBlock</body><body package="XML">tag	^tag</body><body package="XML">valueOfAttribute: attributeName ifAbsent: aBlock	^(self attributes		detect: [:a | a tag isLike: attributeName]		ifNone: [^aBlock value]) value</body></methods><methods><class-id>XML.Element</class-id> <category>printing</category><body package="XML">printHTMLOn: aStream	| elem |	self saxDo: (SAXWriter new output: aStream)		forBodyDo:			[elem := elements == nil				ifTrue: [#()]				ifFalse: [elements" reject: [:str | str isBlankText]"].			self isHTMLBlock ifTrue: [aStream cr].			elem do: [:e |				e printHTMLOn: aStream.				self isHTMLBlock ifTrue: [aStream cr]]]</body><body package="XML">printOn: aStream depth: indent	| elem |	self saxDo: (SAXWriter new output: aStream)		forBodyDo:			[elements == nil				ifFalse:					[elem := elements reject: [:str | str isText and: [str isStripped]].					(elem size &lt;= 1 and: [(elem contains: [:n | n isText not]) not])						ifTrue: [elem do: [:e |									e printOn: aStream depth: indent+1]]						ifFalse:							[1 to: elem size do: [:i | | e |								e := elem at: i.								aStream crtab: indent+1.								e isString 									ifTrue: [aStream nextPutAll: e]									ifFalse: [e printOn: aStream depth: indent+1]].							aStream crtab: indent]]]</body><body package="XML">simpleDescription	^'&lt;', self tag asString, '&gt;'</body></methods><methods><class-id>XML.Element</class-id> <category>namespaces</category><body package="XML">namespaceAt: qualifier	^namespaces == nil		ifTrue: [nil]		ifFalse: [namespaces at: qualifier ifAbsent: [nil]]</body><body package="XML">qualifierAtNamespace: ns	^namespaces == nil		ifTrue: [nil]		ifFalse:			[namespaces keysAndValuesDo: 				[:qualifier :namespace | namespace = ns ifTrue: [^qualifier]].			nil]</body></methods><methods><class-id>XML.Element</class-id> <category>private</category><body package="XML">attributes: a	attributes := a.	a == nil ifFalse: [a do: [:i | i parent: self]].</body><body package="XML">condenseList	elements == nil		ifFalse: [elements size = 0			ifTrue: [elements := nil]			ifFalse: [elements := elements asArray]]</body><body package="XML">condenseText	| elmts str tc |	elmts := (Array new: elements size) writeStream.	str := nil.	elements do: [:elm |		elm isText			ifTrue:				[str == nil ifTrue: [str := (String new: elm text size) writeStream].				tc := elm class.				str nextPutAll: elm text]			ifFalse:				[str == nil ifFalse: [elmts nextPut: (tc new text: str contents)].				str := nil.				elmts nextPut: elm]].	str == nil ifFalse: [elmts nextPut: (tc new text: str contents)].	elements := elmts contents.</body><body package="XML">elements: e	elements := e.	self isEmpty		ifFalse:			[self condenseText.			elements do: [:elm | elm parent: self]]</body><body package="XML">setTag: t attributes: a elements: e	tag := t isString			ifTrue: [NodeTag new qualifier: '' ns: '' type: t]			ifFalse: [t].	self attributes: a.	self elements: e</body></methods><methods><class-id>XML.Element</class-id> <category>testing</category><body package="XML">hasSubNodes	^elements size &gt; 0 or: [attributes size &gt; 0]</body><body package="XML">isContent	^true</body><body package="XML">isElement	^true</body><body package="XML">isEmpty	^elements == nil</body><body package="XML">isHTMLBlock	^#('p' 'html' 'head' 'body') includes: tag asLowercase</body><body package="XML">isLike: aNode	^self class == aNode class		and: [self tag isLike: aNode tag]</body><body package="XML">notEmpty	^elements ~~ nil</body></methods><methods><class-id>XML.Element</class-id> <category>enumerating</category><body package="XML">nodesDo: aBlock	aBlock value: self.	1 to: self attributes size do: [:i |		(self attributes at: i) nodesDo: aBlock].	1 to: self elements size do: [:i |		(self elements at: i) nodesDo: aBlock]</body><body package="XML">saxDo: aDriver	namespaces == nil		ifFalse: [namespaces keysAndValuesDo: [:qual :uri |			aDriver startPrefixMapping: qual uri: uri]].	aDriver startElement: self tag namespace			localName: self tag type			qName: self tag asString			attributes: self attributes.	1 to: self children size do: [:i |		(self children at: i) saxDo: aDriver].	aDriver endElement: self tag namespace			localName: self tag type			qName: self tag asString.	namespaces == nil		ifFalse: [namespaces keysAndValuesDo: [:qual :uri |			aDriver endPrefixMapping: qual]].</body><body package="XML">saxDo: aDriver forBodyDo: aBlock	"a variation on #saxDo: that lets the client	control how the body of the element is to be	printed."	namespaces == nil		ifFalse: [namespaces keysAndValuesDo: [:qual :uri |			aDriver startPrefixMapping: qual uri: uri]].	aDriver startElement: self tag namespace			localName: self tag type			qName: self tag asString			attributes: self attributes.	(aDriver respondsTo: #closeOpenTag) ifTrue: [aDriver closeOpenTag].	aBlock value.	aDriver endElement: self tag namespace			localName: self tag type			qName: self tag asString.	namespaces == nil		ifFalse: [namespaces keysAndValuesDo: [:qual :uri |			aDriver endPrefixMapping: qual]].</body></methods><methods><class-id>XML.Element</class-id> <category>modifying</category><body package="XML">addNode: aNode	aNode parent: self.	elements == nil		ifTrue: [elements := OrderedCollection new: 5]		ifFalse: [elements class == Array			ifTrue: [elements := elements asOrderedCollection]].	elements addLast: aNode</body></methods><methods><class-id>XML.Element class</class-id> <category>instance creation</category><body package="XML">tag: tag	^self new setTag: tag attributes: nil elements: nil</body><body package="XML">tag: tag attributes: attributes elements: elements	^self new setTag: tag attributes: attributes elements: elements</body><body package="XML">tag: tag elements: elements	^self new setTag: tag attributes: nil elements: elements</body></methods><methods><class-id>XML.IDREFS_AT</class-id> <category>validating</category><body package="XML">validateValueOf: anAttribute for: aParser	| v all |	super validateValueOf: anAttribute for: aParser.	v := anAttribute value.	(all := self stringAsTokens: v) do: [:nm |		(aParser isValidName: nm)			ifFalse: [aParser invalid: ((#invalidIdrefsAttribute &lt;&lt; #xml &gt;&gt; 'An IDREFS attribute (&lt;1s&gt;="&lt;2s&gt;") does not match the required syntax of a list of Names.')					expandMacrosWith: anAttribute tag asString					with: v)].		aParser rememberIDREF: nm].	all size = 0 ifTrue: [aParser invalid: #EmptyIdrefs &lt;&lt; #xml &gt;&gt; 'Attribute has empty list of IDREFS'].</body></methods><methods><class-id>XML.NodeTag</class-id> <category>initialize</category><body package="XML">qualifier: q ns: ns type: typeStr	namespace := ns.	type := typeStr.	qualifier := q</body></methods><methods><class-id>XML.NodeTag</class-id> <category>accessing</category><body package="XML">expandedName	^namespace isEmpty		ifTrue: [type]		ifFalse: [namespace, '#', type]</body><body package="XML">namespace	^namespace</body><body package="XML">qualifier	^qualifier</body><body package="XML">type	^type</body></methods><methods><class-id>XML.NodeTag</class-id> <category>converting</category><body package="XML">asString	^qualifier isEmpty		ifTrue: [type]		ifFalse: [qualifier, ':', type]</body></methods><methods><class-id>XML.NodeTag</class-id> <category>testing</category><body package="XML">isLike: aName	^aName isString		ifTrue: [namespace isEmpty and: [type = aName]]		ifFalse: [namespace = aName namespace and: [type = aName type]]</body></methods><methods><class-id>XML.NodeTag</class-id> <category>printing</category><body package="XML">printOn: aStream	aStream nextPutAll: '{', self asString, '}'</body></methods><methods><class-id>XML.NodeTag</class-id> <category>comparing</category><body package="XML">&lt; aNodeTag 	"Answer whether the receiver is less than the argument."	^self asString &lt; aNodeTag asString</body><body package="XML">= aNodeTag	^self class = aNodeTag class		and: [self type = aNodeTag type		and: [self namespace == nil			ifTrue: [self qualifier = aNodeTag qualifier]			ifFalse: [self namespace = aNodeTag namespace]]]</body><body package="XML">hash	"The hash value is not dependent on either the namespace	or the qualifier, but equality is dependent on this. We think	this will not be a problem because collisions between tags	that have the same type but different namespaces or qualifiers	should be rare in the majority of cases."	^self type hash</body></methods><methods><class-id>XML.XMLFilter</class-id> <category>accessing</category><body package="XML">atFeature: aURIstring	^parent atFeature: aURIstring</body><body package="XML">atFeature: aURIstring put: aBoolean	^parent atFeature: aURIstring put: aBoolean</body><body package="XML">atProperty: aURIstring	^parent atProperty: aURIstring</body><body package="XML">atProperty: aURIstring put: anOvbject	^parent atProperty: aURIstring put: anOvbject</body><body package="XML">parent	^parent</body><body package="XML">parent: aParserOrFilter	parent := aParserOrFilter.	parent handlers: self.</body><body package="XML">parse: dataSource	^parent parse: dataSource</body><body package="XML">parseElement: dataSource	^parent parseElement: dataSource</body><body package="XML">parseElements: dataSource	^parent parseElements: dataSource</body></methods><methods><class-id>XML.XMLFilter class</class-id> <category>instance creation</category><body package="XML">on: aParserOrFilter	^self new parent: aParserOrFilter</body></methods><methods><class-id>XML.SAXCanonicalWriter</class-id> <category>content handler</category><body package="XML">comment: data from: start to: stop	"Canonical XML surpresses comments"	^self</body><body package="XML">startElement: namespaceURI localName: localName qName: name attributes: attributes	super startElement: namespaceURI localName: localName qName: name attributes: attributes.	self closeOpenTag.</body></methods><methods><class-id>XML.SAXCanonicalWriter</class-id> <category>private</category><body package="XML">emitNotation: array	| sysID frag |	sysID := array at: 3.	sysID == nil ifTrue: [^super emitNotation: array].	sysID size to: 2 by: -1 do: [:i |		frag := sysID copyFrom: i to: sysID size.		frag replaceAll: $: with: $/.		frag replaceAll: $\ with: $/.		([(baseURI resolvePath: frag) asString = sysID] on: Error do: [:x | x return: false])			ifTrue: [^super emitNotation: (array copy at: 3 put: frag; yourself)]].	super emitNotation: array</body></methods><methods><class-id>XML.SAXCanonicalWriter</class-id> <category>initialize</category><body package="XML">baseURI: url	baseURI := url</body><body package="XML">minimalCharacterMapping	textMap := Dictionary new		at: $&lt; put: '&amp;lt;';		at: $&gt; put: '&amp;gt;';		at: $" put: '&amp;quot;';		at: $&amp; put: '&amp;amp;';		at: (Character value: 9) put: '&amp;#9;';		at: (Character value: 10) put: '&amp;#10;';		at: (Character value: 13) put: '&amp;#13;';		yourself.	attrMap := Dictionary new		at: $&lt; put: '&amp;lt;';		at: $&gt; put: '&amp;gt;';		at: $&amp; put: '&amp;amp;';		at: $" put: '&amp;quot;';		at: (Character value: 9) put: '&amp;#9;';		at: (Character value: 10) put: '&amp;#10;';		at: (Character value: 13) put: '&amp;#13;';		yourself.</body></methods><methods><class-id>XML.PluggableEntityResolver</class-id> <category>entity resolver</category><body package="XML">resolveEntity: publicID systemID: systemID	| resolved stream |	resolved := block cull: publicID cull: systemID.	resolved = ResolveDefaultResource ifTrue: [^nil].	stream := resolved = ResolveEmptyResource ifTrue: ['' readStream] ifFalse: [resolved].	^XML.InputSource		uri: systemID		encoding: nil		stream: stream</body></methods><methods><class-id>XML.PluggableEntityResolver</class-id> <category>accessing</category><body package="XML">block	^block</body><body package="XML">block: anObject	block := anObject</body></methods><methods><class-id>XML.PluggableEntityResolver class</class-id> <category>instance creation</category><body package="XML">withBlock: block	^self new		block: block;		yourself</body></methods><methods><class-id>XML.NOTATION_AT</class-id> <category>accessing</category><body package="XML">typeNames	^typeNames</body><body package="XML">typeNames: aList	typeNames := aList</body></methods><methods><class-id>XML.NOTATION_AT</class-id> <category>validating</category><body package="XML">completeValidationAgainst: aParser from: anAttributeDef	typeNames do: [:nm |		aParser dtd notationAt: nm ifAbsent:			[aParser invalid: ((#attributeUsesUndefinedNotation &lt;&lt; #xml &gt;&gt; 'Undeclared Notation "&lt;1s&gt;" used by attribute type "&lt;2s&gt;"')							expandMacrosWith: nm							with: anAttributeDef tag asString)]]</body><body package="XML">validateValueOf: anAttribute for: aParser	| v |	super validateValueOf: anAttribute for: aParser.	v := anAttribute value.	(typeNames includes: v)		ifFalse: [aParser invalid: ((#invalidNotationAttribute &lt;&lt; #xml &gt;&gt; 'A NOTATION attribute (&lt;1s&gt;="&lt;2s&gt;") should have had a value from &lt;3p&gt;.')					expandMacrosWith: anAttribute tag asString					with: v					with: typeNames asArray)].</body></methods><methods><class-id>XML.NOTATION_AT class</class-id> <category>instance creation</category><body package="XML">typeNames: list	^self new typeNames: list</body></methods><methods><class-id>XML.Notation</class-id> <category>initialize</category><body package="XML">name: aName identifiers: anArray	name := aName.	anArray size = 2		ifTrue:			[systemID := anArray at: 2.			publicID := anArray at: 1]		ifFalse: [self error: (#invalidSystemIDs &lt;&lt; #xml &gt;&gt; 'Invalid PUBLIC / SYSTEM identifiers')]</body></methods><methods><class-id>XML.Notation</class-id> <category>accessing</category><body package="XML">name	^name</body><body package="XML">publicID	^publicID</body><body package="XML">systemID	^systemID</body></methods><methods><class-id>XML.Locator</class-id> <category>processing</category><body package="XML">column	^self externalWrapper column</body><body package="XML">line	^self externalWrapper line</body><body package="XML">publicID	| ent |	ent := self externalWrapper entity.	^ent == nil		ifTrue: [nil]		ifFalse: [ent publicID]</body><body package="XML">systemID	| ent |	ent := self externalWrapper entity.	^ent == nil		ifTrue: [nil]		ifFalse: [ent systemID]</body></methods><methods><class-id>XML.Locator</class-id> <category>accessing</category><body package="XML">parser: aParser	parser := aParser</body></methods><methods><class-id>XML.Locator</class-id> <category>private</category><body package="XML">externalWrapper	^parser fullSourceStack reverse		detect: [:s | s isInternal not]		ifNone: [parser fullSourceStack first]</body></methods><methods><class-id>XML.PI</class-id> <category>initialize</category><body package="XML">name: nm text: aString	name := nm.	text := aString</body></methods><methods><class-id>XML.PI</class-id> <category>accessing</category><body package="XML">name	^name</body><body package="XML">text	^text</body></methods><methods><class-id>XML.PI</class-id> <category>printing</category><body package="XML">printHTMLOn: aStream	aStream nextPutAll: '&lt;?', name, ' ', text, '?&gt;'</body><body package="XML">printOn: aStream depth: indent	aStream nextPutAll: '&lt;?', name, ' ', text, '?&gt;'</body></methods><methods><class-id>XML.PI</class-id> <category>testing</category><body package="XML">isLike: aNode	^self class == aNode class		and: [self name isLike: aNode name]</body><body package="XML">isProcessingInstruction	^true</body></methods><methods><class-id>XML.PI</class-id> <category>enumerating</category><body package="XML">saxDo: aDriver	aDriver processingInstruction: name data: text</body></methods><methods><class-id>XML.PI class</class-id> <category>instance creation</category><body package="XML">name: nm text: aString	^self new name: nm text: aString</body></methods><methods><class-id>XML.XMLParser</class-id> <category>initialize</category><body package="XML">builder: anXMLNodeBuilder	self saxDriver: (SAXBuilderDriver new builder: anXMLNodeBuilder)</body><body package="XML">initialize	validating := true.	self saxDriver: DOM_SAXDriver new.	flags := 0.	self processNamespaces: true.	eol := Character cr.	buffer := (String new: 32) writeStream.	nameBuffer := (String new: 16) writeStream.</body><body package="XML">lineEndLF	eol := Character lf</body><body package="XML">lineEndNormal	eol := Character cr</body><body package="XML">on: dataSource	"The dataSource may be a URI, a Filename (or a String	which will be treated as a Filename), or an InputSource."	sourceStack := self wrapDataSource: dataSource.	elementStack := OrderedCollection new.	dtd := DocumentType new.	unresolvedIDREFs := Set new.	definedIDs := Set new.		"Clear those flags that keep track of the		state of the parse, but retain those that		relate to options."	flags := flags bitAnd: 16rFFFF bitInvert</body><body package="XML">saxDriver: aSAXDriver	sax := aSAXDriver.	sax setDocumentLocator: (Locator new parser: self)</body><body package="XML">wrapDataSource: aDataSource	"The creation of FileURLs takes time:  47 seconds for the whole base as against 24 seconds if we do not create them.  We therefore introduce a performance optimization:  supply the InputSource with a string, dropping the asFilename asURI call here in favour of creating lazily as needed.  It appears that, at least for source-gathering purposes, the uri of the InputSource created here is never used, except for nil checks:  a similar optimisation has been in a StoreGlorp override since 2 February 2006 but only met the non-nil check case and never expanded to a URI, which suggests the URI may not be needed."	| resource |	resource := (aDataSource isKindOf: Stream)		ifTrue:			[[aDataSource lineEndTransparent] on: Error do: [:ex | ].			aDataSource isExternalStream				ifTrue: [InputSource						uri: aDataSource name "asFilename asURI"						encoding: nil						stream: aDataSource]				ifFalse: [InputSource						uri: nil						encoding: nil						stream: aDataSource]]		ifFalse: [(aDataSource isKindOf: URI)			ifTrue: [aDataSource resource]			ifFalse: [aDataSource asFilename asURI resource]].	^(StreamWrapper		resource: resource		entity: nil		from: self)		isInternal: false</body></methods><methods><class-id>XML.XMLParser</class-id> <category>accessing</category><body package="XML">document	^sax document</body><body package="XML">dtd	^dtd</body><body package="XML">eol	^eol</body><body package="XML">saxDriver	^sax</body><body package="XML">sourceWrapper	^sourceStack "last"</body><body package="XML">validate: aBoolean	validating := aBoolean</body></methods><methods><class-id>XML.XMLParser</class-id> <category>testing</category><body package="XML">hasExpanded: anEntity	| s |	s := sourceStack.	[s == nil] whileFalse:		[s entity == anEntity			ifTrue: [self malformed: ((#recursiveEntityDefinition &lt;&lt; #xml &gt;&gt; 'The &lt;1s&gt; entity "&lt;2s&gt;" invokes itself recursively')						expandMacrosWith: anEntity entityType						with: anEntity name)].		s := s nextLink].	^false</body><body package="XML">isValidating	^validating</body><body package="XML">shouldTestWFCEntityDeclared	^self hasDTD not		or: [(self hasExternalDTD not			and: [self usesParameterEntities not])		or: [self isDeclaredStandalone]]</body></methods><methods><class-id>XML.XMLParser</class-id> <category>api</category><body package="XML">comment	| str1 |	str1 := currentSource.	^(self skipIf: '&lt;!--')		ifTrue:			[self completeComment: str1.			true]		ifFalse: [false]</body><body package="XML">docTypeDecl	| nm id |	^(self skipIf: '&lt;!DOCTYPE')		ifTrue:			[self forceSpace.			self noteDTD.			nm := self getQualifiedName.			self dtd declaredRoot: nm.			self skipSpace.			(id := self externalID: #docType) notNil ifTrue: [self skipSpace].			self sourceWrapper usedAsExternal: false.			(self skipIf: '[')				ifTrue: [[self skipIf: ']']					whileFalse: [self dtdEntry]].			self skipSpace.			hereChar = $&gt; ifFalse: [self expected: '&gt;'].			self sourceWrapper usedAsExternal: nil.			id == nil ifFalse: [self dtdFile: id].			self mustFind: '&gt;'.			self isValidating ifTrue: [dtd completeValidationAgainst: self].			true]		ifFalse: [false]</body><body package="XML">element	"Deprecated, see #parseElement:"	^[sax startDocumentFragment.	self getElement.	sax endDocumentFragment.	sax document == nil		ifTrue: [nil]		ifFalse: [sax document elements first]]		ifCurtailed: [self closeAllFiles]</body><body package="XML">latestURI	| s |	s := self fullSourceStack reverse detect: [:i | i hasURI] ifNone: [nil].	^s == nil		ifTrue: [(Filename defaultDirectory construct: 'foo') asURI]		ifFalse: [s uri]</body><body package="XML">misc	^self atEnd not and: [self skipSpace or: [self comment or: [self pi]]]</body><body package="XML">pi	| str1 |	str1 := currentSource.	^(self skipIf: '&lt;?')		ifTrue:			[self completePI: str1.			true]		ifFalse: [false]</body><body package="XML">prolog	self sourceWrapper xmlDecl.        "This is optional."	self getNextChar.	[self misc] whileTrue.	self docTypeDecl		ifTrue: [[self misc] whileTrue].</body><body package="XML">pushSource: aStreamWrapper	aStreamWrapper nextLink: sourceStack.	sourceStack := aStreamWrapper</body><body package="XML">scanDocument	^[sax startDocument.	self prolog.	self atEnd ifTrue: [self malformed: #expectedContent &lt;&lt; #xml &gt;&gt; 'Some XML content was expected'].	self getElement.	[self misc] whileTrue.	self atEnd ifFalse: [self malformed: (#expectedCommentOrPI &lt;&lt; #xml &gt;&gt; 'A comment or processing instruction, or the end of the document, was expected')].	self checkUnresolvedIDREFs.	sax endDocument.	self document]		ensure: [self closeAllFiles]</body><body package="XML">xmlVersion: aString	"Do nothing for now"</body></methods><methods><class-id>XML.XMLParser</class-id> <category>DTD processing</category><body package="XML">conditionalSect	| nm oldIgnore |	hereChar = $&lt; ifFalse: [^false].	self inInternalSubset ifTrue: [^false].	^(self skipIf: '&lt;![')		ifTrue:			[self skipSpaceInDTD.			nm := self getSimpleName.			(#('INCLUDE' 'IGNORE') includes: nm)				ifFalse: [self malformed: (#expectedIncludeOrIgnore &lt;&lt; #xml &gt;&gt; 'INCLUDE or IGNORE was expected')].			oldIgnore := self ignore.			self ignore: (oldIgnore or: [nm = 'IGNORE']).			self skipSpaceInDTD.			self mustFind: '['.			self ignore				ifTrue: [self parseIgnore]				ifFalse: [[self skipIf: ']]&gt;']						whileFalse: [self dtdEntry]].			self ignore: oldIgnore.			true]		ifFalse: [false]</body><body package="XML">dtdEntry	((self PERef: #dtdEntry) or:			[self markUpDecl or:			[self conditionalSect or:			[self skipSpace]]])		ifFalse: [self malformed: (#expectedMarkupDeclOrPI &lt;&lt; #xml &gt;&gt; 'A markup declaration or PE reference was expected')]</body><body package="XML">dtdFile: uriList	| str input |	self noteExternalDTD.	currentSource skip: -1.		"So we don't lose hereChar."	input := sax		resolveEntity: (uriList at: 1)		systemID: (uriList at: 2).	input == nil ifTrue: [input := (uriList at: 2) asURI resource].	self pushSource: (str := StreamWrapper						resource: input						entity: (GeneralEntity new								name: (#dtd &lt;&lt; #xml &gt;&gt; '[dtd]') asString;								externalFrom: uriList)						from: self).	str usedAsExternal: true.	str textDecl.	self getNextChar.	[self fullSourceStack includes: str]		whileTrue: [self dtdEntry].</body><body package="XML">externalID: usage	"Usage may be #docType, #entity, or #notation.	DocType is treated specially, since PE references are not allowed.	Notation is treated specially since the system identifier of the		PUBLIC form is optional."	| lit2 lit1 forceSpace skipSpace |	forceSpace := [usage == #docType					ifTrue: [self forceSpace]					ifFalse: [self forceSpaceInDTD]].	skipSpace := [usage == #docType					ifTrue: [self skipSpace]					ifFalse: [self skipSpaceInDTD]].	^(self skipIf: 'SYSTEM')		ifTrue:			[forceSpace value.			lit2 := self systemLiteral.			Array with: nil with: lit2]		ifFalse: [(self skipIf: 'PUBLIC')			ifTrue:				[forceSpace value.				lit1 := self pubIdLiteral.				usage == #notation					ifTrue:						[(skipSpace value and:								[hereChar = $' or: [hereChar = $"]])							ifTrue: [lit2 := self systemLiteral]							ifFalse: [lit2 := nil]]					ifFalse:						[forceSpace value.						lit2 := self systemLiteral].				Array with: lit1 with: lit2]			ifFalse:				[nil]]</body><body package="XML">inInternalSubset	self fullSourceStack reverseDo:		[:str |		str usedAsExternal == nil			ifFalse: [^str usedAsExternal not]].	self error: (#notProcessingDTD &lt;&lt; #xml &gt;&gt; 'Not currently processing the DTD')</body><body package="XML">markUpDecl	^self elementDecl		or: [self attListDecl		or: [self entityDecl		or: [self notationDecl		or: [self pi		or: [self comment]]]]]</body><body package="XML">notationDecl	| nm id str |	str := currentSource.	^(self skipIf: '&lt;!NOTATION')		ifTrue:			[self forceSpaceInDTD.			nm := self getSimpleName.			self forceSpaceInDTD.			id := self externalID: #notation.			self ignore ifFalse:				[id == nil					ifTrue: [self malformed: (#invalidSystemIDs								&lt;&lt; #xml &gt;&gt; 'Invalid PUBLIC / SYSTEM identifiers')].				dtd notationAt: nm put: (Notation new name: nm identifiers: id) from: self.				sax notationDecl: nm					publicID: (id at: 1)					systemID: (id at: 2)].			self skipSpaceInDTD.			self mustFind: '&gt;'.			str == lastSource				ifFalse: [self invalid: (#declarationsNestingInPEntity &lt;&lt; #xml &gt;&gt; 'Improper nesting of declarations within a parameter entity')].			true]		ifFalse: [false]</body><body package="XML">parseIgnore	| entryCount openIndex closeIndex |	entryCount := 1.	openIndex := closeIndex := 1.	[entryCount = 0]		whileFalse:			[hereChar == nil ifTrue: [self expected: ']]&gt;'].			hereChar = ('&lt;![' at: openIndex)				ifTrue:					[openIndex := openIndex+1.					openIndex = 4						ifTrue:							[entryCount := entryCount+1.							openIndex := 1]]				ifFalse: [openIndex := 1].			hereChar = (']]&gt;' at: closeIndex)				ifTrue:					[closeIndex := closeIndex+1.					closeIndex = 4						ifTrue:							[entryCount := entryCount-1.							closeIndex := 1]]				ifFalse: [closeIndex := 1].			self getNextChar].</body><body package="XML">pubIdLiteral	| str s1 |	str := self quotedString.	str do: [:ch |		((' -''()+,./:=?;!*#@$_%' includes: ch)				or: [ch asInteger = 10				or: [ch asInteger = 13				or: [ch asInteger &lt; 127				and: [ch isLetter or: [ch isDigit]]]]])			ifFalse: [self malformed: (#invalidPublicIDChar &lt;&lt; #xml &gt;&gt; 'Invalid public id character found')]].	str replaceAll: Character tab with: Character space.	str replaceAll: Character cr with: Character space.	str replaceAll: Character lf with: Character space.	[(s1 := str copyReplaceAll: '  ' with: ' ') = str]		whileFalse: [str := s1].	(str isEmpty not and: [str first = Character space])		ifTrue: [str := str copyFrom: 2 to: str size].	(str isEmpty not and: [str last = Character space])		ifTrue: [str := str copyFrom: 1 to: str size-1].	^str</body><body package="XML">systemLiteral	| lit |	lit := self quotedString.	(lit includes: $#)		ifTrue: [self malformed: #noFragmentsInSystemIDs &lt;&lt; #xml &gt;&gt; 'Fragments in System IDs are not supported'].	^lit isEmpty		ifTrue: [lit]		ifFalse: [(self latestURI resolvePath: lit) asString]</body></methods><methods><class-id>XML.XMLParser</class-id> <category>entity processing</category><body package="XML">entityDecl	| nm def str |	str := currentSource.	^(self skipIf: '&lt;!ENTITY')		ifTrue:			[self forceSpace.			hereChar = $%				ifTrue:					[self getNextChar; forceSpaceInDTD.					nm := self getSimpleName.					self forceSpaceInDTD.					def := self peDef: nm.					self ignore ifFalse: [self dtd parameterEntityAt: nm put: def from: self]]				ifFalse:					[self skipSpaceInDTD.					nm := self getSimpleName.					self forceSpaceInDTD.					def := self entityDef: nm.					self ignore ifFalse: [self dtd generalEntityAt: nm put: def from: self]].			self skipSpaceInDTD.			self mustFind: '&gt;'.			str == lastSource				ifFalse: [self invalid: (#declarationsNestingInPEntity &lt;&lt; #xml &gt;&gt; 'Improper nesting of declarations within a parameter entity')].			true]		ifFalse: [false]</body><body package="XML">entityDef: name	| val ndata |	^(val := self entityValue) == nil		ifTrue: [(val := self externalID: #entity) == nil			ifTrue: [self malformed: (#expectedEntityValOrID &lt;&lt; #xml &gt;&gt; 'An entity value or external id was expected')]			ifFalse:				[| entity |				ndata := self nDataDecl.				entity := GeneralEntity new					name: name;					externalFrom: val;					ndata: ndata;					isDefinedExternally: self inInternalSubset not.				ndata == nil					ifFalse: [sax unparsedEntityDecl: name							publicID: entity publicID							systemID: entity systemID							notationName: ndata].				entity]]		ifFalse: [GeneralEntity new					name: name;					text: val;					isDefinedExternally: self inInternalSubset not]</body><body package="XML">entityValue	| aQuote s str1 |	aQuote := hereChar.	(aQuote = $' or: [aQuote = $"]) ifFalse: [^nil].	s := currentSource.	self getNextChar.	buffer reset.	[hereChar == nil		ifTrue: [self expected: (String with: aQuote)].	(hereChar = aQuote and: [s = currentSource])]		whileFalse:			[hereChar = $&amp;				ifTrue:					[str1 := currentSource.					(self skipIf: '&amp;#')						ifTrue: [self charEntity: buffer startedIn: str1]						ifFalse: [self getNextChar; generalEntity: buffer]]				ifFalse: [(self PERef: #data)					ifFalse:						[buffer nextPut: hereChar.						self getNextChar]]].	self getNextChar.	^buffer contents</body><body package="XML">generalEntity: str	| nm |	nm := self getSimpleName.	hereChar = $;		ifFalse: [self malformed: (#expectedSemicolon &lt;&lt; #xml &gt;&gt; 'A semicolon was expected')].	str nextPut: $&amp;; nextPutAll: nm; nextPut: $;.	self getNextChar</body><body package="XML">nDataDecl	^self skipSpaceInDTD		ifTrue: [(self skipIf: 'NDATA')			ifTrue:				[self forceSpaceInDTD.				self getSimpleName]			ifFalse: [nil]]		ifFalse: [nil]</body><body package="XML">peDef: name	| val |	^(val := self entityValue) == nil		ifTrue: [(val := self externalID: #entity) == nil			ifTrue: [self malformed: (#expectedEntityValOrID &lt;&lt; #xml &gt;&gt; 'An entity value or external id was expected')]			ifFalse:				[ParameterEntity new					name: name;					externalFrom: val]]		ifFalse: [ParameterEntity new name: name; text: val]</body><body package="XML">PERef: refType	| nm exp |	^(hereChar = $%)		ifTrue:			[refType = #dtdEntry ifTrue: [self notePEReference].			self getNextChar.			(self inInternalSubset and: [refType ~= #dtdEntry])				ifTrue: [self malformed: (#invalidPEUse &lt;&lt; #xml &gt;&gt; 'Parameter entity references cannot be used in the internal DTD, inside a declaration')].			nm := self getSimpleName.			hereChar = $; ifFalse: [self malformed: (#expectedSemicolon &lt;&lt; #xml &gt;&gt; 'A semicolon was expected')].			exp := self dtd parameterEntityAt: nm.			exp == nil				ifTrue: [self warn: ((#undefinedPEntity &lt;&lt; #xml &gt;&gt; 'The parameter entity "&lt;1s&gt;" has not been defined')							expandMacrosWith: nm)].			exp == nil				ifTrue: [self isValidating					ifTrue:						[self invalid: (#paramterEntityNotDefined &lt;&lt; #xml &gt;&gt; 'Parameter entity used but not defined').						self getNextChar]					ifFalse:						[self pushSource: (StreamWrapper								emptyWithExtraSpace: refType ~= #data								from: self).						self getNextChar]]				ifFalse:					[exp streamFor: self addSpaces: refType ~= #data].			(refType ~= #data and: [self sourceWrapper hasURI])				ifTrue: [self sourceWrapper usedAsExternal: true].			true]		ifFalse: [false]</body></methods><methods><class-id>XML.XMLParser</class-id> <category>element def processing</category><body package="XML">completeChildren: str	| div items node |	items := OrderedCollection with: self cp.	self skipSpaceInDTD.	div := nil.	[self skipIf: ')']		whileFalse:			[div == nil ifTrue:				[(',|' includes: hereChar) ifFalse: [self malformed: (#sequenceOrChoice &lt;&lt; #xml &gt;&gt; 'Either , or | was expected')].				div := hereChar].			div = hereChar ifFalse: [self expected: (String with: div)].			self getNextChar; skipSpaceInDTD.			items add: self cp.			self skipSpaceInDTD].	(self isValidating and: [lastSource ~~ str])		ifTrue: [self invalid: (#nestingParensInEntities &lt;&lt; #xml &gt;&gt; 'Parentheses must nest properly within entities')].	div == nil ifTrue: [div := $,].	div = $,		ifTrue: [node := SequencePattern on: items]		ifFalse: [node := ChoicePattern on: items].	('*+?' includes: hereChar)		ifTrue:			[node := ModifiedPattern on: node type: hereChar.			self getNextChar].	^node</body><body package="XML">completeMixedContent: str	"we already have the #PCDATA finished."	| names |	self skipSpaceInDTD.	names := OrderedCollection new.	[hereChar = $)]		whileFalse:			[self mustFind: '|'.			self skipSpaceInDTD.			names add: (NamePattern named: self getQualifiedName).			self skipSpaceInDTD].	(self isValidating and: [currentSource ~~ str])		ifTrue: [self invalid: (#nestingParensInEntities &lt;&lt; #xml &gt;&gt; 'Parentheses must nest properly within entities')].	names size = 0		ifTrue: [self mustFind: ')'; skipIf: '*']		ifFalse: [self mustFind: ')*'].	1 to: names size do: [:i |		i+1 to: names size do: [:j |			((names at: i) name asString = (names at: j) name asString)				ifTrue: [self invalid: (#elementListedTwice &lt;&lt; #xml &gt;&gt; 'Duplicate element names in a mixed content specification.')].			((names at: i) name isLike: (names at: j) name)				ifTrue: [self invalid: (#elementListedTwice &lt;&lt; #xml &gt;&gt; 'Duplicate element names in a mixed content specification.')].			]].	^MixedPattern on: names</body><body package="XML">contentsSpec	| str |	^(self skipIf: 'ANY')		ifTrue: [AnyPattern new]		ifFalse: [(self skipIf: 'EMPTY')			ifTrue: [EmptyPattern new]			ifFalse:				[str := currentSource.				self mustFind: '('.				self skipSpaceInDTD.				(self skipIf: '#PCDATA')					ifTrue: [self completeMixedContent: str]					ifFalse: [self completeChildren: str]]]</body><body package="XML">cp	| node str |	str := currentSource.	^(self skipIf: '(')		ifTrue: [self skipSpaceInDTD; completeChildren: str]		ifFalse:			[node := NamePattern named: self getQualifiedName.			('*+?' includes: hereChar)				ifTrue:					[node := ModifiedPattern on: node type: hereChar.					self getNextChar].			node]</body><body package="XML">elementDecl	| nm cSpec str |	str := currentSource.	^(self skipIf: '&lt;!ELEMENT')		ifTrue:			[self forceSpaceInDTD.			nm := self getQualifiedName.			self forceSpaceInDTD.			cSpec := self contentsSpec normalizeFor: self.			cSpec isExternal: self inInternalSubset not.			self ignore ifFalse: [self dtd elementFor: nm put: cSpec from: self].			self skipSpaceInDTD.			self mustFind: '&gt;'.			str == lastSource				ifFalse: [self invalid: (#declarationsNestingInPEntity &lt;&lt; #xml &gt;&gt; 'Improper nesting of declarations within a parameter entity')].			true]		ifFalse: [false]</body></methods><methods><class-id>XML.XMLParser</class-id> <category>element processing</category><body package="XML">charEntity: data startedIn: str1	| base digit n d |	hereChar = $x		ifTrue:			[base := 16.			digit := (#expectedHexDigit &lt;&lt; #xml &gt;&gt; 'Expected to find a hex digit').			self getNextChar]		ifFalse:			[base := 10.			digit := (#expectedDigit &lt;&lt; #xml &gt;&gt; 'Expected to find a digit')].	n := 0.	[hereChar = $;]		whileFalse:			[d := hereChar digitValue.			(d &gt;= 0 and: [d &lt; base]) ifFalse: [self malformed: digit].			n := n * base + d.			self getNextChar].	str1 = currentSource		ifFalse: [self malformed: (#nestingCharacterEntitiesInEntities &lt;&lt; #xml &gt;&gt; 'Character entities must nest properly inside other entities')].	"Originally we tested ch to make sure it was less than 16r110000,	but now CharacterClasses' implementation of #at: answers 0 for	large values of ch. If primitive failure code can not be trusted to do	this, then the bounds check would have to be added back."	(CharacterClasses at: n+1) = 0		ifTrue: [sax fatalError: (BadCharacterSignal new messageText:((#illegalUnicodeCharacter &lt;&lt; #xml &gt;&gt; 'A character with Unicode value &lt;1p&gt; is not legal') expandMacrosWith: n))].	data nextPut: (Character value: n).	self getNextChar</body><body package="XML">closeTag: tag	| nm |	nm := self getQualifiedName.	nm := self correctTag: nm.	self skipSpace.	self mustFind: '&gt;'.	nm = tag		ifFalse: [self malformed: ((#expectedCloseTag &lt;&lt; #xml &gt;&gt; 'The close tag for &lt;1s&gt; was not found') expandMacrosWith: tag asString)].	sax endElement: nm namespace localName: nm type qName: nm asString.	elementStack last definesNamespaces		ifTrue: [elementStack last namespaces			keysDo: [:qualifier |				sax endPrefixMapping: qualifier]].</body><body package="XML">completeCDATA: str1	| str data size textType |	buffer reset.	[str := self upToAll: ']&gt;'.	str last = $]]		whileFalse:			[buffer nextPutAll: str; nextPutAll: ']&gt;'].	lastSource = str1		ifFalse: [self malformed: (#CDATAnestingInEntities &lt;&lt; #xml &gt;&gt; 'CDATA sections must nest properly in entities')].	buffer nextPutAll: (str copyFrom: 1 to: str size-1).	data := buffer collection.      "Not necessarily portable, but faster than #contents"	"If CDATA that contains only whiteSpace should not	be allowed in an element that has an element-only	content model, change the 'testBlanks:' parameter to	false."	size := buffer position.	textType := self		validateText: data		from: 1		to: size		testBlanks: false.	sax startCDATA.	textType == #whitespace		ifTrue: [sax ignorableWhitespace: data from: 1 to: size]		ifFalse: [sax characters: data from: 1 to: size].	sax endCDATA</body><body package="XML">completeComment: str1	| str comment size index |	buffer reset.	[str := self upToAll: '-&gt;'.	str last = $-]		whileFalse:			[buffer nextPutAll: str; nextPutAll: '-&gt;'].	buffer nextPutAll: (str copyFrom: 1 to: str size-1).	comment := buffer collection.	size := buffer position.	index := comment findString: '--' startingAt: 1.	(index = 0 or: [index &gt;= size])		ifFalse: [self malformed: (#invalidDoubledHyphens &lt;&lt; #xml &gt;&gt; 'Doubled hyphens in comments are not permitted')].	(size &gt; 0 and: [(comment at: size) = $-])		ifTrue: [self malformed: (#commentEndsWithHyphen &lt;&lt; #xml &gt;&gt; 'A hyphen is not permitted as the last character in a comment')].	lastSource = str1		ifFalse: [self malformed: (#nestingCommentsInEntities &lt;&lt; #xml &gt;&gt; 'Comments must nest properly in entities')].	self ignore ifFalse:		[sax comment: comment from: 1 to: size]</body><body package="XML">completePI: str1	| nm pi |	nm := self getSimpleName.	nm = 'xml' ifTrue: [self malformed: (#misplacedXmlDecl &lt;&lt; #xml &gt;&gt; 'An "xml" declaration is not permitted, except at the beginning of the file')].	nm asLowercase = 'xml' ifTrue: [self malformed: (#xmlInName &lt;&lt; #xml &gt;&gt; '''xml'' is not permitted as the target of a processing instruction')].	self skipSpace		ifTrue:			[pi := self upToAll: '?&gt;']		ifFalse:			[pi := ''.			self mustFind: '?&gt;'].	lastSource = str1		ifFalse: [self malformed: (#nestingPIsInEntities &lt;&lt; #xml &gt;&gt; 'Pprogramming instructions must nest properly in entities')].	self ignore ifFalse: [sax processingInstruction: nm data: pi].</body><body package="XML">elementAtPosition: startPosition	| attributes nm str1 |	str1 := currentSource.	self mustFind: '&lt;'.	nm := self getQualifiedName.	self pushNewTag: nm.	latestID := nil.	attributes := self processAttributes: nm.	nm := self correctTag: nm.	elementStack last definesNamespaces		ifTrue: [elementStack last namespaces			keysAndValuesDo: [:qualifier :uri |				sax startPrefixMapping: qualifier uri: uri]].	sax startElement: nm namespace		localName: nm type		qName: nm asString		attributes: (attributes == nil ifTrue: [#()] ifFalse: [attributes]).	sax sourcePosition: startPosition inStream: str1.	latestID notNil ifTrue: [sax idOfElement: latestID].	(self skipIf: '/&gt;')		ifTrue: 			[str1 = lastSource ifFalse: [self expected: (#elementNestingInEntities &lt;&lt; #xml &gt;&gt; 'Elements must nest properly within entities')].			sax endElement: nm namespace				localName: nm type				qName: nm asString]		ifFalse: [(self skipIf: '&gt;')			ifTrue: 				[str1 = lastSource ifFalse: [self expected: (#elementNestingInEntities &lt;&lt; #xml &gt;&gt; 'Elements must nest properly within entities')].				self elementContent: nm					openedIn: str1]			ifFalse: [self expected: (#expectedEndOfTag &lt;&lt; #xml &gt;&gt; 'end of start tag')]].	self popTag</body><body package="XML">elementContent: tag openedIn: str	| data str1 braceCount size textType |	braceCount := 0.	buffer reset.	[hereChar == nil		ifTrue: [self malformed: ((#expectedEndTag &lt;&lt; #xml &gt;&gt; 'The end tag for %&lt;&lt;1s&gt;&gt; was expected') expandMacrosWith: tag)].	hereChar == $&lt;		ifTrue:			[braceCount := 0.			buffer position &gt; 0				ifTrue:					[data := buffer collection.	"Not necessarily portable, but faster than #contents"					size := buffer position.					textType := self						validateText: data						from: 1						to: size						testBlanks: true.					textType == #whitespace						ifTrue:							[(self isValidating and: [self isDeclaredStandalone and: [elementStack last isDefinedExternal]])								ifTrue: [self invalid: (#NotStandalone &lt;&lt; #xml &gt;&gt; 'This document is not standalone')].							sax ignorableWhitespace: data from: 1 to: size]						ifFalse: [sax characters: data from: 1 to: size]].			str1 := currentSource.			(self skipIf: '&lt;/')				ifTrue:					[self closeTag: tag.					str == lastSource						ifFalse: [self malformed: (#elementNestingInEntities &lt;&lt; #xml &gt;&gt; 'Elements must nest properly within entities')].					^self]				ifFalse: [(self skipIf: '&lt;?')					ifTrue: [self completePI: str1]					ifFalse: [(self skipIf: '&lt;![CDATA[')						ifTrue: [self completeCDATA: str1]						ifFalse: [(self skipIf: '&lt;!--')							ifTrue: [self completeComment: str1]							ifFalse: [self getElement]]]].			buffer reset]		ifFalse: [hereChar == $&amp;			ifTrue:				[braceCount := 0.				str1 := currentSource.				(self skipIf: '&amp;#')					ifTrue: [self charEntity: buffer startedIn: str1]					ifFalse: [self getNextChar; generalEntityInText: buffer canBeExternal: true]]			ifFalse:				[hereChar == $]					ifTrue: [braceCount := braceCount+1]					ifFalse:						[(hereChar == $&gt; and: [braceCount &gt;= 2])							ifTrue: [self malformed: #embeddedCdataClose &lt;&lt; #xml &gt;&gt; ']]&gt; is not permitted in element content'].						braceCount := 0].				buffer nextPut: hereChar.				self getNextChar]]] repeat</body><body package="XML">generalEntityInText: str canBeExternal: external	| exp nm str1 msg |	str1 := lastSource.	nm := self getSimpleName.	hereChar = $;		ifFalse: [self malformed: (#expectedSemicolon &lt;&lt; #xml &gt;&gt; 'A semicolon was expected')].	currentSource = str1		ifFalse: [self malformed: (#nestingEntityRefsInEntities &lt;&lt; #xml &gt;&gt; 'Entity references must nest properly within other entity references')].	exp := self dtd generalEntityAt: nm.	exp == nil		ifTrue:			[msg := (#undefinedGeneralEntity1 &lt;&lt; #xml &gt;&gt; 'The general entity "&lt;1s&gt;" has not been defined')							expandMacrosWith: nm.			self isValidating				ifTrue: [self invalid: msg]				ifFalse: [self warn: msg].			self shouldTestWFCEntityDeclared				ifTrue: [self malformed: (#undefinedGeneralEntity2 &lt;&lt; #xml &gt;&gt; 'General entity used but not defined')].			"str nextPut: $&amp;; nextPutAll: nm; nextPut: $;."			self getNextChar]		ifFalse:			[(external or: [exp isExternal not])				ifFalse: [self malformed: (#invalidExternalEntityUse &lt;&lt; #xml &gt;&gt; 'External entity references are not permitted in attribute values')].			(self isValidating and: [self isDeclaredStandalone					and: [exp isDefinedExternally]])				ifTrue: [self invalid: #NotStandalone &lt;&lt; #xml &gt;&gt; 'This document is not standalone'].			exp isParsed				ifFalse: [self malformed: (#invalidUnparsedEntityUse &lt;&lt; #xml &gt;&gt; 'References to unparsed entities other than in an attribute of type ENTITY are not permitted')].			exp streamFor: self].</body><body package="XML">getElement	| str1 startPosition |	str1 := currentSource.	startPosition := str1 stream position - hereCharNumBytes.	^self elementAtPosition: startPosition</body><body package="XML">isValidTag: aTag	^true</body><body package="XML">popTag	self isValidating		ifTrue:			[elementStack last canTerminate				ifFalse: [self invalid: ((#expectedOneOfList &lt;&lt; #xml &gt;&gt; 'One of &lt;1s&gt; was expected, but none was found') expandMacrosWith: elementStack last followSetDescription)]].	elementStack removeLast.</body><body package="XML">pushNewTag: nm	| elm p types |	self isValidating		ifTrue:			[elementStack isEmpty				ifTrue: [(self hasDTD						and: [self dtd declaredRoot asString = nm asString])					ifFalse: [self invalid: (#DocumentTypeMismatch &lt;&lt; #xml &gt;&gt; 'Document type must match type of the root element') asString]]				ifFalse:					[elm := elementStack last.					types := elm validateTag: nm.					types == nil						ifTrue: [self invalid:							((#notPermittedHere &lt;&lt; #xml &gt;&gt; '"&lt;1s&gt;" is not permitted at this point in the "&lt;2s&gt;" node')								expandMacrosWith: nm asString								with: elm tag asString)].					elm types: types].			elementStack addLast: (ElementContext new tag: nm).			p := self dtd elementFor: nm from: self.			p == nil				ifTrue: [self invalid: ((#useOfUndeclaredTag1 &lt;&lt; #xml &gt;&gt; 'Using a tag (&lt;1s&gt;) without declaring it is not permitted') expandMacrosWith: nm asString)].			elementStack last type: p]		ifFalse:			[elementStack addLast: (ElementContext new tag: nm)]</body><body package="XML">validateText: data from: start to: stop testBlanks: testBlanks	| elm textType types |	textType := #characters.	stop &lt; start ifTrue: [^textType].	self isValidating		ifTrue:			[elm := elementStack last.			types := elm				validateText: data				from: start				to: stop				testBlanks: testBlanks.			types == nil				ifTrue: [self invalid: #textNotPermittedHere &lt;&lt; #xml &gt;&gt; 'The DTD does not permit text here']				ifFalse:					[(types contains: [:n | n couldBeText]) ifFalse: [textType := #whitespace].					elm types: types]].	^textType</body></methods><methods><class-id>XML.XMLParser</class-id> <category>attribute def processing</category><body package="XML">attListDecl	| nm str1 attr |	str1 := currentSource.	^(self skipIf: '&lt;!ATTLIST')		ifTrue:			[self forceSpaceInDTD.			nm := self getQualifiedName.			[self skipSpaceInDTD.			self skipIf: '&gt;']				whileFalse:					[self skipSpaceInDTD.					attr := AttributeDef new name: self getQualifiedName.					self forceSpaceInDTD.					attr type: self attType.					attr type isExternal: self inInternalSubset not.					self forceSpaceInDTD.					attr default: (self defaultDeclType: attr type).					self isValidating ifTrue: [attr selfValidateFor: self].					self checkReservedAttributes: attr name asString						type: attr type						value: attr default.					self ignore ifFalse: [self dtd attributeFor: nm subKey: attr name put: attr from: self]].			str1 == lastSource				ifFalse: [self invalid: (#declarationsNestingInPEntity &lt;&lt; #xml &gt;&gt; 'Improper nesting of declarations within a parameter entity')].			true]		ifFalse: [false]</body><body package="XML">attType	| nm all type |	^hereChar = $(		ifTrue: [self enumeration]		ifFalse:			[nm := self getSimpleName.			all := #('NOTATION' 'CDATA' 'ID'						'IDREF' 'IDREFS'						'ENTITY' 'ENTITIES'						'NMTOKEN' 'NMTOKENS').			(all includes: nm)				ifFalse: [self malformed: ((#expectedOneOfList &lt;&lt; #xml &gt;&gt; 'One of &lt;1s&gt; was expected, but none was found') expandMacrosWith: all storeString)].			type := #(#{NOTATION_AT} #{CDATA_AT} #{ID_AT}						#{IDREF_AT} #{IDREFS_AT}						#{ENTITY_AT} #{ENTITIES_AT}						#{NMTOKEN_AT} #{NMTOKENS_AT})					at: (all indexOf: nm).			nm = 'NOTATION'				ifTrue: [self completeNotationType]				ifFalse: [type value new]].</body><body package="XML">completeNotationType	| nm |	self forceSpaceInDTD.	self mustFind: '('.	self skipSpaceInDTD.	nm := OrderedCollection with: self getSimpleName.	self skipSpaceInDTD.	[self skipIf: '|']		whileTrue:			[self skipSpaceInDTD.			nm add: self getSimpleName.			self skipSpaceInDTD].	self mustFind: ')'.	^NOTATION_AT typeNames: nm</body><body package="XML">defaultDecl	| fixed default |	^(self skipIf: '#REQUIRED')		ifTrue: [#required]		ifFalse: [(self skipIf: '#IMPLIED')			ifTrue: [#implied]			ifFalse:				[fixed := self skipIf: '#FIXED'.				fixed ifTrue:					[self forceSpaceInDTD].				default := self attValue.				default == nil ifTrue: [self malformed: (#expectedQuotedAttributeDefault &lt;&lt; #xml &gt;&gt; 'A quoted value was expected for the attribute''s default')].				fixed -&gt; default]]</body><body package="XML">defaultDeclType: type	| fixed default |	^(self skipIf: '#REQUIRED')		ifTrue: [#required]		ifFalse: [(self skipIf: '#IMPLIED')			ifTrue: [#implied]			ifFalse:				[fixed := self skipIf: '#FIXED'.				fixed ifTrue:					[self forceSpaceInDTD].				default := self attValue: type inDTD: true.				default == nil ifTrue: [self malformed: (#expectedQuotedAttributeDefault &lt;&lt; #xml &gt;&gt; 'A quoted value was expected for the attribute''s default')].				fixed -&gt; default]]</body><body package="XML">enumeration	| nm |	self mustFind: '('.	self skipSpaceInDTD.	nm := OrderedCollection with: self nmToken.	self skipSpaceInDTD.	[self skipIf: '|']		whileTrue:			[self skipSpaceInDTD.			nm add: self nmToken.			self skipSpaceInDTD].	self mustFind: ')'.	^Enumeration_AT withAll: nm</body></methods><methods><class-id>XML.XMLParser</class-id> <category>attribute processing</category><body package="XML">attribute	| nm value |	nm := self getQualifiedName.	self skipSpace.	self mustFind: '='.	self skipSpace.	value := self attValue.	value == nil ifTrue: [self malformed: (#expectedQuotedAttributeValue &lt;&lt; #xml &gt;&gt; 'A quoted value for the attribute was expected, but not found')].	self checkReservedAttributes: nm asString		type: nil		value: value.	^Attribute name: nm value: value</body><body package="XML">attributeFor: elementTag	| nm value |	nm := self getQualifiedName.	self skipSpace.	self mustFind: '='.	self skipSpace.	value := self attValue: (self dtd attributeTypeFor: elementTag subKey: nm from: self)			inDTD: false.	value == nil ifTrue: [self malformed: (#expectedQuotedAttributeValue &lt;&lt; #xml &gt;&gt; 'A quoted value for the attribute was expected, but not found')].	self checkReservedAttributes: nm asString		type: nil		value: value.	^Attribute name: nm value: value</body><body package="XML">attValue	| aQuote s str1 |	aQuote := hereChar.	(aQuote = $' or: [aQuote = $"]) ifFalse: [^nil].	buffer reset.	s := currentSource.	self getNextChar.	[(hereChar = aQuote and: [s = currentSource])]		whileFalse:			[hereChar == nil				ifTrue: [self malformed: #attrCloseQuoteMissing &lt;&lt; #xml &gt;&gt; 'No close quote found for attribute value'].			hereChar = $&lt;				ifTrue: [self malformed: (#lessThanNotPermittedInAttributes &lt;&lt; #xml &gt;&gt; '&lt; not permitted in attribute values; use &amp;lt;')].			hereChar = $&amp;				ifTrue:					[str1 := currentSource.					(self skipIf: '&amp;#')						ifTrue: [self charEntity: buffer startedIn: str1]						ifFalse: [self getNextChar; generalEntityInText: buffer canBeExternal: false]]				ifFalse:					[hereChar asInteger &lt; 16r20						ifTrue: [buffer space]						ifFalse: [buffer nextPut: hereChar].					self getNextChar]].	self getNextChar.	^buffer contents</body><body package="XML">attValue: attType inDTD: isInDTD	| aQuote s str1 sawSpace needsSpace isCDATA count |	isCDATA := attType class == CDATA_AT.	aQuote := hereChar.	(aQuote = $' or: [aQuote = $"]) ifFalse: [^nil].	buffer reset.	s := currentSource.	self getNextChar.	count := 0.	sawSpace := true.	needsSpace := false.	[(hereChar = aQuote and: [s = currentSource])]		whileFalse:			[hereChar == nil				ifTrue: [self malformed: #attrCloseQuoteMissing &lt;&lt; #xml &gt;&gt; 'No close quote found for attribute value'].			hereChar = $&lt;				ifTrue: [self malformed: (#lessThanNotPermittedInAttributes &lt;&lt; #xml &gt;&gt; '&lt; not permitted in attribute values; use &amp;lt;')].			hereChar = $&amp;				ifTrue:					[str1 := currentSource.					(self skipIf: '&amp;#')						ifTrue:							[needsSpace ifTrue: [buffer space].							needsSpace := sawSpace := false.							count := count+1.							self charEntity: buffer startedIn: str1]						ifFalse: [self getNextChar; generalEntityInText: buffer canBeExternal: false]]				ifFalse: [(isInDTD and: [self PERef: #data])					ifFalse:						[hereChar asInteger &lt;= 16r20							ifTrue: [isCDATA								ifTrue: [buffer space]								ifFalse: [sawSpace ifFalse: [sawSpace := needsSpace := true]]]							ifFalse:								[needsSpace ifTrue: [buffer space].								needsSpace := sawSpace := false.								buffer nextPut: hereChar].						count := count+1.						self getNextChar]]].	(self isValidating and: [self isDeclaredStandalone			and: [count ~= buffer position and: [attType isExternal]]])		ifTrue: [self invalid: #NotStandalone &lt;&lt; #xml &gt;&gt; 'This document is not standalone'].	self getNextChar.	^buffer contents</body><body package="XML">checkCountryCode: code from: value	code size &gt;= 2		ifFalse: [self illegalLanguageCode: value].	"code size = 2		ifTrue: [self checkIso3166Code: code from: value]		ifFalse: [self checkIanaSubcode: code from: value]"</body><body package="XML">checkIanaLanguageCode: code from: value	^self</body><body package="XML">checkIso639LanguageCode: code from: value	code size = 2		ifFalse: [self illegalLanguageCode: value].</body><body package="XML">checkLanguageCode: value	| vals list |	value == nil ifTrue: [^self].	value size = 0		ifTrue: [self illegalLanguageCode: value].	^self	"Don't try to validate the value any more""	value last = $-		ifTrue: [self illegalLanguageCode: value].	vals := value readStream.	list := OrderedCollection new.	[vals atEnd] whileFalse: [list add: (vals upTo: $-) asLowercase].	list do: [:subcode |		subcode size = 0			ifTrue: [self illegalLanguageCode: value].		subcode do: [:ch |			(ch between: $a and: $z)				ifFalse: [self illegalLanguageCode: value]]].	list first = 'x'		ifTrue:			[list size &gt; 1				ifFalse: [self illegalLanguageCode: value].			^self].	list first = 'i'		ifTrue:			[list size &gt; 1				ifFalse: [self illegalLanguageCode: value].			self checkIanaLanguageCode: (list at: 2) from: value.			list size &gt; 2				ifTrue: [self checkCountryCode: (list at: 3) from: value].			^self].	self checkIso639LanguageCode: (list at: 1) from: value.	list size &gt; 1		ifTrue: [self checkCountryCode: (list at: 2) from: value]."</body><body package="XML">checkReservedAttributes: nm type: type value: value	nm = 'xml:lang'		ifTrue: [self checkLanguageCode: value].	nm = 'xml:space'		ifTrue:			[(type = nil					or: [type class = Enumeration_AT					and: [(type values asSet - #('default' 'preserve') asSet) isEmpty]])				ifFalse: [self malformed: #xmlSpaceType &lt;&lt; #xml &gt;&gt; 'Malformed type definition for xml:space'].			"The value may be nil if we're checking the ATTLIST definition"			(value = 'default' or: [value = 'preserve' or: [value == nil]])				ifFalse: [self malformed: #badXmlSpace &lt;&lt; #xml &gt;&gt; 'xml:space must have a value of "preserve" or "default"']].</body><body package="XML">illegalLanguageCode: value	self malformed: (#illegalLanguageCode &lt;&lt; #xml &gt;&gt; 'Illegal value (&lt;1s&gt;) for xml:lang' expandMacrosWith: value)</body><body package="XML">isValidName: aTag	aTag size = 0 ifTrue: [^false].	(self isValidNameStart: aTag first)		ifFalse: [^false].	2 to: aTag size do: [:i |		(self isValidNameChar: (aTag at: i))			ifFalse: [^false]].	^true</body><body package="XML">isValidNmToken: aTag	aTag size = 0 ifTrue: [^false].	1 to: aTag size do: [:i |		((self isValidNameChar: (aTag at: i)) or: [(aTag at: i) = $:])			ifFalse: [^false]].	^true</body><body package="XML">processAttributes: nm	| attributes hadSpace attributeSet |	attributes := nil.	[hadSpace := self skipSpace.	self isValidNameStart: hereChar]		whileTrue:			[hadSpace ifFalse: [self malformed: (#AttributeNotPrecededByWhitespace &lt;&lt; #xml &gt;&gt; 'Attributes must be preceded by white space') asString].			attributes == nil ifTrue:				[attributes := OrderedCollection new: 5.				attributeSet := Set new: 7].			attributes addLast: (self attributeFor: nm).			attributeSet add: attributes last tag asString.			attributeSet size = attributes size				ifFalse: [self malformed: ((#attributeAppearsTwice &lt;&lt; #xml &gt;&gt; 'The attribute "&lt;1s&gt;" was used twice in this element''s tag')								expandMacrosWith: attributes last tag asString)]].	self isValidating		ifTrue: [attributes := self validateAttributes: attributes for: nm].	attributes := self resolveNamespaces: attributes.	^attributes</body><body package="XML">quotedString	| string |	hereChar = $"		ifTrue:			[string := self upTo: $".			self getNextChar.			^string].	hereChar = $'		ifTrue:			[string := self upTo: $'.			self getNextChar.			^string].	self malformed: (#expectedQuotedString &lt;&lt; #xml &gt;&gt; 'Quoted string expected but not found')</body><body package="XML">validateAttributes: attributes for: tag	| attr attributeList |	attr := self dtd attributesFor: tag.	attributeList := attributes == nil ifTrue: [#()] ifFalse: [attributes].	attributeList do: [:i |		(attr includesKey: i key asString)			ifFalse: [self invalid: ((#undefinedAttribute1 &lt;&lt; #xml &gt;&gt; 'the attribute &lt;1s&gt; was not defined in the DTD')								expandMacrosWith: i key)]].	attr do: [:adef | | a |		a := attributeList detect: [:at | at key isLike: adef name] ifNone: [].		a == nil			ifTrue: [adef hasDefault				ifTrue:					[(self isValidating and: [self isDeclaredStandalone and: [adef type isExternal]])						ifTrue: [self invalid: #NotStandalone &lt;&lt; #xml &gt;&gt; 'This document is not standalone'].					attributeList := attributeList copyWith:							(Attribute name: adef name value: adef default)]				ifFalse: [adef isRequired					ifTrue: [self invalid: ((#attributeRequired &lt;&lt; #xml &gt;&gt; '"&lt;1s&gt;" elements are required to have a "&lt;2s&gt;" attribute')									expandMacrosWith: tag asString									with: adef name asString)]]]			ifFalse: [adef validateValueOf: a for: self]].	^attributeList size = 0		ifTrue: [nil]		ifFalse: [attributeList]</body></methods><methods><class-id>XML.XMLParser</class-id> <category>IDs</category><body package="XML">checkUnresolvedIDREFs	(self isValidating and: [unresolvedIDREFs isEmpty not])		ifTrue: [self invalid: ((#unresolvedIdrefs &lt;&lt; #xml &gt;&gt; 'The IDREFs &lt;1p&gt; have not been resolved to IDs') expandMacrosWith: unresolvedIDREFs asSortedCollection asArray)]</body><body package="XML">registerID: attribute	latestID := attribute value.	(definedIDs includes: latestID)		ifTrue: [self invalid: ((#idUsedMoreThanOnce &lt;&lt; #xml &gt;&gt; 'The id "&lt;1s&gt;" was used more than once') expandMacrosWith: latestID)].	definedIDs add: latestID.	unresolvedIDREFs remove: latestID ifAbsent: []</body><body package="XML">rememberIDREF: anID	(definedIDs includes: anID) ifFalse: [unresolvedIDREFs add: anID]</body></methods><methods><class-id>XML.XMLParser</class-id> <category>streaming</category><body package="XML">atEnd	[sourceStack == nil ifTrue: [^true].	sourceStack atEnd]		whileTrue:			[sourceStack close.			sourceStack := sourceStack nextLink].	^false</body><body package="XML">forceSpace	self skipSpace ifFalse: [self expectedWhitespace].</body><body package="XML">forceSpaceInDTD	self skipSpaceInDTD ifFalse: [self expectedWhitespace].</body><body package="XML">getNextChar	hereChar := self nextChar.	hereCharNumBytes := hereChar == nil			ifTrue: [0]			ifFalse: [sourceStack stream sizeOfLastElement].	^hereChar</body><body package="XML">mustFind: str	(self skipIf: str)		ifFalse: [self expected: str]</body><body package="XML">nextChar	| ch |	self atEnd ifTrue: [^nil].	lastSource := currentSource.	currentSource := sourceStack.	ch := currentSource next.	^ch</body><body package="XML">skipIf: str	| p oc l c ocn |	hereChar = str first ifFalse: [^false].	p := self sourceWrapper stream position.	l := self sourceWrapper line.	c := self sourceWrapper column.	oc := hereChar.	ocn := hereCharNumBytes.	1 to: str size do: [:i |		hereChar = (str at: i)			ifFalse:				[self sourceWrapper stream position: p.				self sourceWrapper line: l; column: c.				hereChar := oc.				hereCharNumBytes := ocn.				^false].		lastSource := currentSource.		currentSource := self sourceWrapper.		self getNextChar].	hereChar == nil		ifTrue: [self getNextChar].	^true</body><body package="XML">skipSpace	| n |	n := 0.	[hereChar ~~ nil and: [#(9 10 13 32) includes: hereChar asInteger]] whileTrue:		[n := n+1.		self getNextChar].	^n &gt; 0</body><body package="XML">skipSpaceInDTD	| space |	space := self skipSpace.	[self PERef: #dtd]		whileTrue: [space := self skipSpace | space].	^space</body><body package="XML">upTo: aCharacter	"Answer a subcollection from position to the occurrence (if any, exclusive) of anObject.	 The stream is left positioned after anObject.	If anObject is not found answer everything."	| newStream element |	newStream := (String new: 64) writeStream.	[self atEnd]		whileFalse:			[element := self getNextChar.			element = aCharacter				ifTrue: [^newStream contents].			newStream nextPut: element.].	self expected: (String with: aCharacter).	^newStream contents</body><body package="XML">upToAll: target	" Answer a subcollection from the current position	up to the occurrence (if any, not inclusive) of target,	and leave the stream positioned before the occurrence.	If no occurrence is found, answer the entire remaining	stream contents, and leave the stream positioned at the end.	We are going to cheat here, and assume that the first	character in the target only occurs once in the target, so	that we don't have to backtrack."	| str i |	(target occurrencesOf: target first) = 1		ifFalse: [self error: (#badSearchStringTarget &lt;&lt; #xml &gt;&gt; 'The target collection is ambiguous.')].	self sourceWrapper skip: -1.	str := (String new: 32) writeStream.	[str nextPutAll: (self upTo: target first).	i := 2.	[i &lt;= target size and:			[self getNextChar = (target at: i)]]		whileTrue:			[i := i+1].	i &lt;= target size]		whileTrue:			[str nextPutAll: (target copyFrom: 1 to: i-1).			self sourceWrapper skip: -1].	self getNextChar.	^str contents</body></methods><methods><class-id>XML.XMLParser</class-id> <category>private</category><body package="XML">closeAllFiles	self fullSourceStack do: [:str | str close]</body><body package="XML">documentNode	^self document</body><body package="XML">expected: string	self malformed: ((#expectedButNotFound &lt;&lt; #xml &gt;&gt; '&lt;1s&gt; expected, but not found') expandMacrosWith: string)</body><body package="XML">expectedWhitespace	self malformed: (#expectedWhitespace &lt;&lt; #xml &gt;&gt; 'White space expected but not found')</body><body package="XML">fullSourceStack	| out s |	out := OrderedCollection new.	s := sourceStack.	[s == nil]		whileFalse:			[out addFirst: s.			s := s nextLink].	^out</body><body package="XML">getQualifiedName	| nm |	nm := self getSimpleName.	^hereChar = $:		ifTrue:			[self getNextChar.			NodeTag new qualifier: nm ns: '' type: self getSimpleName]		ifFalse:			[NodeTag new qualifier: '' ns: '' type: nm]</body><body package="XML">getSimpleName	(self isValidNameStart: hereChar) ifFalse: [^self malformed: (#expectedName &lt;&lt; #xml &gt;&gt; 'An XML name was expected')].	nameBuffer reset.	nameBuffer nextPut: hereChar.	[self getNextChar.	hereChar notNil and: [self isValidNameChar: hereChar]]		whileTrue: [nameBuffer nextPut: hereChar].	^nameBuffer contents</body><body package="XML">invalid: aMessage	sax nonFatalError: (InvalidSignal new messageText: aMessage)</body><body package="XML">isValidNameChar: c	^c = $:		ifTrue: [self processNamespaces not]		ifFalse: [((CharacterClasses at: c asInteger+1) bitAnd: 2) = 2]</body><body package="XML">isValidNameStart: c	^c = $:		ifTrue: [self processNamespaces not]		ifFalse: [((CharacterClasses at: c asInteger+1) bitAnd: 4) = 4]</body><body package="XML">malformed: aMessage	sax fatalError: (MalformedSignal new messageText: aMessage)</body><body package="XML">nmToken	((self isValidNameChar: hereChar) or: [hereChar = $:])		ifFalse: [^self malformed: (#expectedNmtoken &lt;&lt; #xml &gt;&gt; 'An XML NmToken was expected')].	buffer reset.	buffer nextPut: hereChar.	[self getNextChar.	hereChar notNil and: [(self isValidNameChar: hereChar) or: [hereChar = $:]]]		whileTrue: [buffer nextPut: hereChar].	^buffer contents</body><body package="XML">validateEncoding: encName	| c |	encName size = 0 ifTrue: [self malformed: (#invalidEncodingName &lt;&lt; #xml &gt;&gt; 'A non-empty encoding name was expected')].	c := encName first.	(c asInteger &lt; 128 and: [c isLetter])		ifFalse: [self malformed: ((#encodingMustBeAscii1 &lt;&lt; #xml &gt;&gt; 'The first letter of the encoding ("&lt;1s&gt;") must be an ASCII alphabetic letter')						expandMacrosWith: encName)].	2 to: encName size do: [:i |		c := encName at: i.		(c asInteger &lt; 128 and: [c isLetter or: [c isDigit or: ['._-' includes: c]]])			ifFalse: [self malformed: ((#encodingMustBeAscii2 &lt;&lt; #xml &gt;&gt;'A letter in the encoding name ("&lt;1s&gt;") must be ''.'', ''_'', ''-'', or an ASCII letter or digit')						expandMacrosWith: encName)]]</body><body package="XML">warn: aMessage	sax warning: (WarningSignal new messageText: aMessage)</body><body package="XML">with: list add: node	node isDiscarded		ifFalse: [list add: node]</body></methods><methods><class-id>XML.XMLParser</class-id> <category>flags</category><body package="XML">declaredStandalone: aBoolean	^aBoolean		ifTrue: [flags := flags bitOr: 2]		ifFalse: [flags := flags bitAnd: 2 bitInvert]</body><body package="XML">flagsComment	"The 'flags' instance variable is an integer used	as a bit vector of boolean values, either recording	state as processing occurs, or recording options	that control how the processor is used. The following	documents which bits have been assigned and for	which purpose.	State bits [0..15]		0 -- parser is currently inside an &lt;![IGNORE[ section		1 -- document has standalone='yes' declaration		2 -- document has a DTD		3 -- document has an externalDTD		4 -- document uses parameter entity references to define part of the DTD	Option bits [16..29]		16 -- do namespace attributes		17 -- pass namespace declarations on to the client	"	^self commentOnly</body><body package="XML">hasDTD	^(flags bitAnd: 4) = 4</body><body package="XML">hasExternalDTD	^(flags bitAnd: 8) = 8</body><body package="XML">ignore	^(flags bitAnd: 1) = 1</body><body package="XML">ignore: aBoolean	^aBoolean		ifTrue: [flags := flags bitOr: 1]		ifFalse: [flags := flags bitAnd: 1 bitInvert]</body><body package="XML">isDeclaredStandalone	^(flags bitAnd: 2) = 2</body><body package="XML">noteDTD	flags := (flags bitOr: 4)</body><body package="XML">noteExternalDTD	flags := (flags bitOr: 8)</body><body package="XML">notePEReference	flags := (flags bitOr: 16r10)</body><body package="XML">processNamespaces	^(flags bitAnd: 16r10000) = 16r10000</body><body package="XML">processNamespaces: aBoolean	^aBoolean		ifTrue: [flags := flags bitOr: 16r10000]		ifFalse: [flags := flags bitAnd: 16r10000 bitInvert]</body><body package="XML">showNamespaceDeclarations	^(flags bitAnd: 16r20000) = 16r20000</body><body package="XML">showNamespaceDeclarations: aBoolean	^aBoolean		ifTrue: [flags := flags bitOr: 16r20000]		ifFalse: [flags := flags bitAnd: 16r20000 bitInvert]</body><body package="XML">usesParameterEntities	^(flags bitAnd: 16r10) = 16r10</body></methods><methods><class-id>XML.XMLParser</class-id> <category>namespaces</category><body package="XML">correctAttributeTag: attribute	| ns tag qual type |	qual := attribute tag qualifier.	qual isEmpty		ifTrue: [^self].	type := attribute tag type.	ns := self findNamespace: qual.	tag := NodeTag new qualifier: qual ns: ns type: type.	attribute tag: tag</body><body package="XML">correctTag: tag	| ns type qualifier |	qualifier := tag qualifier.	type := tag type.	ns := self findNamespace: qualifier.	^NodeTag new qualifier: qualifier ns: ns type: type</body><body package="XML">findNamespace: ns	| nsURI |	ns = 'xml' ifTrue: [^XML_URI].	ns = 'xmlns' ifTrue: [^'&lt;!-- xml namespace --&gt;'].	elementStack size to: 1 by: -1 do: [:i |		nsURI := (elementStack at: i) findNamespace: ns.		nsURI = nil ifFalse: [^nsURI]].	^ns = ''		ifTrue: ['']		ifFalse: [self invalid: ((#undefinedNamespaceQualifier &lt;&lt; #xml &gt;&gt; 'The namespace qualifier &lt;1s&gt; has not been bound to a namespace URI') expandMacrosWith: ns)]</body><body package="XML">resolveNamespaces: attributes	| newAttributes showDecls t1 t2 k |	self processNamespaces ifFalse: [^attributes].	showDecls := self showNamespaceDeclarations.	attributes == nil		ifTrue: [newAttributes := #()]		ifFalse:			[newAttributes := OrderedCollection new: attributes size.			attributes do: [:attr || save |				save := showDecls.				attr tag qualifier = 'xmlns'					ifTrue: [elementStack last defineNamespace: attr from: self]					ifFalse: [(attr tag isLike: 'xmlns')						ifTrue: [elementStack last defineDefaultNamespace: attr]						ifFalse: [save := true]].				save ifTrue:					[newAttributes add: attr]].			newAttributes do: [:attr | self correctAttributeTag: attr].			1 to: newAttributes size do: [:i |				t1 := (newAttributes at: i) tag.				k := i+1.				[k &lt;= newAttributes size]					whileTrue:						[t2 := (newAttributes at: k) tag.						(t1 type = t2 type and: [t1 namespace = t2 namespace])							ifTrue:								[self malformed: ((#nsAttributeAppearsTwice &lt;&lt; #xml &gt;&gt;									'The attributes "&lt;1s&gt;" and "&lt;2s&gt;" have the same namespace and type')										expandMacrosWith: t1 asString										with: t2 asString).								k := newAttributes size].						k := k+1]]].	elementStack last tag: (self correctTag: elementStack last tag).	^newAttributes isEmpty		ifTrue: [nil]		ifFalse: [newAttributes asArray]</body></methods><methods><class-id>XML.XMLParser</class-id> <category>SAX accessing</category><body package="XML">atFeature: aURIstring	aURIstring = SAXValidate		ifTrue: [^self isValidating].	aURIstring = SAXNamespace		ifTrue: [^self processNamespaces].	aURIstring = SAXNamespacePrefixes		ifTrue: [^self showNamespaceDeclarations].	aURIstring = SAXExternalGeneralEntities		ifTrue: [^SAXNotSupportedException raiseSignal].	aURIstring = SAXExternalParameterEntities		ifTrue: [^SAXNotSupportedException raiseSignal].	SAXNotRecognizedException new raiseSignal</body><body package="XML">atFeature: aURIstring put: aBoolean	aURIstring = SAXValidate		ifTrue: [^self validate: aBoolean].	aURIstring = SAXNamespace		ifTrue: [^self processNamespaces: aBoolean].	aURIstring = SAXNamespacePrefixes		ifTrue: [^self showNamespaceDeclarations: aBoolean].	aURIstring = SAXExternalGeneralEntities		ifTrue: [^SAXNotSupportedException raiseSignal].	aURIstring = SAXExternalParameterEntities		ifTrue: [^SAXNotSupportedException raiseSignal].	SAXNotRecognizedException new raiseSignal</body><body package="XML">atProperty: aURIstring	SAXNotRecognizedException new raiseSignal</body><body package="XML">atProperty: aURIstring put: anObject	SAXNotRecognizedException new raiseSignal</body><body package="XML">contentHandler	^sax contentHandler</body><body package="XML">contentHandler: aSAXDriver	| newSax |	newSax := sax class == SAXDispatcher		ifTrue: [sax]		ifFalse: [SAXDispatcher new handlers: sax].	newSax contentHandler: aSAXDriver.	self saxDriver: newSax</body><body package="XML">dtdHandler	^sax dtdHandler</body><body package="XML">dtdHandler: aSAXDriver	| newSax |	newSax := sax class == SAXDispatcher		ifTrue: [sax]		ifFalse: [SAXDispatcher new handlers: sax].	newSax dtdHandler: aSAXDriver.	self saxDriver: newSax</body><body package="XML">entityResolver	^sax entityResolver</body><body package="XML">entityResolver: aSAXDriver	| newSax |	newSax := sax class == SAXDispatcher		ifTrue: [sax]		ifFalse: [SAXDispatcher new handlers: sax].	newSax entityResolver: aSAXDriver.	self saxDriver: newSax</body><body package="XML">errorHandler	^sax errorHandler</body><body package="XML">errorHandler: aSAXDriver	| newSax |	newSax := sax class == SAXDispatcher		ifTrue: [sax]		ifFalse: [SAXDispatcher new handlers: sax].	newSax errorHandler: aSAXDriver.	self saxDriver: newSax</body><body package="XML">handlers: aSAXDriver	self saxDriver: aSAXDriver</body><body package="XML">parse: dataSource	self on: dataSource.	^self scanDocument</body><body package="XML">parseElement	^[sax startDocumentFragment.	self getNextChar.	hereChar = $&lt;		ifFalse: [self expected: '&lt;'].	self getElement.	sax endDocumentFragment.	sax document == nil		ifTrue: [nil]		ifFalse: [sax document elements first]]		ifCurtailed: [self closeAllFiles]</body><body package="XML">parseElement: dataSource	self validate: false.	self on: dataSource.	^self parseElement</body><body package="XML">parseElements	^[sax startDocumentFragment.	  self prolog.	  [self atEnd] whileFalse:			[self getElement.			[self misc] whileTrue].	  sax endDocumentFragment.	  sax document == nil			ifTrue: [nil]			ifFalse: [sax document elements]]		ifCurtailed: [self closeAllFiles]</body><body package="XML">parseElements: dataSource	self validate: false.	self on: dataSource.	^self parseElements</body></methods><methods><class-id>XML.XMLParser class</class-id> <category>class initialization</category><body package="XML">isNameChar: index	index &gt; 16rFFFF ifTrue: [^false].	(index between: 16r0300 and: 16r0345) ifTrue: [^true].	(index between: 16r0360 and: 16r0361) ifTrue: [^true].	(index between: 16r0483 and: 16r0486) ifTrue: [^true].	(index between: 16r0591 and: 16r05A1) ifTrue: [^true].	(index between: 16r05A3 and: 16r05B9) ifTrue: [^true].	(index between: 16r05BB and: 16r05BD) ifTrue: [^true].	index = 16r05BF ifTrue: [^true].	(index between: 16r05C1 and: 16r05C2) ifTrue: [^true].	index = 16r05C4 ifTrue: [^true].	(index between: 16r064B and: 16r0652) ifTrue: [^true].	index = 16r0670 ifTrue: [^true].	(index between: 16r06D6 and: 16r06DC) ifTrue: [^true].	(index between: 16r06DD and: 16r06DF) ifTrue: [^true].	(index between: 16r06E0 and: 16r06E4) ifTrue: [^true].	(index between: 16r06E7 and: 16r06E8) ifTrue: [^true].	(index between: 16r06EA and: 16r06ED) ifTrue: [^true].	(index between: 16r0901 and: 16r0903) ifTrue: [^true].	index = 16r093C ifTrue: [^true].	(index between: 16r093E and: 16r094C) ifTrue: [^true].	index = 16r094D ifTrue: [^true].	(index between: 16r0951 and: 16r0954) ifTrue: [^true].	(index between: 16r0962 and: 16r0963) ifTrue: [^true].	(index between: 16r0981 and: 16r0983) ifTrue: [^true].	index = 16r09BC ifTrue: [^true].	index = 16r09BE ifTrue: [^true].	index = 16r09BF ifTrue: [^true].	(index between: 16r09C0 and: 16r09C4) ifTrue: [^true].	(index between: 16r09C7 and: 16r09C8) ifTrue: [^true].	(index between: 16r09CB and: 16r09CD) ifTrue: [^true].	index = 16r09D7 ifTrue: [^true].	(index between: 16r09E2 and: 16r09E3) ifTrue: [^true].	index = 16r0A02 ifTrue: [^true].	index = 16r0A3C ifTrue: [^true].	index = 16r0A3E ifTrue: [^true].	index = 16r0A3F ifTrue: [^true].	(index between: 16r0A40 and: 16r0A42) ifTrue: [^true].	(index between: 16r0A47 and: 16r0A48) ifTrue: [^true].	(index between: 16r0A4B and: 16r0A4D) ifTrue: [^true].	(index between: 16r0A70 and: 16r0A71) ifTrue: [^true].	(index between: 16r0A81 and: 16r0A83) ifTrue: [^true].	index = 16r0ABC ifTrue: [^true].	(index between: 16r0ABE and: 16r0AC5) ifTrue: [^true].	(index between: 16r0AC7 and: 16r0AC9) ifTrue: [^true].	(index between: 16r0ACB and: 16r0ACD) ifTrue: [^true].	(index between: 16r0B01 and: 16r0B03) ifTrue: [^true].	index = 16r0B3C ifTrue: [^true].	(index between: 16r0B3E and: 16r0B43) ifTrue: [^true].	(index between: 16r0B47 and: 16r0B48) ifTrue: [^true].	(index between: 16r0B4B and: 16r0B4D) ifTrue: [^true].	(index between: 16r0B56 and: 16r0B57) ifTrue: [^true].	(index between: 16r0B82 and: 16r0B83) ifTrue: [^true].	(index between: 16r0BBE and: 16r0BC2) ifTrue: [^true].	(index between: 16r0BC6 and: 16r0BC8) ifTrue: [^true].	(index between: 16r0BCA and: 16r0BCD) ifTrue: [^true].	index = 16r0BD7 ifTrue: [^true].	(index between: 16r0C01 and: 16r0C03) ifTrue: [^true].	(index between: 16r0C3E and: 16r0C44) ifTrue: [^true].	(index between: 16r0C46 and: 16r0C48) ifTrue: [^true].	(index between: 16r0C4A and: 16r0C4D) ifTrue: [^true].	(index between: 16r0C55 and: 16r0C56) ifTrue: [^true].	(index between: 16r0C82 and: 16r0C83) ifTrue: [^true].	(index between: 16r0CBE and: 16r0CC4) ifTrue: [^true].	(index between: 16r0CC6 and: 16r0CC8) ifTrue: [^true].	(index between: 16r0CCA and: 16r0CCD) ifTrue: [^true].	(index between: 16r0CD5 and: 16r0CD6) ifTrue: [^true].	(index between: 16r0D02 and: 16r0D03) ifTrue: [^true].	(index between: 16r0D3E and: 16r0D43) ifTrue: [^true].	(index between: 16r0D46 and: 16r0D48) ifTrue: [^true].	(index between: 16r0D4A and: 16r0D4D) ifTrue: [^true].	index = 16r0D57 ifTrue: [^true].	index = 16r0E31 ifTrue: [^true].	(index between: 16r0E34 and: 16r0E3A) ifTrue: [^true].	(index between: 16r0E47 and: 16r0E4E) ifTrue: [^true].	index = 16r0EB1 ifTrue: [^true].	(index between: 16r0EB4 and: 16r0EB9) ifTrue: [^true].	(index between: 16r0EBB and: 16r0EBC) ifTrue: [^true].	(index between: 16r0EC8 and: 16r0ECD) ifTrue: [^true].	(index between: 16r0F18 and: 16r0F19) ifTrue: [^true].	index = 16r0F35 ifTrue: [^true].	index = 16r0F37 ifTrue: [^true].	index = 16r0F39 ifTrue: [^true].	index = 16r0F3E ifTrue: [^true].	index = 16r0F3F ifTrue: [^true].	(index between: 16r0F71 and: 16r0F84) ifTrue: [^true].	(index between: 16r0F86 and: 16r0F8B) ifTrue: [^true].	(index between: 16r0F90 and: 16r0F95) ifTrue: [^true].	index = 16r0F97 ifTrue: [^true].	(index between: 16r0F99 and: 16r0FAD) ifTrue: [^true].	(index between: 16r0FB1 and: 16r0FB7) ifTrue: [^true].	index = 16r0FB9 ifTrue: [^true].	(index between: 16r20D0 and: 16r20DC) ifTrue: [^true].	index = 16r20E1 ifTrue: [^true].	(index between: 16r302A and: 16r302F) ifTrue: [^true].	index = 16r3099 ifTrue: [^true].	index = 16r309A ifTrue: [^true].	(index between: 16r0030 and: 16r0039) ifTrue: [^true].	(index between: 16r0660 and: 16r0669) ifTrue: [^true].	(index between: 16r06F0 and: 16r06F9) ifTrue: [^true].	(index between: 16r0966 and: 16r096F) ifTrue: [^true].	(index between: 16r09E6 and: 16r09EF) ifTrue: [^true].	(index between: 16r0A66 and: 16r0A6F) ifTrue: [^true].	(index between: 16r0AE6 and: 16r0AEF) ifTrue: [^true].	(index between: 16r0B66 and: 16r0B6F) ifTrue: [^true].	(index between: 16r0BE7 and: 16r0BEF) ifTrue: [^true].	(index between: 16r0C66 and: 16r0C6F) ifTrue: [^true].	(index between: 16r0CE6 and: 16r0CEF) ifTrue: [^true].	(index between: 16r0D66 and: 16r0D6F) ifTrue: [^true].	(index between: 16r0E50 and: 16r0E59) ifTrue: [^true].	(index between: 16r0ED0 and: 16r0ED9) ifTrue: [^true].	(index between: 16r0F20 and: 16r0F29) ifTrue: [^true].	index = 16r00B7 ifTrue: [^true].	index = 16r02D0 ifTrue: [^true].	index = 16r02D1 ifTrue: [^true].	index = 16r0387 ifTrue: [^true].	index = 16r0640 ifTrue: [^true].	index = 16r0E46 ifTrue: [^true].	index = 16r0EC6 ifTrue: [^true].	index = 16r3005 ifTrue: [^true].	(index between: 16r3031 and: 16r3035) ifTrue: [^true].	(index between: 16r309D and: 16r309E) ifTrue: [^true].	(index between: 16r30FC and: 16r30FE) ifTrue: [^true].	^false</body><body package="XML">isNameStartChar: index	index &gt; 16rFFFF ifTrue: [^false].	(index between: 16r0041 and: 16r005A) ifTrue: [^true].	(index between: 16r0061 and: 16r007A) ifTrue: [^true].	(index between: 16r00C0 and: 16r00D6) ifTrue: [^true].	(index between: 16r00D8 and: 16r00F6) ifTrue: [^true].	(index between: 16r00F8 and: 16r00FF) ifTrue: [^true].	(index between: 16r0100 and: 16r0131) ifTrue: [^true].	(index between: 16r0134 and: 16r013E) ifTrue: [^true].	(index between: 16r0141 and: 16r0148) ifTrue: [^true].	(index between: 16r014A and: 16r017E) ifTrue: [^true].	(index between: 16r0180 and: 16r01C3) ifTrue: [^true].	(index between: 16r01CD and: 16r01F0) ifTrue: [^true].	(index between: 16r01F4 and: 16r01F5) ifTrue: [^true].	(index between: 16r01FA and: 16r0217) ifTrue: [^true].	(index between: 16r0250 and: 16r02A8) ifTrue: [^true].	(index between: 16r02BB and: 16r02C1) ifTrue: [^true].	index = 16r0386 ifTrue: [^true].	(index between: 16r0388 and: 16r038A) ifTrue: [^true].	index = 16r038C ifTrue: [^true].	(index between: 16r038E and: 16r03A1) ifTrue: [^true].	(index between: 16r03A3 and: 16r03CE) ifTrue: [^true].	(index between: 16r03D0 and: 16r03D6) ifTrue: [^true].	index = 16r03DA ifTrue: [^true].	index = 16r03DC ifTrue: [^true].	index = 16r03DE ifTrue: [^true].	index = 16r03E0 ifTrue: [^true].	(index between: 16r03E2 and: 16r03F3) ifTrue: [^true].	(index between: 16r0401 and: 16r040C) ifTrue: [^true].	(index between: 16r040E and: 16r044F) ifTrue: [^true].	(index between: 16r0451 and: 16r045C) ifTrue: [^true].	(index between: 16r045E and: 16r0481) ifTrue: [^true].	(index between: 16r0490 and: 16r04C4) ifTrue: [^true].	(index between: 16r04C7 and: 16r04C8) ifTrue: [^true].	(index between: 16r04CB and: 16r04CC) ifTrue: [^true].	(index between: 16r04D0 and: 16r04EB) ifTrue: [^true].	(index between: 16r04EE and: 16r04F5) ifTrue: [^true].	(index between: 16r04F8 and: 16r04F9) ifTrue: [^true].	(index between: 16r0531 and: 16r0556) ifTrue: [^true].	index = 16r0559 ifTrue: [^true].	(index between: 16r0561 and: 16r0586) ifTrue: [^true].	(index between: 16r05D0 and: 16r05EA) ifTrue: [^true].	(index between: 16r05F0 and: 16r05F2) ifTrue: [^true].	(index between: 16r0621 and: 16r063A) ifTrue: [^true].	(index between: 16r0641 and: 16r064A) ifTrue: [^true].	(index between: 16r0671 and: 16r06B7) ifTrue: [^true].	(index between: 16r06BA and: 16r06BE) ifTrue: [^true].	(index between: 16r06C0 and: 16r06CE) ifTrue: [^true].	(index between: 16r06D0 and: 16r06D3) ifTrue: [^true].	index = 16r06D5 ifTrue: [^true].	(index between: 16r06E5 and: 16r06E6) ifTrue: [^true].	(index between: 16r0905 and: 16r0939) ifTrue: [^true].	index = 16r093D ifTrue: [^true].	(index between: 16r0958 and: 16r0961) ifTrue: [^true].	(index between: 16r0985 and: 16r098C) ifTrue: [^true].	(index between: 16r098F and: 16r0990) ifTrue: [^true].	(index between: 16r0993 and: 16r09A8) ifTrue: [^true].	(index between: 16r09AA and: 16r09B0) ifTrue: [^true].	index = 16r09B2 ifTrue: [^true].	(index between: 16r09B6 and: 16r09B9) ifTrue: [^true].	(index between: 16r09DC and: 16r09DD) ifTrue: [^true].	(index between: 16r09DF and: 16r09E1) ifTrue: [^true].	(index between: 16r09F0 and: 16r09F1) ifTrue: [^true].	(index between: 16r0A05 and: 16r0A0A) ifTrue: [^true].	(index between: 16r0A0F and: 16r0A10) ifTrue: [^true].	(index between: 16r0A13 and: 16r0A28) ifTrue: [^true].	(index between: 16r0A2A and: 16r0A30) ifTrue: [^true].	(index between: 16r0A32 and: 16r0A33) ifTrue: [^true].	(index between: 16r0A35 and: 16r0A36) ifTrue: [^true].	(index between: 16r0A38 and: 16r0A39) ifTrue: [^true].	(index between: 16r0A59 and: 16r0A5C) ifTrue: [^true].	index = 16r0A5E ifTrue: [^true].	(index between: 16r0A72 and: 16r0A74) ifTrue: [^true].	(index between: 16r0A85 and: 16r0A8B) ifTrue: [^true].	index = 16r0A8D ifTrue: [^true].	(index between: 16r0A8F and: 16r0A91) ifTrue: [^true].	(index between: 16r0A93 and: 16r0AA8) ifTrue: [^true].	(index between: 16r0AAA and: 16r0AB0) ifTrue: [^true].	(index between: 16r0AB2 and: 16r0AB3) ifTrue: [^true].	(index between: 16r0AB5 and: 16r0AB9) ifTrue: [^true].	index = 16r0ABD ifTrue: [^true].	index = 16r0AE0 ifTrue: [^true].	(index between: 16r0B05 and: 16r0B0C) ifTrue: [^true].	(index between: 16r0B0F and: 16r0B10) ifTrue: [^true].	(index between: 16r0B13 and: 16r0B28) ifTrue: [^true].	(index between: 16r0B2A and: 16r0B30) ifTrue: [^true].	(index between: 16r0B32 and: 16r0B33) ifTrue: [^true].	(index between: 16r0B36 and: 16r0B39) ifTrue: [^true].	index = 16r0B3D ifTrue: [^true].	(index between: 16r0B5C and: 16r0B5D) ifTrue: [^true].	(index between: 16r0B5F and: 16r0B61) ifTrue: [^true].	(index between: 16r0B85 and: 16r0B8A) ifTrue: [^true].	(index between: 16r0B8E and: 16r0B90) ifTrue: [^true].	(index between: 16r0B92 and: 16r0B95) ifTrue: [^true].	(index between: 16r0B99 and: 16r0B9A) ifTrue: [^true].	index = 16r0B9C ifTrue: [^true].	(index between: 16r0B9E and: 16r0B9F) ifTrue: [^true].	(index between: 16r0BA3 and: 16r0BA4) ifTrue: [^true].	(index between: 16r0BA8 and: 16r0BAA) ifTrue: [^true].	(index between: 16r0BAE and: 16r0BB5) ifTrue: [^true].	(index between: 16r0BB7 and: 16r0BB9) ifTrue: [^true].	(index between: 16r0C05 and: 16r0C0C) ifTrue: [^true].	(index between: 16r0C0E and: 16r0C10) ifTrue: [^true].	(index between: 16r0C12 and: 16r0C28) ifTrue: [^true].	(index between: 16r0C2A and: 16r0C33) ifTrue: [^true].	(index between: 16r0C35 and: 16r0C39) ifTrue: [^true].	(index between: 16r0C60 and: 16r0C61) ifTrue: [^true].	(index between: 16r0C85 and: 16r0C8C) ifTrue: [^true].	(index between: 16r0C8E and: 16r0C90) ifTrue: [^true].	(index between: 16r0C92 and: 16r0CA8) ifTrue: [^true].	(index between: 16r0CAA and: 16r0CB3) ifTrue: [^true].	(index between: 16r0CB5 and: 16r0CB9) ifTrue: [^true].	index = 16r0CDE ifTrue: [^true].	(index between: 16r0CE0 and: 16r0CE1) ifTrue: [^true].	(index between: 16r0D05 and: 16r0D0C) ifTrue: [^true].	(index between: 16r0D0E and: 16r0D10) ifTrue: [^true].	(index between: 16r0D12 and: 16r0D28) ifTrue: [^true].	(index between: 16r0D2A and: 16r0D39) ifTrue: [^true].	(index between: 16r0D60 and: 16r0D61) ifTrue: [^true].	(index between: 16r0E01 and: 16r0E2E) ifTrue: [^true].	index = 16r0E30 ifTrue: [^true].	(index between: 16r0E32 and: 16r0E33) ifTrue: [^true].	(index between: 16r0E40 and: 16r0E45) ifTrue: [^true].	(index between: 16r0E81 and: 16r0E82) ifTrue: [^true].	index = 16r0E84 ifTrue: [^true].	(index between: 16r0E87 and: 16r0E88) ifTrue: [^true].	index = 16r0E8A ifTrue: [^true].	index = 16r0E8D ifTrue: [^true].	(index between: 16r0E94 and: 16r0E97) ifTrue: [^true].	(index between: 16r0E99 and: 16r0E9F) ifTrue: [^true].	(index between: 16r0EA1 and: 16r0EA3) ifTrue: [^true].	index = 16r0EA5 ifTrue: [^true].	index = 16r0EA7 ifTrue: [^true].	(index between: 16r0EAA and: 16r0EAB) ifTrue: [^true].	(index between: 16r0EAD and: 16r0EAE) ifTrue: [^true].	index = 16r0EB0 ifTrue: [^true].	(index between: 16r0EB2 and: 16r0EB3) ifTrue: [^true].	index = 16r0EBD ifTrue: [^true].	(index between: 16r0EC0 and: 16r0EC4) ifTrue: [^true].	(index between: 16r0F40 and: 16r0F47) ifTrue: [^true].	(index between: 16r0F49 and: 16r0F69) ifTrue: [^true].	(index between: 16r10A0 and: 16r10C5) ifTrue: [^true].	(index between: 16r10D0 and: 16r10F6) ifTrue: [^true].	index = 16r1100 ifTrue: [^true].	(index between: 16r1102 and: 16r1103) ifTrue: [^true].	(index between: 16r1105 and: 16r1107) ifTrue: [^true].	index = 16r1109 ifTrue: [^true].	(index between: 16r110B and: 16r110C) ifTrue: [^true].	(index between: 16r110E and: 16r1112) ifTrue: [^true].	index = 16r113C ifTrue: [^true].	index = 16r113E ifTrue: [^true].	index = 16r1140 ifTrue: [^true].	index = 16r114C ifTrue: [^true].	index = 16r114E ifTrue: [^true].	index = 16r1150 ifTrue: [^true].	(index between: 16r1154 and: 16r1155) ifTrue: [^true].	index = 16r1159 ifTrue: [^true].	(index between: 16r115F and: 16r1161) ifTrue: [^true].	index = 16r1163 ifTrue: [^true].	index = 16r1165 ifTrue: [^true].	index = 16r1167 ifTrue: [^true].	index = 16r1169 ifTrue: [^true].	(index between: 16r116D and: 16r116E) ifTrue: [^true].	(index between: 16r1172 and: 16r1173) ifTrue: [^true].	index = 16r1175 ifTrue: [^true].	index = 16r119E ifTrue: [^true].	index = 16r11A8 ifTrue: [^true].	index = 16r11AB ifTrue: [^true].	(index between: 16r11AE and: 16r11AF) ifTrue: [^true].	(index between: 16r11B7 and: 16r11B8) ifTrue: [^true].	index = 16r11BA ifTrue: [^true].	(index between: 16r11BC and: 16r11C2) ifTrue: [^true].	index = 16r11EB ifTrue: [^true].	index = 16r11F0 ifTrue: [^true].	index = 16r11F9 ifTrue: [^true].	(index between: 16r1E00 and: 16r1E9B) ifTrue: [^true].	(index between: 16r1EA0 and: 16r1EF9) ifTrue: [^true].	(index between: 16r1F00 and: 16r1F15) ifTrue: [^true].	(index between: 16r1F18 and: 16r1F1D) ifTrue: [^true].	(index between: 16r1F20 and: 16r1F45) ifTrue: [^true].	(index between: 16r1F48 and: 16r1F4D) ifTrue: [^true].	(index between: 16r1F50 and: 16r1F57) ifTrue: [^true].	index = 16r1F59 ifTrue: [^true].	index = 16r1F5B ifTrue: [^true].	index = 16r1F5D ifTrue: [^true].	(index between: 16r1F5F and: 16r1F7D) ifTrue: [^true].	(index between: 16r1F80 and: 16r1FB4) ifTrue: [^true].	(index between: 16r1FB6 and: 16r1FBC) ifTrue: [^true].	index = 16r1FBE ifTrue: [^true].	(index between: 16r1FC2 and: 16r1FC4) ifTrue: [^true].	(index between: 16r1FC6 and: 16r1FCC) ifTrue: [^true].	(index between: 16r1FD0 and: 16r1FD3) ifTrue: [^true].	(index between: 16r1FD6 and: 16r1FDB) ifTrue: [^true].	(index between: 16r1FE0 and: 16r1FEC) ifTrue: [^true].	(index between: 16r1FF2 and: 16r1FF4) ifTrue: [^true].	(index between: 16r1FF6 and: 16r1FFC) ifTrue: [^true].	index = 16r2126 ifTrue: [^true].	(index between: 16r212A and: 16r212B) ifTrue: [^true].	index = 16r212E ifTrue: [^true].	(index between: 16r2180 and: 16r2182) ifTrue: [^true].	(index between: 16r3041 and: 16r3094) ifTrue: [^true].	(index between: 16r30A1 and: 16r30FA) ifTrue: [^true].	(index between: 16r3105 and: 16r312C) ifTrue: [^true].	(index between: 16rAC00 and: 16rD7A3) ifTrue: [^true].	(index between: 16r4E00 and: 16r9FA5) ifTrue: [^true].	index = 16r3007 ifTrue: [^true].	(index between: 16r3021 and: 16r3029) ifTrue: [^true].	^false</body></methods><methods><class-id>XML.XMLParser class</class-id> <category>instance creation</category><body package="XML">new	^super new initialize</body><body package="XML">on: aDataSource	"The dataSource may be a URI, a Filename (or a String	which will be treated as a Filename), or an InputSource."	^self new on: aDataSource</body><body package="XML">processDocumentInFilename: aFilename 	^self processDocumentInFilename: aFilename beforeScanDo: [:parser | ]</body><body package="XML">processDocumentInFilename: aFilename beforeScanDo: aBlock	| stream p |	stream := (aFilename asFilename withEncoding: #UTF_8) readStream.	stream lineEndTransparent.	p := self on: stream.	aBlock value: p.	^p scanDocument</body><body package="XML">processDocumentString: aString	^self processDocumentString: aString beforeScanDo: [:parser | ]</body><body package="XML">processDocumentString: aString beforeScanDo: aBlock	| p |	p := self on: aString readStream.	aBlock value: p.	^p scanDocument</body></methods><methods><class-id>XML.XMLParser class</class-id> <category>utilities</category><body package="XML">mapEncoding: anEncoding	| enc |	enc := anEncoding asLowercase.	enc = 'utf-8' ifTrue: [^'UTF_8'].	enc = 'utf-16' ifTrue: [^'UTF_16'].	enc = 'iso-8859-1' ifTrue: [^'ISO8859_1'].	^enc</body><body package="XML">readFileContents: fn	| s p r |	r := fn asFilename asURI resource.	p := self new.	p lineEndLF.	s := StreamWrapper			resource: r			entity: nil			from: p.	^[s checkEncoding.	s contents]		ensure: [s close]</body></methods><methods><class-id>XML.ElementContext</class-id> <category>accessing</category><body package="XML">followSetDescription	| types |	types := IdentitySet new.	self types do: [:tp |		types addAll: tp followSet].	^types asArray printString</body><body package="XML">namespaces	namespaces == nil ifTrue: [namespaces := Dictionary new].	^namespaces</body><body package="XML">tag	^tag</body><body package="XML">tag: aTag	tag := aTag isString			ifTrue: [NodeTag new qualifier: '' ns: '' type: aTag]			ifFalse: [aTag].</body><body package="XML">type	^self shouldNotImplement</body><body package="XML">type: anElementType	type := Array with: anElementType.	isExternal := anElementType isExternal</body><body package="XML">types	^type</body><body package="XML">types: anArray	type := anArray</body></methods><methods><class-id>XML.ElementContext</class-id> <category>namespaces</category><body package="XML">defineDefaultNamespace: attribute	self namespaces at: '' put: attribute value</body><body package="XML">defineNamespace: attribute from: aParser	attribute tag type = 'xmlns'		ifTrue: [self error: ((#illegalQualifier &lt;&lt; #xml &gt;&gt; 'It is illegal to redefine the qualifier "&lt;1s&gt;".') expandMacrosWith: attribute tag type)].	(attribute tag type = 'xml' and: [attribute value ~= XML_URI ])		ifTrue: [self error: ((#illegalQualifier &lt;&lt; #xml &gt;&gt; 'It is illegal to redefine the qualifier "&lt;1s&gt;".') expandMacrosWith: attribute tag type)].	attribute value isEmpty ifTrue: [aParser invalid: (#invalidURIForNamespace &lt;&lt; #xml &gt;&gt; 'It is not permitted to have an empty URI as a namespace name')].	self namespaces at: attribute tag type put: attribute value</body><body package="XML">findNamespace: ns	^namespaces isNil		ifTrue: [nil]		ifFalse: [namespaces at: ns ifAbsent: [nil]]</body></methods><methods><class-id>XML.ElementContext</class-id> <category>testing</category><body package="XML">canTerminate	self types do: [:i |		i canTerminate ifTrue: [^true]].	^false</body><body package="XML">definesNamespaces	^namespaces notNil and: [namespaces isEmpty not]</body><body package="XML">isDefinedExternal	^isExternal</body><body package="XML">validateTag: nm	| types |	types := IdentitySet new.	self types do: [:i || t |		t := i validateTag: nm.		t == nil ifFalse: [types addAll: t]].	^types isEmpty		ifTrue: [nil]		ifFalse: [types asArray]</body><body package="XML">validateText: data from: start to: stop testBlanks: testBlanks	| types |	types := IdentitySet new.	self types do: [:i || t |		t := i validateText: data from: start to: stop testBlanks: testBlanks.		t == nil ifFalse: [types add: t]].	^types isEmpty		ifTrue: [nil]		ifFalse: [types asArray]</body></methods><methods><class-id>XML.SAXElementContext</class-id> <category>accessing</category><body package="XML">attributes	^attributes</body><body package="XML">attributes: aCollection	attributes := aCollection</body><body package="XML">id	^id</body><body package="XML">id: anID	id := anID</body><body package="XML">namespaces: aDictionary	namespaces := aDictionary</body><body package="XML">nodes	^nodes</body><body package="XML">nodes: aCollection	nodes := aCollection</body><body package="XML">startPosition	^startPosition</body><body package="XML">startPosition: anInteger	^startPosition := anInteger</body><body package="XML">stream	^stream</body><body package="XML">stream: aStream	^stream := aStream</body></methods><methods><class-id>XML.InputSource</class-id> <category>initialize</category><body package="XML">uri: aURI encoding: anEncodingName stream: aStream	uri := aURI.	encoding := anEncodingName.	stream := aStream</body></methods><methods><class-id>XML.InputSource</class-id> <category>accessing</category><body package="XML">encoding	^encoding</body><body package="XML">stream	^stream</body><body package="XML">uri	"Often, we do no more than check whether this value is nil or not.  Since the performance hit of creating these was observed to be high in a StoreGlorp context, we drop the send of asFilename asURI in XMLParser&gt;&gt;wrapDataSource:, instead expanding lazily here (and providing a separate #hasURI check for nil-ness)."	uri isString ifTrue: [uri := uri asFilename asURI].	^uri</body></methods><methods><class-id>XML.InputSource</class-id> <category>testing</category><body package="XML">hasURI	"Performance optimisation:  avoid expanding any strings to FileURLs when only checking for nil-ness."	^uri ~~ nil</body></methods><methods><class-id>XML.InputSource class</class-id> <category>instance creation</category><body package="XML">uri: aURI encoding: anEncodingName stream: aStream	^self new uri: aURI encoding: anEncodingName stream: aStream</body></methods><methods><class-id>XML.SAXBuilderDriver</class-id> <category>content handler</category><body package="XML">characters: aString	| text |	text := builder makeText: aString.	text isDiscarded		ifFalse: [elementStack last nodes add: text].</body><body package="XML">endDocument</body><body package="XML">endDocumentFragment	^self endDocument</body><body package="XML">endElement: namespaceURI localName: localName qName: name	"indicates the end of an element. See startElement"	| elm element |	elm := elementStack last.	element := builder			tag: elm tag			attributes: elm attributes			elements: (elm nodes isEmpty					ifTrue: [nil]					ifFalse: [elm nodes asArray])			position: elm startPosition			stream: elm stream.	element namespaces: elm namespaces.	elementStack removeLast.	elementStack isEmpty		ifTrue:			[document addNode: element.			document dtd declaredRoot: element tag asString]		ifFalse: [element isDiscarded			ifFalse: [elementStack last nodes add: element]].	(element isDiscarded not and: [elm id notNil])		ifTrue: [document atID: elm id put: element].	builder popTag</body><body package="XML">ignorableWhitespace: aString	| text |	text := builder makeText: aString.	text isDiscarded		ifFalse: [elementStack last nodes add: text].</body><body package="XML">processingInstruction: targetString data: dataString	| pi |	document == nil ifTrue: [self startDocument].	pi := builder pi: targetString text: dataString.	elementStack isEmpty		ifTrue: [document addNode: pi]		ifFalse: [elementStack last nodes add: pi]</body><body package="XML">startDocument	document := Document new.	document dtd: DocumentType new.	elementStack := OrderedCollection new.</body><body package="XML">startDocumentFragment	document := DocumentFragment new.	document dtd: DocumentType new.	elementStack := OrderedCollection new.</body><body package="XML">startElement: namespaceURI localName: localName qName: name attributes: attributes	| nm |	document == nil ifTrue: [self startDocument].	nm := NodeTag new		qualifier: ((name includes: $:)				ifTrue: [name copyUpTo: $:]				ifFalse: [''])		ns: namespaceURI		type: localName.	elementStack addLast: (SAXElementContext new tag: nm).	elementStack last		attributes: (attributes collect: [:att | att copy]);		nodes: OrderedCollection new;		namespaces: newNamespaces.	newNamespaces := nil.	builder pushTag: nm.</body><body package="XML">startPrefixMapping: prefix uri: uri 	newNamespaces == nil		ifTrue: [newNamespaces := Dictionary new].	newNamespaces at: prefix put: uri.</body></methods><methods><class-id>XML.SAXBuilderDriver</class-id> <category>other</category><body package="XML">comment: data from: start to: stop	| comment |	document == nil ifTrue: [self startDocument].	comment := builder comment: (data copyFrom: start to: stop).	comment isDiscarded		ifFalse: [elementStack isEmpty			ifTrue: [document addNode: comment]			ifFalse: [elementStack last nodes add: comment]].</body><body package="XML">idOfElement: elementID	"Notify the client what was the ID of the latest startElement"	elementStack last id: elementID</body><body package="XML">sourcePosition: position inStream: streamWrapper	"Non-standard API to ease transition from	builders to SAX."	elementStack last		startPosition: position;		stream: streamWrapper</body></methods><methods><class-id>XML.SAXBuilderDriver</class-id> <category>accessing</category><body package="XML">builder: aNodeBuilder	builder := aNodeBuilder</body><body package="XML">document	^document</body></methods><methods><class-id>XML.SAXBuilderDriver</class-id> <category>DTD handler</category><body package="XML">notationDecl: name publicID: publicID systemID: systemID	| notation |	notation := builder notation: name value: (Array with: publicID with: systemID).	document dtd notationAt: name put: notation from: self</body></methods><methods><class-id>XML.MixedPattern</class-id> <category>initialize</category><body package="XML">on: aList	items := (Array with: PCDATAPattern new), aList</body></methods><methods><class-id>XML.MixedPattern</class-id> <category>coercing</category><body package="XML">alternateHeads	^items, followSet</body><body package="XML">normalizeFor: aParser	"Optimized because lots of the testing needed in	the superclass is not needed here."	| result |	followSet := OrderedCollection withAll: items.	followSet add: TerminalPattern new.	result := InitialPattern new.	result followSet: followSet.	items do: [:i | i followSet: followSet].	^result</body><body package="XML">pushDownFollowSet	items do: [:i | i addFollow: self; addFollows: followSet].	^items</body></methods><methods><class-id>XML.MixedPattern</class-id> <category>testing</category><body package="XML">duplicatesNeedTested	^false</body></methods><methods><class-id>XML.MixedPattern</class-id> <category>copying</category><body package="XML">postCopy	super postCopy.	items := items collect: [:i | i copy].</body></methods><methods><class-id>XML.MixedPattern class</class-id> <category>instance creation</category><body package="XML">on: aList	^self new on: (aList size = 0 ifTrue: [#()] ifFalse: [aList])</body></methods><methods><class-id>XML.SequencePattern</class-id> <category>initialize</category><body package="XML">on: aList	items := aList</body></methods><methods><class-id>XML.SequencePattern</class-id> <category>coercing</category><body package="XML">alternateHeads	^Array with: items first</body><body package="XML">pushDownFollowSet	1 to: items size-1 do: [:i |		(items at: i) addFollow: (items at: i+1)].	items last addFollows: followSet.	^items</body></methods><methods><class-id>XML.SequencePattern</class-id> <category>printing</category><body package="XML">description	| str |	str := String new writeStream.	str nextPutAll: '('.	items do: [:ch | str nextPutAll: ch description] separatedBy: [str nextPutAll: ' , '].	str nextPutAll: ')'.	^str contents</body><body package="XML">printOn: aStream	aStream nextPutAll: self description</body></methods><methods><class-id>XML.SequencePattern</class-id> <category>copying</category><body package="XML">postCopy	super postCopy.	items := items collect: [:i | i copy].</body></methods><methods><class-id>XML.SequencePattern class</class-id> <category>instance creation</category><body package="XML">on: aList	^self new on: aList</body></methods><methods><class-id>XML.CharacterTable</class-id> <category>accessing</category><body package="XML">at: index	"Answer the value of an indexable field in the receiver.  Fail if the	 argument index is not an Integer or is out of bounds.  This primitive is an	 optimization of the code inherited from SegmentedArray."	&lt;primitive: 425 errorCode: errorCode&gt;	^index &gt; self size		ifTrue: [self defaultElement]		ifFalse: [super at: index]</body></methods><methods><class-id>XML.ID_AT</class-id> <category>validating</category><body package="XML">validateDefinition: anAttributeDefinition for: aParser	anAttributeDefinition hasDefault		ifTrue: [aParser invalid: (#noDefaultsForIDAttributes &lt;&lt; #xml &gt;&gt; 'ID attributes must be either #REQUIRED or #IMPLIED')]</body><body package="XML">validateValueOf: anAttribute for: aParser	| v |	super validateValueOf: anAttribute for: aParser.	v := anAttribute value.	(v includes: Character space)		ifTrue: [aParser invalid: (#spaceInIdAttribute &lt;&lt; #xml &gt;&gt; 'white space must not occur in ID attributes')].	(aParser isValidName: v)		ifFalse: [aParser invalid: ((#invalidIdAttribute &lt;&lt; #xml &gt;&gt; 'An ID attribute (&lt;1s&gt;="&lt;2s&gt;") does not match the required syntax of a Name.')					expandMacrosWith: anAttribute tag asString					with: v)].	aParser registerID: anAttribute</body></methods><methods><class-id>XML.ID_AT</class-id> <category>testing</category><body package="XML">isID	^true</body></methods><methods><class-id>XML.ENTITIES_AT</class-id> <category>validating</category><body package="XML">completeValidationAgainst: aParser from: anAttributeDef	^anAttributeDef hasDefault		ifTrue: [self validateValueOf: anAttributeDef for: aParser]</body><body package="XML">validateDefinition: anAttributeDefinition for: aParser	^self</body><body package="XML">validateValueOf: anAttribute for: aParser	| v ent all |	super validateValueOf: anAttribute for: aParser.	v := anAttribute value.	(all := self stringAsTokens: v) do: [:nm |		(aParser isValidName: nm)			ifFalse: [aParser invalid: ((#invalidEntitiesAttribute &lt;&lt; #xml &gt;&gt; 'An ENTITIES attribute (&lt;1s&gt;="&lt;2s&gt;") does not match the required syntax of a list of Names.')					expandMacrosWith: anAttribute tag asString					with: v)].		ent := aParser dtd generalEntityAt: nm.		ent == nil			ifTrue: [aParser invalid: ((#attributeUsesUndefinedEntity &lt;&lt; #xml &gt;&gt; 'Undeclared unparsed entity "&lt;1s&gt;" used by attribute type "&lt;2s&gt;"')						expandMacrosWith: nm						with: anAttribute tag asString)]			ifFalse: [ent isParsed				ifTrue: [aParser invalid: ((#parsedEntityTreatedAsUnparsed &lt;&lt; #xml &gt;&gt; 'The entity "&lt;1s&gt;" used by attribute type "&lt;2s&gt;" is a parsed entity and should be unparsed')							expandMacrosWith: nm							with: anAttribute tag asString)]				ifFalse: []]].	all size = 0 ifTrue: [aParser invalid: #EmptyEntities &lt;&lt; #xml &gt;&gt; 'Attribute has empty list of ENTITIES'].</body></methods><methods><class-id>XML.CDATA_AT</class-id> <category>validating</category><body package="XML">validateValueOf: anAttribute for: aParser	^self</body></methods><methods><class-id>XML.InitialPattern</class-id> <category>accessing</category><body package="XML">description	^(followSet asArray collect: [:i | i description]) printString</body><body package="XML">isExternal	^isExternal</body><body package="XML">isExternal: flag	isExternal := flag</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Link</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nextLink </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>Magnitude</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>LargeWordArray</name><environment>Core</environment><super>Core.SegmentedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>