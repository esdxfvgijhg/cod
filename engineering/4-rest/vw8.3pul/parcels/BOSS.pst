<?xml version="1.0"?><st-source><!-- Name: BOSSNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: Contains the Binary Object Streaming Service, which supports efficient storage and retrieval of objects, including code, to and from files.Note that for code storage, the parcel system now supercedes BOSS.Further information on BOSS can be found in the "Application Developer's Guide" (located in the /doc subdirectory of the VisualWorks installation).DbIdentifier: bear73DbTrace: 435926DbUsername: smichaelDbVersion: 8.0 - 3DisregardedPrerequisites: #(#(#name 'DLLCC' #componentType #package))PackageName: BOSSParcel: #('BOSS')ParcelName: BOSSPrintStringCache: (8.0 - 3,smichael)Version: 8.0 - 3Date: 12:42:51 PM June 13, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (jun14.1) of June 6, 2014 on June 13, 2014 at 12:42:51 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>BOSSContents</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><comment><class-id>Kernel.BOSSContents</class-id><body>I hold an object that is normally stored by reference, and force it to write its contents instead.Instance variables:	object	&lt;Class | Metaclass&gt;</body></comment><class><name>AbstractBOSSReaderMap</name><environment>Kernel</environment><super>Core.Array</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>baseIndex storage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><comment><class-id>Kernel.AbstractBOSSReaderMap</class-id><body>This class implements the index-to-object map when reading from a BinaryObjectStorage stream.  This abstract implementation is refined by concrete subclasses to provide functionality needed by the 32 and 64 bit versions of BOSS.Instance Variables	baseIndex	&lt;Integer&gt;  holds objects for this structure	storage	&lt;BinaryObjectStorage&gt;  holds other objects</body></comment><class><name>BOSSSpecialObjectLoader</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>message </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><comment><class-id>Kernel.BOSSSpecialObjectLoader</class-id><body>This class is used for loading objects that need some form of special treatment during loading.  For example, if a Set indirectly contains a reference to itself, when loaded it may be mis-hashed, or may even drop objects completely.  What is instead loaded is a BOSSSpecialObjectLoader that knows how to create a Set.  When all other objects have been resolved, the object loader creates the Set, and becomes it.Because of this #become: operation, it is very important that the object which is created not be an existing object referred to elsewhere.  Thus, this class is something of a loaded gun to be used at your own peril.Also, it won't solve absolutely every case of Set mis-hashing, but merely 90+% of them.  For example, the BOSSSpecialObjectLoader itself may not have the same hash value as the object it represents, so if a Set contains itself, there's no hope.  But didn't Bertrand Russell disallow that?Instance Variables:	message		&lt;MessageSend&gt; message which answers the object for which the instance is a proxy.</body></comment><class><name>BOSSTransporter</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream storage useSource swapBytes baseIndex headers objects recentClasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><comment><class-id>Kernel.BOSSTransporter</class-id><body>BOSSTransporter just factors out a few variables and methods common between BOSSReader and BOSSWriter.  In particular, it holds the shared ByteClasses dictionary.Instance Variables:	stream	&lt;Stream&gt;  for reading or writing the objects	storage	&lt;BinaryObjectStorage&gt;  holding global state	useSource	&lt;Symbol&gt;  write method source and class organization if #keep, discard if #discard, just write pointers if #reference	swapBytes	&lt;Boolean&gt;  if true, swap byte order of multi-byte quantitiesClass Variables:	ByteClasses	&lt;IdentityDictionary key: Behavior value: Boolean&gt;  true means accessing methods mean the same as those of ByteArray; false means not the same, but no byte swapping required</body></comment><class><name>BOSSAbstractWriter</name><environment>Kernel</environment><super>Kernel.BOSSTransporter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bodies currentClass nextRecentClass bodySize nilIndex traceClasses registry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><comment><class-id>Kernel.BOSSAbstractWriter</class-id><body>I write out a single object structure in a rapidly-loadable binary format.  This is the abstract class from which the 32 and 64 bit implementations inherit.Instance Variables	headers	&lt;BOSSBytes&gt;  contains headers for objects being written	bodies	&lt;Array&gt;  bodies and classes of objects being written	objects	&lt;IdentityDictionary of: (Object -&gt; Integer)&gt;  map from objects to indices	baseIndex	&lt;Integer&gt;  index of first object being written	currentClass	&lt;ClassDescription&gt;  class for reverse-resolving Associations	recentClasses	&lt;Array size: 15&gt;  ring buffer of recently used classes	nextRecentClass	&lt;Integer between: 1 and: 15&gt;  next index for storing in ring buffer	bodySize	&lt;Integer&gt;  total space for object bodies	nilIndex	&lt;nil | Integer&gt;  object index for nil	traceClasses	&lt;IdentityDictionary of: (Behavior -&gt; Symbol)&gt;  selectors for tracing specific classes	registry	&lt;OrderedCollection of: BOSSRegisteredObject&gt;The swapBytes instance variable is only needed for the case where we are appending to a file that was written on a platform with a different byte order.See the documentation category in the class methods for more information about the file format.Non-negative values in the objects dictionary are encoded oops (header indices * 4) for objects that have been fully written.  -1 is reserved.  -2 means that this object is currently in the process of being written: if we encounter a -2, we assign an object index on the spot.  This ensures that any object not involved in a circular reference will be written after all objects it references.  Other negative indices indicate registered objects, the first being -3.  Positive entries are strictly a cache for the writerMap in the BinaryObjectStorage.Individual tracing/writing methods return one of three values:	- nil, meaning use the standard representation;	- an Association (integer -&gt; object), indicating that the object (in the form of either a ByteString or an Array) will be passed to a special import method with the given index;	- an array of (receiver selector arg1 ... argn), indicating that the object will be constructed at read time by sending the given message.Internal methods of BOSSWriter can also return an integer, giving the object index.</body></comment><class><name>BOSSWriter</name><environment>Kernel</environment><super>Kernel.BOSSAbstractWriter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><comment><class-id>Kernel.BOSSWriter</class-id><body>I write out a single object structure in a rapidly-loadable binary format.  This is the 32 bit implementation.Instance Variables	headers	&lt;BOSSBytes&gt;  contains headers for objects being written	bodies	&lt;Array&gt;  bodies and classes of objects being written	objects	&lt;IdentityDictionary of: (Object -&gt; Integer)&gt;  map from objects to indices	baseIndex	&lt;Integer&gt;  index of first object being written	currentClass	&lt;ClassDescription&gt;  class for reverse-resolving Associations	recentClasses	&lt;Array size: 15&gt;  ring buffer of recently used classes	nextRecentClass	&lt;Integer between: 1 and: 15&gt;  next index for storing in ring buffer	bodySize	&lt;Integer&gt;  total space for object bodies	nilIndex	&lt;nil | Integer&gt;  object index for nil	traceClasses	&lt;IdentityDictionary of: (Behavior -&gt; Symbol)&gt;  selectors for tracing specific classes	registry	&lt;OrderedCollection of: BOSSRegisteredObject&gt;The swapBytes instance variable is only needed for the case where we are appending to a file that was written on a platform with a different byte order.See the documentation category in the class methods for more information about the file format.Non-negative values in the objects dictionary are encoded oops (header indices * 4) for objects that have been fully written.  -1 is reserved.  -2 means that this object is currently in the process of being written: if we encounter a -2, we assign an object index on the spot.  This ensures that any object not involved in a circular reference will be written after all objects it references.  Other negative indices indicate registered objects, the first being -3.  Positive entries are strictly a cache for the writerMap in the BinaryObjectStorage.Individual tracing/writing methods return one of three values:	- nil, meaning use the standard representation;	- an Association (integer -&gt; object), indicating that the object (in the form of either a ByteString or an Array) will be passed to a special import method with the given index;	- an array of (receiver selector arg1 ... argn), indicating that the object will be constructed at read time by sending the given message.Internal methods of BOSSWriter can also return an integer, giving the object index.</body></comment><class><name>BOSSAbstractReader</name><environment>Kernel</environment><super>Kernel.BOSSTransporter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>readingClasses compiledCode deferredSends </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><comment><class-id>Kernel.BOSSAbstractReader</class-id><body>I read a single object structure that was stored in a rapidly-loadable binary format.  This is the abstract class from which 32 and 64 bit implementations inherit.Instance Variables	readingClasses	&lt;Boolean&gt;  true if reading classes, false if reading ordinary objects	headers	&lt;BOSSBytes&gt;  contains headers for objects being written	objects	&lt;BOSSReaderMap&gt;  map indices to objects	baseIndex	&lt;Integer&gt;  index of first object in structure	recentClasses	&lt;OrderedCollection size: 15&gt;  recently used classes	compiledCode	&lt;OrderedCollection of: Array&gt;  compiled code needing sources to be fixed up	deferredSends	&lt;OrderedCollection of: MessageSend&gt; evaluations that should not be performed until the compiledCode has been fixed up, along with any other cleanupClass Variables	XeroxMap		&lt;LargeArray&gt; mapping from XCCS code points to Unicode code points. Because of 1-based indexing, add 1 to the XCCS value to find the right Unicode value. If a value maps to nil, the mapping is unknown--this does not mean that there is no mapping, only that the patch does not supply it.Odd-numbered imports have bit-type data, even-numbered have pointer-type.</body></comment><class><name>BOSSReader</name><environment>Kernel</environment><super>Kernel.BOSSAbstractReader</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><comment><class-id>Kernel.BOSSReader</class-id><body>This class reads a single object structure that was stored in a rapidly-loadable binary format.  This is the 32 bit implementation.Instance Variables	readingClasses	&lt;Boolean&gt;  true if reading classes, false if reading ordinary objects	headers	&lt;BOSSBytes&gt;  contains headers for objects being written	objects	&lt;BOSSReaderMap&gt;  map indices to objects	baseIndex	&lt;Integer&gt;  index of first object in structure	recentClasses	&lt;OrderedCollection size: 15&gt;  recently used classes	compiledCode	&lt;OrderedCollection of: Array&gt;  compiled code needing sources to be fixed up	deferredSends	&lt;OrderedCollection of: MessageSend&gt; evaluations that should not be performed until the compiledCode has been fixed up, along with any other cleanupClass Variables	XeroxMap		&lt;LargeArray&gt; mapping from XCCS code points to Unicode code points. Because of 1-based indexing, add 1 to the XCCS value to find the right Unicode value. If a value maps to nil, the mapping is unknown--this does not mean that there is no mapping, only that the patch does not supply it.Odd-numbered imports have bit-type data, even-numbered have pointer-type.</body></comment><class><name>BOSSRegisteredObject</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name valueBlock writerClass value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><comment><class-id>Kernel.BOSSRegisteredObject</class-id><body>I hold an object that has been registered for reverse-resolution at BOSS writing time.  I hold a block for computing the value, rather than the value itself, so that BOSS doesn't need to worry about the changes in the values of global variables.Instance Variables:	name	&lt;Symbol&gt;  the object name	valueBlock	&lt;BlockClosure argument: Symbol&gt;  the block to compute the value	writerClass	&lt;SmallInteger&gt;  the special reader index	value	&lt;Object&gt;  cache the value</body></comment><class><name>BOSSCompiledCodeHolder</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class selector category codeClass codeContents source </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><comment><class-id>Kernel.BOSSCompiledCodeHolder</class-id><body>I hold a compiled method that has been read in and is awaiting installation.Instance Variables:	class	&lt;ClassDescription | nil&gt;  the class in which the method will be installed, if any	selector	&lt;Symbol | nil&gt;  the selector for the method, if any	category	&lt;String | nil&gt;  the category for the method, if any	codeClass	&lt;CompiledCode class&gt;  the actual class of the method	codeContents	&lt;Object | CompiledMethod&gt;  the instance variables of the method, as an array	source	&lt;nil | Integer | String&gt;  the source code</body></comment><class><name>BOSSReader32</name><environment>Kernel</environment><super>Kernel.BOSSReader</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><comment><class-id>Kernel.BOSSReader32</class-id><body>This class reads a single object structure that was stored in a rapidly-loadable binary format.  This is the 32 bit implementation that runs on 64 bit images.  It converts large integers and doubles to small integers and small doubles when possible.Instance Variables	readingClasses	&lt;Boolean&gt;  true if reading classes, false if reading ordinary objects	headers	&lt;BOSSBytes&gt;  contains headers for objects being written	objects	&lt;BOSSReaderMap&gt;  map indices to objects	baseIndex	&lt;Integer&gt;  index of first object in structure	recentClasses	&lt;OrderedCollection size: 15&gt;  recently used classes	compiledCode	&lt;OrderedCollection of: Array&gt;  compiled code needing sources to be fixed up	deferredSends	&lt;OrderedCollection of: MessageSend&gt; evaluations that should not be performed until the compiledCode has been fixed up, along with any other cleanupClass Variables	XeroxMap		&lt;LargeArray&gt; mapping from XCCS code points to Unicode code points. Because of 1-based indexing, add 1 to the XCCS value to find the right Unicode value. If a value maps to nil, the mapping is unknown--this does not mean that there is no mapping, only that the patch does not supply it.Odd-numbered imports have bit-type data, even-numbered have pointer-type.</body></comment><class><name>BOSSWriter32</name><environment>Kernel</environment><super>Kernel.BOSSWriter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thirtyTwoBitObjects </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><comment><class-id>Kernel.BOSSWriter32</class-id><body>This special 32 bit BOSSWriter works on 64 bit images.  It converts immediate objects into a suitable 32 bit representation, and maintains the identity of these counterparts during the writing process.Instance Variables	thirtyTwoBitObjects	&lt;IdentityDictionary&gt;	32 bit equivalent of 64 bit immediate objects</body></comment><class><name>AbstractBinaryObjectStorage</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream platformDescription initialPosition readerClass writerClass sourceMode readerMap writerMap nextIndex registry versionReaders classVarLists expectCycles mapXeroxToUnicode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><comment><class-id>Kernel.AbstractBinaryObjectStorage</class-id><body>AbstractBinaryObjectStorage provides for writing object structures on a stream in a compact, rapidly loadable binary format, and reading them back in again.  Instances of this class only hold the state that persists between successive reading or writing operations: each such operation creates a transient instance of BOSSReader or BOSSWriter to hold the temporary state of the reading or writing process.  This class provides a repository for behavior shared between the 32 and 64 bit implementations of BOSS.Instance Variables	stream	&lt;PositionableStream&gt;  stream for reading or writing object structures	platformDescription	&lt;ByteArray&gt;  description of platform where objects were written	initialPosition	&lt;Integer&gt;  position of first object structure	readerClass	&lt;BOSSReader class&gt;  class to instantiate to read a structure	writerClass	&lt;BOSSWriter class&gt;  class to instantiate to write a structure	sourceMode	&lt;Symbol&gt;  #keep, #discard, or #reference	readerMap	&lt;IdentityDictionary key: SmallInteger value: Object&gt;  map from object indices to objects	writerMap	&lt;IdentityDictionary key: Object value: SmallInteger&gt;  map from objects to indices	nextIndex	&lt;Integer&gt;  next object index to be assigned (a multiple of 4)	registry	&lt;OrderedCollection of: BOSSRegisteredObject&gt;	versionReaders	&lt;IdentityDictionary of: (Behavior -&gt; BlockClosure)&gt;  how to handle obsolete versions	classVarLists	&lt;IdentityDictionary of: (Behavior -&gt; (Array | nil))&gt;  lists of the names of all named instance variables for each class in the image that created the file.	expectCycles	&lt;Boolean&gt; controls policy concerning how cautious certain classes should be in storing themselves in a way that does not break due to pointer cycles	mapXeroxToUnicode		&lt;Boolean | nil&gt; nil is treated as false. If true, then a BOSSReader will attempt to transform Strings and Characters from XCCS encoding to Unicode. This may fail for strings that contain unusual characters.Class Variables	BinaryErrorSignal	&lt;Signal&gt;  Holds the signal used to report unexpected error conditions encountered while inside BOSS.	FormatErrorSignal	&lt;Signal&gt;  Holds the signal used to report an unknown format when reading a BOSS stream.	HeaderErrorSignal	&lt;Signal&gt;  Holds the signal used to report an unknown header when reading a BOSS stream.	ShouldUpdateRegistryObjects &lt;Boolean&gt; Configuration switch to cache resolved globals such as #Smalltalk or #Processor.  By default it is turned off.  You may want to consider turning it on when writing many small objects one at a time.	RegistryObjectCache &lt;Dictionary&gt; Holds the cache for the switch mentioned above.</body></comment><class><name>BinaryObjectStorage</name><environment>Kernel</environment><super>Kernel.AbstractBinaryObjectStorage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><comment><class-id>Kernel.BinaryObjectStorage</class-id><body>BinaryObjectStorage provides for writing object structures on a stream in a compact, rapidly loadable binary format, and reading them back in again.  Instances of this class only hold the state that persists between successive reading or writing operations: each such operation creates a transient instance of BOSSReader or BOSSWriter to hold the temporary state of the reading or writing process.  This class implements the 32 bit implementation of BOSS.Instance Variables	stream	&lt;PositionableStream&gt;  stream for reading or writing object structures	platformDescription	&lt;ByteArray&gt;  description of platform where objects were written	initialPosition	&lt;Integer&gt;  position of first object structure	readerClass	&lt;BOSSReader class&gt;  class to instantiate to read a structure	writerClass	&lt;BOSSWriter class&gt;  class to instantiate to write a structure	sourceMode	&lt;Symbol&gt;  #keep, #discard, or #reference	readerMap	&lt;IdentityDictionary key: SmallInteger value: Object&gt;  map from object indices to objects	writerMap	&lt;IdentityDictionary key: Object value: SmallInteger&gt;  map from objects to indices	nextIndex	&lt;Integer&gt;  next object index to be assigned (a multiple of 4)	registry	&lt;OrderedCollection of: BOSSRegisteredObject&gt;	versionReaders	&lt;IdentityDictionary of: (Behavior -&gt; BlockClosure)&gt;  how to handle obsolete versions	classVarLists	&lt;IdentityDictionary of: (Behavior -&gt; (Array | nil))&gt;  lists of the names of all named instance variables for each class in the image that created the file.	expectCycles	&lt;Boolean&gt; controls policy concerning how cautious certain classes should be in storing themselves in a way that does not break due to pointer cycles	mapXeroxToUnicode		&lt;Boolean | nil&gt; nil is treated as false. If true, then a BOSSReader will attempt to transform Strings and Characters from XCCS encoding to Unicode. This may fail for strings that contain unusual characters.Class Variables	BinaryErrorSignal	&lt;Signal&gt;  comment	FormatErrorSignal	&lt;Signal&gt;  comment	HeaderErrorSignal	&lt;Signal&gt;  comment</body></comment><class><name>BOSSBytes</name><environment>Kernel</environment><super>Core.ByteArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><comment><class-id>Kernel.BOSSBytes</class-id><body>I add (some of) UninterpretedBytes accessing protocol to ByteArray.  Unlike UninterpretedBytes, I do not attempt to recover from primitive failure: BOSS never invokes these operations with arguments needing coercion, and all the primitives are implemented.See UninterpretedBytes for the documentation of the methods copied from it.</body></comment><class><name>BOSSReaderMap</name><environment>Kernel</environment><super>Kernel.AbstractBOSSReaderMap</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Binary Storage</category><attributes><package>BOSS</package></attributes></class><comment><class-id>Kernel.BOSSReaderMap</class-id><body>This class implements the index-to-object map when reading from a BinaryObjectStorage stream.  Objects with indices in [baseIndex..baseIndex+(self size-1*4)] are stored directly; objects with other indices are looked up in the BinaryObjectStorage.  Note that indices are 0-origin multiples of 4.Instance Variables	baseIndex	&lt;Integer&gt;  holds objects for this structure	storage	&lt;BinaryObjectStorage&gt;  holds other objects</body></comment><shared-variable><name>XeroxMap</name><environment>Kernel.BOSSAbstractReader</environment><private>false</private><constant>false</constant><category>character maps</category><initializer>nil</initializer><attributes><package>BOSS</package></attributes></shared-variable><shared-variable><name>BinaryErrorSignal</name><environment>Kernel.AbstractBinaryObjectStorage</environment><private>false</private><constant>false</constant><category>signals</category><initializer>nil</initializer><attributes><package>BOSS</package></attributes></shared-variable><shared-variable><name>HeaderErrorSignal</name><environment>Kernel.AbstractBinaryObjectStorage</environment><private>false</private><constant>false</constant><category>signals</category><initializer>nil</initializer><attributes><package>BOSS</package></attributes></shared-variable><shared-variable><name>ShouldUpdateRegistryObjects</name><environment>Kernel.AbstractBinaryObjectStorage</environment><private>false</private><constant>false</constant><category>configuration</category><initializer>true</initializer><attributes><package>BOSS</package></attributes></shared-variable><shared-variable><name>FormatErrorSignal</name><environment>Kernel.AbstractBinaryObjectStorage</environment><private>false</private><constant>false</constant><category>signals</category><initializer>nil</initializer><attributes><package>BOSS</package></attributes></shared-variable><shared-variable><name>RegistryObjectCache</name><environment>Kernel.AbstractBinaryObjectStorage</environment><private>false</private><constant>false</constant><category>configuration</category><initializer>nil</initializer><attributes><package>BOSS</package></attributes></shared-variable><shared-variable><name>BinaryErrorSignal</name><environment>Kernel.BinaryObjectStorage</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>BOSS</package></attributes></shared-variable><shared-variable><name>FormatErrorSignal</name><environment>Kernel.BinaryObjectStorage</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>BOSS</package></attributes></shared-variable><shared-variable><name>HeaderErrorSignal</name><environment>Kernel.BinaryObjectStorage</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>BOSS</package></attributes></shared-variable><shared-variable><name>ByteClasses</name><environment>Kernel.BOSSTransporter</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>BOSS</package></attributes></shared-variable><shared-variable><name>XeroxMap</name><environment>Kernel.BOSSReader</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>BOSS</package></attributes></shared-variable><methods><class-id>Kernel.BOSSContents</class-id> <category>initialize</category><body package="BOSS">object: anObject	object := anObject</body></methods><methods><class-id>Kernel.BOSSContents</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	^object representContentsBinaryOn: binWriter</body></methods><methods><class-id>Kernel.AbstractBOSSReaderMap</class-id> <category>initialize-release</category><body package="BOSS">baseIndex: base	"Subtract 1 because indexing is 0-based"	baseIndex := (base bitShift: 0 - self bitsPerIndex) - 1</body><body package="BOSS">storage: aBOSS	storage := aBOSS</body></methods><methods><class-id>Kernel.AbstractBOSSReaderMap</class-id> <category>private</category><body package="BOSS">primitiveAt: index	&lt;primitive: 60&gt;	^storage objectAtIndex: (index + baseIndex bitShift: self bitsPerIndex)</body></methods><methods><class-id>Kernel.AbstractBOSSReaderMap</class-id> <category>private - accessing</category><body package="BOSS">at: index put: value	"This only works for in-range indices"	storage atIndex: index put: value.	^self basicAt: (index bitShift: 0 - self bitsPerIndex) - baseIndex put: value</body><body package="BOSS">bitsPerIndex	self subclassResponsibility</body><body package="BOSS">bytesPerLongOop	self subclassResponsibility</body><body package="BOSS">size	^super size + baseIndex + 1</body></methods><methods><class-id>Kernel.AbstractBOSSReaderMap</class-id> <category>accessing</category><body package="BOSS">at: index	"This handles out-of-range indices by trying an access to the array0"	^self primitiveAt: (index bitShift: 0 - self bitsPerIndex) - baseIndex</body><body package="BOSS">basicAt: anIndex put: anObject	^super at: anIndex put: anObject</body><body package="BOSS">mapXeroxToUnicode	"Answer whether the reader should map characters from	Xerox encoding to Unicode encoding.	Note that only Characters, ByteStrings, and TwoByteStrings	need to be mapped. Other kinds of strings use a non-standard	encoding table, and are insulated from this change."	^storage mapXeroxToUnicode</body></methods><methods><class-id>Kernel.AbstractBOSSReaderMap class</class-id> <category>instance creation</category><body package="BOSS">new: count baseIndex: baseIndex	^(self basicNew: count)		baseIndex: baseIndex;		yourself</body></methods><methods><class-id>Kernel.BOSSSpecialObjectLoader</class-id> <category>accessing</category><body package="BOSS">message: msgSend 	"Set the message that the receiver will use to create a new object. In 	order to work, the message MUST create and return a new object, 	rather than returning an existing object. The act of getting rid of the 	receiver uses a #become:, which would mess up badly existing 	references to the object returned."	message := msgSend</body></methods><methods><class-id>Kernel.BOSSSpecialObjectLoader</class-id> <category>resolving</category><body package="BOSS">resolve	"The system has been stabilized somewhat.  It is now possible	to create the actual object, who should now be able to trust	information such as hash values."	^self become: message value</body></methods><methods><class-id>Kernel.BOSSSpecialObjectLoader class</class-id> <category>instance creation</category><body package="BOSS">message: msgSend 	"Create a new object loader, which will use the message to create an 	object. In order to work, the message MUST create and return a new 	object, rather than returning an existing object. The act of getting rid 	of the receiver uses a #become:, which would mess up badly 	existing references to the object returned."	^self new message: msgSend</body></methods><methods><class-id>Kernel.BOSSTransporter</class-id> <category>private-initialize-release</category><body package="BOSS">storage: aBOS on: aStream	storage := aBOS.	stream := aStream.	useSource := aBOS sourceMode.	swapBytes := aBOS isBigEndian ~= UninterpretedBytes isBigEndian</body></methods><methods><class-id>Kernel.BOSSTransporter</class-id> <category>private-flags</category><body package="BOSS">flagsBits: flags	^flags anyMask: AbstractBinaryObjectStorage flagIsBits</body><body package="BOSS">flagsForwardReferences: flags	^flags anyMask: AbstractBinaryObjectStorage flagHasForwardReferences</body><body package="BOSS">flagsImmutable: flags	^flags anyMask: AbstractBinaryObjectStorage flagIsImmutable</body><body package="BOSS">flagsRecentClass: flags	^flags anyMask: AbstractBinaryObjectStorage flagRecentClassMask</body><body package="BOSS">flagsShortOops: flags	^flags anyMask: AbstractBinaryObjectStorage flagHasShortOops</body><body package="BOSS">numberOfRecentClasses	^AbstractBinaryObjectStorage flagRecentClassMask</body><body package="BOSS">recentClassIndexFrom: flags	^flags bitAnd: AbstractBinaryObjectStorage flagRecentClassMask</body></methods><methods><class-id>Kernel.BOSSTransporter</class-id> <category>private-constants</category><body package="BOSS">bytesPerHeader	self subclassResponsibility</body><body package="BOSS">bytesPerLongOop	self subclassResponsibility</body><body package="BOSS">bytesPerShortOop	^2</body></methods><methods><class-id>Kernel.BOSSTransporter</class-id> <category>private-oops</category><body package="BOSS">longOops: anObjectat: anIndexput: aValue	self subclassResponsibility</body><body package="BOSS">swapLongOopsIn: anObject	self subclassResponsibility</body><body package="BOSS">swapShortOopsIn: anObject	swapBytes ifTrue: [anObject twoByteEndiannessSwap]</body></methods><methods><class-id>Kernel.BOSSTransporter</class-id> <category>private-headers</category><body package="BOSS">swapIndentityHashHeaderBytes	self subclassResponsibility</body></methods><methods><class-id>Kernel.BOSSTransporter class</class-id> <category>class initialization</category><body package="BOSS">initialize	"BOSSTransporter initialize"	ByteClasses := IdentityDictionary new: 10.	ByteClasses		at: ByteArray put: true;		at: ByteString put: false;		at: ByteSymbol put: false</body></methods><methods><class-id>Kernel.BOSSTransporter class</class-id> <category>instance creation</category><body package="BOSS">new	^super new initialize</body></methods><methods><class-id>Kernel.BOSSAbstractWriter</class-id> <category>private</category><body package="BOSS">assign: anObject	" Record anObject in the objects dictionary,	and return its assigned index. "	| objx |	objx := storage assignIndexFor: anObject.	objects at: anObject put: objx.  "overwrite the -2"	self growHeadersAndBodiesCheckWith: objx.	^objx &gt;= (baseIndex + self shortOopLimit)		ifTrue: [objx]		ifFalse: [objx - baseIndex + 2]</body><body package="BOSS">encode: anObject	self subclassResponsibility</body><body package="BOSS">encodeNonImmediateObject: anObject	| objx |	anObject == nil ifTrue: [^nilIndex].	objx := objects at: anObject ifAbsent: [nil].	objx == nil ifTrue: [objx := storage indexOf: anObject].	objx == nil ifTrue: [^nil].	(objx &gt;= baseIndex and: [objx &lt; (baseIndex + self shortOopLimit)])		ifTrue: [^objx - baseIndex + 2].	^objx</body><body package="BOSS">growHeadersAndBodiesCheckWith: aLongOop	| needsToGrow |	needsToGrow := aLongOop - baseIndex // self bytesPerLongOop * self bytesPerHeader &gt;= headers size.	needsToGrow ifFalse: [^self].	headers := headers , (BOSSBytes new: headers size).	bodies := bodies , (Array new: bodies size)</body><body package="BOSS">record: anObject body: body class: aClass flags: flags index: objx	" Record the header and body for anObject,	and accumulate the body size. "	| class newFlags osize localx oop cx shortClass bx |	class := body class.	newFlags := flags.	oop := (self flagsShortOops: newFlags) ifTrue: [self bytesPerShortOop] ifFalse: [self bytesPerLongOop].	cx := self encode: aClass.	shortClass := (self flagsForwardReferences: newFlags)		ifTrue: [-1]		ifFalse: [recentClasses indexOf: cx].	shortClass &lt;= 0		ifTrue:			[((cx bitAnd: self shortOopMask) ~= 0 and: [oop = self bytesPerShortOop])				ifTrue: [newFlags := newFlags - AbstractBinaryObjectStorage flagHasShortOops.  oop := self bytesPerLongOop].			bodySize := bodySize + oop.			shortClass = 0 ifTrue:				[nextRecentClass := nextRecentClass = 1					ifTrue: [recentClasses size]					ifFalse: [nextRecentClass - 1].				recentClasses at: nextRecentClass put: cx]]		ifFalse:			[shortClass := shortClass - nextRecentClass + 1.			shortClass &lt;= 0 ifTrue: [shortClass := shortClass + recentClasses size].			newFlags := newFlags + shortClass].	osize := class isBits		ifTrue: [newFlags := newFlags + AbstractBinaryObjectStorage flagIsBits.  body basicSize]		ifFalse: [(self oopsInBody: body ofClass: class) * oop].	osize &gt;= 16rFF ifTrue: [bodySize := bodySize + self bytesToWriteExcessBodySize].	localx := (objx anyMask: 2)		ifTrue: [objx - 2]		ifFalse: [objx - baseIndex].	anObject isImmutable ifTrue:		[newFlags := newFlags + AbstractBinaryObjectStorage flagIsImmutable].	self		headersAt: localx		put: newFlags		object: anObject		size: osize.	bx := localx * 2 // self bytesPerLongOop.	bodies at: bx + 1 put: body.	shortClass &lt;= 0 ifTrue: [bodies at: bx + 2 put: cx].	bodySize := bodySize + osize</body><body package="BOSS">write: body class: cx flags: flags	(self flagsShortOops: flags)		ifTrue: [self writeShortBody: body class: cx flags: flags]		ifFalse: [self writeLongBody: body class: cx flags: flags]</body><body package="BOSS">writeBitsBody: body	| byteType osize |	osize := body basicSize.	self writeExcessBodyLength: osize.	byteType := ByteClasses at: body class ifAbsent: [nil].	byteType == true		ifTrue: [stream nextPutAll: body]		ifFalse:			[				| bits |				(byteType == nil and: [swapBytes])					ifTrue:						[							bits := body shallowCopy.							bits reverseByteOrder.							bits changeClassTo: BOSSBytes						]					ifFalse:						[							bits := BOSSBytes new: osize.							bits replaceBytesFrom: 1 with: body						].				stream nextPutAll: bits			]</body><body package="BOSS">writeBodyLength: bodyLength	self subclassResponsibility</body><body package="BOSS">writeExcessBodyLength: bodyLength	bodyLength &lt; 16rFF ifTrue: [^self].	self writeBodyLength: bodyLength</body><body package="BOSS">writeIndexOnly: anObject	self subclassResponsibility</body><body package="BOSS">writeLongBody: body	| class osize bits pos |	class := body class.	osize := (self oopsInBody: body ofClass: class) * self bytesPerLongOop.	self writeExcessBodyLength: osize.	bits := BOSSBytes new: osize.	pos := 1.	1 to: osize // self bytesPerLongOop do:		[:i |			| enc |			enc := self encode: (body instVarAt: i).			self longOops: bits at: pos put: enc.			pos := pos + self bytesPerLongOop		].	self swapLongOopsIn: bits.	stream nextPutAll: bits</body><body package="BOSS">writeLongBody: body class: cx flags: flags	self subclassResponsibility</body><body package="BOSS">writeLongBody: body flags: flags	| class |	class := body class.	class isBits		ifTrue: [self writeBitsBody: body]		ifFalse: [self writeLongBody: body]</body><body package="BOSS">writeShortBody: body	| class osize bits pos |	class := body class.	osize := (self oopsInBody: body ofClass: class) * self bytesPerShortOop.	self writeExcessBodyLength: osize.	bits := BOSSBytes new: osize.	pos := 1.	1 to: osize // self bytesPerShortOop do:		[:i |			| enc |			enc := self encode: (body instVarAt: i).			self shortOops: bits at: pos put: enc.			pos := pos + self bytesPerShortOop		].	self swapShortOopsIn: bits.	stream nextPutAll: bits</body><body package="BOSS">writeShortBody: body class: cx flags: flags	| class |	(self flagsRecentClass: flags) ifFalse: [self writeUnsignedShort: cx].	class := body class.	class isBits		ifTrue: [self writeBitsBody: body]		ifFalse: [self writeShortBody: body]</body></methods><methods><class-id>Kernel.BOSSAbstractWriter</class-id> <category>private-headers</category><body package="BOSS">headersAt: localxput: flagsobject: anObjectsize: objectSize	self subclassResponsibility</body></methods><methods><class-id>Kernel.BOSSAbstractWriter</class-id> <category>private-tracing</category><body package="BOSS">nextPut: topObject do: traceBlock	" Put out an object, but evaluate traceBlock first. "	| nextIndex count |	(topObject isImmediate or: [(storage indexOf: topObject) notNil])		ifTrue: [^self writeIndexOnly: topObject].	baseIndex := storage nextIndex.	traceBlock value.	self trace: topObject.	nextIndex := storage nextIndex.	count := nextIndex - baseIndex // self bytesPerLongOop.	self nextPut: topObject withTracedObjectCount: count</body><body package="BOSS">nextPut: topObject withTracedObjectCount: count	count = 0		ifTrue:			[" Top object was aliased (probably to nil). "			^self writeIndexOnly: topObject].	count = 1		ifTrue: [self writeSingleLongOop: baseIndex + 2]		ifFalse:			[				self					writeLongOop: baseIndex + 2					storageIndex: (storage indexOf: topObject)					count: count					bodySize: bodySize			].	self writeBodiesAndHeaders: count</body><body package="BOSS">trace: anObject	" Recursively trace anObject.  Return the encoding of the object. "	| objectIndex |	objectIndex := self traceIndexFor: anObject.	objectIndex &gt;= 0 ifTrue: [^objectIndex].	objectIndex = -1 ifTrue: [^self traceNewOrImmediate: anObject].	objectIndex = -2 ifTrue:		[			" Circular / recursive reference.  Assign the index now; the correct			flags and body will be supplied when we return out of the recursion. "			^self assign: anObject		].	" Registered object. "	^(registry at: -2 - objectIndex) traceOn: self</body><body package="BOSS">trace: anObject body: body class: aClass	" Record anObject in the objects dictionary,	and trace its dependents and body if needed.	The caller has already traced the class. "	| class objx deps |	deps := anObject isBehavior		ifTrue: [nil]		ifFalse: [DependentsFields at: anObject ifAbsent: [nil]].	class := body class.	(class isBits and: [deps == nil]) ifTrue:		[			objx := self assign: anObject.			self record: anObject body: body class: aClass flags: 0 index: objx.			^objx		].	" Recursively trace the contents of the body.	If the object has circular references,	the trace may assign the object index. "	anObject == nil ifFalse: [objects at: anObject put: -2].	self traceDependents: deps of: anObject.	^self traceThrough: anObject body: body class: aClass</body><body package="BOSS">traceAssociation: assoc	" If the association can be reverse-resolved,	represent it as its name, otherwise represent	it as its contents. "	^((currentClass fullBindingFor: assoc key) == assoc or:			[(Undeclared bindingFor: assoc key) == assoc])		ifTrue: [AbstractBinaryObjectStorage indexImportAssociation -&gt;					(Array with: currentClass with: assoc key)]		ifFalse: [nil]</body><body package="BOSS">traceDependents: deps of: anObject	deps isNil ifTrue: [^self].	self		trace: (anObject -&gt; deps)		body: (Array with: anObject with: #myDependents: with: deps)		class: AbstractBinaryObjectStorage indexImportSend</body><body package="BOSS">traceIndexFor: anObject	anObject == nil ifTrue: [^nilIndex].	^objects		at: anObject		ifAbsent:			[				| index |				index := storage indexOf: anObject.				index notNil					ifTrue: [objects at: anObject put: index]					ifFalse: [-1]			]</body><body package="BOSS">traceNewOrImmediate: anObject	| selector value |	selector := traceClasses at: anObject class ifAbsent: [#traceUnknown:].	value := selector == #represent:		ifTrue: [self traceRepresent: anObject]		ifFalse: [self perform: selector with: anObject].	value == nil ifTrue:  "use standard representation"		[			self trace: anObject class.			^self trace: anObject body: anObject class: anObject class		].	value isInteger ifTrue: [^value].  "internal method returned objx"	" Trace a generic object with special handling. "	(value isMemberOf: Association) ifTrue:  "special reader index"		[			"Check to make sure that the representation			is minimally compatible with the index. "			| index arg |			index := value key.			arg := value value.			arg class isBits = index odd ifFalse:				[self error: 'Incompatible representation'.  ^nil].			^self trace: anObject body: arg class: index		].	^self		trace: anObject		body: (Array with: value receiver with: value selector) , value arguments		class: AbstractBinaryObjectStorage indexImportSend</body><body package="BOSS">traceRepresent: anObject	| value |	value := self represent: anObject.	value isImmediate ifFalse: [^value].	value isInteger ifFalse: [^value].	" A special representation method might have	been invoked.  Check whether the return value	is actually a correct object index. "	value = nilIndex		ifTrue: [objects at: anObject put: value]  " Substitute nil for the object. "		ifFalse:			[				| valueCheck |				valueCheck := (value anyMask: 2)					ifTrue: [value - 2 + baseIndex]					ifFalse: [value].				(objects at: anObject ifAbsent: [nil]) = valueCheck ifFalse:					[						self error: 'Immediate representation is not allowed'.						value := nil					]			].	^value</body><body package="BOSS">traceSkip: anObject	" Encode immediate objects directly. "	^self encode: anObject</body><body package="BOSS">traceThrough: anObject body: body class: aClass	| class flags objx |	class := body class.	flags := AbstractBinaryObjectStorage flagHasShortOops.	class isBits ifFalse:		[			1 to: class instSize do:				[:i |					| oop |					oop := self trace: (body instVarAt: i).					(oop bitAnd: self shortOopMask) = 0 ifFalse: [flags := 0]				].			class isVariable ifTrue:				[					1 to: body basicSize do:						[:i |							| oop |							oop := self trace: (body basicAt: i).							(oop bitAnd: self shortOopMask) = 0 ifFalse: [flags := 0]						]				]		].	objx := self encode: anObject.	objx &lt; 0		ifTrue: [objx := self assign: anObject]		ifFalse: [flags := flags + AbstractBinaryObjectStorage flagHasForwardReferences].	self record: anObject body: body class: aClass flags: flags index: objx.	^objx</body><body package="BOSS">traceUnknown: anObject	" anObject is the first object of its class	encountered so far.  Determine and record	how to trace objects of this class in the future. "	traceClasses at: anObject class put: (self traceSelectorFor: anObject).	^self trace: anObject</body><body package="BOSS">writeBodiesAndHeaders: count	self swapIndentityHashHeaderBytes.	stream nextPutAll: (headers copyFrom: 1 to: count * self bytesPerHeader).	1 to: count * 2 by: 2 do:		[:eachIndex |			self				write: (bodies at: eachIndex)				class: (bodies at: eachIndex + 1)				flags: (headers byteAt: eachIndex // 2 * self bytesPerHeader + 1)		]</body></methods><methods><class-id>Kernel.BOSSAbstractWriter</class-id> <category>private-constants</category><body package="BOSS">bytesToWriteExcessBodySize	^self bytesPerLongOop</body><body package="BOSS">shortOopLimit	^16r10000</body><body package="BOSS">shortOopMask	^-16r10000</body></methods><methods><class-id>Kernel.BOSSAbstractWriter</class-id> <category>representation</category><body package="BOSS">represent: anObject	" This is the representation method for	otherwise undistinguished objects.	The default is to ask the object itself	what representation to use. "	^anObject representBinaryOn: self</body><body package="BOSS">representCompiledMethod: aCompiledMethod	" This is the representation method for	compiled code objects, invoked from	CompiledMethod&gt;&gt;representBinaryOn:.	It manages the saving and restoring of	the source code or source pointer. "	| obj src cls sel cat |	obj := aCompiledMethod shallowCopy.	src := obj sourcePointer.	obj sourcePointer: nil.	sel := currentClass selectorAtMethod: aCompiledMethod setClass: [:c |] ifAbsent: [nil].	cls := aCompiledMethod mclass.	cat := Object errorSignal			handle: [:ex | ex returnWith: nil]			do: [cls whichCategoryIncludesSelector: sel].	src notNil ifTrue:		[useSource == #keep			ifTrue: [src := aCompiledMethod getSource]			ifFalse:				[useSource == #reference					ifFalse: [src := nil]]].	^AbstractBinaryObjectStorage indexImportCompiledCode -&gt;		(BOSSCompiledCodeHolder new			class: cls			selector: sel			category: cat			codeClass: aCompiledMethod class			codeContents: (obj changeClassToThatOf: #())			source: src)</body><body package="BOSS">representContext: aContext	"This is the representation method for Contexts, invoked from	 Context&gt;&gt;representBinaryOn:. It manages the saving and restoring of	 the current class. "	 "Use the standard representation, but rebind currentClass (for finding	 the method) while tracing the contents. "	| saveClass objx |	self trace: aContext class.	saveClass := currentClass.	currentClass := aContext method mclass.	objx := self trace: aContext body: aContext class: aContext class.	currentClass := saveClass.	^objx</body></methods><methods><class-id>Kernel.BOSSAbstractWriter</class-id> <category>writing</category><body package="BOSS">nextPut: topObject	"When writing out regular objects, do not complain about missing source code"	[self nextPut: topObject do: [nil]]		on: SourceFileManagerWarning		do: [:ex | ex resume].	^topObject</body><body package="BOSS">nextPutClasses: classes withSource: sourceMode	"Store a collection of classes. The semantics are equivalent to 	fileOut, i.e., only the code is written, not the values of the class 	variables or class instance variables."	"This message can be used to write classes for a 	runtime environment, if sourceMode is #discard."	| classSet objColl |	useSource := sourceMode.	classSet := IdentitySet new: classes size * 2.	classes do:		[:c |		classSet add: c.		(c class isMeta and: [c class nonTrivial])			ifTrue: [classSet add: c class]].	objColl := SystemUtils sortForLoading: classSet.	objColl := objColl asArray.	self nextPut: objColl do:		[objColl do: [:c |			currentClass := c.			self trace: (BOSSContents new object: c).			self trace: c.			c selectorsAndMethodsDo: [:s :meth | self trace: meth]].		objColl do: [:c | | list |			list := c binaryInitializationMessagesFor: useSource.			list do: [:msg | | init |				init := Array with: #deferSend: with: msg.				self trace: init body: init class: AbstractBinaryObjectStorage indexImportSendSelf]]]</body></methods><methods><class-id>Kernel.BOSSAbstractWriter</class-id> <category>private-oops</category><body package="BOSS">oopsInBody: body ofClass: class	^class instSize + (class isVariable ifTrue: [body basicSize] ifFalse: [0])</body><body package="BOSS">shortOops: anObjectat: anIndexput: aValue	anObject unsignedShortAt: anIndex put: aValue</body><body package="BOSS">writeLong: aLong	| bits |	bits := BOSSBytes new: 4.	bits longAt: 1 put: aLong.	swapBytes ifTrue: [bits fourByteEndiannessSwap].	stream nextPutAll: bits</body><body package="BOSS">writeLongLong: aLongLong	| bits |	bits := BOSSBytes new: 8.	bits longLongAt: 1 put: aLongLong.	swapBytes ifTrue: [bits eightByteEndiannessSwap].	stream nextPutAll: bits</body><body package="BOSS">writeLongOop: anOop	self subclassResponsibility</body><body package="BOSS">writeLongOop: longOopIndexstorageIndex: storageIndexcount: countbodySize: size	| bits |	bits := BOSSBytes new: self bytesPerLongOop * 4.	self longOops: bits at: 1 put: longOopIndex.	self longOops: bits at: self bytesPerLongOop + 1 put: storageIndex.	self longOops: bits at: self bytesPerLongOop * 2 + 1 put: count.	self longOops: bits at: self bytesPerLongOop * 3 + 1 put: size.	self swapLongOopsIn: bits.	stream nextPutAll: bits</body><body package="BOSS">writeSingleLongOop: anOop	self subclassResponsibility</body><body package="BOSS">writeUnsignedLong: anUnsignedLong	| bits |	bits := BOSSBytes new: 4.	bits unsignedLongAt: 1 put: anUnsignedLong.	swapBytes ifTrue: [bits fourByteEndiannessSwap].	stream nextPutAll: bits</body><body package="BOSS">writeUnsignedShort: anUnsignedShort	| bits |	bits := BOSSBytes new: 2.	bits unsignedShortAt: 1 put: anUnsignedShort.	swapBytes ifTrue: [bits twoByteEndiannessSwap].	stream nextPutAll: bits</body></methods><methods><class-id>Kernel.BOSSAbstractWriter</class-id> <category>private-initialize-release</category><body package="BOSS">importRegistryObjects	registry doWithIndex:		[:each :eachIndex |			| eachObject |			eachObject := each updatedValue.			objects				at: eachObject				put: -2 - eachIndex		]</body><body package="BOSS">initialHeaderCapacity	^5</body><body package="BOSS">initializeTraceClasses	"This must include every immediate class,	and any other class whose stored representation	shouldn't be affected by policy or individual	implementation of representBinaryOn:. "	traceClasses := self newTraceClasses.	traceClasses		at: Character put: #traceSkip:;		at: SmallInteger put: #traceSkip:;		at: VariableBinding put: #traceAssociation:</body><body package="BOSS">newRecentClasses	| answer |	answer := Array new: self numberOfRecentClasses.	1 to: self numberOfRecentClasses do: [:each | answer at: each put: (self encode: each)].	^answer</body><body package="BOSS">newTraceClasses	^IdentityDictionary new: 20</body><body package="BOSS">shouldUpdateRegistryObjects	^storage shouldUpdateRegistryObjects</body><body package="BOSS">storage: aBOS on: aStream registry: reg	super storage: aBOS on: aStream.	registry := reg.	objects := IdentityDictionary new: 20.	nilIndex := 0.  "we know this"	self initializeTraceClasses.	self importRegistryObjects.	headers := BOSSBytes new: self initialHeaderCapacity * self bytesPerHeader.	bodies := Array new: self initialHeaderCapacity * 2.	currentClass := Object.	recentClasses := self newRecentClasses.	nextRecentClass := 1.	bodySize := 0</body></methods><methods><class-id>Kernel.BOSSAbstractWriter</class-id> <category>tracing-policy</category><body package="BOSS">expectCycles	^storage expectCycles</body><body package="BOSS">traceSelectorFor: anObject	" anObject is the first object of its class	encountered so far.  Answer the message	selector that should be sent to self	to trace the object.  The default is represent:,	which simply asks the object for its preferred	representation. "	^#represent:</body></methods><methods><class-id>Kernel.BOSSWriter</class-id> <category>private</category><body package="BOSS">encode: anObject	| class |	class := anObject class.	class == SmallInteger ifTrue: [^(anObject bitShift: 2) + 3].	class == Character ifTrue: [^(anObject asInteger bitShift: 2) + 1].	^self encodeNonImmediateObject: anObject</body><body package="BOSS">writeBodyLength: bodyLength	self writeLong: bodyLength</body><body package="BOSS">writeIndexOnly: topObject	" Write out the representation of a top object	that already has an index assigned. "	| value |	baseIndex := SmallInteger maxVal.	value := self encode: topObject.	self writeLong: value</body><body package="BOSS">writeLongBody: body class: cx flags: flags	(self flagsRecentClass: flags) ifFalse: [self writeUnsignedLong: cx].	self writeLongBody: body flags: flags</body></methods><methods><class-id>Kernel.BOSSWriter</class-id> <category>private-oops</category><body package="BOSS">longOops: anObjectat: anIndexput: aValue	anObject longAt: anIndex put: aValue</body><body package="BOSS">swapLongOopsIn: anObject	swapBytes ifTrue: [anObject fourByteEndiannessSwap]</body><body package="BOSS">writeLongOop: anOop	self writeLong: anOop</body><body package="BOSS">writeSingleLongOop: anOop	self writeLongOop: -16r80000000 + anOop</body></methods><methods><class-id>Kernel.BOSSWriter</class-id> <category>private-constants</category><body package="BOSS">bytesPerHeader	^4</body><body package="BOSS">bytesPerLongOop	^4</body></methods><methods><class-id>Kernel.BOSSWriter</class-id> <category>private-headers</category><body package="BOSS">headersAt: localxput: flagsobject: anObjectsize: objectSize	| headerx |	headerx := localx // self bytesPerLongOop * self bytesPerHeader.	headers byteAt: headerx + 1 put: flags.	headers byteAt: headerx + 2 put: (objectSize min: 16rff).	headers unsignedShortAt: headerx + 3 put: (anObject identityHash bitAnd: 16rffff)</body><body package="BOSS">swapIndentityHashHeaderBytes	swapBytes ifTrue: [headers swapColumn: 2 with: 3]</body></methods><methods><class-id>Kernel.BOSSAbstractReader</class-id> <category>private-reading</category><body package="BOSS">assumedVariableListFor: cls describedBy: info 	"Answer the list of instance variable names that a given class had in 	a previous version. This only applies to objects BOSSed out before 	VisualWorks 2.0, and is a compatibility aid for loading in old BOSS 	files. Since this information will be used primarily for patching up 	instance variable refs in BOSSed methods, and since these methods 	are much more likely to be associated with ExternalInterfaces than 	anything else, we're focusing on that problem. Other problematic 	cases could be addressed here as you need them. 		Answering nil for a class should be taken as an indication that the 	class had the same instance variables in its previous version as it 	has now. Even if this is not true, it's acceptable if the methods being 	loaded don't refer to any instance variables directly.	Invoking a method with bogus instance variable offsets may cause	crashes (UAEs, core dumps, etc) or other errors that are hard to	diagnose."	| ext list |	(cls includesBehavior: ExternalInterface) ifFalse: [^nil].	ext := #('externals' ).	list := cls allInstVarNames asArray.	list size = ((info at: 4) bitAnd: 255) ifFalse:		[			(list includes: ext first)				ifFalse: [list := ext , list]		].	^list</body><body package="BOSS">classFromShortClass: shortClass short: short forward: forward using: localBuffer		| answer |	shortClass &gt; 0 ifTrue: [^recentClasses at: shortClass].	answer := short		ifTrue:			[				self read: 1 shortOopsInto: localBuffer.				self shortObjectAt: 1 from: localBuffer baseIndex: baseIndex			]		ifFalse:			[				self read: 1 longOopsInto: localBuffer.				self objectAt: 1 from: localBuffer baseIndex: baseIndex			].	forward ifFalse:		[			recentClasses				removeLast;				addFirst: answer		].	^answer</body><body package="BOSS">importSelectorAt: class with: inst	^self performImportSelectorAt: class with: inst</body><body package="BOSS">mapXeroxToUnicode	^storage mapXeroxToUnicode</body><body package="BOSS">newBaseIndexedReaderMapWithCount: anInteger	| answer |	answer := self readerMapClass		new: anInteger		baseIndex: baseIndex.	answer storage: storage.	^answer</body><body package="BOSS">objectAt: anIndexfrom: aBufferbaseIndex: aBaseIndex	self subclassResponsibility</body><body package="BOSS">objectsAt: anIndex put: anObject	objects		at: anIndex		put: anObject</body><body package="BOSS">potentiallyDeferImmutabilityChangeOf: inst basedOn: flags	(self flagsImmutable: flags) ifTrue:		[			self deferSend:				(MessageSend receiver: inst selector: #isImmutable: argument: true)		]</body><body package="BOSS">read: anInteger into: aBuffer	stream next: anInteger into: aBuffer startingAt: 1</body><body package="BOSS">readBitsClass: classsize: sizeforward: forwardspecial: specialdeferredBodies: deferredBodiesindex: index	| answer |	answer := stream next: size.	forward		ifTrue:			["can only happen if object has dependents"				deferredBodies add: (Array with: index - 1 with: class)			]		ifFalse:			[				special					ifTrue:						[							answer changeClassToThatOf: ''.							self mapXeroxToUnicode ifTrue: [self class mapStringToUnicode: answer]						]					ifFalse:						[							self change: answer toInstanceOf: class.							(swapBytes and: [(ByteClasses at: class ifAbsent: [nil]) == nil])								ifTrue: [answer reverseByteOrder]						]			].	^answer</body><body package="BOSS">readDeferredObjectFrom: deferredBodies	| index inst hx class body |	body := deferredBodies removeFirst.	index := body at: 1.	hx := index * self bytesPerHeader.	inst := objects at: index * self bytesPerLongOop + baseIndex.	class := body at: 2.	inst class isBits ifFalse:		[self resolveArray: inst from: (body at: 3) short: (self flagsShortOops: (self flagsOf: hx))].	class isImmediate		ifTrue: [inst become: (self performImportSelectorAt: class with: inst)]		ifFalse:			[self change: inst toInstanceOf: class.			(swapBytes and: [class isBits and: [(ByteClasses at: class ifAbsent: [nil]) == nil]])				ifTrue: [inst reverseByteOrder]]</body><body package="BOSS">readObject	| first count prefix topIndex |	first := BOSSBytes new: 3 * self bytesPerLongOop.	self read: 1 longOopsInto: first.	prefix := self longOops: first signedAt: 1.	(self encodesSingleObject: prefix) ifTrue:  "single object reference"		[			baseIndex := 0.			objects := self newBaseIndexedReaderMapWithCount: 0.			^self singleObjectFrom: first		].	baseIndex := self baseIndexFromPrefix: prefix.	prefix &lt; 0		ifTrue:  "single object"			[topIndex := baseIndex.			count := 1]		ifFalse:			[self read: 3 longOopsInto: first.			topIndex := self longOops: first signedAt: 1.			count := self longOops: first signedAt: 1 + self bytesPerLongOop].	objects := self newBaseIndexedReaderMapWithCount: count.	" If we are being asked to read an already-known	object, just skip over it and return the object. "	(storage objectAtIndex: topIndex) notNil ifTrue:		[(self skipNext: prefix first: first) do:			[:i | objects at: i put: (storage objectAtIndex: i)].		self longOops: first at: 1 put: topIndex.		^self singleObjectFrom: first].	headers := BOSSBytes new: count * self bytesPerHeader.	self read: headers size into: headers.	self swapIndentityHashHeaderBytes.	^self readObjectsWithTopIndex: topIndex</body><body package="BOSS">readObjectAtCount: i usingBuffer: buffer andPutDeferredBodiesIn: deferredBodies		| objx hx class size flags shortClass special inst short forward localBuffer |	localBuffer := buffer.	objx := (i - 1) * self bytesPerLongOop.	self resolveCyclesUpTo: objx in: deferredBodies.	hx := (i - 1) * self bytesPerHeader.	flags := self flagsOf: hx.	short := self flagsShortOops: flags.	shortClass := self recentClassIndexFrom: flags.	forward := self flagsForwardReferences: flags.	class := self		classFromShortClass: shortClass		short: short		forward: forward		using: localBuffer.	size := self sizeOf: hx.	size = 16rFF ifTrue:		[			self read: 1 longOopsInto: localBuffer.			size := self bodyLengthAt: 1 from: localBuffer		].	special := class isImmediate.	(self flagsBits: flags)		ifTrue:			[				inst := self					readBitsClass: class					size: size					forward: forward					special: special					deferredBodies: deferredBodies					index: i			]		ifFalse:			[				| bytesPerOop |				bytesPerOop := short					ifTrue: [self bytesPerShortOop]					ifFalse: [self bytesPerLongOop].				inst := Array new: size // bytesPerOop.				forward					ifTrue:						["must resolve later"							| bits |							bits := BOSSBytes new: size.							self read: size into: bits.							self								cyclicBody: (Array with: i - 1 with: class with: bits)								to: deferredBodies								short: short						]					ifFalse:						["can resolve now"							size &gt; localBuffer size ifTrue: [localBuffer := BOSSBytes new: size].							self read: size into: localBuffer.							self resolveArray: inst from: localBuffer short: short.							special ifFalse: [self change: inst toInstanceOf: class]						]			].	(special and: [forward not]) ifTrue: [inst := self importSelectorAt: class with: inst]. " Handle import "	self		objectsAt: (i - 1) * self bytesPerLongOop + baseIndex		put: inst.	self potentiallyDeferImmutabilityChangeOf: inst basedOn: flags.	^localBuffer</body><body package="BOSS">readObjectsWithTopIndex: topIndex	" Read in and fix up all the objects. "	| count buf deferredBodies |	count := headers size // self bytesPerHeader.	deferredBodies := OrderedCollection new: (count // 10 max: 5).  "estimate"	compiledCode := nil.	buf := BOSSBytes new: self bytesPerLongOop.	1 to: count do:		[:each |			buf := self				readObjectAtCount: each				usingBuffer: buf				andPutDeferredBodiesIn: deferredBodies		].	" Now fill in the remaining objects "	[deferredBodies isEmpty] whileFalse: [self readDeferredObjectFrom: deferredBodies].	headers := stream := nil.  "release references"	self commitSources.  "update source"	self evaluateSends.  "evaluate any message sends that were just for effect"	^objects at: topIndex</body><body package="BOSS">resolveCyclesUpTo: maxIndex in: bodies	"Fix up those objects that have forward references, if all	the forward references have been resolved."	| i body index hx inst class |	i := 1.	[i &lt;= bodies size] whileTrue:		[body := bodies at: i.		(body size &lt; 4 or: [(body at: 4) &gt; maxIndex])			ifTrue: [i := i+1]			ifFalse:				[bodies removeAtIndex: i.				index := body at: 1.				hx := index * self bytesPerHeader.				inst := objects at: index * self bytesPerLongOop + baseIndex.				class := body at: 2.				self resolveArray: inst					from: (body at: 3)					short: (self flagsShortOops: (self flagsOf: hx)).				class isImmediate					ifTrue: [inst become: (self performImportSelectorAt: class with: inst)]					ifFalse: [self change: inst toInstanceOf: class]]].</body><body package="BOSS">shortObjectAt: anIndexfrom: aBufferbaseIndex: aBaseIndex	self subclassResponsibility</body><body package="BOSS">singleObjectFrom: first	"Answer a single object whose oop is the first self bytesPerIndex bytes of first"	self subclassResponsibility</body></methods><methods><class-id>Kernel.BOSSAbstractReader</class-id> <category>private-initialize-release</category><body package="BOSS">newRecentClasses	| answer |	answer := OrderedCollection new: self numberOfRecentClasses.	1 to: self numberOfRecentClasses do: [:each | answer add: each].	^answer</body><body package="BOSS">storage: aBOS on: aStream	super storage: aBOS on: aStream.	recentClasses := self newRecentClasses</body></methods><methods><class-id>Kernel.BOSSAbstractReader</class-id> <category>private-oops</category><body package="BOSS">bodyLengthAt: anIndexfrom: anObject	self subclassResponsibility</body><body package="BOSS">longOops: anObjectsignedAt: anIndex	self subclassResponsibility</body><body package="BOSS">longOops: anObjectunsignedAt: anIndex	self subclassResponsibility</body><body package="BOSS">read: anInteger longOopsInto: aBuffer	self read: anInteger * self bytesPerLongOop into: aBuffer.	self swapLongOopsIn: aBuffer</body><body package="BOSS">read: anInteger shortOopsInto: aBuffer	self read: anInteger * self bytesPerShortOop into: aBuffer.	self swapShortOopsIn: aBuffer</body><body package="BOSS">shortOops: anObject at: anIndex	^anObject unsignedShortAt: anIndex</body></methods><methods><class-id>Kernel.BOSSAbstractReader</class-id> <category>reading-imports</category><body package="BOSS">importAssociation: classAndSymbol	" Resolve aSymbol in the context of	the current class. "	| cls sym assoc |	cls := classAndSymbol at: 1.	sym := classAndSymbol at: 2.	assoc := cls fullBindingFor: sym.	assoc notNil ifTrue: [^assoc].	" Association doesn't exist in the environment.	Find or create it in Undeclared"	^SystemUtils undeclaredName: sym</body><body package="BOSS">importByteString: aByteString	self mapXeroxToUnicode ifTrue: [self class mapStringToUnicode: aByteString].	^aByteString</body><body package="BOSS">importByteSymbol: aByteString	" Guarantee unique representation for Symbols. "	| answer |	answer := self importByteString: aByteString.	^answer asSymbol</body><body package="BOSS">importClass: info	" info is a 4-element (optionally 5-element) array:	name, meta flag, version, format, array of instance variable names"	| cls varList isMeta |	cls := info first asQualifiedReference value.	(isMeta := info at: 2) ifTrue: [cls := cls class].  "metaclass"	info size &lt; 5		ifTrue: [varList := self assumedVariableListFor: cls describedBy: info]		ifFalse:			[varList := info at: 5.			varList == nil ifTrue: [varList := #()]].	varList = cls allInstVarNames asArray		ifTrue: [varList := nil].	storage variablesForClass: cls put: varList.	isMeta ifTrue: [^cls].  "Don't need to worry about type mismatch."	((info at: 3) = cls binaryRepresentationVersion and:		[| mask |		mask := cls formatMask.		((info at: 4) bitAnd: mask) = (cls format bitAnd: mask)				and: [varList == nil]])			ifFalse: [storage					readerBlockFor: cls					put: (cls binaryReaderBlockForVersion: (info at: 3)							format: (info at: 4))].	^cls</body><body package="BOSS">importCompiledCode: info	" info is a BOSSCompiledCodeHolder "	| oldCode |	self change: info toInstanceOf: BOSSCompiledCodeHolder.	info useSource: useSource.	info computeCodeForStorage: storage.	readingClasses ifFalse: [info dontInstall].	oldCode := info existingCode.	^oldCode = info code		ifTrue:			[" The same code is already installed.			Don't disturb it. "			oldCode]		ifFalse:			[" We let the info stand in for the actual			compiled method until the final commit. "			compiledCode isNil ifTrue: [compiledCode := OrderedCollection new].			compiledCode addLast: info.			info]</body><body package="BOSS">importFloat: bytes	"Someday we might handle non-IEEE floats.  Also,	use a Double constant that is large enough to fall	outside the SmallDouble range"	| bsize float |	bsize := bytes size.	float := bsize = Float instanceByteSize		ifTrue: [1.0]		ifFalse:			[				bsize = Double instanceByteSize					ifTrue: [1.0d40]					ifFalse: [self error: 'Unknown float size!'.  ^0.0 + 0.0]			].	float := bytes changeClassToThatOf: float.	swapBytes ifTrue: [float reverseByteOrder].	^float</body><body package="BOSS">importGlobal: aSymbol	^aSymbol asQualifiedReference value</body><body package="BOSS">importNameSpace: info	" info is an array with a fullName. "	^info first asQualifiedReference value</body><body package="BOSS">importSend: msgArray	^(msgArray at: 1)		perform: (msgArray at: 2)		withArguments: (msgArray copyFrom: 3 to: msgArray size)</body><body package="BOSS">importSendSelf: msgArray	^self perform: (msgArray at: 1)		withArguments: (msgArray copyFrom: 2 to: msgArray size)</body><body package="BOSS">importTwoByteSymbol: aByteString	" Guarantee unique representation for Symbols. "	aByteString changeClassToThatOf: (TwoByteString basicNew: 0).	swapBytes ifTrue: [aByteString reverseByteOrder].	^self importByteSymbol: aByteString</body></methods><methods><class-id>Kernel.BOSSAbstractReader</class-id> <category>reading</category><body package="BOSS">next	" Read the next object from the stream. "	readingClasses := false.	^self readObject</body><body package="BOSS">nextClassesWithSource: sourceMode	"Read a collection of classes. The semantics are equivalent to 	fileIn, i.e., only the code is read, not the values of the class 	variables or class instance variables."	useSource := sourceMode.	readingClasses := true.	^Class commentRequestSignal		handle: [:ex | ex proceedWith: useSource ~= #discard]		do: [self readObject]</body><body package="BOSS">skipNext	" Skip over one structure.  Answer an Interval	of the object indices it defines, or nil	if this is an immediate object or a single	reference. "	| first prefix |	first := BOSSBytes new: 3 * self bytesPerLongOop.  "room for largest prefix"	self read: 1 longOopsInto: first.	prefix := self longOops: first signedAt: 1.	(self encodesSingleObject: prefix) ifTrue: [^nil].	prefix &gt;= 0 ifTrue: [self read: 3 longOopsInto: first].	^self skipNext: prefix first: first</body></methods><methods><class-id>Kernel.BOSSAbstractReader</class-id> <category>private</category><body package="BOSS">change: obj toInstanceOf: aClass 	"Only TwoByteString needs special treatment when loading	XCCS strings into a Unicode environment. ByteStrings and	Characters are not passed through this method."	| inst readBlock |	readBlock := storage readerBlockFor: aClass.	readBlock == nil ifFalse: [^readBlock value: obj].	inst := aClass isVariable		ifTrue: [aClass basicNew: 0]		ifFalse: [aClass basicNew].	(storage usesReaderBlocks and: [aClass ~~ TwoByteString]) ifTrue:		[			storage				readerBlockFor: aClass				put: [:o | o changeClassToThatOf: inst]		].	obj changeClassToThatOf: inst.	(self mapXeroxToUnicode and: [aClass == TwoByteString])		ifTrue: [self class mapStringToUnicode: obj].	^obj</body><body package="BOSS">commitSources	" If we loaded any compiled methods,	commit the changes file and update the	source pointers now. "	| stored |	compiledCode isNil ifTrue: [^self].	stored := false.	compiledCode do: [:info | info storeSource ifTrue: [stored := true]].	stored ifTrue: [SourceFileManager default commitSources].	compiledCode do:		[:info |			| code |			code := info code.			info become: code.  "identities are now swapped"			code commit: info		]</body><body package="BOSS">createSpecialObject: anObjectProxy	self deferSend:		(MessageSend			receiver: anObjectProxy			selector: #resolve).	^anObjectProxy</body><body package="BOSS">cyclicBody: aBody to: bodies short: short	"Add a forwarding reference to an object.  This will be resolved later"	short		ifTrue: [self cyclicShortBody: aBody to: bodies]		ifFalse: [self cyclicLongBody: aBody to: bodies]</body><body package="BOSS">cyclicLongBody: aBody to: bodies	"Add a forwarding reference to an object.  This will be resolved later"	| max bits |	bits := aBody at: 3.	swapBytes ifTrue:		[			bits := bits copy.			self swapLongOopsIn: bits		].	max := 0.	1 to: bits size by: self bytesPerLongOop do:		[:eachIndex | | oop |		oop := self longOops: bits unsignedAt: eachIndex.		"Ignore immediate values."		(oop bitAnd: 1) = 1 ifTrue: [oop := 0].		max := max max: oop].	bodies add: (aBody copyWith: max)</body><body package="BOSS">cyclicShortBody: aBody to: bodies	"Add a forwarding reference to an object.  This will be resolved later"	| max bits |	bits := aBody at: 3.	swapBytes ifTrue:		[			bits := bits copy.			self swapShortOopsIn: bits		].	max := 0.	1 to: bits size by: self bytesPerShortOop do:		[:eachIndex | | oop |		oop := self shortOops: bits at: eachIndex.		"Ignore immediate values."		(oop bitAnd: 1) = 1 ifTrue: [oop := 0].		max := max max: oop].	bodies add: (aBody copyWith: max)</body><body package="BOSS">deferSend: aMessageSend 	"This MessageSend should not be evaluated until after all other action has 	been taken. Record it for later evaluation"	deferredSends == nil		ifTrue: [deferredSends := OrderedCollection new].	deferredSends add: aMessageSend</body><body package="BOSS">evaluateSends	"If any MessageSends were loaded that were supposed to be deferred until later, evaluate them"	deferredSends == nil ifFalse:		[deferredSends do: [:send | send value]]</body><body package="BOSS">performImportSelectorAt: anInteger with: anObject	| selector |	selector := AbstractBinaryObjectStorage importSelectors at: anInteger.	^self perform: selector with: anObject</body><body package="BOSS">readerMapClass	self subclassResponsibility</body><body package="BOSS">resolveArray: inst from: body short: shortFlag	shortFlag		ifTrue: [self resolveArray: inst fromShort: body]		ifFalse: [self resolveArray: inst fromLong: body]</body><body package="BOSS">resolveArray: inst fromLong: body	self swapLongOopsIn: body.	1 to: inst size do:		[:eachIndex |			| eachObject |			eachObject := self				objectAt: (eachIndex - 1) * self bytesPerLongOop + 1				from: body				baseIndex: baseIndex.			inst at: eachIndex put: eachObject		]</body><body package="BOSS">resolveArray: inst fromShort: body	self swapShortOopsIn: body.	1 to: inst size do:		[:eachIndex |			| eachObject |			eachObject := self				shortObjectAt: (eachIndex - 1) * self bytesPerShortOop + 1				from: body				baseIndex: baseIndex.			inst at: eachIndex put: eachObject		]</body><body package="BOSS">skipNext: prefix first: first	" Do the work of skipping over one structure.	first is a 3-long oop BOSSBytes.	prefix is the first long oop of the structure	header as an integer.  If prefix is negative,	the first long oop of first hold prefix;	is prefix is non-negative, first holds	the next 3 long oops of the header; in either case,	any needed byte swapping has been done.	Answer the interval of object indices. "	baseIndex := self baseIndexFromPrefix: prefix.	^prefix &lt; 0		ifTrue: [self skipNextSingleObjectUsing: first]		ifFalse: [self skipNextMultipleObjectsUsing: first]</body><body package="BOSS">skipNextMultipleObjectsUsing: aLongOopHeader	| count bytesUsedByBodies |	count := self longOops: aLongOopHeader signedAt: self bytesPerLongOop + 1.	bytesUsedByBodies := self longOops: aLongOopHeader signedAt: self bytesPerLongOop * 2 + 1.	stream skip: count * self bytesPerHeader + bytesUsedByBodies.	^baseIndex		to: baseIndex + (count * self bytesPerLongOop) - self bytesPerLongOop		by: self bytesPerLongOop</body><body package="BOSS">skipNextSingleObjectUsing: aScratchBuffer	| flags size |	self read: self bytesPerHeader into: aScratchBuffer.	flags := aScratchBuffer byteAt: 1.	size := aScratchBuffer byteAt: 2.	(self flagsRecentClass: flags) ifFalse:  "explicit class"		[			| bytesToSkip |			bytesToSkip := (self flagsShortOops: flags)				ifTrue: [self bytesPerShortOop]				ifFalse: [self bytesPerLongOop].			stream next: bytesToSkip		].	size = 16rFF ifTrue:  "large object"		[			self read: 1 longOopsInto: aScratchBuffer.			size := self bodyLengthAt: 1 from: aScratchBuffer		].	stream skip: size.	^baseIndex to: baseIndex by: self bytesPerLongOop</body></methods><methods><class-id>Kernel.BOSSAbstractReader</class-id> <category>private-constants</category><body package="BOSS">baseIndexFromPrefix: prefix	self subclassResponsibility</body><body package="BOSS">encodesSingleObject: prefix	^(self tagBitsFrom: prefix) ~= 2</body><body package="BOSS">tagBitsFrom: anInteger	self subclassResponsibility</body></methods><methods><class-id>Kernel.BOSSAbstractReader</class-id> <category>private-headers</category><body package="BOSS">flagsOf: objx	" Answer the flags from the header. "	^headers byteAt: objx + 1</body><body package="BOSS">sizeOf: objx	" Answer the size from the header. "	^headers byteAt: objx + 2</body></methods><methods><class-id>Kernel.BOSSAbstractReader class</class-id> <category>initialize</category><body package="BOSS">initialize	"BOSSReader initialize"	XeroxMap := LargeArray new: 65536.	XeroxMap		replaceFrom: 1 to: 256 with: #(0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 nil 167 nil 8216 8220 171 nil nil nil nil 176 177 180 179 215 181 182 183 247 8217 8221 187 188 189 190 191 nil 96 180 710 732 175 728 729 168 nil 176 184 nil 733 731 711 175 185 174 169 8482 nil nil nil nil nil nil nil nil nil nil nil 8486 198 208 170 nil nil nil nil nil 216 338 186 222 nil nil nil nil 230 nil 240 nil 305 nil nil nil 248 339 223 254 nil nil 160);		replaceFrom: 8449 to: 8704 with: #(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 173 nil nil nil nil nil 8230 8230 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 8800 nil nil 8804 8805 8734 8756 nil nil nil 8242 8243 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 9674 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 8465 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 8476 nil nil nil nil nil nil nil nil nil nil nil nil nil 8657 8659 8472 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil);		replaceFrom: 8705 to: 8960 with: #(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 9632 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil);		replaceFrom: 8961 to: 9216 with: #(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 168 nil nil nil nil 184 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil);		replaceFrom: 9729 to: 9984 with: #(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 913 914 nil 8710 916 917 nil nil 918 919 920 921 922 923 924 925 926 927 928 nil 929 931 982 932 933 934 935 936 937 nil 978 nil 945 946 nil 947 948 949 962 nil 950 951 952 953 954 955 181 957 958 959 960 nil 961 963 nil 964 965 966 967 968 969 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil);		replaceFrom: 10241 to: 10496 with: #(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 9484 9488 9496 9492 9500 9516 9508 9524 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 166 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 9571 9553 9559 9565 nil nil nil nil 9562 9556 9577 9574 9568 9552 9580 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil);		replaceFrom: 60673 to: 60928 with: #(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 63743 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil);		replaceFrom: 60929 to: 61184 with: #(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 8218 nil nil nil nil nil nil nil nil nil nil nil nil nil 8962 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 402 nil nil nil nil nil nil nil nil nil nil nil 9617 9619 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 63726 63728 63738 63737 63739 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 8592 8593 8594 8595 nil nil nil nil 8901 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 9829 9830 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 9632 nil 63740 63735 63741 63742 63729 63731 63730 nil nil nil nil nil nil 8992 8993 63733 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil);		replaceFrom: 61185 to: 61440 with: #(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 8211 8212 nil nil 8222 nil 8249 8250 nil nil nil nil 8224 8225 9001 9002 nil nil nil nil nil nil nil nil nil nil nil nil nil 8240 nil nil nil nil 8260 nil nil nil 8712 8713 8717 8656 8660 8658 nil nil 8596 nil nil nil 8745 8746 8839 8838 8835 8834 nil nil nil 8836 nil 8709 8853 nil 8855 nil 8226 nil nil nil 172 166 8736 nil nil nil 8869 8733 8801 nil nil 8747 nil nil 8773 8776 8721 8719 8730 nil 9618 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 402 nil nil nil nil 8501 nil nil nil nil nil nil nil nil nil nil nil nil 8707 8704 8743 8744 nil 8711 8706 nil nil nil nil 8215 nil nil nil nil nil nil nil nil nil nil nil 9824 nil 8900 9827 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 9474 9472 9532 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil);		replaceFrom: 61441 to: 61696 with: #(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 64257 64258 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 188 189 190 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 9608 9604 nil nil 9600 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil);		replaceFrom: 61697 to: 61952 with: #(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 192 193 194 195 nil nil 196 197 nil nil nil nil 199 nil nil 200 201 202 nil nil 203 nil nil nil nil nil nil nil nil 204 205 206 nil nil nil 207 nil nil nil nil nil nil nil 209 nil nil 210 211 212 213 nil 214 nil nil nil nil nil nil nil 352 nil nil 217 218 219 nil nil nil 220 nil nil nil nil nil 221 nil 376 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 224 225 226 227 nil nil 228 229 nil nil nil nil 231 nil nil 232 233 234 nil nil 235 nil nil nil nil nil nil nil nil 236 237 238 nil nil nil 239 nil nil nil nil nil nil nil 241 nil nil 242 243 244 245 nil 246 nil nil nil nil nil nil nil 353 nil nil 249 250 251 nil nil nil 252 nil nil nil nil nil 253 nil 255 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil);		replaceFrom: 64769 to: 65024 with: #(nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 981 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 977 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 8260 nil 185 178 179 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 63717 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil 305 nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil nil);		compress</body></methods><methods><class-id>Kernel.BOSSAbstractReader class</class-id> <category>utilities</category><body package="BOSS">mapStringToUnicode: str	| ch |	1 to: str size do:		[:index |		ch := XeroxMap at: (str at: index) asInteger + 1.		ch == nil			ifTrue:				[self notify: 'Character could not be mapped. Old character will be used if you proceed'.				ch := str at: index].		str at: index put: ch asCharacter].</body><body package="BOSS">mapToUnicode: char	| ch |	ch := XeroxMap at: char asInteger + 1.	ch == nil		ifTrue:			[self notify: 'Character could not be mapped. Old character will be used if you proceed'.			ch := char].	^ch</body></methods><methods><class-id>Kernel.BOSSReader</class-id> <category>private-reading</category><body package="BOSS">objectAt: anIndexfrom: aBufferbaseIndex: aBaseIndex	^aBuffer		objectAt: anIndex		objectMap: objects		baseIndex: aBaseIndex</body><body package="BOSS">shortObjectAt: anIndexfrom: aBufferbaseIndex: aBaseIndex	^aBuffer		shortObjectAt: anIndex		objectMap: objects		baseIndex: aBaseIndex</body><body package="BOSS">singleObjectFrom: first	"Answer a single object whose oop is the first self bytesPerIndex bytes of first"	^first objectAt: 1 objectMap: objects baseIndex: 0</body></methods><methods><class-id>Kernel.BOSSReader</class-id> <category>private</category><body package="BOSS">readerMapClass	^BOSSReaderMap</body></methods><methods><class-id>Kernel.BOSSReader</class-id> <category>private-constants</category><body package="BOSS">baseIndexFromPrefix: prefix	^prefix bitAnd: 16r1ffffffc</body><body package="BOSS">bytesPerHeader	^4</body><body package="BOSS">bytesPerLongOop	^4</body><body package="BOSS">tagBitsFrom: anInteger	^anInteger bitAnd: 3</body></methods><methods><class-id>Kernel.BOSSReader</class-id> <category>private-oops</category><body package="BOSS">bodyLengthAt: anIndexfrom: anObject	^anObject longAt: anIndex</body><body package="BOSS">longOops: anObjectat: anIndexput: aValue	anObject longAt: anIndex put: aValue</body><body package="BOSS">longOops: anObjectsignedAt: anIndex	^anObject longAt: anIndex</body><body package="BOSS">longOops: anObjectunsignedAt: anIndex	^anObject unsignedLongAt: anIndex</body><body package="BOSS">swapLongOopsIn: anObject	swapBytes ifTrue: [anObject fourByteEndiannessSwap]</body></methods><methods><class-id>Kernel.BOSSReader</class-id> <category>private-headers</category><body package="BOSS">swapIndentityHashHeaderBytes	swapBytes ifTrue: [headers swapColumn: 2 with: 3]</body></methods><methods><class-id>Kernel.BOSSRegisteredObject</class-id> <category>initialize-release</category><body package="BOSS">name: objName valueBlock: aBlock class: index	name := objName asString.	valueBlock := aBlock.	writerClass := index</body><body package="BOSS">update	" Update the value by evaluating	the valueBlock. "	value := valueBlock value: name</body></methods><methods><class-id>Kernel.BOSSRegisteredObject</class-id> <category>accessing</category><body package="BOSS">updatedValue	self update.	^self value</body><body package="BOSS">value	^value</body></methods><methods><class-id>Kernel.BOSSRegisteredObject</class-id> <category>private-tracing</category><body package="BOSS">traceOn: writer	" This message is only for use by BOSSWriter. "	| objx |	objx := writer assign: value.	writer record: value body: name class: writerClass flags: 0 index: objx.	^objx</body></methods><methods><class-id>Kernel.BOSSCompiledCodeHolder</class-id> <category>initialize-release</category><body package="BOSS">class: aClass selector: aSymbol category: aString codeClass: aCodeClass codeContents: codeObject source: sourceObject	class := aClass.	selector := aSymbol.	category := aString.	codeClass := aCodeClass.	codeContents := codeObject.	source := sourceObject</body><body package="BOSS">dontInstall	" Prevent this method from being installed	in the method dictionary. "	class := nil</body><body package="BOSS">useSource: aSymbol	" Selectively discard source information	according to the retention mode defined	by aSymbol.  See BOSSWriter for more detail. "	aSymbol == #discard		ifTrue: [source := category := nil]		ifFalse:			[(aSymbol == #reference and: [source isString])				ifTrue: [source := nil]]</body></methods><methods><class-id>Kernel.BOSSCompiledCodeHolder</class-id> <category>accessing</category><body package="BOSS">code	^codeContents</body><body package="BOSS">codeClass	^codeClass</body><body package="BOSS">computeCodeForStorage: storage	| list1 list2 map list1CodeOnly list2CodeOnly |	codeContents class == codeClass ifFalse:		[| aBlockOrNil vars newMeth |		aBlockOrNil := storage readerBlockFor: codeClass.		aBlockOrNil == nil			ifTrue:	[codeContents changeClassToThatOf: (codeClass basicNew: 0)]			ifFalse:	[aBlockOrNil value: codeContents.					class == nil ifFalse: [codeContents mclass: class]].		vars := storage variablesForClass: codeContents mclass.		vars == nil			ifFalse:				[newMeth := codeContents mclass							rebindMethod: codeContents							oldVariableNames: vars.				list1 := self enumerate: codeContents into: OrderedCollection new.				list2 := self enumerate: newMeth into: OrderedCollection new.				list1CodeOnly := self filterOutBlocksFrom: list1 copy.				list2CodeOnly := self filterOutBlocksFrom: list2 copy.				list1CodeOnly size = list2CodeOnly size					ifFalse: [self error: 'Unexplained mismatch between source and translated methods'].				map := IdentityDictionary new.				1 to: list1CodeOnly size do: [:i |					(list1CodeOnly at: i) become: (list2CodeOnly at: i).					map at: (list1CodeOnly at: i) put: (list2CodeOnly at: i).					map at: (list2CodeOnly at: i) put: (list1CodeOnly at: i)].				map at: newMeth put: self.				list1 do: [:obj | self map: obj using: map].					"Not strictly necessary, but for safety...."				list2 do: [:obj | self map: obj using: map].				]].	^codeContents</body><body package="BOSS">existingCode	" If a compiled method with this class and selector	already exists, answer it, otherwise answer nil. "	^class notNil		ifTrue: [class compiledMethodAt: selector ifAbsent: [nil]]		ifFalse: [nil]</body></methods><methods><class-id>Kernel.BOSSCompiledCodeHolder</class-id> <category>installing</category><body package="BOSS">commit: code	" Install in the method dictionary,	and set the source pointer. "	class notNil ifTrue:		[category notNil			ifTrue: [class addSelectorUnsafe: selector withMethod: code category: category]			ifFalse: [class addSelectorUnsafe: selector withMethod: code]].	source isString ifFalse: [code sourcePointer: source]</body><body package="BOSS">storeSource	" Store the source on the changes file if appropriate.	Answer whether this was done. "	^(source isString and: [class notNil and: [category notNil]])		ifTrue:			[source := SourceFileManager default					storeMethodSource: source					class: class					category: category					safely: false.			true]		ifFalse: [false]</body></methods><methods><class-id>Kernel.BOSSCompiledCodeHolder</class-id> <category>private</category><body package="BOSS">enumerate: compiledCode into: collection	"This can be seen as a superset of CompiledMethod&gt;&gt;withAllBlockMethods.	It answers an ordered list of all CompiledCode and BlockClosure objects	reachable from the method."	collection add: compiledCode.	(compiledCode isKindOf: BlockClosure)		ifTrue: [^self enumerate: compiledCode method into: collection].	1 to: compiledCode numLiterals do:		[:n | | lit |		lit := compiledCode literalAt: n.		(lit isKindOf: BlockClosure)			ifTrue:				[collection add: lit.				self enumerate: lit method into: collection].		(lit isKindOf: CompiledCode)			ifTrue:				[self enumerate: lit into: collection]].	^collection</body><body package="BOSS">filterOutBlocksFrom: list	| i lit |	i := 0.	[i &lt; list size]		whileTrue:			[i := i+1.			lit := list at: i.			(lit isKindOf: BlockClosure)				ifTrue: [list removeAtIndex: i+1]].	^list</body><body package="BOSS">map: object using: map	| x |	1 to: object class instSize do:		[:i |		x := object instVarAt: i.		object instVarAt: i put: (map at: x ifAbsent: [x])].	1 to: object basicSize do:		[:n |		x := object basicAt: n.		object basicAt: n put: (map at: x ifAbsent: [x])].</body></methods><methods><class-id>Kernel.BOSSReader32</class-id> <category>private-reading</category><body package="BOSS">buildSixtyFourBitEquivalentFor: anObject	anObject class == Double ifTrue: [^anObject + 0.0d].	(anObject class == LargePositiveInteger		or: [anObject class == LargeNegativeInteger])			ifFalse: [^anObject].	anObject digitLength &gt; 8 ifTrue: [^anObject].	^anObject + 0</body><body package="BOSS">objectsAt: anIndex put: anObject	"It is not necessary to trace through object cycles because	large integers and doubles do not reference other objects.	Therefore, it is not necessary to wrap become: sends"	| newObject |	newObject := self buildSixtyFourBitEquivalentFor: anObject.	super		objectsAt: anIndex		put: newObject</body></methods><methods><class-id>Kernel.BOSSWriter32</class-id> <category>private-accessing</category><body package="BOSS">thirtyTwoBitObjects	^thirtyTwoBitObjects</body><body package="BOSS">thirtyTwoBitObjects: anObject	thirtyTwoBitObjects := anObject</body></methods><methods><class-id>Kernel.BOSSWriter32</class-id> <category>initialize-release</category><body package="BOSS">initialize	super initialize.	self thirtyTwoBitObjects: IdentityDictionary new</body></methods><methods><class-id>Kernel.BOSSWriter32</class-id> <category>private-tracing</category><body package="BOSS">buildDegenerateDoubleFor: aSmallDouble	^self thirtyTwoBitObjects		at: aSmallDouble		ifAbsentPut:			[				aSmallDouble asDegenerateDouble					beImmutable;					yourself			]</body><body package="BOSS">buildLargeIntegerOfClass: aLargeIntegerClasswithBytesFrom: aPositiveInteger	| digitLength bytesLeft answer |	digitLength := aPositiveInteger digitLength.	bytesLeft := aPositiveInteger.	answer := aLargeIntegerClass basicNew: digitLength.	1 to: digitLength do:		[:eachIndex |			answer				digitAt: eachIndex				put: (bytesLeft bitAnd: 16rFF).			bytesLeft := bytesLeft bitShift: -8		].	answer beImmutable.	^answer</body><body package="BOSS">buildNegativeLargeIntegerFor: aSmallInteger	^self thirtyTwoBitObjects		at: aSmallInteger		ifAbsentPut:			[				self					buildLargeIntegerOfClass: LargeNegativeInteger					withBytesFrom: 0 - aSmallInteger			]</body><body package="BOSS">buildPositiveLargeIntegerFor: aSmallInteger	^self thirtyTwoBitObjects		at: aSmallInteger		ifAbsentPut:			[				self					buildLargeIntegerOfClass: LargePositiveInteger					withBytesFrom: aSmallInteger			]</body><body package="BOSS">nextPut: topObject do: traceBlock	^super		nextPut: (self thirtyTwoBitObjectFor: topObject)		do: traceBlock</body><body package="BOSS">thirtyTwoBitObjectFor: anObject	anObject class == SmallInteger ifTrue:		[			anObject &gt; 536870911 ifTrue:				[^self buildPositiveLargeIntegerFor: anObject].			anObject &lt; -536870912 ifTrue:				[^self buildNegativeLargeIntegerFor: anObject].			^anObject		].	anObject class == SmallDouble ifTrue:		[^self buildDegenerateDoubleFor: anObject].	^anObject</body><body package="BOSS">trace: anObject	^super trace: (self thirtyTwoBitObjectFor: anObject)</body></methods><methods><class-id>Kernel.BOSSWriter32</class-id> <category>private</category><body package="BOSS">encode: anObject	^super encode: (self thirtyTwoBitObjectFor: anObject)</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage</class-id> <category>accessing</category><body package="BOSS">expectCycles	"Answer whether the receiver should, on writing, expect to see cycles, 	especially cycles where a Set or Dictionary refers back to itself. If the 	receiver expects to see cycles, it may use a deferred mechanism for 	creating the collection. This will solve the loading problem, but if 	other objects want to send messages to the Set or Dictionary while 	being BOSSed in, the messages they send may not be understood by 	the object acting as proxy to the Set. Thus, this attribute should be 	set to true only when needed."	^expectCycles</body><body package="BOSS">expectCycles: aBoolean 	"Set whether the receiver should, on writing, expect to see cycles, 	especially cycles where a Set or Dictionary refers back to itself. If the 	receiver expects to see cycles, it may use a deferred mechanism for 	creating the collection. This will solve the loading problem, but if 	other objects want to send messages to the Set or Dictionary while 	being BOSSed in, the messages they send may not be understood by 	the object acting as proxy to the Set. Thus, this attribute should be 	set to true only when needed."	expectCycles := aBoolean</body><body package="BOSS">indexOf: anObject	" Answer the index of anObject.	If no index has been assigned, answer nil. "	^anObject == nil		ifTrue: [0 "nil is known to have an index of 0"]		ifFalse: [writerMap at: anObject ifAbsent: [nil]]</body><body package="BOSS">mapXeroxToUnicode	"Answer whether the reader should map characters from	Xerox encoding to Unicode encoding. nil is the same as false,	so we do that mapping here.	Note that only Characters, ByteStrings, and TwoByteStrings	need to be mapped. Other kinds of strings use a non-standard	encoding table, and are insulated from this change."	^mapXeroxToUnicode == nil		ifTrue: [false]		ifFalse: [mapXeroxToUnicode]</body><body package="BOSS">mapXeroxToUnicode: boole	"Declare whether the reader should map characters from	Xerox encoding to Unicode encoding. This must be done	before reading any affected object from the stream.	Note that only Characters, ByteStrings, and TwoByteStrings	need to be mapped. Other kinds of strings use a non-standard	encoding table, and are insulated from this change."	mapXeroxToUnicode := boole</body><body package="BOSS">nextIndex	" Answer the next object index	to be assigned. "	^nextIndex</body><body package="BOSS">nextIndex: objx	" Set the next object index	to be assigned.  This should only be used	when appending to an existing stream	containing mixed BOSS and non-BOSS information,	where the client has saved the next object index	in some other way. "	" Since this is such a dangerous operation,	do a little extra checking. "	(objx &lt; self firstIndex or: [(self tagBitsFrom: objx) ~= 0])		ifTrue: [self error: 'Invalid nextIndex value']		ifFalse: [nextIndex := objx]</body><body package="BOSS">sourceMode	" Answer the mode that describes	how method and class sources are	being handled. "	^sourceMode</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage</class-id> <category>positioning</category><body package="BOSS">position	" Answer the position of the underlying stream. "	^stream position</body><body package="BOSS">position: newPos	" Set the position of the underlying stream. "	^stream position: newPos</body><body package="BOSS">reset	self position: initialPosition</body><body package="BOSS">scanToEnd	" Scan to the end of the stream,	noting the next available object index. "	| reader |	reader := self reader.	[stream atEnd]		whileFalse:			[| range |			range := reader skipNext.			range notNil ifTrue: [nextIndex := nextIndex max: range last + self bytesPerLongOop]]</body><body package="BOSS">setToEnd	" Set the underlying stream to its end. "	stream setToEnd</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage</class-id> <category>private</category><body package="BOSS">reader	" Answer a reader that will read	one object structure from the receiver's stream. "	^readerClass new storage: self on: stream</body><body package="BOSS">writer	" Answer a writer that will write	one object structure on the receiver's stream. "	^writerClass new storage: self on: stream registry: registry</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage</class-id> <category>private - accessing</category><body package="BOSS">addTagBitsTo: anInteger	self subclassResponsibility</body><body package="BOSS">bytesPerLongOop	self subclassResponsibility</body><body package="BOSS">defaultReaderClass	self subclassResponsibility</body><body package="BOSS">defaultWriterClass	self subclassResponsibility</body><body package="BOSS">predefinedObjects	^self class predefinedObjects</body><body package="BOSS">removeTagBitsFrom: anInteger	self subclassResponsibility</body><body package="BOSS">shouldUpdateRegistryObjects	^self class shouldUpdateRegistryObjects</body><body package="BOSS">streamFormatNumber	" Answer the format number supported by this	version of this class. "	^self class streamFormatNumber</body><body package="BOSS">tagBitsFrom: anInteger	self subclassResponsibility</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage</class-id> <category>private-initialize-release</category><body package="BOSS">checkHeader	| format char |	1 to: self headerMagicBytes size do: [:i |		stream next = (self headerMagicBytes at: i) asInteger ifFalse:			[self class headerErrorSignal raise]].	format := 0.	[(char := Character value: stream next) isDigit]		whileTrue:			[format := format * 10 + char digitValue].	char = Character space ifFalse: [self class headerErrorSignal raise].	format = self streamFormatNumber ifFalse: [self class formatErrorSignal raiseWith: format].	self initializeAfterCheckHeader</body><body package="BOSS">firstIndex	" Answer the first index that can be	assigned to an object other than	the predefined ones. "	^self predefinedObjects size * self bytesPerLongOop</body><body package="BOSS">headerMagicBytes	^'BOSS '</body><body package="BOSS">initialize	super initialize.	platformDescription := #[].  "in case client wants to live dangerously, i.e., not use checkHeader"	initialPosition := 0.	self readerClass: self defaultReaderClass.	self writerClass: self defaultWriterClass.	sourceMode := self class defaultSourceMode.	self initializeReadWriteMaps.	self initializePredefinedObjects.	registry := OrderedCollection new.	self		registerGlobal: #Smalltalk;		registerGlobal: #Processor.	expectCycles := false</body><body package="BOSS">initializeAfterCheckHeader	platformDescription := stream next: stream next.	initialPosition := stream position</body><body package="BOSS">initializePredefinedObjects	| pre |	pre := self predefinedObjects.	nextIndex := 0.	(0 to: pre size - 1 * self bytesPerLongOop by: self bytesPerLongOop) with: pre do:		[:objx :obj |			objx &gt; 0 ifTrue: [self atIndex: objx put: obj]		]</body><body package="BOSS">initializeReadWriteMaps	stream isReadable		ifTrue:			[				readerMap := List new: self readWriteMapsInitialSize.				classVarLists := IdentityDictionary new: 40			]		ifFalse:			[				readerMap := nil.				classVarLists := nil			].	writerMap := stream isWritable		ifTrue: [IdentityDictionary new: self readWriteMapsInitialSize]		ifFalse: [nil]</body><body package="BOSS">readWriteMapsInitialSize	^10000</body><body package="BOSS">writeHeader	stream nextPutAll: (self headerMagicBytes, self streamFormatNumber printString , ' ') asByteArray.	platformDescription := ByteArray with: (self imageIsBigEndian ifTrue: [16r80] ifFalse: [0]).	stream		nextPut: platformDescription size;		nextPutAll: platformDescription.	initialPosition := stream position</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage</class-id> <category>reading</category><body package="BOSS">atEnd	"Answer whether the receiver's input stream reached its end."	^stream atEnd</body><body package="BOSS">contents	"Answer the current contents of the receiver's input stream."	| cont |	cont := (Array new: 20) writeStream.	[self atEnd] whileFalse: [cont nextPut: self next].	^cont contents</body><body package="BOSS">next	^self reader next</body><body package="BOSS">nextClasses	^self reader nextClassesWithSource: sourceMode</body><body package="BOSS">skipNext	^self reader skipNext</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage</class-id> <category>initialize-release</category><body package="BOSS">close	"Close the stream that the receiver is accessing."	stream close</body><body package="BOSS">on: aStream 	"Create a new instance of the receiver on aStream, making sure 	that this stream can handle binary reading and writing."	(aStream class canUnderstand: #binary)		ifTrue: [aStream binary].	stream := aStream.	self initialize</body><body package="BOSS">readerClass: aClass	" Set the class for instantiating readers. "	readerClass := aClass</body><body package="BOSS">registerGlobal: globalName	"Register a global object whose value should be reverse-resolved	(This is needed for writing, but not for reading)"	| newRegisteredObject |	newRegisteredObject := BOSSRegisteredObject new		name: globalName		valueBlock: [:varName | self valueForRegistryObjectNamed: varName]		class: self class indexImportGlobal.	registry add: newRegisteredObject</body><body package="BOSS">sourceMode: aSymbol	" Set the mode for handling method sources	and class organizations to #keep, #discard,	or #reference (just store the pointer, on the	assumption that the external source files	will still be there). "	sourceMode := aSymbol</body><body package="BOSS">valueForRegistryObjectNamed: aString	^self class valueForRegistryObjectNamed: aString</body><body package="BOSS">writerClass: aClass	" Set the class for instantiating writers. "	writerClass := aClass</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage</class-id> <category>private - testing</category><body package="BOSS">imageIsBigEndian	^UninterpretedBytes isBigEndian</body><body package="BOSS">imageIsThirtyTwoBit	^self class imageIsThirtyTwoBit</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage</class-id> <category>forgetting</category><body package="BOSS">forgetInterval: anInterval	" Discard any remembered objects	whose indices fall in anInterval. "	self forgetInterval: anInterval excluding: -1</body><body package="BOSS">forgetInterval: anInterval excluding: anIndex 	"Discard any remembered objects 	whose indices fall in anInterval, 	except for the one with index anIndex."	| min max |	min := anInterval first max: self firstIndex.	max := anInterval last.	readerMap == nil		ifFalse:			[readerMap keysAndValuesDo: 				[:i :obj | | index |				index := self addTagBitsTo: i.				(index &gt;= min and: [index &lt;= max and: [index ~= anIndex]])					ifTrue: 						[readerMap at: i put: nil.						writerMap == nil ifFalse: [writerMap removeKey: obj]]]]		ifTrue:			[| killList |			killList := OrderedCollection new.			writerMap keysAndValuesDo:				[:obj :index |				(index &gt;= min and: [index &lt;= max and: [index ~= anIndex]])					ifTrue: [killList add: obj]].			killList do: [:obj | writerMap removeKey: obj]]</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage</class-id> <category>private-reading</category><body package="BOSS">atIndex: anIndex put: anObject	" Register an object at a given index. "	| i |	nextIndex := nextIndex max: anIndex + self bytesPerLongOop.	readerMap == nil		ifFalse: [i := self removeTagBitsFrom: anIndex.				i &gt; readerMap size					ifTrue: [readerMap changeSizeTo: i].				readerMap at: i put: anObject].	writerMap == nil		ifFalse: [writerMap at: anObject put: anIndex]</body><body package="BOSS">isBigEndian	" Answer whether the information stored on	the stream is stored in big-endian format. "	^platformDescription size &gt; 0		ifTrue: [(platformDescription at: 1) anyMask: 16r80]		ifFalse: [self imageIsBigEndian]</body><body package="BOSS">objectAtIndex: anIndex	" Answer the object at the given index.	If there is no object at that index,	answer nil. "	| obj index |	index := self removeTagBitsFrom: anIndex.	obj := (index &lt; 1 or: [index &gt; readerMap size])		ifTrue: [nil]		ifFalse: [readerMap at: index].	^(obj == nil and: [anIndex &lt; self firstIndex ])		ifTrue: [self predefinedObjects at: anIndex // self bytesPerLongOop + 1]		ifFalse: [obj]</body><body package="BOSS">readerBlockFor: aClass 	^versionReaders == nil		ifTrue: [nil]		ifFalse: [versionReaders at: aClass ifAbsent: [nil]]</body><body package="BOSS">readerBlockFor: aClass put: aBlock	versionReaders == nil		ifTrue:	[versionReaders := IdentityDictionary new].	versionReaders at: aClass put: aBlock</body><body package="BOSS">usesReaderBlocks	^versionReaders notNil</body><body package="BOSS">variablesForClass: cls	^classVarLists at: cls</body><body package="BOSS">variablesForClass: cls put: list	classVarLists at: cls put: list</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage</class-id> <category>writing</category><body package="BOSS">nextPut: anObject	self writer nextPut: anObject.	^anObject</body><body package="BOSS">nextPutAll: aCollection 	"Put each of the elements of aCollection	on the stream.  Answer aCollection."	aCollection do: [:v | self nextPut: v].	^aCollection</body><body package="BOSS">nextPutClasses: classes	self writer nextPutClasses: classes withSource: sourceMode</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage</class-id> <category>private-writing</category><body package="BOSS">assignIndexFor: anObject	" Assign the next object index,	and return it. "	| index |	index := nextIndex.	self atIndex: index put: anObject.	^index</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage class</class-id> <category>accessing</category><body package="BOSS">shouldUpdateRegistryObjects	^ShouldUpdateRegistryObjects ifNil: [true]</body><body package="BOSS">shouldUpdateRegistryObjects: aBoolean	ShouldUpdateRegistryObjects := aBoolean.	ShouldUpdateRegistryObjects == true ifTrue: [self registryObjectCache: nil]</body><body package="BOSS">valueForRegistryObjectNamed: aString	self shouldUpdateRegistryObjects ifTrue: [^aString asQualifiedReference value].	^self registryObjectCache		at: aString		ifAbsentPut: [aString asQualifiedReference value]</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage class</class-id> <category>constants</category><body package="BOSS">defaultSourceMode	"What should the default source code policy be if	the user doesn't specify it?"	^#keep</body><body package="BOSS">flagHasForwardReferences	" Answer the flag indicating that	an object contains forward references. "	^16r40</body><body package="BOSS">flagHasShortOops	" Answer the flag indicating that	an object contains 2-byte	rather than 4-byte oops. "	^16r80</body><body package="BOSS">flagIsBits	" Answer the flag indicating that	an object contains bits as opposed to	object references. "	^16r20</body><body package="BOSS">flagIsImmutable	"Answer the flag indicating that an object is immutable."	^16r10</body><body package="BOSS">flagRecentClassMask	" Answer the mask for the recent class	index in the flags. "	^15</body><body package="BOSS">importSelectors	^#(#importByteSymbol: #importSendSelf: #importTwoByteSymbol: #importSend: #importFloat: #importCompiledCode: #importByteString: #importClass: nil #importGlobal: nil #importAssociation: nil #importNameSpace:)</body><body package="BOSS">indexImportAssociation	^12</body><body package="BOSS">indexImportByteString	^7</body><body package="BOSS">indexImportByteSymbol	^1</body><body package="BOSS">indexImportClass	^8</body><body package="BOSS">indexImportCompiledCode	^6</body><body package="BOSS">indexImportFloat	^5</body><body package="BOSS">indexImportGlobal	^10</body><body package="BOSS">indexImportNameSpace	^14</body><body package="BOSS">indexImportSend	^4</body><body package="BOSS">indexImportSendSelf	^2</body><body package="BOSS">indexImportTwoByteSymbol	^3</body><body package="BOSS">predefinedObjects	" Answer the objects that are assigned	the first few object indices.  If you ever	change this list, you will break every	stored structure, so don't do it! "	^#(nil true false)</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage class</class-id> <category>private - testing</category><body package="BOSS">imageIsThirtyTwoBit	^SmallInteger maxVal = 536870911</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage class</class-id> <category>documentation</category><body package="BOSS">fileFormat	"The file format differs between the 32 and 64 bit implementations.	See the subclasses for more information"	self commentOnly</body><body package="BOSS">specialWriters	"Objects of a given class may write themselves out in a special way.	There are two ways to do this.	- BOSSReader may have a special reading mechanism for that class	built into it. This is the most efficient in both space and time, but it	requires that the reader and writer be compatible in their	assignment of special reader codes, which are integers. We attempt	to keep the number of such codes down to an absolute minimum.	- An object may write itself out as &lt;receiver, selector, arguments&gt;.	The reader will send the message to reconstruct the object.		Note that in either of these cases, if the object is involved in a	circular structure, it is possible that the receiver or an argument may	not be fully instantiated when the special reader or the message is	invoked. We haven't yet been able to think of an uncontrived case	where this could cause a problem."		" If an object wants to write itself out specially,	it must implement the method		representBinaryOn: binWriter	This message must return one of the following four things:	- 0, meaning write out nil instead of the object;	- nil, meaning use the standard representation after all;	- a MessageSend, which will be executed at reading time;	- an Association consisting of (aSpecialReaderIndex -&gt; anObject),	which indicates that a special reader action is required. "	self commentOnly</body><body package="BOSS">structureFormat	"The structure format differs between the 32 and 64 bit implementations.	See the subclasses for more information"	self commentOnly</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage class</class-id> <category>class initialization</category><body package="BOSS">initialize	"BinaryObjectStorage initialize"	self initializeSignals</body><body package="BOSS">initializeSignals	"BinaryObjectStorage initializeSignals"	BinaryErrorSignal := Object errorSignal newSignalMayProceed: false.	BinaryErrorSignal		nameClass: self message: #errorSignal;		notifierString: 'BOSS error'.	HeaderErrorSignal := BinaryErrorSignal newSignal.	HeaderErrorSignal		nameClass: self message: #headerErrorSignal;		notifierString: 'Invalid BOSS file'.	FormatErrorSignal := BinaryErrorSignal newSignal.	FormatErrorSignal		nameClass: self message: #formatErrorSignal;		notifierString: 'Incompatible BOSS file format'.</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage class</class-id> <category>signal constants</category><body package="BOSS">errorSignal	^BinaryErrorSignal</body><body package="BOSS">formatErrorSignal	^FormatErrorSignal</body><body package="BOSS">headerErrorSignal	^HeaderErrorSignal</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage class</class-id> <category>private - accessing</category><body package="BOSS">registryObjectCache	| answer |	RegistryObjectCache notNil ifTrue: [^RegistryObjectCache].	answer := Dictionary new.	self registryObjectCache: answer.	^answer</body><body package="BOSS">registryObjectCache: aDictionary	RegistryObjectCache := aDictionary</body><body package="BOSS">streamFormatNumber	"Answer the format number supported by this	version of this class"	self subclassResponsibility</body></methods><methods><class-id>Kernel.AbstractBinaryObjectStorage class</class-id> <category>instance creation</category><body package="BOSS">onNew: aStream	"Answer an instance of the receiver	for writing object structures on aStream.	Any previous contents of aStream are lost."	^self newInstance		on: aStream;		writeHeader;		yourself</body><body package="BOSS">onOld: aStream	"Answer an instance of the receiver	for reading object structures from aStream.	The contents of aStream must	have been written by a BinaryObjectStorage."	| answer |	answer := self onOldNoScan: aStream.	answer scanToEnd; reset.	^answer</body></methods><methods><class-id>Kernel.BinaryObjectStorage</class-id> <category>private - accessing</category><body package="BOSS">addTagBitsTo: anInteger	^anInteger bitShift: 2</body><body package="BOSS">bytesPerLongOop	^4</body><body package="BOSS">defaultReaderClass	^self imageIsThirtyTwoBit		ifTrue: [BOSSReader]		ifFalse: [BOSSReader32]</body><body package="BOSS">defaultWriterClass	^self imageIsThirtyTwoBit		ifTrue: [BOSSWriter]		ifFalse: [BOSSWriter32]</body><body package="BOSS">removeTagBitsFrom: anInteger	^anInteger bitShift: -2</body><body package="BOSS">tagBitsFrom: anInteger	^anInteger bitAnd: 3</body></methods><methods><class-id>Kernel.BinaryObjectStorage class</class-id> <category>instance creation</category><body package="BOSS">onOldNoScan: aStream	"Answer an instance of the receiver	for reading object structures from aStream.	Do not scan to the end of the stream	to find the next assignable object index.	The contents of aStream must	have been written by a BinaryObjectStorage."	| answer |	answer := self newInstance.	answer on: aStream.	answer checkHeader.	^answer</body></methods><methods><class-id>Kernel.BinaryObjectStorage class</class-id> <category>documentation</category><body package="BOSS">fileFormat	"Each file starts with an identifying header consisting of the 5	characters 'BOSS ', a decimal integer to identify the BOSS version	number, and another space. This is the only part of the header	guaranteed to stay the same from one version of BOSS to the next.	Ow\ST release 2.5 BOSS was version 5; release 4, APOK beta was	version 6; release 4, APOK product is version 7. The latter two differ	only in that the product version has byte ordering information	immediately following the file header."	"Immediately following the file header is a single byte giving the	number of bytes of platform description, and then that many	additional bytes of description. Currently, only one bit of the	platform description is used: bit 7 (the high-order bit) of the first	byte, which is 0 if multi-byte quantities are stored low order byte	first, 1 if they are stored high order byte first."	"Objects within a single stream or file are numbered with unique	indices that are multiples of 4 starting at 0. Objects 0, 4, and 8 are	nil, true, and false; the first object written on the file or stream is	numbered 12."	self commentOnly</body><body package="BOSS">structureFormat	"If a structure consists of a single immediate quantity, or a single	reference to an already encoded object, the structure just consists of	a single 4-byte word containing the encoded oop (see below).	Otherwise, the structure consists of a prefix, a sequence of headers,	and object data. The prefix always starts with a 4-byte word where	bits [30:0] are the object index of the first object that follows, +2	(i.e., bits [1:0] are 10). Bit 31 (the sign bit) selects one of two	different formats:	- If the structure consists of a single object, bit 31=1. This is	followed by exactly one header and then the object data. (This is	just an optimization to remove 12 bytes of overhead from	single-object structures.)	- If the structure consists of more than one object, bit 31=0. In this	case the prefix is followed by:		- The index of the top object in the structure (4 bytes) -- note		that this will almost never be the first object;		- The number of objects in the sequence (4 bytes);		- The number of bytes of object data (4 bytes)."	"Each header consists of:	- The object's class (an encoded oop, see below: 4 bytes);	- Flags, 1 byte consisting of:		bit 7: 1 if the object is a pointer-type object with 2-byte oops, 0		  otherwise.		bit 6: 1 if the object is a pointer-type object containing forward		  references, 0 otherwise.		bit 5: 1 if the object is byte-type, 0 if the object is pointer-type.		bit 4: 1 if the object is immutable.		bits [3:0] - 0 or a recent class number (see below).	- The object's data size in bytes (1 byte, set to 16rff if the object is	255 bytes or larger);	- The object's identityHash (2 bytes).		The object reader keeps a buffer of the last 15 classes encountered.	If the recent class number field in the flags is non-zero, it refers to	an entry in this buffer: 1 is the most recent, 2 is the next most	recent, and so on. If the recent class number field in the flags is 0,	the object's class is an encoded oop (2 or 4 bytes) preceding the	object's data; this class becomes entry 1 in the recent class buffer,	former entries 1-14 become 2-15, and entry 15 is discarded.	(Objects containing forward references are an exception: they always	include an explicit class, and do not affect the recent class buffer.)	When the reader starts reading an object structure, the buffer is	initialized to contain the integers 1 (most recent) through 15.		Object data is in the same order as the object headers."	"The data for pointer-type objects consist of encoded oops. An	encoded oop is a 2- or 4-byte quantity. The low-order 2 bits serve	as a tag. The tag values are:		- 00: the 16 or 32 bits are an object index within the entire file.		- 10: the 16 or 32 bits are an index relative to the base index of		this object structure, +2.		- 01: top 14 or 30 bits are a Character value.		- 11: top 14 or 30 bits are a non-negative SmallInteger.		If the 'class' of an object is a SmallInteger, this object is interpreted	specially. The data for the object are bytes if the 'class' is odd,	pointers (encoded oops) if the 'class' is even. After collecting the	data, the reader uses the 'class' as an index in a table of selectors: it	then performs this selector with the reader itself as the receiver and	the object data as the argument. The result of the perform is then	used as the object."	self commentOnly</body></methods><methods><class-id>Kernel.BinaryObjectStorage class</class-id> <category>private - accessing</category><body package="BOSS">streamFormatNumber	" Answer the format number supported by this	version of this class. "	^7</body></methods><methods><class-id>Kernel.BinaryObjectStorage class</class-id> <category>private - instance creation</category><body package="BOSS">newInstance	^self basicNew</body></methods><methods><class-id>Kernel.BOSSBytes</class-id> <category>accessing</category><body package="BOSS">objectAt: datax objectMap: objMap baseIndex: baseIndex	" Decode the encoded oop at byte index	datax in the receiver.  objMap is the table of	decoded objects.  baseIndex is the object	index of the first element of the table. "	| tag vx value |	" Ordinarily we would just get the oop by	self unsignedLongAt: datax.  However, if	the oop is a SmallInteger of more than	27 bits, this would cause an unnecessary	LargeInteger to be created.  As it happens,	this is precisely the case for two of the	instance variables of short CompiledMethods.	The time penalty for this is so large that	we make an explicit byte ordering check and	extract the oop in two shorts. "	UninterpretedBytes isBigEndian		ifTrue:			[tag := self unsignedShortAt: datax + 2.			vx := datax]		ifFalse:			[tag := self unsignedShortAt: datax.			vx := datax + 2].	^(tag bitAnd: 1) = 0		ifFalse:			[value := ((self shortAt: vx) bitShift: 14) + (tag bitShift: -2).			(tag bitAnd: 2) = 0				ifTrue: [objMap mapXeroxToUnicode					ifTrue: [Character value: (BOSSReader mapToUnicode: value)]					ifFalse: [Character value: value]]				ifFalse: [value]]		ifTrue:			[value := self unsignedLongAt: datax.			(tag bitAnd: 2) = 0				ifTrue: [objMap at: value]				ifFalse: [objMap at: value - 2 + baseIndex]]</body><body package="BOSS">replaceBytesFrom: startIndex with: src	| si |	si := startIndex - 1.	1 to: src basicSize do: [:i | self basicAt: si + i put: (src basicAt: i)]</body><body package="BOSS">shortObjectAt: datax objectMap: objMap baseIndex: baseIndex	" Decode the encoded oop at byte index	datax in the receiver.  objMap is the table of	decoded objects.  baseIndex is the object	index of the first element of the table. "	| int value |	int := self unsignedShortAt: datax.	^(int bitAnd: 1) = 0		ifFalse:			[value := int bitShift: -2.			(int bitAnd: 2) = 0				ifTrue: [objMap mapXeroxToUnicode					ifTrue: [Character value: (BOSSReader mapToUnicode: value)]					ifFalse: [Character value: value]]				ifFalse: [value]]		ifTrue:			[(int bitAnd: 2) = 0				ifTrue: [objMap at: int]				ifFalse: [objMap at: int - 2 + baseIndex]]</body></methods><methods><class-id>Kernel.BOSSBytes</class-id> <category>UninterpretedBytes accessing</category><body package="BOSS">longAt: byteIndex	&lt;primitive: 546&gt;	^self primitiveFailed</body><body package="BOSS">longAt: byteIndex put: aLong	&lt;primitive: 547&gt;	^self primitiveFailed</body><body package="BOSS">longLongAt: byteIndex	"Answer a signed long long (64 bit) quantity starting at the given byteIndex."	&lt;primitive: 554&gt;	^self primitiveFailed</body><body package="BOSS">longLongAt: byteIndex put: aLongLong	"Store a signed long long (64 bit) quantity starting at the given byteIndex."	&lt;primitive: 555&gt;	^self primitiveFailed</body><body package="BOSS">shortAt: byteIndex	&lt;primitive: 542&gt;	| word |	word := self unsignedShortAt: byteIndex.	^(word bitAnd: 16r7FFF) - (word bitAnd: 16r8000)</body><body package="BOSS">unsignedLongAt: byteIndex	&lt;primitive: 544&gt;	^self primitiveFailed</body><body package="BOSS">unsignedLongAt: byteIndex put: anUnsignedLong	&lt;primitive: 545&gt;	^self primitiveFailed</body><body package="BOSS">unsignedLongLongAt: byteIndex	"Answer an unsigned long long (64 bit) quantity starting at the given byteIndex."	&lt;primitive: 552&gt;	^self primitiveFailed</body><body package="BOSS">unsignedLongLongAt: byteIndex put: anUnsignedLongLong	"Store an unsigned long long (64 bit) quantity starting at the given byteIndex."	&lt;primitive: 553&gt;	^self primitiveFailed</body><body package="BOSS">unsignedShortAt: byteIndex	&lt;primitive: 540&gt;	^self primitiveFailed</body><body package="BOSS">unsignedShortAt: byteIndex put: anUnsignedShort	&lt;primitive: 541&gt;	^self primitiveFailed</body></methods><methods><class-id>Kernel.BOSSBytes</class-id> <category>byte endianness</category><body package="BOSS">swapColumn: c0 with: c1	" Swap bytes at indices 4N+c0+1 with	those at indices 4N+c1+1. "	1 to: self size by: 4 do:		[:i |			| t |			t := self at: i + c0.			self at: i + c0 put: (self at: i + c1).			self at: i + c1 put: t		]</body></methods><methods><class-id>Kernel.BOSSReaderMap</class-id> <category>accessing</category><body package="BOSS">at: index	"This handles out-of-range indices by trying an access to the array0"	^self primitiveAt: (index bitShift: -2) - baseIndex</body></methods><methods><class-id>Kernel.BOSSReaderMap</class-id> <category>private</category><body package="BOSS">primitiveAt: index	&lt;primitive: 60&gt;	^storage objectAtIndex: (index + baseIndex bitShift: 2)</body></methods><methods><class-id>Kernel.BOSSReaderMap</class-id> <category>private - accessing</category><body package="BOSS">at: index put: value	"This only works for in-range indices"	storage atIndex: index put: value.	^self basicAt: (index bitShift: -2) - baseIndex put: value</body><body package="BOSS">bitsPerIndex	^2</body><body package="BOSS">bytesPerLongOop	^4</body></methods><methods><class-id>Core.Metaclass</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	" Classes are represented by their names,	under the assumption that they are all	present in the Smalltalk dictionary.	We also include a class/metaclass flag,	the version number, and the instance format	and variable names for checking. "	| args |	args := Array new: 5.	args at: 1 put: self soleInstance fullName.	args at: 2 put: true.	args at: 3 put: self binaryRepresentationVersion.	args at: 4 put: self format.	args at: 5 put: (self instSize = 0					ifTrue: [nil]					ifFalse: [self allInstVarNames asArray]).	^AbstractBinaryObjectStorage indexImportClass -&gt; args</body><body package="BOSS">representContentsBinaryOn: binWriter	" Store the methods and organization. "	^MessageSend		receiver: self soleInstance		selector: #classSideInstanceVariableNames:		argument: self instanceVariablesString</body></methods><methods><class-id>Core.SortedCollection class</class-id> <category>instance creation</category><body package="BOSS">fromSortedArray: aCollection sortBlock: aBlock 	"Answer a new SortedCollection with the given elements and sortBlock. 	Since this is used by BOSS, and aBlock may not really be an instance of 	BlockClosure, assume that the collection is sorted and do not resort it."	| newCollection |	newCollection := self new: aCollection size.	newCollection sortBlock: aBlock.	newCollection addAllWithoutSorting: aCollection.	^newCollection</body></methods><methods><class-id>Core.SortedCollection</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	" Represent a SortedCollection by	its contents (elements) and its sortBlock. "	^sortBlock == DefaultSortBlock		ifTrue: [super representBinaryOn: binWriter]		ifFalse:			[MessageSend				receiver: self class				selector: #fromSortedArray:sortBlock:				arguments: (Array with: self asArray with: sortBlock)]</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	" Represent an OrderedCollection by	its contents (elements). "	^MessageSend		receiver: self class		selector: #withAll:		argument: (self isEmpty ifTrue: [#()] ifFalse: [self asArray])</body></methods><methods><class-id>OS.OSHandle</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: bosWriter	self notify: 'OSHandles cannot be stored by BOSS.'.	^0</body></methods><methods><class-id>UI.Label class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new |			new := Array new: oldObj size+1.			new replaceFrom: 1 to: 5 with: oldObj startingAt: 1.			new replaceFrom: 7 to: new size with: oldObj startingAt: 6.			oldObj become: new.			oldObj changeClassToThatOf: inst]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body></methods><methods><class-id>Core.Object</class-id> <category>binary storage</category><body package="BOSS">binaryRepresentationVersion	" Answer a version identification for	the particular representation that	the receiver uses for representBinaryOn:.	(The version identification need not	be an integer, or even a number.)	The default version identification	for the initial BOSS representation is nil. "	^nil</body><body package="BOSS">representBinaryOn: binWriter	" By default, objects do nothing special	to represent themselves in binary form. "	^nil</body></methods><methods><class-id>Core.LimitedPrecisionReal</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	" This is where we would do the right thing	in the unlikely event that this machine	doesn't use IEEE representation.	The only machine in common use with this	bug is the VAX, which we don't support.	(Regardless of representation, we need a special	representation to get the correct byte ordering	at reading time.) "	^AbstractBinaryObjectStorage indexImportFloat -&gt; self</body></methods><methods><class-id>Core.WeakDictionary class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new |			new := Array new: oldObj size+1.			new replaceFrom: 1 to: 3 with: oldObj startingAt: 1.				"Add access lock"			new at: 4 put: RecursionLock new.			new replaceFrom: 5 to: new size with: oldObj startingAt: 4.			oldObj become: new.			oldObj changeClassToThatOf: inst]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	" Answer a version identification for	the particular representation that	the receiver uses for representBinaryOn:."	^'Release 4.1'</body></methods><methods><class-id>Kernel.CompiledCode class</class-id> <category>binary storage</category><body package="BOSS">binaryRepresentationVersion	" Answer a version identification for	the particular representation that	the receiver uses for representBinaryOn:.	(The version identification need not	be an integer, or even a number.)"	^'Release 4.1'</body></methods><methods><class-id>External.CEnumerationType class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	"An attempt is being made to read instances of an obsolete version of this class.  Answer a block that converts old instances (represented as an array or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new oldDict |			new := Array new: 2.			new replaceFrom: 1 to: 2 with: oldObj startingAt: 1.			new changeClassToThatOf: inst.			oldDict := oldObj at: 3.			(oldObj at: 4) do: [:memberName |				new at: memberName put: (oldDict at: memberName)].			oldObj become: new.			oldObj]].	oldVersion = 'Release 2.0'		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | oldDict new |			"Flatten memberDictionary and memberIdentifiers."			new := Array new: 2.			new replaceFrom: 1 to: 2 with: oldObj startingAt: 1.			new changeClassToThatOf: inst.			oldDict := oldObj at: 3.			(oldObj at: 4) do: [:memberName |				new at: memberName put: (oldDict at: memberName)].			oldObj become: new.			oldObj]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	"Answer a version identification for the particular representation that the receiver uses for representBinaryOn:."	^'Release 2.5'</body></methods><methods><class-id>UI.ScheduledWindow class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	"An attempt is being made to read instances of an obsolete version of this class.  Answer a block that converts old instances (represented as an array or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new |			new := Array new: oldObj size+3.			new replaceFrom: 1 to: 3 with: oldObj startingAt: 1.			new replaceFrom: 4 to: 7 with: oldObj startingAt: 5.				"Add isIconic"			new at: 8 put: false.			new replaceFrom: 9 to: 14 with: oldObj startingAt: 9.			new replaceFrom: 17 to: 18 with: oldObj startingAt: 15.			new replaceFrom: 20 to: new size with: oldObj startingAt: 17.			oldObj become: new.			oldObj changeClassToThatOf: inst]].	oldVersion = 'Release 4.1'		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new |			"Add damageRepairPolicy"			new := Array new: oldObj size + 1.			new replaceFrom: 1 to: 18 with: oldObj startingAt: 1.			new replaceFrom: 20 to: new size with: oldObj startingAt: 19.			new at: oldObj size put: nil.			oldObj become: new.			oldObj changeClassToThatOf: inst]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	"Answer a version identification for the particular representation that the receiver uses for representBinaryOn:."	^'VisualWorks Release 2.0'</body></methods><methods><class-id>Kernel.LocalScope class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new |			new := Array new: oldObj size+1.			new replaceFrom: 1 to: 4 with: oldObj startingAt: 1.			new replaceFrom: 6 to: new size with: oldObj startingAt: 5.			oldObj become: new.			oldObj changeClassToThatOf: inst.			oldObj permitDuplicateNames: false]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	" Answer a version identification for	the particular representation that	the receiver uses for representBinaryOn:."	^'Release 4.1'</body></methods><methods><class-id>Kernel.MethodDictionary class</class-id> <category>instance creation</category><body package="BOSS">withKeysAndValues: keyAndValueArray	" Answer an instance whose keys and values	are obtained from alternate elements of the	keyAndValueArray. "	| dict |	dict := self new: keyAndValueArray size.	1 to: keyAndValueArray size by: 2 do: [:i |		dict at: (keyAndValueArray at: i) put: (keyAndValueArray at: i + 1)].	^dict</body></methods><methods><class-id>Kernel.MethodDictionary</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	"Since a MethodDictionary doesn't actually	store Associations, represent it more efficiently	as a sequence of keys and values. "	^MessageSend		receiver: self class		selector: #withKeysAndValues:		argument: (self shallowCopy changeClassToThatOf: #())</body></methods><methods><class-id>Tools.NamedChangeSet class</class-id> <category>private</category><body package="BOSS">currentTag	^-666</body></methods><methods><class-id>Tools.NamedChangeSet</class-id> <category>private</category><body package="BOSS">currentTag	^self class currentTag</body></methods><methods><class-id>Tools.NamedChangeSet</class-id> <category>binary storage</category><body package="BOSS">methodListForPackage	^self messageListForPackage collect: [:assoc | assoc key compiledMethodAt: assoc value]</body></methods><methods><class-id>External.CCompositeType class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	"An attempt is being made to read instances of an obsolete version of this class.  Answer a block that converts old instances (represented as an array or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self new.			^[:oldObj | | new oldDict i |			"Remove metaType, datumClass, pointerClass"			"Flatten memberDictionary and memberIdentifiers."			oldDict := oldObj at: 3.			new := Array new: 4 + (oldDict size * self slotsPerMember).			new replaceFrom: 1 to: 2 with: oldObj startingAt: 1.			new replaceFrom: 3 to: 4 with: oldObj startingAt: 5.			i := 4.			(oldObj at: 4) do: [:memberName | | assoc |				assoc := oldDict at: memberName.				new					at: (i := i + 1) put: memberName;					at: (i := i + 1) put: assoc key;					at: (i := i + 1) put: assoc value;					at: (i := i + 1) put: 0;					at: (i := i + 1) put: nil].			new changeClassToThatOf: inst.			(oldObj at: 7) == #struct				ifTrue: [new beStructure]				ifFalse: [new beUnion].			oldObj become: new.			oldObj]].	oldVersion = 'Release 2.0'		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | oldDict new i |			"Flatten memberDictionary and memberIdentifiers."			oldDict := oldObj at: 3.			new := Array new: 4 + (oldDict size * self slotsPerMember).			new replaceFrom: 1 to: 2 with: oldObj startingAt: 1.			new replaceFrom: 3 to: 4 with: oldObj startingAt: 5.			i := 4.			(oldObj at: 4) do: [:memberName | | assoc |				assoc := oldDict at: memberName.				new					at: (i := i + 1) put: memberName;					at: (i := i + 1) put: assoc key;					at: (i := i + 1) put: assoc value;					at: (i := i + 1) put: 0;					at: (i := i + 1) put: nil].			new changeClassToThatOf: inst.			oldObj become: new.			oldObj]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	"Answer a version identification for the particular representation that the receiver uses for representBinaryOn:."	^'Release 2.5'</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>binary storage</category><body package="BOSS">binaryInitializationMessagesFor: sourceMode	"Answer a list of message sends used to initialize the receiver."	"This method places the initialization of the receiver's externals before the initialization of the remainder of the class so that the receiver can use the externals during class initialization (for example, in the #initialize method)."	| list |	list := OrderedCollection with:		(MessageSend			receiver: self			selector: #ownExternalAssociations:			argument: self ownExternalAssociations).	list addAll: (super binaryInitializationMessagesFor: sourceMode).	^list</body><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	"An attempt is being made to read instances of an obsolete version of this class.  Answer a block that converts old instances (represented as an array or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self new.			^[:oldObj | | new |			new := Array new: oldObj size - 1.			new replaceFrom: 1 to: oldObj size - 1 with: oldObj startingAt: 2.			oldObj become: new.			oldObj changeClassToThatOf: inst.			oldObj]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	"Answer a version identification for the particular representation that the receiver uses for representBinaryOn:."	^'Release 2.0'</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>private boss</category><body package="BOSS">bossDefinitionMessage	"Answer a MessageSend that defines the receiver and the receiver's externalDictionary."	^MessageSend		receiver: superclass		selector: #subclass:includeFiles:includeDirectories:libraryFiles:libraryDirectories:generateMethods:beVirtual:optimizationLevel:instanceVariableNames:classVariableNames:poolDictionaries:category:externalKeys:		arguments:			(self definitionMessageArguments, (Array with: self externals ownKeys asArray))</body><body package="BOSS">definitionMessageArguments	"Answer an Array of values that should be used as the arguments to the receiver's instance creation message."	| arguments |	arguments := Array new: 12.	arguments		at: 1 put: self name;		at: 2 put: (self makeString: includeFiles);		at: 3 put: self includeDirectoriesString;		at: 4 put: self libraryFilesString;		at: 5 put: self libraryDirectoriesString;		at: 6 put: '';		at: 7 put: self isVirtual;		at: 8 put: self optimizationLevel;		at: 9 put: self instanceVariablesString;		at: 10 put: self classVariablesString;		at: 11 put: self sharedPoolsString;		at: 12 put: self category asString.	^arguments</body><body package="BOSS">includeDirectoriesString	includeDirectories isNil ifTrue: [^''].	^self makeString: (includeDirectories ownCollect: [:inc | inc])</body><body package="BOSS">libraryDirectoriesString	libraryDirectories isNil ifTrue: [^''].	^self makeString: (libraryDirectories ownCollect: [:lib | lib])</body><body package="BOSS">libraryFilesString	libraryFiles isNil ifTrue: [^''].	^self makeString: (libraryFiles ownCollect: [:lib | lib name])</body><body package="BOSS">makeString: aStringCollection	"Answer a new String that is a copy of the argument strings separated by spaces"		| aStream  |	aStringCollection isNil ifTrue: [^''].	aStream := WriteStream on: (String new: 100).	aStringCollection do: [:each | aStream nextPutAll: each; space].	^aStream contents</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>private</category><body package="BOSS">ownExternalAssociations	"Answer an Array of the associations contained in the receiver's externals dictionary.  Only answer those actually contained in the receiver's external dictionary and not any in its superclass."	"We add a copy of the association so BOSS readers don't map the original association to the values answered by this method."	| associations |	associations := OrderedCollection new.	self externals ownAssociationsDo: [:anAssoc |		associations add: anAssoc copy].	^associations asArray</body><body package="BOSS">ownExternalAssociations: keyValueArray	"The argument consists of the keys and values of the receiver's own externals.  Set the value in the current external dictionary based on the given key.  This message is typically sent by BOSS readers during a Class fix-up mode.  It is currently intended as a work-around for the Class cycle introduced by external objects."	"Perform the necessary fix-up of the new associations (i.e. weaken them) and inform the system of possible structure realignment."	| myExternals |	myExternals := self externals.	keyValueArray do: [:aKeyValue |		myExternals at: aKeyValue key put: aKeyValue value].	myExternals ownKeysDo: [:key | | external |		external := (myExternals associationAt: key) value.		myExternals weakenAt: key.		(external isKindOf: ExternalObject) ifTrue: [external releaseHandle]].	CCompositeType realign</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>binary storage</category><body package="BOSS">representContentsBinaryOn: binWriter	"Represent the receiver in a binary form on the argument."	"If the receiver is a subclass of ExternalInterface, use the correct definition message, otherwise use the default."	self == ExternalInterface		ifTrue: [^super representContentsBinaryOn: binWriter]		ifFalse: [^self bossDefinitionMessage]</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>creating subclasses</category><body package="BOSS">subclass: t includeFiles: df includeDirectories: id libraryFiles: lf libraryDirectories: ld generateMethods: gm beVirtual: bv optimizationLevel: optLevel instanceVariableNames: f classVariableNames: d poolDictionaries: s category: cat externalKeys: externalKeys	"This is the enhanced initialization message for creating a new class as a subclass of the receiver.  Answer the new subclass.  This method is invoked by BOSSReaders."	"The last argument, externalKeys, is an array of keys used to create the proper associations in the new subclass's externals dictionary.  This class definition message will create dummy associations using these keys.  These associations are used by the subclass's compiled methods.  When the subclass is completely BOSS'ed in, the final operation is to replace the value's of the association with the correct value -- this has been done to avoid circular references between the association values and the new subclass; we consider this only a temporary work-around."	| subclass subclassExternals |	subclass := self subclass: t		includeFiles: df		includeDirectories: id		libraryFiles: lf		libraryDirectories: ld		generateMethods: gm		beVirtual: bv		optimizationLevel: optLevel		instanceVariableNames: f		classVariableNames: d		poolDictionaries: s		category: cat.	subclassExternals := subclass externals.	externalKeys do: [:aKey |		subclassExternals			ownAt: aKey			ifAbsent: [subclassExternals at: aKey put: nil]].	^subclass</body></methods><methods><class-id>Kernel.CompiledMethod class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones."	oldVersion = nil		ifTrue:			[^[:oldObj | | new oldInstSize |				oldInstSize := oldFormat bitAnd: 255.				new := self new: oldObj size - oldInstSize.				new instVarAt: 1 put: (oldObj at: 1).				new mclass: Object.  "We can't find out what the mclass ought to be yet"				"Everything after the bytes needs to be shifted to make room for mclass"				2 to: oldObj size do:					[:i | new instVarAt: i+1 put: (oldObj at: i)].				new become: oldObj				]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: bosWriter	" The stored representation of	CompiledMethods is special. "	^bosWriter representCompiledMethod: self</body></methods><methods><class-id>Kernel.CompiledBlock class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones."	oldVersion = nil		ifTrue:			[^[:oldObj | | new oldInstSize |				oldInstSize := oldFormat bitAnd: 255.				new := self new: oldObj size - oldInstSize.				new instVarAt: 1 put: (oldObj at: 1).				new instVarAt: 2 put: (oldObj at: 3).				"Copy the indexed instance variables"				4 to: oldObj size do:					[:i | new instVarAt: i-1 put: (oldObj at: i)].				new become: oldObj				]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body></methods><methods><class-id>External.ExternalDictionary</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	self fillDefineCaches.	^super representBinaryOn: binWriter</body></methods><methods><class-id>Kernel.GeneralBindingReference class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new |			oldObj size = self instSize				ifFalse:					[oldObj size + 1 = self instSize						ifFalse: [self error: 'not enough information to describe the old object'].					new := Array new: self instSize.					new at: 1 put: (oldObj at: 1).					new replaceFrom: 3 to: self instSize with: oldObj startingAt: 2.					oldObj become: new].			oldObj changeClassToThatOf: inst]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	" Answer a version identification for	the particular representation that	the receiver uses for representBinaryOn:."	^'VisualWorks 7.2.1'</body></methods><methods><class-id>Core.Behavior</class-id> <category>constants</category><body package="BOSS">formatMask	" Answer a mask of all the significant bits in the format instance variable."	^16r1DFFF</body></methods><methods><class-id>External.CQualifiedType class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	"An attempt is being made to read instances of an obsolete version of this class.  Answer a block that converts old instances (represented as an array or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new specifiers |			"Remove segment"			new := Array new: oldObj size.			new at: 1 put: 0.			new replaceFrom: 2 to: new size with: oldObj startingAt: 2.			specifiers := oldObj at: 1.			oldObj become: new.			oldObj changeClassToThatOf: inst.			(specifiers bitAnd: 128) ~~ 0 ifTrue: [oldObj bePascal].			(specifiers bitAnd: 256) ~~ 0 ifTrue: [oldObj beConstant].			(specifiers bitAnd: 512) ~~ 0 ifTrue: [oldObj beVolatile].			(specifiers bitAnd: 1024) ~~ 0 ifTrue: [oldObj beSeg16].			oldObj]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	"Answer a version identification for the particular representation that the receiver uses for representBinaryOn:."	^'Release 2.0'</body></methods><methods><class-id>External.CProcedureType class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	"An attempt is being made to read instances of an obsolete version of this class.  Answer a block that converts old instances (represented as an array or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new specifiers argTypes |			argTypes := oldObj at: 3.		"argumentTypes"			new := Array new: argTypes size + 3.			new at: 1 put: 0.			"specifierFlags"			new at: 2 put: (oldObj at: 5).	"argumentNames"			new at: 3 put: (oldObj at: 2).	"resultType"			new replaceFrom: 4 to: new size with: argTypes.			specifiers := oldObj at: 1.			oldObj become: new.			oldObj changeClassToThatOf: inst.			(new at: 8) == #far ifTrue: [oldObj beFar].			(new at: 7) == #pascal ifTrue: [oldObj bePascal].			(new at: 7) == #c ifTrue: [oldObj beCdecl].			(specifiers bitAnd: 16) ~~ 0 ifTrue: [oldObj beVarArg].			(specifiers bitAnd: 32) ~~ 0 ifTrue: [oldObj beNoCallback].			(specifiers bitAnd: 64) ~~ 0 ifTrue: [oldObj beLongcomp].			oldObj]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	"Answer a version identification for the particular representation that the receiver uses for representBinaryOn:."	^'Release 2.0'</body></methods><methods><class-id>Core.IdentityDictionary</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	" Since an IdentityDictionary doesn't actually	store Associations, represent it more efficiently	as a sequence of keys and values. "	| cont creator |	cont := (Array new: self size * 2) writeStream.	self keysAndValuesDo: [:key :value | cont nextPut: key; nextPut: value].	creator := (MessageSend			receiver: self class			selector: #withKeysAndValues:			argument: cont contents).	^binWriter expectCycles		ifTrue: [AbstractBinaryObjectStorage indexImportSendSelf -&gt;			(Array				with: #createSpecialObject:				with: (BOSSSpecialObjectLoader message: creator))]		ifFalse: [creator]</body></methods><methods><class-id>External.CArrayType class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	"An attempt is being made to read instances of an obsolete version of this class.  Answer a block that converts old instances (represented as an array or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new segment |			new := Array new: oldObj size - 4.			"Remove pointerKind, pointerClass, segment"			new at: 1 put: 0.			new at: 2 put: (oldObj at: 3).			"Remove datumClass"			new at: 3 put: (oldObj at: 6).			4 to: new size do: [:i | new at: i put: (oldObj at: i + 4)].			segment := oldObj at: 5.			oldObj become: new.			oldObj changeClassToThatOf: inst.			segment == #far ifTrue: [oldObj beFar].			segment == #huge ifTrue: [oldObj beFar].			segment == #near ifTrue: [oldObj beNear].			oldObj]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body></methods><methods><class-id>Graphics.BoundedWrapper class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | t |				"Swap extent and layout"			t := oldObj at: 4.			oldObj at: 4 put: (oldObj at: 5).			oldObj at: 5 put: t.			oldObj changeClassToThatOf: inst]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	" Answer a version identification for	the particular representation that	the receiver uses for representBinaryOn:."	^'Release 4.1'</body></methods><methods><class-id>UI.ValueHolder class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new |			new := Array new: oldObj size-2.			new at: 1 put: (oldObj at: 1).			new at: 2 put: (oldObj at: 3).			new replaceFrom: 3 to: new size with: oldObj startingAt: 5.			oldObj become: new.			oldObj changeClassToThatOf: inst]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body></methods><methods><class-id>Graphics.GraphicsHandle</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: bosWriter	self notify: (#notifyGraphicsBoss &lt;&lt; #dialogs &gt;&gt; 'GraphicsHandles cannot be stored by BOSS.').	^0</body></methods><methods><class-id>External.CScalarType</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	^MessageSend		receiver: self class		selector: storeSelector</body></methods><methods><class-id>OS.HandleRegistry class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj |			oldObj changeClassToThatOf: inst]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body></methods><methods><class-id>External.ExternalLibrary class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	"An attempt is being made to read instances of an obsolete version of this class.  Answer a block that converts old instances (represented as an array or string of instance variable values) to new ones."	oldVersion == nil ifTrue: [^[:oldObj | nil]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	"Answer a version identification for the particular representation that the receiver uses for representBinaryOn:."	^'Release 2.0'</body></methods><methods><class-id>UI.TextCollector class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new |			new := Array new: oldObj size-1.			new replaceFrom: 1 to: 2 with: oldObj startingAt: 1.				"Remove isLocked"			new replaceFrom: 3 to: new size with: oldObj startingAt: 4.			oldObj become: new.			oldObj changeClassToThatOf: inst]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body></methods><methods><class-id>Core.Dictionary class</class-id> <category>instance creation</category><body package="BOSS">withKeysAndValues: keyAndValueArray	" Answer an instance whose keys and values	are obtained from alternate elements of the	keyAndValueArray. "	| dict |	dict := self new: keyAndValueArray size.	1 to: keyAndValueArray size by: 2 do: [:i |		dict at: (keyAndValueArray at: i) put: (keyAndValueArray at: i + 1)].	^dict</body></methods><methods><class-id>Core.Dictionary</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	" Represent a Dictionary by its elements	(Associations). "	| creator |	creator := MessageSend				receiver: self class				selector: #withAll:				argument: self associations asArray.	^binWriter expectCycles		ifTrue: [AbstractBinaryObjectStorage indexImportSendSelf -&gt;				(Array					with: #createSpecialObject:					with: (BOSSSpecialObjectLoader message: creator))]		ifFalse: [creator]</body></methods><methods><class-id>Core.ByteString</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	" Symbols must be re-interned	when they are read in. "	^AbstractBinaryObjectStorage indexImportByteString -&gt; self</body></methods><methods><class-id>Text2.DocumentStyle</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	^MessageSend		receiver: self class		selector: #decodeFromLiteralArray:		argument: self literalArrayEncoding</body></methods><methods><class-id>UI.ProtocolAdaptor class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	"An attempt is being made to read instances of an obsolete version of this class.  Answer a block that converts old instances (represented as an array or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new |			new := Array new: oldObj size+1.			new replaceFrom: 1 to: 4 with: oldObj startingAt: 1.			new at: 5 put: nil.			new replaceFrom: 6 to: new size with: oldObj startingAt: 5.			oldObj become: new.			oldObj changeClassToThatOf: inst]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	"Answer a version identification for the particular representation that the receiver uses for representBinaryOn:."	^'VisualWorks Release 2.0'</body></methods><methods><class-id>Core.TwoByteSymbol</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	" Symbols must be re-interned	when they are read in. "	^AbstractBinaryObjectStorage indexImportTwoByteSymbol -&gt; self</body></methods><methods><class-id>Tools.ChangeList class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new |			new := Array new: oldObj size-1.			new replaceFrom: 1 to: 2 with: oldObj startingAt: 1.				"Remove isLocked"			new replaceFrom: 3 to: new size with: oldObj startingAt: 4.			oldObj become: new.			oldObj changeClassToThatOf: inst]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body></methods><methods><class-id>Graphics.MappedPalette class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new size bits |			new := Array new: oldObj size+2.			new replaceFrom: 1 to: 2 with: oldObj startingAt: 1.			new replaceFrom: 6 to: new size with: oldObj startingAt: 4.			(bits := new at: 2) changeClassToThatOf: (WordArray new: 0).			UninterpretedBytes isBigEndian ifFalse: [bits reverseByteOrder].			size := 0.			1 to: bits size by: 3 do: [:i |				(bits at: i) = UnallocatedEntryValue ifFalse: [size := size+1]].			new at: 4 put: self defaultMapResolution.			new at: 5 put: size.			oldObj become: new.			oldObj changeClassToThatOf: inst]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	" Answer a version identification for	the particular representation that	the receiver uses for representBinaryOn:."	^'Release 4.1'</body></methods><methods><class-id>Graphics.MappedPalette</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	"If a Palette has a name as a constant, use the name to represent it."	| const |	const := super representBinaryOn: binWriter.	^const isNil		ifTrue: [MessageSend receiver: self class selector: #withColors: arguments: (Array with: self colors)]		ifFalse: [const]</body></methods><methods><class-id>Core.Set</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	" Represent a Set by its elements. "	| creator |	creator := MessageSend			receiver: self class			selector: #withAll:			argument: (self isEmpty ifTrue: [#()] ifFalse: [self asArray]).	^binWriter expectCycles		ifTrue: [AbstractBinaryObjectStorage indexImportSendSelf -&gt;			(Array				with: #createSpecialObject:				with: (BOSSSpecialObjectLoader message: creator))]		ifFalse: [creator]</body></methods><methods><class-id>Graphics.VariableSizeTextAttributes class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	"An attempt is being made to read instances of an obsolete	version of this class.  Answer a block that converts old	instances (represented as an array or string of instance	variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new |			new := Array new: oldObj size + 1.			new replaceFrom: 1 to: 11 with: oldObj startingAt: 1.			new at: 12 put: 0.			new replaceFrom: 13 to: new size with: oldObj startingAt: 12.			oldObj become: new.			oldObj changeClassToThatOf: inst]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	"Answer a version identification for the particular representation	that the receiver uses for representBinaryOn:."	^'Release 4.2'</body></methods><methods><class-id>Kernel.ClassOrganizer</class-id> <category>categories</category><body package="BOSS">categories: anArray 	"Reorder the receiver's categories to be in the order of anArray.  If the	resulting organization does not include all elements, then give an error."	| newCategories newStops newElements catName list runningTotal | 	newCategories := Array new: anArray size.	newStops := Array new: anArray size.	newElements := Array new: 0.	runningTotal := 0.	1 to: anArray size do:		[:i |		catName := (anArray at: i) asSymbol.		list := self listAtCategoryNamed: catName.				newElements := newElements, list.				newCategories at: i put: catName.				newStops at: i put: (runningTotal := runningTotal + list size)].	elementArray do:		[:element | "check to be sure all elements are included"		(newElements includes: element)			ifFalse: [^self error: 'New categories must match old ones']].	"Everything is good, now update my three arrays."	categoryArray := newCategories.	categoryStops := newStops.	elementArray := newElements</body></methods><methods><class-id>Graphics.LayoutFrame class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | t |			t := oldObj at: 2.				"Shuffle the instance variables"			oldObj at: 2 put: (oldObj at: 5).			oldObj at: 5 put: t.			t := oldObj at: 3.			oldObj at: 3 put: (oldObj at: 4).			oldObj at: 4 put: (oldObj at: 8).			oldObj at: 8 put: (oldObj at: 7).			oldObj at: 7 put: t.			oldObj changeClassToThatOf: inst]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	" Answer a version identification for	the particular representation that	the receiver uses for representBinaryOn:."	^'Release 4.1'</body></methods><methods><class-id>Graphics.CoverageValue</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	coverage = 0 ifTrue: [^MessageSend receiver: self class selector: #transparent].	coverage = 1 ifTrue: [^MessageSend receiver: self class selector: #opaque].	^MessageSend receiver: self class selector: #coverage: argument: coverage</body></methods><methods><class-id>External.CVoidType</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	^MessageSend		receiver: self class		selector: #void</body></methods><methods><class-id>Core.List</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	"Represent a List by its contents (elements)"	^MessageSend		receiver: self class		selector: #withAll:		argument: (self isEmpty ifTrue: [#()] ifFalse: [self asArray])</body></methods><methods><class-id>Core.ByteSymbol</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	" Symbols must be re-interned	when they are read in. "	^AbstractBinaryObjectStorage indexImportByteSymbol -&gt; self</body></methods><methods><class-id>UI.ValueModel class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new |			new := Array new: oldObj size-1.			new at: 1 put: (oldObj at: 1).			new replaceFrom: 2 to: new size with: oldObj startingAt: 3.			oldObj become: new.			oldObj changeClassToThatOf: inst]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	" Answer a version identification for	the particular representation that	the receiver uses for representBinaryOn:."	^'Release 4.1'</body></methods><methods><class-id>Kernel.Context</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: bosWriter	" The stored representation of	Contexts is special. "	^bosWriter representContext: self</body></methods><methods><class-id>Store.XChangeSet class</class-id> <category>instance creation</category><body package="BOSS">withAll: associationsandProperties: properties	^(self withAll: associations)		properties: properties;		yourself</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>private</category><body package="BOSS">properties: anIdentitySet	properties := anIdentitySet</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	| creator |	creator := MessageSend		receiver: self class		selector: #withAll:andProperties:		arguments: (Array with: self associations asArray with: self propertiesOrNil).	binWriter expectCycles ifFalse: [^creator].	^AbstractBinaryObjectStorage indexImportSendSelf -&gt;		(Array			with: #createSpecialObject:			with: (BOSSSpecialObjectLoader message: creator))</body></methods><methods><class-id>Graphics.CachedImage</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter		^MessageSend		receiver: self class		selector: #on:		argument: image</body></methods><methods><class-id>Graphics.ComposedText class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	"An attempt is being made to read instances of an obsolete version of this class.  Answer a block that converts old instances (represented as an array or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new |			new := Array new: oldObj size+1.			new replaceFrom: 1 to: 7 with: oldObj startingAt: 1.			new at: 8 put: true.			new replaceFrom: 9 to: new size with: oldObj startingAt: 8.			oldObj become: new.			oldObj changeClassToThatOf: inst]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	"Answer a version identification for the particular representation that the receiver uses for representBinaryOn:."	^'VisualWorks Release 2.0'</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	" Classes are represented by their names,	under the assumption that they are all	present in the Smalltalk dictionary.	We also include a class/metaclass flag,	the version number, and the instance format	and variable names for checking. "	^AbstractBinaryObjectStorage indexImportNameSpace -&gt; (Array with: self fullName)</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>method dictionary</category><body package="BOSS">addSelectorUnsafe: s withMethod: m category: c	"Add the message selector s associated with the method m under category c."	self addSelectorUnsafe: s withMethod: m.	self organization classify: s under: c</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>binary storage</category><body package="BOSS">binaryInitializationMessagesFor: sourceMode	"Answer a list of MessageSends that should be	evaluated in order to initialize this class when BOSSed	in.  These include setting the class's comment, specifying	the order of message categories for the Browser, and	other actions that subclasses may want to take.  For	example, Class checks to see if the metaclass defines	#initialize, and if so, it adds that message to the list."	| list categories |	list := OrderedCollection new.	sourceMode == #discard ifTrue: [^list].	sourceMode == #keep ifTrue:		[			list add:				(MessageSend					receiver: self					selector: #comment:					argument: self comment)		].	categories := self organization categories.	categories isEmpty ifFalse:		[			list add:				(MessageSend					receiver: self					selector: #orderedCategories:					argument: categories)		].	^list</body><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones.	The block's return value will be ignored.  The block	should use some means like #become: or #changeClassToThatOf:	to change the identity of the block's argument to an instance	of the class"	" By default, classes do not know how to do this. "	self error: 'Attempt to read incompatible version ', oldVersion printString, ' with format = ', oldFormat printString, ' of ', self printString.	^[:oldObj | self error: 'Attempt to create instance of old version!'.  self new]</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>organization</category><body package="BOSS">orderedCategories: aList	"Set the list of categories known by the class's organization.	If the organization knows categories not on this list, add them	at the end.  If the system does not support the development	environment (organization is nil), do nothing."	| list2 |	organization == nil ifTrue: [^self].	list2 := aList copy asOrderedCollection.	self organization categories do:		[:cat |		(list2 includes: cat)			ifFalse: [list2 add: cat]].	self organization categories: list2</body></methods><methods><class-id>Core.MessageSend class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new |			new := Array new: oldObj size-2.			new replaceFrom: 1 to: 3 with: oldObj startingAt: 1.			new replaceFrom: 4 to: new size with: oldObj startingAt: 6.			oldObj become: new.			oldObj changeClassToThatOf: inst]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	" Answer a version identification for	the particular representation that	the receiver uses for representBinaryOn:."	^'Release 4.1'</body></methods><methods><class-id>Core.Class</class-id> <category>binary storage</category><body package="BOSS">binaryInitializationMessagesFor: sourceMode	| list |	list := super binaryInitializationMessagesFor: sourceMode.	(self class includesSelector: #initialize)		ifTrue:			[list add: (MessageSend receiver: self selector: #initialize)].	^list</body></methods><methods><class-id>Core.Class</class-id> <category>instance variables</category><body package="BOSS">classSideInstanceVariableNames: instVarString 	"For BOSS, declare new instance variables for myself and my subclasses"	^self class instanceVariableNames: instVarString</body></methods><methods><class-id>Core.Class</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	" Classes are represented by their names,	under the assumption that they are all	present in the Smalltalk dictionary.	We also include a class/metaclass flag,	the version number, and the instance format	and variable names for checking. "	| args |	args := Array new: 5.	args at: 1 put: self fullName.	args at: 2 put: false.	args at: 3 put: self binaryRepresentationVersion.	args at: 4 put: self format.	args at: 5 put: (self instSize = 0					ifTrue: [nil]  "This prevents the difficulties associated with storing Array itself."					ifFalse: [self allInstVarNames asArray]).	^AbstractBinaryObjectStorage indexImportClass -&gt; args</body><body package="BOSS">representContentsBinaryOn: binWriter	" Store the methods and organization. "	^self definitionMessage</body></methods><methods><class-id>UI.BooleanWidgetView class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new |			new := Array new: oldObj size+1.			new replaceFrom: 1 to: 4 with: oldObj startingAt: 1.			new replaceFrom: 6 to: new size with: oldObj startingAt: 5.			oldObj become: new.			oldObj changeClassToThatOf: inst]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	" Answer a version identification for	the particular representation that	the receiver uses for representBinaryOn:."	^'Release 4.1'</body></methods><methods><class-id>Graphics.Window class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new |			new := Array new: oldObj size.			new replaceFrom: 1 to: 3 with: oldObj startingAt: 1.			new replaceFrom: 4 to: 7 with: oldObj startingAt: 5.				"Add isIconic"			new at: 8 put: false.			new replaceFrom: 9 to: new size with: oldObj startingAt: 9.			oldObj become: new.			oldObj changeClassToThatOf: inst]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body></methods><methods><class-id>External.CPointerType class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	"An attempt is being made to read instances of an obsolete version of this class.  Answer a block that converts old instances (represented as an array or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new segment |			"Remove pointerKind, pointerClass, segment"			new := Array new: oldObj size - 3.			new at: 1 put: 0.			new at: 2 put: (oldObj at: 3).			3 to: new size do: [:i | new at: i put: (oldObj at: i + 3)].			segment := oldObj at: 5.			oldObj become: new.			oldObj changeClassToThatOf: inst.			segment == #far ifTrue: [oldObj beFar].			segment == #huge ifTrue: [oldObj beFar].			segment == #near ifTrue: [oldObj beNear].			oldObj]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	"Answer a version identification for the particular representation that the receiver uses for representBinaryOn:."	^'Release 2.0'</body></methods><methods><class-id>Graphics.CharacterAttributes class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	"An attempt is being made to read instances of an obsolete version of this class.  Answer a block that converts old instances (represented as an array or string of instance variable values) to new ones."	oldVersion == nil ifTrue:		[| inst |		inst := self basicNew.		^[:oldObj | | new |		new := Array new: oldObj size + 2.		new replaceFrom: 1 to: 2 with: oldObj startingAt: 1.		new replaceFrom: 5 to: new size with: oldObj startingAt: 3.		oldObj become: new.		oldObj changeClassToThatOf: inst.		oldObj invalidateQueryCache.		oldObj]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	"Answer a version identification for the particular representation that the receiver uses for representBinaryOn:."	^'VisualWorks Release 2.0'</body></methods><methods><class-id>UI.ParagraphEditor class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new |			new := Array new: oldObj size+1.			new replaceFrom: 1 to: 3 with: oldObj startingAt: 1.				"Add menuChannel, textHasChanged, and performer,				and remove paragraph and initialText"			new replaceFrom: 6 to: 7 with: oldObj startingAt: 5.			new replaceFrom: 8 to: 9 with: oldObj startingAt: 8.			new replaceFrom: 11 to: new size with: oldObj startingAt: 10.			oldObj become: new.			oldObj changeClassToThatOf: inst.			oldObj textHasChanged: false.  "Choose a legal value"]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body></methods><methods><class-id>Core.Signal</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	" If a Signal has a symbolic name,	use it as the representation. "	^self hasName		ifTrue: [MessageSend receiver: nameClass selector: nameMessage]		ifFalse: [nil]</body></methods><methods><class-id>Tools.ChangeSetManager class</class-id> <category>utilities</category><body package="BOSS">currentTag	^-666</body></methods><methods><class-id>External.ExternalLibraryHolder class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	"An attempt is being made to read instances of an obsolete version of this class.  Answer a block that converts old instances (represented as an array or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self new.			^[:oldObj | | new |			new := Array new: oldObj size + 1.			new replaceFrom: 1 to: oldObj size with: oldObj startingAt: 1.			new at: oldObj size + 1 put: nil.			oldObj become: new.			oldObj changeClassToThatOf: inst.			oldObj]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	"Answer a version identification for the particular representation that the receiver uses for representBinaryOn:."	^'Release 2.0'</body></methods><methods><class-id>External.LinkedWeakAssociationDictionary</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	" Since an IdentityDictionary doesn't actually	store Associations, represent it more efficiently	as a sequence of keys and values. "	| cont creator |	cont := (Array new: self size * 2) writeStream.	self ownKeysAndValuesDo: [:key :value | cont nextPut: key; nextPut: value].	creator := (MessageSend			receiver: self class			selector: #withKeysAndValues:			argument: cont contents).	^binWriter expectCycles		ifTrue: [AbstractBinaryObjectStorage indexImportSendSelf -&gt;			(Array				with: #createSpecialObject:				with: (BOSSSpecialObjectLoader message: creator))]		ifFalse: [creator]</body></methods><methods><class-id>UI.ControllerWithMenu class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new |			new := Array new: oldObj size+2.			new replaceFrom: 1 to: 3 with: oldObj startingAt: 1.				"Add menuChannel and performer"			new replaceFrom: 6 to: new size with: oldObj startingAt: 4.			oldObj become: new.			oldObj changeClassToThatOf: inst]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	" Answer a version identification for	the particular representation that	the receiver uses for representBinaryOn:."	^'Release 4.1'</body></methods><methods><class-id>Core.SortedCollectionWithPolicy class</class-id> <category>instance creation</category><body package="BOSS">fromSortedArray: aCollection sortBlock: aBlock sortPolicy: aPolicy	"Answer a new SortedCollection with the given elements and sortBlock. 	Since this is used by BOSS, and aBlock may not really be an instance of 	BlockClosure, assume that the collection is sorted and do not resort it."	| newCollection |	newCollection := self new: aCollection size.	newCollection sortBlock: aBlock.	newCollection sortPolicy: aPolicy.	newCollection addAllWithoutSorting: aCollection.	^newCollection</body></methods><methods><class-id>Core.SortedCollectionWithPolicy</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	" Represent a SortedCollection by	its contents (elements) and its sorting information. "	^MessageSend		receiver: self class		selector: #fromSortedArray:sortBlock:sortPolicy:		arguments: (Array with: self asArray with: sortBlock with: sortPolicy)</body></methods><methods><class-id>Kernel.BinaryStorageBytes</class-id> <category>accessing</category><body package="BOSS">objectAt: datax objectMap: objMap baseIndex: baseIndex	" Decode the encoded oop at byte index	datax in the receiver.  objMap is the table of	decoded objects.  baseIndex is the object	index of the first element of the table. "	| tag vx value |	" Ordinarily we would just get the oop by	self unsignedLongAt: datax.  However, if	the oop is a SmallInteger of more than	27 bits, this would cause an unnecessary	LargeInteger to be created.  As it happens,	this is precisely the case for two of the	instance variables of short CompiledMethods.	The time penalty for this is so large that	we make an explicit byte ordering check and	extract the oop in two shorts. "	UninterpretedBytes isBigEndian		ifTrue:			[tag := self unsignedShortAt: datax + 2.			vx := datax]		ifFalse:			[tag := self unsignedShortAt: datax.			vx := datax + 2].	^(tag bitAnd: 1) = 0		ifFalse:			[value := ((self shortAt: vx) bitShift: 14) + (tag bitShift: -2).			(tag bitAnd: 2) = 0				ifTrue: [Character value: value]				ifFalse: [value]]		ifTrue:			[value := self unsignedLongAt: datax.			(tag bitAnd: 2) = 0				ifTrue: [objMap at: value]				ifFalse: [objMap at: value - 2 + baseIndex]]</body><body package="BOSS">replaceBytesFrom: startIndex with: src	| si |	si := startIndex - 1.	1 to: src basicSize do: [:i | self basicAt: si + i put: (src basicAt: i)]</body><body package="BOSS">shortObjectAt: datax objectMap: objMap baseIndex: baseIndex	" Decode the encoded oop at byte index	datax in the receiver.  objMap is the table of	decoded objects.  baseIndex is the object	index of the first element of the table. "	| int value |	int := self unsignedShortAt: datax.	^(int bitAnd: 1) = 0		ifFalse:			[value := int bitShift: -2.			(int bitAnd: 2) = 0				ifTrue: [Character value: value]				ifFalse: [value]]		ifTrue:			[(int bitAnd: 2) = 0				ifTrue: [objMap at: int]				ifFalse: [objMap at: int - 2 + baseIndex]]</body></methods><methods><class-id>Kernel.BinaryStorageBytes</class-id> <category>byte endianness</category><body package="BOSS">swapColumn: c0 with: c1	" Swap bytes at indices 4N+c0+1 with	those at indices 4N+c1+1. "	1 to: self size by: 4 do:		[:i |			| t |			t := self at: i + c0.			self at: i + c0 put: (self at: i + c1).			self at: i + c1 put: t		]</body></methods><methods><class-id>Graphics.DisplaySurface class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new |			new := Array new: oldObj size-1.			new replaceFrom: 1 to: 3 with: oldObj startingAt: 1.			new replaceFrom: 4 to: new size with: oldObj startingAt: 5.			oldObj become: new.			oldObj changeClassToThatOf: inst]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	" Answer a version identification for	the particular representation that	the receiver uses for representBinaryOn:."	^'Release 4.1'</body></methods><methods><class-id>Tools.DictionaryInspector class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	" An attempt is being made to read instances of	an obsolete version of this class.  Answer a block	that converts old instances (represented as an array	or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self basicNew.			^[:oldObj | | new |			new := Array new: oldObj size-1.			new replaceFrom: 1 to: 3 with: oldObj startingAt: 1.			new replaceFrom: 4 to: new size with: oldObj startingAt: 5.			oldObj become: new.			oldObj changeClassToThatOf: inst]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	" Answer a version identification for	the particular representation that	the receiver uses for representBinaryOn:."	^'Release 4.1'</body></methods><methods><class-id>External.ExternalObject class</class-id> <category>binary storage</category><body package="BOSS">binaryReaderBlockForVersion: oldVersion format: oldFormat	"An attempt is being made to read instances of an obsolete version of this class.  Answer a block that converts old instances (represented as an array or string of instance variable values) to new ones."	oldVersion == nil		ifTrue:			[| inst |			inst := self new.			^[:oldObj | | new |			new := Array new: 6.			new replaceFrom: 1 to: 4 with: oldObj startingAt: 1.			(oldObj at: 6) isNil				ifTrue: [new at: 5 put: nil]				ifFalse: [new at: 5 put: #()].			new at: 6 put: nil.			oldObj become: new.			oldObj changeClassToThatOf: inst.			oldObj]].	^super binaryReaderBlockForVersion: oldVersion format: oldFormat</body><body package="BOSS">binaryRepresentationVersion	"Answer a version identification for the particular representation that the receiver uses for representBinaryOn:."	^'Release 2.0'</body></methods><methods><class-id>Graphics.Palette</class-id> <category>binary storage</category><body package="BOSS">representBinaryOn: binWriter	"If a Palette has a name as a constant, use the name to represent it."	| const |	const := self class constantNameFor: self.	^const isNil		ifTrue: [nil]		ifFalse: [MessageSend receiver: self class selector: const]</body></methods><initialize><class-id>Kernel.BOSSTransporter</class-id></initialize><initialize><class-id>Kernel.BOSSAbstractReader</class-id></initialize><initialize><class-id>Kernel.AbstractBinaryObjectStorage</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CachedImage</name><environment>Graphics</environment><super>Graphics.PixelArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>image retainedMedium conversionMessage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Images</category><attributes><package>Graphics-Images</package></attributes></class><class><name>ByteString</name><environment>Core</environment><super>Core.ByteEncodedString</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>GraphicsHandle</name><environment>Graphics</environment><super>Core.UninterpretedBytes</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>CScalarType</name><environment>External</environment><super>External.CType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>kind numBits printName storeSelector atSelector atPutSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Types</category><attributes><package>External-Types</package></attributes></class><class><name>ByteSymbol</name><environment>Core</environment><super>Core.Symbol</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>LimitedPrecisionReal</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>powersOfTwo </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>IdentityDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>valueArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>XChangeSet</name><environment>Store</environment><super>Core.IdentityDictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>other properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>OSHandle</name><environment>OS</environment><super>OS.OSErrorHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class><class><name>ClassOrganizer</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>globalComment categoryArray categoryStops elementArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>SortedCollection</name><environment>Core</environment><super>Core.OrderedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>sortBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>SortedCollectionWithPolicy</name><environment>Core</environment><super>Core.SortedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>sortPolicy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>Context</name><environment>Kernel</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sender receiver stackp stack </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>List</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents collection limit collectionSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Collections</category><attributes><package>UIBasics-Collections</package></attributes></class><class><name>MethodDictionary</name><environment>Kernel</environment><super>Core.KeyedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>NamedChangeSet</name><environment>Tools</environment><super>Kernel.ChangeSet</super><private>false</private><indexed-type>none</indexed-type><inst-vars>changeSetName lastChange lastFileOut lastFileOutName dirty comment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>LinkedWeakAssociationDictionary</name><environment>External</environment><super>External.WeakAssociationDictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>backup </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Collections</category><attributes><package>External-Collections</package></attributes></class><class><name>Palette</name><environment>Graphics</environment><super>Core.KeyedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Palettes</category><attributes><package>Graphics-Palettes</package></attributes></class><class><name>CoverageValue</name><environment>Graphics</environment><super>Graphics.SimplePaint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>coverage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>BinaryStorageBytes</name><environment>Kernel</environment><super>Core.ByteArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Storage</category><attributes><package>System-Code Storage</package></attributes></class><class><name>NameSpace</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>MappedPalette</name><environment>Graphics</environment><super>Graphics.ColorPalette</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hasColor palette inverseMap mapResolution size </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Palettes</category><attributes><package>Graphics-Palettes</package></attributes></class><class><name>Signal</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent mayProceed notifierString nameClass nameMessage exceptionClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>CVoidType</name><environment>External</environment><super>External.CType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Types</category><attributes><package>External-Types</package></attributes></class><class><name>ExternalDictionary</name><environment>External</environment><super>External.LinkedWeakAssociationDictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Collections</category><attributes><package>External-Collections</package></attributes></class><class><name>TwoByteSymbol</name><environment>Core</environment><super>Core.Symbol</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>DocumentStyle</name><environment>Text2</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>color action annotation annotationStyle adornment adornmentColor alignment verticalAlignment fontDescription tabs backgroundColor firstLineIndent lineIndent padding lineSpacing properties direction cursor hover paragraphBackgroundColor annotationBackgroundColor annotationPadding annotationSpacing paragraphSpacing </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Graphics-Text2-Document</package></attributes></class></st-source>