<?xml version="1.0"?><st-source><!-- Name: PackageCategoriesNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: Contains classes that implement the Package / Bundle model of dividing a large body of code into loadable components.IsFunctional: falsePackageName: PackageCategoriesParcel: #('PackageCategories')Version: 8.3 - 14Post-Load Block: 	[:package |Store.Registry installCallBacksForFileout]Date: 12:05:13 PM July 28, 2017 --><time-stamp>From VisualWorksÂ®, 8.3 of July 28, 2017 on July 28, 2017 at 12:05:13 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Store</name><environment>Smalltalk</environment><private>false</private><imports>			private Lens.LensGraphView			private Database.ExternalDatabaseConnection			private Smalltalk.*			</imports><category>Store-Base</category><attributes><package>PackageCategories</package></attributes></name-space><comment><name-space-id>Store</name-space-id><body>Store namespace for all Store classes. Contains the shared variables: 	Registry - for image related Store queries : Singleton of Store.PundleAccess	Policies - for configurable settings : Singleton of Store.AccessAdditionally, when the Store component is loaded:	DbRegistry - for Store database access : Singleton of Store.DBAccess</body></comment><class><name>Model</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.Model</class-id><body>Abstract superclass for image models.</body></comment><class><name>PackageModelSubModel</name><environment>Store</environment><super>Store.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.PackageModelSubModel</class-id><body>This class is the abstract superclass of all models which are stored in the instance variable #models of PackageModel.</body></comment><class><name>DatabaseConnectionInformation</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle dbIdentifier dbTrace dbTimestamp dbVersion dbUsername changeSet versionString mergeInformation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.DatabaseConnectionInformation</class-id><body>For tracking connections to different database.Instance Variables	pundle &lt;StoreBundle | StorePackage&gt; The pundle this connection is for.	dbIdentifier &lt;String&gt; The name of the database this connection is to. Nil if unhooked.	dbTrace	&lt;Integer&gt; The primary key of the parent package record. Nil if unhooked.	dbTimestamp &lt;Timestamp&gt; The timestamp of the parent package record. Nil if unhooked.	dbVersion &lt;String&gt; The version in the database. Nil if unhooked.	dbUsername &lt;String&gt; The username of the user that published this version. Nil if unhooked.	changeSet	&lt;XChangeSet&gt;	Changes for the owning package for this database.	versionString &lt;String | nil &gt; The cached versionString. nil if unknown.</body></comment><class><name>DatabaseConnectionBundleInformation</name><environment>Store</environment><super>Store.DatabaseConnectionInformation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contentDescriptions fileDescriptions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.DatabaseConnectionBundleInformation</class-id><body>Specialized DatabaseConnectionBundleInformation for tracking bundle content descriptions.Instance Variables:	contentDescriptions	&lt;List of: PundleDescriptions&gt; - tracks bundle contents and their db links.</body></comment><class><name>DefClassModel</name><environment>Store</environment><super>Store.PackageModelSubModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package fullClassSymbol </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.DefClassModel</class-id><body>Represents a class within a package that includes the class definition and comment.Instance Variables:	package	&lt;PackageModel&gt;  the receiver's package	fullClassSymbol	&lt;Symbol&gt; the absolute symbol representing the receiver.The definition class model operates on the principle that most methods/shared variables will be in the same package as the class. Any method/shared variable that is not explicitly in another package is assumed to belong to the receiver's package. This is foot print savings at the cost of some confusion in method/shared variable status. </body></comment><class><name>ExtensionClassModel</name><environment>Store</environment><super>Store.DefClassModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors metaSelectors data </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.ExtensionClassModel</class-id><body>Represents a class in a package that does not have the class definition, but only extension methods/shared variables.Instance Variables:	selectors	&lt;IdentitySet of: symbol&gt;  The selectors in this package	metaSelectors	&lt;IdentitySet of: symbol&gt;  The meta class selectors	data	&lt;IdentitySet of: symbol&gt;  The static keys in this package.</body></comment><class><name>BundleStructureChange</name><environment>Store</environment><super>Kernel.ComponentChange</super><private>false</private><indexed-type>none</indexed-type><inst-vars>structure </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.BundleStructureChange</class-id><body>Class BundleStructureChange represents the change to the specification of a Bundle.Instance Variables:	structure	&lt;Array of: (Array with: Symbol with: String)&gt;  An array of two-element arrays.  The two-element array holds the type of CodeComponent (#bundle #package) and the name</body></comment><class><name>PackageChooser</name><environment>Store</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectName withAdd onCancelDo sequence selectedPackage defaultPackage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.PackageChooser</class-id><body>A utility dialog which presents a list of the currently loaded Packages for the user to select. Optionally can allow the user to create a new Package.  Answers a PackageModel.Instance Variables:	defaultPackage	&lt;PackageModel or nil&gt;	If provided, will be the default selection	objectName	&lt;String&gt;	used in the dialog header if provided	onCancelDo	&lt;BlockClosure&gt;	- evaluated if the user cancels the dialog	selectedPackage	&lt;PackageModel&gt;	the current selection	sequence	&lt;SelectionInList&gt;	the list of packages	withAdd	&lt;Boolean&gt;	True if the user is allowed to create a new package</body></comment><class><name>DefNameSpaceModel</name><environment>Store</environment><super>Store.PackageModelSubModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package name environmentString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.DefNameSpaceModel</class-id><body>Represents a namespace within a package that includes the definition and comment.Instance Variables:	package	&lt;PackageModel&gt;  the receiver's package	name	&lt;Symbol&gt;  the NameSpace name.	environmentString	&lt;String&gt; The absolute path of the NameSpace.The definition namespace model operates on the principle that most shared variables will be in the same package as the namespace. Any shared variable that is not explicitly in another package is assumed to belong to the receiver's package. This is foot print savings at the cost of some confusion in shared variable status. </body></comment><class><name>PundleAccess</name><environment>Store</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packages bundles modelDictionary currentPackage nullPackage containedItemsCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.PundleAccess</class-id><body>Singleton (Store.Registry) is the manager for all code components in the local image.Description:Tracks loaded bundles/packages and maintains a model (i.e. Class/NameSpace models) to packages dictionary. Responsible for definition lookup, creating and organizing pundles.Usage:Use the global Store.Registry to obtain PackageModel and BundleModel objects. For example:  Store.Registry packageNamed: 'XML-source'.or:  Store.Registry bundleNamed: 'Tools-IDE'.In either case you'll get back the BundleModel or PackageModel or nil if they don't exist. Everything is in a package somewhere. The nullPackage is for all unassigned definitions.Instance Variables:	packages	&lt;Dictionary key: name value: PackageModel&gt;  All loaded packages.	bundles	&lt;Dictionary key: name value: BundleModel&gt;  All loaded bundles.	modelDictionary	&lt;IdentityDictionary key: String value: Array of packages&gt;  		key is the #absoluteName of a Class or NameSpace (eg. 'Root.Smalltalk.Store.PundleAccess').		value is an array of PackageModels containing some definitions for that class/namespace. The first		package in the array contains the definiton. The rest contain extension methods or shared variables.	currentPackage	&lt;PackageModel&gt;  Default package.	nullPackage	&lt;PackageModel&gt;  Where things go when they have nowhere to go.	containedItemsCache	&lt;OrderedCollection of: PunleModels&gt; Saves list of all bundles/packages for browser speedup.Shared Variables:	ParcelDirectory &lt;LogicalFilename&gt;  When publishing a pundle to a parcel, this is the destination directory used.  By default this is the current directory.	</body></comment><class><name>ComponentDescription</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbIdentifier id componentName fileName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.ComponentDescription</class-id><body>ComponentDescription is a abstract superclass that describes components or prerequisites of abundle. Is also provides the data structure when saving a bundle into the file.Instance Variables:	dbIdentifier	&lt;Symbol&gt;	identifies the database that the id points to	id	&lt;Integer&gt;	primaryKey (aka dbTrace) of the component in the database	componentName	&lt;String&gt;	component name	fileName	&lt;FileName&gt; obsolete. TBR at a later date.Shared Variables:	CannotLoadComponentSignal	&lt;Signal&gt;	Sigaled when component load aborted	CannotStoreComponentSignal	&lt;Signal&gt;		CannotUnloadComponentSignal	&lt;Signal&gt;	Sigaled when component unload aborted</body></comment><class><name>BasicPackagePolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>alwaysUse newClassUseCurrent newNameSpaceUseCurrent newMethodUseCurrent newMethodUseClassIfNoCurrent newMethodUseClassIfCurrentSame newMethodUseClass newDatumUseCurrent newDatumUseClassIfNoCurrent newDatumUseClassIfCurrentSame newDatumUseClass warnOnFirstModification </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.BasicPackagePolicy</class-id><body>When a new definition (a new class, new method, new namespace or new shared variable) is introduced to the system, BasicPackagePolicy is asked which package should own the definition.    The system's sole instance of BasicPackagePolicy is owned by the Policies (an instance of Access) global in the Store name space.For a new class or a new namespace definition, this policy helps decide whether the system should use the current package, or if the client should be prompted for a package to use. For a new method or a new shared variable, there are more choices.  For example with a new method the choices are:	Current (#currentINAU - in the settings framework)		Use the current package.  The instance variable, newMethodUseCurrent is set to true.  The instance variables newMethodUseClass, newMethodUseClassIfCurrentSame and newMethodUseClassIfNoCurrent are set to false.	Current or class package (#currentINUTCP - in the settings framework)		Use the current package or package that defines the class.  The instance variables, newMethodUseCurrent and newMethodUseClass are set to true.  The instance variables newMethodUseClassIfCurrentSame and newMethodUseClassIfNoCurrent are set to false.	Class package (#useTCP - in the settings framework)		Use the package that defines the class.   The instance variable newMethodUseClass is set to true.  The instance variables newMethodUseCurrent, newMethodUseClassIfCurrentSame and newMethodUseClassIfNoCurrent are set to false.	Class if same as current  (#useTCPIC - in the settings framework)		The instance variable newMethodUseClass and newMethodUseClassIfCurrentSame are set to true.  The instance variables newMethodUseCurrent and newMethodUseClassIfNoCurrent are set to false.	Class if same as current or none (#useTCPICON - in the settings framework)		The instance variables newMethodUseClassIfCurrentSame and newMethodUseClassIfNoCurrent are set to true.  The instance variables newMethodUseClass and newMethodUseCurrent are set to false.  	Always prompt		Always prompt the client.  The instance variables newMethodUseClassIfNoCurrent, newMethodUseClass, newMethodUseCurrent and newMethodUseClassIfNoCurrent are set to false.  The same set of rules applies to shared variables in a name space or class.This policy also provides the ability to override the current settings, but allowing one to set alwaysUse to be the package to always use.  The system uses this feature by calling the #forcePackage:while: method.Instance Variables:	alwaysUse	&lt;PackageModel&gt;	The package that the policy is being forced to use. 	newClassUseCurrent	&lt;Boolean&gt;	Described above.	newDatumUseClass		&lt;Boolean&gt;	Described above	newDatumUseClassIfCurrentSame	&lt;Boolean&gt;	Described above	newDatumUseClassIfNoCurrent	&lt;Boolean&gt;	Described above	newDatumUseCurrent	&lt;Boolean&gt;	Described above	newMethodUseClass	&lt;Boolean&gt;	Described above	newMethodUseClassIfCurrentSame	&lt;Boolean&gt;	Described above	newMethodUseClassIfNoCurrent	&lt;Boolean&gt;	Described above	newMethodUseCurrent	&lt;Boolean&gt;	Described above	newNameSpaceUseCurrent	&lt;Boolean&gt;	Described above	warnOnFirstModification		&lt;Boolean&gt;	If true, warn the client that the package is being modified for the first time</body></comment><class><name>PundleModel</name><environment>Store</environment><super>Kernel.CodeComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbInfo readonly </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.PundleModel</class-id><body>An abstract superclass for Package/Bundle Models.Subclasses must implement the following messages:	accessing		pundleChangesClassInstance Variables:	changeSet	&lt;Store.XChangeSet&gt;  tracks all changes	readonly	&lt;Boolean&gt;  set to true after converting a Parcel that has uninstalled code.Class Variables:	EmergencyUnloadSignal	&lt;Signal&gt;  commentThe XChangeSet determines what gets published when updating.</body></comment><class><name>PackageModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>models </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.PackageModel</class-id><body>Manages the contents of a package.Description:Code components in the local image are represented as instances of PackageModel or BundleModel. The objects in the repository are represented as instances of Package or Bundle.Note that because PackageModels and BundleModels can be reconciled against many different databases, these objects do not track version information (e.g., the properties: version, last modified, modified by).Usage:Use the global Store.Registry to obtain PackageModel and BundleModel objects. For example:  Store.Registry packageNamed: 'XML-source'.or:  Store.Registry bundleNamed: 'Tools-IDE'.In either case you'll get back the BundleModel or PackageModel or nil if they don't exist.Instance Variables:	models	&lt;IdentityDictionary key: Class/NameSpace absoluteSymbol value: Class/NameSpaceModel&gt; </body></comment><class><name>XChangeSet</name><environment>Store</environment><super>Core.IdentityDictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>other properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.XChangeSet</class-id><body>Manages changes for an individual package/bundle. A dictionary of Store.Changes keyed by absolute class or namespace name.Instance Variables:	other	&lt;OrderedCollection of: symbol&gt;  general changes, such as property keys or #componentAddedClass Variables:	CurrentSet	&lt;XMainChangeSet&gt;  A singleton that tracks system wide changes 				and manages inter-package movements.</body></comment><class><name>XMainChangeSet</name><environment>Store</environment><super>Store.XChangeSet</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>reorganizeSystem specialDoIts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.XMainChangeSet</class-id><body>There is one instance of this class (XChangeSet current). We no longer track system wide bundle and package changes here since the individual components track their own.Instead, this class has as its purpose as the target of changes that it then transforms and sens out to the components which need then need to track the changesInstance Variables	reorganizeSystem	&lt;nil&gt;  	specialDoIts			&lt;nil&gt;  </body></comment><class><name>PundleForParcel</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name properties contents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.PundleForParcel</class-id><body>An abstract superclass for pundle/package conversions. Handles everything not related to contents,which are package/bundle specific. These classes are to save the bundle structure in parcels. They are saved in parcels and converted to pundles after loading.NOTE: Updating for packages is not yet supported.Instance Variables:	name	&lt;string&gt;	pundle name	properties	&lt;IndentityDictionary&gt;	pundle properties	contents	&lt;Object&gt;	subclass specfic.</body></comment><class><name>BundleForParcel</name><environment>Store</environment><super>Store.PundleForParcel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.BundleForParcel</class-id><body>Represents bundles within a parcel.Instance Variables:	contents	&lt;OrderedCollection&gt;	 pundles</body></comment><class><name>Access</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blessingPolicy mergePolicy packagePolicy versionPolicy publishPolicy ownershipPolicy prerequisitePolicy filePolicy tableSpacePolicy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.Access</class-id><body>The singleton is Store.Policies, which is simply an accessor for the current set of Store policies. These policies are meant as user subclassable customizations. Many get their values from the Store/Settings dialog.Instance Variables:	blessingPolicy	&lt;BasicBlessingPolicy or subclass&gt; Describes the available and default blessing levels.	mergePolicy	&lt;BasicMergePolicy or subclass&gt; Provides the merge tool a critera to use when performing a 	packagePolicy	&lt;BasicPackagePolicy or subclass&gt; Determines which package should own new definitions (method,	versionPolicy	&lt;BasicVersionPolicy or subclass&gt; Determines how to increment the version string when publishing.	publishPolicy	&lt;BasicPublishPolicy or subclass&gt; Determines whether a client can publish a pundle.	ownershipPolicy	&lt;BasicOwnershipPolicy or subclass&gt; Provides a mechanism for how to determine who owns a pundle.	prerequisitePolicy	&lt;BasicPrerequisitePolicy or subclass&gt; Provides a mechanism for how to resolve development prerequisites	filePolicy	&lt;BasicFilePolicy or subclass&gt; Provides information about how and where to save files when loaded from a bundle	tableSpacePolicy	&lt;BasicTableSpacePolicy or subclass&gt;	Provides information used to create new database table spaces</body></comment><class><name>PublishAsParcelDialog</name><environment>Store</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundle bundleStructure databaseLinks parcelDirectory parcelSave parcelSaveSource parcelHideSource parcelPadded parcelRepublish parcelBackup parcelOverwrite parcelVersionString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.PublishAsParcelDialog</class-id><body>The dialog to collect options for publishing a pundle as a parcel.Instance Variables	bundleStructure	&lt;ValueModel: Boolean&gt;	true if we should store the bundle structure in the parcel	databaseLinks	&lt;ValueModel: Boolean&gt;	true if we should store the database links in the parcel	parcelBackup	&lt;ValueModel: Boolean&gt;	true means backup any existing parcel file	parcelDirectory	&lt;ValueModel: String&gt;	the directory to put the parcel	parcelHideSource	&lt;ValueModel: Boolean&gt;&gt;	sets the hideSource flag for the parcel	parcelOverwrite	&lt;ValueModel: Boolean&gt;	flag whether to override existing files.. if true will do so with no warning prompt.	parcelPadded	&lt;ValueModel: Boolean&gt;	sets the padded flag for the parcel	parcelRepublish	&lt;ValueModel: Boolean&gt;	sets the reepublish flag for the parcel	parcelSave	&lt;ValueModel: Boolean&gt;	true to save the parcel	parcelSaveSource	&lt;ValueModel: Boolean&gt;	flag to tell the parcel whether to save the sources	parcelVersionString	&lt;ValueHolder &lt;String&gt;&gt; This is the version string for the Parcel (which can be different than the package/bundle)	pundle	&lt;BundleModel | PackageModel&gt;	that which we are making a parcel from</body></comment><class><name>PseudoRecord</name><environment>Store</environment><super>Store.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-ImageModel</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.PseudoRecord</class-id><body>Abstract superclass. PseudoRecords substitute for image models. They are used in comparison browsers to represent definitions that don't exist or as a generic model when the real model is not known.. </body></comment><class><name>ClassDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullClassName meta cachedName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Records</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.ClassDescriptor</class-id><body>Represents a class which may or may not exist in the image. Unlike ClassModels, ClassDescriptors know if they are metaclasses or not.</body></comment><class><name>MethodFilterPundle</name><environment>Tools</environment><super>Tools.MethodFilter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundleName pundleCache namesCache subdefCache isForPackage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Tools.MethodFilterPundle</class-id><body>This filter matches methods that are part of a particular package or bundle, specified by name. It is created by sending #package: or #bundle: to a MethodCollector, as in:		| collector filter |	collector := MethodCollector new.	filter := collector package: 'Store-Base'.	collector browseSelect: filterInstance Variables:pundleName		&lt;String&gt;		Name of the pundlepundleCache	&lt;Package | Bundle | nil&gt;	Lazy initialized to the actual package or bundle in the imagenamesCache	&lt;Colleciton&gt;	Absolute Names of classes defined in this packageisForPackage	&lt;Boolean&gt;	True if this is for a Package, false if it is for a bundlesubdefCache	&lt;Dictionary&gt;	Dictionary where the key is a class, and the value is an array of three items: 1) selectors on the instance side 2) selectors on the class side 3) Data objects (Shareds)</body></comment><class><name>Changes</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>symbol defChanges dataChanges </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.Changes</class-id><body>Changes is the abstract superclass for NameSpaceChanges and ClassChanges. These are used by the Store XChangeSets to dynamically track changes in packages.They keep track of the type of change made to avoid spurious changes and to produce the reverse change. For example, #add followed by #remove cancel each other out and the reverse of #addis #remove. This is useful when comparing packages and switching directions (ie. to go from packageA to packageB, add the defintion. To go from packageB to packageA, remove it).Subclasses must implement the following messages:	accessing		modifiedTags - answer Tags for all the modifications		removedTags - answer Tags for all removed defintions	fileIn/Out		fileOutObjectType	testing		isDefinitionChangedInstance Variables:	dataChanges	&lt;IdentityDictionary&gt;	shared name -&gt; the type of change	defChanges	&lt;Set of symbols&gt;	the set of changes made to the Class or Namespace itself	symbol	&lt;Symbol&gt;	absoluteSymbol of the class/namespace being tracked.</body></comment><class><name>NameSpaceChanges</name><environment>Store</environment><super>Store.Changes</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.NameSpaceChanges</class-id><body>Tracks various types of changes to a NameSpace for use in Store.XChangeSets.</body></comment><class><name>MethodDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector protocol fullClassName meta </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Subdefs</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.MethodDescriptor</class-id><body>MethodDescriptor provides a model of a method.Instance Variables:	selector	&lt;Symbol&gt;	The selector for the method	protocol	&lt;Symbol | nil&gt;	The method's protocol, or nil for some unknown reason	fullClassName	&lt;String&gt;	The absolute name for the class where the method lives	meta	&lt;Boolean&gt;	Indicating whether the method resides on the class or instance side of the class.</body></comment><class><name>BasicTableSpacePolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blobTableSpace defaultTableSpace userAndOwnershipTableSpace methodsTableSpace </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-Database</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.BasicTableSpacePolicy</class-id><body>BasicTableSpacePolicy is the policy used to create new database table spacesInstance Variables:	blobTableSpace	&lt;String&gt;		What table space to use when creating the Blob and BinaryBlob tables	defaultTableSpace	&lt;String&gt;		What table space to use for otherwise unspecified tables	methodsTableSpace	&lt;String&gt;		What table space to use for the Method and Methods tables	userAndOwnershipTableSpace	&lt;String&gt;		What table space to use for the DBPundlePrivileges and DBUserGroup tables</body></comment><class><name>ModelForParcel</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object hasDefinition data </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.ModelForParcel</class-id><body>ModelForParcel is an abstract superclass for NameSpaceForParcel and ClassForParcel.These are used within PackageForParcel to store Package information in a parcel neededto restore the bundle structure.Instance Variables:	data	&lt;Collection of Symbols&gt;	- shareds owned by the package	hasDefinition	&lt;Boolean&gt;	true if this package contains the object definition	object	&lt;Class | NameSpace&gt;	the object we are modeling</body></comment><class><name>NameSpaceForParcel</name><environment>Store</environment><super>Store.ModelForParcel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.NameSpaceForParcel</class-id><body>NameSpaceForParcel is used to reflect namespaces for a package in restoring bundle structure from a parcel.</body></comment><class><name>PackageDescription</name><environment>Store</environment><super>Store.ComponentDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.PackageDescription</class-id><body>Represents a package as a component or a prerequsite.</body></comment><class><name>StoreWarning</name><environment>Store</environment><super>Core.Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.StoreWarning</class-id><body>It appears that StoreWarning existed to supress warnings about duplicate adds and what not. However, it doesn't appear to be doing much now.</body></comment><class><name>ClassChanges</name><environment>Store</environment><super>Store.Changes</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodChanges metaMethodChanges </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.ClassChanges</class-id><body>Tracks various types of changes to a Class for use in Store.XChangeSets.instance variables: 	methodChanges &lt;IdentityDictionary: &lt;symbol&gt;-&gt;&lt;symbol&gt;&gt; - selector to change dictionary	metaMethodChanges &lt;IdentityDictionary: &lt;symbol&gt;-&gt;&lt;symbol&gt;&gt; - selector to change dictionary for class methods</body></comment><class><name>StoreError</name><environment>Store</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.StoreError</class-id><body>StoreError is the abstract superclass for Store errors. It exists to group the errors as in "on: StoreError do:"</body></comment><class><name>NameSpaceDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Records</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.NameSpaceDescriptor</class-id><body>Represents a NameSpace which may or may not exist in the image. Instance Variables:	fullName	&lt;String&gt;	absoluteName of the NameSpace</body></comment><class><name>NameSpaceExtensionDescriptor</name><environment>Store</environment><super>Store.NameSpaceDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Records</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.NameSpaceExtensionDescriptor</class-id><body>Represents a NameSpace which may or may not exist in the image for extensions (ie. shareds)</body></comment><class><name>UnloadedObjectError</name><environment>Store</environment><super>Store.StoreError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.UnloadedObjectError</class-id><body>UnloadedObjectError is signalled when an object that Store expects to exist in the system, doesn't.</body></comment><class><name>ExtensionNameSpaceModel</name><environment>Store</environment><super>Store.DefNameSpaceModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>data </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.ExtensionNameSpaceModel</class-id><body>Represents a class in a package that does not have the namespace definition, but only extension shared variables.Instance Variables:	data	&lt;IdentitySet of: symbol&gt;  The shared variable keys in this package.</body></comment><class><name>BundleModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.BundleModel</class-id><body>Manages the contents of a bundle.Description:Code components in the local image are represented as instances of PackageModel or BundleModel. The objects in the repository are represented as instances of Package or Bundle.Note that because PackageModels and BundleModels can be reconciled against many different databases, these objects do not track version information (e.g., the properties: version, last modified, modified by).Usage:Use the global Store.Registry to obtain PackageModel and BundleModel objects. For example:  Store.Registry packageNamed: 'XML-source'.or:  Store.Registry bundleNamed: 'Tools-IDE'.In either case you'll get back the BundleModel or PackageModel or nil if they don't exist.Instance Variables:	contents	&lt;List of: PundleModels&gt;  An ordered list of subcomponents.</body></comment><class><name>DatumDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataKey nameSpaceName className </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Subdefs</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.DatumDescriptor</class-id><body>DatumDescriptor provides a model for a shared variable that lives in a namespace or the namespace of a class.Instance Variables:	dataKey	&lt;Symbol&gt;	The name of this SharedVariable	nameSpaceName	&lt;String | nil&gt;	The absolute name of the namespace where this shared variable, nil if it belongs in the namespace of a class.	className	&lt;String | nil&gt;	The absolute name of the class whose namespace this shared variable belongs to, nil if it belongs in a namespace proper.</body></comment><class><name>Change</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type classSymbol meta nameSpaceSymbol subdef key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.Change</class-id><body>Change defines a single change to the system. These objects are transient, created for being added to a Changes object (ClassChanges or NameSpaceChanges) or as intermediate objects to be worked on by XChangeSet objects. Instance Variables:	classSymbol	&lt;Symbol | nil&gt;	For a Method or Class change, this is the fully pathed name of the Class being changed, for a Shared change, it is the path to the owning object (namespace or class)	key	&lt;Symbol | nil&gt;	For a Method change, this holds the method signature as a symbol. For a Shared, Class or Namespace change, this is the acutal name of the object	meta	&lt;Boolean | nil&gt;	For a Method change, this is true if it is a Class method, or false if it is a Instance method	nameSpaceSymbol	&lt;Symbol | nil&gt;	Used only for a Namespace change, the full path to the owning object	subdef	&lt;Symbol | nil&gt;	May be #dataKey (for a Shared) or #selector (for a method). If nil, then the type of change is a Class or Namespace change.	type	&lt;ByteSymbol&gt;	#add, #change, #comment, #override, #remove, #removeChanges, #removeDefinition or #reorganize</body></comment><class><name>ClassForParcel</name><environment>Store</environment><super>Store.ModelForParcel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors metaSelectors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.ClassForParcel</class-id><body>ClassForParcel is used to reflect classes for a package in restoring bundle structure from a parcel.Instance Variables:	metaSelectors	&lt;Collection of Symbols&gt;	 metaclass selectors the owning package owns.	selectors	&lt;Collection of Symbols&gt;	 selectors the owning package owns.</body></comment><class><name>PackageForParcel</name><environment>Store</environment><super>Store.PundleForParcel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.PackageForParcel</class-id><body>Represents packages within a parcel.</body></comment><class><name>StoreUnloadWarning</name><environment>Store</environment><super>Core.Warning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.StoreUnloadWarning</class-id><body>StoreUnloadWarning is raised when unloading packages</body></comment><class><name>ComponentRelatedChange</name><environment>Store</environment><super>Store.Change</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tag </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.ComponentRelatedChange</class-id><body>An extension to Changes that tracks CodeComponent changes for ChangeSets.Instance Variables:	tag	&lt;AbstractTag&gt;	the change</body></comment><class><name>BundleDescription</name><environment>Store</environment><super>Store.ComponentDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.BundleDescription</class-id><body>Represents a bundle as a component or a prerequsite.</body></comment><class><name>ClassExtensionDescriptor</name><environment>Store</environment><super>Store.ClassDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Records</category><attributes><package>PackageCategories</package></attributes></class><comment><class-id>Store.ClassExtensionDescriptor</class-id><body>Represents a class which may or may not exist in the image for extensions (ie. methods and sharedswhen the package does not own a defintion).</body></comment><shared-variable><name>EmergencyUnloadSignal</name><environment>Store.PundleModel</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>PackageCategories</package></attributes></shared-variable><shared-variable><name>Policies</name><environment>Store</environment><private>false</private><constant>false</constant><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></shared-variable><shared-variable><name>Registry</name><environment>Store</environment><private>false</private><constant>false</constant><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></shared-variable><shared-variable><name>ParcelDirectory</name><environment>Store.PundleAccess</environment><private>false</private><constant>false</constant><category>settings</category><initializer>Filename currentDirectory asLogicalFileSpecification</initializer><attributes><package>PackageCategories</package></attributes></shared-variable><shared-variable><name>BundleIcon</name><environment>Store.BundleModel</environment><private>false</private><constant>false</constant><category>visuals</category><initializer>nil</initializer><attributes><package>PackageCategories</package></attributes></shared-variable><shared-variable><name>PackageIcon</name><environment>Store.PackageModel</environment><private>false</private><constant>false</constant><category>visuals</category><initializer>nil</initializer><attributes><package>PackageCategories</package></attributes></shared-variable><shared-variable><name>VerboseUnload</name><environment>Store.PackageModel</environment><private>false</private><constant>false</constant><category>notification</category><initializer>true</initializer><attributes><package>PackageCategories</package></attributes></shared-variable><shared-variable><name>CurrentSet</name><environment>Store.XChangeSet</environment><private>false</private><constant>false</constant><category>current</category><attributes><package>PackageCategories</package></attributes></shared-variable><methods><class-id>Store.Model</class-id> <category>testing</category><body package="PackageCategories">existsInImage	^true</body><body package="PackageCategories">isClassModel	^false</body><body package="PackageCategories">isExtension	^false</body><body package="PackageCategories">isForClass	^false</body><body package="PackageCategories">isForData	^false</body><body package="PackageCategories">isForGeneral	^false</body><body package="PackageCategories">isForMethod	^false</body><body package="PackageCategories">isForNameSpace			^false</body><body package="PackageCategories">isLoaded	^self existsInImage</body><body package="PackageCategories">isNameSpaceModel	^false</body></methods><methods><class-id>Store.PackageModelSubModel</class-id> <category>data accessing</category><body package="PackageCategories">addDataKey: aDataKey	"It's not our problem to track data."	"Well.... it is under a very special circumstance. 	When a parcel is loading and my package overrode this class, some of my subdefs 	were put into the original classes' package and we have to reclaim them."	| pkg owner |	owner :=  self actual.	( pkg := Registry containingPackageForDataKey: aDataKey symbol: owner absoluteSymbol ) = self package		ifTrue: [ ^nil ].		"ok, its already ours"	pkg == nil		ifTrue: [ ^nil ].	pkg relinquishDataKey: aDataKey owner: owner.</body><body package="PackageCategories">dataKeys	^self systemDataKeys select: 		[ :selector | self quickIncludesDataKey: selector ]</body><body package="PackageCategories">dataKeysDo: aBlock	self dataKeys do: aBlock</body><body package="PackageCategories">datumDescriptorForDataKey: dataKey	 	^self datumDescriptorForDataKey: dataKey andName: self absoluteName</body><body package="PackageCategories">datumDescriptorForDataKey: dataKey andName: aName	self subclassResponsibility</body><body package="PackageCategories">datumDescriptors		| nsname |	nsname := self absoluteName.	^self dataKeys asSortedCollection asOrderedCollection collect: 		[ :dataKey | 		self datumDescriptorForDataKey: dataKey andName: nsname 		]</body><body package="PackageCategories">includesDataKey: dataKey	^[ ( ( Registry quickContainingPackageForDataKey: dataKey		symbol: self registrySymbol ) == self package ) 	and: [ self actual includesDataKey: dataKey ]	] on: UnloadedObjectError do: 		[: exp | exp return: false ].</body><body package="PackageCategories">protocols	^( self datumDescriptors collect: 		[ :d | d protocol ] 	 ) asSet asOrderedCollection.</body><body package="PackageCategories">quickIncludesDataKey: dataKey	"For when you know dataKey is loaded"	| containingPackage |	containingPackage := Registry quickContainingPackageForDataKey: dataKey symbol: self registrySymbol.	^containingPackage == self package</body><body package="PackageCategories">removeDataKey: dataKey	"It isn't our problem to track this stuff"	"well... maybe if we were overridden"	^self</body></methods><methods><class-id>Store.PackageModelSubModel</class-id> <category>browser support</category><body package="PackageCategories">binding	^self"		| ref |	^( ref := self fullName asQualifiedReference ) isDefined 		ifTrue: [ ref binding ]		ifFalse: [ nil ]."</body><body package="PackageCategories">containingPackages	"Answer all the packges that contain the definition for the receiver, 	including overriden."	^Registry allContainingPackagesForClassOrNameSpace: self actual</body></methods><methods><class-id>Store.PackageModelSubModel</class-id> <category>testing</category><body package="PackageCategories">hasDefinition	^true</body><body package="PackageCategories">isEmpty	"Is this class model holding onto nothing?"	"We have a definition so we cannot be."	^false</body><body package="PackageCategories">isExtension	^false</body></methods><methods><class-id>Store.PackageModelSubModel</class-id> <category>private</category><body package="PackageCategories">package	self subclassResponsibility</body><body package="PackageCategories">systemDataKeys	^self actual dataKeys</body></methods><methods><class-id>Store.PackageModelSubModel</class-id> <category>private-unloading</category><body package="PackageCategories">unloadAllDataKeysFromActual: anActualObject	"Unload all the receiver's data keys from the system"	self dataKeys do: [:key | Override unloadDataKey: key in: anActualObject from: self package]</body></methods><methods><class-id>Store.PackageModelSubModel</class-id> <category>printing</category><body package="PackageCategories">displayString	^self name</body><body package="PackageCategories">printOn: aStream	aStream nextPutAll: self printStringPrefix.	aStream nextPutAll: self fullName.	aStream nextPutAll: ':'.	aStream nextPutAll: self package name</body><body package="PackageCategories">printStringPrefix	^String new</body></methods><methods><class-id>Store.PackageModelSubModel</class-id> <category>symbols</category><body package="PackageCategories">registrySymbol	self subclassResponsibility</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>accessing</category><body package="PackageCategories">basicVersionString	| writeStream |	writeStream := (String new: 20) writeStream.	self printBasicVersionOn: writeStream.	^writeStream contents</body><body package="PackageCategories">changeSet 	changeSet == nil		ifTrue: [ changeSet := self class changeSetClass new ].	^changeSet</body><body package="PackageCategories">dbIdentifier 	^dbIdentifier</body><body package="PackageCategories">dbIdentifier: aSymbol	dbIdentifier := aSymbol asSymbol</body><body package="PackageCategories">dbTimestamp	^dbTimestamp</body><body package="PackageCategories">dbTimestamp: aTimestamp	dbTimestamp := aTimestamp</body><body package="PackageCategories">dbTrace		^dbTrace</body><body package="PackageCategories">dbTrace: anInteger	(dbTrace isNil or: [self shouldTrackChanges]) ifFalse:		[self addOtherChange: pundle parentChangedMark].	dbTrace := anInteger.	versionString := nil.	(anInteger notNil and: [pundle shouldTrackChanges]) ifTrue: 		[#{Store.DbRegistry} ifDefinedDo: [:ignored | self updateTraceInformation]].	self isInCurrentDatabase ifTrue:		[self manager traceChangedForComponent: pundle].</body><body package="PackageCategories">dbUsername	^dbUsername notNil		ifTrue: [dbUsername]		ifFalse: ['']</body><body package="PackageCategories">dbUsername: anObject	dbUsername := anObject</body><body package="PackageCategories">dbVersion	^dbVersion notNil		ifTrue: [dbVersion]		ifFalse: ['']</body><body package="PackageCategories">dbVersion: anObject	dbVersion := anObject</body><body package="PackageCategories">getBasicVersionString	^versionString ifNil: ['']</body><body package="PackageCategories">manager	^Registry</body><body package="PackageCategories">mergeInformation	^mergeInformation</body><body package="PackageCategories">mergeInformation: anObject	mergeInformation := anObject</body><body package="PackageCategories">printBasicVersionOn: writeStream	writeStream		nextPut: $(;		nextPutAll: self dbVersionOrDerived;		nextPut: $,;		nextPutAll: self dbUsernameOrDerived;		nextPut: $)</body><body package="PackageCategories">pundle	^pundle</body><body package="PackageCategories">pundle: aPundle	^pundle := aPundle</body><body package="PackageCategories">traceVersionString	"Answer a string describing a version of my trace  pundle. 	Use versionString cache if possible."		| string |	(string := versionString) ifNil:		[string := Store.DbRegistry isOnlineImage 			ifTrue: [(pundle storeForGlorpPundleClass traceVersionStringFor: self dbTrace) ifNil: ['']]			ifFalse: [''].		self versionString: string].	^string</body><body package="PackageCategories">versionString	"Answer the versionString based on cached information"		(dbVersion isNil or: [dbUsername isNil])		ifTrue: [			(self dbTrace isNil) "Can't figure it out without a link to the database"				ifTrue: [^'']				ifFalse: [self updateTraceInformation]].	^self basicVersionString</body><body package="PackageCategories">versionString: aString	"Set the cached versionString"		versionString := (aString == nil or: [aString isEmpty]) ifTrue: [nil] ifFalse: [aString]</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>testing</category><body package="PackageCategories">isChangeSetEmpty		^changeSet == nil or: [ changeSet isEmpty ]</body><body package="PackageCategories">isInCurrentDatabase	"The only time that DbRegistry might be defined and still be nil is	if StoreBase is being loaded into the image for the first time.  So,	the following check is simply to prevent walkbacks while loading	StoreBase."	^#{Store.DbRegistry}		ifDefinedDo: [:registry | registry notNil and: [registry dbIdentifier = self dbIdentifier]]		elseDo: [false]</body><body package="PackageCategories">shouldTrackChanges	^#{Store.DbRegistry} isDefined</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>initialization</category><body package="PackageCategories">initializeContentsFrom: anInfo	"pass"</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>printing</category><body package="PackageCategories">dbUsernameOrDerived	^dbUsername ifNil: [((self getBasicVersionString allButFirst: (self getBasicVersionString lastIndexOf: $,)) allButLast: 1)]</body><body package="PackageCategories">dbVersionOrDerived	^dbVersion ifNil: [((self getBasicVersionString first: (self getBasicVersionString lastIndexOf: $,) - 1) allButFirst: 1)]</body></methods><methods><class-id>Store.DatabaseConnectionInformation</class-id> <category>actions</category><body package="PackageCategories">addOtherChange: aChangeSymbol	self changeSet addOtherChange: aChangeSymbol</body><body package="PackageCategories">emptyChangeSet	changeSet := nil</body><body package="PackageCategories">setDbTrace: anInteger	dbTrace := anInteger</body></methods><methods><class-id>Store.DatabaseConnectionInformation class</class-id> <category>instance creation</category><body package="PackageCategories">dbIdentifier: aSymbol	"Answer an instance of the receiver for a database."	^self new		dbIdentifier: aSymbol asSymbol;		yourself.</body></methods><methods><class-id>Store.DatabaseConnectionInformation class</class-id> <category>private</category><body package="PackageCategories">changeSetClass	"Answer the changeSet class for pundles."	^XChangeSet</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>initialization</category><body package="PackageCategories">initialize	self initializeContents</body><body package="PackageCategories">initializeContents		contentDescriptions := List new.</body><body package="PackageCategories">initializeContentsFrom: aBundleConnectionInformation	"Set up the initial contents from  an existing dbconnection."		contentDescriptions := 		( aBundleConnectionInformation contentDescriptions collect:			[ :desc | 			desc copy 				id: nil; 				dbIdentifier: dbIdentifier;				yourself 			] ) asList.	#{Store.DbRegistry} ifDefinedDo:			[ :reg |			fileDescriptions := aBundleConnectionInformation fileDescriptions collect:				[ :desc | 				desc copy 					dbTrace: nil; 					yourself 				].			].</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>accessing</category><body package="PackageCategories">contentDescriptions	"Answer a collection of pundle descriptions."	^contentDescriptions</body><body package="PackageCategories">contentDescriptions: aCollection	contentDescriptions := aCollection asList</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation</class-id> <category>actions</category><body package="PackageCategories">addComponentDescription: aComponentDescription	"Add aComponentDescription to the contents"	( contentDescriptions includes: aComponentDescription )		ifTrue: [ ^false ].		contentDescriptions add: aComponentDescription.	self shouldTrackChanges 		ifTrue: [ self addOtherChange: pundle structureMark ].	Registry changedBundleStructure: self pundle.	^true</body><body package="PackageCategories">adjustComponents	"Ensure all components are named."	contentDescriptions do:		[ :desc | desc setName ].</body><body package="PackageCategories">component: aComponent beingRenamedTo: aString	"aComponent is about to be renamed to aString.  Ensure that the component description	 that the receiver has for aComponent has its componentName set appropriately.  	 Because this method is only invoked by the bundle that encloses aComponent, it is an	 error condition if a match can not be made. "		| matchingDescription |	matchingDescription := contentDescriptions		detect:			[:description | 			description name = aComponent name				and: [description isPackage = aComponent isPackage]]		ifNone: [nil].	matchingDescription isNil ifTrue:		[^self error: #NoMatchingComponentDescription &lt;&lt; #packages &gt;&gt; 'No matching component description'].	matchingDescription componentName: aString.	self shouldTrackChanges ifTrue: 		[self addOtherChange: pundle structureMark]</body><body package="PackageCategories">containedItems: aCollectionOfComponents	"Set my contents to be aCollectionOfComponents.	Note: consolidated, so #addedComponent event registered only once. 	The component is ignored anyway and this it is also used for removals."	| saved mark |	saved := contentDescriptions.	mark := false.	self initializeContents.	aCollectionOfComponents do: 		[:each |		| exitingDescription newDesciption dbInfo |		newDesciption := each asDescription.		(contentDescriptions includes: newDesciption) ifFalse: 			[exitingDescription := saved remove: newDesciption ifAbsent: [nil].			exitingDescription isNil				ifTrue: [mark := true]				ifFalse: 					[((dbInfo := each databaseInformationFor: dbIdentifier) notNil and: [dbInfo dbTrace = exitingDescription id])						ifTrue: [newDesciption := exitingDescription]].			contentDescriptions add: newDesciption]].	saved do: 		[:each |		(aCollectionOfComponents contains: [:eachComponent | eachComponent asDescription = each])			ifFalse: [mark := true]].	(self shouldTrackChanges and: [mark or: [(saved = contentDescriptions) not]])			ifTrue: [self addOtherChange: pundle structureMark].	Registry changedBundleStructure: self pundle</body><body package="PackageCategories">emptyChangeSet	super emptyChangeSet.	contentDescriptions do: 		[:description | 		description component ifNotNil: 			[:pundleModel | pundleModel emptyChangeSet]]</body><body package="PackageCategories">removeComponentDescription: aComponentDescription	"Remove aComponentDescription from the receiver's contents"	contentDescriptions remove: aComponentDescription ifAbsent: nil.	self shouldTrackChanges 		ifTrue: [ self addOtherChange: pundle structureMark ].	Registry changedBundleStructure: self pundle.</body><body package="PackageCategories">removeNonexistentComponents	contentDescriptions copy do:		[ :descr |		descr == nil			ifFalse: 				[ descr component == nil					ifTrue: [ self removeComponentDescription: descr ]				]		].</body><body package="PackageCategories">removeNonexistentComponentsRecursive	contentDescriptions copy do:		[ :descr | | comp |		descr == nil			ifFalse: 				[ ( comp := descr component ) == nil					ifTrue: [ self removeComponentDescription: descr ]					ifFalse: 						[ comp isBundle 							ifTrue: [ comp removeNonexistentComponentsRecursive ]						]				]		].</body></methods><methods><class-id>Store.DatabaseConnectionBundleInformation class</class-id> <category>instance creation</category><body package="PackageCategories">new	^super new		initialize</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>testing</category><body package="PackageCategories">existsInImage	^fullClassSymbol asStrictReference isDefined</body><body package="PackageCategories">isClassModel	^true</body><body package="PackageCategories">isForClass			^true</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>consistency checking</category><body package="PackageCategories">checkConsistencyOn: aStream 	| pcm pkg class |	pcm := self package classModelAtClassSymbol: self fullClassSymbol ifAbsent: [nil].	pcm isNil		ifTrue: 			[aStream nextPutAll: ((#classModelNotInPackage &lt;&lt; #packages &gt;&gt; 'class model "&lt;1s&gt;" not in package "&lt;2p&gt;"  it references: ')				expandMacrosWith: self fullClassSymbol				with: self package).			^aStream cr].	pcm == self		ifFalse: 			[aStream nextPutAll: ((#classModelDifferentThanInPackage &lt;&lt; #packages &gt;&gt; 'class model "&lt;1s&gt;" is not the same as in package "&lt;2p&gt;"  it references: ')				expandMacrosWith: self fullClassSymbol				with: self package).			^aStream cr].	pkg := Registry packageNamed: self package name.	pkg isNil		ifTrue: 			[aStream nextPutAll: ((#classModelRefersToUnloadedPackage &lt;&lt; #packages &gt;&gt; 'class model "&lt;1s&gt;" refers to package "&lt;2p&gt;" which is not loaded')				expandMacrosWith: self fullClassSymbol				with: self package).			^aStream cr].	pkg == self package		ifFalse: 			[aStream nextPutAll: ((#classModelRefersToDifferentPackage &lt;&lt; #packages &gt;&gt; 'class model "&lt;1s&gt;" refers to package "&lt;2p&gt;" which is different from the loaded package')				expandMacrosWith: self fullClassSymbol				with: self package).			^aStream cr].	class := self fullClassSymbol asStrictReference valueOrDo: [nil].	class isNil		ifTrue: 			["class printOn: 	aStream.aStream cr."			aStream nextPutAll: ((#classModelRefersToNonloadedClass &lt;&lt; #packages &gt;&gt; 'class model "&lt;1s&gt;" in package "&lt;2p&gt;" refers to non-loaded class')				expandMacrosWith: self fullClassSymbol				with: self package).			^aStream cr].	self isExtension 		ifTrue: 			[ self classAndSelectorDo: 				[:cls :sel | 				cls compiledMethodAt: sel ifAbsent: 						[aStream nextPutAll: (#classModelRefersToNonloadedSelector &lt;&lt; #packages &gt;&gt; 'class "&lt;1p&gt;" in package "&lt;2p&gt;" refers to non-loaded selector "&lt;3s&gt;"'							expandMacrosWith: cls							with: self package							with: sel).						aStream cr						]				].		 	self dataKeys do:				[ :key |				( class asNameSpace includesDataKey:key )					ifFalse: 						[ aStream nextPutAll: (#namespaceRefersToNonloadedDataKey &lt;&lt; #packages &gt;&gt; 'namespace "&lt;1p&gt;" in package "&lt;2p&gt;" refers to non-loaded datakey "&lt;3s&gt;"'							expandMacrosWith: class							with: self package							with: key).							aStream cr						]				]		].</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>printing</category><body package="PackageCategories">printStringPrefix	^'CM:'</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>accessing</category><body package="PackageCategories">asDescription	^ClassDescriptor fromModel: self</body><body package="PackageCategories">cloneFrom: aClassModel	"Copy all our selectors and data from another class model"	"We don't care about selectors or data"	^self</body><body package="PackageCategories">fileOutObjectType	^#class</body><body package="PackageCategories">name	^self fullName asStrictReference simpleName</body><body package="PackageCategories">package	^package</body><body package="PackageCategories">package: ourPackage	package := ourPackage</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>private</category><body package="PackageCategories">systemSelectorsMeta: isMeta 	^(self actualClassMeta: isMeta) selectors</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>class accessing</category><body package="PackageCategories">absoluteName	^self fullName</body><body package="PackageCategories">absoluteSymbol	^self fullClassSymbol</body><body package="PackageCategories">actual	^self actualClass</body><body package="PackageCategories">actualClass	^self actualClassMeta: false</body><body package="PackageCategories">actualClassMeta: isMeta 	| class |	class := fullClassSymbol asStrictReference valueOrDo:			[ ( UnloadedObjectError class: fullClassSymbol ) raiseSignal. ^nil ].	^isMeta		ifTrue: [ class class ]		ifFalse: [ class ]</body><body package="PackageCategories">classNameMeta: isMeta	^fullClassSymbol asString, (isMeta ifTrue: [' class'] ifFalse: [''])</body><body package="PackageCategories">fullClassSymbol	^fullClassSymbol</body><body package="PackageCategories">fullClassSymbol: aSymbol	fullClassSymbol := aSymbol</body><body package="PackageCategories">fullName	^fullClassSymbol asString</body><body package="PackageCategories">fullName: aString	^fullClassSymbol := aString asSymbol</body><body package="PackageCategories">fullSymbol: aSymbol	fullClassSymbol := aSymbol</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>data accessing</category><body package="PackageCategories">classAndDataKeyDo: aBlock 	"For each pair of the class and its datakeys, evaluate aBlock."	| actual |	actual := self actualClass.	self dataKeys copy do: 		[ :dataKey | aBlock value: actual value: dataKey].</body><body package="PackageCategories">datumDescriptorForDataKey: dataKey andName: aName 	^DatumDescriptor fromDataKey: dataKey className: aName</body><body package="PackageCategories">ownerDataKeyPairs	|  pairs |	pairs := OrderedCollection new.	self classAndDataKeyDo: 		[ :cls :dataKey |			pairs add: ( Array with: cls with: dataKey )		].	^pairs</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>selector accessing</category><body package="PackageCategories">addSelector: aSelector meta: isMeta 	"It's not our problem to track selectors."	"Well.... it is under a very special circumstance. 	When a parcel is loading and my package overrode this class, some of my selectors 	were put into the original classes' package and we have to reclaim them."	| pkg cls |	cls :=  self actualClassMeta: isMeta.	( pkg := Registry containingPackageForSelector: aSelector class: cls ) = self package		ifTrue: [ ^nil ].		"ok, its already ours"	pkg == nil		ifTrue: [ ^nil ].	pkg relinquishSelector: aSelector class: cls.</body><body package="PackageCategories">classAndSelectorDo: aBlock 	"For each pair of the class and its selectors and the meta class and its selectors	evaluate aBlock."	| actual |	actual := self actualClassMeta: false.	(self selectorsMeta: false) copy		do: [:selector | aBlock value: actual value: selector].	actual := self actualClassMeta: true.	(self selectorsMeta: true) copy		do: [:selector | aBlock value: actual value: selector]</body><body package="PackageCategories">classNameAndSelectorDo: aBlock 	"For each pair of the class and its selectors and the meta class and its selectors	evaluate aBlock."	| className |	className := self classNameMeta: false.	(self selectorsMeta: false)		do: [:selector | aBlock value: className value: selector].	className := self classNameMeta: true.	(self selectorsMeta: true)		do: [:selector | aBlock value: className value: selector]</body><body package="PackageCategories">classSelectorPairs	|  pairs |	pairs := OrderedCollection new.	self classAndSelectorDo: [:class :selector|		pairs add: (Array with: class with: selector)].	^pairs</body><body package="PackageCategories">compiledMethods		| comp |	comp := OrderedCollection new.	self classAndSelectorDo: [:class :selector|		comp add: (class compiledMethodAt: selector)].	^comp</body><body package="PackageCategories">includesSelector: aSelector meta: isMeta		^[(self quickIncludesSelector: aSelector meta: isMeta) and: [(self actualClassMeta: isMeta) includesSelector: aSelector]] 		on: UnloadedObjectError 		do: [:exception | exception return: false]</body><body package="PackageCategories">methodDescriptorForSelector: aSelector meta: isMeta	"Answer a method descriptor for aSelector."	"Shouldn't be asking if you don't know it's there."		^MethodDescriptor fromSelector: aSelector className: self absoluteName meta: isMeta</body><body package="PackageCategories">methods	^( self methodsMeta: true ), ( self methodsMeta: false )</body><body package="PackageCategories">methodsForProtocol: aProtocolName meta: isMeta 	| actual |	actual := self actualClassMeta: isMeta.	^( ( actual organization listAtCategoryNamed: aProtocolName) select: 			[ :selector | self quickIncludesSelector: selector meta: isMeta ]	 ) asSortedCollection asOrderedCollection 		collect: 			[:sel | 			MethodDescriptor 				fromSelector: sel 				className: actual absoluteName 				meta: isMeta 			]</body><body package="PackageCategories">methodsMeta: isMeta		| cname |	cname := self classNameMeta: isMeta.	^(self selectorsMeta: isMeta)		asSortedCollection 			asOrderedCollection				collect: [:sel| MethodDescriptor fromSelector: sel className: cname meta: isMeta ]</body><body package="PackageCategories">protocolsMeta: isMeta 	| actual | 	actual := self actualClassMeta: isMeta .	^actual organization categories 		select: [:proto | ((actual organization listAtCategoryNamed: proto)			detect: [:selector | self quickIncludesSelector: selector meta: isMeta] 			ifNone: [nil]) notNil]</body><body package="PackageCategories">quickIncludesSelector: aSelector meta: isMeta 	"For when you know 'aSelector' is loaded	It is possible that the package are not identity equal, so just test the names, which is appropriate"	| target |	target := (Registry		quickContainingPackageForSelector: aSelector		classSymbol: fullClassSymbol		meta: isMeta).	target isNil ifTrue: [^false].	^target name = package name</body><body package="PackageCategories">removeSelector: aSelector meta: isMeta	"It isn't our problem to track this stuff"	"well... maybe if we were overridden"	^self</body><body package="PackageCategories">selectorsMeta: isMeta 	^( self systemSelectorsMeta: isMeta ) select: 		[:selector | self quickIncludesSelector: selector meta: isMeta ]</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>browser support</category><body package="PackageCategories">selectors	^self actual selectors</body><body package="PackageCategories">value	"Implemented by any subclass wanting to be displayed in a browser"	^self actualClass</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>private-unloading</category><body package="PackageCategories">unloadAllDataKeys	"Before unloading the receiver, unload all the receiver's data keys from the system"	| actual |	actual := self actual.	self unloadAllDataKeysFromActual: actual</body><body package="PackageCategories">unloadAllSelectors	| affectedClasses |	affectedClasses := Set new.	self existsInImage ifFalse: [ ^affectedClasses ].		"validation"	self classSelectorPairs do: 		[ :pair | 		Override unloadSelector: pair last class: pair first from: package.		affectedClasses add: pair first.		].	^affectedClasses</body></methods><methods><class-id>Store.DefClassModel</class-id> <category>symbols</category><body package="PackageCategories">registrySymbol	^self fullClassSymbol</body></methods><methods><class-id>Store.DefClassModel class</class-id> <category>instance creation</category><body package="PackageCategories">package: ourPackage fullClassSymbol: aClassSymbol	^self new package: ourPackage; fullClassSymbol: aClassSymbol.</body><body package="PackageCategories">package: ourPackage fullSymbol: aClassSymbol	^self new package: ourPackage; fullClassSymbol: aClassSymbol.</body></methods><methods><class-id>Store.ExtensionClassModel</class-id> <category>selector accessing</category><body package="PackageCategories">addSelector: aSelector meta: isMeta	(self privateWritableSelectorsMeta: isMeta) add: aSelector</body><body package="PackageCategories">includesSelector: aSelector meta: isMeta	^(self selectorsMeta: isMeta) includes: aSelector</body><body package="PackageCategories">quickIncludesSelector: aSelector meta: isMeta	^(self selectorsMeta: isMeta) includes: aSelector</body><body package="PackageCategories">removeSelector: aSelector meta: isMeta	super removeSelector: aSelector meta: isMeta.	(self privateWritableSelectorsMeta: isMeta) remove: aSelector ifAbsent: []</body><body package="PackageCategories">selectorsMeta: isMeta 	^isMeta		ifTrue: [metaSelectors isNil				ifTrue: [#()]				ifFalse: [metaSelectors]]		ifFalse: [selectors isNil				ifTrue: [#()]				ifFalse: [selectors]]</body></methods><methods><class-id>Store.ExtensionClassModel</class-id> <category>data accessing</category><body package="PackageCategories">addDataKey: aDataKey	self privateData add: aDataKey</body><body package="PackageCategories">dataKeys	^data == nil		ifTrue: [ IdentitySet new ]		ifFalse: [ data ]</body><body package="PackageCategories">includesDataKey: dataKey	^self dataKeys includes: dataKey</body><body package="PackageCategories">quickIncludesDataKey: dataKey	^self includesDataKey: dataKey</body><body package="PackageCategories">removeDataKey: dataKey	super removeDataKey: dataKey.	data == nil ifTrue: [ ^self ].	self privateData remove: dataKey ifAbsent: [ ]</body></methods><methods><class-id>Store.ExtensionClassModel</class-id> <category>testing</category><body package="PackageCategories">hasDefinition	^false</body><body package="PackageCategories">isEmpty	"Is this class model holding onto nothing?"	^( selectors size = 0 )  &amp;  ( metaSelectors size = 0 ) &amp;  ( data size = 0 )</body><body package="PackageCategories">isExtension	^true</body></methods><methods><class-id>Store.ExtensionClassModel</class-id> <category>printing</category><body package="PackageCategories">printStringPrefix	^'CM-EXT:'</body></methods><methods><class-id>Store.ExtensionClassModel</class-id> <category>private</category><body package="PackageCategories">cloneFrom: aClassModel	"Copy all our selectors and data from another class model"	| keys |	super cloneFrom: aClassModel.	#( true false ) do: 		[:isMeta | 		( aClassModel selectorsMeta: isMeta ) 			do: [ :sel | self addSelector: sel meta: isMeta ]		].	data := ( keys := aClassModel dataKeys ) isEmpty		ifTrue: [ nil ]		ifFalse: [ keys ].</body><body package="PackageCategories">privateData	"Answer dataKeys defined by the receiver. Initialize the set if empty."	data isNil ifTrue: [ data := IdentitySet new ].	^data</body><body package="PackageCategories">privateWritableSelectorsMeta: isMeta 	"Return the list of selectors, depending on which subclass this may be 	the list of present or absent selector.  If the list is empty initialize it first"	^isMeta		ifTrue: 			[metaSelectors isNil ifTrue: [metaSelectors := IdentitySet new].			metaSelectors]		ifFalse: 			[selectors isNil ifTrue: [selectors := IdentitySet new].			selectors]</body></methods><methods><class-id>Store.BundleStructureChange</class-id> <category>fileIn/Out</category><body package="PackageCategories">fileIn	"File-in the receiver - ie. make the change to the system."	self createComponent structure: structure.</body><body package="PackageCategories">fileOutOn: aSourceFile	aSourceFile		bundleNamed: componentName		structure: structure</body></methods><methods><class-id>Store.BundleStructureChange</class-id> <category>testing</category><body package="PackageCategories">isStructureTag	^true</body><body package="PackageCategories">sameAsSystem	"Return true if the receiver represents an object that is the same as the system."	| bundle |	( bundle := self component ) == nil		ifTrue: [ ^false ].	^structure = bundle structure</body></methods><methods><class-id>Store.BundleStructureChange</class-id> <category>accessing</category><body package="PackageCategories">component: aBundle	"Extract relevant information from aCodeComponent."		super component: aBundle.	structure := aBundle structure.</body><body package="PackageCategories">componentType	^#bundle</body><body package="PackageCategories">name	"Answer the name which should appear in the list view."	nil == name 		ifTrue: [	name := self description ].	^name</body><body package="PackageCategories">parameters	"Return the parameters used for the 'same as' test"	^super parameters asOrderedCollection		add: structure;		asArray.</body><body package="PackageCategories">printStructure: aStructure on: aStream	aStream nextPutAll: '#('; cr.	aStructure do:		[:array | 		aStream			tab;			nextPutAll: array storeString;			cr].	aStream nextPutAll: ')'; cr.</body><body package="PackageCategories">structure	^structure</body><body package="PackageCategories">structure: anArray	structure := anArray.</body><body package="PackageCategories">structureString: aString	structure := Compiler evaluate: aString</body><body package="PackageCategories">systemText	"Answer the text displayed by the receiver."	| comp stream|	( comp := self component ) == nil		ifTrue: [ ^(#doesNotExist &lt;&lt; #packages &gt;&gt; 'does not exist') asString ].	stream := (String new: 100) writeStream.	stream nextPutAll: ((#x1sStructureC &lt;&lt; #packages &gt;&gt; '"&lt;1s&gt; structure: "')			expandMacrosWith: componentName); cr.	self printStructure: comp structure on: stream.	^stream contents</body><body package="PackageCategories">text		| stream |	stream := (String new: 100) writeStream.	stream nextPutAll: ((#x1sStructureC &lt;&lt; #packages &gt;&gt; '"&lt;1s&gt; structure: "')			expandMacrosWith: componentName); cr.	self printStructure: structure on: stream.	^stream contents</body><body package="PackageCategories">text: aString	self structureString: aString</body><body package="PackageCategories">type 	"Answer the sub-type of this kind of change."	^#structure</body></methods><methods><class-id>Store.BundleStructureChange</class-id> <category>store</category><body package="PackageCategories">doChangeTo: aChangeSet	"Perfrom the reciever's change onto aChangeSet."	"Used in converting ChangeSet changes to Store changes."	aChangeSet addOtherChange: BundleModel structureMark.</body></methods><methods><class-id>Store.BundleStructureChange</class-id> <category>printing</category><body package="PackageCategories">description		^((#x1sStructureChanged &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; structure changed')			expandMacrosWith: super description)</body><body package="PackageCategories">printOn: aStream		super printOn: aStream.	aStream 		nextPut: $(;		nextPutAll: ((#x1sStructureChanged &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; structure changed')			expandMacrosWith: componentName);		nextPut: $)</body></methods><methods><class-id>Store.BundleStructureChange</class-id> <category>converting</category><body package="PackageCategories">sourceTextForImage	| comp |	comp := self component.	^comp == nil		ifTrue: [ nil ]		ifFalse: [ comp structure ]</body></methods><methods><class-id>Store.PackageChooser</class-id> <category>initialize-release</category><body package="PackageCategories">initialize	| list pkgs |	super initialize.	pkgs := Registry allPackagesWithNull 				asSortedCollection: [ :p1 :p2 | p1 name &lt; p2 name ].	list := pkgs collect: [ :pk | pk name ].	sequence := SelectionInList new.	sequence list: list.	self cancel onChangeSend: #userCanceled to: self</body></methods><methods><class-id>Store.PackageChooser</class-id> <category>accessing</category><body package="PackageCategories">objectName: aString	objectName := aString</body><body package="PackageCategories">selectedPackageOrNil	^self accept value		ifTrue: 			[| sel |			(sel := sequence selection) notNil				ifTrue: [Registry packageNamed: sel]				ifFalse: [nil]]		ifFalse: [nil]</body></methods><methods><class-id>Store.PackageChooser</class-id> <category>aspects</category><body package="PackageCategories">dialogHeader	^objectName== nil		ifTrue: [ Registry currentPackage name ]		"ifTrue: [ 'Choose a Package' ]"		ifFalse: [ objectName ].</body><body package="PackageCategories">labelFor: aSymbol	^self perform: aSymbol</body><body package="PackageCategories">packageList	^sequence</body></methods><methods><class-id>Store.PackageChooser</class-id> <category>private-accessing</category><body package="PackageCategories">defaultPackage: aPkg	defaultPackage := aPkg</body><body package="PackageCategories">onCancelDo: aBlock	onCancelDo := aBlock</body><body package="PackageCategories">withAdd: aBoolean	withAdd := aBoolean</body></methods><methods><class-id>Store.PackageChooser</class-id> <category>private-actions</category><body package="PackageCategories">addNewPackage	| newPkg |	sequence selection: nil.	(newPkg := self addPackage) notNil		ifTrue: 			[sequence list add: newPkg name.			sequence selection: newPkg name.			self accept value: true]</body><body package="PackageCategories">addPackage	^SmalltalkWorkbench requestNewPackageName		ifNotNil: [:name | PackageModel named: name]</body><body package="PackageCategories">dClickAccept	self accept value: true</body><body package="PackageCategories">userCanceled	onCancelDo value</body></methods><methods><class-id>Store.PackageChooser</class-id> <category>interface opening</category><body package="PackageCategories">openFrom: aSpec 	"Open a dialog based on aSpec"	| okButton |	self allButOpenFrom: aSpec.	withAdd ifFalse: [(self builder componentAt: #addButton) beInvisible].	okButton := self builder componentAt: #OKbutton.	sequence selectionHolder compute: [:x | x isNil			ifTrue: [okButton disable]			ifFalse: [okButton enable]].	sequence selection: (defaultPackage isNil			ifTrue: [nil]			ifFalse: [defaultPackage name]).	(self widgetAt: #SelectionList) tooltip: nil.	builder openDialog.	^accept value</body></methods><methods><class-id>Store.PackageChooser class</class-id> <category>interface opening</category><body package="PackageCategories">choose	"Prompt the user to choose a package. 	He can pick one form the list, 	or cancel operation in whichcase a block is executed.	Answer the selected package or nil."	"self choose"	^self chooseOnCancelDo: [nil].</body><body package="PackageCategories">chooseOnCancelDo: cancelBlock	"Prompt the user to choose a package. 	He can pick one form the list	or cancel operation in whichcase a block is executed.	Answer the selected package or nil."	"self chooseOnCancelDo: [nil]"		| defPkg |	defPkg := Registry isCurrentNull ifTrue: [nil] ifFalse: [Registry currentPackage].	^self openWithDefault: defPkg withAdd: false onCancel: cancelBlock</body><body package="PackageCategories">chooseOrAdd	"Prompt the user to choose a package. 	He can pick one form the list, create a new one 	or cancel operation in which case a block is executed.	Answer the selected package or nil."	"self chooseOrAdd"	^self chooseOrAddOnCancelDo: [nil].</body><body package="PackageCategories">chooseOrAdd: objectName noCancelWithDefault: defPackage 	"Prompt the user to choose a package. 	He can pick one form the list, or create a new one. 	Answer the selected package."	"self chooseOrAddNoCancel"	^self		openWithDefault: defPackage		objectName: objectName		withAdd: true		onCancel: nil</body><body package="PackageCategories">chooseOrAdd: objectName onCancelDo: cancelBlock	"Prompt the user to choose a package. He can pick one form the list	or cancel operation in whichcase a block is executed.	Answer the selected package or nil."	"self chooseOrAdd: 'TestClass' onCancelDo: [Transcript show: 'canceled';cr]"		| defPkg |	defPkg := Registry isCurrentNull ifTrue: [nil] ifFalse: [Registry currentPackage].	^self openWithDefault: defPkg objectName: objectName withAdd: true onCancel: cancelBlock</body><body package="PackageCategories">chooseOrAdd: objectName withDefault: defPackage onCancelDo: aBlock	"Prompt the user to choose a package. He can pick one form the list, or create a new one. 	Answer the selected package."	"self chooseOrAddNoCancel"	^self		openWithDefault: defPackage		objectName: objectName		withAdd: true		onCancel: aBlock</body><body package="PackageCategories">chooseOrAddNoCancel	"Prompt the user to choose a package. 	He can pick one form the list, or create a new one. 	Answer the selected package."	"self chooseOrAddNoCancel"	^self chooseOrAddOnCancelDo: nil</body><body package="PackageCategories">chooseOrAddNoCancel: objectName	"Prompt the user to choose a package. 	He can pick one form the list, or create a new one. 	Answer the selected package."	"self chooseOrAddNoCancel"	^self chooseOrAdd: objectName onCancelDo: nil</body><body package="PackageCategories">chooseOrAddOnCancelDo: cancelBlock	"Prompt the user to choose a package. 	He can pick one form the list	or cancel operation in whichcase a block is executed.	Answer the selected package or nil."	"self chooseOrAddOnCancelDo: [Transcript show: 'canceled';cr]"		| defPkg |	defPkg := Registry isCurrentNull ifTrue: [nil] ifFalse: [Registry currentPackage].	^self openWithDefault: defPkg withAdd: true onCancel: cancelBlock</body><body package="PackageCategories">openWithDefault: aDefaultPackage objectName: objectName withAdd: aBoolean onCancel: cancelBlock 	| interface |	interface := cancelBlock isNil				ifTrue: [ #windowSpecNoCancel ]				ifFalse: [ #windowSpec ].	^self new		withAdd: aBoolean; 		onCancelDo: cancelBlock; 		objectName: objectName;		defaultPackage: aDefaultPackage;		openInterface: interface;		selectedPackageOrNil</body><body package="PackageCategories">openWithDefault: aDefaultPackage withAdd: aBoolean onCancel: cancelBlock 	| baby |	baby := self new.	baby withAdd: aBoolean; onCancelDo: cancelBlock; defaultPackage: aDefaultPackage.	baby openInterface: (cancelBlock isNil			ifTrue: [#windowSpecNoCancel]			ifFalse: [#windowSpec]).	^baby selectedPackageOrNil</body></methods><methods><class-id>Store.DefNameSpaceModel</class-id> <category>testing</category><body package="PackageCategories">isForNameSpace	^true</body><body package="PackageCategories">isNameSpaceModel	^true</body></methods><methods><class-id>Store.DefNameSpaceModel</class-id> <category>data accessing</category><body package="PackageCategories">datumDescriptorForDataKey: dataKey andName: aName 	^DatumDescriptor fromDataKey: dataKey nameSpaceName: aName</body><body package="PackageCategories">nameSpaceAndDataKeyDo: aBlock 	"For each pair of the namespace and its datakeys, 	evaluate aBlock."	| actual |	actual := self nameSpace.	self dataKeys do: 		[ :dataKey | aBlock value: actual value: dataKey].</body><body package="PackageCategories">nameSpaceNameAndDataKeyDo: aBlock 	"For each pair of the namespace and its selectors and the meta class and its selectors	evaluate aBlock."	| nsName |	nsName := self fullName.	self dataKeys do: 		[ :dataKey | aBlock value: nsName value: dataKey ].</body><body package="PackageCategories">ownerDataKeyPairs	|  pairs |	pairs := OrderedCollection new.	self nameSpaceAndDataKeyDo: 		[ :ns :dataKey |			pairs add: ( Array with: ns with: dataKey )		].	^pairs</body></methods><methods><class-id>Store.DefNameSpaceModel</class-id> <category>accessing</category><body package="PackageCategories">absoluteName	^BindingReference fullNameFrom: self environmentString name: name</body><body package="PackageCategories">absoluteSymbol	^self absoluteName asSymbol</body><body package="PackageCategories">actual	^self nameSpace</body><body package="PackageCategories">asDescription	^NameSpaceDescriptor fromModel: self</body><body package="PackageCategories">environment	^self environmentString asStrictReference valueOrDo: [ nil ]</body><body package="PackageCategories">environmentString	^environmentString</body><body package="PackageCategories">environmentString: aString	environmentString := aString</body><body package="PackageCategories">fileOutObjectType	"Answer a symbol that represents the type of the receiver."	^#namespace</body><body package="PackageCategories">fullName	^BindingReference fullNameFrom: self environmentString name: name</body><body package="PackageCategories">fullName: aString	"Extract environment and name."	| qual |	qual := aString asStrictReference.	environmentString := qual finalNameSpaceName.	name := qual simpleName.</body><body package="PackageCategories">fullSymbol: aSymbol	self fullName: aSymbol asString</body><body package="PackageCategories">name	^name</body><body package="PackageCategories">name: aString	^name</body><body package="PackageCategories">nameSpace	^self fullName asStrictReference valueOrDo: 		[ ( UnloadedObjectError nameSpace: self fullName ) raiseSignal. nil.]</body><body package="PackageCategories">package	^package</body><body package="PackageCategories">package: ourPackage	package := ourPackage</body></methods><methods><class-id>Store.DefNameSpaceModel</class-id> <category>printing</category><body package="PackageCategories">printStringPrefix	^'NSM:'</body></methods><methods><class-id>Store.DefNameSpaceModel</class-id> <category>initialize-release</category><body package="PackageCategories">cloneFrom: aNameSpaceModel	"Copy all our data from another namespace model"	aNameSpaceModel dataKeysDo:		[ :key | self addDataKey: key ].</body></methods><methods><class-id>Store.DefNameSpaceModel</class-id> <category>browser support</category><body package="PackageCategories">value	^self fullName asStrictReference valueOrDo: [ nil ].</body><body package="PackageCategories">valueOrDo: aBlock	^self fullName asStrictReference valueOrDo: aBlock.</body></methods><methods><class-id>Store.DefNameSpaceModel</class-id> <category>private-unloading</category><body package="PackageCategories">unloadAllDataKeys	"Before unloading the receiver, unload all the receiver's data keys from the system"	| actual |	actual := self valueOrDo: [ ^self ].	self unloadAllDataKeysFromActual: actual</body></methods><methods><class-id>Store.DefNameSpaceModel</class-id> <category>consistency checking</category><body package="PackageCategories">checkConsistencyOn: aStream	"Undeclared in the '(none)'/nullPackage is a special case 'cause it can be not identical"	| pmodel pkg ns |	pmodel := self package modelAtSymbol: self absoluteSymbol ifAbsent: [ nil ].	pmodel == nil		ifTrue: 			[ aStream nextPutAll: ((#x1sNotInPackage &lt;&lt; #packages &gt;&gt; 'namespace model &lt;1s&gt;" not in package "&lt;2p&gt;"  it references. ')				expandMacrosWith: self absoluteSymbol				with: self package).			^self.			].	(pmodel == self or: [pmodel ~= self and: [name = #Undeclared and: [package == Registry nullPackage]]])		ifFalse: 			[ aStream nextPutAll: ((#namespaceModelDifferentThanInPackage &lt;&lt; #packages &gt;&gt; 'namespace model &lt;1s&gt;" is not the same as in package "&lt;2p&gt;"  it references. ')				expandMacrosWith: self absoluteSymbol				with: self package).			^self			].	( pkg := Registry packageNamed: self package name ) == nil		ifTrue: 			[ aStream nextPutAll: ((#x1sRefersToPackageNotLoaded &lt;&lt; #packages &gt;&gt; 'namespace model &lt;1s&gt;" refers to package "&lt;2p&gt;" which is not loaded')				expandMacrosWith: self absoluteSymbol				with: self package).			^self.			].	pkg == self package		ifFalse: 			[ aStream nextPutAll: ((#x1sRefersToPackageDifferentThenLoaded &lt;&lt; #packages &gt;&gt; 'namespace model &lt;1s&gt;" refers to package "&lt;2p&gt;" which is different from the loaded package')				expandMacrosWith: self absoluteSymbol				with: self package).			^self.			].	( ns := self nameSpace ) == nil		ifTrue: 			[ aStream nextPutAll: ((#x1sInPackage &lt;&lt; #packages &gt;&gt; 'namespace model &lt;1s&gt;" in package "&lt;2p&gt;" refers to non-loaded namespace')				expandMacrosWith: self absoluteSymbol				with: self package).			^self.			].	self isExtension 		ifTrue: 			[ self dataKeys do:				[ :key |				( ns includesDataKey:key )					ifFalse: [ aStream nextPutAll: ((#namespaceRefersToNonloadedDataKey &lt;&lt; #packages &gt;&gt; 'namespace "&lt;1p&gt;" in package "&lt;2p&gt;" refers to non-loaded datakey "&lt;3s&gt;"')								expandMacrosWith: ns								with: self package								with: key).							aStream cr						 ]				]			].</body></methods><methods><class-id>Store.DefNameSpaceModel</class-id> <category>symbols</category><body package="PackageCategories">registrySymbol	^self fullName asSymbol</body></methods><methods><class-id>Store.DefNameSpaceModel class</class-id> <category>instance creation</category><body package="PackageCategories">package: ourPackage fullSymbol: aSymbol	^self new package: ourPackage; fullSymbol: aSymbol.</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>namespace model</category><body package="PackageCategories">addNameSpaceModel: nameSpaceModel	self addModel: nameSpaceModel named: nameSpaceModel absoluteSymbol</body><body package="PackageCategories">containingPackageForNameSpace: namespace	^self containingPackageForSymbol: namespace absoluteSymbol</body><body package="PackageCategories">nameSpaceModelsForNameSpaceName: aFullSymbol do: aBlock 	self modelsForSymbol: aFullSymbol do: aBlock</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>class model</category><body package="PackageCategories">addClassModel: cm 	self addModel: cm named: cm absoluteName.</body><body package="PackageCategories">classModelsForClassSymbol: aClassSymbol do: aBlock 	self modelsForSymbol: aClassSymbol do: aBlock</body><body package="PackageCategories">defClassModelForClassSymbol: aFullSymbol 	^self defModelForSymbol: aFullSymbol</body><body package="PackageCategories">defNameSpaceModelForNameSpaceSymbol: aFullSymbol 	^self defModelForSymbol: aFullSymbol</body><body package="PackageCategories">extensionClassModelsForClassSymbol: aClassSymbol 		^self extensionModelsForSymbol: aClassSymbol</body><body package="PackageCategories">extensionModelsForSymbol: aSymbol 	"Answer all extension models for aSymbol or an empty collection if none."	| models |	models := modelDictionary at: aSymbol ifAbsent: [ ^#() ].	^models size &gt; 1		ifTrue: [ models copyFrom: 2 to: models size ]		ifFalse: [#() ]</body><body package="PackageCategories">packagesContaining: aClassOrNameSpace	"Answer a collection of packages that contain some methods/statics for aClassOrNameSpace.	The first package contains the definition."	"Store.Registry packagesContaining: Object class"	| symbol |	symbol := aClassOrNameSpace isBehavior		ifTrue: [ aClassOrNameSpace instanceBehavior absoluteSymbol ]		ifFalse: [  aClassOrNameSpace absoluteSymbol ].	^( self modelsForSymbol: symbol ) collect:		[ :model | model package ]</body><body package="PackageCategories">packagesContaining: aClassOrNameSpace do: aBlock 	"Evaluate aBlock for each packages that contain some methods/statics for aClassOrNameSpace."	"Store.Registry packagesContaining: Object class do: [ :pkg | Transcript show: pkg name; tab ]"	| symbol |	symbol := aClassOrNameSpace isBehavior		ifTrue: [ aClassOrNameSpace instanceBehavior absoluteSymbol ]		ifFalse: [  aClassOrNameSpace absoluteSymbol ].	self modelsForSymbol: symbol do: 		[ :model | aBlock value: model package ]</body><body package="PackageCategories">packagesContainingClass: aClass do: aBlock 	"Evaluate aBlock for each packages that contain some methods/statics for aClass."	self classModelsForClassSymbol: aClass instanceBehavior absoluteSymbol do: 		[:cm | aBlock value: cm package]</body><body package="PackageCategories">packagesContainingClassSymbol: classSymbol do: aBlock 	self classModelsForClassSymbol: classSymbol do: 		[:cm | aBlock value: cm package]</body><body package="PackageCategories">packagesContainingNameSpace: namespace do: aBlock 	self modelsForSymbol: namespace absoluteSymbol do: 		[ :model | aBlock value: model package ]</body><body package="PackageCategories">quickContainingClassModelForSelector: aSelector classSymbol: aClassSymbol meta: isMeta	"If there are extensions check them for the selector.  	Otherwise use the class' model do not ask the class' model if it includes 	the selector or there will be infinite recursion.	The last(est) one in the list is the one that has the current definition"	| classModels |	classModels := modelDictionary at: aClassSymbol ifAbsent: [^nil].	classModels size &gt; 1 ifTrue: 		[classModels size to: 2 by: -1 do: 			[:index |			| classModel |			classModel := classModels at: index.			(classModel includesSelector: aSelector meta: isMeta) ifTrue: [^classModel]]].	^classModels first</body><body package="PackageCategories">quickContainingModelForDataKey: datakey symbol: aSymbol	"If there are extensions check them for the datakey.  Otherwise use the class' model.	Do not ask the def model if it includes the datakey or there will be infinite recursion."	| models |	models := modelDictionary at: aSymbol ifAbsent: [ ^nil ].	models size &gt; 1		ifTrue: 			[ 2 to: models size do: 				[ :index | | model |				model := models at: index.				( model includesDataKey: datakey )						ifTrue: [ ^model ]				].			].	^models first</body><body package="PackageCategories">removeClassModel: cm 	self removeModel: cm named: cm absoluteSymbol</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>private model accessing</category><body package="PackageCategories">addModel: model 	self addModel: model named: model absoluteSymbol.</body><body package="PackageCategories">addModel: aModel named: aFullSymbol	"private- generic for looking up in model dictionaries"	"took out a couple 'snafus'. They can mess the image up."	| models symbol |	symbol := aFullSymbol asSymbol.	models := modelDictionary at: symbol ifAbsentPut: [Array new: 1].	aModel isExtension		ifTrue: [modelDictionary at: symbol put: (models copyWith: aModel)]		ifFalse: 			[models first isNil				ifFalse: 					[self notify: #GlobalPackageModelsCorrupted &lt;&lt; #packages &gt;&gt; 'The Global Package Model Dictionary May Be Corrupted'].			models at: 1 put: aModel]	"means there should be at least a defmodel there"</body><body package="PackageCategories">definitionModels	^( modelDictionary collect: [ :list | list first ]  )		reject: [ :m | m == nil ]</body><body package="PackageCategories">defModelForSymbol: aFullSymbol 	^( modelDictionary at: aFullSymbol ifAbsent: [ ^nil ] ) first</body><body package="PackageCategories">modelKeys	^modelDictionary keys</body><body package="PackageCategories">modelsForSymbol: aFullSymbol 	"Answer a list of def/extenstion models for aFullSymbol"	^( modelDictionary at: aFullSymbol ifAbsent: [ ^#() ] ) 		reject: [ :m | m == nil ]</body><body package="PackageCategories">modelsForSymbol: aFullSymbol do: aBlock 	"Perform aBlock for every def/extenstion model for aFullSymbol"	| models |	models := modelDictionary at: aFullSymbol ifAbsent: [ ^self ].	models do: 		[ :model | model == nil ifFalse: [ aBlock value: model ] ].</body><body package="PackageCategories">removeModel: model named: fullSymbol	"Removes all mention of the class/namespace represented by model from the registry."	"Newer version is more forgiving, so we can use it cleaning up."	| models |	models := modelDictionary at: fullSymbol ifAbsent: [^self].	model isExtension		ifTrue: 			[| index |			index := models indexOf: model ifAbsent: [^self].			index = 1				ifTrue: [self notify: (#RemovingNonexistentExtension1s &lt;&lt; #packages &gt;&gt; 'Attempting to Remove non-existent extension: &lt;1s&gt;' expandMacrosWith: models first absoluteName)].			models size = 2				ifTrue: 					[models first isNil						ifTrue: [modelDictionary removeKey: fullSymbol]						ifFalse: [modelDictionary at: fullSymbol put: (models copyWithout: model)]]				ifFalse: [modelDictionary at: fullSymbol put: (models copyWithout: model)]]		ifFalse: 			[model = models first				ifTrue: 					[models size == 1						ifTrue: [modelDictionary removeKey: fullSymbol]						ifFalse: [models at: 1 put: nil]]				ifFalse: 					[models first isNil						ifTrue: [^self]						ifFalse: 							[self halt: (#RemovingMisnamed1s &lt;&lt; #packages &gt;&gt; 'Attempting to Remove Internally Misnamed: &lt;1s&gt;' expandMacrosWith: models first absoluteName)]]]</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>private-image delivery</category><body package="PackageCategories">createTableOfContents	"Registry createTableOfContents"	| aStream fName |	fName := Dialog requestNewFileName: (#RequestTOCfileName &lt;&lt; #packages &gt;&gt; 'Write the package table of contents to:') default: 'toc'.	fName isEmpty ifTrue: [^self].	aStream := fName asFilename writeStream.	[Registry tableOfContentsOn: aStream]		ensure: [aStream close].	fName := Dialog requestNewFileName: (#RequestTOBCfileName &lt;&lt; #packages &gt;&gt; 'Write the bundle table of contents to:') default: 'tobc'.	fName isEmpty ifTrue: [^self].	aStream := fName asFilename writeStream.	[Registry tableOfBundleContentsOn: aStream]		valueNowOrOnUnwindDo: [aStream close]</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>utility</category><body package="PackageCategories">repairForMethodsInZeroOrMultiplePackages	"Registry repairForMethodsInZeroOrMultiplePackages"	Transcript cr; show: (#CheckingMultiplePackagesOrNone &lt;&lt; #packages &gt;&gt; 'Checking/repairing methods in multiple packages or no package').	Object allSubclassesDo: [:class | class selectors			do: 				[:selector | 				| pkgs cnt |				cnt := 0.				pkgs := self whatPackagesContainSelector: selector class: class.				pkgs size &gt; 1					ifTrue: [Transcript show: class printString , '&gt;&gt;' , selector asString , ' --&gt; ' , pkgs asArray printString; cr]					ifFalse: [(pkgs size &lt; 1 or: [pkgs first name = '(none)'])							ifTrue: 								[cnt := cnt + 1.								XChangeSet current									moveSelector: selector									class: class									toPackage: (self containingPackageForClass: class)]].				cnt &gt; 0 ifTrue: [Transcript cr; show: ((#MovingMethodsToNewPackage &lt;&lt; #packages &gt;&gt; 'Moved &lt;1s&gt; methods in class &lt;2s&gt; to &lt;3s&gt;')								expandMacrosWith: cnt printString								with: class printString								with: (self containingPackageForClass: class) name)]]].	Transcript cr; show: (#Done &lt;&lt; #packages &gt;&gt; 'Done.'); cr.</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>consistency checking</category><body package="PackageCategories">checkConsistencyOn: aStream 	"| strm | strm := WriteStream on: String new. 	Registry checkConsistencyOn: strm. 	Transcript show: strm contents; cr"	| checkSize |	checkSize := 		[ ( aStream size &gt; 1000 ) ifTrue: [ ^aStream nextPutAll: '.......' ] ].	self cleanseModels.	self checkModelsOn: aStream .	checkSize value.	self checkPackagesOn: aStream.	checkSize value.	self checkForNameSpaceAndDataInZeroOrMultiplePackagesOn: aStream.	checkSize value.	self checkForClassesAndMethodsInZeroOrMultiplePackagesOn: aStream</body><body package="PackageCategories">checkForClassesAndMethodsInZeroOrMultiplePackagesOn: aStream 	Root allClasses do: 		[ :class | 		( self containingPackageForClass: class ) == nil			ifTrue: [ class isMeta ifFalse: [ aStream nextPutAll: ((#x1sUnpackaged &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; - Unpackaged')						expandMacrosWith: class printString); cr ] ]			ifFalse: 				[ | cms |				cms := self extensionClassModelsForClassSymbol: class absoluteSymbol.				cms size &gt;= 2 ifTrue: 					[ class selectors do: 						[ :selector |   | pkgs |						pkgs := OrderedCollection new.						cms do: 							[ :cm | 							( cm includesSelector: selector meta: class isMeta )								ifTrue: [ pkgs add: cm package ] 							].						pkgs size &gt; 1 							ifTrue: [ aStream nextPutAll: ((#x1s2sInPackages3s &lt;&lt; #packages &gt;&gt; '&lt;1s&gt;%&gt;%&gt;&lt;2s&gt; in packages &lt;3s&gt;')								expandMacrosWith: class printString								with: selector asString								with: pkgs asArray printString); cr ]						]					].					class dataKeys do:						[ :key |  | pkgs |						pkgs := OrderedCollection new.						cms do: 							[ :cm | 							( cm includesDataKey: key )								ifTrue: [ pkgs add: cm package ] 							].						pkgs size &gt; 1 							ifTrue: [ aStream nextPutAll: ((#x1sDot2sInPackages3s &lt;&lt; #packages &gt;&gt; '&lt;1s&gt;.&lt;2s&gt; in packages &lt;3s&gt;')								expandMacrosWith: class printString								with: key asString								with: pkgs asArray printString); cr ]						]				]		]</body><body package="PackageCategories">checkForNameSpaceAndDataInZeroOrMultiplePackagesOn: aStream 	Root allNameSpaces do: 		[ :ns | 		( self containingPackageForNameSpace: ns ) == nil			ifTrue: [ aStream nextPutAll: ((#x1sUnpackaged &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; - Unpackaged')							expandMacrosWith: ns printString); cr ]			ifFalse: 				[ | models |				models := self extensionModelsForSymbol: ns absoluteSymbol.				models size &gt;= 2 ifTrue: 					[ ns dataKeys do:						[ :key |  | pkgs |						pkgs := OrderedCollection new.						models do: 							[ :model | 							( model includesDataKey: key )								ifTrue: [ pkgs add: model package ] 							].						pkgs size &gt; 1 							ifTrue: [ aStream nextPutAll: ((#x1sDot2sInPackages3s &lt;&lt; #packages &gt;&gt; '&lt;1s&gt;.&lt;2s&gt; in packages &lt;3s&gt;')								expandMacrosWith: ns printString								with: key asString								with: ns asArray printString); cr ]						]					]				]		]</body><body package="PackageCategories">checkModel: model symbol: symbol isExtension: isExtension on: aStream 	model absoluteName asSymbol == symbol		ifFalse: 			[aStream nextPutAll: ((#modelDictEntryWrongName &lt;&lt; #packages &gt;&gt; 'model dictionary entry "&lt;1s&gt;" includes model "&lt;2p&gt;" with different name')				expandMacrosWith: symbol				with: model classSymbol).			aStream cr]		ifTrue: [model isExtension ~~ isExtension				ifTrue: 					[aStream nextPutAll: ((#modelDictWrongSlot &lt;&lt; #packages &gt;&gt; 'model dictionary wrong slot "&lt;1s&gt;" in package "&lt;2p&gt;"')						expandMacrosWith: symbol						with: model package).					aStream cr]				ifFalse: 					[model checkConsistencyOn: aStream ]]</body><body package="PackageCategories">checkModels: models for: aSymbol on: aStream 	"Private- subroutine for #checkClassModelsOn: 	Check that a model collection is correct. Registered in a package, 	that the class to class models dictionary is in proper form, that the class models 	themselves are correct (refer the existent classes and methods, etc)."	| instSelectors metaSelectors dataKeys forClass |	aSymbol isSymbol		ifFalse: [ ^aStream nextPutAll: ((#modelKeyNotSymbol &lt;&lt; #packages &gt;&gt; 'model dictionary key not a symbol: &lt;1s&gt;')					expandMacrosWith: aSymbol); cr ].	models isNil		ifTrue:  [ ^aStream nextPutAll: ((#modelEntryNil &lt;&lt; #packages &gt;&gt; 'model dictionary entry is nil: &lt;1s&gt;')					expandMacrosWith: aSymbol); cr ].	models size = 0		ifTrue: [ ^aStream nextPutAll: ((#modelEntryZeroSize &lt;&lt; #packages &gt;&gt; 'class model dictionary entry is zero size: &lt;1s&gt;')					expandMacrosWith: aSymbol); cr. ].	models first isNil		ifTrue: [aStream nextPutAll: ((#x1sIsNotInAPackage &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; is not in a package')					expandMacrosWith: aSymbol); cr ]		ifFalse: 				[ models first isClassModel 					ifTrue:						[ self							checkModel: models first							symbol: aSymbol							isExtension: false							on: aStream.						forClass := true.						]					ifFalse: 						[ self							checkNameSpaceModel: models first							symbol: aSymbol  							isExtension: false							on: aStream.						forClass := false. 						].				].			"Check extension models"		instSelectors := IdentitySet new.		metaSelectors := IdentitySet new.		dataKeys := IdentitySet new.		2 to: models size do: 			[ :index |   | model |			( model := models at: index ) == nil				ifTrue: 					[ aStream nextPutAll: ((#modelExtensionsNil &lt;&lt; #packages &gt;&gt; 'model dictionary extension is nil: &lt;1s&gt;')						expandMacrosWith: aSymbol).					aStream cr]				ifFalse: 					[ 					model isClassModel 						ifFalse: 							[ | newData | 							forClass == true 								ifTrue: [ aStream nextPutAll: ((#x1sBothClassAndNamespace &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; has both class and namespace models.')										expandMacrosWith: aSymbol); cr ].							forClass := false.							newData := model dataKeys.							newData do: 								[ :dataKey | 								(dataKeys includes: dataKey)										ifTrue: 											[aStream nextPutAll: ((#dataInMultiplePackages &lt;&lt; #packages &gt;&gt; 'data &lt;1s&gt;:&lt;2s&gt; is in another package besides &lt;3p&gt;')												expandMacrosWith: aSymbol												with: dataKey												with: model package).											aStream cr].								self									checkNameSpaceModel: model									symbol: aSymbol									isExtension: true									on: aStream								].							dataKeys addAll: newData.					  ]				ifTrue:						[ | newInst newMeta |						forClass := true.						newInst := model selectorsMeta: false.						newMeta := model selectorsMeta: true.						newInst do: 							[ :selector | 							(instSelectors includes: selector)								ifTrue: 									[aStream nextPutAll: ((#methodInMultiplePackages &lt;&lt; #packages &gt;&gt; 'method &lt;1s&gt;%&gt;&lt;2s&gt; is in another package besides &lt;3p&gt;')											expandMacrosWith: aSymbol											with: selector											with: model package).									aStream cr]							].							instSelectors addAll: newInst.							newMeta do: 								[:selector | 								(metaSelectors includes: selector)									ifTrue: 										[aStream nextPutAll: ((#metaMethodInMultiplePackages &lt;&lt; #packages &gt;&gt; 'method &lt;1s&gt; class%&gt;&lt;2s&gt; is in another package besides &lt;3p&gt;')													expandMacrosWith: aSymbol													with: selector													with: model package).										aStream cr]								].								metaSelectors addAll: newMeta.				]			]		].</body><body package="PackageCategories">checkModelsOn: aStream 	"Check that all models are in their package, that these packages are registered, 	that the class to class models dictionary is in proper form, that the class models 	themselves are correct (refer the existent classes and methods, etc)."	"| strm | strm := WriteStream on: String new. 	TT_Registry checkClassModelsOn: strm. 	Transcript show: strm contents; cr"	modelDictionary keysAndValuesDo: 		[ :symbol :models | 		self checkModels: models for: symbol on: aStream 		].</body><body package="PackageCategories">checkNameSpaceModel: model symbol: nsSymbol isExtension: isExtension on: aStream 	model absoluteName asSymbol == nsSymbol		ifFalse: 			[aStream nextPutAll: ((#namespaceModelHasClassNameWrong &lt;&lt; #packages &gt;&gt; 'namespace model dictionary entry "&lt;1s&gt;" includes class model "&lt;2p&gt;" with different name')				expandMacrosWith: nsSymbol				with: model symbol).			aStream cr]		ifTrue: [model isExtension ~~ isExtension				ifTrue: 					[aStream nextPutAll: ((#namespaceModelWrongSlot &lt;&lt; #packages &gt;&gt; 'namespace model dictionary wrong slot "&lt;1s&gt;" in package "&lt;2p&gt;"')						expandMacrosWith: nsSymbol						with: model package).					aStream cr]				ifFalse: 					[model checkConsistencyOn: aStream ]]</body><body package="PackageCategories">checkPackagesOn: aStream	packages keys do:		[ :key | 		key isSymbol			ifTrue: [ aStream nextPutAll: ((#PackageShouldBeString &lt;&lt; #packages &gt;&gt; 'Package: &lt;1s&gt; is a symbol, not a string).')					expandMacrosWith: key) ]		].	bundles keys do:		[ :key | 		key isSymbol			ifTrue: [ aStream nextPutAll: ((#BundleShouldBeString &lt;&lt; #packages &gt;&gt; 'Bundle: &lt;1s&gt; is a symbol, not a string).')					expandMacrosWith: key) ]		].	self packagesDo: [:pkg | pkg checkConsistencyOn: aStream ].</body><body package="PackageCategories">cleanseModels	"Check that all models exist - remove non-existant models and dispaly a warning."	self cleanseModels: true</body><body package="PackageCategories">cleanseModels: warn	"Check that all models exist - remove non-existent models and display a warning if warn is true."	| real undeclaredModel |	modelDictionary values copy do: 		[:models |		models first isNil			ifTrue: 				[[real := (models at: 2) actual] 					on: UnloadedObjectError					do: [:exception | modelDictionary removeKey: models second absoluteSymbol].				real isNil ifFalse: 					[modelDictionary removeKey: (models at: 2) absoluteSymbol.					2 to: models size do: 						[:index |						| model |						model := models at: index.						model fullSymbol: real absoluteSymbol.						self addModel: model]]]				ifFalse: 					[[models first actual] 						on: UnloadedObjectError						do: 							[:exception |							warn ifTrue: 								[Dialog warn: (#RemovingNonexistentC1s &lt;&lt; #packages &gt;&gt; 'Removing non-existent: &lt;1s&gt;'										expandMacrosWith: models first absoluteName)].						modelDictionary removeKey: models first absoluteSymbol]]].	undeclaredModel := modelDictionary at: #'Root.Smalltalk.Kernel.Undeclared' ifAbsent: [^self].	((undeclaredModel allButFirst: 1) select: [:each | each package = self nullPackage]) do:		[:each |		each dataKeys copy do: [:eachData | (Undeclared includesKey: eachData) ifFalse: [each removeDataKey: eachData]].		each dataKeys isEmpty ifTrue: [self removeModel: each named: #'Root.Smalltalk.Kernel.Undeclared']]</body><body package="PackageCategories">whatPackagesContainDatum: aDataKey classOrNameSpace: owner 	| pkgs |	pkgs := OrderedCollection new.	self modelsForSymbol: owner absoluteSymbol do: 		[ :model | ( model includesDataKey: aDataKey )			ifTrue: [ pkgs add: model package ]		].	^pkgs</body><body package="PackageCategories">whatPackagesContainSelector: aSelector class: aClass 	| pkgs |	pkgs := OrderedCollection new.	self classModelsForClassSymbol: aClass absoluteName asClassNameOnly asSymbol do: 		[ :cm | ( cm includesSelector: aSelector meta: aClass isMeta )			ifTrue: [ pkgs add: cm package ]		].	^pkgs</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>initialize-release</category><body package="PackageCategories">cloneFrom: aPundleAccess	"| pa | pa := PundleAccess new. pa cloneFrom: Registry. Registry := pa."		aPundleAccess packagesDo:		[:eachPackage | 		packages at: eachPackage name put: eachPackage.		eachPackage modelsDo: [:eachClassModel | self addClassModel: eachClassModel]].	aPundleAccess bundlesDo:		[:eachBundle |  		bundles at: eachBundle name put: eachBundle].	aPundleAccess nullPackage modelsDo:		[:each | self nullPackage addClassModel: (each package: self nullPackage; yourself)].	"My nullPackage is initialized to a new object so we must reset the class models to use it."</body><body package="PackageCategories">initialize	bundles := Dictionary new.	packages := Dictionary new.	modelDictionary := IdentityDictionary new.	"When creating the null package, it is important to workaround	 PundleModel class&gt;&gt;#named:, otherwise the null package will be	 added to the list of packages."	nullPackage := PackageModel new		name: self nullPackageName;		comment: 'This "package" is a special package that holds all code (classes, methods, shares, namespaces) that does not show up in a normal package. It is generated automatically. Removing it will remove the code contained in it, but the package itself never goes away. It can serve as a temporary "scratch space" to try quick throw away work before creating a normal package.';		markNotModified;	"otherwise the comment would appear as a change"		yourself.	currentPackage := nullPackage.	self addDependent: self</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>pundle model private access</category><body package="PackageCategories">privateRegisterPundle: aPundleModel 	"Private access for loaded pundles to register 	themselves on creation."	( aPundleModel isBundle		ifTrue: [ bundles ]		ifFalse: [ packages ]	 ) at: aPundleModel name put: aPundleModel.	self changed: #addedPundle with: aPundleModel.	ChangeSet createdComponent: aPundleModel.	SourceFileManager default createdComponent: aPundleModel.</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>table of contents</category><body package="PackageCategories">executeTableOfBundleContents: aTC 	^aTC isSequenceable		ifTrue: [aTC first createComponent containedItems: (aTC last collect: [:desc | self executeTableOfBundleContents: desc])]		ifFalse: [aTC createComponent]</body><body package="PackageCategories">executeTableOfBundleContentsFromFile: aString 	"Registry executeTableOfBundleContentsFromFile: 'TOBC'"	| strm tc |		[strm := aString asFilename readStream.	tc := self tableOfBundleContentsFrom: strm]		ensure: [strm close].	tc do: [:tci | self executeTableOfBundleContents: tci]</body><body package="PackageCategories">executeTableOfContents: aTC	aTC keysAndValuesDo: 		[ :pkgName :tags | 	| pkg |		pkg := self packageNamedOrCreate: pkgName.		tags do: [ :tag | tag moveToPackage: pkg ifNotLoaded: [ ] ]		]</body><body package="PackageCategories">executeTableOfContentsFromFile: aString 	"Registry executeTableOfContentsFromFile: 'TOC'"	| strm tc |		[strm := aString asFilename readStream.	tc := self tableOfContentsFrom: strm]		ensure: [strm close].	self executeTableOfContents: tc</body><body package="PackageCategories">tableOfBundleContents	"Registry tableOfBundleContents"	| strm |	strm := WriteStream on: (String new: 400000).	self tableOfBundleContentsOn: strm.	^strm contents</body><body package="PackageCategories">tableOfBundleContentsFrom: aStream 	^self tobcComponentsFrom: aStream</body><body package="PackageCategories">tableOfBundleContentsOn: aStream 	self bundlesDo: [:bun | bun tableOfBundleContentsOn: aStream]</body><body package="PackageCategories">tableOfBundleContentsOnFile: aString	"Registry tableOfBundleContentsOnFile: 'TOBC'"	| strm |	strm := aString asFilename writeStream.	self tableOfBundleContentsOn: strm.	strm close.</body><body package="PackageCategories">tableOfContents	"Registry tableOfContents"	| strm |	strm := WriteStream on: (String new: 400000).	self tableOfContentsOn: strm.	^strm contents</body><body package="PackageCategories">tableOfContentsBundleContentsFrom: aStream 	| itemNames |	itemNames := OrderedCollection new.		[| kind desc |	aStream skipSeparators.	kind := aStream next.	desc := kind = $"				ifTrue: [PackageDescription new]				ifFalse: [kind = $@						ifTrue: [BundleDescription new]						ifFalse: [kind = $;								ifTrue: [^itemNames]								ifFalse: [self error: (#ExpectedQuoteForPackageName &lt;&lt; #packages &gt;&gt; 'Malformed quote for package name expected')]]].	desc componentName: (aStream upTo: $").	itemNames add: desc] repeat</body><body package="PackageCategories">tableOfContentsFrom: aStream 	| dict |	dict := Dictionary new.		[aStream skipSeparators.	aStream atEnd]		whileFalse: 			[| pkgTags pkgName |			aStream next = $" ifFalse: [self error: (#ExpectedQuoteForPackageName &lt;&lt; #packages &gt;&gt; 'Malformed quote for package name expected')].			pkgName := aStream upTo: $".			pkgTags := self tableOfContentsTagsFrom: aStream.			dict at: pkgName put: pkgTags].	^dict</body><body package="PackageCategories">tableOfContentsOn: aStream 	self packagesDo: [:pkg | pkg tableOfContentsOn: aStream]</body><body package="PackageCategories">tableOfContentsOnFile: aString	"Registry tableOfContentsOnFile: 'TOC'"	| strm |	strm := aString asFilename writeStream.	self tableOfContentsOn: strm.	strm close.</body><body package="PackageCategories">tobcBundleFrom: aStream 	| desc comps |	aStream next = $@ ifFalse: [self error: (#ExpectedAtSign &lt;&lt; #packages &gt;&gt; 'Expected at-sign to begin bundle name')].	desc := BundleDescription new.	desc componentName: (aStream upTo: $").	comps := self tobcComponentsFrom: aStream.	aStream next = $; ifFalse: [self error: (#ExpectedSemicolon &lt;&lt; #packages &gt;&gt; 'Expected semi-colon to end bundle description')].	^Array with: desc with: comps</body><body package="PackageCategories">tobcComponentFrom: aStream 	aStream peek = $" ifTrue: [^self tobcPackageFrom: aStream].	aStream peek = $@ ifTrue: [^self tobcBundleFrom: aStream].	self error: (#ExpectedAtSignOrQuote &lt;&lt; #packages &gt;&gt; 'Expected at-sign or quote to begin component')</body><body package="PackageCategories">tobcComponentsFrom: aStream 	| comps |	comps := OrderedCollection new.		[aStream skipSeparators.	(aStream atEnd or: [aStream peek = $;]) ifTrue: [^comps].	comps add: (self tobcComponentFrom: aStream)] repeat</body><body package="PackageCategories">tobcPackageFrom: aStream 	| desc |	aStream next = $" ifFalse: [self error: (#ExpectedQuoteBeforePackageName &lt;&lt; #packages &gt;&gt; 'Expected quote to begin package name')].	desc := PackageDescription new.	desc componentName: (aStream upTo: $").	^desc</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>definition lookup</category><body package="PackageCategories">allContainingPackagesForClassOrNameSpace: aClassOrNameSpace 	"Answer all the packges that contain the definition for a class or namespace, including overriden."	"Returns an Array, since a class can have its methods in several packages,	or even its definition in several packages via overrides."	| coll pkg overs |	(pkg := self containingPackageForSymbol: aClassOrNameSpace absoluteSymbol) 		== nil ifTrue: [^#()].	(overs := Override overridesForClassOrNameSpace: aClassOrNameSpace) == nil 		ifTrue: [^Array with: pkg].	coll := OrderedCollection with: pkg.	overs do: [:over | (pkg := over package) == nil ifFalse: [coll add: pkg]].	^coll</body><body package="PackageCategories">allContainingPackagesForDataKey: key owner: aClassOrNamespace 	"Answer all the packges that contain the definition for aClassOrNamespace.key, including overriden."	"Returns an Array, since a class can have its methods in several packages,	or even its definition in several packages via overrides."	| coll pkg overs |	(pkg := self containingPackageForDataKey: key				symbol: aClassOrNamespace absoluteSymbol) == nil 		ifTrue: [^#()].	(overs := Override overridesForDataKey: key in: aClassOrNamespace) == nil 		ifTrue: [^Array with: pkg].	coll := OrderedCollection with: pkg.	overs do: [:over | (pkg := over package) == nil ifFalse: [coll add: pkg]].	^coll</body><body package="PackageCategories">allContainingPackagesForSelector: selector class: aClass 	"Answer all the packges that contain the definition for aClass&gt;&gt;selector, including overriden."	"Returns an Array, since a class can have its methods in several packages,	or even its definition in several packages via overrides."	| containingPackages currentPackageDefinition overriddenMethods |	(currentPackageDefinition := self containingPackageForSelector: selector class: aClass) 		ifNil: [^#()].	(overriddenMethods := Override overridesForSelector: selector class: aClass)		ifNil: [^Array with: currentPackageDefinition].	containingPackages := OrderedCollection with: currentPackageDefinition.	overriddenMethods do: 		[:each | 		(currentPackageDefinition := each package) ifNotNil: [containingPackages add: currentPackageDefinition]].	^containingPackages</body><body package="PackageCategories">containingPackageForClass: aClass 	^self containingPackageForClassSymbol: aClass instanceBehavior absoluteSymbol</body><body package="PackageCategories">containingPackageForClassName: aClassName 	^self containingPackageForClassSymbol: aClassName asClassNameOnly asSymbol</body><body package="PackageCategories">containingPackageForClassNamed: aClassName 	^self containingPackageForClassSymbol: aClassName asClassNameOnly asSymbol</body><body package="PackageCategories">containingPackageForClassSymbol: aClassSymbol 	| cm |	cm := self defClassModelForClassSymbol: aClassSymbol.	^cm isNil		ifTrue: [nil]		ifFalse: [cm package]</body><body package="PackageCategories">containingPackageForDataKey: dataKey class: aClass	^self containingPackageForDataKey: dataKey 			symbol: aClass absoluteSymbol</body><body package="PackageCategories">containingPackageForDataKey: dataKey nameSpace: aNameSpace	^self containingPackageForDataKey: dataKey 			symbol: aNameSpace absoluteSymbol</body><body package="PackageCategories">containingPackageForDataKey: dataKey symbol: aSymbol	| models |	models := self modelsForSymbol: aSymbol.	models reverse do:		[:each |		(each includesDataKey: dataKey) ifTrue: [^each package]].	^nil</body><body package="PackageCategories">containingPackageForNameSpaceSymbol: aNameSpaceSymbol 	| model |	model := self defNameSpaceModelForNameSpaceSymbol: aNameSpaceSymbol.	^model isNil		ifTrue: [nil]		ifFalse: [model package]</body><body package="PackageCategories">containingPackageForSelector: aSelector class: aClass 	"Answer the current package for aClass&gt;&gt;aSelector, nil if none."	"HACK- check for proxy class....."	| symbol |	symbol := aClass isBehavior		ifTrue: [ 	aClass instanceBehavior absoluteSymbol ]		ifFalse: [ aClass absoluteName asSymbol ].	^self containingPackageForSelector: aSelector classSymbol: symbol meta: aClass isMeta</body><body package="PackageCategories">containingPackageForSelector: aSelector className: aClassName meta: isMeta 	^self		containingPackageForSelector: aSelector		classSymbol: aClassName asClassNameOnly asSymbol		meta: isMeta</body><body package="PackageCategories">containingPackageForSelector: aSelector classSymbol: aClassSymbol meta: isMeta	"Check to see if it is in an extension, otherwise check if it is really in the 	definition class model."	| classModel |	classModel := self quickContainingClassModelForSelector: aSelector classSymbol: aClassSymbol meta: isMeta.	^classModel isNil		ifTrue: [nil] 		ifFalse: [classModel package]</body><body package="PackageCategories">containingPackageForSymbol: aSymbol 	| model |	model := self defModelForSymbol: aSymbol.	^model isNil		ifTrue: [ nil ]		ifFalse: [ model package ]</body><body package="PackageCategories">packageForClass: class	"Return the package that this class is in (or should be	placed in).  Nil if none can be determined."	^self packageForClassSymbol: class absoluteSymbol.</body><body package="PackageCategories">packageForClassSymbol: classSymbol 		^Policies packagePolicy packageForClassSymbol: classSymbol</body><body package="PackageCategories">packageForDataKey: dataKey classSymbol: classSymbol 	^Policies packagePolicy 		packageForDataKey: dataKey classSymbol: classSymbol</body><body package="PackageCategories">packageForDataKey: dataKey nameSpaceSymbol: nameSpaceSymbol 		^Policies packagePolicy 		packageForDataKey: dataKey nameSpaceSymbol: nameSpaceSymbol</body><body package="PackageCategories">packageForDataKey: dataKey owner: aClassOrNameSpace		| symbol |	symbol := aClassOrNameSpace absoluteSymbol.	^aClassOrNameSpace isBehavior		ifTrue: [ self packageForDataKey: dataKey classSymbol: symbol ]		ifFalse: [  self packageForDataKey: dataKey nameSpaceSymbol: symbol ].</body><body package="PackageCategories">packageForNameSpace: namespace	"Return the package that this namespace is in (or should be	placed in).  Nil if none can be determined."	^self packageForNameSpaceSymbol: namespace absoluteSymbol.</body><body package="PackageCategories">packageForNameSpaceSymbol: nameSpaceSymbol 	^Policies isNil		ifTrue: [nil]		ifFalse: [Policies packagePolicy packageForNameSpaceSymbol: nameSpaceSymbol]</body><body package="PackageCategories">packageForNewDataKey: dataKey classSymbol: classSymbol 	^Policies packagePolicy 		packageForNewDataKey: dataKey classSymbol: classSymbol</body><body package="PackageCategories">packageForNewDataKey: dataKey nameSpaceSymbol: nameSpaceSymbol 		^Policies packagePolicy 		packageForNewDataKey: dataKey 		nameSpaceSymbol: nameSpaceSymbol</body><body package="PackageCategories">packageForNewSelector: selector classSymbol: classSymbol meta: isMeta 	^Policies packagePolicy		packageForNewSelector: selector		classSymbol: classSymbol		meta: isMeta</body><body package="PackageCategories">packageForSelector: selector classSymbol: classSymbol meta: isMeta 	^Policies packagePolicy		packageForSelector: selector		classSymbol: classSymbol		meta: isMeta</body><body package="PackageCategories">quickContainingPackageForDataKey: dataKey symbol: aSymbol	"If there are extensions check them for the selector.  Otherwise use the class' package 	Do not ask the class' package if it includes the datakey or there will be infinite recursion."	"This will be wrong if a dataKey is not loaded."	| cm |	cm := self quickContainingModelForDataKey: dataKey symbol: aSymbol.			^cm == nil		ifTrue: [ Registry nullPackage ]		ifFalse: [ cm package ]</body><body package="PackageCategories">quickContainingPackageForSelector: aSelector class: aClass 	^self		quickContainingPackageForSelector: aSelector		classSymbol: (aClass isMeta				ifTrue: [aClass soleInstance]				ifFalse: [aClass]) absoluteSymbol		meta: aClass isMeta</body><body package="PackageCategories">quickContainingPackageForSelector: aSelector classSymbol: aClassSymbol meta: isMeta 	"If there are extensions check them for the selector.  Otherwise use the class' package do not ask the	class' package if it includes the selector or there will be infinite recursion."	"This will be wrong if 'aSelector' is not loaded."	| cm |	cm := self		quickContainingClassModelForSelector: aSelector		classSymbol: aClassSymbol		meta: isMeta.	^cm == nil		ifTrue: [ Registry nullPackage ]		ifFalse: [ cm package ]</body><body package="PackageCategories">trueContainingPackageForSelector: aSelector class: aClass	"Answer the current package for aClass&gt;&gt;aSelector, nil if none."	| symbol |	symbol := aClass isBehavior		ifTrue: [aClass instanceBehavior absoluteSymbol]		ifFalse: [aClass absoluteName asSymbol].	^self		trueContainingPackageForSelector: aSelector		classSymbol: symbol		meta: aClass isMeta</body><body package="PackageCategories">trueContainingPackageForSelector: aSelector classSymbol: aClassSymbol meta: isMeta	"Check to see if it is in an extension, otherwise check if it is really in the 	definition class model."	| classModel |	classModel := self quickContainingClassModelForSelector: aSelector classSymbol: aClassSymbol meta: isMeta.	^classModel isNil 		ifTrue: [nil] 		ifFalse: [(classModel includesSelector: aSelector meta: isMeta) ifTrue: [classModel package]]</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>updating</category><body package="PackageCategories">blessingChangedForPundle: aPundle 	self changed: #pundleBlessing with: aPundle</body><body package="PackageCategories">changedBundleStructure: aBundle	containedItemsCache := nil.	self changed: #changedBundleStructure with: aBundle.	ChangeSet bundleStructure: aBundle.	SourceFileManager default bundleStructure: aBundle.</body><body package="PackageCategories">modificationChangedForPundle: aPundle 	self changed: #pundleModificationStatus with: aPundle.	(self allEnclosingBundlesFor: aPundle)		do: [:p | self changed: #pundleModificationStatus with: p]</body><body package="PackageCategories">traceChangedForComponent: aCodeComponent 	self changed: #pundleTrace with: aCodeComponent</body><body package="PackageCategories">updateUndeclaredInNullPackage	"Undeclareds are put in the nullPackage during loading.  Some of these will be transient;  later parts of the load will resolve them.  This cleans up these transients during end-load's general purge of Undeclared."		| undeclaredChanges undeclaredKeys |	undeclaredKeys := Undeclared keys.	undeclaredKeys isEmpty ifTrue: [self nullPackage models removeKey: #'Root.Smalltalk.Kernel.Undeclared' ifAbsent: [nil]].	undeclaredChanges := self nullPackage changeSet at: #'Root.Smalltalk.Kernel.Undeclared' ifAbsent: [^nil].	(undeclaredChanges getDataChangesIfNone: [Dictionary new]) keys do: 		[:each | (undeclaredKeys includes: each) ifFalse: [undeclaredChanges forgetDataChange: each]].	self nullPackage changeSet removeIfEmptySymbol: #'Root.Smalltalk.Kernel.Undeclared'</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>parcel support</category><body package="PackageCategories">checkPrerequisite: aPundle requiredVersion: reqVersion codeReader: codeReader	"Validate the existense of a pundle as a prerequisite. 	Answer true if acceptable version is already loaded"	^aPundle == nil		ifTrue: [ false ]		ifFalse: 			[ codeReader 				checkPrerequisiteNamed: aPundle name 				withVersion: aPundle traceVersion 				requiredVersion: reqVersion			].</body><body package="PackageCategories">checkPrerequisiteNamed: reqName requiredVersion: reqVersion codeReader: codeReader	"Validate the existense of a pundle as a prerequisite. 	Answer true if acceptable version is already loaded"	| pundle |	pundle := self bundleNamed: reqName.	pundle == nil		ifTrue: [ pundle := self packageNamed: reqName ].	^pundle == nil		ifTrue: [ false ]		ifFalse: 			[ codeReader 				checkPrerequisiteNamed: reqName 				withVersion: pundle traceVersion 				requiredVersion: reqVersion			].</body><body package="PackageCategories">parcel: aParcel added: aThing to: aPackage	"aThing has been changed - reflect the update in aPackage."	aThing isNameSpace		ifTrue: [ ^XChangeSet current moveWholeNameSpace: aThing toPackage: aPackage ].	aThing isBehavior		ifTrue: [ ^XChangeSet current moveWholeClass: aThing toPackage: aPackage ].	aThing isVariableBinding		ifTrue: 			[ aParcel definedBindings keysAndValuesDo:				[ :env :keySet |				( ( keySet includes: aThing key ) and:						[ ( env asNameSpace bindingFor: aThing key ) = aThing ] )					ifTrue: [ ^XChangeSet current addBinding: aThing in: env  ].				]			].	aThing class == MethodInstallationRecord		ifTrue: [ ^XChangeSet current 					addSelector: aThing selector					class: aThing implementingClass					toPackage: aPackage				].	Dialog warn: ( (#UnknownParcelChange &lt;&lt; #packages &gt;&gt; 'Unknown parcel change (&lt;1s&gt;)&lt;n&gt; in &lt;2s&gt;')					expandMacrosWith: aThing printString 					with: aPackage name ).</body><body package="PackageCategories">parcel: aParcel change: aThing to: aPackage	"aThing has been changed - reflect the update in aPackage."	aThing isNameSpace		ifTrue: [ ^XChangeSet current changeNameSpace: aThing toPackage: aPackage ].	aThing isBehavior		ifTrue: [ ^XChangeSet current changeClass: aThing toPackage: aPackage ].	aThing isVariableBinding		ifTrue: 			[ ^aParcel definedBindings keysAndValuesDo:				[ :env :keySet |				( keySet includes: aThing key )					ifTrue: [ XChangeSet current changeBinding: ( env asNameSpace bindingFor: aThing key ) in: env  ].				]			].	aThing class == MethodInstallationRecord		ifTrue: [ ^XChangeSet current 					changeSelector: aThing selector					class: aThing implementingClass					toPackage: aPackage				].	Dialog warn: ( (#UnknownParcelChange &lt;&lt; #packages &gt;&gt; 'Unknown parcel change (&lt;1s&gt;)&lt;n&gt; in &lt;2s&gt;')					expandMacrosWith: aThing printString 					with: aPackage name ).</body><body package="PackageCategories">parcel: aParcel toPackageNamed: aString 	"A parcel has been loaded, now create a matching package for that parcel.	The name of this package &lt;aString&gt; will either be the name of the parcel or if the 	#packageName property is set in the parcel that name will be used.  That decision	has already been made by the time this method is called.  	One of the subtle side-effects of this method is that the new package has its 	#packageName property set right away to prevent future confusion in case this	package is published to a database and then again as a parcel.	If the parcel contains any database links, those will be restored.	We restoreLinksFrom the parcel's properties into the package for the stored db links."	| package |	package := Registry packageNamedOrCreate: aString.	package startLoad.	[self registerParcel: aParcel to: package.	aParcel propertyAt: #packageName put: aString.	package propertyAt: #packageName put: aString.	package propertyAt: #parcelName put: aParcel name.	package resetUninstalledStateFrom: aParcel.	package removeTransientProperties.	package markNotModified] 			ensure: [package endLoad].	Override equateComponent: aParcel with: package</body><body package="PackageCategories">parcel: aParcel updates: updates to: aPackage	"aParcel has been updated - reflect updates in its related package.  	 Be careful to maintain the same installation order as the CodeReader.	 Note that the overrides have already been handled"	| changedThings addedThings |	addedThings := ( updates at: #added ).	changedThings := ( updates at: #changed ).	( addedThings select: [ :thing | thing isNameSpace ] ) do:		[ :aNameSpace | self parcel: aParcel change: aNameSpace to: aPackage ].	( addedThings select: [ :thing | thing isBehavior ] ) do:		[ :aClass | self parcel: aParcel change: aClass to: aPackage ].	( addedThings select: [ :thing | thing isVariableBinding ] ) do:		[ :aBinding | self parcel: aParcel change: aBinding to: aPackage ].	( changedThings select: [ :thing | thing isNameSpace ] ) do:		[ :aNameSpace | self parcel: aParcel change: aNameSpace to: aPackage ].	( changedThings select: [ :thing | thing isBehavior ] ) do:		[ :aClass | self parcel: aParcel change: aClass to: aPackage ].	( changedThings select: [ :thing | thing isVariableBinding ] ) do:		[ :aBinding | self parcel: aParcel change: aBinding to: aPackage ].	( addedThings select: [ :ea | ea class == MethodInstallationRecord ] ) do:		[ :thing | self parcel: aParcel added: thing to: aPackage ].	( changedThings select: [ :ea | ea class == MethodInstallationRecord ] ) do:		[ :thing | self parcel: aParcel change: thing to: aPackage ].	"Takes care of removals - which can't be found to remove anyway."	aPackage cleanse: false.</body><body package="PackageCategories">parcelToBundle: aParcel	"Convert aParcel to a bundle - assumes was saved as a bundle and that prereqs reflect bundle contents."	"setup database links if they exist."	| bundle |	[ bundle := ( aParcel propertyAt: #bundleStructure ) convert ]		on: StoreWarning do: [ :ex | ex resume ].		"may be duplicate adds - okay"	aParcel propertyAt: #bundleStructure put: nil.	"Ensure that the sourceIndex gets copied over."	bundle propertyAt: #sourceIndex put: (aParcel propertyAt: #sourceIndex).	bundle allContainedItems do: [:each | each propertyAt: #sourceIndex put: (aParcel propertyAt: #sourceIndex)].	^bundle.</body><body package="PackageCategories">parcelToPundle: aParcel	"Convert aParcel to a pundle - setup database links if they exist. Handle updates if package exists."	| string |	( aParcel propertyAt: #bundleStructure ) == nil		ifFalse: [ ^self parcelToBundle: aParcel ].	(  string := aParcel propertyAt: #packageName ) == nil		ifFalse: [ ^self parcel: aParcel toPackageNamed: string ].	^self parcel: aParcel toPackageNamed: aParcel name.</body><body package="PackageCategories">parcelUpdated: aParcel updates: updates	"A parcel has been updated. Update the related package(s)"	( aParcel propertyAt: #bundleStructure ) == nil		ifTrue: [ self updatePackageFromParcel: aParcel updates: updates ]		ifFalse: [ self updateBundleFromParcel: aParcel updates: updates ].</body><body package="PackageCategories">registerParcel: aParcel to: aPackage	"Generate update events for the contents of a parcel - put everything in aPackage.	special case for overridden class defs - its selectors have been stolen by the original class"		| currentChangeSet |	currentChangeSet := XChangeSet current.	aParcel definedNameSpaces do: 		[:each | currentChangeSet addNameSpaceDefinition: each toPackage: aPackage].	aParcel definedClasses do: 		[:each | currentChangeSet addClassDefinition: each toPackage: aPackage].	aParcel classesAndSelectorsDo:		[:eachClass :eachSelectorsForClass | 		| hasClass |		hasClass := aPackage includesClass: eachClass instanceBehavior.		eachSelectorsForClass do:			[:eachSelector |			(Override overridesForSelector: eachSelector class: eachClass)				ifNil: [hasClass					ifTrue: [currentChangeSet correctSelector: eachSelector class: eachClass toPackage: aPackage]					ifFalse: [currentChangeSet addSelector: eachSelector class: eachClass toPackage: aPackage]]				ifNotNil: 					[:overrides |					"in case of an installed override, the previous owner has already given up ownership;					add to new package and remove override change effects in the previous owner;					in case of multiple overrides, handle the last/new one only; 					handling older overrides would make their package dirty"					currentChangeSet changeSelector: eachSelector class: eachClass fromPackage: overrides last package toPackage: aPackage]]].	aParcel definedBindingsDo:		[:eachBinding :eachEnvironment | 		(Override isOverriddenStatic: eachBinding key in: eachEnvironment)			ifTrue:				[eachEnvironment isBehavior					ifTrue: [currentChangeSet changeDataKey: eachBinding key class: eachEnvironment package: aPackage]					ifFalse: [currentChangeSet changeDataKey: eachBinding key nameSpace: eachEnvironment package: aPackage]]			ifFalse:				[eachEnvironment isBehavior					ifTrue: [currentChangeSet addDataKey: eachBinding key class: eachEnvironment package: aPackage]					ifFalse: [currentChangeSet addDataKey: eachBinding key nameSpace: eachEnvironment package: aPackage]]].	aPackage copyPropertiesFrom: aParcel properties</body><body package="PackageCategories">update: anAspect with: anArgument	"Handle parcel update"	anAspect == #parcelLoaded 		ifTrue: [ ^self parcelToPundle: anArgument ].	anAspect == #parcelUpdated		ifTrue: [ ^self parcelUpdated: anArgument first updates: anArgument last ].	( #( #parcelInstalledClasses #parcelInstalledNameSpaces #parcelInstalledMethods #installedOverrideMethods )			includes: anAspect )		ifTrue: 			[ | parcel pkg cset |			parcel := anArgument first.			( pkg := parcel relatedPackage ) == nil				ifTrue: [ ^self ].			cset := XChangeSet current.			anAspect == #parcelInstalledClasses				ifTrue: [ cset installedClasses: anArgument last toPackage: pkg ].			anAspect == #parcelInstalledNameSpaces				ifTrue: [ cset installedNameSpaces: anArgument last toPackage: pkg ].			anAspect == #parcelInstalledMethods				ifTrue: [ cset installedMethods: anArgument last toPackage: pkg ].			anAspect == #installedOverrideMethods				ifTrue: [ cset installedOverrideMethods: anArgument last toPackage: pkg ].			pkg resetUninstalledStateFrom: parcel.			^self			].	containedItemsCache := nil.	super update: anAspect with: anArgument.</body><body package="PackageCategories">updateBundleFromParcel: aParcel updates: updates	"Update a bundle from aParcel's updates."	| bundle |	[ bundle := ( aParcel propertyAt: #bundleStructure ) 					updates: updates fromParcel: aParcel	] on: StoreWarning do: [ :ex | ex resume ].		"may be duplicate adds - okay"		^bundle.</body><body package="PackageCategories">updatePackageFromParcel: aParcel updates: aChangeSet	"aParcel has been updated - reflect updates in it's related package."		| packageModel |	(packageModel := aParcel relatedPackage) ifNil: [^self].	self parcel: aParcel updates: aChangeSet to: packageModel.	packageModel updatePropertiesForSaveFromParcel: aParcel</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>overrides</category><body package="PackageCategories">componentDefiningClass: aClass	^( self containingPackageForClass: aClass ) "asDescription"</body><body package="PackageCategories">componentDefiningNameSpace: aNameSpace	^( self containingPackageForNameSpace: aNameSpace ) "asDescription"</body><body package="PackageCategories">componentDefiningSelector: selector class: aClass	^( self containingPackageForSelector: selector class: aClass ) "asDescription"</body><body package="PackageCategories">componentDefiningStatic: aStaticBinding in: aNameSpace	^( self 		containingPackageForDataKey: aStaticBinding key 		symbol: aNameSpace absoluteSymbol 	  ) "asDescription"</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>fileout</category><body package="PackageCategories">installCallBacksForFileout	"Add the package property to all fileouts.	Store.Registry  installCallBacksForFileout 	HACK- for handling class proxies"		SourceFileFormat		attributeFor: #package		compute:			[:object | 			| packageModel |			packageModel := object isBindingReference				ifTrue:					[(object isKindOf: Kernel.ChangeSupportClassProxy)						ifTrue: [self containingPackageForSymbol: object absoluteSymbol]						ifFalse: [self containingPackageForDataKey: object simpleName symbol: object environment absoluteSymbol]]				ifFalse: 					[object isOverride						ifTrue: 							[object sources								ifNil: [nil]								ifNotNil: [:collection | collection isEmpty									ifTrue: [nil]									ifFalse: [collection any]]]						ifFalse: [self containingPackageForSymbol: object absoluteSymbol]].			packageModel ifNotNil: [packageModel name]].	SourceFileFormat		attributeForMethods: #package		compute:			[:cls :selector | 			| pkg |			(pkg := self containingPackageForSelector: selector class: cls) == nil ifTrue: [nil] ifFalse: [pkg name]]</body><body package="PackageCategories">removeCallBacksForFileout	"Add the package property to all fileouts." 	SourceFileFormat removeAttributeFor: #package.</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>accessing-package</category><body package="PackageCategories">allPackages	"Answer a collection of all the loaded packages."	^packages values</body><body package="PackageCategories">allPackagesWithNull	| pkgs |	pkgs := OrderedCollection new: packages size + 1.	packages do: [:pkg | pkgs addLast: pkg].	( pkgs includes: self nullPackage )		ifFalse: [ pkgs addFirst: self nullPackage ].	^pkgs</body><body package="PackageCategories">isPackageLoaded: aName	^packages includesKey: aName asString</body><body package="PackageCategories">packageNamed: aName 	"Answer a PackageModel for the named package, or nil if it doesn't exist."	aName == nil ifTrue: [^nil].	^packages at: aName asString		ifAbsent: 			[aName = self nullPackageName ifTrue: [self nullPackage] ifFalse: [nil]]</body><body package="PackageCategories">packageNamedOrCreate: aName	^packages at: aName asString ifAbsent: 		[ aName = self nullPackageName			ifTrue: [ self nullPackage ]			ifFalse: [ PackageModel named: aName ]		]</body><body package="PackageCategories">packagesDo: aBlock	"Execute 'aBlock' for each package loaded.	Access this way to keep 'packages' private."	packages do: aBlock</body><body package="PackageCategories">removePackage: aPackage 	"Unload aPackage and remove it from the 	package list. Answer true if operation succeeds."	aPackage isNil		ifFalse: 			[ self currentPackage = aPackage ifTrue: [self currentPackage: self nullPackage].			packages removeKey: aPackage name ifAbsent: [^false].			self changed: #removedPundle with: aPackage.			( self enclosingComponentsFor: aPackage ) do:				[ :comp | comp removeComponent: aPackage asDescription ].			^true			].	^false</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>accessing-bundle</category><body package="PackageCategories">allBundles	"Answer a collection of all the loaded bundles."	^bundles values</body><body package="PackageCategories">allEnclosingBundlesFor: aComponent 	"Answer a collection of bundles that contain aComponent, all bundles that contain those bundles, etc."	| findAncestors hasBeenDone |	"deal with potential circular containment structure"	hasBeenDone := Set new.	findAncestors := [:aPundle | 		(hasBeenDone includes: aPundle) ifTrue: [#()]			ifFalse: [ | collectedAncestors parents|				hasBeenDone add: aPundle.				parents := self enclosingComponentsFor: aPundle.				collectedAncestors := Set new addAll: parents; yourself.				parents do: [:aParent | collectedAncestors addAll: (findAncestors value: aParent)].				collectedAncestors]].	^findAncestors value: aComponent.</body><body package="PackageCategories">anyContainedItems	"Answer a collection of components."	^self containedItems</body><body package="PackageCategories">bundleNamed: aName	"Answer a BundleModel for the named bundle, or nil if it doesn't exist."	^bundles at: aName asString ifAbsent: [nil]</body><body package="PackageCategories">bundleNamedOrCreate: aName	^bundles at: aName asString ifAbsent: 		[ BundleModel named: aName ]</body><body package="PackageCategories">bundlesDo: aBlock	"Execute 'aBlock' for each bundle loaded.	Access this way to keep 'bundles' private."	bundles do: aBlock</body><body package="PackageCategories">containedItems	"Answer a collection of top level components."	^containedItemsCache isNil 		ifTrue: 			[ | blist plist enclosedItems |			enclosedItems := IdentitySet new.			self allBundles do: [ :bundle | enclosedItems addAll: bundle allContainedItems ].			blist := ( self allBundles reject: [ :pkg | enclosedItems includes: pkg ] ) asSortedCollection: [ :a :b | a name &lt; b name ].			plist := ( self allPackages reject: [ :pkg | enclosedItems includes: pkg  ] ) asSortedCollection: [ :a :b | a name &lt; b name ].			containedItemsCache := blist asOrderedCollection, plist.			]		ifFalse: [ containedItemsCache ]</body><body package="PackageCategories">enclosingComponentsFor: aComponent 	"Answer a collection of bundles that contian aComponent."	| answer |	answer := OrderedCollection new.	bundles do: 		[ :aBundle | 		( aBundle containsItem: aComponent )			ifTrue: [ answer add: aBundle ]		].	^answer</body><body package="PackageCategories">isBundleLoaded: aName	^bundles includesKey: aName asString</body><body package="PackageCategories">isLeaf	^false</body><body package="PackageCategories">pundleNamed: aName	"Answer a bundle or a package named aName"	| pundle |	( pundle := self bundleNamed: aName ) == nil		ifTrue: [  pundle := self packageNamed: aName ].	^pundle.</body><body package="PackageCategories">removeBundle: aBundle 	"Unload aBundle and remove it from the 	bundle list. Answer true if operation succeeds."	aBundle == nil		ifTrue: [ ^false ].	bundles removeKey: aBundle name ifAbsent: [ ^false ].	self changed: #removedPundle with: aBundle.	( self enclosingComponentsFor: aBundle ) do:		[ :comp | comp removeComponent: aBundle asDescription ].	^true.</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>accessing-current/null package</category><body package="PackageCategories">currentPackage	^currentPackage</body><body package="PackageCategories">currentPackage: aPkg 	"Set the current default package"	| newCurrentPackage |	newCurrentPackage := aPkg isNil				ifTrue: [self nullPackage]				ifFalse: [aPkg].	currentPackage == newCurrentPackage		ifFalse: 			[currentPackage := newCurrentPackage.			self changed: #currentPackage with: currentPackage]</body><body package="PackageCategories">isCurrentNull	currentPackage isNil ifTrue: [^true].	^currentPackage name = self nullPackageName</body><body package="PackageCategories">nullPackage		"TT_Registry nullPackage"	^nullPackage</body><body package="PackageCategories">nullPackageName	^'(none)'</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>accessing-pundle</category><body package="PackageCategories">allBundlesSorted	^bundles values sort: [:x :y | x name &lt; y name].</body><body package="PackageCategories">allPackagesSorted	^packages values sort: [:x :y | x name &lt; y name].</body><body package="PackageCategories">allPundles	"Answer a collection of all the loaded packages and bundles."	| all |	all := OrderedCollection new: self size.	packages do: [:value | all add: value].	bundles do: [:value | all add: value].	^all</body><body package="PackageCategories">allPundlesSorted	"Answer a collection of all the loaded packages and bundles. 	Bundles go first in alphabetical order followed by packages."	| all |	all := OrderedCollection new: bundles size + packages size.	all addAll: self allBundlesSorted.	all addAll: self allPackagesSorted.	^all</body><body package="PackageCategories">renamePundle: aPundle to: aString	"Renames a pundle - assumes user already knows this will lose pundle history."	| dict |	aPundle name = self nullPackageName		ifTrue: 			[^Dialog warn: #CannotRenameNullPackage &lt;&lt; #packages						&gt;&gt; 'Cannot rename the null package.'].	aPundle enclosingComponents		do: [:bundle | bundle component: aPundle beingRenamedTo: aString].	self allPundles		do: [:each | each changePrerequisite: aPundle nameTo: aString].	(dict := aPundle isBundle ifTrue: [bundles] ifFalse: [packages])		removeKey: aPundle name.	aPundle name: aString.	dict at: aString put: aPundle.	aPundle propertyAt: #packageName put: aString.	aPundle relatedParcel ifNotNil: [:value | value packageName: aString].	self changed: #renamedPundle with: aPundle</body></methods><methods><class-id>Store.PundleAccess</class-id> <category>deprecated</category><body package="PackageCategories">allContainingPackagesForClass: aClass 	^self allContainingPackagesForClassOrNameSpace: aClass</body></methods><methods><class-id>Store.PundleAccess class</class-id> <category>instance creation</category><body package="PackageCategories">new	^super new initialize</body></methods><methods><class-id>Store.PundleAccess class</class-id> <category>package partitioning</category><body package="PackageCategories">createBaseBundle	"Creates the system bundle from the tobc file created with:		( Store.Registry bundleNamed: 'Base VisualWorks' ) 				tableOfBundleContentsOnFile: 'Base VisualWorks.tobc'  "	| filename |	filename := ( Filename fromComponents:			( Array with: '$(VISUALWORKS)' with: 'tocs' with: 'Base VisualWorks.tobc' ) ) asResolvedString.	filename asFilename exists		ifTrue: [ 	Registry executeTableOfBundleContentsFromFile: filename ].</body><body package="PackageCategories">createStoreBundle: storeParcel	"Creates the system bundle from the tobc file created with:		( Store.Registry bundleNamed: 'StoreBase' ) 			completeTableOfContentsNamed: 'Store'  "</body><body package="PackageCategories">moveUnpackagedToNullPackage	"Move any unpackaged anything into the NullPackage."		"self moveUnpackagedToNullPackage"	| pkg |	pkg := Registry nullPackage.	Root withAllNameSpacesDo: 		[ :ns  | 		( Registry defNameSpaceModelForNameSpaceSymbol: ns absoluteSymbol ) == nil			ifTrue: [  XChangeSet current moveUnpackagedInWholeNameSpace: ns toPackage: pkg ].		ns classes do:			[ :cls |  			( Registry defClassModelForClassSymbol: cls absoluteSymbol ) == nil				ifTrue: [ XChangeSet current moveUnpackagedInWholeClass: cls toPackage: pkg  ]			]		].</body><body package="PackageCategories">unloadEmptyPackages	"DANGER unprotected unloads"	"self unloadEmptyPackages"  	Registry allPackages copy do: 		[:pkg | pkg isCompletelyEmpty  ifTrue: [pkg doUnloadFromImage]].	Registry allBundles copy do: 		[ :bundle | 		bundle removeNonexistentComponents.		bundle isCompletelyEmpty   ifTrue: [ bundle doUnloadFromImage ]		]</body></methods><methods><class-id>Store.PundleAccess class</class-id> <category>parcel load/unload/save</category><body package="PackageCategories">addImports	"Add specific imports to base NameSpaces."	self storeImports do:		[ :import |		UI addImport: import.  		Tools addImport: import.		].</body><body package="PackageCategories">packageOverridden	"Assigns overridden code to the base packages. This uses the cateogory names from the overridden	definition as the package name. Known limitation: code already overriden by user parcels before	Store was installed."		Override overridesDo:	[ :over | | pkg |	pkg := Registry packageNamed: over packageFromCategoryName.	( over sources includes: pkg )		ifFalse:			[ over sources add: 				( Registry packageNamed: over packageFromCategoryName )			]	]</body><body package="PackageCategories">removeImports	"Remove imports added to base NameSpaces during parcel load."	self storeImports do:		[ :import |		UI removeImport: import.  		Tools removeImport: import 		].</body><body package="PackageCategories">storeImports	"Answer an array of specific imports to base NameSpaces."	"self storeImports"	^#( #Policies #Registry #DbRegistry #PackageChooser ) collect:		[ :symbol | | import |		import :=  SpecificNameSpaceImport path: ( Array with: #Store with: symbol ).		import private: true.		import.		].</body></methods><methods><class-id>Store.PundleAccess class</class-id> <category>class initialization</category><body package="PackageCategories">initialize	"Need only be executed on first installation or on change in definition."	"Retrieve old pundle information from old version of PundleAccess if available."	"PundleAccess initialize"	| old |	old := Registry.	Registry :=  self new.	old == nil		ifFalse: 			[ [ Registry cloneFrom: old.			   ( Parcel dependents includes: old )				ifTrue: [ Parcel removeDependent: old ].			  Override unregisterSourceManager: old.			   old removeCallBacksForFileout.			  Override registerSourceManager: Registry.			  ( Parcel dependents includes: Store.Registry )   				ifFalse: [ Parcel addDependent: Store.Registry ].			  Registry installCallBacksForFileout.			  ] on: Error do:					[ :ex | 					Dialog warn: ((#ErrorReinitializingImageModel &lt;&lt; #packages &gt;&gt; 'Error %&lt;&lt;1s&gt;%&gt; reinitializing the image model.&lt;n&gt;See PundleAccess%&gt;initilialize')						expandMacrosWith: ex description).					Registry := old.					ex  return.					]				].</body></methods><methods><class-id>Store.PundleAccess class</class-id> <category>accessing</category><body package="PackageCategories">parcelDirectory	^ParcelDirectory</body><body package="PackageCategories">parcelDirectory: logicalFilename	 ParcelDirectory := logicalFilename</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>comparing</category><body package="PackageCategories">= anObject	self class == anObject class 		ifFalse: [ ^false ].	^self describesSameAs: anObject</body><body package="PackageCategories">hash	^self isPackage hash bitXor: self componentName hash</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>testing</category><body package="PackageCategories">describesBundleNamed: aString	"Answer true if the description refers to a bundle named aString."	^false</body><body package="PackageCategories">describesComponent: aPundle 	"Answer true if my description matches exactly aPundle"	"NOTE: assumes aPundle is the image version of the receiver."	| info |	aPundle == nil	ifTrue: [ ^false ].	id == nil			ifTrue: [ ^true ].	( info := aPundle databaseInformationFor: dbIdentifier ) == nil		ifTrue: [ ^false ].	^info dbTrace = id</body><body package="PackageCategories">describesPackageNamed: aString	"Answer true if the description refers to a package named aString."	^false</body><body package="PackageCategories">exactLoadedComponent	"Find if a bundle with my id is loaded into the image."	self subclassResponsibility</body><body package="PackageCategories">hasBeenModified	"Check if the underlying package has been modified and if it is the same 	as the one described.		All new components (without trace) are considered modified."	| comp |	comp := self component.	^comp notNil and: 		[ comp hasBeenModified or: 			[ ( comp dbTraceFor: dbIdentifier ) isNil or: 				[ ( self describesComponent: comp ) not ]			]		]</body><body package="PackageCategories">isBundle	^false</body><body package="PackageCategories">isPackage	^false</body><body package="PackageCategories">loadedComponent	"Find if a component fulfilling 	my description is loaded into the image.	My subclasses should answer this message"	self subclassResponsibility</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>printing</category><body package="PackageCategories">printOn: aStream 	aStream nextPutAll: self class name asString.	aStream nextPutAll: ' ('.	componentName == nil		ifFalse: [ aStream nextPutAll: componentName ].	aStream nextPut: $ .	id == nil		ifFalse: [ id printOn: aStream ].	dbIdentifier == nil		ifFalse: [ aStream nextPutAll: ':', dbIdentifier ].	aStream nextPut: $).</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>accessing</category><body package="PackageCategories">component	"Find a component named componentName and answer it."	^self subclassResponsibility</body><body package="PackageCategories">component: aLoadedComponent 	"Set the name of the component"		componentName := aLoadedComponent name.	dbIdentifier := aLoadedComponent dbIdentifier.	id := aLoadedComponent isLoaded		ifTrue: [ aLoadedComponent dbTrace ]		ifFalse: [ aLoadedComponent primaryKey ].</body><body package="PackageCategories">componentName	"Answer a component name"	componentName == nil		ifTrue: [ self setName ].	^componentName</body><body package="PackageCategories">componentName: aString	"Set a component name"	componentName := aString</body><body package="PackageCategories">dbComponent	"Find a component named componentName and answer it."	^self subclassResponsibility</body><body package="PackageCategories">dbIdentifier	^dbIdentifier</body><body package="PackageCategories">dbIdentifier: aSymbol 	"Set the database identifier."	dbIdentifier := aSymbol == nil		ifFalse: [ aSymbol asSymbol ]</body><body package="PackageCategories">hasSetVersion	"A description describes a particular version of a component 	if the id field is set."	^id notNil</body><body package="PackageCategories">id	^id</body><body package="PackageCategories">id: aValue	id := aValue</body><body package="PackageCategories">name	"Answer a component name"	^self componentName</body></methods><methods><class-id>Store.ComponentDescription</class-id> <category>private</category><body package="PackageCategories">setName	| comp |	comp := self loadedComponent.	comp notNil ifTrue: [self component: comp]</body></methods><methods><class-id>Store.BasicPackagePolicy</class-id> <category>private-method-package assignment</category><body package="PackageCategories">newMethodUseClass	newMethodUseClass isNil ifTrue: [newMethodUseClass := true].	^newMethodUseClass</body><body package="PackageCategories">newMethodUseClass: aBoolean	newMethodUseClass := aBoolean</body><body package="PackageCategories">newMethodUseClassIfCurrentSame	newMethodUseClassIfCurrentSame isNil ifTrue: [newMethodUseClassIfCurrentSame := false].	^newMethodUseClassIfCurrentSame</body><body package="PackageCategories">newMethodUseClassIfCurrentSame: aBoolean	newMethodUseClassIfCurrentSame := aBoolean</body><body package="PackageCategories">newMethodUseClassIfNoCurrent	newMethodUseClassIfNoCurrent isNil ifTrue: [newMethodUseClassIfNoCurrent := false].	^newMethodUseClassIfNoCurrent</body><body package="PackageCategories">newMethodUseClassIfNoCurrent: aBoolean	newMethodUseClassIfNoCurrent := aBoolean</body><body package="PackageCategories">newMethodUseCurrent	newMethodUseCurrent isNil ifTrue: [newMethodUseCurrent := true].	^newMethodUseCurrent</body><body package="PackageCategories">newMethodUseCurrent: aBoolean	newMethodUseCurrent := aBoolean</body></methods><methods><class-id>Store.BasicPackagePolicy</class-id> <category>private-class-package assignment</category><body package="PackageCategories">newClassUseCurrent	newClassUseCurrent isNil ifTrue: [newClassUseCurrent := true].	^newClassUseCurrent</body><body package="PackageCategories">newClassUseCurrent: aBoolean	newClassUseCurrent := aBoolean</body><body package="PackageCategories">newNameSpaceUseCurrent	newNameSpaceUseCurrent isNil ifTrue: [newNameSpaceUseCurrent := true].	^newNameSpaceUseCurrent</body><body package="PackageCategories">newNameSpaceUseCurrent: aBoolean	newNameSpaceUseCurrent := aBoolean</body></methods><methods><class-id>Store.BasicPackagePolicy</class-id> <category>private-datum-package assignment</category><body package="PackageCategories">newDatumUseClass	newDatumUseClass isNil ifTrue: [newDatumUseClass := true].	^newDatumUseClass</body><body package="PackageCategories">newDatumUseClass: aBoolean	newDatumUseClass := aBoolean</body><body package="PackageCategories">newDatumUseClassIfCurrentSame	newDatumUseClassIfCurrentSame isNil ifTrue: [newDatumUseClassIfCurrentSame := false].	^newDatumUseClassIfCurrentSame</body><body package="PackageCategories">newDatumUseClassIfCurrentSame: aBoolean	newDatumUseClassIfCurrentSame := aBoolean</body><body package="PackageCategories">newDatumUseClassIfNoCurrent	newDatumUseClassIfNoCurrent isNil ifTrue: [newDatumUseClassIfNoCurrent := false].	^newDatumUseClassIfNoCurrent</body><body package="PackageCategories">newDatumUseClassIfNoCurrent: aBoolean	newDatumUseClassIfNoCurrent := aBoolean</body><body package="PackageCategories">newDatumUseCurrent	newDatumUseCurrent isNil ifTrue: [newDatumUseCurrent := true].	^newDatumUseCurrent</body><body package="PackageCategories">newDatumUseCurrent: aBoolean	newDatumUseCurrent := aBoolean</body></methods><methods><class-id>Store.BasicPackagePolicy</class-id> <category>testing</category><body package="PackageCategories">checkForFirst	"Answer true if we need to ask if okay to modify the first time."		^self packageIsForced not and: [self warnOnFirstModification]</body><body package="PackageCategories">isTemporary	^false</body><body package="PackageCategories">packageIsForced	"Answer true if we are in a force package block."	^alwaysUse ~~ nil</body></methods><methods><class-id>Store.BasicPackagePolicy</class-id> <category>accessing</category><body package="PackageCategories">forcedPackage	^alwaysUse</body><body package="PackageCategories">parentPackageFor: aPackage   	"Decide if we ask for the parent version from the database or   	 just assume that trace is OK.	Default implementation just returns the parent of aPackage"	^aPackage tracePackage</body><body package="PackageCategories">warnOnFirstModification	warnOnFirstModification := warnOnFirstModification ifNil: [true].	^#{Store.DbRegistry} isDefined and: [warnOnFirstModification]</body><body package="PackageCategories">warnOnFirstModification: aBoolean	warnOnFirstModification := aBoolean</body></methods><methods><class-id>Store.BasicPackagePolicy</class-id> <category>package assignment</category><body package="PackageCategories">forceNullPackageWhile: aBlock 	"This method puts everything into the null package when. 	It overrides current policy settings."	^self forcePackage: self nullPackage while: aBlock</body><body package="PackageCategories">forcePackage: aPackage while: aBlock 	"This method designates aPackage to be used whenever 	a new definition is created. It overrides current policy settings."	| old retVal |	old := alwaysUse.		[ alwaysUse := aPackage.	retVal := aBlock value 	] ensure: [ alwaysUse := old ].	^retVal.</body><body package="PackageCategories">packageForClassSymbol: classSymbol	"Return the package that this class should be 	placed in. Nil if none can be determined."	alwaysUse notNil ifTrue: [^alwaysUse].	^(self containingPackageForClassSymbol: classSymbol)		ifNil: [self packageForNewClassSymbol: classSymbol]</body><body package="PackageCategories">packageForDataKey: dataKey classSymbol: classSymbol 	"Return the package that this data should be 	placed in. Nil if none can be determined."	alwaysUse notNil ifTrue: [^alwaysUse].	^(self containingPackageForDataKey: dataKey symbol: classSymbol)		ifNil: [self packageForNewDataKey: dataKey classSymbol: classSymbol]</body><body package="PackageCategories">packageForDataKey: dataKey nameSpaceSymbol: nameSpaceSymbol 	"Return the package that this data should be placed in. 	Nil if none can be determined."	alwaysUse notNil ifTrue: [ ^alwaysUse ].	^(self containingPackageForDataKey: dataKey symbol: nameSpaceSymbol)		ifNil: [self packageForNewDataKey: dataKey nameSpaceSymbol: nameSpaceSymbol]</body><body package="PackageCategories">packageForNameSpaceSymbol: nameSpaceSymbol	"Return the package that this class should be 	placed in. Nil if none can be determined."	alwaysUse notNil ifTrue: [ ^alwaysUse ].	^(self containingPackageForNameSpaceSymbol: nameSpaceSymbol)		ifNil: [self packageForNewNameSpaceSymbol: nameSpaceSymbol]</body><body package="PackageCategories">packageForNewClassSymbol: classSymbol	"Return the package that this class should be placed in. The nullPackage if none can be determined."		alwaysUse notNil ifTrue: [^alwaysUse].	^self newClassUseCurrent		ifTrue: [self currentPackage]		ifFalse: [self chooseOrAddPackageNamed: classSymbol]</body><body package="PackageCategories">packageForNewDataKey: dataKey classSymbol: classSymbol	"Return the package that this datum should be 	placed in. Nil if none can be determined."	alwaysUse notNil ifTrue: [^alwaysUse].	(self newDatumUseCurrent and: [self currentPackageIsNull not])		ifTrue: [^self currentPackage].	self newDatumUseClass		ifTrue: 			[ | clpkg |			clpkg := self containingPackageForClassSymbol: classSymbol.			( self newDatumUseClassIfCurrentSame not or: [ self currentPackageIsNull					ifTrue: [ self newDatumUseClassIfNoCurrent ]					ifFalse: [ self currentPackage == clpkg ] ]			)				ifTrue: [ ^self validatePackage: clpkg description: classSymbol, '.', dataKey ].			^self 				chooseOrAddPackageNamed:  classSymbol, '.', dataKey 				withDefault: clpkg			].	^self chooseOrAddPackageNamed: classSymbol, '.', dataKey</body><body package="PackageCategories">packageForNewDataKey: dataKey nameSpaceSymbol: nameSpaceSymbol	"Return the package that this datum should be 	placed in. Nil if none can be determined."	alwaysUse notNil ifTrue: [ ^alwaysUse ].	(self newDatumUseCurrent and: [self currentPackageIsNull not])		ifTrue: [^self currentPackage].	self newDatumUseClass		ifTrue: 			[ | clpkg |			clpkg := self containingPackageForNameSpaceSymbol: nameSpaceSymbol.			( self newDatumUseClassIfCurrentSame not or: [ self currentPackageIsNull					ifTrue: [ self newDatumUseClassIfNoCurrent ]					ifFalse: [ self currentPackage == clpkg ] ]			)				ifTrue: [ ^self validatePackage: clpkg description: nameSpaceSymbol, '.', dataKey ].			^self 				chooseOrAddPackageNamed:  nameSpaceSymbol, '.', dataKey 				withDefault: clpkg			].	^self chooseOrAddPackageNamed: nameSpaceSymbol, '.', dataKey</body><body package="PackageCategories">packageForNewNameSpaceSymbol: nameSpaceSymbol	"Return the package that this namespace should be 	placed in. Nil if none can be determined."		alwaysUse notNil ifTrue: [^alwaysUse].	^self newNameSpaceUseCurrent		ifTrue: [self currentPackage]		ifFalse: [self chooseOrAddPackageNamed: nameSpaceSymbol]</body><body package="PackageCategories">packageForNewSelector: selector classSymbol: classSymbol meta: isMeta	"Return the package that this method should be 	placed in. Nil if none can be determined."	| clpkg |	alwaysUse notNil ifTrue: [ ^alwaysUse ].	( self newMethodUseCurrent and: [ self currentPackageIsNull not ] )		ifTrue: [ ^self currentPackage ].	clpkg := self containingPackageForClassSymbol: classSymbol.	self newMethodUseClass		ifTrue: 			[ ( self newMethodUseClassIfCurrentSame not or: 				[ self currentPackageIsNull					ifTrue: [ self newMethodUseClassIfNoCurrent ]					ifFalse: [ self currentPackage == clpkg ] 				] )  					ifTrue: [ ^self validatePackage: clpkg description: classSymbol, '&gt;&gt;', selector ].			].	^self 		chooseOrAddPackageNamed:  classSymbol,  '&gt;&gt;', selector 		withDefault: clpkg</body><body package="PackageCategories">packageForSelector: selector classSymbol: classSymbol meta: isMeta	"Return the package that this method should be placed in."	alwaysUse notNil ifTrue: [^alwaysUse].	^(self containingPackageForSelector: selector classSymbol: classSymbol meta: isMeta)		ifNil: [self packageForNewSelector: selector classSymbol: classSymbol meta: isMeta]</body></methods><methods><class-id>Store.BasicPackagePolicy</class-id> <category>private</category><body package="PackageCategories">validatePackage: aPackage description: aString		aPackage hasBeenModifiedSomewhere ifTrue: [^aPackage].	^self checkForFirst		ifTrue: [self warnOnFirstModificationOfPackage: aPackage description: aString]		ifFalse: [aPackage]</body><body package="PackageCategories">warnOnFirstModificationOfPackage: aPackageModel description: aString	"Display warning and answer appropiate package to use."	| msg |	msg := (#WarnModifiedPackage &lt;&lt; #packages &gt;&gt; 'Do you want to add &lt;1s&gt; to the previously unchanged package, &lt;2s&gt;&lt;ntttttt&gt;OK to continue?').	^( Dialog confirm: ( msg expandMacrosWith: aString with: aPackageModel name ) )		ifTrue: [ aPackageModel ]		ifFalse: 			[ self 				chooseOrAddPackageNamed:  aString 				withDefault: nil			]</body></methods><methods><class-id>Store.BasicPackagePolicy</class-id> <category>private - choosing packages</category><body package="PackageCategories">chooseOrAddPackageNamed: classSymbol	"Note that chooseOrAdd:onCancelDo: will not answer the value of the cancel block if the dialog is cancelled, and thus the return in the cancel block is necessary"	^PackageChooser		chooseOrAdd: classSymbol		onCancelDo: [^self nullPackage]</body><body package="PackageCategories">chooseOrAddPackageNamed: classSymbol withDefault: defaultValue	"Note that chooseOrAdd:onCancelDo: will not answer the value of the cancel block if the dialog is cancelled, and thus the return in the cancel block is necessary"	^PackageChooser		chooseOrAdd: classSymbol		withDefault: defaultValue		onCancelDo: [^self nullPackage]</body></methods><methods><class-id>Store.BasicPackagePolicy</class-id> <category>private - registry</category><body package="PackageCategories">containingPackageForClassSymbol: classSymbol	^self registry containingPackageForClassSymbol: classSymbol</body><body package="PackageCategories">containingPackageForDataKey: dataKey symbol: classSymbol	^self registry containingPackageForDataKey: dataKey symbol: classSymbol</body><body package="PackageCategories">containingPackageForNameSpaceSymbol: nameSpaceSymbol	^self registry containingPackageForNameSpaceSymbol: nameSpaceSymbol</body><body package="PackageCategories">containingPackageForSelector: selector classSymbol: classSymbol meta: isMeta	^self registry containingPackageForSelector: selector classSymbol: classSymbol meta: isMeta</body><body package="PackageCategories">currentPackage	^self registry currentPackage</body><body package="PackageCategories">currentPackageIsNull	^self registry isCurrentNull</body><body package="PackageCategories">nullPackage	^self registry nullPackage</body><body package="PackageCategories">registry	^Registry</body></methods><methods><class-id>Store.PundleModel</class-id> <category>printing</category><body package="PackageCategories">itemString	| nameAndVersion env |	nameAndVersion := self name , self versionString.	env := self environment.	^env isNil 		ifTrue: [nameAndVersion]		ifFalse: [ |envName |			envName := 'Environment: ', self environment fullName.			nameAndVersion , (String with: Character cr with: Character tab), envName].</body><body package="PackageCategories">printStringCache	"Answer the db printString for the current connection versioin, nil if none."	| info |	^( info := self databaseInformation ) == nil		ifFalse: [ info versionString ].</body><body package="PackageCategories">printStringCache: aString	self databaseInformationOrCreate		versionString: aString</body><body package="PackageCategories">textForItem	"Descriptive text for the browser text window."	| stream dbId |	stream := TextStream on: ( String new: 80 ).	stream nextPutAll: self name; cr.	#{DbRegistry} ifDefinedDo: 		[ :reg | dbId := reg dbIdentifier.		self databaseInformationsDo:			[ :info | | id | 			id := info dbIdentifier.			id = dbId ifTrue: [ stream emphasis: #bold ].			id == nil ifTrue: [ id := '' ]. 			stream tab; nextPutAll: 				( id, info versionString,						( ( self hasBeenModifiedIn: id )							ifTrue: [ '*' ]							ifFalse: [ '=' ]						)				).			stream emphasis: #normal.			stream cr.			].		].	^stream contents</body><body package="PackageCategories">traceVersion	"Answer a string describing a version of my trace 	pundle appropiate for version	comparisons."	| info |	^self shouldTrackChanges		ifTrue: 			[(info := self databaseInformation) isNil				ifTrue: ['']				ifFalse: [info traceVersion]]		ifFalse: [self version]</body><body package="PackageCategories">versionString	self shouldTrackChanges		ifFalse: [ ^'' ].	^self traceVersionString , 		( self hasBeenModified			ifTrue: [ '*' ]			ifFalse: [ '=' ]		)</body></methods><methods><class-id>Store.PundleModel</class-id> <category>public-change set access</category><body package="PackageCategories">anyInvalidModifiedSource	^self changeSet modifiedMethodDescriptors 		detect: [:eachMethodDescriptor|			eachMethodDescriptor compiledMethod getSource isNil] ifNone: [nil].</body><body package="PackageCategories">emptyPundleChangeSetFor: aDatabaseIdentifier	"Empty the currently active ChangeSet."	| databaseInformation |	(databaseInformation := self databaseInformationFor: aDatabaseIdentifier)		ifNotNil: [self updateAfterDo: [databaseInformation emptyChangeSet]]</body><body package="PackageCategories">markNotModified	self shouldTrackChanges 		ifTrue: [ self emptyChangeSet ]</body><body package="PackageCategories">markPundleNotModifiedFor: aDatabaseIdentifier	self shouldTrackChanges		ifTrue: [self emptyPundleChangeSetFor: aDatabaseIdentifier]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>testing</category><body package="PackageCategories">hasBeenModifiedEverywhere	"Answer true if the receiver has been modified in every database it is reconciled against and in at least one."		^self isImageDatabaseEnabled	and: [self databaseInformations notEmpty	and: [self databaseInformations allSatisfy:			[:each | self hasBeenModifiedIn: each dbIdentifier]]]</body><body package="PackageCategories">hasBeenModifiedIn: aDatabaseId	"Answer true if the receiver or a subcomponent has been modified within a database."		| info |	^( info := self  databaseInformationFor: aDatabaseId ) == nil		ifTrue: [ false ]		ifFalse: [ info isChangeSetEmpty not ]</body><body package="PackageCategories">hasBeenModifiedSomewhere	"Answer true if the receiver has been modified within any database."	^self isImageDatabaseEnabled and:		[self databaseInformations anySatisfy: [:each | self hasBeenModifiedIn: each dbIdentifier]]</body><body package="PackageCategories">hasItselfBeenModified	"Return true if the receiver itself has been modified.  Does not consider whether	 contained items have been modified"	^self isChangeSetEmpty not</body><body package="PackageCategories">hasItselfBeenModifiedWithoutProperties	"Return true if the receiver itself has been modified.  Does not consider whether	 contained items have been modified but does consider that properties changes are ignored"	^self isChangeSetEmpty not and: [self changeSet properties isEmpty]</body><body package="PackageCategories">haveAnyBeenModifiedWithoutProperties	"Return true if the receiver itself has been modified.  Does not consider whether	 contained items have been modified but does consider that properties changes are ignored"	(self isPackage and: [self isNullPackage]) ifTrue: [^false].	dbInfo isEmpty ifTrue: [^false].	self changeSetsDo: [:each | (each isEmpty not and: [each properties isEmpty]) ifTrue: [^true]].	^false</body><body package="PackageCategories">isChangeSetEmpty		| info |	^( info := self databaseInformation ) == nil		ifTrue: [ true ]		ifFalse: [ info isChangeSetEmpty ]</body><body package="PackageCategories">isImageDatabaseEnabled	^#{Store.DbRegistry} isDefined</body><body package="PackageCategories">isImageModel	^true</body><body package="PackageCategories">isInCurrentDatabase	^#{Store.DbRegistry}		ifDefinedDo: [:registry | registry notNil and: [dbInfo keys includes: registry dbIdentifier]]		elseDo: [false]</body><body package="PackageCategories">isModifiedSourceValid	^self anyInvalidModifiedSource isNil</body><body package="PackageCategories">shouldTrackChanges	^#{Store.DBAccess} isDefined</body></methods><methods><class-id>Store.PundleModel</class-id> <category>initialization</category><body package="PackageCategories">initialize	super initialize.	dbInfo := IdentityDictionary new: 2.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="PackageCategories">allItems	^self subclassResponsibility</body><body package="PackageCategories">allUniqueItems	"Answer a list of unique pundles contianed in this pundle. 	The list preserves the pundle order. 	Remove duplicates from the list."		| items present |	items := self allItems.	present := Set new: items size.	^items select:		[:each | 		| result |		result := present includes: each.		present add: each.		result not].</body><body package="PackageCategories">anyDatabaseId	"Answer a database id that this pundle has, or the infamous noDatabase if there are none."	self databaseList do: [:any | ^any].	^self noDbSymbol</body><body package="PackageCategories">basicVersionString	"Answer a string describing a version of pundle. but don't access the cache, so may answer nil"		^self databaseInformation ifNotNil: [:value | value basicVersionString]</body><body package="PackageCategories">changeSetFor: aDatabaseId	"Answer a changeset for the specified database connection"	| dbinfo |	^( dbinfo := self databaseInformationFor: aDatabaseId ) == nil		ifFalse: [ dbinfo changeSet ]</body><body package="PackageCategories">changedMethodsFor: dbIdentifier	| changeSet |	^( changeSet := self changeSetFor: dbIdentifier ) == nil		ifTrue: [ #( ) ]		ifFalse: [ changeSet modifiedMethodDescriptors ]</body><body package="PackageCategories">databaseInformationClass	^DatabaseConnectionInformation</body><body package="PackageCategories">databaseList	"Answer an array of datbase identifiers whether the receiver has links or not"	^dbInfo keys</body><body package="PackageCategories">dbIdentifier	"Answer the db identifier for the current connection, nil if none."	| info |	^( info := self databaseInformation ) == nil		ifFalse: [ info dbIdentifier ].</body><body package="PackageCategories">dbIdentifier: dbIdentifier 	"Set the database identifier."	self databaseInformationForOrCreate: dbIdentifier</body><body package="PackageCategories">dbTimestamp	"Answer the db timestamp for the current connection, nil if none."	| info |	^( info := self databaseInformation ) == nil		ifFalse: [ info dbTimestamp ].</body><body package="PackageCategories">dbTimestamp: aTimestampOfDbPackage 	"Store the timestamp of the loaded package."	self databaseInformationOrCreate		dbTimestamp: aTimestampOfDbPackage .</body><body package="PackageCategories">dbTrace	"Answer the db parent id for the current connection, nil if none."	| info |	^( info := self databaseInformation ) == nil		ifFalse: [ info dbTrace ].</body><body package="PackageCategories">dbTraceFor: databaseId	"Answer the db parent id for the specified database, nil if none."	| info |	^( info := self databaseInformationFor: databaseId ) == nil		ifFalse: [ info dbTrace ].</body><body package="PackageCategories">dbUsernameOrDerived	"Answer the db parent id for the current connection, nil if none."	| info |	^(info := self databaseInformation) isNil		ifTrue: ['']		ifFalse: [info dbUsernameOrDerived]</body><body package="PackageCategories">dbVersionOrDerived	"Answer the db parent id for the current connection, nil if none."	| info |	^(info := self databaseInformation) isNil		ifTrue: ['']		ifFalse: [info dbVersionOrDerived]</body><body package="PackageCategories">getImagePundle	^self</body><body package="PackageCategories">markReadOnly	readonly := true.</body><body package="PackageCategories">mergeInformation	^self databaseInformation ifNotNil: [:value | value mergeInformation]</body><body package="PackageCategories">mergeInformation: aMergeInformation	self databaseInformation ifNotNil: [:value | value mergeInformation: aMergeInformation]</body><body package="PackageCategories">name: aString	super name: aString asString.</body><body package="PackageCategories">parcelName	"Answer the parcel name, or receiver's name if absent."		^self propertyAt: #parcelName ifAbsent: [ self name ].</body><body package="PackageCategories">parcelName: aString	"Answer the parcel name, or receiver's name if absent."		^self propertyAt: #parcelName put: aString</body><body package="PackageCategories">parentChangedMark	^#parentChanged</body><body package="PackageCategories">raiseMismatchedSignal	self class mismatchedDatabaseSignal signalWith: self.</body><body package="PackageCategories">relatedParcel	"Answer the receiver's coresponding parcel, nil if none"	^Parcel parcelNamed: self parcelName</body><body package="PackageCategories">relatedPundle	^self</body><body package="PackageCategories">renameTo: aString	"Rename the receiver. If it has been published, this will disconnect  it from previous versions."	Registry renamePundle: self to: aString.</body><body package="PackageCategories">silentProperties: aDictionary	( properties contentsEquals: aDictionary ) 		ifTrue: [ ^self ].	properties := IdentityDictionary new.	self startLoad.	[ self copyPropertiesFrom: aDictionary ]		ensure: [ self endLoad ].</body><body package="PackageCategories">storeModel	^self</body><body package="PackageCategories">toolListIcon	^ListIconLibrary visualFor: self toolListIconKey</body><body package="PackageCategories">toolListIconKey	"subclasses are required to compute the correct lookup key to be used against the ListIconLibrary"	^self subclassResponsibility</body><body package="PackageCategories">unmarkReadOnly	readonly := false.</body><body package="PackageCategories">version	^(#image &lt;&lt; #packages &gt;&gt; 'image') asString</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private</category><body package="PackageCategories">asDescription	^( self descriptionClass new )		componentName: self name;		yourself.</body><body package="PackageCategories">cleanse	"Cleanse the component. Remove any class or method definitions	 that are no longer in the system, including the postLoadMethod."</body><body package="PackageCategories">cleanse: ignore	"Cleanse the component. Remove any class or method definitions	 that are no longer in the system, including the postLoadMethod."</body><body package="PackageCategories">removeLinks: propertyDictionary	"Remove the database link properties before any further processing of the supplied dictionary into the pundle's properties, so that future parcels saved from this pundle are not inadvertently saved with stale link information from its properties."	propertyDictionary 		removeKey: #databaseId ifAbsent: nil;		removeKey: #dbIdentifier ifAbsent: nil;		removeKey: #dbTrace ifAbsent: nil;		removeKey: #dbUsername ifAbsent: nil;		removeKey: #dbVersion ifAbsent: nil;		removeKey: #printStringCache ifAbsent: nil.</body><body package="PackageCategories">selectIconKeyDefault: defaultKey modified: modifiedKey noDBdefault: ndDefaultKey modified: ndModified	^(self isImageDatabaseEnabled not or: [self isInCurrentDatabase])		ifTrue:			[self hasBeenModifiedSomewhere				ifTrue: [modifiedKey]				ifFalse: [defaultKey]]		ifFalse:			[self hasBeenModifiedSomewhere				ifTrue: [ndModified]				ifFalse: [ndDefaultKey]]</body><body package="PackageCategories">sortCategories: categories with: orderedCategories	"Answer a collection that is categories sorted according to the image."	| list |	list := OrderedCollection new: categories size.	orderedCategories do:		[ :cat | 			( categories includes: cat )			ifTrue: [ list add: cat ]		].	^list.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-db management</category><body package="PackageCategories">addOtherChange: mark	self updateAfterDo: 		[ self changeSetsDo: [ :cs | cs  addOtherChange: mark ] ]</body><body package="PackageCategories">addPropertyChange: mark	self updateAfterDo: 		[ self changeSetsDo: [ :cs | cs  addPropertyChange: mark ] ]</body><body package="PackageCategories">changeSet	"Answer a changeset for the current/last database connection"	| dbinfo |	( dbinfo := self databaseInformation ) == nil		ifTrue: [ dbinfo := self databaseInformationForOrCreate: self noDbSymbol ].	^dbinfo changeSet.</body><body package="PackageCategories">changeSetsDo: aBlock 	"Evaluate aBlock for all of the receiver's changeSets 	(ie. for all database connections). 		If there are no changesets, create an unnamed one"	dbInfo isEmpty ifTrue: [self databaseInformationForOrCreate: self noDbSymbol].	dbInfo values do: [:each | aBlock value: each changeSet].</body><body package="PackageCategories">databaseInformation	| dbid |	dbid := self noDbSymbol.	#{Store.DbRegistry} ifDefinedDo: 		[:registry | 		"The only time that DbRegistry might be defined and still be nil is		if StoreBase is being loaded into the image for the first time.  So,		the following check is simply to prevent walkbacks while loading		StoreBase."		dbid := registry isNil ifTrue: [nil] ifFalse: [registry dbIdentifier]].	^dbInfo at: dbid ifAbsent: [nil]</body><body package="PackageCategories">databaseInformationFor: aDatabaseId	"Answer a DatabaseInformationConnection for the receiver 	and the specified database"	^dbInfo at: aDatabaseId ifAbsent: nil</body><body package="PackageCategories">databaseInformationForOrCreate: aDatabaseId	"Answer a  DatabaseInformationConnection for the receiver 	and the specified database"	| dbid |	dbid := aDatabaseId == nil		ifTrue: [ self noDbSymbol ]		ifFalse: [ aDatabaseId asSymbol ].	^dbInfo at: dbid ifAbsentPut: 		[ ( self databaseInformationClass dbIdentifier: dbid )				pundle: self ;				initializeContentsFrom: self;				yourself		].</body><body package="PackageCategories">databaseInformationOrCreate	"Answer a DatabaseInformationConnection for the receiver 	and the current/last database or create a new one and set it up."	| dbid |	( dbid := #{DbRegistry} ifDefinedDo: [ :reg | reg  dbIdentifier ] ) == nil		ifTrue: 			[ dbid := dbInfo isEmpty				ifTrue: [ self noDbSymbol ]				ifFalse: [ dbInfo values first dbIdentifier ]			].	^dbInfo at: dbid ifAbsentPut: 		[ ( self databaseInformationClass dbIdentifier: dbid )				pundle: self;				initializeContentsFrom: self;				yourself		].</body><body package="PackageCategories">databaseInformations	"Private- Answer the dictionary of databaseConnectionInformations."	^dbInfo</body><body package="PackageCategories">databaseInformationsDo: aBlock	"Evaluate aBlock for all all database connections."	dbInfo == nil		ifFalse: [ dbInfo do: aBlock ].</body><body package="PackageCategories">emptyChangeSet	"Empty the currently active ChangeSet."		| databaseInformation |	(databaseInformation := self databaseInformation) ifNotNil: 		[self updateAfterDo: [databaseInformation emptyChangeSet]]</body><body package="PackageCategories">noDbSymbol	^#''</body><body package="PackageCategories">updateAfterDo: aBlock 	| changeSetState |	changeSetState := self hasBeenModified.	aBlock value.	changeSetState = self hasBeenModified 		ifFalse: [ Registry modificationChangedForPundle: self ]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>browser support</category><body package="PackageCategories">value	"Implemented by any subclass wanting to be displayed in a browser."	^self</body></methods><methods><class-id>Store.PundleModel</class-id> <category>parcel support</category><body package="PackageCategories">asParcel	"Convert the receiver to a parcel." 	^self asParcel: self name.</body><body package="PackageCategories">asParcel: string 	"Convert the receiver to a parcel named string.	Does not remove anything from existing parcels."	| parcel |	( parcel := Parcel parcelNamed: string ) == nil		ifTrue: [ parcel := Parcel createParcelNamed: string ].	self copyContentsToParcel: parcel.	parcel properties: self propertiesForSave.	(properties at: #parcelDirectory ifAbsent: [nil]) ifNotNil:		[:value | parcel propertyAt: #parcelDirectory put: value].	^parcel.</body><body package="PackageCategories">cleanseRelatedParcel	"If there is a related parcel to this pundle, cleanse it. This helps keep the parcel void of any obsolete 	definitions. If the parcel is empty the side-effect (yuck) is to ask the user if they want to destroy it."	| parcel |	(parcel := self relatedParcel) ifNil: [^self].	parcel cleanse.	ChangeSet unloadComponent: parcel.	SourceFileManager default unloadComponent: parcel.	Parcel destroyParcelNamed: parcel name</body><body package="PackageCategories">copyPropertiesFrom:  aPropertyDictionary	"Move the relevant properties to the receiver. Uses accessors where  possible."	"NOTE: maybe should to get property list from class"	self restoreLinksFrom: aPropertyDictionary.  "special case stored db links."	super copyPropertiesFrom: aPropertyDictionary</body><body package="PackageCategories">notInParcel: aParcel 	"Answer a string listing things contained in the receiver but not in a Parcel."	| stream |	stream := ( String new: 100 ) writeStream.	stream nextPutAll: (#ClassesC &lt;&lt; #packages &gt;&gt; 'Classes:') asString; cr.	self definedClassesNotInParcel: aParcel on: stream.	stream cr; nextPutAll: (#MethodsC &lt;&lt; #packages &gt;&gt; 'Methods:') asString; cr.	self methodsNotInParcel: aParcel on: stream.	stream cr; nextPutAll: (#NameSpacesC &lt;&lt; #packages &gt;&gt; 'NameSpaces:') asString; cr.	self definedNameSpacesNotInParcel: aParcel on: stream.	stream cr; nextPutAll: (#DataC &lt;&lt; #packages &gt;&gt; 'Data:') asString; cr.	self dataNotInParcel: aParcel on: stream.	^stream contents.</body><body package="PackageCategories">putStoredPropertiesIn: aDictionary 	"Put any PundleModel-specific properties into aDictionary for Parcel publishing."	aDictionary at: #name put: self parcelName.</body><body package="PackageCategories">resetUninstalledStateFrom: aParcel	"A parcel has changed in some way, recheck and set the uninstalled properties.	We no longer mark a Pundle as read only if it has uninstalled things, because they are now writable.	These uninstalled properties serve no direct purpose in Store"		self propertyAt: #uninstalledClasses put: nil.	self propertyAt: #uninstalledMethods put: nil.	self propertyAt: #uninstalledBindings put: nil</body><body package="PackageCategories">restoreLinksFrom: propertyDictionary	"Called when restoring database links after parcel load."		| identifier |	identifier := propertyDictionary at: #dbIdentifier ifAbsent: [propertyDictionary at: #databaseId ifAbsent: [nil]].	identifier ifNotNil:		[(self databaseInformationForOrCreate: identifier)			setDbTrace: (propertyDictionary at: #dbTrace ifAbsent: [nil]);			versionString: (propertyDictionary at: #printStringCache ifAbsent: [nil]);			dbUsername: (propertyDictionary at: #dbUsername ifAbsent: [nil]);			dbVersion: (propertyDictionary at: #dbVersion ifAbsent: [nil]);			emptyChangeSet.		dbInfo removeKey: self noDbSymbol ifAbsent: [nil]].	self removeLinks: propertyDictionary</body></methods><methods><class-id>Store.PundleModel</class-id> <category>private-load/unload</category><body package="PackageCategories">assertNotLoaded: nameString ifFail: aBlock 	"Check if the receiver is already loaded and if so, raise the parcelAlreadyLoadedSignal.	 If the handler returns false, indicating the load should be aborted, and then raise the	 abortedActionSignal and return its value through aBlock."	self needsMoreWork</body><body package="PackageCategories">assertSelfIsSameComponentAs: parcelName ifFail: aBlock	"For updating from binary (i.e. parcel)"		(parcelName ~= self parcelName and: [self name ~= parcelName])		ifTrue:			[^aBlock value:				(Parcel abortedActionSignal					raiseRequestWith: (Array 						with: self 						with: self name 						with: #updateWrongComponent &lt;&lt; #dialogs &gt;&gt; 'Attempt to update different component')					errorString: #loadAborted &lt;&lt; #dialogs &gt;&gt; 'Parcel load aborted')]</body><body package="PackageCategories">prerequisiteProviderFrom: aCodeReaderOrNil	^Registry</body><body package="PackageCategories">recordPackageContentsFrom: aCodeReader	"Override to suppress unnecessary duplicate add warnings."	[super recordPackageContentsFrom: aCodeReader]  		on: Store.StoreWarning 		do: [ :ex | ex resume ]</body><body package="PackageCategories">unloadLogged: ignored		| success |	success := self unloadFromImage.	(success and: [#{Store.DbRegistry} isDefined]) ifTrue:		[ChangeSet unloadComponent: self.		SourceFileManager default unloadComponent: self].	^success</body></methods><methods><class-id>Store.PundleModel</class-id> <category>fileIn/Out</category><body package="PackageCategories">fileOut	"Ask for the file name and file out the content of the pundle into it."	| fileName |	fileName := Dialog 				requestNewFileName: #FileOutOnC &lt;&lt; #packages &gt;&gt; 'File out on:'				default: self name , '.st'.	fileName isEmpty ifTrue: [^nil].	self fileOutOnFileNamed: fileName</body><body package="PackageCategories">fileOutOnFileNamed: fileName		| stream |	stream := SourceCodeStream write: fileName.	[Notice 		showNotice: (#FilingOut1s &lt;&lt; #packages &gt;&gt; 'Filing out &lt;1s&gt;' 				expandMacrosWith: name)		complete: self itemCount		while: 			[stream timeStamp.			stream deferInitializations.			self fileOutOn: stream.			stream finishInitializations]		title: #Store &lt;&lt; #packages &gt;&gt; 'Store'] 			ensure: [stream close]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>deprecated/backward compatiblity</category><body package="PackageCategories">databaseInfomation	"This is deprecated, but preserves the old mis-spelling for backward compatibility. Use databaseInformation instead."	^self databaseInformation.</body><body package="PackageCategories">databaseInfomationForOrCreate: aDatabaseId	"This is deprecated, but preserves the old mis-spelling for backward compatibility. Use databaseInformationForOrCreate: instead."	^self databaseInformationForOrCreate: aDatabaseId.</body><body package="PackageCategories">databaseInfomationOrCreate	"This is deprecated, but preserves the old mis-spelling for backward compatibility. Use databaseInformationOrCreate instead."	^self databaseInformationOrCreate.</body></methods><methods><class-id>Store.PundleModel</class-id> <category>load/unload</category><body package="PackageCategories">doUnloadFromImage	^self subclassResponsibility</body><body package="PackageCategories">runPreUnloadFrom: aBundle	"Run the preUnload code for the receiver - only if aBundle is the only referent. "	( self preUnloadChecksFromBundle: aBundle )		ifFalse: [ ^false ].	^( self onlyReferencedBy: aBundle )		ifTrue: [ self runPreUnload ]		ifFalse: [ true ].</body><body package="PackageCategories">unloadFromGroup: aGroup 	"aGroup asks for unloading this component. 	Obey only if aGroup is the only group that references this component."	( self onlyReferencedBy: aGroup )		ifTrue: 			[ self doUnloadFromImage.			ChangeSet unloadContainedComponent: self. 			]</body><body package="PackageCategories">unloadProblemsQuery: aProblemSet header: aHeader 	| problemsStream problems indent |	aProblemSet size = 0 ifTrue: [^true].	problemsStream := WriteStream on: String new.	problemsStream		nextPutAll: aHeader;		cr.	problems := aProblemSet asSortedCollection.	problems isEmpty ifTrue: [^true].	indent := '         '.	problems size &lt; 20 		ifTrue: 			[problems do: 					[:prob | 					problemsStream nextPutAll: indent.					problemsStream nextPutAll: prob.					problemsStream cr]]		ifFalse: 			[1 to: 14				do: 					[:inx | 					problemsStream nextPutAll: indent.					problemsStream nextPutAll: (problems at: inx).					problemsStream cr].			problemsStream				nextPutAll: '...';				cr].	problemsStream nextPutAll: (#ProceedQ &lt;&lt; #store &gt;&gt; 'Proceed?') asString.	^StoreUnloadWarning raiseSignal: problemsStream contents</body></methods><methods><class-id>Store.PundleModel</class-id> <category>change management</category><body package="PackageCategories">applyChangeType: aSymbol forProperty: propertyName	aSymbol == #none ifTrue: [		| cs |		cs := self changeSet.		cs propertiesOrNil isNil ifTrue: [^self].		cs properties remove: propertyName ifAbsent: [nil]]</body></methods><methods><class-id>Store.PundleModel</class-id> <category>change lookup</category><body package="PackageCategories">currentChangeForProperty: propertyName	^self changeSet currentChangeForProperty: propertyName</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>class initialization</category><body package="PackageCategories">initialize	"self initialize"	EmergencyUnloadSignal := Object errorSignal newSignal 		notifierString: (#CannotLoadAComponent &lt;&lt; #packages &gt;&gt; 'Cannot load a component');		nameClass: self message: #emergencyUnloadSignal.</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>utility</category><body package="PackageCategories">selectDatabaseFor: pundles	"Display a list of existing db names and answer the user's choice."	| dbs |	( dbs := self allDatabasesFor: pundles ) size == 0		ifTrue: [ ^nil ].	dbs size == 1		ifTrue: [ ^dbs first ].	^Dialog		choose: (#ForWhichDatabase &lt;&lt; #packages &gt;&gt; 'For which database?')		fromList: dbs		values: dbs		lines: dbs size + 1		cancel: nil</body><body package="PackageCategories">selectDatabasesFor: aCollection prompt: aString	"Display a list of existing dbIdentifiers and answer the user's choices.	self selectDatabasesFor: ( Store.Registry bundleNamed: 'StoreBase' ) leafItems prompt: 'which?'"		| dbIdentifiers |	(dbIdentifiers := self allDatabasesFor: aCollection) size == 0 ifTrue:		[Dialog warn: #ThereAreNoDatabaseLinks &lt;&lt; #store &gt;&gt; 'There are no database links.'.		^#()].	^SimpleDialog new		chooseMultiple: aString		fromList: dbIdentifiers		values: dbIdentifiers		buttons: #()		values: #()		lines: dbIdentifiers size + 1		cancel: [#()]		for: Dialog defaultParentWindow</body></methods><methods><class-id>Store.PundleModel class</class-id> <category>instance creation</category><body package="PackageCategories">illegalCharacters	"Answer a list of characters that should not be in a package name because of possibly illiegal 	directory names that can be constructed from the packagename."	"Using this as the most restrictive list of chars"	^PCFilename badEightDotThreeCharacterList copyWithout: Character space</body><body package="PackageCategories">named: aString 	"The ONLY legitimate method for creating new pundles."	| newPundle |	newPundle := super named: aString.	Registry notNil 		ifTrue: [ Registry privateRegisterPundle: newPundle ].	^newPundle</body><body package="PackageCategories">validateName: proposedComponentName 	"Answer true if proposedComponentName does not contain any illegal characters that might be used	as a directory name."	| badChars |	badChars := self illegalCharacters.	^(proposedComponentName contains: [:char | badChars includes: char]) not</body></methods><methods><class-id>Store.PackageModel</class-id> <category>testing</category><body package="PackageCategories">definesClass: aClass 	^(self classModelAtClass: aClass ifAbsent: [^false]) hasDefinition</body><body package="PackageCategories">extendsClass: aClass 	^(self classModelAtClass: aClass ifAbsent: [ ^false ] ) isExtension</body><body package="PackageCategories">hasBeenModified	"Answer true if the receiver has been 	modified or has no dbTrace."	^self shouldTrackChanges and:		[ self hasItselfBeenModified or: 			[ ( self dbTraceFor: self dbIdentifier ) == nil ]		].</body><body package="PackageCategories">hasDataKey: aSymbol in: aClassOrNameSpace	"Answer true if the receiver owns the definition for aClassOrNameSpace.aSymbol, 	even if it has been overridden."	^( self includesDataKey: aSymbol owner: aClassOrNameSpace )  or:		[ Override isOverriddenStatic: aSymbol in: aClassOrNameSpace  in: self ]</body><body package="PackageCategories">hasDefinitionFor: aClassOrNameSpace	"Answer true if the receiver owns the definition for aClassOrNameSpace, 	even if it has been overridden."	^( self includesSymbol: aClassOrNameSpace absoluteSymbol )  or:		[ Override isOverriddenClassOrNameSpace: aClassOrNameSpace  in: self ]</body><body package="PackageCategories">hasExtensions	"Answer true if the receiver extends a class/namespace not in the package."		models == nil ifTrue: [ ^false ].	^( models detect: [ :model | model hasDefinition not ] ifNone: [ nil ] ) 			notNil</body><body package="PackageCategories">hasSelector: aSelector in: aClass	"Answer true if the receiver owns the definition for aClass&gt;&gt;aSelector, 	even if it has been overridden."	^( self includesSelector: aSelector class: aClass )  or:		[ Override isOverriddenSelector: aSelector class: aClass  in: self ]</body><body package="PackageCategories">hasUninstalledCode	"Borrowed from parcel. Currently only valid if there was a binary load."	^( ( properties at: #uninstalledClasses ifAbsent: nil ) size ~= 0		or: [ ( properties at: #uninstalledMethods ifAbsent: nil ) size ~= 0 ] )		or: [ ( properties at: #uninstalledBindings ifAbsent: nil ) size ~= 0 ]</body><body package="PackageCategories">includesClass: aClass 	^(self classModelAtClass: aClass ifAbsent: [^false]) hasDefinition</body><body package="PackageCategories">includesClassNamed: anAbsoluteClassName 	"Answer true if the receiver owns a definition for anAbsoluteClassName, even if overridden."	( self		classModelAtClassName: anAbsoluteClassName		ifAbsent: [ ^self isClassOrNameSpaceNameOverridden: anAbsoluteClassName ] 	) ifNotNil: 		[ :model | 			^model hasDefinition				ifTrue: [ true ]				ifFalse: [ self isClassOrNameSpaceNameOverridden: anAbsoluteClassName ]		].</body><body package="PackageCategories">includesClassSymbol: aClassSymbol 	^(self classModelAtClassSymbol: aClassSymbol ifAbsent: [^false]) hasDefinition</body><body package="PackageCategories">includesDataKey: dataKey nameSpace: namespace	^( self modelAtSymbol: namespace absoluteSymbol ifAbsent: [ ^false ] ) 		includesDataKey: dataKey</body><body package="PackageCategories">includesDataKey: dataKey nameSpaceName: aNameSpaceName	^( self modelAtName: aNameSpaceName ifAbsent: [ ^false ] ) 		includesDataKey: dataKey</body><body package="PackageCategories">includesDataKey: dataKey nameSpaceSymbol: nameSpaceSymbol 	^(self modelAtSymbol: nameSpaceSymbol ifAbsent: [ ^false ] )		includesDataKey: dataKey</body><body package="PackageCategories">includesDataKey: dataKey owner: owner	^self includesDataKey: dataKey ownerSymbol: owner absoluteSymbol</body><body package="PackageCategories">includesDataKey: dataKey ownerName: aName	^( self modelAtName: aName ifAbsent: [ ^false ] ) 		includesDataKey: dataKey</body><body package="PackageCategories">includesDataKey: dataKey ownerSymbol: symbol	^( self modelAtSymbol: symbol ifAbsent: [ ^false ] ) 		includesDataKey: dataKey</body><body package="PackageCategories">includesDatum: aDataDescriptor	"Answer true if the receiver contains a definition of aDataDescriptor. 	Since this is for package comparisons, include overrides."		^( self 		includesDataKey: aDataDescriptor dataKey 		ownerName: aDataDescriptor absoluteOwnerName	) or: [ Override 			isOverriddenStatic: aDataDescriptor dataKey 			in: aDataDescriptor owner 			in: self 		  ]</body><body package="PackageCategories">includesMethod: aMethodDescriptor	"Answer true if the receiver contains a definition of aMethodDescriptor. 	Since this is for package comparisons, include overrides."		^(self 		includesSelector: aMethodDescriptor selector 		className: aMethodDescriptor className asClassNameOnly 		meta: aMethodDescriptor isMeta) or: 			[Override 				isOverriddenSelector: aMethodDescriptor selector 				class: aMethodDescriptor implementingClass 				in: self]</body><body package="PackageCategories">includesNameSpaceNamed: anAbsoluteName 	"Answer true if the receiver owns a definition for anAbsoluteName, even if overridden."	( self		modelAtName: anAbsoluteName		ifAbsent: [ ^self isClassOrNameSpaceNameOverridden: anAbsoluteName ] 	) ifNotNil: 		[ :model | 			^model hasDefinition				ifTrue: [ true ]				ifFalse: [ self isClassOrNameSpaceNameOverridden: anAbsoluteName ]		].</body><body package="PackageCategories">includesSelector: aSelector class: aClass	^(self classModelAtClass: aClass ifAbsent: [^false]) includesSelector: aSelector meta: aClass isMeta</body><body package="PackageCategories">includesSelector: aSelector className: aClassName meta: isMeta	^( self classModelAtClassName: aClassName ifAbsent: [ ^false ] ) 		includesSelector: aSelector meta: isMeta</body><body package="PackageCategories">includesSelector: aSelector classSymbol: aClassSymbol meta: isMeta 	^(self classModelAtClassSymbol: aClassSymbol ifAbsent: [^false])		includesSelector: aSelector meta: isMeta</body><body package="PackageCategories">includesSymbol: aSymbol 	^( self modelAtSymbol: aSymbol ifAbsent: [ ^false ] ) hasDefinition</body><body package="PackageCategories">isEmpty	"Answer true if I do not contain any definitions. This method is used	to distinguish newly created packages from the existing ones."	^models isEmpty</body><body package="PackageCategories">isLeaf	^true</body><body package="PackageCategories">isNullPackage	^name = Registry nullPackageName</body><body package="PackageCategories">isPackage	^true</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-model</category><body package="PackageCategories">addFullSymbol: fullSymbol 	"Add namespace/class."	| model |	model := self modelAtFullSymbol: fullSymbol  hasDefinition: true.	model hasDefinition ifFalse: 		[ self			installModelAtFullSymbol: fullSymbol			hasDefinition: true		]</body><body package="PackageCategories">addModel: classOrNameSpaceModel	"Add a classOrNameSpaceModel to the package."	models at: classOrNameSpaceModel absoluteSymbol put: classOrNameSpaceModel.	Registry addModel: classOrNameSpaceModel.</body><body package="PackageCategories">addStatic: staticKey to: aClassOrNameSpace	"Add aClassOrNameSpace.staticKey to the receiver."	self addDataKey: staticKey symbol: aClassOrNameSpace absoluteSymbol.</body><body package="PackageCategories">definedModels	models == nil ifTrue: [^OrderedCollection new].	^(models select: [:model | model hasDefinition]) asOrderedCollection</body><body package="PackageCategories">descriptorClassFor: aSymbol	^aSymbol asStrictReference value isBehavior		ifTrue: [ ClassDescriptor ]		ifFalse:[ NameSpaceDescriptor ]</body><body package="PackageCategories">descriptorClassFor: aSymbol hasDefinition: hasDefinition	^aSymbol asStrictReference value isBehavior		ifTrue: [ hasDefinition					ifTrue: [ ClassDescriptor ]					ifFalse: [ ClassExtensionDescriptor ]				]		ifFalse: [ hasDefinition					ifTrue: [ NameSpaceDescriptor ]					ifFalse: [ NameSpaceExtensionDescriptor ]				]</body><body package="PackageCategories">extendedModels	models == nil ifTrue: [^OrderedCollection new: 1].	^(models reject: [:cm | cm hasDefinition]) asOrderedCollection</body><body package="PackageCategories">includesDefinitionOf: aName 	^( self modelAtSymbol: aName asSymbol ifAbsent: [ ^false ] ) 			hasDefinition</body><body package="PackageCategories">installModelAtFullSymbol: aSymbol hasDefinition: hasDefinition 	"This is the ONLY place new models are created."	"Cloning must occur before installation."	| newModel oldModel |	newModel := ( self modelClassFor: aSymbol hasDefinition: hasDefinition )						package: self fullSymbol: aSymbol.	( oldModel := self modelAtSymbol: aSymbol ifAbsent: [ nil ] ) notNil		ifTrue: 			[ newModel cloneFrom: oldModel.			self removeModel: oldModel			].	self addModel: newModel.	^newModel</body><body package="PackageCategories">modelAtFullSymbol: fullSymbol hasDefinition: hasDefinition 	"Return the namespace/class model for the fully qualified symbol.	If one does not exist create one.  'hasDefinition' is a hint that it is known that 	the namespace/class's definition is in this package."	^models at: fullSymbol ifAbsent:		[ self installModelAtFullSymbol: fullSymbol hasDefinition: hasDefinition ].</body><body package="PackageCategories">modelAtName: string ifAbsent: absentBlock	^models at: string asSymbol ifAbsent: absentBlock.</body><body package="PackageCategories">modelAtSymbol: symbol ifAbsent: absentBlock	^models at: symbol ifAbsent: absentBlock.</body><body package="PackageCategories">modelClassFor: aSymbol hasDefinition: hasDefinition	^aSymbol asStrictReference value isBehavior		ifTrue: [ hasDefinition					ifTrue: [ DefClassModel ]					ifFalse: [ ExtensionClassModel ]				]		ifFalse: [ hasDefinition					ifTrue: [ DefNameSpaceModel ]					ifFalse: [ ExtensionNameSpaceModel ]				]</body><body package="PackageCategories">modelsDo: aBlock	models == nil ifTrue: [ ^self ].	models do: aBlock</body><body package="PackageCategories">removeDataKey: dataKey ownerSymbol: symbol 	"remove the data from package."	( self modelAtSymbol: symbol ifAbsent: [ ^self ] )		removeDataKey: dataKey</body><body package="PackageCategories">removeModel: model	models removeKey: model absoluteSymbol ifAbsent: nil.	Registry removeModel: model named: model absoluteSymbol</body><body package="PackageCategories">removeStatic: staticKey from: aClassOrNameSpace	"Remove aClassOrNameSpace.staticKey from the receiver."	self removeDataKey: staticKey ownerSymbol: aClassOrNameSpace absoluteSymbol</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-class model</category><body package="PackageCategories">addClassModel: classModel	"Add a classModel to the package."	self addModel: classModel</body><body package="PackageCategories">classModelAtClass: aClass hasDefinition: hasDefinition 	"Return the class model for the class 'aClass'.	If one does not exist create one.  'hasDefinition' is a	hint that it is known that the class's definition is in	this package."	| class |	class := aClass isMeta				ifTrue: [aClass soleInstance]				ifFalse: [aClass].	^self modelAtFullSymbol: class absoluteSymbol hasDefinition: hasDefinition</body><body package="PackageCategories">classModelAtClass: aClass ifAbsent: absentBlock	^self classModelAtClassSymbol: aClass instanceBehavior absoluteSymbol ifAbsent: absentBlock.</body><body package="PackageCategories">classModelAtClassName: className hasDefinition: hasDefinition 	"Return the class model for the class 'aClass'.	If one does not exist create one.  'hasDefinition' is a	hint that it is known that the class's definition is in	this package."	^self classModelAtClassSymbol: className asClassNameOnly asSymbol hasDefinition: hasDefinition</body><body package="PackageCategories">classModelAtClassName: aClassName ifAbsent: absentBlock		| model |	model := self 		classModelAtClassSymbol: aClassName asClassNameOnly asSymbol 		ifAbsent: [^absentBlock value].	^model isForClass 		ifTrue: [model] 		ifFalse: [absentBlock value]</body><body package="PackageCategories">classModelAtClassNamed: aClassName ifAbsent: absentBlock	^self classModelAtClassSymbol: aClassName asClassNameOnly asSymbol ifAbsent: absentBlock</body><body package="PackageCategories">classModelAtClassSymbol: fullClassSymbol hasDefinition: hasDefinition 	"Return the class model for the class 'aClass'.	If one does not exist create one.  'hasDefinition' is a hint that it is known that 	the class's definition is in this package."	^models at: fullClassSymbol ifAbsent:		[ self installClassModelAtFullClassSymbol: fullClassSymbol hasDefinition: hasDefinition ].</body><body package="PackageCategories">classModelAtClassSymbol: classSymbol ifAbsent: absentBlock	^models at: classSymbol ifAbsent: absentBlock.</body><body package="PackageCategories">classModels	models == nil ifTrue: [^OrderedCollection new].	^(models select: [:model | model isClassModel]) asOrderedCollection</body><body package="PackageCategories">classModelsDo: aBlock	models == nil ifTrue: [ ^self ].	models do: 		[ :model | model isClassModel ifTrue: [ aBlock value: model ] ]</body><body package="PackageCategories">definedClassModels	models == nil ifTrue: [^OrderedCollection new].	^(self classModels select: [:cm | cm hasDefinition]) asOrderedCollection</body><body package="PackageCategories">extendedAndOverrideModels	models ifNil: [^OrderedCollection new: 1].	^(models reject: 		[:each | 		each hasDefinition and: 			[(Override isOverriddenClassOrNameSpace: each actual)				ifTrue:[Override isOverriddenClassOrNameSpace: each actual in: self]				ifFalse: [true]]]) asOrderedCollection</body><body package="PackageCategories">extendedClassModels	models == nil ifTrue: [^OrderedCollection new: 1].	^(self classModels reject: [:cm | cm hasDefinition]) asOrderedCollection</body><body package="PackageCategories">extendedClasses	models ifNil: [^OrderedCollection new: 1].	^(self classModels reject: [:each | each hasDefinition]) collect: [:each | each actual]</body><body package="PackageCategories">extendedNameSpaceModels	models == nil ifTrue: [^OrderedCollection new: 1].	^(self nameSpaceModels reject: [:model | model hasDefinition]) asOrderedCollection</body><body package="PackageCategories">installClassModelAtFullClassSymbol: aClassSymbol hasDefinition: hasDefinition 	"This is the ONLY place new class models are created."	"Cloning must occur before installation."	| newCm oldCm |	newCm := (hasDefinition				ifTrue: [DefClassModel]				ifFalse: [ExtensionClassModel])				package: self fullClassSymbol: aClassSymbol.	oldCm := self classModelAtClassSymbol: aClassSymbol ifAbsent: [ nil ].	oldCm notNil		ifTrue: 			[ newCm cloneFrom: oldCm.			self removeClassModel: oldCm			].	self addClassModel: newCm.	^newCm</body><body package="PackageCategories">namespaceModelAtNamespace: aNamespace ifAbsent: absentBlock	^models at: aNamespace absoluteSymbol ifAbsent: absentBlock.</body><body package="PackageCategories">removeClassModel: cm	self removeModel: cm</body><body package="PackageCategories">removeWholeSymbol: symbol 	"Remove a definition model and all methods/datakeys defined wherein	This methods removes both class and metaclass."	self removeModel: ( self modelAtSymbol: symbol ifAbsent: [ ^self ] )</body><body package="PackageCategories">renameClassModel: cm as: newName	self removeClassModel: cm.	cm className: newName.	self addClassModel: cm</body><body package="PackageCategories">renameModel: cm as: newName	self removeModel: cm.	cm fullName: newName.	self addModel: cm</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-namespace model</category><body package="PackageCategories">addObject: aNameSpace 	"This is for polymorphism with Parcels."	aNameSpace isNameSpace ifFalse: 		[self error: #invalidObjectType &lt;&lt; #dialogs &gt;&gt; 'invalid object type'].	XChangeSet current addNameSpaceDefinition: aNameSpace toPackage: self</body><body package="PackageCategories">dataForNameSpaceName: nameSpaceName 	^( self modelAtSymbol: nameSpaceName ifAbsent: [ ^ OrderedCollection new: 0 ] )			dataKeys asOrderedCollection</body><body package="PackageCategories">definedNameSpaceModels	models == nil ifTrue: [^OrderedCollection new].	^(self nameSpaceModels select: [:model | model hasDefinition]) asOrderedCollection</body><body package="PackageCategories">nameSpaceModels	models == nil ifTrue: [ ^OrderedCollection new ].	^models select: [ :model | model isNameSpaceModel ]</body><body package="PackageCategories">nameSpaceModelsDo: aBlock	models == nil ifTrue: [ ^self ].	models do: 		[ :model | model isNameSpaceModel ifTrue: [ aBlock value: model ] ]</body><body package="PackageCategories">removeDefinitionFullNameSpaceSymbol: symbol 	"Remove a namespace definition."	| model |	model := self modelAtSymbol: symbol ifAbsent: [ ^self ].	model hasDefinition ifTrue: 		[ model := self installModelAtFullSymbol: model absoluteSymbol hasDefinition: false ].	model isEmpty ifTrue: [ self removeModel: model ]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-class model changes</category><body package="PackageCategories">addClass: class 	"Add a class to myself."	XChangeSet current addClassDefinition: class toPackage: self</body><body package="PackageCategories">addDataKey: dataKey symbol: symbol 	"add the data into package."	( self modelAtFullSymbol: symbol hasDefinition: false )		addDataKey: dataKey</body><body package="PackageCategories">addFullClassSymbol: fullClassSymbol 	"Add class."	| cm |	cm := self modelAtFullSymbol: fullClassSymbol hasDefinition: true.	cm hasDefinition 		ifFalse: 			[self installClassModelAtFullClassSymbol: cm fullClassSymbol				hasDefinition: true.			self recompileMethodsFor: cm].</body><body package="PackageCategories">addName: dataKey in: anObject 	"For parcel compatibility during binary loading."	(Override isOverriddenStatic: dataKey in: anObject)		ifTrue: [anObject isBehavior				ifTrue: [XChangeSet current						changeDataKey: dataKey						class: anObject						package: self]				ifFalse: [XChangeSet current						changeDataKey: dataKey						nameSpace: anObject						package: self]]		ifFalse: [anObject isBehavior				ifTrue: [XChangeSet current						addDataKey: dataKey						class: anObject						package: self]				ifFalse: [XChangeSet current						addDataKey: dataKey						nameSpace: anObject						package: self]]</body><body package="PackageCategories">addSelector: aSymbol class: aBehavior 	"Add the selector aSymbol for aBehavior to myself."	"Used during binary load."	(Override isOverriddenSelector: aSymbol class: aBehavior)		ifTrue: [XChangeSet current				changeSelector: aSymbol				class: aBehavior				toPackage: self]		ifFalse: [XChangeSet current				addSelector: aSymbol				class: aBehavior				toPackage: self]</body><body package="PackageCategories">addSelector: aSymbol fullClassSymbol: fullClassSymbol meta: meta 	"add the method into package."	(self modelAtFullSymbol: fullClassSymbol hasDefinition: false)		addSelector: aSymbol meta: meta</body><body package="PackageCategories">addSelector: selector toClass: aClass	"Add aClass&gt;&gt;selector to the receiver."	XChangeSet current moveSelector: selector class: aClass toPackage: self</body><body package="PackageCategories">addSelectors: aCollection forClass: aBehavior 	"Add all of the selectors for aBehavior in aCollection to myself."	aCollection do: [:selector | self addSelector: selector class: aBehavior]</body><body package="PackageCategories">markModificationAsRemoves: aCollectionOfDefinitions	"Give a collection of modification modify the package change set to contian 	removes of all definitons."	| cs tags |	cs := self changeSet.	tags := aCollectionOfDefinitions collect: [:mod|  mod tag].	tags :=  tags reject: [:tag | tag isCommentTag or: [tag isClassTag and: [tag isMeta]]].	tags do: 		[ :tag | | removeChange |		removeChange := tag asChange.		tag isClassTag | tag isNameSpaceTag			ifTrue: 				[ removeChange removeDefinition.				cs doChange: removeChange				]			ifFalse: 				[ tag isComponentTag					ifTrue: [ removeChange remove ]					ifFalse: 						[ tag isSubdefTag							ifTrue: 								[ removeChange meta: tag isMeta.								removeChange remove.								tag isDataTag 									ifTrue: [ removeChange dataKey: tag dataKey ].								tag isMethodTag 									ifTrue: [ removeChange selector: tag selector ].								cs doSubdefChange: removeChange								]							ifFalse: [ self error: (#WrongModificationType &lt;&lt; #packages &gt;&gt; 'Wrong modification type.') ]					]				]		]</body><body package="PackageCategories">removeDefinitionFullClassSymbol: classSymbol 	"Remove a class definition."	| cm |	cm := self classModelAtClassSymbol: classSymbol ifAbsent: 		[	| symbol obj |		symbol := ('* class' match: classSymbol) ifTrue: [classSymbol asClassNameOnly] ifFalse: [classSymbol].		 obj := symbol asQualifiedReference ifDefinedDo: [ :value | value ] elseDo: [ ^self ].		^Override removeOverridesForClassOrNameSpaceDefinition: obj in: self].	cm hasDefinition 		ifTrue: [ cm := self installClassModelAtFullClassSymbol: cm fullClassSymbol hasDefinition: false ].	cm isEmpty 		ifTrue: [ self removeClassModel: cm ]		ifFalse: ["There are methods left which are now extensions"				self recompileMethodsFor: cm].</body><body package="PackageCategories">removeWholeClassSymbol: classSymbol 	"Remove a class definition and all methods defined in a class. 	This methods removes both class and metaclass."	self removeClassModel: (self classModelAtClassSymbol: classSymbol ifAbsent: [^self])</body></methods><methods><class-id>Store.PackageModel</class-id> <category>printing</category><body package="PackageCategories">classDescription	"Answer a string for describing  the class."	^(#Package &lt;&lt; #packages &gt;&gt; 'Package') asString</body><body package="PackageCategories">displayString	"Answer the string to be displayed for a package in a Package list."	| stream |	stream := WriteStream on: ( String new: 32 ).	stream nextPutAll: self name.	self hasBeenModified ifTrue: [ stream nextPutAll: ' *' ].	self hasExtensions      ifTrue: [ stream nextPutAll: ' +' ].	self hasCodeOverridden ifTrue: [ stream nextPutAll: ' -' ].	^stream contents</body><body package="PackageCategories">printOn: aStream		aStream nextPut: $[;		nextPutAll: (name isNil ifTrue: [(#unnamed &lt;&lt; #packages &gt;&gt; '*unnamed*') asString] ifFalse: [name]);		nextPut: $].</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-descriptors</category><body package="PackageCategories">affectedClassNamesMeta: meta	"Answer a collection of changed  class name symbols."	"Note that this is only called when comparing dbs, so the changeset must have already been validated."	^self isChangeSetEmpty		ifTrue: [OrderedCollection new]		ifFalse: [self changeSet affectedClassNamesMeta: meta]</body><body package="PackageCategories">affectedNameSpaceNames	"Answer a collection of changed  namespace name symbols."	"Note that this is only called when comparing dbs, so the changeset must have already been validated."	^self isChangeSetEmpty		ifTrue: [ OrderedCollection new ]		ifFalse: [ self changeSet affectedNameSpaceNames ]</body><body package="PackageCategories">modifiedAndReorganizedMethodDescriptors	| methods |	self isChangeSetEmpty ifTrue: [^OrderedCollection new].	methods := self changeSet modifiedMethodDescriptors.	methods addAll: self reorganizedMethodDescriptors.	^methods asSet asOrderedCollection</body><body package="PackageCategories">modifiedDatumDescriptors	^self isChangeSetEmpty		ifTrue: [OrderedCollection new]		ifFalse: [self changeSet modifiedDatumDescriptors]</body><body package="PackageCategories">removedClassOrDefinitionNames	"Answer a collection of class names that have been removed	from the receiver."	^self isChangeSetEmpty		ifTrue: [ Array new ]		ifFalse: [ self changeSet removedClassOrDefinitionNames ]</body><body package="PackageCategories">removedDatumDescriptors	^self isChangeSetEmpty		ifTrue: [Array new]		ifFalse: [self changeSet removedDatumDescriptors]</body><body package="PackageCategories">removedMethodDescriptors	^self isChangeSetEmpty		ifTrue: [Array new]		ifFalse: [self changeSet removedMethodDescriptors]</body><body package="PackageCategories">removedNameSpaceOrDefinitionNames	^self isChangeSetEmpty		ifTrue: [Array new]		ifFalse: [self changeSet removedNameSpaceOrDefinitionNames]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>queries</category><body package="PackageCategories">dataKeysForName: aClassOrNameSpaceName		^( self modelAtName: aClassOrNameSpaceName ifAbsent: [ ^#( ) ] ) 		dataKeys</body><body package="PackageCategories">definedBindings	"Answer a dictionary of bindings (NameSpace/Class to datakey) contained in the receiver.	Note- duplicates Parcel format."		| bindings keys |	bindings := IdentityDictionary new.	self modelsDo: 		[:each | 		(keys := each dataKeys) size &gt; 0 ifTrue: [bindings at: each actual put: (IdentitySet withAll: keys)]].	Override overriddenStaticsDo:		[:each | (each sources includes: self) ifTrue: [(bindings at: each definitionMessage receiver ifAbsentPut: [IdentitySet new]) add: each key]].	^bindings</body><body package="PackageCategories">definedBindingsFor: aClassOrNameSpace	"Answer an Array of bindings."	^( self modelAtName: aClassOrNameSpace absoluteName ifAbsent: [ ^#() ] ) 		dataKeys collect: [ :key | aClassOrNameSpace bindingFor: key ]</body><body package="PackageCategories">definedBindingsIncludingUninstalled	| bindings |	bindings := self definedBindings.	self relatedParcel ifNotNil: 		[self relatedParcel uninstalledBindings associationsDo: [:eachAssociation | bindings add: eachAssociation]].	^bindings</body><body package="PackageCategories">definedClasses	"Answer a collection of all Classes whose definition is contained in the receiver."	^self classesDefinedInPackage collect: 		[ :each | each actual ].</body><body package="PackageCategories">definedClassesDo: aBlock 		self classModelsDo:		[ :model |		model hasDefinition 			ifTrue: [ aBlock value: model actual ]		].</body><body package="PackageCategories">definedNameSpaces	"Answer a collection of all NameSpaces whose definition is contained in the receiver."	^self nameSpacesDefinedInPackage collect: 		[ :each | each nameSpace ].</body><body package="PackageCategories">definedObjectsDo: aBlock	^self definedNameSpaces do: aBlock</body><body package="PackageCategories">definedSelectorsFor: aBehavior	"Answer an Array of selectors."	^( self modelAtName: aBehavior absoluteName asClassNameOnly ifAbsent: [ ^#() ] ) 		selectorsMeta: aBehavior isMeta</body><body package="PackageCategories">definesClassOrNameSpace: aClassOrNameSpace	^self includesSymbol: aClassOrNameSpace absoluteName asSymbol</body><body package="PackageCategories">definesName: key in: nameSpace	^self includesDataKey: key owner: nameSpace</body><body package="PackageCategories">definesObject: aNameSpace	| theNameSpacesAbsoluteName |	theNameSpacesAbsoluteName := aNameSpace absoluteName.	self nameSpaceModelsDo:		[:model |		(model hasDefinition		and: [model absoluteName = theNameSpacesAbsoluteName]) ifTrue:			[^true]].	^false</body><body package="PackageCategories">definesSelector: aSelector forClass: aBehavior 	| model |	model := self classModelAtClassSymbol: aBehavior instanceBehavior absoluteSymbol					ifAbsent: nil.	^model ~~ nil	and: [model includesSelector: aSelector meta: aBehavior isMeta]</body><body package="PackageCategories">selectorsMeta: isMeta forClassName: className		^(self		modelAtName: className		ifAbsent: [^#()]) selectorsMeta: isMeta</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing browser</category><body package="PackageCategories">allClasses	"Return a Collection of ClassDescriptor objects for all classes that	are defined in the package and extension descriptors for classes for	which only methods are defined."	| list overs |	list := self classesDefinedInPackage, self classesExtendedInPackage.	overs := ( ( Override overridesForComponent: self )  select:				[ : over | ( over isForClass | over isForMethod ) | ( over isForGeneral and: [ over owner isForClass ] ) ]			) collect: [ :over | over asPseudoRecord ].	( list := list asSet ) addAll: overs.	^list asOrderedCollection</body><body package="PackageCategories">allMetaclasses	"Answer a collection of class names. The collection contains 	names for classes that are defined in the package and names 	of classes for which methods are defined"	| list overs |	list := self metaclassesDefinedInPackage, self metaclassesExtendedInPackage.	overs := ( ( Override overridesForComponent: self ) select:				[ : over | over isForClass ]			) collect: [ :over | over asPseudoRecord meta: true ].	list addAll: overs asSet asOrderedCollection.	^list</body><body package="PackageCategories">allNameSpaces	"Returns a Set of NameSpaceDescriptor objects for all for name spaces	that are defined in the package and extension descriptors for name spaces	for which only data is defined."	| list overs |	list := self nameSpacesDefinedInPackage, self nameSpacesExtendedInPackage.	overs := ( ( Override overridesForComponent: self )  select:				[ : over | over isForNameSpace | ( over isForGeneral and: [ over owner isForNameSpace ] ) ]			) collect: [ :over | over asPseudoRecord ].	( list := list asSet ) addAll: overs.	^list asOrderedCollection</body><body package="PackageCategories">allShareds	^self dataAsArray</body></methods><methods><class-id>Store.PackageModel</class-id> <category>consistency checking</category><body package="PackageCategories">makeConsistent	self isChangeSetEmpty 		ifFalse: [ self changeSet makeConsistentForPackage: self ].</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-file out</category><body package="PackageCategories">createOrFindExpression	"Answer a string that when evaluated will instantiate the receiver - creating, if neccessary."	^'( Store.Registry packageNamedOrCreate: ', self name printString, ' ) '.</body><body package="PackageCategories">fileOutClassesOn: aFileManager 	"New classes or classes with new definitions."	| cset |	cset := self classesDefinedInPackage collect: [ :each | each myClass ].	cset := cset reject: [ :c | c == nil ].	cset addAll: self overriddenClasses.	cset := SystemUtils sortForLoading: cset.	cset do: 		[ :each | 		each fileOutDefinitionOn: aFileManager.		each fileOutCommentOn: aFileManager.		IncrementNotification raiseSignal.		].</body><body package="PackageCategories">fileOutDataOn: aFileManager 	"File-out data for every namespace/class. Order is not important."	self modelsDo:		[ :model |		model datumDescriptors do:			[ :dd | 			dd fileOutOn: aFileManager. 			aFileManager cr.			IncrementNotification raiseSignal.			].		model datumDescriptors notEmpty ifTrue: [aFileManager cr]		].	self overriddenStatics do:		[ :dd |			dd fileOutOn: aFileManager. 			aFileManager cr.		]</body><body package="PackageCategories">fileOutMethodsOn: aFileManager 	"First group methods by class and protocol 	and the ask aFileManager to do the job class by class"	| toFileOut byClass byProtocol |	toFileOut := Dictionary new.	self methods do: 		[ :each | 		byClass := toFileOut at: each implementingClass ifAbsent: [ Dictionary new ].		byProtocol := byClass at: each protocolName ifAbsent: [ Set new ].		byProtocol add: each.		byClass at: each protocolName put: byProtocol.		toFileOut at: each implementingClass put: byClass.		( each selector = #initialize and: [ each implementingClass isMeta] )			ifTrue: [ aFileManager initializeThisClass: each implementingClass instanceBehavior ]		].	( self sortForFileout: toFileOut keys ) do:		[ :cls | | dict |		dict := toFileOut at: cls.		aFileManager			fileOutTTMessages: dict			for: cls fullName			logging: false.		aFileManager cr.		IncrementNotification signalWith: 			( dict inject: 0 into: [ :s :c | s + c size ] )		].</body><body package="PackageCategories">fileOutNameSpacesOn: aFileManager 	"New namespaces or namespaces with new definitions."	| cset |	cset := self nameSpacesDefinedInPackage collect: 		[ :each | each nameSpace ].	cset addAll: self overriddenNameSpaces.	cset size &gt; 0 ifFalse: [ ^self ].	cset := SystemUtils sortForLoading: cset.	cset do: 		[ :each | 		each fileOutDefinitionOn: aFileManager.		each fileOutCommentOn: aFileManager.		IncrementNotification raiseSignal.		].</body><body package="PackageCategories">fileOutOn: aFileManager	"File out package on aFileManager"		| commentString |	commentString := #Package1s &lt;&lt; #packages &gt;&gt; 'Package &lt;1s&gt;' expandMacrosWith: self itemString.	MessageNotification raiseSignal: commentString.	aFileManager createdComponent: self.	aFileManager addComment: commentString.	(#{Store.StoreSettings} ifDefinedDo: [:object | object preferenceFor: #fileoutOption] elseDo: [nil]) == #never ifFalse:		[(aFileManager sourceFormatter)			attributeFor: #package compute: [:ignore | self name];			attributeForMethods: #package compute: [:ignore :moreIgnore | self name].		self fileOutPropertiesOn: aFileManager].	self fileOutNameSpacesOn: aFileManager.	self fileOutClassesOn: aFileManager.	self fileOutDataOn: aFileManager.	self fileOutMethodsOn: aFileManager.	IncrementNotification raiseSignal.	aFileManager cr</body><body package="PackageCategories">fileOutOn: aFileManagerwithoutRepeatingAnyOf: aSet	"File out package on aFileManager"	(aSet includes: self) ifTrue: [^self].	self fileOutOn: aFileManager</body><body package="PackageCategories">sortForFileout: classes	"Sort classes based on package inclusion in addition to normal sort."	| in out |	in := OrderedCollection new.	out := OrderedCollection new.	( SystemUtils metaclassesFirst: ( SystemUtils sortForLoading: classes ) ) do:		[ :cls | 		( self includesDefinitionOf: cls instanceBehavior absoluteName )			ifTrue: [ in add: cls ]			ifFalse: [ out add: cls ].		].	^in, out</body></methods><methods><class-id>Store.PackageModel</class-id> <category>initialize-release</category><body package="PackageCategories">initialize		super initialize.	models := IdentityDictionary new.</body><body package="PackageCategories">release	models notNil 		ifTrue: [ models copy do: [ :model | self removeModel: model ] ].	models := IdentityDictionary new.	Registry removePackage: self</body></methods><methods><class-id>Store.PackageModel</class-id> <category>unloading</category><body package="PackageCategories">preUnloadChecks	"Do checks for uses of classes in package."	^self preUnloadChecksFromBundle: nil</body><body package="PackageCategories">preUnloadChecksFromBundle: aBundle 	"unloading self can modify other code components. Report the problems and give a chance to cancel the unload.	 Possible problems are: modified containing bundle,	   removed subclasses, extension methods and shareds of removed classes,	   removed subnamespaces, classes and shareds in removed namespaces"	| probSubclass probExtensions bundles bndls probShareds probNamespaces leafItems definedClasses definedNameSpaces |	probSubclass := Set new.	probExtensions := Set new.	probShareds := Set new.	probNamespaces := Set new.	bndls := Registry enclosingComponentsFor: self.	leafItems := aBundle isNil ifTrue: [#()] ifFalse: [aBundle leafItems].	definedClasses := aBundle isNil ifTrue: [self definedClasses] ifFalse: [aBundle definedClasses].	definedNameSpaces := aBundle isNil ifTrue: [self definedNameSpaces] ifFalse: [aBundle definedNameSpaces].	aBundle notNil 		ifTrue: [ bndls remove: aBundle ifAbsent: 					[ aBundle allContainedItems do: [ :b | bndls remove: b ifAbsent: [] ] ].			   ].	bundles := bndls collect: [:bndl | bndl name].	self classModelsDo: 		[ :cm | | pkgClass |		pkgClass :=  cm actualClass.		( cm hasDefinition and: [ (self isClassOrNamespace: pkgClass overriddenOutside: leafItems) not ] )			ifTrue: 				[self listProblemsInClass: pkgClass bundleLeafItems: leafItems bundleDefinedClasses: definedClasses foundSubclasses: probSubclass foundExtensions: probExtensions foundShareds: probShareds]		].	self nameSpaceModelsDo: 		[ :cm | | pkgNamespace |		pkgNamespace := cm actual.		(  cm hasDefinition and: [ (self isClassOrNamespace: pkgNamespace overriddenOutside: leafItems) not ] )			ifTrue: 				[self listProblemsInNamespace: pkgNamespace bundleLeafItems: leafItems bundleDefinedClasses: definedClasses bundleDefinedNamespaces: definedNameSpaces  foundSubclasses: probSubclass foundNamespaces: probNamespaces  foundShareds: probShareds]		].	(self unloadProblemsQuery: bundles header: ((#UnloadingPackageWillModifyBundles &lt;&lt; #packages &gt;&gt; 'The package to be unloaded, "&lt;1s&gt;", is contained in the bundles&lt;n&gt;listed below.  Proceeding will modify these bundles.')			expandMacrosWith: self name))		ifFalse: [^false].	(self unloadProblemsQuery: probSubclass header: ((#UnloadingPackageWillRemoveClasses &lt;&lt; #packages &gt;&gt; 'Proceeding will remove the following classes which are not in "&lt;1s&gt;", the package to be unloaded:')			expandMacrosWith: self name))		ifFalse: [^false].	(self unloadProblemsQuery: probExtensions header: ((#UnloadingPackageWillRemoveMethods &lt;&lt; #packages &gt;&gt; 'Proceeding will remove the following methods which are not in &lt;n&gt;"&lt;1s&gt;", the package to be unloaded:')			expandMacrosWith: self name))		ifFalse: [^false].	(self unloadProblemsQuery: probNamespaces header: ((#UnloadingPackageWillRemoveNamespaces &lt;&lt; #packages &gt;&gt; 'Proceeding will remove the following namespaces which are not in &lt;n&gt;"&lt;1s&gt;", the package to be unloaded:')			expandMacrosWith: self name))		ifFalse: [^false].	(self unloadProblemsQuery: probShareds header: ((#UnloadingPackageWillRemoveShareds &lt;&lt; #packages &gt;&gt; 'Proceeding will remove the following shared variables which are not in &lt;n&gt;"&lt;1s&gt;", the package to be unloaded:')			expandMacrosWith: self name))		ifFalse: [^false].	^self shouldTrackChanges 		ifTrue: [ self checkChangeSet ]		ifFalse: [ true ].</body><body package="PackageCategories">preUnloadChecksThorough	"Do extensive check for uses of classes in package."" ******* out of date, but keep for logic ************	| problems cmeths |	problems := SortedCollection new.	Cursor execute showWhile: [classes			do: 				[:className | 				| classAssoc classSym |				classSym := className asSymbol.				classAssoc := Smalltalk associationAt: classSym.				classAssoc value subclasses do: [:class | (self includesClassNamed: class name asString)						ifFalse: [problems add: class name , ' is a subclass of ' , className]].				Smalltalk allBehaviorsDo: [:class | (self includesClassNamed: class name)						ifFalse: 							[| list |							list := class whichSelectorsReferTo: classAssoc.							list size &gt; 0 ifTrue: [list do: [:sel | (self includesSelector: sel class: class)										ifFalse: [problems add: class name , '&gt;&gt;' , sel , ' uses ' , className]]]]].				cmeths := classToSelectors at: classSym ifAbsent: [Set new].				classAssoc value selectors do: [:sel | (cmeths includes: sel)						ifFalse: [problems add: className , '&gt;&gt;' , sel , ' is an extension from ' , (PackageModel containingPackageForSelector: sel class: classAssoc value) name]]]].	^self unloadProblemsQuery: problems********************* "</body><body package="PackageCategories">runRearguard	"Check if this package can be safetly unloaded from the image."	^true</body><body package="PackageCategories">systemRemoveSelector: aSymbol fromClass: aClass	"Remove the message whose selector is aSymbol from the method	dictionary of the receiver, if it is there.  Answer nil otherwise."	"RGF 8/5/94 Bernstein:	Based on 'ClassDescription&gt;&gt;removeSelector:' and 	'Behavior&gt;&gt;removeSelector:'.  	Changed to remove write to changes file.  	Notification of change set also removed."	(aClass includesSelector: aSymbol) ifFalse: [^nil].	aClass removeSelectorSimply: aSymbol.	aClass organization removeElement: aSymbol.</body><body package="PackageCategories">unloadFromImage	"Remove content of a package from the image. 	Answer true if the operation has succeeded."	self cleanse.	Cursor execute showWhile: 		[ self runPreUnload ifFalse: [ ^false ].		self preUnloadChecks ifFalse: [ ^false ].		self doUnloadFromImage].	^true</body><body package="PackageCategories">unloadSourceSafely	(properties at: #sourceIndex ifAbsent: nil) ifNotNil: 			[:sourceIndex | 			(SourceFileManager default)				rescueOrphanedSourcesAt: sourceIndex excluding: Set new;				discardSourceAt: sourceIndex]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing</category><body package="PackageCategories">actualClassInPackageNamed: aClassName 	^(self classModelAtClassName: aClassName ifAbsent: [^nil]) actualClass</body><body package="PackageCategories">allDefinedClasses	"Answer a collection of classes that are defined in the receiver including those overridden."	| list overs |	list := self classesDefinedInPackage collect: [ :cd | cd actual ].	overs := ( ( Override overridesForComponent: self )  select:				[ : over | over isForClass ]			) collect: [ :over | over object ].	( list := list asSet ) addAll: overs.	list remove: nil ifAbsent: nil.	^list asOrderedCollection</body><body package="PackageCategories">allItems	^Array with: self</body><body package="PackageCategories">allMethodsAsArray	"Answer a collection of method descriptors and overridden methods.	This method is used for the DB package creation. This version also gathers up any and all methods that	may be uninstalled in a related Parcel"		| methods |	methods := self methods.	self relatedParcel ifNotNil: 		[:value |		| uninstalledMethods |		uninstalledMethods := value properties at: #uninstalledMethods ifAbsent: [#()].		uninstalledMethods do:			[:each |			| methodDescriptor |			methodDescriptor := MethodDescriptor fromSelector: each selector className: each mclass absoluteName meta: each mclass isMeta.			methodDescriptor protocol: each protocol.			methods add: methodDescriptor]].	^methods</body><body package="PackageCategories">classInPackageNamed: aClassName 	^(self includesClassNamed: aClassName)		ifTrue: [ClassDescriptor fullName: aClassName meta: false]		ifFalse: [nil]</body><body package="PackageCategories">classInPackageNamed: aClassName meta: aBoolean	^(self includesClassNamed: aClassName)		ifTrue: [ClassDescriptor fullName: aClassName meta: aBoolean] 		ifFalse: [nil]</body><body package="PackageCategories">data	"Returns a Collection of DatumDescriptor objects, for every shared variable	defined in the package. These may be either shared variables that belong to	a name space, or to a class."	| dd |	dd := OrderedCollection new.	self nameSpaceModelsDo: [:cm | dd addAll: cm datumDescriptors].	self classModelsDo: [:cm | dd addAll: cm datumDescriptors].	^dd</body><body package="PackageCategories">dataAsArray	"Answer a collection of DatumDescriptors."	"This method is used for the DB package creation."	^self data		addAll: self overriddenStatics;		yourself.</body><body package="PackageCategories">dataInstances	"Returns the actual instances associated to the class/key pairs"	^self data collect: [:dd | dd fullName asStrictReference valueOrDo: [nil]]</body><body package="PackageCategories">dataWithSource	"For the image model this is the same as data."	^self dataAsArray.</body><body package="PackageCategories">environmentFor: aStoreMethod 	^aStoreMethod environment isNil 		ifTrue: [self environmentFor: aStoreMethod selector in: aStoreMethod implementingClass]		ifFalse: [aStoreMethod environment valueOrDo: [nil]]</body><body package="PackageCategories">environmentFor: aSelector in: aClass	"Return the environment for the method in question. If we should not define its scope, return nil"	(self includesDefinitionOf: aClass instanceBehavior absoluteName) ifTrue: [^nil].	aClass compiledMethodAt: aSelector ifAbsent: [^self environment].	^self environment.</body><body package="PackageCategories">inPackageNamed: aName 		"Answer a descriptor for the class/namespace aName"	^( self includesDefinitionOf: aName)		ifTrue: [ ( self descriptorClassFor: aName ) fullName: aName ] 		ifFalse: [ nil ]</body><body package="PackageCategories">itemCount	"Answer a count of work to be done. For now, count yourself + models."	^self methods size + self data size + models size + 1.</body><body package="PackageCategories">methods	"Returns a Collection of MethodDescriptor objects, for every method defined in the package."	| methods |	methods := OrderedCollection new.	self classModelsDo: 		[:each | 		methods addAll: (each methodsMeta: false).		methods addAll: (each methodsMeta: true)].	methods := methods reject: 		[:eachMethodDescriptor | 		self overriddenMethods contains: [:eachOverride | eachMethodDescriptor comparesTo: eachOverride]].	methods addAll: self overriddenMethods.	^methods</body><body package="PackageCategories">methodsAsArray	"Answer a collection of method descriptors and overridden methods."	"This method is used for the DB package creation."	^self methods</body><body package="PackageCategories">methodsWithSource	"For image model same as methods since sources are already loaded."	"Only called during package comparison, so includes overrridden methods"	^self methodsAsArray.</body><body package="PackageCategories">mostPopularNameSpace	| classesByNameSpace |	self environment ifNotNil: [:packageScope | ^packageScope].	classesByNameSpace := self allDefinedClasses				groupedBy: [:each | each environment].	^classesByNameSpace isEmpty		ifTrue: 			[^self definedNameSpaces size = 1				ifTrue: 					[| singularNamespace |					singularNamespace := self definedNameSpaces first.					singularNamespace == Undeclared ifTrue: [nil] ifFalse: [singularNamespace]]				ifFalse: [nil]]		ifFalse: 			[(classesByNameSpace associations				fold: [:a :b | a value size &gt;= b value size ifTrue: [a] ifFalse: [b]]) key]</body><body package="PackageCategories">nameSpaceInPackageNamed: aName 	^( self includesNameSpaceNamed: aName )		ifTrue: [ NameSpaceDescriptor fullName: aName ]		ifFalse: [ nil ]</body><body package="PackageCategories">removeMethodDescriptor: aMethod	"Remove aMethod from a collection of methods	defined in the package."	| cm |	cm := self classModelAtClassName: aMethod className ifAbsent: [^self].	cm removeSelector: aMethod selector meta: aMethod className namesMetaClass.	cm isEmpty ifTrue: [self removeClassModel: cm]	.</body><body package="PackageCategories">toolListIconKey	^self		selectIconKeyDefault: #package 		modified: #modifiedPackage		noDBdefault: #packageNoDB 		modified: #modifiedPackageNoDB</body><body package="PackageCategories">withAllContainedItems	^(OrderedCollection with: self).</body><body package="PackageCategories">withContainedItems	^(OrderedCollection with: self).</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-differences calculation</category><body package="PackageCategories">classesNamed: aSetOfNames 	"Convert aSetOfnames into a collection of ClassDescriptor or ClassExtensionDescriptors."		| names selected |	names := aSetOfNames copy.	selected := SortedCollection sortBlock: [:x :y | x name &lt; y name].	self classesDefinedInPackage do: 		[ :cl | (names includes: cl absoluteName)				ifTrue: 				[ names remove: cl absoluteName.				selected add: cl				]		].	self metaclassesDefinedInPackage do: 		[ :cl | (names includes: cl absoluteName, ' class')			ifTrue: 				[names remove: cl absoluteName, ' class'.				selected add: cl]		].	names do: 		[ :nm|  selected add: ( ClassExtensionDescriptor fullName: nm meta: false ) ].	^selected</body><body package="PackageCategories">modificationsFor: dbid	"Answer my content as a collection of modifications."	^self basicModificationsFor: dbid</body><body package="PackageCategories">nameSpacesNamed: aSetOfNames 	"Convert aSetOfnames into a collection of NameSpaceDescriptor or NameSpacesExtensionDescriptors."		| names selected |	names := aSetOfNames copy.	selected := SortedCollection sortBlock: [:x :y | x name &lt; y name].	self nameSpacesDefinedInPackage do: 		[ :ns | (names includes: ns absoluteName)				ifTrue: 				[ names remove: ns absoluteName.				selected add: ns				]		].	names do: [:nm|  selected add: ((NameSpaceExtensionDescriptor new) fullName: nm; yourself)].	^selected</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private</category><body package="PackageCategories">checkUndeclared	self cleanse.	( models includesKey: Undeclared absoluteSymbol )		ifFalse: [ ^true ].	Undeclared purgeUnusedBindings.	^( models at: Undeclared absoluteSymbol ifAbsent: [ ^true ] ) 		dataKeys isEmpty</body><body package="PackageCategories">cleanse	"Cleanse the component. Remove any class or method definitions	 that are no longer in the system, including the postLoadMethod."	self cleanse: true.</body><body package="PackageCategories">cleanse: warn	"Cleanse the component. Remove any class or method definitions	 that are no longer in the system, including the postLoadMethod."	| warnBlock |	warnBlock := [ :str | warn ifTrue: [ Transcript show: ((#nRemovingNonexistant1s &lt;&lt; #packages &gt;&gt; '&lt;n&gt;Removing non-existant &lt;1s&gt;') expandMacrosWith: str)  ] ].	models keys do:		[ :key |		 key asStrictReference isDefined			ifFalse: 				[ warnBlock value: key.				models removeKey: key. 				].		].	self extendedClassModels do:		[ :model | 		model classAndSelectorDo:			[ :cls :selector | 			cls compiledMethodAt: selector ifAbsent: 				[ warnBlock value: ((#x1s2s &lt;&lt; #packages &gt;&gt; '&lt;1s&gt;%&gt;%&gt;&lt;2s&gt;')						expandMacrosWith: cls fullName						with: selector).				model removeSelector: selector meta: cls isMeta 				]			].		model classAndDataKeyDo:			[ :cls :key |			( cls includesDataKey: key )				ifFalse: [ warnBlock value: (cls fullName, '.', key).						model removeDataKey: key ]			]		].	self extendedNameSpaceModels do:		[ :model | 		model nameSpaceAndDataKeyDo:			[ :ns :key |			( ns includesDataKey: key )				ifFalse: [ warnBlock value: (ns fullName, '.', key).						model removeDataKey: key ]			]		].	models copy do:		[ :m | m isEmpty ifTrue: [ self removeModel: m ] ]</body><body package="PackageCategories">descriptionClass	^PackageDescription</body><body package="PackageCategories">doUnloadDefinitionsFromImage	"Remove the receiver's defined classes and namespaces from the image. 	Answer true if the operation has succeeded."		| classesAndNameSpaces |	classesAndNameSpaces := [self definedModels collect: [:cm | cm actual]]		on: UnloadedObjectError		do:			[:exception | 			StoreUnloadWarning raiseSignal: exception description.			exception resume].	classesAndNameSpaces := SystemUtils sortForLoading: (classesAndNameSpaces reject: [:each | each isNil]).	XMainChangeSet ignoreMainChangesWhile:		[classesAndNameSpaces reverseDo:			[:each | 			| change |			change := Change new removeChanges actual: each.			Override unloadClassOrNameSpace: each from: self.			XChangeSet current doChange: change]].	^true</body><body package="PackageCategories">doUnloadExtensionsFromImage	"Remove the class/namespace extensions of a package from the image. 	Answer true if the operation has succeeded."		| affectedClasses |	affectedClasses := Set new.	XMainChangeSet ignoreMainChangesWhile:		[SystemUtils modifySystem:			[self extendedAndOverrideModels do:				[:each | 				each unloadAllDataKeys.				each isForClass ifTrue: [affectedClasses addAll: each unloadAllSelectors]]]].	affectedClasses do: [:each | each instanceMethodsChanged].	^true</body><body package="PackageCategories">doUnloadFromImage	"Remove content of a package from the image.  Answer true if the operation has succeeded."	SystemUtils modifySystem: [		VerboseUnload == true ifTrue: [			Transcript cr; show: ((#UnloadingPackageC1s &lt;&lt; #packages &gt;&gt; 'Unloading package: &lt;1s&gt;')					expandMacrosWith: self name printString)].		self doUnloadExtensionsFromImage.		self doUnloadDefinitionsFromImage.		self release.		Smalltalk organization removeEmptyCategories.		Override removeOverridesForComponent: self.		Override cleanseLists.		self runPostUnload.		self cleanseRelatedParcel.		self unloadSourceSafely.		ChangeSet unloadPundle: self].	^true</body><body package="PackageCategories">manager	^Registry</body><body package="PackageCategories">models	^models</body><body package="PackageCategories">relinquishDataKey: aDataKey owner: aClassOrNameSpace	"Called only during parcel loading. Remove the selector without marking anything modified."	( self modelAtName: aClassOrNameSpace absoluteName ifAbsent: [ ^nil ] )		removeDataKey: aDataKey</body><body package="PackageCategories">relinquishSelector: aSelector class: aClass	"Called only during parcel loading. Remove the selector without marking anything modified."		(self		modelAtName: aClass instanceBehavior absoluteName		ifAbsent: [^nil])			removeSelector: aSelector			meta: aClass isMeta.</body><body package="PackageCategories">removeEmptyModels	models copy do: 		[ :model | 		model isEmpty			ifTrue: [ self removeModel: model ]		]</body><body package="PackageCategories">removeEmptyProtocols	self classModelsDo: 			[:cm | 			(cm selectorsMeta: false) isNil ifFalse: [cm actualClass organization removeEmptyCategories].			(cm selectorsMeta: true) isNil ifFalse: [cm actualClass class organization removeEmptyCategories]]</body><body package="PackageCategories">unloadSource	| sourceIndex |	((sourceIndex := properties at: #sourceIndex ifAbsent: nil) notNil) ifTrue:		[SourceFileManager default discardSourceAt: sourceIndex]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>table of contents</category><body package="PackageCategories">tableOfBundleContentsOn: aStream level: aLevel	aLevel timesRepeat: [aStream tab].	aStream nextPut: $"; nextPutAll: self name; nextPut: $"; cr.</body><body package="PackageCategories">tableOfContentsOn: aStream 	aStream nextPut: $"; nextPutAll: self name; nextPut: $"; cr.	self modelsDo: 		[ :model | 	| mname |		mname := model absoluteName.		model hasDefinition 			ifTrue: 				[ aStream tab.				model isForNameSpace ifTrue: [ aStream nextPut: $! ].				aStream nextPutAll: mname; cr 				].		model isForClass			ifTrue:				[ ( model selectorsMeta: false ) do: 					[ :selector | 					aStream tab; tab; 						nextPutAll: mname; nextPutAll: '&gt;'; 						nextPutAll: selector; cr					].				( model selectorsMeta: true ) do: 					[ :selector | 					aStream tab; tab; nextPut: $%; nextPutAll: mname; 						nextPutAll: '&gt;'; nextPutAll: selector; cr					]				].		model dataKeys do: 			[ :dataKey | 			aStream tab; tab; 				nextPutAll: mname; 				nextPutAll: '@'; 				nextPutAll: dataKey; cr.			]		].	aStream tab; nextPutAll: ';'; cr</body><body package="PackageCategories">tableOfContentsOnFile: aString	| strm |	strm := aString asFilename writeStream.	self tableOfContentsOn: strm.	strm close.</body></methods><methods><class-id>Store.PackageModel</class-id> <category>main change set access</category><body package="PackageCategories">doClassChange: change 	self	updateAfterDo: 		[ | classSymbol |		classSymbol := change fullClassSymbol.		change isRemove			ifTrue: 				[ self removeAllChangeSetClassSymbol: classSymbol.				self removeWholeClassSymbol: classSymbol				]			ifFalse: 				[ self changeSetsDo: 					[ :cs | cs doClassChange: change ].				change isRemoveDefinition					ifTrue: [ self removeDefinitionFullClassSymbol: classSymbol ].				change isAdd					ifTrue: [ self addFullClassSymbol: classSymbol ]				]		]</body><body package="PackageCategories">doNameSpaceChange: change 	"Apply the change to the receiver."	self updateAfterDo: 		[ | nsSymbol |		nsSymbol := change nameSpaceSymbol.		change isRemove			ifTrue: 				[ self removeAllChangeSetNameSpaceSymbol: nsSymbol.				self removeWholeSymbol: nsSymbol				]			ifFalse: 				[ self changeSetsDo: [ :cs | cs doNameSpaceChange: change ].				change isRemoveDefinition					ifTrue: [ self removeDefinitionFullNameSpaceSymbol: nsSymbol ].				change isAdd					ifTrue: [ self addFullSymbol: nsSymbol ]				]		]</body><body package="PackageCategories">doSubdefChange: change	"Apply the method/static change to the receiver." 	self updateAfterDo:		[| symbol |		self changeSetsDo: [:each | each doSubdefChange: change].		symbol := change symbol.		change isRemove			ifTrue:				[| model |				model := self modelAtSymbol: symbol ifAbsent: [nil].				model ifNotNil: 					[change isMethodChange 						ifTrue: [model removeSelector: change selector meta: change meta] 						ifFalse: [model removeDataKey: change dataKey].					model isEmpty ifTrue: [self removeModel: model]]]			ifFalse:				[change isAdd ifTrue:					[change isMethodChange						ifTrue: [self addSelector: change selector fullClassSymbol: symbol meta: change meta]						ifFalse: [self addDataKey: change dataKey symbol: symbol]]]]</body><body package="PackageCategories">removeAllChangeSetClassSymbol: classSymbol	"Propagate the removal of everything in this class which is not in 	another package to the package change sets."	| cm |	cm := self classModelAtClassSymbol: classSymbol ifAbsent: [ ^self ].	self updateAfterDo: 		[ | change |		change := ( Change new ) classSymbol: classSymbol.		cm hasDefinition 			ifTrue: [ self changeSetsDo: [ :cs | cs doChange: change remove "Definition" ] ].		change remove.		( cm selectorsMeta: false ) do: 			[ :selector | 			self changeSetsDo: [ :cs | cs doSubdefChange: ( change selector: selector; meta: false ) ]			].		( cm selectorsMeta: true ) do: 			[ :selector | 			self changeSetsDo: [ :cs | cs doSubdefChange: ( change selector: selector; meta: true ) ]			].		cm dataKeys do:			[ :key |			self changeSetsDo: [ :cs | cs doSubdefChange: ( change dataKey: key ) ]			]		]</body><body package="PackageCategories">removeAllChangeSetNameSpaceSymbol: nsSymbol	"Propagate the removal of everything in this namesapce which is not in 	another package to the package change sets."	| model |	model := self modelAtSymbol: nsSymbol ifAbsent: [ ^self ].	self updateAfterDo: 		[ | change |		change := (Change new) nameSpaceSymbol: nsSymbol.		model hasDefinition ifTrue: 			[ self changeSetsDo: [ :cs | cs doNameSpaceChange: change remove "Definition" ] ].		change remove.		( model dataKeys ) do: 			[ :dataKey | 			self changeSetsDo: [ :cs | cs doSubdefChange: (change dataKey: dataKey) ]			].		]</body><body package="PackageCategories">renameAllChangeSetClassSymbol: oldSymbol to: newSymbol 	"Propagate the removal of everything in this class which is not in 	another package to the package change sets."	| cm |	cm := self classModelAtClassSymbol: oldSymbol ifAbsent: [ ^self ].	self updateAfterDo: 		[ | removeChange addChange |		removeChange := Change new classSymbol: oldSymbol.		addChange := Change new classSymbol: newSymbol.		addChange add.		cm hasDefinition			ifTrue: 				[ self changeSetsDo: 					[ :cs | 					cs doChange: removeChange removeDefinition.					cs doChange: addChange					]				].		removeChange remove.		cm dataKeys do: 			[ :dataKey | 			self changeSetsDo: 				[ :cs | 				cs doSubdefChange: ( removeChange dataKey: dataKey ).				cs doSubdefChange: ( addChange dataKey: dataKey )				]			].		( cm selectorsMeta: false ) do: 			[ :selector | 			self changeSetsDo: 				[ :cs | 				cs doSubdefChange: ( removeChange selector: selector; meta: false ).				cs doSubdefChange: ( addChange selector: selector; meta: false ) 				]			].		( cm selectorsMeta: true ) do: 			[ :selector | 			self changeSetsDo: 				[ :cs | 				cs doSubdefChange: ( removeChange selector: selector; meta: true ).				cs doSubdefChange: ( addChange selector: selector; meta: true ) 				]			]		]</body><body package="PackageCategories">renameAllChangeSetNameSpaceSymbol: oldSymbol to: newSymbol 	"Propagate the removal of everything in this namespace which is not in 	another package to the package change sets."	| model |	model := self modelAtSymbol: oldSymbol ifAbsent: [ ^self ].	self updateAfterDo: 		[ | removeChange addChange |		removeChange := Change new nameSpaceSymbol: oldSymbol.		addChange := Change new nameSpaceSymbol: newSymbol.		addChange add.		model hasDefinition			ifTrue: 				[ self changeSetsDo: 					[ :cs | 					cs doChange: removeChange removeDefinition.					cs doChange: addChange					]				].		removeChange remove.		model dataKeys do: 			[ :dataKey | 			self changeSetsDo: 				[ :cs | 				cs doSubdefChange: (removeChange dataKey: dataKey).				cs doSubdefChange: (addChange dataKey: dataKey) 				]			].		]</body><body package="PackageCategories">renameClassSymbol: oldClassSymbol as: newClassSymbol 	| cm |	cm := self classModelAtClassSymbol: oldClassSymbol ifAbsent: [^self].	self renameAllChangeSetClassSymbol: oldClassSymbol to: newClassSymbol.	self renameModel: cm as: newClassSymbol.</body><body package="PackageCategories">renameNameSpaceSymbol: oldNameSpaceSymbol as: newNameSpaceSymbol 	| model |	model := self modelAtSymbol: oldNameSpaceSymbol ifAbsent: [ ^self ].	self renameAllChangeSetNameSpaceSymbol: oldNameSpaceSymbol to: newNameSpaceSymbol.	self renameModel: model as: newNameSpaceSymbol.</body></methods><methods><class-id>Store.PackageModel</class-id> <category>parcel support</category><body package="PackageCategories">copyContentsToParcel: parcel	"Copy contents (including any overridden contents) to the parcel.  (Strangely, packageClasses and packageNamespaces send actual to the models but not to the overrides - presumably they are called in some Store context where no more polymorphism is needed than exists between an override and an actual.  That is not the case here, so we must iterate separately.)"	self definedClassModels do: [:each | parcel addClass: each actual].	self overriddenClasses do: [:each | parcel addClass: each actual].	self definedNameSpaceModels do: [:each | parcel addNameSpace: each actual].	self overriddenNameSpaces do: [:each | parcel addNameSpace: each actual].	self methods do: [:each | parcel addSelector: each selector class: each myClass].	self dataAsArray do: [:each | parcel addName: each dataKey in: each owner].</body><body package="PackageCategories">dataNotInParcel: aParcel on: aStream	"Write method&gt;&gt;selectors contained in the receiver but not in a Parcel."	self modelsDo:		[ :model |		model dataKeys do:			[ :key |			( aParcel definesName: key in: model actual )				ifFalse: [ aStream nextPutAll: ( model name, '.', key ); cr ]			]		].</body><body package="PackageCategories">definedClassesExcludedSelectors	"Answer an IdentityDictionary of Class -&gt; &lt;Set of selectors&gt;	Parcel compatibility."		| selectorDictionary selectors |	selectorDictionary := IdentityDictionary new.	self definedClasses do:		[:eachClass | 		(Registry extensionClassModelsForClassSymbol: eachClass absoluteSymbol) do:			[:eachExtensionModel | 			selectors := eachExtensionModel selectorsMeta: false.			selectors := selectors reject: [:eachSelector | Override isOverriddenSelector: eachSelector class: eachClass in: self].			selectors isEmpty ifFalse: [(selectorDictionary at: eachClass ifAbsentPut: [Set new]) addAll: selectors].			selectors := eachExtensionModel selectorsMeta: true.			selectors := selectors reject: [:eachSelector | Override isOverriddenSelector: eachSelector class: eachClass class in: self].			selectors isEmpty ifFalse: [(selectorDictionary at: eachClass class ifAbsentPut: [Set new]) addAll: selectors]]].	^selectorDictionary</body><body package="PackageCategories">definedClassesNotInParcel: aParcel on: aStream	"Write classes whose definition is contained in the receiver but not in a Parcel."	| pclasses |	pclasses  := aParcel definedClasses.	self definedClassModels do:		[ :model |		( pclasses includes: model actual )			ifFalse: [ aStream nextPutAll: model name; cr ]		].</body><body package="PackageCategories">definedNameSpacesNotInParcel: aParcel on: aStream	"Write namespaces whose definition is contained in the receiver but not in a Parcel."	self definedNameSpaceModels do:		[ :model |		( aParcel definedObjects includes: model actual )			ifFalse: [ aStream nextPutAll: model name; cr ]		].</body><body package="PackageCategories">definedObjects	"Parcel compatibility"		| list |	list := self definedNameSpaces.	Override overriddenClassesAndNameSpacesDo: 		[:each | 		each isForNameSpace ifTrue: [(each sources includes: self) ifTrue: [list add: each]]].	^list</body><body package="PackageCategories">extensionMethods	"Answer an OrderedCollection of CompiledMethods	Parcel compatibility."		| result |	result := OrderedCollection new.	self extendedModels do:		[:eachClassModel | 		eachClassModel isForClass ifTrue: 			[eachClassModel methods do: 				[:eachMethodDescriptor | 				(Registry containingPackageForSelector: eachMethodDescriptor selector class: eachMethodDescriptor owner) = self					ifTrue: [result add: eachMethodDescriptor method]]]].	^result reject: [:each | each isNil]</body><body package="PackageCategories">extensionMethodsIncludingUninstalled	"Answer an IdentitySet of CompiledMethods"	| collection |	collection := self extensionMethods.	self relatedParcel ifNotNil: [collection addAll: self relatedParcel uninstalledMethods].	collection addAll: self overriddenMethods.	^collection</body><body package="PackageCategories">extensionsDo: aBlock 	"Evaluate aBlock with MethodDefinitions for all defined extension methods"	"Parcel compatibility."	| cls |	self extendedClassModels do:		[ :model |		cls := model actual.		( model selectorsMeta: true ) do:			[ :selector |	aBlock value: cls class value: selector ].		( model selectorsMeta: false ) do:			[ :selector |	aBlock value: cls value: selector ].		]</body><body package="PackageCategories">methodsFor: aClass do: aBlock 	"Evaluate aBlock with MethodDefinitions for all defined methods on this class"	| classModel cls |	classModel := aClass isBehavior 				ifTrue: [self classModelAtClass: aClass ifAbsent: [^self]]				ifFalse: [aClass "if not a class assume it's a model"].	cls := classModel actual.	(classModel selectorsMeta: true) 		do: [:selector | aBlock value: cls class value: selector].	(classModel selectorsMeta: false) 		do: [:selector | aBlock value: cls value: selector]</body><body package="PackageCategories">methodsNotInParcel: aParcel on: aStream	"Write method&gt;&gt;selectors contained in the receiver but not in a Parcel."	self classModels do:		[ :model |		model classAndSelectorDo:			[ :cls :sel |			( aParcel definesSelector: sel forClass: cls )				ifFalse: [ aStream nextPutAll: ( cls name, '&gt;&gt;', sel ); cr ]			]		].</body><body package="PackageCategories">namedObjects	^Dictionary new.</body><body package="PackageCategories">putStoredPropertiesIn: aDictionary 	"Put any PundleModel-specific properties into aDictionary for Parcel publishing."	super putStoredPropertiesIn: aDictionary. 	aDictionary 		at: #packageName put: name;		at: #dbTrace put: self dbTrace;		at: #dbUsername put: self dbUsernameOrDerived;		at: #dbVersion put: self dbVersionOrDerived;		at: #dbIdentifier put: self dbIdentifier.	#{Store.DbRegistry} 		ifDefinedDo: 	[:ignored | aDictionary at: #printStringCache put: self printStringCache]		elseDo: [|string|			string := self basicVersionString.			(string notNil and: [string notEmpty])				ifTrue: [aDictionary at: #printStringCache put: string]]</body><body package="PackageCategories">saveAsParcel: fullPathName saveStructure: saveStructure saveLinks: saveLinks	"Save the receiver as a parcel -without creating the parcel in the image.	fullPathName is a directory/parcelName with no extension.	If saveStructure is meaningless for packages	If saveLinks is true, save the db link."	| dir pname |	pname := fullPathName tail.	dir := fullPathName directory.	dir exists 		ifFalse:			[ ( Dialog confirm: ( (#CreateDirectory1s &lt;&lt; #packages &gt;&gt; 'Create directory &lt;1s&gt;?') expandMacrosWith: dir asString ) )				ifFalse: [ ^self ].			dir makeDirectory.			].	properties at: #packageName put: name.	self		parcelOutTo: ( dir  construct: ( pname, '.pcl' ) ) asString		sourceFileName: ( dir construct: ( pname, '.pst' ) ) asString.</body><body package="PackageCategories">saveAsParcel: aFilename saveStructure: unusedBoolean saveLinks: alsoUnusedBoolean parcelOptions: aDictionary	"Save the receiver as a parcel -without creating the parcel in the image.	fullPathName is a directory/parcelName with no extension.	saveStructure and save links is meaningless for packages with this method"		| parcelDirectory parcelName |	parcelName := aFilename tail.	parcelDirectory := aFilename directory.	parcelDirectory exists ifFalse:		[(Dialog confirm: (#CreateDirectory1s &lt;&lt; #packages &gt;&gt; 'Create directory &lt;1s&gt;?' expandMacrosWith: parcelDirectory asString)) 			ifFalse: [^self].		parcelDirectory makeDirectory].	properties at: #packageName put: name.	properties at: #parcel put: (Array with: parcelName).	self		parcelOutTo: (parcelDirectory construct: parcelName , '.pcl') asString		sourceFileName: (parcelDirectory construct: parcelName , '.pst') asString		parcelOptions: aDictionary</body></methods><methods><class-id>Store.PackageModel</class-id> <category>overrides</category><body package="PackageCategories">cleanUpOverrides	self overrides copy do:		[ :over | | obj |		( obj := over object ) == nil			ifFalse: 				[ ( ( over getSources: obj ) includes: self )					ifTrue: [ over silentlyRemove ]				].		].</body><body package="PackageCategories">comparesTo: aCodeComponent	"Answer true if the receiver is some version of aCodeComponent."	^aCodeComponent isPackage and: [ name = aCodeComponent name ].</body><body package="PackageCategories">notifyAdditionalOverridenStatic: aSymbol in: aNameSpaceOrClass	"We find any remaining overides for this static. If they are not in me,	and the source is a package (a source can be a Parcel, and that doesn't apply)	we detect if there IS a override in THAT source, and if so, in effect remove any #remove change set	items in that source by telling it that we have reinstalled it somewhere else"		| overrides |	(overrides := Override overridesForDataKey: aSymbol in: aNameSpaceOrClass) ifNil: [^self].	overrides do:		[:eachOverride | 		eachOverride sources do:			[:eachSource | 			(eachSource ~= self and: [eachSource isPackage]) ifTrue:				[(Override isOverriddenStatic: aSymbol in: aNameSpaceOrClass in: eachSource) ifTrue: 					[eachSource overriddenStatic: aSymbol in: aNameSpaceOrClass]]]]</body><body package="PackageCategories">overriddenClass: aClass	"The class definition has been redefined for another package."	".... the new definition has just been installed..."	self changeSetsDo: 		[ :cs | cs overriddenClass: aClass ].</body><body package="PackageCategories">overriddenNameSpace: aNameSpace	"The nameSpace definition has been redefined for another package."	".... the new definition  has just been installed	...."	self changeSetsDo: 		[ :cs | cs overriddenNameSpace: aNameSpace ].</body><body package="PackageCategories">overriddenSelector: aSymbol class: aClass	"aClass&gt;&gt;aSymbol has been redefined by another package.	Remove it from the underlying class model."	| model |	self changeSetsDo: [:each | each overriddenSelector: aSymbol class: aClass].	model := self modelAtSymbol: aClass instanceBehavior absoluteSymbol ifAbsent: [^self].	model removeSelector: aSymbol meta: aClass isMeta.	model isEmpty ifTrue: [self removeModel: model]</body><body package="PackageCategories">overriddenStatic: key in: aNameSpace	"aNameSpace.key defintion has been redefined for another package."	self changeSetsDo: 		[ :cs | cs overriddenStatic: key in: aNameSpace ].</body><body package="PackageCategories">reinstalledClass: aClass 	"A previously overriden class definition has been restored.	This may look odd: Why look for add and NOT remove it if it is there and DO remove it if it isn't?	The answer is, we want to preserve the state, and the move can change it from none to add.	So, if it WAS add, we don't want to remove it AFTER the move, if it WAS NOT add, we do want to clear it after the move"	| classChange removeChanges |	removeChanges := IdentityDictionary new.	self changeSetsDo:		[:eachChangeSet |		removeChanges			at: eachChangeSet			put: ((eachChangeSet currentChangeForClass: aClass) = #add				ifTrue: [#(#override #remove)]				ifFalse: [#(#override #remove #add)])].	XChangeSet current moveClassDefinition: aClass toPackage: self.	removeChanges keysAndValuesDo:		[:eachChangeSet :eachChanges |		classChange := eachChangeSet at: aClass absoluteSymbol ifAbsent: [nil].		classChange ifNotNil: [classChange removeDefChanges: eachChanges].		eachChangeSet removeIfEmptySymbol: aClass absoluteSymbol]</body><body package="PackageCategories">reinstalledNameSpace: aNameSpace	"A previously overriden namespace definition has been restored.	This may look odd: Why look for add and NOT remove it if it is there and DO remove it if it isn't?	The answer is, we want to preserve the state, and the move can change it from none to add.	So, if it WAS add, we don't want to remove it AFTER the move, if it WAS NOT add, we do want to clear it after the move"	| nameSpaceChange removeChanges |	removeChanges := IdentityDictionary new.	self changeSetsDo:		[:eachChangeSet |		removeChanges			at: eachChangeSet			put: ((eachChangeSet currentChangeForNameSpace: aNameSpace) = #add				ifTrue: [#(#override #remove)]				ifFalse: [#(#override #remove #add)])].	XChangeSet current moveNameSpaceDefinition: aNameSpace toPackage: self.	removeChanges keysAndValuesDo:		[:eachChangeSet :eachChanges |		nameSpaceChange := eachChangeSet at: aNameSpace absoluteSymbol ifAbsent: [nil].		nameSpaceChange ifNotNil: [nameSpaceChange removeDefChanges: eachChanges].		eachChangeSet removeIfEmptySymbol: aNameSpace absoluteSymbol]</body><body package="PackageCategories">reinstalledSelector: aSymbol class: aClass	"A previously overriden method definition is being restored.	This may look odd: Why look for add and NOT remove it if it is there and DO remove it if it isn't	The answer is, we want to preserve the state, and the move can change it from none to add.	So, if it WAS add, we don't want to remove it AFTER the move, if it WAS NOT add, we do want to clear it after the move"	| removeChanges |	removeChanges := IdentityDictionary new.	self changeSetsDo:		[:eachChangeSet |		removeChanges			at: eachChangeSet			put: ((eachChangeSet currentChangeForSelector: aSymbol class: aClass) = #add				ifTrue: [#(#override #remove)]				ifFalse: [#(#override #remove #add)])].	XChangeSet current fullyMoveSelector: aSymbol class: aClass toPackage: self.	removeChanges keysAndValuesDo:		[:eachChangeSet :eachChanges |		 eachChangeSet removeChangeTypes: eachChanges forClass: aClass selector: aSymbol].</body><body package="PackageCategories">reinstalledShared: aSymbol in: aClassOrNameSpace	"A previously static definition has been restored.	This may look odd: Why look for add and NOT remove it if it is there and DO remove it if it isn't?	The answer is, we want to preserve the state, and the move can change it from none to add.	So, if it WAS add, we don't want to remove it AFTER the move, if it WAS NOT add, we do want to clear it after the move"		| removeChanges |	removeChanges := IdentityDictionary new.	self changeSetsDo:		[:eachChangeSet |		removeChanges			at: eachChangeSet			put: ((eachChangeSet currentChangeForShared: aSymbol in: aClassOrNameSpace) = #add				ifTrue: [#(#override #remove)]				ifFalse: [#(#override #remove #add)])].	XChangeSet current moveDataKey: aSymbol owner: aClassOrNameSpace toPackage: self.	removeChanges keysAndValuesDo:		[:eachChangeSet :eachChanges |		eachChangeSet removeChangeTypes: eachChanges forSharedNamed: aSymbol in: aClassOrNameSpace].	self notifyAdditionalOverridenStatic: aSymbol in: aClassOrNameSpace</body><body package="PackageCategories">reinstalledStatic: aSymbol in: aClassOrNameSpace	"A previously static definition has been restored."		self reinstalledShared: aSymbol in: aClassOrNameSpace</body><body package="PackageCategories">removeOverriddenClass: aClass	"Remove only the class definition that has been overridden by another component."	"Record in changeset"	self doClassChange: 		( Change new class: aClass; removeDefinition ).</body><body package="PackageCategories">removeOverriddenNameSpace: aNameSpace	"Remove only the namespace definition that has been overridden by another component."	"Record in changeset"	self doNameSpaceChange: 		( Change new nameSpace: aNameSpace; removeDefinition ).</body><body package="PackageCategories">removeOverriddenSelector: selector class: aClass	"Remove  a  selector that was overridden by another component."	"Record in changeset"	self doSubdefChange: 		( Change new class: aClass; selector: selector; remove ).</body><body package="PackageCategories">removeOverriddenStatic: symbol nameSpace: aNameSpace	"Remove only the static that has been overridden by another component."	"Record in changeset"	self doSubdefChange: 		( Change new actual: aNameSpace; dataKey: symbol; remove ).</body></methods><methods><class-id>Store.PackageModel</class-id> <category>change set conversion</category><body package="PackageCategories">conversionPackage	"Answer a copy of the receiver suitable for publishing change fragments."	^( self class new )		name: name;		copyPropertiesFrom: properties;		copyModels: models;		dbIdentifier: self dbIdentifier;		dbTrace: self dbTrace;		yourself.</body><body package="PackageCategories">copyModels: modelDictionary	"Deep copy the modelDictionary into the receiver."	"Meant for internal use only."	models := IdentityDictionary new.	modelDictionary keysAndValuesDo:		[ :key :value | models at: key put: value copy ].</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-loading/unloading</category><body package="PackageCategories">isClassOrNamespace: aClassOrNameSpace overriddenOutside: packageList	| overridden |	overridden := Override overridesForClassOrNameSpace: aClassOrNameSpace.	overridden isNil ifTrue: [^false].	^overridden anySatisfy: 			[:over | (over sources contains: [:aSource| packageList includes: aSource ]) not]</body><body package="PackageCategories">listProblemsInClass: pkgClass bundleLeafItems: leafItems bundleDefinedClasses: definedClasses foundSubclasses: probSubclass foundExtensions: probExtensions foundShareds: probShareds	"report problems with extension methods and class shareds"	( Registry extensionClassModelsForClassSymbol: pkgClass absoluteSymbol ) do: 	[ :ecm |		 (leafItems includes: ecm package ) not 			ifTrue:  											[ecm classNameAndSelectorDo: 					[ :className :selector | 						probExtensions add: ((#methodIsExtension &lt;&lt; #packages &gt;&gt; '&lt;1s&gt;%&gt;%&gt;&lt;2s&gt; (an extension in package "&lt;3s&gt;")')							expandMacrosWith: className							with: selector							with: ecm package name) ].				ecm dataKeysDo: [:static | 						probShareds add: ((#sharedIsExtension &lt;&lt; #packages &gt;&gt; '&lt;1s&gt;.&lt;2s&gt; (an extension in package "&lt;3s&gt;")')							expandMacrosWith: pkgClass name							with: static							with: ecm package name) ]					]	].							"report problems with subclasses"	pkgClass allSubclasses do: 		[ :sclass |  			(definedClasses includes: sclass )				ifFalse:  					[ probSubclass add: ((#ancestorIsToBeUnloaded &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; (its ancestor &lt;2s&gt; is in the package to be unloaded)')						expandMacrosWith: sclass name						with: pkgClass name) ]		]</body><body package="PackageCategories">listProblemsInNamespace: pkgNamespace bundleLeafItems: leafItems bundleDefinedClasses: definedClasses bundleDefinedNamespaces: definedNameSpaces foundSubclasses: probSubclasses foundNamespaces: probNamespaces foundShareds: probShareds		"report problems with namespace shareds"	( Registry extensionModelsForSymbol: pkgNamespace absoluteSymbol ) do: 	[ :ecm |		 (leafItems includes: ecm package ) not 			ifTrue:  											[ecm dataKeysDo: [:sharedName|  					probShareds add: ((#namespaceIsToBeUnloaded &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; (its namespace &lt;2s&gt; is in the package to be unloaded)')						expandMacrosWith: sharedName						with: pkgNamespace name) ]]].	"report problems with classes and namespaces in pkgNamespace"	pkgNamespace bindingsDo: 		[ :binding |  		binding isForClass ifTrue: 			[(definedClasses includes: binding value) 				ifFalse: [					probSubclasses add: ((#classInNamespaceToBeUnloaded &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; (its namespace &lt;2s&gt; is in the package to be unloaded)')						expandMacrosWith: binding key						with: pkgNamespace name) ]]		ifFalse: [binding isForNameSpace ifTrue: 			[( definedNameSpaces includes: binding value) 				ifFalse: [ 					probNamespaces add: ((#namespaceInNamespaceToBeUnloaded &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; (its namespace &lt;2s&gt; is in the package to be unloaded)')						expandMacrosWith: binding key						with: pkgNamespace name) ]]		ifFalse: ["shared handled above" ]]].</body><body package="PackageCategories">removeClass: aClass unloaded: aBoolean	"Remove a class from the receiver. aBoolean is true means that the class	was removed from the system. If false, an override was reinstalled."	aBoolean		ifTrue: [ self removeClass: aClass ].</body><body package="PackageCategories">removeNameSpace: aNameSpace unloaded: aBoolean	"Remove a namespace from the receiver. aBoolean is true means that 	the	namespace was removed from the system. If false, an override was reinstalled."	aBoolean		ifTrue: [ self removeNameSpace: aNameSpace ].</body></methods><methods><class-id>Store.PackageModel</class-id> <category>editing</category><body package="PackageCategories">addClasses: classes 	classes do: [:aClass | self addClass: aClass]</body><body package="PackageCategories">addEntiretyOfClass: class 	"Add a class and all its methods to myself."	XChangeSet current moveWholeClass: class toPackage: self</body><body package="PackageCategories">addSelector: aSymbol forClass: aBehavior	"Used during binary load."	self addSelector: aSymbol class: aBehavior</body><body package="PackageCategories">removeModelForSelector: aSelector class: aClass	| model |	model := self modelAtSymbol: aClass instanceBehavior absoluteSymbol ifAbsent: [^self].	model removeSelector: aSelector meta: aClass isMeta.	model isEmpty ifTrue: [self removeModel: model]</body><body package="PackageCategories">removeName: aSymbol in: aNameSpace 	XChangeSet current removeDataKey: aSymbol nameSpace: aNameSpace</body><body package="PackageCategories">removeSelector: aSelector forClass: aBehavior	XMainChangeSet current removeSelector: aSelector class: aBehavior fromPackage: self.</body><body package="PackageCategories">removeShared: aSymbol from: aClassOrNameSpace	"Remove aClassOrNameSpace.aSymbol from the receiver."	self removeDataKey: aSymbol ownerSymbol: aClassOrNameSpace absoluteSymbol</body></methods><methods><class-id>Store.PackageModel</class-id> <category>change management</category><body package="PackageCategories">applyChangeType: aSymbol class: aClass	| classChanges definitionChanges classSymbol retainComment |	classChanges := self changeSet createForClassAt: (classSymbol := aClass instanceBehavior absoluteSymbol).	definitionChanges := classChanges alterChanges.	retainComment := definitionChanges includes: #comment.	aSymbol == #none 		ifTrue: [classChanges initializeChanges]		ifFalse: [aSymbol == #noComment ifFalse: [definitionChanges add: aSymbol]].	definitionChanges := classChanges alterChanges.	aSymbol == #add ifTrue: [definitionChanges remove: #change ifAbsent: [nil]].	aSymbol == #change ifTrue: [definitionChanges remove: #add ifAbsent: [nil]].	retainComment ifTrue: [definitionChanges add: #comment].	aSymbol == #noComment ifTrue: [definitionChanges remove: #comment ifAbsent: [nil]].	self changeSet removeIfEmptySymbol: classSymbol</body><body package="PackageCategories">applyChangeType: aSymbol forSharedNamed: aSharedName in: aClassOrNameSpace	| targetName changes definitionChanges |	targetName := aClassOrNameSpace isBehavior		ifTrue: [aClassOrNameSpace instanceBehavior absoluteSymbol]		ifFalse: [aClassOrNameSpace absoluteSymbol].	changes := self changeSet 		createAt: targetName		forChange: aClassOrNameSpace.	definitionChanges := changes alterDataChanges.	aSymbol == #none 		ifTrue: [changes initializeDataChanges]		ifFalse: [definitionChanges at: aSharedName put: aSymbol].	self changeSet removeIfEmptySymbol: targetName</body><body package="PackageCategories">applyChangeType: aSymbol nameSpace: aNameSpace	| nameSpaceChanges definitionChanges nameSpaceSymbol retainComment |	nameSpaceChanges := self changeSet createForNameSpaceAt: (nameSpaceSymbol := aNameSpace absoluteSymbol).	definitionChanges := nameSpaceChanges alterChanges.	retainComment := definitionChanges includes: #comment.	aSymbol == #none 		ifTrue: [nameSpaceChanges initializeChanges]		ifFalse: [aSymbol == #noComment ifFalse: [definitionChanges add: aSymbol]].	definitionChanges := nameSpaceChanges alterChanges.	aSymbol == #add ifTrue: [definitionChanges remove: #change ifAbsent: [nil]].	aSymbol == #change ifTrue: [definitionChanges remove: #add ifAbsent: [nil]].	retainComment ifTrue: [definitionChanges add: #comment].	aSymbol == #noComment ifTrue: [definitionChanges remove: #comment ifAbsent: [nil]].	self changeSet removeIfEmptySymbol: nameSpaceSymbol</body><body package="PackageCategories">applyChangeType: aSymbol selector: aSelector class: aClass	| classChanges methodChanges classSymbol |	classChanges := self changeSet createForClassAt: (classSymbol := aClass instanceBehavior absoluteSymbol).	methodChanges := classChanges alterMethodChangesMeta: aClass isMeta.	aSymbol == #none 		ifTrue: [methodChanges removeKey: aSelector ifAbsent: [nil]]		ifFalse: [methodChanges at: aSelector put: aSymbol].	self changeSet removeIfEmptySymbol: classSymbol</body><body package="PackageCategories">removeChangeTypes: aCollectionOfSymbol forClass: aClass selector: aSymbol	self changeSetsDo: 		[:eachChangeSet |		| classChange |		classChange := eachChangeSet			at: aClass instanceBehavior absoluteSymbol			ifAbsent: [nil].		classChange ifNotNil: 			[(classChange 				removeMethodChangesMeta: aClass isMeta 				selector: aSymbol				forTypes: aCollectionOfSymbol)].		eachChangeSet removeIfEmptySymbol: aClass instanceBehavior absoluteSymbol].	self cleanse: false</body><body package="PackageCategories">removeChangeTypes: aCollectionOfSymbol forSharedNamed: aSymbol in: aClassOrNameSpace	self changeSetsDo: 		[:eachChangeSet |		eachChangeSet removeChangeTypes: aCollectionOfSymbol forSharedNamed: aSymbol in: aClassOrNameSpace].	self cleanse: false</body><body package="PackageCategories">removeClass: aClass	XChangeSet current removeClass: aClass from: self</body><body package="PackageCategories">removeNameSpace: aNameSpace	XChangeSet current removeNameSpace: aNameSpace from: self</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-load/unload</category><body package="PackageCategories">queryLoaded: nameString ifLoadedAndOK: updateBlock ifFail: failBlock 	"Check if the receiver is already loaded and if so, take whatever error actions are required and 	 evaluate aBlock with the error value, which will probably be derived from some exception handler.	 By default there's nothing to do.  With StORE ."	| oldPackage |	oldPackage := Registry packageNamed: nameString.	(oldPackage isNil or: [oldPackage isEmpty]) ifTrue: [^self].	^(Parcel parcelAlreadyLoadedSignal raiseRequestWith: nameString)		ifTrue: [updateBlock value: oldPackage]		ifFalse:			[failBlock value: (self class abortedActionSignal									raiseRequestWith:										(Array											with: self											with: nameString											with: #packageAlreadyLoaded &lt;&lt; #dialogs &gt;&gt; 'Package already loaded')									errorString: #packageLoadAborted &lt;&lt; #dialogs &gt;&gt; 'Package load aborted')]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing-browser</category><body package="PackageCategories">allClassNames	"Answer a collection of class names. The collection contains 	names for classes that are defined in the package and names 	of classes for which methods are defined"	| defined extended |	defined := self definedClassModels 		collect: [:cm | cm absoluteName].	extended := self extendedClassModels 		collect: [:cm | cm absoluteName].	^defined asSortedCollection asOrderedCollection , 		extended asSortedCollection asOrderedCollection</body><body package="PackageCategories">allMetaclassNames	"Answer a collection of metaclass names. The collection contains 	names for classes that are defined in the package and names 	of classes for which methods are defined"	| defined extended |	defined := self definedClassModels 		collect: [:cm | cm className , ' class'].	extended := self extendedClassModels 		collect: [:cm | cm className , ' class'].	^defined asSortedCollection asOrderedCollection , 		extended asSortedCollection asOrderedCollection</body><body package="PackageCategories">allMethodsBut: oldCollection 	"Answer an array. The first element has collection of methods that are 	defined in the backage but not in oldCollection. 	The second has method defined in oldColection but not in the package."	| coll newColl oldMethod |	coll := oldCollection copy.	newColl := List new.	self methods		do: 			[:method | 			oldMethod := coll detect: [:each | each sameAs: method]						ifNone: [nil].			oldMethod isNil				ifTrue: [newColl add: method]				ifFalse: [coll remove: oldMethod]].	^Array with: newColl with: coll</body><body package="PackageCategories">allNameSpaceNames	"Answer a collection of class names. The collection contains 	names for classes that are defined in the package and names 	of classes for which methods are defined"	| defined extended |	defined := self definedNameSpaceModels 		collect: [ :model | model absoluteName].	extended := self extendedNameSpaceModels 		collect: [ :model | model absoluteName].	^defined asSortedCollection asOrderedCollection , 		extended asSortedCollection asOrderedCollection</body><body package="PackageCategories">allPackageClasses	"Answer a collection of classes defined in the package.	For pubishing ONLY. Includes overridden class definitions as well as any related parcel classes we can't otherwise see."	| classes |	classes := OrderedCollection new.	self relatedParcel ifNotNil: 		[:value |		| uninstalledClasses |		uninstalledClasses := value properties at: #uninstalledClasses ifAbsent: [#()].		uninstalledClasses do:			[:each |			classes add: each]].	classes addAll: (self definedClassModels collect: [:each | each actualClass]).	classes addAll: self overriddenClasses.	^classes</body><body package="PackageCategories">classesDefinedInPackage	"Answer a collection of class descriptors. The collection contains 	descriptors only for classes that are defined in the package."	^( self definedClassModels 			collect: [:cm | ClassDescriptor fromModel: cm ] )		asOrderedCollection</body><body package="PackageCategories">classesExtendedInPackage	"Answer a collection of class descriptors. The collection contains 	descriptors only for classes that are extended (not defined)	in the package."	^( self extendedClassModels 			collect: [:cm | ClassExtensionDescriptor fromModel: cm ] )		asOrderedCollection</body><body package="PackageCategories">classesWithSource	"Answer a collection of ClassDescriptors for the receiver.  This also includes any class definitions that are	 overridden by any other packages in the system."	^self classesDefinedInPackage addAll:		( ( Override overridesForComponent: self ) select:			[ :over | over isForClass ]		);	yourself.</body><body package="PackageCategories">dataForNamed: aFullName	"Answer a collection of datum descriptors."		^( self modelAtName: aFullName asClassNameOnly ifAbsent: [ ^Array new ] )			datumDescriptors</body><body package="PackageCategories">dataForNamed: aFullName andProtocol: aSymbol	"Answer a collection of datum descriptors."	^( self modelAtName: aFullName  asClassNameOnly ifAbsent: [^Array new] )			datumDescriptors select:				[ :dd | dd protocolName asSymbol = aSymbol ]</body><body package="PackageCategories">datum: dataKey forOwnerNamed: aFullName	^( self modelAtSymbol: aFullName ifAbsent: [ ^nil ] )		datumDescriptorForDataKey: dataKey.</body><body package="PackageCategories">metaclassesDefinedInPackage	"Answer a collection of class descriptors. The collection contains 	descriptors only for metaclasses that are defined in the package."	^( self definedClassModels 			collect: [:cm | ClassDescriptor fullName: cm absoluteName meta: true ] )		asSortedCollection asOrderedCollection</body><body package="PackageCategories">metaclassesExtendedInPackage	"Answer a collection of class descriptors. The collection contains 	descriptors only for metaclasses that are extended (not defined)	in the package."	^( self extendedClassModels 		collect: [:cm | ClassExtensionDescriptor fullName: cm absoluteName meta: true ] )			asSortedCollection asOrderedCollection</body><body package="PackageCategories">method: aSelector forClassNamed: aClassName meta: isMeta 	"Answer a method with selector aSelector defined in the class named aClassName."	^( self modelAtSymbol: aClassName asClassNameOnly asSymbol ifAbsent: 		[ ^aClassName asQualifiedReference 			ifDefinedDo: [ :cls | Override overrideForSelector: aSelector class: (isMeta ifTrue: [cls class] ifFalse: [cls])  in: self ]		]  	 ) methodDescriptorForSelector: aSelector meta: isMeta.</body><body package="PackageCategories">methodsForClassNamed: aClassName andProtocol: aProtocolName meta: isMeta	"Answer a collection of method descriptors."	^(self classModelAtClassName: aClassName ifAbsent: [^Array new])			methodsForProtocol: aProtocolName meta: isMeta</body><body package="PackageCategories">methodsForClassNamed: aClassName meta: isMeta	"Answer a collection of method descriptors."	^(self classModelAtClassName: aClassName ifAbsent: [^Array new])			methodsMeta: isMeta</body><body package="PackageCategories">nameSpacesDefinedInPackage	"Answer a collection of namespace descriptors. The collection contains 	descriptors only for NameSpaces that are defined in the package."	^( self definedNameSpaceModels 			collect: [:model | NameSpaceDescriptor fromModel: model ] )		asSortedCollection asOrderedCollection</body><body package="PackageCategories">nameSpacesExtendedInPackage	"Answer a collection of namespace descriptors. The collection contains 	descriptors only for namespaces that are extended (not defined)	in the package."	^( self extendedNameSpaceModels 			collect: [:cm | NameSpaceExtensionDescriptor fromModel: cm ] )		asSortedCollection asOrderedCollection</body><body package="PackageCategories">nameSpacesWithSource	"For image model same as defined NameSpace."	^self nameSpacesDefinedInPackage.</body><body package="PackageCategories">packageClasses	"Answer a collection of classes defined in the package."	"For pubishing ONLY. Includes overridden class defs."	^(self definedClassModels asArray collect: [:cm | cm actualClass])		, self overriddenClasses</body><body package="PackageCategories">packageNameSpaces	"Answer a collection of NameSpaces defined in the package.	For pubishing ONLY. Includes overridden namespace definitions."		^(self definedNameSpaceModels collect: [:each | each nameSpace])		addAll: self overriddenNameSpaces;		yourself</body><body package="PackageCategories">protocolsForClassNamed: aClassName meta: isMeta 	| model list cls |	model := self classModelAtClassName: aClassName ifAbsent: [ ^Array new ].	cls := model actual.	isMeta ifTrue: [ cls := cls class ].	list := model protocolsMeta: isMeta.	^self sortCategories: list with: cls organization categories.</body><body package="PackageCategories">protocolsForDataIn: anOwner 	^( self modelAtName: anOwner absoluteSymbol ifAbsent: [ ^#() ] )		protocols</body><body package="PackageCategories">protocolsForNameSpaceNamed: aName 	| model |	model := self modelAtName: aName asSymbol ifAbsent: [ ^#() ].	^self sortCategories: model protocols with: model actual organization categories.</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing-fake</category><body package="PackageCategories">allContainedItems	"Answer a collection of components."	^#( )			"don't got none."</body><body package="PackageCategories">anyContainedItems	"Answer a collection of components."	^#()			"don't got none."</body><body package="PackageCategories">containedItems	"Answer a collection of components."	^#()			"don't got none."</body></methods><methods><class-id>Store.PackageModel</class-id> <category>private-testing</category><body package="PackageCategories">isClassOrNameSpaceNameOverridden: absoluteClassOrNameSpaceName	^absoluteClassOrNameSpaceName asQualifiedReference 		ifDefinedDo:			[:cls | (Override isOverriddenClassOrNameSpace: cls in: self)]		elseDo: [false]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>changes</category><body package="PackageCategories">recompileExtensions	"Our compilation scope has changed. Recompile any extension methods which may be affected"	self extensionsDo: [:eachClass :eachSelector |		eachClass recompile: eachSelector in: (self environmentFor: eachSelector in: eachClass) ].</body><body package="PackageCategories">recompileMethodsFor: aClass	"Our compilation scope has changed. Recompile any methods which may be affected."	| environment realClass |	realClass := aClass isBehavior 		ifTrue: [aClass instanceBehavior] 		ifFalse: [aClass actualClass instanceBehavior].	environment := (self includesDefinitionOf: realClass absoluteName) ifTrue: [nil]		ifFalse: [self environment].	self methodsFor: aClass do: [:eachClass :eachSelector |		| localEnvironment|		localEnvironment := environment.		eachClass recompile: eachSelector in: localEnvironment].</body></methods><methods><class-id>Store.PackageModel</class-id> <category>public-change set access</category><body package="PackageCategories">checkChangeSet	"(Registry packageNamed: 'PackageCategories') checkChangeSet"		self isChangeSetEmpty ifTrue: [^true].	^StoreUnloadWarning		raiseSignal:			(#Package1sHasUnpIscardThoseChanges &lt;&lt; #store &gt;&gt; 'Package "&lt;1s&gt;" has unpublished changes.&lt;n&gt;Do you wish to discard those changes?'				expandMacrosWith: self name)</body></methods><methods><class-id>Store.PackageModel</class-id> <category>change lookup</category><body package="PackageCategories">currentChangeForClass: aClass	"There are only two we care about, #add or #change... the rest we don't care about"	^self changeSet currentChangeForClass: aClass</body><body package="PackageCategories">currentChangeForClassComment: aClass	"There are only two we care about, #add or #change... the rest we don't care about"	^self changeSet currentChangeForClassComment: aClass</body><body package="PackageCategories">currentChangeForNameSpace: aNameSpace	"There are only two we care about, #add or #change... the rest we don't care about"	^self changeSet currentChangeForNameSpace: aNameSpace</body><body package="PackageCategories">currentChangeForNameSpaceComment: aNameSpace	"There are only two we care about, #add or #change... the rest we don't care about"	^self changeSet currentChangeForNameSpaceComment: aNameSpace</body><body package="PackageCategories">currentChangeForSelector: aSymbol class: aClass	^self changeSet currentChangeForSelector: aSymbol class: aClass</body><body package="PackageCategories">currentChangeForShared: aSymbol in: aClassOrNameSpace	^self changeSet currentChangeForShared: aSymbol in: aClassOrNameSpace</body><body package="PackageCategories">currentChangeForSymbol: aClassOrNameSpaceSymbol	^self changeSet currentChangeForSymbol: aClassOrNameSpaceSymbol</body><body package="PackageCategories">hasAddOrChangeForClass: aClass	| hasChange |	hasChange := false.	self changeSetsDo: 		[:eachChangeSet |		| classChange |		classChange := eachChangeSet			at: aClass instanceBehavior absoluteSymbol			ifAbsent: [nil].		classChange ifNotNil: 			[hasChange := hasChange or: 				[classChange alterChanges anySatisfy: [:each | #(#add #change) includes: each]]]].	^hasChange</body><body package="PackageCategories">hasAddOrChangeForNameSpace: aNameSpace	| hasChange |	hasChange := false.	self changeSetsDo: 		[:eachChangeSet |		| classChange |		classChange := eachChangeSet			at: aNameSpace absoluteSymbol			ifAbsent: [nil].		classChange ifNotNil: 			[hasChange := hasChange or: 				[classChange alterChanges anySatisfy: [:each | #(#add #change) includes: each]]]].	^hasChange</body><body package="PackageCategories">hasAddOrChangeForSelector: aSymbol class: aClass	| absoluteSymbol |	absoluteSymbol := aClass instanceBehavior absoluteSymbol.	self changeSetsDo: 		[:eachChangeSet |		eachChangeSet at: absoluteSymbol			ifPresent: 				[:classChange |				(classChange isMethodChangedOrAddedSelector: aSymbol meta: aClass isMeta) ifTrue: [^true]]].	^false</body><body package="PackageCategories">hasAddOrChangeForSharedSymbol: aSymbol in: aClassOrNameSpace	| hasChange targetName |	hasChange := false.	targetName := aClassOrNameSpace isBehavior		ifTrue: [aClassOrNameSpace instanceBehavior absoluteSymbol]		ifFalse: [aClassOrNameSpace absoluteSymbol].	self changeSetsDo: 		[:eachChangeSet |		| nameSpaceChange |		nameSpaceChange := eachChangeSet			at: targetName			ifAbsent: [nil].		nameSpaceChange ifNotNil: 			[hasChange := hasChange or: 				[nameSpaceChange isSharedChangedOrAddedSymbol: aSymbol]]].	^hasChange</body><body package="PackageCategories">hasChangeForSelector: aSymbol class: aClass	| hasChange |	hasChange := false.	self changeSetsDo: 		[:eachChangeSet |		| classChange |		classChange := eachChangeSet			at: aClass instanceBehavior absoluteSymbol			ifAbsent: [nil].		classChange ifNotNil: 			[hasChange := hasChange or: 				[classChange isMethodChangedSelector: aSymbol meta: aClass isMeta]]].	^hasChange</body></methods><methods><class-id>Store.PackageModel</class-id> <category>testing-store shadow compilation</category><body package="PackageCategories">residesInStandardEnvironment	^true</body></methods><methods><class-id>Store.PackageModel class</class-id> <category>private</category><body package="PackageCategories">emptyFrom: aPublishedPackage 	"Create a new EMPTY package using aPublishedPackage. 	In order to make the package change set reflect this situation 	convert the contents of aPublishedPackage into removes. 	Answer a collection of modifications."	| imPkg mods |	imPkg := self named: aPublishedPackage name.	imPkg dbTrace: aPublishedPackage primaryKey.	mods := aPublishedPackage modificationsFor: aPublishedPackage dbIdentifier.	imPkg markModificationAsRemoves: mods.	^mods</body></methods><methods><class-id>Store.PackageModel class</class-id> <category>constants</category><body package="PackageCategories">componentType	"Answer a symbol representing the class of the receiver."	^#package</body><body package="PackageCategories">descriptionString	"Answer a string for error messages."	^(#package &lt;&lt; #packages &gt;&gt; 'package') asString</body><body package="PackageCategories">packageIcon	^PackageIcon ifNil: [PackageIcon := ListIconLibrary visualFor: #package]</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>changes</category><body package="PackageCategories">addOtherChange: aChange	self other add: aChange</body><body package="PackageCategories">addPropertyChange: aSymbol	self properties add: aSymbol</body><body package="PackageCategories">currentChangeForClass: aClass	| classChange changes |	classChange := self		at: aClass instanceBehavior absoluteSymbol		ifAbsent: [^#none].	changes := classChange alterChanges.	(changes includes: #add) ifTrue: [^#add].	(changes includes: #change) ifTrue: [^#change].	^#none</body><body package="PackageCategories">currentChangeForClassComment: aClass	| classChange changes |	classChange := self		at: aClass instanceBehavior absoluteSymbol		ifAbsent: [^#noComment].	changes := classChange alterChanges.	(changes includes: #comment) ifTrue: [^#comment].	^#noComment</body><body package="PackageCategories">currentChangeForNameSpace: aNameSpace	"There are only two we care about, #add or #change... the rest we don't care about"	| nameSpaceChanges changes |	nameSpaceChanges := self		at: aNameSpace absoluteSymbol		ifAbsent: [^#none].	changes := nameSpaceChanges alterChanges.	(changes includes: #add) ifTrue: [^#add].	(changes includes: #change) ifTrue: [^#change].	^#none</body><body package="PackageCategories">currentChangeForNameSpaceComment: aNameSpace	"There are only two we care about, #add or #change... the rest we don't care about"	| nameSpaceChanges changes |	nameSpaceChanges := self		at: aNameSpace absoluteSymbol		ifAbsent: [^#noComment].	changes := nameSpaceChanges alterChanges.	(changes includes: #comment) ifTrue: [^#comment].	^#noComment</body><body package="PackageCategories">currentChangeForProperty: propertyName	self propertiesOrNil isNil ifTrue: [^#none].	^(self properties includes: propertyName) ifTrue: [propertyName] ifFalse: [#none]</body><body package="PackageCategories">currentChangeForSelector: aSymbol class: aClass	| classChange |	classChange := self		at: aClass instanceBehavior absoluteSymbol		ifAbsent: [^#none].	^(classChange getMethodChangesMeta: aClass isMeta ifNone: [^#none])		at: aSymbol		ifAbsent: [#none]</body><body package="PackageCategories">currentChangeForShared: aSymbol in: aClassOrNameSpace	"There are only two we care about, #add or #change... the rest we don't care about"	| changes sharedChange targetSymbol |	targetSymbol := aClassOrNameSpace isBehavior		ifTrue: [aClassOrNameSpace instanceBehavior absoluteSymbol]		ifFalse: [aClassOrNameSpace absoluteSymbol].	changes := self		at: targetSymbol		ifAbsent: [^#none].	sharedChange := changes alterDataChanges at: aSymbol ifAbsent: [^#none].	^(#(#add #change) includes: sharedChange)		ifTrue: [sharedChange]		ifFalse: [#none].</body><body package="PackageCategories">currentChangeForSymbol: aClassOrNameSpaceSymbol	"There are only two we care about, #add or #change... the rest we don't care about"	| objectChanges changes |	objectChanges := self at: aClassOrNameSpaceSymbol ifAbsent: [^#none].	changes := objectChanges alterChanges.	(changes includes: #add) ifTrue: [^#add].	(changes includes: #change) ifTrue: [^#change].	^#none</body><body package="PackageCategories">doChange: aChange	aChange isRemoveChanges ifTrue: 		[^self removeKey: aChange symbol ifAbsent: [nil]].	(self createAt: aChange symbol forChange: aChange) doChangeType: aChange typeWithMeta.	self removeIfEmptySymbol: aChange symbol</body><body package="PackageCategories">doClassChange: change	change isRemoveChanges ifTrue: 		[^self removeKey: change classSymbol ifAbsent: [nil]].	(self createForClassAt: change classSymbol) doChangeType: change typeWithMeta.	self removeIfEmptySymbol: change classSymbol</body><body package="PackageCategories">doNameSpaceChange: change	change isRemoveChanges ifTrue: 		[^self removeKey: change nameSpaceSymbol ifAbsent: [nil]].	(self createForNameSpaceAt: change nameSpaceSymbol) doChangeType: change type.	self removeIfEmptySymbol: change nameSpaceSymbol</body><body package="PackageCategories">doSubdefChange: change	| symbol |	symbol := change classSymbol == nil		ifFalse: [ change classSymbol ]		ifTrue: [ change nameSpaceSymbol ].	(self createAt: symbol forChange: change) doSubdefChange: change.	self removeIfEmptySymbol: symbol</body><body package="PackageCategories">noChanges	self become: self class new</body><body package="PackageCategories">overriddenClass: aClass	( self createForClassAt: aClass absoluteSymbol )		doChangeType: #override.	self removeIfEmptySymbol: aClass absoluteSymbol</body><body package="PackageCategories">overriddenNameSpace: aNameSpace	( self createForNameSpaceAt: aNameSpace absoluteSymbol )		doChangeType: #override.	self removeIfEmptySymbol: aNameSpace absoluteSymbol</body><body package="PackageCategories">overriddenSelector: selector class: aClass	| symbol change |	symbol := aClass instanceBehavior absoluteSymbol.	change := 		Change new 			class: aClass; 			selector: selector;			override;			yourself.	( self createAt: symbol forChange: change ) doSubdefChange: change.	self removeIfEmptySymbol: symbol</body><body package="PackageCategories">overriddenStatic: dataKey in: anOwner	| symbol change |	symbol := anOwner absoluteSymbol.	change := 		Change new 			actual: anOwner; 			dataKey: dataKey;			override;			yourself.	( self createAt: symbol forChange: change ) doSubdefChange: change.	self removeIfEmptySymbol: symbol</body><body package="PackageCategories">reflection	"Answer a XChangeSet that is the reflection of the receiver."		| cs |	cs := self class new.	self keysAndValuesDo:		[ :key :changes |		cs at: key put: changes reflection		].	self otherOrNil == nil		ifFalse: 			[ self otherOrNil do:				[ :change | cs addOtherChange: change ].			].	self propertiesOrNil == nil		ifFalse: 			[ self propertiesOrNil do:				[ :change | cs addPropertyChange: change ].			].			^cs.</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>consistency checking</category><body package="PackageCategories">checkConsistencyInPackage: pkg on: aStream 	| printBlock |	printBlock := [ :string  |				   aStream nextPutAll: (#changeSetForPackage &lt;&lt; #packages &gt;&gt; 'change set for package &lt;1p&gt; notes &lt;2s&gt;'						expandMacrosWith: pkg						with: string).				   aStream cr				   ].	self keysAndValuesDo: 		[ :symbol :cc |   	| obj |		obj := symbol asStrictReference valueOrDo: [nil].		cc isNonDestructivelyModified			ifTrue: 				[ obj isNil					ifTrue: [ printBlock value: ((#modificationForSomethingNotInTheSystem &lt;&lt; #packages &gt;&gt; 'a modification for "&lt;1s&gt;" which is not in the system')							expandMacrosWith: symbol) ].				( pkg includesSymbol: symbol )					ifFalse: [ printBlock value: ((#modificationForSomethingNotInThePackage &lt;&lt; #packages &gt;&gt; 'a modification for "&lt;1s&gt;" which is not in the package')						expandMacrosWith: symbol) ]				].			( cc isDefinitionRemoved or: [cc isRemoved and: [cc isAdded not]] ) 				ifTrue: 					[ ( pkg includesSymbol: symbol )						ifTrue: [ printBlock value: ((#removeOperationForSomethingInThePackage &lt;&lt; #packages &gt;&gt; 'a remove/remove definition for class "&lt;1s&gt;" still in the package')								expandMacrosWith: symbol)]					].			cc isForClass				ifTrue:					[ #( false true ) do: 						[ :meta |   | cls |						cls := obj isNil							ifTrue: [ nil ]							ifFalse: [ meta										ifTrue: [ obj class ]										ifFalse: [ obj ]									].					( cc modifiedSelectorsMeta: meta ) do: 						[ :selector | 						( cls isNil or: [ (cls compiledMethodAt: selector ifAbsent: [nil]) isNil] )							ifTrue: 								[ printBlock value:  ((#addChangeForMissingMethod &lt;&lt; #packages &gt;&gt; 'an add/change for method &lt;1s&gt;%&gt;&lt;2s&gt;" which is not in the system')									expandMacrosWith: symbol									with: selector) ].						( pkg							includesSelector: selector							classSymbol: symbol							meta: meta						) ifFalse: [ printBlock value: ((#addChangeForMispackagedMethod &lt;&lt; #packages &gt;&gt; 'an add/change for method &lt;1s&gt;%&gt;&lt;2s&gt;" which is not in the package')									expandMacrosWith: symbol									with: selector) ]						].					( cc removedSelectorsMeta: meta ) do: 						[ :selector | 						( pkg includesSelector: selector classSymbol: symbol meta: meta )							ifTrue: 								[ printBlock value:  ((#removeForMethodStillInPackage &lt;&lt; #packages &gt;&gt; 'a remove for method &lt;1s&gt;%&gt;&lt;2s&gt;" which is still in the package')									expandMacrosWith: symbol									with: selector) ]						]				]			].		cc modifiedDataKeys do: 			[ :dataKey | 			( pkg includesDataKey: dataKey ownerSymbol: symbol )				ifFalse: [ printBlock value:  ((#addChangeForDataNotInPackage &lt;&lt; #packages &gt;&gt; 'an add/change for data &lt;1s&gt;:&lt;2s&gt;" which is not in the package')						expandMacrosWith: symbol						with: dataKey) ]			].		cc removedDataKeys do: 			[ :dataKey | 			( pkg includesDataKey: dataKey ownerSymbol: symbol )					ifTrue: [ printBlock value: ((#removeForDataStillInPackage &lt;&lt; #packages &gt;&gt; ' a remove for data &lt;1s&gt;:&lt;2s&gt;" which is still in the package')							expandMacrosWith: symbol							with: dataKey) ]			]		]</body><body package="PackageCategories">makeConsistentForPackage: pkg	"Resolve references to non-existent things:		- adds are removed altogether		- changes are changed to removes."	self keysAndValuesDo: 		[ :symbol :cc |   | obj |		obj := symbol asStrictReference valueOrDo:			[ cc isAdded ifTrue: [ self removeKey: symbol ].			cc isChanged ifTrue: [ cc remove ].			nil.			].		cc isForClass			ifTrue:				[ #( false true ) do: 					[ :meta |   | cls |					cls := obj isNil						ifTrue: [ nil ]						ifFalse: [ meta ifTrue: [ obj class ] ifFalse: [ obj ] ].					( cc modifiedSelectorsMeta: meta ) do: 						[ :selector | 						( cls isNil or: [ ( cls compiledMethodAt: selector ifAbsent: [ nil ] ) == nil ] )							ifTrue: 								[ | change |								change := Change new class: cls; selector: selector; remove.								self doSubdefChange: change.								].						].					]				]			].</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>public-lists</category><body package="PackageCategories">affectedClassNamesMeta: meta 	"Answer a collection of class names that ????"	| names |	names := OrderedCollection new.	self keysAndValuesDo: 		[ :classSymbol :changes | 		changes isForClass 			ifTrue: 				[ ( ( changes isClassModifiedMeta: meta ) or: [ meta and: [ changes isAdded ] ] )					ifTrue: [ ( changes isRemoved or: [ changes isDefinitionRemoved ] )							ifFalse: [ names add: classSymbol asString ] 						   ]				]		].	^names</body><body package="PackageCategories">affectedNameSpaceNames 	"Answer a collection of namespace names whose definition is changed,	but not removed."	| names |	names := OrderedCollection new.	self keysAndValuesDo: 		[ :symbol :changes | 		( changes isForNameSpace &amp; changes isDefinitionChanged )				ifTrue: [ (changes isRemoved or: [ changes isDefinitionRemoved ] )					ifFalse: [ names add: symbol asString ] ]		].	^names</body><body package="PackageCategories">changedClasses	"Answer a collection of the changed or edited classes, not including removed classes."	| classes |	classes := OrderedCollection new.	self keysAndValuesDo: 		[:classSymbol :changes |   | class |		changes isForClass ifTrue:			[ class := classSymbol asStrictReference valueOrDo: [ nil ].			class notNil ifTrue: 				[				(changes isModifiedMeta: false) ifTrue: [classes add: class].				(changes isModifiedMeta: true) ifTrue: [classes add: class class]				]			].		].	^classes</body><body package="PackageCategories">changedMessageList	"Answer an array that identifies the methods that have been changed. 	Each entry is a String containing the class name and method selector."	| messageList | 	messageList := SortedCollection new.	self keysAndValuesDo: 		[ :classSymbol :cc | | className |		cc isForClass ifTrue:			[ className := classSymbol asString, ' '.			( cc modifiedSelectorsMeta: false )				do: [ :selector | messageList add: className , selector ].			className := classSymbol fullMetaName, ' '.			( cc modifiedSelectorsMeta: true )				do: [ :selector | messageList add: className , selector ]			].		].	^messageList asArray</body><body package="PackageCategories">changedNameSpaces	"Answer a collection of the changed or edited namespaces,	not including removed NameSpaces."	| nameSpaces |	nameSpaces := OrderedCollection new.	self keysAndValuesDo: 		[: symbol :changes |   | ns |		changes isForNameSpace ifTrue:			[ ns := symbol asStrictReference valueOrDo: [ nil ].			ns notNil ifTrue: [ nameSpaces add: ns].			].		].	^nameSpaces</body><body package="PackageCategories">modifiedDataKeysFor: aClassOrNameSpace	"Answer a collection of all methods added or changed for a class." 	| cc |	cc := self at: aClassOrNameSpace absoluteSymbol.	cc isForClass	ifFalse: [ ^#( ) ].	^cc modifiedDataKeys</body><body package="PackageCategories">modifiedDatumDescriptors	| dataItems |	dataItems := OrderedCollection new.	self keysAndValuesDo: 		[ :symbol :cc | 		cc modifiedDataKeys do: 			[ :dataKey | 			dataItems add: 				( cc isForNameSpace					ifTrue: [ DatumDescriptor fromDataKey: dataKey nameSpaceName: symbol asString ]					ifFalse: [ DatumDescriptor fromDataKey: dataKey className: symbol asString ]				)			].		].	^dataItems</body><body package="PackageCategories">modifiedMethodDescriptors	"Answer a collection of all methods added or changed." 	| methods |	methods := Set new.	self keysAndValuesDo: 		[:classSymbol :cc |    | className |		cc isForClass			ifTrue:				[				className := classSymbol asString.				(cc modifiedSelectorsMeta: false) do: 					[ :selector | methods add: 						(MethodDescriptor fromSelector: selector className: className meta: false )					].				(cc modifiedSelectorsMeta: true) do: 					[:selector | methods add: 					(MethodDescriptor fromSelector: selector className: className meta: true )					]				]			].	^methods asOrderedCollection</body><body package="PackageCategories">modifiedSelectorsFor: aClass	"Answer a collection of all methods added or changed for a class." 	| cc |	cc := self at: aClass absoluteSymbol.	cc isForClass	ifFalse: [ ^#( ) ].	^cc modifiedSelectorsMeta: aClass isMeta.</body><body package="PackageCategories">removeChangeTypes: aCollectionOfSymbol forClass: aClass selector: aSymbol	| absoluteSymbol |	self at: (absoluteSymbol := aClass instanceBehavior absoluteSymbol)		ifPresent: 			[:classChange |			classChange				removeMethodChangesMeta: aClass isMeta				selector: aSymbol				forTypes: aCollectionOfSymbol.			self removeIfEmptySymbol: absoluteSymbol]</body><body package="PackageCategories">removeChangeTypes: aCollectionOfSymbol forSharedNamed: aSymbol in: aClassOrNameSpace	| targetName change |	targetName := aClassOrNameSpace isBehavior		ifTrue: [aClassOrNameSpace instanceBehavior absoluteSymbol]		ifFalse: [aClassOrNameSpace absoluteSymbol].	change := self		at: targetName		ifAbsent: [nil].	change ifNotNil: 		[change removeSharedChangeForKey: aSymbol forTypes: aCollectionOfSymbol].	self removeIfEmptySymbol: targetName.</body><body package="PackageCategories">removedClassOrDefinitionNames	"Answer a collection of removed class names"	| names |	names := OrderedCollection new.	self keysAndValuesDo: 		[ :classSymbol :cc |		cc isForClass and:			[ ( cc isRemoved or: [ cc isDefinitionRemoved ] ) 				ifTrue: [ names add: classSymbol asString ] 			]		].	^names</body><body package="PackageCategories">removedDatumDescriptors	| dataItems |	dataItems := OrderedCollection new.	self keysAndValuesDo: 		[ :symbol :cc | 		cc removedDataKeys do: 			[ :dataKey | 			dataItems add: 				( cc isForNameSpace					ifTrue: [ DatumDescriptor fromDataKey: dataKey nameSpaceName: symbol asString ]					ifFalse: [ DatumDescriptor fromDataKey: dataKey className: symbol asString ]				)			].		].	^dataItems</body><body package="PackageCategories">removedMethodDescriptors	| methods |	methods := OrderedCollection new.	self keysAndValuesDo: 		[ :classSymbol :cc |  | className |		cc isForClass ifTrue:			[ className := classSymbol asString.			( cc removedSelectorsMeta: false ) do: 				[ :selector | 	methods add: 					( MethodDescriptor fromSelector: selector className: className meta: false )				].			( cc removedSelectorsMeta: true ) do: 				[ :selector | methods add: 					( MethodDescriptor fromSelector: selector className: className meta: true )				]			]		].	^methods</body><body package="PackageCategories">removedNames	"Answer a collection of removed class and namespace names"	| names |	names := OrderedCollection new.	self keysAndValuesDo:		 [ :symbol :cc |		 ( cc isRemoved or: [ cc isDefinitionRemoved ]  ) 			ifTrue: [ names add: symbol ]		].	^names</body><body package="PackageCategories">removedNameSpaceOrDefinitionNames	"Answer a collection of removed class names"	| names |	names := OrderedCollection new.	self keysAndValuesDo: 		[ :symbol :cc |		cc isForNameSpace and:			[ ( cc isRemoved or: [ cc isDefinitionRemoved ] ) 				ifTrue: [ names add: symbol asString ] 			]		].	^names</body><body package="PackageCategories">reorganizedClassNames	"Answer a collection of reorganized class names"	| names |	names := OrderedCollection new.	self keysAndValuesDo: 		[ :classSymbol :cc | 		cc isForClass ifTrue:			[			( cc isClassReorganizedMeta: false )				ifTrue: [ names add: classSymbol asString ].			( cc isClassReorganizedMeta: true )				ifTrue: [ names add: classSymbol fullMetaName ] 			].		].	^names</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>public-printing</category><body package="PackageCategories">itemCount	^self inject: 1 into:		[ :cnt :change | cnt + change itemCount ].</body><body package="PackageCategories">printOn: aStream 	"Append to the argument aStream a sequence of characters that 	identifies the receiver."	self putStatsOn: aStream</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>public-testing</category><body package="PackageCategories">forgetDataChange: dataKey owner: owner	| res |	res := ( self at: owner absoluteSymbol ifAbsent: [ ^false ] )		forgetDataChange: dataKey.	self removeIfEmptySymbol: owner absoluteSymbol.	^res</body><body package="PackageCategories">forgetMethodChange: aSymbol class: aClass	"Note: Previously, this method answered the result of forgetMethod:meta:... But that is the changes object.	Also, no one uses the result. Therefore, this method no longer answers anything of importance"		| classNameSymbol changes |	changes := self at: (classNameSymbol := aClass instanceBehavior absoluteSymbol) ifAbsent: [^self].	changes forgetMethod: aSymbol meta: aClass isMeta.	self removeIfEmptySymbol: classNameSymbol</body><body package="PackageCategories">forgetMethodChangeIfNotRemoved: aSymbol class: aClass	"Note: This is just like forgetMethodChange:class: but only does the forget IF the change was NOT a remove"		| classNameSymbol changes |	changes := self at: (classNameSymbol := aClass instanceBehavior absoluteSymbol) ifAbsent: [^self].	((changes removedSelectorsMeta: aClass isMeta) includes: aSymbol) ifTrue: [^self].	changes forgetMethod: aSymbol meta: aClass isMeta.	self removeIfEmptySymbol: classNameSymbol</body><body package="PackageCategories">forgetTag: aTag	"Remove the change represented by aTag."	| cc |	cc := self at: aTag fullClassName ifAbsent: [ ^self ].		"Already forgotten"	cc forgetTag: aTag.	self removeIfEmptySymbol: aTag fullClassName</body><body package="PackageCategories">hasChangeForClassOrNameSpaceSymbol: aSymbol	^self includesKey: aSymbol asSymbol</body><body package="PackageCategories">hasChangeForClassOrNameSpaceSymbol: aSymbol defType: defType	^( self at: aSymbol asSymbol ifAbsent: [ ^false ] )		isDefTypeModified: defType</body><body package="PackageCategories">isClassModifiedClassSymbol: classSymbol meta: meta 	^(self at: classSymbol ifAbsent: [^false])		isClassModifiedMeta: meta</body><body package="PackageCategories">isDataKeyModified: dataKey ownerSymbol: ownerSymbol 	^( ( self at: ownerSymbol asSymbol ifAbsent: [ ^false ] )		modifiedDataKeys	) includes: dataKey</body><body package="PackageCategories">isEmpty	^( super isEmpty and: [ self otherOrNil size == 0 ] )		and: [ self propertiesOrNil size == 0 ].</body><body package="PackageCategories">isMainChangeSet	^false</body><body package="PackageCategories">isSelectorModified: selector classSymbol: classSymbol meta: meta 	^( ( self at: classSymbol ifAbsent: [ ^false ] )		modifiedSelectorsMeta: meta 	) includes: selector</body><body package="PackageCategories">notEmpty	^self isEmpty not</body><body package="PackageCategories">otherChangesInclude: aChange 	^self otherOrNil isNil		ifTrue: [false]		ifFalse: [self other includes: aChange]</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>private</category><body package="PackageCategories">createAt: aSymbol forChange: aChange	"We answer a ClassChange or a NameSpaceChange object"		^self		at: aSymbol		ifAbsentPut: 			[(aChange isForClass 				ifTrue: [self class classChangeClass] 				ifFalse: [self class nameSpaceChangeClass]) 					symbol: aSymbol]</body><body package="PackageCategories">createForClassAt: classSymbol 	^self at: classSymbol ifAbsentPut: 		[ self class classChangeClass symbol: classSymbol ]</body><body package="PackageCategories">createForClassAt: oldSymbol andMoveTo: newSymbol	"For renaming/relocating classes. Create the change at the original name	and then move it."	| cc |	cc := self createForClassAt: oldSymbol.	cc renameOldSymbol: oldSymbol.	self at: newSymbol put: cc.	self removeKey: oldSymbol.</body><body package="PackageCategories">createForNameSpaceAt: symbol 	^self at: symbol ifAbsentPut: 		[ self class nameSpaceChangeClass symbol: symbol ]</body><body package="PackageCategories">other	other isNil ifTrue: [other := IdentitySet new].	^other</body><body package="PackageCategories">otherOrNil	^other</body><body package="PackageCategories">properties	properties == nil 		ifTrue: [ properties := IdentitySet new ].	^properties</body><body package="PackageCategories">propertiesOrNil	^properties</body><body package="PackageCategories">removeIfEmptySymbol: symbol 	( self at: symbol ifAbsent: [^self] ) 		isModified ifFalse: [ self removeKey: symbol ]</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>user interface</category><body package="PackageCategories">inspectorClass	^ChangeSetInspector</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>private-fileIn/Out</category><body package="PackageCategories">changedDefinitionsFor: aPackage	"Answer a collection of the changed or edited classes, not including removed classes."		| changedDefinitions |	changedDefinitions := OrderedCollection new.	self keysAndValuesDo:		[:symbol :changes | 		| targetObject |		targetObject := symbol asStrictReference valueOrDo: [nil].		targetObject ifNotNil:			[changes isForClass				ifTrue:					[((changes isModifiedMeta: false) or: [changes isDataModified]) ifTrue: 						[changedDefinitions add: targetObject].					(changes isModifiedMeta: true) ifTrue: 						[changedDefinitions add: targetObject class]]				ifFalse: [changedDefinitions add: targetObject]]].	^(SystemUtils sortForLoading: changedDefinitions) asOrderedCollection</body><body package="PackageCategories">fileOutSpecialOn: fileManager 	"Write out any special changes the receiver knows about."</body><body package="PackageCategories">statsFor: description selector: selector on: stream	"Print out the receivers changes for changes that evaluate a selector true.	Write nothing if not changes, otherwise use description as header."	| coll |	coll := self select: [ :chng | chng perform: selector ].	coll isEmpty 		ifFalse:			[ stream nextPutAll: description; cr.			coll do: [ :chng | stream tab; nextPutAll: chng symbol; cr ].			stream cr.			].</body></methods><methods><class-id>Store.XChangeSet</class-id> <category>public-fileIn/Out</category><body package="PackageCategories">fileOutOn: outputStream 	"Write out all the changes the receiver knows about."	self fileOutOn: outputStream for: nil within: nil</body><body package="PackageCategories">fileOutOn: outputStream for: aPackage within: aBundle	"Write out all the changes the receiver knows about."		| fileManager |	fileManager := outputStream.	fileManager deferInitializations.	(self changedDefinitionsFor: aPackage) do:		[:eachDefinition | 		| changeSet |		changeSet := self at: eachDefinition absoluteName asClassNameOnly asSymbol.		changeSet fileOutChangesFor: eachDefinition for: aPackage within: aBundle on: fileManager].	self removedNames do:		[:eachRemovedName | 		(aBundle ~~ nil and: [aBundle includesDefinitionOf: eachRemovedName]) 			ifFalse: [fileManager removeObject: eachRemovedName type: (self at: eachRemovedName) fileOutObjectType]].	self fileOutSpecialOn: fileManager.	fileManager finishInitializations.	fileManager cr</body><body package="PackageCategories">putStatsOn: aStream	"Write out all the changes the receiver knows about."		| renamed |	self isEmpty ifTrue: 		[^aStream nextPutAll: (#anEmptyChangeSet &lt;&lt; #packages &gt;&gt; 'an Empty ChangeSet') asString].	self statsFor: (#AddedC &lt;&lt; #packages &gt;&gt; 'Added: ') asString selector: #isAdded on: aStream.	(renamed := self select: [:each | each isRenamed]) isEmpty ifFalse:		[aStream cr; nextPutAll: (#RenamedC &lt;&lt; #packages &gt;&gt; 'Renamed: ') asString; cr.		renamed do:			[:eachChange | 			aStream tab; nextPutAll: (#x1sBecame2p &lt;&lt; #packages &gt;&gt; '&lt;1s&gt;&lt;t&gt;became&lt;t&gt;&lt;2p&gt;' expandMacrosWith: eachChange oldName with: eachChange symbol); cr]].	self statsFor: (#RedefinedC &lt;&lt; #packages &gt;&gt; 'Redefined: ') asString selector: #isDefinitionChanged on: aStream.	self statsFor: (#CommentChangedC &lt;&lt; #packages &gt;&gt; 'Comment changed: ') asString selector: #isCommented on: aStream.	self statsFor: (#RemovedDefinitionC &lt;&lt; #packages &gt;&gt; 'Removed Definition:') asString selector: #isDefinitionRemoved on: aStream.	self statsFor: (#RemovedC &lt;&lt; #packages &gt;&gt; 'Removed:') asString selector: #isRemoved on: aStream.	self statsFor: (#ReOrganizedCChangedC &lt;&lt; #packages &gt;&gt; 'ReOrganized: changed: ') asString selector: #isReorganized on: aStream.	self statsFor: (#RemovedDefinitionC &lt;&lt; #packages &gt;&gt; 'Removed Definition:') asString selector: #isDefinitionRemoved on: aStream.	aStream nextPutAll: (#SubdefChangesC &lt;&lt; #packages &gt;&gt; 'Subdef changes:') asString; cr.	self keysAndValuesDo:		[:key :value | 		value isForClass ifTrue:			[(value areMethodsModifiedMeta: false) ifTrue:				[aStream tab; nextPutAll: key; cr.				value putMethodStatsMeta: false on: aStream.				aStream cr].			(value areMethodsModifiedMeta: true) ifTrue:				[aStream tab; nextPutAll: key; nextPutAll: ' class'; cr.				value putMethodStatsMeta: true on: aStream.				aStream cr]].		value isDataModified ifTrue:			[aStream tab; nextPutAll: key; cr.			value putDataStatsOn: aStream.			aStream cr]].	self otherOrNil ifNotNil:		[aStream nextPutAll: (#OtherChangesC &lt;&lt; #packages &gt;&gt; 'Other changes: ') asString; cr.		self other do:			[:each | aStream tab; print: each; cr]].	self propertiesOrNil ifNotNil:		[aStream nextPutAll: (#PropertyChangesC &lt;&lt; #packages &gt;&gt; 'Property changes: ') asString; cr.		self properties do:			[:each | aStream tab; print: each; cr]]</body></methods><methods><class-id>Store.XChangeSet class</class-id> <category>accessing</category><body package="PackageCategories">classChangeClass	^ClassChanges</body><body package="PackageCategories">current	"Answer the current change set"	CurrentSet == nil		ifTrue: [ self newChanges: self new ].	^CurrentSet.</body><body package="PackageCategories">nameSpaceChangeClass	^NameSpaceChanges</body><body package="PackageCategories">newChanges: aChangeSet 	"Change the current change set."		ChangeSet removeDependent: CurrentSet.	CurrentSet := aChangeSet.	ChangeSet addDependent: aChangeSet.</body><body package="PackageCategories">noChanges	self current noChanges.</body></methods><methods><class-id>Store.XChangeSet class</class-id> <category>initialization/finalization</category><body package="PackageCategories">obsolete	super obsolete.	CurrentSet notNil ifTrue: [ ChangeSet removeDependent: CurrentSet ]</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>public-method changes</category><body package="PackageCategories">addSelector: selector class: class toPackage: pkg	"Put a new selector into aPackage."	"Note- trusts that the selector is in fact, new. (Can't really verify it anyway)"	| change | 	change := Change new class: class; selector: selector; add.	(Override overrideForSelector: selector class: change classSymbol asStrictReference value in: pkg) ifNil:		[pkg doSubdefChange: change].</body><body package="PackageCategories">changeSelector: aSymbol class: aClass fromPackage: currentPackage toPackage: aPackageModel	"Put a modified selector into aPackage.	If the 'from' package has a change, don't remove it, only #add or #none"		| change |	(change := Change new)		class: aClass;		selector: aSymbol.	(currentPackage notNil and: [currentPackage ~= aPackageModel]) ifTrue: 		[(currentPackage hasAddOrChangeForSelector: aSymbol class: aClass)			ifTrue: [currentPackage removeModelForSelector: aSymbol class: aClass]			ifFalse: [currentPackage doSubdefChange: change remove]].	aPackageModel ifNotNil: 		[aPackageModel doSubdefChange: (currentPackage = aPackageModel 			ifTrue: [change change] 			ifFalse: [change add])].</body><body package="PackageCategories">changeSelector: aSymbol class: aClass toPackage: aPackageModel	"Put a modified selector into aPackage.	If the 'from' package has a change, don't remove it, only #add or #none"	| currentPackage |	currentPackage := Registry containingPackageForSelector: aSymbol class: aClass.	self		changeSelector: aSymbol		class: aClass		fromPackage: currentPackage		toPackage: aPackageModel</body><body package="PackageCategories">correctSelector: selector class: class toPackage: pkg	"Used only when converting Parcels. Put a added selector into aPackage where 	it has accidently been appropiated by the original class owner." 	| change currPkg |	change := Change new class: class; selector: selector.	currPkg := Registry containingPackageForSelector: selector class: class.	( currPkg notNil and: [ currPkg ~= pkg ] )		ifTrue: [ currPkg relinquishSelector: selector class: class ].	pkg doSubdefChange: change add.</body><body package="PackageCategories">overrideSelector: aSymbol class: aClass toPackage: aPackageModel	"Put a modified selector into aPackage."		| change currentOwningPackage |	change := (Change new)		class: aClass;		selector: aSymbol.	currentOwningPackage := Registry containingPackageForSelector: aSymbol class: aClass.	(currentOwningPackage notNil and: [currentOwningPackage ~= aPackageModel]) ifTrue: 		[currentOwningPackage doSubdefChange: change removeChanges].	aPackageModel ifNotNil: 		[aPackageModel doSubdefChange: (currentOwningPackage = aPackageModel 			ifTrue: [change change] 			ifFalse: [change add])].</body><body package="PackageCategories">removeSelector: selector class: class	"Method named &lt;selector&gt; int he given class has been removed.	Determine the package that owns the method and notify to update for the removal."	| pkg change |	(pkg := Registry containingPackageForSelector: selector class: class) isNil ifTrue: [^self].	(change := Change new)		class: class;		selector: selector;		remove.	pkg doSubdefChange: change</body><body package="PackageCategories">removeSelector: selector class: class fromPackage: aPackage	| change |	change := (Change new)				class: class;				selector: selector;				remove.	aPackage ifNotNil: [aPackage doSubdefChange: change]</body><body package="PackageCategories">removeSelectorChanges: selector class: class	| pkg change |	change := (Change new)				class: class;				selector: selector;				removeChanges.	pkg := Registry				quickContainingPackageForSelector: selector				classSymbol: change symbol				meta: class isMeta.	pkg ifNotNil: [pkg doSubdefChange: change]</body><body package="PackageCategories">updateOverriddenSelector: aSymbol class: aClass inPackage: aPackageModel	"Make the selector modified selector in the package which had been overridden"	| change |	change := (Change new)				class: aClass;				selector: aSymbol;				change;				yourself.	aPackageModel ifNotNil: [aPackageModel doSubdefChange: change]</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>public-data changes</category><body package="PackageCategories">addDataKey: dataKey class: class package: newPkg	| change |	change := (Change new)		class: class;		dataKey: dataKey.	newPkg ifNotNil: [newPkg doSubdefChange: change add]</body><body package="PackageCategories">addDataKey: dataKey nameSpace: namespace package: newPkg	| change |	change := (Change new)				nameSpace: namespace;				dataKey: dataKey.	newPkg ifNotNil: [newPkg doSubdefChange: change add].</body><body package="PackageCategories">changeDataKey: dataKey class: class 	self changeDataKey: dataKey class: class package: 		( Registry packageForDataKey: dataKey classSymbol: class absoluteSymbol ).</body><body package="PackageCategories">changeDataKey: aSymbol class: aClass package: aPackageModel		| change currentPackage |	(change := Change new)		class: aClass;		dataKey: aSymbol.	currentPackage := Registry containingPackageForDataKey: aSymbol class: aClass.	(currentPackage notNil and: [currentPackage ~= aPackageModel]) ifTrue: 		[(currentPackage hasAddOrChangeForSharedSymbol: aSymbol in: aClass)			ifTrue: [currentPackage removeShared: aSymbol from: aClass]			ifFalse: [currentPackage doSubdefChange: change remove]].	aPackageModel doSubdefChange:		(currentPackage = aPackageModel			ifTrue: [change change]			ifFalse: [change add]).</body><body package="PackageCategories">changeDataKey: dataKey nameSpace: namespace 	self changeDataKey: dataKey nameSpace: namespace package: 		( Registry 			packageForDataKey: dataKey 			nameSpaceSymbol: namespace absoluteSymbol 		).</body><body package="PackageCategories">changeDataKey: aSymbol nameSpace: aNamespace package: aPackageModel		| change currentPackage |	(change := Change new)		nameSpace: aNamespace;		dataKey: aSymbol.	currentPackage := Registry containingPackageForDataKey: aSymbol nameSpace: aNamespace.	(currentPackage notNil and: [currentPackage ~= aPackageModel]) ifTrue: 		[(currentPackage hasAddOrChangeForSharedSymbol: aSymbol in: aNamespace)			ifTrue: [currentPackage removeShared: aSymbol from: aNamespace]			ifFalse: [currentPackage doSubdefChange: change remove]].	aPackageModel doSubdefChange:		(currentPackage = aPackageModel			ifTrue: [change change]			ifFalse: [change add]).</body><body package="PackageCategories">changeDataKeyForConvert: aSymbol class: aClass package: aPackage	"Why do we go about getting the current package twice?	When this method is called, the registry only knows about the package where the class was created.	This means, that on the first invocation, it sees that package as the owner of the item.	If however, the data is only really in the NEW package currently being created, then when 	we get to the point after the second invocation (if it were not there),	it thinks that the package that is supposed to hold onto the change and the package where the object is,	are NOT the same.	But adding this extra call, after the add or change, will find the right place where the object is.	Thus it will THEN think that the package that holds the object is the SAME as the package that is supposed	to hold onto the change.	Without this, the change will be wrongly associated with the package where the object is defined	and that package will wrongly be marked dirty"	| change packageToGetChangeInformationBeforeChange packageToGetChangeInformationAfterChange |	change := Change new		class: aClass;		dataKey: aSymbol;		yourself.	packageToGetChangeInformationBeforeChange := Registry		containingPackageForDataKey: aSymbol		class: aClass.	aPackage doSubdefChange:		(packageToGetChangeInformationBeforeChange = aPackage			ifTrue: [change change]			ifFalse: [change add]).	packageToGetChangeInformationAfterChange := Registry		containingPackageForDataKey: aSymbol		class: aClass.	(packageToGetChangeInformationAfterChange notNil		and: [packageToGetChangeInformationAfterChange ~= aPackage])			ifTrue: [packageToGetChangeInformationAfterChange doSubdefChange: change remove].</body><body package="PackageCategories">changeDataKeyForConvert: aSymbol nameSpace: aNamespace package: aPackage	"See the method comment for #changeDataKey:class:package for the silly bit about	 calling #containingPackageForDataKey:* twice because of the way that the underlying 	 Store models have been optimized."	| change packageToGetChangeInformationBeforeChange packageToGetChangeInformationAfterChange |	change := Change new		nameSpace: aNamespace;		dataKey: aSymbol		yourself.	packageToGetChangeInformationBeforeChange := Registry		containingPackageForDataKey: aSymbol		nameSpace: aNamespace.	aPackage doSubdefChange:		(packageToGetChangeInformationBeforeChange = aPackage			ifTrue: [change change]			ifFalse: [change add]).	packageToGetChangeInformationAfterChange := Registry		containingPackageForDataKey: aSymbol		nameSpace: aNamespace.	(packageToGetChangeInformationAfterChange notNil		and: [packageToGetChangeInformationAfterChange ~= aPackage])			ifTrue: [packageToGetChangeInformationAfterChange doSubdefChange: change remove].</body><body package="PackageCategories">relocateBinding: binding from: currentOwner to: newOwner	"Include indication that a variable binding has been moved."	| change pkg |	(change := Change new)		actual: currentOwner;		dataKey: binding key.	pkg := Registry containingPackageForDataKey: binding key				symbol: currentOwner absoluteSymbol.	pkg isNil		ifTrue: [pkg := Registry packageForDataKey: binding key owner: newOwner]		ifFalse: 			[(change := Change new)				actual: currentOwner;				dataKey: binding key.			pkg doSubdefChange: change remove].	pkg ifNil: [^self].	(change := Change new)		actual: newOwner;		dataKey: binding key.	pkg doSubdefChange: change add</body><body package="PackageCategories">removeBinding: binding in: owner	owner isBehavior		ifTrue: [ self removeDataKey: binding key class: owner ]		ifFalse: [ self removeDataKey: binding key nameSpace: owner ].</body><body package="PackageCategories">removeChangesDataKey: dataKey class: class	| pkg change |	change := (Change new)				class: class;				dataKey: dataKey;				removeChanges.	pkg := Registry containingPackageForDataKey: dataKey				symbol: class absoluteSymbol.	pkg ifNotNil: [pkg doSubdefChange: change]</body><body package="PackageCategories">removeDataKey: dataKey class: class	| pkg change |	change := (Change new)				class: class;				dataKey: dataKey;				remove.	pkg := Registry containingPackageForDataKey: dataKey				symbol: class absoluteSymbol.	pkg ifNotNil: [pkg doSubdefChange: change]</body><body package="PackageCategories">removeDataKey: dataKey class: class from: aPackage	| change |	change := (Change new)				class: class;				dataKey: dataKey;				remove.	aPackage ifNotNil: [aPackage doSubdefChange: change]</body><body package="PackageCategories">removeDataKey: dataKey nameSpace: namespace	| pkg change |	change := (Change new)				nameSpace: namespace;				dataKey: dataKey;				remove.	pkg := Registry containingPackageForDataKey: dataKey				symbol: namespace absoluteSymbol.	pkg ifNotNil: [pkg doSubdefChange: change]</body><body package="PackageCategories">removeDataKey: dataKey nameSpace: namespace from: aPackage	| change |	change := (Change new)				nameSpace: namespace;				dataKey: dataKey;				remove.	aPackage ifNotNil: [aPackage doSubdefChange: change]</body><body package="PackageCategories">renameBinding: binding in: owner as: newName	"Include indication that a variable binding has been renamed."	| change pkg |	pkg := Registry containingPackageForDataKey: binding key				symbol: owner absoluteSymbol.	pkg isNil		ifTrue: [pkg := Registry packageForDataKey: newName asSymbol owner: owner]		ifFalse: 			[(change := Change new)				actual: owner;				dataKey: binding key.			pkg doSubdefChange: change remove].	pkg ifNil: [^self].	(change := Change new)		actual: owner;		dataKey: newName asSymbol.	pkg doSubdefChange: change add</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>public-fileIn/Out</category><body package="PackageCategories">putStatsOn: stream 	"Write out all the changes the receiver knows about."	self isEmpty		ifTrue: [ ^stream nextPutAll: (#anEmptyChangeSet &lt;&lt; #packages &gt;&gt; 'an Empty ChangeSet') asString. ].	super putStatsOn: stream</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>public-other changes</category><body package="PackageCategories">addDoIt: smalltalkExpression 	"We no longer collect do its"</body><body package="PackageCategories">addPatch: aPatchID	"We no longer track patches here"</body><body package="PackageCategories">removeDoIt: smalltalkExpression	"We no longer collect do its"</body><body package="PackageCategories">reorganizeClassData: class 	"Include indication that a class was reorganized (i.e. data protocol change)." 	"At the moment, we don't distinguish between instance, class or data' reorgs."	self reorganizeClass: class.</body><body package="PackageCategories">reorganizeSystem	"We no longer collect changes here"	^reorganizeSystem.</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>public-testing</category><body package="PackageCategories">isMainChangeSet	^true</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>public-package movement</category><body package="PackageCategories">fullyMoveSelector: aSymbol class: aClass fromPackage: aPackage toPackage: anotherPackage	"If prepareMoveOfSelector:class:fromPackage:toPackage: answers false, then do nothing.	This is because we don't ever want to do the move in those situations"	aPackage = anotherPackage ifTrue: 		[#{Refactory.Browser.RefactoryChangeFailureNotification} 			ifDefinedDo: [:value | value raiseSignal].		^self].	(Override prepareFullMoveOfSelector: aSymbol class: aClass fromPackage: aPackage toPackage: anotherPackage)		ifFalse: [^self].	aPackage notNil ifTrue:		[aPackage doSubdefChange: ((Change new remove)			selector: aSymbol;			class: aClass).		ChangeSet component: aPackage definition: aClass selector: aSymbol change: #removed.		SourceFileManager default component: aPackage definition: aClass selector: aSymbol change: #removed].	anotherPackage doSubdefChange: ((Change new add)		selector: aSymbol;		class: aClass).	anotherPackage isLoading ifFalse:		[ChangeSet component: anotherPackage definition: aClass selector: aSymbol change: #added.		SourceFileManager default component: anotherPackage definition: aClass selector: aSymbol change: #added]</body><body package="PackageCategories">fullyMoveSelector: aSymbol class: aClass toPackage: aPackageModel	"This is called only when a selector is being reinstalled to a class.	When we move that selector to the new package, we ONLY tell the original package	to forget the change for that selector IF that change was NOT already a remove.	That would indicate that the method was already removed (by way of a move) BEFORE this reinstalled override	occurs... In other words, the method was moved from its original package before the override	even occurred in the first place"	| savedChanges currentPackage newPackage |	(currentPackage := Registry containingPackageForSelector: aSymbol class: aClass) notNil		ifTrue: 			[savedChanges := IdentityDictionary new.			currentPackage changeSetsDo:				[:eachChangeSet | | selectorChange |				selectorChange := eachChangeSet currentChangeForSelector: aSymbol class: aClass.				savedChanges at: eachChangeSet put: selectorChange]].	self fullyMoveSelector: aSymbol class: aClass fromPackage: currentPackage toPackage: aPackageModel.	currentPackage isNil ifTrue: [^self].	newPackage := Registry containingPackageForSelector: aSymbol class: aClass.	currentPackage = newPackage ifTrue: [^self].	currentPackage changeSetsDo: 		[:eachChangeSet | | currentChange savedChange |		currentChange := eachChangeSet currentChangeForSelector: aSymbol class: aClass.		savedChange := savedChanges at: eachChangeSet.		savedChange = currentChange | (currentChange == #none)			ifTrue: ["same state or no change recorded"]			ifFalse: [eachChangeSet forgetMethodChange: aSymbol class: aClass]]</body><body package="PackageCategories">moveClassDefinition: class from: oldPackage toPackage: newPackage 	"Move just the definition of class from its current package to newPackage."	oldPackage = newPackage		ifFalse: 			[ oldPackage notNil				ifTrue: 					[ oldPackage doClassChange: ( Change new removeDefinition class: class ).					ChangeSet component: oldPackage definition: class change: #removed.					SourceFileManager default component: oldPackage definition: class change: #removed.					].			newPackage doClassChange: ( Change new add class: class ).			newPackage isLoading				ifFalse: 					[ ChangeSet component: newPackage definition: class change: #added.					SourceFileManager default component: newPackage definition: class change: #added.					]			].</body><body package="PackageCategories">moveClassDefinition: class toPackage: newPackage 	"Move just the definition of class from its current package to newPackage."	| pkg |	pkg := Registry containingPackageForClass: class.	self moveClassDefinition: class from: pkg toPackage: newPackage.</body><body package="PackageCategories">moveClassModel: aModel to: bPackage	"Move what part of a class that is contained in a model to bPackage."	aModel hasDefinition 		ifTrue: [ self moveClassDefinition: aModel actualClass from: aModel package toPackage: bPackage ].	aModel classAndSelectorDo:		[ :cls :selector | 		self moveSelector: selector class: cls toPackage: bPackage 		].	aModel classAndDataKeyDo:		[ :cls :datakey |		self moveDataKey: datakey class: cls toPackage: bPackage 		].</body><body package="PackageCategories">moveClassName: aClassName from: aPackage to: bPackage	"Move what part of a class that is contained in aPackage to bPackage."	| model  |	bPackage == aPackage ifTrue: [ ^self ].	model := aPackage classModelAtClassName: aClassName ifAbsent: [ ^self ].	model hasDefinition 		ifTrue: [ self moveClassDefinition: model actualClass toPackage: bPackage ].	model classAndSelectorDo:		[ :cls :selector | 		self moveSelector: selector class: cls toPackage: bPackage 		].	model classAndDataKeyDo: 		[ :cls :dataKey |		self moveDataKey: dataKey class: cls toPackage: bPackage 		]</body><body package="PackageCategories">moveDataKey: dataKey class: class toPackage: newPackage 	| pkg |	pkg := Registry containingPackageForDataKey: dataKey class: class.	pkg = newPackage		ifFalse: 			[ pkg notNil 				ifTrue: 					[ pkg doSubdefChange: ( ( Change new remove ) dataKey: dataKey; class: class ).					ChangeSet component: pkg definition: class static: dataKey change: #removed.					SourceFileManager default component: pkg definition: class static: dataKey change: #removed.					].			newPackage doSubdefChange: ( ( Change new add) dataKey: dataKey; class: class ).			newPackage isLoading				ifFalse: 					[ ChangeSet component: newPackage definition: class static: dataKey change: #added.					SourceFileManager default component: newPackage definition: class static: dataKey change: #added.					]			]</body><body package="PackageCategories">moveDataKey: dataKey nameSpace: nameSpace toPackage: newPackage 	| pkg |	pkg := Registry containingPackageForDataKey: dataKey nameSpace: nameSpace.	pkg = newPackage		ifFalse: 			[ pkg notNil 				ifTrue: 					[ pkg doSubdefChange: 						( (Change new remove ) dataKey: dataKey; nameSpace: nameSpace ).					ChangeSet component: pkg definition: nameSpace static: dataKey change: #removed.					SourceFileManager default component: pkg definition: nameSpace static: dataKey change: #removed.					].			newPackage doSubdefChange: 				( ( Change new add ) dataKey: dataKey; nameSpace: nameSpace ).			newPackage isLoading				ifFalse: 					[ ChangeSet component: newPackage definition: nameSpace static: dataKey change: #added.					SourceFileManager default component: newPackage definition: nameSpace static: dataKey change: #added.					]		]</body><body package="PackageCategories">moveDataKey: dataKey owner: anOwner toPackage: newPackage 	anOwner isBehavior		ifTrue: [ ^self moveDataKey: dataKey class: anOwner toPackage: newPackage ].	anOwner isNameSpace		ifTrue: [ ^self  moveDataKey: dataKey nameSpace: anOwner toPackage: newPackage ].	self error: (#UnexpectedOwner &lt;&lt; #packages &gt;&gt; 'Unexpected owner.')</body><body package="PackageCategories">moveDefinedSelector: aSymbol class: aClass toPackage: aPackageModel	"Unlike our cousin moveSelector:class:toPackage:, we move the current definition, not the overridden"	aPackageModel doSubdefChange: ((Change new add)		selector: aSymbol;		class: aClass).	aPackageModel isLoading ifFalse:		[ChangeSet component: aPackageModel definition: aClass selector: aSymbol change: #added.		SourceFileManager default component: aPackageModel definition: aClass selector: aSymbol change: #added]</body><body package="PackageCategories">moveDefinition: classOrNameSpace toPackage: newPackage 	"Move just the definition of class or namespace from its current package to newPackage."	classOrNameSpace isForNameSpace		ifTrue: [ self moveNameSpaceDefinition: classOrNameSpace toPackage: newPackage ]		ifFalse: [ self moveClassDefinition: classOrNameSpace toPackage: newPackage ]</body><body package="PackageCategories">moveNameSpaceDefinition: namespace from: oldPackage toPackage: newPackage 	"Move just the definition of 'namespace' from its oldPackage to newPackage."	oldPackage = newPackage		ifFalse: 			[ oldPackage notNil				ifTrue: 					[ oldPackage doNameSpaceChange: 							( Change new removeDefinition nameSpace: namespace ).					ChangeSet component: oldPackage definition: namespace change: #removed.					SourceFileManager default component: oldPackage definition: namespace change: #removed.					 ].			newPackage doNameSpaceChange: ( Change new add nameSpace: namespace ).			newPackage isLoading				ifFalse: 					[ ChangeSet component: newPackage definition: namespace change: #added.					SourceFileManager default component: newPackage definition: namespace change: #added.					]			]</body><body package="PackageCategories">moveNameSpaceDefinition: namespace toPackage: newPackage 	"Move just the definition of 'namespace' from its current package to newPackage."	| pkg |	pkg := Registry containingPackageForNameSpace: namespace.	self moveNameSpaceDefinition: namespace from: pkg toPackage: newPackage</body><body package="PackageCategories">moveNameSpaceModel: model to: bPackage	"Move the definition and whatever other parts of a namespace that is contained in aModel to bPackage."	model hasDefinition		ifTrue: [ self moveNameSpaceDefinition: model nameSpace from: model package toPackage: bPackage ].	model nameSpaceAndDataKeyDo: 		[ :ns :dataKey |		self moveDataKey: dataKey nameSpace: ns toPackage: bPackage 		]</body><body package="PackageCategories">moveObject: aDefinedObject from: aPackage to: bPackage	"Move what part of a class/namespace that is contained in aPackage to bPackage."	| model  |	model := aPackage modelAtName: aDefinedObject absoluteName ifAbsent: 		[ aDefinedObject isBehavior 			ifTrue: [ self moveUnpackagedInWholeClass: aDefinedObject toPackage: bPackage ]			ifFalse: [ self moveUnpackagedInWholeNameSpace: aDefinedObject toPackage: bPackage ].		^self 		].	model isClassModel		ifTrue: [ self moveClassModel: model to: bPackage ]		ifFalse: [ self moveNameSpaceModel: model to: bPackage ].</body><body package="PackageCategories">moveSelector: selector class: class fromPackage: oldPackage 	| pkg | 	pkg := Registry containingPackageForSelector: selector class: class.	pkg = oldPackage		ifFalse: [ ^self ].		"already been moved"	self moveSelector: selector class: class toPackage: ( Registry nullPackage ).</body><body package="PackageCategories">moveSelector: aSymbol class: aClass fromPackage: aPackage toPackage: anotherPackage	"If prepareMoveOfSelector:class:fromPackage:toPackage: answers false, then do nothing.	This is because we don't ever want to do the move in those situations"	aPackage = anotherPackage ifTrue: 		[#{Refactory.Browser.RefactoryChangeFailureNotification} 			ifDefinedDo: [:value | value raiseSignal].		^self].	(Override prepareMoveOfSelector: aSymbol class: aClass fromPackage: aPackage toPackage: anotherPackage)		ifFalse: [^self].	aPackage notNil ifTrue:		[aPackage doSubdefChange: ((Change new remove)			selector: aSymbol;			class: aClass).		ChangeSet component: aPackage definition: aClass selector: aSymbol change: #removed.		SourceFileManager default component: aPackage definition: aClass selector: aSymbol change: #removed].	anotherPackage doSubdefChange: ((Change new add)		selector: aSymbol;		class: aClass).	anotherPackage isLoading ifFalse:		[ChangeSet component: anotherPackage definition: aClass selector: aSymbol change: #added.		SourceFileManager default component: anotherPackage definition: aClass selector: aSymbol change: #added]</body><body package="PackageCategories">moveSelector: selector class: class toPackage: newPackage 	| pkg | 	pkg := Registry containingPackageForSelector: selector class: class.	self moveSelector: selector class: class fromPackage: pkg toPackage: newPackage</body><body package="PackageCategories">moveSelectors: selectors class: class toPackage: newPackage 	| pkg | 	selectors do:		[ :sel |		pkg := Registry containingPackageForSelector: sel class: class.		pkg = newPackage			ifFalse: 			[ pkg notNil				ifTrue: 					[ pkg doSubdefChange: ( Change new remove selector: sel; class: class ).					ChangeSet component: pkg definition: class selector: sel change: #removed.					SourceFileManager default component: pkg definition: class selector: sel change: #removed.					].			newPackage doSubdefChange: ( Change new add selector: sel; class: class ).			newPackage isLoading				ifFalse: 					[ ChangeSet component: pkg definition: class selector: sel change: #added.					SourceFileManager default component: pkg definition: class selector: sel change: #added.					]			]		].</body><body package="PackageCategories">moveUnpackagedClassDefinition: class toPackage: newPackage	"Move just the definition of 'class' from its current package to 'newPackage'."	| pkg |	pkg := Registry containingPackageForClass: class.	pkg ifNil: [newPackage doClassChange: (Change new add class: class)]</body><body package="PackageCategories">moveUnpackagedDataKey: dataKey nameSpace: namespace toPackage: newPackage	| pkg |	pkg := Registry containingPackageForDataKey: dataKey nameSpace: namespace.	pkg		ifNil: 			[newPackage doSubdefChange: ((Change new add)						dataKey: dataKey;						nameSpace: namespace)]</body><body package="PackageCategories">moveUnpackagedInWholeClass: class toPackage: newPackage 	"Move the definition of 'class' and all its methods from its current package to 	'newPackage'."	class selectors do: [:selector | self			moveUnpackagedSelector: selector			class: class			toPackage: newPackage].	class class selectors do: [:selector | self			moveUnpackagedSelector: selector			class: class class			toPackage: newPackage].	self moveUnpackagedClassDefinition: class toPackage: newPackage.</body><body package="PackageCategories">moveUnpackagedInWholeNameSpace: namespace toPackage: newPackage 	"Move the definition of namespace and all its methods from its current package to 	'newPackage'."	namespace bindingsDo: 		[ : binding |		( binding isForGeneral )			ifTrue:				[ self					moveUnpackagedDataKey: binding key					nameSpace: namespace					toPackage: newPackage				]		].	self moveUnpackagedNameSpaceDefinition: namespace toPackage: newPackage.</body><body package="PackageCategories">moveUnpackagedNameSpaceDefinition: namespace toPackage: newPackage	"Move just the definition of namespace from its current package to 'newPackage'."	| pkg |	pkg := Registry containingPackageForNameSpace: namespace.	pkg		ifNil: [newPackage doNameSpaceChange: (Change new add nameSpace: namespace)]</body><body package="PackageCategories">moveUnpackagedSelector: selector class: class toPackage: newPackage	| pkg |	pkg := Registry containingPackageForSelector: selector class: class.	pkg		ifNil: 			[newPackage doSubdefChange: ((Change new add)						selector: selector;						class: class)]</body><body package="PackageCategories">moveWholeClass: class toPackage: newPackage 	"Move the definition of 'class' and all its methods from its current package to 	'newPackage'."	| cls |	cls := class instanceBehavior.	cls selectors do: 		[ :selector | 	self moveSelector: selector class: cls toPackage: newPackage ].	cls class selectors do: 		[ :selector | 	self	moveSelector: selector class: cls class toPackage: newPackage ].	cls dataKeys do: 		[ :dataKey | 	self	moveDataKey: dataKey class: cls toPackage: newPackage ].	self moveClassDefinition: cls toPackage: newPackage.</body><body package="PackageCategories">moveWholeNameSpace: namespace toPackage: newPackage 	"Move the definition of 'namespace' and all its methods from its current package to 	'newPackage'."	namespace dataBindings do: 		[ :binding | 		self moveDataKey: binding key 			nameSpace: namespace 			toPackage: newPackage		].	self moveNameSpaceDefinition: namespace toPackage: newPackage.</body><body package="PackageCategories">moveWholeObject: object toPackage: newPackage 	"Move the definition of a class/namespace and it's contents from its current package to 	newPackage."	object isBehavior 		ifTrue: [ ^self moveWholeClass: object toPackage: newPackage ].	( object isNameSpace )		ifTrue: [ ^self moveWholeNameSpace: object toPackage: newPackage ].</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>events</category><body package="PackageCategories">addBinding: binding in: anObject	"Event triggered when new static is created."	anObject residesInStandardEnvironment ifFalse: [^self].	anObject isBehavior		ifTrue: 			[self				addDataKey: binding key				class: anObject				package: (Registry packageForNewDataKey: binding key						classSymbol: anObject absoluteSymbol)]		ifFalse: 			[self				addDataKey: binding key				nameSpace: anObject				package: (Registry packageForNewDataKey: binding key						nameSpaceSymbol: anObject absoluteSymbol)]</body><body package="PackageCategories">addBinding: binding in: anObject attributes: attributes	"Event triggered when new static is created with attributes."	| pkg |	anObject residesInStandardEnvironment ifFalse: [^self].	pkg := Policies packagePolicy packageIsForced		ifTrue: [Policies packagePolicy forcedPackage]		ifFalse: [self packageFromAttributes: attributes].	pkg ifNil: [^self addBinding: binding in: anObject].	anObject isBehavior		ifTrue: 			[self				addDataKey: binding key				class: anObject				package: pkg]		ifFalse: 			[self				addDataKey: binding key				nameSpace: anObject				package: pkg]</body><body package="PackageCategories">addClass: class	"Event triggered when new class is created."	| cls |	class residesInStandardEnvironment ifFalse: [^self].	cls := class instanceBehavior.	self addClass: cls toPackage: (Registry packageForClass: cls)</body><body package="PackageCategories">addClass: class attributes: attributes	"Event triggered when new class is created with attributes."	| pkg cls |	class residesInStandardEnvironment ifFalse: [^self].	pkg := Policies packagePolicy packageIsForced		ifTrue: [Policies packagePolicy forcedPackage]		ifFalse: [self packageFromAttributes: attributes].	cls := class instanceBehavior.	pkg isNil		ifTrue: [self addClass: cls]		ifFalse: [self addClass: cls toPackage: pkg]</body><body package="PackageCategories">addNameSpace: namespace	"Event triggered when new namespace is created."	| pkg |	namespace residesInStandardEnvironment ifFalse: [^self].	(pkg := Registry packageForNameSpace: namespace)		ifNotNil: [self addNameSpace: namespace toPackage: pkg]</body><body package="PackageCategories">addNameSpace: namespace attributes: attributes	"Event triggered when new namespace is created with attributes."	| pkg |	namespace residesInStandardEnvironment ifFalse: [^self].	pkg := Policies packagePolicy packageIsForced		ifTrue: [Policies packagePolicy forcedPackage]		ifFalse: [self packageFromAttributes: attributes].	pkg isNil		ifTrue: [self addNameSpace: namespace]		ifFalse: [self addNameSpace: namespace toPackage: pkg]</body><body package="PackageCategories">addSelector: selector class: class 	"Event triggered when a new method is created."	class residesInStandardEnvironment		ifFalse: [ ^self ].	self addSelector: selector class: class toPackage: 		( Registry 			packageForNewSelector: selector				classSymbol: class absoluteName asClassNameOnly asSymbol			meta: class isMeta		).</body><body package="PackageCategories">addSelector: selector class: class attributes: attributes	"Event triggered when new method is created with attributes."	| pkg |	class residesInStandardEnvironment		ifFalse:	[ ^self ].			"ignore while shadow compiling"	pkg := Policies packagePolicy packageIsForced		ifTrue: [ Policies packagePolicy forcedPackage ]		ifFalse: [ self packageFromAttributes: attributes ].	pkg isNil		ifTrue: [ self addSelector: selector class: class ]		ifFalse: [ self addSelector: selector class: class toPackage: pkg ]</body><body package="PackageCategories">changeBinding: binding in: anObject	"Event triggered when a static definition is changed."	anObject residesInStandardEnvironment		ifFalse: [ ^self ].	anObject isBehavior		ifTrue: [ self changeDataKey: binding key class: anObject ]		ifFalse: [ self changeDataKey: binding key nameSpace: anObject ].</body><body package="PackageCategories">changeBinding: binding in: anObject attributes: attributes	"Event triggered when a static definition is changed with attributes."	| pkg |	anObject residesInStandardEnvironment ifFalse: [^self].	pkg := Policies packagePolicy packageIsForced				ifTrue: [Policies packagePolicy forcedPackage]				ifFalse: [self packageFromAttributes: attributes].	pkg ifNil: [^self changeBinding: binding in: anObject].	anObject isBehavior		ifTrue: 			[self				changeDataKey: binding key				class: anObject				package: pkg]		ifFalse: 			[self				changeDataKey: binding key				nameSpace: anObject				package: pkg]</body><body package="PackageCategories">changeClass: class 	"Event triggered when a class definition is changed."	| cls |	class residesInStandardEnvironment		ifFalse: [ ^self ].	cls := class instanceBehavior.	self changeClass: cls toPackage: ( Registry packageForClass: cls ).</body><body package="PackageCategories">changeClass: class attributes: attributes	"Event triggered when a class definition is changed with attributes."	| pkg cls |	class residesInStandardEnvironment		ifFalse: [ ^self ].	pkg := Policies packagePolicy packageIsForced		ifTrue: [ Policies packagePolicy forcedPackage ]		ifFalse: [ self packageFromAttributes: attributes ].	cls := class instanceBehavior.	pkg isNil		ifTrue: [ 	self changeClass: cls ]		ifFalse: [ self changeClass: cls toPackage: pkg ]</body><body package="PackageCategories">changeNameSpace: namespace	"Event triggered when a namespace definition is changed."	| pkg |	namespace residesInStandardEnvironment ifFalse: [^self].	(pkg := Registry packageForNameSpace: namespace)		ifNotNil: [self changeNameSpace: namespace toPackage: pkg]</body><body package="PackageCategories">changeNameSpace: namespace attributes: attributes	"Event triggered when a namespace definition is changed with attributes."	| pkg |	namespace residesInStandardEnvironment		ifFalse: [ ^self ].	pkg := Policies packagePolicy packageIsForced		ifTrue: [ Policies packagePolicy forcedPackage ]		ifFalse: [ self packageFromAttributes: attributes ].	pkg isNil		ifTrue: [ 	self changeNameSpace: namespace ]		ifFalse: [ self changeNameSpace: namespace toPackage: pkg ]</body><body package="PackageCategories">changeSelector: selector class: class 	"Event triggered when a method is changed."	class residesInStandardEnvironment		ifFalse: [ ^self ].	self changeSelector: selector class: class toPackage: 		( Registry			packageForSelector: selector			classSymbol: class absoluteName asClassNameOnly asSymbol			meta: class isMeta		)</body><body package="PackageCategories">changeSelector: selector class: class attributes: attributes	"Event triggered when a method is changed with attributes.	For Override it's essential to call this method BEFORE actually installing the new method in the method dictionary."	| pkg notification |	pkg := Policies packagePolicy packageIsForced			ifTrue: [Policies packagePolicy forcedPackage]			ifFalse: [self packageFromAttributes: attributes].	notification := RedefinitionNotification redefinedSelector: selector class: class inPackage: pkg.	class residesInStandardEnvironment ifFalse: [^self].	pkg isNil ifTrue: [^self changeSelector: selector class: class].	notification isSignalledException		ifTrue: 			[self				changeSelector: selector				class: class				fromPackage: notification currentPackage				toPackage: pkg]		ifFalse: [self changeSelector: selector class: class toPackage: pkg]</body><body package="PackageCategories">changeSelector: selector class: class  documentation: documentation	self changeSelector: selector class: class</body><body package="PackageCategories">changeSelector: selector class: class protocol: protocol	self changeSelector: selector class: class</body><body package="PackageCategories">packageFromAttributes: attributes	"Private- Check attributes for a package and answer it or nil."	| pname |	pname := ( SystemUtils makeAttributesDictionary: attributes )				at: #package ifAbsent: [ ^nil ].	^Registry packageNamedOrCreate: pname.</body><body package="PackageCategories">reorganizeClass: class	"The name check is performed so that adding a protocol in a class extension does not make the package where the class is defined dirty"	| package change |	change := (Change new) class: class; reorganize.	package := Registry containingPackageForClassSymbol: class instanceBehavior absoluteSymbol.	(package notNil and: [package name = Registry currentPackage name])		ifTrue: [package doClassChange: change].</body><body package="PackageCategories">update: anAspect with: arguments from: anObject		"ChangeSet changes- reexecute here.""Transcript show: anAspect; tab; show: arguments printString; cr."	anAspect isSymbol ifFalse: [^nil].	^[ self perform: anAspect withArguments: arguments ]		on: MessageNotUnderstood do: 			[ :e | e message selector == anAspect 						ifTrue: [ ^nil ]						ifFalse: [ e pass ]			]</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>public-namespace changes</category><body package="PackageCategories">addNameSpace: nameSpace toPackage: pkg	"Add a newly created namespace to a package.	Note, pkg cannot be nil.	currPkg should be nil.  This is just in case code."	| change currPkg |	change := Change new nameSpace: nameSpace.	currPkg := Registry containingPackageForNameSpace: nameSpace.	(currPkg notNil and: [currPkg ~= pkg])		ifTrue: [currPkg doNameSpaceChange: change removeDefinition].	self moveUnpackagedInWholeNameSpace: nameSpace toPackage: pkg</body><body package="PackageCategories">addNameSpaceDefinition: nameSpace toPackage: pkg	"Add a newly created namespace to a package.	Note, pkg cannot be nil.	currPkg should be nil.  This is just in case code."	| change currPkg |	change := Change new nameSpace: nameSpace.	currPkg := Registry containingPackageForNameSpace: nameSpace.	(currPkg notNil and: [currPkg ~= pkg])		ifTrue: [currPkg doNameSpaceChange: change removeDefinition].	pkg doNameSpaceChange: change add</body><body package="PackageCategories">changeNameSpace: aNameSpace toPackage: aPackageModel	"Put a modifed namespace to a package."	"Note, aPackageModel cannot be nil."		| change currentPackage |	change := Change new nameSpace: aNameSpace.	currentPackage := Registry containingPackageForNameSpace: aNameSpace.	(Override isOverriddenClassOrNameSpace: aNameSpace strictReference value in: aPackageModel) ifTrue: 		[^self].	(currentPackage notNil and: [currentPackage ~= aPackageModel]) ifTrue: 		[(currentPackage hasAddOrChangeForNameSpace: aNameSpace)			ifTrue: [currentPackage removeDefinitionFullNameSpaceSymbol: change nameSpaceSymbol]			ifFalse: [currentPackage doNameSpaceChange: change removeDefinition]].	aPackageModel doNameSpaceChange: (currentPackage = aPackageModel 		ifTrue: [change change] 		ifFalse: [change add]).</body><body package="PackageCategories">commentNameSpace: namespace	| pkg change |	change := (Change new)				nameSpace: namespace;				comment.	pkg := Registry containingPackageForNameSpace: namespace.	pkg ifNotNil: [pkg doNameSpaceChange: change].</body><body package="PackageCategories">component: component property: property value: value	component addPropertyChange: property.</body><body package="PackageCategories">component: component renamedTo: aString	component addOtherChange: #name</body><body package="PackageCategories">relocateNameSpace: namespace from: parent to: newParent 	"Include indication that a nameSpace has been moved."	self renameNameSpace: namespace asAbsoluteSymbol: 		( BindingReference 			fullNameFrom: newParent absoluteName 			name: namespace name 		) asSymbol.</body><body package="PackageCategories">removeNameSpace: namespace 	"This is subtle, packages need to know about whole namespace removes 	as an atomic act - then they translate to bit by bit remove.  At the main level, 	we do our own bit by bit translation - taking into account that the 	original name may have been different."	Registry packagesContainingNameSpace: namespace do: 		[ :pkg | pkg doNameSpaceChange: 			( Change new remove nameSpace: namespace ) 		].</body><body package="PackageCategories">renameNameSpace: namespace as: newName 	"Include indication that a nameSpace has been renamed."	self renameNameSpace: namespace asAbsoluteSymbol: 		( BindingReference 			newName: newName 			from: namespace absoluteName 		) asSymbol.</body><body package="PackageCategories">reorganizeNameSpace: namespace	"We no longer capture changes here"</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>public-class changes</category><body package="PackageCategories">addClass: class toPackage: pkg	"Add a newly created class to a package.	Note, pkg cannot be nil.	currPkg should be nil.... but we check just in case."	| change currPkg |	change := Change new class: class.	currPkg := Registry containingPackageForClass: class.	(currPkg notNil and: [currPkg ~= pkg])		ifTrue: [currPkg doClassChange: change removeDefinition].	self moveUnpackagedInWholeClass: class toPackage: pkg</body><body package="PackageCategories">addClassDefinition: class toPackage: pkg	"Add a newly created class to a package.	Note, pkg cannot be nil.	currPkg should be nil.... but we check just in case."	| change currPkg |	change := Change new class: class.	currPkg := Registry containingPackageForClass: class.	(currPkg notNil and: [currPkg ~= pkg])		ifTrue: [currPkg doClassChange: change removeDefinition].	pkg doClassChange: change add</body><body package="PackageCategories">changeClass: aClass toPackage: aPackageModel	"Put a modifed class to a package.	Note, aPackageModel cannot be nil.	If the Class is overridden in the package (vs the current package) then don't make a change!"		| change currentPackage |	change := Change new class: aClass.	currentPackage := Registry containingPackageForClass: aClass.	(Override isOverriddenClassOrNameSpace: aClass absoluteName asStrictReference value in: aPackageModel) ifTrue: 		[^self].	(currentPackage notNil and: [currentPackage ~= aPackageModel]) ifTrue: 		[(currentPackage hasAddOrChangeForClass: aClass)			ifTrue: [currentPackage removeDefinitionFullClassSymbol: change classSymbol]			ifFalse: [currentPackage doClassChange: change removeDefinition]].	aPackageModel doClassChange: (currentPackage = aPackageModel 		ifTrue: [change change] 		ifFalse: [change add]).</body><body package="PackageCategories">changeDefinitionClass: cls	"Mark a changed class definition. If it doesn't exist, it's already been changed."	| change currPkg |	change := Change new class: cls.	change change.	currPkg := Registry containingPackageForClass: cls.	currPkg ifNil: [^nil].	currPkg doClassChange: change</body><body package="PackageCategories">commentClass: class	| pkg change |	change := (Change new)				class: class;				comment.	pkg := Registry containingPackageForClass: class.	pkg ifNotNil: [pkg doClassChange: change]</body><body package="PackageCategories">relocateClass: class from: nameSpace to: newNameSpace	"Since a class may have extensions in various packages 	we must iterate over all packages containing the class."	self renameClass: class 		  asAbsoluteSymbol: 			( BindingReference 				fullNameFrom: newNameSpace absoluteName 				name: class name 			) asSymbol.</body><body package="PackageCategories">removeChangesPropagatingClass: class 	| change |	change := (Change new) class: class; removeChanges.	Registry packagesContainingClass: class do: [:pkg | pkg doClassChange: change].</body><body package="PackageCategories">removeClass: class 	"This is subtle, packages need to know about whole 	class removes as an atomic act - then they translate	to bit by bit remove.  At the main level, we do our own	bit by bit translation - taking into account that the 	original name may have been different."	Registry 		packagesContainingClass: class 		do: [:each | each doClassChange: (Change new remove class: class)].	(Parcel parcelsForClass: class) do: [:each | each removeClass: class].	(class isExternalInterface)		ifTrue: [self removeDataKey: class poolName nameSpace: class environment]</body><body package="PackageCategories">removeClass: aClass from: aPackageModel	"Remove the class definition from package. Assumes it has/will be moved to another package."		aPackageModel doClassChange: (Change new removeDefinition class: aClass).</body><body package="PackageCategories">removeClassChanges: class 	"We no longer capture changes in the X[Main]ChangeSet objects"</body><body package="PackageCategories">removeNameSpace: aNameSpace from: aPackageModel	"Remove the class definition from package. Assumes it has/will be moved to another package."	aPackageModel doNameSpaceChange: (Change new removeDefinition nameSpace: aNameSpace).</body><body package="PackageCategories">renameClass: class as: newName 	"Since a class may have extensions in various packages 	we must iterate over all packages containing the class."	self renameClass: class asAbsoluteSymbol: 		( BindingReference 			newName: newName 			from: class absoluteName		) asSymbol.</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>private- cascade changes</category><body package="PackageCategories">cascadeRelocateNameSpace: namespace to: newEnvironmentSymbol		"Private- newEnvironmentSymbol is the about to be renamed/relocated 		enviornment of namespace. Cascade to all contained namespaces and 		classes models."	| newSymbol |	newSymbol := BindingReference fullNameFrom: newEnvironmentSymbol name: namespace name.	Registry packagesContainingNameSpace: namespace do:			[ :pkg | pkg renameNameSpaceSymbol: namespace absoluteSymbol as: newSymbol ].	namespace classes do:		[ :cls | 		Registry packagesContainingClass: cls do: 			[ :pkg | pkg renameClassSymbol: cls absoluteSymbol as: 						( BindingReference fullNameFrom: newSymbol name: cls name ).			].		cls allSubclasses do: [ :sub | self changeDefinitionClass: sub ]. 		].	namespace nameSpaces do: 		[ :ns | 	self cascadeRelocateNameSpace: ns to: newSymbol ].</body><body package="PackageCategories">renameClass: class asAbsoluteSymbol: newSymbol	"Since a class may have extensions in various packages 	we must iterate over all packages containing the class."	| oldSymbol |	oldSymbol := class absoluteSymbol.	Registry packagesContainingClassSymbol: oldSymbol do: 		[:pkg | pkg renameClassSymbol: oldSymbol as: newSymbol ].	class subclasses do: 		[ :cls | 		( Registry packageForClass: cls ) doClassChange: 			( (Change new) class: cls; change )		].</body><body package="PackageCategories">renameNameSpace: namespace asAbsoluteSymbol: newSymbol	"Since a NameSpace may have extensions in various packages 	we must iterate over all packages containing the namespace."	| oldSymbol |	oldSymbol := namespace absoluteSymbol.	Registry packagesContainingNameSpace: namespace do: 		[:pkg | pkg renameNameSpaceSymbol: oldSymbol as: newSymbol ].	namespace classes do:		[ :cls |  | newClassSym |		newClassSym := ( BindingReference fullNameFrom: newSymbol name: cls name )								asSymbol.		Registry packagesContainingClass: cls do: 			[ :pkg | pkg renameClassSymbol: cls absoluteSymbol as: newClassSym ].		cls allSubclasses do: [ :sub | self changeDefinitionClass: sub ]. 		].	namespace nameSpaces do:		[ :ns | self cascadeRelocateNameSpace: ns to: newSymbol ].</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>events-parcels</category><body package="PackageCategories">installedClasses: classList toPackage: aPackage	classList do:		[ :cls |		self addClassDefinition: cls toPackage: aPackage.		].</body><body package="PackageCategories">installedMethods: aCollection toPackage: aPackageModel	| change currentOwningPackage previousOwningPackage |	aCollection do: 		[:each |		previousOwningPackage := Registry containingPackageForSelector: each selector class: each mclass.		self changeSelector: each selector class: each mclass classObject toPackage: aPackageModel.		change := (Change new)			class: each mclass;			selector: each selector.		currentOwningPackage := Registry containingPackageForSelector: each selector class: each mclass.		currentOwningPackage = aPackageModel			ifTrue: [aPackageModel doSubdefChange: change removeChanges].		previousOwningPackage = aPackageModel			ifFalse: [previousOwningPackage doSubdefChange: change removeChanges]]</body><body package="PackageCategories">installedNameSpaces: list toPackage: aPackage	list do:		[ :ns |		self addNameSpaceDefinition: ns toPackage: aPackage.		].</body><body package="PackageCategories">installedOverrideMethods: list toPackage: aPackage	list do:		[ :mir |		self changeSelector: mir selector class: mir mclass classObject toPackage: aPackage		].</body></methods><methods><class-id>Store.XMainChangeSet</class-id> <category>db phantoms</category><body package="PackageCategories">addRemoveClass: className package: aPackage	"Adds a remove class change to aPackage, for the case of an unloadable definition."	aPackage		doClassChange: (Change new removeDefinition className: className meta: false)</body><body package="PackageCategories">addRemoveNameSpace: aName package: aPackage	"Adds a remove namespace change to aPackage, for the case of an unloadable definition."	aPackage doNameSpaceChange: (Change new removeDefinition				nameSpaceSymbol: aName asSymbol)</body><body package="PackageCategories">addRemoveSelector: selector className: className meta: meta package: aPackage	"Adds a remove selector change to aPackage, for the case of an unloadable definition."	aPackage doSubdefChange: ((Change new remove)				selector: selector;				className: className meta: meta)</body><body package="PackageCategories">addRemoveStatic: key ownerName: ownerName isInNameSpace: aBoolean package: aPackage	"Adds a remove static change to aPackage, for the case of an unloadable definition."	| change |	change := Change new remove dataKey: key.	aBoolean		ifTrue: [change classSymbol: ownerName asSymbol]		ifFalse: [change nameSpaceSymbol: ownerName asSymbol].	aPackage doSubdefChange: change</body></methods><methods><class-id>Store.XMainChangeSet class</class-id> <category>utilities</category><body package="PackageCategories">ignoreChangesWhile: aBlock 	"Code changes that occur during the execution of aBlock are not 	recorded in any change set. "	^ChangeSet ignoreChangesWhile: aBlock</body><body package="PackageCategories">ignoreMainChangesWhile: aBlock 	"Since we no longer collect changes we don't bother ignoring them"	aBlock value</body></methods><methods><class-id>Store.XMainChangeSet class</class-id> <category>initialize</category><body package="PackageCategories">initialize	self newChanges: self new.</body></methods><methods><class-id>Store.PundleForParcel</class-id> <category>initialization</category><body package="PackageCategories">from: aPundle saveLinks: saveLinks		name := aPundle name.	properties := aPundle propertiesForParcel.	saveLinks ifTrue:		[properties			at: #dbTrace put: aPundle dbTrace;			at: #dbUsername put: aPundle dbUsernameOrDerived;			at: #dbVersion put: aPundle dbVersionOrDerived;			at: #dbIdentifier put: aPundle dbIdentifier.		#{Store.DbRegistry} 			ifDefinedDo:  [:ignored | properties at: #printStringCache put: aPundle printStringCache]			elseDo: [|string|				string := self basicVersionString.				(string notNil and: [string notEmpty])					ifTrue: [properties at: #printStringCache put: string]]]</body></methods><methods><class-id>Store.PundleForParcel</class-id> <category>private</category><body package="PackageCategories">asPundle: aSymbol	"Convert the receiver into a pundle. Called on parcel load. Answer the converted pundle"	| pundle |	pundle := self pundleInImage.	pundle startLoad.	[ aSymbol ~~ nil		ifTrue: [ pundle restoreLinksFrom: properties ].	pundle properties: properties.	] ensure: [ pundle endLoad ].	^pundle.</body><body package="PackageCategories">updates: updates fromParcel: aParcel relink: aSymbol	"Update the pundle in the image from a parcel."	| pundle |	pundle := self pundleInImage.	pundle properties: properties.	aSymbol ~~ nil ifFalse: [pundle removeLinks: pundle properties].	^pundle</body></methods><methods><class-id>Store.PundleForParcel</class-id> <category>accessing</category><body package="PackageCategories">dbIdentifier	| dbid |	^( dbid := properties at: #dbIdentifier ifAbsent: 		[ properties at: #databaseId ifAbsent: [ nil ] ]	) == nil			ifFalse: [ dbid asSymbol ].</body><body package="PackageCategories">deploymentPrerequisites	"Answer the names of the receiver's deployment prerequisite parcels	 as an Array of Name String, Version String pairs."	^properties at: #prerequisiteParcels ifAbsent: [ #() ]</body><body package="PackageCategories">developmentPrerequisites	"Answer the names of the receiver's development prerequisite parcels	 as an Array of Name String, Version String pairs."	^properties at: #developmentPrerequisites ifAbsent: [#()]</body><body package="PackageCategories">name	^name.</body><body package="PackageCategories">prerequisiteDescriptions	^(PrerequisiteDescription		descriptionsFrom: (self properties at: #prerequisiteDescriptions				ifAbsent: [nil])		orDeployment: self deploymentPrerequisites		andDevelopment: self developmentPrerequisites)			collect: [:each | each client: self]</body><body package="PackageCategories">properties	^properties</body></methods><methods><class-id>Store.PundleForParcel</class-id> <category>conversion</category><body package="PackageCategories">convert	"Convert the receiver into a pundle. Called on parcel load. Answer the converted pundle"	^self asPundle: self dbIdentifier</body><body package="PackageCategories">updates: updates fromParcel: aParcel	"A parcel has been updated- update the receiver's image model."	^self updates: updates fromParcel: aParcel relink: self dbIdentifier</body></methods><methods><class-id>Store.PundleForParcel</class-id> <category>iterating</category><body package="PackageCategories">pundlesDo: aBlock	"Evaluate aBlock for all of our contained packages and bundles."	self subclassResponsibility.</body></methods><methods><class-id>Store.PundleForParcel class</class-id> <category>instance creation</category><body package="PackageCategories">classForPundle: aPundle 			^aPundle isPackage		ifTrue: [ PackageForParcel ]		ifFalse: [ BundleForParcel ]</body><body package="PackageCategories">from: aPundle saveLinks: saveLinks			^( self classForPundle: aPundle ) new		from: aPundle saveLinks: saveLinks</body></methods><methods><class-id>Store.BundleForParcel</class-id> <category>initialization</category><body package="PackageCategories">from: aBundle saveLinks: saveLinks	super from: aBundle saveLinks: saveLinks.	contents := OrderedCollection new.	aBundle containedItems do:		[ :pundle |  contents add: 					( PundleForParcel from: pundle saveLinks: saveLinks )		].</body></methods><methods><class-id>Store.BundleForParcel</class-id> <category>private</category><body package="PackageCategories">asPundle: aSymbol	"Convert the receiver into a pundle. Called on parcel load. Answer the converted pundle."	| bundle |	bundle := super asPundle: aSymbol.	bundle startLoad.	[bundle containedItems: (contents collect: [:each | each asPundle: aSymbol]).	self relinkContentDescriptionsFor: (bundle databaseInformationFor: aSymbol).	bundle markPundleNotModifiedFor: (aSymbol ifNil: [#''])]		ensure: [bundle endLoad].	^bundle</body><body package="PackageCategories">pundleInImage	"Answer the image version of the receiver. Creates one if it doesn't exist."	^Registry bundleNamedOrCreate: name.</body><body package="PackageCategories">relinkContentDescriptionsFor: relinkedDbInfo	"By the time this has been called then (if the parameter is non-nil) the bundle and its subpundles have both had their database links reset from the parcels properties.  However the parcel properties only hold values for the pundles, not for the content descriptions that connect a bundle to its contained pundles.  This makes sense (if the parcel was saved with links, the contentDescriptions values are deducible from them) but until they are set the bundle will not show itself reconciled."	relinkedDbInfo == nil ifTrue: [^self].	relinkedDbInfo contentDescriptions do:		[:each |		each dbIdentifier: relinkedDbInfo dbIdentifier.		each id: each component dbTrace].</body><body package="PackageCategories">updates: updates fromParcel: aParcel relink: aSymbol	"Update the pundle in the image from a parcel."	| bundle |	bundle := super updates: updates fromParcel: aParcel relink: aSymbol.	bundle containedItems:		(contents collect: [:pun | pun updates: updates fromParcel: aParcel relink: aSymbol]).	self relinkContentDescriptionsFor: (bundle databaseInformationFor: aSymbol).	bundle markNotModified.	^bundle</body></methods><methods><class-id>Store.BundleForParcel</class-id> <category>iterating</category><body package="PackageCategories">pundlesDo: aBlock	"Evaluate aBlock for all of our contained packages and bundles."	contents do: [:each |		each pundlesDo: aBlock.		aBlock value: each].</body></methods><methods><class-id>Store.Access</class-id> <category>initialize-release</category><body package="PackageCategories">cloneFrom: anAccess	| replaceBlock |	replaceBlock := [:policy| (policy isNil or: [policy class isObsolete]) ifTrue: [nil] ifFalse: [policy]].		self publishPolicy: ((replaceBlock value: anAccess publishPolicy) ifNil: [self class defaultPublishPolicy]).	self ownershipPolicy: ((replaceBlock value: anAccess ownershipPolicy) ifNil: [self class defaultOwnershipPolicy]).	self blessingPolicy: ((replaceBlock value: anAccess blessingPolicy) ifNil: [self class defaultBlessingPolicy]).	self mergePolicy: ((replaceBlock value: anAccess mergePolicy) ifNil: [self class defaultMergePolicy]).	self packagePolicy: ((replaceBlock value: anAccess packagePolicy) ifNil: [self class defaultPackagePolicy]).	self versionPolicy: ((replaceBlock value: anAccess versionPolicy) ifNil: [self class defaultVersionPolicy]).	self prerequisitePolicy: ((replaceBlock value: anAccess prerequisitePolicy) ifNil: [self class defaultPrerequisitePolicy]).	self filePolicy: ((replaceBlock value: anAccess filePolicy) ifNil: [self class defaultFilePolicy]).	self tableSpacePolicy: ((replaceBlock value: self tableSpacePolicy) ifNil: [self class defaultTableSpacePolicy]).</body></methods><methods><class-id>Store.Access</class-id> <category>accessing</category><body package="PackageCategories">blessingPolicy	^blessingPolicy == nil		ifTrue: [ blessingPolicy := self class defaultBlessingPolicy ]		ifFalse: [ blessingPolicy ]</body><body package="PackageCategories">blessingPolicy: aPolicy	blessingPolicy := aPolicy</body><body package="PackageCategories">filePolicy	^filePolicy</body><body package="PackageCategories">filePolicy: aPolicy	filePolicy := aPolicy</body><body package="PackageCategories">mergePolicy	^mergePolicy == nil		ifTrue: [ mergePolicy := self class defaultMergePolicy ]		ifFalse: [ mergePolicy ]</body><body package="PackageCategories">mergePolicy: aPolicy	mergePolicy := aPolicy</body><body package="PackageCategories">ownershipPolicy	^ownershipPolicy == nil		ifTrue: [ ownershipPolicy := self class defaultOwnershipPolicy ]		ifFalse: [ ownershipPolicy ]</body><body package="PackageCategories">ownershipPolicy: aPolicy	ownershipPolicy := aPolicy</body><body package="PackageCategories">packagePolicy	^packagePolicy == nil		ifTrue: [ packagePolicy := self class defaultPackagePolicy ]		ifFalse: [ packagePolicy ]</body><body package="PackageCategories">packagePolicy: aPolicy	packagePolicy := aPolicy</body><body package="PackageCategories">prerequisitePolicy		^prerequisitePolicy == nil		ifTrue: [ prerequisitePolicy := self class defaultPrerequisitePolicy ]		ifFalse: [ prerequisitePolicy ]</body><body package="PackageCategories">prerequisitePolicy: aPolicy		prerequisitePolicy := aPolicy</body><body package="PackageCategories">publishPolicy	^publishPolicy == nil		ifTrue: [ publishPolicy := self class defaultPublishPolicy ]		ifFalse: [ publishPolicy ]</body><body package="PackageCategories">publishPolicy: aPolicy	publishPolicy := aPolicy</body><body package="PackageCategories">tableSpacePolicy		^tableSpacePolicy ifNil: [tableSpacePolicy := self class defaultTableSpacePolicy]</body><body package="PackageCategories">tableSpacePolicy: aPolicy		tableSpacePolicy := aPolicy</body><body package="PackageCategories">versionPolicy	^versionPolicy == nil		ifTrue: [ versionPolicy := self class defaultVersionPolicy ]		ifFalse: [ versionPolicy ]</body><body package="PackageCategories">versionPolicy: aPolicy	versionPolicy := aPolicy</body></methods><methods><class-id>Store.Access class</class-id> <category>class initialization</category><body package="PackageCategories">initialize	"Need only be executed on first installation or on change in definition."	"self initialize"		Policies isNil		ifTrue:			[Policies := self new.			self setDefaultPolicies]		ifFalse: [Policies := self new cloneFrom: Policies]</body></methods><methods><class-id>Store.Access class</class-id> <category>defaults</category><body package="PackageCategories">defaultBlessingPolicy	^#{BasicBlessingPolicy} ifDefinedDo: [ :cls | cls new ].</body><body package="PackageCategories">defaultFilePolicy		^#{BasicFilePolicy} ifDefinedDo: [:value | value new]</body><body package="PackageCategories">defaultMergePolicy	^#{BasicMergePolicy} ifDefinedDo: [ :cls | cls new ].</body><body package="PackageCategories">defaultOwnershipPolicy	^#{BasicOwnershipPolicy} ifDefinedDo: [ :cls | cls new ].</body><body package="PackageCategories">defaultPackagePolicy	^#{BasicPackagePolicy} ifDefinedDo: [ :cls | cls new ].</body><body package="PackageCategories">defaultPrerequisitePolicy	^#{BasicPrerequisitePolicy} ifDefinedDo: [ :cls | cls new ].</body><body package="PackageCategories">defaultPublishPolicy	^#{BasicPublishPolicy} ifDefinedDo: [ :cls | cls new ].</body><body package="PackageCategories">defaultTableSpacePolicy		^#{BasicTableSpacePolicy} ifDefinedDo: [:value | value new]</body><body package="PackageCategories">defaultVersionPolicy	^#{BranchingVersionPolicy} ifDefinedDo: [ :cls | cls new ].</body><body package="PackageCategories">setDefaultPolicies	"self setDefaultPolicies"	Policies blessingPolicy: self defaultBlessingPolicy.	Policies publishPolicy: self defaultPublishPolicy.	Policies mergePolicy: self defaultMergePolicy.	Policies ownershipPolicy: self defaultOwnershipPolicy.	Policies packagePolicy: self defaultPackagePolicy.	Policies versionPolicy: self defaultVersionPolicy.	Policies prerequisitePolicy: self defaultPrerequisitePolicy.	Policies tableSpacePolicy: self defaultTableSpacePolicy.	Policies filePolicy: self defaultFilePolicy</body></methods><methods><class-id>Store.Access class</class-id> <category>filein/fileout</category><body package="PackageCategories">reinitializeAfterStoreUnload	"Preserve those policies whose hierarchy root classes are defined outside of Store and so should survive the unload of Store."	| packagePolicy tableSpacePolicy |	packagePolicy := Policies packagePolicy.	tableSpacePolicy := Policies tableSpacePolicy.	Policies := nil.	self initialize.	Policies packagePolicy: packagePolicy.	Policies tableSpacePolicy: tableSpacePolicy.</body></methods><methods><class-id>Store.PublishAsParcelDialog</class-id> <category>interface opening</category><body package="PackageCategories">postOpenWith: aBuilder	"This message is sent by the builder after it has opened a completed window."		self copyFromPackage.	(pundle hasBeenModified and: [pundle isBundle]) ifTrue:		[Dialog warn: 			(#PundleHasUnpublishedChanges &lt;&lt; #packages &gt;&gt; '&lt;1s&gt; has unpublished changes. Database links cannot be saved.'				 expandMacrosWith: pundle name)].	(self builder componentAt: #parcelSave) isEnabled: false.	(self builder componentAt: #parcelDirectory) isEnabled: true.	self bundleStructureChanged</body></methods><methods><class-id>Store.PublishAsParcelDialog</class-id> <category>aspects</category><body package="PackageCategories">bundleStructure		bundleStructure ifNil: [bundleStructure := true asValue].	^bundleStructure</body><body package="PackageCategories">bundleStructureChanged	"Enable the database links depending on whether the structure will be saved."		(self builder componentAt: #databaseLinks) isEnabled: pundle hasBeenModified not.	databaseLinks value: databaseLinks value</body><body package="PackageCategories">databaseLinks	databaseLinks == nil		ifTrue: [ databaseLinks := false asValue ].	^databaseLinks</body><body package="PackageCategories">helpAction	| sh |	sh := SimpleHelp helpString: self class parcelHelp.	sh class openOn: sh</body><body package="PackageCategories">parcelBackup	parcelBackup == nil		ifTrue: [ parcelBackup := false asValue ].	^parcelBackup</body><body package="PackageCategories">parcelDirectory		parcelDirectory ifNil: 		[parcelDirectory := pundle parcelDirectory isNil			ifTrue: [(PundleAccess parcelDirectory asFilename construct: pundle parcelName) asString asValue]			ifFalse: [pundle parcelDirectory asString asValue]].	^parcelDirectory</body><body package="PackageCategories">parcelHideSource	parcelHideSource == nil		ifTrue: [ parcelHideSource := false asValue ].	^parcelHideSource</body><body package="PackageCategories">parcelOverwrite	parcelOverwrite == nil		ifTrue: [ parcelOverwrite := false asValue ].	^parcelOverwrite</body><body package="PackageCategories">parcelPadded	parcelPadded == nil		ifTrue: [ parcelPadded := false asValue ].	^parcelPadded</body><body package="PackageCategories">parcelRepublish	parcelRepublish == nil		ifTrue: [ parcelRepublish := false asValue ].	^parcelRepublish</body><body package="PackageCategories">parcelSave	parcelSave == nil		ifTrue: [ parcelSave := true asValue ].	^parcelSave</body><body package="PackageCategories">parcelSaveSource	parcelSaveSource == nil		ifTrue: [ parcelSaveSource := true asValue ].	^parcelSaveSource</body><body package="PackageCategories">parcelSaveSourceChanged	"Enable/disable the subcheck boxes depending on sources."	| save |	save := self parcelSaveSource value &amp;  ( self parcelSave value ).	self parcelSaveSourceDetails do:		[ :sym | self enableComponentAt: sym enable: save ].	self parcelRepublish value: ( self parcelRepublish value &amp; save ).	self enableComponentAt: #parcelRepublish enable: save.</body><body package="PackageCategories">parcelSaveSourceDetails	^#( parcelHideSource 		parcelPadded 		)</body><body package="PackageCategories">parcelVersionString	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^parcelVersionString isNil		ifTrue:			[parcelVersionString := String new asValue]		ifFalse:			[parcelVersionString]</body><body package="PackageCategories">pundle: aPundle 	"aPundle will be the pundle that is going to be used for creating the parcel.	 Consult aPundle (or any of its contained items if aPundle is a bundle) has a 	 sourceIndex.  If so, then make sure we force the republish flag to be true. 	 Check to see if the padded property  (see the class comment for SourceFileManager) 	 for aPundle is either true, false or absent (which we treat as false) and set the aspect	 for padded appropriately."	| hasSourceIndex |	pundle := aPundle.	hasSourceIndex := (aPundle propertyAt: #sourceIndex) notNil.	aPundle isBundle ifTrue: 		[hasSourceIndex := hasSourceIndex or: 								[aPundle allContainedItems anySatisfy: 									[:each | (each propertyAt: #sourceIndex) notNil]]].	self parcelRepublish value: hasSourceIndex.	self parcelPadded value: (aPundle propertyAt: #padded ifAbsent: false)</body><body package="PackageCategories">validateParcelSaveString	"Check whether save as parcel should be enabled. Answer the message if not, an empty string if okay"	| existing |	( existing := pundle relatedParcel ) == nil		ifFalse: 			[ existing hasUninstalledCode 				ifTrue: [ ^(#uninstalledCode &lt;&lt; #dialogs &gt;&gt; 'Parcel has uninstalled code.&lt;n&gt;Saving will lose it.').					]			].	pundle hasCodeOverridden 		ifTrue: [ ^#parcelCodeOverridden &lt;&lt; #dialogs &gt;&gt; 'Parcel has code overridden by other parcels.&lt;n&gt;Saving would save the override, not the overridden code.&lt;n&gt;Operation cancelled.'.				].	^String new</body></methods><methods><class-id>Store.PublishAsParcelDialog</class-id> <category>private</category><body package="PackageCategories">enableComponentAt: aSymbol enable: aBoolean	| comp |	( comp := self builder componentAt: aSymbol ) == nil		ifFalse: [ comp isEnabled: aBoolean ]</body><body package="PackageCategories">validateParcelOptions	| filename |	( ( filename := self basePath , Parcel fileExtension ) asFilename exists				and: [ self parcelOverwrite value not ] )		ifTrue: 			[ ( Dialog confirm: ( (#OKtoOverwriteParcelQ &lt;&lt; #packages &gt;&gt; '&lt;n&gt;&lt;1s&gt; exists: &lt;n&gt;&lt;n&gt;Overwrite files?&lt;n&gt;') expandMacrosWith: filename ) ) 				ifTrue: [ self parcelOverwrite value: true ]				ifFalse: [ ^false ].			].	^true</body></methods><methods><class-id>Store.PublishAsParcelDialog</class-id> <category>events</category><body package="PackageCategories">requestForWindowClose	"The ApplicationWindow's controller is checking to see if the application is in a state that can be closed."	self validateParcelOptions		ifFalse: [ ^false ].	^super requestForWindowClose</body></methods><methods><class-id>Store.PublishAsParcelDialog</class-id> <category>accessing</category><body package="PackageCategories">basePath	"Return the base path of the filename for the parcel to be saved."		^( Filename expandEnvironmentIn: ( self parcelDirectory value ) ) asString</body><body package="PackageCategories">options	"Answer a dictionary containing all the possible options that are used when 	 saving a parcel.  These properties are instructions that determine how the	 parcel will be saved (for example, with or without source).  One of the 	 options, #padded, is passed along to the newly created parcel and assigned	 into its properties dictionary.  For #padded, we only want to add it to the	 dictionary being returned if the client user this dialog has set it to true.  	 Otherwise, we do not want to add this property because the absence of the 	 #padded conveys the same information to the system as if it is there with	 a value of false.  Also, by only adding this property if the user wants it added	 we prevent unnecessary modifications to the package."	| optionsDictionary |	optionsDictionary := Dictionary new.	optionsDictionary		at: #parcelSave put: self parcelSave value;		at: #databaseLinks put: self databaseLinks value;		at: #bundleStructure put: self bundleStructure value;		at: #parcelDirectory put: self parcelDirectory value;		at: #parcelRepublish put: self parcelRepublish value;		at: #parcelBackup put: self parcelBackup value;		at: #parcelOverwrite put: self parcelOverwrite value;		at: #parcelSaveSource put: self parcelSaveSource value;		at: #parcelVersionString put: self parcelVersionString value;		at: #parcelHideSource put: self parcelHideSource value.	self parcelPadded value ifTrue:		[pundle propertyAt: #padded put: true].	^optionsDictionary.</body></methods><methods><class-id>Store.PublishAsParcelDialog</class-id> <category>actions</category><body package="PackageCategories">copyFromPackage	| version |	#{Store.DbRegistry} ifDefinedDo: [:object | object isOnline ifTrue:  [version := pundle traceVersion]].	version ifNil: [version := pundle propertyAt: #version ifAbsent: [nil]].	self parcelVersionString value: (version ifNil: [^self]).	(self controllerAt: #VersionString) accept</body></methods><methods><class-id>Store.PublishAsParcelDialog class</class-id> <category>interface opening</category><body package="PackageCategories">publishAsParcel: aPundle	"Open a dialog for package/bundle parcel publishing."	"self publishAsParcel: ( Registry packageNamed: 'Store-UI' )"		| dialog filename |	dialog := self new.	dialog pundle: aPundle.	dialog open.	dialog accept value ifFalse: [^nil].	filename := Filename named: dialog parcelDirectory value.	aPundle parcelDirectory: filename asString.	aPundle 		saveAsParcel: filename 		saveStructure: dialog bundleStructure value 		saveLinks: dialog databaseLinks value 		parcelOptions: dialog options</body></methods><methods><class-id>Store.PublishAsParcelDialog class</class-id> <category>dummy</category><body package="PackageCategories">parcelWarningMessage	"We don't need this here, but it's in the dialog we're borrowing from PublishPundleDialog"	^''</body></methods><methods><class-id>Store.PublishAsParcelDialog class</class-id> <category>help</category><body package="PackageCategories">parcelHelp	^(#parcelHelp &lt;&lt; #packages &gt;&gt; 'The parcel will be saved in the Parcel Path + .pcl, the sources in Parcel Path +.pst.Include Bundle Structure if you would like the bundle to be recreated when loading the parcel into a Store image.  Saving Database Links will hook the components to a particular database. This saves the loader from needing to reconcile source before publishing a new version to the same database.Save source file will create the parcel sources (.pst) file.Hide sources on load will not effect the current image, but will supress sources when it is loaded into a another image. This is for deployment parcels and should not be used during development.Select republish to save with sources to a parcel that is currently loaded to the same file name.  Republishing does not hide sources. Republishing will invalidate other images that point to the original file.') asString</body></methods><methods><class-id>Store.PseudoRecord</class-id> <category>testing</category><body package="PackageCategories">isDataModel	"Is this a Bernstein data model?"	^true</body><body package="PackageCategories">isExtension	^false</body><body package="PackageCategories">sameAsImage	^self existsInImage</body></methods><methods><class-id>Store.PseudoRecord</class-id> <category>comparing</category><body package="PackageCategories">sameAs: aThing	| thing |			thing := aThing isDataModel 		"Munched for browser support-DS"		ifFalse: [ aThing absoluteName ]		ifTrue: [ aThing ].	thing isString ifTrue: [ ^self absoluteName = thing ].	^thing sameAsImThing: self</body></methods><methods><class-id>Store.PseudoRecord</class-id> <category>printing</category><body package="PackageCategories">itemString	^self fullName , self versionString</body><body package="PackageCategories">versionString	^(#parenImage &lt;&lt; #packages &gt;&gt; '(image)') asString</body></methods><methods><class-id>Store.PseudoRecord</class-id> <category>accessing</category><body package="PackageCategories">asDescriptor		^self</body><body package="PackageCategories">myClass	"Give a class name answer a class."	| cls |	cls := self fullClassName asClassNameOnly asStrictReference valueOrDo: [ ^nil ].	self isMeta ifTrue: [ cls := cls class ].	^cls</body></methods><methods><class-id>Store.PseudoRecord</class-id> <category>accessing browser</category><body package="PackageCategories">primaryKey	^0</body><body package="PackageCategories">version	^(#image &lt;&lt; #packages &gt;&gt; 'image') asString</body></methods><methods><class-id>Store.PseudoRecord</class-id> <category>merge</category><body package="PackageCategories">loadCommentFor: aClass 	"Load the receiver's comment."	"Already in the image, so no action required."</body><body package="PackageCategories">loadDefinition: aString logged: logFlag	"Load the receiver into the image by compiling it's definition."	"Already in the image, so no action required."</body></methods><methods><class-id>Store.PseudoRecord class</class-id> <category>instance creation</category><body package="PackageCategories">fromModel: aModel	^aModel isForClass		ifTrue: [ ClassDescriptor fromModel: aModel ]		ifFalse: [ NameSpaceDescriptor  fromModel: aModel ].</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>comparing</category><body package="PackageCategories">&lt;= aClassDescriptor	^self absoluteName &lt;= aClassDescriptor absoluteName</body><body package="PackageCategories">= aThing	^self sameAs: aThing</body><body package="PackageCategories">comparesTo: anObject	"Answer true if anObject could be another version of the receiver."	( self objectIsForSelf: anObject ) ifFalse: [ ^false ].	anObject isMeta = self isMeta		ifFalse: [ ^false ].	^anObject absoluteName asClassNameOnly = self absoluteName.</body><body package="PackageCategories">hash	^self fullName hash</body><body package="PackageCategories">objectIsForSelf: anObject	"Answer true if anObject represents the same kind of thing as the reciever."	^anObject isForClass</body><body package="PackageCategories">sameAsImThing:  aClass	^aClass absoluteName = self absoluteName</body><body package="PackageCategories">sameName: aString	"Answer true if aString is the same name as the receiver."		| string |	string := aString namesMetaClass		ifTrue:			[self isMeta ifFalse: [^false].			aString asClassNameOnly]		ifFalse:			[self isMeta ifTrue: [^false].			aString].	^string = self absoluteName</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>accessing</category><body package="PackageCategories">absoluteName	^self fullClassName</body><body package="PackageCategories">absoluteSymbol	^self absoluteName asSymbol</body><body package="PackageCategories">actual	"Answer the class in the image that the reciever represents. nil if none."	^self fullClassName asStrictReference ifDefinedDo: 		[ :cls | self isMeta 					ifTrue: [ cls class ]					ifFalse: [ cls ].		].</body><body package="PackageCategories">classNameWithMeta	^meta		ifTrue: [ self fullClassName fullMetaName ]		ifFalse: [  self fullClassName ].</body><body package="PackageCategories">comment	| cl |	(cl := self myClass) isNil		ifTrue: [ ^'' ]		ifFalse: [ ^cl instanceBehavior comment ]</body><body package="PackageCategories">definition	| cl |	(cl := self myClass) isNil		ifTrue: [^'']		ifFalse: [^cl definition]</body><body package="PackageCategories">environment	^self actual environment</body><body package="PackageCategories">existsInImage	^( self myClass == nil ) not</body><body package="PackageCategories">fullClassName	^self fullName</body><body package="PackageCategories">fullClassName: aString	aString namesMetaClass 		ifTrue: [ self meta: true ].	fullClassName := aString asClassNameOnly</body><body package="PackageCategories">fullName		^fullClassName isNil ifTrue: [''] ifFalse: [fullClassName]</body><body package="PackageCategories">meta: aBoolean	meta := aBoolean</body><body package="PackageCategories">name	"Answer the receiver's simple name."	^cachedName isNil		ifTrue: [cachedName := (self fullName tokensBasedOn: $.) last]		ifFalse: [cachedName]</body><body package="PackageCategories">realname	^self fullName</body><body package="PackageCategories">superclass	"Answer the superclass of the receiver in the image. nil if none."	| cls |	^( cls := self actual ) == nil		ifFalse: [ cls superclass ]</body><body package="PackageCategories">symbol	^self absoluteSymbol</body><body package="PackageCategories">textRepresentationForTag: aTag 	^aTag isClassCommentTag		ifTrue: [ self comment ]		ifFalse: [ self definition ]</body><body package="PackageCategories">xmlDefinition	| cl |	(cl := self myClass) isNil		ifTrue: [^'']		ifFalse: [^cl xmlDefinition]</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>testing</category><body package="PackageCategories">isForClass	^true</body><body package="PackageCategories">isMeta	^meta</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>browser support</category><body package="PackageCategories">asNameSpace	^self actual asNameSpace</body><body package="PackageCategories">asString	^self simpleName</body><body package="PackageCategories">binding	"Answer a binding for the class in the system if it exists, otherwise just answer the receiver (which pretends to be a binding)."	| ref |	^( ref := self fullName asStrictReference ) isDefined 		ifTrue: [ ref binding ]		ifFalse: [ self ]."	^self "</body><body package="PackageCategories">classifySymbol: varName under: protocol	^self value classifySymbol: varName under: protocol</body><body package="PackageCategories">containingPackages	"Answer all the packges that contain the definition for the receiver, 	including overriden."	^Registry allContainingPackagesForClassOrNameSpace: self actual</body><body package="PackageCategories">organization	^self value organization</body><body package="PackageCategories">renameCategory: oldCategory to: newCategory	^self value renameCategory: oldCategory to: newCategory</body><body package="PackageCategories">reorganize	self actual reorganize</body><body package="PackageCategories">selectors	^self actual selectors</body><body package="PackageCategories">simpleName	^self name</body><body package="PackageCategories">value	"Implemented by any subclass wanting to be displayed in a browser"	^self myClass</body><body package="PackageCategories">valueOrDo: aBlock 	"Implemented by any subclass wanting to be displayed in a browser"	^self myClass</body><body package="PackageCategories">withAllSuperclasses	^self actual withAllSuperclasses</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>printing</category><body package="PackageCategories">displayString		^meta 		ifTrue: [ self name fullMetaName ]		ifFalse: [ self name ]</body><body package="PackageCategories">instanceBehavior	"Give a class name answer a class."	^self fullClassName asStrictReference valueOrDo: [ nil ]</body><body package="PackageCategories">printOn: aStream	aStream nextPutAll: self class name, '(', 		( SystemUtils convertAbsoluteNameToFull: fullClassName ) , ')'.</body></methods><methods><class-id>Store.ClassDescriptor</class-id> <category>filing out</category><body package="PackageCategories">fileOutSourceOn: aStream	"File the receiver out on aSourceFileManager."	self actual == nil		ifFalse: [ self actual fileOutSourceOn: aStream ].</body></methods><methods><class-id>Store.ClassDescriptor class</class-id> <category>instance creation</category><body package="PackageCategories">fromModel: aClassModel	^self fullName: aClassModel absoluteName meta: false "aClassModel isMeta."</body><body package="PackageCategories">fullName: aName meta: aBoolean	^self new		fullClassName: aName;		meta: aBoolean;		yourself.</body></methods><methods><class-id>Tools.MethodFilterPundle</class-id> <category>private</category><body package="PackageCategories">dataKeyCacheFor: aClass		^(self subdefCacheFor: aClass) at: 3</body><body package="PackageCategories">privateSelectClass: aClass		namesCache ifNil: [namesCache := self pundle allClasses collect: [:eachClass | eachClass absoluteName]].	^namesCache includes: aClass instanceBehavior absoluteName</body><body package="PackageCategories">privateSelectClass: aClass selector: aSymbol method: method	^self pundle includesSelector: aSymbol className: aClass absoluteName meta: aClass isMeta</body><body package="PackageCategories">selectNameSpace: aNameSpace key: aString binding: binding	^self pundle includesDataKey: aString ownerName: aNameSpace absoluteName</body><body package="PackageCategories">selectorCacheFor: aClass		| array |	array := self subdefCacheFor: aClass.	^aClass isMeta		ifTrue: [array at: 2]		ifFalse: [array first]</body><body package="PackageCategories">subdefCacheFor: aClass	"Answer an array of a classes subdefinitions: instance selectors, class selectors and static keys"		| class |	subdefCache ifNil: [subdefCache := Dictionary new].	class := aClass isForClass		ifTrue: [aClass instanceBehavior]		ifFalse: [aClass].	^subdefCache		at: class		ifAbsentPut:			[Array				with: (self pundle selectorsMeta: false forClassName: class absoluteName) asSet				with: (self pundle selectorsMeta: true forClassName: class absoluteName) asSet				with: (self pundle dataKeysForName: class absoluteName) asSet]</body></methods><methods><class-id>Tools.MethodFilterPundle</class-id> <category>printing</category><body package="PackageCategories">auxiliaryDisplayString	^isForPackage		ifTrue: ['in package &lt;1s&gt;' expandMacrosWith: pundleName]		ifFalse: ['in bundle &lt;1s&gt;' expandMacrosWith: pundleName]</body><body package="PackageCategories">displayString	^isForPackage		ifTrue: ['In package &lt;1s&gt;' expandMacrosWith: pundleName]		ifFalse: ['In bundle &lt;1s&gt;' expandMacrosWith: pundleName]</body></methods><methods><class-id>Tools.MethodFilterPundle</class-id> <category>accessing</category><body package="PackageCategories">bundleName: aName	pundleName := aName.	isForPackage := false</body><body package="PackageCategories">packageName: aName	pundleName := aName.	isForPackage := true</body><body package="PackageCategories">pundle		pundleCache		ifNil:			[pundleCache := isForPackage				ifTrue: [Store.Registry packageNamed: pundleName]				ifFalse: [Store.Registry bundleNamed: pundleName]].	^pundleCache</body></methods><methods><class-id>Tools.MethodFilterPundle</class-id> <category>ordering</category><body package="PackageCategories">priority	^8</body></methods><methods><class-id>Store.Changes</class-id> <category>printing</category><body package="PackageCategories">printOn: aStream 	"Append to the argument aStream a sequence of characters that 	identifies the receiver."	self putStatsOn: aStream</body></methods><methods><class-id>Store.Changes</class-id> <category>testing</category><body package="PackageCategories">isAdded	^self defChangesIncludes: #add</body><body package="PackageCategories">isChanged	^self defChangesIncludes: #change</body><body package="PackageCategories">isCommented		^self defChangesIncludes: #comment</body><body package="PackageCategories">isDataModified	^( self getDataChangesIfNone: [ ^false ] ) size &gt; 0</body><body package="PackageCategories">isDefinitionChanged	self subclassResponsibility</body><body package="PackageCategories">isDefinitionRemoved	^self defChangesIncludes: #removeDefinition</body><body package="PackageCategories">isForClass	^false</body><body package="PackageCategories">isForNameSpace	^false</body><body package="PackageCategories">isModified	^( defChanges size &gt; 0 )  |   ( dataChanges size &gt; 0 )</body><body package="PackageCategories">isOverridden	^self defChangesIncludes: #override</body><body package="PackageCategories">isRelocated	^self defChangesIncludes: #relocate</body><body package="PackageCategories">isRemoved	^self defChangesIncludes: #remove</body><body package="PackageCategories">isRenamed	^self defChangesIncludes: #rename</body><body package="PackageCategories">isSharedChangedOrAddedSymbol: aSymbol	| change |	dataChanges ifNil: [^false].	change := dataChanges at: aSymbol ifAbsent: [^false].	^#(#change #add) includes: change.</body></methods><methods><class-id>Store.Changes</class-id> <category>private-access</category><body package="PackageCategories">alterChanges	defChanges isNil ifTrue: [ defChanges := Set new ].	^defChanges</body><body package="PackageCategories">alterDataChanges	dataChanges isNil ifTrue: [dataChanges := IdentityDictionary new].	^dataChanges</body><body package="PackageCategories">getDataChangesIfNone: aBlock	dataChanges isNil ifTrue: [ ^aBlock value ].	^dataChanges</body><body package="PackageCategories">getDefChangesIfNone: aBlock	defChanges isNil ifTrue: [ ^aBlock value ].	^defChanges</body><body package="PackageCategories">removeSharedChangeForKey: aSymbol forTypes: aCollection	| changes |	changes := self getDataChangesIfNone: [^self].	aCollection do: 		[:each | 		((changes at: aSymbol ifAbsent: [nil]) == each) ifTrue: 			[changes removeKey: aSymbol ifAbsent: [nil]]]</body></methods><methods><class-id>Store.Changes</class-id> <category>private-queries</category><body package="PackageCategories">defChangesIncludes: aSymbol		^(self getDefChangesIfNone: [^false]) includes: aSymbol</body><body package="PackageCategories">modifiedKeysSubdefChanges: subdefChanges	| mods |	mods := OrderedCollection new.	subdefChanges isNil 		ifFalse: 			[ subdefChanges keysAndValuesDo: 				[ :key :changeType | 				( changeType ~~ #remove ) &amp; ( changeType ~~ #override )					ifTrue: [ mods add: key ]				]			].	^mods</body><body package="PackageCategories">nameSpaceChangeTypes	^#( #add #removeDefinition #remove #change #rename #reorganize #comment )</body><body package="PackageCategories">overrideKeysSubdefChanges: subdefChanges		| modifications |	modifications := OrderedCollection new.	subdefChanges ifNotNil:		[subdefChanges keysAndValuesDo:			[:key :changeType | 			changeType == #override ifTrue: [modifications add: key]]].	^modifications</body><body package="PackageCategories">removedKeysSubdefChanges: subdefChanges	| mods |	mods := OrderedCollection new.	subdefChanges isNil ifFalse: 		[		subdefChanges keysAndValuesDo: 			[ :key :changeType | 			changeType == #remove ifTrue: [ mods add: key ]			]		].	^mods</body></methods><methods><class-id>Store.Changes</class-id> <category>accessing</category><body package="PackageCategories">itemCount	^defChanges size + dataChanges size</body><body package="PackageCategories">modifiedDataKeys	^self modifiedKeysSubdefChanges: ( self getDataChangesIfNone: [ nil ] )</body><body package="PackageCategories">modifiedTags	"Answer a collection of tags for changed or add definitions,	methods or data, not including removed definitions."	self subclassResponsibility</body><body package="PackageCategories">oldName 	| name |	name := (self getDefChangesIfNone: [self error: 'class changes empty']) 					detect: [ :x | x isString and: [ 'oldName: *' match: x ] ] 					ifNone: [ ^'ERROR oldName not found' asSymbol ].	^(Compiler preferredParserClass new scanTokens: name) last asSymbol</body><body package="PackageCategories">reflection	"Answer a reflection of the receiver- the opposite of any change."	| reflection |	reflection := self class symbol: symbol.	( self getDefChangesIfNone: [ #() ] ) do:		[ :type | reflection doChangeType: ( self reverse: type )	].	self dataChanges do:		[ :change | reflection doSubdefChange: ( self subdefReverse: change ) ].	^reflection.</body><body package="PackageCategories">removedDataKeys	^self removedKeysSubdefChanges: (self getDataChangesIfNone: [nil])</body><body package="PackageCategories">removedTags	"Answer a collection of tags for removed definitions, methods or data."	self subclassResponsibility</body><body package="PackageCategories">symbol	"class or namespace symbol"	^symbol</body><body package="PackageCategories">symbol: aSymbol	"class or namespace symbol"	symbol := aSymbol asSymbol</body></methods><methods><class-id>Store.Changes</class-id> <category>private-changes</category><body package="PackageCategories">commentChanges		^#(#comment)</body><body package="PackageCategories">defChanges		^#(#add #removeDefinition #remove #change #rename #changeMeta)</body><body package="PackageCategories">modifyAll	"For cases where we don't know what changed, assume everything changed."		self initializeChanges.	#(#change #reorganize #comment) do: [:each | self alterChanges add: each]</body><body package="PackageCategories">reverse: changeType	"Answer a change that reflects the opposite of changeType 	- for ChangeSet reflections."	changeType == #add		ifTrue: [ ^#remove ].	changeType == #remove		ifTrue: [ ^#add ].	changeType == #removeDefinition		ifTrue: [ ^#add ].	^changeType</body><body package="PackageCategories">subdefChanges: subdefChanges changeType: changeType key: key	"Process the subdef change.	For overrides, both an override and a remove come through and the net result should be no change.	When changeType is add and old is remove, it would seem that adding a #change would be right.	Also, when changeType is remove and old is #add, it would seem that removing the key is right.	In fact, though, the system only works properly, when the actions are reverse of what you would expect!"		| oldType |	self deprecated: #(#version '7.8' #sunset '8.0' #use #subdefChanges:changeType:key:forShared:).	changeType == #removeChanges ifTrue: 		[^subdefChanges removeKey: key ifAbsent: [nil]].	oldType := subdefChanges at: key ifAbsent: [#none].	changeType == #override ifTrue:		[^(oldType == #remove or: [oldType == #change]) 			ifTrue: [subdefChanges removeKey: key ifAbsent: [nil]] 			ifFalse: [subdefChanges at: key put: #override]].	(oldType == #override and: [changeType == #remove]) ifTrue: 		[^subdefChanges removeKey: key ifAbsent: [nil]].	changeType == #add &amp; (oldType == #remove) ifTrue: 		[^subdefChanges removeKey: key ifAbsent: [nil]].	changeType == #remove &amp; (oldType == #add) ifTrue: 		[^subdefChanges at: key put: #change].	changeType == #change &amp; (oldType == #add) ifTrue: 		[^self].	subdefChanges at: key put: changeType</body><body package="PackageCategories">subdefChanges: subdefChanges changeType: changeType key: key forShared: ignored	"Process the subdef change.	For overrides, both an override and a remove come through and the net result should be no change.	When changeType is add and old is remove, it would seem that adding a #change would be right.	Also, when changeType is remove and old is #add, it would seem that removing the key is right.	In fact, though, the system only works properly, when the actions are reverse of what you would expect!"	| oldType |	changeType == #removeChanges		ifTrue: [^subdefChanges removeKey: key ifAbsent: [nil]].	oldType := subdefChanges at: key 		ifAbsent: [^self subdefChanges: subdefChanges changeType: changeType newKey: key].	changeType == #override		ifTrue: 			[(oldType == #change or: [oldType == #add]) ifTrue: [^self].			^oldType == #remove				ifTrue: [subdefChanges removeKey: key ifAbsent: [nil]]				ifFalse: [subdefChanges at: key put: #override]].	(changeType == #add and: [oldType == #remove])		ifTrue: [^subdefChanges at: key put: #change].	(changeType == #remove and: [oldType == #add or: [oldType == #override]])		ifTrue: [^subdefChanges removeKey: key ifAbsent: [nil]].	((changeType == #change and: [oldType == #add])		or: [changeType == #add and: [oldType == #change]]) 			ifTrue: [^self].	subdefChanges at: key put: changeType</body><body package="PackageCategories">subdefChanges: subdefChanges changeType: changeType newKey: key	"This is the special case in #subdefChanges:changeType:key:forShared: when oldType==#none.	Replace all 'oldType' with #none, then repeatedly reduce conditions that evaluate to false."	subdefChanges at: key put: changeType</body><body package="PackageCategories">subdefReverse: aChange	"Reverse a change to reflect the opposite of aChange's changeType 	- for ChangeSet reflections."	aChange isAdd		ifTrue: [ ^aChange remove; yourself ].	aChange isRemove		ifTrue: [ ^aChange add; yourself ].	^aChange</body></methods><methods><class-id>Store.Changes</class-id> <category>initialize-release</category><body package="PackageCategories">initialize	self initializeChanges.	self initializeSubdefChanges</body><body package="PackageCategories">initializeChanges	defChanges := nil.</body><body package="PackageCategories">initializeDataChanges	dataChanges := nil.</body><body package="PackageCategories">initializeSubdefChanges	dataChanges := nil.</body></methods><methods><class-id>Store.Changes</class-id> <category>changes</category><body package="PackageCategories">doChangeType: aSymbol	"Make change 'changeType' to the receiver.	If the  class/namespace was previously removed		removing again is redundant and may indicate problems		adding (after a remove) is like changing everything - cannot be add because of possible future remove		if overriding, clear the removal, to clear ChangeSet		If the type is comment on a removed then don't do anything, the comment will go away with the class/namespace.		some other kind of modification should not occur, assume we missed an add	if the class/namespace was previously added		removing clears all changes:  X - X = 0		adding is redundant		other modifications are legitimate but are already covered in the add state	if the class/namespace was not changed or was modified		removing should become removal (only)		adding to an unchanged becomes an add, but to something with changes should not occur		other modifications are included in the set of modifications.	For overrides, both an override and a remove come through and the net result should be no change."		| nowRemoved nowAdded |	aSymbol ifNil: [self raiseInvalidTypeError].	nowRemoved := (aSymbol == #removeDefinition) or: [aSymbol == #remove].	nowAdded := aSymbol == #add.	aSymbol == #override ifTrue:		[^(self isRemoved or: [self isDefinitionRemoved])			ifTrue: [self initializeChanges]			ifFalse: [self alterChanges add: aSymbol]].	nowRemoved ifTrue: [self isOverridden ifTrue: [^self alterChanges remove: #override ifAbsent: [nil]]].	(self isRemoved or: [self isDefinitionRemoved]) ifTrue:		[^nowRemoved ifFalse: [aSymbol == #comment ifFalse: 			[self initializeChanges].			self alterChanges add: aSymbol]].	self isAdded		ifTrue:			[nowRemoved				ifTrue: 					[self initializeChanges]				ifFalse:					[| changes |					changes := self alterChanges.					nowAdded ifTrue:						[changes size = 0 ifFalse: [self alterChanges remove: #override ifAbsent: [nil]]].					changes add: aSymbol]]		ifFalse:			[nowRemoved				ifTrue:					[self initializeChanges. self alterChanges add: aSymbol]				ifFalse:					[| changes |					changes := self alterChanges.					nowAdded ifTrue:						[changes size = 0 ifFalse: [self alterChanges remove: #override ifAbsent: [nil]]].					changes add: aSymbol]]</body><body package="PackageCategories">raiseErrorIfInvalid: aChange		aChange isValid ifFalse: [self raiseInvalidTypeError]</body><body package="PackageCategories">raiseInvalidTypeError		self error: (#ChangeObjectTypeIsNil &lt;&lt; #store &gt;&gt; 'Change object type is nil.&lt;n&gt;All change objects must have a type') asString</body><body package="PackageCategories">removeDefChanges: aCollection	| changes |	changes := self alterChanges.	aCollection do: [:each | changes remove: each ifAbsent: [nil]]</body><body package="PackageCategories">renameOldSymbol: oldSymbol 	"Include indication that a namespace/class has been renamed."	"only original name of pre-existing class matters"	( ( self isRenamed ) 	or: [ self isAdded ] )		ifFalse: 			[ self alterChanges add: 'oldName: ' , oldSymbol.			self alterChanges add: #rename			]</body></methods><methods><class-id>Store.Changes</class-id> <category>fileIn/Out</category><body package="PackageCategories">fileOutDataChangesFor: aClassOrNameSpace for: aPackage within: aBundle on: fileManager		| removes changes changedShareds |	removes := OrderedCollection new.	changes := OrderedCollection new.	changedShareds := self getDataChangesIfNone: [nil].	changedShareds ifNotNil:		[changedShareds keysAndValuesDo:			[:key :change | 			change = #remove 				ifTrue: [(self isRemoved or: [self isDefinitionRemoved]) ifFalse: [removes add: key]]				 ifFalse: [changes add: key]]].	changes isEmpty ifFalse: [fileManager fileOutData: changes for: aClassOrNameSpace asNameSpace].	removes do:		[:key | 		(aBundle notNil and: [aBundle includesDataKey: key ownerName: symbol asString])			ifFalse: [fileManager removeObject: aClassOrNameSpace fullName , '.' , key type: #variable]]</body><body package="PackageCategories">fileOutDataChangesFor: object on: fileManager within: aBundle	| removes changes dChanges |	removes := OrderedCollection new.	changes := OrderedCollection new.	dChanges := self getDataChangesIfNone: [ nil ].	dChanges notNil ifTrue: 		[ dChanges keysAndValuesDo: 			[ :key :change | 			change = #remove				ifTrue: [ ( self isRemoved or: [ self isDefinitionRemoved ] ) 						ifFalse: [ removes add: key ] ]				ifFalse: [ changes add: key ]			]		].	changes isEmpty ifFalse: 		[ fileManager fileOutData: changes for: object asNameSpace ].	removes do:		[ :key |		( ( aBundle ~~ nil ) and: 				[ aBundle includesDataKey: key ownerName: symbol asString ] )			ifFalse: [ fileManager removeObject: object fullName, '.', key type: #variable ]		].</body><body package="PackageCategories">fileOutObjectType	"Answer a symbol that represents the type of the receiver."	^self subclassResponsibility</body><body package="PackageCategories">putDataStatsOn: stream 	| removes changes adds |	removes := OrderedCollection new.	changes := OrderedCollection new.	adds := OrderedCollection new.	(self getDataChangesIfNone: [ ^self] )		keysAndValuesDo: [:mSel :mChange | mChange = #remove				ifTrue: [removes add: mSel]				ifFalse: [mChange = #change						ifTrue: [changes add: mSel]						ifFalse: [adds add: mSel]]].	adds isEmpty		ifFalse: 			[stream tab; tab; nextPutAll: (#AddedDataC &lt;&lt; #packages &gt;&gt; 'Added data:') asString; cr.			adds do: [:dataKey | stream tab; tab; tab; nextPutAll: dataKey; cr]].	changes isEmpty		ifFalse: 			[stream tab; tab; nextPutAll: (#ChangedDataC &lt;&lt; #packages &gt;&gt; 'Changed data:') asString; cr.			changes do: [:dataKey | stream tab; tab; tab; nextPutAll: dataKey; cr]].	removes isEmpty		ifFalse: 			[stream tab; tab; nextPutAll: (#RemovedDataC &lt;&lt; #packages &gt;&gt; 'Removed data:') asString; cr.			removes do: [:dataKey | stream tab; tab; tab; nextPutAll: dataKey; cr]]</body></methods><methods><class-id>Store.Changes</class-id> <category>actions</category><body package="PackageCategories">forgetDataChange: dataKey	"Forget all changes relating to a dataKey"	( self getDataChangesIfNone: [ ^nil ] )		removeKey: dataKey ifAbsent: nil.</body><body package="PackageCategories">forgetTag: aTag	"Forget changes associated with aTag."		aTag isCommentTag ifTrue: [^self removeDefChanges: self commentChanges].	aTag isForClass | aTag isForNameSpace ifTrue: [^self removeDefChanges: self defChanges].	aTag isForData ifTrue: [^self forgetDataChange: aTag dataKey].	aTag isForMethod ifTrue: [^self forgetMethod: aTag selector meta: aTag isMeta]</body></methods><methods><class-id>Store.Changes class</class-id> <category>instance creation</category><body package="PackageCategories">symbol: aSymbol	^self new		symbol: aSymbol;		yourself.</body></methods><methods><class-id>Store.NameSpaceChanges</class-id> <category>changes</category><body package="PackageCategories">doSubdefChange: aChange		self raiseErrorIfInvalid: aChange.	self		subdefChanges: self alterDataChanges		changeType: aChange type		key: aChange key		forShared: false</body></methods><methods><class-id>Store.NameSpaceChanges</class-id> <category>testing</category><body package="PackageCategories">isDefinitionChanged	^self defChangesIncludes: #change</body><body package="PackageCategories">isForNameSpace	^true</body><body package="PackageCategories">isNonDestructivelyModified	( self getDefChangesIfNone: [ ^false ] ) do: 		[ :changeType | 		( #( #add #change #reorganize #comment ) 				includes: changeType )  ifTrue: [ ^true ] 		].	^false</body><body package="PackageCategories">isReorganized	^self defChangesIncludes: #reorganize</body></methods><methods><class-id>Store.NameSpaceChanges</class-id> <category>fileIn/Out</category><body package="PackageCategories">fileOutChangesFor: aNamespace for: aPackage within: aBundle on: aSourceFileManager	"Write out all the changes the receiver knows about this namespace."	self fileOutDefChanges: aNamespace on: aSourceFileManager.	self fileOutDataChangesFor: aNamespace for: aPackage within: aBundle on: aSourceFileManager.</body><body package="PackageCategories">fileOutDefChanges: aNamespace on: aSourceFileManager	"Write out nanespace changes.  i.e.  new namespace, definition, comment, renaming."		self isRenamed ifTrue:		[aSourceFileManager			rename: aNamespace fullName			from: self oldName			type: #nameSpace].	(self isAdded or: [self isDefinitionChanged]) ifTrue: 		[aNamespace fileOutDefinitionOn: aSourceFileManager].	self isCommented ifTrue: 		[aNamespace fileOutCommentOn: aSourceFileManager]</body><body package="PackageCategories">putDefStatsOn: aStream	self isAdded ifTrue:		[aStream nextPutAll: (#NameSpaceAdded &lt;&lt; #packages &gt;&gt; 'NameSpace added.') asString; cr].	self isRenamed ifTrue:		[aStream nextPutAll: (#NameSpaceRenamedFrom1sN &lt;&lt; #packages &gt;&gt; 'NameSpace renamed from &lt;1s&gt;.&lt;n&gt;' expandMacrosWith: self oldName); cr].	self isDefinitionRemoved ifTrue:		[aStream nextPutAll: (#NameSpaceDefinitionRemoved &lt;&lt; #packages &gt;&gt; 'NameSpace definition removed.') asString; 	cr].	self isDefinitionChanged ifTrue:		[aStream nextPutAll: (#NameSpaceRedefined &lt;&lt; #packages &gt;&gt; 'NameSpace redefined.') asString; cr].	self isRemoved ifTrue:		[aStream nextPutAll: (#NameSpaceRemoved &lt;&lt; #packages &gt;&gt; 'NameSpace removed.') asString; cr].	self isReorganized ifTrue:		[aStream nextPutAll: (#NameSpaceReorganized &lt;&lt; #packages &gt;&gt; 'NameSpace reorganized.') asString; cr].	self isCommented ifTrue:		[aStream nextPutAll: (#NameSpaceCommentChanged &lt;&lt; #packages &gt;&gt; 'NameSpace comment changed.') asString; cr].	self isOverridden ifTrue:		[aStream nextPutAll: (#NameSpaceOverridden &lt;&lt; #packages &gt;&gt; 'NameSpace overridden.') asString; cr]</body><body package="PackageCategories">putStatsOn: stream	self putDefStatsOn: stream.	self isDataModified		ifTrue: 			[stream				nextPutAll: (#DataChangedC &lt;&lt; #packages &gt;&gt; 'Data changed:') asString;				cr.			self putDataStatsOn: stream]</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>printing</category><body package="PackageCategories">asMethodString	| string |	string := ( SystemUtils convertAbsoluteNameToFull: self className ), ' '.	self isMeta		ifTrue: [ string := string, 'class  ' ].	^string, self itemString.</body><body package="PackageCategories">displayString	^self itemString</body><body package="PackageCategories">itemString	^self name , self versionString</body><body package="PackageCategories">printOn: aStream		aStream		nextPutAll: self classNameWithMeta;		nextPutAll: '&gt;&gt;';		nextPutAll: self protocolName;		nextPutAll: '&gt;&gt;';		nextPutAll: self selector asString</body><body package="PackageCategories">versionString	^''</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>accessing browser</category><body package="PackageCategories">asString	^self name.</body><body package="PackageCategories">name 	^self selector asString</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>accessing</category><body package="PackageCategories">absoluteClassName	^fullClassName</body><body package="PackageCategories">className	^fullClassName</body><body package="PackageCategories">classNameWithMeta	^self isMeta		ifTrue: [self fullClassName, ' class']		ifFalse: [self fullClassName].</body><body package="PackageCategories">containingPackages	"Answer all the packges that contain the definition for the receiver, 	including overriden."		| class |	(class := self implementingClass) ifNil: [^OrderedCollection new].	^Registry		allContainingPackagesForSelector: self selector		class: class</body><body package="PackageCategories">definition	^self sourceCode</body><body package="PackageCategories">definitionString	^self sourceCode</body><body package="PackageCategories">environment	^self owner</body><body package="PackageCategories">fullClassName	^fullClassName</body><body package="PackageCategories">fullClassName: aString	aString namesMetaClass ifTrue: [ self notify: #InvalidClassName &lt;&lt; #packages &gt;&gt; 'Invalid class name'  ].	fullClassName := aString</body><body package="PackageCategories">fullName	^self classNameWithMeta, '&gt;&gt;', self name</body><body package="PackageCategories">implementingClass	^self myClass</body><body package="PackageCategories">meta: aBoolean	meta := aBoolean</body><body package="PackageCategories">method		| class |	(class := self myClass) ifNil: [^nil].	^class		compiledMethodAt: self selector		ifAbsent: [nil]</body><body package="PackageCategories">methodSources		| class |	^[(class := self myClass) isNil		ifTrue: [MethodSourceCollection source: (#NonexistentClass &lt;&lt; #packages &gt;&gt; 'Non-existent class') asString]		ifFalse: [class methodSourcesAt: self selector]]			on: KeyNotFoundError			do: 				[:exception | 				exception return: (MethodSourceCollection source: (#SourceUnavailable &lt;&lt; #packages &gt;&gt; 'Source unavailable.') asString)]</body><body package="PackageCategories">myClass	| cls |	cls := self fullClassName asStrictReference valueOrDo: [ ^nil ].	^self isMeta ifTrue: [ cls class ] ifFalse: [ cls ].</body><body package="PackageCategories">owner	| cls |	cls := self fullClassName asStrictReference valueOrDo: [ ^nil ].	^self isMeta ifTrue: [ cls class ] ifFalse: [ cls ].</body><body package="PackageCategories">ownerName	^fullClassName</body><body package="PackageCategories">protocol	"Do lazy evaluation of protocol name, since method may not	have been installed in class when a change is registered." 	protocol isNil ifTrue: [self protocol: (self classFromClassName organization categoryOfElement: self selector)].	^protocol</body><body package="PackageCategories">protocol: aValue	protocol := aValue</body><body package="PackageCategories">protocolName	self protocol isNil ifTrue: [^''].	^self protocol asString</body><body package="PackageCategories">selector	^selector</body><body package="PackageCategories">selector: aValue	selector := aValue</body><body package="PackageCategories">sourceCode		| class |	^[(class := self myClass) isNil		ifTrue: [(#NonexistentClass &lt;&lt; #packages &gt;&gt; 'Non-existent class') asString]		ifFalse: [(class sourceCodeAt: self selector) ifNil: [(#SourceUnavailable &lt;&lt; #packages &gt;&gt; 'Source unavailable.') asString]]]			on: KeyNotFoundError			do: [:exception | exception return: (#SourceUnavailable &lt;&lt; #packages &gt;&gt; 'Source unavailable.') asString]</body><body package="PackageCategories">stDocumentation	^self compiledMethod stDocumentation</body><body package="PackageCategories">stDocumentation: docString"	self compiledMethod stDocumentation: docString  "</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>testing</category><body package="PackageCategories">hasMethod	^self method notNil</body><body package="PackageCategories">isForMethod			^true</body><body package="PackageCategories">isMeta	^meta</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>private-testing</category><body package="PackageCategories">existsInImage	"Answer true if the receiver is a valid description of an existing method."	| class prot |	( class := self myClass ) == nil ifTrue: [ ^false ].	prot := class organization categoryOfElement: self selector.	prot isNil ifTrue: [ ^false ].	prot ~= self protocol ifTrue: [ ^false ].	^true</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>comparing</category><body package="PackageCategories">= aThing	^self sameAs: aThing</body><body package="PackageCategories">comparesTo: anObject	"Answer true if anObject could be another version of the receiver."		(self objectIsForSelf: anObject) ifFalse: [^false].	^anObject selector = self selector and: [anObject classNameWithMeta = self classNameWithMeta]</body><body package="PackageCategories">hash	^self classNameWithMeta hash + self selector hash</body><body package="PackageCategories">objectIsForSelf: anObject	"Answer true if anObject represents the same kind of thing as the reciever."	^anObject isForMethod</body><body package="PackageCategories">sameAs: aMethod	"Browsers are only interested in the selector...."		aMethod isSymbol ifTrue: [^self selector == aMethod].	((aMethod respondsTo: #isForData) and: [aMethod isForData]) ifTrue: [^false].	^aMethod sameAsImThing: self</body><body package="PackageCategories">sameAsImThing: aMethod 	((aMethod respondsTo: #isForData) and: [aMethod isForData]) ifTrue: [ ^false ].	^self classNameWithMeta = aMethod classNameWithMeta 		and: [ self selector = aMethod selector ].</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>private</category><body package="PackageCategories">classFromClassName	"className is either a class name or a class name followed by ' class'.  Answer the class or metaclass it names.  Changed to use meta var- DS" 	| class |	class := fullClassName asStrictReference valueOrDo: 		[ self error: (#CannotFindClass &lt;&lt; #packages &gt;&gt; 'Cannot find class'). ^nil ].	^meta		ifTrue: [ class class ]		ifFalse: [ class ]</body><body package="PackageCategories">compiledMethod	"Answer the compiled method"	| mclass |	mclass := self myClass.	mclass isNil		ifTrue: 			[self error: (#MethodRefersToBogusClass &lt;&lt; #packages &gt;&gt; 'Method refers to non existing class').			^self].	^mclass compiledMethodAt: self selector.</body><body package="PackageCategories">fileOutOn: aSourceCodeStream		| d |	d := Dictionary new.	d at: self protocol put: ( Set with: self ).	aSourceCodeStream fileOutTTMessages: d for: self classNameWithMeta logging: false.</body><body package="PackageCategories">loadAsNew	"Do nothing since I'm already in the image."	^true</body><body package="PackageCategories">loadAsNewIn: imgPackage	"Do nothing since I'm already in the image."	^true</body><body package="PackageCategories">loadSrcIntoPackage: imPkg confirm: aBoolean	"Do nothing since I'm already in the image."</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>bogus</category><body package="PackageCategories">forDbPackage	"Answer an array with a first element being a class and second	being a selector. This method is used for the DB package creation."	^Array with: self myClass with: self selector</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>utils</category><body package="PackageCategories">isMetaclassMethod	"Answer true if the class is meta class"	^meta</body></methods><methods><class-id>Store.MethodDescriptor</class-id> <category>accessing externals</category><body package="PackageCategories">fillDefineCacheIn: anExternalInterface	| myExternal |	myExternal := ExternalInterface bindingDefinedByMethod: self method.	myExternal isNil ifTrue: [^nil].	^anExternalInterface externals at: myExternal key put: myExternal value</body></methods><methods><class-id>Store.MethodDescriptor class</class-id> <category>instance creation</category><body package="PackageCategories">fromSelector: aSelector class: class 	^self new		selector: aSelector; 		protocol: (class organization categoryOfElement: aSelector); 		fullClassName: class  absoluteName asClassNameOnly;		meta: class isMeta;		yourself.</body><body package="PackageCategories">fromSelector: aSelector className: className meta: boolean  	^self new		selector: aSelector; 		fullClassName: className asClassNameOnly;		meta: boolean;		yourself</body></methods><methods><class-id>Store.BasicTableSpacePolicy</class-id> <category>accessing</category><body package="PackageCategories">blobTableSpace	^blobTableSpace</body><body package="PackageCategories">blobTableSpace: aString	blobTableSpace := aString</body><body package="PackageCategories">defaultTableSpace	^defaultTableSpace</body><body package="PackageCategories">defaultTableSpace: aString	defaultTableSpace := aString</body><body package="PackageCategories">methodsTableSpace	^methodsTableSpace</body><body package="PackageCategories">methodsTableSpace: aString	methodsTableSpace := aString</body><body package="PackageCategories">userAndOwnershipTableSpace	^userAndOwnershipTableSpace</body><body package="PackageCategories">userAndOwnershipTableSpace: aString	userAndOwnershipTableSpace := aString</body></methods><methods><class-id>Store.BasicTableSpacePolicy</class-id> <category>initialize-release</category><body package="PackageCategories">initialize	blobTableSpace := 'NEWBERN1'.	defaultTableSpace := 'NEWBERN2'.	methodsTableSpace := 'NEWBERN2'.	userAndOwnershipTableSpace := 'NEWBERN2'.</body></methods><methods><class-id>Store.BasicTableSpacePolicy</class-id> <category>testing</category><body package="PackageCategories">allTableSpacesAreEqual	^blobTableSpace = defaultTableSpace and: 		[blobTableSpace = methodsTableSpace and:		[blobTableSpace = userAndOwnershipTableSpace]]</body></methods><methods><class-id>Store.BasicTableSpacePolicy class</class-id> <category>instance creation</category><body package="PackageCategories">new	^super new initialize</body></methods><methods><class-id>Store.BasicTableSpacePolicy class</class-id> <category>class initialization</category><body package="PackageCategories">initialize	Policies tableSpacePolicy ifNil: [Policies tableSpacePolicy: self new]</body></methods><methods><class-id>Store.ModelForParcel</class-id> <category>initialization</category><body package="PackageCategories">from: aModel	object := aModel actual.	hasDefinition := aModel hasDefinition.	data := aModel dataKeys.</body></methods><methods><class-id>Store.ModelForParcel</class-id> <category>testing</category><body package="PackageCategories">hasDefinition	^hasDefinition</body><body package="PackageCategories">isForClass	^false</body><body package="PackageCategories">isForNameSpace	^false</body></methods><methods><class-id>Store.ModelForParcel</class-id> <category>private</category><body package="PackageCategories">isDataKey: key in: aCollection	"Answer true if aClass&gt;&gt;selector is in a Collection of parcel updates."	| binding |	binding := object bindingFor: key.	^aCollection includes: binding.</body><body package="PackageCategories">isObjectIn: aCollection	"Answer true if the receiver's class or namespace is in aCollection."	^aCollection includes: object</body></methods><methods><class-id>Store.ModelForParcel</class-id> <category>accessing</category><body package="PackageCategories">data	"Answer the receiver's static data keys."	^data</body><body package="PackageCategories">object	"Answer the object that receiver represents. 	Note that this may be a 'shadow' object in a partially loaded Parcel."	^object</body></methods><methods><class-id>Store.ModelForParcel class</class-id> <category>instance creation</category><body package="PackageCategories">classForModel: aModel			^aModel isForNameSpace		ifTrue: [ NameSpaceForParcel ]		ifFalse: [ ClassForParcel ]</body><body package="PackageCategories">from: aModel			^( self classForModel: aModel ) new		from: aModel</body></methods><methods><class-id>Store.NameSpaceForParcel</class-id> <category>conversion</category><body package="PackageCategories">addToPackage: aPackage	"Add the receiver to aPackage"		| currentChangeSet |	currentChangeSet := XChangeSet current.	hasDefinition ifTrue: 		[currentChangeSet addNameSpaceDefinition: object toPackage: aPackage].	data do: 		[:each | 		currentChangeSet changeDataKeyForConvert: each nameSpace: object package: aPackage]</body><body package="PackageCategories">updates: updates package: aPackage	"Update aPackage after parcel update."	| cset |	cset :=XChangeSet current.	self hasDefinition		ifTrue:			[ ( ( updates at: #changed ) includes: object )				ifTrue: [ cset changeNameSpace: object toPackage: aPackage ].			( ( updates at: #added ) includes: object )				ifTrue: [ cset addNameSpace: object toPackage: aPackage ].			].	self processDataUpdates: updates package: aPackage.</body></methods><methods><class-id>Store.NameSpaceForParcel</class-id> <category>testing</category><body package="PackageCategories">isForNameSpace	^true</body></methods><methods><class-id>Store.NameSpaceForParcel</class-id> <category>private</category><body package="PackageCategories">processDataUpdates: updates package: aPackage	| cset |	cset :=XChangeSet current.	data do:		[ :key |		( self isDataKey: key in: ( updates at: #added ) )			ifTrue: [ cset addDataKey: key nameSpace: object package: aPackage ].		( self isDataKey: key in: ( updates at: #changed ) )			ifTrue: [ cset changeDataKey: key nameSpace: object package: aPackage ].		].</body></methods><methods><class-id>Store.PackageDescription</class-id> <category>testing</category><body package="PackageCategories">describesPackageNamed: aString	"Answer true if the description referes to a package named aString"	^self componentName = aString</body><body package="PackageCategories">describesSameAs:  aComponentDescr	"Answer true if aComponentDescr referes to	a package named the same as my bundle"	^aComponentDescr isPackage		and: [ self describesPackageNamed: aComponentDescr name ].</body><body package="PackageCategories">isPackage	^true</body></methods><methods><class-id>Store.PackageDescription</class-id> <category>accessing</category><body package="PackageCategories">component	"Find a component named componentName and answer it."	^componentName isNil		ifTrue: [nil]		ifFalse: [Registry packageNamed: componentName]</body><body package="PackageCategories">createComponent	"Return the component with my componentName create it if needed."	componentName isNil ifTrue: [ ^nil ].	^Registry packageNamedOrCreate: componentName.</body></methods><methods><class-id>Store.PackageDescription</class-id> <category>private</category><body package="PackageCategories">leafItems	"My component is a leaf item."	| comp |	comp := self component.	^comp isNil		ifTrue: [#()]		ifFalse: [Array with: comp]</body></methods><methods><class-id>Store.StoreWarning</class-id> <category>private - actions</category><body package="PackageCategories">defaultAction	"Display a notifier and then continue. Returns nothing of interest to the signaller."	^Dialog warn: self description</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>testing</category><body package="PackageCategories">areMethodsModifiedMeta: meta	^(self getMethodChangesMeta: meta ifNone: [^false]) size &gt; 0</body><body package="PackageCategories">isClassChangedMeta: meta	^self defChangesIncludes: (meta ifTrue: [#changeMeta] ifFalse: [#change])</body><body package="PackageCategories">isClassModifiedMeta: meta	| localDefChanges classChangeTypes |	classChangeTypes := self classChangeTypesMeta: meta.	localDefChanges := self getDefChangesIfNone: [Array new].	^localDefChanges anySatisfy: [:changeType | classChangeTypes includes: changeType]</body><body package="PackageCategories">isClassReorganizedMeta: meta	^self defChangesIncludes: (meta ifTrue: [#reorganizeMeta] ifFalse: [#reorganize])</body><body package="PackageCategories">isDefinitionChanged	^( self isClassChangedMeta: false )  | 			 ( self isClassChangedMeta: true )</body><body package="PackageCategories">isDefTypeModified: defType	^defType == #data		ifTrue: [ self isDataModified ]		ifFalse: [ self isMetaModified: ( defType == #meta ) ]</body><body package="PackageCategories">isForClass	^true</body><body package="PackageCategories">isMetaModified: isMeta	^isMeta		ifTrue: [ metaMethodChanges size &gt; 0 ]		ifFalse: [ methodChanges size &gt; 0 ]</body><body package="PackageCategories">isMethodChangedOrAddedSelector: selector meta: meta	| dict |	dict := self getMethodChangesMeta: meta ifNone: [^false].	^#(#change #add) includes: (dict at: selector ifAbsent: [^false])</body><body package="PackageCategories">isMethodChangedSelector: selector meta: meta	| dict |	dict := self getMethodChangesMeta: meta ifNone: [^false].	^(dict at: selector ifAbsent: [^false]) == #change</body><body package="PackageCategories">isModified	^super isModified  |		( methodChanges size &gt; 0 )  |		( metaMethodChanges size &gt; 0 )</body><body package="PackageCategories">isModifiedMeta: meta	(self areMethodsModifiedMeta: meta) ifTrue: [ ^true ].	(self isClassModifiedMeta: meta) ifTrue: [ ^true ].	^false</body><body package="PackageCategories">isNonDestructivelyModified		(self getDefChangesIfNone: [^false]) do: 		[:each | 		(#(#changeMeta #reorganizeMeta #add #change #reorganize #comment) includes: each) 			ifTrue: [^true]].	^false</body><body package="PackageCategories">isReorganized	^( self isClassReorganizedMeta: true )  |		( self isClassReorganizedMeta: false )</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>changes</category><body package="PackageCategories">doSubdefChange: aChange	| aDictionary |	self raiseErrorIfInvalid: aChange.	aDictionary := aChange isDataChange				ifTrue: [self alterDataChanges]				ifFalse: [self alterMethodChangesMeta: aChange meta].	self		subdefChanges: aDictionary		changeType: aChange type		key: aChange key		forShared: false</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>private-queries</category><body package="PackageCategories">classChangeTypesMeta: aBoolean		^aBoolean 		ifTrue: [self metaClassChangeTypes] 		ifFalse: [#(#add #removeDefinition #remove #change #rename #reorganize #comment)]</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>private-changes</category><body package="PackageCategories">modifyAll	"For cases where we don't know what changed 	for the class, assume everything changed."		super modifyAll.	self metaClassChangeTypes do: [:each | self alterChanges add: each]</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>initialize-release</category><body package="PackageCategories">initializeSubdefChanges	methodChanges := nil.	metaMethodChanges := nil.	dataChanges := nil.</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>actions</category><body package="PackageCategories">forgetMethod: aSymbol meta: aBoolean		| selectors |	selectors := self getMethodChangesMeta: aBoolean ifNone: [^self].	selectors removeKey: aSymbol ifAbsent: [nil]</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>accessing</category><body package="PackageCategories">dataChanges	"Answer a collection of Changes for all modified/added/removed statics."	| coll |	dataChanges == nil		ifTrue: [ ^#( ) ].	coll := OrderedCollection new.	dataChanges keysAndValuesDo:		[ :key :type | 		coll add:			( Change new				classSymbol: symbol;				dataKey: key;				perform: type;				yourself				)		].	^coll</body><body package="PackageCategories">itemCount	^super itemCount + methodChanges size + metaMethodChanges size</body><body package="PackageCategories">methodChanges	"Answer a collection of Changes for all modified/added/removed statics."	| coll |	coll := OrderedCollection new.	methodChanges == nil		ifFalse:			[ methodChanges keysAndValuesDo:				[ :key :type | 				coll add:					( Change new						classSymbol: symbol;						selector: key;						perform: type;						yourself						)				].			].	metaMethodChanges == nil		ifFalse:				[ metaMethodChanges keysAndValuesDo:				[ :key :type | 				coll add:					( Change new						classSymbol: symbol, ' class';						selector: key;						perform: type;						yourself						)				].			].	^coll</body><body package="PackageCategories">modifiedDatumDescriptors	^( self getDataChangesIfNone: [ ^#( ) ] ) keys collect:		[ :key  | DatumDescriptor fromDataKey: key className: symbol asString ].</body><body package="PackageCategories">modifiedMethodDescriptorsMeta: isMeta	^( self getMethodChangesMeta: isMeta ifNone: [ ^#( ) ] ) keys collect:		[ :key  | MethodDescriptor fromSelector: key className: symbol asString meta: isMeta ].</body><body package="PackageCategories">modifiedSelectorsMeta: meta 	^self modifiedKeysSubdefChanges: (self getMethodChangesMeta: meta ifNone: [nil])</body><body package="PackageCategories">reflection	"Answer a reflection of the receiver- the opposite of any change."	| reflection |	reflection := super reflection.	self methodChanges do:		[ :change | reflection doSubdefChange: ( self subdefReverse: change ) ].	^reflection.</body><body package="PackageCategories">removedSelectorsMeta: meta 	^self removedKeysSubdefChanges: (self getMethodChangesMeta: meta ifNone: [nil])</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>private-access</category><body package="PackageCategories">alterMethodChangesMeta: aBoolean	^aBoolean		ifTrue: 			[metaMethodChanges isNil ifTrue: [metaMethodChanges := IdentityDictionary new].			metaMethodChanges]		ifFalse: 			[methodChanges isNil ifTrue: [methodChanges := IdentityDictionary new].			methodChanges]</body><body package="PackageCategories">getMethodChangesMeta: meta ifNone: aBlock	| dict |	dict := meta		ifTrue: [metaMethodChanges]		ifFalse: [methodChanges].	dict isNil ifTrue: [^aBlock value].	^dict</body><body package="PackageCategories">removeMethodChangesMeta: aBoolean selector: aSymbol forTypes: aCollection	| changes selectorChange |	changes := self alterMethodChangesMeta: aBoolean.	selectorChange := changes at: aSymbol ifAbsent: [^self].	(aCollection includes: selectorChange)		ifTrue: [changes removeKey: aSymbol ifAbsent: []]</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>fileIn/Out</category><body package="PackageCategories">fileOutChangesFor: aClass for: aPackage within: aBundle on: aSourceFileManager	"Write out all the changes the receiver knows about this class."		aClass isMeta ifFalse:		[self fileOutDefChanges: aClass on: aSourceFileManager.		self fileOutDataChangesFor: aClass for: aPackage within: aBundle on: aSourceFileManager].	self fileOutMethodChangesFor: aClass for: aPackage within: aBundle on: aSourceFileManager</body><body package="PackageCategories">fileOutDefChanges: aClass on: aSourceFileManager	"Write out class changes.  i.e.  new class, definition, comment, renaming.	If the class is to be initialized on fileIn, add the class to aClassCollection.	We don't do anything about meta changes here."		aClass isMeta ifTrue: [^self].		(self isAdded or: [self isClassChangedMeta: false]) ifTrue: 		[aClass fileOutDefinitionOn: aSourceFileManager].	self isRenamed ifTrue:		[aSourceFileManager			rename: aClass fullName			from: self oldName			type: #class].		self isCommented ifTrue: [aClass fileOutCommentOn: aSourceFileManager]</body><body package="PackageCategories">fileOutMethodChangesFor: aClass for: aPackage within: aBundle on: aFileManager	"Write out all the changes the receiver knows about this class."		| changes removes changedMethods workingBundle |	removes := OrderedCollection new.	changes := OrderedCollection new.	changedMethods := self getMethodChangesMeta: aClass isMeta ifNone: [nil].	workingBundle := aBundle ifNotNil: [aBundle isBundle ifTrue: [aBundle]].	changedMethods notNil ifTrue:		[changedMethods keysAndValuesDo:			[:eachSelector :eachType | 			eachType = #remove 				ifTrue: [(self isRemoved or: [self isDefinitionRemoved]) ifFalse: [removes add: eachSelector]] 				ifFalse: [changes add: eachSelector]]].	changes isEmpty ifFalse:		[aFileManager fileOutMessages: changes for: aClass].	removes do:		[:selector | 		((workingBundle notNil and: [workingBundle includesSelector: selector className: symbol asString meta: aClass isMeta]) or:			[aPackage notNil])				ifFalse: [aFileManager removeSelector: selector from: aClass]				ifTrue: [aFileManager component: aPackage definition: aClass selector: selector change: #removed]].	((self isClassReorganizedMeta: aClass isMeta) and: [aClass isBehavior]) ifTrue:			[aFileManager emphasis: #italic.			aFileManager reorganizeObject: aClass.			aFileManager emphasis: nil].		"reinitialize metaclass if necessary"	(aClass isMeta and: [changes includes: #initialize])		ifTrue: [aFileManager initializeThisClass: ((Kernel.ChangeSupportClassProxy pathString: symbol asString) meta: false)]</body><body package="PackageCategories">putDefStatsOn: aStream 	self isAdded ifTrue: [aStream nextPutAll: (#ClassAdded &lt;&lt; #packages &gt;&gt; 'Class added.') asString; cr].	self isRenamed ifTrue: 		[aStream nextPutAll: ((#ClassRenamedFrom1s &lt;&lt; #packages &gt;&gt; 'Class renamed from &lt;1s&gt;.') expandMacrosWith: self oldName); cr].	self isDefinitionRemoved ifTrue: 		[aStream nextPutAll: (#ClassDefinitionRemoved &lt;&lt; #packages &gt;&gt; 'Class definition removed.') asString; cr].	self isRemoved ifTrue: 		[aStream nextPutAll: (#ClassRemoved &lt;&lt; #packages &gt;&gt; 'Class removed.') asString; cr].	(self isClassChangedMeta: false) ifTrue: 		[aStream nextPutAll: (#ClassRedefined &lt;&lt; #packages &gt;&gt; 'Class redefined.') asString; cr].	self isOverridden ifTrue: 		[aStream nextPutAll: (#ClassOverridden &lt;&lt; #packages &gt;&gt; 'Class overridden.') asString; cr ].	(self isClassChangedMeta: true) ifTrue: 		[aStream nextPutAll: (#MetaclassRedefined &lt;&lt; #packages &gt;&gt; 'Metaclass redefined.') asString; cr].	(self isClassReorganizedMeta: false) ifTrue: 		[aStream nextPutAll: (#ClassReorganized &lt;&lt; #packages &gt;&gt; 'Class reorganized.') asString; cr].	(self isClassReorganizedMeta: true) ifTrue: 		[aStream nextPutAll: (#MetaclassReorganized &lt;&lt; #packages &gt;&gt; 'Metaclass reorganized.') asString; cr].	self isCommented ifTrue: 		[aStream nextPutAll: (#ClassCommentChanged &lt;&lt; #packages &gt;&gt; 'Class comment changed.') asString; cr].</body><body package="PackageCategories">putMethodStatsMeta: aBoolean on: aStream 	| removes changes adds overrides |	removes := OrderedCollection new.	changes := OrderedCollection new.	adds := OrderedCollection new.	overrides := OrderedCollection new.	(self getMethodChangesMeta: aBoolean ifNone: [^self]) keysAndValuesDo: 		[:eachSelector :eachChangeType | 		eachChangeType == #remove ifTrue: [removes add: eachSelector].		eachChangeType == #change ifTrue: [changes add: eachSelector].		eachChangeType == #override ifTrue: [overrides add: eachSelector].		eachChangeType == #add ifTrue: [adds add: eachSelector]].	adds isEmpty		ifFalse: 			[aStream tab; tab; nextPutAll: (#AddedMethodsC &lt;&lt; #packages &gt;&gt; 'Added methods:') asString; cr.			adds do: [:selector | aStream tab; tab; tab; nextPutAll: selector; cr]].	overrides isEmpty		ifFalse: 			[aStream tab; tab; nextPutAll: (#OverriddenMethodsC &lt;&lt; #packages &gt;&gt; 'Overridden methods:') asString; cr.			overrides do: [:selector | aStream tab; tab; tab; nextPutAll: selector; cr]].	changes isEmpty		ifFalse: 			[aStream tab; tab; nextPutAll: (#ChangedMethodsC &lt;&lt; #packages &gt;&gt; 'Changed methods:') asString; cr.			changes do: [:selector | aStream tab; tab; tab; nextPutAll: selector; cr]].	removes isEmpty		ifFalse: 			[aStream tab; tab; nextPutAll: (#RemovedMethodsC &lt;&lt; #packages &gt;&gt; 'Removed methods:') asString; cr.			removes do: [:selector | aStream tab; tab; tab; nextPutAll: selector; cr]]</body><body package="PackageCategories">putStatsOn: stream 	self putDefStatsOn: stream.	(self areMethodsModifiedMeta: false)		ifTrue: 			[stream nextPutAll: (#InstanceMethodsChanged &lt;&lt; #packages &gt;&gt; 'Instance side methods changed:') asString; cr.			self putMethodStatsMeta: false on: stream].	(self areMethodsModifiedMeta: true)		ifTrue: 			[stream nextPutAll: (#ClassSideMethodsChangedC &lt;&lt; #packages &gt;&gt; 'Class side methods changed:') asString; cr.			self putMethodStatsMeta: true on: stream].	self isDataModified		ifTrue: 			[stream nextPutAll: (#DataChangedC &lt;&lt; #packages &gt;&gt; 'Data changed:') asString; cr.			self putDataStatsOn: stream			].</body></methods><methods><class-id>Store.ClassChanges</class-id> <category>constants</category><body package="PackageCategories">metaClassChangeTypes	^#(#changeMeta #reorganizeMeta)</body></methods><methods><class-id>Store.ClassChanges class</class-id> <category>instance creation</category><body package="PackageCategories">new	^super new initialize</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>accessing</category><body package="PackageCategories">absoluteName		^fullName</body><body package="PackageCategories">absoluteSymbol		^fullName asSymbol</body><body package="PackageCategories">actual	^ self nameSpace</body><body package="PackageCategories">comment	| nspace |	^( nspace := self nameSpace) isNil		ifTrue: [ '']		ifFalse: [ nspace comment ]</body><body package="PackageCategories">definition	| nspace |	^( nspace := self nameSpace) isNil		ifTrue: [ '' ]		ifFalse: [ nspace definition ]</body><body package="PackageCategories">environment	"Answer the environment of the NameSpace. nil if it doesn't exist in the image."	^self fullName asStrictReference ifDefinedDo: [ :ns | ns environment ]</body><body package="PackageCategories">existsInImage	"Answer true if the receiver is a valid description of an existing method."	^self nameSpace isNil not</body><body package="PackageCategories">fullName		^fullName</body><body package="PackageCategories">fullName: aString		fullName := aString</body><body package="PackageCategories">myClass	"Give a class name answer a class."	self shouldNotImplement</body><body package="PackageCategories">name	^( self fullName tokensBasedOn: $. ) last</body><body package="PackageCategories">nameSpace	^self fullName asStrictReference valueOrDo: [ nil ]</body><body package="PackageCategories">symbol	^self absoluteSymbol</body><body package="PackageCategories">textRepresentationForTag: aTag 	^aTag isCommentTag		ifTrue: [ self comment ]		ifFalse: [ self definition ]</body><body package="PackageCategories">xmlDefinition	| nspace |	^( nspace := self nameSpace) isNil		ifTrue: [ '' ]		ifFalse: [ nspace xmlDefinition ]</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>comparing</category><body package="PackageCategories">&lt;= aNameSpaceDescriptor	^self fullName &lt;= aNameSpaceDescriptor fullName</body><body package="PackageCategories">= aThing	^self sameAs: aThing</body><body package="PackageCategories">comparesTo: anObject	"Answer true if anObject could be another version of the receiver."	( self objectIsForSelf: anObject ) ifFalse: [ ^false ].	^anObject absoluteName = self absoluteName.</body><body package="PackageCategories">hash	^self fullName hash</body><body package="PackageCategories">objectIsForSelf: anObject	"Answer true if anObject represents the same kind of thing as the reciever."	^anObject isForNameSpace</body><body package="PackageCategories">sameAsImThing:  aNameSpace	^aNameSpace absoluteName = self absoluteName</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>browser support</category><body package="PackageCategories">asNameSpace	^self actual asNameSpace</body><body package="PackageCategories">asString	^self simpleName</body><body package="PackageCategories">binding	^self"		| ref |	^( ref := self fullName asQualifiedReference ) isDefined 		ifTrue: [ ref binding ]		ifFalse: [ nil ]."</body><body package="PackageCategories">classifySymbol: varName under: protocol	^self value classifySymbol: varName under: protocol</body><body package="PackageCategories">containingPackages	"Answer all the packges that contain the definition for the receiver, 	including overriden."	^Registry allContainingPackagesForClassOrNameSpace: self actual</body><body package="PackageCategories">isDefined	"Answer whether the receiver exists in the image. aka #isDefined for bindings."	self valueOrDo: [ ^false ].	^true.</body><body package="PackageCategories">organization	^self value organization</body><body package="PackageCategories">renameCategory: oldCategory to: newCategory	^self value renameCategory: oldCategory to: newCategory</body><body package="PackageCategories">simpleName	^self fullName asStrictReference simpleName</body><body package="PackageCategories">value	^self fullName asStrictReference value</body><body package="PackageCategories">valueOrDo: aBlock	^self fullName asStrictReference valueOrDo: aBlock</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>testing</category><body package="PackageCategories">isForNameSpace	^true</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>printing</category><body package="PackageCategories">displayString	^self name</body><body package="PackageCategories">printOn: aStream	aStream nextPutAll: self class name, '(', 		( SystemUtils convertAbsoluteNameToFull: fullName ) , ')'.</body></methods><methods><class-id>Store.NameSpaceDescriptor</class-id> <category>filing out</category><body package="PackageCategories">fileOutSourceOn: aStream	"File the receiver out on aSourceFileManager."	self actual == nil		ifFalse: [ self actual fileOutSourceOn: aStream ].</body></methods><methods><class-id>Store.NameSpaceDescriptor class</class-id> <category>instance creation</category><body package="PackageCategories">fromModel: aNameSpaceModel	^self fullName: aNameSpaceModel absoluteName</body><body package="PackageCategories">fullName: aName 	^self new		fullName: aName;		yourself.</body></methods><methods><class-id>Store.UnloadedObjectError class</class-id> <category>private</category><body package="PackageCategories">baseMessage	^'model references non-loaded '</body></methods><methods><class-id>Store.UnloadedObjectError class</class-id> <category>instance creation</category><body package="PackageCategories">class: aClassName	^self new 		messageText: ((#nonLoadedClass1s &lt;&lt; #packages &gt;&gt; 'model references non-loaded class &lt;1s&gt;')			expandMacrosWith: aClassName).</body><body package="PackageCategories">nameSpace: aName	^self new 		messageText: ((#nonLoadedNameSpace2s &lt;&lt; #packages &gt;&gt; 'model references non-loaded name space &lt;1s&gt;')			expandMacrosWith: aName)</body></methods><methods><class-id>Store.UnloadedObjectError class</class-id> <category>testing</category><body package="PackageCategories">mayResume	^true</body></methods><methods><class-id>Store.ExtensionNameSpaceModel</class-id> <category>testing</category><body package="PackageCategories">hasDefinition	^false</body><body package="PackageCategories">isEmpty	"Is this model holding onto nothing?"	^data size = 0</body><body package="PackageCategories">isExtension	^true</body></methods><methods><class-id>Store.ExtensionNameSpaceModel</class-id> <category>data accessing</category><body package="PackageCategories">addDataKey: aDataKey	self privateData add: aDataKey</body><body package="PackageCategories">dataKeys	^data == nil		ifTrue: [ IdentitySet new ]		ifFalse: [ data ]</body><body package="PackageCategories">includesDataKey: dataKey	^self dataKeys includes: dataKey</body><body package="PackageCategories">quickIncludesDataKey: dataKey	^self includesDataKey: dataKey</body><body package="PackageCategories">removeDataKey: dataKey	super removeDataKey: dataKey.	data == nil ifTrue: [ ^self ].	self privateData remove: dataKey ifAbsent: [ ]</body></methods><methods><class-id>Store.ExtensionNameSpaceModel</class-id> <category>private</category><body package="PackageCategories">privateData	"Answer dataKeys defined by the receiver. Initialize the set if empty."	data isNil ifTrue: [ data := IdentitySet new ].	^data</body></methods><methods><class-id>Store.ExtensionNameSpaceModel</class-id> <category>printing</category><body package="PackageCategories">printStringPrefix	^'NSM-EXT:'</body></methods><methods><class-id>Store.BundleModel</class-id> <category>printing</category><body package="PackageCategories">classDescription	"Answer a string for describing the class."	^(#Bundle &lt;&lt; #packages &gt;&gt; 'Bundle') asString</body><body package="PackageCategories">describeContents	| strm |	strm := WriteStream on: String new.	self describeContentsOn: strm level: 0.	^strm contents</body><body package="PackageCategories">describeContentsOn: aStream level: aDepth 	self containedItems		do: 			[:pun | 			aDepth timesRepeat: [aStream tab].			aStream nextPutAll: (pun stringKey: #()).			pun hasBeenModified ifTrue: [aStream nextPut: $*].			aStream cr.			pun isBundle ifTrue: [pun describeContentsOn: aStream level: aDepth + 1]]</body><body package="PackageCategories">displayString	"Answer the string to be displayed for a bundle in a Bundle list."	| stream |	stream := WriteStream on: ( String new: 32 ).	stream nextPutAll: self name.	self hasBeenModified ifTrue: [ stream nextPutAll: ' *' ].	self hasExtensions ifTrue: [ stream nextPutAll: ' +' ].	^stream contents</body><body package="PackageCategories">printOn: aStream 		aStream nextPut: ${;		nextPutAll: (name isNil ifTrue: [(#unnamed &lt;&lt; #packages &gt;&gt; '*unnamed*') asString] ifFalse: [name]);		nextPut: $}.</body><body package="PackageCategories">storeOn: aStream 	name storeOn: aStream.	aStream tab.	aStream cr.	self contentDescriptions do: 		[ :pr |		aStream nextPut: $C; tab.		pr storeOn: aStream.		aStream cr		].	aStream nextPut: $E; cr.</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-file out</category><body package="PackageCategories">createOrFindExpression	"Answer a string that when evaluated will instantiate the receiver - creating, if neccessary."	^'( Store.Registry bundleNamedOrCreate: ', self name printString, '  ) '.</body><body package="PackageCategories">fileOutOn: aFileManager	"File out the bundle on aFileManager"	self		fileOutOn: aFileManager		withoutRepeatingAnyOf: Set new</body><body package="PackageCategories">fileOutOn: aFileManager withoutRepeatingAnyOf: aSet	"File out the bundle on aFileManager, but do not file out pundles repeatedly."		(aSet includes: self) ifTrue: [^self].	aFileManager createdComponent: self.	aFileManager addComment: (#Bundle1s &lt;&lt; #packages &gt;&gt; 'Bundle &lt;1s&gt;' expandMacrosWith: self itemString).	(#{Store.StoreSettings} ifDefinedDo: [:object | object preferenceFor: #fileoutOption] elseDo: [nil]) == #never ifFalse: 		[self fileOutPropertiesOn: aFileManager].	self containedItems do:		[:each | 		each fileOutOn: aFileManager withoutRepeatingAnyOf: aSet.		aSet add: each].	aFileManager bundleStructure: self</body></methods><methods><class-id>Store.BundleModel</class-id> <category>unloading</category><body package="PackageCategories">preUnloadChecksFromBundle: aBundle 	| bundles bnames bundle components |	bundles := Registry enclosingComponentsFor: self.	aBundle notNil 		ifTrue: 			[ bundles remove: aBundle ifAbsent: nil.			components := aBundle allContainedItems				select: [ :c | c isBundle ].			bundles copy do: 				[ :b | ( components includes: b ) ifTrue: [ bundles remove: b ] ]			].	bnames := bundles collect: [ :b | b name ].	(self unloadProblemsQuery: bnames header: ((#UnloadingPackageWillModifySomeBundles &lt;&lt; #packages &gt;&gt; 'The package to be unloaded, "&lt;1s&gt;", is contained in the bundles&lt;2s&gt;listed below.  Proceeding will modify these bundles.')			expandMacrosWith: self name			with: (String with: Character cr)))		ifFalse: [^false].	bundle := aBundle == nil		ifTrue: [ self ]		ifFalse: [ aBundle ].	self contents reverseDo: 		[ :comp | 		comp notNil 			ifTrue: 				[ ( comp runPreUnloadFrom: bundle )					ifFalse: [ ^false ]				]		].	^true</body><body package="PackageCategories">unloadFromImage	"I'm being ask to disappear from the image. 	Run rear guard code for all of my components and if all 	goes well obey the order. 	Answer true if I can fulfill the wish."	#{Store.DbRegistry} ifDefinedDo:		[ :reg |		( self runPreUnloadFrom: nil )			ifFalse: [ ^false ].		].	^self doUnloadFromImage</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-change set access</category><body package="PackageCategories">structureMark	"Answer the symbol used to indicate that the bundle structure has been modified."	^self class structureMark</body></methods><methods><class-id>Store.BundleModel</class-id> <category>public-change set access</category><body package="PackageCategories">inspectChangeSet	"Attempt to describe the changes to the bundle at a	high level."	"Could do better."	| stream |	stream := WriteStream on: String new.	self hasBeenModified		ifFalse: [stream nextPutAll: (#BundleHasNotBeenChanged &lt;&lt; #packages &gt;&gt; 'There are no changes to this bundle or its components') asString]		ifTrue: 			[| modPuns |			modPuns := OrderedCollection new.			self contentDescriptions do: 				[ :descrip | descrip hasBeenModified 					ifTrue: [ modPuns add: descrip component ]				].			modPuns size &gt; 0				ifTrue: 					[stream nextPutAll: (#SomeBundleComponentsHaveChanged &lt;&lt; #packages &gt;&gt; 'The following bundle components have been&lt;n&gt;modified (see component for details):') expandMacros; cr.					modPuns do: [:item | stream tab; nextPutAll: item name; cr].					stream cr].			self isChangeSetEmpty ifFalse: [stream nextPutAll: self changeSet printString]].	Dialog warn: stream contents</body></methods><methods><class-id>Store.BundleModel</class-id> <category>accessing-browser</category><body package="PackageCategories">allClasses	"Answer a collection of class descriptors. The collection contains 	descriptors for classes that are defined in the package and extention 	descriptors for classes for which only data is defined"	| classes |	classes := Set new.	self leafItems do: [ :pkg | classes addAll: pkg allClasses ].	^classes</body><body package="PackageCategories">allNameSpaces	"Answer a collection of namespace descriptors. The collection contains 	descriptors for namespaces that are defined in the package and extention 	descriptors for namespaces for which only data is defined"	| namespaces |	namespaces := Set new.	self leafItems do: [ :pkg | namespaces addAll: pkg allNameSpaces ].	^namespaces.</body><body package="PackageCategories">allShareds	"Answer a collection of shared descriptors. The collection contains 	descriptors for shareds that are defined in the package"		| shareds |	shareds := Set new.	self leafItems do: [:each | shareds addAll: each allShareds].	^shareds</body><body package="PackageCategories">dataForNamed: aFullName 	"Answer a collection of datum descriptors."	| set |	set := Set new.	self leafItems do:		[ :pkg |  set addAll: 	( pkg dataForNamed: aFullName ) ].	^set asOrderedCollection</body><body package="PackageCategories">dataForNamed: aFullName andProtocol: aSymbol	"Answer a collection of datum descriptors."	| set |	set := Set new.	self leafItems do:		[ :pkg |  set addAll: 	( pkg dataForNamed: aFullName andProtocol: aSymbol) ].	^set asOrderedCollection</body><body package="PackageCategories">includesDataKey: dataKey ownerName: aName	"Answer whether the reciver contains aName.dataKey."	self leafItems 		detect: [ :pkg | pkg includesDataKey: dataKey ownerName: aName ] 		ifNone: [ ^false ].	^true</body><body package="PackageCategories">includesDefinitionOf: aName  	"Answer whether the reciver contains something represented by aName."	self leafItems 		detect: [ :pkg | pkg includesDefinitionOf: aName ] ifNone: [ ^false ].	^true</body><body package="PackageCategories">includesMethod: aMethodDescriptor	^self 		includesSelector: aMethodDescriptor selector 		className: aMethodDescriptor className 		meta: aMethodDescriptor isMeta</body><body package="PackageCategories">includesSelector: selector class: aClass	^self 		includesSelector: selector 		className: aClass instanceBehavior absoluteName 		meta: aClass isMeta</body><body package="PackageCategories">includesSelector: selector className: className meta: isMeta	"Answer whether the reciver contains className&gt;&gt;aSelector."	self leafItems 		detect: [ :pkg | pkg includesSelector: selector className: className meta: isMeta ]		ifNone: [ ^false ].	^true</body><body package="PackageCategories">methods	| methods |	methods := Set new.	self leafItems do: [:each | methods addAll: each methods].	^methods</body><body package="PackageCategories">methodsForClassNamed: cName andProtocol: protocolName meta: isMeta	"Answer a collection of method descriptors."	| set |	set := Set new.	self leafItems do:		[ :pkg |  set addAll: 			( pkg methodsForClassNamed: cName 					andProtocol: protocolName meta: isMeta ) 		].	^set asOrderedCollection</body><body package="PackageCategories">methodsForClassNamed: aClassName meta: isMeta	"Answer a collection of methods."	| set |	set := Set new.	self leafItems do: [ :pkg | set addAll: ( pkg methodsForClassNamed: aClassName meta: isMeta ) ].	^set  asSortedCollection: [:x :y | x name &lt; y name]</body><body package="PackageCategories">protocolsForClassNamed: aClassName meta: isMeta	"Answer a collection of protocols."	| set |	set := Set new.	self leafItems do: 		[ :pkg | set addAll: ( pkg protocolsForClassNamed: aClassName meta: isMeta ) ].	^set</body><body package="PackageCategories">protocolsForDataIn: anObject	| set |	set := Set new.	self leafItems do:		[ :pkg |  set addAll: ( pkg protocolsForDataIn: anObject ) ].	^set asSortedCollection</body></methods><methods><class-id>Store.BundleModel</class-id> <category>accessing</category><body package="PackageCategories">addItem: aPundle 	"Create a bundle or a package description and add it to 	the content of the bundle. Leave the id field not set."	self addComponent: aPundle asDescription</body><body package="PackageCategories">allContainedItems	"Returns a recursive collection of all components contained in the BundleModel."	| coll component |	coll := OrderedCollection new.	self contentDescriptions do:		[ :descr | 		( component := descr component ) notNil			ifTrue: 				[ coll add: component.				component isBundle					ifTrue: [ coll addAll: component allContainedItems ].				]		]. 	^coll</body><body package="PackageCategories">allItems	"Answer a list of pundles contianed in this bundle and in bundles contained by 	this 	bundle. 	The list preserves the bundle order. Put this bundle as a last item on the list."	| items |	items := OrderedCollection new.	self containedItems do: 		[ :item | 		item isBundle			ifTrue: [ items addAll: item allItems ]			ifFalse: [ items add: item ]		].	items add: self. 	^items</body><body package="PackageCategories">anyContainedItems	"Answer a recursive collection of components."	| coll component descs |	coll := OrderedCollection new.	( descs := self contentDescriptions ) isEmpty		ifTrue: [ descs := self anyContentDescriptions ].	descs do:		[ :descr | 		( component := descr component ) notNil			ifTrue: [ coll add: component]		]. 	^coll</body><body package="PackageCategories">databaseInformationClass	^DatabaseConnectionBundleInformation</body><body package="PackageCategories">descriptionsAndLevels	"Answer a list of pairs. The first element contains a descriptions the second the 	level on which the description was found."	| coll |	coll := OrderedCollection new.	self contentDescriptions 		do: [:descr | coll addAll: descr descriptionsAndLevels].	^coll</body><body package="PackageCategories">itemCount	"Answer a count of work to be done."	^self contents inject: 1 into:		[ :sz :pun | sz + pun itemCount ]</body><body package="PackageCategories">leafDescriptions	"Answer the package descriptions at the leaves."	"Answer a list of PackageDescriptions."	^self uniqueDescriptionsAndLevels collect: [:a | a at: 1]</body><body package="PackageCategories">leafItems	"Answer a list of packages contianed in this bundle 	and in bundles contained by this bundle."	| items |	items := OrderedCollection new.	self contentDescriptions do: 		[ :descr | items addAll: descr leafItems].	^items</body><body package="PackageCategories">structure	"Answer an array that reflects the receiver's contents in the form:		#( #( #package name ) #( #bundle name ) .... )"		| answer |	answer := OrderedCollection new: self contentDescriptions size.	self contentDescriptions do:		[ :cd | 		cd isPackage			ifTrue: [ answer add: ( Array with: #package with: cd name ) ]			ifFalse: [ answer add: ( Array with: #bundle with: cd name ) ].		].	^answer asArray</body><body package="PackageCategories">structure: anArray	"Set the receivers contents based on an array in the form:		#( #( #package name ) #( #bundle name ) .... )"	| components |	anArray ifNil: [^self containedItems: #()].	components := OrderedCollection new: anArray size.	anArray do: 		[:eachItem |		| pundle |		pundle := eachItem first == #package 			ifTrue: [Registry packageNamed: eachItem last] 			ifFalse: [Registry bundleNamed: eachItem last].		pundle isNil			ifTrue: 				[| errorString |				errorString := #CannotAdd1sTo2s &lt;&lt; #packages &gt;&gt; 'Cannot add &lt;1s&gt; to &lt;2s&gt;&lt;ntt&gt;Continue?' expandMacrosWith: eachItem first with: name.				(Warning raiseSignal: errorString) ifFalse: [^self]]			ifFalse: [components add: pundle]].	self containedItems: components</body><body package="PackageCategories">toolListIconKey	^self		selectIconKeyDefault: #bundle 		modified: #modifiedBundle 		noDBdefault: #bundleNoDB 		modified: #modifiedBundleNoDB</body><body package="PackageCategories">traceBundle	self deprecated: #(#version '7.8' #sunset '8.0' #use #parentRecord).	^self parentRecord</body><body package="PackageCategories">uniqueDescriptionsAndLevels	"Just like description and levels but remove 	components that are present more then one time."	| coll present |	present := IdentitySet new.	coll := self descriptionsAndLevels.	coll := coll select: 					[:pair | 					| descr comp |					descr := pair at: 1.					comp := descr component.					comp isNil 						ifTrue: [false]						ifFalse: 							[| res |							res := present includes: comp.							present add: comp.							res not]].	^coll</body><body package="PackageCategories">withAllContainedItems	^(OrderedCollection with: self), self allContainedItems.</body><body package="PackageCategories">withContainedItems	^self containedItems addFirst: self; yourself</body></methods><methods><class-id>Store.BundleModel</class-id> <category>table of contents</category><body package="PackageCategories">tableOfBundleContentsOn: aStream 	self tableOfBundleContentsOn: aStream level: 0</body><body package="PackageCategories">tableOfBundleContentsOn: aStream level: aLevel	aLevel timesRepeat: [aStream tab].	aStream nextPut: $@; nextPutAll: self name; nextPut: $"; cr.	self containedItems		do: 			[:pun | 			pun tableOfBundleContentsOn: aStream level: (aLevel + 1)].	(aLevel + 1) timesRepeat: [aStream tab].	aStream nextPut: $; ; cr</body><body package="PackageCategories">tableOfBundleContentsOnFile: aString	| strm |	strm := aString asFilename writeStream.	self tableOfBundleContentsOn: strm.	strm close.</body><body package="PackageCategories">tableOfContentsOn: aStream 	self leafItems do: 		[ :pkg | pkg tableOfContentsOn: aStream ]</body><body package="PackageCategories">tableOfContentsOnFile: aString	| strm |	strm := aString asFilename writeStream.	self tableOfContentsOn: strm.	strm close.</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-validation</category><body package="PackageCategories">removeNonexistentComponents	self databaseInformationsDo:		[ :info | info removeNonexistentComponents ].</body><body package="PackageCategories">validateLoadOrder	"Examines NameSpace/Class prereqs to ensure that content list is in a valid order.	Answers a string of errors, or an empty string."	^self validateLoadOrder: self leafItems.</body><body package="PackageCategories">validateLoadOrder: list	"Examines NameSpace/Class prereqs to ensure that content list is in a valid order.	Answers a string of errors, or an empty string."	^self class validateLoadOrder: list</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private</category><body package="PackageCategories">descriptionClass	^BundleDescription</body><body package="PackageCategories">dialogForException: ex 	"Ask if a user wants to proceed with loading 	this bundle after an error occurred while loading one of the components."	^Dialog		choose: ((#ProblemOccurredWhatNowQ &lt;&lt; #packages &gt;&gt; 'The following problem occurred while loading &lt;1s&gt;  bundle:&lt;nn&gt;&lt;2s&gt;&lt;nn&gt;You can ignore the problem and continue loading the bundle&lt;n&gt;or you can abort the operation and unload already loaded &lt;n&gt;bundles and packages.&lt;n&gt;')			expandMacrosWith: self name			with: ex errorString)		labels: (Array with: (#Ignore &lt;&lt; #packages &gt;&gt; 'Ignore') with: (#Abort &lt;&lt; #packages &gt;&gt; 'Abort'))		values: #(#ignore #abort)		default: #abort</body><body package="PackageCategories">doUnloadFromImage	"The difference between unloadFromImage and 	this method is that this method does not run 	the rearguard code and does not ask for rearguard 	of the components."		| components |	components := self contents.	components reverseDo: [:each | each notNil ifTrue: [each unloadFromGroup: self]].	self runPostUnload.	Registry removeBundle: self.	self cleanseRelatedParcel.	ChangeSet unloadPundle: self.	^true</body><body package="PackageCategories">manager	^Registry</body><body package="PackageCategories">pundlesNotIn: anImageBundle  or: parentBundle	"Answer a collection of pundles that I contain but that are not in anImageBundle. 	The comparison is done based on names of the items."	| notIn |	notIn := OrderedCollection new.	self contentDescriptions do: 		[ :descr | 		( ( anImageBundle containsDescription: descr ) or: 				[ parentBundle ~~ nil and: [ parentBundle containsDescription: descr ] ] 		) ifFalse: [ notIn add: descr component ] 		].	^notIn</body><body package="PackageCategories">removeComponent: aComponentDescription 	self databaseInformationsDo:		[ :info | info removeComponentDescription: aComponentDescription ].</body></methods><methods><class-id>Store.BundleModel</class-id> <category>queries</category><body package="PackageCategories">dataKeysForName: aClassOrNameSpaceName	"Answer a collection of selectors for aClassName belonging to the receiver."	| list |	list := OrderedCollection new.	self leafItems do:		[ :pkg | list addAll: ( pkg  dataKeysForName: aClassOrNameSpaceName ) ].	^list</body><body package="PackageCategories">definedBindings	"Answer a dictionary of bindings (NameSpace/Class to datakey) contained in the receiver."	"Note- duplicates Parcel format."	| bindings |	bindings := IdentityDictionary new.	self leafItems do:		[ :pkg | 		pkg definedBindings keysAndValuesDo:			[ :owner :keys |			( bindings at: owner ifAbsentPut: [ Set new ] ) addAll: keys.			].		].	^bindings</body><body package="PackageCategories">definedClasses	"Answer a collection of all Classes whose definition is contained in the receiver."	| list |	list := OrderedCollection new.	self leafItems do:		[ :pkg | list addAll: pkg  definedClasses ].	^list</body><body package="PackageCategories">definedClassesExcludedSelectors	"Answer an IdentityDictionary of Class -&gt; &lt;Set of selectors&gt;"	"Parcel compatibility."	| coll |	coll := IdentityDictionary new.	self leafItems do:		[ :pkg | 		pkg definedClassesExcludedSelectors keysAndValuesDo:			[ :cls :selectors | | cname |			cname := cls instanceBehavior absoluteName.			selectors do:				[ :selector |					( self includesSelector: selector className: cname meta: cls isMeta )					ifFalse: [ ( coll at: cls ifAbsentPut: [ Set new ] ) add: selector ].				].			].		].	^coll</body><body package="PackageCategories">definedNameSpaces	"Answer a collection of all NameSpaces whose definition is contained in the receiver."	| list |	list := OrderedCollection new.	self leafItems do:		[ :pkg | list addAll: pkg  definedNameSpaces ].	^list</body><body package="PackageCategories">definedObjects	"Parcel compatibility"	^self definedNameSpaces</body><body package="PackageCategories">definesClassOrNameSpace: aClassOrNameSpace		^self shouldNotImplement</body><body package="PackageCategories">extensionMethods	"Answer an OrderedCollection of CompiledMethods	Parcel compatibility."		| result classes |	result := OrderedCollection new.	self leafItems do: [:each | result addAll: each extensionMethods].	classes := self definedClasses.	^result reject: [:each | classes includes: each mclass instanceBehavior]</body><body package="PackageCategories">selectorsMeta: isMeta forClassName: className	"Answer a collection of selectors for aClassName belonging to the receiver."		| list |	list := OrderedCollection new.	self leafItems		do:			[:eachPackage | list addAll: (eachPackage selectorsMeta: isMeta forClassName: className)].	^list</body></methods><methods><class-id>Store.BundleModel</class-id> <category>parcel support</category><body package="PackageCategories">copyContentsToParcel: parcel	self leafItems do: [ :pkg  | pkg copyContentsToParcel: parcel ].</body><body package="PackageCategories">dataNotInParcel: aParcel on: aStream	"Write owner.dataKey contained in the receiver but not in a Parcel."	self leafItems do: [ :pkg |	pkg dataNotInParcel: aParcel on: aStream ].</body><body package="PackageCategories">definedClassesNotInParcel: aParcel 	"Answer a string listing class names contained in the receiver but not in a Parcel."	| stream |	stream := ( String new: 100 ) writeStream.	self definedClassesNotInParcel: aParcel on: stream.	^stream contents.</body><body package="PackageCategories">definedClassesNotInParcel: aParcel on: aStream	"Write class names contained in the receiver but not in a Parcel."	self leafItems do: [ :pkg |	pkg definedClassesNotInParcel: aParcel on: aStream ].</body><body package="PackageCategories">definedNameSpacesNotInParcel: aParcel 	"Answer a string listing class names contained in the receiver but not in a Parcel."	| stream |	stream := ( String new: 100 ) writeStream.	self definedNameSpacesNotInParcel: aParcel on: stream.	^stream contents.</body><body package="PackageCategories">definedNameSpacesNotInParcel: aParcel on: aStream	"Write class names contained in the receiver but not in a Parcel."	self leafItems do: [ :pkg |	pkg definedNameSpacesNotInParcel: aParcel on: aStream ].</body><body package="PackageCategories">methodsNotInParcel: aParcel on: aStream	"Write method&gt;&gt;selectors contained in the receiver but not in a Parcel."	self leafItems do: [ :pkg |	pkg methodsNotInParcel: aParcel on: aStream ].</body><body package="PackageCategories">namedObjects	^Dictionary new.</body><body package="PackageCategories">saveAsParcel: fullPathName saveStructure: ignored saveLinks: saveLinks	"Save the receiver as a parcel -without creating the parcel in the image.	fullPathName is a directory/parcelName with no extension.	If saveStructure is true, fill in the bundleStructure property with bundle/package contents.	If saveLinks is true, save the db links for every component.	For a bundle, we now always save the structure and thus the saveStructure parameter is ignored"	| dir link pname |	link := saveLinks.	 ( saveLinks &amp; self hasBeenModified )		ifTrue: 			[ ( Dialog confirm: 				( (#UnpublishedModificationsMeanNoDBLinks &lt;&lt; #packages &gt;&gt; '&lt;t&gt;&lt;1s&gt; has unpublished modifications.&lt;n&gt;This means that database links will not be included.&lt;ntttt&gt;Continue?')						 expandMacrosWith: name ) )					ifFalse: [ ^self ].			link := false.			].	pname := fullPathName tail.	dir := fullPathName directory.	dir exists 		ifFalse:			[ ( Dialog confirm: ( (#CreateDirectory1s &lt;&lt; #packages &gt;&gt; 'Create directory &lt;1s&gt;?') expandMacrosWith: dir asString ) )				ifFalse: [ ^self ].			dir makeDirectory.			].	properties 		at: #bundleName put: self name;		at: #parcelName put: pname.	properties at: #bundleStructure put: ( PundleForParcel from: self saveLinks: link ).	[ self		parcelOutTo: ( dir construct: ( pname, '.pcl' ) ) asString		sourceFileName: ( dir construct: ( pname, '.pst' ) ) asString.	] ensure:		[ properties			removeKey: #bundleStructure ifAbsent: [ ];			removeKey: #bundleName ifAbsent: [ ].		].</body><body package="PackageCategories">saveAsParcel: aFilename saveStructure: ignored saveLinks: saveLinksBoolean parcelOptions: aDictionary	"Save the receiver as a parcel -without creating the parcel in the image.	fullPathName is a directory/parcelName with no extension.	If saveStructure is true, fill in the bundleStructure property with bundle/package contents.	If saveLinks is true and saveStructure is true, then save the db links in the properties.	For a bundle, we now always save the structure and thus the saveStructure parameter is ignored"		| parcelDirectory shouldSaveLinks parcelName |	shouldSaveLinks := saveLinksBoolean.	saveLinksBoolean &amp; self hasBeenModified ifTrue:		[(Dialog confirm:			(#UnpublishedModificationsMeanNoDBLinks 				&lt;&lt; #packages 				&gt;&gt; '&lt;t&gt;&lt;1s&gt; has unpublished modifications.&lt;n&gt;This means that database links will not be included.&lt;ntttt&gt;Continue?' expandMacrosWith: name))					ifFalse: [^self].		shouldSaveLinks := false].	parcelName := aFilename tail.	parcelDirectory := aFilename directory.	parcelDirectory exists ifFalse:		[(Dialog confirm: (#CreateDirectory1s &lt;&lt; #packages &gt;&gt; 'Create directory &lt;1s&gt;?' expandMacrosWith: parcelDirectory asString)) 			ifFalse: [^self].		parcelDirectory makeDirectory].	properties		at: #bundleName put: self name;		at: #parcelName put: parcelName.	properties		at: #bundleStructure		put: (PundleForParcel from: self saveLinks: shouldSaveLinks).	[self		parcelOutTo: (parcelDirectory construct: parcelName , '.pcl') asString		sourceFileName: (parcelDirectory construct: parcelName , '.pst') asString		parcelOptions: aDictionary]		ensure:			[properties 				removeKey: #bundleStructure ifAbsent: [nil];				removeKey: #bundleName ifAbsent: [nil]]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>content management</category><body package="PackageCategories">addComponent: aComponentDescription	"Add a component to the receiver."	| changed |	changed := false.	self databaseInfomationOrCreate.	self databaseInformationsDo: 		[:eachDatabaseInformation |		changed := (eachDatabaseInformation addComponentDescription: aComponentDescription copy) or: [changed]].	(changed and: [self shouldTrackChanges]) ifTrue: 		[self addOtherChange: self structureMark.		Registry changedBundleStructure: self]</body><body package="PackageCategories">allContentCollectionsDo: aBlock	"Evaluate aBlock for all of the receiver's contents 	(ie. for all database connections)."	dbInfo values do: 		[ :info | aBlock value: info contentDescriptions ].</body><body package="PackageCategories">anyContentDescriptions	"Answer a collection of pundle descriptors for any database connection"	dbInfo isEmpty		ifTrue: [ ^#( ) ].	dbInfo size &gt; 1 		ifTrue: [ 	dbInfo removeKey: self noDbSymbol ifAbsent: nil ].	^dbInfo values first contentDescriptions collect:		[ :desc |		desc copy			id: nil; 			dbIdentifier: nil;			yourself		].</body><body package="PackageCategories">component: aComponent beingRenamedTo: aString	"Called by the registry which is about to rename a component contained in the receiver. 	Since it may be owned by other bundles as well, we are only updating internal information."	self databaseInformationsDo:		[ :info | info component: aComponent beingRenamedTo: aString ].</body><body package="PackageCategories">containedItems	"Answer a collection of components."	^self contents asList 		reject: [ :c | c == nil ]</body><body package="PackageCategories">containedItems: aCollectionOfComponents	"Set my contents to be aCollectionOfComponents."	dbInfo isEmpty		ifTrue: [ self databaseInformationForOrCreate: self noDbSymbol ].	self databaseInformationsDo:		[ :info | info containedItems: aCollectionOfComponents ].</body><body package="PackageCategories">contentDescriptions	"Answer a collection of pundle descriptors for the current/last database connection"	| dbinfo |	^( dbinfo := self databaseInformation ) == nil		ifTrue: [ self anyContentDescriptions ]		ifFalse: [ dbinfo contentDescriptions ].</body><body package="PackageCategories">contentDescriptionsFor: aDatabaseId	"Answer a collection of pundle descriptors for the specified database connection"	| dbinfo |	^( dbinfo := self databaseInformationFor: aDatabaseId ) == nil		ifTrue: [ #( ) ]		ifFalse: [ dbinfo contentDescriptions ].</body><body package="PackageCategories">contents	"Answer a collection of sub-components contained in the bundle"	^self contentDescriptions collect: 		[ :desc | desc component ]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>testing</category><body package="PackageCategories">containsDescription: aDescr 	"Answer true if I or my sub-components contain aDescr ."	self contentDescriptions do: 		[ :descr | 		( ( descr describesSameAs: aDescr )			or: [ descr isBundle and: [ descr component containsDescription: aDescr ] ]		) 			ifTrue: [ ^true ]		].	^false</body><body package="PackageCategories">containsItem: aPundle 	"Answer true if I contain aPundle."	^self contentDescriptions contains: 		[:aDescr | aPundle sameAsDescribedBy: aDescr ].</body><body package="PackageCategories">hasBeenModified	"Answer true if the receiver or a subcomponent has been modified."		^self shouldTrackChanges and:		[ self hasItselfBeenModified or:			[ ( self contentDescriptions detect: 				[ :c | c hasBeenModified ] ifNone: [ nil ] ) ~~ nil 			]		].</body><body package="PackageCategories">hasBeenModifiedIn: aDatabaseId	"Answer true if the receiver or a subcomponent has been modified within a database."			^( super hasBeenModifiedIn: aDatabaseId ) or:		[ ( self containedItems detect: 			[ :c | c hasBeenModifiedIn: aDatabaseId ] ifNone: [ nil ] ) ~~ nil ]</body><body package="PackageCategories">hasCodeOverridden	"Answer true if the receiver has definitions overriden by other components."	^self leafItems contains: 		[ :pkg | pkg hasCodeOverridden ]</body><body package="PackageCategories">hasExtensions	"Check if any of my components have been modifed."	^self leafItems contains: [:descr | descr hasExtensions]</body><body package="PackageCategories">hasItselfBeenModifiedWithoutProperties	"Return true if the receiver itself has been modified.  Does not consider whether	 contained items have been modified but does consider that properties changes are ignored"	^super hasItselfBeenModifiedWithoutProperties or:		[self allContainedItems anySatisfy: [:each | each hasItselfBeenModifiedWithoutProperties]]</body><body package="PackageCategories">hasValidLoadOrder	^self class isValidLoadOrder: self leafItems</body><body package="PackageCategories">haveAnyBeenModifiedWithoutProperties	"Return true if the receiver itself has been modified.  Does not consider whether	 contained items have been modified but does consider that properties changes are ignored"	^super haveAnyBeenModifiedWithoutProperties or:		[self allContainedItems anySatisfy: [:each | each haveAnyBeenModifiedWithoutProperties]]</body><body package="PackageCategories">isBundle	^true</body><body package="PackageCategories">isEmpty	"Answer true if I do not contain any definitions. This method is used	to distinguish newly created bundles from the existing ones."	^dbInfo isEmpty		or: [ dbInfo values first contentDescriptions isEmpty ].</body><body package="PackageCategories">isLeaf	^self isEmpty</body><body package="PackageCategories">overridesSelf	"Answer true if any of the receiver's contents override another."	| subs |	self hasCodeOverridden		ifFalse: [ ^false ].	( subs := self leafItems ) do:		[ :pundle |		pundle overrides do:			[ :over | 			( ( over getSources: over object )				contains: [ :current | subs includes: current ] )					ifTrue: [ ^true ]			]		].	^false</body></methods><methods><class-id>Store.BundleModel</class-id> <category>initialize-release</category><body package="PackageCategories">setContentsFromDB: aDBBundle		self databaseInformationOrCreate contentDescriptions: 		( aDBBundle containedItems collect: [ :each | each asComponentDescription ] ).	self databaseInformation fileDescriptions: 		( aDBBundle files collect: [ :each | each asComponentDescription ] ).		dbInfo removeKey: self noDbSymbol ifAbsent: nil. "now we be connected"</body></methods><methods><class-id>Store.BundleModel</class-id> <category>utilities-repository</category><body package="PackageCategories">cleanUpOverrides	self allContainedItems do: 		[ :each | each cleanUpOverrides ]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>private-load/unload</category><body package="PackageCategories">addObject: aNameSpace		^self shouldNotImplement</body><body package="PackageCategories">appendBundlePrerequisitesFrom: aBundleForParcel to: basicProperties	| pundleNames deploymentPrereqsOutsideTheBundle |	pundleNames := Set new.	aBundleForParcel pundlesDo: [:each | pundleNames add: each name].	aBundleForParcel pundlesDo: 		[:each |		each deploymentPrerequisites ifNotNil: 			[:deployment |			deploymentPrereqsOutsideTheBundle := deployment reject: 				[:eachPrereq | pundleNames includes: eachPrereq first].			pundleNames addAll: (deploymentPrereqsOutsideTheBundle collect: [:eachPrereq | eachPrereq first]).			basicProperties 				at: #prerequisiteParcels				put: (basicProperties at: #prerequisiteParcels ifAbsent: [#()]) , deploymentPrereqsOutsideTheBundle]]</body><body package="PackageCategories">propertiesForParcel	| basicProperties |	basicProperties := self propertiesForSave.	(basicProperties at: #bundleStructure ifAbsent: [nil]) ifNotNil: [:bundleStructure |		self appendBundlePrerequisitesFrom: bundleStructure to: basicProperties].	^basicProperties.</body><body package="PackageCategories">removeClass: aClass unloaded: aBoolean		^self shouldNotImplement</body><body package="PackageCategories">removeNameSpace: aNameSpace unloaded: aBoolean		^self shouldNotImplement</body><body package="PackageCategories">storePropertiesOn: aCodeWriter 	"Store the CodeComponents's properties. But ensure the #parcel 	property is just the 	base name, and that the stored properties exclude any volatile 	properties."	| storedProperties version |	super storePropertiesOn: aCodeWriter.	version := aCodeWriter properties at: #version ifAbsent: [nil].	storedProperties := (self propertiesForParcel) 		at: #parcel put: nil; 		yourself.	version ifNotNil: [storedProperties at: #version put: version].	"Store any subclass-specific properties."	self putStoredPropertiesIn: storedProperties.	aCodeWriter storeProperties: storedProperties</body></methods><methods><class-id>Store.BundleModel</class-id> <category>editing</category><body package="PackageCategories">addSelector: aSymbol toClass: aClass		^self shouldNotImplement</body><body package="PackageCategories">addStatic: staticKey to: aClassOrNameSpace		^self shouldNotImplement</body><body package="PackageCategories">removeShared: aSymbol from: aClassOrNameSpace		^self shouldNotImplement</body><body package="PackageCategories">removeStatic: staticKey from: aClassOrNameSpace		^self shouldNotImplement</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>constants</category><body package="PackageCategories">bundleIcon	^BundleIcon ifNil: [BundleIcon := ListIconLibrary visualFor: #bundle]</body><body package="PackageCategories">componentType	"Answer a symbol representing the class of the receiver."	^#bundle</body><body package="PackageCategories">descriptionString	"Answer a string for error messages."	^(#bundle &lt;&lt; #packages &gt;&gt; 'bundle') asString</body><body package="PackageCategories">fileMark	"Answer the symbol used to indicate that an external file has been added/removed/modified."	"Should really be a real Change"	^#externalFile</body><body package="PackageCategories">structureMark	"Answer the symbol used to indicate that the bundle structure has been modified."	^#bundleStructure</body></methods><methods><class-id>Store.BundleModel class</class-id> <category>validation</category><body package="PackageCategories">isValidLoadOrder: aSequenceOfCodeComponents	self outOfOrderLoadDependencies: aSequenceOfCodeComponents do: [^false].	^true</body><body package="PackageCategories">outOfOrderLoadDependencies: aSequenceOfCodeComponents do: aThreeArgBlock	"Enumerate aSequenceOfCodeComponents, expanded to their sub packages, for each case where a package is found to need a package later in aSequenceOfCodeComponents, cull aThreeArgBlock with the arguments in order of	1) objectNeeded	2) packageThatNeededIt	3) packageThatSuppliesIt "	| packages alreadyDefined absoluteNameCache |	packages := OrderedCollection new: aSequenceOfCodeComponents size.	aSequenceOfCodeComponents		do: [:each | each isPackage ifTrue: [packages add: each] ifFalse: [packages addAll: each leafItems]].	alreadyDefined := IdentitySet new.	absoluteNameCache := IdentityDictionary new.	packages keysAndValuesDo: 			[:index :eachPackage |			| prerequisites defines |			prerequisites := IdentitySet new: 100.			defines := eachPackage definedClasses , eachPackage definedNameSpaces.			"Include overridden definitions in the definitions I contain"			Override				overriddenClassesAndNameSpacesDo: [:each | (each includesSource: eachPackage) ifTrue: [defines add: each object]].			defines do: [:each | prerequisites addAll: each prerequisitesForLoading].			prerequisites addAll: (eachPackage classesExtendedInPackage collect: [:each | each actual]).			prerequisites addAll: (eachPackage nameSpacesExtendedInPackage collect: [:each | each actual]).			eachPackage environment ifNotNil: [:value | prerequisites add: value].			"Old code included iterating eachPackage, add before rejecting"			alreadyDefined addAll: defines.			prerequisites := prerequisites reject: [:each | each isExternalDictionary or: [alreadyDefined includes: each]].			(packages allButFirst: index) do: 					[:laterPackage |					prerequisites do: 							[:eachObject |							| absoluteName |							absoluteName := absoluteNameCache at: eachObject ifAbsentPut: [eachObject absoluteName asSymbol].							(laterPackage includesDefinitionOf: absoluteName)								ifTrue: [aThreeArgBlock cull: eachObject cull: eachPackage cull: laterPackage]]]]</body><body package="PackageCategories">validateLoadOrder: packages	"Examines NameSpace/Class prereqs to ensure that content list is in a valid order.	Answer a string with errors, an empty string if none.	Stop when we get 25 or more errors.	We reject anything that is an ExternalDictionary, because we can't compute closure on them.	Finally, we look if anything is overridden, because a later package (whiere it is overridden) doesn't mean the load order is bad. In fact, quite the opposite"	| errorStream leafItems count |	leafItems := OrderedCollection new: packages size.	packages do: 			[:each |			each isPackage				ifTrue: [leafItems add: each]				ifFalse: [leafItems addAll: each leafItems]].	errorStream := (String new: 200) writeStream.	count := 0.	1 to: leafItems size		do: 			[:index |			| packageModel prerequisites |			count &gt;= 25 ifTrue: [^errorStream contents , '....more....'].			packageModel := leafItems at: index.			prerequisites := IdentitySet new: 100.			packageModel definedClasses				do: [:each | prerequisites addAll: each prerequisitesForLoading].			packageModel definedNameSpaces				do: [:each | prerequisites addAll: each prerequisitesForLoading].			prerequisites addAll: (packageModel classesExtendedInPackage						collect: [:each | each actual]).			prerequisites addAll: (packageModel nameSpacesExtendedInPackage						collect: [:each | each actual]).			packageModel environment ifNotNil: [:value | prerequisites add: value].			prerequisites := prerequisites reject: [:each | each isExternalDictionary].			1 to: index				do: 					[:innerIndex |					| targetPackageModel |					targetPackageModel := leafItems at: innerIndex.					prerequisites := prerequisites								reject: [:each | targetPackageModel includesDefinitionOf: each absoluteName].					Override overriddenClassesAndNameSpacesDo: 							[:each |							(each includesSource: targetPackageModel)								ifTrue: [prerequisites remove: each object ifAbsent: [nil]]]].			index + 1 to: leafItems size				do: 					[:innerIndex |					| dependentPackageModel |					prerequisites detect: 							[:each |							((dependentPackageModel := leafItems at: innerIndex)								includesDefinitionOf: each absoluteName)									ifFalse: [false]									ifTrue: 										[errorStream											nextPutAll: packageModel name , ' depends on ' , each name , ' in '														, dependentPackageModel name;											cr.										count := count + 1.										true]]						ifNone: [nil]]].	^errorStream contents</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>printing</category><body package="PackageCategories">displayString	^SystemUtils convertAbsoluteNameToFull: self name</body><body package="PackageCategories">itemString	^self name , self versionString</body><body package="PackageCategories">printOn: aStream	 	aStream nextPutAll: self fullName.</body><body package="PackageCategories">versionString	^''</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>testing</category><body package="PackageCategories">isClassVariable 	^nameSpaceName isNil</body><body package="PackageCategories">isForData	^true</body><body package="PackageCategories">isForGeneral	^true</body><body package="PackageCategories">isInClass 	^className ~~  nil</body><body package="PackageCategories">isInNameSpace 	^nameSpaceName notNil</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>accessing browser</category><body package="PackageCategories">name 	^self dataKey asString</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>accessing</category><body package="PackageCategories">absoluteName	^self fullName</body><body package="PackageCategories">absoluteOwnerName 	^self environmentString</body><body package="PackageCategories">binding	| ns |	^( ns := self nameSpace ) == nil		ifTrue: [ nil ]		ifFalse: [ ns bindingFor: dataKey ]</body><body package="PackageCategories">className 	^className</body><body package="PackageCategories">className: aString 	className := aString</body><body package="PackageCategories">containingPackages	"Answer all the packges that contain the definition for the receiver, 	including overriden."	| owner |	( owner := self owner ) == nil		ifTrue: [ ^OrderedCollection new ].	^Registry allContainingPackagesForDataKey: dataKey owner: owner.</body><body package="PackageCategories">dataKey	^dataKey asSymbol</body><body package="PackageCategories">dataKey: aValue	dataKey := aValue asSymbol</body><body package="PackageCategories">definition	| ns |	^( ns := self nameSpace ) == nil		ifTrue: [ '' ]		ifFalse: [ ns definitionOf: dataKey ifAbsent: [ '' ] ]</body><body package="PackageCategories">environment	^self owner</body><body package="PackageCategories">environmentString 	^nameSpaceName == nil		ifTrue: [ className ]		ifFalse: [ nameSpaceName ]</body><body package="PackageCategories">fullClassName	^className</body><body package="PackageCategories">fullName 	^self environmentString, '.', dataKey.</body><body package="PackageCategories">key	^self dataKey</body><body package="PackageCategories">nameSpace	"Answer the nameSpace the receiver belongs in.	May be a class' namespace." 		^( self environmentString asStrictReference valueOrDo: [ ^nil ] ) 		asNameSpace</body><body package="PackageCategories">nameSpaceName 	^nameSpaceName</body><body package="PackageCategories">nameSpaceName: aString 	nameSpaceName := aString</body><body package="PackageCategories">owner	"Answer the thing the receiver belongs in."	"Is a NameSpace, or a class'" 	^self environmentString asStrictReference valueOrDo: [ nil ]</body><body package="PackageCategories">ownerName 	^nameSpaceName == nil		ifTrue: [ className ]		ifFalse: [ nameSpaceName ]</body><body package="PackageCategories">protocol	^self nameSpace organization categoryOfElement: self dataKey</body><body package="PackageCategories">protocol: aValue	"data does not have a protocol."	"no-op"</body><body package="PackageCategories">protocolName	| name |	^( name := self protocol ) == nil		ifTrue: [ (#unknown &lt;&lt; #packages &gt;&gt; 'unknown') asString ]		ifFalse: [ name ]</body><body package="PackageCategories">sourceCode	"fake it"	^self textRepresentation</body><body package="PackageCategories">textRepresentation	| namespace |	( namespace := self nameSpace ) isNil		ifTrue: [ ^'' ]		ifFalse: [^( namespace definitionOf: dataKey ifAbsent: [ '' ] ) ]</body><body package="PackageCategories">xmlDefinition	(self nameSpace includesKey: dataKey) ifFalse: [^nil].	^(BindingReference simpleName: dataKey in: self nameSpace namedReferent)		xmlDefinition</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>private-testing</category><body package="PackageCategories">existsInImage	"Answer if the receiver is a valid description of data."	^self fullName asStrictReference isDefined</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>comparing</category><body package="PackageCategories">= aThing	^self sameAs: aThing</body><body package="PackageCategories">hash	^self nameSpaceName hash + self dataKey hash</body><body package="PackageCategories">sameAs: aDatum	^aDatum sameAsImThing: self</body><body package="PackageCategories">sameAsImThing: aDatum 	| res |	self debugVersionOnly.	res := ( self nameSpaceName = aDatum nameSpaceName 		and: [ self className = aDatum className ] )		and: [ self dataKey = aDatum dataKey ].	^res</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>private</category><body package="PackageCategories">fileOutOn: aSourceCodeStream		| env str |	str := ((#NoSouceForC1s &lt;&lt; #packages &gt;&gt; 'No souce for: &lt;1s&gt;')			expandMacrosWith: self fullName).	( env := self nameSpace ) == nil		ifTrue: [ ^Dialog warn: str ].	( env asNameSpace includesKey: dataKey )		ifFalse: [^Dialog warn: str].	aSourceCodeStream storeObjectDefinition: (env asNameSpace fullyQualifiedReferenceOf: dataKey).	self fullName asStrictReference fileOutInitializerOn: aSourceCodeStream.</body><body package="PackageCategories">loadSrcIntoPackage: imPkg confirm: aBoolean	"Do nothing since I'm already in the image."</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>bogus</category><body package="PackageCategories">forDbPackage	"Answer an array with a first element being a namespace and second	being a dataKey. This method is used for the DB package creation."	^Array with: self nameSpace with: dataKey</body></methods><methods><class-id>Store.DatumDescriptor class</class-id> <category>instance creation</category><body package="PackageCategories">fromDataKey: dataKey class: aClass	^self fromDataKey: dataKey className: aClass absoluteName.</body><body package="PackageCategories">fromDataKey: dataKey className: aName	^self new		dataKey: dataKey; 		className: aName;		yourself.</body><body package="PackageCategories">fromDataKey: dataKey nameSpace: namespace	^self fromDataKey: dataKey nameSpaceName: namespace absoluteName.</body><body package="PackageCategories">fromDataKey: dataKey nameSpaceName: nameSpaceName	^self new		dataKey: dataKey; 		nameSpaceName: nameSpaceName;		yourself.</body><body package="PackageCategories">fromDataKey: dataKey owner: anOwner	^anOwner isBehavior		ifTrue: [ self fromDataKey: dataKey class: anOwner ]		ifFalse: [ self fromDataKey: dataKey nameSpace: anOwner ].</body></methods><methods><class-id>Store.Change</class-id> <category>change types</category><body package="PackageCategories">add	type := #add</body><body package="PackageCategories">change	type := #change</body><body package="PackageCategories">comment	type := #comment</body><body package="PackageCategories">override	type := #override.</body><body package="PackageCategories">remove	type := #remove</body><body package="PackageCategories">removeChanges	type := #removeChanges</body><body package="PackageCategories">removeDefinition	type := #removeDefinition.	meta := false.</body><body package="PackageCategories">reorganize	type := #reorganize</body></methods><methods><class-id>Store.Change</class-id> <category>testing</category><body package="PackageCategories">isAdd	^type == #add</body><body package="PackageCategories">isChange	^type == #change</body><body package="PackageCategories">isClassChange	^classSymbol notNil and:  [subdef notNil]</body><body package="PackageCategories">isComment	^type == #comment</body><body package="PackageCategories">isComponentChange	^false</body><body package="PackageCategories">isDataChange	^subdef = #dataKey</body><body package="PackageCategories">isForClass	^classSymbol notNil</body><body package="PackageCategories">isForNameSpace	^nameSpaceSymbol notNil</body><body package="PackageCategories">isMethodChange	^subdef = #selector</body><body package="PackageCategories">isNameSpaceChange	^nameSpaceSymbol notNil and: [subdef notNil]</body><body package="PackageCategories">isRemove	^type == #remove</body><body package="PackageCategories">isRemoveChanges	^type == #removeChanges</body><body package="PackageCategories">isRemoveDefinition	^type == #removeDefinition</body><body package="PackageCategories">isReorganize	^type == #reorganize</body><body package="PackageCategories">isValid		^type notNil</body></methods><methods><class-id>Store.Change</class-id> <category>accessing</category><body package="PackageCategories">actual: aClassOrNameSpace	"Set the actual object - a class or namespace."	aClassOrNameSpace isBehavior		ifTrue: [ self class: aClassOrNameSpace ]		ifFalse: [ self nameSpace: aClassOrNameSpace ].</body><body package="PackageCategories">class: class	classSymbol := class absoluteName asClassNameOnly asSymbol.	meta := class isMeta</body><body package="PackageCategories">className: aClassName meta: isMeta	classSymbol := aClassName asSymbol.	self meta: isMeta.</body><body package="PackageCategories">classSymbol	^classSymbol</body><body package="PackageCategories">classSymbol: aClassSymbol	classSymbol := aClassSymbol asClassNameOnly asSymbol.	self meta: aClassSymbol namesMetaClass</body><body package="PackageCategories">dataKey	subdef == #dataKey ifFalse: [self error: (#wrongRetrivalType &lt;&lt; #packages &gt;&gt; 'wrong retrival type')].	^key asSymbol</body><body package="PackageCategories">dataKey: dataKey	key := dataKey asSymbol.	subdef := #dataKey.	meta := false.</body><body package="PackageCategories">fullClassSymbol	^classSymbol</body><body package="PackageCategories">index	^subdef == #selector		ifTrue: [self meta				ifTrue: [2]				ifFalse: [1]]		ifFalse: [subdef == #dataKey				ifTrue: [3]				ifFalse: [0]]</body><body package="PackageCategories">key	^key</body><body package="PackageCategories">meta	meta isNil ifTrue: [^false].	^meta</body><body package="PackageCategories">meta: isMeta	meta := isMeta</body><body package="PackageCategories">nameSpace: namespace	nameSpaceSymbol := namespace absoluteSymbol.</body><body package="PackageCategories">nameSpaceSymbol	^nameSpaceSymbol</body><body package="PackageCategories">nameSpaceSymbol: aNameSpaceSymbol	nameSpaceSymbol := aNameSpaceSymbol asSymbol.</body><body package="PackageCategories">selector	subdef == #selector ifFalse: [self error: (#wrongRetrivalType &lt;&lt; #packages &gt;&gt; 'wrong retrival type')].	^key</body><body package="PackageCategories">selector: selector	key := selector.	subdef := #selector</body><body package="PackageCategories">symbol	^classSymbol == nil		ifFalse: [ classSymbol ]		ifTrue: [ nameSpaceSymbol ]</body><body package="PackageCategories">type	^type</body><body package="PackageCategories">type: aSymbol	type := aSymbol</body><body package="PackageCategories">typeWithMeta	"Note: Only Class related change objects have meta set to true, not Namespace/Data changes"		self meta ifFalse: [^type].	type == #reorganize ifTrue: [^#reorganizeMeta].	type == #change ifTrue: [^#changeMeta].	^type</body></methods><methods><class-id>Store.Change</class-id> <category>printing</category><body package="PackageCategories">printOn: aStream	aStream nextPutAll: (type ifNil: [(#InvalidChangeObject &lt;&lt; #store &gt;&gt; 'Invalid change object') asString]).	aStream nextPutAll: ' '.	self classSymbol ifNotNil: [ aStream nextPutAll: self classSymbol ].	self nameSpaceSymbol ifNotNil: [ aStream nextPutAll: self nameSpaceSymbol ]. 	self meta ifTrue: [aStream nextPutAll: ' class'].	self isMethodChange ifTrue: [aStream nextPutAll: ' &gt;&gt; ', key].	self isDataChange ifTrue: [aStream nextPutAll: ' : ', key].</body></methods><methods><class-id>Store.ClassForParcel</class-id> <category>initialization</category><body package="PackageCategories">from: aModel	super from: aModel.	selectors := aModel selectorsMeta: false.	metaSelectors := aModel selectorsMeta: true.</body></methods><methods><class-id>Store.ClassForParcel</class-id> <category>conversion</category><body package="PackageCategories">addToPackage: aPackage	( object isKindOf: AbsentClassImport )		ifTrue: [ ^self ].	hasDefinition 		ifTrue: [ XChangeSet current addClassDefinition: object toPackage: aPackage ].	self addAllSubDefsTo: aPackage.</body><body package="PackageCategories">updates: updates package: aPackage	"Update aPackage after parcel update."	| cset |	( object isKindOf: AbsentClassImport )		ifTrue: [ ^self ].	cset :=XChangeSet current.	self hasDefinition		ifTrue:			[ ( self isObjectIn: ( updates at: #added ) )				ifTrue: [ ^self addToPackage: aPackage ].			( self isObjectIn: ( updates at: #changed ) )				ifTrue: [ cset changeClass: object toPackage: aPackage ].			].	( self isObjectIn: ( updates at: #added ) )		ifTrue: [ ^self addAllSubDefsTo: aPackage ].	self processSelectors: selectors class: object updates: updates package: aPackage.	self processSelectors: metaSelectors class: object class			updates: updates package: aPackage.	self processDataUpdates: updates package: aPackage.</body></methods><methods><class-id>Store.ClassForParcel</class-id> <category>testing</category><body package="PackageCategories">isForClass	^true</body></methods><methods><class-id>Store.ClassForParcel</class-id> <category>accessing</category><body package="PackageCategories">selectorsMeta: isMeta	^isMeta		ifTrue: [ metaSelectors ]		ifFalse: [ selectors ]</body></methods><methods><class-id>Store.ClassForParcel</class-id> <category>private</category><body package="PackageCategories">addAllSubDefsTo: aPackage		| currentChangeSet |	currentChangeSet := XChangeSet current.	selectors		do:			[:each | 			(Override isOverriddenSelector: each class: object)				ifTrue: [currentChangeSet changeSelector: each class: object toPackage: aPackage]				ifFalse: [self addOrMoveSelector: each class: object toPackage: aPackage]].	metaSelectors		do:			[:each | 			(Override isOverriddenSelector: each class: object class)				ifTrue: [currentChangeSet changeSelector: each class: object class toPackage: aPackage]				ifFalse: [self addOrMoveSelector: each class: object class toPackage: aPackage]].	data do: [:each | currentChangeSet changeDataKeyForConvert: each class: object package: aPackage]</body><body package="PackageCategories">addOrMoveSelector: aSelector class: aClass toPackage: aPackage	"In the case where a Parceled Bundle has a overridden class, and also an extension, we need to move the method	and remove it from the old package. This is not the same as an override, which is handled in the calling method"	| owningPackage currentChangeSet |	currentChangeSet := XChangeSet current.	owningPackage := Store.Registry containingPackageForSelector: aSelector class: aClass.	^((aClass includesSelector: aSelector) and: [owningPackage ~= aPackage])		ifTrue: 			[currentChangeSet moveSelector: aSelector class: aClass toPackage: aPackage.			owningPackage changeSetsDo: [:eachChangeSet | eachChangeSet forgetMethodChange: aSelector class: aClass]]		ifFalse: [currentChangeSet addSelector: aSelector class: aClass toPackage: aPackage]</body><body package="PackageCategories">isSelector: selector class: aClass in: aCollection	"Answer true if aClass&gt;&gt;selector is in a Collection of parcel updates."	^aCollection contains:		[ :thing |		( ( thing class = MethodInstallationRecord ) and:			[ thing selector = selector ] ) and: 			[ thing implementingClass = aClass ] 		]</body><body package="PackageCategories">processDataUpdates: updates package: aPackage	| cset |	cset :=XChangeSet current.	data do:		[ :key |		( self isDataKey: key in: ( updates at: #added ) )			ifTrue: [ cset addDataKey: key class: object package: aPackage ].		( self isSelector: key class: object in: ( updates at: #changed ) )			ifTrue: [ cset changeDataKey: key class: object package: aPackage ].		].</body><body package="PackageCategories">processSelectors: aCollection class: aClass updates: updates package: aPackage	| cset |	cset :=XChangeSet current.	aCollection do:		[ :selector |		( self isSelector: selector class: aClass in: ( updates at: #added ) )			ifTrue: [ cset addSelector: selector class: object toPackage: aPackage ].		( self isSelector: selector class: aClass in: ( updates at: #changed ) )			ifTrue: [ cset changeSelector: selector class: aClass toPackage: aPackage ].		].</body><body package="PackageCategories">processSelectors: aCollection updates: updates package: aPackage	| cset |	cset :=XChangeSet current.	aCollection do:		[ :selector |		( self isSelector: selector class: object in: ( updates at: #added ) )			ifTrue: [ cset addSelector: selector class: object toPackage: aPackage ].		( self isSelector: selector class: object in: ( updates at: #changed ) )			ifTrue: [ cset changeSelector: selector class: object toPackage: aPackage ].		].</body></methods><methods><class-id>Store.PackageForParcel</class-id> <category>private</category><body package="PackageCategories">asPundle: aSymbol	"Convert the receiver into a pundle. Called on parcel load. Answer the converted pundle"	| packageModel |	packageModel := super asPundle: aSymbol.	packageModel startLoad.	[contents do: [:model | model addToPackage: packageModel].	packageModel		cleanse: false;		markPundleNotModifiedFor: (aSymbol ifNil: [#''])]			ensure: [packageModel endLoad].	^packageModel</body><body package="PackageCategories">pundleInImage	"Answer the image version of the receiver. Creates one if it doesn't exist."	^Registry packageNamedOrCreate: name.</body><body package="PackageCategories">updates: updates fromParcel: aParcel relink: aSymbol	"Update the pundle in the image from a parcel."	"Luckily, removes and overrides are handled outside this."	| pkg |	pkg := super updates: updates fromParcel: aParcel relink: aSymbol.	contents do:		[ :model | model updates: updates package: pkg ].	pkg 		cleanse: false; 		markNotModified.	^pkg.</body></methods><methods><class-id>Store.PackageForParcel</class-id> <category>initialization</category><body package="PackageCategories">from: aPackage saveLinks: saveLinks	super from: aPackage saveLinks: saveLinks.	contents := OrderedCollection new.	aPackage modelsDo:		[ :model |  contents add: ( ModelForParcel from: model ) ].</body></methods><methods><class-id>Store.PackageForParcel</class-id> <category>accessing</category><body package="PackageCategories">definedClasses	"Answer the receiver's defined classes."	^( contents select: 		[ :m | m isForClass &amp; m hasDefinition ]	) collect: [ :m | m object ]</body><body package="PackageCategories">definedNameSpaces	"Answer the receiver's defined namespaces."	^( contents select: 		[ :m | m isForNameSpace &amp; m hasDefinition ]	) collect: [ :m | m object ]</body><body package="PackageCategories">extendedClasses	"Answer the receiver's extended classes."	^( contents select: 		[ :m | m isForClass &amp; m hasDefinition not ]	) collect: [ :m | m object ]</body></methods><methods><class-id>Store.PackageForParcel</class-id> <category>iterating</category><body package="PackageCategories">pundlesDo: aBlock	"Evaluate aBlock for all of our contained packages and bundles."	^self.</body></methods><methods><class-id>Store.ComponentRelatedChange</class-id> <category>accessing</category><body package="PackageCategories">tag: aTag	tag := aTag</body></methods><methods><class-id>Store.ComponentRelatedChange</class-id> <category>testing</category><body package="PackageCategories">isClassChange	^false</body><body package="PackageCategories">isComponentChange	^true</body></methods><methods><class-id>Store.BundleDescription</class-id> <category>testing</category><body package="PackageCategories">describesBundleNamed: aString	"Answer true if the description refers to a bundle named aString"	^self componentName = aString</body><body package="PackageCategories">describesSameAs:  aComponentDescr	"Answer true if aComponentDescr refers to	a bundle named the same as my bundle"	^aComponentDescr isBundle		and: [ self describesBundleNamed: aComponentDescr name ].</body><body package="PackageCategories">exactLoadedComponent	"Find if a bundle with my id is loaded into the image."	id isNil ifTrue: [^nil].	Registry bundlesDo: 		[ :bndl | 		bndl dbTrace = id 			ifTrue: 				[ ^bndl hasBeenModified					ifTrue: [ nil ]					ifFalse: [ bndl ]				]		].	^nil</body><body package="PackageCategories">isBundle	^true</body><body package="PackageCategories">loadedComponent	"Find if a bundle fullfilling my description is loaded into the image."	componentName == nil		ifFalse: [ ^Registry bundleNamed: componentName ].	id isNil ifTrue: [ ^nil ].	Registry bundlesDo: 		[ :bndl | 		bndl dbTrace = id 			ifTrue: 				[ ^bndl hasBeenModified					ifTrue: [ nil ]					ifFalse: [ bndl ]				]		].	^nil</body></methods><methods><class-id>Store.BundleDescription</class-id> <category>accessing</category><body package="PackageCategories">component	"Find a component named componentName and answer it."	^componentName == nil		ifTrue: [ nil ]		ifFalse: [ Registry bundleNamed: componentName ]</body><body package="PackageCategories">createComponent	"Return the component with my componentName create it if needed."	| bun |	componentName isNil ifTrue: [^nil].	bun := Registry bundleNamed: componentName.	bun notNil ifTrue: [^bun].	^BundleModel named: componentName</body></methods><methods><class-id>Store.BundleDescription</class-id> <category>private</category><body package="PackageCategories">leafItems	"Answer a list of packages contianed in my bundle 	and in bundles contained by my bundle."	| comp |	comp := self component.	^comp isNil		ifTrue: [#()]		ifFalse: [comp leafItems]</body></methods><methods><class-id>Store.ClassExtensionDescriptor</class-id> <category>testing</category><body package="PackageCategories">isExtension	^true</body></methods><methods><class-id>Store.ClassExtensionDescriptor</class-id> <category>accessing</category><body package="PackageCategories">definition		^super definition."	^'This class is not defined in this package'"</body><body package="PackageCategories">prerequisitesForLoading		^OrderedCollection new.</body><body package="PackageCategories">xmlDefinition		^super xmlDefinition."	^'This class is not defined in this package'"</body></methods><methods><class-id>Store.ClassExtensionDescriptor</class-id> <category>printing</category><body package="PackageCategories">itemString	^self name</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store utils</category><body package="PackageCategories">absoluteSymbol	"Answer an environment independant 	(and therefore truely unique) symbol"	^self absoluteReference asSymbol</body></methods><methods><class-id>Tools.IncrementalSearchModule class</class-id> <category>instance creation-predefined</category><body package="PackageCategories">forPackageSelection: prompt	"Answer a module that allows to select a package with search by a partial name."		| instance |	instance := self new.	instance		firstLabel: prompt;		secondLabel: #PackagesC &lt;&lt; #labels &gt;&gt; 'Packages:';		searchBlock: [:string | self findPackagesMatching: string];		objectToStringBlock: [:package | package name];		displayStringSelector: #toolListText;		iconBlock:				[:package | 					package == Store.Registry nullPackage						ifTrue: [nil]						ifFalse: [package toolListIcon]].	^instance</body></methods><methods><class-id>Core.String</class-id> <category>private-store</category><body package="PackageCategories">classNameOnly	"Answer a part of receiver that contains the class name.	Note that this method assumes that the receiver holds the metaclass name"	^self allButLast: 6</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store data</category><body package="PackageCategories">dataAt: aDataKey put: data		"Install a data value. Answer true if ok"	self at: aDataKey put: data.	^true</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>accessing</category><body package="PackageCategories">environmentNameFromSmalltalk	| index startingFromSmalltalk absoluteOwnerName |	absoluteOwnerName := self absoluteOwnerName.	index := absoluteOwnerName findString: '.Smalltalk' startingAt: 1.	startingFromSmalltalk := absoluteOwnerName copyFrom: index + 1 to: absoluteOwnerName size.	index isZero ifTrue: [(absoluteOwnerName findString: 'Root' startingAt: 1) isZero ifFalse: [index := 1]].	index isZero ifFalse: [index := startingFromSmalltalk indexOf: $.].	^startingFromSmalltalk copyFrom: index + 1 to: startingFromSmalltalk size</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>file out support</category><body package="PackageCategories">fileOutData: aSet for: aNameSpace logging: logging 	"File a description of the data of aNameSpace whose keys are in aSet onto the	target file."	aSet do: 			[:key | 			(aNameSpace asNameSpace includesKey: key) 				ifTrue: 					[self storeObjectDefinition: (aNameSpace asNameSpace 								fullyQualifiedReferenceOf: key).					logging 						ifTrue: 							[Transcript								cr;								show: aNameSpace printString;								show: '.';								show: key]]				ifFalse: 					[Dialog 						warn: ((#_1p2sIsNotDefined &lt;&lt; #store &gt;&gt; '&lt;1p&gt;.&lt;2s&gt; is not defined.') expandMacrosWith: aNameSpace with: key)]]</body></methods><methods><class-id>Kernel.ChunkSourceFileFormat</class-id> <category>code component support</category><body package="PackageCategories">bundleStructure:  aBundle on: aStream	"Add the loading of a package/bundle event on a stream. "	self bundleNamed: aBundle name structure: aBundle structure on: aStream</body></methods><methods><class-id>Tools.EntryWithPasteButtonModule class</class-id> <category>instance creation</category><body package="PackageCategories">forPackages	^self new 		pasteBlock: [self selectPackage];		yourself</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>accessing</category><body package="PackageCategories">absoluteName	"Answers the overriden object's absouteName."	^self environment absoluteName, '.', self name.</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>change list support</category><body package="PackageCategories">asStoreChange	^(Store.Change new)		selector: self selector;		class: self implementingClass</body></methods><methods><class-id>Core.Metaclass</class-id> <category>team tools</category><body package="PackageCategories">absoluteSymbol	^self absoluteName asSymbol</body></methods><methods><class-id>Tools.IncrementalSearchModule class</class-id> <category>instance creation-predefined</category><body package="PackageCategories">forPackageSelection	"Answer a module that allows to select a package with search by a partial name."	"self forPackageSelection open"	^self forPackageSelection: #FindC &lt;&lt; #labels &gt;&gt; 'Find:'</body></methods><methods><class-id>Kernel.Override</class-id> <category>change list support</category><body package="PackageCategories">cleanUpAfterLoad	^self subclassResponsibility</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>accessing</category><body package="PackageCategories">actual	^self object value</body></methods><methods><class-id>Kernel.OverridenNameSpace</class-id> <category>change list support</category><body package="PackageCategories">cleanUpAfterLoad	self sources do:		[:each |		each isParcel ifFalse:			[each changeSetsDo:				[:eachChangeSet |				| nameSpaceChange |				nameSpaceChange := eachChangeSet at: self absoluteSymbol ifAbsent: [nil].				nameSpaceChange ifNotNil: [nameSpaceChange removeDefChanges: #(#override #comment #removeDefinition)].				eachChangeSet removeIfEmptySymbol: self absoluteSymbol]]]</body></methods><methods><class-id>Kernel.GeneralBindingReference</class-id> <category>printing</category><body package="PackageCategories">absoluteName	| prefix |	(self valueOrDo: [nil]) ifNotNil: [:value | ^value absoluteName].	prefix := ''.	self environment ifNotNil: [:value | prefix := value absoluteName, '.'].	^prefix , self fullName</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>file out support</category><body package="PackageCategories">fileOutData: aSet for: aNameSpace	"File a description of the data of aNameSpace, whose keys are in aSet, onto the	target file.  If updateSourcePointers is true, then set the methods' sourcePointers in	order to indicate where to find the source code."	^self fileOutData: aSet for: aNameSpace logging: false</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>installation</category><body package="PackageCategories">restoreStateUsing: aStoreChange	| package |	package := self sources detect: #isPackage ifNone: [^self].	package changeSetsDo: [:each | each doChange: aStoreChange]</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>store</category><body package="PackageCategories">asPseudoRecord	"Answer a store psuedo record representing the image version of the 	class/namespace part of the receiver."	 ^Store.ClassDescriptor 		fullName: self owner absoluteName 		meta: self isMeta</body></methods><methods><class-id>Core.String</class-id> <category>private-store</category><body package="PackageCategories">metaclassDisplayStringSuffix	^' class'</body></methods><methods><class-id>Core.Class</class-id> <category>store data</category><body package="PackageCategories">includesDataKey: dataKey 	"is this one of the data items."	"should check the class vars."	^self asNameSpace includesKey: dataKey</body></methods><methods><class-id>Tools.IncrementalSearchModule class</class-id> <category>private</category><body package="PackageCategories">findPackagesMatching: aString	| pattern packages |	pattern := aString trimBlanks, '*'.	packages := Store.Registry allPackages.	packages := packages copyWith: Store.Registry nullPackage.	^(packages select: [:each | pattern match: each name])		asSortedCollection: [:a :b | a name &lt; b name]</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>store</category><body package="PackageCategories">methodDescriptors	^self selectors asSortedCollection asOrderedCollection collect:  		[ :sel | 		Store.MethodDescriptor 			fromSelector: sel 			className: self absoluteName 			meta: self isMeta 		]</body></methods><methods><class-id>Kernel.Override</class-id> <category>change list support</category><body package="PackageCategories">asStoreChange	self subclassResponsibility</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>accessing</category><body package="PackageCategories">binding	^self object</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>store</category><body package="PackageCategories">copyPropertiesTo:  pkg	"Move the receiver's properties to pkg. Where possible, use accessors."	"May have to do a little editing."	properties keysAndValuesDo:		[ :key : value |		[ pkg  perform: ( key, ':' ) asSymbol with: value ] on: MessageNotUnderstood 			do: [ :e | pkg propertyAt: key put: value. e return ]		]</body></methods><methods><class-id>Kernel.OverridenNameSpace</class-id> <category>change list support</category><body package="PackageCategories">asStoreChange	^Store.Change new nameSpace: self actual</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>code component support</category><body package="PackageCategories">bundleNamed: name structure: structure on: aStream	"Save the bundle structure on a Stream."	self checkForWrite: aStream.	aStream cr; cr.	self on: aStream tag: 'bundle-structure' do:		[:xml :str |		str cr.		xml on: str tag: 'name' value: name.		str space.		xml on: str tag: 'structure' value: structure storeString.		str cr]</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>change list support</category><body package="PackageCategories">existingChangeType	self sources do:		[:each |		each isParcel ifFalse: 			[^each currentChangeForClass: self actual]].	^#none</body></methods><methods><class-id>XML.SourceNodeBuilder</class-id> <category>compiling-code components</category><body package="PackageCategories">compile_bundle_structure: anElement	| reg bundle string |	reg := #{Store.Registry} valueOrDo: [ ^nil ].	string :=  self getString: 'name' from: anElement default: ''.	string isEmpty		ifTrue: [ ^nil ].	bundle := reg bundleNamedOrCreate: string.	string := self getString: 'structure' from: anElement default: ''.	bundle structure: ( Compiler evaluate: string ).</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>installation</category><body package="PackageCategories">restoreStateUsing: aStoreChange	| package |	package := self sources detect: #isPackage ifNone: [^self].	package doSubdefChange: aStoreChange</body></methods><methods><class-id>Core.Class</class-id> <category>store tools</category><body package="PackageCategories">absoluteSymbol	"Answer an environment independant (and therefore truely unique) name"	^self absoluteName asSymbol</body></methods><methods><class-id>Kernel.Override</class-id> <category>store</category><body package="PackageCategories">asPseudoRecord	"Answer a store psuedo record representing the image version of the 	class/namespace part of the receiver."	self subclassResponsibility</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>accessing</category><body package="PackageCategories">protocol	^self argumentForKeyWord: 'category'</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store utils</category><body package="PackageCategories">dataBindings	| list |	list := List new.	bindings do: 		[ :i | i isForGeneral ifTrue: [ list add: i ] ].	^list</body></methods><methods><class-id>Kernel.OverridenNameSpace</class-id> <category>store</category><body package="PackageCategories">asPseudoRecord	"Answer a store psuedo record representing the image version of the 	class/namespace part of the receiver."	 ^Store.PseudoRecord fromModel: self</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>installation</category><body package="PackageCategories">applyChangeType: aSymbol	self package applyChangeType: aSymbol class: self object</body></methods><methods><class-id>Tools.TreeItemHolder class</class-id> <category>instance creation-store</category><body package="PackageCategories">withStorePundleTree	^(self on: Store.Registry)		childrenBlock: [:object | object containedItems];		yourself</body></methods><methods><class-id>Tools.CategorizedSelectionModule class</class-id> <category>private</category><body package="PackageCategories">classesInPundle: aPundleOrNil	^aPundleOrNil isNil		ifTrue: [Array new]		ifFalse: [aPundleOrNil definedClasses asSortedCollection: [:a :b | a name &lt; b name]]</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>private</category><body package="PackageCategories">setOverriddenProtocol: aSymbol	protocol := aSymbol</body></methods><methods><class-id>Tools.IncrementalSearchDialog class</class-id> <category>dialog opening-predefined</category><body package="PackageCategories">selectPackage: aUserMessageOrString	"self selectPackage: 'Find package:' "	| dialog |	dialog := self new module: 		(IncrementalSearchModule forPackageSelection: aUserMessageOrString).	^dialog select</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>store</category><body package="PackageCategories">asPseudoRecord	"Answer a store psuedo record representing the image version of the 	class/namespace part of the receiver."	| object |	object := self owner.	^object isBehavior		ifTrue: [ Store.ClassExtensionDescriptor fullName: object absoluteName meta: false ]		ifFalse: [  Store.NameSpaceExtensionDescriptor fullName: object absoluteName ]</body><body package="PackageCategories">sourceCode	^self text</body></methods><methods><class-id>Kernel.BindingReference class</class-id> <category>tt_utilities</category><body package="PackageCategories">newName: newName from: oldQualifiedName	| path |	path := self parseString: oldQualifiedName.	path at: path size put: newName.	^( self path: path ) asString</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>binary storage</category><body package="PackageCategories">codeWriterTraceOnto: tracer	"There's nothing real to do yet."</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>change list support</category><body package="PackageCategories">cleanUpAfterLoad	self sources do:		[:each |		each isParcel ifFalse:			[each 				removeChangeTypes: #(#remove #override) 				forClass: self implementingClass 				selector: selector]]</body></methods><methods><class-id>Kernel.SourceFileFormat</class-id> <category>code component support</category><body package="PackageCategories">bundleNamed: name structure: structure on: aStream	"Add the changing of a bundle structure event on a stream. "	^self subclassResponsibility</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>store</category><body package="PackageCategories">absoluteOwnerName	^self owner absoluteName</body></methods><methods><class-id>Kernel.Override</class-id> <category>store</category><body package="PackageCategories">packageName	^( self sources detect: [ :s | s isPackage ] ifNone: [ ^nil ] ) name</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>change list support</category><body package="PackageCategories">cleanUpAfterLoad	self sources do:		[:each |		each isParcel ifFalse: 			[each  				removeChangeTypes: #(#remove #override) 				forSharedNamed: self key 				in: self owner]]</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>store</category><body package="PackageCategories">asPackageNamed: packageNameString	"Answer a package that duplicates the receiver."	"Currently, does not remove from an existing package."		| packageModel |	packageNameString isEmpty ifTrue: [^nil].	(Store.Registry packageNamed: packageNameString) == nil		ifFalse:			[^self				asPackageNamed:					(Dialog						request: (#PackageAlreadyExists &lt;&lt; #packages &gt;&gt; 'Package &lt;1s&gt; already exists.&lt;n&gt;Confirm. ' expandMacrosWith: packageNameString)						initialAnswer: packageNameString						onCancel: [^nil])].	packageModel := Store.Registry packageNamedOrCreate: packageNameString.	[packageModel startLoad.	self moveContentsTo: packageModel.	packageModel copyPropertiesFrom: self properties.	packageModel		comment:			(self commentOrNil == nil				ifTrue: [#PackageConvertedFromParcel &lt;&lt; #packages &gt;&gt; 'Converted from parcel: &lt;1s&gt;  &lt;2s&gt;' expandMacrosWith: self name with: self versionString]				ifFalse: [self comment]).	packageModel resetUninstalledStateFrom: self.	packageModel markNotModified.	Override equateComponent: packageModel with: self] ensure: [packageModel endLoad].	^packageModel</body></methods><methods><class-id>Kernel.OverridenNameSpace</class-id> <category>store</category><body package="PackageCategories">absoluteName	"Answers the overriden object's absouteName."	^self environment absoluteName, '.', self name.</body></methods><methods><class-id>Kernel.AbsentClassImport</class-id> <category>accessing</category><body package="PackageCategories">absoluteSymbol	^(self name asQualifiedReference environment fullName, '.', self name) asSymbol</body></methods><methods><class-id>Kernel.ChangeSet</class-id> <category>component change management</category><body package="PackageCategories">bundleStructure: aBundle	"Include indication or the changing of a bundle structure event. "	self addComponentChange:		( Store.BundleStructureChange new			component: aBundle;			yourself		)</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>change list support</category><body package="PackageCategories">cleanUpAfterLoad	self sources do:		[:each |		each isParcel ifFalse: 			[each changeSetsDo:				[:eachChangeSet |				| classChange |				classChange := eachChangeSet at: self actual absoluteSymbol ifAbsent: [nil].				classChange ifNotNil: [classChange removeDefChanges: #(#override #remove #removeDefinition)].				eachChangeSet removeIfEmptySymbol: self actual absoluteSymbol]]]</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>change list support</category><body package="PackageCategories">existingChangeType	self sources do:		[:each |		each isParcel ifFalse:			[^each currentChangeForSelector: self selector class: self implementingClass]].	^#none</body></methods><methods><class-id>Core.String</class-id> <category>private-store</category><body package="PackageCategories">asClassNameOnly	"Check if the string names meta class and strip 	the postfix class."	^self namesMetaClass		ifTrue: [self classNameOnly]		ifFalse: [self copy]</body><body package="PackageCategories">fullMetaName	"Add ' class' to the receiver"	^self, self metaclassDisplayStringSuffix</body></methods><methods><class-id>Kernel.Override</class-id> <category>installation</category><body package="PackageCategories">restoreStateUsing: aStoreChange	self subclassResponsibility</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>store</category><body package="PackageCategories">absoluteName	^self owner absoluteName, '.', self key</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>store</category><body package="PackageCategories">asPackage	"Answer a package that duplicates the receiver."	^self asPackageNamed: self name.</body></methods><methods><class-id>Kernel.OverridenNameSpace</class-id> <category>installation</category><body package="PackageCategories">restoreStateUsing: aStoreChange	| package |	package := self sources detect: #isPackage ifNone: [^self].	package changeSetsDo: [:each | each doChange: aStoreChange]</body></methods><methods><class-id>Kernel.GeneralBindingReference</class-id> <category>store</category><body package="PackageCategories">finalNameSpaceName		| list |	( list := self path asOrderedCollection ) removeLast.	^( self class path: list ) asString.</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>file out code components support</category><body package="PackageCategories">bundleStructure: aBundle 	"Add the changing of a bundle structure event on a stream. "	self noTargetForWrites 		ifFalse:			[self targetFormatter bundleStructure: aBundle on: self targetFile.			self endOfChunk]</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>change list support</category><body package="PackageCategories">asStoreChange	^Store.Change new class: self actual</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>store</category><body package="PackageCategories">sourceCode	^self text</body></methods><methods><class-id>Core.Class</class-id> <category>store data</category><body package="PackageCategories">datumDescriptors	"Answer a collection of DatumDescriptors for the recievers dataKeys."	^self dataKeys asSortedCollection asOrderedCollection collect: 		[ :dataKey | 		Store.DatumDescriptor fromDataKey: dataKey className: self absoluteName 		]</body></methods><methods><class-id>Tools.DefinitionCreationDialog</class-id> <category>validation</category><body package="PackageCategories">validatePackageIfFails: aBlock	self isPackageProvided ifFalse:		[aBlock value: #PackageNameIsRequired &lt;&lt; #dialogs &gt;&gt; 'The package name is required'].	(Store.Registry packageNamed: self packageModule value trimBlanks) isNil		ifTrue: [aBlock value: #NoSuchPackage &lt;&lt; #dialogs &gt;&gt; 'There is no such package']</body></methods><methods><class-id>Kernel.Override</class-id> <category>installation</category><body package="PackageCategories">installAndRestoreStateTo: aSymbolOrNil	self install.	(#(#add #change) includes: aSymbolOrNil) ifTrue: 		[self restoreStateUsing: (self asStoreChange type: aSymbolOrNil)]</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>store</category><body package="PackageCategories">isInClass	^self owner isBehavior</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store data</category><body package="PackageCategories">dataKeys	| list |	list := List new.	bindings do: 		[ :i | i isForGeneral ifTrue: [ list add: i key ] ].	^list</body></methods><methods><class-id>Core.String</class-id> <category>private-store</category><body package="PackageCategories">namesMetaClass	"Answer true if the string contains the word class."		^self size &gt; 6 and: [self endsWith: self metaclassDisplayStringSuffix]</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>store</category><body package="PackageCategories">checkPrerequisiteNamed: prerequisiteName withVersion: prerequisiteVersionString requiredVersion: requiredVersionString	"Answer if the version of the prerequisite prerequisiteName is acceptable.	Callback for prerequiste loading"	| blk |	( blk := self versionSelectionBlock  ) == nil		ifTrue: [ ^true ].	^blk		value: prerequisiteName		value: prerequisiteVersionString		value: requiredVersionString</body></methods><methods><class-id>Kernel.XMLSourceFileFormat</class-id> <category>code component support</category><body package="PackageCategories">bundleStructure: aBundle on: aStream	"Save the bundle structure on a Stream."	self bundleNamed: aBundle name structure: aBundle structure on: aStream</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>store</category><body package="PackageCategories">asPseudoRecord	"Answer a store psuedo record representing the image version of the 	class/namespace part of the receiver."	 ^Store.PseudoRecord fromModel: self</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>installation</category><body package="PackageCategories">applyChangeType: aSymbol	self package		applyChangeType: aSymbol		selector: self selector		class: self implementingClass</body></methods><methods><class-id>Core.Class</class-id> <category>store data</category><body package="PackageCategories">dataAt: aDataKey ifAbsent: aBlock	"Look up data value "	^self asNameSpace dataAt: aDataKey ifAbsent: aBlock</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>accessing externals</category><body package="PackageCategories">fillDefineCacheIn: anExternalInterface	"the ExternalDictionary is updated as a side effect of the compilation.	  We also need to hold on to the compiled method, otherwise the binding in the ExternalDictionary may get garbage collected"	| methodNode  compiler |	compiler := anExternalInterface compilerClass new.	compiler environment: nil.	methodNode := compiler 				compile: self getSource				in: anExternalInterface				notifying: nil				ifFail: [^nil].	^methodNode generate</body></methods><methods><class-id>Kernel.ChangeSet class</class-id> <category>component change management</category><body package="PackageCategories">unloadPundle: aPundle	"Include indication that aPundle was unloaded."		self changed: #unloadPundle: with: (Array with: aPundle)</body></methods><methods><class-id>Kernel.Override</class-id> <category>accessing</category><body package="PackageCategories">actual	^self object</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>installation</category><body package="PackageCategories">applyChangeType: aSymbol	self package		applyChangeType: aSymbol		forSharedNamed: self key		in: self owner</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store data</category><body package="PackageCategories">includesDataKey: dataKey	"is this one of the data items."	^self includesKey: dataKey</body><body package="PackageCategories">dataAt: aDataKey ifAbsent: aBlock		"look up a data value- "	^self at: aDataKey ifAbsent: aBlock</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>installation</category><body package="PackageCategories">restoreStateUsing: aStoreChange	| package |	package := self sources detect: #isPackage ifNone: [^self].	package doSubdefChange: aStoreChange</body></methods><methods><class-id>Core.VariableBinding</class-id> <category>printing</category><body package="PackageCategories">definitionString	| definitionStream |	definitionStream := WriteStream on: String new.	definitionStream		nextPutAll: self environment unambiguousName;		nextPutAll: ' defineSharedVariable: #';		nextPutAll: self key;		cr;		tab;		nextPutAll: 'private: ';		nextPutAll: self isPrivate printString;		cr;		tab;		nextPutAll: 'constant: ';		nextPutAll: self isConstant printString;		cr;		tab;		nextPutAll: 'category: ';		nextPutAll: self category asString printString;		cr;		tab;		nextPutAll: 'initializer: '.	self method isNil 		ifTrue: [definitionStream nextPutAll: 'nil']		ifFalse: [definitionStream nextPutAll: self method getSource printString].	^definitionStream contents</body></methods><methods><class-id>Tools.EntryWithPasteButtonModule class</class-id> <category>private</category><body package="PackageCategories">selectPackage	^(IncrementalSearchDialog selectPackage: #PackageC &lt;&lt; #labels &gt;&gt; 'Package:')		ifNotNil: [:package | package name]</body></methods><methods><class-id>Tools.CategorizedSelectionModule class</class-id> <category>instance creation-predefined</category><body package="PackageCategories">forClassesByPackage	"self forClassesByPackage open"	^self new		categoryModule: TreeSelectionModule forStoreBundlesAndPackages		itemModule: ListSelectionModule forClasses		itemBlock: [:pundle | self classesInPundle: pundle]</body></methods><methods><class-id>Kernel.Override</class-id> <category>installation</category><body package="PackageCategories">applyChangeType: aSymbol	self subclassResponsibility</body></methods><methods><class-id>Core.Class</class-id> <category>store data</category><body package="PackageCategories">dataKeys	"Answer the receiver's data."	^( self classPool isEmpty )		ifTrue: [ #() ]		ifFalse: 	[ self classPool keys ].</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>change list support</category><body package="PackageCategories">existingChangeType	self sources do:		[:each |		each isParcel ifFalse: 			[^each currentChangeForShared: self key in: self owner]].	^#none</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store data</category><body package="PackageCategories">datumDescriptors		"Answer a collection of DatumDescriptors for the recievers dataKeys."	^self dataKeys asSortedCollection asOrderedCollection collect: 		[ :dataKey | 		Store.DatumDescriptor fromDataKey: dataKey nameSpaceName: self absoluteName 		]</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>store</category><body package="PackageCategories">dataKey	^self key</body></methods><methods><class-id>Kernel.SourceFileManager</class-id> <category>file out code components support</category><body package="PackageCategories">bundleNamed: name structure: structure 	"Add the changing of a bundle structure event on a stream. "	self noTargetForWrites 		ifFalse: 			[self targetFormatter 				bundleNamed: name				structure: structure				on: self targetFile.			self endOfChunk]</body></methods><methods><class-id>Kernel.Override class</class-id> <category>management</category><body package="PackageCategories">removeOverridesForClassOrNameSpaceDefinition: aClassOrNameSpace in: aComponent	"Remove the override for a class or namespace definition in aComponent." 	| override |	override := ( self overriddenClassesAndNameSpaces at: aClassOrNameSpace ifAbsent: [ ^self ] ) detect:		[ :over | over includesSource: aComponent ] ifNone: [ ^self ]. 	override purge</body></methods><methods><class-id>Kernel.AbsentClassImport</class-id> <category>accessing</category><body package="PackageCategories">absoluteName	"HACK. Since #fullName is relative to Smalltalk, we have to force it to be relative to nil for Store."		^(self fullName beginsWith: 'Root')		ifTrue: [ self fullName ]		ifFalse: [ 'Root.Smalltalk.', self fullName ].</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>accessing</category><body package="PackageCategories">superclass		^(self argumentForKeyWord: 'superclass') value</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>store</category><body package="PackageCategories">absoluteClassName	^self implementingClass absoluteName</body></methods><methods><class-id>Core.Class</class-id> <category>store data</category><body package="PackageCategories">dataAt: aDataKey	"Answer text for aDataKey"	^self asNameSpace dataAt: aDataKey ifAbsent: [ nil ]</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>actions</category><body package="PackageCategories">changePrerequisite: aCodeComponent nameTo: aString	self		setPrerequisiteDescriptions: (self prerequisiteDescriptions collect: 					[:each |					each loadedCodeComponent == aCodeComponent ifTrue: [each name: aString].					each]).	self 		setDisregardedPrerequisites: (self disregardedPrerequisites collect: 					[:each |					each loadedCodeComponent == aCodeComponent ifTrue: [each name: aString].					each])</body></methods><methods><class-id>Kernel.BindingReference class</class-id> <category>tt_utilities</category><body package="PackageCategories">fullNameFrom: aPath name: aString	^( aPath == nil or: [ aPath isEmpty ] )		ifTrue: [ aString asString ]		ifFalse: [ ( aPath asQualifiedReference append: aString ) asString ]</body></methods><methods><class-id>Kernel.Override</class-id> <category>store</category><body package="PackageCategories">package	"Answer the overriden package, nil if none."	^self sources detect: [ :s | s isPackage ] ifNone: [ nil ].</body></methods><methods><class-id>Kernel.Parcel</class-id> <category>queries</category><body package="PackageCategories">pundleInImage	"Return the associated package or bundle, nil if we can't find one."	| pundleModel |		self packageName ifNotNil: [:id | pundleModel := Store.Registry packageNamed: id].	pundleModel notNil ifTrue: [^pundleModel].	self bundleName ifNotNil: [:id | pundleModel := Store.Registry bundleNamed: id].	^pundleModel"It is an error - but a possible state of things - for a pundle to have a packageName property _and_ a bundleName property.  The pundleModel notNil check above prevents this method from failing to return if a bundle is in such a state."</body></methods><methods><class-id>Kernel.Override class</class-id> <category>find instances</category><body package="PackageCategories">classesIn: aCodeComponent	"Answer the overridden classes in aCodeComponent."		| result |	result := OrderedCollection new.	self overriddenClassesAndNameSpaces do: 		[:each | 		each do: 			[:eachOverride | 			(eachOverride isForClass and: [eachOverride includesSource: aCodeComponent]) ifTrue: [result add: eachOverride]]].	^result</body></methods><methods><class-id>Kernel.AbsentClassImport</class-id> <category>accessing</category><body package="PackageCategories">classNameWithMeta		^self isMeta		ifTrue: [self absoluteName , ' class']		ifFalse: [self absoluteName]</body></methods><methods><class-id>Kernel.ChangeSet class</class-id> <category>component change management</category><body package="PackageCategories">bundleStructure: aBundle	"Include indication that aBundle's structure has changed."	self changed: #bundleStructure: with: ( Array with: aBundle )</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>testing</category><body package="PackageCategories">isMeta	^self name namesMetaClass</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>store</category><body package="PackageCategories">classNameWithMeta	^self absoluteClassName</body></methods><methods><class-id>Core.Class</class-id> <category>store data</category><body package="PackageCategories">unloadDataKey: dataKey 	"unload a data value. Answer nil if unable."	^self asNameSpace unloadDataKey: dataKey</body></methods><methods><class-id>Tools.DefinitionCreationDialog</class-id> <category>private-validation</category><body package="PackageCategories">isPackageProvided	| name |	name := packageModule value.	^name notNil and: [name trimBlanks notEmpty]</body></methods><methods><class-id>Kernel.Override</class-id> <category>change list support</category><body package="PackageCategories">existingChangeType	self subclassResponsibility</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>accessing</category><body package="PackageCategories">absoluteSymbol	^definition receiver absoluteSymbol, self key</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store data</category><body package="PackageCategories">dataAt: aDataKey		"Answer text for aDataKey"	^self dataAt: aDataKey ifAbsent: [ nil ]</body></methods><methods><class-id>Kernel.OverridenNameSpace</class-id> <category>change list support</category><body package="PackageCategories">existingChangeType	self sources do:		[:each |		each isParcel ifFalse: 			[^each currentChangeForNameSpace: self actual]].	^#none</body></methods><methods><class-id>Tools.TreeSelectionModule class</class-id> <category>instance creation-predefined</category><body package="PackageCategories">forStoreBundlesAndPackages	^TreeSelectionModule new		rootHolder: TreeItemHolder withStorePundleTree;		iconSelector: #toolListIcon;		showRoot: false;		expandableRoots: true;		preExpandTo: 0</body></methods><methods><class-id>Core.Class</class-id> <category>store data</category><body package="PackageCategories">dataAt: aDataKey put: data 	"Install a data value. Answer true if ok"	self asNameSpace dataAt: aDataKey put: data.	^true</body></methods><methods><class-id>Tools.DefinitionCreationDialog</class-id> <category>accessing</category><body package="PackageCategories">packageOrDo: aBlock	| name |	name := self packageModule value.	^(Store.Registry packageNamed: name) 			ifNil: [aBlock value]</body></methods><methods><class-id>Kernel.Override</class-id> <category>store</category><body package="PackageCategories">definition	^self text</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>change list support</category><body package="PackageCategories">asStoreChange	| change |	change := Store.Change new dataKey: self key.	self owner isBehavior		ifTrue: [change class: self owner]		ifFalse: [change nameSpace: self owner].	^change</body></methods><methods><class-id>Kernel.GeneralNameSpace</class-id> <category>store data</category><body package="PackageCategories">unloadDataKey: dataKey		"unload a data value. Answer nil  if unable."	self dataAt: dataKey ifAbsent: [ ^nil ].	self removeKey: dataKey.</body></methods><methods><class-id>Kernel.OverridenNameSpace</class-id> <category>installation</category><body package="PackageCategories">applyChangeType: aSymbol	self package applyChangeType: aSymbol nameSpace: self object</body></methods><methods><class-id>XML.SourceScannerNodeBuilder</class-id> <category>scanning-code components</category><body package="PackageCategories">scan_bundle_structure: anElement 	self doChange: 		( Store.BundleStructureChange new			componentName: ( self getString: 'name' from: anElement default: '' );			structureString: ( self getString: 'structure' from: anElement default: '' );			yourself		).</body></methods><methods><class-id>Kernel.ChunkSourceFileFormat</class-id> <category>code component support</category><body package="PackageCategories">bundleNamed: name structure: structure on: aStream	"Add the changing of a bundle structure event on a stream. "	aStream nextChunkPut: 		( '#{Store.Registry} ifDefinedDo:&lt;nt&gt;[:reg | (reg bundleNamedOrCreate: ''&lt;1s&gt;'') structure: &lt;2s&gt;]'				expandMacrosWith: name				with: structure storeString		); cr.</body></methods><methods><class-id>Kernel.NameSpaceOfClass</class-id> <category>store utils</category><body package="PackageCategories">dataBindings	"All class bindings are for data - right?"	^bindings asList</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>binary storage</category><body package="PackageCategories">storeInitializationObjectsOn: aBinaryCodeWriter	(self superclass == ExternalInterface or: [self superclass inheritsFrom: ExternalInterface]) 		ifTrue: [^self object storeInitializationObjectsOn: aBinaryCodeWriter]</body></methods><methods><class-id>Kernel.OverridenMethod</class-id> <category>store</category><body package="PackageCategories">protocolName	| p |	^( p := self protocol ) == nil		ifTrue: [ ClassOrganizer defaultProtocol ]		ifFalse: [ p ]</body></methods><methods><class-id>Store.PackageChooser class</class-id> <category>interface specs</category><body package="PackageCategories">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #ChooseAPackage #defaultString: 'Choose a Package' #catalogID: #packages) 			#min: #(#{Point} 199 275 ) 			#bounds: #(#{Rectangle} 288 163 665 588 ) ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{SequenceViewSpec} 					#layout: #(#{LayoutFrame} 5 0 40 0 -12 1 -52 1 ) 					#name: #SelectionList					#flags: 15 					#model: #packageList 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#doubleClickSelector: #dClickAccept ) ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutOrigin} 0 0.774536 0 0.898823 ) 					#name: #cancelButton 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #packages) 					#defaultable: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutOrigin} 5 0 -43 1 ) 					#name: #OKbutton 					#model: #accept 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #packages) 					#isDefault: true 					#defaultable: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{AlignmentOrigin} 0 0.453581 -43 1 0.5 0 ) 					#name: #addButton 					#model: #addNewPackage 					#label: #(#{Kernel.UserMessage} #key: #Add #defaultString: 'Add' #catalogID: #packages) 					#defaultable: true ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 0 0.5 9 0 0.5 0 ) 					#label: #dialogHeader ) ) ) )</body><body package="PackageCategories">windowSpecNoCancel	"UIPainter new openOnClass: self andSelector: #windowSpecNoCancel"	&lt;resource: #canvas&gt;	^#(#{FullSpec} 		#window: 		#(#{WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #ChooseAPackage #defaultString: 'Choose a Package' #catalogID: #packages) 			#min: #(#{Point} 199 275 ) 			#bounds: #(#{Rectangle} 373 204 768 625 ) ) 		#component: 		#(#{SpecCollection} 			#collection: #(				#(#{SequenceViewSpec} 					#layout: #(#{LayoutFrame} 5 0 40 0 -5 1 -50 1 ) 					#name: #SelectionList					#flags: 15 					#model: #packageList 					#callbacksSpec: 					#(#{UIEventCallbackSubSpec} 						#doubleClickSelector: #dClickAccept ) ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutOrigin} 25 0 -43 1 ) 					#name: #OKbutton 					#model: #accept 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #packages) 					#isDefault: true 					#defaultable: true ) 				#(#{ActionButtonSpec} 					#layout: #(#{LayoutOrigin} 0 0.728495 0 0.900709 ) 					#name: #addButton 					#model: #addNewPackage 					#label: #(#{Kernel.UserMessage} #key: #Add #defaultString: 'Add' #catalogID: #packages) 					#defaultable: true ) 				#(#{LabelSpec} 					#layout: #(#{AlignmentOrigin} 0 0.5 9 0 0.5 0 ) 					#label: #dialogHeader ) ) ) )</body></methods><methods><class-id>Store.PublishAsParcelDialog class</class-id> <category>interface specs</category><body package="PackageCategories">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #Publish 				#defaultString: 'Publish' 				#catalogID: #packages ) 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 575 247 1047 727 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 5 0 -4 1 -39 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #ParcelOptions 						#defaultString: 'Parcel options' 						#catalogID: #packages ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 11 80 ) 					#name: #parcelWarningMessage 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #red ) ) 					#label: #parcelWarningMessage ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 11 25 ) 					#name: #parcelSave 					#model: #parcelSave 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #parcelSaveChanged ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #PublishParcel 						#defaultString: 'Publish Parcel' 						#catalogID: #packages ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 3 ) 							#label: 							#(#{Kernel.UserMessage} 								#key: #ParcelPathC 								#defaultString: 'Parcel Path:' 								#catalogID: #packages ) ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 0 1 25 0 ) 							#name: #parcelDirectory 							#flags: 40 							#model: #parcelDirectory ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 11 0 50 0 -11 1 75 0 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 							#(#{Kernel.UserMessage} 								#key: #StoreOptions 								#defaultString: 'Store options' 								#catalogID: #packages ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0722892 0 0.4 ) 							#name: #databaseLinks 							#model: #databaseLinks 							#label: 							#(#{Kernel.UserMessage} 								#key: #WithDatabaseLinks 								#defaultString: 'With database links' 								#catalogID: #packages ) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 15 0 0 0.333333 -5 0.5 75 0.333333 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 							#(#{Kernel.UserMessage} 								#key: #SourceOptions 								#defaultString: 'Source options' 								#catalogID: #packages ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0722892 0 0.198276 ) 							#name: #parcelSaveSource 							#model: #parcelSaveSource 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #parcelSaveSourceChanged ) 							#label: 							#(#{Kernel.UserMessage} 								#key: #SaveSourceFile 								#defaultString: 'Save source file' 								#catalogID: #packages ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.174699 0 0.422414 ) 							#name: #parcelHideSource 							#model: #parcelHideSource 							#label: 							#(#{Kernel.UserMessage} 								#key: #HideSourceOnLoad 								#defaultString: 'Hide source on load' 								#catalogID: #packages ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.174699 0 0.681034 ) 							#name: #parcelPadded 							#model: #parcelPadded 							#label: 							#(#{Kernel.UserMessage} 								#key: #PadSource 								#defaultString: 'Pad source' 								#catalogID: #packages ) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 15 0 0 0.583333 -5 0.5 80 0.583333 ) ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 0 1.0 ) 							#label: 							#(#{Kernel.UserMessage} 								#key: #MiscellaneousOptions 								#defaultString: 'Miscellaneous Options' 								#catalogID: #packages ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.2 ) 							#name: #parcelRepublish 							#model: #parcelRepublish 							#label: 							#(#{Kernel.UserMessage} 								#key: #Republish 								#defaultString: 'Republish' 								#catalogID: #packages ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.448 ) 							#name: #parcelBackup 							#model: #parcelBackup 							#label: 							#(#{Kernel.UserMessage} 								#key: #Backup 								#defaultString: 'Backup' 								#catalogID: #packages ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0.0843373 0 0.712 ) 							#name: #parcelOverwrite 							#model: #parcelOverwrite 							#label: 							#(#{Kernel.UserMessage} 								#key: #OverwriteExistingFiles 								#defaultString: 'Overwrite existing files' 								#catalogID: #packages ) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 5 0.5 0 0.583333 -15 1 80 0.583333 ) ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -5 1 0 1 ) 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #Publish 						#defaultString: 'Publish' 						#catalogID: #packages ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -5 1 0.5 1 ) 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #packages ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -10 1 -5 1 1 1 ) 					#model: #helpAction 					#label: 					#(#{Kernel.UserMessage} 						#key: #Help 						#defaultString: 'Help' 						#catalogID: #packages ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 11 0 -55 1 0 1 ) 					#name: #VersionStringLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #VersionStringColon 						#defaultString: 'Version String:' 						#catalogID: #store ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 115 0 -77 1 -145 1 -52 1 ) 					#name: #VersionString 					#model: #parcelVersionString ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -135 1 -77 1 -11 1 -52 1 ) 					#name: #CopyFromPackage 					#model: #copyFromPackage 					#label: 					#(#{Kernel.UserMessage} 						#key: #CopyFromPackage 						#defaultString: 'Copy From Package' 						#catalogID: #store ) 					#defaultable: true ) ) ) )</body></methods><initialize><class-id>Store.PundleAccess</class-id></initialize><initialize><class-id>Store.PundleModel</class-id></initialize><initialize><class-id>Store.XMainChangeSet</class-id></initialize><initialize><class-id>Store.Access</class-id></initialize><initialize><class-id>Store.BasicTableSpacePolicy</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SourceFileFormat</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectProperties methodProperties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CodeComponent</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Components</category><attributes><package>System-Code Components</package></attributes></class><class><name>Parcel</name><environment>Kernel</environment><super>Kernel.CodeComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definedObjects definedClasses definedBindings classSelectors namedObjects dirty loaded </inst-vars><class-inst-vars>parcels classParcelMap parcelFileInfoCache parcelFileDirectoryCache dependents </class-inst-vars><imports></imports><category>System-Code Components</category><attributes><package>System-Code Components</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>GeneralBindingReference</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>path cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>AbsentClassImport</name><environment>Kernel</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name isMeta format instanceVariables dummyBehavior dummyClassPool </inst-vars><class-inst-vars></class-inst-vars><imports>			Core.Behavior.*			</imports><category>System-Code Storage</category><attributes><package>System-Code Storage</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>IdentityDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>valueArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>VariableBinding</name><environment>Core</environment><super>Core.LookupKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value usage category environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>Override</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sources definition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>OverridenNameSpace</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment documentation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>SourceNodeBuilder</name><environment>XML</environment><super>XML.XMLNodeBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Source Code</category><attributes><package>XML-source</package></attributes></class><class><name>ChangeSet</name><environment>Kernel</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectChanges objectRemoves componentChanges specialDoIts initializationOrder </inst-vars><class-inst-vars>dependents </class-inst-vars><imports></imports><category>System-Changes</category><attributes><package>System-Changes</package></attributes></class><class><name>SourceFileManager</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>files names writableIndices openIndices currentTarget isPadding sourceFormatters sourceToCopy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>GeneralNameSpace</name><environment>Kernel</environment><super>Core.KeyedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>organization bindings specificImports generalImports </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>NameSpaceOfClass</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>owner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>ChunkSourceFileFormat</name><environment>Kernel</environment><super>Kernel.SourceFileFormat</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>ComponentChange</name><environment>Kernel</environment><super>Kernel.Change</super><private>false</private><indexed-type>none</indexed-type><inst-vars>componentType componentName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Component Changes</category><attributes><package>System-Code Component Changes</package></attributes></class><class><name>OverridenStatic</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>method </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>XMLSourceFileFormat</name><environment>Kernel</environment><super>Kernel.SourceFileFormat</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state docName cachedFile cachedParser </inst-vars><class-inst-vars></class-inst-vars><imports>			private XML.*			</imports><category>Kernel-Support</category><attributes><package>XML-source</package></attributes></class><class><name>SourceScannerNodeBuilder</name><environment>XML</environment><super>XML.XMLNodeBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors currentFile currentPosition positions changeBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Source Code</category><attributes><package>XML-source</package></attributes></class><class><name>OverridenMethod</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector protocol instVarNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>DefinitionCreationDialog</name><environment>Tools</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageModule namespaceModule nameHolder privateHolder importsHolder </inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.Browser.Navigator			</imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>MethodFilter</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>Warning</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>OverridenClass</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>comment documentation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class></st-source>