<?xml version="1.0"?><st-source><!-- Name: Protocols-Http2Notice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: Protocol classes for client and server specific to HTTP2. HTTP2 implementation based on RFC 7540. https://httpwg.github.io/specs/rfc7540.htmlNot implemented yet:1. CONNECT methodSee SiouX-Http2 package comments for server implementationDbIdentifier: bear73DbTrace: 503119DbUsername: tkoganDbVersion: 8.3 - 21DevelopmentPrerequisites: #(#(#any 'Protocols-Common' '') #(#any 'Protocols-Http' '') #(#any 'Xtreams-Core' '') #(#any 'Xtreams-Terminals' '') #(#any 'Xtreams-Substreams' ''))PackageName: Protocols-Http2Parcel: #('Protocols-Http2')PrerequisiteDescriptions: #(#(#name 'Protocols-Common' #componentType #package) #(#name 'Protocols-Http' #componentType #package) #(#name 'Xtreams-Core' #componentType #package) #(#name 'Xtreams-Terminals' #componentType #package) #(#name 'Xtreams-Substreams' #componentType #package))PrerequisiteParcels: #(#('Protocols-Common' '') #('Protocols-Http' '') #('Xtreams-Core' '') #('Xtreams-Terminals' '') #('Xtreams-Substreams' ''))PrintStringCache: (8.3 - 21,tkogan)Version: 8.3 - 21Date: 1:17:53 PM July 14, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jul17.2) of July 14, 2017 on July 14, 2017 at 1:17:53 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>HTTP2FrameWriteStream</name><environment>Protocols</environment><super>Xtreams.WriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>endOfStream http2Stream </inst-vars><class-inst-vars></class-inst-vars><imports>			private Xtreams.*			</imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.HTTP2FrameWriteStream</class-id><body>HTTP2FrameWriteStream implement splitting Http messages in to framesInstance Variables:	destination	&lt;Xtreams.Buffer&gt;	 buffer	endOfStream	&lt;Boolean&gt; true if the message is done	http2Stream &lt;HTTP2Stream&gt; stream with the message</body></comment><class><name>HPACKCompessor</name><environment>Protocols</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dynamicTable dynamicTableAllowedSize dynamicTableSize accessMutex firstHeaderBlock onDynamicTableUpdate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.HPACKCompessor</class-id><body>HPACKCompessor implements HPACK: Header Compression for HTTP/2https://httpwg.github.io/specs/rfc7541.htmlInstance Variables:	accessMutex	&lt;Semaphore&gt;	controls access to encoder	dynamicTable	&lt;OrderedCollection&gt;  a table that associates stored header fields with index values. This table is dynamic and specific to an encoding or decoding context.	dynamicTableMaxSize	&lt;Integer&gt;	max size	dynamicTableSize	&lt;Integer&gt;	current size	firstHeaderBlock	&lt;Boolean&gt; a flag to detect the first header block and decode a change in the maximum size of the dynamic table. It is signaled via a dynamic table size update	neverIndexedFields	&lt;(OrderedCollection of: (String)&gt;  never indexed field names	source	&lt;Stream&gt;	read or write stream	useHuffmanEncoding	&lt;Boolean&gt;	an option to use Huffman encoding	dynamicTableAllowedSize &lt;Integer&gt; max dynamic table size	onDynamicTableUpdate &lt;BlockClosure&gt; a callback to acknowledge receiving s dynamic table update</body></comment><class><name>HPACKDecoder</name><environment>Protocols</environment><super>Protocols.HPACKCompessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.HPACKDecoder</class-id><body>HPACKDecoder decodes header fields from requests</body></comment><class><name>HTTP2Frame</name><environment>Protocols</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>length flags streamId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.HTTP2Frame</class-id><body>HTTP2Frame is HTTP2 frames superclass.Subclasses must implement the following messages:	delegation		processWith:	readPayloadFrom:	writePayloadOn:Instance Variables:	flags		&lt;Integer&gt;	 flags	length	&lt;Integer&gt;	length	streamId	&lt;Integer&gt;	streamIdShared Variables:	FrameClasses &lt;Dictionary&gt; key: HTTP2 frame type,  value: HTTP2 frame class</body></comment><class><name>PaddedFrames</name><environment>Protocols</environment><super>Protocols.HTTP2Frame</super><private>false</private><indexed-type>none</indexed-type><inst-vars>padding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.PaddedFrames</class-id><body>PaddedFrames is a superclass for frames with paddingSubclasses must implement the following messages:	writing		dataSizeInstance Variables:	padding	&lt;ByteArray&gt;	padding</body></comment><class><name>ContinuationFrame</name><environment>Protocols</environment><super>Protocols.PaddedFrames</super><private>false</private><indexed-type>none</indexed-type><inst-vars>headerBlockFragment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.ContinuationFrame</class-id><body>ContinuationFrame is used to continue a sequence of header block fragmentsInstance Variables:	headerBlockFragment	&lt;ByteArray&gt;	headerBlockFragment</body></comment><class><name>HeadersFrame</name><environment>Protocols</environment><super>Protocols.ContinuationFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars>priority </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.HeadersFrame</class-id><body>HeadersFrame is used to open a HTTP2Stream stream and additionally carries a header block fragment.Instance Variables:	priority &lt;PriorityFrame&gt;</body></comment><class><name>HTTP2Announcement</name><environment>Protocols</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>description type frame </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.HTTP2Announcement</class-id><body>HTTP2Announcement is superclass for HTTP2 annoucementsInstance Variables:	description	&lt;String&gt;	 description	type	&lt;Symbol&gt;	type: #C(client)  or #S(server)	frame &lt;HTTP2Frame&gt; frame </body></comment><class><name>HTTPRequestAnnouncement</name><environment>Protocols</environment><super>Protocols.HTTP2Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream request </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.HTTPRequestAnnouncement</class-id><body>HTTPRequestAnnouncement is used to annouce an HttpRequestInstance Variables:	request	&lt;HttpRequest&gt;	request to log	stream	&lt;HTTP2Stream&gt; stream that received the request</body></comment><class><name>HTTP2ErrorAnnouncement</name><environment>Protocols</environment><super>Protocols.HTTP2Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.HTTP2ErrorAnnouncement</class-id><body>HTTP2ErrorAnnouncement  is used to log error messages and their debug stacks</body></comment><class><name>HTTP2RecyclingCenter</name><environment>Protocols</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>recycled mutex logRecycled </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.HTTP2RecyclingCenter</class-id><body>HTTP2RecyclingCenter allows to recycle collection instances to lighten the load on the garbage collector. The recycling center sets cache of ByteArrays for input, output and frame buffersInstance Variables:	logRecycled &lt;(Dictionary of: (Dictionary)&gt; logRecycled collects statistics of reused buffers	mutex	&lt;Semaphore&gt;	controls access to recycled	recycled	&lt;Dictionary&gt; recycled cacheProtocols.HTTP2RecyclingCenter.CacheLimit := 10.Protocols.HTTP2RecyclingCenter default startLogging.Protocols.HTTP2RecyclingCenter default logPrint.Protocols.HTTP2RecyclingCenter default stopLogging.</body></comment><class><name>HTTP2Error</name><environment>Protocols</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.HTTP2Error</class-id><body>HTTP2Error is superclass HTTP2 spec errors</body></comment><class><name>HTTP2StreamError</name><environment>Protocols</environment><super>Protocols.HTTP2Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.HTTP2StreamError</class-id><body>HTTP2StreamError implements a stream error that is an error related to a specific stream that does not affect processing of other streams</body></comment><class><name>PriorityFrame</name><environment>Protocols</environment><super>Protocols.HTTP2Frame</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parentStreamId weight exclusiveDependend </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.PriorityFrame</class-id><body>The PRIORITY frame specifies the sender-advised priority of a stream. It can be sent in any stream state, including idle or closed streamsInstance Variables:	parentStreamId &lt;Integer&gt;	A 31-bit stream identifier for the stream that this stream depends on	weight	&lt;Integer&gt;	An unsigned 8-bit integer representing a priority weight for the stream. Add one to the value to obtain a weight between 1 and 256	exclusiveDependend &lt;1 or 0&gt;	A single-bit flag indicating that the stream dependency is exclusive</body></comment><class><name>HTTP2FrameReadStream</name><environment>Protocols</environment><super>Xtreams.ReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>endOfStream writeStream waitingLock stateLock bufferLock onReading onWriting </inst-vars><class-inst-vars></class-inst-vars><imports>			private Xtreams.*			</imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.HTTP2FrameReadStream</class-id><body>HTTP2DATAReadStream  is a read channel, which receives DATA frames in to its buffer from a HTTP2Stream.Instance Variables:	bufferLock	&lt;Semaphore&gt;	serializes read and write to a cache buffer	endOfStream	&lt;Boolean&gt; if true all DATA frames are received	onReading	&lt;Block&gt; callback records the read count (equivalent to increasing the local available limit)	onWriting	&lt;Block&gt; callback is used to record the written count (equivalent of decreasing the local available limit)	stateLock	&lt;Semaphore&gt;	a lock to prevent incoming frames from the HTTP2Stream disrupting the read operation of this stream	waitingLock	&lt;Semaphore&gt;	a lock we wait on when expecting DATA frames to be sent from the remote side	writeStream	&lt;WriteStream&gt;	cache buffer </body></comment><class><name>PingFrame</name><environment>Protocols</environment><super>Protocols.HTTP2Frame</super><private>false</private><indexed-type>none</indexed-type><inst-vars>data </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.PingFrame</class-id><body>Implements PING frame (type=0x6) which is a mechanism for measuring a minimal round-trip time from the sender, as well as determining whether an idle connection is still functional. PING frames can be sent from any endpoint.Instance Variables:	data	&lt;ByteArray&gt;	data 8 bytes onlyReceipt of a PING frame with a length field value other than 8 MUST be treated as a connection error (Section 5.4.1) of type FRAME_SIZE_ERROR.</body></comment><class><name>HTTP2HeadersWriteStream</name><environment>Protocols</environment><super>Protocols.HTTP2FrameWriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numberOfFrames frameBlock </inst-vars><class-inst-vars></class-inst-vars><imports>			private Xtreams.*			</imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.HTTP2HeadersWriteStream</class-id><body>HTTP2HeadersWriteStream implement writing Http message bodies as HEADERS framesInstance Variables:	headersOnly	&lt;Boolean&gt; if true the last HEADERS frame will set with end-of-stream flag	numberOfFrames	&lt;Integer&gt; number of frames. If the number is more than one the stream starts sending CONTINUATION frames	frameBlock &lt;BlockClosure&gt; the block argument is a HEADER/CONTINUATION frame ready to be sent</body></comment><class><name>DataFrame</name><environment>Protocols</environment><super>Protocols.PaddedFrames</super><private>false</private><indexed-type>none</indexed-type><inst-vars>data </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.DataFrame</class-id><body>DataFrame is used to transport HTTP message bodiesInstance Variables:	data		&lt;ByteArray&gt; data bytes</body></comment><class><name>SentFrameAnnouncement</name><environment>Protocols</environment><super>Protocols.HTTP2Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.SentFrameAnnouncement</class-id><body>SentFrameAnnouncement is used to announce a sent frame</body></comment><class><name>HTTP2ConnectionError</name><environment>Protocols</environment><super>Protocols.HTTP2Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.HTTP2ConnectionError</class-id><body>HTTP2ConnectionError implements a connection error that is any error that prevents further processing of the frame layer or corrupts any connection state. https://httpwg.github.io/specs/rfc7540.html#ErrorHandlerEndpoints SHOULD send a GOAWAY frame when ending a connection, providing that circumstances permit it</body></comment><class><name>HTTP2Settings</name><environment>Protocols</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>settingsFrame outputWindowSize ackTimeout reservedStreams </inst-vars><class-inst-vars>settingsFrame outputWindowSize reservedStreams </class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.HTTP2Settings</class-id><body>HTTP2Settings represent local Http2 settingsInstance Variables:	outputWindowSize &lt;Integer&gt; the number defines a buffer size for sending messages: post messages on a client and responses on a server	settingsFrame	&lt;SettingsFrame&gt; HTTP2 spec SETTINGS frame	ackTimeout	&lt;Duration&gt; after this amount of time the timer raises connection error If the sender of a SETTINGS frame does not receive an acknowledgment. If the duration is not specified (nil) a multiplexer doesn't set a timer 	reservedStreams &lt;Integer&gt; allowed amount of Push_Promise streams in #reserved state a server can send. The client option onlyClass Instance Variables:	outputWindowSize &lt;Integer&gt; the default value for output buffer size	settingsFrame &lt;SettingsFrame&gt; the default HTTP2 settings frame	ackTimeout&lt;Duration&gt; default timeout 	reservedStreams &lt;Integer&gt;  default allowed amount of Push_Promise streams in #reserved state</body></comment><class><name>SettingsFrame</name><environment>Protocols</environment><super>Protocols.HTTP2Frame</super><private>false</private><indexed-type>none</indexed-type><inst-vars>values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.SettingsFrame</class-id><body>SettingsFrame is used to communicate configuration parameters for the connection.Instance Variables:	currentWindowSize	&lt;Integer&gt; description of currentWindowSize	values	&lt;Array&gt; setting options</body></comment><class><name>HTTP2Stream</name><environment>Protocols</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>multiplexer headers id inputDataStream state endOfHeaders dispatchProcess flowControlWindow inputHeadersStream trailerHeader trailerHeaders contentLength inputDataSize outputDataStream httpMessage dataBytesSent method scheme authority path </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.HTTP2Stream</class-id><body>HTTP2Stream implements a bidirectional flow of bytes within an established connection, which may carry one or more messages.Subclasses must implement the following messages:	private read		dispatchMessage		headersDone	read input		receivedEOS		sentEOS	write output		createOutputDataStream		readyToSendDATA		headerFramesDo:		writeFrames		onOutputDataStreamCloseInstance Variables:	multiplexer	&lt;HTTP2Multiplexer&gt;	headers	&lt;(OrderedCollection of: (Array)&gt; an array has two decoded items: header field name and value	id 	&lt;Integer&gt; the stream id	inputDataStream &lt;HTTP2FrameReadStream&gt; reads input DATA frames	state	&lt;ByteSymbol&gt;	 defines the stream state					https://httpwg.github.io/specs/rfc7540.html#StreamStates					endOfHeaders &lt;Boolean&gt; indicates if the stream received end-of-header flag	dispatchProcess	&lt;Process&gt;	dispatches Http messages. The messages are dispatched after receiving a lst HEADERS frame	flowControlWindow  &lt;HTTP2FlowControlWindow&gt; stream flow control	inputHeadersStream &lt;HTTP2FrameReadStream&gt;  reads input HEADERS frames	trailerHeader &lt;ByteArray&gt; encoded trailer bytes	trailerHeaders &lt;OrderedCollection&gt; the collection contains decoded trailer headers. The trailes can be decoded executing #decodeTrailer	contentLength &lt;Integer&gt; if present the Content-Length fileld value	inputDataSize &lt;Integer&gt; total amount of received DATA frame bytes 	outputDataStream &lt;HTTP2DATAWriteStream&gt; the stream writes Http message bodies as DATA frames	httpMessage &lt;HttpRequest|HttpResponse&gt; message to send	dataBytesSent &lt;Integer&gt; the number of DATA bytes sent	authority	&lt;ByteArray&gt;	:authority pseudo-header	method	&lt;String&gt;	HTTP :method pseudo-header	path	&lt;String&gt;	url :path pseudo-header	scheme	&lt;String&gt;	http/https  :scheme pseudo-headerShared Instance Variables:	requestPseudoHeaders &lt;Collection of String&gt; #( ':method' ':scheme' ':authority' ':path')	responsePseudoHeaders &lt;Collection of String&gt; #( ':status' )</body></comment><class><name>DebugAnnouncement</name><environment>Protocols</environment><super>Protocols.HTTP2Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.DebugAnnouncement</class-id><body>DebugAnnouncement is used to log debug info</body></comment><class><name>RstStreamFrame</name><environment>Protocols</environment><super>Protocols.HTTP2Frame</super><private>false</private><indexed-type>none</indexed-type><inst-vars>errorCode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.RstStreamFrame</class-id><body>RstStreamFrame is used to signal termination of a stream and errors.Instance Variables:	errorCode	&lt;Integer&gt;	error code</body></comment><class><name>HPACKEncoder</name><environment>Protocols</environment><super>Protocols.HPACKCompessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tableSizeUpdate </inst-vars><class-inst-vars>neverIndexedFields </class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.HPACKEncoder</class-id><body>HPACKEncoder encodes header fieldsInstance Variables:	tableSizeUpdate	&lt;Boolean&gt; the flag indicating if the the dynamic table update should be added to encodingClass Instance Variables:	neverIndexedFields &lt;OrderedCollection of String&gt; a collection of field names that will be appended  to the decoded header list without altering the dynamic table</body></comment><class><name>HTTPResponseAnnouncement</name><environment>Protocols</environment><super>Protocols.HTTP2Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.HTTPResponseAnnouncement</class-id><body>HTTPResponseAnnouncement is used to announce an HttpResponse.Instance Variables:	stream	&lt;HTTP2Stream&gt; stream that sends the response</body></comment><class><name>PushPromiseFrame</name><environment>Protocols</environment><super>Protocols.ContinuationFrame</super><private>false</private><indexed-type>none</indexed-type><inst-vars>promisedStreamId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.PushPromiseFrame</class-id><body>PushPromiseFrame is used to signal a promise to serve the referenced resource.Instance Variables:	padLength	&lt;Integer&gt;  padLength	promisedStreamId	&lt;Integer&gt;  promisedStreamId</body></comment><class><name>HTTPv20</name><environment>Protocols</environment><super>Protocols.ProtocolVersion</super><private>false</private><indexed-type>none</indexed-type><inst-vars>multiplexer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.HTTPv20</class-id><body>HTTPv20 upgrades HTTP request to HTTP2 version and creates HTTP2 multiplexer to process messages.Instance Variables:	logging	&lt;Boolean&gt;	 logging	multiplexer	&lt;HTTP2Multiplexer&gt;	 multiplexer	settings	&lt;SettingsFrame&gt;	HtTTP2 settings</body></comment><class><name>HTTP2FlowControlWindow</name><environment>Protocols</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>remoteAvailable stream localAvailable connectionWindow mutex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.HTTP2FlowControlWindow</class-id><body>HTTP2FlowControlWindow represents values received by WindowUpdateFrame. It maintains the current available size and maxSize.https://tools.ietf.org/html/rfc7540#section-6.9Instance Variables:	remoteAvailable &lt;Integer&gt; 	stream 	&lt;HTTP2Stream&gt;			localAvailable &lt;Integer&gt;	connectionWindow &lt;HTTP2FlowControlWindows&gt;	mutex &lt;Semaphore&gt;Clas Instance Variables:</body></comment><class><name>HTTP2DATAWriteStream</name><environment>Protocols</environment><super>Protocols.HTTP2FrameWriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>writingLock </inst-vars><class-inst-vars></class-inst-vars><imports>			private Xtreams.*			</imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.HTTP2DATAWriteStream</class-id><body>HTTP2DATAWriteStream implement writing Http message bodies as DATA framesInstance Variables:	writingLock &lt;Semaphore&gt; signals that the cache buffer can accept bytes or waits if the buffer is full</body></comment><class><name>WindowUpdateFrame</name><environment>Protocols</environment><super>Protocols.HTTP2Frame</super><private>false</private><indexed-type>none</indexed-type><inst-vars>windowSizeIncrement </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.WindowUpdateFrame</class-id><body>The WINDOW_UPDATE frame (type=0x8) is used to implement flow control. Receivers advertise how many octets they are prepared to receive on a stream and for the entire connection. This is a credit-based scheme.Instance Variables:	windowSizeIncrement	&lt;Number&gt;	 windowSizeIncrement</body></comment><class><name>HTTP2Multiplexer</name><environment>Protocols</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>streams streamId state hpackEncoder hpackDecoder remoteSettings protocolVersion flowControlWindow updatedSettings accessMutex lastStream activeStreams ackTimeout recyclingCenter </inst-vars><class-inst-vars>announcementPrinter </class-inst-vars><imports>			private Protocols.*			private Xtreams.*			</imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.HTTP2Multiplexer</class-id><body>Implements HTTP2 streaming and multiplexing.https://http2.github.io/http://chimera.labs.oreilly.com/books/1230000000545/ch12.htmlInstance Variables:	log	&lt;AnnouncementLogger&gt;  log	remoteSettings	&lt;SettingsFrame&gt;	remote settings	state	&lt;ByteSymbol&gt;	 state	streams	&lt;(SharedRegistry of: (HTTP2Stream))&gt;	description of streams	lastStream &lt;HTTP2Stream&gt;  last registered actve stream	hpackEncoder &lt;HPACKCompressor&gt;	hpackDecoder &lt;HPACKCompressor&gt;	streamId &lt;Integer&gt; last created stream index	protocolVersion &lt;HTTPv20&gt;	outputMutex &lt;Semaphore&gt; serializes access to writeStream	flowControlWindow &lt;HTTP2FlowControlWindow&gt; the connection flow control	updatedSettings &lt;SettingsFrame&gt; changed but not applied settings. The changes are applied after another party acknowledges receipt 	accessMutex &lt;Semaphore&gt; serializes access to Settings update	activeStreams &lt;Integer&gt; a number of active concurrent streams	ackTimeout &lt;Integer&gt; milliseconds to raise ACK timeout if ACK was not received	recyclingCenter &lt;HTTP2RecyclingCenter&gt;Class Instance Variables:	announcementPrinter &lt;AnnouncementPrinter&gt;  log printer. By default the printer uses Transcript. </body></comment><class><name>GoawayFrame</name><environment>Protocols</environment><super>Protocols.HTTP2Frame</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lastStreamID errorCode debugData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.GoawayFrame</class-id><body>Implements GoawayFrame (type=0x7) that is used to initiate shutdown of a connection or to signal serious error conditionsInstance Variables:	debugData	&lt;ByteArray&gt;	debug data	errorCode	&lt;Integer&gt;	errorCode	lastStreamID	&lt;Integer&gt;	lastStreamID</body></comment><class><name>ReceivedFrameAnnouncement</name><environment>Protocols</environment><super>Protocols.HTTP2Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http2</package></attributes></class><comment><class-id>Protocols.ReceivedFrameAnnouncement</class-id><body>ReceivedFrameAnnouncement is used to announce a received frame</body></comment><shared-variable><name>ShouldPrintProcessName</name><environment>Protocols.HTTP2Announcement</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>Protocols-Http2</package></attributes></shared-variable><shared-variable><name>ErrorCodes</name><environment>Protocols.HTTP2Multiplexer</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>nil</initializer><attributes><package>Protocols-Http2</package></attributes></shared-variable><shared-variable><name>ClientPreface</name><environment>Protocols.HTTP2Multiplexer</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>nil</initializer><attributes><package>Protocols-Http2</package></attributes></shared-variable><shared-variable><name>PADDED</name><environment>Protocols.PaddedFrames</environment><private>false</private><constant>false</constant><category>flags</category><initializer>8</initializer><attributes><package>Protocols-Http2</package></attributes></shared-variable><shared-variable><name>END_STREAM</name><environment>Protocols.PaddedFrames</environment><private>false</private><constant>false</constant><category>flags</category><initializer>1</initializer><attributes><package>Protocols-Http2</package></attributes></shared-variable><shared-variable><name>VerboseDebugPrint</name><environment>Protocols.HTTP2Frame</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>Protocols-Http2</package></attributes></shared-variable><shared-variable><name>FrameClasses</name><environment>Protocols.HTTP2Frame</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>Protocols-Http2</package></attributes></shared-variable><shared-variable><name>END_HEADERS</name><environment>Protocols.ContinuationFrame</environment><private>false</private><constant>false</constant><category>flags</category><initializer>4</initializer><attributes><package>Protocols-Http2</package></attributes></shared-variable><shared-variable><name>Default</name><environment>Protocols.HTTP2RecyclingCenter</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>Protocols-Http2</package></attributes></shared-variable><shared-variable><name>CacheLimit</name><environment>Protocols.HTTP2RecyclingCenter</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>Protocols-Http2</package></attributes></shared-variable><shared-variable><name>DefaultWeight</name><environment>Protocols.PriorityFrame</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>16</initializer><attributes><package>Protocols-Http2</package></attributes></shared-variable><shared-variable><name>ResponseDigestSize</name><environment>Protocols.HTTPResponseAnnouncement</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>200</initializer><attributes><package>Protocols-Http2</package></attributes></shared-variable><shared-variable><name>RequestPseudoHeaders</name><environment>Protocols.HTTP2Stream</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>Protocols-Http2</package></attributes></shared-variable><shared-variable><name>ResponsePseudoHeaders</name><environment>Protocols.HTTP2Stream</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>Protocols-Http2</package></attributes></shared-variable><shared-variable><name>StaticEncodingTable</name><environment>Protocols.HPACKCompessor</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>nil</initializer><attributes><package>Protocols-Http2</package></attributes></shared-variable><shared-variable><name>HuffmanEncodingTable</name><environment>Protocols.HPACKCompessor</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>nil</initializer><attributes><package>Protocols-Http2</package></attributes></shared-variable><shared-variable><name>StaticDecodingTable</name><environment>Protocols.HPACKCompessor</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>nil</initializer><attributes><package>Protocols-Http2</package></attributes></shared-variable><shared-variable><name>HuffmanDecodingTable</name><environment>Protocols.HPACKCompessor</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>nil</initializer><attributes><package>Protocols-Http2</package></attributes></shared-variable><shared-variable><name>UseHuffmanCoding</name><environment>Protocols.HPACKEncoder</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>nil</initializer><attributes><package>Protocols-Http2</package></attributes></shared-variable><shared-variable><name>PRIORITY</name><environment>Protocols.HeadersFrame</environment><private>false</private><constant>false</constant><category>flags</category><initializer>32</initializer><attributes><package>Protocols-Http2</package></attributes></shared-variable><shared-variable><name>RequestDigestSize</name><environment>Protocols.HTTPRequestAnnouncement</environment><private>false</private><constant>false</constant><category>defaults</category><initializer>200</initializer><attributes><package>Protocols-Http2</package></attributes></shared-variable><methods><class-id>Protocols.HTTP2FrameWriteStream</class-id> <category>initialize-release</category><body package="Protocols-Http2">close	self setEndOfStream.</body><body package="Protocols-Http2">flush</body><body package="Protocols-Http2">newDestinationBuffer	^self subclassResponsibility</body><body package="Protocols-Http2">on: anHTTP2Stream	http2Stream := anHTTP2Stream.	endOfStream := false.	destination := self newDestinationBuffer.</body><body package="Protocols-Http2">recycle	| saved |	destination ifNotNil: [		saved := destination cache.		destination := nil.		saved ifNotNil: [http2Stream multiplexer recycle: saved].		saved := nil]</body></methods><methods><class-id>Protocols.HTTP2FrameWriteStream</class-id> <category>printing</category><body package="Protocols-Http2">streamingPrintOn: aStream	super streamingPrintOn: aStream.	aStream		write: ' buffer size: ';		print: destination writeSize.</body></methods><methods><class-id>Protocols.HTTP2FrameWriteStream</class-id> <category>testing</category><body package="Protocols-Http2">hasDataToSend	^ destination notNil and: [ destination hasDataToRead ]</body><body package="Protocols-Http2">hasFrameToWrite	^ destination readSize &gt;= self maxFrameSize		or: [ destination cacheSize &lt; self maxFrameSize 			and: [ destination writeSize isZero ]]</body><body package="Protocols-Http2">hasSpaceToWrite	^ destination hasSpaceToWrite</body></methods><methods><class-id>Protocols.HTTP2FrameWriteStream</class-id> <category>services</category><body package="Protocols-Http2">checkDestinationSize	^self subclassResponsibility</body><body package="Protocols-Http2">readyToSendFrame	^self subclassResponsibility</body></methods><methods><class-id>Protocols.HTTP2FrameWriteStream</class-id> <category>accessing</category><body package="Protocols-Http2">maxFrameSize	^http2Stream remoteMaxFrameSize</body><body package="Protocols-Http2">put: anObject	self checkDestinationSize.	destination put: anObject.	^1</body><body package="Protocols-Http2">setEndOfStream	endOfStream := true.</body><body package="Protocols-Http2">write: anInteger from: aSequenceableCollection at: startIndex	| count amount  |	count := 0.	[		[self checkDestinationSize.					amount := destination write: (destination writeSize min: (anInteger - count)) from: aSequenceableCollection at: startIndex + count.		count := count + amount.		count &lt; anInteger] whileTrue		] 	on: Incomplete 		do: [:exception | (Incomplete on: aSequenceableCollection count: count + exception count at: startIndex) raise].	^anInteger</body></methods><methods><class-id>Protocols.HTTP2FrameWriteStream class</class-id> <category>instance creation</category><body package="Protocols-Http2">on: anHTTP2Stream	^self new		on: anHTTP2Stream;		yourself</body></methods><methods><class-id>Protocols.HPACKCompessor</class-id> <category>initialize-release</category><body package="Protocols-Http2">do: aBlock	^ accessMutex critical: [		aBlock value.]</body><body package="Protocols-Http2">dynamicTableAllowedSize	^dynamicTableAllowedSize</body><body package="Protocols-Http2">dynamicTableAllowedSize: aNumber"Protocols that use HPACK determine the maximum size that the encoder is permitted to use for the dynamic table. In HTTP/2, this value is determined by the SETTINGS_HEADER_TABLE_SIZE setting."	aNumber ifNil: [self halt].	dynamicTableAllowedSize := aNumber.</body><body package="Protocols-Http2">initialize	dynamicTable := OrderedCollection new.	dynamicTableAllowedSize := SettingsFrame SETTINGS_HEADER_TABLE_SIZE.	dynamicTableSize := 0.	accessMutex := Semaphore forMutualExclusion.	firstHeaderBlock := true</body><body package="Protocols-Http2">on: aStream	firstHeaderBlock := true</body></methods><methods><class-id>Protocols.HPACKCompessor</class-id> <category>accessing</category><body package="Protocols-Http2">dynamicTable	^dynamicTable</body><body package="Protocols-Http2">dynamicTableAdd: anArray"Before a new entry is added to the dynamic table, entries are evicted from the end of the dynamic table until the size of the dynamic table is less than or equal to (maximum size - new entry size) or until the table is empty"	| entrySize |	"The size of an entry is the sum of its name's length in octets (as defined in Section 5.2), its value's length in octets, and 32."	entrySize := 32.	anArray do: [ :str | entrySize := entrySize + str size].		entrySize &gt; dynamicTableAllowedSize ifTrue: [		" It is not an error to attempt to add an entry that is larger than the maximum size; an attempt to add an entry larger than the maximum size causes the table to be emptied of all existing entries and results in an empty table"		dynamicTableSize := 0.		^dynamicTable := OrderedCollection new	].		"The dynamic table consists of a list of header fields maintained in first-in, first-out order. The first and newest entry in a dynamic table is at the lowest index, and the oldest entry of a dynamic table is at the highest index"	self dynamicTable addFirst: anArray.	dynamicTableSize := dynamicTableSize + entrySize.	"Eject old entries if the dynamic table is too big"	self evictDynamicTableEntries.</body><body package="Protocols-Http2">dynamicTableSize	^dynamicTableSize</body><body package="Protocols-Http2">dynamicTableSize: aNumber	^dynamicTableSize := aNumber</body><body package="Protocols-Http2">evictDynamicTableEntries"4.3 Entry Eviction When Dynamic Table Size ChangesWhenever the maximum size for the dynamic table is reduced, entries are evicted from the end of the dynamic table until the size of the dynamic table is less than or equal to the maximum size.""This mechanism can be used to completely clear entries from the dynamic table by setting a maximum size of 0, which can subsequently be restored."	dynamicTableSize = 0		ifTrue: [ ^dynamicTable := OrderedCollection new ].			[ dynamicTableSize &gt; dynamicTableAllowedSize ]		whileTrue: [			self dynamicTable removeLast do: [ :str | dynamicTableSize := dynamicTableSize - str size ].			"The additional 32 octets account for an estimated overhead associated with an entry. "			dynamicTableSize := dynamicTableSize - 32 ].</body><body package="Protocols-Http2">staticDecodingTable	^self class staticDecodingTable</body><body package="Protocols-Http2">staticEncodingTable	^self class staticEncodingTable</body></methods><methods><class-id>Protocols.HPACKCompessor class</class-id> <category>class initialization</category><body package="Protocols-Http2">initialize	self initializeStaticDecodingTable.	self initializeStaticEncodingTable.	self initializeHuffmanDecodingTable.	self initializeHuffmanEncodingTable</body><body package="Protocols-Http2">initializeHuffmanDecodingTable"(self initializeHuffmanDecodingTable)"	| data index encodedVal size coll |	HuffmanDecodingTable := Array new: 30.	data := self huffmanTableData reading. 	[ data atEnd]		whileFalse: [ 			data get. "Skip character"			index := data get.			encodedVal := data get.			size := data get.			coll := OrderedCollection new: size.			1 to: size do: [ :ind | coll add: (encodedVal bitAt: size - ind + 1) ].			(HuffmanDecodingTable at: size ) 				ifNil: [HuffmanDecodingTable at: size put: (OrderedCollection with: coll -&gt; index)]				ifNotNil: [:c | c add: coll -&gt; index ]							]</body><body package="Protocols-Http2">initializeHuffmanEncodingTable"(self initializeHuffmanEncodingTable)"	| data index encodedVal size coll |	HuffmanEncodingTable := Array new: 257.	data := self huffmanTableData reading. 	[ data atEnd]		whileFalse: [ 			data get. "Skip character"			index := data get.			encodedVal := data get.			size := data get.			coll := OrderedCollection new: size.			1 to: size do: [ :ind | coll add: (encodedVal bitAt: size - ind + 1) ].			HuffmanEncodingTable at: index + 1 put: coll ]</body><body package="Protocols-Http2">initializeStaticDecodingTable"(self initializeStaticDecodingTable)"	| data |	StaticDecodingTable := Array new: 61.	data := self staticTableData reading. 	[ data atEnd]		whileFalse: [ StaticDecodingTable at: data get put: data get ]</body><body package="Protocols-Http2">initializeStaticEncodingTable"(self initializeStaticEncodingTable)"	| data ind val key arrStr |	StaticEncodingTable := Dictionary new.	data := self staticTableData reading. 	[ data atEnd ]		whileFalse: [ 			ind := data get.			arrStr := data get.			arrStr isString					ifTrue: [ key := arrStr.							val := ind -&gt; nil ]					ifFalse: [ key := arrStr first.							val := ind -&gt; arrStr last asByteArray].							(StaticEncodingTable 					at: key 					ifAbsentPut: [OrderedCollection new]) add: val ]</body></methods><methods><class-id>Protocols.HPACKCompessor class</class-id> <category>spec data</category><body package="Protocols-Http2">huffmanTableData" symbol___code as bits___ length"^#(  '' 0    02r1111111111000 						13'' 1   02r11111111111111111011000				23 '' 2    02r1111111111111111111111100010 		28'' 3    02r1111111111111111111111100011		28'' 4    02r1111111111111111111111100100		28'' 5    02r1111111111111111111111100101		28'' 6    02r1111111111111111111111100110		28'' 7    02r1111111111111111111111100111		28'' 8    02r1111111111111111111111101000		28'' 9    02r111111111111111111101010			24'' 10  02r111111111111111111111111111100		30'' 11  02r1111111111111111111111101001		28'' 12  02r1111111111111111111111101010		28'' 13  02r111111111111111111111111111101		30'' 14  02r1111111111111111111111101011		28'' 15  02r1111111111111111111111101100		28'' 16  02r1111111111111111111111101101		28'' 17  02r1111111111111111111111101110		28'' 18  02r1111111111111111111111101111		28'' 19  02r1111111111111111111111110000		28'' 20  02r1111111111111111111111110001		28'' 21  02r1111111111111111111111110010		28'' 22  02r111111111111111111111111111110		30'' 23  02r1111111111111111111111110011		28'' 24  02r1111111111111111111111110100		28'' 25  02r1111111111111111111111110101		28'' 26  02r1111111111111111111111110110		28'' 27  02r1111111111111111111111110111		28'' 28  02r1111111111111111111111111000		28'' 29  02r1111111111111111111111111001		28'' 30  02r1111111111111111111111111010		28'' 31  02r1111111111111111111111111011		28' ' 32  02r010100								 6'!' 33  02r1111111000							10'"' 34  02r1111111001							10'#' 35  02r111111111010 						12'$' 36  02r1111111111001						13'%' 37  02r010101								6'&amp;'  38  02r11111000							8''''  39 02r11111111010						11'('  40  02r1111111010							10')'  41  02r1111111011							10'*'  42  02r11111001								8'+'  43  02r11111111011							11','  44  02r11111010								8'-'  45  02r010110									6'.'  46  02r010111									6'/'  47  02r011000									6'0'  48 02r00000									5'1'  49  02r00001									5'2'  50  02r00010									5'3'  51  02r011001									6'4'  52  02r011010									6'5'  53  02r011011									6'6'  54  02r011100									6'7'  55  02r011101									6'8'  56  02r011110									6'9'  57  02r011111									6':'  58  02r1011100								7';'  59  02r11111011								8'&lt;'  60 02r111111111111100						15'='  61  02r100000								6'&gt;'  62  02r111111111011							12'?'  63  02r1111111100								10'@'  64  02r1111111111010 						13'A'  65  02r100001								6'B'  66  02r1011101 								7'C'  67  02r1011110								7'D'  68  02r1011111 								7'E'  69  02r1100000 								7'F'  70  02r1100001								7'G'  71  02r1100010 								7'H'  72  02r1100011								7'I'  73  02r1100100								7'J'  74  02r1100101 								7'K'  75  02r1100110								7'L'  76  02r1100111 								7'M'  77  02r1101000								7'N'  78  02r1101001								7'O'  79  02r1101010								7'P'  80  02r1101011								7'Q'  81  02r1101100								7'R'  82  02r1101101								7'S'  83  02r1101110								7'T'  84  02r1101111								7'U'  85  02r1110000								7'V'  86  02r1110001								7'W'  87  02r1110010								7'X'  88  02r11111100								8'Y'  89  02r1110011								7'Z'  90  02r11111101								8'['  91  02r1111111111011							13'\'  92  02r1111111111111110000					19']'  93  02r1111111111100							13'^'  94  02r11111111111100						14'_'  95  02r100010									6'`'  96  02r111111111111101						15'a'  97  02r00011									5'b'  98  02r100011									6'c'  99  02r00100									5'd'  100   02r100100								6'e'  101  02r00101									5'f'  102  02r100101								6'g'  103  02r100110 								6'h'  104  02r100111								6'i'  105  02r00110									5'j'  106  02r1110100								7'k'  107  02r1110101								7'l'  108  02r101000								6'm'  109    02r101001								6'n'  110    02r101010								6'o'  111    02r00111								5'p'  112    02r101011								6'q'  113    02r1110110								7'r'  114    02r101100								6's'  115    02r01000								5't'  116    02r01001								5'u'  117    02r101101								6'v'  118    02r1110111								7'w'  119    02r1111000								7'x'  120    02r1111001								7'y'  121    02r1111010								7'z'  122    02r1111011								7'{'  123   02r111111111111110						15' '  124    02r11111111100							11'}'  125    02r11111111111101						14'~'  126    02r1111111111101						13''     127    02r1111111111111111111111111100		28''     128    02r11111111111111100110				20 ''     129    02r1111111111111111010010           	      22 ''     130   02r11111111111111100111				20 ''     131    02r11111111111111101000           		       20 ''     132    02r1111111111111111010011				22 ''     133   02r1111111111111111010100				22 ''     134    02r1111111111111111010101				22 ''     135    02r11111111111111111011001 			23 ''     136    02r1111111111111111010110 				22 ''     137   02r11111111111111111011010				23 ''     138    02r11111111111111111011011			23 ''     139    02r11111111111111111011100			23 ''     140    02r11111111111111111011101			23 ''     141   02r11111111111111111011110				23 ''     142    02r111111111111111111101011 			24 ''     143    02r11111111111111111011111			23 ''     144   02r111111111111111111101100			24 ''     145    02r111111111111111111101101			24 ''     146    02r1111111111111111010111                 22 ''     147    02r11111111111111111100000               23 ''     148    02r111111111111111111101110              24 ''     149    02r11111111111111111100001                23 ''     150    02r11111111111111111100010                23 ''    151    02r11111111111111111100011                23 ''    152    02r11111111111111111100100                23 ''     153    02r111111111111111011100                  21 ''     154    02r1111111111111111011000                 22 ''     155    02r11111111111111111100101               23 ''     156    02r1111111111111111011001                 22 ''     157    02r11111111111111111100110                23 ''     158    02r11111111111111111100111                23 ''     159    02r111111111111111111101111              24 ''     160    02r1111111111111111011010                22 ''     161    02r111111111111111011101                  21 ''     162    02r11111111111111101001                    20 ''     163    02r1111111111111111011011                 22 ''     164    02r1111111111111111011100                22 ''     165    02r11111111111111111101000               23 ''    166    02r11111111111111111101001                23 ''     167    02r111111111111111011110                  21 ''     168    02r11111111111111111101010                23 ''     169    02r1111111111111111011101                22 ''     170    02r1111111111111111011110                 22 ''     171    02r111111111111111111110000               24 ''     172    02r111111111111111011111                  21 ''     173    02r1111111111111111011111                 22 ''     174    02r11111111111111111101011                23 ''     175    02r11111111111111111101100                23 ''     176    02r111111111111111100000                  21 ''     177    02r111111111111111100001                  21 ''     178    02r1111111111111111100000                 22 ''     179    02r111111111111111100010                  21 ''     180    02r11111111111111111101101                23 ''     181    02r1111111111111111100001                 22 ''     182    02r11111111111111111101110               23 ''     183    02r11111111111111111101111                23 ''     184    02r11111111111111101010                    20 ''    185    02r1111111111111111100010                 22 ''     186    02r1111111111111111100011                 22 ''     187    02r1111111111111111100100                22 ''     188    02r11111111111111111110000                23 ''     189    02r1111111111111111100101                22 ''     190    02r1111111111111111100110                 22 ''     191    02r11111111111111111110001                23 ''     192    02r11111111111111111111100000          26 ''     193    02r11111111111111111111100001          26 ''     194    02r11111111111111101011                    20 ''     195    02r1111111111111110001                     19 ''     196    02r1111111111111111100111                 22 ''     197    02r11111111111111111110010                23 ''     198    02r1111111111111111101000                 22 ''     199    02r1111111111111111111101100           25 ''     200    02r11111111111111111111100010          26 ''     201    02r11111111111111111111100011           26 ''     202    02r11111111111111111111100100           26 ''     203    02r111111111111111111111011110		27 ''     204    02r111111111111111111111011111		27 ''    205    02r11111111111111111111100101			26 ''     206    02r111111111111111111110001			24 ''     207    02r1111111111111111111101101			25 ''     208    02r1111111111111110010				19 ''     209    02r111111111111111100011				21 ''     210    02r11111111111111111111100110			26 ''     211    02r111111111111111111111100000		27 ''     212    02r111111111111111111111100001		27 ''     213    02r11111111111111111111100111			26 ''     214    02r111111111111111111111100010		27 ''     215    02r111111111111111111110010			24 ''     216    02r111111111111111100100				21 ''     217    02r111111111111111100101				21 ''     218    02r11111111111111111111101000			26 ''     219    02r11111111111111111111101001			26 ''     220    02r1111111111111111111111111101		28 ''     221    02r111111111111111111111100011		27 ''     222    02r111111111111111111111100100		27 ''     223    02r111111111111111111111100101		27 ''     224    02r11111111111111101100				20 ''     225    02r111111111111111111110011			24 ''    226    02r11111111111111101101				20 ''    227    02r111111111111111100110				21 ''     228    02r1111111111111111101001				22 ''     229    02r111111111111111100111				21 ''     230    02r111111111111111101000				21 ''     231    02r11111111111111111110011			23 ''     232    02r1111111111111111101010				22 ''     233    02r1111111111111111101011				22 ''     234    02r1111111111111111111101110			25  ''    235    02r1111111111111111111101111			25 ''     236    02r111111111111111111110100			24 ''     237    02r111111111111111111110101			24 ''     238    02r11111111111111111111101010			26  ''    239    02r11111111111111111110100			23 ''     240    02r11111111111111111111101011			26 ''     241    02r111111111111111111111100110		27 ''     242    02r11111111111111111111101100			26 ''     243    02r11111111111111111111101101			26 ''     244    02r111111111111111111111100111		27 ''     245    02r111111111111111111111101000		27 ''     246    02r111111111111111111111101001		27 ''     247    02r111111111111111111111101010		27 ''     248    02r111111111111111111111101011		27 ''     249    02r1111111111111111111111111110		28 ''     250    02r111111111111111111111101100		27 ''     251    02r111111111111111111111101101		27 ''     252    02r111111111111111111111101110		27 ''     253    02r111111111111111111111101111		27 ''     254    02r111111111111111111111110000		27 ''    255    02r11111111111111111111101110 			26 ''    256    02r111111111111111111111111111111		30)</body><body package="Protocols-Http2">staticTableData^#(1 ':authority'	2	#(':method'	'GET')3	#(':method'	'POST')4	#(':path'	'/')5	#(':path' '/index.html')6	#(':scheme' 'http')7	#(':scheme' 'https')8	#(':status' '200')9	#(':status' '204')10	#(':status' '206')11	#(':status' '304')12	#(':status' '400')13	#(':status' '404')14	#(':status' '500')15	'accept-charset'	16	#('accept-encoding' 'gzip, deflate')17	'accept-language'	18 'accept-ranges'	19 'accept'	20 'access-control-allow-origin'	21	'age'	22	'allow'	23	'authorization'	24	'cache-control'	25	'content-disposition'	26	'content-encoding'	27	'content-language'	28	'content-length'	29	'content-location'	30	'content-range'	31	'content-type'	32	'cookie'	33	'date'	34	'etag'	35	'expect'	36 'expires'	37	'from'	38	'host'	39	'if-match'	40	'if-modified-since'	41	'if-none-match'	42	'if-range'	43	'if-unmodified-since'	44	'last-modified'	45	'link'	46	'location'	47	'max-forwards'	48	'proxy-authenticate'	49	'proxy-authorization'	50	'range'	51	'referer'	52	'refresh'	53	'retry-after'	54	'server'	55	'set-cookie'	56	'strict-transport-security'	57	'transfer-encoding'	58	'user-agent'	59	'vary'	60	'via'	61	'www-authenticate')</body></methods><methods><class-id>Protocols.HPACKCompessor class</class-id> <category>accessing</category><body package="Protocols-Http2">huffmanDecodingTable	^HuffmanDecodingTable</body><body package="Protocols-Http2">huffmanEncodingTable	^HuffmanEncodingTable</body><body package="Protocols-Http2">staticDecodingTable	^StaticDecodingTable</body><body package="Protocols-Http2">staticEncodingTable	^StaticEncodingTable</body></methods><methods><class-id>Protocols.HPACKCompessor class</class-id> <category>instance creation</category><body package="Protocols-Http2">dynamicTableAllowedSize: aNumber	^self new		dynamicTableAllowedSize: aNumber;		yourself</body><body package="Protocols-Http2">new	^self basicNew initialize</body></methods><methods><class-id>Protocols.HPACKDecoder</class-id> <category>private read</category><body package="Protocols-Http2">readLength: anInteger prefixSize: bitNumber from: aStream	| number |	number := anInteger.	1 to: bitNumber do: [:ind | number := number bitAt: 8 - ind + 1 put: 0].	^number &lt; ((2 raisedTo: 8 - bitNumber) - 1)		ifTrue: [number]		ifFalse: [self readLengthFor: number from: aStream]</body><body package="Protocols-Http2">readLengthFor: anInteger from: aStream	| length byte i |	i := 0.	length := anInteger.		[byte := aStream get.	length := length + ((byte bitAnd: 127) * (2 raisedTo: i)).	i := i + 7.	(byte bitAt: 8) = 1]			whileTrue.	^length</body><body package="Protocols-Http2">readLiteralField: aNumber bitPattern: bitNumber from: aStream	| fieldName header number |	number := aNumber.	1 to: bitNumber do: [:ind | number := number bitAt: 8 - ind + 1 put: 0].	fieldName := number = 0				ifTrue: 					[" Literal Header Field â New Name"					self readLiteralFrom: aStream]				ifFalse: 					[" Literal Header Field with Incremental Indexing â Indexed Name"					header := self								readIndexed: (self readLength: number prefixSize: bitNumber from: aStream).					header isString ifTrue: [header] ifFalse: [header first]].	^Array with: fieldName with: (self readLiteralFrom: aStream)</body><body package="Protocols-Http2">readLiteralFrom: aStream	"| H |     Value Length (7+)     |+---+---------------------------+| Value String (Length octets)  |"	| valSize byte encoded |	byte := aStream get.	encoded := (byte bitAt: 8) = 1.	valSize := self readLength: byte prefixSize: 1 from: aStream.	^encoded		ifTrue: [(self decodeHuffmanLiteral: (aStream read: valSize)) asString]		ifFalse: [((aStream read: valSize) reading encoding: #ascii) rest]</body></methods><methods><class-id>Protocols.HPACKDecoder</class-id> <category>huffman decoding</category><body package="Protocols-Http2">decodeHuffmanLiteral: encodedBytes	| decoded bitBuffer bitsInBuffer decByte  requestedBits  stream |	decoded := ByteArray new writing.	bitsInBuffer := 0.	bitBuffer := 02r111111111111111111111111111111.	requestedBits := 5.	stream := encodedBytes reading.		[	requestedBits &gt; bitsInBuffer 	ifTrue: [			[bitBuffer := (bitBuffer bitShift: 8) + stream get.			bitsInBuffer := bitsInBuffer + 8.			] on: Xtreams.Incomplete do: [ :ex | 				"TO DO validate paddings. Complain if not EOS"				bitBuffer := nil ]].			bitBuffer notNil		] whileTrue: [		decByte := self findLeafFor: bitBuffer size: requestedBits bufferSize: bitsInBuffer.		decByte 			ifNil: [requestedBits := requestedBits + 1]			ifNotNil: [	decoded write:  decByte.					bitsInBuffer := bitsInBuffer - requestedBits.					requestedBits := 5.].					].	^decoded contents</body><body package="Protocols-Http2">findLeafFor: aNumber size: requestedSize bufferSize: bufferSize	| coll  |	(coll := self huffmanDecodingTable at: requestedSize) ifNil: [^nil].	coll do: [ :assoc |(self match: aNumber to: assoc key bufferSize: bufferSize) ifTrue: [^assoc value]].	^nil</body><body package="Protocols-Http2">match: aNumber to: bitsColl bufferSize: bufferSize	1 to: bitsColl size do: [ :i | (aNumber bitAt: (bufferSize - i + 1)) = (bitsColl at: i ) ifFalse: [^false]].	^true</body></methods><methods><class-id>Protocols.HPACKDecoder</class-id> <category>reading</category><body package="Protocols-Http2">readDynamicTableUpdate: aNumber from: aStream	| byte |	byte := aNumber.	(firstHeaderBlock and: [self isDynamicTableUpdate: byte])		ifTrue: 			["A change in the maximum size of the dynamic table is signaled via a dynamic table size update. The value is received from the decoder and acknowledged by the encoder"						[dynamicTableSize := self readLength: byte prefixSize: 3 from: aStream.			onDynamicTableUpdate				ifNotNil: [onDynamicTableUpdate value: dynamicTableSize].			self evictDynamicTableEntries.			aStream atEnd ifTrue: [^nil].			byte := aStream get.			self isDynamicTableUpdate: byte]					whileTrue].	firstHeaderBlock := false.	"The dynamic table size update MUST occur at the beginning of the first header block following the change to the dynamic table size."	(self isDynamicTableUpdate: byte)		ifTrue: 			[self				error: (#DynamicTableUpdateMustBeAtBeginning &lt;&lt; #protocols &gt;&gt; 'HPACK Decoding error: The dynamic table update must occur at the beginning of the first header block ')].	^byte</body><body package="Protocols-Http2">readFieldFrom: aStream	| byte |	aStream atEnd ifTrue: [^nil].	byte := aStream get.		["Dynamic Table Size Update"	(byte := self readDynamicTableUpdate: byte from: aStream) ifNil: [^nil].	(byte bitAnd: 02r10000000) = 02r10000000		ifTrue: 			["Indexed Header Field. High bit set 1"			^self readIndexed: (self readLength: byte prefixSize: 1 from: aStream)].	(byte bitAnd: 2r11000000) = 2r01000000		ifTrue: 			["Literal Header Field with Incremental Indexing.  2r10xxxxxx: top two bits are 10"			^self readIndexedLiteral: byte from: aStream].	(byte bitAnd: 2r11110000) = 0		ifTrue: 			["Literal Header Field without Indexing.  2r0000xxxx: top four bits are 0000"			^self readLiteralWithoutIndexing: byte from: aStream].	(byte bitAnd: 2r11110000) = 2r00010000		ifTrue: 			["Literal Header Field never Indexed. 2r0001xxxx: top four bits are 0001"			^self readLiteralNeverIndexed: byte from: aStream]	]		on: Xtreams.Incomplete		do: [:ex | self error: 'HPACK Decoding error'].	self error: (#HPACKDecodingError &lt;&lt; #protocols &gt;&gt; 'HPACK Decoding error')</body><body package="Protocols-Http2">readHeaderFrom: aStream	| fields field |	fields := OrderedCollection new.	[(field := self readFieldFrom: aStream) notNil] whileTrue: [fields add: field].	^fields</body><body package="Protocols-Http2">readIndexed: aNumber	^aNumber &lt;= self staticDecodingTable size		ifTrue: [ self staticDecodingTable at: aNumber ]		ifFalse: [ self dynamicTable size &lt; (aNumber - 61) ifTrue: [					"Indices strictly greater than the sum of the lengths of both tables MUST be treated as a decoding error"					^self error: ((#NoSuchDynamicTableEntry &lt;&lt; #protocols &gt;&gt; 'HPACK Decoding error: No such dynamic table entry: &lt;1s&gt;') expandMacrosWith: aNumber printString)].			self dynamicTable 	at: aNumber - 61 ]</body><body package="Protocols-Http2">readIndexedLiteral: aNumber from: aStream	" 0 | 1 |      Index (6+) "	" 0 | 1 |           0   "	"Literal Header Field with Incremental Indexing. A literal header field with incremental indexing representation results in appending a header field to the decoded header list and inserting it as a new entry into the dynamic table"	| array |	array := self readLiteralField: aNumber bitPattern: 2 from: aStream.	self dynamicTableAdd: array.	^array</body><body package="Protocols-Http2">readLiteralNeverIndexed: aNumber from: aStream	"Literal Header Field Never Indexed. A literal header field never-indexed representation results in appending a header field to the decoded header list without altering the dynamic table"	| array |	array := self readLiteralField: aNumber bitPattern: 4 from: aStream.	^Array		with: array first		with: (array at: 2)		with: #sensitive</body><body package="Protocols-Http2">readLiteralWithoutIndexing: aNumber from: aStream	"Literal Header Field without Indexing. A literal header field without indexing representation results in appending a header field to the decoded header list without altering the dynamic table"	^self readLiteralField: aNumber bitPattern: 4 from: aStream</body></methods><methods><class-id>Protocols.HPACKDecoder</class-id> <category>testing</category><body package="Protocols-Http2">isDynamicTableUpdate: aByte"6.3 Dynamic Table Size Update  Top three bits are '001' "	^ (aByte bitAnd: 2r11100000) = 2r00100000</body></methods><methods><class-id>Protocols.HPACKDecoder</class-id> <category>accessing</category><body package="Protocols-Http2">huffmanDecodingTable	^self class huffmanDecodingTable</body><body package="Protocols-Http2">onDynamicTableUpdate: aBlock	onDynamicTableUpdate := aBlock</body></methods><methods><class-id>Protocols.HTTP2Frame</class-id> <category>accessing</category><body package="Protocols-Http2">flags	^flags ifNil: [0]</body><body package="Protocols-Http2">flags: anObject	flags := anObject</body><body package="Protocols-Http2">length	^length</body><body package="Protocols-Http2">length: anInteger	length := anInteger</body><body package="Protocols-Http2">streamId	^streamId ifNil: [0]</body><body package="Protocols-Http2">streamId: anInteger	streamId := anInteger</body><body package="Protocols-Http2">type	^self class type</body></methods><methods><class-id>Protocols.HTTP2Frame</class-id> <category>testing</category><body package="Protocols-Http2">isContinuation	^false</body><body package="Protocols-Http2">isData	^false</body><body package="Protocols-Http2">isGoaway	^false</body><body package="Protocols-Http2">isHeaders	^false</body><body package="Protocols-Http2">isPriority	^false</body><body package="Protocols-Http2">isRstStream	^false</body><body package="Protocols-Http2">isSettings	^false</body><body package="Protocols-Http2">isWindowUpdate	^false</body></methods><methods><class-id>Protocols.HTTP2Frame</class-id> <category>writing</category><body package="Protocols-Http2">calculateLength	^nil</body><body package="Protocols-Http2">writeOn: aStream	|  size |	size := length ifNil: [self calculateLength].	aStream 		putUint24: size;		put: self type;		put: self flags;		putUint31: self streamId firstBit: 0.		self writePayloadOn: aStream</body><body package="Protocols-Http2">writePayloadOn: aStream</body></methods><methods><class-id>Protocols.HTTP2Frame</class-id> <category>delegation</category><body package="Protocols-Http2">processWith: aMultiplexer	^self subclassResponsibility</body></methods><methods><class-id>Protocols.HTTP2Frame</class-id> <category>parsing</category><body package="Protocols-Http2">read: aNumber from: aStream	length := aNumber.	flags := aStream get.	streamId := aStream getUint31 value.		self readPayloadFrom: aStream.</body><body package="Protocols-Http2">readPayloadFrom: aStream"Received an extension frame. This should be ignored "	aStream read: length</body></methods><methods><class-id>Protocols.HTTP2Frame</class-id> <category>printing</category><body package="Protocols-Http2">printFrameHeadOn: aStream	streamId ifNotNil: [		aStream nextPutAll: ' id:'.		streamId printOn: aStream].		aStream nextPutAll: ' flags:'.	self flags printOn: aStream.	aStream nextPutAll: ' len:'.		length		ifNil: [self calculateLength ifNotNil: [:l | l printOn: aStream]]		ifNotNil: [	length printOn: aStream].</body><body package="Protocols-Http2">printOn: aStream	aStream nextPutAll: self class name.	self printFrameHeadOn: aStream</body><body package="Protocols-Http2">verboseDebugPrint	^self class verboseDebugPrint</body></methods><methods><class-id>Protocols.HTTP2Frame class</class-id> <category>accessing</category><body package="Protocols-Http2">frameClasses	^FrameClasses</body><body package="Protocols-Http2">type	^nil</body><body package="Protocols-Http2">verboseDebugPrint	^VerboseDebugPrint</body><body package="Protocols-Http2">verboseDebugPrint: aBoolean	VerboseDebugPrint := aBoolean</body></methods><methods><class-id>Protocols.HTTP2Frame class</class-id> <category>instance creation</category><body package="Protocols-Http2">streamId: anInteger	^self new		streamId: anInteger;		yourself</body></methods><methods><class-id>Protocols.HTTP2Frame class</class-id> <category>class initialization</category><body package="Protocols-Http2">initialize	VerboseDebugPrint := false.	FrameClasses := Dictionary new.	self allSubclasses do: [ :cl | cl type ifNotNil: [ FrameClasses at: cl type put: cl ]]</body></methods><methods><class-id>Protocols.PaddedFrames</class-id> <category>accessing</category><body package="Protocols-Http2">beEndOfStream"END_STREAM (0x1)"	flags := self flags bitAt: 1 put: 1</body><body package="Protocols-Http2">beNotEndOfStream"END_STREAM (0x1)"	flags := self flags bitAt: 1 put: 0</body><body package="Protocols-Http2">padding	^padding</body><body package="Protocols-Http2">padding: aByteArray	padding := aByteArray</body><body package="Protocols-Http2">setEndOfStream: aBoolean	aBoolean ifTrue: [self beEndOfStream] ifFalse: [self beNotEndOfStream]</body><body package="Protocols-Http2">usePadding: aByteArray	flags := self flags bitOr: PADDED.	padding := aByteArray</body></methods><methods><class-id>Protocols.PaddedFrames</class-id> <category>testing</category><body package="Protocols-Http2">endOfStream"END_STREAM (0x1):When set, bit 0 indicates that the header block (Section 4.3) is the last that the endpoint will send for the identified stream."	^( self flags bitAnd: END_STREAM ) ~= 0</body><body package="Protocols-Http2">isPadded"PADDED (0x8):When set, bit 3 indicates that the Pad Length field and any padding that it describes are present."	^( self flags bitAnd: PADDED ) ~= 0</body></methods><methods><class-id>Protocols.PaddedFrames</class-id> <category>writing</category><body package="Protocols-Http2">calculateLength	^self paddingSize +  self dataSize</body><body package="Protocols-Http2">dataSize	^self subclassResponsibility</body><body package="Protocols-Http2">paddingSize	^self isPadded ifTrue: [self padding size] ifFalse: [0]</body><body package="Protocols-Http2">writePadLengthOn: aStream	self isPadded ifTrue: [aStream write: self padding size].</body><body package="Protocols-Http2">writePaddedPayloadOn: aStream do: aBlock"|Pad Length? (8)| +-+-------------+-----------------------------------------------+ |E|                 Stream Dependency? (31)                     | +-+-------------+-----------------------------------------------+ |  Weight? (8)  | +-+-------------+-----------------------------------------------+ |                   Header Block Fragment (*)                 ... +---------------------------------------------------------------+ |                           Padding (*)     "	self isPadded ifTrue: [aStream write: self padding size].	aBlock value: aStream.	self isPadded ifTrue: [aStream write: self padding ].</body><body package="Protocols-Http2">writePaddingOn: aStream	self isPadded ifTrue: [aStream write: self padding ].</body></methods><methods><class-id>Protocols.PaddedFrames</class-id> <category>printing</category><body package="Protocols-Http2">printOn: aStream	super printOn: aStream.	self endOfStream ifTrue: [aStream nextPutAll: ' EOS' ].</body></methods><methods><class-id>Protocols.PaddedFrames</class-id> <category>parsing</category><body package="Protocols-Http2">readPadLength: aNumber from: aStream	| padLength |	padLength := aNumber.	self isPadded ifTrue: [		aNumber = 0 ifTrue: [			" A frame can be increased in size by one octet by including a Pad Length field with a value of zero"			padLength := 1]. 				[			(padding := aStream read: padLength ) do: [ :b |			b ~= 0 ifTrue: [HTTP2ConnectionError protocolError: 'Data has non-zero padding']]		] on: Xtreams.Incomplete do: [ :ex |HTTP2ConnectionError protocolError: ((#Frame1sHasWrongPaddingSize &lt;&lt; #protocols &gt;&gt; 'The frame &lt;1s&gt; has a wrong padding size') expandMacrosWith: self class name)]].</body><body package="Protocols-Http2">readPadLengthFrom: aStream	| padLength |	^self isPadded 		ifTrue: [ padLength := aStream get.			"The total number of padding octets is determined by the value of the Pad Length field. If the length of the padding is the length of the frame payload or greater, the recipient MUST treat this as a connection error of type PROTOCOL_ERROR"				padLength &gt;= length ifTrue: [HTTP2ConnectionError protocolError: (#DATAHasPaddingLengthGreaterFrameLength &lt;&lt; #protocols &gt;&gt; 'DATA has the length of the padding that is greater than the length of the frame payload')].			padLength ]		ifFalse: [ 0 ]</body><body package="Protocols-Http2">readPaddedPayloadFrom: aStream do: aBlock	| padLength |	padLength := self readPadLengthFrom: aStream.	aBlock value: aStream value: padLength.	self readPadLength: padLength from: aStream.</body></methods><methods><class-id>Protocols.ContinuationFrame</class-id> <category>delegation</category><body package="Protocols-Http2">processWith: aMultiplexer	aMultiplexer processCONTINUATION: self</body></methods><methods><class-id>Protocols.ContinuationFrame</class-id> <category>writing</category><body package="Protocols-Http2">dataSize	^self headerBlockFragment size</body><body package="Protocols-Http2">writeHeaderBlockOn: aStream"               Header Block Fragment (*)                 ..."	aStream write: headerBlockFragment.</body><body package="Protocols-Http2">writePayloadOn: aStream"               Header Block Fragment (*)                 ..."	self writeHeaderBlockOn: aStream</body></methods><methods><class-id>Protocols.ContinuationFrame</class-id> <category>parsing</category><body package="Protocols-Http2">readHeaderBlockFrom: aStream limiting: anInteger	headerBlockFragment := aStream read: anInteger.</body><body package="Protocols-Http2">readPayloadFrom: aStream	self readHeaderBlockFrom: aStream limiting: length</body></methods><methods><class-id>Protocols.ContinuationFrame</class-id> <category>accessing</category><body package="Protocols-Http2">beEndOfHeaders"END_HEADERS (0x4):When set, bit 2 indicates that this frame contains an entire header block and is not followed by any CONTINUATION frames."	flags := self flags bitOr: END_HEADERS</body><body package="Protocols-Http2">headerBlockFragment	^headerBlockFragment</body><body package="Protocols-Http2">headerBlockFragment: aByteArray	headerBlockFragment := aByteArray</body><body package="Protocols-Http2">headerSize	^length</body></methods><methods><class-id>Protocols.ContinuationFrame</class-id> <category>testing</category><body package="Protocols-Http2">endOfHeaders"END_HEADERS (0x4):When set, bit 2 indicates that this frame contains an entire header block (Section 4.3) and is not followed by any CONTINUATION frames."	^(self flags bitAnd: END_HEADERS) ~= 0</body><body package="Protocols-Http2">isContinuation	^true</body></methods><methods><class-id>Protocols.ContinuationFrame</class-id> <category>printing</category><body package="Protocols-Http2">printOn: aStream	super printOn: aStream.	self endOfHeaders ifTrue: [aStream nextPutAll: ' EOH ' ].	(self verboseDebugPrint and: [ headerBlockFragment notNil ]) 		ifTrue: [ aStream nextPutAll: ' Header block: '.			headerBlockFragment printOn: aStream]</body></methods><methods><class-id>Protocols.ContinuationFrame class</class-id> <category>instance creation</category><body package="Protocols-Http2">type	^9</body></methods><methods><class-id>Protocols.HeadersFrame</class-id> <category>testing</category><body package="Protocols-Http2">hasPriority"PRIORITY (0x20):When set, bit 5 indicates that the Exclusive Flag (E), Stream Dependency, and Weight fields are present"	^( self flags bitAnd: PRIORITY) ~= 0</body><body package="Protocols-Http2">isContinuation	^false</body><body package="Protocols-Http2">isDependent	^self priority isDependent</body><body package="Protocols-Http2">isExclusiveDependend	^self priority isExclusiveDependend</body><body package="Protocols-Http2">isHeaders	^true</body><body package="Protocols-Http2">parentStreamId	^self priority parentStreamId</body></methods><methods><class-id>Protocols.HeadersFrame</class-id> <category>delegation</category><body package="Protocols-Http2">processWith: aMultiplexer	aMultiplexer processHEADERS: self</body></methods><methods><class-id>Protocols.HeadersFrame</class-id> <category>accessing</category><body package="Protocols-Http2">beDependendOn: dependStreamId	self beDependendOn: dependStreamId exclusiveDependency: 0.</body><body package="Protocols-Http2">beDependendOn: dependStreamId exclusiveDependency: zeroOrOne	"Set PRIORITY flag"	flags := self flags bitOr: PRIORITY.	self priority beDependendOn: dependStreamId exclusiveDependency: zeroOrOne</body><body package="Protocols-Http2">beExclusiveDependendOn: dependStreamId		self beDependendOn: dependStreamId exclusiveDependency: 1</body><body package="Protocols-Http2">priority	^priority ifNil: [priority := PriorityFrame new]</body><body package="Protocols-Http2">weight	^self priority weight</body><body package="Protocols-Http2">weight: anInteger	self priority weight: anInteger</body></methods><methods><class-id>Protocols.HeadersFrame</class-id> <category>writing</category><body package="Protocols-Http2">dataSize	^super dataSize + (self hasPriority						ifTrue: [self priority calculateLength ]						ifFalse: [ 0 ])</body><body package="Protocols-Http2">writePayloadOn: aStream"|Pad Length? (8)| +-+-------------+-----------------------------------------------+ |E|                 Stream Dependency? (31)                     | +-+-------------+-----------------------------------------------+ |  Weight? (8)  | +-+-------------+-----------------------------------------------+ |                   Header Block Fragment (*)                 ... +---------------------------------------------------------------+ |                           Padding (*)     "	self 		writePaddedPayloadOn: aStream 		do: [ :stream | 			self hasPriority ifTrue: [self priority writePayloadOn: stream].			self writeHeaderBlockOn: stream ]</body></methods><methods><class-id>Protocols.HeadersFrame</class-id> <category>parsing</category><body package="Protocols-Http2">readPayloadFrom: aStream" |Pad Length? (8)| +-+-------------+-----------------------------------------------+ |E|                 Stream Dependency? (31)                     | +-+-------------+-----------------------------------------------+ |  Weight? (8)  | +-+-------------+-----------------------------------------------+ |                   Header Block Fragment (*)                 ... +---------------------------------------------------------------+ |                           Padding (*)    "	| headerLength |	self 		readPaddedPayloadFrom: aStream 		do: [ :stream :padLength |			headerLength := length - padLength.			self hasPriority ifTrue: [				self priority readPriorityFrom: aStream.				headerLength := headerLength - self priority calculateLength].			self readHeaderBlockFrom: aStream limiting: headerLength ]</body></methods><methods><class-id>Protocols.HeadersFrame</class-id> <category>printing</category><body package="Protocols-Http2">printOn: aStream	super printOn: aStream.	self hasPriority ifTrue: [ self priority printOn: aStream ].</body></methods><methods><class-id>Protocols.HeadersFrame class</class-id> <category>instance creation</category><body package="Protocols-Http2">type	^1</body></methods><methods><class-id>Protocols.HTTP2Announcement</class-id> <category>accessing</category><body package="Protocols-Http2">description	description ifNotNil: [ :d | ^d ].	frame ifNotNil: [ :f | ^f printString ].	^String new</body><body package="Protocols-Http2">description: anUserMessageOrString	description := anUserMessageOrString asString</body><body package="Protocols-Http2">direction	^String new</body><body package="Protocols-Http2">frame	^frame</body><body package="Protocols-Http2">frame: anObject	frame := anObject</body><body package="Protocols-Http2">type	^type ifNil: [String new]</body><body package="Protocols-Http2">type: aString	type := aString</body></methods><methods><class-id>Protocols.HTTP2Announcement</class-id> <category>printing</category><body package="Protocols-Http2">printOn: aStream	self class shouldPrintProcessName		ifTrue: [aStream nextPutAll: self processName, '[', Time now printString, ']  '].			aStream nextPutAll: self type, self direction, self description.</body><body package="Protocols-Http2">processName	^[Processor activeProcess name printString ] on: Error do: [ :ex | String new].</body></methods><methods><class-id>Protocols.HTTP2Announcement class</class-id> <category>instance creation</category><body package="Protocols-Http2">description: aString	^self new		description: aString;		yourself</body><body package="Protocols-Http2">frame: aString	^self new		frame: aString;		yourself</body></methods><methods><class-id>Protocols.HTTP2Announcement class</class-id> <category>accessing</category><body package="Protocols-Http2">shouldPrintProcessName	^ShouldPrintProcessName ifNil: [ false ]</body><body package="Protocols-Http2">shouldPrintProcessName: aBoolean	ShouldPrintProcessName := aBoolean</body></methods><methods><class-id>Protocols.HTTPRequestAnnouncement</class-id> <category>accessing</category><body package="Protocols-Http2">description	| digest |	^description ifNil: [		digest := request printString.		description := 'Receiving request  from Stream id: ', stream id printString, ' ', (digest copyFrom: 1 to: (digest size min: RequestDigestSize))]</body><body package="Protocols-Http2">direction	^' &lt;-- '</body></methods><methods><class-id>Protocols.HTTPRequestAnnouncement</class-id> <category>initialize-release</category><body package="Protocols-Http2">stream: anHTTP2Stream request: anHttpRequest	stream := anHTTP2Stream.	request := anHttpRequest</body></methods><methods><class-id>Protocols.HTTPRequestAnnouncement class</class-id> <category>accessing</category><body package="Protocols-Http2">requestDigestSize	^RequestDigestSize</body><body package="Protocols-Http2">requestDigestSize: aNumber	RequestDigestSize := aNumber</body></methods><methods><class-id>Protocols.HTTPRequestAnnouncement class</class-id> <category>instance creation</category><body package="Protocols-Http2">stream: anHTTP2Stream request: anHttpRequest	^self new		stream: anHTTP2Stream request: anHttpRequest;		yourself</body></methods><methods><class-id>Protocols.HTTP2ErrorAnnouncement</class-id> <category>accessing</category><body package="Protocols-Http2">description: anErrorOrString	description := (anErrorOrString isString					ifTrue: [anErrorOrString asString]					ifFalse: [ | stream  |						stream := String new writeStream.						stream cr.						anErrorOrString stackTraceOn: stream indentedTo: 1.						stream contents])</body><body package="Protocols-Http2">direction	^'*error*'</body></methods><methods><class-id>Protocols.HTTP2RecyclingCenter</class-id> <category>logging</category><body package="Protocols-Http2">isLogging	^logRecycled notNil</body><body package="Protocols-Http2">log: aSymbol for: aNumber	| n d  |	d := logRecycled at: aSymbol ifAbsentPut: [Dictionary new].	n := d at: aNumber ifAbsentPut: [0].	d at: aNumber put: n + 1</body><body package="Protocols-Http2">logNotFoundFor: aNumber	self log: #notFound for: aNumber</body><body package="Protocols-Http2">logPrint	self logPrintOn: Transcript</body><body package="Protocols-Http2">logPrintOn: aStream	logRecycled ifNotNil: [		aStream cr; nextPutAll: 'Cache limit size: ', self class cacheLimit printString.		aStream cr; nextPutAll: 'Reused cache:'.		(logRecycled at: #reused) keysAndValuesDo: [:key :value |			aStream cr; tab; nextPutAll: 'Buffer size: ', key printString, ' times: ', value printString].				aStream cr; nextPutAll: 'Not found cache:'.		(logRecycled at: #notFound) keysAndValuesDo: [:key :value |			aStream cr; tab; nextPutAll: 'Buffer size: ', key printString, ' times: ', value printString].				]</body><body package="Protocols-Http2">logReusedFor: aNumber	self log: #reused for: aNumber</body><body package="Protocols-Http2">startLogging	(logRecycled := Dictionary new)		at: #reused put: Dictionary new;		at: #notFound put: Dictionary new.</body><body package="Protocols-Http2">stopLogging	logRecycled := nil</body></methods><methods><class-id>Protocols.HTTP2RecyclingCenter</class-id> <category>recycling</category><body package="Protocols-Http2">existing: aNumber	^ (mutex critical: [self privateExisting: aNumber]) 		ifNil: [	self isLogging ifTrue: [self logNotFoundFor: aNumber].			nil]</body><body package="Protocols-Http2">newByteArraySize: anInteger	^(self existing: anInteger) ifNil: [ByteArray newInFixedSpace: anInteger ]</body><body package="Protocols-Http2">recycle: aCollection	| queue |	queue := recycled at: aCollection size ifAbsent: [^self].	mutex critical: [ self recycle: aCollection in: queue ]</body></methods><methods><class-id>Protocols.HTTP2RecyclingCenter</class-id> <category>private</category><body package="Protocols-Http2">privateExisting: aNumber	| queue collection |	queue := recycled 				at: aNumber				ifAbsentPut: [Array new: self class cacheLimit].	1 to: queue size		do: 			[:index |			collection := queue at: index.			collection == nil				ifFalse: 					[queue at: index put: nil.					self isLogging ifTrue: [self logReusedFor: aNumber].					^ collection]].	^ nil</body><body package="Protocols-Http2">recycle: aCollection in: queue"	aCollection can be in queue only once. If aCollection is recycled again before being reused,	it could end up in multiple slots in queue. Prevent that by checking if it's in queue already."	1 to: queue size do: [:index |		(queue at: index)			ifNil: [ queue at: index put: aCollection.				^ self ]			ifNotNil: [ :another | another == aCollection ifTrue: [					^ self ] ] ].</body></methods><methods><class-id>Protocols.HTTP2RecyclingCenter</class-id> <category>printing</category><body package="Protocols-Http2">printOn: aStream	super printOn: aStream.	recycled ifNotNil: [		aStream nextPut: Character space.		recycled printOn: aStream]</body></methods><methods><class-id>Protocols.HTTP2RecyclingCenter</class-id> <category>initialize-release</category><body package="Protocols-Http2">initialize		mutex := Semaphore forMutualExclusion.	recycled := Dictionary new.</body></methods><methods><class-id>Protocols.HTTP2RecyclingCenter class</class-id> <category>instance creation</category><body package="Protocols-Http2">default	^Default</body><body package="Protocols-Http2">new 		^super new initialize</body></methods><methods><class-id>Protocols.HTTP2RecyclingCenter class</class-id> <category>accessing</category><body package="Protocols-Http2">cacheLimit	^CacheLimit</body><body package="Protocols-Http2">cacheLimit: aNumber	CacheLimit := aNumber</body></methods><methods><class-id>Protocols.HTTP2RecyclingCenter class</class-id> <category>class initialization</category><body package="Protocols-Http2">initialize	CacheLimit := 10.	Default := self new.</body></methods><methods><class-id>Protocols.HTTP2Error</class-id> <category>accessing</category><body package="Protocols-Http2">frame	^parameter</body></methods><methods><class-id>Protocols.HTTP2StreamError</class-id> <category>accessing</category><body package="Protocols-Http2">rstStreamFrame	^parameter</body></methods><methods><class-id>Protocols.HTTP2StreamError class</class-id> <category>instance creation</category><body package="Protocols-Http2">enhanceYourCalmError: streamId errorString: aString	^self raiseWith: (RstStreamFrame 					streamId: streamId					errorCode: HTTP2Multiplexer ENHANCE_YOUR_CALM)		errorString: aString</body><body package="Protocols-Http2">flowControlError: streamId errorString: aString	^self raiseWith: (RstStreamFrame 						streamId: streamId						errorCode: HTTP2Multiplexer FLOW_CONTROL_ERROR)		errorString: aString</body><body package="Protocols-Http2">frameSizeError: streamId errorString: aString	^self raiseWith: (RstStreamFrame 					streamId: streamId					errorCode: HTTP2Multiplexer FRAME_SIZE_ERROR)		errorString: aString</body><body package="Protocols-Http2">protocolError: streamId errorString: aString	^self raiseWith: (RstStreamFrame 					streamId: streamId					errorCode: HTTP2Multiplexer PROTOCOL_ERROR)		errorString: aString</body><body package="Protocols-Http2">refusedStreamError: streamId errorString: aString	^self raiseWith: (RstStreamFrame 					streamId: streamId					errorCode: HTTP2Multiplexer REFUSED_STREAM)		errorString: aString</body><body package="Protocols-Http2">streamClosedError: streamId errorString: aString	^self raiseWith: (RstStreamFrame 					streamId: streamId					errorCode: HTTP2Multiplexer STREAM_CLOSED)		errorString: aString</body></methods><methods><class-id>Protocols.PriorityFrame</class-id> <category>accessing</category><body package="Protocols-Http2">beDependendOn: dependStreamId	self beDependendOn: dependStreamId exclusiveDependency: 0.</body><body package="Protocols-Http2">beDependendOn: dependStreamId exclusiveDependency: zeroOrOne"A 31-bit stream identifier for the stream that this stream depends on. This field is only present if the PRIORITY flag is set.""Set PRIORITY flag"	flags := self flags bitAt: 5 put: 1.	parentStreamId := dependStreamId.	exclusiveDependend := zeroOrOne.</body><body package="Protocols-Http2">beExclusiveDependendOn: dependStreamId		self beDependendOn: dependStreamId exclusiveDependency: 1</body><body package="Protocols-Http2">parentStreamId"5.3.5 Default PrioritiesAll streams are initially assigned a non-exclusive dependency on stream 0x0. Streams are assigned a default weight of 16."	^parentStreamId ifNil: [0]</body><body package="Protocols-Http2">weight"5.3.5 Default PrioritiesAll streams are initially assigned a non-exclusive dependency on stream 0x0. Streams are assigned a default weight of 16."	^weight ifNil: [DefaultWeight]</body><body package="Protocols-Http2">weight: anInteger	weight := anInteger</body></methods><methods><class-id>Protocols.PriorityFrame</class-id> <category>printing</category><body package="Protocols-Http2">printOn: aStream	super printOn: aStream.	parentStreamId ifNotNil: [ aStream nextPutAll: ' depend on: ',  parentStreamId printString].	weight ifNotNil: [ aStream nextPutAll: ' w: ', weight printString].</body></methods><methods><class-id>Protocols.PriorityFrame</class-id> <category>delegation</category><body package="Protocols-Http2">processWith: aMultiplexer	aMultiplexer processPRIORITY: self</body></methods><methods><class-id>Protocols.PriorityFrame</class-id> <category>testing</category><body package="Protocols-Http2">isDependent	^self parentStreamId ~= 0</body><body package="Protocols-Http2">isExclusiveDependend	exclusiveDependend ifNil: [^false].	^exclusiveDependend = 1</body><body package="Protocols-Http2">isPriority	^true</body></methods><methods><class-id>Protocols.PriorityFrame</class-id> <category>writing</category><body package="Protocols-Http2">calculateLength	^5</body><body package="Protocols-Http2">writePayloadOn: aStream" |E|                 Stream Dependency? (31)                     | +-+-------------+-----------------------------------------------+ |  Weight? (8)  |   "	aStream 		putUint31: parentStreamId 		firstBit: (exclusiveDependend ifNil: [0]).	aStream write: self weight.</body></methods><methods><class-id>Protocols.PriorityFrame</class-id> <category>parsing</category><body package="Protocols-Http2">readPayloadFrom: aStream" |E|                  Stream Dependency (31)                     | +-+-------------+-----------------------------------------------+ |   Weight (8) "	"A PRIORITY frame with a length other than 5 octets MUST be treated as a stream error of type FRAME_SIZE_ERROR"	length ~= 5 ifTrue: [		aStream read: length.		^HTTP2StreamError 			frameSizeError: streamId			errorString: (#PRIORITYHasLengthNot5 &lt;&lt; #protocols &gt;&gt; 'A PRIORITY frame with a length other than 5 octets')].		self readPriorityFrom: aStream</body><body package="Protocols-Http2">readPriorityFrom: aStream	| assoc |	assoc := aStream getUint31.	parentStreamId := assoc value.	exclusiveDependend := assoc key.	weight := aStream get.</body></methods><methods><class-id>Protocols.PriorityFrame class</class-id> <category>instance creation</category><body package="Protocols-Http2">type	^2</body></methods><methods><class-id>Protocols.HTTP2FrameReadStream</class-id> <category>accessing</category><body package="Protocols-Http2">cacheSize	^source cacheSize</body><body package="Protocols-Http2">endOfStream	^ endOfStream</body><body package="Protocols-Http2">get	| object |	stateLock wait.	[source hasDataToRead] whileFalse: 			[endOfStream				ifTrue: 					[stateLock signal.					Xtreams.Incomplete zero raise].			waitingLock excessSignals timesRepeat: [waitingLock wait].			stateLock signal.			waitingLock wait.			stateLock wait].	object := source get.	self checkForFullBuffer.	stateLock signal.	^object</body><body package="Protocols-Http2">onReading: aBlock	onReading := aBlock</body><body package="Protocols-Http2">onWriting: aBlock	onWriting := aBlock</body><body package="Protocols-Http2">read: anInteger into: aSequenceableCollection at: startIndex	| count amount readSize |	anInteger isZero ifTrue: [^0].	count := 0.	[count &lt; anInteger] whileTrue: [		stateLock wait.		[			readSize := (anInteger - count) min: (source cacheSize - source readPosition).			amount := source read: readSize into: aSequenceableCollection at: startIndex + count.			stateLock signal		]			on: Xtreams.Incomplete 			do: [:exception |				endOfStream ifTrue: [					source readPosition &gt; 0 ifTrue: [ 						self notifyReading: source readPosition.						source reset ].					stateLock signal.					(Xtreams.Incomplete on: aSequenceableCollection count: count + exception count at: startIndex) raise].								"More data cannot signal waitingLock until stateLock is unlocked. We know we have fully consumed all the data in the buffer and that until stateLock is unlocked, waitingLock cannot be signalled. waitingLock may have been signalled multiple times before we locked stateLock though, so we must consume the excessSignals."				waitingLock excessSignals timesRepeat: [waitingLock wait].				"Release the stateLock so that incoming data can signal waitingLock at least once."				stateLock signal.				waitingLock wait.				amount := exception count].					self checkForFullBuffer.		count := count + amount].	^anInteger</body><body package="Protocols-Http2">setEndOfStream"We come here in case of trailer header EOS or closing the Http stream"	endOfStream := true.	stateLock signal.	waitingLock signal</body><body package="Protocols-Http2">write: aByteArray endOfStream: aBoolean	| reading writeSize  |	reading := aByteArray reading.	[ reading atEnd ] whileFalse: [		source inactiveSize = 0 ifTrue: [ bufferLock wait ].		stateLock critical: [			writeSize := (reading length - reading position) min: source inactiveSize.			self notifyWriting: writeSize.			writeStream				write: writeSize				from: reading.			reading atEnd ifTrue: [ endOfStream := aBoolean ].			waitingLock signal ]]</body></methods><methods><class-id>Protocols.HTTP2FrameReadStream</class-id> <category>printing</category><body package="Protocols-Http2">streamingPrintOn: aStream	super streamingPrintOn: aStream.	endOfStream ifTrue: [ aStream nextPutAll: ' EOS' ]</body></methods><methods><class-id>Protocols.HTTP2FrameReadStream</class-id> <category>private</category><body package="Protocols-Http2">checkForFullBuffer	(source readPosition = source cacheSize		or: [source hasDataToRead not			or: [self atEnd]]) 		ifTrue: [			self notifyReading: source readPosition.			source reset.			bufferLock signal]</body><body package="Protocols-Http2">notifyReading: anInteger"	If an onReading callback has been set up, invoke it."	onReading ifNotNil: [ :aBlock | aBlock value: anInteger ]</body><body package="Protocols-Http2">notifyWriting: anInteger"	If an onWriting callback has been set up, invoke it."	onWriting ifNotNil: [ :aBlock | aBlock value: anInteger]</body></methods><methods><class-id>Protocols.HTTP2FrameReadStream</class-id> <category>seeking</category><body package="Protocols-Http2">atEnd	^endOfStream and: [source hasDataToRead not]</body></methods><methods><class-id>Protocols.HTTP2FrameReadStream</class-id> <category>initialize-release</category><body package="Protocols-Http2">contentsSpecies	"Returns collection class suitable to hold elements of this stream."	^ByteArray</body><body package="Protocols-Http2">on: aSource		super on: aSource.	writeStream := source writing.	waitingLock := Semaphore new.	bufferLock := Semaphore new.	stateLock := Semaphore forMutualExclusion.	endOfStream := false.</body><body package="Protocols-Http2">recycleWith: aMultiplexer	| saved |	self close.	saved := source cache.	source := nil.	saved ifNotNil: [ aMultiplexer recycle: saved ].	saved := nil.</body></methods><methods><class-id>Protocols.PingFrame</class-id> <category>delegation</category><body package="Protocols-Http2">processWith: aMultiplexer	aMultiplexer processPING: self</body></methods><methods><class-id>Protocols.PingFrame</class-id> <category>testing</category><body package="Protocols-Http2">isACK	^(self flags bitAt: 1) = 1</body></methods><methods><class-id>Protocols.PingFrame</class-id> <category>accessing</category><body package="Protocols-Http2">data	^data</body><body package="Protocols-Http2">data: aByteArray	data := aByteArray</body><body package="Protocols-Http2">setACK"ACK (0x1):When set, bit 0 indicates that this PING frame is a PING response. An endpoint MUST set this flag in PING responses. An endpoint MUST NOT respond to PING frames containing this flag"	flags := self flags bitAt: 1 put: 1.</body></methods><methods><class-id>Protocols.PingFrame</class-id> <category>writing</category><body package="Protocols-Http2">asACK"Receivers of a PING frame that does not include an ACK flag MUST send a PING frame with the ACK flag set in response, with an identical payload"	^self class new		setACK;		data: data;		yourself.</body><body package="Protocols-Http2">calculateLength	^8</body><body package="Protocols-Http2">writePayloadOn: aStream	aStream write: (data reading limiting: 8) rest.	data size &lt; 8		ifTrue: [ (8 - data size) timesRepeat: [ aStream write: 0 ]]</body></methods><methods><class-id>Protocols.PingFrame</class-id> <category>printing</category><body package="Protocols-Http2">printOn: aStream	super printOn: aStream.	self verboseDebugPrint ifTrue: [		aStream nextPutAll: ' data:'.		data printOn: aStream]</body></methods><methods><class-id>Protocols.PingFrame</class-id> <category>parsing</category><body package="Protocols-Http2">readPayloadFrom: aStream" Opaque Data (64) "	"Receipt of a PING frame with a length field value other than 8 MUST be treated as a connection error (Section 5.4.1) of type FRAME_SIZE_ERROR"	length ~= 8 ifTrue: [^HTTP2ConnectionError frameSizeError: (#PINGLengthNot8 &lt;&lt; #protocols &gt;&gt; 'PING frame length is not 8 octets')].	data := aStream read: 8</body></methods><methods><class-id>Protocols.PingFrame class</class-id> <category>instance creation</category><body package="Protocols-Http2">data: aByteArray"Opaque Data (64)"	^self new		data: aByteArray;		yourself</body><body package="Protocols-Http2">type	^6</body></methods><methods><class-id>Protocols.HTTP2HeadersWriteStream</class-id> <category>initialize-release</category><body package="Protocols-Http2">close	super close.	self readyToSendFrame.	self recycle</body><body package="Protocols-Http2">newDestinationBuffer	^http2Stream multiplexer newRecycledFrameBuffer</body><body package="Protocols-Http2">on: anHTTP2Stream onFrame: aBlock	self on: anHTTP2Stream.	numberOfFrames := 0.	frameBlock := aBlock</body></methods><methods><class-id>Protocols.HTTP2HeadersWriteStream</class-id> <category>services</category><body package="Protocols-Http2">checkDestinationSize	self hasFrameToWrite ifTrue: [self readyToSendFrame].</body><body package="Protocols-Http2">readyToSendFrame	| frameClass frame |	destination ifNil: [ ^ self ].	numberOfFrames := numberOfFrames + 1.	frameClass := (numberOfFrames  &gt; 1 ifTrue: [ ContinuationFrame ] ifFalse: [ HeadersFrame ]).	frame := frameClass new 			streamId:  http2Stream id;			headerBlockFragment: destination contentsPast;			yourself.	destination reset.				"A HEADERS frame carries the END_STREAM flag that signals the end of a stream"		(frame isHeaders and: [http2Stream sendHeadersOnly]) ifTrue: [frame beEndOfStream].	endOfStream ifTrue: [frame beEndOfHeaders. ].	frameBlock value: frame.</body></methods><methods><class-id>Protocols.HTTP2HeadersWriteStream class</class-id> <category>instance creation</category><body package="Protocols-Http2">on: anHTTP2Stream onFrame: aBlock	^self new		on: anHTTP2Stream onFrame: aBlock;		yourself</body></methods><methods><class-id>Protocols.DataFrame</class-id> <category>accessing</category><body package="Protocols-Http2">data	^data</body><body package="Protocols-Http2">data: aByteArray	data := aByteArray.</body></methods><methods><class-id>Protocols.DataFrame</class-id> <category>delegation</category><body package="Protocols-Http2">processWith: aMultiplexer	aMultiplexer processDATA: self</body></methods><methods><class-id>Protocols.DataFrame</class-id> <category>writing</category><body package="Protocols-Http2">dataSize	^self data size</body><body package="Protocols-Http2">writePayloadOn: aStream" |Pad Length? (8)| +---------------+-----------------------------------------------+ |                            Data (*)                         ... +---------------------------------------------------------------+ |                           Padding (*) "	self 		writePaddedPayloadOn: aStream 		do: [ :stream | stream write: self data ]</body></methods><methods><class-id>Protocols.DataFrame</class-id> <category>parsing</category><body package="Protocols-Http2">readPayloadFrom: aStream" |Pad Length? (8)| +---------------+-----------------------------------------------+ |                            Data (*)                         ... +---------------------------------------------------------------+ |                           Padding (*)     "	self 		readPaddedPayloadFrom: aStream 		do: [ :stream :padLength |			data := aStream read: length - padLength ].</body></methods><methods><class-id>Protocols.DataFrame</class-id> <category>testing</category><body package="Protocols-Http2">isData	^true</body></methods><methods><class-id>Protocols.DataFrame</class-id> <category>printing</category><body package="Protocols-Http2">printOn: aStream	super printOn: aStream.	(self verboseDebugPrint and: [data notNil]) 		ifTrue: [ aStream nextPutAll: ' data:'.				(data copyFrom: 1 to: (data size min: 200) ) asString printOn: aStream].</body></methods><methods><class-id>Protocols.DataFrame class</class-id> <category>instance creation</category><body package="Protocols-Http2">type	^0</body></methods><methods><class-id>Protocols.SentFrameAnnouncement</class-id> <category>accessing</category><body package="Protocols-Http2">direction	^' --&gt; '</body></methods><methods><class-id>Protocols.HTTP2ConnectionError</class-id> <category>accessing</category><body package="Protocols-Http2">goawayFrame	^parameter</body></methods><methods><class-id>Protocols.HTTP2ConnectionError class</class-id> <category>instance creation</category><body package="Protocols-Http2">ackTimeoutError: aDuration	^self new		messageText: (#ACKWasNotReceivedIn &lt;&lt; #protocols&gt;&gt; 'The ACK was not received in &lt;1s&gt;' expandMacrosWith:  aDuration printString);						parameter:  (GoawayFrame new					errorCode: HTTP2Multiplexer SETTINGS_TIMEOUT;					yourself);		yourself</body><body package="Protocols-Http2">compressionError: aStringOrUserMessage	^self raiseWith: (GoawayFrame new					errorCode: HTTP2Multiplexer COMPRESSION_ERROR;					debugData: aStringOrUserMessage asString;					yourself)		errorString: aStringOrUserMessage</body><body package="Protocols-Http2">flowControlError: aStringOrUserMessage	^self raiseWith: (GoawayFrame new					errorCode: HTTP2Multiplexer FLOW_CONTROL_ERROR;					debugData: aStringOrUserMessage asString;					yourself)		errorString: aStringOrUserMessage</body><body package="Protocols-Http2">frameSizeError: aStringOrUserMessage	^self raiseWith: (GoawayFrame new					errorCode: HTTP2Multiplexer FRAME_SIZE_ERROR;					debugData: aStringOrUserMessage asString;					yourself)		errorString: aStringOrUserMessage</body><body package="Protocols-Http2">protocolError: aStringOrUserMessage	" An endpoint that encounters a connection error SHOULD first send a GOAWAY frame "	^self raiseWith: (GoawayFrame new					errorCode: HTTP2Multiplexer PROTOCOL_ERROR;					debugData: aStringOrUserMessage asString;					yourself)		errorString: aStringOrUserMessage</body></methods><methods><class-id>Protocols.HTTP2Settings</class-id> <category>accessing</category><body package="Protocols-Http2">ackTimeout	^ackTimeout</body><body package="Protocols-Http2">headerTableSize	^self settingsFrame headerTableSizeValue</body><body package="Protocols-Http2">initialWindowSize	^self settingsFrame initialWindowSizeValue</body><body package="Protocols-Http2">inputWindowSize	^self settingsFrame initialWindowSizeValue</body><body package="Protocols-Http2">maxFrameSize	^self settingsFrame maxFrameSizeValue</body><body package="Protocols-Http2">outputWindowSize	^outputWindowSize ifNil: [ outputWindowSize := self class outputWindowSize ]</body><body package="Protocols-Http2">settingsFrame	^settingsFrame ifNil: [ settingsFrame := self class settingsFrame ]</body></methods><methods><class-id>Protocols.HTTP2Settings</class-id> <category>initialize-release</category><body package="Protocols-Http2">ackTimeout: aDuration	ackTimeout := aDuration</body><body package="Protocols-Http2">disablePush	self settingsFrame disablePush</body><body package="Protocols-Http2">enablePush	self settingsFrame enablePush</body><body package="Protocols-Http2">headerTableSize: aNumber	self settingsFrame headerTableSize: aNumber</body><body package="Protocols-Http2">inputWindowSize: aNumber	self settingsFrame initialWindowSize: aNumber</body><body package="Protocols-Http2">maxConcurrentStreams: aNumber	self settingsFrame maxConcurrentStreams: aNumber</body><body package="Protocols-Http2">maxFrameSize: aNumber	self settingsFrame maxFrameSize: aNumber</body><body package="Protocols-Http2">maxHeaderListSize: aNumber	self settingsFrame maxHeaderListSize: aNumber</body><body package="Protocols-Http2">outputWindowSize: aNumber	outputWindowSize := aNumber</body><body package="Protocols-Http2">settingsFrame: aSettingsFrame	settingsFrame := aSettingsFrame</body></methods><methods><class-id>Protocols.HTTP2Settings class</class-id> <category>accessing</category><body package="Protocols-Http2">outputWindowSize	^outputWindowSize ifNil: [ outputWindowSize := SettingsFrame SETTINGS_INITIAL_WINDOW_SIZE]</body><body package="Protocols-Http2">outputWindowSize: aNumber	outputWindowSize := aNumber</body><body package="Protocols-Http2">settingsFrame	^settingsFrame ifNil: [ SettingsFrame default ]</body><body package="Protocols-Http2">settingsFrame: aSettingsFrame	settingsFrame := aSettingsFrame</body></methods><methods><class-id>Protocols.SettingsFrame</class-id> <category>updating</category><body package="Protocols-Http2">updateWith: aRemoteSettings	1 to: 6 do: [ :ind | self values at: ind put: (aRemoteSettings values at: ind) ]</body></methods><methods><class-id>Protocols.SettingsFrame</class-id> <category>delegation</category><body package="Protocols-Http2">processWith: aMultiplexer	aMultiplexer processSETTINGS: self</body></methods><methods><class-id>Protocols.SettingsFrame</class-id> <category>accessing</category><body package="Protocols-Http2">disablePush"SETTINGS_ENABLE_PUSH 0x2"	self valueAt: 2 put: 0</body><body package="Protocols-Http2">enablePush"SETTINGS_ENABLE_PUSH 0x2"	self valueAt: 2 put: 1</body><body package="Protocols-Http2">enablePushValue"SETTINGS_ENABLE_PUSH 0x2"	^self valueAt: 2</body><body package="Protocols-Http2">headerTableSize"SETTINGS_HEADER_TABLE_SIZE (0x1)"	^self valueAt: 1</body><body package="Protocols-Http2">headerTableSize: aNumber"SETTINGS_HEADER_TABLE_SIZE (0x1)"	^self valueAt: 1 put: aNumber</body><body package="Protocols-Http2">headerTableSizeValue"SETTINGS_HEADER_TABLE_SIZE (0x1)"	^self headerTableSize ifNil: [self class SETTINGS_HEADER_TABLE_SIZE]</body><body package="Protocols-Http2">initialWindowSize"SETTINGS_INITIAL_WINDOW_SIZE (0x4)"	^self valueAt: 4</body><body package="Protocols-Http2">initialWindowSize: aNumber"SETTINGS_INITIAL_WINDOW_SIZE (0x4)"	self valueAt: 4 put: aNumber</body><body package="Protocols-Http2">initialWindowSizeValue"SETTINGS_INITIAL_WINDOW_SIZE (0x4)"	^self initialWindowSize ifNil: [self class SETTINGS_INITIAL_WINDOW_SIZE ]</body><body package="Protocols-Http2">maxConcurrentStreams"SETTINGS_MAX_CONCURRENT_STREAMS (0x3)"	^ self valueAt: 3</body><body package="Protocols-Http2">maxConcurrentStreams: aNumber"SETTINGS_MAX_CONCURRENT_STREAMS (0x3)"	self valueAt: 3 put: aNumber</body><body package="Protocols-Http2">maxConcurrentStreamsValue"SETTINGS_MAX_CONCURRENT_STREAMS (0x3)"	^self maxConcurrentStreams ifNil: [ self class SETTINGS_MAX_CONCURRENT_STREAMS]</body><body package="Protocols-Http2">maxFrameSize"SETTINGS_MAX_FRAME_SIZE (0x5)"	^(self valueAt: 5) ifNil: [ self class SETTINGS_INITIAL_FRAME_SIZE ]</body><body package="Protocols-Http2">maxFrameSize: aNumber"SETTINGS_MAX_FRAME_SIZE (0x5)"	self valueAt: 5 put: aNumber</body><body package="Protocols-Http2">maxFrameSizeValue"SETTINGS_MAX_FRAME_SIZE (0x5)"	^self maxFrameSize ifNil: [ self class SETTINGS_INITIAL_FRAME_SIZE ]</body><body package="Protocols-Http2">maxHeaderListSize"SETTINGS_MAX_HEADER_LIST_SIZE (0x6)"	^self valueAt: 6</body><body package="Protocols-Http2">maxHeaderListSize: aNumber"SETTINGS_MAX_HEADER_LIST_SIZE (0x6)"	self valueAt: 6 put: aNumber</body><body package="Protocols-Http2">maxHeaderListSizeValue"SETTINGS_MAX_HEADER_LIST_SIZE (0x6)"	^self maxHeaderListSize ifNil: [ self class SETTINGS_MAX_HEADER_LIST_SIZE ]</body><body package="Protocols-Http2">setACK"SETTINGS parameters are acknowledged by the receiving peer. To enable this, the SETTINGS frame defines the following flag:ACK (0x1):When set, bit 0 indicates that this frame acknowledges receipt and application of the peer's SETTINGS frame"	flags := self flags bitAt: 1 put: 1.</body><body package="Protocols-Http2">valueAt: aNumber	^self values at: aNumber</body><body package="Protocols-Http2">valueAt: aNumber put: aValue	self values at: aNumber put: aValue</body><body package="Protocols-Http2">values	^values ifNil: [values := Array new: 6]</body></methods><methods><class-id>Protocols.SettingsFrame</class-id> <category>writing</category><body package="Protocols-Http2">calculateLength	^(self values select: [ :v | v notNil])  size * 6</body><body package="Protocols-Http2">writePayloadOn: aStream	self values doWithIndex:  [ :val :ind | 		val ifNotNil: [			aStream 				putUint16: ind;				putUint32: val ]]</body></methods><methods><class-id>Protocols.SettingsFrame</class-id> <category>testing</category><body package="Protocols-Http2">isACK" SETTINGS acknowledges receipt"	^( self flags bitAt: 1 ) = 1</body><body package="Protocols-Http2">isPushEnabled"SETTINGS_ENABLE_PUSH 0x2"	| v |	^(v := self valueAt: 2 ) == nil		ifTrue: [ true ]		ifFalse: [  v = 1]</body><body package="Protocols-Http2">isSettings	^true</body></methods><methods><class-id>Protocols.SettingsFrame</class-id> <category>copying</category><body package="Protocols-Http2">postCopy	values := Array withAll: self values</body></methods><methods><class-id>Protocols.SettingsFrame</class-id> <category>parsing</category><body package="Protocols-Http2">readPayloadFrom: aStream"https://httpwg.github.io/specs/rfc7540.html#SETTINGSThe payload of a SETTINGS frame consists of zero or more parameters, each consisting of an unsigned 16-bit setting identifier and an unsigned 32-bit value"	length = 0 ifTrue: [^self].	(length rem: 6) ~= 0 ifTrue: ["A SETTINGS frame with a length other than a multiple of 6 octets MUST be treated as a connection error of type FRAME_SIZE_ERROR"		HTTP2ConnectionError frameSizeError: (#SETTINGSLengthNotMultipleOf6 &lt;&lt; #protocols &gt;&gt; 'Received SETTINGS frame with a length other than a multiple of 6 octets' )].		length / 6 timesRepeat: [self valueAt: aStream getUint16 put: aStream getUint32]</body></methods><methods><class-id>Protocols.SettingsFrame</class-id> <category>printing</category><body package="Protocols-Http2">printOn: aStream	self isACK ifTrue: [^aStream nextPutAll: 'SettingsFrame ACK'].	super printOn: aStream.	self headerTableSize ifNotNil: [ :n | aStream nextPutAll: ' HEADER_TABLE_SIZE:'.  n printOn: aStream ].	self enablePushValue ifNotNil: [ :n | aStream nextPutAll: ' ENABLE_PUSH:'.  n printOn: aStream ].				self maxConcurrentStreams ifNotNil: [ :n | aStream nextPutAll: ' MAX_CONCURRENT_STREAMS:'.  n printOn: aStream ].	self initialWindowSize ifNotNil: [ :n | aStream nextPutAll: ' INITIAL_WINDOW_SIZE:'.  n printOn: aStream ].	self maxFrameSize ifNotNil: [ :n | aStream nextPutAll: ' MAX_FRAME_SIZE:'.  n printOn: aStream ].	self maxHeaderListSize ifNotNil: [ :n | aStream nextPutAll: ' MAX_HEADER_LIST_SIZE:'.  n printOn: aStream ].</body></methods><methods><class-id>Protocols.SettingsFrame class</class-id> <category>defaults</category><body package="Protocols-Http2">SETTINGS_HEADER_TABLE_SIZE"Allows the sender to inform the remote endpoint of the maximum size of the header compression table used to decode header blocks, in octets. The encoder can select any size equal to or less than this value by using signaling specific to the header compression format inside a header block (see [COMPRESSION]). The initial value is 4,096 octets."	^4096</body><body package="Protocols-Http2">SETTINGS_INITIAL_FRAME_SIZE"This setting can have any value between 2^14 (16,384) and 2^24-1 (16,777,215) octets, inclusive.All implementations MUST be capable of receiving and minimally processing frames up to 2^14 octets in length "	^16384</body><body package="Protocols-Http2">SETTINGS_INITIAL_WINDOW_SIZE"Indicates the sender's initial window size (in octets) for stream-level flow control. The initial value is 2^16-1 (65,535) octets.This setting affects the window size of all streams (see Section 6.9.2).Values above the maximum flow-control window size of 2^31-1 MUST be treated as a connection error (Section 5.4.1) of type FLOW_CONTROL_ERROR."	^65535</body><body package="Protocols-Http2">SETTINGS_MAX_CONCURRENT_STREAMS"Indicates the maximum number of concurrent streams that the sender will allow. This limit is directional: it applies to the number of streams that the sender permits the receiver to create. Initially, there is no limit to this value. It is recommended that this value be no smaller than 100, so as to not unnecessarily limit parallelism."	^100</body><body package="Protocols-Http2">SETTINGS_MAX_FRAME_SIZE"This setting can have any value between 2^14 (16,384) and 2^24-1 (16,777,215) octets, inclusive.All implementations MUST be capable of receiving and minimally processing frames up to 2^14 octets in length "	^16777215</body><body package="Protocols-Http2">SETTINGS_MAX_HEADER_LIST_SIZE"This advisory setting informs a peer of the maximum size of header list that the sender is prepared to accept, in octets. The value is based on the uncompressed size of header fields, including the length of the name and value in octets plus an overhead of 32 octets for each header field.For any given request, a lower limit than what is advertised MAY be enforced. The initial value of this setting is unlimited"	^nil</body><body package="Protocols-Http2">SETTINGS_MAX_WINDOW_SIZE"Indicates the sender's initial window size (in octets) for stream-level flow control. The initial value is 2^16-1 (65,535) octets.This setting affects the window size of all streams (see Section 6.9.2).Values above the maximum flow-control window size of 2^31-1 (2,147,483,647) MUST be treated as a connection error (Section 5.4.1) of type FLOW_CONTROL_ERROR."	^2147483647</body></methods><methods><class-id>Protocols.SettingsFrame class</class-id> <category>instance creation</category><body package="Protocols-Http2">acknowledge	^self new		setACK;		yourself</body><body package="Protocols-Http2">default	^self new 		maxConcurrentStreams: self SETTINGS_MAX_CONCURRENT_STREAMS; 		yourself</body><body package="Protocols-Http2">type	^4</body></methods><methods><class-id>Protocols.HTTP2Stream</class-id> <category>state</category><body package="Protocols-Http2">setClosed	self isReleased ifFalse: [ state := #closed ].</body><body package="Protocols-Http2">setHalfClosedLocal	self isClosed ifFalse: [ state := #half_closed_local ]</body><body package="Protocols-Http2">setHalfClosedRemote	self isClosed ifFalse: [  state := #half_closed_remote ]</body><body package="Protocols-Http2">setIdle	state := #idle</body><body package="Protocols-Http2">setOpen	state := #open</body><body package="Protocols-Http2">setReleased	state := #released</body></methods><methods><class-id>Protocols.HTTP2Stream</class-id> <category>accessing</category><body package="Protocols-Http2">authority	^authority</body><body package="Protocols-Http2">dataBytesSent	^dataBytesSent == nil		ifTrue: [0]		ifFalse: [ dataBytesSent ]</body><body package="Protocols-Http2">dataBytesSent: aNumber	dataBytesSent := aNumber</body><body package="Protocols-Http2">flowControlWindow	^flowControlWindow</body><body package="Protocols-Http2">get	^ inputDataStream get</body><body package="Protocols-Http2">headers	^headers</body><body package="Protocols-Http2">hpackDecoder	^self multiplexer hpackDecoder</body><body package="Protocols-Http2">hpackEncoder	^self multiplexer hpackEncoder</body><body package="Protocols-Http2">httpMessage	^httpMessage</body><body package="Protocols-Http2">id	^id</body><body package="Protocols-Http2">id: anInteger	id := anInteger</body><body package="Protocols-Http2">localMaxFrameSize	^ self multiplexer localSettings maxFrameSizeValue</body><body package="Protocols-Http2">method	^method</body><body package="Protocols-Http2">multiplexer	^multiplexer</body><body package="Protocols-Http2">outputWindowSize	^ self multiplexer protocolVersion settings outputWindowSize</body><body package="Protocols-Http2">path	^path</body><body package="Protocols-Http2">pseudoHeaderFields	^self subclassResponsibility</body><body package="Protocols-Http2">pushMethod	^self class pushMethod</body><body package="Protocols-Http2">read: anInteger	^ inputDataStream read: anInteger</body><body package="Protocols-Http2">remoteAvailable	^ self flowControlWindow remoteAvailable</body><body package="Protocols-Http2">remoteMaxFrameSize	^ self multiplexer remoteSettings maxFrameSizeValue</body><body package="Protocols-Http2">scheme	^scheme</body><body package="Protocols-Http2">serverName	^authority 		ifNil: [ String new ]		ifNotNil: [ (authority tokensBasedOn: $: ) first ]</body><body package="Protocols-Http2">state	^state</body><body package="Protocols-Http2">trailerFields	^(self headers select: [ :h | h first = 'trailer']) collect: [ :arr | arr last]</body><body package="Protocols-Http2">trailerHeader	^trailerHeader</body></methods><methods><class-id>Protocols.HTTP2Stream</class-id> <category>testing</category><body package="Protocols-Http2">canAcceptData	^false</body><body package="Protocols-Http2">canAcceptTrailer	^self trailerHeader isNil and: [self isOpen]</body><body package="Protocols-Http2">hasTrailer	^self headers anySatisfy: [:h | h first = 'trailer']</body><body package="Protocols-Http2">isClosed	^self state = #closed		or: [self isReleased ]</body><body package="Protocols-Http2">isEndOfHeader	^ endOfHeaders</body><body package="Protocols-Http2">isHalfClosedLocal	^self state = #half_closed_local</body><body package="Protocols-Http2">isHalfClosedRemote	^self state = #half_closed_remote</body><body package="Protocols-Http2">isIdle	^self state = #idle</body><body package="Protocols-Http2">isOpen	^self state = #open</body><body package="Protocols-Http2">isPushed	^id even</body><body package="Protocols-Http2">isReceivingHeaders	^false</body><body package="Protocols-Http2">isReleased	^self state = #released</body></methods><methods><class-id>Protocols.HTTP2Stream</class-id> <category>private read</category><body package="Protocols-Http2">closing: aBlock	^(Xtreams.PositionReadSubstream on: inputDataStream)		closeBlock: aBlock;		yourself</body><body package="Protocols-Http2">encoding: aSymbol	^inputDataStream encoding: aSymbol</body><body package="Protocols-Http2">ending: aSymbol	^inputDataStream ending: aSymbol</body><body package="Protocols-Http2">limiting: aNumber	^inputDataStream limiting: aNumber</body></methods><methods><class-id>Protocols.HTTP2Stream</class-id> <category>dispatching process</category><body package="Protocols-Http2">dispatchMessage	self subclassResponsibility</body><body package="Protocols-Http2">startDispatching	dispatchProcess == nil ifFalse: [^self].		dispatchProcess := [		[self dispatchMessage]			on: Error			do: [ :ex | 				"Could be an HTTP2Error, an application error or an error writting Http response"				self multiplexer handleError: ex].		] fork.	self multiplexer isLogging ifTrue: [		dispatchProcess name: self class name, ':', self id printString, ' ', self multiplexer connection printString].</body></methods><methods><class-id>Protocols.HTTP2Stream</class-id> <category>processing frames</category><body package="Protocols-Http2">processCONTINUATION: aContinuationFrame	self readHeaderBlockFragment: aContinuationFrame</body><body package="Protocols-Http2">processDATA: aDataFrame	inputDataSize := inputDataSize + aDataFrame dataSize.	contentLength == nil ifFalse: [		"8.1.2.6 Malformed Requests and Responses. A request or response is malformed if the value of a content-length header field does not equal the sum of the DATA frame payload lengths that form the body"		(inputDataSize &gt; contentLength 			or: [aDataFrame endOfStream and: [inputDataSize ~= contentLength ]])			ifTrue: [^HTTP2StreamError protocolError: self id errorString: (#DATAContentLengthNotEqualPayloadSize &lt;&lt; #protocols &gt;&gt; 'Processing DATA: The value of content-length header field does not equal the sum of the DATA frame payload lengths that form the body')]].		self ensureInputDataStream.		aDataFrame endOfStream ifTrue: [ self receivedEOS ].		inputDataStream write: aDataFrame data endOfStream: aDataFrame endOfStream.</body><body package="Protocols-Http2">processHEADERS: aHeaderFrame	aHeaderFrame endOfStream ifTrue: [self receivedEOS].	inputHeadersStream := HTTP2FrameReadStream on: self multiplexer newRecycledFrameBuffer.	self readHeaderBlockFragment: aHeaderFrame.	self hpackDecoder on: inputHeadersStream.	self startDispatching</body><body package="Protocols-Http2">processWINDOW_UPDATE: aNumber	self flowControlWindow processWINDOW_UPDATE: aNumber.</body></methods><methods><class-id>Protocols.HTTP2Stream</class-id> <category>initialize-release</category><body package="Protocols-Http2">close	| diff |	self isReleased ifTrue: [^nil].	self setReleased.	self isPushed ifFalse: [ self multiplexer decreaseActiveStreams ].			"Return connection-level flow control when a stream is closed with buffered data not read by the user"	self multiplexer protocolVersion ifNotNil: [		(diff := self multiplexer localSettings initialWindowSizeValue - self flowControlWindow localAvailable) &gt; 0			ifTrue: [self sendWindowUpdateWith: diff]].			outputDataStream ifNotNil: [ 		outputDataStream recycle.		outputDataStream := nil ].		inputHeadersStream ifNotNil: [ 		inputHeadersStream setEndOfStream.		inputHeadersStream recycleWith: self multiplexer.		inputHeadersStream := nil ].	inputDataStream ifNotNil: [ 		inputDataStream  setEndOfStream.		inputDataStream recycleWith: self multiplexer.		inputDataStream := nil ].		trailerHeader := nil.	trailerHeaders := nil.		headers := nil.	Processor activeProcess == dispatchProcess ifTrue: [ ^ self ].		dispatchProcess ifNotNil: [		dispatchProcess terminate.		dispatchProcess := nil ].</body><body package="Protocols-Http2">closeRstStreamFrame: aFrame	self subclassResponsibility</body><body package="Protocols-Http2">initialize	endOfHeaders := false.	inputDataSize := 0.	self setIdle.	headers := OrderedCollection new.</body><body package="Protocols-Http2">initialize: streamId with:  anHTTP2Multiplexer 	multiplexer := anHTTP2Multiplexer.	id := streamId.	flowControlWindow := multiplexer flowControlWindow asStreamWindow: self</body></methods><methods><class-id>Protocols.HTTP2Stream</class-id> <category>write output</category><body package="Protocols-Http2">createOutputDataStream	^self subclassResponsibility</body><body package="Protocols-Http2">getDataFrameLimited: anInteger do: aBlock	| dataSize |	dataSize := outputDataStream getDataFrameLimited: anInteger do: aBlock.	self flowControlWindow reduceRemoteAvailableBy: dataSize.</body><body package="Protocols-Http2">headerFramesDo: aBlock		^self subclassResponsibility</body><body package="Protocols-Http2">readyToSendData	^self subclassResponsibility</body><body package="Protocols-Http2">sendHeadersOnly		^self multiplexer remoteSettings initialWindowSizeValue = 0 		or: [self httpMessage notNil and: [self httpMessage hasBody not]]</body><body package="Protocols-Http2">signalMoreData</body><body package="Protocols-Http2">writeFrames	^self subclassResponsibility</body><body package="Protocols-Http2">writeFramesFrom: anHttpEntity	httpMessage := anHttpEntity.	self multiplexer logAnnounce: [HTTPResponseAnnouncement stream: self].	self writeFrames.	^self dataBytesSent</body><body package="Protocols-Http2">writeHeaders: headerColl do: aBlock onFrame: aBlock1	"When transmitted over a connection, a header list is serialized into a header block using HTTP header compression. The serialized header block is then divided into one or more octet sequences, called header block fragments, and transmitted within the payload.Header blocks MUST be transmitted as a contiguous sequence of frames, with no interleaved frames of any other type or from any other stream. "	| writeStream stream |	writeStream := HTTP2HeadersWriteStream on: self onFrame: aBlock1.	self hpackEncoder do: 			[headerColl do: 					[:header |					stream := ByteArray new writing encoding: #ISO8859_1.					aBlock value: header value: stream.					self hpackEncoder						writeFieldNamed: header name						value: stream conclusion						on: writeStream]].	writeStream close.		self setHalfClosedLocal.</body></methods><methods><class-id>Protocols.HTTP2Stream</class-id> <category>logging</category><body package="Protocols-Http2">debug: aString	self multiplexer debug: aString</body></methods><methods><class-id>Protocols.HTTP2Stream</class-id> <category>read input</category><body package="Protocols-Http2">sendWindowUpdateWith: aNumber		"For the connection."	self multiplexer queueFrame: ((WindowUpdateFrame streamId: 0)								windowSizeIncrement: aNumber;								yourself ).	self isClosed ifTrue: [^self].		"stream"	self multiplexer queueFrame: ((WindowUpdateFrame streamId: self id)								windowSizeIncrement: aNumber;								yourself ) .</body></methods><methods><class-id>Protocols.HTTP2Stream</class-id> <category>announcements</category><body package="Protocols-Http2">announce: aString	self multiplexer announce: aString</body></methods><methods><class-id>Protocols.HTTP2Stream</class-id> <category>printing</category><body package="Protocols-Http2">printIdState	^self id printString, ' ', state printString</body><body package="Protocols-Http2">printOn: aStream	aStream nextPutAll: self class name, ':', self printIdState.	endOfHeaders ifTrue: [ aStream nextPutAll: ' EOH' ].	(self headers notNil and: [self headers notEmpty]) ifTrue: [ 		aStream nextPutAll: ' Headers: '.		self headers printOn: aStream].</body></methods><methods><class-id>Protocols.HTTP2Stream</class-id> <category>parsing headers</category><body package="Protocols-Http2">anyPseudoHeaderNil	^true</body><body package="Protocols-Http2">anyRequestPseudoHeaderNil"All HTTP/2 requests MUST include exactly one valid value for the :method, :scheme, and :path pseudo-header fields, unless it is a CONNECT request. An HTTP request that omits mandatory pseudo-header fields is malformed.Malformed requests or responses that are detected MUST be treated as a stream error (Section 5.4.2) of type PROTOCOL_ERROR."		^( method == nil		or: [ path == nil			or: [ scheme == nil ]])</body><body package="Protocols-Http2">authority: aString	authority == nil ifFalse: [		^self streamProtocolError: (#ReceivedDuplicateAuthority &lt;&lt; #protocols &gt;&gt;  'Received duplicate :authority') ].		authority := aString</body><body package="Protocols-Http2">decodeHeader	| field fieldName |	[inputHeadersStream atEnd] whileFalse: 			[field := self readHeaderFieldFrom: inputHeadersStream.			(self pseudoHeaderFields includes: field first)				ifTrue: 					[fieldName := field first copyFrom: 2 to: field first size.					self perform: (fieldName , ':') asSymbol with: field last]				ifFalse: 					[(field first first = $: or: [self anyPseudoHeaderNil])						ifTrue: 							["Pseudo-header but not mine, or invalid, or mine are not set "							^self streamProtocolError: (#PseudoHeaderError &lt;&lt; #protocols &gt;&gt; 'Decoding HEADERS: Pseudo-header error')].					self headers add: field]].				self validateHeaders.	self headersDone</body><body package="Protocols-Http2">decodeTrailer	"optionally, one HEADERS frame, followed by zero or more CONTINUATION frames containing the trailer-part, if present (see [RFC7230], Section 4.1.2)."	| field trailerStream |	trailerHeaders ifNotNil: [^trailerHeaders ].	trailerHeaders := OrderedCollection new.	trailerStream := HTTP2FrameReadStream on: self multiplexer newRecycledFrameBuffer.	[		trailerStream write: self trailerHeader headerBlockFragment endOfStream: true.		self hpackDecoder on: trailerStream.				[field := self readHeaderFieldFrom: trailerStream.		field notNil]			whileTrue: [trailerHeaders add: field].	] ensure: [ trailerStream recycleWith: self multiplexer ].	^trailerHeaders</body><body package="Protocols-Http2">ensureInputDataStream"	This method should only be sent within the 'multiplexer' process, not the 'stream' process, otherwise there is a potential race condition."	inputDataStream == nil ifFalse: [^self].		inputDataStream := HTTP2FrameReadStream on: self multiplexer newRecycledDATABuffer.	inputDataStream onReading: 		[:number |		self flowControlWindow increaseLocalAvailableBy: number.		self sendWindowUpdateWith: number].	inputDataStream		onWriting: [:number | flowControlWindow reduceLocalAvailableBy: number]</body><body package="Protocols-Http2">headersDone"	Headers are done. Subclasses must implement."	self subclassResponsibility</body><body package="Protocols-Http2">method: aString"By convention, standardized methods are defined in all-uppercase US-ASCII letters.http://httpwg.org/specs/rfc7231.html#method.overview "	method == nil ifFalse: [		^self streamProtocolError: (#ReceivedDuplicateMethod &lt;&lt; #protocols &gt;&gt;  'Received duplicate :method' )].		method := aString</body><body package="Protocols-Http2">path: aString" Malformed requests or responses that are detected MUST be treated as a stream error  of type PROTOCOL_ERROR. :path MUST NOT be empty for http or https URIs; http or https URIs that do not contain a path component MUST include a value of '/'."	path == nil ifFalse: [		^self streamProtocolError: (#ReceivedDuplicatePath &lt;&lt; #protocols &gt;&gt; 'Received duplicate :path') ].		(aString size = 0 		or: [ aString size =1 				and: [ (aString at: 1) ~= $/ ]]) ifTrue: [		^self streamProtocolError: (#ReceivedWrongPath &lt;&lt; #protocols &gt;&gt; 'Received wrong :path') ].		path := aString</body><body package="Protocols-Http2">readHeaderBlockFragment: aFrame	aFrame endOfHeaders ifTrue: [ self setEndOfHeaders ].	inputHeadersStream 		write: aFrame headerBlockFragment 		endOfStream: endOfHeaders.</body><body package="Protocols-Http2">readHeaderFieldFrom: aStream	| field |	[		field := self hpackDecoder readFieldFrom: aStream.	] 		on: Error		do: [:error | ^HTTP2ConnectionError compressionError: error errorString].			field first		do: [:ch | ch isUppercase ifTrue: [				^self streamProtocolError: (#HEADERSFieldNameNotLowerCase &lt;&lt; #protocols &gt;&gt; 'Decoding HEADERS: The header field name is not in a lower case' )]].	"8.1.2.2 Connection-Specific Header Fields"	((field first first = $: and: [self headers size &gt; 0]) or: 			[field first = 'connection'				or: [field first = 'te' and: [field last ~= 'trailers']]])		ifTrue: 			["Pseudo-header in the middle of regular fields.			HTTP/2 does not use the Connection header field to indicate connection-specific header fields.			TE header field MAY be present in an HTTP/2 request; when it is, it MUST NOT contain any value other than trailers"			^self streamProtocolError: (#HEADERSProblemConnectionSpecificField &lt;&lt; #protocols &gt;&gt; 'Decoding HEADERS: There is a problem with Connection-Specific Header Fields')].				field first = 'content-length'		ifTrue: 			[contentLength := (field at: 2) asNumber.			"There is possible received DATA frame. Check if the data size exceed the content length"			inputDataSize &gt; contentLength				ifTrue: [^self streamProtocolError: (#DATAContentLengthExceedPayloadSize &lt;&lt; #protocols &gt;&gt; 'The DATA size exceed the content-length value' )]].	^field</body><body package="Protocols-Http2">receivedEOS	self setHalfClosedRemote.</body><body package="Protocols-Http2">scheme: aString	scheme == nil ifFalse: [		^self streamProtocolError: (#ReceivedDuplicateScheme &lt;&lt; #protocols &gt;&gt;  'Received duplicate :scheme' )].		('https' ~= aString		and: [ 'http' ~= aString]) 		ifTrue: [^self streamProtocolError: ((#ReceivedUnknownScheme &lt;&lt; #protocols &gt;&gt; 'Received unknown :scheme &lt;1s&gt;') expandMacrosWith: scheme printString)].		scheme := aString.</body><body package="Protocols-Http2">setEndOfHeaders	endOfHeaders := true</body><body package="Protocols-Http2">streamProtocolError: aString	^HTTP2StreamError 		protocolError: self id 		errorString: aString</body><body package="Protocols-Http2">trailerHeader: aHeadersFrame	trailerHeader := aHeadersFrame.	"EOS flag is already checked in multiplexer"	self receivedEOS.	inputDataStream ifNotNil: [inputDataStream setEndOfStream].</body><body package="Protocols-Http2">validateHeaders</body><body package="Protocols-Http2">validateRequestHeaders"All HTTP/2 requests MUST include exactly one valid value for the :method, :scheme, and :path pseudo-header fields, unless it is a CONNECT request. An HTTP request that omits mandatory pseudo-header fields is malformed.Malformed requests or responses that are detected MUST be treated as a stream error (Section 5.4.2) of type PROTOCOL_ERROR."		(method == nil		or: [path == nil			or: [scheme == nil ]]) 		ifTrue: [			^self streamProtocolError: (#MissingRequiredPseudoHeader &lt;&lt; #protocols &gt;&gt; 'Decoding HEADERS: Missing a required pseudo-header') ].</body></methods><methods><class-id>Protocols.HTTP2Stream class</class-id> <category>instance creation</category><body package="Protocols-Http2">initialize: streamId with: anHTTP2Multiplexer 	^self new 		initialize: streamId with: anHTTP2Multiplexer ;		yourself</body><body package="Protocols-Http2">new	^self basicNew initialize</body></methods><methods><class-id>Protocols.HTTP2Stream class</class-id> <category>accessing</category><body package="Protocols-Http2">pushMethod	^'GET'</body><body package="Protocols-Http2">requestPseudoHeaders	^RequestPseudoHeaders ifNil: [ RequestPseudoHeaders := #( ':method' ':scheme' ':authority' ':path')  ]</body><body package="Protocols-Http2">responsePseudoHeaders	^ResponsePseudoHeaders ifNil: [ ResponsePseudoHeaders := #( ':status' ) ]</body></methods><methods><class-id>Protocols.DebugAnnouncement</class-id> <category>accessing</category><body package="Protocols-Http2">direction	^'**'</body></methods><methods><class-id>Protocols.RstStreamFrame</class-id> <category>accessing</category><body package="Protocols-Http2">errorCode	^errorCode</body><body package="Protocols-Http2">errorCode: anInteger	errorCode := anInteger</body></methods><methods><class-id>Protocols.RstStreamFrame</class-id> <category>delegation</category><body package="Protocols-Http2">processWith: aMultiplexer	aMultiplexer processRST_STREAM: self</body></methods><methods><class-id>Protocols.RstStreamFrame</class-id> <category>initialize-release</category><body package="Protocols-Http2">streamId: aNumber errorCode: anInteger	errorCode := anInteger.	streamId := aNumber</body></methods><methods><class-id>Protocols.RstStreamFrame</class-id> <category>testing</category><body package="Protocols-Http2">isRstStream	^true</body></methods><methods><class-id>Protocols.RstStreamFrame</class-id> <category>writing</category><body package="Protocols-Http2">calculateLength	^4</body><body package="Protocols-Http2">writePayloadOn: aStream" Error Code (32)   "	aStream putUint32: errorCode</body></methods><methods><class-id>Protocols.RstStreamFrame</class-id> <category>printing</category><body package="Protocols-Http2">description	^HTTP2Multiplexer errorDescription: errorCode</body><body package="Protocols-Http2">printOn: aStream	super printOn: aStream.	aStream nextPutAll: self description.</body></methods><methods><class-id>Protocols.RstStreamFrame</class-id> <category>parsing</category><body package="Protocols-Http2">readPayloadFrom: aStream" Error Code (32)   "	"A RST_STREAM frame with a length other than 4 octets MUST be treated as a stream error of type FRAME_SIZE_ERROR"	length ~= 4 ifTrue: [		aStream read: length.		^HTTP2ConnectionError frameSizeError: (#RST_STREAMHasLengthNot4 &lt;&lt; #protocols &gt;&gt; 'RST_STREAM frame length is not 4 octets')].	errorCode := aStream getUint32.</body></methods><methods><class-id>Protocols.RstStreamFrame class</class-id> <category>instance creation</category><body package="Protocols-Http2">streamId: aNumber errorCode: anInteger	^(self new)		streamId: aNumber errorCode: anInteger;		yourself</body><body package="Protocols-Http2">type	^3</body></methods><methods><class-id>Protocols.HPACKEncoder</class-id> <category>writing</category><body package="Protocols-Http2">writeDynamicTableMaxSize: anInteger on: aStream	self		writeLength: anInteger		prefix: #(0 0 1)		on: aStream</body><body package="Protocols-Http2">writeFieldNamed: fieldName value: valueString on: aStream	tableSizeUpdate		ifTrue: 			[self writeDynamicTableMaxSize: dynamicTableSize on: aStream.			tableSizeUpdate := false].	(self neverIndexedFields detect: [:str | str = fieldName] ifNone: [nil])		ifNotNil: 			[^self writeLiteralNeverIndexed: fieldName value: valueString on: aStream].	(self findIndexFor: fieldName value: valueString)		ifNotNil: 			[:assoc |			assoc value				ifNil: [self writeIndexed: assoc key on: aStream]				ifNotNil: 					[self						writeLiteral: fieldName						indexed: assoc key						value: assoc value						on: aStream]]		ifNil: 			[self				writeLiteral: fieldName				indexed: 0				value: valueString				on: aStream]</body><body package="Protocols-Http2">writeIndexed: anInteger on: aStream	"| 1 |        Index (7+)  "	self		writeLength: anInteger		prefix: #(1)		on: aStream</body><body package="Protocols-Http2">writeLiteral: fieldName indexed: anInteger value: valueString on: aStream	"Let's write indexed all literals until we don't exceed the dynamic table max size"	| shouldIndex prefix |	shouldIndex := fieldName size + valueString size + 32				+ self dynamicTableSize &lt;= dynamicTableAllowedSize.	prefix := shouldIndex ifTrue: [#(0 1)] ifFalse: [#(0 0 0 0)].	self writeLength: anInteger prefix: prefix on: aStream.	anInteger = 0 ifTrue: [self writeLiteral: fieldName on: aStream].	self writeLiteral: valueString on: aStream.	shouldIndex		ifTrue: [self dynamicTableAdd: (Array with: fieldName with: valueString)]</body><body package="Protocols-Http2">writeLiteralNeverIndexed: fieldString value: valueString on: aStream	self		writeLiteral: fieldString		value: valueString		prefix: #(0 0 0 1)		on: aStream</body><body package="Protocols-Http2">writeLiteralWithoutIndexing: fieldString value: valueString on: aStream	self		writeLiteral: fieldString		value: valueString		prefix: #(0 0 0 0)		on: aStream</body></methods><methods><class-id>Protocols.HPACKEncoder</class-id> <category>testing</category><body package="Protocols-Http2">useHuffmanCode: valueString	"Force encoding for all literals "	UseHuffmanCoding ifTrue: [ ^true].	"Optimize encoding. Do it only if the encoded values has smaller size"	^(self huffmanCodeLenFor: valueString) &lt; valueString size</body></methods><methods><class-id>Protocols.HPACKEncoder</class-id> <category>huffman encoding</category><body package="Protocols-Http2">encodeHuffmanLiteral: aString on: aStream	| bitBuffer bitsInBuffer |	bitBuffer := 02r00000000.	bitsInBuffer := 0.		aString do: [ :char |		(self huffmanEncodingTable at: char asInteger + 1) do: [ :val  | 			bitBuffer := bitBuffer bitAt: 8 - bitsInBuffer put: val.			bitsInBuffer := bitsInBuffer + 1.			bitsInBuffer = 8 				ifTrue: [ aStream write: bitBuffer.						bitBuffer := 02r00000000.						bitsInBuffer := 0]]		].	"Padding"	bitsInBuffer &gt; 0 ifTrue: [		8 - bitsInBuffer to: 1 by: -1 do: [ :i | bitBuffer := bitBuffer bitAt: i put: 1].		aStream write: bitBuffer.	].</body><body package="Protocols-Http2">huffmanCodeLenFor: aString	| len |	len :=   0.	aString do: [ :char | len := len + (self huffmanEncodingTable at: char asInteger + 1) size ].	^(len + 7) // 8</body></methods><methods><class-id>Protocols.HPACKEncoder</class-id> <category>private write</category><body package="Protocols-Http2">findInDynamicTable: fieldString value: valString	self dynamicTable doWithIndex: [ :val :ind | 		(val first = fieldString and: [val last = valString]) ifTrue: ["Encode as indexed" ^61 + ind -&gt; nil ]].	^nil</body><body package="Protocols-Http2">findInStaticTable: fieldString value: valString	^(self staticEncodingTable at: fieldString ifAbsent: [ nil ]) ifNotNil: [ :val | 		(val detect: [ :assoc | assoc value = valString ]  ifNone: [nil]) 			ifNotNil: [ :assoc | 				"Got both field name and value. Encode as indexed"				assoc key -&gt; nil]			ifNil: ["Key is found but value no" 				( self findInDynamicTable: fieldString value: valString)					ifNil: ["Encode as indexed-&gt;literal"						 val first key -&gt; valString ]]].</body><body package="Protocols-Http2">findIndexFor: fieldString value: stringOrByteArray" stringOrByteArray as a string is used for testing mostly. Decoding/encoding http messages from a socket stream uses bytes "	^(self findInStaticTable: fieldString value: stringOrByteArray asByteArray)		ifNil: [self findInDynamicTable: fieldString value: stringOrByteArray asByteArray ]</body><body package="Protocols-Http2">writeLength: anInteger prefix: bits on: aStream	| octet max |	max := (2 raisedTo: 8 - bits size) - 1.	octet := anInteger &lt; max ifTrue: [anInteger] ifFalse: [02r11111111].	bits doWithIndex: [:b :i | octet := octet bitAt: 9 - i put: b].	aStream write: octet.	anInteger &lt; max ifTrue: [^self].	octet := anInteger - max.	[octet &gt;= 128] whileTrue: 			[aStream write: ((octet bitAnd: 02r01111111) bitAt: 8 put: 1).			octet := octet bitShift: -7].	aStream write: octet</body><body package="Protocols-Http2">writeLiteral: valueString on: aStream	"Use Huffman encoding if it produces a shorter byte string "	| prefix stream val |	(self useHuffmanCode: valueString)		ifTrue: 			[prefix := #(1).			stream := ByteArray new writing.			self encodeHuffmanLiteral: valueString on: stream.			val := stream contents]		ifFalse: 			[prefix := #(0).			val := ByteArray new: valueString size.			valueString doWithIndex: [:c :i | val at: i put: c asInteger]].	self		writeLength: val size		prefix: prefix		on: aStream.	aStream write: val</body><body package="Protocols-Http2">writeLiteral: fieldString value: valueString prefix: anArray on: aStream	| sz |	sz := (self findIndexFor: fieldString value: valueString)				ifNotNil: [:assoc | assoc key]				ifNil: [0].	self writeLength: sz prefix: anArray on: aStream.	sz = 0 ifTrue: [self writeLiteral: fieldString on: aStream].	self writeLiteral: valueString on: aStream</body></methods><methods><class-id>Protocols.HPACKEncoder</class-id> <category>accessing</category><body package="Protocols-Http2">huffmanEncodingTable	^self class huffmanEncodingTable</body><body package="Protocols-Http2">neverIndexedFields	^self class neverIndexedFields</body></methods><methods><class-id>Protocols.HPACKEncoder</class-id> <category>initialize-release</category><body package="Protocols-Http2">initialize	super initialize.	tableSizeUpdate := false</body><body package="Protocols-Http2">updateDynamicTableSize: aNumber	tableSizeUpdate := true.	dynamicTableSize := dynamicTableAllowedSize min: aNumber</body></methods><methods><class-id>Protocols.HPACKEncoder class</class-id> <category>class initialization</category><body package="Protocols-Http2">initialize	UseHuffmanCoding := false</body></methods><methods><class-id>Protocols.HPACKEncoder class</class-id> <category>defaults</category><body package="Protocols-Http2">neverIndexedFieldsDefaultValue	^#()</body></methods><methods><class-id>Protocols.HPACKEncoder class</class-id> <category>accessing</category><body package="Protocols-Http2">neverIndexedFields	^neverIndexedFields ifNil: [ neverIndexedFields := self neverIndexedFieldsDefaultValue ]</body><body package="Protocols-Http2">neverIndexedFields: anArray	neverIndexedFields := anArray</body></methods><methods><class-id>Protocols.HTTPResponseAnnouncement</class-id> <category>accessing</category><body package="Protocols-Http2">description	|  digest  |	^description ifNil: [		digest := stream httpMessage printString.		description := 'Sending response from Stream id: ', stream id printString, ' ', (digest copyFrom: 1 to: (digest size min: ResponseDigestSize)).]</body><body package="Protocols-Http2">direction	^' --&gt; '</body></methods><methods><class-id>Protocols.HTTPResponseAnnouncement</class-id> <category>initialize-release</category><body package="Protocols-Http2">stream: anHTTP2Stream	stream := anHTTP2Stream</body></methods><methods><class-id>Protocols.HTTPResponseAnnouncement class</class-id> <category>accessing</category><body package="Protocols-Http2">responseDigestSize	^ResponseDigestSize</body><body package="Protocols-Http2">responseDigestSize:  aNumber	ResponseDigestSize := aNumber</body></methods><methods><class-id>Protocols.HTTPResponseAnnouncement class</class-id> <category>instance creation</category><body package="Protocols-Http2">stream: anHTTP2Stream	^self new		stream: anHTTP2Stream;		yourself</body></methods><methods><class-id>Protocols.PushPromiseFrame</class-id> <category>delegation</category><body package="Protocols-Http2">processWith: aMultiplexer	aMultiplexer processPUSH_PROMISE: self</body></methods><methods><class-id>Protocols.PushPromiseFrame</class-id> <category>accessing</category><body package="Protocols-Http2">beEndOfStream	^self shouldNotImplement</body><body package="Protocols-Http2">beNotEndOfStream 		^self shouldNotImplement</body><body package="Protocols-Http2">promisedStreamId	^promisedStreamId</body><body package="Protocols-Http2">promisedStreamId: anInteger	promisedStreamId := anInteger</body><body package="Protocols-Http2">setEndOfStream: aBoolean	^self shouldNotImplement</body></methods><methods><class-id>Protocols.PushPromiseFrame</class-id> <category>writing</category><body package="Protocols-Http2">dataSize	^super dataSize + 4  " promised stream id "</body><body package="Protocols-Http2">writePayloadOn: aStream" |Pad Length? (8)| +-+-------------+-----------------------------------------------+ |R|                  Promised Stream ID (31)                    | +-+-----------------------------+-------------------------------+ |                   Header Block Fragment (*)                 ... +---------------------------------------------------------------+ |                           Padding (*)    "	self 		writePaddedPayloadOn: aStream 		do: [ :stream | 			stream putUint31: promisedStreamId firstBit: 0.			self writeHeaderBlockOn: stream]</body></methods><methods><class-id>Protocols.PushPromiseFrame</class-id> <category>parsing</category><body package="Protocols-Http2">readPayloadFrom: aStream"  |Pad Length? (8)| +-+-------------+-----------------------------------------------+ |R|                  Promised Stream ID (31)                    | +-+-----------------------------+-------------------------------+ |                   Header Block Fragment (*)                 ... +---------------------------------------------------------------+ |                           Padding (*)       "	self 		readPaddedPayloadFrom: aStream 		do: [ :stream :padLength |			promisedStreamId := aStream getUint31 value.			self readHeaderBlockFrom: aStream limiting: length - padLength - 4]</body></methods><methods><class-id>Protocols.PushPromiseFrame</class-id> <category>testing</category><body package="Protocols-Http2">endOfStream	^self shouldNotImplement</body><body package="Protocols-Http2">isContinuation	^false</body></methods><methods><class-id>Protocols.PushPromiseFrame</class-id> <category>printing</category><body package="Protocols-Http2">printOn: aStream	aStream nextPutAll: self class name.	self printFrameHeadOn: aStream.	aStream nextPutAll: ' promisedStreamId: ', self promisedStreamId printString.	self endOfHeaders ifTrue: [aStream nextPutAll: ' EOH ' ].</body></methods><methods><class-id>Protocols.PushPromiseFrame class</class-id> <category>instance creation</category><body package="Protocols-Http2">type	^5</body></methods><methods><class-id>Protocols.HTTPv20</class-id> <category>accessing</category><body package="Protocols-Http2">multiplexer	^multiplexer</body><body package="Protocols-Http2">multiplexer: aMultiplexer	multiplexer := aMultiplexer</body><body package="Protocols-Http2">settingsFrame	^self settings settingsFrame</body><body package="Protocols-Http2">settingsFrame: aSettingsFrame	self settings settingsFrame: aSettingsFrame</body></methods><methods><class-id>Protocols.HTTPv20</class-id> <category>initialize-release</category><body package="Protocols-Http2">closingConnection	multiplexer ifNotNil: [ multiplexer stop ]</body><body package="Protocols-Http2">initializeSettings	settings := HTTP2Settings new</body></methods><methods><class-id>Protocols.HTTPv20</class-id> <category>testing</category><body package="Protocols-Http2">isHTTPv20	^true</body></methods><methods><class-id>Protocols.HTTP2FlowControlWindow</class-id> <category>accessing</category><body package="Protocols-Http2">connectionWindow	^connectionWindow		ifNil: [ self ]		ifNotNil: [ connectionWindow connectionWindow ]</body><body package="Protocols-Http2">connectionWindow: aFlowControlWindow	connectionWindow := aFlowControlWindow.	localAvailable := connectionWindow localAvailable.	remoteAvailable := connectionWindow remoteAvailable.</body><body package="Protocols-Http2">flowControlError: aString	^stream		ifNil: [HTTP2ConnectionError flowControlError: aString]		ifNotNil: [HTTP2StreamError flowControlError: stream id errorString: aString]</body><body package="Protocols-Http2">increaseLocalAvailableBy: aNumber	localAvailable := localAvailable + aNumber.	connectionWindow ifNotNil: [connectionWindow increaseLocalAvailableBy: aNumber ]</body><body package="Protocols-Http2">localAvailable	^localAvailable</body><body package="Protocols-Http2">localAvailable: anInteger	localAvailable := anInteger.</body><body package="Protocols-Http2">processWINDOW_UPDATE: aNumber"	a WINDOW_UPDATE frame specifies the amount by which the remote available size should be increased."	mutex critical: 			[| newAvailable |			newAvailable := self remoteAvailable + aNumber.			newAvailable &gt; SettingsFrame SETTINGS_MAX_WINDOW_SIZE				ifTrue: [^self flowControlError: (#WUSpecifiesAmountBiggerThanSettings &lt;&lt; #protocols &gt;&gt; 'WINDOW_UPDATE frame specifies the amount bigger than SettingsFrame SETTINGS_MAX_WINDOW_SIZE')].			remoteAvailable := newAvailable ]</body><body package="Protocols-Http2">reduceLocalAvailableBy: aNumber	| newAvailable |	newAvailable := localAvailable - aNumber.	newAvailable &lt; 0 ifTrue: [^self flowControlError: (#LocalEvailableIsLessZero &lt;&lt; #protocols &gt;&gt;'Local available reduced to &lt; 0 ')].	localAvailable := newAvailable.	connectionWindow ifNotNil: [connectionWindow reduceLocalAvailableBy: aNumber ]</body><body package="Protocols-Http2">reduceRemoteAvailableBy: aNumber"A change to SETTINGS_INITIAL_WINDOW_SIZE can cause the available space in a flow-control window to become negative. A sender MUST track the negative flow-control window and MUST NOT send new flow-controlled frames until it receives WINDOW_UPDATE frames that cause the flow-control window to become positive."	remoteAvailable := self remoteAvailable - aNumber.	connectionWindow ifNotNil: [connectionWindow reduceRemoteAvailableBy: aNumber ]</body><body package="Protocols-Http2">remoteAvailable	^ remoteAvailable</body><body package="Protocols-Http2">remoteAvailable: aNumber	remoteAvailable := aNumber</body><body package="Protocols-Http2">stream	^stream</body><body package="Protocols-Http2">stream: anHttp2Stream	stream := anHttp2Stream</body><body package="Protocols-Http2">streamId	^stream id</body><body package="Protocols-Http2">streamId: anInteger	stream := anInteger</body></methods><methods><class-id>Protocols.HTTP2FlowControlWindow</class-id> <category>services</category><body package="Protocols-Http2">asStreamWindow: anHttp2Stream	^self class new		connectionWindow: self connectionWindow;		stream: anHttp2Stream;		localAvailable: self localAvailable;		remoteAvailable: self remoteAvailable;		yourself</body></methods><methods><class-id>Protocols.HTTP2FlowControlWindow</class-id> <category>printing</category><body package="Protocols-Http2">printOn: aStream	| type |	type := connectionWindow 				ifNil: ['Connection window']				ifNotNil: ['Stream window'].	aStream 		nextPutAll: type;		nextPutAll: ' remote avail: ', remoteAvailable printString;		nextPutAll: ' local avail: ', localAvailable printString</body></methods><methods><class-id>Protocols.HTTP2FlowControlWindow</class-id> <category>initialize-release</category><body package="Protocols-Http2">initialize	mutex := Semaphore forMutualExclusion.	remoteAvailable := SettingsFrame SETTINGS_INITIAL_WINDOW_SIZE.	localAvailable := SettingsFrame SETTINGS_INITIAL_WINDOW_SIZE</body></methods><methods><class-id>Protocols.HTTP2FlowControlWindow class</class-id> <category>instance creation</category><body package="Protocols-Http2">new	^ super new initialize</body></methods><methods><class-id>Protocols.HTTP2DATAWriteStream</class-id> <category>services</category><body package="Protocols-Http2">checkDestinationSize	self hasFrameToWrite ifTrue: [self readyToSendFrame].	self hasSpaceToWrite ifFalse: [ self wait ].</body><body package="Protocols-Http2">getDataFrameLimited: anInteger do: aBlock	|  fragment  isFinalFrame |	fragment := ByteArray new: (destination readSize min: anInteger).	destination read: fragment size into: fragment at: 1.	http2Stream dataBytesSent: http2Stream dataBytesSent + fragment size.	isFinalFrame := (self hasDataToSend not and: [endOfStream]).	aBlock value: (DataFrame new				streamId: http2Stream id;				data: fragment;				setEndOfStream: isFinalFrame;				yourself).				endOfStream 		ifTrue: [ self hasDataToSend ifTrue: [ http2Stream readyToSendData ] ]		ifFalse: [ http2Stream signalMoreData ].	^fragment size</body><body package="Protocols-Http2">readyToSendFrame	http2Stream readyToSendData.</body><body package="Protocols-Http2">signal	writingLock signal</body><body package="Protocols-Http2">wait	writingLock wait.</body></methods><methods><class-id>Protocols.HTTP2DATAWriteStream</class-id> <category>initialize-release</category><body package="Protocols-Http2">newDestinationBuffer	^http2Stream multiplexer newRecycledOutputBuffer</body><body package="Protocols-Http2">on: anHTTP2Stream	super on: anHTTP2Stream.	writingLock := Semaphore new.</body></methods><methods><class-id>Protocols.HTTP2DATAWriteStream</class-id> <category>accessing</category><body package="Protocols-Http2">http2DataStream	^ self</body><body package="Protocols-Http2">setEndOfStream	endOfStream := true.	http2Stream readyToSendData</body></methods><methods><class-id>Protocols.HTTP2DATAWriteStream</class-id> <category>private</category><body package="Protocols-Http2">setNoDependencies	http2Stream setNoDependencies</body></methods><methods><class-id>Protocols.HTTP2DATAWriteStream class</class-id> <category>instance creation</category><body package="Protocols-Http2">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Protocols.WindowUpdateFrame</class-id> <category>printing</category><body package="Protocols-Http2">printOn: aStream	super printOn: aStream.	self windowSizeIncrement ifNotNil: [ :n | aStream nextPutAll: ' size increment: '.  n printOn: aStream ].</body></methods><methods><class-id>Protocols.WindowUpdateFrame</class-id> <category>testing</category><body package="Protocols-Http2">isWindowUpdate	^true</body></methods><methods><class-id>Protocols.WindowUpdateFrame</class-id> <category>writing</category><body package="Protocols-Http2">calculateLength	^4</body><body package="Protocols-Http2">writePayloadOn: aStream	aStream putUint31: (self windowSizeIncrement ifNil: [0]) firstBit: 0</body></methods><methods><class-id>Protocols.WindowUpdateFrame</class-id> <category>delegation</category><body package="Protocols-Http2">processWith: aMultiplexer	aMultiplexer processWINDOW_UPDATE: self</body></methods><methods><class-id>Protocols.WindowUpdateFrame</class-id> <category>accessing</category><body package="Protocols-Http2">windowSizeIncrement	^windowSizeIncrement</body><body package="Protocols-Http2">windowSizeIncrement: aNumber	(aNumber &lt; 1 or: [aNumber &gt; 16r7FFFFFFF]) ifTrue: [ self error: (#IlligalWinUpdateIncrement &lt;&lt; #protocols &gt;&gt; 'The legal range for the increment to the flow-control window is 1 to 2,147,483,647 octets ')].	windowSizeIncrement := aNumber</body></methods><methods><class-id>Protocols.WindowUpdateFrame</class-id> <category>parsing</category><body package="Protocols-Http2">readPayloadFrom: aStream" |R|              Window Size Increment (31)   "	"A WINDOW_UPDATE frame with a length other than 4 octets MUST be treated as a connection error (Section 5.4.1) of type FRAME_SIZE_ERROR"	length ~= 4 ifTrue: [HTTP2ConnectionError frameSizeError: (#WINDOW_UPDATEHasLengthNot4 &lt;&lt; #protocols &gt;&gt; 'Received WINDOW_UPDATE frame with a length other than 4 octets')].	windowSizeIncrement := aStream getUint31 value.</body></methods><methods><class-id>Protocols.WindowUpdateFrame class</class-id> <category>instance creation</category><body package="Protocols-Http2">type	^8</body></methods><methods><class-id>Protocols.HTTP2Multiplexer</class-id> <category>accessing</category><body package="Protocols-Http2">ackTimeout	^self protocolVersion settings ackTimeout</body><body package="Protocols-Http2">connection	^ self protocolVersion connection</body><body package="Protocols-Http2">flowControlWindow	^flowControlWindow</body><body package="Protocols-Http2">hpackDecoder	^hpackDecoder</body><body package="Protocols-Http2">hpackEncoder	^hpackEncoder</body><body package="Protocols-Http2">localSettings	^self protocolVersion settingsFrame</body><body package="Protocols-Http2">newReservedStreamFor: aStreamId	^self streams 		at: aStreamId 		ifAbsentPut: [self http2StreamClass initialize: aStreamId with: self].</body><body package="Protocols-Http2">newStreamFor: aStreamId	| stream |	stream := self newReservedStreamFor: aStreamId.	lastStream := stream.	self increaseActiveStreams.	^stream</body><body package="Protocols-Http2">protocolVersion	^protocolVersion</body><body package="Protocols-Http2">readStream	^self connection readStream</body><body package="Protocols-Http2">remoteSettings	^remoteSettings</body><body package="Protocols-Http2">writeStream	^self connection writeStream</body></methods><methods><class-id>Protocols.HTTP2Multiplexer</class-id> <category>logging</category><body package="Protocols-Http2">announce: anAnnouncementOrClass 	anAnnouncementOrClass type: self type.	super announce: anAnnouncementOrClass</body><body package="Protocols-Http2">announcementPrinter	^self class announcementPrinter</body><body package="Protocols-Http2">debug: aString	self logAnnounce: [DebugAnnouncement description: aString]</body><body package="Protocols-Http2">logAnnounce: aBlockClosure"	If I am logging, evaluate aBlockClosure. This would normally be a new instance of an announcement."	self isLogging ifTrue: [self announce: aBlockClosure value]</body><body package="Protocols-Http2">logAnnounceError: anErrorOrString	self logAnnounce: [ HTTP2ErrorAnnouncement description: anErrorOrString ]</body><body package="Protocols-Http2">registerAnnouncer	self announcementPrinter announcers:   self.	self 		when: self announcementPrinter announcements		do: [ :ann |self announcementPrinter isLogging ifTrue: [self announcementPrinter privateLog: ann ]]		for: self announcementPrinter</body><body package="Protocols-Http2">removeAnnouncer	self announcementPrinter announcers remove: self ifAbsent: [].</body><body package="Protocols-Http2">type</body></methods><methods><class-id>Protocols.HTTP2Multiplexer</class-id> <category>processing frames</category><body package="Protocols-Http2">processCONTINUATION: aFrame"The CONTINUATION frame (type=0x9) is used to continue a sequence of header block fragments"	aFrame streamId == nil ifTrue: [^HTTP2ConnectionError protocolError: (#CONTINUATIONHasZeroId &lt;&lt; #protocols &gt;&gt; 'CONTINUATION Frame has zero stream id') ].	self lastStream ifNil: ["The endpoint MUST respond with a stream error (Section 5.4.2) of type STREAM_CLOSED."			^HTTP2ConnectionError protocolError: ((#CONTINUATIONNoStreamOpened &lt;&lt; #protocols &gt;&gt; 'Received CONTINUATION &lt;1s&gt; when there is no stream opened') expandMacrosWith: aFrame streamId printString)].				"A CONTINUATION frame MUST be preceded by a HEADERS, PUSH_PROMISE or CONTINUATION frame without the END_HEADERS flag set. A recipient that observes violation of this rule MUST respond with a connection error  of type PROTOCOL_ERROR."		self lastStreamID ~= aFrame streamId			ifTrue: [^HTTP2ConnectionError protocolError: ((#CONTINUATIONNotPrecededByHEADERS &lt;&lt; #protocols &gt;&gt;'CONTINUATION is not preceded by a HEADERS frame with id: &lt;1s&gt; ') expandMacrosWith: aFrame streamId printString )].	"The endpoint MUST respond with a stream error (Section 5.4.2) of type STREAM_CLOSED"	self lastStream isClosed ifTrue: [		^HTTP2StreamError 			streamClosedError: aFrame streamId 			errorString: (#CONTINUATIONLastStreamClosed &lt;&lt; #protocols &gt;&gt; 'Process CONTINUATION: The last stream has been already closed')].								self lastStream isReceivingHeaders		ifTrue: [self lastStream processCONTINUATION: aFrame]		ifFalse:[^HTTP2ConnectionError protocolError: ((#StreamIsNotReceivingHeadersAnymore &lt;&lt; #protocols &gt;&gt; 'The stream &lt;1s&gt; is not receiving any headers anymore ') expandMacrosWith: aFrame streamId printString )]</body><body package="Protocols-Http2">processDATA: aFrame		| stream |	aFrame streamId = 0 ifTrue: ["DATA frames MUST be associated with a stream. If a DATA frame is received whose stream identifier field is 0x0, the recipient MUST respond with a connection error  of type PROTOCOL_ERROR."		^HTTP2ConnectionError protocolError: (#DATAHasZeroId &lt;&lt; #protocols &gt;&gt; 'Data Frame has zero stream id') ].		(stream := self findStream: aFrame streamId) == nil ifTrue: [ "not opened yet" 		^HTTP2ConnectionError protocolError: ((#IdleStream1sReceivedDATA &lt;&lt; #protocols &gt;&gt; 'Idle stream &lt;1s&gt; received DATA ') expandMacrosWith: aFrame streamId printString)].		stream canAcceptData		ifFalse: [ "An endpoint that receives any frames after receiving a frame with the END_STREAM flag set MUST treat that as a connection error of type STREAM_CLOSED"			^HTTP2StreamError 				streamClosedError: stream id				errorString: (#DATAStreamAlreadyEOS &lt;&lt; #protocols &gt;&gt;'Processing DATA: the stream has already received EOS' )].			stream isEndOfHeader ifFalse: 		["A receiver MUST treat the receipt of any other than CONTINUATION type of frame or a frame on a different stream as a connection error PROTOCOL_ERROR"		^HTTP2ConnectionError protocolError: ((#DATAStreamDidnotReceiveEOH &lt;&lt; #protocols &gt;&gt; 'The stream: &lt;1s&gt; received DATA but has not received end of headers yet') expandMacrosWith: stream id printString)].			stream processDATA: aFrame.</body><body package="Protocols-Http2">processGOAWAY: aFrame"The GOAWAY frame (type=0x7) is used to initiate shutdown of a connection or to signal serious error conditions.  Receivers of a GOAWAY frame MUST NOT open additional streams on the connection, although a new connection can be established for new streams "	aFrame streamId ~= 0 ifTrue: ["The GOAWAY frame applies to the connection, not a specific stream. An endpoint MUST treat a GOAWAY frame with a stream identifier other than 0x0 as a connection error (Section 5.4.1) of type PROTOCOL_ERROR. "		^HTTP2ConnectionError protocolError: (#GOAWAYStreamIdNotZero &lt;&lt; #protocols &gt;&gt; 'GOAWAY frame stream id is not zero')].		self stop</body><body package="Protocols-Http2">processHEADERS: aHeaderFrame"The HEADERS frame (type=0x1) is used to open a stream"	self validateHeaderStreamId: aHeaderFrame streamId.		"Validate stream depencies"	aHeaderFrame priority parentStreamId = aHeaderFrame streamId		ifTrue: [^HTTP2StreamError 					protocolError: aHeaderFrame streamId 					errorString: (#HEADERSStreamIdEqualPriorityParentId &lt;&lt; #protocols &gt;&gt; 'Processing HEADERS: The stream id and priority parent stream id are the same')].</body><body package="Protocols-Http2">processPING: aFrame"Opaque Data (64)"	aFrame streamId ~= 0 ifTrue: ["PING frames are not associated with any individual stream. If a PING frame is received with a stream identifier field value other than 0x0, the recipient MUST respond with a connection error (Section 5.4.1) of type PROTOCOL_ERROR."		^HTTP2ConnectionError protocolError: (#PINGIdNotZero &lt;&lt; #protocols &gt;&gt; 'PING frame id is not zero')].		"Receivers of a PING frame that does not include an ACK flag MUST send a PING frame with the ACK flag set in response, with an identical payload."	aFrame isACK ifFalse: [ self queueFrame: aFrame asACK ]</body><body package="Protocols-Http2">processPRIORITY: aPriorityFrame	^self subclassResponsibility</body><body package="Protocols-Http2">processPUSH_PROMISE: aFrame 	^self subclassResponsibility</body><body package="Protocols-Http2">processRST_STREAM: aFrame"The RST_STREAM frame (type=0x3) allows for immediate termination of a stream. RST_STREAM is sent to request cancellation of a stream or to indicate that an error condition has occurred"	" If a RST_STREAM frame is received with a stream identifier of 0x0, the recipient MUST treat this as a connection error of type PROTOCOL_ERROR."	aFrame streamId = 0 ifTrue: [HTTP2ConnectionError protocolError: (#RST_STREAMHasZeroId &lt;&lt; #protocols &gt;&gt; 'RST_STREAM Frame has zero stream id' )].		( self findStream: aFrame streamId)		ifNil: [ HTTP2ConnectionError protocolError: ((#RST_STREAMStreamNotOpened &lt;&lt; #protocols &gt;&gt; 'RST_STREAM Frame has not opened stream id: &lt;1s&gt;') expandMacrosWith: aFrame streamId printString)]		ifNotNil: [ :stream |  			stream closeRstStreamFrame: aFrame ].</body><body package="Protocols-Http2">processSETTINGS: aSettingsFrame"https://httpwg.github.io/specs/rfc7540.html#SETTINGSThe payload of a SETTINGS frame consists of zero or more parameters, each consisting of an unsigned 16-bit setting identifier and an unsigned 32-bit value"		aSettingsFrame streamId ~= 0 ifTrue: ["The stream identifier for a SETTINGS frame MUST be zero (0x0). If an endpoint receives a SETTINGS frame whose stream identifier field is anything other than 0x0, the endpoint MUST respond with a connection error of type PROTOCOL_ERROR."		HTTP2ConnectionError protocolError: (#SETTIGSCannotHaveStreamID &lt;&lt; #protocols &gt;&gt; 'SETTINGS frame can not have stream id' )].		self validateSettings: aSettingsFrame.		aSettingsFrame isACK ifTrue: [			self applyUpdatedLocalSettings: aSettingsFrame. 			^aSettingsFrame].	self applyRemoteSettings: aSettingsFrame.	self queueFrame: SettingsFrame acknowledge.</body><body package="Protocols-Http2">processWINDOW_UPDATE: aFrame"The WINDOW_UPDATE frame (type=0x8) is used to implement flow control; see Section 5.2 for an overview.Flow control operates at two levels: on each individual stream and on the entire connection""A receiver MUST treat the receipt of a WINDOW_UPDATE frame with an flow-control window increment of 0 as a stream error of type PROTOCOL_ERROR; errors on the connection flow-control window MUST be treated as a connection error "	| stream |	aFrame streamId = 0		ifTrue: [			aFrame windowSizeIncrement = 0 ifTrue: [				^HTTP2ConnectionError protocolError: (#WINDOW_UPDATEHasConnectionWinIncremetZero &lt;&lt; #protocols &gt;&gt; 'WINDOW_UPDATE frame has an flow-control window increment of 0') ].			self flowControlWindow processWINDOW_UPDATE: aFrame windowSizeIncrement.]		ifFalse: [			aFrame windowSizeIncrement = 0 ifTrue: [				^HTTP2StreamError 					protocolError: aFrame streamId					errorString: (#WINDOW_UPDATEHasStreamWinIncremetZero &lt;&lt; #protocols &gt;&gt; 'Processing WINDOW_UPDATE: the window size increment is 0' )].			(stream := self findStream: aFrame streamId ) == nil				ifTrue: [ aFrame streamId &lt;= self lastStreamID						ifTrue: ["The stream is already closed. A receiver MUST NOT treat this as an error" ^self]						ifFalse: [^ HTTP2ConnectionError protocolError: ((#WINDOW_UPDATEHasInvalidStreamId &lt;&lt; #protocols &gt;&gt; 'WINDOW_UPDATE Frame has invalid stream id: &lt;1s&gt;') expandMacrosWith: aFrame streamId printString )]]				ifFalse: [ stream processWINDOW_UPDATE: aFrame windowSizeIncrement ]			]</body></methods><methods><class-id>Protocols.HTTP2Multiplexer</class-id> <category>private</category><body package="Protocols-Http2">ackTimeoutError		^HTTP2ConnectionError ackTimeoutError: self ackTimeout</body><body package="Protocols-Http2">closeStreamOnError: anHTTP2Stream	anHTTP2Stream close</body><body package="Protocols-Http2">critical: aBlock	accessMutex critical: aBlock</body><body package="Protocols-Http2">handleError: anError	| goawayFrame |	self logAnnounceError: anError.	(HTTP2StreamError handles: anError ) ifTrue: [		"A stream error is an error related to a specific stream that does not affect processing of other streams"		self queueFrame: anError rstStreamFrame.		(self findStream: anError rstStreamFrame streamId) ifNotNil: [ :stream | self closeStreamOnError: stream ].		^ self ].		"A connection error SHOULD first send a GOAWAY frame with the stream identifier of the last stream that 	it successfully received from its peer. The GOAWAY frame includes an error code that indicates why 	the connection is terminating. After sending the GOAWAY frame for an error condition, the endpoint MUST 	close the TCP connection"		state := #closingOnError.	goawayFrame := (HTTP2ConnectionError handles: anError )		ifTrue: [anError goawayFrame ]		ifFalse: ["It is a generic Error. Let's try to send GoawayFrame and stop the multiplexer"			GoawayFrame new				errorCode: HTTP2Multiplexer INTERNAL_ERROR;				debugData: anError errorString;				yourself].	goawayFrame lastStreamID: self lastStreamID.	self sendGoawayOnError: goawayFrame.</body><body package="Protocols-Http2">privateSendFrame: aFrame	aFrame writeOn: self writeStream.	self writeStream flush.	self logAnnounce: [SentFrameAnnouncement frame: aFrame]</body><body package="Protocols-Http2">queueFrame: aFrame	^self subclassResponsibility</body><body package="Protocols-Http2">readFrame	^self readFrameFrom: self readStream</body><body package="Protocols-Http2">readFrameFrom: aStream	"An endpoint MUST send an error code of FRAME_SIZE_ERROR if a frame exceeds the size defined in SETTINGS_MAX_FRAME_SIZE"	| length frame type |	length := self readLength: aStream.		type := aStream get.	frame := (HTTP2Frame frameClasses at: type				ifAbsent: 					[self validateUnknownFrame: type.					"Implementations MUST ignore and discard any frame that has a type that is unknown"					^HTTP2Frame new read: length from: aStream])					new.	frame read: length from: aStream.	self logAnnounce: [ReceivedFrameAnnouncement frame: frame].	self validateExpectedFrame: frame.	self isACKTimeout ifTrue: [ self ackTimeoutError raise].		frame processWith: self.	^frame</body><body package="Protocols-Http2">readLength: aStream	"An endpoint MUST send an error code of FRAME_SIZE_ERROR if a frame exceeds the size defined in SETTINGS_MAX_FRAME_SIZE"	| length |	length := aStream getUint24.	length &gt; self localSettings maxFrameSizeValue		ifTrue: 			["A frame size error in a frame that could alter the state of the entire connection MUST be treated as a connection error"			^HTTP2ConnectionError frameSizeError: (#ReceivedFrameLengthExceedSetting &lt;&lt; #protocols &gt;&gt;  'Received a frame with a length &gt; localSettings maxFrameSize')].	^length</body><body package="Protocols-Http2">sendFrame: aFrame	self critical: [		[			self writeStream == nil				ifTrue: [ self error: (#NoWriteStreamPresent &lt;&lt; #protocols &gt;&gt; 'No writeStream present to send frame: ', aFrame printString) ]				ifFalse: [ self privateSendFrame: aFrame ]				] 			on: Error 			do: [ :ex | 				self logAnnounceError: ex.				"The connection may get closed and the multiplexer stopped. Forget about this frame in this case"				state = #running 				 	ifTrue: [ state := #closingOnError.							self stop]]	]</body><body package="Protocols-Http2">sendGoawayOnError: aFrame	self critical: [		[			self privateSendFrame: aFrame.			self stop		] 			on: Error 			do: [ :ex |self logAnnounceError: ex ]	]</body><body package="Protocols-Http2">sendNoErrorGoaway	state = #closingOnError ifFalse: [		self queueFrame: (GoawayFrame noError								lastStreamID: self lastStreamID;								yourself)].</body><body package="Protocols-Http2">validateExpectedFrame: aFrame"Make sure if we start receiving HEADERS\CONTINUATION frames there is no other frames in between""self debug: 'validateExpectedFrame:', aFrame printString.self lastStream ifNotNil: [	self debug: 'Last stream: ', self lastStream printString, ' state:', self lastStream state printString]."	self lastStream == nil ifFalse: 		[(self lastStream isReceivingHeaders and: 				[aFrame isContinuation not					or: [aFrame isContinuation and: [aFrame streamId ~= self lastStreamID]]])			ifTrue: 				[^HTTP2ConnectionError protocolError: ((#ExpectedContinuationOnly1s &lt;&lt; #protocols &gt;&gt;'Expected Continuation frame only on stream id: &lt;1s&gt;') expandMacrosWith:  self lastStreamID printString)]].</body><body package="Protocols-Http2">validateUnknownFrame: anInteger"Complain only if we are receiving HEADERS/CONTINUATION frames "	self logAnnounce: [ReceivedFrameAnnouncement description: ((#ReceivedUnknowFrameType1s &lt;&lt; #protocols &gt;&gt;  'Received unknown frame type: &lt;1s&gt;' ) expandMacrosWith: anInteger printString)].	(self lastStream notNil and: [self lastStream isReceivingHeaders]) ifTrue: [		^HTTP2ConnectionError protocolError: (#ExpectedContinuationOnly &lt;&lt; #protocols &gt;&gt; 'Expected Continuation frame only')].</body></methods><methods><class-id>Protocols.HTTP2Multiplexer</class-id> <category>testing</category><body package="Protocols-Http2">isACKTimeout		^(ackTimeout notNil 		and: [ackTimeout - Time now asMilliseconds &lt; 0])</body><body package="Protocols-Http2">isClosed	^state == #closed</body><body package="Protocols-Http2">isGracefulShutdown	^state == #gracefulShutdown</body><body package="Protocols-Http2">isLogging	^ self announcementPrinter isLogging</body><body package="Protocols-Http2">isRunning	^state == #running or: [self isGracefulShutdown]</body></methods><methods><class-id>Protocols.HTTP2Multiplexer</class-id> <category>services</category><body package="Protocols-Http2">closeAllStreams	self streams do: [ :str | str close].</body><body package="Protocols-Http2">releaseAll	recyclingCenter release.	self removeAnnouncer.</body><body package="Protocols-Http2">start	state := #running.	[		self isRunning	] 		whileTrue: [			[self readFrame]				on: Error				do: [ :error | self handleError: error ]		]</body><body package="Protocols-Http2">stop	state = #closed ifTrue: [^nil].	self sendNoErrorGoaway.	state := #closed.	self closeAllStreams.	self releaseAll</body></methods><methods><class-id>Protocols.HTTP2Multiplexer</class-id> <category>handling streams</category><body package="Protocols-Http2">decreaseActiveStreams	self critical: [activeStreams := activeStreams - 1].</body><body package="Protocols-Http2">findStream: anInteger	^self streams at: anInteger ifAbsent: [nil]</body><body package="Protocols-Http2">http2StreamClass	^self subclassResponsibility</body><body package="Protocols-Http2">increaseActiveStreams	activeStreams := activeStreams + 1</body><body package="Protocols-Http2">lastStream	^lastStream</body><body package="Protocols-Http2">lastStreamID	^self lastStream ifNil: [ 0] ifNotNil: [ self lastStream id ]</body><body package="Protocols-Http2">maximumStreamId"Streams are identified with an unsigned 31-bit integer"	^self class maximumStreamId</body><body package="Protocols-Http2">minimumStreamId	^self subclassResponsibility</body><body package="Protocols-Http2">newMessageStream	^self newStreamFor: self nextStreamId.</body><body package="Protocols-Http2">nextStreamId"To eliminate stream ID collisions between client- and server initiated streams, the counters are offset: client-initiated streams have odd-numbered stream IDs, and server-initiated streams have even-numbered stream IDs."	streamId := streamId + 2.	streamId &gt;= self maximumStreamId ifTrue: [self error: (#StreamIDExceedMax &lt;&lt; #protocols &gt;&gt; 'Stream id exceeded maximum')].	^streamId</body><body package="Protocols-Http2">streams	^streams</body><body package="Protocols-Http2">validateHeaderStreamId: anInteger		anInteger = 0 ifTrue: [		"If a HEADERS frame is received whose stream identifier field is 0x0, the recipient MUST respond with a connection error of type PROTOCOL_ERROR"		HTTP2ConnectionError protocolError: (#HEADERSHasZeroId &lt;&lt; #protocols &gt;&gt; 'HEADER Frame has zero stream id') ].	activeStreams &gt; self localSettings maxConcurrentStreamsValue ifTrue: [		"An endpoint that receives a HEADERS frame that causes its advertised SETTINGS_MAX_CONCURRENT_STREAMS limit to be exceeded MUST treat this as a stream error of type PROTOCOL_ERROR or REFUSED_STREAM. The choice of error code determines whether the endpoint wishes to enable automatic retry."		HTTP2StreamError 			refusedStreamError: anInteger 			errorString: (#HEADERSStreamIdLargerMaxSetting &lt;&lt; #protocols &gt;&gt; 'Processing HEADERS: the stream id is larger than local settings max concurrent stream id')].</body></methods><methods><class-id>Protocols.HTTP2Multiplexer</class-id> <category>updating settings</category><body package="Protocols-Http2">applyDynamicTableUpdate: newSize"The new maximum size MUST be lower than or equal to the limit determined by the protocol using HPACK. A value that exceeds this limit MUST be treated as a decoding error. In HTTP/2, this limit is the last value of the SETTINGS_HEADER_TABLE_SIZE parameter received from the decoder and acknowledged by the encoder"	newSize &gt; self hpackDecoder dynamicTableAllowedSize ifTrue: [		^HTTP2ConnectionError compressionError: (#DynTableUpdateExceedMaxSetting &lt;&lt; #protocols &gt;&gt; 'DecodingError: The new value exceeds SETTINGS_HEADER_TABLE_SIZE parameter')].	self queueFrame: SettingsFrame acknowledge.</body><body package="Protocols-Http2">applyRemoteSettings: aRemoteSettings	| size |	remoteSettings ifNil: [		remoteSettings := aRemoteSettings.		self flowControlWindow remoteAvailable: remoteSettings initialWindowSizeValue.		self hpackEncoder dynamicTableAllowedSize: remoteSettings headerTableSizeValue.		^remoteSettings ].		"A SETTINGS frame can alter the initial flow control window size for all current streams. When the value of SETTINGS_INITIAL_WINDOW_SIZE changes, a receiver MUST adjust the size of all stream flow control windows that itmaintains by the difference between the new value and the old value."		aRemoteSettings initialWindowSize ifNotNil: [ :newVal | | diff |		self flowControlWindow remoteAvailable:  newVal.		size := remoteSettings initialWindowSize ifNil: [0].		diff := newVal - size.		self streams do: [ :s | s isClosed not ifTrue: [ s processWINDOW_UPDATE: diff ]]].		aRemoteSettings headerTableSize ifNotNil: [ :n |		self critical: [ self hpackEncoder updateDynamicTableSize: n ]].	remoteSettings updateWith: aRemoteSettings.</body><body package="Protocols-Http2">applyUpdatedLocalSettings: anACKSetting	anACKSetting length = 0		ifTrue: ["SETTINGS parameters are acknowledged by the receiving peer." 				updatedSettings 					ifNil: ["Hmm, we have not sent any SETTINGS but the client sends ACK. 						Let's close the connection"						HTTP2ConnectionError protocolError: (#ReceivedUnexpectedACK &lt;&lt; #protocols &gt;&gt; 'Received unexpected SETTINGS frame with ACK flag' )]					ifNotNil: ["SETTINGS parameters are acknowledged by the receiving peer. 						Now we can start using them" 						self critical: [							self protocolVersion settingsFrame: updatedSettings.													self setLocalAvailable: updatedSettings.].						ackTimeout := nil.						updatedSettings := nil.]]		ifFalse: [ "Receipt of a SETTINGS frame with the ACK flag set and a length field value other than 0 MUST be treated as a connection error  of type FRAME_SIZE_ERROR"			HTTP2ConnectionError frameSizeError: (#SETTINGSWithACKHasLength &lt;&lt; #protocols &gt;&gt; 'Received SETTINGS frame with ACK flag and a length field value other than 0' )].</body><body package="Protocols-Http2">sendLocalSettings: aSettingsFrame"Send local settings. Upon receiving a SETTINGS frame with the ACK flag set, the sender of the altered parameters can rely on the setting having been applied.If the sender of a SETTINGS frame does not receive an acknowledgement within a reasonable amount of time, it MAY issue a connection error (Section 5.4.1) of type SETTINGS_TIMEOUT"	"Cache the updated local settings and wait for ACK to apply them "	updatedSettings := aSettingsFrame.	self queueFrame: aSettingsFrame.	"According to the spec the timeout is optional and we set it only If the settings specify the ACK timeout duration"	self ackTimeout == nil ifFalse: [		ackTimeout := Time now asMilliseconds + self ackTimeout asMilliseconds ]</body><body package="Protocols-Http2">setLocalAvailable: aSettingsFrame"The method is used to set initial values and dynamicaly update local settings "	self flowControlWindow localAvailable: aSettingsFrame initialWindowSizeValue.	self hpackDecoder dynamicTableAllowedSize: aSettingsFrame headerTableSizeValue.</body><body package="Protocols-Http2">validateSettings: aRemoteSettings	| push |	((push := aRemoteSettings enablePushValue) notNil		and: [ push ~= 0 and: [ push ~= 1]])		ifTrue: [ ^HTTP2ConnectionError protocolError: (#SETTINGSHasWrongPushValue &lt;&lt; #protocols &gt;&gt; 'SETTINGS frame has wrong push value')].			aRemoteSettings initialWindowSize == nil ifFalse: [ 		aRemoteSettings initialWindowSize &gt; SettingsFrame SETTINGS_MAX_WINDOW_SIZE			ifTrue: ["Values above the maximum flow-control window size of 2^31-1 MUST be treated as a connection error (Section 5.4.1) of type FLOW_CONTROL_ERROR." 				^HTTP2ConnectionError flowControlError: (#SETTINGSHasLargeInitialWinSize &lt;&lt; #protocols &gt;&gt; 'Remote Settings have initialWindowSize larger than SettingsFrame SETTINGS_MAX_WINDOW_SIZE')]].			(aRemoteSettings maxFrameSizeValue &lt; SettingsFrame SETTINGS_INITIAL_FRAME_SIZE			or: [aRemoteSettings maxFrameSizeValue &gt; SettingsFrame SETTINGS_MAX_FRAME_SIZE])			ifTrue: ["The value advertised by an endpoint MUST be between this initial value and the maximum allowed frame size" 				^HTTP2ConnectionError protocolError: (#SETTINGSSizeOutsideRange &lt;&lt; #protocols &gt;&gt;  'SETTINGS frame size outside the range')].</body></methods><methods><class-id>Protocols.HTTP2Multiplexer</class-id> <category>initialize-release</category><body package="Protocols-Http2">connectionPreface: anHTTPv20 	| text frame |	self setProtocolVersion: anHTTPv20.	self setLocalAvailable: self protocolVersion settingsFrame.		self handshake.		["Send my SETTINGS frame"	self sendLocalSettings: self localSettings.	"This sequence MUST be followed by a SETTINGS frame (Section 6.5), which MAY be empty.	Read remote SETTINGS frame"	frame := self readFrame.	]	on: Error		do: [ :ex |			(HTTP2Error handles: ex ) ifTrue: [ ^self handleError: ex].			 "probably remote party closed connection"			self connection close.			text := #RemotePartyClosedConnection &lt;&lt; #protocols &gt;&gt;'Remote Party closed connection'.			self logAnnounceError: text asString.			^HTTP2ConnectionError protocolError: text asString ].			frame type ~= SettingsFrame type ifTrue: [		text := #ExpectedRemoteSettingsFrame &lt;&lt; #protocols &gt;&gt; 'Expected remote SETTINGS frame after the preface string'.		self logAnnounceError: text.		^HTTP2ConnectionError protocolError: text].</body><body package="Protocols-Http2">handshake	^self subclassResponsibility</body><body package="Protocols-Http2">initialize	streams := SharedRegistry new.	streamId := self minimumStreamId.	"The amount of active streams "	activeStreams := 0.	"Protocols that use HPACK determine the maximum size that the encoder is permitted to use for the dynamic table. In HTTP/2, this value is determined by the SETTINGS_HEADER_TABLE_SIZE setting"	hpackDecoder := HPACKDecoder new.	hpackDecoder onDynamicTableUpdate: [ :newSize | self applyDynamicTableUpdate: newSize].	"The dynamic table size is set by remote settings"	hpackEncoder := HPACKEncoder new.	accessMutex := RecursionLock new.	flowControlWindow := HTTP2FlowControlWindow new.	recyclingCenter := HTTP2RecyclingCenter default.	state := #initializing.	self registerAnnouncer</body><body package="Protocols-Http2">setProtocolVersion: anHTTPv20 	protocolVersion := anHTTPv20.</body></methods><methods><class-id>Protocols.HTTP2Multiplexer</class-id> <category>recycling</category><body package="Protocols-Http2">newRecycledDATABuffer	^Buffer on: (recyclingCenter newByteArraySize: self protocolVersion settings initialWindowSize)</body><body package="Protocols-Http2">newRecycledFrameBuffer	^Buffer on: (recyclingCenter newByteArraySize: self protocolVersion settings maxFrameSize )</body><body package="Protocols-Http2">newRecycledOutputBuffer	^RingBuffer on: (recyclingCenter newByteArraySize: self protocolVersion settings outputWindowSize )</body><body package="Protocols-Http2">recycle: aCollection	^recyclingCenter recycle: aCollection</body></methods><methods><class-id>Protocols.HTTP2Multiplexer class</class-id> <category>errors</category><body package="Protocols-Http2">NO_ERROR	^0</body><body package="Protocols-Http2">errorDescription:  aNumber	| stream |		aNumber = self NO_ERROR ifTrue: [^' NO_ERROR'].	stream := String new writing.	stream write: ' Error:('.	stream write: aNumber printString.	"TO DO investigate why Apache returns aNumber as 4294966791"	[stream write: ') ', (self errorCodes at: aNumber )] 		on: Error 		do: [ :ex | Transcript cr; show: 'TO DO Apache GOAWAY error code'].			^stream conclusion</body></methods><methods><class-id>Protocols.HTTP2Multiplexer class</class-id> <category>instance creation</category><body package="Protocols-Http2">connectionPreface: anHttpv20	^self new		connectionPreface: anHttpv20;		yourself</body><body package="Protocols-Http2">new	^self basicNew initialize</body></methods><methods><class-id>Protocols.HTTP2Multiplexer class</class-id> <category>accessing</category><body package="Protocols-Http2">addAnnouncement: anAnnouncement	(self announcementPrinter announcements includes: anAnnouncement) ifFalse: [		self announcementPrinter announcements add: anAnnouncement ]</body><body package="Protocols-Http2">announcementPrinter	announcementPrinter		ifNil: 			[announcementPrinter := AnnouncementPrinter new.			announcementPrinter				announcements: ReceivedFrameAnnouncement, 							SentFrameAnnouncement, 							DebugAnnouncement ].	^announcementPrinter</body><body package="Protocols-Http2">announcementPrinter: anAnnouncementPrinter	announcementPrinter := anAnnouncementPrinter</body><body package="Protocols-Http2">announcements: anAnnSet	self announcementPrinter announcements: anAnnSet</body><body package="Protocols-Http2">errorCodes	^ErrorCodes ifNil: [ self initializeErrorCodes ]</body><body package="Protocols-Http2">isLogging	^self announcementPrinter isLogging</body><body package="Protocols-Http2">isLogging: aBoolean	aBoolean		ifTrue: [ self announcementPrinter start ]		ifFalse: [ self announcementPrinter stop ]</body><body package="Protocols-Http2">maximumStreamId"Streams are identified with an unsigned 31-bit integer"	^2147483647</body><body package="Protocols-Http2">removeAnnouncement: anAnnouncement	(self announcementPrinter announcements includes: anAnnouncement) ifTrue: [		self announcementPrinter announcements remove: anAnnouncement ifAbsent: [nil]]</body></methods><methods><class-id>Protocols.HTTP2Multiplexer class</class-id> <category>class initialization</category><body package="Protocols-Http2">initialize	ClientPreface := ByteArray fromHexString:  '505249202A20485454502F322E300D0A0D0A534D0D0A0D0A'.	self initializeErrorCodes</body><body package="Protocols-Http2">initializeErrorCodes"self initializeErrorCodes"	| pragmas |	"Let's not assume HTTP2Multiplexer is always going to be the receiver of this message, and use the Pragma API correctly. "	pragmas := Tools.Pragma allNamed: #http2Error from: self class to: HTTP2Multiplexer class.	ErrorCodes := Array new: pragmas size.	pragmas 		do: [ :pragma | ErrorCodes at: (self perform: pragma selector) put: pragma selector asString ].			^ErrorCodes</body></methods><methods><class-id>Protocols.GoawayFrame</class-id> <category>accessing</category><body package="Protocols-Http2">debugData	^debugData</body><body package="Protocols-Http2">debugData: anObject	debugData := anObject</body><body package="Protocols-Http2">errorCode	^errorCode</body><body package="Protocols-Http2">errorCode: anInteger	errorCode := anInteger</body><body package="Protocols-Http2">lastStreamID	^lastStreamID</body><body package="Protocols-Http2">lastStreamID: anInteger	lastStreamID := anInteger</body></methods><methods><class-id>Protocols.GoawayFrame</class-id> <category>printing</category><body package="Protocols-Http2">description	^HTTP2Multiplexer errorDescription: errorCode</body><body package="Protocols-Http2">printOn: aStream	super printOn: aStream.	lastStreamID ifNotNil: [aStream nextPutAll: ' last sid: '.  lastStreamID printOn: aStream].	errorCode  ifNotNil: [ aStream nextPutAll: self description ].	(self verboseDebugPrint and: [ debugData notNil] ) ifTrue: [		aStream nextPutAll: ' Error message: '.  		aStream nextPutAll: debugData asString ].</body></methods><methods><class-id>Protocols.GoawayFrame</class-id> <category>delegation</category><body package="Protocols-Http2">processWith: aMultiplexer	aMultiplexer processGOAWAY: self</body></methods><methods><class-id>Protocols.GoawayFrame</class-id> <category>writing</category><body package="Protocols-Http2">calculateLength	^8"	^debugData 		ifNil: [ 8 ]		ifNotNil: [ 8 + debugData size]."</body><body package="Protocols-Http2">writePayloadOn: aStream"  |R|                  Last-Stream-ID (31)                        | +-+-------------------------------------------------------------+ |                      Error Code (32)                          | +---------------------------------------------------------------+ |                  Additional Debug Data (*)    "	aStream 		putUint31: lastStreamID firstBit: 0;		putUint32: errorCode."	debugData ifNotNil: [stream write: debugData asByteArray]."</body></methods><methods><class-id>Protocols.GoawayFrame</class-id> <category>testing</category><body package="Protocols-Http2">isConnectionError	^errorCode &gt; HTTP2Multiplexer NO_ERROR</body><body package="Protocols-Http2">isGoaway	^true</body><body package="Protocols-Http2">isGracefulShutdown	^errorCode = HTTP2Multiplexer NO_ERROR		and: [ lastStreamID = HTTP2Multiplexer maximumStreamId]</body></methods><methods><class-id>Protocols.GoawayFrame</class-id> <category>parsing</category><body package="Protocols-Http2">readPayloadFrom: aStream"  |R|                  Last-Stream-ID (31)                        | +-+-------------------------------------------------------------+ |                      Error Code (32)                          | +---------------------------------------------------------------+ |                  Additional Debug Data (*)    "	| rest |	self streamId = 0 ifFalse:[" An endpoint MUST treat a GOAWAY frame with a stream identifier other than 0x0 as a connection error (Section 5.4.1) of type PROTOCOL_ERROR"		HTTP2ConnectionError protocolError: (#GOAWAYCannotHaveStreamID &lt;&lt; #protocols &gt;&gt; 'GOAWAY frame can not have stream id') ].	lastStreamID := aStream getUint31 value.	errorCode := aStream getUint32.	(rest := length - 8) &gt; 0		ifTrue: [ debugData := aStream read: rest ]</body></methods><methods><class-id>Protocols.GoawayFrame class</class-id> <category>instance creation</category><body package="Protocols-Http2">noError 		^self new		errorCode: HTTP2Multiplexer NO_ERROR;		yourself</body><body package="Protocols-Http2">type	^7</body></methods><methods><class-id>Protocols.ReceivedFrameAnnouncement</class-id> <category>accessing</category><body package="Protocols-Http2">direction	^' &lt;-- '</body></methods><methods><class-id>Xtreams.WriteStream</class-id> <category>accessing</category><body package="Protocols-Http2">http2DataStream	^ destination http2DataStream</body></methods><methods><class-id>Xtreams.WriteStream</class-id> <category>transforming</category><body package="Protocols-Http2">putUint31: uint firstBit: oneOrZero	| firstByte |	oneOrZero = 0		ifTrue: [ self putUint32: uint ]		ifFalse: [			firstByte := uint bitShift: -24.			firstByte := firstByte bitAt: 8 put: oneOrZero.			self 				put: firstByte; 				putUint24: (uint bitAnd: 16rFFFFFF)]</body></methods><methods><class-id>Xtreams.ReadStream</class-id> <category>transforming</category><body package="Protocols-Http2">getUint31"Returns association of reserved first bit and an integer from the rest of bits"	| bytes firstByte reservedBit |	bytes := ByteArray new: 4.	1 to: 4 do: [:i | bytes at: i put: self get ].	firstByte := bytes first.	reservedBit := firstByte bitAt: 8.	reservedBit = 1 ifTrue: [ bytes at: 1 put: (firstByte bitAt: 8 put: 0 )].	^reservedBit -&gt; bytes reading getUint32.</body></methods><methods><class-id>Protocols.ProtocolVersion</class-id> <category>testing</category><body package="Protocols-Http2">isHTTPv20	^false</body></methods><methods><class-id>Protocols.HTTP2Multiplexer class</class-id> <category>errors</category><body package="Protocols-Http2">CANCEL	&lt;http2Error&gt;	^8</body><body package="Protocols-Http2">COMPRESSION_ERROR	&lt;http2Error&gt;	^9</body><body package="Protocols-Http2">CONNECT_ERROR	&lt;http2Error&gt;		^10</body><body package="Protocols-Http2">ENHANCE_YOUR_CALM	&lt;http2Error&gt;	^11</body><body package="Protocols-Http2">FLOW_CONTROL_ERROR	&lt;http2Error&gt;	^3</body><body package="Protocols-Http2">FRAME_SIZE_ERROR	&lt;http2Error&gt;	^6</body><body package="Protocols-Http2">HTTP_1_1_REQUIRED	&lt;http2Error&gt;	^13</body><body package="Protocols-Http2">INADEQUATE_SECURITY	&lt;http2Error&gt;	^12</body><body package="Protocols-Http2">INTERNAL_ERROR	&lt;http2Error&gt;	^2</body><body package="Protocols-Http2">PROTOCOL_ERROR	&lt;http2Error&gt;	^1</body><body package="Protocols-Http2">REFUSED_STREAM	&lt;http2Error&gt;	^7</body><body package="Protocols-Http2">SETTINGS_TIMEOUT	&lt;http2Error&gt;	^4</body><body package="Protocols-Http2">STREAM_CLOSED	&lt;http2Error&gt;	^5</body><body package="Protocols-Http2">errorPragma	&lt;pragmas: #class&gt;	^#( #http2Error )</body></methods><initialize><class-id>Protocols.HPACKCompessor</class-id></initialize><initialize><class-id>Protocols.HTTP2Frame</class-id></initialize><initialize><class-id>Protocols.HTTP2RecyclingCenter</class-id></initialize><initialize><class-id>Protocols.HPACKEncoder</class-id></initialize><initialize><class-id>Protocols.HTTP2Multiplexer</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Announcement</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Announcements</category><attributes><package>System-Announcements</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>WriteStream</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars>destination </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.BehaviorIcons			</imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class><class><name>ReadStream</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars>source </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.BehaviorIcons			</imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class><class><name>ProtocolVersion</name><environment>Protocols</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection validateHostOriginBlock writeResponseBlock settings </inst-vars><class-inst-vars>validateHostOriginBlock </class-inst-vars><imports></imports><category></category><attributes><package>Protocols-Http</package></attributes></class><class><name>Announcer</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subscriptionRegistry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>System-Announcements</package></attributes></class></st-source>