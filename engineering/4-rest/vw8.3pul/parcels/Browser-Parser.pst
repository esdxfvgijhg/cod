<?xml version="1.0"?><st-source><!-- Name: Browser-ParserNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Portions © 1998-2002 The Refactory, IncComment: The parser for the Refactoring Browser. It contains both the ability to parse Smalltalk and also to rewrite Smalltalk code. The refactorings use this rewriting behavior to perform the source code transformations.DbIdentifier: bear73DbTrace: 493644DbUsername: kgreekDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'Browser-Namespace' ''))PackageName: Browser-ParserParcel: #('Browser-Parser')ParcelName: Browser-ParserPrerequisiteParcels: #(#('Browser-Namespace' ''))PrintStringCache: (8.3 - 1,kgreek)Version: 8.3 - 1Date: 3:26:52 PM June 30, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (jun17.4) of June 23, 2017 on June 30, 2017 at 3:26:52 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>RBToken</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourcePointer comments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBToken</class-id><body>RBToken is the abstract superclass of all of the RB tokens. These tokens (unlike the standard parser's) remember where they came from in the original source code.Subclasses must implement the following messages:	accessing		lengthInstance Variables:	sourcePointer	&lt;Integer&gt;	The position in the original source code where this token began.</body></comment><class><name>RBValueToken</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBValueToken</class-id><body>RBValueToken is the abstract superclass of all tokens that have additional information attached. For example, the BinarySelector token holds onto the actual character (e.g. $+).Instance Variables:	value	&lt;String&gt;	The value of this token</body></comment><class><name>RBIdentifierToken</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBIdentifierToken</class-id><body>RBIdentifierToken is the first class representation of an identifier token (e.g. Class)</body></comment><class><name>RBStringReplacement</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>startPosition stopPosition string </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBStringReplacement</class-id><body>RBStringReplacement represents replacing source in the original method with a different string. These are used when reformatting code after a parse tree change has been made. Depending on the change, it may be possible to minimally change the parse tree without needing to format it.Instance Variables:	startPosition	&lt;Integer&gt;	the start position in the original source	stopPosition	&lt;Integer&gt;	the end position in the original source	string	&lt;String&gt;	replaces everything from the startPosition to the endPosition with this string</body></comment><class><name>RBProgramNode</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent comments errors properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBProgramNode</class-id><body>RBProgramNode is an abstract class that represents an abstract syntax tree node in a Smalltalk program.Subclasses must implement the following messages:	accessing		start		stop	visitor		acceptVisitor:The #start and #stop methods are used to find the source that corresponds to this node. "source copyFrom: self start to: self stop" should return the source for this node.The #acceptVisitor: method is used by RBProgramNodeVisitors (the visitor pattern). This will also require updating all the RBProgramNodeVisitors so that they know of the new node.Subclasses might also want to redefine match:inContext: and copyInContext: to do parse tree searching and replacing.Subclasses that contain other nodes should override equalTo:withMapping: to compare nodes while ignoring renaming temporary variables, and children that returns a collection of our children nodes.Instance Variables:	comments	&lt;Collection of: Interval&gt;	the intervals in the source that have comments for this node	parent	&lt;RBProgramNode&gt;	the node we're contained in	errors	&lt;Collection of: RBErrorAction&gt;	errors that were found while parsing this node	properties	&lt;nil | Dictionary&gt;	custom properties for this nodeShared Variables:	FormatterClass	&lt;Behavior&gt;	the formatter class that is used when we are formatted</body></comment><class><name>RBValueNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parentheses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBValueNode</class-id><body>RBValueNode is an abstract class that represents a node that returns some value.Subclasses must implement the following messages:	accessing		startWithoutParentheses		stopWithoutParentheses	testing		needsParenthesisInstance Variables:	parentheses	&lt;SequenceableCollection of: Inteval&gt;	the positions of the parethesis around this node. We need a collection of intervals for stupid code such as "((3 + 4))" that has multiple parethesis around the same expression.</body></comment><class><name>RBBlockNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>left right colons body arguments bar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBBlockNode</class-id><body>RBBlockNode is an AST node that represents a block "[...]".Instance Variables:	arguments	&lt;SequenceableCollection of: RBVariableNode&gt;	the arguments for the block	bar	&lt;Integer | nil&gt;	position of the | after the arguments	body	&lt;RBSequenceNode&gt;	the code inside the block	colons	&lt;SequenceableCollection of: Integer&gt;	positions of each : before each argument	left	&lt;Integer&gt;	position of [	right	&lt;Integer&gt;	position of ]</body></comment><class><name>RBPatternBlockNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBBlockNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>valueBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBPatternBlockNode</class-id><body>RBPatternBlockNode is the node in matching parse trees (it never occurs in normal Smalltalk code) that executes a block to determine if a match occurs. valueBlock takes two arguments, the first is the actual node that we are trying to match against, and second node is the dictionary that contains all the metavariable bindings that the matcher has made thus far.Instance Variables:	valueBlock	&lt;BlockClosure&gt;	The block to execute when attempting to match this to a node.</body></comment><class><name>RBPatternWrapperBlockNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBPatternBlockNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>wrappedNode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBPatternWrapperBlockNode</class-id><body>RBPatternWrapperBlockNode allows further matching using a block after a node has been matched by a pattern node.Instance Variables:	wrappedNode	&lt;RBProgramNode&gt;	The original pattern node to match</body></comment><class><name>RBScanner</name><environment>Refactory.Browser</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream buffer tokenStart currentCharacter characterType classificationTable comments errorBlock errorActions </inst-vars><class-inst-vars>classificationTable </class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBScanner</class-id><body>RBScanner is a stream that returns a sequence of token from the string that it is created on. The tokens know where they came from in the source code and which comments were attached to them.Instance Variables	buffer	&lt;PositionableStream&gt;	Accumulates the text for the current token.	characterType	&lt;ByteSymbol&gt;	The type of the next character. (e.g. #alphabetic, etc.)	classificationTable	&lt;Array of: Symbol&gt;	Mapping from Character values to their characterType.	comments	&lt;Collection of: Interval&gt;	Source intervals of scanned comments that must be attached to the next token.	currentCharacter	&lt;Character&gt;	The character currently being processed.	errorBlock	&lt;BlockClosure&gt;	The block to execute on lexical errors.	extendedLiterals	&lt;Boolean&gt;	True if IBM-type literals are allowed. In VW, this is false.	nameSpaceCharacter	&lt;Character&gt;	The character used to separate namespaces.	numberType	&lt;ByteSymbol&gt;	The method to perform: to scan a number. 	separatorsInLiterals	&lt;Boolean&gt;	True if separators are allowed within literals.	stream	&lt;PositionableStream&gt;	Contains the text to be scanned.	tokenStart	&lt;Integer&gt;	The source position of the beginning of the current token	errorActions	&lt;OrderedCollection of: RBErrorAction&gt;	The errors actions that are needed to fix the original source code.Class Instance Variables	classificationTable	&lt;Array&gt;		the default classification table for all charactersShared Variables	PatternVariableCharacter	&lt;Character&gt;	the character that starts a pattern node</body></comment><class><name>RBCascadeNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messages semicolons </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBCascadeNode</class-id><body>RBCascadeNode is an AST node for cascaded messages (e.g., "self print1 ; print2").Instance Variables:	messages	&lt;SequenceableCollection of: RBMessageNode&gt;	the messages 	semicolons	&lt;SequenceableCollection of: Integer&gt;	positions of the ; between messages</body></comment><class><name>RBLiteralArrayToken</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBLiteralArrayToken</class-id><body>I'm the first class respresentation of a literal array. e.g. #(1 2 #symbol #[255] #('embedded'))</body></comment><class><name>RBLiteralToken</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stopPosition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBLiteralToken</class-id><body>RBLiteralToken is the first-class representation of a literal token (entire literals, even literal arrays, are a single token in the ST80 grammar.).Instance Variables:	stopPosition	&lt;Integer&gt;	The position within the source code where the token terminates.</body></comment><class><name>RBMultiKeywordLiteralToken</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBLiteralToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBMultiKeywordLiteralToken</class-id><body>Special pseudo token to aggregate singular keywords into a single token.</body></comment><class><name>RBTagNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector selectorParts arguments brackets </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBTagNode</class-id><body>RBTagNode is an AST node that represents a "Tag" (or Pragma) in a method body. E.g. '&lt;primitive: 42&gt;' or '&lt;resource: #image&gt;'. TagNodes look like MessageNodes, but differ in that they have no reciever, and their arguments are constrianed to literals. Also, the selector(Parts) cannot be a binary type selector (e.g. +, -, etc).Instance Variables:	arguments	&lt;Stack of: RBLiteralNode&gt;	nodes for the literals associate with each keyword, empty when unary	selector	&lt;Symbol | nil&gt;	the selector we're sending (lazy cached)	selectorParts	&lt;Stack of: RBValueToken&gt;	the tokens for each keyword	brackets&lt;Interval&gt;		the start and stop in the source of the &lt; &gt;'s</body></comment><class><name>RBSpecialCharacterToken</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBSpecialCharacterToken</class-id><body>RBSpecialCharacterToken is the first class representation of special characters.</body></comment><class><name>RBMethodNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector selectorParts body source arguments tags replacements nodeReplacements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBMethodNode</class-id><body>RBMethodNode is the AST that represents a Smalltalk method.Instance Variables:	arguments	&lt;SequenceableCollection of: RBVariableNode&gt;	the arguments to the method	body	&lt;BRSequenceNode&gt;	the body/statements of the method	nodeReplacements	&lt;Dictionary&gt;	a dictionary of oldNode -&gt; newNode replacements	replacements	&lt;Collection of: RBStringReplacement&gt;	the collection of string replacements for each node replacement in the parse tree	selector	&lt;Symbol | nil&gt;	the method name (cached)	selectorParts	&lt;SequenceableCollection of: RBValueToken&gt;	the tokens for the selector keywords	source	&lt;String&gt;	the source we compiled	tags		&lt;SequenceableCollection of: RBTagNode&gt;	nodes for any tags (annotations/pragmas) this method defines</body></comment><class><name>RBPatternMethodNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBMethodNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBPatternMethodNode</class-id><body>RBPatternMethodNode is a RBMethodNode that will match other method nodes without their selectors being equal. Instance Variables:	isList	&lt;Boolean&gt;	are we matching each keyword or matching all keywords together (e.g., `keyword1: would match a one argument method whereas `@keywords: would match 0 or more arguments)</body></comment><class><name>RBErrorAction</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBErrorAction</class-id><body>RBErrorAction is an abstract class that represents a corrective action taken by the parser when it parses an invalid method.</body></comment><class><name>RBInsertErrorAction</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBErrorAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>text position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBInsertErrorAction</class-id><body>RBInsertErrorAction represents an insertion corrective action. For example, if we are parsing an empty string as a method, we need to insert a method pattern so that we can parse a method.Instance Variables	position	&lt;Integer&gt;	the location in the string that the text should be inserted at (it may be one past the end of the string)	text	&lt;String&gt;	the text that when inserted would produce the returned parsed tree</body></comment><class><name>RBNumberLiteralToken</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBLiteralToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBNumberLiteralToken</class-id><body>Specialized token for number literals. This allows us to capture and remember the format of the entered number. Otherwise we end up turning the developer's input of 16rFF into 255 on formatting.Instance Variables	source	&lt;String&gt;	the input print format of the number</body></comment><class><name>RBParseTreeRule</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searchTree owner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBParseTreeRule</class-id><body>RBParseTreeRule is the abstract superclass of all of the parse tree searching rules. A parse tree rule is the first class representation of a particular rule to search for. The owner of a rule is the algorithm that actually executes the search. This arrangement allows multiple searches to be conducted by a single Searcher.Instance Variables:	owner	&lt;ParseTreeSearcher&gt;	The searcher that is actually performing the search.	searchTree	&lt;RBProgramNode&gt;	The parse tree to be searched.</body></comment><class><name>RBReplaceRule</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBParseTreeRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>verificationBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBReplaceRule</class-id><body>RBReplaceRule is the abstract superclass of all of the transforming rules. The rules change the source code by replacing the node that matches the rule. Subclasses implement different strategies for this replacement.Subclasses must implement the following messages:	matching		foundMatchFor:Instance Variables:	verificationBlock	&lt;BlockClosure&gt;	Is evaluated with the matching node. This allows for further verification of a match beyond simple tree matching.</body></comment><class><name>RBPatternBlockToken</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBPatternBlockToken</class-id><body>RBPatternBlockToken is the first-class representation of the pattern block token.</body></comment><class><name>RBLiteralNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBLiteralNode</class-id><body>Abstract node class for Smalltalk literals.Subclasses must implement the following messages:	accessing		value</body></comment><class><name>RBDeleteErrorAction</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBErrorAction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>item </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBDeleteErrorAction</class-id><body>RBDeleteErrorAction represents a deletion corrective action (e.g., deleting a ")" token from an expression -- "3 + 4)").Instance Variables	item	&lt;RBProgramNode | RBToken&gt;	the token or node that was deleted to parse the source</body></comment><class><name>RBScannerError</name><environment>Refactory.Browser</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBScannerError</class-id><body>Raise when the scanner errors while trying to scan as Smalltalk source but might continue as whitespace, and/or to distinguish other scanner-specific states.</body></comment><class><name>RBPatternScanner</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBScanner</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBPatternScanner</class-id><body>RBPatternScanner is a subclass of RBScanner that allows the extended syntax of pattern matching trees.</body></comment><class><name>RBReturnNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>return value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBReturnNode</class-id><body>RBReturnNode is an AST node that represents a return expression.Instance Variables:	return	&lt;Integer&gt;	the position of the ^ character	value	&lt;RBValueNode&gt;	the value that is being returned</body></comment><class><name>RBVariableNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>token </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBVariableNode</class-id><body>RBVariableNode is an AST node that represent a variable (global, inst var, temp, etc.).Instance Variables:	token	&lt;RBValueToken&gt;	the token that contains our name and position</body></comment><class><name>RBSequenceNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leftBar rightBar statements periods temporaries </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBSequenceNode</class-id><body>RBSequenceNode is an AST node that represents a sequence of statements. Both RBBlockNodes and RBMethodNodes contain these.Instance Variables:	leftBar	&lt;Integer | nil&gt;	the position of the left | in the temporaries definition	periods	&lt;SequenceableCollection of: Integer&gt;	the positions of all the periods that separate the statements	rightBar	&lt;Integer | nil&gt;	the position of the right | in the temporaries definition	statements	&lt;SequenceableCollection of: RBStatementNode&gt;	the statement nodes	temporaries	&lt;SequenceableCollection of: RBVariableNode&gt;	the temporaries defined</body></comment><class><name>RBMessageNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver selector selectorParts arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBMessageNode</class-id><body>RBMessageNode is an AST node that represents a message send.Instance Variables:	arguments	&lt;SequenceableCollection of: RBValueNode&gt;	our argument nodes	receiver	&lt;RBValueNode&gt;	the receiver's node	selector	&lt;Symbol | nil&gt;	the selector we're sending (lazy cached)	selectorParts	&lt;SequenceableCollection of: RBValueToken&gt;	the tokens for each keyword</body></comment><class><name>RBProgramNodeVisitor</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBProgramNodeVisitor</class-id><body>RBProgramNodeVisitor is an abstract visitor for the RBProgramNodes.</body></comment><class><name>ParseTreeSearcher</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>searches answer argumentSearches context messages </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.ParseTreeSearcher</class-id><body>ParseTreeSearcher walks over a normal source code parse tree using the visitor pattern, and then matches these nodes against the meta-nodes using the match:inContext: methods defined for the meta-nodes.Instance Variables	answer	&lt;Object&gt;	the "answer" that is propagated between matches	argumentSearches	&lt;Collection of: (Association key: RBProgramNode value: BlockClosure)&gt;	argument searches (search for the BRProgramNode and perform the BlockClosure when its found)	context	&lt;CompactDictionary&gt;	a dictionary that contains what each meta-node matches against. We use a CompactDictionary because they are fast for small sets.	messages	&lt;Collection&gt;	the sent messages in our searches	searches	&lt;Collection of: (Association key: RBProgramNode value: BlockClosure)&gt;	non-argument searches (search for the BRProgramNode and perform the BlockClosure when its found)</body></comment><class><name>RBKeywordToken</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBKeywordToken</class-id><body>RBKeywordToken is the first-class representation of a keyword token (e.g. add:)</body></comment><class><name>RBParser</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scanner currentToken nextToken errorBlock source comments errorActions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBParser</class-id><body>RBParser takes a source code string and generates an AST for it. This is a hand-written, recursive descent parser and has been optimized for speed. The simplest way to call this is either 'RBParser parseExpression: aString' if you want the AST for an expression, or 'RBParser parseMethod: aString' if you want to parse an entire method.Instance Variables	comments	&lt;OrderedCollection of: Interval&gt;	The collection of comment intervals that have been processed since the last node.	currentToken	&lt;RBToken&gt;	The current token being processed.	errorActions	&lt;SequenceableCollection of: RBErrorAction&gt;	The collection of error actions that need to be added to the current node.	errorBlock	&lt;BlockClosure&gt;	The block to evaluate on a syntax error.	nextToken	&lt;RBToken&gt;	The next token that will be processed. This allows one-token lookahead.	scanner	&lt;RBScanner&gt;	The scanner that generates a stream of tokens to parse.	source	&lt;String&gt;	The source code to parse</body></comment><class><name>RBPatternParser</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBPatternParser</class-id><body>RBPatternParser is a subclass of RBParser that allows the extended syntax that creates matching trees. These trees can be used by the ParseTreeMatcher to search and transform source code.</body></comment><class><name>RBAssignmentNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variable assignment value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBAssignmentNode</class-id><body>RBAssignmentNode is an AST node for assignment statementsInstance Variables:	assignment	&lt;Integer&gt;	position of the :=	value	&lt;RBValueNode&gt;	the value that we're assigning	variable	&lt;RBVariableNode&gt;	the variable being assigned</body></comment><class><name>RBCDeclarationNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBTagNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBCDeclarationNode</class-id><body>I am a specialized form of a Method Tag.</body></comment><class><name>RBStringReplaceRule</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBReplaceRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>replaceTree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBStringReplaceRule</class-id><body>RBStringReplaceRule replaces a matched tree with another tree (which may include metavariable from the matching tree). This is a very succint syntax for specifying most rewrites.Instance Variables:	replaceTree	&lt;RBProgramNode&gt;	The tree to replace the matched tree with.</body></comment><class><name>RBLiteralArrayNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBLiteralNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isByteArray stop contents start </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBLiteralArrayNode</class-id><body>I represent literal arrays of both the byte array and literal kind.Instance Variables:	contents	&lt;(Collection of: (RBLiteralNode ))&gt;	description of contents	isByteArray	&lt;Boolean&gt;	am I a ByteArray?	start	&lt;Integer&gt;	start position for the node	stop	&lt;Integer&gt;	stop positon for the node</body></comment><class><name>RBAssignmentToken</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBAssignmentToken</class-id><body>RBAssignmentToken is the first-class representation of the assignment token ':='</body></comment><class><name>RBLiteralValueNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBLiteralNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>token </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBLiteralValueNode</class-id><body>RBLiteralNode is an AST node that represents literals (e.g., #foo, #(1 2 3), true, etc.).Instance Variables:	token	&lt;RBLiteralToken&gt;	the token that contains the literal value as well as its source positions</body></comment><class><name>RBPatternVariableNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBVariableNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>recurseInto isList isLiteral isStatement isAnything </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBPatternVariableNode</class-id><body>RBPatternVariableNode is an AST node that is used to match several other types of nodes (literals, variables, value nodes, statement nodes, and sequences of statement nodes).The different types of matches are determined by the name of the node. If the name contains a # character, then it will match a literal. If it contains, a . then it matches statements. If it contains no extra characters, then it matches only variables. These options are mutually exclusive.The @ character can be combined with the name to match lists of items. If combined with the . character, then it will match a list of statement nodes (0 or more). If used without the . or # character, then it matches anything except for list of statements. Combining the @ with the # is not supported.Adding another ` in the name will cause the search/replace to look for more matches inside the node that this node matched. This option should not be used for top level expressions since that would cause infinite recursion (e.g., searching only for "``@anything").Instance Variables:	isAnything	&lt;Boolean&gt;	can we match any type of node	isList	&lt;Boolean&gt;	can we match a list of items (@)	isLiteral	&lt;Boolean&gt;	only match a literal node (#)	isStatement	&lt;Boolean&gt;	only match statements (.)	recurseInto	&lt;Boolean&gt;	search for more matches in the node we match (`)</body></comment><class><name>RBFormatter</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>codeStream lineStart firstLineLength tabs lineLengthLimit horizontalSpacing verticalSpacing terminatorFrequency isInBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBFormatter</class-id><body>RBFormatter formats an RB parse tree. It is nearly identical to the style set forth in "Smalltalk with Style" by Kent Beck.UsageThis is rarely called directly. Sending #formattedCode to a parse tree uses this algorithm to return a pretty-printed version.I have a limited amount of configurability, regarding whitespace and periods. They are initialized to the initial values in class side shares. Which can be set using the Settings tool. Each of these three tuning points, can be set to 1, 2, or 3, indicative of "minimal, moderate, and extreme."Terminator Frequency	Minimal - Place periods at the end of the statements only where they are absolutely required by the Smalltalk syntax. This means there will not be one at the end of the method, nor will there be any at the ends of blocks.	Moderate - Like "Minimal", but will emit a period at the end of the method.	Extreme - Emit periods at the end of every statement, including the end of the method, and the last statement of each block.Vertical Spacing	Minimal - Pack all rows together, with no blank lines in between.	Moderate - Leave a blank line between the method signature and the body of the method. If there is a method comment, the blank line is inserted below it.	Extreme - Places blank lines above and below | temporaries | as well as on both sides of eacy method comment.Horizonal Spacing	Minimal - No extra spaces, except those required by the Smalltalk syntax.	Moderate - Add spaces between code and "bracketing" characters, such as &lt;&gt;, (), and [], as well as between ^ and following statements.	Extreme - Also places extra spaces in #{}, #(), and #[] constructs.ImplementationI am implemented as Visitor pattern over the parse tree.Instance Variables	codeStream	&lt;PositionableStream&gt;	The buffer where the output is accumulated.	firstLineLength	&lt;Object&gt;	The length of the first line of a message send.	horizontalSpacing	&lt;Integer&gt;	Initially set to CurrentHorizontalSpacing, see Usage.	isInBlock	&lt;Boolean&gt;	Whether we're formatting inside of a block or not, conditions the effect of some of the configurability.	lineLengthLimit	&lt;Integer&gt;	The number of characters to put on one line, before we start trying to wrap lines.	lineStart	&lt;Magnitude&gt;	The position of the current line's start.	tabs	&lt;Integer&gt;	The number of tabs currently indented.	terminatorFrequency	&lt;Integer&gt;	Initially set to CurrentTerminatorFrequency, see Usage.	verticalSpacing	&lt;Integer&gt;	Initially set to CurrentVerticalSpacing, see Usage.</body></comment><class><name>RBBinarySelectorToken</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueToken</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Scanner</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBBinarySelectorToken</class-id><body>RBBinarySelectorToken is the first-class representation of a binary selector (e.g. +)</body></comment><class><name>ParseTreeRewriter</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ParseTreeSearcher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.ParseTreeRewriter</class-id><body>ParseTreeRewriter walks over and transforms its RBProgramNode (tree). If the tree is modified, then answer is set to true, and the modified tree can be retrieved by the #tree method.Instance Variables:	tree	&lt;RBProgramNode&gt;	the parse tree we're transforming</body></comment><class><name>RBBlockReplaceRule</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBReplaceRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>replaceBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBBlockReplaceRule</class-id><body>RBBlockReplaceRule replaces the matching node by the result of evaluating replaceBlock. This allows arbitrary computation to come up with a replacement.Instance Variables:	replaceBlock	&lt;BlockClosure&gt;	The block that returns the node to replace to matching node with.</body></comment><class><name>RBPatternMessageNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBMessageNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isList isCascadeList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBPatternMessageNode</class-id><body>RBPatternMessageNode is a RBMessageNode that will match other message nodes without their selectors being equal. Instance Variables:	isCascadeList	&lt;Boolean&gt;	are we matching a list of message nodes in a cascaded message	isList	&lt;Boolean&gt;	are we matching each keyword or matching all keywords together (e.g., `keyword1: would match a one argument method whereas `@keywords: would match 0 or more arguments)</body></comment><class><name>RBReadBeforeWrittenTester</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>read checkNewTemps scopeStack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBReadBeforeWrittenTester</class-id><body>RBReadBeforeWrittenTester is a visitor that identifies variables that may have been read before they are initialized.Instance Variables:	checkNewTemps	&lt;Boolean&gt;	description of checkNewTemps	read	&lt;Collection&gt;	description of read	scopeStack	&lt;OrderedCollection&gt;	description of scopeStack</body></comment><class><name>RBSearchRule</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBParseTreeRule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>answerBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBSearchRule</class-id><body>RBSearchRule is a parse tree rule that simply searches for matches to the rule. Every time a match is found, answerBlock is evaluated with the node that matches and the cureent answer. This two-argument approach allows a collection to be formed from all of the matches (Think inject:into:).Instance Variables:	answerBlock	&lt;BlockClosure&gt;	Block to evaluate with the matching node and the current answer.</body></comment><class><name>RBPrimitiveTagNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBTagNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-Parser</package></attributes></class><comment><class-id>Refactory.Browser.RBPrimitiveTagNode</class-id><body>Special subclass for &lt;primitve&gt; patterns, which do "interesting" things with some of their arguments.</body></comment><shared-variable><name>PatternVariableCharacter</name><environment>Refactory.Browser.RBScanner</environment><private>false</private><constant>false</constant><category>characters</category><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>FormatterClass</name><environment>Refactory.Browser.RBProgramNode</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>CurrentTerminatorFrequency</name><environment>Refactory.Browser.RBFormatter</environment><private>false</private><constant>false</constant><category>settings</category><initializer></initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>CurrentVerticalSpacing</name><environment>Refactory.Browser.RBFormatter</environment><private>false</private><constant>false</constant><category>settings</category><initializer></initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><shared-variable><name>CurrentHorizontalSpacing</name><environment>Refactory.Browser.RBFormatter</environment><private>false</private><constant>false</constant><category>settings</category><initializer></initializer><attributes><package>Browser-Parser</package></attributes></shared-variable><methods><class-id>Refactory.Browser.RBToken</class-id> <category>testing</category><body package="Browser-Parser">intersectsInterval: anInterval	^(anInterval first between: self start and: self stop) 		or: [self start between: anInterval first and: anInterval last]</body><body package="Browser-Parser">isAssignment	^false</body><body package="Browser-Parser">isBinary	^false</body><body package="Browser-Parser">isIdentifier	^false</body><body package="Browser-Parser">isKeyword	^false</body><body package="Browser-Parser">isLiteral	^self isLiteralToken</body><body package="Browser-Parser">isLiteralArrayToken	^false</body><body package="Browser-Parser">isLiteralToken	^false</body><body package="Browser-Parser">isPatternBlock	^false</body><body package="Browser-Parser">isPatternVariable	^false</body><body package="Browser-Parser">isSpecial	^false</body></methods><methods><class-id>Refactory.Browser.RBToken</class-id> <category>accessing</category><body package="Browser-Parser">comments	^comments</body><body package="Browser-Parser">comments: anObject	comments := anObject</body><body package="Browser-Parser">length	^self subclassResponsibility</body><body package="Browser-Parser">removePositions	sourcePointer := nil</body><body package="Browser-Parser">sourceInterval	^self start to: self stop</body><body package="Browser-Parser">start	^sourcePointer</body><body package="Browser-Parser">stop	^self start + self length - 1</body></methods><methods><class-id>Refactory.Browser.RBToken</class-id> <category>printing</category><body package="Browser-Parser">printOn: aStream 	aStream		nextPut: $ ;		nextPutAll: self class name</body></methods><methods><class-id>Refactory.Browser.RBToken</class-id> <category>initialize-release</category><body package="Browser-Parser">start: anInteger 	sourcePointer := anInteger</body></methods><methods><class-id>Refactory.Browser.RBToken class</class-id> <category>instance creation</category><body package="Browser-Parser">start: anInterval 	^self new start: anInterval</body></methods><methods><class-id>Refactory.Browser.RBValueToken</class-id> <category>private</category><body package="Browser-Parser">length	^value size</body></methods><methods><class-id>Refactory.Browser.RBValueToken</class-id> <category>printing</category><body package="Browser-Parser">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	value printOn: aStream.	aStream nextPutAll: ')'</body></methods><methods><class-id>Refactory.Browser.RBValueToken</class-id> <category>accessing</category><body package="Browser-Parser">value	^value</body><body package="Browser-Parser">value: anObject	value := anObject</body></methods><methods><class-id>Refactory.Browser.RBValueToken</class-id> <category>initialize-release</category><body package="Browser-Parser">value: aString start: anInteger 	value := aString.	sourcePointer := anInteger</body></methods><methods><class-id>Refactory.Browser.RBValueToken class</class-id> <category>instance creation</category><body package="Browser-Parser">value: aString start: anInteger 	^self new value: aString start: anInteger</body></methods><methods><class-id>Refactory.Browser.RBIdentifierToken</class-id> <category>testing</category><body package="Browser-Parser">isIdentifier	^true</body><body package="Browser-Parser">isPatternVariable	^value first == RBScanner patternVariableCharacter</body></methods><methods><class-id>Refactory.Browser.RBStringReplacement</class-id> <category>accessing</category><body package="Browser-Parser">startPosition	^startPosition</body><body package="Browser-Parser">stopPosition	^stopPosition</body><body package="Browser-Parser">string	^string</body></methods><methods><class-id>Refactory.Browser.RBStringReplacement</class-id> <category>initialize-release</category><body package="Browser-Parser">startPosition: anInteger 	startPosition := anInteger</body><body package="Browser-Parser">stopPosition: anInteger 	stopPosition := anInteger</body><body package="Browser-Parser">string: aString 	string := aString</body></methods><methods><class-id>Refactory.Browser.RBStringReplacement class</class-id> <category>instance creation</category><body package="Browser-Parser">replaceFrom: startInteger to: stopInteger with: aString 	^(self new)		startPosition: startInteger;		stopPosition: stopInteger;		string: aString;		yourself</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>visitor</category><body package="Browser-Parser">acceptVisitor: aProgramNodeVisitor 	self subclassResponsibility</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>accessing</category><body package="Browser-Parser">allArgumentVariables	| children |	children := self children.	children isEmpty ifTrue: [^#()].	^children inject: OrderedCollection new		into: 			[:vars :each | 			vars				addAll: each allArgumentVariables;				yourself]</body><body package="Browser-Parser">allDefinedVariables	| children |	children := self children.	children isEmpty ifTrue: [^#()].	^children inject: OrderedCollection new		into: 			[:vars :each | 			vars				addAll: each allDefinedVariables;				yourself]</body><body package="Browser-Parser">allLeafNodesAndTokens	| allLeafNodesAndTokens |	allLeafNodesAndTokens := OrderedCollection new.	self allLeafNodesAndTokensDo: [:each | allLeafNodesAndTokens add: each].	^allLeafNodesAndTokens</body><body package="Browser-Parser">allLeafNodesAndTokensDo: aBlockClosure	self children isEmpty ifTrue: [^aBlockClosure value: self].	self children do: [:each | each allLeafNodesAndTokensDo: aBlockClosure]</body><body package="Browser-Parser">allScopedArgumentVariables	parent == nil ifTrue: [^#()].	^parent allScopedArgumentVariables</body><body package="Browser-Parser">allScopedTemporaryVariables	parent == nil ifTrue: [^#()].	^parent allScopedTemporaryVariables</body><body package="Browser-Parser">allTemporaryVariables	| children |	children := self children.	children isEmpty ifTrue: [^#()].	^children inject: OrderedCollection new		into: 			[:vars :each | 			vars				addAll: each allTemporaryVariables;				yourself]</body><body package="Browser-Parser">asReturn	"Change the current node to a return node."	parent isNil 		ifTrue: [self error: (#CannotChangeWithoutParent &lt;&lt; #browser &gt;&gt; 'Cannot change to a return without a parent node.')].	parent isSequence 		ifFalse: [self error: (#ParentMustBeSequence &lt;&lt; #browser &gt;&gt; 'Parent node must be a sequence node.')].	(parent isLast: self) ifFalse: [self error: (#ReturnNodeMustBeLast &lt;&lt; #browser &gt;&gt; 'Return node must be last.')].	^parent addReturn</body><body package="Browser-Parser">blockVariables	^parent isNil ifTrue: [#()] ifFalse: [parent blockVariables]</body><body package="Browser-Parser">children	^#()</body><body package="Browser-Parser">comments	^comments isNil ifTrue: [#()] ifFalse: [comments]</body><body package="Browser-Parser">comments: aCollection	comments := aCollection</body><body package="Browser-Parser">definingNodeForVariable: aVariableNode	^parent definingNodeForVariable: aVariableNode</body><body package="Browser-Parser">formattedCode	^self formatterClass new format: self</body><body package="Browser-Parser">formatterClass	^self class formatterClass</body><body package="Browser-Parser">mappingFor: aNode	| method |	method := self methodNode.	method isNil ifTrue: [^aNode].	^method mappingFor: aNode</body><body package="Browser-Parser">messageSearchClassFromScope: aClass	"If possible, determine the class where a method search will start when sent to me, return nil otherwise. Some subclasses are able to do more here."		^nil</body><body package="Browser-Parser">methodComments	^self comments</body><body package="Browser-Parser">methodNode	^parent isNil ifTrue: [nil] ifFalse: [parent methodNode]</body><body package="Browser-Parser">newSource	^self formattedCode</body><body package="Browser-Parser">parent	^parent</body><body package="Browser-Parser">parent: aRBProgramNode 	parent := aRBProgramNode</body><body package="Browser-Parser">precedence	^6</body><body package="Browser-Parser">propertyAt: aSymbol ifAbsent: absentBlock	properties == nil ifTrue: [^absentBlock value].	^properties at: aSymbol ifAbsent: absentBlock</body><body package="Browser-Parser">propertyAt: aSymbol put: anObject	properties == nil ifTrue: [properties := Dictionary new].	properties at: aSymbol put: anObject</body><body package="Browser-Parser">sentMessages	| messages |	messages := Set new.	self children do: [:each | messages addAll: each sentMessages].	^messages</body><body package="Browser-Parser">source	^parent notNil ifTrue: [parent source] ifFalse: [nil]</body><body package="Browser-Parser">sourceInterval	^self start to: self stop</body><body package="Browser-Parser">start	self subclassResponsibility</body><body package="Browser-Parser">statementComments	| statementComments |	statementComments := OrderedCollection withAll: self comments.	self children do: [:each | statementComments addAll: each statementComments].	^statementComments asSortedCollection: [:a :b | a first &lt; b first]</body><body package="Browser-Parser">stop	self subclassResponsibility</body><body package="Browser-Parser">temporaryVariables	^parent isNil ifTrue: [#()] ifFalse: [parent temporaryVariables]</body><body package="Browser-Parser">top	^parent == nil ifTrue: [self] ifFalse: [parent top]</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>testing</category><body package="Browser-Parser">assigns: aVariableName 	^self children anySatisfy: [:each | each assigns: aVariableName]</body><body package="Browser-Parser">containedBy: anInterval 	^anInterval first &lt;= self start and: [anInterval last &gt;= self stop]</body><body package="Browser-Parser">containsReturn	^self children anySatisfy: [:each | each containsReturn]</body><body package="Browser-Parser">defines: aName	^false</body><body package="Browser-Parser">directlyUses: aNode	^true</body><body package="Browser-Parser">evaluatedFirst: aNode 	self children do: 			[:each | 			each == aNode ifTrue: [^true].			each isImmediateNode ifFalse: [^false]].	^false</body><body package="Browser-Parser">hasAnyErrors	^self allErrorActions notEmpty</body><body package="Browser-Parser">hasErrors	(errors notNil and: [errors notEmpty]) ifTrue: [^true].	^[self start == nil or: [self stop == nil]] on: Error do: [:exception | ^true].</body><body package="Browser-Parser">intersectsInterval: anInterval 	^(anInterval first between: self start and: self stop) 		or: [self start between: anInterval first and: anInterval last]</body><body package="Browser-Parser">isAssignment	^false</body><body package="Browser-Parser">isBlock	^false</body><body package="Browser-Parser">isCDeclaration	^false</body><body package="Browser-Parser">isCascade	^false</body><body package="Browser-Parser">isDirectlyUsed	"This node is directly used as an argument, receiver, or part of an assignment."	^parent isNil ifTrue: [false] ifFalse: [parent directlyUses: self]</body><body package="Browser-Parser">isEvaluatedFirst	"Return true if we are the first thing evaluated in this statement."	^parent isNil or: [parent isSequence or: [parent evaluatedFirst: self]]</body><body package="Browser-Parser">isImmediateNode	^false</body><body package="Browser-Parser">isLast: aNode 	| children |	children := self children.	^children notEmpty and: [children last == aNode]</body><body package="Browser-Parser">isLiteralArray	^false</body><body package="Browser-Parser">isLiteralNode	^false</body><body package="Browser-Parser">isMessage	^false</body><body package="Browser-Parser">isMethod	^false</body><body package="Browser-Parser">isReturn	^false</body><body package="Browser-Parser">isSelf		^false</body><body package="Browser-Parser">isSequence	^false</body><body package="Browser-Parser">isSuper		^false</body><body package="Browser-Parser">isTagNode	^false</body><body package="Browser-Parser">isUsed	"Answer true if this node could be used as part of another expression. For example, you could use the 	result of this node as a receiver of a message, an argument, the right part of an assignment, or the 	return value of a block. This differs from isDirectlyUsed in that it is conservative since it also includes 	return values of blocks."	^parent isNil ifTrue: [false] ifFalse: [parent uses: self]</body><body package="Browser-Parser">isValue	^false</body><body package="Browser-Parser">isVariable	^false</body><body package="Browser-Parser">isVariableDeclaration	"Return true if the node is a variable and is the declaration of a variable, not the use of a variable."		^false</body><body package="Browser-Parser">lastIsReturn	^self isReturn</body><body package="Browser-Parser">references: aVariableName 	^self children anySatisfy: [:each | each references: aVariableName]</body><body package="Browser-Parser">uses: aNode	^true</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>querying</category><body package="Browser-Parser">bestNodeFor: anInterval 	| selectedChildren |	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	selectedChildren := self children 				select: [:each | each intersectsInterval: anInterval].	^selectedChildren size == 1 		ifTrue: [selectedChildren first bestNodeFor: anInterval]		ifFalse: [self]</body><body package="Browser-Parser">bestNodeForPosition: aPosition	(aPosition between: self start - 1 and: self stop) ifFalse: [^nil].	self children do: [:each | (each bestNodeForPosition: aPosition) ifNotNil: [:aNode | ^aNode]].	^self</body><body package="Browser-Parser">bestTokenFor: anInterval	^self</body><body package="Browser-Parser">selfMessages	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: 'self `@msg: ``@args'		do: 			[:aNode :answer | 			answer				add: aNode selector;				yourself].	^searcher executeTree: self initialAnswer: Set new</body><body package="Browser-Parser">statementNode	"Return your topmost node that is contained by a sequence node."	(parent isNil or: [parent isSequence]) ifTrue: [^self].	^parent statementNode</body><body package="Browser-Parser">superMessages	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: 'super `@msg: ``@args'		do: 			[:aNode :answer | 			answer				add: aNode selector;				yourself].	^searcher executeTree: self initialAnswer: Set new</body><body package="Browser-Parser">whichNodeIsContainedBy: anInterval 	| selectedChildren |	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	selectedChildren := self children 				select: [:each | each intersectsInterval: anInterval].	^selectedChildren size == 1 		ifTrue: [selectedChildren first whichNodeIsContainedBy: anInterval]		ifFalse: [nil]</body><body package="Browser-Parser">whoDefines: aName	^(self defines: aName)		ifTrue: [self]		ifFalse: [parent ifNotNil: [parent whoDefines: aName]]</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>meta variable-accessing</category><body package="Browser-Parser">cascadeListCharacter	^$;</body><body package="Browser-Parser">listCharacter	^$@</body><body package="Browser-Parser">literalCharacter	^$#</body><body package="Browser-Parser">recurseIntoCharacter	^$`</body><body package="Browser-Parser">statementCharacter	^$.</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>enumeration</category><body package="Browser-Parser">allCommentsDo: aBlock	self comments do: aBlock.	self children do: [:each | each allCommentsDo: aBlock]</body><body package="Browser-Parser">collect: aBlock 	"Hacked to fit collection protocols"	^aBlock value: self</body><body package="Browser-Parser">do: aBlock 	"Hacked to fit collection protocols"	aBlock value: self</body><body package="Browser-Parser">size	"Hacked to fit collection protocols"	^1</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>copying</category><body package="Browser-Parser">copyCommentsFrom: aNode 	"Add all comments from aNode to us. If we already have the comment, then don't add it."	| newComments |	newComments := OrderedCollection new.	aNode nodesDo: [:each | newComments addAll: each comments].	self nodesDo: 			[:each | 			each comments do: [:comment | newComments remove: comment ifAbsent: []]].	newComments isEmpty ifTrue: [^self].	newComments := newComments asSortedCollection: [:a :b | a first &lt; b first].	self comments: newComments</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>matching</category><body package="Browser-Parser">copyInContext: aDictionary	^self copy</body><body package="Browser-Parser">copyList: matchNodes inContext: aDictionary 	| newNodes |	newNodes := OrderedCollection new.	matchNodes do: 			[:each | 			| object |			object := each copyInContext: aDictionary.			newNodes addAll: object].	^newNodes</body><body package="Browser-Parser">equalTo: aNode exceptForNewVariables: newVariableCollection oldVariables: oldVariableCollection	"the method performs the same test as equalTo:exceptForVariables: except that it also ensures that &lt;value&gt; is a variable that was found in &lt;oldVariableCollection&gt;	The method is used to test if two methods share the same body but can have different names for the same variable. 	The variables that are supported is limited to method-arguments."		| dictionary |	dictionary := Dictionary new.	(self equalTo: aNode withMapping: dictionary) ifFalse: [^false].	dictionary keysAndValuesDo: 			[:key :value |			(key = value or: 					[(newVariableCollection includes: key)						and: [oldVariableCollection includes: value]])				ifFalse: [^false]].	^true</body><body package="Browser-Parser">match: aNode inContext: aDictionary 	^self = aNode</body><body package="Browser-Parser">matchList: matchNodes against: programNodes inContext: aDictionary 	^self		matchList: matchNodes		index: 1		against: programNodes		index: 1		inContext: aDictionary</body><body package="Browser-Parser">matchList: matchNodes index: matchIndex against: programNodes index: programIndex inContext: aDictionary 	| node currentIndex currentDictionary nodes |	matchNodes size &lt; matchIndex ifTrue: [^programNodes size &lt; programIndex].	node := matchNodes at: matchIndex.	node isList 		ifTrue: 			[currentIndex := programIndex - 1.						[currentDictionary := aDictionary copy.			programNodes size &lt; currentIndex or: 					[nodes := programNodes copyFrom: programIndex to: currentIndex.					(currentDictionary at: node ifAbsentPut: [nodes]) = nodes and: 							[(self 								matchList: matchNodes								index: matchIndex + 1								against: programNodes								index: currentIndex + 1								inContext: currentDictionary) 									ifTrue: 										[currentDictionary 											keysAndValuesDo: [:key :value | aDictionary at: key put: value].										^true].							false]]] 					whileFalse: [currentIndex := currentIndex + 1].			^false].	programNodes size &lt; programIndex ifTrue: [^false].	(node match: (programNodes at: programIndex) inContext: aDictionary) 		ifFalse: [^false].	^self 		matchList: matchNodes		index: matchIndex + 1		against: programNodes		index: programIndex + 1		inContext: aDictionary</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>comparing</category><body package="Browser-Parser">equalTo: aNode exceptForVariables: variableNameCollection 	| dictionary |	dictionary := Dictionary new.	(self equalTo: aNode withMapping: dictionary) ifFalse: [^false].	dictionary keysAndValuesDo: 			[:key :value | 			(key = value or: [variableNameCollection includes: key]) ifFalse: [^false]].	^true</body><body package="Browser-Parser">equalTo: aNode withMapping: aDictionary 	^self = aNode</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>testing-matching</category><body package="Browser-Parser">canMatchMethod: aCompiledMethod 	^self sentMessages allSatisfy: 			[:each | 			(self class optimizedSelectors includes: each) 				or: [aCompiledMethod refersToLiteral: each]]</body><body package="Browser-Parser">isList	^false</body><body package="Browser-Parser">isPatternNode	^false</body><body package="Browser-Parser">recurseInto	^false</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>iterating</category><body package="Browser-Parser">nodesDo: aBlock 	aBlock value: self.	self children do: [:each | each nodesDo: aBlock]</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>printing</category><body package="Browser-Parser">printOn: aStream 	aStream		nextPutAll: self class fullName;		nextPut: $(;		nextPutAll: self formattedCode;		nextPut: $)</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>replacing</category><body package="Browser-Parser">addReplacement: aStringReplacement	parent isNil ifTrue: [^self].	parent addReplacement: aStringReplacement</body><body package="Browser-Parser">clearReplacements	parent isNil ifTrue: [^self].	parent clearReplacements</body><body package="Browser-Parser">removeDeadCode	self children do: [:each | each removeDeadCode]</body><body package="Browser-Parser">replaceMethodSource: aNode 	"We are being replaced with aNode -- if possible try to perform an in place edit of the source."	| method |	method := self methodNode.	method notNil ifTrue: [method map: self to: aNode].	aNode parent: self parent.	[self replaceSourceWith: aNode] on: Error		do: 			[:ex | 			self clearReplacements.			ex return]</body><body package="Browser-Parser">replaceNode: aNode withNode: anotherNode 	self error: (#IDontStoreOtherNodes &lt;&lt; #browser &gt;&gt; 'I don''t store other nodes')</body><body package="Browser-Parser">replaceWith: aNode 	parent isNil ifTrue: [self error: (#ThisNodeHasNoParent &lt;&lt; #browser &gt;&gt; 'This node doesn''t have a parent')].	self replaceMethodSource: aNode.	parent replaceNode: self withNode: aNode</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>private-replacing</category><body package="Browser-Parser">replaceSourceFrom: aNode 	self clearReplacements</body><body package="Browser-Parser">replaceSourceWith: aNode 	aNode replaceSourceFrom: self</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>utility</category><body package="Browser-Parser">composeSelector: aSequenceOfTokens	^aSequenceOfTokens size = 1		ifTrue: [aSequenceOfTokens first value asSymbol]		ifFalse:			[| ws |			ws := String new writeStream.			aSequenceOfTokens do: [:each | ws nextPutAll: each value].			ws contents asSymbol]</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>errors</category><body package="Browser-Parser">addErrorAction: aRBErrorAction	errors isNil ifTrue: [errors := OrderedCollection new].	errors add: aRBErrorAction</body><body package="Browser-Parser">addErrorActions: aCollection	aCollection do: [:each | self addErrorAction: each]</body><body package="Browser-Parser">allErrorActions	| allErrors |	allErrors := OrderedCollection new.	self nodesDo: [:each | allErrors addAll: each errorActions].	^allErrors</body><body package="Browser-Parser">errorActions	^errors ifNil: [#()]</body></methods><methods><class-id>Refactory.Browser.RBProgramNode class</class-id> <category>accessing</category><body package="Browser-Parser">formatterClass	^FormatterClass ifNil: [RBFormatter] ifNotNil: [FormatterClass]</body><body package="Browser-Parser">formatterClass: aClass 	FormatterClass := aClass</body><body package="Browser-Parser">optimizedSelectors	^#(#ifTrue: #ifTrue:ifFalse: #ifFalse: #ifFalse:ifTrue: #whileTrue: #whileTrue #whileFalse: #whileFalse #to:do: #to:by:do: #and: #or: #repeat #timesRepeat:)</body></methods><methods><class-id>Refactory.Browser.RBValueNode</class-id> <category>accessing</category><body package="Browser-Parser">addParenthesis: anInterval 	parentheses isNil ifTrue: [parentheses := OrderedCollection new: 1].	parentheses add: anInterval</body><body package="Browser-Parser">parentheses	^parentheses isNil ifTrue: [#()] ifFalse: [parentheses]</body><body package="Browser-Parser">start	^parentheses isNil 		ifTrue: [self startWithoutParentheses]		ifFalse: [parentheses last first]</body><body package="Browser-Parser">startWithoutParentheses	^self subclassResponsibility</body><body package="Browser-Parser">stop	^parentheses isNil		ifTrue: [self stopWithoutParentheses]		ifFalse: [parentheses last last]</body><body package="Browser-Parser">stopWithoutParentheses	^self subclassResponsibility</body></methods><methods><class-id>Refactory.Browser.RBValueNode</class-id> <category>testing</category><body package="Browser-Parser">containedBy: anInterval 	^anInterval first &lt;= self startWithoutParentheses 		and: [anInterval last &gt;= self stopWithoutParentheses]</body><body package="Browser-Parser">hasParentheses	^self parentheses notEmpty</body><body package="Browser-Parser">isValue	^true</body><body package="Browser-Parser">needsParenthesis	^self subclassResponsibility</body></methods><methods><class-id>Refactory.Browser.RBBlockNode</class-id> <category>comparing</category><body package="Browser-Parser">= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	self body = anObject body ifFalse: [^false].	self arguments size = anObject arguments size ifFalse: [^false].	1 to: self arguments size		do: [:i | (self arguments at: i) = (anObject arguments at: i) ifFalse: [^false]].	^true</body><body package="Browser-Parser">equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	self arguments size = anObject arguments size ifFalse: [^false].	1 to: self arguments size		do: 			[:i | 			((self arguments at: i) equalTo: (anObject arguments at: i)				withMapping: aDictionary) ifFalse: [^false]].	(self body equalTo: anObject body withMapping: aDictionary)		ifFalse: [^false].	self arguments do: [:each | aDictionary removeKey: each name].	^true</body><body package="Browser-Parser">hash	^self arguments hash bitXor: self body hash</body></methods><methods><class-id>Refactory.Browser.RBBlockNode</class-id> <category>visitor</category><body package="Browser-Parser">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptBlockNode: self</body></methods><methods><class-id>Refactory.Browser.RBBlockNode</class-id> <category>accessing</category><body package="Browser-Parser">allArgumentVariables	^(self argumentNames asOrderedCollection)		addAll: super allArgumentVariables;		yourself</body><body package="Browser-Parser">allDefinedVariables	^(self argumentNames asOrderedCollection)		addAll: super allDefinedVariables;		yourself</body><body package="Browser-Parser">allScopedArgumentVariables	^self argumentNames asOrderedCollection, super allScopedArgumentVariables</body><body package="Browser-Parser">argumentNames	^self arguments collect: [:each | each name]</body><body package="Browser-Parser">arguments	^arguments</body><body package="Browser-Parser">arguments: argCollection 	arguments := argCollection.	arguments do: [:each | each parent: self]</body><body package="Browser-Parser">bar	^bar</body><body package="Browser-Parser">bar: anObject	bar := anObject</body><body package="Browser-Parser">blockVariables	| vars |	vars := super blockVariables asOrderedCollection.	vars addAll: self argumentNames.	^vars</body><body package="Browser-Parser">body	^body</body><body package="Browser-Parser">body: stmtsNode 	body := stmtsNode.	body parent: self</body><body package="Browser-Parser">children	^self arguments copyWith: self body</body><body package="Browser-Parser">colons: aCollection 	colons := aCollection</body><body package="Browser-Parser">definingNodeForVariable: aVariableNode	(self argumentNames includes: aVariableNode) ifTrue: [^self].	^parent definingNodeForVariable: aVariableNode</body><body package="Browser-Parser">left	^left</body><body package="Browser-Parser">left: anObject	left := anObject</body><body package="Browser-Parser">precedence	^0</body><body package="Browser-Parser">right	^right</body><body package="Browser-Parser">right: anObject	right := anObject</body><body package="Browser-Parser">startWithoutParentheses	^left</body><body package="Browser-Parser">statementComments	^self comments</body><body package="Browser-Parser">stopWithoutParentheses	^right</body></methods><methods><class-id>Refactory.Browser.RBBlockNode</class-id> <category>matching</category><body package="Browser-Parser">copyInContext: aDictionary 	^(self class new)		arguments: (self copyList: arguments inContext: aDictionary);		body: (body copyInContext: aDictionary);		yourself</body><body package="Browser-Parser">match: aNode inContext: aDictionary 	aNode class == self class ifFalse: [^false].	^(self 		matchList: arguments		against: aNode arguments		inContext: aDictionary) 			and: [body match: aNode body inContext: aDictionary]</body></methods><methods><class-id>Refactory.Browser.RBBlockNode</class-id> <category>testing</category><body package="Browser-Parser">defines: aName 	^arguments anySatisfy: [:each | each name = aName]</body><body package="Browser-Parser">directlyUses: aNode 	^false</body><body package="Browser-Parser">isBlock	^true</body><body package="Browser-Parser">isImmediateNode	^true</body><body package="Browser-Parser">isLast: aNode 	^body isLast: aNode</body><body package="Browser-Parser">needsParenthesis	^false</body><body package="Browser-Parser">references: aVariableName 	^body references: aVariableName</body><body package="Browser-Parser">uses: aNode 	aNode = body ifFalse: [^false].	^parent isMessage 		ifTrue: 			[(#(#ifTrue:ifFalse: #ifTrue: #ifFalse: #ifFalse:ifTrue:) 				includes: parent selector) not 				or: [parent isUsed]]		ifFalse: [self isUsed]</body></methods><methods><class-id>Refactory.Browser.RBBlockNode</class-id> <category>copying</category><body package="Browser-Parser">postCopy	super postCopy.	self arguments: (self arguments collect: [:each | each copy]).	self body: self body copy</body></methods><methods><class-id>Refactory.Browser.RBBlockNode</class-id> <category>replacing</category><body package="Browser-Parser">replaceNode: aNode withNode: anotherNode 	body == aNode ifTrue: [self body: anotherNode].	self arguments: (arguments 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])</body></methods><methods><class-id>Refactory.Browser.RBBlockNode class</class-id> <category>instance creation</category><body package="Browser-Parser">arguments: argNodes body: sequenceNode 	^(self new)		arguments: argNodes;		body: sequenceNode;		yourself</body><body package="Browser-Parser">body: sequenceNode 	^self arguments: #() body: sequenceNode</body></methods><methods><class-id>Refactory.Browser.RBPatternBlockNode</class-id> <category>visitor</category><body package="Browser-Parser">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptPatternBlockNode: self</body></methods><methods><class-id>Refactory.Browser.RBPatternBlockNode</class-id> <category>matching</category><body package="Browser-Parser">addArgumentWithNameBasedOn: aString to: aRBBlockNode 	| name index vars |	name := aString.	vars := aRBBlockNode allDefinedVariables.	index := 0.	[vars includes: name] whileTrue: 			[index := index + 1.			name := name , index printString].	aRBBlockNode 		arguments: (aRBBlockNode arguments copyWith: (RBVariableNode named: name))</body><body package="Browser-Parser">constructLookupNodeFor: aString in: aRBBlockNode 	| argumentNode |	argumentNode := RBLiteralNode literalToken: (RBLiteralToken 						value: aString						start: nil						stop: nil).	^RBMessageNode 		receiver: (RBVariableNode named: 'self')		selector: #lookupMatchFor:in:		arguments: (Array with: argumentNode with: aRBBlockNode arguments last)</body><body package="Browser-Parser">copyInContext: aDictionary 	^self replacingBlock value: aDictionary</body><body package="Browser-Parser">createBlockFor: aRBBlockNode 	| source |	self replacePatternNodesIn: aRBBlockNode.	source := aRBBlockNode formattedCode.	^Compiler 		evaluate: source		for: self		logged: false</body><body package="Browser-Parser">createMatchingBlock	| newBlock |	self arguments size &gt; 2 		ifTrue: 			[self 				error: (#GenKey7 &lt;&lt; #browser &gt;&gt; 'Search blocks can only contain arguments for the node and matching dictionary')].	newBlock := RBBlockNode arguments: arguments body: body.	newBlock arguments isEmpty 		ifTrue: [self addArgumentWithNameBasedOn: 'aNode' to: newBlock].	newBlock arguments size = 1 		ifTrue: [self addArgumentWithNameBasedOn: 'aDictionary' to: newBlock].	^self createBlockFor: newBlock</body><body package="Browser-Parser">createReplacingBlock	| newBlock |	self arguments size &gt; 1 		ifTrue: 			[self 				error: (#GenKey8 &lt;&lt; #browser &gt;&gt; 'Replace blocks can only contain an argument for the matching dictionary')].	newBlock := RBBlockNode arguments: arguments body: body.	self arguments isEmpty 		ifTrue: [self addArgumentWithNameBasedOn: 'aDictionary' to: newBlock].	^self createBlockFor: newBlock</body><body package="Browser-Parser">lookupMatchFor: aString in: aDictionary 	^aDictionary at: aString		ifAbsent: 			[| variableNode |			variableNode := RBPatternVariableNode named: aString.			aDictionary at: variableNode ifAbsent: [nil]]</body><body package="Browser-Parser">match: aNode inContext: aDictionary 	^self matchingBlock value: aNode value: aDictionary</body><body package="Browser-Parser">matchingBlock	^valueBlock isNil 		ifTrue: [valueBlock := self createMatchingBlock]		ifFalse: [valueBlock]</body><body package="Browser-Parser">replacePatternNodesIn: aRBBlockNode 	aRBBlockNode body nodesDo: 			[:each | 			(each isVariable and: [each isPatternNode]) 				ifTrue: 					[each 						replaceWith: (self constructLookupNodeFor: each name in: aRBBlockNode)]]</body><body package="Browser-Parser">replacingBlock	^valueBlock isNil 		ifTrue: [valueBlock := self createReplacingBlock]		ifFalse: [valueBlock]</body></methods><methods><class-id>Refactory.Browser.RBPatternBlockNode</class-id> <category>accessing</category><body package="Browser-Parser">sentMessages	^OrderedCollection new</body></methods><methods><class-id>Refactory.Browser.RBPatternWrapperBlockNode</class-id> <category>visitor</category><body package="Browser-Parser">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptPatternWrapperBlockNode: self</body></methods><methods><class-id>Refactory.Browser.RBPatternWrapperBlockNode</class-id> <category>matching</category><body package="Browser-Parser">copyInContext: aDictionary 	"I don't know what this would mean, so ignore it."	^wrappedNode copyInContext: aDictionary</body><body package="Browser-Parser">match: aNode inContext: aDictionary 	(wrappedNode match: aNode inContext: aDictionary) ifFalse: [^false].	^super match: aNode inContext: aDictionary</body></methods><methods><class-id>Refactory.Browser.RBPatternWrapperBlockNode</class-id> <category>accessing</category><body package="Browser-Parser">precedence	^1</body><body package="Browser-Parser">wrappedNode	^wrappedNode</body><body package="Browser-Parser">wrappedNode: aRBProgramNode 	wrappedNode := aRBProgramNode.	aRBProgramNode parent: self</body></methods><methods><class-id>Refactory.Browser.RBScanner</class-id> <category>testing</category><body package="Browser-Parser">atEnd	^characterType == #eof</body><body package="Browser-Parser">isReadable	^true</body><body package="Browser-Parser">isWritable	^false</body></methods><methods><class-id>Refactory.Browser.RBScanner</class-id> <category>accessing</category><body package="Browser-Parser">contents	| contentsStream |	contentsStream := WriteStream on: (Array new: 50).	self do: [:each | contentsStream nextPut: each].	^contentsStream contents</body><body package="Browser-Parser">error: message	^RBScannerError raiseErrorString: message</body><body package="Browser-Parser">errorBlock: aBlock	errorBlock := aBlock</body><body package="Browser-Parser">flush</body><body package="Browser-Parser">getComments	| oldComments |	comments isEmpty ifTrue: [^nil].	oldComments := comments.	comments := OrderedCollection new: 1.	^oldComments</body><body package="Browser-Parser">getErrorActions	| errors |	errors := errorActions ifNil: [#()].	errorActions := nil.	^errors</body><body package="Browser-Parser">next	"When the buffer is reset, we need to make sure to reset the content type as well as the buffer pointer."	| token |	buffer := WriteStream on: (String new: 60).	tokenStart := stream position.	token := characterType == #eof 		ifTrue: [			"The EOF token should occur after the end of input"			RBToken start: tokenStart + 1]		ifFalse: [self scanToken].	self stripSeparators.	token comments: self getComments.	^token</body><body package="Browser-Parser">nextPut: anObject 	"Provide an error notification that the receiver does not	implement this message."	self shouldNotImplement</body><body package="Browser-Parser">position: aPosition	"Use this very sparingly and very carefully. We need to reset any intermediate state."	stream position: aPosition</body><body package="Browser-Parser">scanToken	"fast-n-ugly. Don't write stuff like this. Has been found to cause cancer in laboratory rats. Basically a 	case statement. Didn't use Dictionary because lookup is pretty slow."	characterType == #alphabetic ifTrue: [^self scanIdentifierOrKeyword].	(characterType == #digit		or: [currentCharacter == $- and: [(self classify: stream peek) == #digit]])			ifTrue: [^self scanNumber].	characterType == #binary ifTrue: [^self scanBinary: RBBinarySelectorToken].	characterType == #special ifTrue: [^self scanSpecialCharacter].	currentCharacter == $' ifTrue: [^self scanLiteralString].	currentCharacter == $# ifTrue: [^self scanLiteral].	currentCharacter == $$ ifTrue: [^self scanLiteralCharacter].	^self scanUnknownCharacter</body><body package="Browser-Parser">skipUntil: aCharacter	| position |	(stream skipThrough: aCharacter) isNil		ifTrue: 			[self scannerError: (#x1sNotFound &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; not found'						expandMacrosWith: (String with: aCharacter)).			self insert: (String with: aCharacter) at: self errorPosition + 1].	position := stream position.	self step.	self stripSeparators.	^position</body><body package="Browser-Parser">sourceStream	^stream</body></methods><methods><class-id>Refactory.Browser.RBScanner</class-id> <category>private</category><body package="Browser-Parser">addErrorAction: aRBErrorAction	errorActions isNil ifTrue: [errorActions := OrderedCollection new].	errorActions add: aRBErrorAction</body><body package="Browser-Parser">classify: aCharacter 	| index |	aCharacter isNil ifTrue: [^nil].	index := aCharacter asInteger.	index == 0 ifTrue: [^#separator].	index &gt; 255 		ifTrue: 			[^aCharacter isLetter 				ifTrue: [#alphabetic]				ifFalse: [aCharacter isSeparator ifTrue: [#separator] ifFalse: [nil]]].	^classificationTable at: index</body><body package="Browser-Parser">previousStepPosition	^characterType == #eof 		ifTrue: [stream position]		ifFalse: [stream position - 1]</body><body package="Browser-Parser">step	stream atEnd 		ifTrue: 			[characterType := #eof.			^currentCharacter := nil].	currentCharacter := stream next.	characterType := self classify: currentCharacter.	^currentCharacter</body></methods><methods><class-id>Refactory.Browser.RBScanner</class-id> <category>error handling</category><body package="Browser-Parser">errorBlock	^errorBlock isNil ifTrue: [[:message :position | ]] ifFalse: [errorBlock]</body><body package="Browser-Parser">errorPosition	^stream position</body><body package="Browser-Parser">scannerError: aString	errorBlock notNil		ifTrue: 			[errorBlock				value: aString				value: self errorPosition				value: self]</body></methods><methods><class-id>Refactory.Browser.RBScanner</class-id> <category>initialize-release</category><body package="Browser-Parser">on: aStream	buffer := WriteStream on: (String new: 60).	stream := aStream.	classificationTable := self class classificationTable.	comments := OrderedCollection new</body></methods><methods><class-id>Refactory.Browser.RBScanner</class-id> <category>private-scanning</category><body package="Browser-Parser">scanAnySymbol	characterType == #alphabetic ifTrue: [^self scanSymbol].	characterType == #binary ifTrue: [^self scanBinary: RBLiteralToken].	^RBToken new</body><body package="Browser-Parser">scanBinary: aClass	"Patched to do ANSI compliant binary selectors."		| val |	buffer nextPut: currentCharacter.	self step.	[characterType == #binary]		whileTrue:			[buffer nextPut: currentCharacter.			self step].	val := buffer contents.	val := val asSymbol.	^aClass value: val start: tokenStart</body><body package="Browser-Parser">scanIdentifierOrKeyword	| token name |	self scanName.	currentCharacter == $.		ifTrue:			[token := self scanNameSpaceName.			token notNil ifTrue: [^token]].	(currentCharacter == $: and: [stream peek ~~ $=])		ifTrue: [^self scanKeyword].	name := buffer contents.	name = 'true'		ifTrue:			[^RBLiteralToken				value: true				start: tokenStart				stop: self previousStepPosition].	name = 'false'		ifTrue:			[^RBLiteralToken				value: false				start: tokenStart				stop: self previousStepPosition].	name = 'nil'		ifTrue:			[^RBLiteralToken				value: nil				start: tokenStart				stop: self previousStepPosition].	^RBIdentifierToken		value: name		start: tokenStart</body><body package="Browser-Parser">scanKeyword	| outputPosition inputPosition name |	[currentCharacter == $:] whileTrue: 			[buffer nextPut: currentCharacter.			outputPosition := buffer position.			inputPosition := stream position.			self step.	":"			[characterType == #alphabetic] whileTrue: [self scanName]].	buffer position: outputPosition.	stream position: inputPosition.	self step.	name := buffer contents.	^(name occurrencesOf: $:) == 1 		ifTrue: [RBKeywordToken value: name start: tokenStart]		ifFalse: 			[RBMultiKeywordLiteralToken 				value: name asSymbol				start: tokenStart				stop: tokenStart + name size - 1]</body><body package="Browser-Parser">scanLiteral	self step.	self stripSeparators.	characterType == #alphabetic ifTrue: [^self scanSymbol].	characterType == #binary		ifTrue: [^(self scanBinary: RBLiteralToken) stop: self previousStepPosition].	currentCharacter == $' ifTrue: [^self scanStringSymbol].	(currentCharacter == $( or: [currentCharacter == $[])		ifTrue: [^self scanLiteralArrayToken].	currentCharacter == ${ ifTrue: [^self scanQualifiedReference].	^self scanUnknownSymbol</body><body package="Browser-Parser">scanLiteralArrayToken	| token |	token := RBLiteralArrayToken 				value: (String with: $# with: currentCharacter)				start: tokenStart.	self step.	^token</body><body package="Browser-Parser">scanLiteralCharacter	| token |	self step.	"$"	token := RBLiteralToken 				value: currentCharacter				start: tokenStart				stop: stream position.	self step.	"char"	^token</body><body package="Browser-Parser">scanLiteralString	self step.		[currentCharacter isNil		ifTrue: 			[self scannerError: #UnmatchedQuoteInString &lt;&lt; #browser &gt;&gt; 'Unmatched '' in string literal.'.			self insert: '''' at: self errorPosition + 1].	currentCharacter isNil or: [currentCharacter == $' and: [self step ~~ $']]]			whileFalse: 				[buffer nextPut: currentCharacter.				self step].	^RBLiteralToken		value: buffer contents		start: tokenStart		stop: self previousStepPosition</body><body package="Browser-Parser">scanName	[characterType == #alphabetic or: [characterType == #digit]] whileTrue: 			[buffer nextPut: currentCharacter.			self step]</body><body package="Browser-Parser">scanNameSpaceName	(stream atEnd or: [(self classify: stream peek) ~~ #alphabetic])		ifTrue: [^nil].	buffer nextPut: $..	self step.	self scanName.	currentCharacter == $. ifTrue: [self scanNameSpaceName].	^RBIdentifierToken		value: buffer contents		start: tokenStart</body><body package="Browser-Parser">scanNumber	| start number stop string currentPosition |	start := stream position.	stream skip: -1.	[ number := Number readSmalltalkSyntaxFrom: stream ] on: ArithmeticError do: [ :err | nil ].	self step.	currentPosition := stream position.	stop := self atEnd		ifTrue: [currentPosition]		ifFalse: [currentPosition - 1].	stream position: start - 1.	string := stream next: stop - start + 1.	stream position: currentPosition.	^RBNumberLiteralToken		value: number		start: start		stop: stop		source: string</body><body package="Browser-Parser">scanQualifiedReference	| nameToken position |	self step.	"{"	self stripSeparators.	position := stream position.	stream atEnd ifFalse: [position := position - 1].	(characterType == #alphabetic and: 			[(nameToken := self scanIdentifierOrKeyword) isIdentifier				and: [nameToken value notEmpty]])		ifFalse: 			[self scannerError: #InvalidNameInQRef &lt;&lt; #browser						&gt;&gt; 'Invalid name in qualified reference'.			self position: position.			self step.			self insert: RBParser missingQualifiedReferenceName at: position + 1.			nameToken := RBIdentifierToken						value: RBParser missingQualifiedReferenceName						start: 0].	self stripSeparators.	currentCharacter == $}		ifTrue: [self step	"}"]		ifFalse: 			[self scannerError: #CloseBraceExpected &lt;&lt; #browser &gt;&gt; '} expected'.			self insert: '}'				at: (stream atEnd ifTrue: [stream position + 1] ifFalse: [stream position])].	^RBLiteralToken		value: (BindingReference pathString: nameToken value)		start: tokenStart		stop: self previousStepPosition</body><body package="Browser-Parser">scanSpecialCharacter	| character |	currentCharacter == $: 		ifTrue: 			[self step.			^currentCharacter == $= 				ifTrue: 					[self step.					RBAssignmentToken start: tokenStart]				ifFalse: [RBSpecialCharacterToken value: $: start: tokenStart]].	character := currentCharacter.	self step.	^RBSpecialCharacterToken value: character start: tokenStart</body><body package="Browser-Parser">scanStringSymbol	| literalToken |	literalToken := self scanLiteralString.	literalToken value: literalToken value asSymbol.	^literalToken</body><body package="Browser-Parser">scanSymbol	| lastPosition hasColon value startPosition |	hasColon := false.	startPosition := lastPosition := stream position.	[characterType == #alphabetic] whileTrue: 			[self scanName.			currentCharacter == $: 				ifTrue: 					[buffer nextPut: $:.					hasColon := true.					lastPosition := stream position.					self step]].	value := buffer contents.	(hasColon and: [value last ~~ $:]) 		ifTrue: 			[stream position: lastPosition.			self step.			value := value copyFrom: 1 to: lastPosition - startPosition + 1].	^RBLiteralToken 		value: value asSymbol		start: tokenStart		stop: self previousStepPosition</body><body package="Browser-Parser">stripComment	| start stop |	start := stream position.	[self step == $"] whileFalse: 			[characterType == #eof				ifTrue: 					[self scannerError: #UnmatchedQuoteInComment &lt;&lt; #browser &gt;&gt; 'Unmatched " in comment.'.					^self insert: '"' at: self errorPosition + 1]].	stop := stream position.	self step.	comments add: (start to: stop)</body><body package="Browser-Parser">stripSeparators		[[characterType == #separator] whileTrue: [self step].	currentCharacter == $"] 			whileTrue: [self stripComment]</body></methods><methods><class-id>Refactory.Browser.RBScanner</class-id> <category>private-scanning-error handling</category><body package="Browser-Parser">delete: aCharacter	self addErrorAction: (RBDeleteErrorAction				item: (RBSpecialCharacterToken value: aCharacter start: self errorPosition))</body><body package="Browser-Parser">insert: aString	self insert: aString at: self errorPosition</body><body package="Browser-Parser">insert: aString at: anInteger	self addErrorAction: (RBInsertErrorAction insert: aString at: anInteger)</body><body package="Browser-Parser">scanUnknownCharacter	self scannerError: #UnknownCharacter &lt;&lt; #browser &gt;&gt; 'Unknown character'.	self delete: currentCharacter.	self step.	characterType == #eof ifTrue: [^RBSpecialCharacterToken value: nil start: tokenStart].	^self scanToken</body><body package="Browser-Parser">scanUnknownSymbol	self scannerError: #ExpectingALiteralType &lt;&lt; #browser				&gt;&gt; 'Expecting a literal type'.	self insert: RBParser missingVariableName , ' '.	^RBLiteralToken		value: RBParser missingVariableName asSymbol		start: tokenStart		stop: self errorPosition</body></methods><methods><class-id>Refactory.Browser.RBScanner class</class-id> <category>accessing</category><body package="Browser-Parser">classificationTable	classificationTable isNil ifTrue: [self initializeClassificationTable].	^classificationTable</body><body package="Browser-Parser">patternVariableCharacter	^PatternVariableCharacter</body></methods><methods><class-id>Refactory.Browser.RBScanner class</class-id> <category>class initialization</category><body package="Browser-Parser">initialize	self initializeClassificationTable</body><body package="Browser-Parser">initializeChars: characters to: aSymbol 	characters do: [:c | classificationTable at: c asInteger put: aSymbol]</body><body package="Browser-Parser">initializeClassificationTable	| allCharacters |	PatternVariableCharacter := $`.	classificationTable := Array new: 255.	allCharacters := (1 to: 255) collect: [:i | Character value: i].	self initializeChars: (allCharacters select: [:each | each isLetter])		to: #alphabetic.	self initializeChars: '_' to: #alphabetic.	self initializeChars: '01234567890' to: #digit.	self initializeChars: '!%&amp;*+,-/&lt;=&gt;?@\~|' to: #binary.	classificationTable at: 177 put: #binary.	"plus-or-minus"	classificationTable at: 183 put: #binary.	"centered dot"	classificationTable at: 215 put: #binary.	"times"	classificationTable at: 247 put: #binary.	"divide"	self initializeChars: '().:;[]^{}' to: #special.	self initializeChars: (allCharacters select: [:each | each isSeparator])		to: #separator</body></methods><methods><class-id>Refactory.Browser.RBScanner class</class-id> <category>testing</category><body package="Browser-Parser">isSelector: aSymbol 	| scanner token |	scanner := self basicNew.	scanner on: (ReadStream on: aSymbol asString).	scanner step.	token := scanner scanAnySymbol.	token isLiteralToken ifFalse: [^false].	token value isEmpty ifTrue: [^false].	^scanner atEnd</body><body package="Browser-Parser">isVariable: aString 	| scanner token |	scanner := self on: (ReadStream on: aString) errorBlock: [:s :p | ^false].	token := scanner next.	token isIdentifier ifFalse: [^false].	(token start = 1 and: [token stop = aString size]) ifFalse: [^false].	^(aString includes: $.) not</body></methods><methods><class-id>Refactory.Browser.RBScanner class</class-id> <category>instance creation</category><body package="Browser-Parser">on: aStream 	| str |	str := self basicNew on: aStream.	str		step;		stripSeparators.	^str</body><body package="Browser-Parser">on: aStream errorBlock: aBlock 	| str |	str := self basicNew on: aStream.	str		errorBlock: aBlock;		step;		stripSeparators.	^str</body></methods><methods><class-id>Refactory.Browser.RBScanner class</class-id> <category>utility</category><body package="Browser-Parser">scanTextFragments: aSmalltalkSource	"Return a series of TextFragment objects, derived from a SmalltalkSource, where each fragment represents a smalltalk language token, or the whitespace runs in between."	^aSmalltalkSource smalltalkOrWordAndWhitespaceFragments</body></methods><methods><class-id>Refactory.Browser.RBCascadeNode</class-id> <category>comparing</category><body package="Browser-Parser">= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	self messages size = anObject messages size ifFalse: [^false].	1 to: self messages size		do: [:i | (self messages at: i) = (anObject messages at: i) ifFalse: [^false]].	^true</body><body package="Browser-Parser">equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	self messages size == anObject messages size ifFalse: [^false].	1 to: self messages size		do: 			[:i | 			((self messages at: i) equalTo: (anObject messages at: i)				withMapping: aDictionary) ifFalse: [^false]].	^true</body><body package="Browser-Parser">hash	^self messages hash</body></methods><methods><class-id>Refactory.Browser.RBCascadeNode</class-id> <category>visitor</category><body package="Browser-Parser">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptCascadeNode: self</body></methods><methods><class-id>Refactory.Browser.RBCascadeNode</class-id> <category>querying</category><body package="Browser-Parser">bestNodeFor: anInterval 	| selectedChildren |	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	messages 		reverseDo: [:each | (each containedBy: anInterval) ifTrue: [^each]].	selectedChildren := (messages 				collect: [:each | each bestNodeFor: anInterval]) 					reject: [:each | each isNil].	^selectedChildren detect: [:each | true] ifNone: [nil]</body><body package="Browser-Parser">whichNodeIsContainedBy: anInterval 	| selectedChildren |	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	messages 		reverseDo: [:each | (each containedBy: anInterval) ifTrue: [^each]].	selectedChildren := (messages 				collect: [:each | each whichNodeIsContainedBy: anInterval]) 					reject: [:each | each isNil].	^selectedChildren detect: [:each | true] ifNone: [nil]</body></methods><methods><class-id>Refactory.Browser.RBCascadeNode</class-id> <category>accessing</category><body package="Browser-Parser">children	^self messages</body><body package="Browser-Parser">messages	^messages</body><body package="Browser-Parser">messages: messageNodeCollection 	messages := messageNodeCollection.	messages do: [:each | each parent: self]</body><body package="Browser-Parser">precedence	^4</body><body package="Browser-Parser">receiver	^self messages first receiver</body><body package="Browser-Parser">semicolons	^semicolons</body><body package="Browser-Parser">startWithoutParentheses	^messages first start</body><body package="Browser-Parser">statementComments	| statementComments |	statementComments := OrderedCollection withAll: self comments.	statementComments addAll: messages first receiver statementComments.	messages do: 			[:each | 			each arguments 				do: [:arg | statementComments addAll: arg statementComments]].	^statementComments asSortedCollection: [:a :b | a first &lt; b first]</body><body package="Browser-Parser">stopWithoutParentheses	^messages last stop</body></methods><methods><class-id>Refactory.Browser.RBCascadeNode</class-id> <category>testing</category><body package="Browser-Parser">directlyUses: aNode 	^messages last = aNode and: [self isDirectlyUsed]</body><body package="Browser-Parser">isCascade	^true</body><body package="Browser-Parser">needsParenthesis	^parent isNil 		ifTrue: [false]		ifFalse: [self precedence &gt; parent precedence]</body><body package="Browser-Parser">uses: aNode 	^messages last = aNode and: [self isUsed]</body></methods><methods><class-id>Refactory.Browser.RBCascadeNode</class-id> <category>initialize-release</category><body package="Browser-Parser">messages: messageNodes semicolons: integerCollection	self messages: messageNodes.	semicolons := integerCollection</body></methods><methods><class-id>Refactory.Browser.RBCascadeNode</class-id> <category>copying</category><body package="Browser-Parser">postCopy	super postCopy.	self messages: (self messages collect: [:each | each copy])</body></methods><methods><class-id>Refactory.Browser.RBCascadeNode</class-id> <category>replacing</category><body package="Browser-Parser">replaceNode: aNode withNode: anotherNode 	self messages: (messages 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])</body></methods><methods><class-id>Refactory.Browser.RBCascadeNode</class-id> <category>matching</category><body package="Browser-Parser">copyInContext: aDictionary 	^(self class new)		messages: (self copyList: messages inContext: aDictionary);		yourself</body><body package="Browser-Parser">match: aNode inContext: aDictionary 	aNode class == self class ifFalse: [^false].	^self 		matchList: messages		against: aNode messages		inContext: aDictionary</body></methods><methods><class-id>Refactory.Browser.RBCascadeNode class</class-id> <category>instance creation</category><body package="Browser-Parser">messages: messageNodes 	^self new messages: messageNodes</body><body package="Browser-Parser">messages: messageNodes semicolons: integerCollection 	^self new messages: messageNodes semicolons: integerCollection</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayToken</class-id> <category>testing</category><body package="Browser-Parser">isForByteArray	^value last = $[</body><body package="Browser-Parser">isLiteralArrayToken	^true</body></methods><methods><class-id>Refactory.Browser.RBLiteralToken</class-id> <category>testing</category><body package="Browser-Parser">isLiteralToken	^true</body><body package="Browser-Parser">isMultiKeyword	^false</body></methods><methods><class-id>Refactory.Browser.RBLiteralToken</class-id> <category>private</category><body package="Browser-Parser">length	^stopPosition - self start + 1</body></methods><methods><class-id>Refactory.Browser.RBLiteralToken</class-id> <category>accessing</category><body package="Browser-Parser">realValue	^value</body><body package="Browser-Parser">stop: anObject 	stopPosition := anObject</body></methods><methods><class-id>Refactory.Browser.RBLiteralToken</class-id> <category>initialize-release</category><body package="Browser-Parser">value: aString start: anInteger stop: stopInteger 	value := aString.	sourcePointer := anInteger.	stopPosition := stopInteger</body></methods><methods><class-id>Refactory.Browser.RBLiteralToken</class-id> <category>printing</category><body package="Browser-Parser">storeOn: aStream 	value isSymbol 		ifTrue: 			[aStream nextPut: $#.			((RBScanner isSelector: value) and: [value ~~ #'||']) 				ifTrue: [aStream nextPutAll: value]				ifFalse: [value asString printOn: aStream].			^self].	value class == Character 		ifTrue: 			[aStream				nextPut: $$;				nextPut: value.			^self].	value storeOn: aStream</body></methods><methods><class-id>Refactory.Browser.RBLiteralToken class</class-id> <category>instance creation</category><body package="Browser-Parser">value: anObject 	| literal |	literal := anObject class == Array 				ifTrue: [anObject collect: [:each | self value: each]]				ifFalse: [anObject].	^self 		value: literal		start: nil		stop: nil</body><body package="Browser-Parser">value: anObject at: aPosition	| literal |	literal := anObject class == Array 				ifTrue: [anObject collect: [:each | self value: each]]				ifFalse: [anObject].	^self 		value: literal		start: aPosition		stop: aPosition - 1</body><body package="Browser-Parser">value: aString start: anInteger stop: stopInteger 	^(self new)		value: aString			start: anInteger			stop: stopInteger;		yourself</body></methods><methods><class-id>Refactory.Browser.RBMultiKeywordLiteralToken</class-id> <category>testing</category><body package="Browser-Parser">isMultiKeyword	^true</body></methods><methods><class-id>Refactory.Browser.RBTagNode</class-id> <category>accessing</category><body package="Browser-Parser">allLeafNodesAndTokensDo: aBlockClosure	| selectorPartsStream argumentsStream |	selectorPartsStream := selectorParts readStream.	argumentsStream := self arguments readStream.	[selectorPartsStream atEnd ifFalse: [aBlockClosure value: selectorPartsStream next].	argumentsStream atEnd] whileFalse: [argumentsStream next allLeafNodesAndTokensDo: aBlockClosure]</body><body package="Browser-Parser">arguments	^arguments isNil ifTrue: [#()] ifFalse: [arguments]</body><body package="Browser-Parser">arguments: argCollection 	arguments := argCollection.	arguments do: [:each | each parent: self]</body><body package="Browser-Parser">brackets	^brackets</body><body package="Browser-Parser">brackets: anInterval	brackets := anInterval</body><body package="Browser-Parser">children	^self arguments</body><body package="Browser-Parser">numArgs	^self selector numArgs</body><body package="Browser-Parser">selector	^selector == nil		ifTrue: [selector := self composeSelector: selectorParts]		ifFalse: [selector]</body><body package="Browser-Parser">sentMessages	^self selector</body><body package="Browser-Parser">start	^brackets first</body><body package="Browser-Parser">stop	^brackets last</body></methods><methods><class-id>Refactory.Browser.RBTagNode</class-id> <category>testing</category><body package="Browser-Parser">isKeyword	^self isUnary not</body><body package="Browser-Parser">isPrimitiveTag	^false</body><body package="Browser-Parser">isTagNode	^true</body><body package="Browser-Parser">isUnary	^arguments isEmpty</body><body package="Browser-Parser">looksLikePrimitiveTag	"Assumes that someone else checked/knows already that I have one or more arguments."	^selectorParts first value = 'primitive:'</body></methods><methods><class-id>Refactory.Browser.RBTagNode</class-id> <category>private</category><body package="Browser-Parser">becomePrimitiveTag	"Convert the receiver into my subclass specific to primitives. This assumes all the appropriate checks have already been performed."	| originalLiteralNode newVariableNode newIdentifierToken |	self changeClassTo: RBPrimitiveTagNode.	self selectorParts last value = 'errorCode:' ifFalse: [^self].	originalLiteralNode := arguments last.	newIdentifierToken := RBIdentifierToken				value: originalLiteralNode token value asString				start: originalLiteralNode token start.	newVariableNode := RBVariableNode identifierToken: newIdentifierToken.	newVariableNode parent: self.	arguments at: arguments size put: newVariableNode</body><body package="Browser-Parser">buildSelector	| selectorStream |	selectorStream := WriteStream on: (String new: 50).	selectorParts do: [:each | selectorStream nextPutAll: each value].	^selectorStream contents asSymbol</body><body package="Browser-Parser">selectorParts	^selectorParts</body><body package="Browser-Parser">selectorParts: tokenCollection 	selectorParts := tokenCollection</body></methods><methods><class-id>Refactory.Browser.RBTagNode</class-id> <category>copying</category><body package="Browser-Parser">postCopy	super postCopy.	self arguments: (self arguments collect: [:each | each copy])</body></methods><methods><class-id>Refactory.Browser.RBTagNode</class-id> <category>visitor</category><body package="Browser-Parser">acceptVisitor: aProgramNodeVisitor	aProgramNodeVisitor acceptTagNode: self</body></methods><methods><class-id>Refactory.Browser.RBTagNode</class-id> <category>comparing</category><body package="Browser-Parser">= anObject	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	self selector = anObject selector ifFalse: [^false].	arguments		keysAndValuesDo:			[:i :each | each = (anObject arguments at: i) ifFalse: [^false]].	^true</body><body package="Browser-Parser">hash	^self selector hash		bitXor:			(self arguments isEmpty				ifTrue: [0]				ifFalse: [self arguments first hash])</body></methods><methods><class-id>Refactory.Browser.RBTagNode</class-id> <category>initialize-release</category><body package="Browser-Parser">selectorParts: keywordTokens arguments: valueNodes	self selectorParts: keywordTokens.	self arguments: valueNodes</body></methods><methods><class-id>Refactory.Browser.RBTagNode</class-id> <category>querying</category><body package="Browser-Parser">bestTokenFor: anInterval	^selectorParts		detect: [:each | each intersectsInterval: anInterval]		ifNone: [self]</body></methods><methods><class-id>Refactory.Browser.RBTagNode class</class-id> <category>instance creation</category><body package="Browser-Parser">selectorParts: keywordTokens arguments: valueNodes	^(self new)		selectorParts: keywordTokens arguments: valueNodes;		yourself</body></methods><methods><class-id>Refactory.Browser.RBSpecialCharacterToken</class-id> <category>testing</category><body package="Browser-Parser">isSpecial	^true</body></methods><methods><class-id>Refactory.Browser.RBSpecialCharacterToken</class-id> <category>private</category><body package="Browser-Parser">length	^1</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>comparing</category><body package="Browser-Parser">= anObject	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	(self selector = anObject selector and: [self body = anObject body])		ifFalse: [^false].	1 to: self arguments size		do: [:i | (self arguments at: i) = (anObject arguments at: i) ifFalse: [^false]].	self tags size = anObject tags size ifFalse: [^false].	1 to: self tags size		do: [:i | (self tags at: i) = (anObject tags at: i) ifFalse: [^false]].	^true</body><body package="Browser-Parser">equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	(self selector = anObject selector 		and: [self body equalTo: anObject body withMapping: aDictionary]) 			ifFalse: [^false].	1 to: self arguments size		do: 			[:i | 			((self arguments at: i) equalTo: (anObject arguments at: i)				withMapping: aDictionary) ifFalse: [^false].			aDictionary removeKey: (self arguments at: i) name].	^self primitiveSources = anObject primitiveSources</body><body package="Browser-Parser">hash	^(self selector hash bitXor: self body hash) bitXor: self arguments hash</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>visitor</category><body package="Browser-Parser">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptMethodNode: self</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>accessing</category><body package="Browser-Parser">addNode: aNode 	^body addNode: aNode</body><body package="Browser-Parser">addReturn	body addReturn</body><body package="Browser-Parser">addSelfReturn	^body addSelfReturn</body><body package="Browser-Parser">allArgumentVariables	^(self argumentNames asOrderedCollection)		addAll: super allArgumentVariables;		yourself</body><body package="Browser-Parser">allDefinedVariables	^(self argumentNames asOrderedCollection)		addAll: super allDefinedVariables;		yourself</body><body package="Browser-Parser">allLeafNodesAndTokensDo: aBlockClosure	| selectorPartsStream argumentsStream |	selectorPartsStream := selectorParts readStream.	argumentsStream := self arguments readStream.	[selectorPartsStream atEnd ifFalse: [aBlockClosure value: selectorPartsStream next].	argumentsStream atEnd] whileFalse: [argumentsStream next allLeafNodesAndTokensDo: aBlockClosure].	self tags do: [:each | each allLeafNodesAndTokensDo: aBlockClosure].	self body allLeafNodesAndTokensDo: aBlockClosure</body><body package="Browser-Parser">allScopedArgumentVariables	^self argumentNames asOrderedCollection, super allScopedArgumentVariables</body><body package="Browser-Parser">argumentNames	^self arguments collect: [:each | each name]</body><body package="Browser-Parser">arguments	^arguments</body><body package="Browser-Parser">arguments: variableNodes 	arguments := variableNodes.	arguments do: [:each | each parent: self]</body><body package="Browser-Parser">body	^body</body><body package="Browser-Parser">body: stmtsNode 	body := stmtsNode.	body parent: self</body><body package="Browser-Parser">children	^self arguments , self tags copyWith: self body</body><body package="Browser-Parser">definingNodeForVariable: aVariableNode	(self argumentNames includes: aVariableNode) ifTrue: [^self].	^parent definingNodeForVariable: aVariableNode</body><body package="Browser-Parser">methodComments	| methodComments |	methodComments := OrderedCollection withAll: self comments.	arguments do: [:each | methodComments addAll: each comments].	^methodComments asSortedCollection: [:a :b | a first &lt; b first]</body><body package="Browser-Parser">methodNode	^self</body><body package="Browser-Parser">newSource	replacements isNil ifTrue: [^self formattedCode].	^[self reformatSource] on: Error do: [:ex | ex return: self formattedCode]</body><body package="Browser-Parser">numArgs	^self selector numArgs</body><body package="Browser-Parser">primitiveSources	^self tags 		collect: [:each | self source copyFrom: each start to: each stop]</body><body package="Browser-Parser">renameSelector: newSelector andArguments: varNodeCollection 	| oldSelectorParts oldArguments |	oldSelectorParts := selectorParts.	oldArguments := arguments.	self		arguments: varNodeCollection;		selector: newSelector.	self changeSourceSelectors: oldSelectorParts arguments: oldArguments</body><body package="Browser-Parser">selector	^selector == nil		ifTrue: [selector := self composeSelector: selectorParts]		ifFalse: [selector]</body><body package="Browser-Parser">selector: aSelector 	| keywords numArgs |	keywords := aSelector keywords.	numArgs := aSelector numArgs.	numArgs == arguments size 		ifFalse: 			[self 				error: (#AssignmentWithWrongArgNumber &lt;&lt; #browser &gt;&gt; 'Attempting to assign selector with wrong number of arguments.')].	selectorParts := numArgs == 0 				ifTrue: [Array with: (RBIdentifierToken value: keywords first start: nil)]				ifFalse: 					[keywords first last == $: 						ifTrue: [keywords collect: [:each | RBKeywordToken value: each start: nil]]						ifFalse: [Array with: (RBBinarySelectorToken value: aSelector start: nil)]].	selector := aSelector</body><body package="Browser-Parser">source	^source</body><body package="Browser-Parser">source: anObject	source := anObject</body><body package="Browser-Parser">start	^1</body><body package="Browser-Parser">stop	^source size</body><body package="Browser-Parser">tagCount	^tags size</body><body package="Browser-Parser">tags	^tags isNil ifTrue: [#()] ifFalse: [tags]</body><body package="Browser-Parser">tags: aSequenceOfTagNodes	tags := aSequenceOfTagNodes.	self tagsDo: [:each | each parent: self]</body><body package="Browser-Parser">tagsDo: aBlock	"Shortcut for tags do:. A preponderance of methods have no tags, so we can shortcircuit this with a nil check"	tags == nil ifTrue: [^self].	tags do: aBlock</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>private</category><body package="Browser-Parser">buildSelector	| selectorStream |	selectorStream := WriteStream on: (String new: 50).	selectorParts do: [:each | selectorStream nextPutAll: each value].	^selectorStream contents asSymbol</body><body package="Browser-Parser">reformatSource	| newSource stream |	stream := WriteStream on: (String new: source size + 100).	stream 		nextPutAll: (source copyFrom: (replacements inject: 1						into: 							[:sum :each | 							stream								nextPutAll: (source copyFrom: sum to: each startPosition - 1);								nextPutAll: each string.							each stopPosition + 1])				to: source size).	newSource := stream contents.	self 		= (RBParser parseMethod: newSource onError: [:s :p | ^self formattedCode]) 			ifFalse: [^self formattedCode].	"Sanity check -- make sure the formatted code is = self"	^newSource</body><body package="Browser-Parser">selectorParts	^selectorParts</body><body package="Browser-Parser">selectorParts: tokenCollection 	selectorParts := tokenCollection</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>matching</category><body package="Browser-Parser">copyInContext: aDictionary 	^(self class new)		selectorParts: (selectorParts collect: [:each | each removePositions]);		arguments: (arguments collect: [:each | each copyInContext: aDictionary]);		body: (body copyInContext: aDictionary);		source: (aDictionary at: '-source-');		yourself</body><body package="Browser-Parser">match: aNode inContext: aDictionary 	self class == aNode class ifFalse: [^false].	aDictionary at: '-source-' put: aNode source.	self selector == aNode selector ifFalse: [^false].	^(self 		matchList: arguments		against: aNode arguments		inContext: aDictionary) 			and: [body match: aNode body inContext: aDictionary]</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>testing</category><body package="Browser-Parser">defines: aName	^(arguments anySatisfy: [:each | each name = aName])		or: [self hasCDeclaration and: [aName = '_errorCode']]</body><body package="Browser-Parser">hasCDeclaration	self tagsDo: [:each | each isCDeclaration ifTrue: [^true]].	^false</body><body package="Browser-Parser">isLast: aNode 	^body isLast: aNode</body><body package="Browser-Parser">isMethod	^true</body><body package="Browser-Parser">isPrimitive	self tagsDo: [:each | each selector = #primitive: ifTrue: [^true]].	^false</body><body package="Browser-Parser">lastIsReturn	^body lastIsReturn</body><body package="Browser-Parser">references: aVariableName 	^body references: aVariableName</body><body package="Browser-Parser">uses: aNode 	^body == aNode and: [aNode lastIsReturn]</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>copying</category><body package="Browser-Parser">postCopy	super postCopy.	self body: self body copy.	self arguments: (self arguments collect: [:each | each copy]).	self tags: (self tags collect: [:each | each copy])</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>replacing</category><body package="Browser-Parser">addReplacement: aStringReplacement 	replacements isNil ifTrue: [^self].	replacements add: aStringReplacement</body><body package="Browser-Parser">clearReplacements	replacements := nil</body><body package="Browser-Parser">map: oldNode to: newNode 	nodeReplacements at: oldNode put: newNode</body><body package="Browser-Parser">mappingFor: oldNode 	^nodeReplacements at: oldNode ifAbsent: [oldNode]</body><body package="Browser-Parser">replaceNode: aNode withNode: anotherNode 	aNode == body ifTrue: [self body: anotherNode].	self arguments: (arguments 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>initialize-release</category><body package="Browser-Parser">initialize	super initialize.	replacements := SortedCollection sortBlock: 					[:a :b | 					a startPosition &lt; b startPosition 						or: [a startPosition = b startPosition and: [a stopPosition &lt; b stopPosition]]].	nodeReplacements := IdentityDictionary new</body><body package="Browser-Parser">selectorParts: tokenCollection arguments: variableNodes 	selectorParts := tokenCollection.	self arguments: variableNodes</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>printing</category><body package="Browser-Parser">printOn: aStream 	aStream nextPutAll: self formattedCode</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>private-replacing</category><body package="Browser-Parser">changeSourceSelectors: oldSelectorParts arguments: oldArguments 		[oldSelectorParts size = selectorParts size ifFalse: [^self].	oldArguments size = arguments size ifFalse: [^self].	oldSelectorParts with: selectorParts		do: 			[:old :new | 			self addReplacement: (RBStringReplacement 						replaceFrom: old start						to: old stop						with: new value)].	oldArguments with: arguments		do: 			[:old :new | 			self addReplacement: (RBStringReplacement 						replaceFrom: old start						to: old stop						with: new name)]] 			on: Error			do: [:ex | ex return]</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>querying</category><body package="Browser-Parser">bestTokenFor: anInterval	^selectorParts		detect: [:each | each intersectsInterval: anInterval]		ifNone: [self]</body></methods><methods><class-id>Refactory.Browser.RBMethodNode class</class-id> <category>instance creation</category><body package="Browser-Parser">new	^(super new)		initialize;		yourself</body><body package="Browser-Parser">selector: aSymbol arguments: variableNodes body: aSequenceNode 	^(self new)		arguments: variableNodes;		selector: aSymbol;		body: aSequenceNode;		yourself</body><body package="Browser-Parser">selector: aSymbol body: aSequenceNode 	^self 		selector: aSymbol		arguments: #()		body: aSequenceNode</body><body package="Browser-Parser">selectorParts: tokenCollection arguments: variableNodes 	^(self new)		selectorParts: tokenCollection arguments: variableNodes;		yourself</body></methods><methods><class-id>Refactory.Browser.RBPatternMethodNode</class-id> <category>matching</category><body package="Browser-Parser">copyInContext: aDictionary 	| selectors |	selectors := self isSelectorList 				ifTrue: [(aDictionary at: selectorParts first value) keywords]				ifFalse: [selectorParts collect: [:each | aDictionary at: each value]].	^(RBMethodNode new)		selectorParts: (selectors collect: 						[:each | 						(each last == $: ifTrue: [RBKeywordToken] ifFalse: [RBIdentifierToken]) 							value: each							start: nil]);		arguments: (self copyList: arguments inContext: aDictionary);		body: (body copyInContext: aDictionary);		source: (aDictionary at: '-source-');		yourself</body><body package="Browser-Parser">match: aNode inContext: aDictionary 	aNode class == self matchingClass ifFalse: [^false].	aDictionary at: '-source-' put: aNode source.	self isSelectorList 		ifTrue: 			[^(aDictionary at: selectorParts first value ifAbsentPut: [aNode selector]) 				= aNode selector and: 						[(aDictionary at: arguments first ifAbsentPut: [aNode arguments]) 							= aNode arguments and: [body match: aNode body inContext: aDictionary]]].	^(self matchArgumentsAgainst: aNode inContext: aDictionary) 		and: [body match: aNode body inContext: aDictionary]</body><body package="Browser-Parser">matchArgumentsAgainst: aNode inContext: aDictionary 	self arguments size == aNode arguments size ifFalse: [^false].	(self matchSelectorAgainst: aNode inContext: aDictionary) 		ifFalse: [^false].	1 to: arguments size		do: 			[:i | 			((arguments at: i) match: (aNode arguments at: i) inContext: aDictionary) 				ifFalse: [^false]].	^true</body><body package="Browser-Parser">matchSelectorAgainst: aNode inContext: aDictionary 	| keyword |	1 to: selectorParts size		do: 			[:i | 			keyword := selectorParts at: i.			(aDictionary at: keyword value				ifAbsentPut: 					[keyword isPatternVariable 						ifTrue: [(aNode selectorParts at: i) value]						ifFalse: [keyword value]]) 					= (aNode selectorParts at: i) value ifFalse: [^false]].	^true</body></methods><methods><class-id>Refactory.Browser.RBPatternMethodNode</class-id> <category>testing-matching</category><body package="Browser-Parser">isPatternNode	^true</body></methods><methods><class-id>Refactory.Browser.RBPatternMethodNode</class-id> <category>testing</category><body package="Browser-Parser">isSelectorList	^isList</body></methods><methods><class-id>Refactory.Browser.RBPatternMethodNode</class-id> <category>private</category><body package="Browser-Parser">matchingClass	^RBMethodNode</body></methods><methods><class-id>Refactory.Browser.RBPatternMethodNode</class-id> <category>initialize-release</category><body package="Browser-Parser">selectorParts: tokenCollection arguments: variableNodes 	super selectorParts: tokenCollection arguments: variableNodes.	isList := (tokenCollection first value at: 2) == self listCharacter</body></methods><methods><class-id>Refactory.Browser.RBPatternMethodNode class</class-id> <category>instance creation</category><body package="Browser-Parser">selectorParts: tokenCollection arguments: variableNodes 	^(tokenCollection anySatisfy: [:each | each isPatternVariable]) 		ifTrue: [super selectorParts: tokenCollection arguments: variableNodes]		ifFalse: 			[RBMethodNode selectorParts: tokenCollection arguments: variableNodes]</body></methods><methods><class-id>Refactory.Browser.RBErrorAction</class-id> <category>testing</category><body package="Browser-Parser">isDeletion	^false</body><body package="Browser-Parser">isInsertion	^false</body></methods><methods><class-id>Refactory.Browser.RBErrorAction</class-id> <category>accessing</category><body package="Browser-Parser">position	^self subclassResponsibility</body></methods><methods><class-id>Refactory.Browser.RBInsertErrorAction</class-id> <category>accessing</category><body package="Browser-Parser">position	^position</body><body package="Browser-Parser">position: anInteger	position := anInteger</body><body package="Browser-Parser">text	^text</body><body package="Browser-Parser">text: aString	text := aString</body></methods><methods><class-id>Refactory.Browser.RBInsertErrorAction</class-id> <category>testing</category><body package="Browser-Parser">isInsertion	^true</body></methods><methods><class-id>Refactory.Browser.RBInsertErrorAction class</class-id> <category>instance creation</category><body package="Browser-Parser">insert: aString at: anInteger	^(self new)		text: aString;		position: anInteger;		yourself</body></methods><methods><class-id>Refactory.Browser.RBNumberLiteralToken</class-id> <category>accessing</category><body package="Browser-Parser">source	^source</body></methods><methods><class-id>Refactory.Browser.RBNumberLiteralToken</class-id> <category>initialize-release</category><body package="Browser-Parser">source: aString 	source := aString</body></methods><methods><class-id>Refactory.Browser.RBNumberLiteralToken</class-id> <category>printing</category><body package="Browser-Parser">storeOn: aStream 	aStream nextPutAll: source</body></methods><methods><class-id>Refactory.Browser.RBNumberLiteralToken class</class-id> <category>instance creation</category><body package="Browser-Parser">value: aNumber start: anInteger stop: stopInteger source: sourceString 	^(self 		value: aNumber		start: anInteger		stop: stopInteger)		source: sourceString;		yourself</body></methods><methods><class-id>Refactory.Browser.RBParseTreeRule</class-id> <category>matching</category><body package="Browser-Parser">canMatch: aProgramNode 	^true</body><body package="Browser-Parser">foundMatchFor: aProgramNode	^aProgramNode</body><body package="Browser-Parser">performOn: aProgramNode		owner resetContext.	^((searchTree		match: aProgramNode		inContext: self context) and: [self canMatch: aProgramNode])		ifTrue:			[owner recursivelySearchInContext.			self foundMatchFor: aProgramNode]		ifFalse: [nil]</body></methods><methods><class-id>Refactory.Browser.RBParseTreeRule</class-id> <category>private</category><body package="Browser-Parser">context	^owner context</body></methods><methods><class-id>Refactory.Browser.RBParseTreeRule</class-id> <category>initialize-release</category><body package="Browser-Parser">methodSearchString: aString 	searchTree := RBParser parseRewriteMethod: aString</body><body package="Browser-Parser">owner: aParseTreeSearcher	owner := aParseTreeSearcher</body><body package="Browser-Parser">searchString: aString 	searchTree := RBParser parseRewriteExpression: aString</body></methods><methods><class-id>Refactory.Browser.RBParseTreeRule</class-id> <category>accessing</category><body package="Browser-Parser">sentMessages	^searchTree sentMessages</body></methods><methods><class-id>Refactory.Browser.RBParseTreeRule class</class-id> <category>instance creation</category><body package="Browser-Parser">methodSearch: aString 	^(self new)		methodSearchString: aString;		yourself</body><body package="Browser-Parser">new	^(super new)		initialize;		yourself</body><body package="Browser-Parser">search: aString 	^(self new)		searchString: aString;		yourself</body></methods><methods><class-id>Refactory.Browser.RBReplaceRule</class-id> <category>matching</category><body package="Browser-Parser">canMatch: aProgramNode 	^verificationBlock value: aProgramNode</body><body package="Browser-Parser">foundMatchFor: aProgramNode 	self subclassResponsibility</body><body package="Browser-Parser">replace: aProgramNode with: newNode 	aProgramNode replaceMethodSource: newNode</body></methods><methods><class-id>Refactory.Browser.RBReplaceRule</class-id> <category>initialize-release</category><body package="Browser-Parser">initialize	super initialize.	verificationBlock := [:aNode | true]</body></methods><methods><class-id>Refactory.Browser.RBPatternBlockToken</class-id> <category>testing</category><body package="Browser-Parser">isPatternBlock	^true</body></methods><methods><class-id>Refactory.Browser.RBLiteralNode</class-id> <category>comparing</category><body package="Browser-Parser">= anObject 	self == anObject ifTrue: [^true].	^self class == anObject class</body><body package="Browser-Parser">hash	^self value hash</body></methods><methods><class-id>Refactory.Browser.RBLiteralNode</class-id> <category>testing</category><body package="Browser-Parser">isImmediateNode	^true</body><body package="Browser-Parser">isLiteralNode	^true</body><body package="Browser-Parser">needsParenthesis	^false</body></methods><methods><class-id>Refactory.Browser.RBLiteralNode</class-id> <category>accessing</category><body package="Browser-Parser">messageSearchClassFromScope: aClass	"If possible, determine the class where a method search will start when sent to me, return nil otherwise"		^self value class</body><body package="Browser-Parser">precedence	^0</body><body package="Browser-Parser">value	^self subclassResponsibility</body></methods><methods><class-id>Refactory.Browser.RBLiteralNode</class-id> <category>private-replacing</category><body package="Browser-Parser">replaceSourceFrom: aNode 	self addReplacement: (RBStringReplacement 				replaceFrom: aNode start				to: aNode stop				with: self formattedCode)</body><body package="Browser-Parser">replaceSourceWith: aNode 	self addReplacement: (RBStringReplacement 				replaceFrom: self start				to: self stop				with: aNode formattedCode)</body></methods><methods><class-id>Refactory.Browser.RBLiteralNode class</class-id> <category>instance creation</category><body package="Browser-Parser">literalToken: aLiteralToken 	^(aLiteralToken realValue class == Array 		or: [aLiteralToken realValue class == ByteArray]) 			ifTrue: 				[RBLiteralArrayNode 					startPosition: aLiteralToken start					contents: (aLiteralToken value asArray 							collect: [:each | RBLiteralNode literalToken: each])					stopPosition: aLiteralToken stop					isByteArray: aLiteralToken value class ~~ Array]			ifFalse: [RBLiteralValueNode literalToken: aLiteralToken]</body><body package="Browser-Parser">value: aValue 	^((aValue class == Array or: [aValue class == ByteArray]) 		ifTrue: [RBLiteralArrayNode]		ifFalse: [RBLiteralValueNode]) value: aValue</body></methods><methods><class-id>Refactory.Browser.RBDeleteErrorAction</class-id> <category>accessing</category><body package="Browser-Parser">item	^item</body><body package="Browser-Parser">item: aRBTokenOrRBProgramNode	item := aRBTokenOrRBProgramNode</body><body package="Browser-Parser">position	^item start</body><body package="Browser-Parser">start	^item start</body><body package="Browser-Parser">stop	^item stop</body></methods><methods><class-id>Refactory.Browser.RBDeleteErrorAction</class-id> <category>testing</category><body package="Browser-Parser">isDeletion	^true</body></methods><methods><class-id>Refactory.Browser.RBDeleteErrorAction class</class-id> <category>instance creation</category><body package="Browser-Parser">item: aRBTokenOrRBProgramNode	^(self new)		item: aRBTokenOrRBProgramNode;		yourself</body></methods><methods><class-id>Refactory.Browser.RBPatternScanner</class-id> <category>accessing</category><body package="Browser-Parser">scanToken	currentCharacter == PatternVariableCharacter 		ifTrue: [^self scanPatternVariable].	currentCharacter == $} ifTrue: [^self scanSpecialCharacter].	^super scanToken</body></methods><methods><class-id>Refactory.Browser.RBPatternScanner</class-id> <category>private-scanning</category><body package="Browser-Parser">scanPatternVariable	buffer nextPut: currentCharacter.	self step.	currentCharacter == ${		ifTrue: 			[self step.			^RBPatternBlockToken value: '`{' start: tokenStart].	[characterType == #alphabetic or: [characterType == #eof]] whileFalse: 			[buffer nextPut: currentCharacter.			self step].	characterType == #eof		ifTrue: 			[self				scannerError: #MetaVariableExpected &lt;&lt; #browser &gt;&gt; 'Meta variable expected'.			self insert: RBParser missingVariableName at: self errorPosition + 1.			buffer nextPutAll: RBParser missingVariableName].	^self scanIdentifierOrKeyword</body></methods><methods><class-id>Refactory.Browser.RBReturnNode</class-id> <category>comparing</category><body package="Browser-Parser">= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	^self value = anObject value</body><body package="Browser-Parser">equalTo: anObject withMapping: aDictionary 	^self class = anObject class 		and: [self value equalTo: anObject value withMapping: aDictionary]</body><body package="Browser-Parser">hash	^self value hash</body></methods><methods><class-id>Refactory.Browser.RBReturnNode</class-id> <category>visitor</category><body package="Browser-Parser">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptReturnNode: self</body></methods><methods><class-id>Refactory.Browser.RBReturnNode</class-id> <category>accessing</category><body package="Browser-Parser">children	^Array with: value</body><body package="Browser-Parser">start	^return</body><body package="Browser-Parser">stop	^value stop</body><body package="Browser-Parser">value	^value</body><body package="Browser-Parser">value: valueNode 	value := valueNode.	value parent: self</body></methods><methods><class-id>Refactory.Browser.RBReturnNode</class-id> <category>testing</category><body package="Browser-Parser">containsReturn	^true</body><body package="Browser-Parser">isReturn	^true</body></methods><methods><class-id>Refactory.Browser.RBReturnNode</class-id> <category>matching</category><body package="Browser-Parser">copyInContext: aDictionary 	^(self class new)		value: (value copyInContext: aDictionary);		yourself</body><body package="Browser-Parser">match: aNode inContext: aDictionary 	aNode class == self class ifFalse: [^false].	^value match: aNode value inContext: aDictionary</body></methods><methods><class-id>Refactory.Browser.RBReturnNode</class-id> <category>copying</category><body package="Browser-Parser">postCopy	super postCopy.	self value: self value copy</body></methods><methods><class-id>Refactory.Browser.RBReturnNode</class-id> <category>replacing</category><body package="Browser-Parser">replaceNode: aNode withNode: anotherNode 	value == aNode ifTrue: [self value: anotherNode]</body></methods><methods><class-id>Refactory.Browser.RBReturnNode</class-id> <category>initialize-release</category><body package="Browser-Parser">return: returnInteger value: aValueNode 	return := returnInteger.	self value: aValueNode</body></methods><methods><class-id>Refactory.Browser.RBReturnNode class</class-id> <category>instance creation</category><body package="Browser-Parser">return: returnInteger value: aValueNode 	^self new return: returnInteger value: aValueNode</body><body package="Browser-Parser">value: aNode	^self return: nil value: aNode</body></methods><methods><class-id>Refactory.Browser.RBVariableNode</class-id> <category>comparing</category><body package="Browser-Parser">= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	^self name = anObject name</body><body package="Browser-Parser">equalTo: anObject withMapping: aDictionary 	^self class = anObject class and: 			[(aDictionary at: self name ifAbsentPut: [anObject name]) = anObject name]</body><body package="Browser-Parser">hash	^self name hash</body></methods><methods><class-id>Refactory.Browser.RBVariableNode</class-id> <category>visitor</category><body package="Browser-Parser">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptVariableNode: self</body></methods><methods><class-id>Refactory.Browser.RBVariableNode</class-id> <category>matching</category><body package="Browser-Parser">copyInContext: aDictionary 	^self class identifierToken: token removePositions</body></methods><methods><class-id>Refactory.Browser.RBVariableNode</class-id> <category>initialize-release</category><body package="Browser-Parser">identifierToken: anIdentifierToken 	token := anIdentifierToken</body></methods><methods><class-id>Refactory.Browser.RBVariableNode</class-id> <category>testing</category><body package="Browser-Parser">isImmediateNode	^true</body><body package="Browser-Parser">isLocalVariable	"Do I represent a variable that is bound tighter than the instance variable scope? Special variables, temps, and args qualifiy."	| variableName |	variableName := self name.	^'self' = variableName or: 			['super' = variableName or: 					['thisContext' = variableName or: [(self whoDefines: variableName) notNil]]]</body><body package="Browser-Parser">isMissingVariable	"Return true if the node is a place holder variable for an error."		^self errorActions notEmpty and: [self start = 0]</body><body package="Browser-Parser">isSelf		^self name = 'self'</body><body package="Browser-Parser">isSuper		^self name = 'super'</body><body package="Browser-Parser">isThisContext		^self name = 'thisContext'</body><body package="Browser-Parser">isVariable	^true</body><body package="Browser-Parser">isVariableDeclaration	"Return true if the node is a variable and is the declaration of a variable, not the use of a variable."		(parent isMethod or: [parent isBlock]) ifTrue: [		parent arguments identityIndexOf: self ifAbsent: [^false].		^true].		parent isSequence ifTrue: [		parent temporaries identityIndexOf: self ifAbsent: [^false].		^true].		^false</body><body package="Browser-Parser">needsParenthesis	^false</body><body package="Browser-Parser">references: aVariableName 	^self name = aVariableName</body></methods><methods><class-id>Refactory.Browser.RBVariableNode</class-id> <category>accessing</category><body package="Browser-Parser">definingNode	"Return a the parent node that defines this variable"		^parent definingNodeForVariable: self name</body><body package="Browser-Parser">messageSearchClassFromScope: aClass	"If possible, determine the class where a method search will start when sent to me, return nil otherwise."		self isSelf ifTrue: [^aClass].	self isSuper ifTrue: [^aClass superclass].	(BindingReference		simpleName: self name		in: aClass environment) bindingOrNil		ifNotNil: [:binding | binding isForClass ifTrue: [^binding value class]].	^nil</body><body package="Browser-Parser">name	^token value</body><body package="Browser-Parser">precedence	^0</body><body package="Browser-Parser">referencingNodes	"Return a the parent node that defines this variable"		| references |	references := OrderedCollection new.	self definingNode nodesDo: [:each |		(each isVariable and: [each references: self name]) ifTrue: [			references add: each]].	^references</body><body package="Browser-Parser">startWithoutParentheses	^token start</body><body package="Browser-Parser">stopWithoutParentheses	^token stop</body><body package="Browser-Parser">token	^token</body></methods><methods><class-id>Refactory.Browser.RBVariableNode</class-id> <category>replacing</category><body package="Browser-Parser">replaceSourceFrom: aNode 	self addReplacement: (RBStringReplacement 				replaceFrom: aNode start				to: aNode stop				with: self name)</body><body package="Browser-Parser">replaceSourceWith: aNode	self addReplacement: (RBStringReplacement 				replaceFrom: self start				to: self stop				with: aNode formattedCode)</body></methods><methods><class-id>Refactory.Browser.RBVariableNode class</class-id> <category>instance creation</category><body package="Browser-Parser">identifierToken: anIdentifierToken 	^(self new)		identifierToken: anIdentifierToken;		yourself</body><body package="Browser-Parser">named: aString 	^self identifierToken: (RBIdentifierToken value: aString start: 0)</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>comparing</category><body package="Browser-Parser">= anObject 	"Can't send = to the temporaries and statements collection since they might change from arrays to OCs"	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	self temporaries size = anObject temporaries size ifFalse: [^false].	1 to: self temporaries size		do: 			[:i | 			(self temporaries at: i) = (anObject temporaries at: i) ifFalse: [^false]].	self statements size = anObject statements size ifFalse: [^false].	1 to: self statements size		do: [:i | (self statements at: i) = (anObject statements at: i) ifFalse: [^false]].	^true</body><body package="Browser-Parser">equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	self statements size == anObject statements size ifFalse: [^false].	1 to: self statements size		do: 			[:i | 			((self statements at: i) equalTo: (anObject statements at: i)				withMapping: aDictionary) ifFalse: [^false]].	aDictionary values asSet size = aDictionary size ifFalse: [^false].	"Not a one-to-one mapping"	self temporaries		do: [:each | aDictionary removeKey: each name ifAbsent: []].	^true</body><body package="Browser-Parser">hash	^self temporaries hash bitXor: (self statements isEmpty 				ifTrue: [0]				ifFalse: [self statements first hash])</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>visitor</category><body package="Browser-Parser">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptSequenceNode: self</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>adding nodes</category><body package="Browser-Parser">addNode: aNode 	aNode parent: self.	(statements notEmpty and: [statements last isReturn]) 		ifTrue: [self error: (#CannotAddStmtAfterReturn &lt;&lt; #browser &gt;&gt; 'Cannot add statement after return node')].	statements := (statements asOrderedCollection)				add: aNode;				yourself</body><body package="Browser-Parser">addNode: aNode before: anotherNode 	| index |	index := self indexOfNode: anotherNode.	index = 0 ifTrue: [^self addNode: aNode].	statements := (statements asOrderedCollection)				add: aNode beforeIndex: index;				yourself.	aNode parent: self</body><body package="Browser-Parser">addNodeFirst: aNode 	aNode parent: self.	statements := (statements asOrderedCollection)				addFirst: aNode;				yourself</body><body package="Browser-Parser">addNodes: aCollection 	aCollection do: [:each | each parent: self].	(statements notEmpty and: [statements last isReturn]) 		ifTrue: [self error: (#CannotAddStmtAfterReturn &lt;&lt; #browser &gt;&gt; 'Cannot add statement after return node')].	statements := (statements asOrderedCollection)				addAll: aCollection;				yourself</body><body package="Browser-Parser">addNodes: aCollection before: anotherNode 	aCollection do: [:each | self addNode: each before: anotherNode]</body><body package="Browser-Parser">addNodesFirst: aCollection 	aCollection do: [:each | each parent: self].	statements := (statements asOrderedCollection)				addAllFirst: aCollection;				yourself</body><body package="Browser-Parser">addSelfReturn	| node |	self lastIsReturn ifTrue: [^self].	node := RBReturnNode value: (RBVariableNode named: 'self').	self addNode: node</body><body package="Browser-Parser">addTemporariesNamed: aCollection 	aCollection do: [:each | self addTemporaryNamed: each]</body><body package="Browser-Parser">addTemporaryNamed: aString 	| variableNode |	variableNode := RBVariableNode named: aString.	variableNode parent: self.	temporaries := temporaries copyWith: variableNode</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>accessing</category><body package="Browser-Parser">addReturn	| node |	statements isEmpty ifTrue: [^nil].	statements last isReturn ifTrue: [^statements last].	node := RBReturnNode value: statements last.	statements at: statements size put: node.	node parent: self.	^node</body><body package="Browser-Parser">allDefinedVariables	^(self temporaryNames asOrderedCollection)		addAll: super allDefinedVariables;		yourself</body><body package="Browser-Parser">allScopedTemporaryVariables	^self temporaryNames asOrderedCollection, super allScopedTemporaryVariables</body><body package="Browser-Parser">allTemporaryVariables	^(self temporaryNames asOrderedCollection)		addAll: super allTemporaryVariables;		yourself</body><body package="Browser-Parser">children	^(OrderedCollection new)		addAll: self temporaries;		addAll: self statements;		yourself</body><body package="Browser-Parser">definingNodeForVariable: aVariableNode	(self temporaryNames includes: aVariableNode) ifTrue: [^self].	^parent definingNodeForVariable: aVariableNode</body><body package="Browser-Parser">leftBar	^leftBar</body><body package="Browser-Parser">methodComments	| methodComments |	methodComments := OrderedCollection withAll: self comments.	temporaries do: [:each | methodComments addAll: each comments].	(parent notNil and: [parent isBlock]) 		ifTrue: [parent arguments do: [:each | methodComments addAll: each comments]].	^methodComments asSortedCollection: [:a :b | a first &lt; b first]</body><body package="Browser-Parser">periods	^periods</body><body package="Browser-Parser">periods: anObject	periods := anObject</body><body package="Browser-Parser">removeTemporaryNamed: aName 	temporaries := temporaries reject: [:each | each name = aName]</body><body package="Browser-Parser">rightBar	^rightBar</body><body package="Browser-Parser">start	^leftBar isNil 		ifTrue: [statements isEmpty ifTrue: [1] ifFalse: [statements first start]]		ifFalse: [leftBar]</body><body package="Browser-Parser">statements	^statements</body><body package="Browser-Parser">statements: stmtCollection 	statements := stmtCollection.	statements do: [:each | each parent: self]</body><body package="Browser-Parser">stop	^(periods isEmpty ifTrue: [0] ifFalse: [periods last]) 		max: (statements isEmpty ifTrue: [0] ifFalse: [statements last stop])</body><body package="Browser-Parser">temporaries	^temporaries</body><body package="Browser-Parser">temporaries: tempCollection 	temporaries := tempCollection.	temporaries do: [:each | each parent: self]</body><body package="Browser-Parser">temporaryNames	^temporaries collect: [:each | each name]</body><body package="Browser-Parser">temporaryVariables	^(super temporaryVariables asOrderedCollection)		addAll: self temporaryNames;		yourself</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>querying</category><body package="Browser-Parser">bestNodeFor: anInterval 	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifFalse: [		| selectedChildren firstChild |		selectedChildren := self children 			select: [:each | each intersectsInterval: anInterval].		selectedChildren size == 1 			ifTrue: [^selectedChildren first bestNodeFor: anInterval].				"Selection is between statements, so pick the last child that comes before the selection"		firstChild := nil.		self children do: [:each | each stop &lt; anInterval first ifTrue: [firstChild := each]].		firstChild == nil ifFalse: [^firstChild]].			(temporaries isEmpty and: [statements size == 1]) 		ifTrue: [^statements first].	^self</body><body package="Browser-Parser">whichNodeIsContainedBy: anInterval 	| node |	node := super whichNodeIsContainedBy: anInterval.	node == self 		ifTrue: 			[(temporaries isEmpty and: [statements size == 1]) 				ifTrue: [^statements first]].	^node</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>matching</category><body package="Browser-Parser">copyInContext: aDictionary 	^(self class new)		temporaries: (self copyList: temporaries inContext: aDictionary);		statements: (self copyList: statements inContext: aDictionary);		yourself</body><body package="Browser-Parser">match: aNode inContext: aDictionary 	self class == aNode class ifFalse: [^false].	^(self 		matchList: temporaries		against: aNode temporaries		inContext: aDictionary) and: 				[self 					matchList: statements					against: aNode statements					inContext: aDictionary]</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>testing</category><body package="Browser-Parser">defines: aName 	^temporaries anySatisfy: [:each | each name = aName]</body><body package="Browser-Parser">directlyUses: aNode 	^false</body><body package="Browser-Parser">isLast: aNode 	| last |	statements isEmpty ifTrue: [^false].	last := statements last.	^last == aNode or: 			[last isMessage and: 					[(#(#ifTrue:ifFalse: #ifFalse:ifTrue:) includes: last selector) 						and: [last arguments anySatisfy: [:each | each isLast: aNode]]]]</body><body package="Browser-Parser">isSequence	^true</body><body package="Browser-Parser">lastIsReturn	^statements notEmpty and: [statements last lastIsReturn]</body><body package="Browser-Parser">references: aVariableName 	^statements anySatisfy: [:each | each references: aVariableName]</body><body package="Browser-Parser">uses: aNode 	statements isEmpty ifTrue: [^false].	aNode == statements last ifFalse: [^false].	^self isUsed</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>private</category><body package="Browser-Parser">indexOfNode: aNode 	"Try to find the node by first looking for ==, and then for ="	^(1 to: statements size) detect: [:each | (statements at: each) == aNode]		ifNone: [statements indexOf: aNode]</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>initialize-release</category><body package="Browser-Parser">leftBar: leftInteger temporaries: variableNodes rightBar: rightInteger 	leftBar := leftInteger.	self temporaries: variableNodes.	rightBar := rightInteger</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>copying</category><body package="Browser-Parser">postCopy	super postCopy.	self temporaries: (self temporaries collect: [:each | each copy]).	self statements: (self statements collect: [:each | each copy])</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>replacing</category><body package="Browser-Parser">removeDeadCode	(self isUsed ifTrue: [statements size - 1] ifFalse: [statements size]) 		to: 1		by: -1		do: 			[:i | 			(statements at: i) isImmediateNode 				ifTrue: 					[self clearReplacements.					statements removeAtIndex: i]].	super removeDeadCode</body><body package="Browser-Parser">removeNode: aNode	self replaceNode: aNode withNodes: #()</body><body package="Browser-Parser">replaceNode: aNode withNode: anotherNode 	self statements: (statements 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]]).	self temporaries: (temporaries 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])</body><body package="Browser-Parser">replaceNode: aNode withNodes: aCollection 	| index newStatements |	self clearReplacements.	index := self indexOfNode: aNode.	newStatements := OrderedCollection new: statements size + aCollection size.	1 to: index - 1 do: [:i | newStatements add: (statements at: i)].	newStatements addAll: aCollection.	index + 1 to: statements size		do: [:i | newStatements add: (statements at: i)].	aCollection do: [:each | each parent: self].	statements := newStatements</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode class</class-id> <category>instance creation</category><body package="Browser-Parser">leftBar: leftInteger temporaries: variableNodes rightBar: rightInteger 	^(self new)		leftBar: leftInteger			temporaries: variableNodes			rightBar: rightInteger;		yourself</body><body package="Browser-Parser">statements: statementNodes 	^self temporaries: #() statements: statementNodes</body><body package="Browser-Parser">temporaries: variableNodes statements: statementNodes 	^(self new)		temporaries: variableNodes;		statements: statementNodes;		yourself</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>comparing</category><body package="Browser-Parser">= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	(self receiver = anObject receiver 		and: [self selector = anObject selector]) ifFalse: [^false].	1 to: self arguments size		do: [:i | (self arguments at: i) = (anObject arguments at: i) ifFalse: [^false]].	^true</body><body package="Browser-Parser">equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	((self receiver equalTo: anObject receiver withMapping: aDictionary)		and: [self selector = anObject selector]) ifFalse: [^false].	1 to: self arguments size		do: 			[:i | 			((self arguments at: i) equalTo: (anObject arguments at: i)				withMapping: aDictionary) ifFalse: [^false]].	^true</body><body package="Browser-Parser">hash	^(self receiver hash bitXor: self selector hash) 		bitXor: (self arguments isEmpty 				ifTrue: [0]				ifFalse: [self arguments first hash])</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>visitor</category><body package="Browser-Parser">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptMessageNode: self</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>accessing</category><body package="Browser-Parser">allLeafNodesAndTokensDo: aBlockClosure	| selectorPartsStream argumentsStream |	selectorPartsStream := selectorParts readStream.	argumentsStream := self arguments readStream.	self receiver allLeafNodesAndTokensDo: aBlockClosure.	[selectorPartsStream atEnd ifFalse: [aBlockClosure value: selectorPartsStream next].	argumentsStream atEnd] whileFalse: [argumentsStream next allLeafNodesAndTokensDo: aBlockClosure]</body><body package="Browser-Parser">arguments	^arguments isNil ifTrue: [#()] ifFalse: [arguments]</body><body package="Browser-Parser">arguments: argCollection 	arguments := argCollection.	arguments do: [:each | each parent: self]</body><body package="Browser-Parser">children	^(OrderedCollection with: self receiver)		addAll: self arguments;		yourself</body><body package="Browser-Parser">numArgs	^self selector numArgs</body><body package="Browser-Parser">precedence	^self isUnary 		ifTrue: [1]		ifFalse: [self isKeyword ifTrue: [3] ifFalse: [2]]</body><body package="Browser-Parser">receiver	^receiver</body><body package="Browser-Parser">receiver: aValueNode 	receiver := aValueNode.	receiver parent: self</body><body package="Browser-Parser">renameSelector: newSelector andArguments: varNodeCollection 	self		arguments: varNodeCollection;		selector: newSelector</body><body package="Browser-Parser">selector	^selector == nil		ifTrue: [selector := self composeSelector: selectorParts]		ifFalse: [selector]</body><body package="Browser-Parser">selector: aSelector 	| keywords numArgs |	keywords := aSelector keywords.	numArgs := aSelector numArgs.	numArgs == arguments size 		ifFalse: 			[self 				error: (#AssignmentWithWrongArgNumber &lt;&lt; #browser &gt;&gt; 'Attempting to assign selector with wrong number of arguments.')].	selectorParts := numArgs == 0 				ifTrue: [Array with: (RBIdentifierToken value: keywords first start: nil)]				ifFalse: 					[keywords first last == $: 						ifTrue: [keywords collect: [:each | RBKeywordToken value: each start: nil]]						ifFalse: [Array with: (RBBinarySelectorToken value: aSelector start: nil)]].	selector := aSelector</body><body package="Browser-Parser">selectorPartsDo: partBlock argumentsDo: argumentBlock		self numArgs isZero ifTrue: [^partBlock value: selectorParts first].	selectorParts		with: arguments		do:			[:selectorPart :argument | 			partBlock value: selectorPart.			argumentBlock value: argument]</body><body package="Browser-Parser">sentMessages	^(super sentMessages)		add: self selector;		yourself</body><body package="Browser-Parser">startWithoutParentheses	^receiver start</body><body package="Browser-Parser">stopWithoutParentheses	^arguments isEmpty 		ifTrue: [selectorParts first stop]		ifFalse: [arguments last stop]</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>querying</category><body package="Browser-Parser">bestNodeFor: anInterval 	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	selectorParts do: 			[:each | 			((anInterval first between: each start and: each stop) 				or: [each start between: anInterval first and: anInterval last]) 					ifTrue: [^self]].	self children do: 			[:each | 			| node |			node := each bestNodeFor: anInterval.			node notNil ifTrue: [^node]]</body><body package="Browser-Parser">bestTokenFor: anInterval	^selectorParts		detect: [:each | each intersectsInterval: anInterval]		ifNone: [self]</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>private</category><body package="Browser-Parser">buildSelector	| selectorStream |	selectorStream := WriteStream on: (String new: 50).	selectorParts do: [:each | selectorStream nextPutAll: each value].	^selectorStream contents asSymbol</body><body package="Browser-Parser">selectorParts	^selectorParts</body><body package="Browser-Parser">selectorParts: tokenCollection 	selectorParts := tokenCollection</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>testing</category><body package="Browser-Parser">isBinary	^(self isUnary or: [self isKeyword]) not</body><body package="Browser-Parser">isCascaded	^parent notNil and: [parent isCascade]</body><body package="Browser-Parser">isFirstCascaded	^self isCascaded and: [parent messages first == self]</body><body package="Browser-Parser">isKeyword	^selectorParts first value last == $:</body><body package="Browser-Parser">isMessage	^true</body><body package="Browser-Parser">isUnary	^arguments isEmpty</body><body package="Browser-Parser">lastIsReturn	^(#(#ifTrue:ifFalse: #ifFalse:ifTrue:) includes: self selector) and: 			[arguments first isBlock and: 					[arguments first body lastIsReturn						and: [arguments last isBlock and: [arguments last body lastIsReturn]]]]</body><body package="Browser-Parser">needsParenthesis	^parent isNil 		ifTrue: [false]		ifFalse: 			[self precedence &gt; parent precedence 				or: [self precedence = parent precedence and: [self isUnary not]]]</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>matching</category><body package="Browser-Parser">copyInContext: aDictionary 	^(self class new)		receiver: (receiver copyInContext: aDictionary);		selectorParts: (selectorParts collect: [:each | each removePositions]);		arguments: (arguments collect: [:each | each copyInContext: aDictionary]);		yourself</body><body package="Browser-Parser">match: aNode inContext: aDictionary 	aNode class == self class ifFalse: [^false].	self selector == aNode selector ifFalse: [^false].	(receiver match: aNode receiver inContext: aDictionary) ifFalse: [^false].	1 to: arguments size		do: 			[:i | 			((arguments at: i) match: (aNode arguments at: i) inContext: aDictionary)				ifFalse: [^false]].	^true</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>copying</category><body package="Browser-Parser">postCopy	super postCopy.	self receiver: self receiver copy.	self arguments: (self arguments collect: [:each | each copy])</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>initialize-release</category><body package="Browser-Parser">receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 	self receiver: aValueNode.	selectorParts := keywordTokens.	self arguments: valueNodes</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>replacing</category><body package="Browser-Parser">replaceNode: aNode withNode: anotherNode 	"If we're inside a cascade node and are changing the receiver, change all the receivers"	receiver == aNode 		ifTrue: 			[self receiver: anotherNode.			(parent notNil and: [parent isCascade]) 				ifTrue: [parent messages do: [:each | each receiver: anotherNode]]].	self arguments: (arguments 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>private-replacing</category><body package="Browser-Parser">isContainmentReplacement: aNode 	^(self mappingFor: self receiver) = aNode 		or: [self arguments anySatisfy: [:each | (self mappingFor: each) = aNode]]</body><body package="Browser-Parser">replaceContainmentSourceWith: aNode 	| originalNode needsParenthesis |	needsParenthesis := aNode hasParentheses not and: [aNode needsParenthesis].	originalNode := (self mappingFor: self receiver) = aNode 				ifTrue: [self receiver]				ifFalse: [self arguments detect: [:each | (self mappingFor: each) = aNode]].	self		addReplacement: (RBStringReplacement 					replaceFrom: self start					to: originalNode start - 1					with: (needsParenthesis ifTrue: ['('] ifFalse: ['']));		addReplacement: (RBStringReplacement 					replaceFrom: originalNode stop + 1					to: self stop					with: (needsParenthesis ifTrue: [')'] ifFalse: ['']))</body><body package="Browser-Parser">replaceSourceWith: aNode 	(self isContainmentReplacement: aNode) 		ifTrue: [^self replaceContainmentSourceWith: aNode].	aNode isMessage ifFalse: [^super replaceSourceWith: aNode].	^self replaceSourceWithMessageNode: aNode</body><body package="Browser-Parser">replaceSourceWithMessageNode: aNode 	| isBinaryToKeyword |	self numArgs = aNode numArgs ifFalse: [^super replaceSourceWith: aNode].	(self mappingFor: self receiver) = aNode receiver 		ifFalse: [^super replaceSourceWith: aNode].	self arguments with: aNode arguments		do: [:old :new | (self mappingFor: old) = new ifFalse: [^super replaceSourceWith: aNode]].	(isBinaryToKeyword := self isBinary and: [aNode isKeyword]) 		ifTrue: 			[(self hasParentheses not and: [self parent precedence &lt;= aNode precedence]) 				ifTrue: 					[self						addReplacement: (RBStringReplacement 									replaceFrom: self start									to: self start - 1									with: '(');						addReplacement: (RBStringReplacement 									replaceFrom: self stop + 1									to: self stop									with: ')')]].	self selectorParts with: aNode selectorParts		do: 			[:old :new | 			old value ~= new value 				ifTrue: 					[self addReplacement: (RBStringReplacement 								replaceFrom: old start								to: old stop								with: ((isBinaryToKeyword 										and: [(self source at: old start - 1) isSeparator not]) 											ifTrue: [' ' , new value]											ifFalse: [new value]))]]</body></methods><methods><class-id>Refactory.Browser.RBMessageNode class</class-id> <category>instance creation</category><body package="Browser-Parser">receiver: aValueNode selector: aSymbol 	^self 		receiver: aValueNode		selector: aSymbol		arguments: #()</body><body package="Browser-Parser">receiver: aValueNode selector: aSymbol arguments: valueNodes 	^(self new)		receiver: aValueNode;		arguments: valueNodes;		selector: aSymbol;		yourself</body><body package="Browser-Parser">receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 	^(self new)		receiver: aValueNode			selectorParts: keywordTokens			arguments: valueNodes;		yourself</body></methods><methods><class-id>Refactory.Browser.RBProgramNodeVisitor</class-id> <category>visitor-double dispatching</category><body package="Browser-Parser">acceptAssignmentNode: anAssignmentNode 	self visitNode: anAssignmentNode variable.	self visitNode: anAssignmentNode value</body><body package="Browser-Parser">acceptBlockNode: aBlockNode 	self visitArguments: aBlockNode arguments.	self visitNode: aBlockNode body</body><body package="Browser-Parser">acceptCascadeNode: aCascadeNode 	aCascadeNode messages do: [:each | self visitNode: each]</body><body package="Browser-Parser">acceptCDeclarationNode: aCDeclarationNode</body><body package="Browser-Parser">acceptLiteralArrayNode: aRBLiteralArrayNode 	aRBLiteralArrayNode contents do: [:each | self visitNode: each]</body><body package="Browser-Parser">acceptLiteralNode: aLiteralNode</body><body package="Browser-Parser">acceptMessageNode: aMessageNode 	(aMessageNode isCascaded not or: [aMessageNode isFirstCascaded]) 		ifTrue: [self visitNode: aMessageNode receiver].	aMessageNode arguments do: [:each | self visitNode: each]</body><body package="Browser-Parser">acceptMethodNode: aMethodNode	self visitArguments: aMethodNode arguments.	aMethodNode tagsDo: [:each | self visitNode: each].	self visitNode: aMethodNode body</body><body package="Browser-Parser">acceptPatternBlockNode: aRBPatternBlockNode 	self visitArguments: aRBPatternBlockNode arguments.	self visitNode: aRBPatternBlockNode body</body><body package="Browser-Parser">acceptPatternWrapperBlockNode: aRBPatternWrapperBlockNode 	self visitNode: aRBPatternWrapperBlockNode wrappedNode.	self visitArguments: aRBPatternWrapperBlockNode arguments.	self visitNode: aRBPatternWrapperBlockNode body</body><body package="Browser-Parser">acceptPrimitiveTagNode: aTagNode	self acceptTagNode: aTagNode</body><body package="Browser-Parser">acceptReturnNode: aReturnNode 	self visitNode: aReturnNode value</body><body package="Browser-Parser">acceptSequenceNode: aSequenceNode 	self visitArguments: aSequenceNode temporaries.	aSequenceNode statements do: [:each | self visitNode: each]</body><body package="Browser-Parser">acceptTagNode: aTagNode	aTagNode arguments do: [:each | self visitNode: each]</body><body package="Browser-Parser">acceptVariableNode: aVariableNode</body></methods><methods><class-id>Refactory.Browser.RBProgramNodeVisitor</class-id> <category>visiting</category><body package="Browser-Parser">visitArgument: each 	"Here to allow subclasses to detect arguments or temporaries."	^self visitNode: each</body><body package="Browser-Parser">visitArguments: aNodeCollection 	^aNodeCollection do: [:each | self visitArgument: each]</body><body package="Browser-Parser">visitNode: aNode 	^aNode acceptVisitor: self</body></methods><methods><class-id>Refactory.Browser.RBProgramNodeVisitor class</class-id> <category>instance creation</category><body package="Browser-Parser">new	^super new initialize</body></methods><methods><class-id>Refactory.Browser.ParseTreeSearcher</class-id> <category>accessing</category><body package="Browser-Parser">addArgumentRule: aParseTreeRule 	argumentSearches add: aParseTreeRule.	aParseTreeRule owner: self</body><body package="Browser-Parser">addArgumentRules: ruleCollection 	ruleCollection do: [:each | self addArgumentRule: each]</body><body package="Browser-Parser">addRule: aParseTreeRule 	searches add: aParseTreeRule.	aParseTreeRule owner: self</body><body package="Browser-Parser">addRules: ruleCollection 	ruleCollection do: [:each | self addRule: each]</body><body package="Browser-Parser">answer	^answer</body><body package="Browser-Parser">context	^context</body><body package="Browser-Parser">executeMethod: aParseTree initialAnswer: anObject 	answer := anObject.	searches detect: [:each | (each performOn: aParseTree) notNil] ifNone: [].	^answer</body><body package="Browser-Parser">executeTree: aParseTree	"Save our current context, in case someone is performing another search inside a match."		| oldContext |	oldContext := context.	self resetContext.	self visitNode: aParseTree.	context := oldContext.	^answer</body><body package="Browser-Parser">executeTree: aParseTree initialAnswer: aValue 	answer := aValue.	^self executeTree: aParseTree</body><body package="Browser-Parser">messages	messages notNil ifTrue: [^messages].	argumentSearches notEmpty ifTrue: [^messages := #()].	messages := Set new.	searches do: 			[:each | 			| searchMessages |			searchMessages := each sentMessages.			RBProgramNode optimizedSelectors 				do: [:sel | searchMessages remove: sel ifAbsent: []].			searchMessages isEmpty ifTrue: [^messages := #()].			messages addAll: searchMessages].	^messages := messages asArray</body></methods><methods><class-id>Refactory.Browser.ParseTreeSearcher</class-id> <category>initialize-release</category><body package="Browser-Parser">answer: anObject	answer := anObject</body><body package="Browser-Parser">initialize		super initialize.	self resetContext.	searches := OrderedCollection new.	argumentSearches := OrderedCollection new: 0.	answer := nil</body><body package="Browser-Parser">resetContext		context := CompactDictionary new</body></methods><methods><class-id>Refactory.Browser.ParseTreeSearcher</class-id> <category>testing</category><body package="Browser-Parser">canMatchMethod: aCompiledMethod 	^self messages isEmpty 		or: [self messages anySatisfy: [:each | aCompiledMethod sendsSelector: each]]</body></methods><methods><class-id>Refactory.Browser.ParseTreeSearcher</class-id> <category>private</category><body package="Browser-Parser">foundMatch</body><body package="Browser-Parser">lookForMoreMatchesInContext: oldContext 	oldContext keysAndValuesDo: 			[:key :value | 			(key isString not and: [key recurseInto]) 				ifTrue: [value do: [:each | self visitNode: each]]]</body><body package="Browser-Parser">performSearches: aSearchCollection on: aNode 	| value |	1 to: aSearchCollection size		do: 			[:i | 			value := (aSearchCollection at: i) performOn: aNode.			value notNil 				ifTrue: 					[self foundMatch.					^value]].	^nil</body><body package="Browser-Parser">recursivelySearchInContext	"We need to save the matched context since the other searches might overwrite it."		| oldContext |	oldContext := context.	self resetContext.	self lookForMoreMatchesInContext: oldContext.	context := oldContext</body></methods><methods><class-id>Refactory.Browser.ParseTreeSearcher</class-id> <category>searching</category><body package="Browser-Parser">matches: aString do: aBlock 	self addRule: (RBSearchRule searchFor: aString thenDo: aBlock)</body><body package="Browser-Parser">matchesAnyArgumentOf: stringCollection do: aBlock 	stringCollection do: [:each | self matchesArgument: each do: aBlock]</body><body package="Browser-Parser">matchesAnyMethodOf: aStringCollection do: aBlock 	aStringCollection do: [:each | self matchesMethod: each do: aBlock]</body><body package="Browser-Parser">matchesAnyOf: aStringCollection do: aBlock 	aStringCollection do: [:each | self matches: each do: aBlock]</body><body package="Browser-Parser">matchesAnyTreeOf: treeCollection do: aBlock 	treeCollection do: [:each | self matchesTree: each do: aBlock]</body><body package="Browser-Parser">matchesArgument: aString do: aBlock 	self addArgumentRule: (RBSearchRule searchFor: aString thenDo: aBlock)</body><body package="Browser-Parser">matchesArgumentTree: aBRProgramNode do: aBlock 	self 		addArgumentRule: (RBSearchRule searchForTree: aBRProgramNode thenDo: aBlock)</body><body package="Browser-Parser">matchesMethod: aString do: aBlock 	self addRule: (RBSearchRule searchForMethod: aString thenDo: aBlock)</body><body package="Browser-Parser">matchesTree: aBRProgramNode do: aBlock 	self addRule: (RBSearchRule searchForTree: aBRProgramNode thenDo: aBlock)</body></methods><methods><class-id>Refactory.Browser.ParseTreeSearcher</class-id> <category>visiting</category><body package="Browser-Parser">visitArgument: aNode 	| value |	value := self performSearches: argumentSearches on: aNode.	^value isNil 		ifTrue: 			[aNode acceptVisitor: self.			aNode]		ifFalse: [value]</body><body package="Browser-Parser">visitNode: aNode 	| value |	value := self performSearches: searches on: aNode.	^value isNil 		ifTrue: 			[aNode acceptVisitor: self.			aNode]		ifFalse: [value]</body></methods><methods><class-id>Refactory.Browser.ParseTreeSearcher class</class-id> <category>private</category><body package="Browser-Parser">buildSelectorString: aSelector 	| stream keywords |	aSelector numArgs = 0 ifTrue: [^aSelector].	stream := WriteStream on: String new.	keywords := aSelector keywords.	1 to: keywords size		do: 			[:i | 			stream				nextPutAll: (keywords at: i);				nextPutAll: ' ``@arg';				nextPutAll: i printString;				nextPut: $ ].	^stream contents</body><body package="Browser-Parser">buildSelectorTree: aSelector 	aSelector isEmpty ifTrue: [^nil].	^RBParser parseRewriteExpression: '``@receiver ' 				, (self buildSelectorString: aSelector)		onError: [:err :pos | ^nil]</body><body package="Browser-Parser">buildTree: aString method: aBoolean 	^aBoolean 		ifTrue: [RBParser parseRewriteMethod: aString]		ifFalse: [RBParser parseRewriteExpression: aString]</body></methods><methods><class-id>Refactory.Browser.ParseTreeSearcher class</class-id> <category>instance creation</category><body package="Browser-Parser">getterMethod: aVarName 	^(self new)		matchesMethod: '`method ^' , aVarName do: [:aNode :ans | aNode selector];		yourself</body><body package="Browser-Parser">justSendsSuper	^(self new)		matchesAnyMethodOf: 				#('`@method: `@Args ^super `@method: `@Args' 				'`@method: `@Args super `@method: `@Args')			do: [:aNode :ans | true];		yourself</body><body package="Browser-Parser">returnSetterMethod: aVarName 	^(self new)		matchesMethod: '`method: `Arg ^' , aVarName , ' := `Arg'			do: [:aNode :ans | aNode selector];		yourself</body><body package="Browser-Parser">setterMethod: aVarName 	^(self new)		matchesAnyMethodOf: (Array with: '`method: `Arg ' , aVarName , ' := `Arg'					with: '`method: `Arg ^' , aVarName , ' := `Arg')			do: [:aNode :ans | aNode selector];		yourself</body></methods><methods><class-id>Refactory.Browser.ParseTreeSearcher class</class-id> <category>accessing</category><body package="Browser-Parser">treeMatching: aString in: aParseTree 	(self new)		matches: aString do: [:aNode :answer | ^aNode];		executeTree: aParseTree.	^nil</body><body package="Browser-Parser">treeMatchingStatements: aString in: aParseTree 	| notifier tree |	notifier := self new.	tree := RBParser parseExpression: aString.	tree isSequence 		ifFalse: [tree := RBSequenceNode statements: (Array with: tree)].	tree temporaries: (Array with: (RBPatternVariableNode named: '`@temps')).	tree addNodeFirst: (RBPatternVariableNode named: '`@.S1').	tree lastIsReturn 		ifFalse: [tree addNode: (RBPatternVariableNode named: '`@.S2')].	notifier matchesTree: tree		do: [:aNode :answer | ^RBParser parseExpression: aString].	notifier executeTree: aParseTree.	^nil</body></methods><methods><class-id>Refactory.Browser.RBKeywordToken</class-id> <category>testing</category><body package="Browser-Parser">isExternalProcedure	^#{CPreprocessor} isDefined		and: [value = 'C:' or: [value = 'COM:' and: [#{COMParser} isDefined]]]</body><body package="Browser-Parser">isKeyword	^true</body><body package="Browser-Parser">isPatternVariable	^value first == RBScanner patternVariableCharacter</body></methods><methods><class-id>Refactory.Browser.RBParser</class-id> <category>private</category><body package="Browser-Parser">addCommentsTo: aNode	aNode comments: aNode comments , comments.	comments := OrderedCollection new</body><body package="Browser-Parser">addErrorActionsTo: aNode	aNode addErrorActions: scanner getErrorActions.	errorActions notEmpty		ifTrue: 			[aNode addErrorActions: errorActions.			errorActions := OrderedCollection new]</body><body package="Browser-Parser">addPropertiesAndCommentsTo: aNode	self addCommentsTo: aNode.	self addPropertiesTo: aNode</body><body package="Browser-Parser">addPropertiesTo: aNode	aNode isNil ifTrue: [^self].	self addErrorActionsTo: aNode</body><body package="Browser-Parser">isValidByteArrayObjectToken	^currentToken isLiteralToken and: [currentToken value isInteger]</body><body package="Browser-Parser">missingVariableName	^'_missing_variable_'</body><body package="Browser-Parser">nextToken	^nextToken isNil ifTrue: [nextToken := scanner next] ifFalse: [nextToken]</body><body package="Browser-Parser">patchLiteralArrayDottedNameToken	"VW allows for non-standard literals such as #(Foo.bar)  #('Foo.bar')"	(currentToken isIdentifier and: [currentToken value includes: $.])		ifTrue:			[currentToken := RBLiteralToken				value: currentToken value				start: currentToken start				stop: currentToken stop.			^true].	^false</body><body package="Browser-Parser">patchLiteralArrayEmbeddedAssignmentToken	"VW allows for non-standard literals such as #(a:= :=) which is equivalent to  #(#a: #= #':' #=)"	(currentToken isIdentifier		and:			[self nextToken isAssignment				and: [currentToken stop + 1 = self nextToken start]])		ifTrue:			[currentToken := RBLiteralToken				value: (currentToken value , ':') asSymbol				start: currentToken start				stop: self nextToken start.			nextToken := RBLiteralToken				value: #=				start: nextToken stop				stop: nextToken stop.			^true].	currentToken isAssignment		ifTrue:			[currentToken := RBLiteralToken				value: #':'				start: currentToken start				stop: currentToken start.			nextToken := RBLiteralToken				value: #=				start: currentToken stop				stop: currentToken stop.			^true].	^false</body><body package="Browser-Parser">patchLiteralArraySpecialToken	"VW allows for non-standard literals such as #(: ;|{},) which is equivalent to  #(#':', .... #',')"	currentToken isSpecial		ifTrue:			[currentToken := RBLiteralToken				value: (String with: currentToken value) asSymbol				start: currentToken start				stop: currentToken stop.			^true].	^false</body><body package="Browser-Parser">patchLiteralArraySymbolToken	"this is the standard expansion. e.g: #(foo) -&gt; #(#foo)"	(currentToken isIdentifier		or: [currentToken isBinary or: [currentToken isKeyword]])		ifFalse: [^false].	currentToken := RBLiteralToken		value: currentToken value asSymbol		start: currentToken start		stop: currentToken stop.	^true</body><body package="Browser-Parser">patchLiteralArrayToken	(self patchLiteralArrayEmbeddedAssignmentToken or: 			[self patchLiteralArraySpecialToken or: 					[self patchLiteralArrayDottedNameToken						or: [self patchLiteralArraySymbolToken]]])		ifFalse: 			[self parserError: #InvalidToken &lt;&lt; #browser &gt;&gt; 'Invalid token'.			self deleteCurrentToken.			self step.			^false].	^true</body><body package="Browser-Parser">patchLiteralMessage	currentToken value == true 		ifTrue: 			[^currentToken := RBIdentifierToken value: 'true' start: currentToken start].	currentToken value == false 		ifTrue: 			[^currentToken := RBIdentifierToken value: 'false' start: currentToken start].	currentToken value == nil 		ifTrue: 			[^currentToken := RBIdentifierToken value: 'nil' start: currentToken start]</body><body package="Browser-Parser">patchNegativeLiteral	"Handle the special negative number case for binary message sends."	(currentToken value isKindOf: Number) ifFalse: [^self].	currentToken value &lt;= 0 ifFalse: [^self].	currentToken value = 0 		ifTrue: 			[(source notNil and: 					[source notEmpty 						and: [(source at: (currentToken start min: source size)) == $-]]) 				ifFalse: [^self]].	nextToken := currentToken.	currentToken := RBBinarySelectorToken value: #- start: nextToken start.	nextToken value: nextToken value negated.	(nextToken isKindOf: RBNumberLiteralToken) 		ifTrue: 			[nextToken source: (nextToken source copyFrom: 2 to: nextToken source size)].	nextToken start: nextToken start + 1</body><body package="Browser-Parser">reposition: aNewPosition	"Meant for the case where we use another parser to consume subtexts, state needs to be cleared when we do this."	scanner sourceStream position: aNewPosition.	scanner step; stripSeparators.	nextToken := currentToken := nil.	self step</body><body package="Browser-Parser">step	(currentToken notNil and: [currentToken comments notNil]) 		ifTrue: [comments addAll: currentToken comments].	nextToken notNil 		ifTrue: 			[currentToken := nextToken.			nextToken := nil]		ifFalse: [currentToken := scanner next]</body></methods><methods><class-id>Refactory.Browser.RBParser</class-id> <category>private-classes</category><body package="Browser-Parser">assignmentNodeClass	^RBAssignmentNode</body><body package="Browser-Parser">blockNodeClass	^RBBlockNode</body><body package="Browser-Parser">cascadeNodeClass	^RBCascadeNode</body><body package="Browser-Parser">literalArrayNodeClass	^RBLiteralArrayNode</body><body package="Browser-Parser">messageNodeClass	^RBMessageNode</body><body package="Browser-Parser">methodNodeClass	^RBMethodNode</body><body package="Browser-Parser">returnNodeClass	^RBReturnNode</body><body package="Browser-Parser">sequenceNodeClass	^RBSequenceNode</body><body package="Browser-Parser">variableNodeClass	^RBVariableNode</body></methods><methods><class-id>Refactory.Browser.RBParser</class-id> <category>testing</category><body package="Browser-Parser">atEnd	^currentToken class == RBToken</body><body package="Browser-Parser">canHaveStatementsAfterReturn	^false</body></methods><methods><class-id>Refactory.Browser.RBParser</class-id> <category>accessing</category><body package="Browser-Parser">checkEndOfInputFor: aRBProgramNode	[self atEnd] whileFalse: 			[self parserError: #UnknownInputAtEnd &lt;&lt; #browser &gt;&gt; 'Unknown input at end'.			self deleteCurrentToken.			self step]</body><body package="Browser-Parser">errorBlock: aBlock	errorBlock := aBlock.	scanner notNil ifTrue: [scanner errorBlock: aBlock]</body><body package="Browser-Parser">initializeParserWith: aString	source := aString.	self scanner: (self scannerClass on: (ReadStream on: aString)				errorBlock: errorBlock)</body><body package="Browser-Parser">parseExpression: aString	| node |	node := self parseStatements: nil.	(RBMethodNode selector: #noMethod body: node) source: aString.	"Make the sequence node have a method node as its parent"	self checkEndOfInputFor: node.	self addPropertiesTo: node.	^node</body><body package="Browser-Parser">parseMethod: aString 	| node |	node := self parseMethod.	self checkEndOfInputFor: node.	node source: aString.	self addPropertiesTo: node.	^node</body><body package="Browser-Parser">scannerClass	^RBScanner</body></methods><methods><class-id>Refactory.Browser.RBParser</class-id> <category>error handling</category><body package="Browser-Parser">errorPosition	^currentToken start</body><body package="Browser-Parser">parserError: aString	^self parserError: aString position: self errorPosition</body><body package="Browser-Parser">parserError: aString position: aPosition	errorBlock notNil		ifTrue: [errorBlock value: aString value: aPosition value: self]</body></methods><methods><class-id>Refactory.Browser.RBParser</class-id> <category>initialize-release</category><body package="Browser-Parser">scanner: aScanner	scanner := aScanner.	comments := OrderedCollection new.	errorActions := OrderedCollection new.	self step</body></methods><methods><class-id>Refactory.Browser.RBParser</class-id> <category>private-parsing</category><body package="Browser-Parser">parseArgs	| args |	args := OrderedCollection new.	[currentToken isIdentifier] whileTrue: [args add: self parseVariableNode].	^args</body><body package="Browser-Parser">parseAssignment	"Need one token lookahead to see if we have a ':='. This method could 	make it possible to assign the literals true, false and nil."	| node position |	(currentToken isIdentifier and: [self nextToken isAssignment]) 		ifFalse: [^self parseCascadeMessage].	node := self parseVariableNode.	position := currentToken start.	self step.	^self assignmentNodeClass 		variable: node		value: self parseAssignment		position: position</body><body package="Browser-Parser">parseBinaryMessage	| node |	node := self parseUnaryMessage.		[currentToken isLiteralToken ifTrue: [self patchNegativeLiteral].	currentToken isBinary] 			whileTrue: [node := self parseBinaryMessageWith: node].	^node</body><body package="Browser-Parser">parseBinaryMessageWith: aNode 	| binaryToken |	binaryToken := currentToken.	self step.	^self messageNodeClass 		receiver: aNode		selectorParts: (Array with: binaryToken)		arguments: (Array with: self parseUnaryMessage)</body><body package="Browser-Parser">parseBinaryPattern	| binaryToken node args |	binaryToken := currentToken.	self step.	args := Array with: self parseVariableNode.	node := self methodNodeClass		selectorParts: (Array with: binaryToken)		arguments: args.	node comments: node comments , args last comments.	args last comments: nil.	^node</body><body package="Browser-Parser">parseBlock	| position node |	position := currentToken start.	self step.	node := self blockNodeClass new.	self parseBlockArgsInto: node.	node left: position.	node body: (self parseStatements: $]).	(currentToken isSpecial and: [currentToken value == $]])		ifTrue: 			[node right: currentToken start.			self step]		ifFalse: 			[self parserError: #CloseBracketExpected &lt;&lt; #browser &gt;&gt; ''']'' expected'.			self insert: ']'].	self addPropertiesTo: node.	^node</body><body package="Browser-Parser">parseBlockArgsInto: node	| verticalBar args colons |	args := OrderedCollection new: 2.	colons := OrderedCollection new: 2.	verticalBar := false.	[currentToken isSpecial and: [currentToken value == $:]] whileTrue: 			[colons add: currentToken start.			self step.	":"			verticalBar := true.			args add: self parseVariableNode].	verticalBar		ifTrue: 			[currentToken isBinary				ifTrue: 					[node bar: currentToken start.					currentToken value == #|						ifTrue: [self step]						ifFalse: 							[(currentToken value == #'||' or: [currentToken value = #'|||'])								ifTrue: 									["Hack the current token to be the start of temps bar"									currentToken										value: (currentToken value size = 2 ifTrue: [#|] ifFalse: [#'||']);										start: currentToken start + 1]								ifFalse: 									[self parserError: #BarExpected &lt;&lt; #browser &gt;&gt; '''|'' expected'.									self insert: '|']]]				ifFalse: 					[(currentToken isSpecial and: [currentToken value == $]])						ifFalse: 							[self parserError: #BarExpected &lt;&lt; #browser &gt;&gt; '''|'' expected'.							self insert: '|']]].	node		arguments: args;		colons: colons.	self addPropertiesTo: node.	^node</body><body package="Browser-Parser">parseByteArrayObjectsInto: aStream	[self isValidByteArrayObjectToken] whileTrue: 			[self parseLiteralByteArrayObject ifNotNil: [:node | aStream nextPut: node]]</body><body package="Browser-Parser">parseCascadeMessage	| node receiver messages semicolons |	node := self parseKeywordMessage.	(currentToken isSpecial		and: [currentToken value == $; and: [node isMessage]]) ifFalse: [^node].	receiver := node receiver.	messages := OrderedCollection new: 3.	semicolons := OrderedCollection new: 3.	messages add: node.	[currentToken isSpecial and: [currentToken value == $;]] whileTrue: 			[| message |			semicolons add: currentToken start.			self step.			currentToken isIdentifier				ifTrue: [message := self parseUnaryMessageWith: receiver]				ifFalse: 					[currentToken isKeyword						ifTrue: [message := self parseKeywordMessageWith: receiver]						ifFalse: 							[currentToken isLiteralToken ifTrue: [self patchNegativeLiteral].							currentToken isBinary								ifTrue: [message := self parseBinaryMessageWith: receiver]								ifFalse: [message := self parseMissingCascadedMessage: receiver]]].			messages add: message].	^self cascadeNodeClass messages: messages semicolons: semicolons</body><body package="Browser-Parser">parseCDeclarationTag	"The idea here is to use the CPreprocessor/CDeclarationParser processor to simply consume the characters on the source stream, we know at this point that we've seen a &lt;C: pattern. We end up having to reach around the parser's normal mode of operations. For one, we have to transform the error mechanism into one we like, and then we have to inline our version so we can use a different source position. We also have to 'reposition:' ourselves which basically means jumping ahead to where the CParsers left off and resyncing the scan from that point."	| subStream selectorToken start stop |	selectorToken := currentToken.	subStream := source readStream.	start := selectorToken stop + 1.	[start &gt; source size ifTrue: [		self parserError: #TagTokenExpected &lt;&lt; #browser &gt;&gt; 'Unary or keword expected'.		^nil].	(source at: start) isSeparator] whileTrue: [start := start + 1].	subStream position: start - 1.		[(#{CPreprocessor} value		parseWithNoPreprocess: subStream		as: #defineOrSingleDeclaration		declarations: ExternalDictionary new		requestor: (SignallingCompilerErrorHandler				handler: SilentCompilerErrorHandler new))			lastDefine			ifNil: 				[subStream position: start - 1.				#{CDeclarationParser} value					parseWithNoPreprocess: subStream					as: #defineOrSingleDeclaration					declarations: ExternalDictionary new					requestor: (SignallingCompilerErrorHandler							handler: SilentCompilerErrorHandler new)]]			on: CompilerError			do: [:ex | ^self signalInvalidCTagError: ex].	stop := subStream position - 1.	[(source at: stop) isSeparator] whileTrue: [stop := stop - 1].	self reposition: stop.	^RBCDeclarationNode selectorParts: (Array with: selectorToken)		arguments: (Array				with: (RBLiteralNode literalToken: (RBLiteralToken								value: (source copyFrom: start to: stop) asString								start: start								stop: stop)))</body><body package="Browser-Parser">parseKeywordMessage	^self parseKeywordMessageWith: self parseBinaryMessage</body><body package="Browser-Parser">parseKeywordMessageWith: node 	| args isKeyword keywords |	args := OrderedCollection new: 3.	keywords := OrderedCollection new: 3.	isKeyword := false.	[currentToken isKeyword] whileTrue: 			[keywords add: currentToken.			self step.			args add: self parseBinaryMessage.			isKeyword := true].	^isKeyword 		ifTrue: 			[self messageNodeClass 				receiver: node				selectorParts: keywords				arguments: args]		ifFalse: [node]</body><body package="Browser-Parser">parseKeywordPattern	| keywords args node |	keywords := OrderedCollection new: 2.	args := OrderedCollection new: 2.	[currentToken isKeyword]		whileTrue:			[keywords add: currentToken.			self step.			args add: self parseVariableNode].	node := self methodNodeClass		selectorParts: keywords		arguments: args.	node comments: (node comments, args last comments).	args last comments: nil.	^node</body><body package="Browser-Parser">parseKeywordTag	| selectorParts arguments keywordTag |	selectorParts := OrderedCollection new.	arguments := OrderedCollection new.	[currentToken isKeyword] whileTrue: 			[| literalNode |			selectorParts addLast: currentToken.			self step.			self patchLiteralArraySymbolToken.			literalNode := self parsePrimitiveObject.			literalNode isLiteralNode				ifFalse: [literalNode := self signalInvalidKeywordArgumentFor: literalNode].			arguments addLast: literalNode].	keywordTag := RBTagNode selectorParts: selectorParts arguments: arguments.	^self patchPrimitiveTag: keywordTag</body><body package="Browser-Parser">parseLiteralArray	| stream start stop node |	start := currentToken start.	stream := WriteStream on: (Array new: 5).	self step.	[self atEnd or: [currentToken isSpecial and: [currentToken value = $)]]]		whileFalse: 			[self parseLiteralArrayObject				ifNotNil: [:literal | stream nextPut: literal]].	(currentToken isSpecial and: [currentToken value == $)])		ifTrue: 			[stop := currentToken stop.			self step]		ifFalse: 			[self parserError: #CloseParenExpected &lt;&lt; #browser &gt;&gt; ''')'' expected'.			self insert: ')'].	node := self literalArrayNodeClass				startPosition: start				contents: stream contents				stopPosition: stop				isByteArray: false.	self addPropertiesTo: node.	^node</body><body package="Browser-Parser">parseLiteralArrayObject	currentToken isSpecial		ifTrue: 			[currentToken value == $( ifTrue: [^self parseLiteralArray].			currentToken value == $[ ifTrue: [^self parseLiteralByteArray]].	currentToken isLiteralArrayToken		ifTrue: 			[^currentToken isForByteArray				ifTrue: [self parseLiteralByteArray]				ifFalse: [self parseLiteralArray]].	currentToken isLiteralToken		ifFalse: [self patchLiteralArrayToken ifFalse: [^nil]].	^self parsePrimitiveLiteral</body><body package="Browser-Parser">parseLiteralByteArray	| stream start stop node |	start := currentToken start.	stream := WriteStream on: (Array new: 5).	self step.	self parseByteArrayObjectsInto: stream.	(currentToken isSpecial and: [currentToken value == $]])		ifTrue: 			[stop := currentToken stop.			self step]		ifFalse: 			[self parserError: #CloseBracketExpected &lt;&lt; #browser &gt;&gt; ''']'' expected'.			self insert: ']'].	node := self literalArrayNodeClass				startPosition: start				contents: stream contents				stopPosition: stop				isByteArray: true.	self addPropertiesTo: node.	^node</body><body package="Browser-Parser">parseLiteralByteArrayObject	| node |	(currentToken value between: 0 and: 255)		ifTrue: [node := self parsePrimitiveLiteral]		ifFalse: 			[self parserError: #CloseBracketExpected &lt;&lt; #browser &gt;&gt; ''']'' expected'.			self deleteCurrentToken.			self step.			node := nil].	^node</body><body package="Browser-Parser">parseMessagePattern	currentToken isLiteralToken ifTrue: [self patchLiteralMessage].	currentToken isIdentifier ifTrue: [^self parseUnaryPattern].	currentToken isKeyword ifTrue: [^self parseKeywordPattern].	currentToken isBinary ifTrue: [^self parseBinaryPattern].	^self parseMissingMessagePattern</body><body package="Browser-Parser">parseMethod	| methodNode |	methodNode := self parseMessagePattern.	methodNode tags: self parseTags.	self addPropertiesAndCommentsTo: methodNode.	methodNode body: (self parseStatements: nil).	self addPropertiesTo: methodNode.	^methodNode</body><body package="Browser-Parser">parseParenthesizedExpression	| leftParen node |	leftParen := currentToken start.	self step.	node := self parseAssignment.	(currentToken isSpecial and: [currentToken value == $)])		ifTrue: 			[node addParenthesis: (leftParen to: currentToken start).			self step]		ifFalse: 			[self parserError: #CloseParenExpected &lt;&lt; #browser &gt;&gt; ''')'' expected'.			self insert: ')'].	self addPropertiesTo: node.	^node</body><body package="Browser-Parser">parsePrimitiveIdentifier	| token node |	token := currentToken.	self step.	node := self variableNodeClass identifierToken: token.	self addPropertiesAndCommentsTo: node.	^node</body><body package="Browser-Parser">parsePrimitiveLiteral	| token |	token := currentToken.	self step.	^RBLiteralNode literalToken: token</body><body package="Browser-Parser">parsePrimitiveObject	currentToken isIdentifier ifTrue: [^self parsePrimitiveIdentifier].	(currentToken isLiteralToken and: [currentToken isMultiKeyword not])		ifTrue: [^self parsePrimitiveLiteral].	currentToken isLiteralArrayToken		ifTrue: 			[^currentToken isForByteArray				ifTrue: [self parseLiteralByteArray]				ifFalse: [self parseLiteralArray]].	currentToken isSpecial		ifTrue: 			[currentToken value == $[ ifTrue: [^self parseBlock].			currentToken value == $( ifTrue: [^self parseParenthesizedExpression]].	self parserError: #VariableExpected &lt;&lt; #browser &gt;&gt; 'Variable expected'.	^self createObjectErrorNode</body><body package="Browser-Parser">parseStatementListInto: sequenceNode endWith: aCharacter	| statements return periods returnPosition node lastToken firstReturn missingSeparator |	return := false.	firstReturn := nil.	missingSeparator := false.	statements := OrderedCollection new.	periods := OrderedCollection new.	self addPropertiesAndCommentsTo: sequenceNode.		[self atEnd		or: [currentToken isSpecial and: [aCharacter == currentToken value]]]			whileFalse: 				[return					ifTrue: 						[self parserError: #EndOfStmtList &lt;&lt; #browser									&gt;&gt; 'End of statement list encountered'.						missingSeparator ifTrue: [self insert: '. ']].				self addPropertiesTo: sequenceNode.				lastToken := currentToken.				(currentToken isSpecial and: [currentToken value == $^])					ifTrue: 						[returnPosition := currentToken start.						self step.						node := self returnNodeClass return: returnPosition									value: self parseAssignment.						statements add: node.						firstReturn isNil ifTrue: [firstReturn := statements size].						return := self canHaveStatementsAfterReturn not]					ifFalse: 						[node := self parseAssignment.						statements add: node].				(lastToken == currentToken and: [statements last hasErrors])					ifTrue: 						[self deleteCurrentToken.						self step.						statements removeLast]					ifFalse: 						[(currentToken isSpecial and: [currentToken value == $.])							ifTrue: 								[periods add: currentToken start.								self step.								self addPropertiesAndCommentsTo: node]							ifFalse: 								[missingSeparator := true.								return := true]]].	statements notEmpty		ifTrue: [self addPropertiesAndCommentsTo: statements last].	(self canHaveStatementsAfterReturn not		and: [firstReturn notNil and: [firstReturn &lt; statements size]])			ifTrue: 				[firstReturn to: statements size - 1					do: 						[:i |						(statements at: i) isReturn							ifTrue: 								[self									delete: (RBSpecialCharacterToken value: $^ start: (statements at: i) start).								statements at: i put: (statements at: i) value]]].	sequenceNode		statements: statements;		periods: periods.	self addPropertiesTo: sequenceNode.	^sequenceNode</body><body package="Browser-Parser">parseStatements: aCharacter	| args leftBar rightBar node |	args := #().	leftBar := rightBar := nil.	currentToken isBinary		ifTrue: 			[currentToken value == #|				ifTrue: 					[leftBar := currentToken start.					self step.					args := self parseArgs.					(currentToken isBinary and: [currentToken value = #|])						ifTrue: 							[rightBar := currentToken start.							self step]						ifFalse: 							[self parserError: #BarExpected &lt;&lt; #browser &gt;&gt; '''|'' expected'.							self insert: '|']]				ifFalse: 					[currentToken value == #'||'						ifTrue: 							[rightBar := (leftBar := currentToken start) + 1.							self step]]].	node := self sequenceNodeClass				leftBar: leftBar				temporaries: args				rightBar: rightBar.	self addPropertiesTo: node.	^self parseStatementListInto: node endWith: aCharacter</body><body package="Browser-Parser">parseTag	| startToken tagNode |	startToken := currentToken.	self step.	(currentToken isIdentifier or: [currentToken isKeyword])		ifFalse: 			[self				parserError: #TagTokenExpected &lt;&lt; #browser &gt;&gt; 'Unary or keword expected'.			self delete: startToken.			^nil].	tagNode := currentToken isIdentifier				ifTrue: [self parseUnaryTag]				ifFalse: 					[currentToken isExternalProcedure 						ifTrue: [self parseCDeclarationTag]						ifFalse: [self parseKeywordTag]].	tagNode isNil		ifTrue: 			[self delete: startToken.			(currentToken isBinary and: [currentToken value == #&gt;])				ifTrue: 					[self deleteCurrentToken.					self step]]		ifFalse: 			[(currentToken isBinary and: [currentToken value == #&gt;])				ifTrue: 					[tagNode brackets: (startToken start to: currentToken start).					self step]				ifFalse: 					[self parserError: #TagCloseExpected &lt;&lt; #browser &gt;&gt; 'expected &gt;'.					self insert: '&gt;'].			self addPropertiesTo: tagNode].	^tagNode</body><body package="Browser-Parser">parseTags	| ws |	(currentToken isBinary and: [currentToken value == #&lt;]) ifFalse: [^nil].	ws := (Array new: 1) writeStream.	[currentToken isBinary and: [currentToken value == #&lt;]]		whileTrue: [self parseTag ifNotNil: [:tag | ws nextPut: tag]].	^ws contents</body><body package="Browser-Parser">parseUnaryMessage	| node |	node := self parsePrimitiveObject.	self addPropertiesAndCommentsTo: node.	[currentToken isLiteralToken ifTrue: [self patchLiteralMessage].	currentToken isIdentifier] 			whileTrue: [node := self parseUnaryMessageWith: node].	self addPropertiesAndCommentsTo: node.	^node</body><body package="Browser-Parser">parseUnaryMessageWith: aNode 	| selector |	selector := currentToken.	self step.	^self messageNodeClass 		receiver: aNode		selectorParts: (Array with: selector)		arguments: #()</body><body package="Browser-Parser">parseUnaryPattern	| selector |	selector := currentToken.	self step.	^self methodNodeClass selectorParts: (Array with: selector) arguments: #()</body><body package="Browser-Parser">parseUnaryTag	| tagNode |	tagNode := RBTagNode		selectorParts: (Array with: currentToken)		arguments: #().	self step.	^tagNode</body><body package="Browser-Parser">parseVariableNode	currentToken isIdentifier		ifFalse: 			[self				parserError: #VariableNameExpected &lt;&lt; #browser &gt;&gt; 'Variable name expected'.			^self createVariableErrorNode].	^self parsePrimitiveIdentifier</body><body package="Browser-Parser">patchPrimitiveTag: aKeywordTagNode	| primitiveArgument errorCode |	aKeywordTagNode looksLikePrimitiveTag ifFalse: [^aKeywordTagNode].	primitiveArgument := aKeywordTagNode arguments first.	(primitiveArgument value isInteger		or: [primitiveArgument value isCharacters])			ifFalse: [self signalInvalidPrimitiveArgument: aKeywordTagNode].	aKeywordTagNode selectorParts last value = 'errorCode:'		ifTrue: 			[errorCode := aKeywordTagNode arguments last.			errorCode value isSymbol				ifFalse: [self signalInvalidErrorCodeArgument: aKeywordTagNode]].	self addPropertiesTo: aKeywordTagNode.	^aKeywordTagNode becomePrimitiveTag</body><body package="Browser-Parser">signalInvalidKeywordArgumentFor: aRBProgramNode	self		parserError: #TagLiteralExpected &lt;&lt; #browser &gt;&gt; 'Literal constant expected'.	self delete: aRBProgramNode.	self insert: self class keywordTagName storeString at: aRBProgramNode start.	^RBLiteralNode value: self class keywordTagName</body></methods><methods><class-id>Refactory.Browser.RBParser</class-id> <category>private-parsing-error handling</category><body package="Browser-Parser">addErrorAction: aRBErrorAction	errorActions add: aRBErrorAction</body><body package="Browser-Parser">createObjectErrorNode	| errorNode |	errorNode := RBLiteralNode literalToken: (RBLiteralToken value: self class missingObjectValue at: currentToken start).	self insert: ' ' , errorNode value storeString , ' '.	self addPropertiesTo: errorNode.	^errorNode</body><body package="Browser-Parser">createVariableErrorNode	| errorNode |	errorNode := self variableNodeClass named: self class missingVariableName.	self insert: ' ' , errorNode name , ' '.	self addPropertiesTo: errorNode.	^errorNode</body><body package="Browser-Parser">delete: aRBTokenOrRBProgramNode	self addErrorAction: (RBDeleteErrorAction item: aRBTokenOrRBProgramNode)</body><body package="Browser-Parser">deleteCurrentToken	self delete: currentToken</body><body package="Browser-Parser">insert: aString	self insert: aString at: self errorPosition</body><body package="Browser-Parser">insert: aString at: anInteger	self addErrorAction: (RBInsertErrorAction insert: aString at: anInteger)</body><body package="Browser-Parser">parseMissingCascadedMessage: aRBProgramNode	| message |	self parserError: #MessageExpected &lt;&lt; #browser &gt;&gt; 'Message expected'.	message := RBMessageNode receiver: aRBProgramNode				selector: self class missingMessageName.	self insert: message selector , ' '.	self addPropertiesTo: message.	^message</body><body package="Browser-Parser">parseMissingMessagePattern	| node |	self parserError: #MessagePatternExpected &lt;&lt; #browser				&gt;&gt; 'Message pattern expected'.	node := self methodNodeClass selectorParts: (Array						with: (RBIdentifierToken value: self class missingMessageName start: nil))				arguments: #().	self insert: self class missingMessageName , ' ' at: 1.	self addPropertiesTo: node.	^node</body><body package="Browser-Parser">signalInvalidCTagError: aCompilerError	| position endTag crPosition stopPosition errorSource |	position := aCompilerError sourcePosition.	self parserError: aCompilerError parameter position: position.	stopPosition := position min: source size.	position &lt; source size		ifTrue: 			[endTag := source indexOfSubCollection: '&gt;' startingAt: position.			crPosition := source indexOfSubCollection: (String with: Character cr)						startingAt: position.			crPosition = 0 ifTrue: [crPosition := source size + 1].			(endTag &gt; 0 and: [endTag &lt; crPosition])				ifTrue: [stopPosition := endTag - 1]].	errorSource := source copyFrom: currentToken start to: stopPosition.	self delete: (RBValueToken value: errorSource start: currentToken start).	self reposition: stopPosition.	^nil</body><body package="Browser-Parser">signalInvalidErrorCodeArgument: aKeywordTagNode	self parserError: #PrimitiveArgumentErrorCodeType &lt;&lt; #IDE				&gt;&gt; 'Primitive error code variable name expected'		position: aKeywordTagNode arguments last start.	self delete: aKeywordTagNode arguments last.	self insert: self class primitiveErrorCodeName		at: aKeywordTagNode arguments last start.	aKeywordTagNode arguments at: 2		put: (RBLiteralNode				value: (self class primitiveErrorCodeName copyWithout: $#) asSymbol)</body><body package="Browser-Parser">signalInvalidPrimitiveArgument: aKeywordTagNode	self parserError: #PrimitiveArgumentType &lt;&lt; #IDE				&gt;&gt; 'Primitive integer or string expected'		position: aKeywordTagNode arguments first start.	self delete: aKeywordTagNode arguments first.	self insert: self class primitiveIntegerOrStringName		at: aKeywordTagNode arguments first start.	aKeywordTagNode arguments at: 1		put: (RBLiteralNode				value: (self class primitiveIntegerOrStringName copyWithout: $'))</body></methods><methods><class-id>Refactory.Browser.RBParser class</class-id> <category>accessing</category><body package="Browser-Parser">parseExpression: aString 	^self parseExpression: aString onError: nil</body><body package="Browser-Parser">parseExpression: aString onError: aBlock	| node parser |	parser := self new.	parser errorBlock: (self createErrorBlock: aBlock).	parser initializeParserWith: aString.	node := parser parseExpression: aString.	^(node statements size == 1 and: [node temporaries isEmpty])		ifTrue: [node statements first]		ifFalse: [node]</body><body package="Browser-Parser">parseExpressionWithErrors: aString	| node parser |	parser := self new.	parser initializeParserWith: aString.	node := parser parseExpression: aString.	^(node statements size == 1 and: [node temporaries isEmpty and: [node hasErrors not]])		ifTrue: [node statements first]		ifFalse: [node]</body><body package="Browser-Parser">parseMethod: aString 	^self parseMethod: aString onError: nil</body><body package="Browser-Parser">parseMethod: aString onError: aBlock	"Error block takes two arguments: 1) the error string describing the parser error 2) the position the error took place at."	| parser |	parser := self new.	parser errorBlock: (self createErrorBlock: aBlock).	parser initializeParserWith: aString.	^parser parseMethod: aString</body><body package="Browser-Parser">parseMethodWithErrors: aString	| parser |	parser := self new.	parser initializeParserWith: aString.	^parser parseMethod: aString</body><body package="Browser-Parser">parseRewriteExpression: aString 	^self parseRewriteExpression: aString onError: nil</body><body package="Browser-Parser">parseRewriteExpression: aString onError: aBlock 	^RBPatternParser parseExpression: aString onError: aBlock</body><body package="Browser-Parser">parseRewriteMethod: aString 	^self parseRewriteMethod: aString onError: nil</body><body package="Browser-Parser">parseRewriteMethod: aString onError: aBlock 	^RBPatternParser parseMethod: aString onError: aBlock</body></methods><methods><class-id>Refactory.Browser.RBParser class</class-id> <category>parsing</category><body package="Browser-Parser">parseMethodPattern: aString 	| parser |	parser := self new.	parser errorBlock: [:error :position | ^nil].	parser initializeParserWith: aString.	^parser parseMessagePattern selector</body></methods><methods><class-id>Refactory.Browser.RBParser class</class-id> <category>error correction</category><body package="Browser-Parser">keywordTagName	^#_missing_literal_</body><body package="Browser-Parser">missingMessageName	^#_missing_message_</body><body package="Browser-Parser">missingObjectValue	^'_missing_object_'</body><body package="Browser-Parser">missingQualifiedReferenceName	^'_missing_qualified_reference_'</body><body package="Browser-Parser">missingVariableName	^'_missing_variable_'</body><body package="Browser-Parser">primitiveErrorCodeName	^'#_error_code_'</body><body package="Browser-Parser">primitiveIntegerOrStringName	^'''string or integer'''</body></methods><methods><class-id>Refactory.Browser.RBParser class</class-id> <category>private</category><body package="Browser-Parser">createErrorBlock: aBlock	^[:message :position :object |	aBlock notNil ifTrue: [aBlock cull: message cull: position].	object error: message]</body></methods><methods><class-id>Refactory.Browser.RBPatternParser</class-id> <category>private-classes</category><body package="Browser-Parser">messageNodeClass	^RBPatternMessageNode</body><body package="Browser-Parser">methodNodeClass	^RBPatternMethodNode</body><body package="Browser-Parser">variableNodeClass	^RBPatternVariableNode</body></methods><methods><class-id>Refactory.Browser.RBPatternParser</class-id> <category>private-parsing</category><body package="Browser-Parser">parseLiteralByteArrayObject	(currentToken isIdentifier and: [currentToken isPatternVariable])		ifTrue: 			[| node |			node := self variableNodeClass identifierToken: currentToken.			self step.			^node].	^super parseLiteralByteArrayObject</body><body package="Browser-Parser">parsePatternBlock: aClass	| position node |	position := currentToken start.	self step.	node := self parseBlockArgsInto: aClass new.	node left: position.	node body: (self parseStatements: $}).	(currentToken isSpecial and: [currentToken value == $}])		ifTrue: 			[node right: currentToken start.			self step]		ifFalse: 			[self parserError: #CloseBraceExpected &lt;&lt; #browser &gt;&gt; '} expected'.			self insert: '}'].	self addPropertiesTo: node.	^node</body><body package="Browser-Parser">parsePrimitiveLiteral	| node |	(currentToken isIdentifier and: [currentToken isPatternVariable]) 		ifTrue: 			[node := self variableNodeClass identifierToken: currentToken.			node isLiteralNode 				ifTrue: 					[self step.					^node].			currentToken := RBLiteralToken 						value: currentToken value asSymbol						start: currentToken start						stop: currentToken stop].	^super parsePrimitiveLiteral</body><body package="Browser-Parser">parsePrimitiveObject	currentToken isPatternBlock 		ifTrue: [^self parsePatternBlock: RBPatternBlockNode].	^super parsePrimitiveObject</body><body package="Browser-Parser">parseUnaryMessage	| node |	node := self parsePrimitiveObject.	self addPropertiesAndCommentsTo: node.		[currentToken isLiteralToken ifTrue: [self patchLiteralMessage].	currentToken isPatternBlock 		ifTrue: 			[node := (self parsePatternBlock: RBPatternWrapperBlockNode)						wrappedNode: node;						yourself].	currentToken isIdentifier] 			whileTrue: [node := self parseUnaryMessageWith: node].	self addPropertiesAndCommentsTo: node.	^node</body></methods><methods><class-id>Refactory.Browser.RBPatternParser</class-id> <category>accessing</category><body package="Browser-Parser">scannerClass	^RBPatternScanner</body></methods><methods><class-id>Refactory.Browser.RBPatternParser</class-id> <category>private</category><body package="Browser-Parser">isValidByteArrayObjectToken	^super isValidByteArrayObjectToken		or: [currentToken isIdentifier and: [currentToken isPatternVariable]]</body><body package="Browser-Parser">patchLiteralArrayToken	(currentToken isIdentifier and: [currentToken isPatternVariable])		ifTrue: [^true].	^super patchLiteralArrayToken</body></methods><methods><class-id>Refactory.Browser.RBAssignmentNode</class-id> <category>comparing</category><body package="Browser-Parser">= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	^self variable = anObject variable and: [self value = anObject value]</body><body package="Browser-Parser">equalTo: anObject withMapping: aDictionary 	^self class = anObject class and: 			[(self variable equalTo: anObject variable withMapping: aDictionary) 				and: [self value equalTo: anObject value withMapping: aDictionary]]</body><body package="Browser-Parser">hash	^self variable hash bitXor: self value hash</body></methods><methods><class-id>Refactory.Browser.RBAssignmentNode</class-id> <category>visitor</category><body package="Browser-Parser">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptAssignmentNode: self</body></methods><methods><class-id>Refactory.Browser.RBAssignmentNode</class-id> <category>testing</category><body package="Browser-Parser">assigns: aVariableName 	^variable name = aVariableName or: [value assigns: aVariableName]</body><body package="Browser-Parser">directlyUses: aNode 	^aNode = value ifTrue: [true] ifFalse: [self isDirectlyUsed]</body><body package="Browser-Parser">isAssignment	^true</body><body package="Browser-Parser">needsParenthesis	^parent isNil 		ifTrue: [false]		ifFalse: [self precedence &gt; parent precedence]</body><body package="Browser-Parser">uses: aNode 	^aNode = value ifTrue: [true] ifFalse: [self isUsed]</body></methods><methods><class-id>Refactory.Browser.RBAssignmentNode</class-id> <category>querying</category><body package="Browser-Parser">bestNodeFor: anInterval 	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	assignment isNil ifTrue: [^super bestNodeFor: anInterval].	((anInterval first between: assignment and: assignment + 1) 		or: [assignment between: anInterval first and: anInterval last]) 			ifTrue: [^self].	self children do: 			[:each | 			| node |			node := each bestNodeFor: anInterval.			node notNil ifTrue: [^node]]</body></methods><methods><class-id>Refactory.Browser.RBAssignmentNode</class-id> <category>accessing</category><body package="Browser-Parser">allLeafNodesAndTokensDo: aBlockClosure	variable allLeafNodesAndTokensDo: aBlockClosure.	value allLeafNodesAndTokensDo: aBlockClosure</body><body package="Browser-Parser">assignmentPosition	^assignment</body><body package="Browser-Parser">children	^Array with: value with: variable</body><body package="Browser-Parser">precedence	^5</body><body package="Browser-Parser">startWithoutParentheses	^variable start</body><body package="Browser-Parser">stopWithoutParentheses	^value stop</body><body package="Browser-Parser">value	^value</body><body package="Browser-Parser">value: aValueNode 	value := aValueNode.	value parent: self</body><body package="Browser-Parser">variable	^variable</body><body package="Browser-Parser">variable: varNode 	variable := varNode.	variable parent: self</body></methods><methods><class-id>Refactory.Browser.RBAssignmentNode</class-id> <category>matching</category><body package="Browser-Parser">copyInContext: aDictionary 	^(self class new)		variable: (variable copyInContext: aDictionary);		value: (value copyInContext: aDictionary);		yourself</body><body package="Browser-Parser">match: aNode inContext: aDictionary 	aNode class == self class ifFalse: [^false].	^(variable match: aNode variable inContext: aDictionary)		and: [value match: aNode value inContext: aDictionary]</body></methods><methods><class-id>Refactory.Browser.RBAssignmentNode</class-id> <category>copying</category><body package="Browser-Parser">postCopy	super postCopy.	self variable: self variable copy.	self value: self value copy</body></methods><methods><class-id>Refactory.Browser.RBAssignmentNode</class-id> <category>replacing</category><body package="Browser-Parser">replaceNode: aNode withNode: anotherNode 	value == aNode ifTrue: [self value: anotherNode].	variable == aNode ifTrue: [self variable: anotherNode]</body><body package="Browser-Parser">replaceSourceWith: aNode 	"Check if we are being replaced with a setter message send. If so, create the replacements to edit the original source."	aNode isMessage ifFalse: [^super replaceSourceWith: aNode].	aNode receiver isVariable ifFalse: [^super replaceSourceWith: aNode].	aNode numArgs = 1 ifFalse: [^super replaceSourceWith: aNode].	(self mappingFor: self value) = aNode arguments first 		ifFalse: [^super replaceSourceWith: aNode].	(self value hasParentheses not 		and: [aNode arguments first precedence &gt;= aNode precedence]) 			ifTrue: 				[self					addReplacement: (RBStringReplacement 								replaceFrom: self value start								to: self value start - 1								with: '(');					addReplacement: (RBStringReplacement 								replaceFrom: self value stop + 1								to: self value stop								with: ')')].	self addReplacement: (RBStringReplacement 				replaceFrom: self variable start				to: self assignmentPosition + 1				with: aNode receiver name , ' ' , aNode selector)</body></methods><methods><class-id>Refactory.Browser.RBAssignmentNode</class-id> <category>initialize-release</category><body package="Browser-Parser">variable: aVariableNode value: aValueNode position: anInteger 	self variable: aVariableNode.	self value: aValueNode.	assignment := anInteger</body></methods><methods><class-id>Refactory.Browser.RBAssignmentNode class</class-id> <category>instance creation</category><body package="Browser-Parser">variable: aVariableNode value: aValueNode 	^self 		variable: aVariableNode		value: aValueNode		position: nil</body><body package="Browser-Parser">variable: aVariableNode value: aValueNode position: anInteger 	^(self new)		variable: aVariableNode			value: aValueNode			position: anInteger;		yourself</body></methods><methods><class-id>Refactory.Browser.RBCDeclarationNode</class-id> <category>visitor</category><body package="Browser-Parser">acceptVisitor: aProgramNodeVisitor	aProgramNodeVisitor acceptCDeclarationNode: self</body></methods><methods><class-id>Refactory.Browser.RBCDeclarationNode</class-id> <category>accessing</category><body package="Browser-Parser">cDeclarationText	^self arguments first value</body></methods><methods><class-id>Refactory.Browser.RBCDeclarationNode</class-id> <category>testing</category><body package="Browser-Parser">isCDeclaration	^true</body></methods><methods><class-id>Refactory.Browser.RBStringReplaceRule</class-id> <category>initialize-release</category><body package="Browser-Parser">methodReplaceString: replaceString 	replaceTree := RBParser parseRewriteMethod: replaceString</body><body package="Browser-Parser">replaceString: replaceString 	replaceTree := RBParser parseRewriteExpression: replaceString.	searchTree isSequence = replaceTree isSequence 		ifFalse: 			[searchTree isSequence 				ifTrue: [replaceTree := RBSequenceNode statements: (Array with: replaceTree)]				ifFalse: [searchTree := RBSequenceNode statements: (Array with: searchTree)]]</body><body package="Browser-Parser">searchFor: searchString replaceWith: replaceString 	self searchString: searchString.	self replaceString: replaceString</body><body package="Browser-Parser">searchFor: searchString replaceWith: replaceString when: aBlock 	self searchFor: searchString replaceWith: replaceString.	verificationBlock := aBlock</body><body package="Browser-Parser">searchForMethod: searchString replaceWith: replaceString 	self methodSearchString: searchString.	self methodReplaceString: replaceString</body><body package="Browser-Parser">searchForMethod: searchString replaceWith: replaceString when: aBlock 	self searchForMethod: searchString replaceWith: replaceString.	verificationBlock := aBlock</body><body package="Browser-Parser">searchForTree: aBRProgramNode replaceWith: replaceNode 	searchTree := aBRProgramNode.	replaceTree := replaceNode</body><body package="Browser-Parser">searchForTree: aBRProgramNode replaceWith: replaceString when: aBlock 	self searchForTree: aBRProgramNode replaceWith: replaceString.	verificationBlock := aBlock</body></methods><methods><class-id>Refactory.Browser.RBStringReplaceRule</class-id> <category>matching</category><body package="Browser-Parser">foundMatchFor: aProgramNode 	| newNode |	newNode := replaceTree copyInContext: self context.	aProgramNode replaceMethodSource: newNode.	newNode copyCommentsFrom: aProgramNode.	^newNode</body></methods><methods><class-id>Refactory.Browser.RBStringReplaceRule class</class-id> <category>instance creation</category><body package="Browser-Parser">searchFor: searchString replaceWith: replaceString 	^self new searchFor: searchString replaceWith: replaceString</body><body package="Browser-Parser">searchFor: searchString replaceWith: replaceString when: aBlock 	^self new 		searchFor: searchString		replaceWith: replaceString		when: aBlock</body><body package="Browser-Parser">searchForMethod: searchString replaceWith: replaceString 	^(self new)		searchForMethod: searchString replaceWith: replaceString;		yourself</body><body package="Browser-Parser">searchForMethod: searchString replaceWith: replaceString when: aBlock 	^self new 		searchForMethod: searchString		replaceWith: replaceString		when: aBlock</body><body package="Browser-Parser">searchForTree: aRBProgramNode replaceWith: replaceString 	^self new searchForTree: aRBProgramNode replaceWith: replaceString</body><body package="Browser-Parser">searchForTree: aRBProgramNode replaceWith: replaceString when: aBlock 	^self new 		searchForTree: aRBProgramNode		replaceWith: replaceString		when: aBlock</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayNode</class-id> <category>copying</category><body package="Browser-Parser">postCopy	super postCopy.	self contents: (self contents collect: [:each | each copy])</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayNode</class-id> <category>accessing</category><body package="Browser-Parser">children	^contents</body><body package="Browser-Parser">contents	^contents</body><body package="Browser-Parser">startWithoutParentheses	^start</body><body package="Browser-Parser">stopWithoutParentheses	^stop</body><body package="Browser-Parser">value	| array |	array := (isByteArray ifTrue: [ByteArray] ifFalse: [Array]) 				new: contents size.	1 to: contents size		do: [:each | array at: each put: (contents at: each) value].	^array</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayNode</class-id> <category>initialize-release</category><body package="Browser-Parser">contents: aRBLiteralNodeCollection 	contents := aRBLiteralNodeCollection.	contents do: [:each | each parent: self]</body><body package="Browser-Parser">startPosition: startInteger contents: anArray stopPosition: stopInteger isByteArray: aBoolean 	start := startInteger.	self contents: anArray.	stop := stopInteger.	isByteArray := aBoolean</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayNode</class-id> <category>replacing</category><body package="Browser-Parser">replaceNode: aNode withNode: anotherNode 	self contents: (contents 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayNode</class-id> <category>comparing</category><body package="Browser-Parser">= anObject 	super = anObject ifFalse: [^false].	self isForByteArray = anObject isForByteArray ifFalse: [^false].	self contents size = anObject contents size ifFalse: [^false].	1 to: self contents size		do: [:i | (self contents at: i) = (anObject contents at: i) ifFalse: [^false]].	^true</body><body package="Browser-Parser">equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	self isForByteArray = anObject isForByteArray ifFalse: [^false].	self contents size = anObject contents size ifFalse: [^false].	1 to: self contents size		do: 			[:i | 			((self contents at: i) equalTo: (anObject contents at: i)				withMapping: aDictionary) ifFalse: [^false]].	^true</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayNode</class-id> <category>testing</category><body package="Browser-Parser">isForByteArray	^isByteArray</body><body package="Browser-Parser">isLiteralArray	^true</body><body package="Browser-Parser">looksLikeStructuredArrayEncoding	"This is a guess, but pretty good. Basically it looks structured when every other symbol looks like a keyword message send. Also to skip something like a tag array (e.g. #(#pragma1: #pragma2: #pragma3:), we make sure that the odd elements includes at least some objects that are not symbols."	^self isForByteArray not		and:			[self children size &gt; 2				and:					[((2 to: self children size by: 2)						allSatisfy:							[:n | 							| each |							each := self children at: n.							each value isSymbol and: [each value isKeyword]])						and:							[(1 to: self children size by: 2)								anySatisfy:									[:n | 									| each |									each := self children at: n.									each value isSymbol not]]]]</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayNode</class-id> <category>visitor</category><body package="Browser-Parser">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptLiteralArrayNode: self</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayNode</class-id> <category>matching</category><body package="Browser-Parser">copyInContext: aDictionary 	^self class 		startPosition: nil		contents: (self copyList: contents inContext: aDictionary)		stopPosition: nil		isByteArray: isByteArray</body><body package="Browser-Parser">match: aNode inContext: aDictionary 	aNode class == self class ifFalse: [^false].	self isForByteArray = aNode isForByteArray ifFalse: [^false].	^self 		matchList: contents		against: aNode contents		inContext: aDictionary</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayNode</class-id> <category>private-replacing</category><body package="Browser-Parser">replaceSourceWith: aNode 	(self class = aNode class and: 			[self isForByteArray = aNode isForByteArray 				and: [self contents size = aNode contents size]]) 		ifFalse: [^super replaceSourceWith: aNode].	1 to: self contents size		do: 			[:i | 			(self contents at: i) = (aNode contents at: i) 				ifFalse: [(self contents at: i) replaceSourceWith: (aNode contents at: i)]]</body></methods><methods><class-id>Refactory.Browser.RBLiteralArrayNode class</class-id> <category>instance creation</category><body package="Browser-Parser">startPosition: startInteger contents: anArray stopPosition: stopInteger isByteArray: aBoolean 	^(self new)		startPosition: startInteger			contents: anArray			stopPosition: stopInteger			isByteArray: aBoolean;		yourself</body><body package="Browser-Parser">value: aValue 	^(self new)		startPosition: nil			contents: (aValue asArray collect: [:each | RBLiteralNode value: each])			stopPosition: nil			isByteArray: aValue class ~~ Array;		yourself</body></methods><methods><class-id>Refactory.Browser.RBAssignmentToken</class-id> <category>testing</category><body package="Browser-Parser">isAssignment	^true</body></methods><methods><class-id>Refactory.Browser.RBAssignmentToken</class-id> <category>private</category><body package="Browser-Parser">length	^2</body></methods><methods><class-id>Refactory.Browser.RBLiteralValueNode</class-id> <category>accessing</category><body package="Browser-Parser">allLeafNodesAndTokensDo: aBlockClosure	token length isZero ifTrue: [^self].	super allLeafNodesAndTokensDo: aBlockClosure</body><body package="Browser-Parser">startWithoutParentheses	^token start</body><body package="Browser-Parser">stopWithoutParentheses	^token stop</body><body package="Browser-Parser">token	^token</body><body package="Browser-Parser">value	^token realValue</body></methods><methods><class-id>Refactory.Browser.RBLiteralValueNode</class-id> <category>visitor</category><body package="Browser-Parser">acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptLiteralNode: self</body></methods><methods><class-id>Refactory.Browser.RBLiteralValueNode</class-id> <category>initialize-release</category><body package="Browser-Parser">literalToken: aLiteralToken 	token := aLiteralToken</body></methods><methods><class-id>Refactory.Browser.RBLiteralValueNode</class-id> <category>matching</category><body package="Browser-Parser">copyInContext: aDictionary	^self class literalToken: token removePositions</body></methods><methods><class-id>Refactory.Browser.RBLiteralValueNode</class-id> <category>comparing</category><body package="Browser-Parser">= anObject 	^super = anObject and: 			[self value = anObject value 				and: [self value species == anObject value species]]</body></methods><methods><class-id>Refactory.Browser.RBLiteralValueNode class</class-id> <category>instance creation</category><body package="Browser-Parser">literalToken: aLiteralToken 	^(self new)		literalToken: aLiteralToken;		yourself</body><body package="Browser-Parser">value: aValue 	^self literalToken: (RBLiteralToken value: aValue)</body></methods><methods><class-id>Refactory.Browser.RBPatternVariableNode</class-id> <category>initialize-release</category><body package="Browser-Parser">identifierToken: anIdentifierToken 	super identifierToken: anIdentifierToken.	self initializePatternVariables</body><body package="Browser-Parser">initializePatternVariables	| name |	name := self name.	isAnything := isList := isLiteral := isStatement := recurseInto := false.	2 to: name size		do: 			[:i | 			| character |			character := name at: i.			character == self listCharacter 				ifTrue: [isAnything := isList := true]				ifFalse: 					[character == self literalCharacter 						ifTrue: [isLiteral := true]						ifFalse: 							[character == self statementCharacter 								ifTrue: [isStatement := true]								ifFalse: 									[character == self recurseIntoCharacter 										ifTrue: [recurseInto := true]										ifFalse: [^self]]]]]</body></methods><methods><class-id>Refactory.Browser.RBPatternVariableNode</class-id> <category>testing-matching</category><body package="Browser-Parser">isAnything	^isAnything</body><body package="Browser-Parser">isList	^isList</body><body package="Browser-Parser">isLiteralNode	^isLiteral</body><body package="Browser-Parser">isPatternNode	^true</body><body package="Browser-Parser">isStatement	^isStatement</body><body package="Browser-Parser">recurseInto	^recurseInto</body></methods><methods><class-id>Refactory.Browser.RBPatternVariableNode</class-id> <category>private</category><body package="Browser-Parser">matchingClass	^RBVariableNode</body></methods><methods><class-id>Refactory.Browser.RBPatternVariableNode</class-id> <category>matching</category><body package="Browser-Parser">copyInContext: aDictionary 	^(aDictionary at: self) copy</body><body package="Browser-Parser">match: aNode inContext: aDictionary 	self isAnything 		ifTrue: [^(aDictionary at: self ifAbsentPut: [aNode]) = aNode].	self isLiteralNode ifTrue: [^self matchLiteral: aNode inContext: aDictionary].	self isStatement 		ifTrue: [^self matchStatement: aNode inContext: aDictionary].	aNode class == self matchingClass ifFalse: [^false].	^(aDictionary at: self ifAbsentPut: [aNode]) = aNode</body><body package="Browser-Parser">matchLiteral: aNode inContext: aDictionary 	^aNode isLiteralNode		and: [(aDictionary at: self ifAbsentPut: [aNode]) = aNode]</body><body package="Browser-Parser">matchStatement: aNode inContext: aDictionary 	(aNode parent notNil and: [aNode parent isSequence]) ifFalse: [^false].	^(aDictionary at: self ifAbsentPut: [aNode]) = aNode</body></methods><methods><class-id>Refactory.Browser.RBPatternVariableNode</class-id> <category>accessing</category><body package="Browser-Parser">parent: aBRProgramNode 	"Fix the case where '``@node' should match a single node, not a sequence node."	super parent: aBRProgramNode.	parent isSequence 		ifTrue: 			[(self isStatement or: [parent temporaries includes: self]) 				ifFalse: [isList := false]]</body></methods><methods><class-id>Refactory.Browser.RBPatternVariableNode class</class-id> <category>instance creation</category><body package="Browser-Parser">identifierToken: anIdentifierToken 	^anIdentifierToken isPatternVariable 		ifTrue: [super identifierToken: anIdentifierToken]		ifFalse: [RBVariableNode identifierToken: anIdentifierToken]</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>accessing</category><body package="Browser-Parser">firstLineLength	^firstLineLength ifNil: [codeStream position] ifNotNil: [firstLineLength]</body><body package="Browser-Parser">format: aNode	self visitNode: aNode.	^codeStream contents</body><body package="Browser-Parser">horizontalSpacingLevel: anInteger	"Horizontal spacing is tuned as minimal, medium, or high (0, 1, or 2)."	horizontalSpacing := anInteger</body><body package="Browser-Parser">lastLineLength	^codeStream position - (lineStart max: 0)</body><body package="Browser-Parser">lineLengthLimit: anObject	lineLengthLimit := anObject</body><body package="Browser-Parser">terminatorLevel: anInteger	terminatorFrequency := anInteger</body><body package="Browser-Parser">verticalSpacingLevel: anInteger	verticalSpacing := anInteger</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>private-formatting</category><body package="Browser-Parser">formatBlockNode: aBlockNode startBlockString: startBlockString endBlockString: endBlockString	| seqNode multiline formattedBody formatter |	seqNode := aBlockNode body.	formatter := (self copy)				lineStart: 0;				yourself.	formattedBody := formatter format: seqNode.	multiline := self lineLength + formattedBody size &gt; self lineLengthLimit				or: [formatter isMultiLine].	multiline ifTrue: [self indent].	codeStream nextPutAll: startBlockString.	self addModerateExtraSpace.	aBlockNode arguments do: 			[:each |			codeStream nextPut: $:.			self visitNode: each.			codeStream space].	aBlockNode arguments notEmpty		ifTrue: 			[codeStream nextPutAll: '| '.			multiline ifTrue: [self indent]].	codeStream nextPutAll: formattedBody.	self addModerateExtraSpace.	codeStream nextPutAll: endBlockString</body><body package="Browser-Parser">formatGeneralLiteralArray: aLiteralArrayNode	codeStream		nextPut: (aLiteralArrayNode isForByteArray ifTrue: [$[] ifFalse: [$(]).	self addEveryExtraSpace.	aLiteralArrayNode contents do: [:each | self visitNode: each]		separatedBy: [codeStream space].	self addEveryExtraSpace.	codeStream		nextPut: (aLiteralArrayNode isForByteArray ifTrue: [$]] ifFalse: [$)])</body><body package="Browser-Parser">formatMessage: aMessageNode cascade: cascadeBoolean	| selectorParts arguments multiLine formattedArgs indentFirst firstArgLength length argLimit |	selectorParts := aMessageNode selectorParts.	arguments := aMessageNode arguments.	formattedArgs := OrderedCollection new.	argLimit := self maximumArgumentsPerLine.	(arguments allSatisfy: [:each | each children isEmpty])		ifTrue: [argLimit := argLimit + 1].	multiLine := aMessageNode selector numArgs &gt; argLimit.	length := aMessageNode selector size + arguments size + 1.	firstArgLength := 0.	self indentWhile: 			[1 to: arguments size				do: 					[:i |					| formatter string |					formatter := (self copy)								lineStart: (selectorParts at: i) length negated;								yourself.					string := formatter format: (arguments at: i).					formattedArgs add: string.					i == 1 ifTrue: [firstArgLength := formatter firstLineLength].					length := length + string size.					multiLine := multiLine or: [formatter isMultiLine]]].	multiLine := multiLine				or: [length + self lineLength &gt; self lineLengthLimit].	indentFirst := cascadeBoolean not and: 					[multiLine and: 							[(self startMessageSendOnNewLine: aMessageNode) or: 									[self lineLength + selectorParts first length + 2 + firstArgLength										&gt; self lineLengthLimit]]].	indentFirst ifTrue: [self indent].	self		formatMessageSelector: selectorParts		withArguments: formattedArgs		multiline: multiLine</body><body package="Browser-Parser">formatMessageSelector: selectorParts withArguments: formattedArgs multiline: multiLine	formattedArgs isEmpty		ifTrue: [codeStream nextPutAll: selectorParts first value]		ifFalse: 			[1 to: formattedArgs size				do: 					[:i |					i ~~ 1 &amp; multiLine not ifTrue: [codeStream space].					codeStream						nextPutAll: (selectorParts at: i) value;						space;						nextPutAll: (formattedArgs at: i).					(multiLine and: [i &lt; formattedArgs size]) ifTrue: [self indent]]]</body><body package="Browser-Parser">formatMethodCommentFor: aNode	| source |	source := aNode source.	source ifNil: [^self].	aNode methodComments do: 			[:each |			codeStream nextPutAll: (aNode source copyFrom: each first to: each last).			self indent.			self addEveryExtraNewline]</body><body package="Browser-Parser">formatMethodPatternFor: aMethodNode	| selectorParts arguments |	selectorParts := aMethodNode selectorParts.	arguments := aMethodNode arguments.	arguments isEmpty		ifTrue: [codeStream nextPutAll: selectorParts first value]		ifFalse: 			[selectorParts with: arguments				do: 					[:selector :arg |					codeStream						nextPutAll: selector value;						space.					self visitArgument: arg.					codeStream space]]</body><body package="Browser-Parser">formatStatementCommentFor: aNode	| source |	source := aNode source.	source ifNil: [^self].	aNode statementComments do: 			[:each |			| crs |			crs := self newLinesFor: source startingAt: each first.			(crs - 1 max: 0) timesRepeat: [codeStream cr].			crs == 0 ifTrue: [codeStream tab] ifFalse: [self indent].			codeStream nextPutAll: (source copyFrom: each first to: each last)]</body><body package="Browser-Parser">formatStatementsFor: aSequenceNode	| statements |	statements := aSequenceNode statements.	statements isEmpty ifTrue: [^self].	1 to: statements size - 1		do: 			[:i |			| eachStatement |			eachStatement := statements at: i.			self visitNode: eachStatement.			codeStream nextPut: $..			self formatStatementCommentFor: eachStatement.			self indent].	self visitNode: statements last.	aSequenceNode parent ifNotNil: [:parent |  parent isMethod		ifTrue: [self addModerateExtraPeriod]		ifFalse: [self addEveryExtraPeriod]].	self formatStatementCommentFor: statements last</body><body package="Browser-Parser">formatStructuredLiteralArray: aLiteralArrayNode	| ratchet first |	codeStream nextPut: $(.	self addEveryExtraSpace.	ratchet := false.	first := true.	aLiteralArrayNode contents do: 			[:each |			self indentWhile: 					[ratchet ifTrue: [self indent] ifFalse: [first ifFalse: [codeStream space]].					first := false.					ratchet := ratchet not.					self visitNode: each]].	self addEveryExtraSpace.	codeStream nextPut: $)</body><body package="Browser-Parser">formatTemporariesFor: aSequenceNode	| temps |	temps := aSequenceNode temporaries.	temps isEmpty ifTrue: [^self].	self addModeratePrecedingNewline.	codeStream nextPutAll: '| '.	temps do: 			[:each |			self visitArgument: each.			codeStream space].	codeStream nextPut: $|.	self indent.	self addEveryExtraNewline</body><body package="Browser-Parser">newLinesFor: aString startingAt: anIndex	| count cr lf index char |	cr := Character value: 13.	lf := Character value: 10.	count := 0.	index := anIndex - 1.	[index &gt; 0 and: 			[char := aString at: index.			char isSeparator]]		whileTrue: 			[char == lf				ifTrue: 					[count := count + 1.					(aString at: (index - 1 max: 1)) == cr ifTrue: [index := index - 1]].			char == cr ifTrue: [count := count + 1].			index := index - 1].	^count</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>private</category><body package="Browser-Parser">addEveryExtraNewline	(isInBlock not and: [verticalSpacing &gt;= self highVerticalSpacing])		ifTrue: [self indent]</body><body package="Browser-Parser">addEveryExtraPeriod	terminatorFrequency &gt;= self highTerminatorFrequency		ifTrue: [codeStream nextPut: $.]</body><body package="Browser-Parser">addEveryExtraSpace	horizontalSpacing &gt;= self highHorizontalSpacing ifTrue: [codeStream space]</body><body package="Browser-Parser">addModerateExtraNewline	(isInBlock not and: [verticalSpacing &gt;= self mediumVerticalSpacing])		ifTrue: [self indent]</body><body package="Browser-Parser">addModerateExtraPeriod	terminatorFrequency &gt;= self mediumTerminatorFrequency		ifTrue: [codeStream nextPut: $.]</body><body package="Browser-Parser">addModerateExtraSpace	horizontalSpacing &gt;= self mediumHorizontalSpacing		ifTrue: [codeStream space]</body><body package="Browser-Parser">addModeratePrecedingNewline	self hasPreceedingBlankLineAlready ifTrue: [^self].	self addModerateExtraNewline</body><body package="Browser-Parser">indent	self throwAwayTrailingWhitespace.	firstLineLength ifNil: [firstLineLength := codeStream position].	codeStream cr.	tabs timesRepeat: [codeStream tab].	lineStart := codeStream position</body><body package="Browser-Parser">indent: anInteger while: aBlock	tabs := tabs + anInteger.	aBlock value.	tabs := tabs - anInteger</body><body package="Browser-Parser">indentWhile: aBlock	self indent: 1 while: aBlock</body><body package="Browser-Parser">lineLength	^codeStream position - lineStart</body><body package="Browser-Parser">lineLengthLimit	^lineLengthLimit</body><body package="Browser-Parser">lineStart: aPosition	lineStart := aPosition</body><body package="Browser-Parser">maximumArgumentsPerLine	^2</body><body package="Browser-Parser">needsParenthesisFor: aNode	| parent grandparent |	aNode isValue ifFalse: [^false].	parent := aNode parent.	parent ifNil: [^false].	(aNode isMessage and: [parent isMessage and: [parent receiver == aNode]])		ifTrue: 			[grandparent := parent parent.			(grandparent notNil and: [grandparent isCascade]) ifTrue: [^true]].	aNode precedence &lt; parent precedence ifTrue: [^false].	aNode isAssignment &amp; parent isAssignment ifTrue: [^false].	aNode isAssignment | aNode isCascade ifTrue: [^true].	aNode precedence == 0 ifTrue: [^false].	aNode isMessage ifFalse: [^true].	aNode precedence = parent precedence ifFalse: [^true].	aNode isUnary ifTrue: [^false].	aNode isKeyword ifTrue: [^true].	parent receiver == aNode ifFalse: [^true].	^self precedenceOf: parent selector greaterThan: aNode selector</body><body package="Browser-Parser">precedenceOf: parentSelector greaterThan: childSelector	"Put parenthesis around things that are preceived to have 'lower' precedence. For example, 'a + b * c' 	-&gt; '(a + b) * c' but 'a * b + c' -&gt; 'a * b + c'"	| childIndex parentIndex operators |	operators := #(#($| $&amp; $?) #($= $~ $&lt; $&gt;) #($- $+) #($* $/ $% $\) #($@)).	childIndex := 0.	parentIndex := 0.	1 to: operators size		do: 			[:i |			((operators at: i) includes: parentSelector first)				ifTrue: [parentIndex := i].			((operators at: i) includes: childSelector first)				ifTrue: [childIndex := i]].	^childIndex &lt; parentIndex</body><body package="Browser-Parser">reset	codeStream reset.	tabs := 0.	lineStart := 0.	firstLineLength := nil</body><body package="Browser-Parser">selectorsToLeaveOnLine	^#(#to:do: #to:by: #to:by:do:)</body><body package="Browser-Parser">selectorsToStartOnNewLine	^#(#ifTrue:ifFalse: #ifFalse:ifTrue: #ifTrue: #ifFalse: #ifNil: #ifNotNil: #ifNil:ifNotNil: #ifNotNil:ifNil:)</body><body package="Browser-Parser">throwAwayTrailingWhitespace	| char |		[codeStream position &gt; 0 and: 			[char := codeStream collection at: codeStream position.			char = Character space or: [char = Character tab]]]			whileTrue: [codeStream skip: -1]</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>constants</category><body package="Browser-Parser">highHorizontalSpacing	^3</body><body package="Browser-Parser">highTerminatorFrequency	^3</body><body package="Browser-Parser">highVerticalSpacing	^3</body><body package="Browser-Parser">lowHorizontalSpacing	^1</body><body package="Browser-Parser">lowTerminatorFrequency	^1</body><body package="Browser-Parser">lowVerticalSpacing	^1</body><body package="Browser-Parser">mediumHorizontalSpacing	^2</body><body package="Browser-Parser">mediumTerminatorFrequency	^2</body><body package="Browser-Parser">mediumVerticalSpacing	^2</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>visitor-double dispatching</category><body package="Browser-Parser">acceptAssignmentNode: anAssignmentNode	self indent: 2		while: 			[self visitNode: anAssignmentNode variable.			codeStream nextPutAll: ' := '.			self visitNode: anAssignmentNode value]</body><body package="Browser-Parser">acceptBlockNode: aBlockNode	isInBlock := true.	self formatBlockNode: aBlockNode startBlockString: '[' endBlockString: ']'.	isInBlock := false</body><body package="Browser-Parser">acceptCDeclarationNode: aCDeclarationNode	self indent.	codeStream nextPut: $&lt;.	codeStream		nextPutAll: aCDeclarationNode selector;		nextPutAll: aCDeclarationNode cDeclarationText.	self addModerateExtraSpace.	codeStream nextPut: $&gt;</body><body package="Browser-Parser">acceptCascadeNode: aCascadeNode	| messages |	messages := aCascadeNode messages.	self visitNode: messages first receiver.	self indentWhile: 			[messages do: 					[:each |					self						indent;						indentWhile: [self formatMessage: each cascade: true]]				separatedBy: [codeStream nextPut: $;]]</body><body package="Browser-Parser">acceptLiteralArrayNode: aLiteralArrayNode	codeStream nextPut: $#.	aLiteralArrayNode looksLikeStructuredArrayEncoding		ifTrue: [self formatStructuredLiteralArray: aLiteralArrayNode]		ifFalse: [self formatGeneralLiteralArray: aLiteralArrayNode]</body><body package="Browser-Parser">acceptLiteralNode: aLiteralNode	aLiteralNode value isBindingReference		ifTrue: 			[codeStream nextPutAll: '#{'.			self addEveryExtraSpace.			aLiteralNode value printStringRepresentationOn: codeStream.			self addEveryExtraSpace.			codeStream nextPut: $}]		ifFalse: [aLiteralNode token storeOn: codeStream]</body><body package="Browser-Parser">acceptMessageNode: aMessageNode	| newFormatter code |	newFormatter := self copy.	code := newFormatter format: aMessageNode receiver.	codeStream nextPutAll: code.	codeStream space.	newFormatter isMultiLine		ifTrue: [lineStart := codeStream position - newFormatter lastLineLength].	self indent: (newFormatter isMultiLine ifTrue: [2] ifFalse: [1])		while: [self formatMessage: aMessageNode cascade: false]</body><body package="Browser-Parser">acceptMethodNode: aMethodNode	self formatMethodPatternFor: aMethodNode.	self indentWhile: 			[self indent.			self formatMethodCommentFor: aMethodNode.			aMethodNode tagsDo: [:each | self visitNode: each].			aMethodNode body children notEmpty				ifTrue: 					[self addModeratePrecedingNewline.					self visitNode: aMethodNode body]]</body><body package="Browser-Parser">acceptPatternBlockNode: aRBPatternBlockNode	self		formatBlockNode: aRBPatternBlockNode		startBlockString: '`{'		endBlockString: '}'</body><body package="Browser-Parser">acceptPatternWrapperBlockNode: aRBPatternWrapperBlockNode	self visitNode: aRBPatternWrapperBlockNode wrappedNode.	self		formatBlockNode: aRBPatternWrapperBlockNode		startBlockString: '`{'		endBlockString: '}'</body><body package="Browser-Parser">acceptReturnNode: aReturnNode	codeStream nextPut: $^.	self addModerateExtraSpace.	self visitNode: aReturnNode value</body><body package="Browser-Parser">acceptSequenceNode: aSequenceNode	self formatMethodCommentFor: aSequenceNode.	self formatTemporariesFor: aSequenceNode.	self formatStatementsFor: aSequenceNode</body><body package="Browser-Parser">acceptTagNode: aTagNode	codeStream nextPut: $&lt;.	self addModerateExtraSpace.	self formatMessage: aTagNode cascade: false.	self addModerateExtraSpace.	codeStream nextPut: $&gt;.	self indent.	self addEveryExtraNewline</body><body package="Browser-Parser">acceptVariableNode: aVariableNode	codeStream nextPutAll: aVariableNode name</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>testing</category><body package="Browser-Parser">hasPreceedingBlankLineAlready	| index string |	index := codeStream position.	string := codeStream collection.	[index &gt; 0 and: [(string at: index) = Character tab]]		whileTrue: [index := index - 1].	index &lt;= 1 ifTrue: [^false].	^(string at: index) = Character cr		and: [(string at: index - 1) = Character cr]</body><body package="Browser-Parser">isMultiLine	^firstLineLength notNil</body><body package="Browser-Parser">startMessageSendOnNewLine: aMessageNode	(self selectorsToStartOnNewLine includes: aMessageNode selector)		ifTrue: [^true].	(self selectorsToLeaveOnLine includes: aMessageNode selector)		ifTrue: [^false].	^aMessageNode selector numArgs &gt; self maximumArgumentsPerLine</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>copying</category><body package="Browser-Parser">postCopy	super postCopy.	lineStart := self lineLength negated.	codeStream := WriteStream on: (String new: 60).	firstLineLength := nil</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>initialize-release</category><body package="Browser-Parser">initialize	super initialize.	codeStream := WriteStream on: (String new: 60).	horizontalSpacing := CurrentHorizontalSpacing				ifNil: [self lowHorizontalSpacing].	verticalSpacing := CurrentVerticalSpacing				ifNil: [self mediumVerticalSpacing].	terminatorFrequency := CurrentTerminatorFrequency				ifNil: [self lowTerminatorFrequency].	isInBlock := false.	lineLengthLimit := 75.	tabs := 0.	lineStart := 0.	firstLineLength := nil</body></methods><methods><class-id>Refactory.Browser.RBFormatter</class-id> <category>visiting</category><body package="Browser-Parser">visitNode: aNode	| parenthesis |	parenthesis := self needsParenthesisFor: aNode.	parenthesis		ifTrue: 			[codeStream nextPut: $(.			self addModerateExtraSpace].	aNode acceptVisitor: self.	parenthesis		ifTrue: 			[self addModerateExtraSpace.			codeStream nextPut: $)]</body></methods><methods><class-id>Refactory.Browser.RBFormatter class</class-id> <category>settings</category><body package="Browser-Parser">currentHorizontalSpacingLevel	^CurrentHorizontalSpacing</body><body package="Browser-Parser">currentHorizontalSpacingLevel: anInteger	"HighHorizontalSpacingLevel, MediumHorizontalSpacingLevel, or LowHorizontalSpacingLevel"	CurrentHorizontalSpacing := anInteger</body><body package="Browser-Parser">currentTerminatorLevel	^CurrentTerminatorFrequency</body><body package="Browser-Parser">currentTerminatorLevel: anInteger	"HighTerminatorLevel, MediumTerminatorLevel, or LowTerminatorLevel"	CurrentTerminatorFrequency := anInteger</body><body package="Browser-Parser">currentVerticalSpacingLevel	^CurrentVerticalSpacing</body><body package="Browser-Parser">currentVerticalSpacingLevel: anInteger	"HighVerticalSpacingLevel, MediumVerticalSpacingLevel, or LowVerticalSpacingLevel"	CurrentVerticalSpacing := anInteger</body></methods><methods><class-id>Refactory.Browser.RBFormatter class</class-id> <category>class initialization</category><body package="Browser-Parser">initialize	"self initialize"	CurrentTerminatorFrequency := 1.	CurrentHorizontalSpacing := 1.	CurrentVerticalSpacing := 2</body></methods><methods><class-id>Refactory.Browser.RBBinarySelectorToken</class-id> <category>testing</category><body package="Browser-Parser">isBinary	^true</body></methods><methods><class-id>Refactory.Browser.ParseTreeRewriter</class-id> <category>visitor-double dispatching</category><body package="Browser-Parser">acceptAssignmentNode: anAssignmentNode 	anAssignmentNode variable: (self visitNode: anAssignmentNode variable).	anAssignmentNode value: (self visitNode: anAssignmentNode value)</body><body package="Browser-Parser">acceptBlockNode: aBlockNode 	aBlockNode arguments: (self visitArguments: aBlockNode arguments).	aBlockNode body: (self visitNode: aBlockNode body)</body><body package="Browser-Parser">acceptCascadeNode: aCascadeNode 	| newMessages notFound |	newMessages := OrderedCollection new: aCascadeNode messages size.	notFound := OrderedCollection new: aCascadeNode messages size.	aCascadeNode messages do: 			[:each | 			| newNode |			newNode := self performSearches: searches on: each.			newNode isNil 				ifTrue: 					[newNode := each.					notFound add: newNode].			newNode isMessage 				ifTrue: [newMessages add: newNode]				ifFalse: 					[newNode isCascade 						ifTrue: [newMessages addAll: newNode messages]						ifFalse: 							[Transcript								cr; 								show: (#CannotReplaceMsgInCascade &lt;&lt; #browser &gt;&gt; 'Cannot replace message node inside of cascaded node with non-message node.').							newMessages add: each]]].	notFound size == aCascadeNode messages size 		ifTrue: 			[| receiver |			receiver := self visitNode: aCascadeNode messages first receiver.			newMessages do: [:each | each receiver: receiver]].	notFound 		do: [:each | each arguments: (each arguments collect: [:arg | self visitNode: arg])].	aCascadeNode messages: newMessages</body><body package="Browser-Parser">acceptLiteralArrayNode: aRBArrayLiteralNode 	aRBArrayLiteralNode contents: (aRBArrayLiteralNode contents 				collect: [:each | self visitNode: each])</body><body package="Browser-Parser">acceptMessageNode: aMessageNode 	aMessageNode receiver: (self visitNode: aMessageNode receiver).	aMessageNode 		arguments: (aMessageNode arguments collect: [:each | self visitNode: each])</body><body package="Browser-Parser">acceptMethodNode: aMethodNode 	aMethodNode tags: (self visitArguments: aMethodNode tags).	aMethodNode arguments: (self visitArguments: aMethodNode arguments).	aMethodNode body: (self visitNode: aMethodNode body)</body><body package="Browser-Parser">acceptReturnNode: aReturnNode 	aReturnNode value: (self visitNode: aReturnNode value)</body><body package="Browser-Parser">acceptSequenceNode: aSequenceNode 	aSequenceNode 		temporaries: (self visitArguments: aSequenceNode temporaries).	aSequenceNode statements: (aSequenceNode statements 				collect: [:each | self visitNode: each])</body><body package="Browser-Parser">acceptTagNode: aTagNode	aTagNode		arguments: (aTagNode arguments collect: [:each | self visitNode: each])</body></methods><methods><class-id>Refactory.Browser.ParseTreeRewriter</class-id> <category>accessing</category><body package="Browser-Parser">executeTree: aParseTree 	| oldContext |	oldContext := context.	context := CompactDictionary new.	answer := false.	tree := self visitNode: aParseTree.	context := oldContext.	^answer</body><body package="Browser-Parser">tree	^tree</body></methods><methods><class-id>Refactory.Browser.ParseTreeRewriter</class-id> <category>private</category><body package="Browser-Parser">foundMatch	answer := true</body><body package="Browser-Parser">lookForMoreMatchesInContext: oldContext 	oldContext keysAndValuesDo: 			[:key :value | 			(key isString not and: [key recurseInto]) 				ifTrue: 					[oldContext at: key put: (value collect: [:each | self visitNode: each])]]</body></methods><methods><class-id>Refactory.Browser.ParseTreeRewriter</class-id> <category>replacing</category><body package="Browser-Parser">replace: searchString with: replaceString 	self addRule: (RBStringReplaceRule searchFor: searchString				replaceWith: replaceString)</body><body package="Browser-Parser">replace: searchString with: replaceString when: aBlock 	self addRule: (RBStringReplaceRule 				searchFor: searchString				replaceWith: replaceString				when: aBlock)</body><body package="Browser-Parser">replace: searchString withValueFrom: replaceBlock 	self addRule: (RBBlockReplaceRule searchFor: searchString				replaceWith: replaceBlock)</body><body package="Browser-Parser">replace: searchString withValueFrom: replaceBlock when: conditionBlock 	self addRule: (RBBlockReplaceRule 				searchFor: searchString				replaceWith: replaceBlock				when: conditionBlock)</body><body package="Browser-Parser">replaceArgument: searchString with: replaceString 	self addArgumentRule: (RBStringReplaceRule searchFor: searchString				replaceWith: replaceString)</body><body package="Browser-Parser">replaceArgument: searchString with: replaceString when: aBlock 	self addArgumentRule: (RBStringReplaceRule 				searchFor: searchString				replaceWith: replaceString				when: aBlock)</body><body package="Browser-Parser">replaceArgument: searchString withValueFrom: replaceBlock 	self addArgumentRule: (RBBlockReplaceRule searchFor: searchString				replaceWith: replaceBlock)</body><body package="Browser-Parser">replaceArgument: searchString withValueFrom: replaceBlock when: conditionBlock 	self addArgumentRule: (RBBlockReplaceRule 				searchFor: searchString				replaceWith: replaceBlock				when: conditionBlock)</body><body package="Browser-Parser">replaceMethod: searchString with: replaceString 	self addRule: (RBStringReplaceRule searchForMethod: searchString				replaceWith: replaceString)</body><body package="Browser-Parser">replaceMethod: searchString with: replaceString when: aBlock 	self addRule: (RBStringReplaceRule 				searchForMethod: searchString				replaceWith: replaceString				when: aBlock)</body><body package="Browser-Parser">replaceMethod: searchString withValueFrom: replaceBlock 	self addRule: (RBBlockReplaceRule searchForMethod: searchString				replaceWith: replaceBlock)</body><body package="Browser-Parser">replaceMethod: searchString withValueFrom: replaceBlock when: conditionBlock 	self addRule: (RBBlockReplaceRule 				searchForMethod: searchString				replaceWith: replaceBlock				when: conditionBlock)</body><body package="Browser-Parser">replaceTree: searchTree withTree: replaceTree 	self addRule: (RBStringReplaceRule searchForTree: searchTree				replaceWith: replaceTree)</body><body package="Browser-Parser">replaceTree: searchTree withTree: replaceTree when: aBlock 	self addRule: (RBStringReplaceRule 				searchForTree: searchTree				replaceWith: replaceTree				when: aBlock)</body></methods><methods><class-id>Refactory.Browser.ParseTreeRewriter</class-id> <category>visiting</category><body package="Browser-Parser">visitArguments: aNodeCollection 	^aNodeCollection collect: [:each | self visitArgument: each]</body></methods><methods><class-id>Refactory.Browser.ParseTreeRewriter class</class-id> <category>instance creation</category><body package="Browser-Parser">removeTemporaryNamed: aName 	| rewriteRule |	rewriteRule := self new.	rewriteRule replace: '| `@temps1 ' , aName , ' `@temps2 | ``@.Statements'		with: '| `@temps1  `@temps2 | ``@.Statements'.	^rewriteRule</body><body package="Browser-Parser">rename: varName to: newVarName 	| rewriteRule |	rewriteRule := self new.	rewriteRule		replace: varName with: newVarName;		replaceArgument: varName with: newVarName.	^rewriteRule</body><body package="Browser-Parser">rename: varName to: newVarName handler: aBlock 	"Rename varName to newVarName, evaluating aBlock if there is a 	temporary variable with the same name as newVarName. This 	does not change temporary variables with varName."	| rewriteRule |	rewriteRule := self new.	rewriteRule		replace: varName with: newVarName;		replaceArgument: newVarName			withValueFrom: 				[:aNode | 				aBlock value.				aNode].	^rewriteRule</body><body package="Browser-Parser">replace: code with: newCode method: aBoolean 	| rewriteRule |	rewriteRule := self new.	aBoolean 		ifTrue: [rewriteRule replaceMethod: code with: newCode]		ifFalse: [rewriteRule replace: code with: newCode].	^rewriteRule</body><body package="Browser-Parser">replaceLiteral: literal with: newLiteral 	| rewriteRule |	rewriteRule := self new.	rewriteRule replaceTree: (RBLiteralNode value: literal)		withTree: (RBLiteralNode value: newLiteral).	^rewriteRule</body><body package="Browser-Parser">variable: aVarName getter: getMethod setter: setMethod 	| rewriteRule |	rewriteRule := self new.	rewriteRule		replace: aVarName , ' := ``@object'			with: 'self ' , setMethod , ' ``@object';		replace: aVarName with: 'self ' , getMethod.	^rewriteRule</body></methods><methods><class-id>Refactory.Browser.ParseTreeRewriter class</class-id> <category>accessing</category><body package="Browser-Parser">replace: code with: newCode in: aParseTree 	^(self 		replace: code		with: newCode		method: false)		executeTree: aParseTree;		tree</body><body package="Browser-Parser">replace: code with: newCode in: aParseTree onInterval: anInterval 	| rewriteRule |	rewriteRule := self new.	^rewriteRule		replace: code			with: newCode			when: [:aNode | aNode intersectsInterval: anInterval];		executeTree: aParseTree;		tree</body><body package="Browser-Parser">replaceStatements: code with: newCode in: aParseTree onInterval: anInterval 	| tree replaceStmt |	tree := self buildTree: code method: false.	tree isSequence 		ifFalse: [tree := RBSequenceNode statements: (Array with: tree)].	tree temporaries: (Array with: (RBPatternVariableNode named: '`@temps')).	tree addNodeFirst: (RBPatternVariableNode named: '`@.S1').	tree lastIsReturn 		ifTrue: [replaceStmt := '| `@temps | `@.S1. ^' , newCode]		ifFalse: 			[tree addNode: (RBPatternVariableNode named: '`@.S2').			replaceStmt := '| `@temps | `@.S1. ' , newCode , '. `@.S2'].	^self 		replace: tree formattedCode		with: replaceStmt		in: aParseTree		onInterval: anInterval</body></methods><methods><class-id>Refactory.Browser.RBBlockReplaceRule</class-id> <category>initialize-release</category><body package="Browser-Parser">initialize	super initialize.	replaceBlock := [:aNode | aNode]</body><body package="Browser-Parser">searchFor: searchString replaceWith: aBlock 	self searchString: searchString.	replaceBlock := aBlock</body><body package="Browser-Parser">searchFor: searchString replaceWith: replBlock when: verifyBlock 	self searchFor: searchString replaceWith: replBlock.	verificationBlock := verifyBlock</body><body package="Browser-Parser">searchForMethod: searchString replaceWith: aBlock 	self methodSearchString: searchString.	replaceBlock := aBlock</body><body package="Browser-Parser">searchForMethod: searchString replaceWith: replBlock when: verifyBlock 	self searchForMethod: searchString replaceWith: replBlock.	verificationBlock := verifyBlock</body><body package="Browser-Parser">searchForTree: aBRProgramNode replaceWith: aBlock 	searchTree := aBRProgramNode.	replaceBlock := aBlock</body><body package="Browser-Parser">searchForTree: aBRProgramNode replaceWith: replBlock when: verifyBlock 	self searchForTree: aBRProgramNode replaceWith: replBlock.	verificationBlock := verifyBlock</body></methods><methods><class-id>Refactory.Browser.RBBlockReplaceRule</class-id> <category>matching</category><body package="Browser-Parser">foundMatchFor: aProgramNode 	| newNode |	newNode := replaceBlock value: aProgramNode.	aProgramNode replaceMethodSource: newNode.	^newNode</body></methods><methods><class-id>Refactory.Browser.RBBlockReplaceRule class</class-id> <category>instance creation</category><body package="Browser-Parser">searchFor: searchString replaceWith: replaceBlock 	^self new searchFor: searchString replaceWith: replaceBlock</body><body package="Browser-Parser">searchFor: searchString replaceWith: replaceBlock when: aBlock 	^self new 		searchFor: searchString		replaceWith: replaceBlock		when: aBlock</body><body package="Browser-Parser">searchForMethod: searchString replaceWith: replaceBlock 	^self new searchForMethod: searchString replaceWith: replaceBlock</body><body package="Browser-Parser">searchForMethod: searchString replaceWith: replaceBlock when: aBlock 	^self new 		searchForMethod: searchString		replaceWith: replaceBlock		when: aBlock</body><body package="Browser-Parser">searchForTree: aRBProgramNode replaceWith: replaceBlock 	^self new searchForTree: aRBProgramNode replaceWith: replaceBlock</body><body package="Browser-Parser">searchForTree: aRBProgramNode replaceWith: replaceBlock when: aBlock 	^self new 		searchForTree: aRBProgramNode		replaceWith: replaceBlock		when: aBlock</body></methods><methods><class-id>Refactory.Browser.RBPatternMessageNode</class-id> <category>matching</category><body package="Browser-Parser">copyInContext: aDictionary 	| selectors |	self isList ifTrue: [^aDictionary at: self].	selectors := self isSelectorList 				ifTrue: [(aDictionary at: selectorParts first value) keywords]				ifFalse: [selectorParts collect: [:each | aDictionary at: each value]].	^(RBMessageNode new)		receiver: (receiver copyInContext: aDictionary);		selectorParts: (selectors collect: 						[:each | 						(each last == $: ifTrue: [RBKeywordToken] ifFalse: [RBIdentifierToken]) 							value: each							start: nil]);		arguments: (self copyList: arguments inContext: aDictionary);		yourself</body><body package="Browser-Parser">match: aNode inContext: aDictionary 	aNode class == self matchingClass ifFalse: [^false].	(receiver match: aNode receiver inContext: aDictionary) ifFalse: [^false].	self isSelectorList 		ifTrue: 			[^(aDictionary at: selectorParts first value ifAbsentPut: [aNode selector]) 				== aNode selector and: 						[(aDictionary at: arguments first ifAbsentPut: [aNode arguments]) 							= aNode arguments]].	^self matchArgumentsAgainst: aNode inContext: aDictionary</body><body package="Browser-Parser">matchArgumentsAgainst: aNode inContext: aDictionary 	self arguments size == aNode arguments size ifFalse: [^false].	(self matchSelectorAgainst: aNode inContext: aDictionary) 		ifFalse: [^false].	1 to: arguments size		do: 			[:i | 			((arguments at: i) match: (aNode arguments at: i) inContext: aDictionary) 				ifFalse: [^false]].	^true</body><body package="Browser-Parser">matchSelectorAgainst: aNode inContext: aDictionary 	| keyword |	1 to: selectorParts size		do: 			[:i | 			keyword := selectorParts at: i.			(aDictionary at: keyword value				ifAbsentPut: 					[keyword isPatternVariable 						ifTrue: [(aNode selectorParts at: i) value]						ifFalse: [keyword value]]) 					= (aNode selectorParts at: i) value ifFalse: [^false]].	^true</body></methods><methods><class-id>Refactory.Browser.RBPatternMessageNode</class-id> <category>testing-matching</category><body package="Browser-Parser">isList	^isCascadeList and: [parent notNil and: [parent isCascade]]</body><body package="Browser-Parser">isPatternNode	^true</body><body package="Browser-Parser">isSelectorList	^isList</body></methods><methods><class-id>Refactory.Browser.RBPatternMessageNode</class-id> <category>private</category><body package="Browser-Parser">matchingClass	^RBMessageNode</body></methods><methods><class-id>Refactory.Browser.RBPatternMessageNode</class-id> <category>initialize-release</category><body package="Browser-Parser">receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 	| message |	super 		receiver: aValueNode		selectorParts: keywordTokens		arguments: valueNodes.	isCascadeList := isList := false.	message := keywordTokens first value.	2 to: message size		do: 			[:i | 			| character |			character := message at: i.			character == self listCharacter 				ifTrue: [isList := true]				ifFalse: 					[character == self cascadeListCharacter 						ifTrue: [isCascadeList := true]						ifFalse: [^self]]]</body></methods><methods><class-id>Refactory.Browser.RBPatternMessageNode</class-id> <category>accessing</category><body package="Browser-Parser">sentMessages	^(super sentMessages)		remove: self selector ifAbsent: [];		yourself</body></methods><methods><class-id>Refactory.Browser.RBPatternMessageNode class</class-id> <category>instance creation</category><body package="Browser-Parser">receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 	^(keywordTokens anySatisfy: [:each | each isPatternVariable]) 		ifTrue: 			[super 				receiver: aValueNode				selectorParts: keywordTokens				arguments: valueNodes]		ifFalse: 			[RBMessageNode 				receiver: aValueNode				selectorParts: keywordTokens				arguments: valueNodes]</body></methods><methods><class-id>Refactory.Browser.RBReadBeforeWrittenTester</class-id> <category>visitor-double dispatching</category><body package="Browser-Parser">acceptAssignmentNode: anAssignmentNode 	self visitNode: anAssignmentNode value.	self variableWritten: anAssignmentNode</body><body package="Browser-Parser">acceptBlockNode: aBlockNode 	self processBlock: aBlockNode</body><body package="Browser-Parser">acceptMessageNode: aMessageNode 	((#(#whileTrue: #whileFalse: #whileTrue #whileFalse) 		includes: aMessageNode selector) and: [aMessageNode receiver isBlock]) 		ifTrue: [self executeTree: aMessageNode receiver body]		ifFalse: 			[(aMessageNode isCascaded not or: [aMessageNode isFirstCascaded]) 				ifTrue: [self visitNode: aMessageNode receiver]].	((#(#ifTrue:ifFalse: #ifFalse:ifTrue: #ifNil:ifNotNil: #ifNotNil:ifNil:) includes: aMessageNode selector) 		and: [aMessageNode arguments allSatisfy: [:each | each isBlock]]) 			ifTrue: [^self processIfTrueIfFalse: aMessageNode].	aMessageNode arguments do: [:each | self visitNode: each]</body><body package="Browser-Parser">acceptReturnNode: aReturnNode 	super acceptReturnNode: aReturnNode.	self currentScope keysAndValuesDo: 			[:key :value | 			value isNil 				ifTrue: [self currentScope at: key put: false]]</body><body package="Browser-Parser">acceptSequenceNode: aSequenceNode 	self processStatementNode: aSequenceNode</body><body package="Browser-Parser">acceptVariableNode: aVariableNode 	self variableRead: aVariableNode</body></methods><methods><class-id>Refactory.Browser.RBReadBeforeWrittenTester</class-id> <category>initialize-release</category><body package="Browser-Parser">checkNewTemps: aBoolean 	checkNewTemps := aBoolean</body><body package="Browser-Parser">initialize	super initialize.	scopeStack := OrderedCollection with: Dictionary new.	read := Set new.	checkNewTemps := true</body><body package="Browser-Parser">initializeVars: varNames 	varNames do: [:each | self currentScope at: each put: nil]</body></methods><methods><class-id>Refactory.Browser.RBReadBeforeWrittenTester</class-id> <category>private</category><body package="Browser-Parser">copyDictionary: aDictionary 	"We could send aDictionary the copy message, but that doesn't copy the associations."	| newDictionary |	newDictionary := Dictionary new: aDictionary size.	aDictionary 		keysAndValuesDo: [:key :value | newDictionary at: key put: value].	^newDictionary</body><body package="Browser-Parser">createScope	scopeStack add: (self copyDictionary: scopeStack last)</body><body package="Browser-Parser">currentScope	^scopeStack last</body><body package="Browser-Parser">processBlock: aNode 	| newScope |	self createScope.	self executeTree: aNode body.	newScope := self removeScope.	newScope keysAndValuesDo: 			[:key :value | 			(value == true and: [(self currentScope at: key) isNil]) 				ifTrue: [self currentScope at: key put: value]]</body><body package="Browser-Parser">processIfTrueIfFalse: aNode 	| trueScope falseScope |	self createScope.	self executeTree: aNode arguments first body.	trueScope := self removeScope.	self createScope.	self executeTree: aNode arguments last body.	falseScope := self removeScope.	self currentScope keysAndValuesDo: 			[:key :value | 			value isNil 				ifTrue: 					[(trueScope at: key) == (falseScope at: key) 						ifTrue: [self currentScope at: key put: (trueScope at: key)]						ifFalse: 							[((trueScope at: key) == true or: [(falseScope at: key) == true]) 								ifTrue: [self currentScope at: key put: true]]]]</body><body package="Browser-Parser">processStatementNode: aNode 	| temps |	(checkNewTemps not or: [aNode temporaries isEmpty]) 		ifTrue: 			[aNode statements do: [:each | self executeTree: each].			^self].	self createScope.	temps := aNode temporaries collect: [:each | each name].	self initializeVars: temps.	aNode statements do: [:each | self executeTree: each].	self removeScope keysAndValuesDo: 			[:key :value | 			(temps includes: key) 				ifTrue: [value == true ifTrue: [read add: key]]				ifFalse: 					[(self currentScope at: key) isNil 						ifTrue: [self currentScope at: key put: value]]]</body><body package="Browser-Parser">removeScope	^scopeStack removeLast</body><body package="Browser-Parser">variableRead: aNode 	(self currentScope includesKey: aNode name) 		ifTrue: 			[(self currentScope at: aNode name) isNil 				ifTrue: [self currentScope at: aNode name put: true]]</body><body package="Browser-Parser">variableWritten: aNode 	(self currentScope includesKey: aNode variable name) 		ifTrue: 			[(self currentScope at: aNode variable name) isNil 				ifTrue: [self currentScope at: aNode variable name put: false]]</body></methods><methods><class-id>Refactory.Browser.RBReadBeforeWrittenTester</class-id> <category>accessing</category><body package="Browser-Parser">executeTree: aParseTree 	^self visitNode: aParseTree</body><body package="Browser-Parser">read	self currentScope		keysAndValuesDo: [:key :value | value == true ifTrue: [read add: key]].	^read</body></methods><methods><class-id>Refactory.Browser.RBReadBeforeWrittenTester class</class-id> <category>accessing</category><body package="Browser-Parser">isVariable: aString readBeforeWrittenIn: aBRProgramNode 	^(self isVariable: aString writtenBeforeReadIn: aBRProgramNode) not</body><body package="Browser-Parser">isVariable: aString writtenBeforeReadIn: aBRProgramNode 	^(self readBeforeWritten: (Array with: aString) in: aBRProgramNode) 		isEmpty</body><body package="Browser-Parser">readBeforeWritten: varNames in: aParseTree 	^(self new)		checkNewTemps: false;		initializeVars: varNames;		executeTree: aParseTree;		read</body><body package="Browser-Parser">variablesReadBeforeWrittenIn: aParseTree 	^(self new)		executeTree: aParseTree;		read</body></methods><methods><class-id>Refactory.Browser.RBSearchRule</class-id> <category>testing</category><body package="Browser-Parser">canMatch: aProgramNode 	owner answer: (answerBlock value: aProgramNode value: owner answer).	^true</body></methods><methods><class-id>Refactory.Browser.RBSearchRule</class-id> <category>initialize-release</category><body package="Browser-Parser">searchFor: aString thenDo: aBlock 	self searchString: aString.	answerBlock := aBlock</body><body package="Browser-Parser">searchForMethod: aString thenDo: aBlock 	self methodSearchString: aString.	answerBlock := aBlock</body><body package="Browser-Parser">searchForTree: aBRProgramNode thenDo: aBlock 	searchTree := aBRProgramNode.	answerBlock := aBlock</body></methods><methods><class-id>Refactory.Browser.RBSearchRule class</class-id> <category>instance creation</category><body package="Browser-Parser">searchFor: aString thenDo: aBlock 	^self new searchFor: aString thenDo: aBlock</body><body package="Browser-Parser">searchForMethod: aString thenDo: aBlock 	^self new searchForMethod: aString thenDo: aBlock</body><body package="Browser-Parser">searchForTree: aBRProgramNode thenDo: aBlock 	^self new searchForTree: aBRProgramNode thenDo: aBlock</body></methods><methods><class-id>Refactory.Browser.RBPrimitiveTagNode</class-id> <category>visitor</category><body package="Browser-Parser">acceptVisitor: aProgramNodeVisitor	aProgramNodeVisitor acceptPrimitiveTagNode: self</body></methods><methods><class-id>Refactory.Browser.RBPrimitiveTagNode</class-id> <category>accessing</category><body package="Browser-Parser">errorCodeVariable	^selectorParts last value = 'errorCode:'		ifTrue: [arguments last]		ifFalse: [nil]</body><body package="Browser-Parser">moduleName	^(selectorParts size &gt; 1 and: [(selectorParts at: 2) value = 'module:'])		ifTrue: [(arguments at: 2) value]		ifFalse: [nil]</body><body package="Browser-Parser">primitiveName	| value |	value := arguments first value.	^value isCharacters ifTrue: [value] ifFalse: [nil]</body><body package="Browser-Parser">primitiveNumber	| value |	value := arguments first value.	^value isInteger ifTrue: [value] ifFalse: [nil]</body></methods><methods><class-id>Refactory.Browser.RBPrimitiveTagNode</class-id> <category>testing</category><body package="Browser-Parser">defines: aName	^self errorCodeVariable		ifNil: [false]		ifNotNil: [:node | node name = aName]</body><body package="Browser-Parser">isPrimitiveTag	^true</body></methods><methods><class-id>Core.Behavior</class-id> <category>RefactoringBrowser</category><body package="Browser-Parser">parseTreeFor: aSymbol 	^Refactory.Browser.RBParser parseMethod: (self sourceCodeAt: aSymbol)		onError: [:aString :pos | ^nil]</body></methods><initialize><class-id>Refactory.Browser.RBScanner</class-id></initialize><initialize><class-id>Refactory.Browser.RBFormatter</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class></st-source>