<?xml version="1.0"?><st-source><!-- Name: ExternalWebBrowser-TextNotice: Copyright 2008-2013 Cincom Systems, Inc.  All rights reserved.Comment: When used with the ExternalWebBrowser package this package will give you hyperlink click support on text that has been emphasized with #href.  One way to add that emphasis is to send the message #addHyperlinkEmphases to a Text instance which will automatically add the emphasis for you.Here is an example that will open a window on some text with clickable hyperlinks.	ComposedTextView		edit: 'CincomSmalltalk http://www.cincomsmalltalk.com\Space Weather http://www.spaceweather.com' withCRs asText addHyperlinkEmphases asValue		label: 'Cincom Smalltalk'		icon: (Icon constantNamed: #workspace)		extent: 400@300Previously visited links are held in the Visited class shared variable on Text.DbIdentifier: bear73DbTrace: 400110DbUsername: nrossDbVersion: 7.10 - 1DevelopmentPrerequisites: #(#(#any 'ExternalWebBrowser' ''))PackageName: ExternalWebBrowser-TextParcel: #('ExternalWebBrowser-Text')ParcelName: ExternalWebBrowser-TextPrerequisiteParcels: #(#('ExternalWebBrowser' ''))PrintStringCache: (7.10 - 1,nross)Version: 7.10 - 1Date: 5:37:41 AM April 3, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (mar13.4) of March 22, 2013 on April 3, 2013 at 5:37:41 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><shared-variable><name>VisitedHyperlinks</name><environment>Core.CharacterArray</environment><private>false</private><constant>false</constant><category>visited links</category><initializer>Set new</initializer><attributes><package>ExternalWebBrowser-Text</package></attributes></shared-variable><methods><class-id>UI.Cursor class</class-id> <category>constants</category><body package="ExternalWebBrowser-Text">pendingHyperlink	^self fingerPointer</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>event driven</category><body package="ExternalWebBrowser-Text">exitEvent: anEvent	"Make sure we restore the cursor and remove temporary underlining if need be."	self text exciseAnyPendingLinkEmphases ifTrue: [self view simpleRedisplay].	Cursor currentCursor = Cursor pendingHyperlink		ifTrue: [Cursor normal show].	^super exitEvent: anEvent</body><body package="ExternalWebBrowser-Text">hrefAtEvent: anEvent	"Find whether the emphases at anEvent includes an #href association, and if so return it."	| point characterBlock index emphasis |	point := self sensor cursorPointFor: anEvent.	characterBlock := view characterBlockAtPoint: point.	index := characterBlock stringIndex.	(index between: 1 and: self text size) ifFalse: [^nil].	(self isLineBreakCharacterBlock: characterBlock) ifTrue: [^nil].	emphasis := self text emphasisAt: index.	((emphasis isKindOf: Association) and: [emphasis key = #href])		ifTrue: [^emphasis].	(emphasis isKindOf: Array) ifFalse: [^nil].	^emphasis		detect: [:each | (each isKindOf: Association) and: [each key = #href]]		ifNone: [nil]</body><body package="ExternalWebBrowser-Text">isLineBreakCharacterBlock: aCharacterBlock	"When line wrapping occurs, it inserts character blocks for characters	that aren't really there, but the index points to the next element, we have	to make sure we're not over one of those."	| index |	index := aCharacterBlock stringIndex.	^(self text at: index) ~= aCharacterBlock character</body></methods><methods><class-id>UI.TextEditorController</class-id> <category>events</category><body package="ExternalWebBrowser-Text">mouseMovedEvent: anEvent	"Each time we move the mouse, update the cursor if we're over an href link. Also note whether styling changes took place in the text and redisplay if necessary."	| updateNeeded |	updateNeeded := (self hrefAtEvent: anEvent)				ifNotNil: 					[:hrefEmphasis |					Cursor currentCursor = Cursor normal						ifTrue: 							[Cursor pendingHyperlink show.							self text assurePendingLinkEmphasesAlong: hrefEmphasis]						ifFalse: [false]]				ifNil: 					[Cursor currentCursor = Cursor pendingHyperlink						ifTrue: [Cursor normal show].					self text exciseAnyPendingLinkEmphases].	updateNeeded ifTrue: [self view simpleRedisplay]</body><body package="ExternalWebBrowser-Text">redButtonReleasedEvent: anEvent	self hasRangeSelection ifTrue: [^self].	#{ExternalWebBrowser} ifDefinedDo: 			[:webBrowserInterface |			(self hrefAtEvent: anEvent)				ifNotNil: 					[:hrefEmphasis |					| link |					link := hrefEmphasis value.					link rememberHyperlinkVisit.					self view simpleRedisplay.					webBrowserInterface open: link]].	super redButtonReleasedEvent: anEvent</body></methods><methods><class-id>Graphics.CharacterAttributes class</class-id> <category>accessing</category><body package="ExternalWebBrowser-Text">hrefColor: aString	^aString isVisitedHyperlink		ifTrue: [ColorValue purple]		ifFalse: [ColorValue blue]</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>event driven</category><body package="ExternalWebBrowser-Text">exitEvent: anEvent	"Make sure we restore the cursor and remove temporary underlining if need be."	self text exciseAnyPendingLinkEmphases ifTrue: [self view simpleRedisplay].	Cursor currentCursor = Cursor pendingHyperlink ifTrue:[Cursor normal show].	^super exitEvent: anEvent</body><body package="ExternalWebBrowser-Text">hrefAtEvent: anEvent	"Find whether the emphases at anEvent includes an #href association, and if so return it."		| point characterBlock index emphasis |	point := self sensor cursorPointFor: anEvent.	characterBlock := view characterBlockAtPoint: point.	index := characterBlock stringIndex.	(index		between: 1		and: self text size) ifFalse: [^nil].	(self isLineBreakCharacterBlock: characterBlock) ifTrue: [^nil].	emphasis := self text emphasisAt: index.	((emphasis isKindOf: Association) and: [emphasis key = #href])		ifTrue: [^emphasis].	(emphasis isKindOf: Array) ifFalse: [^nil].	^emphasis		detect: [:each | (each isKindOf: Association) and: [each key = #href]]		ifNone: [nil]</body><body package="ExternalWebBrowser-Text">isLineBreakCharacterBlock: aCharacterBlock	"When line wrapping occurs, it inserts character blocks for characters	that aren't really there, but the index points to the next element, we have	to make sure we're not over one of those."	| index |	index := aCharacterBlock stringIndex.	^(self text at: index) ~= aCharacterBlock character</body></methods><methods><class-id>UI.ParagraphEditor</class-id> <category>events</category><body package="ExternalWebBrowser-Text">mouseMovedEvent: anEvent	"Each time we move the mouse, update the cursor if we're over an href link. Also note whether styling changes took place in the text and redisplay if necessary."	| updateNeeded |	updateNeeded := (self hrefAtEvent: anEvent)				ifNotNil: 					[:hrefEmphasis |					Cursor currentCursor = Cursor normal						ifTrue: 							[Cursor pendingHyperlink show.							self text assurePendingLinkEmphasesAlong: hrefEmphasis]						ifFalse: [false]]				ifNil: 					[Cursor currentCursor = Cursor pendingHyperlink ifTrue: [Cursor normal show].					self text exciseAnyPendingLinkEmphases].	updateNeeded ifTrue: [self view simpleRedisplay]</body><body package="ExternalWebBrowser-Text">redButtonReleasedEvent: anEvent	self hasRangeSelection ifTrue: [^self].	#{ExternalWebBrowser}		ifDefinedDo:			[:webBrowserInterface | 			(self hrefAtEvent: anEvent)				ifNotNil:					[:hrefEmphasis | 					| link |					link := hrefEmphasis value.					link rememberHyperlinkVisit.					self view simpleRedisplay.					webBrowserInterface open: link]].	super redButtonReleasedEvent: anEvent</body></methods><methods><class-id>UI.TextSelectionTracker</class-id> <category>events</category><body package="ExternalWebBrowser-Text">redButtonReleasedEvent: aMouseButtonEvent	super redButtonReleasedEvent: aMouseButtonEvent.	controller redButtonReleasedEvent: aMouseButtonEvent</body></methods><methods><class-id>Core.PeekableStream</class-id> <category>accessing</category><body package="ExternalWebBrowser-Text">skipWhile: aTestBlock	[self atEnd or: [(aTestBlock value: self peek) not]]		whileFalse: [self next]</body></methods><methods><class-id>Core.Text</class-id> <category>accessing</category><body package="ExternalWebBrowser-Text">addHrefLink: aLink from: start to: stop	self		addEmphasis: (Array with: #href -&gt; aLink)		removeEmphasis: nil		allowDuplicates: false		from: start		to: stop</body><body package="ExternalWebBrowser-Text">addHrefLinkFrom: start to: stop	self		addHrefLink: (self copyFrom: start to: stop) asString		from: start		to: stop</body><body package="ExternalWebBrowser-Text">addHyperlinkEmphases	"This API is deprecated."	^self styleEmbeddedHttps</body><body package="ExternalWebBrowser-Text">assurePendingLinkEmphasesAlong: anEmphasis	"Place a #temporaryUnderline in parallel to anEmphasis, return true if that indeed happens."	| added |	added := false.	runs := runs		collect:			[:each | 			(each isKindOf: Array)				ifTrue:					[((each includes: anEmphasis)						and: [(each includes: #temporaryUnderline) not])						ifTrue:							[added := true.							each copyWith: #temporaryUnderline]						ifFalse: [each]]				ifFalse:					[each = anEmphasis						ifTrue:							[added := true.							Array with: each with: #temporaryUnderline]						ifFalse: [each]]].	^added</body><body package="ExternalWebBrowser-Text">exciseAnyPendingLinkEmphases	"We exploit the fact that we know it has to show up next to an href in an array of emphases. Return whether we actually made any changes or not."	| removed |	removed := false.	runs := runs		collect:			[:each | 			(each isKindOf: Array)				ifTrue:					[(each includes: #temporaryUnderline)						ifTrue:							[| replacement |							removed := true.							replacement := each copyWithout: #temporaryUnderline.							replacement size = 1								ifTrue: [replacement first]								ifFalse: [replacement]]						ifFalse: [each]]				ifFalse: [each]].	^removed</body><body package="ExternalWebBrowser-Text">styleEmbeddedHttps	| stream start stop |	stream := string readStream.	[stream atEnd]		whileFalse:			[stream skipThroughAll: 'http://'.			stream atEnd				ifFalse:					[start := stream position.					stream						skipWhile:							[:char | char isAlphaNumeric or: ['-_.!~*''():@&amp;=+$,;/?:@&amp;=+$,#%' includes: char]].					['.)?!' includes: (string at: stream position)]						whileTrue: [stream skip: -1].					stop := stream position.					stop &gt; start						ifTrue:							[self								addHrefLinkFrom: start - 6								to: stop]]]</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>testing</category><body package="ExternalWebBrowser-Text">isVisitedHyperlink	"Keep track of the reciever as a link that has been 'visited' in the hyperlink sense."	^VisitedHyperlinks includes: self asString</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>accessing</category><body package="ExternalWebBrowser-Text">rememberHyperlinkVisit	VisitedHyperlinks add: self asString</body></methods><methods><class-id>Core.RunArray</class-id> <category>enumerating</category><body package="ExternalWebBrowser-Text">collect: aBlock	"Assume that the result is to have the same run layout as the reciever and visit the value for each span only once."	^self class		runs: runs copy		values: (values collect: aBlock)</body></methods><methods><class-id>Graphics.CharacterAttributes class</class-id> <category>class initialization</category><body package="ExternalWebBrowser-Text">addHyperlinkStyles: aDictionary	&lt;stylesWithOrder: 10&gt;	aDictionary		at: #href		put:			[:query :value | 			query boldness: 1.0.			query color: (self hrefColor: value)].	aDictionary		at: #temporaryUnderline		put: [:query | query underline: true]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>RunArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runs values cacheRun cacheRunStart </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>PeekableStream</name><environment>Core</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>TextSelectionTracker</name><environment>UI</environment><super>UI.ScrollingTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pivotBlock currentBlock nextBlock showingCaret gc prevStartBlock prevStopBlock isInDoubleClickSelect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Trackers</category><attributes><package>Interface-Events-Trackers</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Text</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string runs </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>TextEditorController</name><environment>UI</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>beginTypeInIndex anchorIndex emphasisHere dispatchTable charComposer textHasChanged feelPolicy supportCodeEditingFeels localMenuItems extendingDown keyboardHook readOnly accepted autoAccept continuousAccept tabMeansNextField tabRequiresControl dispatcher selectable maxChars nextUndoBlock currentUndo </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>ParagraphEditor</name><environment>UI</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>beginTypeInIndex anchorIndex emphasisHere dispatchTable charComposer textHasChanged feelPolicy supportCodeEditingFeels localMenuItems extendingDown </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class></st-source>