<?xml version="1.0"?><st-source><!-- Name: MemoryPolicyTunerNotice: Copyright 2010-2013 Cincom Systems, Inc.  All rights reserved.DbIdentifier: bear73DbTrace: 400841DbUsername: nrossDbVersion: 7.10 - 1DevelopmentPrerequisites: #(#(#any 'MemoryPolicyChecker' ''))PackageName: MemoryPolicyTunerParcel: #('MemoryPolicyTuner')PrerequisiteDescriptions: #(#(#name 'MemoryPolicyChecker' #componentType #package))PrerequisiteParcels: #(#('MemoryPolicyChecker' ''))PrintStringCache: (7.10 - 1,nross)Version: 7.10 - 1Date: 7:23:08 AM April 3, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (mar13.5) of April 3, 2013 on April 3, 2013 at 7:23:08 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>MemoryPolicyTuner</name><environment>Smalltalk</environment><super>MemoryPolicyTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MemoryPolicyTuner</package></attributes></class><methods><class-id>MemoryPolicyTuner</class-id> <category>growth</category><body package="MemoryPolicyTuner">testPreferredGrowthIncrement	self		assert: self memoryUpperBound // self preferredGrowthIncrement &lt; 32		description: 'The preferred growth increment should be increased to there are less segments'</body></methods><methods><class-id>MemoryPolicyTuner</class-id> <category>free memory upper bound</category><body package="MemoryPolicyTuner">testFreeMemoryUpperBoundAndGrowthIncrement	"If this test fails, then an application past the growth regime can get in this cycle:		1.  Try to grow, fail.  GC does not clean up enough room.  Grow.		2.  After a bit, enough objects are collected and the memory policy shrinks the object memory.		3.  Go to 1.	"	self		assert: self freeMemoryUpperBound // 2 &gt; self preferredGrowthIncrement		description: 'The free memory upper bound should be at least twice the growth increment'</body><body package="MemoryPolicyTuner">testFreeMemoryUpperBoundLargerThanOldSegments	"If freeSpaceUpperBound is smaller than the smallest segment size,	the memory policy is going to find many many times that	freeMemory &gt; freeMemoryUpperBound, without finding a completely	empty segment, so it may uselessly try over and over to free memory"	| smallestOldSpaceSegment |	self assert: self oldSpaceSegmentSizes notEmpty.	smallestOldSpaceSegment := self oldSpaceSegmentSizes fold: [:x :y | x min: y].	self		assert: self freeMemoryUpperBound &gt; smallestOldSpaceSegment		description: 'The freeMemoryUpperBound should be larger than the smallest old segment'</body></methods><methods><class-id>MemoryPolicyTuner</class-id> <category>fixed space</category><body package="MemoryPolicyTuner">testFixedSpaceHeadroom	self		assert: self defaultStartupFixedSpaceHeadroom * self startupFixedSpaceHeadroomMultiplier * 8 &gt;= self fixedBytes		description: 'Consider a larger fixed space headroom'</body><body package="MemoryPolicyTuner">testFixedSpaceSegments	self		assert: self fixedSegments &lt; 10		description: 'There seem to be too many fixed segments, consider a larger fixed space growth increment'</body></methods><methods><class-id>MemoryPolicyTuner</class-id> <category>large space</category><body package="MemoryPolicyTuner">largeClassInstances	| classes queue |	classes := OrderedCollection new.	queue := OrderedCollection withAll: Class rootsOfTheWorld.	[queue isEmpty] whileFalse:		[			| each |			each := queue removeLast.			(each isBits and: [each hasImmediateInstances not])				ifTrue: [classes add: each].			queue addAll: each subclasses		].	^ObjectMemory allInstancesOfClasses: classes</body><body package="MemoryPolicyTuner">testLargeSpaceSizeIsReasonable	"It would be nice if large space held most of the large objects"	| largeObjectBytes |	largeObjectBytes := self largeClassInstances		inject: 0		into:			[:sum :each |				each basicSize &gt; 1023					ifTrue:						[							| eachSize |							eachSize := each basicSize + self bytesPerOOP - 1								// self bytesPerOOP * self bytesPerOOP.							eachSize + sum						]					ifFalse: [sum]			].	self		assert: self largeBytes * 2 &gt; largeObjectBytes		description: 'Consider increasing the size of large space, there are ', largeObjectBytes printString, ' bytes in large objects.'</body><body package="MemoryPolicyTuner">testStackMultiplier	| processes stackMultiplier |	processes := Process allInstances reject: [:any | any isTerminated].	stackMultiplier := self startupStackMultiplier.	self		assert: processes size / stackMultiplier &lt;= 5		description: 'The number of active processes should not exceed the stack multiplier times 5'</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>MemoryPolicyTest</name><environment>Smalltalk</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentObjectMemory cachedObjectMemory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MemoryPolicyChecker</package></attributes></class></st-source>