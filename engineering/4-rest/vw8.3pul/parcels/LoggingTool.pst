<?xml version="1.0"?><st-source><!-- Name: LoggingToolNotice: Copyright 2000-2016 Cincom Systems, Inc.  All rights reserved.Comment: LoggingTool provides support to log diagnostic messages and trace execution to a window.  Any object may send a diagnostic string with an optional identifying debug level name to the log.  The LoggingTool control environment logs messages from objects whose class and debug level name match those registered with the environment.  The contents of the log window may be saved to a file.DbIdentifier: bear73DbTrace: 483124DbUsername: tkoganDbVersion: 8.2 - 1PackageName: LoggingToolParcel: #('LoggingTool')ParcelName: LoggingToolPrintStringCache: (8.2 - 1,tkogan)Version: 8.2 - 1Date: 12:07:19 PM January 22, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (jan16.2) of January 15, 2016 on January 22, 2016 at 12:07:19 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>LogEnvironment</name><environment>Tools</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>debugStream debugCategories debugClasses trace logFileName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Logging Tool</category><attributes><package>LoggingTool</package></attributes></class><comment><class-id>Tools.LogEnvironment</class-id><body>Now the LogEnvironment class is used mostly for tracing and debugging purposes.Instance Variables:	debugStream	&lt;Stream&gt;	The debugged class put the information to the stream to display it using Logging Tool	debugCategories	&lt;Collection&gt;	The list of debug categories from the debugged classes	debugClasses	&lt;Collection&gt;	The list of registered classes to debug	trace	&lt;Boolean&gt;	Turns on and off the debug	logFileName	&lt;String&gt;	The name of external file to file out the debug informationClass Variables:	Environment	&lt;LogEnvironment&gt;	To be register for debugging the class should implement the following protocol:1. Specify the list of the class categories to debugaClass class &gt;&gt;debugLabelsAndValues 	^List new		add: ('IMAP Client Messages'-&gt;#IMAPClient);		add: ('IMAP Server Messages'-&gt;#IMAPServer);		yourself2. Menu item name for the class in Logging ToolaClass class &gt;&gt;menuItemName	^'IMAPClient Messages'3. Register with the LogEnvironment registerToDebug	Tools.LogEnvironment default addToDebug: selfTo print the debugging information into Logging Tool can be used 	LogEnvironment default log: aString level: aLevel</body></comment><class><name>LogTextCollector</name><environment>Tools</environment><super>UI.TextCollector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Logging Tool</category><attributes><package>LoggingTool</package></attributes></class><comment><class-id>Tools.LogTextCollector</class-id><body>Class LogTextCollector  represents a ValueHolder for LoggingTool classInstance Variables:</body></comment><class><name>LoggingTool</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Logging Tool</category><attributes><package>LoggingTool</package></attributes></class><comment><class-id>Tools.LoggingTool</class-id><body>Logging Tool is a user interface to display debugging information.Instance Variables:Class Variables:	LastBounds	&lt;Rectangle&gt;	The interface size	MyCollector	&lt;LogTextCollector&gt;	Collects debugging information</body></comment><class><name>LogStackCollector</name><environment>Tools</environment><super>Tools.LogTextCollector</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messages </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>LoggingTool</package></attributes></class><comment><class-id>Tools.LogStackCollector</class-id><body>For improved introspection, each log request is stored with the string to be logged and the call stack which caused the logging. The stack is stored with the list of active CompiledMethods.This class can be used as logger for a DatabaseAccessor. An instance is installed via DatabaseAccessor&gt;&gt;logger: and written to by DatabaseAccessor&gt;&gt;logString:. Each log request is stored for later evaluation, e.g. checking whether certain logged code points have been visited.Instance Variables:	messages	&lt;(OrderedCollection of: (Association key: String value: OrderedCollection))&gt;	holds each request to log a string, along with the method call stack</body></comment><shared-variable><name>Environment</name><environment>Tools.LogEnvironment</environment><private>false</private><constant>false</constant><category>default</category><initializer></initializer><attributes><package>LoggingTool</package></attributes></shared-variable><shared-variable><name>LastBounds</name><environment>Tools.LoggingTool</environment><private>false</private><constant>false</constant><category>unknown</category><attributes><package>LoggingTool</package></attributes></shared-variable><shared-variable><name>MyCollector</name><environment>Tools.LoggingTool</environment><private>false</private><constant>false</constant><category>constants</category><attributes><package>LoggingTool</package></attributes></shared-variable><shared-variable><name>CharacterLimit</name><environment>Tools.LogTextCollector</environment><private>false</private><constant>false</constant><category>constants</category><initializer>50000</initializer><attributes><package>LoggingTool</package></attributes></shared-variable><methods><class-id>Tools.LogEnvironment</class-id> <category>private</category><body package="LoggingTool">addDebugCategory: symbol 	self debugCategories add: symbol</body><body package="LoggingTool">removeDebugCategory: symbol 	self debugCategories remove: symbol</body><body package="LoggingTool">reset	self resetDebugClasses.	self resetDebugCategories.</body><body package="LoggingTool">resetDebugCategories	debugCategories := nil</body><body package="LoggingTool">resetDebugClasses	debugClasses := nil</body></methods><methods><class-id>Tools.LogEnvironment</class-id> <category>registration</category><body package="LoggingTool">addToDebug: aClass	self debugClasses add: aClass.</body><body package="LoggingTool">removeFromDebug: aClass	debugClasses notNil		ifTrue: [debugClasses remove: aClass ifAbsent: [nil]]</body></methods><methods><class-id>Tools.LogEnvironment</class-id> <category>debugging</category><body package="LoggingTool">debug: aBlock level: aLevel	( self trace and: [ self debugCategories includes: aLevel ] ) ifTrue: [ aBlock value]</body><body package="LoggingTool">log: aStringOrBlock		self log: aStringOrBlock level: #general</body><body package="LoggingTool">log: aStringOrBlock level: aLevel	| stream i briefMsg aMsg |	self 		debug:			[(stream := self debugStream) == nil ifTrue: [^self].			aMsg := ((aStringOrBlock isKindOf: BlockClosure)				ifTrue: [ aStringOrBlock value ]				ifFalse: [ aStringOrBlock ]) asString.			i := aMsg size.			[i &gt; 0 and: [(aMsg at: i) isSeparator]] whileTrue: [i := i - 1].			briefMsg := aMsg copyFrom: 1 to: i.			stream cr; nextPutAll: briefMsg; cr; flush]		level: aLevel</body><body package="LoggingTool">printTrace: aString	| stream |	(stream := self debugStream) == nil ifTrue: [^self].	stream cr; cr; nextPutAll: ' **** ' asString.	Date today printOn: stream.	stream nextPutAll: ' '.		Time now printOn: stream.	stream nextPutAll: ' ', aString asString, ' ****'; flush.</body><body package="LoggingTool">traceOff	self printTrace: (#StopTrace &lt;&lt; #dialogs &gt;&gt; 'Stop Trace').	self trace: false.</body><body package="LoggingTool">traceOn	self trace: true.	self printTrace: (#StartTrace &lt;&lt; #dialogs &gt;&gt; 'Start Trace').</body></methods><methods><class-id>Tools.LogEnvironment</class-id> <category>accessing</category><body package="LoggingTool">debugCategories	debugCategories isNil		ifTrue: [ debugCategories := Set new.				debugCategories add: #general ].	^debugCategories</body><body package="LoggingTool">debugClasses	^debugClasses isNil		ifTrue: [ debugClasses  := Set new.]		ifFalse: [ debugClasses ].</body><body package="LoggingTool">debugStream	^debugStream</body><body package="LoggingTool">debugStream: aStream	debugStream := aStream</body><body package="LoggingTool">logFileName	logFileName isNil		ifTrue: [ logFileName  := 'LogOutput.txt'].	^ logFileName</body><body package="LoggingTool">logFileName: aString	logFileName := aString</body><body package="LoggingTool">trace	trace isNil		ifTrue: [ trace := false].	^ trace</body><body package="LoggingTool">trace: aBoolean	 trace := aBoolean</body></methods><methods><class-id>Tools.LogEnvironment</class-id> <category>actions</category><body package="LoggingTool">getFileName	"Prompt the user for a filename and open the file."	| fileName  |	fileName := self logFileName.	fileName := Dialog 					requestFileName: (#PleaseEnterFileName &lt;&lt; #dialogs &gt;&gt; 'Please, enter file name ')					default: fileName.	^fileName isEmpty 		ifTrue: [nil]		ifFalse: [ fileName]</body><body package="LoggingTool">saveOutput	"Prompt the user for a filename and save the log in to this file."	| fileName logFile |	(fileName := self getFileName) isNil ifTrue: [ ^nil].	logFile := (Filename named: fileName) writeStream.	[logFile nextPutAll: self debugStream value string.	logFile flush.	] ensure: [ logFile close ].</body></methods><methods><class-id>Tools.LogEnvironment class</class-id> <category>accessing</category><body package="LoggingTool">default	^ Environment isNil		ifTrue: [ Environment := self new ]		ifFalse: [ Environment ].</body></methods><methods><class-id>Tools.LogTextCollector</class-id> <category>entry control</category><body package="LoggingTool">beginEntry	"use a text stream"	entryStream := TextStream on: (String new: CharacterLimit)</body></methods><methods><class-id>Tools.LogTextCollector</class-id> <category>private</category><body package="LoggingTool">characterLimit	^characterLimit isNil		ifTrue: [characterLimit := CharacterLimit]		ifFalse: [characterLimit]</body></methods><methods><class-id>Tools.LogTextCollector</class-id> <category>accessing</category><body package="LoggingTool">nextPutAll: aCollection 	"Append all the characters in aCollection to the text."	^entryStream nextPutAllText: aCollection</body></methods><methods><class-id>Tools.LoggingTool</class-id> <category>private</category><body package="LoggingTool">buildLoggingMenu	| logMenu |	logMenu := Menu new. 	self debugClasses do:		[ :debugClass | | item submenu | 			item := MenuItem labeled: debugClass menuItemName.			submenu := Menu new.			debugClass debugLabelsAndValues do: 				[ :association | | menuitem  |					menuitem := MenuItem labeled: association key.					menuitem indication: 						[ self debugCategories includes: association value ].					menuitem value: 						[( self debugCategories includes: association value)							ifTrue: 								[ self environment removeDebugCategory: association value]							ifFalse: 								[ self environment addDebugCategory: association value]].					submenu addItem: menuitem.				].			item submenu: submenu.			logMenu addItem: item.		].	^logMenu</body><body package="LoggingTool">buildTracingMenu	| menu menuitem |		menu := Menu new.	menuitem := MenuItem labeled: (#TraceON &lt;&lt; #dialogs &gt;&gt; 'Trace ON').	menuitem value: [ self environment traceOn ].	menuitem indication: [ self environment trace ].	menu addItem: menuitem.	menuitem := MenuItem labeled: (#TraceOFF &lt;&lt; #dialogs &gt;&gt; 'Trace OFF').	menuitem value: [ self environment traceOff ].	menuitem indication:  [ self environment trace not ].	menu addItem: menuitem.	^menu.</body><body package="LoggingTool">debugCategories	^self environment debugCategories</body><body package="LoggingTool">debugClasses	^self environment debugClasses</body></methods><methods><class-id>Tools.LoggingTool</class-id> <category>menu messages</category><body package="LoggingTool">clear	"Clears output."	self textCollector clear.</body><body package="LoggingTool">saveOutput	^self environment saveOutput</body></methods><methods><class-id>Tools.LoggingTool</class-id> <category>views</category><body package="LoggingTool">collector	| textCollectorView |	textCollectorView := TextCollectorView model: self textCollector.	textCollectorView editText: self textCollector value.	textCollectorView controller: TextEditorController new.	^textCollectorView</body></methods><methods><class-id>Tools.LoggingTool</class-id> <category>accessing</category><body package="LoggingTool">environment	^self model</body><body package="LoggingTool">model	model isNil		ifTrue: 			[model := LogEnvironment default.			model addDependent: self].	^model</body><body package="LoggingTool">model: aLogEnvironment		model := aLogEnvironment.	model addDependent: self.</body><body package="LoggingTool">textCollector	^self class myCollector</body></methods><methods><class-id>Tools.LoggingTool</class-id> <category>update</category><body package="LoggingTool">noticeOfWindowClose: aWindow	"The ApplicationWindow aWindow is in the process of closing."	model removeDependent: self.	super noticeOfWindowClose: aWindow</body></methods><methods><class-id>Tools.LoggingTool</class-id> <category>interface opening</category><body package="LoggingTool">postBuildWith: aBuilder 	super postBuildWith: aBuilder.	((builder menuAt: #windowMenu) atNameKey: #logging) ifNotNil:		[:value | value submenu: self buildLoggingMenu].	((builder menuAt: #windowMenu) atNameKey: #trace) ifNotNil:		[:value | value submenu: self buildTracingMenu].	self environment debugStream: self textCollector.</body><body package="LoggingTool">postOpenWith: aBuilder 	| view |	super postOpenWith: aBuilder.	view := (aBuilder componentAt: #collector) widget.	view selectionIndex: view text size + 1.	view selectAndScroll.	view deselect.</body></methods><methods><class-id>Tools.LoggingTool class</class-id> <category>accessing</category><body package="LoggingTool">clear	self myCollector clear</body><body package="LoggingTool">initCollector	MyCollector := nil</body><body package="LoggingTool">lastBounds	"Clients should check for nil."	^LastBounds</body><body package="LoggingTool">lastBounds: rectangle	LastBounds := rectangle</body><body package="LoggingTool">myCollector	MyCollector isNil		ifTrue: [ MyCollector := LogTextCollector new ].	^ MyCollector</body></methods><methods><class-id>Tools.LoggingTool class</class-id> <category>class-initialization</category><body package="LoggingTool">obsolete	MyCollector := nil.	super obsolete</body></methods><methods><class-id>Tools.LoggingTool class</class-id> <category>interface opening</category><body package="LoggingTool">open	"Open an Interface.  If an interface is already open raise it."	self raiseSingleInstance isNil ifTrue: [^super open]</body><body package="LoggingTool">openWith: aLogEnvironment	"Open an interface.  If an interface is already open raise it."	| obj |	(obj := self new)		model: aLogEnvironment.	obj open.</body></methods><methods><class-id>Tools.LogStackCollector</class-id> <category>initialize-release</category><body package="LoggingTool">initialize	super initialize.	messages := OrderedCollection new.</body></methods><methods><class-id>Tools.LogStackCollector</class-id> <category>accessing</category><body package="LoggingTool">logEntriesWithMessage: aString	"Answer all log entries where the log string matches the pattern of aString, returning an OrderedCollection of associations whose keys are the logged strings and whose values are the stacks of where those strings were logged, as ordered collections of compiled methods."	^messages select: [:assoc | aString match: assoc key]</body><body package="LoggingTool">logEntriesWithMessage: aString fromClass: aClass selector: aSymbol	"Answer all log entries where	- log string matches the pattern aString	- the stack contains the method aClass&gt;&gt;aSymbol"	^(self logEntriesWithMessage: aString) select:		[:assoc |		assoc value contains: 			[:aCompiledMethod |			aCompiledMethod mclass = aClass and: [aCompiledMethod selector = aSymbol]]]</body><body package="LoggingTool">messages	^messages</body><body package="LoggingTool">openInLoggingTool	"Open a logging tool on me;  return the LoggingTool instance (so that, for example, a test can close it again)."		| oldVal |	oldVal := LoggingTool.MyCollector.	^([LoggingTool.MyCollector := self.	LoggingTool open]		ensure: [LoggingTool.MyCollector := oldVal])			source</body><body package="LoggingTool">show: aString	"Store the log request along with the underlying method call stack."		| stack ctx |	stack := OrderedCollection new.	ctx := thisContext sender.	[ctx notNil] whileTrue: [stack add: ctx method homeMethod. ctx := ctx sender].	messages add: aString -&gt; stack.	super show: aString.</body></methods><methods><class-id>Tools.LoggingTool class</class-id> <category>resources</category><body package="LoggingTool">windowMenu	"MenuEditor new openOnClass: self andSelector: #windowMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_File #defaultString: '&amp;File' #catalogID: #menus) 				#nameKey: #file 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #SaveOutput #defaultString: 'Save Output...' #catalogID: #menus) 							#value: #saveOutput ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ClearLog #defaultString: 'Clear log' #catalogID: #menus) 							#value: #clear ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #E_xit #defaultString: 'E&amp;xit' #catalogID: #menus) 							#value: #closeRequest 							#shortcutKeyCharacter: $x ) ) #(2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Logging #defaultString: '&amp;Logging' #catalogID: #menus) 				#nameKey: #logging ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Utils #defaultString: '&amp;Utils' #catalogID: #menus) 				#nameKey: #utils 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #InspectDots #defaultString: 'Inspect...' #catalogID: #menus) 							#value: #inspect ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #BrowseDot #defaultString: 'Browse...' #catalogID: #menus) 							#value: #browse ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Trace #defaultString: '&amp;Trace' #catalogID: #menus) 				#nameKey: #trace ) ) #(4 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.LoggingTool class</class-id> <category>interface specs</category><body package="LoggingTool">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #LogWindow #defaultString: 'Log Window' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 293 265 732 503 ) 			#flags: 4 			#menu: #windowMenu 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.00683371 0 0.0178571 0 0.995444 0 0.986607 ) 					#name: #collector 					#flags: 9 					#component: #collector ) ) ) )</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>TextCollector</name><environment>UI</environment><super>UI.ValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>entryStream characterLimit writeSequencer nextEntry autoFlush </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class></st-source>