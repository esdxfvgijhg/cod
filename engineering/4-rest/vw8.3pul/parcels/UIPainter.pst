<?xml version="1.0"?><st-source><!-- Name: UIPainterNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: Contains the User Interface Painter and related GUI tools such as the Menu Editor, Graphics Image Editor, Resouce Finder, Coding Assistant and Hot Region Editor.  The UI Painter is used to create user interfaces visually.Further information on using the UI Painter can be found in the "GUI Developer's Guide" (located in the /doc subdirectory of the VisualWorks installation).DbIdentifier: bear73DbTrace: 502829DbUsername: cgundelDbVersion: 8.3 - 9DevelopmentPrerequisites: #(#(#any 'ImageReaders' ''))PackageName: UIPainterParcel: #('UIPainter')ParcelName: UIPainterPrerequisiteParcels: #(#('ImageReaders' ''))PrintStringCache: (8.3 - 9,cgundel)Version: 8.3 - 9Pre-Unload Block: 	[:pkg | BitView allGeneralInstances do: [:each | each topComponent controller closeAndUnschedule].UIPainter preUnloadFor: pkg ]Date: 1:09:30 PM June 23, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.4) of June 23, 2017 on June 23, 2017 at 1:09:30 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ColumnReorderAgent</name><environment>Tools</environment><super>UI.ColumnResizeAgent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>columnSize columnRanges </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.ColumnReorderAgent</class-id><body>This class is used by the PaintedDataSetViewController to handle the re-ordering of the columns.  It simply monitors mouse movement and re-orders the columns appropriately and will then cause those changes to be known to all interested parties. Instance Variables:	columnRanges	&lt;Collection&gt;	When moving, we want to know the edges of the columns, this holds that.	columnSize	&lt;integer&gt;	Poorly named. It is really the column count. Used to make sure we don't move too far.Shared Variable:	AdjustmentCursor   The cursor used when reordering columns in the UIPainter.</body></comment><class><name>DrawingModeTracker</name><environment>Tools</environment><super>UI.SelectionTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Modes</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.DrawingModeTracker</class-id><body>DrawingMode is an abstract subclass of ControlMode, which adds protocol for graphic input of lines and rectangles</body></comment><class><name>DragModeTracker</name><environment>Tools</environment><super>Tools.DrawingModeTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lastShowPoint dragObject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Modes</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.DragModeTracker</class-id><body>An abstract class, whose subclasses are used to implement placement and dragging of components in a UIPainter</body></comment><class><name>DividerResizingDragModeTracker</name><environment>Tools</environment><super>Tools.DragModeTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalBounds horizontal </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Modes</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.DividerResizingDragModeTracker</class-id><body>DividerResizingDragMode handles the special case of manipulating the 'handle' of a selected Divider in a UIPainter.  It is a very special case, because Dividers have only two handles, whereas most other components have four corners.</body></comment><class><name>UIPainter</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetClass targetSelector acceptedState windowSpec minWindowExtent prefWindowExtent maxWindowExtent definer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Tools</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.UIPainter</class-id><body>UIPainter is the central tool of VisualWorks.  It allows user interface specifications to be prepared by graphically editing the appearance of the desired runtime window.  The resulting specifications are then installed as methods on classes, typically subclasses of ApplicationModel.  The specifications are used by a UIBuilder, at interface opening time, to automatically generate the necessary view structures.A brief precis of commands on the action button menu:	copy	Copy one or more widgets to an internal paste buffer	cut		Cut one or more widgets to the paste buffer	paste	Paste one or more widgets from the paste buffer	window &gt; bounds	Set the minimum, preferred, and/or maximum bounds for the runtime window	window &gt; properties...	Set the appearance properties for the runtime window	bring &gt; *	raise one or more widgets upward in the drawing order	send &gt; *		lower one or more widgets downward in the drawing order	group 	combine one or more widgets into a composite	ungroup		explode a composite into its constituent widgets	arrange &gt; align ...	line up one or more widgets, either horizontally or vertically	arrange &gt; distribute...		give evenly distributed spacing to two or more widgets	arrange &gt; equalize...		equalize the widths and/or heights of two or more widgets	layout &gt; fixed	give one or more widgets layouts that are expressed purely in terms of fixed offsets	layout &gt; relative		give one or more widgets layouts that are expressed purely in terms of relative fractions	layout &gt; constrained		give one or more widgets layouts that combine fixed offsets and relative fractions	layout &gt; be bounded		give one or more unbounded widgets bounded layouts (e.g. labels, check boxes, radio buttons)	layout &gt; be unbounded 	give one or more bounded widgets unbounded layouts (works only for the above mentioned types)	layout &gt; grid snap	move the origin(s) of one or more widgets into coincidence with a layout grid (whether the grid is active or not)	properties ...		raise a preemptive dialog for editing the properties of a widget	methods &gt; define...	automatically generate stub methods that furnish models for one or more widgets	methods &gt; browse...	browse the methods that interact with the models underlying one or more widgets	tools &gt;	gives access to auxiliary painting tools	accept &gt;	save the current state of the UIPainter in an internal buffer	cancel &gt;	restore the current state of the UIPainter from an internal buffer	spawn &gt;		spawn a new UIPainter based on the current state of the UIPainter	install &gt;		generate a specification method based on the current state of the UIPainter	open &gt;	attempt to open an instance of the application using openInterface: with the canvas being editedInstance Variables	targetClass	&lt;Class&gt;  The class to which the specification will be or has been attached	targetSelector	&lt;Symbol&gt;  The selector for the specification method	acceptedState	&lt;Array of: &lt;Literal&gt;&gt;  Used to support the accept and cancel commands	windowSpec	&lt;WindowSpec&gt;  Holds the specification for the runtime window	prefWindowExtent	&lt;Point&gt;  Holds the current preferred bounds for the runtime window	maxWindowExtent	&lt;Point&gt;  Holds the current maximum bounds for the runtime window	definer	&lt;UIDefiner&gt;  Used for generating stub definitions of methods for furnishing modelsClass Variables	ControlOffsets	&lt;Dictioinary of: Point indexedBy: Symbol&gt; 	Maps window system to offset</body></comment><class><name>GridWrapper</name><environment>Tools</environment><super>Graphics.Wrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>showGrid griddedHorizontally griddedVertically grid gridPaint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.GridWrapper</class-id><body>GridWrapper is used by UIPainter for superimposing a reference grid, for use when the UIPainter's grid feature is on and visible.Instance Variables:	showGrid	&lt;ValueHolder with: Symbol&gt;  #Show, #Hide or #'Show If On', the possible settings for displaying the grid	griddedHorizontally	&lt;ValueHolder with: Boolean&gt;  Whether to constrain placement and movement in the x dimension	griddedVertically	&lt;ValueHolder with: Boolean&gt;  Whether to constrain placement and movement in the y dimension	grid	&lt;ValueHolder with: Integer&gt;  The size of the grid cell in pixels	gridPaint	&lt;Paint | nil&gt;  Optional Paint to be used for the grid linesshowGrid griddedHorizontally griddedVertically grid gridPaint </body></comment><class><name>UIPainterWatcher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectionHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.UIPainterWatcher</class-id><body>This class is the parent of a number of UIPainter-related applications that are sensitive to what components are selected in the currently active UIPainter.  Those interested in implementing new painting tools are directed to the methods reloadSelectionInformation and to the instVar selectionHolder, which are the triggers for updating the tool when the currently active UIPainter passes the baton to another UIPainter, or when selection changes in the currently active UIPainter.Instance Variables:	selectionHolder	&lt;ValueHolder with: &lt;UIPainterController | nil&gt;&gt;&gt;  The value of UIPainterController's LastControllerWithSelection class var</body></comment><class><name>UIMaskEditor</name><environment>Tools</environment><super>Tools.UIPainterWatcher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>magnifiedBitView directBitView acceptedState targetClass targetSelector modified menuBar storeMask useCachedImage doTheCurrentColor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Tools</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.UIMaskEditor</class-id><body>UIMaskEditor creates either color or black and white images (masks).  The default is to store them as cached images ('Cache' is enabled), but user can toggle this off. Images large enough to serve as labels can be stored as methods or strings to reconstruct the image on demand, and are completely portable from platform to platform with no change in appearance due to differences in palette or depth of the Screen.UIMaskEditor can take an image directly from the screen ('Capture Image'), or read an image from the currently selected widget on the current active canvas ('Read'), or load an image from a resource method on a class ('Load').  The 'Resize Image' command can be used to specify a new shape and size for the image being edited; you will be prompted for a rectangle which can both clip and overlap the current image.  'Copy', 'Cut', and 'Paste' can be used to move rectangular sections within an image, or among UIMaskEditors.The objective in using this tool is to wind up with images that can be used in VW applications. The tool consists of the menu bar containing all of the commands available to the user of UIMaskEditor, speedbar buttons containing some of the most frequently used commands, two areas displaying the image, painting tool and option palette, avaiable colors and an area displaying the currently selected color. The 'Replace Color' command can be used to map specified colors to the currently selected color (you will be prompted to select a pixel in the image that has the color to be mapped).  The select button of the mouse can be used to 'freehand draw' using selected color. If the color image is converted to the mask (black and white image) then you should change current color to either black or white and use 'Replace Color' to map various colors to either black or white. The finished mask can be previewed by using the 'Color to B&amp;W' command, which will substitute ColorValue black for any non-white ColorValues remaining in the image.  'Color to B&amp;W' does an Accept, so its effect can always be undone by Undo.  When the completed image is ready, 'Apply' can be used to smash it directly onto the current (single) selection on the currently active canvas, provided that the selected widget is able to have a label property.  An appropriate resource method will be created for the class that holds the canvas.  You will be asked to confirm and/or supply the class and selector for the mask generating method that will be created as the tool's output.  'Install' can be used to directly create an image generating method on an arbitrary class and selector, regardless of whether there is a currently active canvas and a current selection on it.Instance Variables:	magnifiedBitView        &lt;BitView&gt;  The magnified view of the image	directBitView   &lt;DirectBitView&gt;  The small repeater view that shows the image at actual scale	acceptedState   &lt;Depth8Image&gt;  Changes when an Accept is done	targetClass     &lt;Class&gt;  The class on which the resulting resource method will be installed	targetSelector  &lt;Symbol&gt;  The selector for the resulting resource method	modified        &lt;Boolean&gt;  Whether the image has been modified since it was loaded, read, applied, or installed.	menuBar                 &lt;Menu&gt; The menu for the main window of MaskEditor. A convenient way to access menu items to disable or enable them.	storeMask       &lt;ValueHolder with: Boolean&gt;     control whether to store as Mask	useCachedImage  &lt;ValueHolder with: Boolean&gt; control whether to store a representation to use CachedImage	doTheCurrentColor	&lt;ValueHolder with: String&gt; a placeholder variableClass Variables:	PasteBuffer     &lt;Image|nil&gt; buffer containing the image used by cut, copy and paste operations.</body></comment><class><name>MaskPainterView</name><environment>UI</environment><super>UI.SimpleView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>backdrop onPaint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>UI.MaskPainterView</class-id><body>MaskPainterView displays a Depth1Image in the course of editting. Instance Variables:	backdrop	&lt;VisualComponent&gt;  comment	onPaint	&lt;Paint&gt;  comment</body></comment><class><name>SelectionDragModeTracker</name><environment>Tools</environment><super>Tools.DragModeTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectedWidgets constrainedAxis </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Modes</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.SelectionDragModeTracker</class-id><body>SelectionDragMode is the drag mode used for repositioning a component in a UIPainter when the entire component is being dragged, as opposed to one of its handles.</body></comment><class><name>DragHandle</name><environment>Tools</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isPrimary wrapper subject selector block extent dragModeBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Modes</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.DragHandle</class-id><body>DragHandles are the small black squares that show component selection in a UIPainter, and which are used for moving and/or resizing components using the mouse.Instance Variables:	wrapper	&lt;SpecWrapper&gt;  The SpecWrapper of the component to which the DragHandle is attached	subject	&lt;PassiveLabel&gt;  The component to which the DragHandle is attached	selector	&lt;Symbol&gt;  #origin, #corner, #topRight, or #bottomLeft; the corner to which the DragHandle is attached	block	&lt;BlockClosure&gt;  A block with two arguments: the subject and the wrapper, used for computing the position of the handle</body></comment><class><name>NullDragModeTracker</name><environment>Tools</environment><super>Tools.DragModeTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Modes</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.NullDragModeTracker</class-id><body>The kind of DragMode that is used when a DragHandle is not independently repositionable (i.e. the handles attached to any but the origin corner of an unbounded object, such as Label).</body></comment><class><name>UIPainterSystemController</name><environment>Tools</environment><super>UI.ApplicationStandardSystemController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.UIPainterSystemController</class-id><body>UIPainterSystemController is the Controller for a UIPainter window (a canvas). UIPainterSystemController restricts the resizing of the window to the minimum and maximum dimensions specified in the WindowSpec.</body></comment><class><name>UIPalette</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>activeSpecs toolName currentLookPolicy stickyStatus </inst-vars><class-inst-vars>selectIcon stickyIcon </class-inst-vars><imports></imports><category>UIPainter-Tools</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.UIPalette</class-id><body>UIPalette provides an application model for the palette window,making it a first class application. Adding new objects to the palette:The class variable ActiveSpecList holds an ordered collection ofnames. Each symbol represents specification which will be present onthe palette. The palette's order is row by row from top to bottom. Aspecification implements paletteIcon message. This message returns a24x24 image which represents the specification on the palette. Addingnew specs to the palette requires changing only an ActiveSpecListcollection. This variable is accessible by sending activeSpecListmessage to UIPalette class.Instance Variables:	activeSpecs	&lt;OrderedCollection&gt;	holds a list of specsClass Variables:	ActiveSpecsList	&lt;OrderedCollection of symbols&gt; specs shown on				palette. </body></comment><class><name>BitView</name><environment>Tools</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pixmap policy scale gridding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.BitView</class-id><body>BitView is the magnified image editing view used in UIMaskEditor.Instance Variables:	pixmap	&lt;Pixmap&gt;  Holds the magnified image	policy	&lt;OrderedDither&gt;&gt;  Policy used for rendering the colors in the image being edited	scale	&lt;Point&gt;  Magnification scale for the BitView</body></comment><class><name>CornerDragModeTracker</name><environment>Tools</environment><super>Tools.DragModeTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalBounds drawByXAxis drawByYAxis </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Modes</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.CornerDragModeTracker</class-id><body>CornerDragModeTracker is used when the user is adjusting the position and/or size of a selected component by manipulating one of its four 'handles'.Instance Variables:	drawByXAxis	&lt;Boolean&gt;	if true with shift down drag only horizontally. 	drawByYAxis	&lt;Boolean&gt;	if true with shift down drag only vertically.	originalBounds	&lt;Rectangle&gt;	original bounds of drag object.</body></comment><class><name>SpecPlacementModeTracker</name><environment>Tools</environment><super>Tools.DragModeTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>specGenBlock dragee specClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Modes</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.SpecPlacementModeTracker</class-id><body>An abstract class for red down dragging of figures generated by adding specs to a UIBuilder.  The specGenBlock holds a block for generating the spec to be handed to the builder, which will be invoked when the cursor enters the controller's window.  The specGenBlock should take two arguments: the controller for the window being entered, and the coordinate of the entry point.Instance Variables:	specGenBlock	&lt;BlockClosure&gt;  Used for generating the UISpecification of the component to be emplaced, when it is first created	dragee	&lt;SpecWrapper | nil&gt;  The SpecWrapper of the component being emplaced	residualDelta	&lt;Point&gt;  Collects residual mouse motion that would otherwise be lost when constraining placement to a grid</body></comment><class><name>DragPlacementModeTracker</name><environment>Tools</environment><super>Tools.SpecPlacementModeTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetWindow lock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Modes</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.DragPlacementModeTracker</class-id><body>DragPlacementMode is the kind of PlacementMode with which the new component appears as the mouse cursor enters the UIPainterView, is dragged with all mouse buttons up, and then resized with the 'select' mouse button held down.  Used by UIPainterController.Instance Variables	lock						&lt;Boolean&gt; 	Used to lock out superfluous entry updates	targetWindow			&lt;Window&gt;	Window this tracker enters and acts on</body></comment><class><name>HotSlice</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mask selector index parentRegions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>UI.HotSlice</class-id><body>HotSlice is used during the creation and modification of instances pf HotRegions. A HotSlice specifies all the coordinates for which a given selector is mapped, by means of a 1-bit-deep image which is 'on' everywhere the given selector is indicated. Instance Variables:	mask	&lt;Depth1Image&gt;  	selector	&lt;Symbol&gt;  	index	&lt;Integer&gt;  	parentRegions	&lt;HotRegions&gt;  </body></comment><class><name>UIPainterTool</name><environment>Tools</environment><super>Tools.UIPainterWatcher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selection selectionKind controller currentSpecCopy currentSpecBindings specChannel subBuilder lock slice lastSlice slicesMenu sliceInfo client statusBarText list sliceChanging sliceTabChanging canvasTree menuBar currentView </inst-vars><class-inst-vars></class-inst-vars><imports>			private Smalltalk.TextConstants.*			</imports><category>UIPainter-Tools</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.UIPainterTool</class-id><body>UIPainterTool is a persistent tool window that shows the properties of the currently selected component on the most recently active UIPainter canvas.UIPainterTool openThe Apply button must be used to make any edits actually take effect in the properties of the currently selected component on the currently active canvas.  When there is no selection in the currently active canvas, the tool displays the runtime window properties for the currently active canvas.  The Prev and Next buttons can be used to move the selection around the face of the currently active canvas.  The pseudo-spec MultiSpec is used when multiple components are selected.With the new Hierarchy view, the view can be confused if there are two components of the same type at exactly the same position and size. Therefore, always make sure you name your components.Instance Variables:	selection					&lt;Array of: SpecWrapper&gt; The selection being edited also used to lock out superfluous retargetting	selectionKind			&lt;Symbol&gt; What kind of selection is being edited	controller					&lt;UIPainterController&gt; Controller for 'selection'	currentSpecCopy		&lt;RadioButtonSpec&gt;  Buffer holding a copy of the spec for the selected widget	currentSpecBindings	&lt;IdentityDictionary key: &lt;Symbol&gt; value: &lt;ValueModel&gt;&gt;  Maps property names to Adaptors	specChannel				&lt;ValueHolder with: UISpecification&gt; Used to target the adaptors onto the buffered specification	subBuilder				&lt;UIBuilder&gt; The UIBuilder used to build a property dialog's widgets inside UINewPropertiesTool's SubCanvas	lock						&lt;Boolean&gt; Used to lock out superfluous updating	slice 						&lt;ValueHolder on: Symbol&gt; Name of the current slice	lastSlice					&lt;Symbol&gt; The last slice reflected in the display	slicesMenu 				&lt;ValueHolder on: Menu&gt; The current slice menu	sliceInfo 					&lt;IdentityDictionary Symbol -&gt; &lt;Array of: Symbol&gt;&gt;	Maps slice name to info needed to build slice	client						&lt;UIPainterTool(self) | IntegratedSpecModel&gt; The model for the spec in the subcanvas	statusBarText			&lt;ValueHolder with: String&gt; Used at one time to show the name of the current selected component.	list 						&lt;SelectionInList&gt; Contains the list of the current property slice page names	sliceChanging 			&lt;Boolean&gt; Contains a flag that says that the current selected widget is going to change to a different selection	sliceTabChanging 		&lt;Boolean&gt; Contains a flag that says that the current page within the slice is going to change to a different page	canvasTree 				&lt;SelectionInTree&gt; Contains the visible selection tree for the Hierarchical list	tabPageEnabled 		&lt;Boolean&gt; Contains a flag that is usually true, but will be false if the currently selected primary widget is embedded in a composite, and that composite is not in "Embedded Edit" mode	menuBar					&lt;Menu&gt; Contains the main menu bar</body></comment><class><name>LabelConstructor</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>labeledValueHolder suppliedByBuilder parentBuilderBlock fieldMenuBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Support</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>UI.LabelConstructor</class-id><body>LabelConstructor is used by the UIPropertiesTool to construct label specifications for Labels, ActionButtons, RadioButtons, and other widgets that possess labels. A LabelConstructor is created by a UIPropertiesTool when a slice containing a label is displayed. LabelConstructor creates label specifications suitable for simple default static labels, labels supplied by the application via a message send, and labels that reside in message catalogs.See also comments on LabelSpec, UserMessage, and PassiveLabelInstance Variables:	labeledValueHolder		&lt;ValueHolder on: UISpecification&gt;  the UISpecification for whom a label is being constructed. For example, when the label of an ActionButton is being edited, labeledValueHolder's value is an ActionButtonSpec.	suppliedByBuilder 		&lt;ValueHolder on: Boolean&gt; whether the label is supplied by the UIBuilder (or, indirectly, the ApplicationModel) or not.	parentBuilderBlock		&lt;BlockClosure&gt;		a block when evaluated that answers the UIBuilder for the labeled widget.	fieldMenuBlock			&lt;BlockClosure&gt;		a block when evaluated that answers the pop-up menu for the labeled widget, if any.</body></comment><class><name>MenuEditor</name><environment>Tools</environment><super>Tools.UIPainterWatcher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetClass targetSelector menu menuBar menuBarView menuList currentItem modified properties labelPasteBuffer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Tools</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.MenuEditor</class-id><body>MenuEditor creates and edits menus based on an indented list and a properties notebook.  Note: This tool cannot deal with menus whose values include BlockClosures.  Where BlockClosures are wanted as menu actions, you must edit or write Smalltalk methods that use MenuBuilders or other means to generate the desired menus. Or, you can use the MenuEditor to create the structure of the menu, and then programatically modify those elements that need to be more complex.MenuEditor openMenuEditor is Command-aware, and can be used to assign existing commands to a menu item that will define both the menu label and the shortcut key bindings which will trigger the menu action.  It is possible to override the menu label defined in the Command with a String or UserMessage defined in the MenuItem itself, but this tool does not support setting up dynamic labels supplied by the application.  The Command Bindings tool in the Settings pages has a much richer interface for specifying keystroke combinations independently by platform, making the single Shortcut Character definition in this tool obsolete and invalid when the MenuItem specifies a Command.  The tool will visually warn you of conflicts between the Command and the MenuItem definition for both labels and shortcuts.  You have the opportunity to resolve these conflicts before installing your updated menu, or the tool will resolve them during install, after displaying a dialog informing you of the intended changes.  The conflict resolution removes labels and shortcuts defined in the MenuItem which conflict with the assigned Command, as well as any label overrides which are duplicates of the label in the Command.The 'Edit Command' item on the Command input field menu opens a browser on the specified Command definition method should you need to view (or, in very exceptional cases, adjust) the Command definition.  The 'Copy label' and 'Paste label' items in the Menu Label String input field will allow you to save the current label and replace it as an override after you have assigned a Command to the MenuItem.  These helpers provide support for retrofitting existing menus to install Commands.MenuEditor can take a menu directly from the currently selected widget on the current active canvas (Read).  It can be used to create a new menu from scratch at any time, simply by cutting the contents of the text area and typing in the new menu's items.  The typographic convention is that leading tabs are used to indicate submenu levels.  If a menu item must have an action symbol that is different from its label, one or more tabs must be used to separate the label from its value.  Any text line whose first visible character is a hyphen designates a line between menu items; any trailing text will be disregarded.Apply can be used to smash it directly onto the current (single) selection on the currently active canvas, provided that the selected widget is able to have a menu property.  If there is no current selection in the most recently active canvas, the menu bar for the canvas is treated as being selected.    IMPORTANT:  the Menu Bar window property must first be set, and the menu being installed must be fully hierarchical.  If these conditions aren't met, the Apply menu item won't enable.When using Apply, you will be asked to confirm and/or supply the class and selector for the menu generating method that will be created as the tool's output.  Install can be used to directly create a menu generating method on an arbitrary class and selector, regardless of whether there is a currently active canvas and a current selection on it.  Install can be used to directly create a menu generating method on an arbitrary class and selector, regardless of whether there is a currently active canvas and a current selection on it.Instance Variables	targetClass	&lt;Class&gt;  The class on which the resulting resource method will be installed	targetSelector	&lt;Symbol&gt;  The selector for the resulting resource method	menu	&lt;Menu&gt;  The menu created by Build, Read, or Load	menuBar	&lt;ValueHolder with: Menu&gt;  The model underlying MenuEditor's own menu bar	menuBarView	&lt;ApplicationWindow | nil&gt; a floting window that previews the menu in menu bar form.	menuList	&lt;SelectionInList&gt; holds a list of Associations, whose keys are either MenuiItems or tokens signifying divider lines, and whose values represent nesting levels in the menu hierarchy.	currentItem	&lt;ValueHolder with: MenuItem&gt; the currently selected item for editing	modified	&lt;Boolean&gt;  Whether the image has been modified since it was loaded, read, applied, or installed. 	properties	&lt;SelectionInList&gt; model for the notebook--keeps track of the currently selected page	labelPasteBuffer	&lt;String | UserMessage | nil&gt;	a copy/paste buffer used by the label string menu as a helper in retrofitting existing menusClass Variables	Masks		&lt;IdentityDictionary&gt; Masks for the various color images	InactiveMasks &lt;IdentityDictionary&gt; Alternate masks for images. An example of use is to show when a button is inactive (whose label is an image)	PasteBuffer	&lt;Array&gt; a list of Associations (see menuList above) that were cut or copied from a menu, ready to be pasted elsewhere.</body></comment><class><name>OrientationResizeModeTracker</name><environment>Tools</environment><super>Tools.DragModeTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalBounds horizontal </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Modes</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.OrientationResizeModeTracker</class-id><body>OrientationResizeMode is the kind of DragMode used for dragging the handles of a Slider.  They side-effect the dragee's SpecWrapper so that its orientation is determined by the component's aspect ratio.</body></comment><class><name>SelectModeTracker</name><environment>Tools</environment><super>UI.ScrollingTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dragging </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Modes</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.SelectModeTracker</class-id><body>SelectMode is the ControlMode used for selecting entities on a canvas by a UIPainterController</body></comment><class><name>SpecModel</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>specChannel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.SpecModel</class-id><body>I represent an abstract application model for the slice of properties.My subclasses provide logic and state necessary to define complexproperties.Instance variables:	 specChannel 	&lt;ValueHolder&gt; 	holds the current focus of the 			UIPainter. My every  instances is dependent of the specChannel,       		whenever the value of it changes it reloads the properties dialog.</body></comment><class><name>IntegratedSpecModel</name><environment>Tools</environment><super>Tools.SpecModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>propertiesTool readMode interruptedRead </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Tools</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.IntegratedSpecModel</class-id><body>This is an abstract class for models of properties slices that have Read/Apply semantics and therefore are intimately tied to the Properties Tool.When the Read button is latched, the state the most recently active UIPainter window or currently selected display component will be displayed.  If the Read button is unlatched, the values will not update.The Apply button causes the currently displayed state to be attached to whatever components are selected in that window. Instance Variables:	propertiesTool	&lt;UIPropertiesTool&gt; The Properties Tool that we are inside of and intimately ties to.	readMode	&lt;ValueHolder with: Boolean&gt;  Whether the tool is in read mode.	interruptedRead	&lt;Boolean&gt;  Whether the tool was in read mode before a change was made; controls whether read mode will be returned to automatically after an Apply.</body></comment><class><name>PaintedDataSetView</name><environment>Tools</environment><super>UI.DataSetView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>editMode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.PaintedDataSetView</class-id><body>This class exists to provide the proper behavior of a DataSetView (DSV) when the DSV is being edited on a canvas.A brief note on editing the properties of a DSV	Due to the complexities of a DSV, it was necessary to alter the editing procedure.  The DSV will actually allow for a limited selection into the DSV itself.  It will also allow a degree of live interaction when it is being edited.  To start this interaction, do a control click on an already selected DSV.  To get out of this mode, select any other component, do a shift click on a selected column, or a single click anywhere on the canvas outside of the DSV.  While the DSV component is in this interactive mode, it will be 'frozen' on the canvas (i.e. a DSV that is in interactive mode may not be repositioned, it must be taken out of this mode and it can then be repositioned).	In interactive mode, the DSV may be scrolled, it's columns can be resized and the column order can be changed.  To resize a column, drag the right edge of the column to change that column's width (dragging the left edge of a column will actually result in the adjustment of the right edge of the column to the right).  To change the order of columns in a DSV that is in interactive mode, drag the handle that is displayed in the center of the first row of the selected column (note: a row selector column will always by the first column and thus not repositionable).</body></comment><class><name>DataSetSpecColumnDetailsModel</name><environment>Tools</environment><super>Tools.IntegratedSpecModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectionChannel currentColumn modelGen columnType changedBlock typeChoices typeSize typePopup typeAlign typeMenu typeFont typeDataType typeDataFormat defaultFormats lock readSelector printSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><class><name>UIDefiner</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>aClass initializeModels excludedBindings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.UIDefiner</class-id><body>UIDefiner is used by UIPainter for automatically generating 'stub' aspect and action methods for newly painted components.  For historical reasons, it also provides some public entries for simple generation of accessor and mutator methods based on instance variables in the class being defined for (see the 'defining' protocol).  When used by the UIPainter, It can generate limited initializations for the models for which it writes accessors, based on the default models employed by UIPainter.  These initializations can optionally be included in the accessors themselves.Instance Variables:	aClass	&lt;Temp class&gt;  Cache of the target class of the UIPainter, so that changes in the target can be detected	initializeModels	&lt;ValueHolder with: Boolean&gt;  Whether or not to include initialization code in the accessors	excludedBindings	&lt;IdentityDictionary key: &lt;Symbol&gt; value: &lt;Object&gt;&gt;  Bindings for which the user is currently declining automatic generation.  The value of the association is the default model</body></comment><class><name>ColorToolModel</name><environment>Tools</environment><super>Tools.IntegratedSpecModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cubesBrightness cubeColors colorValue colorName lookPreferences </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Tools</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.ColorToolModel</class-id><body>ColorToolModel is the model used for the color property slice to assign, display and edit the color policies governing the appearance of UIPainter canvases and display components (see class LookPreferences).Colors can be generated for use in color policies using either the color cube, a rectangular color map display which includes a brightness slider, or an HSV  triplet of analog sliders, or a menu of named colors.  The color cube gives decent but not exhaustive coverage of the available colors in the Screen palette; the sliders can sometimes turn up a few more.  The Hue slider will appear only when the Saturation slider is not zeroed; similarly the Saturation slider will appear only when the Value slider is not zeroed.  The menu of named colors can be summoned by pressing the select mouse button while the cursor is inside the color patch underneath the sliders.Once a color has been selected either by pointing into the color cube, moving the sliders, or selecting a named color, it can be installed in the appropriate display patch at the bottom of the tool by clicking on the 'select' button below the policy color patch.  The 'clear' button which appears when a color is installed on a display patch, can be used to remove the color from that patch.The menu on the master color patch under the sliders will also allow a color to be moved back to itself from one of the policy color patches, which can be handy for transferring this color to another policy color patch without having to find it again in the color cube or the slider settings.When the Read button is latched, the policy for the most recently active UIPainter window or currently selected display component will be displayed on the policy color patches at the bottom of the tool.  If the Read button is unlatched, or if the most recently active UIPainter window contains a multiple selection, the labels on the policy slots will grey to indicate that the colors still displayed are now only the internal state of the tool.The Apply button causes the currently displayed color policy to be attached to either the most recently active UIPainter window or to whatever components are selected in that window.  Note that the LookPreferences of a window must include a valid color for each of the four symbolic paints; ColoringTool will therefor refuse to remove policy colors from the LookPreferences of a canvas; where no color is provided in the tool's current state, the tool will leave the corresponding color in the canvas' policy undisturbed.Instance Variables:	cubesBrightness	&lt;ValueHolder with: ColorValue&gt;  Brightness setting for the color cube	cubeColors	&lt;OrderedCollection of: &lt;ValueHolder with: ColorValue&gt;  The value holders behind the 'paint chips' in the color cube	colorValue	&lt;ValueHolder with: ColorValue&gt;  The color in the master color patch under the sliders	colorName	&lt;ValueHolder with: String&gt;  The currently selected named color, if any	lookPreferences	&lt;LookPreferences&gt;  The current settings of all four policy colors</body></comment><class><name>MultiSpec</name><environment>UI</environment><super>UI.WidgetSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>propertiesTool style defaultable changeAspect changeDefaultable changeFont changeBorder changeOpaque changeTabable changeDisabled changeInvisible </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>UI.MultiSpec</class-id><body>A MultiSpec is used during editing (w/ properties tool) to hold changes to a collection of specs (multiple selection).  It is thus not a real spec, in that it is never stored in literal form or painted onto a canvas.Instance Variables:	propertiesTool &lt;UIPainterTool&gt;		used to enable and disable components as changes are allowed and disallowed	style	&lt;Symbol | nil&gt;  The key in TextAttributes used for displaying text	defaultable	&lt;Boolean&gt;  Whether a button is the size of a default button	changeAspect	&lt;Boolean&gt;	should the value of aspect in this spec be copied to the selected specs	changeDefaultable	&lt;Boolean&gt;	should the value of defaultable in this spec be copied to the selected specs	changeFont		&lt;Boolean&gt;	should the value of style in this spec be copied to the selected specs	changeBorder	&lt;Boolean&gt;	should the value of isDecorated in this spec be copied to the selected specs	changeOpaque	&lt;Boolean&gt;	should the value of isOpaque in this spec be copied to the selected specs	changeTabable	&lt;Boolean&gt;	should the value of tabable in this spec be copied to the selected specs	changeDisabled	&lt;Boolean&gt;	should the value of initiallyDisabled in this spec be copied to the selected specs	changeInvisible 	&lt;Boolean&gt;	should the value of initiallyInvisible in this spec be copied to the selected specs</body></comment><class><name>UISpecificationTreeModel</name><environment>Tools</environment><super>UI.TreeModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullSpec </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter</category><attributes><package>UIPainter</package></attributes></class><class><name>ColumnReorderTracker</name><environment>Tools</environment><super>UI.SelectionTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>oldCursor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.ColumnReorderTracker</class-id><body>ColumnReorderTracker processes DataSet column reordering mouse events.Instance Variables:	oldCursor	&lt;Cursor&gt;  cursor to be restored after column reordering</body></comment><class><name>ColorBitView</name><environment>Tools</environment><super>Tools.BitView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.ColorBitView</class-id><body>ColorBitView is the magnified image editing view used in UIMaskEditor.</body></comment><class><name>HelpConstructor</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>helpSuppliedByBuilder helpLabeledValueHolder parentBuilderBlock fieldMenuBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Support</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>UI.HelpConstructor</class-id><body>HelpConstructor is the application model for the 'Fly-by Help' property pages in the Propery tool.Instance Variables:	helpSuppliedByBuilder	&lt;ValueHolder on: Boolean&gt;		A value of true indicates the application provides the help message.	helpLabeledValueHolder	&lt;ValueHolder on: (LabeledButtonView | ProgressWidgetView | SliderView | TextEditorView)&gt;	Widget providing help in lieu of application builder.	parentBuilderBlock	&lt;BlockClosure&gt;	Block to obtain application builder.	fieldMenuBlock	&lt;BlockClosure&gt;	Block to obtain view menu.		</body></comment><class><name>DirectBitView</name><environment>Tools</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>policy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.DirectBitView</class-id><body>DirectBitView is used in UIColorTool to show the image being edited in actual scale.Instance Variables:	policy	&lt;OrderedDither&gt;&gt;  Policy used for rendering the colors in the image being edited</body></comment><class><name>UIPainterView</name><environment>Tools</environment><super>UI.CompositeView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.UIPainterView</class-id><body>UIPainterView is the view for a UIPainter.  Its protocol provides for managing the movment of painted components on a canvas.</body></comment><class><name>UIHotRegionEditor</name><environment>Tools</environment><super>Tools.UIPainterWatcher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hotRegions currentSlice selectedSliceChannel modeAdaptor brushAdaptor selectorAdaptor hotRegionView targetClass targetSelector menuBar modified slicesList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Tools</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.UIHotRegionEditor</class-id><body>UIHotRegionEditor allows the creation of mappings between areas and message selectors. The resulting mappings can be installed into an ApplicationModel class as a resource and used by a MappedClickWidget to determine its reaction to clicks. An arbitrary backdrop visual can be loaded to aid in defining the regions. Instance Variables:	hotRegions	&lt;HotRegions&gt;  	currentSlice	&lt;HotSlice&gt;  	selectedSliceChannel	&lt;ValueHolder on: HotSlice&gt;  	modeAdaptor	&lt;AspectAdaptor on: MaskPainterController&gt;  	brushAdaptor	&lt;AspectAdaptor on: MaskPainterController&gt;  	selectorAdaptor	&lt;AspectAdaptor on: HotSlice&gt;  	hotRegionView	&lt;MaskPainterView&gt;  	targetClass	&lt;Class&gt;  	targetSelector	&lt;Symbol&gt;  	menuBar	&lt;Menu&gt;  	modified	&lt;Boolean&gt;  	slicesList	&lt;Collection&gt;  </body></comment><class><name>PositionToolModel</name><environment>Tools</environment><super>Tools.IntegratedSpecModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectionType alignmentX topFraction bottomOffset rightOffset bottomFraction alignmentY leftFraction topOffset leftOffset rightFraction topSlide leftSlide bottomSlide rightSlide alignmentXSlide alignmentYSlide tracking sizeHeight sizeWidth </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Tools</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.PositionToolModel</class-id><body>PositionToolModel is the model used for the position property slice to provide a way to numerically control the position and layout of components on a canvas.  It is a fancier version of the dialog that is obtained when using the UIPainte's layout &gt; constrained command.  The face of the tool looks different depending on whether the currently selected item is a bounded or unbounded figure.The four blank buttons down the right side of the tool's face can be used to clear the corresponding Proportion and Offet fields.  The general paradigm is that a blank field means that the tool is free to readjust values in this part of the selected component's layout frame, in order to preserve the figure's current apparent location, or its shape and size.  Thus, setting a Proportion field with the corresponding Offset field blank will cause this aspect of the component's location to become 'anchored' to the indicated spot in proportional space, without the figure actually seeming to move on the canvas.  If the Offset field is also set to some value, the affected aspect of the component will be changed such that the component actually moves or changes shape.  For example, it the top proportion and offset are specified, but not the bottom proportion or offset, the figure will move in the vertical dimension so as to preserve its current height.  If all of the top and bottom proportions and offsets are specified, the figure will adopt the indicated location in the y dimension, and the indicated height.The iconic buttons in the lower left corner of the tool can be used to convert certain types of bounded figures (i.e. action buttons) into unbounded figures, and vice versa.  The sliders underneath the proportion fields can be used to quickly select any of twelve preset values for these fractions.Instance Variables:	selectionType	&lt;Symbol&gt;  Whether the selection in the current active canvas is unbounded or bounded	alignmentX	&lt;ValueHolder with: &lt;Float | nil&gt;&gt;  Describes the locator inset for an unbounded figure	topFraction	&lt;ValueHolder with: &lt;Float | nil&gt;&gt;  Fractional y component of the figure's origin	bottomOffset	&lt;ValueHolder with: &lt;Integer&gt;&gt;  Absolute y component of the figure's extent	rightOffset	&lt;ValueHolder with: &lt;Integer&gt;&gt;  Absolute x component of the figure's extent	bottomFraction	&lt;ValueHolder with: &lt;Float | nil&gt;&gt;  Fractional y component of the figure's extent	alignmentY	&lt;ValueHolder with: &lt;Float | nil&gt;&gt;  Describes the locator inset for an unbounded figure	leftFraction	&lt;ValueHolder with: &lt;Float | nil&gt;&gt;  Fractional x component of the figure's origin	topOffset	&lt;ValueHolder with: &lt;Integer&gt;&gt;  Absolute y component of the figure's origin	leftOffset	&lt;ValueHolder with: &lt;Integer&gt;&gt;  Absolute x component of the figure's origin	rightFraction	&lt;ValueHolder with: &lt;Float | nil&gt;&gt;  Fractional x component of the figure's extent	topSlide	&lt;TypeConverter&gt;  Model underlying the slider for setting the topFraction	leftSlide	&lt;TypeConverter&gt;  Model underlying the slider for setting the leftFraction	bottomSlide	&lt;TypeConverter&gt;  Model underlying the slider for setting the bottomFraction	rightSlide	&lt;TypeConverter&gt;  Model underlying the slider for setting the rightFraction	alignmentXSlide	&lt;TypeConverter&gt;  Model underlying the slider for setting the alignmentX	alignmentYSlide	&lt;TypeConverter&gt;  Model underlying the slider for setting the alignmentY	tracking	&lt;Boolean&gt;  Used to lock out superfluous updatingClass Variables:	GroupBounded	&lt;Array of: Symbol&gt;  ID's for a coordinated group of widgets	GroupMutual	&lt;Array of: Symbol&gt;  ID's for a coordinated group of widgets	GroupUnbounded	&lt;Array of: Symbol&gt;  ID's for a coordinated group of widgets</body></comment><class><name>DSVDependencyAgent</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bindings spec validationAspects notificationAspects </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.DSVDependencyAgent</class-id><body>DSVDependencyAgent is a helper class used during the painting of a DataSetView. This class is private to the implementation of DataSets.  Other users should not interface to this class and should not subclass it.Instance Variables:	bindings		&lt;Dictionary&gt;  bindings for the DSV currently being edited	spec		&lt;DataSetSpec&gt; spec for the DSV currently being edited	validationAspects	&lt;Array&gt; validation AspectAdaptors	notificationAspects	&lt;Array&gt; notification AspectAdaptors	</body></comment><class><name>CodingAssistant</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classNameChannel instVarList readAccessing writeAccessing dependency finder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.CodingAssistant</class-id><body>CodingAssistant is a simple application that can be used to generate accessing methods for arbitrary classes. An instance of UIDefiner does the real work. Useful in its own right, CodingAssistant demonstrates multi-selection SequenceViews, and the uses of dependency in the coordination of the models underlying the constituent widgets of a user interface.Instance Variables:	classNameChannel	&lt;ValueHolder with: Symbol&gt;  Holds the name of the class	instVarList	&lt;MultiSelectionInList&gt;  Holds the user's indications of which variables are to be provided for	readAccessing	&lt;ValueHolder with: Boolean&gt;  Whether to generate read accessors	writeAccessing	&lt;ValueHolder with: Boolean&gt;  Whether to generate write accessors	dependency	&lt;ValueHolder with: Boolean&gt;  Whether to generate write accessors which send change notification</body></comment><class><name>PaintTracker</name><environment>UI</environment><super>UI.SelectTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>UI.PaintTracker</class-id><body>PaintTracker serves as the SelectionTracker for instances of MaskPainterController. By not "collapsing" mouse-moved events, rapidly painted strokes may be more accurately represented. </body></comment><class><name>DataSetSpecColumnModel</name><environment>Tools</environment><super>Tools.IntegratedSpecModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectionChannel currentColumn label labelFromApplication width labelFont modelGen columnType changedBlock labelIsImage frozen lock allowSorting allowResizing </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.DataSetSpecColumnModel</class-id><body>DataSetSpecColumnModel is the model behind the Column slice of a DataSetView.  It is responsible for holding values for the column's properties until the values are either accepted or canceled.Instance Variables:	selectionChannel	&lt;ValueHolder on: Integer&gt; selected column number	currentColumn	&lt;ValueHolder on: DataSetColumnSpec&gt;  column spec begin edited	label	&lt;AspectAdaptor&gt;  the column label, kept in the currentColumn	width	&lt;AspectAdaptor&gt;  width in pixels of currentColumn	labelFont	&lt;ValueHolder on: Symbol&gt;  the label font name (e.g., #system, #default, ...)	modelGen	&lt;ValueHolder on: String&gt; model aspect for the current column	columnType	&lt;ValueHolder on: Symbol&gt;	changedBlock	&lt;BlockClosure&gt; block evaluated when a property is changed	typeChoices	&lt;AspectAdaptor&gt; choices aspect for currentColumn if ComboBox	typeSize	&lt;AspectAdaptor&gt; field size for currentColumn	typePopup	&lt;ValueHolder on: Boolean&gt; whether menus are popup or pull down	typeAlign	&lt;ValueHolder on: Symbol&gt; alignment of current column	typeMenu	&lt;AspectAdaptor&gt;  menu aspect for currentColumn	typeFont		&lt;ValueHolder on: Symbol&gt;  font name for currentColumn	typeDataType	&lt;ValueHolder on: Symbol&gt; type of currentColumn	typeDataFormat	&lt;ValueHolder on: String&gt;  selected format String (or nil)	defaultFormats	&lt;ValueHolder on: List&gt; collection of default format Strings	checkBoxLabel	&lt;AspectAdaptor&gt;	labelIsImage	&lt;ValueHolder on: Boolean&gt; whether the label is a VisualComponent	frozen	&lt;ValueHolder on: Boolean&gt;  whether the current column should scroll horizontally	lock	&lt;Boolean&gt;  whether the current column can be edited or not	readSelector	&lt;ValueHolder on: Symbol&gt;  message to send to a String to return an Object for the ComboBox list	printSelector	&lt;ValueHolder on: Symbol&gt; message to send to an Object in a ComboBox list for display	</body></comment><class><name>ResourceInstallDialog</name><environment>Tools</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectorHolder existingSelectorsHolder classModule resourceType classCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Tools</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.ResourceInstallDialog</class-id><body>ResourceInstallDialog is used to query the user for a MethodDefinition for a target resource (e.g. #menu method).UsageHere's an example that shows opening the receiver with a given class, resourceType, and defaultSelector.(ResourceInstallDialog new)	targetClass: ResourceInstallDialog;	selector: #windowSpec;	resourceType: #canvas;	selectThe result of the select will be either a MethodDefinition of the targetClass&gt;&gt;selector, or nil if cancelled.Instance Variables	classModule	&lt;EntryWithPasteButtonModule&gt;	used to prompt for the class	existingSelectorsHolder	&lt;ValueModel of: List&gt; the existing methods for the selected class	resourceType	&lt;Symbol&gt;	resource type to filter on (e.g. #menu, #canvas, #image, etc)	selectorHolder	&lt;ValueModel of: String&gt;	selector name	classCache		&lt;IdentitySet of: Class&gt;	cache of all classes defined in image.</body></comment><class><name>DataSetEditTracker</name><environment>Tools</environment><super>Tools.DrawingModeTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>oldMode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Modes</category><attributes><package>UIPainter</package></attributes></class><class><name>WindowOpenPositionToolModel</name><environment>Tools</environment><super>Tools.IntegratedSpecModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>openType width height minimumHeight minimumWidth maximumHeight maximumWidth yPosition xPosition sizeType positionType sizeAutoSave positionAutoSave </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Tools</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.WindowOpenPositionToolModel</class-id><body>WindowOpenPositionToolModel is the model used for the Position/Size property slice of a window.Instance Variables:	openType		&lt;Symbol&gt;	#systemDefault, #userPlacement or #advanced.	width				&lt;Integer&gt;		Specified/Preferred width of the current canvas	height				&lt;Integer&gt;		Specified/Preferred height of the current canvas	minimumHeight	&lt;Integer&gt;		Current minimum height of the open canvas	minimumWidth	&lt;Integer&gt;		Current minimum width of the open canvas	maximumHeight	&lt;Integer&gt;		Current maximum height of the open canvas	maximumWidth	&lt;Integer&gt;		Current maximum width of the open canvas	yPosition			&lt;Integer&gt;		If the opening position is specifed, then the y coordinate for that origin	xPosition			&lt;Integer&gt;		If the opening position is specifed, then the x coordinate for that origin	sizeType			&lt;Symbol&gt;	#lastSavedSize or #specifiedSize	positionType		&lt;Symbol&gt;	#screenCenter, #mouseCenter, #lastSavedPostion, #cascade or #specifiedPosition	sizeAutoSave		&lt;Boolean&gt;	Determine state of autoSave for Size, if #lastSavedSize is the sizeType	positionAutoSave	&lt;Boolean&gt;	Determine state of autoSave for Position, if #lastSavedPosition is the positionType</body></comment><class><name>BitEditor</name><environment>Tools</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>foreground background imageHasChanged </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.BitEditor</class-id><body>BitEditor is the controller used by BitView, which is the image editing view that forms the basis for UIMaskEditor.Instance Variables:	black	&lt;Integer&gt;  Cache for the actual palette index of ColorValue black	white	&lt;Interger&gt;  Cache for the actual palette index of ColorValue white	imageHasChanged	&lt;Boolean&gt;  Whether the image has been changed since it was last Installed or Applied</body></comment><class><name>SelectPlacementModeTracker</name><environment>Tools</environment><super>Tools.SpecPlacementModeTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Modes</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.SelectPlacementModeTracker</class-id><body>SelectPlacementMode is the kind of PlacementMode with which the new component first appears when the 'select' mouse button is pressed, and is then dragged with the mouse button held down.  Used by UIPainterController.</body></comment><class><name>LabelAndValue</name><environment>UI</environment><super>Core.LookupKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>UI.LabelAndValue</class-id><body>LabelAndValue may be used to represent a value for selection in a SequenceView or similar but display a String or VisualComponent for it as key.  Note this is equivalent to using an Association.Instance Variables:	value	&lt;Object&gt;	object represented by key</body></comment><class><name>DataSetCallbacksSpecModel</name><environment>Tools</environment><super>Tools.IntegratedSpecModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>focusInSelector valueChangeSelector focusOutSelector currentColumn selectionChannel requestFocusInSelector requestValueChangeSelector requestFocusOutSelector trigger doubleClickSelector requestDoubleClickSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.DataSetCallbacksSpecModel</class-id><body>DataSetCallbacksSpecModel is the model behind the Validation and Notification slices of a DataSetView.  It is responsible for holding values for the callbacks until the values are either accepted or canceled.Instance Variables:	focusInSelector	&lt;BufferedValueHolder on: AspectAdaptor&gt; Connects the input field to the domain model's 'focusInSelector' aspect	valueChangeSelector	&lt;BufferedValueHolder on: AspectAdaptor&gt; Connects the input field to the domain model's 'valueChangeSelector' aspect	focusOutSelector	&lt;BufferedValueHolder on: AspectAdaptor&gt; Connects the input field to the domain model's 'focusOutSelector' aspect	currentColumn	&lt;ValueHolder on: DataSetColumnSpec&gt; ValueHolder on the DataSetColumnSpec for which the callbacks are currently being edited	selectionChannel	&lt;ValueHolder on: Integer&gt; ValueHolder on the index of the currently selected column in the DataSetView currently being edited.	requestFocusInSelector	&lt;BufferedValueHolder on: AspectAdaptor&gt; Connects the input field to the domain model's 'requestFocusInSelector' aspect	requestValueChangeSelector	&lt;BufferedValueHolder on: AspectAdaptor&gt; Connects the input field to the domain model's 'requestValueChangeSelector' aspect	requestFocusOutSelector	&lt;BufferedValueHolder on: AspectAdaptor&gt; Connects the input field to the domain model's 'requestFocusOutSelector' aspect	trigger	&lt;ValueHolder on: Boolean&gt;	ValueHolder used to trigger all of the instance's BufferedValueHolders	doubleClickSelector	&lt;BufferedValueHolder on: AspectAdaptor&gt; Connects the input field to the domain model's 'focusInSelector' aspect	requestDoubleClickSelector	&lt;BufferedValueHolder on: AspectAdaptor&gt; Connects the input field to the domain model's 'requestFocusInSelector' aspect	</body></comment><class><name>UIPainterController</name><environment>Tools</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentMode oldPoint showGrid gridStep griddedHorizontally griddedVertically fenced primarySelection selections handles canvasHasChanged </inst-vars><class-inst-vars></class-inst-vars><imports>			private Smalltalk.TextConstants.*			</imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.UIPainterController</class-id><body>UIPainterController is the controller for a UIPainter, and this class is where many of the operations afforded by UIPainters are actually implemented.Instance Variables:	showGrid	&lt;ValueHolder with: Symbol&gt;  #Show, #Hide or #'Show If On', the possible settings for displaying the grid	gridStep		&lt;ValueHolder with: SmallInteger&gt;		Value of the grid size	griddedHorizontally	&lt;ValueHolder with: Boolean&gt;  Whether to constrain placement and movement in the x dimension	griddedVertically	&lt;ValueHolder with: Boolean&gt;  Whether to constrain placement and movement in the y dimension	fenced	&lt;ValueHolder with: Boolean&gt;  Whether to constrain placment and movement so that all of each component is visible on the canvas	primarySelection	&lt;SpecWrapper | nil&gt;  Whatever component was selected first, if sweep selection was not employed	selections	&lt;Array of: SpecWrapper&gt;  The remaining components comprising the current selection	handles	&lt;OrderedCollection of: DragHandle&gt;  The handle objects used for repositioning the selected components	canvasHasChanged	&lt;Boolean&gt;  Whether the canvas has changed since it was last installedClass Variables:	KeyboardDispatchTable	&lt;DispatchTable&gt;  Used for interpreting keyboard input as commands to the UIPainterController and its UIPainter	LastControllerWithSelection	&lt;&lt;ValueHolder with: UIPainterController&gt; | nil&gt;  Used to alert UIPainterWatchers to changes in activity and selection	MultiSelectMenu	&lt;Menu&gt;  Menu to be used when more than one component is selected	NoSelectMenu	&lt;Menu&gt;  Menu to be used when no components are selected	OperationParameters		&lt;Dictionary key: Symbol value: ValueModel&gt;  Users last settings for the align, distribute, and equalize dialogs	Scrap	&lt;SpecCollection | nil&gt;  The secondary selections as they were copied or cut to the paste buffer	ScrapPrimary	&lt;SpecCollection | nil&gt;  The primary selection as it was copied or cut to the paste buffer	SingleSelectMenu	&lt;Menu&gt;  Menu to be used when a single component is selected	StickyMode	&lt;ValueHolder with: Boolean&gt;  Whether or not the global palette is in 'repeat' mode</body></comment><class><name>ColorBitEditor</name><environment>Tools</environment><super>Tools.BitEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentColor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.ColorBitEditor</class-id><body>ColorBitEditor is the controller used by ColorBitView, which is the image editing view that forms the basis for color support in UIMaskEditor.Instance Variables:	currentColor		&lt;Integer&gt;	Cache for the actual palette index of the current ColorValue</body></comment><class><name>MaskPainterController</name><environment>UI</environment><super>UI.SelectController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>editMask mode brush brushCursor coveragePaint oldCursor geometricInProgress originInProgress undoBuffer constrainAxis </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>UI.MaskPainterController</class-id><body>MaskPainterController allows bitmap-painting of a Depth1Image. All editing is done on a scratch Mask. Instance Variables:	editMask	&lt;Mask&gt;  	mode	&lt;Symbol&gt;  	brush	&lt;Controller&gt;  	brushCursor	&lt;Cursor&gt;  	coveragePaint	&lt;CoverageValue&gt;  	oldCursor	&lt;Cursor&gt;  	geometricInProgress	&lt;Rectangle | EllipticalArc&gt;  	originInProgress	&lt;Point&gt;  	undoBuffer	&lt;Mask&gt; 	constrainAxis	&lt;Symbol&gt;  #x, #y, or nilClass Variables:	FillCursor	&lt;Cursor&gt; </body></comment><class><name>BitEditorTracker</name><environment>Tools</environment><super>UI.SelectionTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lastPoint color </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Trackers</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.BitEditorTracker</class-id><body>A specialized tracker for BitEditor, BitEditorTracker maps the current cursor location to a pixel in the editing image. Instance Variables:	lastPoint	&lt;Point&gt;	The most recent image point, created by mapping the previous mouse				location onto the corresponding pixel location in the BitEditor	color		&lt;ColorValue&gt;	The color of the pixel at lastPoint of the image. For BitEditor,					valid values are black or white.</body></comment><class><name>UIFinderVW2</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classNameList selectorList iconList filter menuBar addWhat partSortType updateTrigger lastCategory menuBarMenuWithSelection menuBarMenuWithNoCanvasSelected menuBarMenuWithNoSelection classListMenuWithSelection classListMenuForNoSelection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Tools</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.UIFinderVW2</class-id><body>UIFinderVW2 is a specialized browser that finds UIPainter canvases and Lens Data models and the application classes that use them.  The lefthand (class) pane of the finder shows only these classes.  This list can be further filtered according to whether the classes are user-defined, original system equipment, were recently worked with or based on the category the classes belong to.  The righthand (application resources) pane displays list of resources contained in the class selected in the lefthand pane. The menu in the class pane and under the 'View' button on the menu bar provides for selecting among these filters, and for updating the list of classes after filing or defining classes via Browser, FileList or ChangeList.  The class pane is automatically updated as new canvases are installed from UIPainter, or added or removed via the UIFinderVW2.The Start button can be used to run applications that provide an instance method for 'open', or that adhere to certain conventions for subclasses of ApplicationModel.  The Browse button or a double-click on a class name in the class pane can be used to open a browser on the selected class.  An item in the Settings allows a choice between ordinary Class Browsers and Hierarchy Browsers.  The Add and Remove buttons can be used to add new classes to the system and remove existing ones (if no selection is made in the right hand pane of the finder) or to add a canvas to an existing class.  The Edit button or a double click on a resource name in the righthand pane opens an appropriate editor on the specification selected in the right hand pane of the finder.Instance Variables:	classNameList	&lt;SelectionInList&gt;  The model behind the class pane	selectorList		&lt;SelectionInList&gt;  The model behind the canvas pane	filter			&lt;Symbol&gt;  What sorts of application classes are to be shown in the class pane	menuBar		&lt;ValueHolder with: Menu&gt;  The (dynamic) menu bar menu	addWhat 		&lt;Symbol&gt; Result of the add dialog with the user.	partSortType	&lt;ValueHolder with: Symbol&gt; How are the names of application elements to be sorted.	iconList			&lt;List&gt; list of associations where each name of the resource is paired-up with a corresponding icon.	updateTrigger	&lt;ValueHolder with: Symbol&gt; releases the buffered value holders.	lastCategory	&lt;Symbol&gt;		non-nil result of the class catgory selection dialog	menuBarMenuWithNoCanvasSelected	&lt;Menu&gt;  Used when a class, but not a canvas, is selected	menuBarMenuWithNoSelection	&lt;Menu&gt;  Used when no class is selected	menuBarMenuWithSelection	&lt;Menu&gt;  Used when both a class and canvas are selected	classListMenuForNoSelection	&lt;Menu&gt;  Used when no class is selected	classListMenuWithSelection	&lt;Menu&gt;  Used when a class is selectedClass Variables:	RecentlyVisitedClasses	&lt;OrderedCollection of: Symbol&gt;  The last ten classes visited using UIFinderVW2 or UIPainter	SelListMenuForNoSelection	&lt;Menu&gt;  Used when no canvas is selected	SelListMenuWithSelection	&lt;Menu&gt;  Used when a canvas is selected	SpecBearingClasses	&lt;Set of: Symbol&gt;  Names of all classes currently known to have interface specs	CanvasIcon		&lt;OpaqueImage&gt; image used for canvases	ImageIcon		&lt;OpaqueImage&gt; image used for images	MenuIcon		&lt;OpaqueImage&gt; image used for menus	ModelIcon		&lt;OpaqueImage&gt; image used for data models	QueryIcon		&lt;OpaqueImage&gt; image used for queries	SpecBearingCategories	&lt;Set of: Symbol&gt;  Names of all class categories for classes in SpecBearingClasses	 </body></comment><class><name>ColorBitEditorTracker</name><environment>Tools</environment><super>Tools.BitEditorTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Trackers</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.ColorBitEditorTracker</class-id><body>A specialized tracker for ColorBitEditor.</body></comment><class><name>UIPainterIcons</name><environment>Tools</environment><super>AlphaBlendedIcons</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>UIPainter</package></attributes></class><class><name>PaintedDataSetController</name><environment>Tools</environment><super>UI.DataSetController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><comment><class-id>Tools.PaintedDataSetController</class-id><body>A PaintedDataSetController determines the selection and column resizing behavior for a PaintedDataSetView (a DataSetView that is being painted on a canvas).  Resizing of columns is delegated to ColumnResizeAgent when appropriate. The PaintedDataSetView cannot be scrolled or otherwise used in the normal fashion.This class is private to the implementation of UILookPolicy and should not by subclasses or referenced.</body></comment><shared-variable><name>InactiveMask</name><environment>Tools.UIPainterView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>ActiveSpecsList</name><environment>Tools.UIPalette</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>CurrentMode</name><environment>Tools.UIPalette</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>PasteBuffer</name><environment>Tools.UIMaskEditor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>TypeIcons</name><environment>Tools.UIFinderVW2</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>SelListMenuForNoSelection</name><environment>Tools.UIFinderVW2</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>SpecBearingClasses</name><environment>Tools.UIFinderVW2</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>SpecBearingCategories</name><environment>Tools.UIFinderVW2</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>SelListMenuWithSelection</name><environment>Tools.UIFinderVW2</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>RecentlyVisitedClasses</name><environment>Tools.UIFinderVW2</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>FillCursor</name><environment>UI.MaskPainterController</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>AdjustmentCursor</name><environment>Tools.ColumnReorderAgent</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>KeyboardDispatchTable</name><environment>Tools.UIPainterController</environment><private>false</private><constant>false</constant><category>Misc</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>MultiSelectMenu</name><environment>Tools.UIPainterController</environment><private>false</private><constant>false</constant><category>Menus</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>NoSelectMenu</name><environment>Tools.UIPainterController</environment><private>false</private><constant>false</constant><category>Menus</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>OperationParameters</name><environment>Tools.UIPainterController</environment><private>false</private><constant>false</constant><category>Misc</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>PreviewFileName</name><environment>Tools.UIPainterController</environment><private>false</private><constant>false</constant><category>Wave Support</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>StickyMode</name><environment>Tools.UIPainterController</environment><private>false</private><constant>false</constant><category>Misc</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>SingleSelectMenu</name><environment>Tools.UIPainterController</environment><private>false</private><constant>false</constant><category>Menus</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>Scrap</name><environment>Tools.UIPainterController</environment><private>false</private><constant>false</constant><category>Scrap Stacks</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>ScrapPrimary</name><environment>Tools.UIPainterController</environment><private>false</private><constant>false</constant><category>Scrap Stacks</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>LastControllerWithSelection</name><environment>Tools.UIPainterController</environment><private>false</private><constant>false</constant><category>Misc</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>PasteBuffer</name><environment>Tools.MenuEditor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>Masks</name><environment>Tools.MenuEditor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>UIPainter</package></attributes></shared-variable><shared-variable><name>InactiveMasks</name><environment>Tools.MenuEditor</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>UIPainter</package></attributes></shared-variable><methods><class-id>Tools.ColumnReorderAgent</class-id> <category>event driven</category><body package="UIPainter">mouseMovedTo: aPoint	(aPoint x between: columnRanges first and: columnRanges last) ifFalse: 		[aPoint x &gt; columnRanges first			ifTrue: [self moveRight]			ifFalse: [self moveLeft]].		controller checkScrollingFrom: aPoint.</body></methods><methods><class-id>Tools.ColumnReorderAgent</class-id> <category>interaction</category><body package="UIPainter">adjustmentCursor 	^AdjustmentCursor</body><body package="UIPainter">moveLeft	| selectionIndex view |	controller view selectionIndex == leftLimit ifTrue: [^self].	columnRanges := controller view 		xRangesFor: (selectionIndex := (view := controller view) selectionIndex) 		inBounds: view bounds.	view invalidateColumn: selectionIndex.	view switchColumnIndex: selectionIndex withIndex: selectionIndex - 1.	view setSelectionIndex: selectionIndex - 1.	view topComponent displayPendingInvalidation. 		columnRanges := view xRangesFor: selectionIndex - 1 inBounds: view bounds</body><body package="UIPainter">moveRight	| selectionIndex view |	controller view selectionIndex == columnSize ifTrue: [^self].	columnRanges := controller view 		xRangesFor: (selectionIndex := (view := controller view) selectionIndex) 		inBounds: view bounds.	view invalidateColumn: selectionIndex + 1.	view invalidateColumn: selectionIndex.	view switchColumnIndex: selectionIndex withIndex: selectionIndex + 1.	view setSelectionIndex: selectionIndex + 1.	view topComponent displayPendingInvalidation.	columnRanges := view xRangesFor: selectionIndex + 1 inBounds: view bounds</body></methods><methods><class-id>Tools.ColumnReorderAgent</class-id> <category>initialize-release</category><body package="UIPainter">controller: aController	super controller: aController.	columnSize := controller view columnDescriptors size.	(controller view columnDescriptors at: 1) rendererSpec == #rowSelector		ifTrue: [leftLimit := 2]		ifFalse: [leftLimit := 1].	columnRanges := controller view xRangesFor: controller view selectionIndex inBounds: controller view bounds.</body></methods><methods><class-id>Tools.ColumnReorderAgent class</class-id> <category>class initialization</category><body package="UIPainter">initialize	"self initialize"	AdjustmentCursor := Cursor		imageArray: #(			2r0000000000000000			2r0000000000000000			2r0000000000000000			2r0000000000000000			2r0000110000110000			2r0001100000011000			2r0011000000001100			2r0111111111111110			2r0011000000001100			2r0001100000011000			2r0000110000110000			2r0000000000000000			2r0000000000000000			2r0000000000000000			2r0000000000000000			2r0000000000000000	)		maskArray: #(			2r0000000000000000			2r0000000000000000			2r0000000000000000			2r0000111001110000			2r0001111001111000			2r0011110000111100			2r0111111111111110			2r1111111111111111			2r0111111111111110			2r0011110000111100			2r0001111001111000			2r0000110000110000			2r0000000000000000			2r0000000000000000			2r0000000000000000			2r0000000000000000	)			hotSpot: 8@8			name: 'absoluteHorizontal'.</body></methods><methods><class-id>Tools.DrawingModeTracker</class-id> <category>private</category><body package="UIPainter">stretchRectangle: rect from: start to: new 	^self class stretchRectangle: rect from: start to: new</body></methods><methods><class-id>Tools.DrawingModeTracker</class-id> <category>drag drop</category><body package="UIPainter">noFeedback: aSymbol dropSource: aDropSource	^false</body></methods><methods><class-id>Tools.DrawingModeTracker class</class-id> <category>drag drop</category><body package="UIPainter">stretchRectangle: rect from: start to: new 	| delta |	delta := new - start.	start = rect origin		ifTrue: [^Rectangle vertex: rect origin + delta vertex: rect corner].	start = rect corner		ifTrue: [^Rectangle vertex: rect origin vertex: rect corner + delta].	start = rect topRight		ifTrue: [^Rectangle vertex: rect topRight + delta vertex: rect bottomLeft].	^Rectangle vertex: rect bottomLeft + delta vertex: rect topRight.</body></methods><methods><class-id>Tools.DragModeTracker</class-id> <category>private</category><body package="UIPainter">adjust: aPoint toGrid: aConstrainingPoint	| constraintSize |	aPoint x abs &gt; (constraintSize := aConstrainingPoint x)		ifTrue: [aPoint x: ((aPoint x quo: constraintSize) * constraintSize)]		ifFalse: [aPoint x: 0].	aPoint y abs &gt; (constraintSize := aConstrainingPoint y)		ifTrue: [aPoint y: ((aPoint y quo: constraintSize) * constraintSize)]		ifFalse: [aPoint y: 0].</body><body package="UIPainter">containedPointFor: pt and: aRectangle in: box	^((pt x min: box right  - aRectangle width ) max: box left) @	((pt y min: box bottom  - aRectangle height) max: box top)</body><body package="UIPainter">containedPointFor: pt  in: box	^((pt x min: box right  ) max: box left) @	((pt y min: box bottom ) max: box top)</body><body package="UIPainter">newPoint: aPoint exceedsGrid: aConstrainingPoint 	"Answer if the new point is at least more than the 	constraining point's value"	| gridPointTest |	gridPointTest := (aPoint - lastShowPoint) abs.	^gridPointTest x &gt; aConstrainingPoint x or: [gridPointTest y &gt; aConstrainingPoint y]</body><body package="UIPainter">trackingBoxFor: selections	| trackingBox |	trackingBox := nil.	selections do: [:s | 		trackingBox == nil			ifTrue: [trackingBox := s bounds]			ifFalse: [trackingBox := trackingBox merge: s bounds]].	^trackingBox</body></methods><methods><class-id>Tools.DragModeTracker</class-id> <category>drag drop</category><body package="UIPainter">dragObject: anObject startingAt: aPoint inController: aController 	| oldMode |	lastShowPoint := aPoint.	dragObject := anObject.	oldMode := (controller := aController) currentMode value.	[controller currentMode setValue: self.	self startDragDrop]		ensure:[controller currentMode setValue: oldMode].</body><body package="UIPainter">dragOverWidgets: aDragDropContext	self subclassResponsibility</body><body package="UIPainter">preDragDrop	"default do nothing"</body><body package="UIPainter">setupDropData: aDragDropData	"Default, do nothing"</body><body package="UIPainter">startDragDrop	| data dropSource |	controller hideHandles.	self preDragDrop.	data := DragDropData new.	data contextWindow: controller builder window.	data contextWidget: controller.	data contextApplication: self.	self setupDropData: data.	dropSource := ConfigurableDropSource new.	dropSource		giveFeedbackSelector: #noFeedback:dropSource:;		receiver: self.	(DragDropManager			withDropSource: dropSource			withData: data) doDragDrop.	controller canvasHasChanged: true.	controller showHandles</body></methods><methods><class-id>Tools.DividerResizingDragModeTracker</class-id> <category>drag drop</category><body package="UIPainter">dragOverWidgets: aDragDropContext	| currentPoint targetBounds oneAxisOnlyPoint controllerGrid |	(currentPoint := controller sensor mousePoint) = lastShowPoint ifTrue: [^self].	controllerGrid := controller gridValue.	oneAxisOnlyPoint := horizontal		ifFalse: [currentPoint x @ lastShowPoint y]		ifTrue: [lastShowPoint x @ currentPoint y].	controller isFenced ifTrue: 		[currentPoint := self 			containedPointFor: oneAxisOnlyPoint 			in: controller view bounds].	self adjust: oneAxisOnlyPoint toGrid: controllerGrid.	oneAxisOnlyPoint = lastShowPoint ifTrue: [^self].	targetBounds := self stretchRectangle: originalBounds from: lastShowPoint to: oneAxisOnlyPoint.	controller view		newBounds: targetBounds		oldBounds: originalBounds		forWrapper: dragObject wrapper.	originalBounds := targetBounds.	lastShowPoint := oneAxisOnlyPoint</body><body package="UIPainter">preDragDrop	lastShowPoint := dragObject getOrigin.	originalBounds := dragObject wrapper bounds.	horizontal := dragObject wrapper spec orientation = #vertical</body></methods><methods><class-id>Tools.UIPainter</class-id> <category>accessing</category><body package="UIPainter">acceptedState	^acceptedState</body><body package="UIPainter">acceptedState: aSpec	acceptedState := aSpec</body><body package="UIPainter">activeWrapper	"answer the receiver's active wrapper."	^self builder wrapper</body><body package="UIPainter">builderComponentWrappers	^builder composite components select: [:each | each isKindOf: SpecWrapper]</body><body package="UIPainter">definer	^definer</body><body package="UIPainter">definer: aUIDefiner	definer := aUIDefiner</body><body package="UIPainter">maxWindowExtent	^maxWindowExtent</body><body package="UIPainter">maxWindowExtent: aPoint	maxWindowExtent := aPoint</body><body package="UIPainter">minWindowExtent	^minWindowExtent</body><body package="UIPainter">minWindowExtent: aPoint	minWindowExtent := aPoint</body><body package="UIPainter">parentUIPainter	^nil</body><body package="UIPainter">prefWindowExtent	^prefWindowExtent isNil ifTrue: [builder window bounds extent] ifFalse: [prefWindowExtent]</body><body package="UIPainter">prefWindowExtent: aPoint	prefWindowExtent := aPoint</body><body package="UIPainter">targetClass	(targetClass notNil and: [targetClass isObsolete])		ifTrue:			[targetClass := nil].	^targetClass</body><body package="UIPainter">targetClass: aClass	targetClass := aClass.	builder source: aClass.	definer setClass: aClass</body><body package="UIPainter">targetSelector	^targetSelector</body><body package="UIPainter">targetSelector: aSelector	targetSelector := aSelector</body><body package="UIPainter">view	^self findPainterController view</body><body package="UIPainter">windowSpec	^windowSpec</body><body package="UIPainter">windowSpec: aWindowSpec	windowSpec := aWindowSpec</body></methods><methods><class-id>Tools.UIPainter</class-id> <category>private</category><body package="UIPainter">applyWindowSpec	| win min max bounds |	win := builder window.	(windowSpec labelInBuilder: builder) ifNotNil: [:label| win label: label].	(min := windowSpec min) notNil		ifTrue: [self minWindowExtent: min].	(max := windowSpec max) notNil		ifTrue: [self maxWindowExtent: max].	(bounds := windowSpec bounds) notNil		ifTrue:  [self prefWindowExtent: bounds extent].	builder policy		finalHookupWindow: windowSpec		component: builder window component		into: builder</body><body package="UIPainter">extractFullSpec	|  spec |	spec := self defaultSpecClass new.	spec window: self makeWindowSpec.	spec component: self extractSpecCollection.	^spec</body><body package="UIPainter">extractSpecCollection	"Be sneaky and recycle the actual Specs, so that some trace of 	component identity can survive in the copy."	^SpecCollection new extractFromCollection: self builderComponentWrappers</body><body package="UIPainter">findPainterController	| targetComponent |	targetComponent := [self mainWindow notNil ifTrue: [self mainWindow component component]]		on: MessageNotUnderstood		do: [:exception | exception return: nil].	^(targetComponent isNil or: [(targetComponent isKindOf: UIPainterView) not])		ifFalse: [targetComponent controller]		ifTrue: [(self dependents detect: [:dep | dep isKindOf: UIPainterView] ifNone: [^nil]) controller]</body><body package="UIPainter">findPainterTool	| painterToolView |	painterToolView := nil.	UIPainterTool someInstance notNil ifTrue:		[ScheduledWindow scheduledControllers do:			[:each |			[((each model isKindOf: UIPainterTool) and: [each view isOpen]) ifTrue: [painterToolView := each view]]				on: Object errorSignal				do: [:ex | ex return]]].	^painterToolView</body><body package="UIPainter">findPalette	| paletteView |	paletteView := nil.	UIPalette someInstance notNil ifTrue:		[Screen default allScheduledControllersDo:			[:each |			[((each model isKindOf: UIPalette) and: [each view isOpen]) ifTrue: [paletteView := each view]]				on: Object errorSignal				do: [:ex | ex return]]].	^paletteView</body><body package="UIPainter">fixBuildersWindow	builder fixWindowWith: windowSpec</body><body package="UIPainter">installInSystem	self defaultSpecClass		store: self makeFullSpec		toClass: self targetClass class		methodName: self targetSelector.	Transcript cr; show: ((#x1s2sDefined &lt;&lt; #UIPainter &gt;&gt; '&lt;1s&gt;%&gt;&lt;2s&gt; defined')			expandMacrosWith: self targetClass class name			with: self targetSelector).	UIFinderVW2 installed: (Array with: self targetClass with: self targetSelector).	self accept</body><body package="UIPainter">makeFullSpec	|  spec |	spec := self defaultSpecClass new.	spec window: self makeWindowSpec.	spec component: self makeSpecCollection.	^spec</body><body package="UIPainter">makeSpecCollection	^SpecCollection new fromCollection: self builderComponentWrappers</body><body package="UIPainter">makeWindowSpec	| win |	win := builder window.	windowSpec min: self minWindowExtent.	windowSpec max: self maxWindowExtent.	windowSpec labelFromApplication ifFalse: [windowSpec label: win label].	windowSpec bounds:		(Rectangle			origin: win displayBox origin			extent:				(self prefWindowExtent notNil					ifTrue: [self prefWindowExtent]					ifFalse: [win displayBox extent])).	"windowSpec colors: win getLookPreferences."	^windowSpec</body><body package="UIPainter">noticeOfWindowClose: aWindow	self release.	super noticeOfWindowClose: aWindow.</body><body package="UIPainter">openOnLiteralArray: anArray	^self openOnSpec:		(self defaultSpecClass decodeFromLiteralArray: anArray)</body><body package="UIPainter">openOnSpec: aFullSpec	self setupBuilder.	windowSpec := aFullSpec window.	builder add: aFullSpec component.	self applyWindowSpec.	self openPainterWindows: windowSpec</body><body package="UIPainter">openPainterTool	self openPainterToolFor: self view topComponent.</body><body package="UIPainter">openPainterToolFor: mainWindow	"Make sure that if a satellite palette exists and is collapsed that	it does not expand also."	| existingPainterTool |	(existingPainterTool := self findPainterTool) notNil 		ifTrue:			[existingPainterTool displayBox:				((UIPainter					painterToolPlaceNear: self findPalette					bounds: existingPainterTool bounds extent) extent: existingPainterTool bounds extent).			mainWindow 				when: #closing send: #canvasClosing to: existingPainterTool model;				when: #gettingFocus send: #canvasRequestsFocus: to: existingPainterTool model with: self.			existingPainterTool isCollapsed					ifTrue: [existingPainterTool expand]					ifFalse: [existingPainterTool raise]]		ifFalse:			[UIPainterController lastControllerWithSelectionChannel value: builder composite controller.			self findPalette isNil ifTrue: [self openPaletteFor: mainWindow].			(self openPainterToolNear: self findPalette)]</body><body package="UIPainter">openPainterToolNear: mainWindow	| painterBuilder painterTool |	painterTool := UIPainterTool new.	painterBuilder :=  painterTool allButOpenInterface: #windowSpec.	painterBuilder openAt: (self class painterToolPlaceNear: mainWindow bounds: painterBuilder window extent).	painterTool postOpenWith: painterBuilder.	(painterBuilder window) 		application: self; 		model: painterTool.	self mainWindow 			when: #closing send: #canvasClosing to: painterTool;			when: #gettingFocus send: #canvasRequestsFocus: to: painterTool with: self.	^painterBuilder window</body><body package="UIPainter">openPainterWindows: winSpec 	"Used by all the various opening methods -- except when spawning. 	Depending on user preferences, may open a satellite palette or (possibly 	in the future) other auxiliary windows, as well as the builder window used 	for interface painting. Do the initial 'accept' for the user. If the host 	window manager is OpenWindows, delay awhile in the fond hope that 	the window manager's information will eventually stabilize.	The value of mainWindow minimumSize and maximumSize will set the 	actual range of sizes available through the host window manager's 	controls. The range of sizes available through VW's window control 	menu will be controlled by minWindowExtent and maxWindowExtent."	| mainWindow ctrlr |	(mainWindow := builder window) application: self.	mainWindow controller: UIPainterSystemController new.	mainWindow label: (winSpec labelInBuilder: builder).	mainWindow minimumSize: WindowSpec initialMin.	(UIPainter preferenceFor: #maximumCanvasWidth) ifNil: [UIPainter initialize].	mainWindow maximumSize: (UIPainter preferenceFor: #maximumCanvasWidth)			@ (UIPainter preferenceFor: #maximumCanvasHeight).	winSpec colors ifNotNil: [:colors| mainWindow lookPreferences: colors].	winSpec bounds ifNil: [winSpec bounds: (Screen default bounds center extent: 200 @ 200)].	builder openWithoutHookupFromWindowSpec: winSpec.	self openPaletteFor: mainWindow.	[self findPalette isNil] whileTrue: [Processor yield].	self openPainterToolFor: mainWindow.	(ctrlr := self findPainterController) notNil ifTrue: [ctrlr becomeLastControllerWithSelection].	self accept</body><body package="UIPainter">openPaletteFor: mainWindow	"Make sure that if canvas controls exist and are collapsed that	they do not expand also."	| existingPalette | 	(existingPalette := self findPalette) notNil		ifTrue:			[existingPalette displayBox: 				((UIPalette 					palettePlaceNear: mainWindow 					for: existingPalette bounds extent) extent: existingPalette bounds extent).			mainWindow when: #closing send: #canvasClosing to: existingPalette model.			existingPalette isCollapsed				ifTrue: [existingPalette expand]				ifFalse: [existingPalette raise]]		ifFalse:			[ (UIPalette openPaletteNear: mainWindow) application: self ]</body><body package="UIPainter">runInstallationDialog	"The assumption embodied here is that the source for resources 	while painting is a class:  the send of targetClass: will also change 	the source instVar of the receiver's builder."	^((ResourceInstallDialog new)		targetClass: self targetClass;		selector: (self targetSelector ifNil: [#windowSpec]);		resourceType: #canvas;		select)			ifNotNil: 				[:definition |				self					targetClass: definition implementingClass;					targetSelector: definition selector]</body><body package="UIPainter">setupBuilder	"UIPainter new open"	|  paintingCanvas gridWrapper |	builder windowOn: self.	paintingCanvas := builder composite.	paintingCanvas model: self.	paintingCanvas controller currentMode: UIPalette currentModeHolder.	gridWrapper := GridWrapper on: paintingCanvas.	gridWrapper grid: paintingCanvas controller gridStep.	gridWrapper showGrid: paintingCanvas controller showGrid.	gridWrapper griddedHorizontally: paintingCanvas controller griddedHorizontally.	gridWrapper griddedVertically: paintingCanvas controller griddedVertically.	builder window component: gridWrapper.	builder window keyboardProcessor keyboardHook: paintingCanvas controller keyboardHook</body><body package="UIPainter">spawnPainterWindows: newWindow ofType: type 	| mainWindow |	mainWindow := builder window.	newWindow label: mainWindow label.	newWindow minimumSize: WindowSpec initialMin.	newWindow maximumSize: (UIPainter preferenceFor: #maximumCanvasWidth)			@ (UIPainter preferenceFor: #maximumCanvasHeight).	newWindow openWithExtent: mainWindow displayBox extent andType: type.	(Delay forMilliseconds: 200) wait.	(newWindow model)		openPainterToolFor: newWindow;		openPaletteFor: newWindow.	newWindow application accept</body><body package="UIPainter">targetTrouble	| tgtClass tgtSelector |	^(tgtClass := self targetClass) isNil or:		[(tgtSelector := self targetSelector) isNil or:			[(tgtClass respondsTo: tgtSelector) not]]</body><body package="UIPainter">windowEvent: anEvent from: anApplicationWindow	super windowEvent: anEvent from: anApplicationWindow.	(anEvent key == #expand and: [anApplicationWindow model isKindOf: UIPalette])		ifTrue: [anApplicationWindow model updateSize].</body></methods><methods><class-id>Tools.UIPainter</class-id> <category>constants</category><body package="UIPainter">defaultSpecClass	"answer the receiver's default spec class"	^FullSpec</body></methods><methods><class-id>Tools.UIPainter</class-id> <category>activation</category><body package="UIPainter">activateViewHierarchy	"do nothing, top painter.  only embedded painters need to apply this request."</body><body package="UIPainter">deactivateView	"do nothing, top painter.  only embedded painters need to apply this request."</body></methods><methods><class-id>Tools.UIPainter</class-id> <category>initialize-release</category><body package="UIPainter">initialize	super initialize.	self initializeWindowSpec.	self initializeBuilder.	self initializeDefiner</body><body package="UIPainter">initializeBuilder	self builder: self builderClass new.	builder isEditing: true.	builder composite: UIPainterView new.	builder composite controller: UIPainterController new</body><body package="UIPainter">initializeDefiner	definer := UIDefiner for: self targetClass</body><body package="UIPainter">initializeWindowSpec	windowSpec := WindowSpec new.	windowSpec label: WindowSpec initialLabel asString</body></methods><methods><class-id>Tools.UIPainter</class-id> <category>support</category><body package="UIPainter">accept	acceptedState := self makeFullSpec literalArrayEncoding</body><body package="UIPainter">cancel	"Reset to the last accepted state."	| view fullSpec win bounds  |	(view := builder composite) controller removeSelections.	view components copy do: [:wrapper | view remove: wrapper. wrapper release].	fullSpec := self defaultSpecClass new fromLiteralArrayEncoding: acceptedState.	builder add: fullSpec component.	windowSpec := fullSpec window.	win := builder window.	(windowSpec labelInBuilder: builder) ifNotNil:[:label| win label: label].	self minWindowExtent: windowSpec min.	self maxWindowExtent: windowSpec max.	(bounds := windowSpec bounds) notNil		ifTrue: 			[self prefWindowExtent: bounds extent].	win lookPreferences: windowSpec colors.</body><body package="UIPainter">installFor: aController	"make sure anything unaccepted is applied by the PropertiesTool"	aController broadcastPendingSelectionChange.	(self targetTrouble or:		[(UIPainter preferenceFor: #avoidInstallationDialog) not xor:			(builder window sensor shiftDown)])		ifTrue:			[self runInstallationDialog isNil				ifTrue: [^nil]].	self installInSystem.	aController canvasHasChanged: false</body></methods><methods><class-id>Tools.UIPainter</class-id> <category>interface opening</category><body package="UIPainter">openNewWindowCanvas	"The builder's current spec  should be for the window. If in future this changes,	then simply synthesize a WindowSpec not of dialog type and pass it in."	self setupBuilder.	self openPainterWindows: builder spec.	UIPalette currentMode: #{SelectModeTracker} value new.	self findPainterController notifyOpenedCanvas.	self mainWindow raise.</body><body package="UIPainter">openOnClass: nonMetaClass andSelector: aSelector 	"Remember from where in the system organization we got this spec from."	self targetClass: nonMetaClass.	self targetSelector: aSelector.	UIFinderVW2 visited: (Array with: nonMetaClass with: aSelector).	aSelector isNil ifTrue: [^self openNewWindowCanvas].	(nonMetaClass respondsTo: #installApplicationNamedFonts) ifTrue:		[nonMetaClass new installApplicationNamedFonts].	self openOnLiteralArray: (nonMetaClass perform: aSelector).	UIPalette currentMode: #{SelectModeTracker} value new.	self findPainterController notifyOpenedCanvas.</body></methods><methods><class-id>Tools.UIPainter class</class-id> <category>private</category><body package="UIPainter">browseWiringTo: symbols within: anApplication 	"Create and schedule a message browser on the consequential 	references to symbols within anApplication and its subclasses."	MethodCollector new		openListBrowserOn:			(Cursor execute showWhile:				[self wiringTo:symbols within: anApplication])		label:			(symbols size == 1				ifTrue: [((#UseOf1sIn2s &lt;&lt; #UIPainter &gt;&gt; 'Use of &lt;1s&gt; in &lt;2s&gt;')			expandMacrosWith: symbols first			with: anApplication name)]				ifFalse: [((#GenKey115 &lt;&lt; #UIPainter &gt;&gt; 'Use of Selected Models in &lt;1s&gt;')			expandMacrosWith: anApplication name)])		initialSelection:			(symbols size == 1				ifTrue: [symbols first keywords first]				ifFalse: [nil])</body><body package="UIPainter">gridModeMenu	"Used by the canvas control panel.  Hand-formatted"	^((MenuBuilder new)		add: #'Grid Off' -&gt; #Off;		add: #'Grid On' -&gt; #On;		add: #'Grid Hidden' -&gt; #Hidden) menuHolder</body><body package="UIPainter">painterToolPlaceNear: mainWindow bounds: bounds 	"ccRectangle is passed in so that, if we ever change the relative orientations, 	the control panel's dimensions can vary dynamically. Return the preferred 	position for the origin (upper right) corner of the control panel. Use user 	preference to establish the (unknown and unknowable) host window 	manager, on whose identity the proper offset depends."	| mainRectangle hackFactor screenBounds |	hackFactor := 13 @ 0.	screenBounds := mainWindow == nil		ifTrue: [Screen default bounds]		ifFalse: [mainWindow screen bounds].	mainRectangle := mainWindow getDisplayBox.	^Point		x: (((mainRectangle topLeft x - bounds x - hackFactor x) max: screenBounds left) min: screenBounds right)		y: (((mainRectangle topLeft y + hackFactor y) max: screenBounds top) min: screenBounds bottom)</body><body package="UIPainter">placementFeelClass	^(self preferenceFor: #placementFeel) asQualifiedReference 		valueOrDo: [ #{DragPlacementModeTracker} value ]</body><body package="UIPainter">wiringTo: models within: anApplication 	"Answer a list of all the methods that use or implement models in anApplication, or access instance 	variables of the same names."	| mc filter list |	mc := MethodCollector new.	list := List new.	filter := mc searchClassHierarchy: anApplication.	models		do: 			[:mdl | 			| betterFilter |			betterFilter := (mc instVarUse: mdl access: #readWrite:)						| (mc referencesTo: mdl) | (mc implementorsOf: mdl).			betterFilter := filter &amp; betterFilter.			list addAll: (mc select: betterFilter)].	^list</body></methods><methods><class-id>Tools.UIPainter class</class-id> <category>instance creation</category><body package="UIPainter">new 	^self basicNew initialize</body></methods><methods><class-id>Tools.UIPainter class</class-id> <category>user preferences</category><body package="UIPainter">preferenceFor: aSubject 	^UISettings preferenceFor: aSubject</body></methods><methods><class-id>Tools.UIPainter class</class-id> <category>class initialization</category><body package="UIPainter">initialize	"UIPainter initialize."	UISettings addPreferenceSection: #addUIPainterSectionTo:development:runtime:.	#{VisualLauncher} isDefined		ifTrue: [#{VisualLauncher} value checkInstalledComponents]</body></methods><methods><class-id>Tools.UIPainter class</class-id> <category>parcel load/unload/save</category><body package="UIPainter">preUnloadFor: theUIPainterParcel	"Close any open applications implemented by this parcel."	ApplicationModel checkUnloadOfApplicationsDefinedBy: theUIPainterParcel.	UISettings removePreferenceSection: #addUIPainterSectionTo:development:runtime:</body></methods><methods><class-id>Tools.GridWrapper</class-id> <category>displaying</category><body package="UIPainter">displayGridOn: aGraphicsContext 	| rect gc top g bottom left right |	g := grid value.	gc := aGraphicsContext copy.	gc paint: self gridPaint.	rect := aGraphicsContext clippingBounds intersect: self bounds.	left := rect left.	right := rect right.	top := rect top + (g // 2) // g * g.	bottom := rect bottom.	(showGrid value == #Show or: [griddedVertically value])		ifTrue: [[top &lt; bottom]				whileTrue: 					[gc displayRectangle: (left @ top corner: right @ (top + 1)).					top := top + g]].	top := rect top.	left := left + (g // 2) // g * g.	(showGrid value == #Show or: [griddedHorizontally value])		ifTrue: [[left &lt; right]				whileTrue: 					[gc displayRectangle: (left @ top corner: left + 1 @ bottom).					left := left + g]]</body><body package="UIPainter">displayOn: aGraphicsContext	(showGrid value ~~ #Hide and: [grid value &gt; 1]) ifTrue: [self displayGridOn: aGraphicsContext].	super displayOn: aGraphicsContext</body></methods><methods><class-id>Tools.GridWrapper</class-id> <category>private</category><body package="UIPainter">gridPaint	^gridPaint == nil		ifTrue: [SymbolicPaint selectionBackground]		ifFalse: [gridPaint]</body><body package="UIPainter">gridPaint: paint	gridPaint := paint</body><body package="UIPainter">setGrid: aValue	grid := aValue</body><body package="UIPainter">setShowGrid: aValue	showGrid := aValue</body></methods><methods><class-id>Tools.GridWrapper</class-id> <category>updating</category><body package="UIPainter">update: anAspect with: aParameter from: anObject	self invalidate</body></methods><methods><class-id>Tools.GridWrapper</class-id> <category>accessing</category><body package="UIPainter">grid: aValueHolder	grid removeDependent: self.	grid := aValueHolder.	grid addDependent: self</body><body package="UIPainter">griddedHorizontally: aValueHolder	griddedHorizontally removeDependent: self.	griddedHorizontally := aValueHolder.	griddedHorizontally addDependent: self</body><body package="UIPainter">griddedVertically: aValueHolder	griddedVertically removeDependent: self.	griddedVertically := aValueHolder.	griddedVertically addDependent: self</body><body package="UIPainter">showGrid: aValueHolder	showGrid removeDependent: self.	showGrid := aValueHolder.	showGrid addDependent: self</body></methods><methods><class-id>Tools.GridWrapper</class-id> <category>initialize-release</category><body package="UIPainter">initialize	super initialize.	self setShowGrid: true.	self setGrid: 16.	gridPaint := nil</body><body package="UIPainter">release	grid removeDependent: self.	showGrid removeDependent: self.	super release</body></methods><methods><class-id>Tools.UIPainterWatcher</class-id> <category>initialize-release</category><body package="UIPainter">dontWatchPainter	selectionHolder removeDependent: self</body><body package="UIPainter">initialize	selectionHolder := UIPainterController lastControllerWithSelectionChannel</body><body package="UIPainter">release	super release.	self dontWatchPainter</body><body package="UIPainter">watchPainter	selectionHolder addDependent: self</body></methods><methods><class-id>Tools.UIPainterWatcher</class-id> <category>private</category><body package="UIPainter">able: aBoolean components: idList	idList do:		[:id |		aBoolean			ifTrue: [(builder componentAt: id) enable]			ifFalse: [(builder componentAt: id) disable]]</body><body package="UIPainter">disableApply	(builder componentAt: #applyButton) disable</body><body package="UIPainter">disableGroup: idList	self able: false components: idList</body><body package="UIPainter">disableRead	(builder componentAt:#readButton) disable</body><body package="UIPainter">embeddedPainter</body><body package="UIPainter">enableApply	(builder componentAt: #applyButton) enable</body><body package="UIPainter">enableGroup: idList	self able: true components: idList</body><body package="UIPainter">enableRead	(builder componentAt: #readButton) enable</body><body package="UIPainter">pendingSelectionChange</body><body package="UIPainter">quietlyReloadSelectionInformation	"Default do nothing"</body><body package="UIPainter">reappearGroup: idList	self visible: true components: idList</body><body package="UIPainter">reloadSelectionInformation</body><body package="UIPainter">setUpVisuals</body><body package="UIPainter">topLevelPainter</body><body package="UIPainter">vanishGroup: idList	self visible: false components: idList</body><body package="UIPainter">visible: aBoolean components: idList	idList do:		[:id |		aBoolean			ifTrue: [(builder componentAt: id) beVisible]			ifFalse: [(builder componentAt: id) beInvisible]]</body><body package="UIPainter">windowEvent: anEvent from: anApplicationWindow 	super windowEvent: anEvent from: anApplicationWindow.	anEvent key == #release ifTrue: [self release].	anEvent key == #expand ifTrue: [self reloadSelectionInformation]</body></methods><methods><class-id>Tools.UIPainterWatcher</class-id> <category>accessing</category><body package="UIPainter">controller	^self builder window controller</body><body package="UIPainter">selectionHolder	^selectionHolder</body></methods><methods><class-id>Tools.UIPainterWatcher</class-id> <category>interface opening</category><body package="UIPainter">postBuildWith: aBuilder	self setUpVisuals.</body><body package="UIPainter">postOpenWith: aBuilder	self watchPainter.	builder window application: self.	self reloadSelectionInformation</body></methods><methods><class-id>Tools.UIPainterWatcher</class-id> <category>updating</category><body package="UIPainter">update: anAspect with: parameter from: anObject	(builder window notNil and: [builder window key notNil and: [builder window isCollapsed not]])		ifFalse: [^self].	anAspect == #value ifTrue: [^self reloadSelectionInformation].	(anAspect == #pendingSelectionChange and: [self controller = anObject value]) ifTrue: 		[^self pendingSelectionChange].	anAspect == #topLevelPainter ifTrue: [^self topLevelPainter].</body></methods><methods><class-id>Tools.UIPainterWatcher</class-id> <category>interface closing</category><body package="UIPainter">noticeOfWindowClose: aWindow	self release.	super noticeOfWindowClose: aWindow.</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>private</category><body package="UIPainter">apertureIntersectsWithScreenRectangle: aRectangle	| viewOrigin |	viewOrigin :=		aRectangle origin -			((builder componentAt: #magnifiedBitView)  component bounds origin +				magnifiedBitView topComponent globalOrigin + (4@3)).	^(magnifiedBitView container bounds intersects:			(Rectangle origin: viewOrigin extent: aRectangle extent))</body><body package="UIPainter">changeRequest	^super changeRequest		ifFalse: [false]		ifTrue:			[(self modified or: [self magnifiedBitView controller updateRequest not])				ifTrue:					[Dialog confirm: (#GenKey109 &lt;&lt; #UIPainter &gt;&gt; 'The image has been altered, but not installed.Do you wish to discard the changes?') for: builder window]				ifFalse: [true]]</body><body package="UIPainter">disableApply	"Disable Apply menu item"	super disableApply.	(menuBar atNameKey: #apply) disable</body><body package="UIPainter">disableColor	builder isNil ifTrue: [^self].	#(#greyButton #redButton #yellowButton #greenButton #cyanButton #blueButton #magentaButton #darkGreyButton #darkRedButton #darkYellowButton #darkGreenButton #darkCyanButton #darkBlueButton #darkMagentaButton )		do: 			[:n | 			(builder componentAt: n) disable.			(builder componentAt: n) beInvisible]</body><body package="UIPainter">disableRead	"Disable Read menu item"	super disableRead.	(menuBar atNameKey: #read) disable</body><body package="UIPainter">enableApply	"Enable Apply menu item"	super enableApply.	(menuBar atNameKey: #apply) enable</body><body package="UIPainter">enableColor	Screen default colorDepth == 1 ifTrue: [^self].	builder isNil ifTrue: [^self].	#(#greyButton #redButton #yellowButton #greenButton #cyanButton #blueButton #magentaButton #darkGreyButton #darkRedButton #darkYellowButton #darkGreenButton #darkCyanButton #darkBlueButton #darkMagentaButton )		do: 			[:n | 			(builder componentAt: n) enable.			(builder componentAt: n) beVisible]</body><body package="UIPainter">enableRead	"Enable Read menu item"	super enableRead.	(menuBar atNameKey: #read) enable</body><body package="UIPainter">fill: anImage with: aColorIndex in: aRectangle		aRectangle left		to: aRectangle right - 1		do:			[:x | 			aRectangle top				to: aRectangle bottom - 1				do: [:y | anImage atX: x y: y put: aColorIndex]].	magnifiedBitView		model: anImage;		invalidate.	directBitView		model: anImage;		invalidate</body><body package="UIPainter">generateMask	| oldImage colorWhite newImage opaque transparent takeBuffer putBuffer |	oldImage := magnifiedBitView model copy.	colorWhite := oldImage palette indexOf: ColorValue white.	newImage := Image				extent: oldImage extent				depth: 1				palette: CoveragePalette monoMaskPalette				bits: (ByteArray new: ((oldImage width + 31 // 32 * 4) * oldImage height)).	opaque := newImage palette indexOf: CoverageValue opaque.	transparent := newImage palette indexOf: CoverageValue transparent.	takeBuffer := Array new: oldImage width.	putBuffer := Array new: oldImage width.	0 to: oldImage height - 1		do: 			[:rowIndex | 			oldImage rowAt: rowIndex into: takeBuffer.			1 to: takeBuffer size do: [:colIndex | (takeBuffer at: colIndex)					== colorWhite					ifTrue: [putBuffer at: colIndex put: transparent]					ifFalse: [putBuffer at: colIndex put: opaque]].			newImage rowAt: rowIndex putAll: putBuffer].	^newImage</body><body package="UIPainter">getScreenRectangleOfWidth: width andHeight: height	^Screen default		dragShape: (Rectangle origin: 0@0 extent: width@height) asPointArray		offset: 0@0		gridPhase:			(magnifiedBitView localPointToGlobal: 0@0) +				magnifiedBitView topComponent globalOrigin		gridSpacing: 8@8		boundedBy: nil		whileButton: 0		isDown: false.</body><body package="UIPainter">installInSystem	| class image s |	image := (storeMask value				ifTrue: [self generateMask]				ifFalse: [magnifiedBitView model]).	class := self targetClass class.	s := WriteStream on: (String new: image bits size // 8).	s nextPutAll: self targetSelector; cr.	"Put in a nice comment for re-opening the mask maker."	s tab;		nextPutAll: ('"&lt;1s&gt; new openOnClass: self andSelector: #' expandMacrosWith: self class fullName);		nextPutAll: self targetSelector; nextPut: $"; cr;		crtab; nextPutAll: '&lt;resource: #image&gt;';		crtab; nextPut: $^.	useCachedImage value		ifTrue: [s nextPutAll: 'CachedImage on: '].	s nextPutAll: image minimalStorageString.	class compile: s contents classified: #'resources'.	Transcript cr; show: ((#x1s2sDefined &lt;&lt; #UIPainter &gt;&gt; '&lt;1s&gt;%&gt;&lt;2s&gt; defined')			expandMacrosWith: class name			with: self targetSelector).	UIFinderVW2 installed: (Array with: self targetClass with: self targetSelector).	self accept.	self magnifiedBitView controller imageHasChanged: false.	self modified: false</body><body package="UIPainter">modelRegionFromScreenRegion: aRectangle	| r |	r := aRectangle translatedBy:			magnifiedBitView controller sensor globalOrigin negated.	r := r scaledBy: 1 / magnifiedBitView scale.	^r</body><body package="UIPainter">openOnClass: aClass andSelector: aSelector	| image |	self targetClass: aClass.	self targetSelector: aSelector.	aSelector isNil		ifFalse: 			[aSelector numArgs = 0				ifTrue: 					[image := aClass perform: aSelector.					(image isKindOf: CachedImage)						ifTrue: 							[image := image image.							useCachedImage value: true]						ifFalse: [useCachedImage value: false]]				ifFalse: [image := nil].			(image isKindOf: Image)				ifFalse: 					[Dialog warn: #MethodDoesntReturnImage &lt;&lt; #UIPainter								&gt;&gt; 'The method did not return an image'						for: (builder isNil ifTrue: [nil] ifFalse: [builder window]).					^self].			storeMask value: image paintBasis == CoverageValue.			Cursor execute showWhile: 					[storeMask value ifTrue: [image palette: MonoMappedPalette whiteBlack].					image := image								convertToPalette: Screen default colorPalette								bitsPerPixel: Screen default colorDepth								renderedBy: NearestPaint new								paintTransfer: nil.					magnifiedBitView						model: image;						changedPreferredGeometry;						invalidate.					directBitView						model: image;						changedPreferredGeometry;						invalidate.					self accept]].	UIFinderVW2 visited: (Array with: aClass with: aSelector).	self magnifiedBitView controller imageHasChanged: false.	self modified: false.	self open</body><body package="UIPainter">rectangleFromUserLimitedTo: extentPoint 	"It is lamentably necessary to duplicate the code from Rectangle class 	here, so that limitations can be imposed on the size of the rectangle 	specified by the user."	| originPoint |	^Cursor crossHair		showWhile: 			[originPoint := Screen default						dragShape: (0 @ 0 extent: 1@1) asPointArray						offset: 0 @ 0						gridPhase: 0@0						gridSpacing: 1@1						boundedBy: nil						whileButton: 0						isDown: false.			Screen default				resizeRectangle: (Rectangle origin: originPoint extent: 1@1)				minimumExtent: 0@0				resizeIncrement: 1@1				boundedBy: (Rectangle origin: originPoint extent: extentPoint)				whileButton: 0				isDown: true]</body><body package="UIPainter">reloadSelectionInformation	| sel controller |	controller := selectionHolder value.	controller == nil		ifTrue: 			[self disableRead; disableApply.			^self].	sel := controller selectionList.	(sel size = 0 or: [sel size &gt; 1])		ifTrue:			[self disableRead; disableApply.			^self].	(self selectionCanHaveLabel: sel first)		ifTrue: [self enableApply]		ifFalse: [self disableApply].	(self selectionHasImage: sel first)		ifTrue: [self enableRead]		ifFalse: [self disableRead]</body><body package="UIPainter">runInstallationDialog	^((ResourceInstallDialog new)		targetClass: self targetClass;		selector: self targetSelector;		resourceType: #image;		select)			ifNotNil: 				[:definition |				self					targetClass: definition implementingClass;					targetSelector: definition selector]</body><body package="UIPainter">runInstallationDialogFor: sel	| defaultSelector |	defaultSelector := sel spec hasCharacterOrientedLabel				ifTrue: [nil]				ifFalse: [sel spec getLabel notNil ifTrue: [sel spec getLabel asSymbol] ifFalse: [nil]].	^((ResourceInstallDialog new)		targetClass: self targetClass;		selector: defaultSelector;		resourceType: #image;		select)			ifNotNil: 				[:definition |				self					targetClass: definition implementingClass;					targetSelector: definition selector]</body><body package="UIPainter">selectionCanHaveLabel: aSelection		^aSelection spec canHaveLabel</body><body package="UIPainter">selectionHasImage: aSelection	| spec |	^(spec := aSelection spec) canHaveLabel and:		[spec getLabel notNil and:			[spec hasCharacterOrientedLabel not]]</body><body package="UIPainter">setColorFor: aButtonId	| currentLookPreferences color colorNumber |	color := (builder componentAt: aButtonId) lookPreferences backgroundColor.	currentLookPreferences := (builder componentAt: #currentColorID) lookPreferences copy.	currentLookPreferences setBackgroundColor: color.	colorNumber := magnifiedBitView model  palette indexOf: color ifAbsent: [magnifiedBitView model  palette indexOfPaintNearest: color].	magnifiedBitView controller currentColor: colorNumber.	(builder componentAt: #currentColorID)		lookPreferences: currentLookPreferences</body><body package="UIPainter">storeMaskChanged	storeMask value		ifTrue: [self disableColor]		ifFalse: [self enableColor]</body><body package="UIPainter">targetTrouble	| tgtClass tgtSelector |	^(tgtClass := self targetClass) isNil or:		[(tgtSelector := self targetSelector) isNil or:			[(tgtClass respondsTo: tgtSelector) not]]</body><body package="UIPainter">toColor: aColorIndex	| controller point oldImage zeroColor newImage takeBuffer putBuffer |	controller := builder window controller.	oldImage := magnifiedBitView model copy.	Cursor crossHair showWhile: 			[[controller sensor anyButtonPressed not] whileTrue: [].			[controller sensor anyButtonPressed] whileTrue: []].	point := magnifiedBitView controller sensor cursorPoint.	(magnifiedBitView bounds containsPoint: point) ifFalse: [^self].	point := (point scaledBy: 1 / magnifiedBitView scale) truncated.	(oldImage bounds containsPoint: point) ifFalse: [^self].	zeroColor := oldImage atPoint: point.	newImage := oldImage copy.	takeBuffer := Array new: oldImage width.	putBuffer := Array new: oldImage width.	0 to: newImage height - 1		do: 			[:rowIndex |			oldImage rowAt: rowIndex into: takeBuffer.			1 to: takeBuffer size				do: 					[:colIndex |					(takeBuffer at: colIndex) = zeroColor						ifTrue: [putBuffer at: colIndex put: aColorIndex]						ifFalse: [putBuffer at: colIndex put: (takeBuffer at: colIndex)]].			newImage rowAt: rowIndex putAll: putBuffer].	magnifiedBitView		model: newImage;		changedPreferredGeometry;		invalidate.	directBitView		model: newImage;		changedPreferredGeometry;		invalidate</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>resources</category><body package="UIPainter">directBitView	^directBitView</body><body package="UIPainter">magnifiedBitView	^magnifiedBitView</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>actions</category><body package="UIPainter">accept	self acceptedState: magnifiedBitView model copy</body><body package="UIPainter">apply	| controller painter sel |	(controller := selectionHolder value) isNil ifTrue: [^self].	painter := controller model.	sel := controller selections first.	self targetClass: painter targetClass.	(self targetTrouble or:		[(UIPainter preferenceFor: #avoidInstallationDialog) not or:				[builder window sensor shiftDown]])		ifTrue:			[(self runInstallationDialogFor: sel) isNil				ifTrue: [^nil]].	painter targetClass isNil ifTrue: [painter targetClass: self targetClass].	self installInSystem.	sel spec hasCharacterOrientedLabel: false.	sel spec label: self targetSelector asString.	"replaceElement:etc. will cause change to be noted, and select: will	cause UIPainterWatchers to be alerted."	controller broadcastPendingSelectionChange.	controller select: (controller replaceElement: sel basedOnSpec: sel spec)</body><body package="UIPainter">cancel	| newImage |	Cursor execute showWhile: 			[newImage := self acceptedState copy.			magnifiedBitView				model: newImage;				changedPreferredGeometry;				invalidate.			directBitView				model: newImage;				changedPreferredGeometry;				invalidate]</body><body package="UIPainter">clip	| ctrlr model r newMap |	ctrlr := magnifiedBitView controller.	model := magnifiedBitView model.	r := Rectangle fromUser: magnifiedBitView scale				phase: ctrlr sensor globalOrigin.	r extent = (8 @ 8) ifTrue: [^self].	r := r translatedBy: ctrlr sensor globalOrigin negated.	r := r scaledBy: 1 / magnifiedBitView scale.	newMap := Image				extent: r extent				depth: model depth				bitsPerPixel: model bitsPerPixel				palette: model palette.	Cursor execute showWhile: 			[newMap				copy: (Rectangle origin: 0 @ 0 corner: r extent)				from: r origin				in: model				rule: RasterOp paint.			magnifiedBitView				model: newMap;				changedPreferredGeometry;				invalidate.			directBitView				model: newMap;				changedPreferredGeometry;				invalidate].	self modified: true</body><body package="UIPainter">copy	| image r newMap |	r := Rectangle			fromUser: magnifiedBitView scale			phase: magnifiedBitView controller sensor globalOrigin.	r extent = (8@8) ifTrue: [^self].	(self apertureIntersectsWithScreenRectangle: r) ifFalse: [^self].	r := self modelRegionFromScreenRegion: r.	image := magnifiedBitView model.	newMap :=		Image			extent: r extent			depth: image depth			bitsPerPixel: image bitsPerPixel			palette: image palette.	newMap		copy: (Rectangle origin: 0 @ 0 corner: r extent)		from: r origin		in: image		rule: RasterOp paint.	self pasteBuffer: newMap</body><body package="UIPainter">cut	| image r newMap |	r := Rectangle			fromUser: magnifiedBitView scale			phase: magnifiedBitView controller sensor globalOrigin.	r extent = (8@8) ifTrue: [^self].	(self apertureIntersectsWithScreenRectangle: r) ifFalse: [^self].	r := self modelRegionFromScreenRegion: r.	image := magnifiedBitView model.	Cursor execute showWhile:		[newMap :=			Image				extent: r extent				depth: image depth				bitsPerPixel: image bitsPerPixel				palette: image palette.		newMap			copy: (Rectangle origin: 0 @ 0 corner: r extent)			from: r origin			in: image			rule: RasterOp paint.		self pasteBuffer: newMap.		self fill: image with: (image palette indexOf: ColorValue white) in: r].	self modified: true</body><body package="UIPainter">doBlack	self setColorFor: #blackButton</body><body package="UIPainter">doBlue	self setColorFor: #blueButton</body><body package="UIPainter">doCyan	self setColorFor: #cyanButton</body><body package="UIPainter">doDarkBlue	self setColorFor: #darkBlueButton</body><body package="UIPainter">doDarkCyan	self setColorFor: #darkCyanButton</body><body package="UIPainter">doDarkGreen	self setColorFor: #darkGreenButton</body><body package="UIPainter">doDarkGrey	self setColorFor: #darkGreyButton</body><body package="UIPainter">doDarkMagenta	self setColorFor: #darkMagentaButton</body><body package="UIPainter">doDarkRed	self setColorFor: #darkRedButton</body><body package="UIPainter">doDarkYellow	self setColorFor: #darkYellowButton</body><body package="UIPainter">doGreen	self setColorFor: #greenButton</body><body package="UIPainter">doGrey	self setColorFor: #greyButton</body><body package="UIPainter">doMagenta	self setColorFor: #magentaButton</body><body package="UIPainter">doRed	self setColorFor: #redButton</body><body package="UIPainter">doWhite	self setColorFor: #whiteButton</body><body package="UIPainter">doYellow	self setColorFor: #yellowButton</body><body package="UIPainter">fillCurrentColor	Cursor execute showWhile: 			[| r |			r := Rectangle fromUser: magnifiedBitView scale						phase: magnifiedBitView controller sensor globalOrigin.			r extent = (8 @ 8) ifTrue: [^self].			(self apertureIntersectsWithScreenRectangle: r) ifFalse: [^self].			r := self modelRegionFromScreenRegion: r.			self 				fill: magnifiedBitView model with: magnifiedBitView controller currentColor				in: r].	self modified: true</body><body package="UIPainter">grab	| rect image |	self changeRequest ifFalse: [^self].	rect := self rectangleFromUserLimitedTo: 128 @ 128.	(rect height == 0 or: [rect width == 0 or: [rect extent = (1 @ 1)]])		ifTrue: [^self].	image := Screen default completeContentsOfArea: rect.	image extent = (1 @ 1) ifTrue: [^self].	Cursor execute showWhile: 			[magnifiedBitView				model: image;				changedPreferredGeometry;				invalidate.			directBitView				model: image;				changedPreferredGeometry;				invalidate.			self magnifiedBitView controller imageHasChanged: false.			self accept].	self modified: true</body><body package="UIPainter">install	(self targetTrouble or:		[(UIPainter preferenceFor: #avoidInstallationDialog) not or:				[builder window sensor shiftDown]])		ifTrue:			[self runInstallationDialog isNil				ifTrue: [^nil]].	self installInSystem</body><body package="UIPainter">load	| image result |	self changeRequest ifFalse: [^self].	result := (ResourceInstallDialog new)				targetClass: self targetClass;				resourceType: #image;				loadSelect.	result ifNil: [^self].	self targetClass: result implementingClass.	self targetSelector: result selector.	image := nil.	self messageNotUnderstoodSignal		handle: 			[:ex |			ex parameter selector == self targetSelector				ifTrue: [ex return]				ifFalse: [ex pass]]		from: self targetClass		do: [image := self targetClass perform: self targetSelector].	(image isKindOf: CachedImage)		ifTrue: 			[image := image image.			useCachedImage value: true]		ifFalse: [useCachedImage value: false].	(image isKindOf: Image)		ifFalse: 			[Dialog warn: #MethodDoesntReturnImage &lt;&lt; #UIPainter						&gt;&gt; 'The method did not return an image'				for: builder window.			^self].	storeMask value: image paintBasis == CoverageValue.	Cursor execute showWhile: 			[storeMask value ifTrue: [image palette: MonoMappedPalette whiteBlack].			image := image convertToPalette: Screen default colorPalette.			magnifiedBitView				model: image;				changedPreferredGeometry;				invalidate.			directBitView				model: image;				changedPreferredGeometry;				invalidate.			UIFinderVW2				visited: (Array with: self targetClass with: self targetSelector).			self accept].	self magnifiedBitView controller imageHasChanged: false.	self modified: false</body><body package="UIPainter">maskify	| newImage oldImage colorWhite colorBlack takeBuffer putBuffer |	self accept.	oldImage := magnifiedBitView model copy.	newImage := oldImage copy.	Cursor execute showWhile: 			[colorWhite := oldImage palette indexOf: ColorValue white.			colorBlack := oldImage palette indexOf: ColorValue black.			takeBuffer := Array new: oldImage width.			putBuffer := Array new: oldImage width.			0 to: newImage height - 1				do: 					[:rowIndex |					oldImage rowAt: rowIndex into: takeBuffer.					1 to: takeBuffer size						do: 							[:colIndex |							(takeBuffer at: colIndex) = colorWhite								ifTrue: [putBuffer at: colIndex put: colorWhite]								ifFalse: [putBuffer at: colIndex put: colorBlack]].					newImage rowAt: rowIndex putAll: putBuffer].			magnifiedBitView				model: newImage;				changedPreferredGeometry;				invalidate.			directBitView				model: newImage;				changedPreferredGeometry;				invalidate].	self modified: true</body><body package="UIPainter">paste	| bufferBounds buffer ctrlr origin bltOrigin r model |	(buffer := self pasteBuffer) isNil ifTrue: [^self].	(bufferBounds := buffer bounds scaledBy: magnifiedBitView scale) isNil		ifTrue: [^self].	ctrlr := magnifiedBitView controller.	origin := self getScreenRectangleOfWidth: bufferBounds width andHeight: bufferBounds height.	(self apertureIntersectsWithScreenRectangle:			(Rectangle origin: origin extent: bufferBounds extent))		ifFalse: [^self].	bltOrigin := (origin - ctrlr sensor globalOrigin) scaledBy: 1 /magnifiedBitView scale.	r := Rectangle origin: bltOrigin extent: bufferBounds width @ bufferBounds height.	r extent = (1@1) ifTrue: [^self].	model := magnifiedBitView model.	Cursor execute showWhile:		[model copy: r from: 0@0 in: buffer rule: RasterOp over.		magnifiedBitView model: model; invalidate.		directBitView invalidate].	self modified: true</body><body package="UIPainter">read	| controller spec image |	self changeRequest ifFalse: [^self].	controller := selectionHolder value.	spec := controller selections first spec.	image := controller builder visualAt: spec getLabel asSymbol.	image isNil ifTrue: [^self].	(image isKindOf: CachedImage) ifTrue: [image := image image].	(image isKindOf: Image)		ifFalse: 			[Dialog				warn: #GenKey113 &lt;&lt; #UIPainter &gt;&gt; 'The application did not supply an image'				for: builder window.			^self].	Cursor execute showWhile: 			[image palette: MonoMappedPalette whiteBlack.			image := image						convertToPalette: Screen default colorPalette						bitsPerPixel: Screen default colorDepth						renderedBy: NearestPaint new						paintTransfer: nil.			magnifiedBitView				model: image;				changedPreferredGeometry;				invalidate.			directBitView				model: image;				changedPreferredGeometry;				invalidate.			self accept].	self magnifiedBitView controller imageHasChanged: false.	self targetClass: controller model targetClass.	self targetSelector: (spec label isNil				ifTrue: [nil]				ifFalse: [spec label asSymbol]).	self modified: false</body><body package="UIPainter">toCurrentColor	Cursor execute showWhile: [self toColor: magnifiedBitView controller currentColor].	self modified: true</body><body package="UIPainter">toggleStoreMask	storeMask value: storeMask value not</body><body package="UIPainter">toggleUseCache	useCachedImage value: useCachedImage value not</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>accessing</category><body package="UIPainter">acceptedState	^acceptedState</body><body package="UIPainter">acceptedState: anImage	acceptedState := anImage</body><body package="UIPainter">modified	^modified</body><body package="UIPainter">modified: aBoolean	modified := aBoolean</body><body package="UIPainter">pasteBuffer	^PasteBuffer</body><body package="UIPainter">pasteBuffer: anImage	PasteBuffer := anImage</body><body package="UIPainter">storeMask	^storeMask</body><body package="UIPainter">targetClass	(targetClass notNil and: [targetClass isObsolete])		ifTrue:			[targetClass := nil].	^targetClass</body><body package="UIPainter">targetClass: aClassOrNil	targetClass := aClassOrNil</body><body package="UIPainter">targetSelector	^targetSelector</body><body package="UIPainter">targetSelector: aSymbolOrNil	targetSelector := aSymbolOrNil</body><body package="UIPainter">useCachedImage	^useCachedImage</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>aspects</category><body package="UIPainter">doTheCurrentColor	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^doTheCurrentColor isNil ifTrue: [doTheCurrentColor := String new asValue] ifFalse: [doTheCurrentColor]</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>menus</category><body package="UIPainter">maskEditorMenu	menuBar := self class maskEditorMenu.	(menuBar atNameKey: #toggleStoreMask)		indication: storeMask.	(menuBar atNameKey: #toggleUseCache)		indication: useCachedImage.	(menuBar atNameKey: #fillCurrentColor)		labelImage: UIMaskEditor fillRectangleImage.	(menuBar atNameKey: #toCurrentColor)		labelImage: UIMaskEditor changeColorImage.	self disableRead.	self disableApply.	^menuBar</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>interface opening</category><body package="UIPainter">postBuildWith: aBuilder	super postBuildWith: aBuilder.	Screen default colorDepth == 1 ifTrue: [self disableColor]</body></methods><methods><class-id>Tools.UIMaskEditor</class-id> <category>initialize-release</category><body package="UIPainter">initialize	| image buffer white colorImage |	super initialize.	Screen default colorDepth == 1		ifTrue: [storeMask := ValueHolder with: true]		ifFalse: [storeMask := ValueHolder with: false].	useCachedImage := ValueHolder with: true.	colorImage := self class colorPaletteImage image.	image := Image				extent: 32 @ 32				depth: colorImage depth				palette: colorImage palette.	buffer := Array new: image width.	white := image palette indexOf: ColorValue white.	1 to: buffer size do: [:colIndex | buffer at: colIndex put: white].	0 to: image height - 1		do: [:rowIndex | image rowAt: rowIndex putAll: buffer].	acceptedState := image copy.	magnifiedBitView := ColorBitView model: image.	magnifiedBitView scale: 8 @ 8.	magnifiedBitView controller		currentColor: (image palette indexOf: ColorValue black).	directBitView := DirectBitView model: image.	magnifiedBitView changedPreferredGeometry.	modified := false.	storeMask onChangeSend: #storeMaskChanged to: self</body></methods><methods><class-id>Tools.UIMaskEditor class</class-id> <category>coded resources</category><body package="UIPainter">changeColorImage	Screen default colorDepth == 1		ifTrue: [^self changeColorImageBW]		ifFalse: [^self changeColorImageColor]</body><body package="UIPainter">fillRectangleImage	Screen default colorDepth == 1		ifTrue: [^self fillRectangleImageBW]		ifFalse: [^self fillRectangleImageColor]</body></methods><methods><class-id>Tools.UIMaskEditor class</class-id> <category>resources</category><body package="UIPainter">colorPaletteImage	^CachedImage on: (Image			extent: 32 @ 32			depth: 4			bitsPerPixel: 4			palette: (MappedPalette withColors: ((Array new: 16)						at: 1 put: ColorValue black;						at: 2 put: ColorValue darkGray;						at: 3 put: ColorValue white;						at: 4 put: ColorValue red;						at: 5 put: ColorValue olive;						at: 6 put: ColorValue green;						at: 7 put: ColorValue blue;						at: 8 put: ColorValue darkCyan;						at: 9 put: ColorValue darkMagenta;						at: 10 put: ColorValue darkRed;						at: 11 put: ColorValue darkGreen;						at: 12 put: ColorValue magenta;						at: 13 put: ColorValue yellow;						at: 14 put: ColorValue lightGray;						at: 15 put: ColorValue cyan;						at: 16 put: ColorValue navy; yourself))			usingBits: (ByteArray fromPackedString: 'KS1&lt;resource: #image&gt;	^Z2H"H"H"H"H"H"H"H"4&lt;W&amp;,"H"H"H"H"H"H"H"HA%J_8H"H"H"H"H"H"H"H"@YR''&gt;BH"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"Hb'))</body></methods><methods><class-id>UI.MaskPainterView</class-id> <category>accessing</category><body package="UIPainter">backdrop	^backdrop</body><body package="UIPainter">backdrop: aValue	backdrop := aValue.	self invalidate</body><body package="UIPainter">model: aModel 	"Set the receiver's model to aModel."	super setModel: aModel.	self invalidate.</body><body package="UIPainter">onPaint	^onPaint</body><body package="UIPainter">onPaint: aValue	onPaint := aValue</body></methods><methods><class-id>UI.MaskPainterView</class-id> <category>controller accessing</category><body package="UIPainter">defaultControllerClass	"Answer the class of the default controller for the receiver."	^MaskPainterController</body></methods><methods><class-id>UI.MaskPainterView</class-id> <category>initialize-release</category><body package="UIPainter">initialize	super initialize.	onPaint := ColorValue red.</body></methods><methods><class-id>UI.MaskPainterView</class-id> <category>displaying</category><body package="UIPainter">displayOn: aGraphicsContext	"Display the receiver on aGraphicsContext. The receiver may alter	aGraphicsContext in any way it chooses."	backdrop isNil ifFalse: [		backdrop displayOn: aGraphicsContext. 		aGraphicsContext clippingRectangle: (backdrop bounds intersect: aGraphicsContext clippingBounds). 	].	self controller editMask isNil ifFalse: [		aGraphicsContext paint: onPaint. 		self controller editMask displayOn: aGraphicsContext	].	"geometricInProgress isNil ifFalse: [		aGraphicsContext paint: onPaint.		geometricInProgress displayFilledOn: aGraphicsContext.	]."</body></methods><methods><class-id>UI.MaskPainterView</class-id> <category>bounds accessing</category><body package="UIPainter">preferredExtent	"Answer the Screen's bounding box.	Views are expected to be Wrapped by a BoundedWrapper."	^backdrop notNil ifTrue: [ backdrop bounds extent ] ifFalse: [ super preferredExtent ]</body></methods><methods><class-id>Tools.SelectionDragModeTracker</class-id> <category>drag drop</category><body package="UIPainter">constrainMovementOf: delta	^constrainedAxis = #y		ifTrue: [0 @ delta y]		ifFalse: [delta x @ 0]</body><body package="UIPainter">dragOverWidgets: aDragDropContext	| currentPoint newOrigin trackingBox delta controllerGrid |	currentPoint := controller sensor mousePoint.	controllerGrid := controller gridValue.	(self newPoint: currentPoint exceedsGrid: controllerGrid) ifFalse: [^self].	delta := controller isFenced		ifFalse: [currentPoint - lastShowPoint]		ifTrue:			[trackingBox := self trackingBoxFor: selectedWidgets.			newOrigin := self				containedPointFor: trackingBox origin + (currentPoint - lastShowPoint)				and: trackingBox				in: controller view bounds.			newOrigin - trackingBox origin].	self adjust: delta toGrid: controllerGrid.	(controller sensor shiftDown and: [constrainedAxis isNil])		ifTrue: [self setConstrainmentFrom: currentPoint].	constrainedAxis notNil ifTrue: [delta := self constrainMovementOf: delta].	delta isZero ifTrue: [^self].	selectedWidgets do: [:each | each moveBy: delta].	lastShowPoint := lastShowPoint + delta</body><body package="UIPainter">preDragDrop	selectedWidgets := controller selections.</body><body package="UIPainter">setConstrainmentFrom: aPoint	"No, I'm not sure that it's english &lt;sigh&gt;"	| change |	change := (aPoint - lastShowPoint) abs.	constrainedAxis := change x &gt; change y ifTrue: [#x] ifFalse: [#y]</body></methods><methods><class-id>Tools.SelectionDragModeTracker</class-id> <category>accessing</category><body package="UIPainter">specClass	^nil</body></methods><methods><class-id>Tools.DragHandle</class-id> <category>accessing</category><body package="UIPainter">block	"Answer the value for block"	^block</body><body package="UIPainter">block: aValue	"Set the value for block"	block := aValue</body><body package="UIPainter">dragModeBlock: aBlock	dragModeBlock := aBlock</body><body package="UIPainter">extent	^extent</body><body package="UIPainter">extent: aPoint	extent := aPoint</body><body package="UIPainter">isPrimary	^isPrimary</body><body package="UIPainter">isPrimary: aBoolean	isPrimary := aBoolean</body><body package="UIPainter">painterDragMode	"Answer an object, appropriate for use by a UIPainterController, that will	respond to the message dragObject:startingAt:inController:."	^dragModeBlock value: self</body><body package="UIPainter">selector	"Answer the value for selector"	^selector</body><body package="UIPainter">selector: aValue	"Set the value for selector"	selector := aValue</body><body package="UIPainter">subject	"Answer the value for subject"	^subject</body><body package="UIPainter">subject: aValue	"Set the value for subject"	subject := aValue</body><body package="UIPainter">wrapper	"Answer the value for wrapper"	^wrapper</body><body package="UIPainter">wrapper: aValue	"Set the value for wrapper"	wrapper := aValue</body></methods><methods><class-id>Tools.DragHandle</class-id> <category>displaying</category><body package="UIPainter">displayOn: aGraphicsContext	| box |	box := self bounds.	self isPrimary		ifTrue: [aGraphicsContext paint: ColorValue white.				aGraphicsContext displayRectangle: box.				aGraphicsContext paint: ColorValue black.				aGraphicsContext displayRectangle: (box insetBy: 1)]		ifFalse: [aGraphicsContext paint: ColorValue white.				aGraphicsContext displayRectangle: box.				aGraphicsContext paint: ColorValue black.				aGraphicsContext displayRectangle: (box insetBy: 1).				aGraphicsContext paint: ColorValue white.				aGraphicsContext displayRectangle: (box insetBy: 3)]</body></methods><methods><class-id>Tools.DragHandle</class-id> <category>private</category><body package="UIPainter">getOrigin	^block value: wrapper value: subject</body><body package="UIPainter">recomposePainterViews</body></methods><methods><class-id>Tools.DragHandle</class-id> <category>initialize-release</category><body package="UIPainter">asBottomLeft	selector := #bottomLeft.	block := [:wr :sub | wr globalBounds bottomLeft]</body><body package="UIPainter">asCenter	selector := #center.	block := [:wr :sub | wr globalBounds center]</body><body package="UIPainter">asCorner	selector := #corner.	block := [:wr :sub | wr globalBounds corner]</body><body package="UIPainter">asDividerCorner	selector := #corner.	block := [:wr :sub | sub orientation == #vertical 		ifTrue: [wr globalBounds bottomLeft]		ifFalse: [wr globalBounds topRight]]</body><body package="UIPainter">asOrigin	selector := #origin.	block := [:wr :sub | wr globalBounds origin]</body><body package="UIPainter">asTopRight	selector := #topRight.	block := [:wr :sub | wr globalBounds topRight]</body><body package="UIPainter">initialize	isPrimary := true.	extent := 8@8</body></methods><methods><class-id>Tools.DragHandle</class-id> <category>bounds accessing</category><body package="UIPainter">bounds	"Answer a Rectangle that represents the receiver's actual bounding rectangle."	^Rectangle origin: self getOrigin - (extent // 2) extent: extent</body><body package="UIPainter">preferredExtent		^extent</body></methods><methods><class-id>Tools.DragHandle class</class-id> <category>instance creation</category><body package="UIPainter">wrapper: aWrapper subject: aSubject isPrimary: aBoolean	| dh |	dh := self new.	dh wrapper: aWrapper.	dh subject: aSubject.	dh isPrimary: aBoolean.	^dh</body></methods><methods><class-id>Tools.NullDragModeTracker</class-id> <category>drag drop</category><body package="UIPainter">dragOverWidgets: aDragDropContext	"Do Nothing"</body></methods><methods><class-id>Tools.UIPainterSystemController</class-id> <category>menu messages</category><body package="UIPainter">redButtonPressedEvent: anEvent</body><body package="UIPainter">resize	"Resize the receiver's window."	| max min |	self sensor cursorPoint: view extent.	view displayBox:		(Screen default			resizeRectangle: (view globalOrigin extent: view extent)			minimumExtent: ((min := model minWindowExtent) isNil						ifTrue: [view minimumSize]						ifFalse: [min])			resizeIncrement: 1@1			boundedBy:				(view globalOrigin extent:					((max := model maxWindowExtent) isNil						ifTrue: [view maximumSize]						ifFalse: [max]))			whileButton: 0			isDown: false)</body></methods><methods><class-id>Tools.UIPalette</class-id> <category>private-icons</category><body package="UIPainter">adaptButton: newButtonSpec toRepresent: aSpec 	"Given aSpec and a prototype spec create a new spec for a 	button containing proper label and model. Add 	visual to the dictionary in builder."	| sName iconName |	sName := aSpec name.	iconName := (sName , 'Icon') asSymbol.	newButtonSpec model: sName.	builder visualAt: iconName put: aSpec paletteIconImage.	newButtonSpec label: iconName.	builder aspectAt: sName put: (self adaptorFor: aSpec fullName)</body><body package="UIPainter">iconView	"Return a visual component able to house palette's icons."	^CompositePart new.</body><body package="UIPainter">numberOfColumns	"The palette has fixed width == 17 icons"	^17</body><body package="UIPainter">populateSpec: prototypeSpec 	"Replicate a prototype spec by creating clones and changing the layout.	Also send adaptButton:toRepresent: message to chage button's properties.	The layout algorithm is 'numberOfColumns' icons in a row in the window."	| width height maximumColumns iconPosition currentColumn firstX rows rect finalExtent |	rect := (prototypeSpec layout rectangleRelativeTo: builder window bounds preferred: nil).	width := rect width.	height := rect height.	maximumColumns := self numberOfColumns.	iconPosition := 0 @ 0.	firstX := iconPosition x.	currentColumn := 0. 	activeSpecs		do: 			[:spec | 			| newButtonSpec |			newButtonSpec := prototypeSpec copy.			newButtonSpec helpText: spec componentName.			newButtonSpec layout: prototypeSpec layout copy.			(newButtonSpec layout) 				leftOffset: newButtonSpec layout leftOffset + iconPosition x;				rightOffset: newButtonSpec layout rightOffset + iconPosition x;				topOffset: newButtonSpec layout topOffset + iconPosition y;				bottomOffset: newButtonSpec layout bottomOffset + iconPosition y.			self adaptButton: newButtonSpec toRepresent: spec.			builder add: newButtonSpec.			currentColumn := currentColumn + 1.			(currentColumn \\ maximumColumns) isZero				ifTrue: 					[iconPosition := iconPosition + (0 @ height).					iconPosition x: firstX]				ifFalse: [iconPosition := iconPosition + (width @ 0)]].	rows := currentColumn - 1 // maximumColumns.	finalExtent := 0 @ (rows * height).	finalExtent := builder window minimumSize + finalExtent.	(builder window) changeExtent: finalExtent; minimumSize: finalExtent; maximumSize: finalExtent.</body><body package="UIPainter">reBuildIcons: aBuilder	"Add icons if the iconic palette is in use"	| composite prototypeSpec  | 	composite := aBuilder componentAt: #iconView.	composite isNil ifTrue: [^self].	composite := composite widget.	composite releaseAllComponents.	aBuilder newComposite: composite.	prototypeSpec  := self class interfaceSpecFor: #iconPrototypeSpec.	self populateSpec: prototypeSpec.	aBuilder endComposite.</body><body package="UIPainter">rebuildActiveSpecs	"Take a list of symbols and build a list containing classes.	If the symbol is not a valid class name do not add ot to the list."	self updateActiveSpecs.	self reBuildIcons: builder</body><body package="UIPainter">updateActiveSpecs	"Take a list of symbols and build a list containing classes.	If the symbol is not a valid class name do not add ot to the list."	activeSpecs := OrderedCollection new.	self class activeSpecsList do: 		[:each | 		each asQualifiedReference ifDefinedDo: [:class | activeSpecs add: class]]</body><body package="UIPainter">updateSize	(#(#MSWindows4 #MSWindows5 #MSWindowsXP) includes: (LookPreferences probableLAFAndHWMgr at: 2)) ifTrue: 		[(builder window) hibernate;  recreate; finishOpening]</body></methods><methods><class-id>Tools.UIPalette</class-id> <category>private</category><body package="UIPainter">adaptorFor: aSpecClassName	^(PluggableAdaptor on: self currentModeHolder)		getBlock: 			[:model | 			| class |			(class := model value specClass) notNil and: [class name == aSpecClassName]]		putBlock:			[:model :value |			value				ifTrue: 					[self checkForSticky						ifTrue: [self makeSticky]						ifFalse: [model value class == #{SelectModeTracker} value ifFalse: [self noSticky]].					model value: (self placementFeelFor: aSpecClassName)]				ifFalse: 					[(model value isKindOf: #{SelectModeTracker} value) 						ifFalse: [model value: #{SelectModeTracker} value new]]]				updateBlock: [:model :value :performer | true]</body><body package="UIPainter">checkForSticky	^builder window sensor shiftDown</body><body package="UIPainter">currentModeHolder	^self class currentModeHolder</body><body package="UIPainter">makeSticky	UIPainterController modeIsSticky ifFalse: 		[UIPainterController modeIsSticky: true.		self stickyStatus value: (#StickyOn &lt;&lt; #UIPainter &gt;&gt; 'Sticky On') asString].	self setStickyButtons: true</body><body package="UIPainter">newSpec	"The selection on palette has changed update the name box."	| class |	class := self currentModeHolder value specClass.	toolName 		value: ((class isNil or: [class == #{SelectModeTracker} value])			ifTrue: ['']			ifFalse: [class componentName])</body><body package="UIPainter">noSticky	(self class currentMode isKindOf: SpecPlacementModeTracker)		ifTrue: [self class currentMode cancelDragDrop].	UIPainterController modeIsSticky ifTrue: 		[self stickyStatus value: (#NotSticky &lt;&lt; #UIPainter &gt;&gt; 'Not Sticky') asString.		UIPainterController modeIsSticky: false].	self setStickyButtons: false</body><body package="UIPainter">painterController	^UIPainterController lastControllerWithSelectionChannel value</body><body package="UIPainter">placementFeelFor: aSpecClassName	^UIPainter placementFeelClass forSpecClass: aSpecClassName asQualifiedReference value</body><body package="UIPainter">toolName	^toolName</body><body package="UIPainter">trapEscOnDrop	^[:event :object |	(event keyValue == Character esc)		ifTrue: 			[self class currentMode cancelDragDrop.			nil] 		ifFalse: [event]]</body></methods><methods><class-id>Tools.UIPalette</class-id> <category>initialize-release</category><body package="UIPainter">canvasClosing	(UIPainter allInstances select: [:each | each mainWindow notNil and: [each mainWindow key notNil]]) size &lt;= 1		ifTrue: [self closePalette]</body><body package="UIPainter">initialize	"Make sure that toolName is in sync with	the current selection."	super initialize.	toolName := String new  asValue.	self currentModeHolder onChangeSend: #newSpec to: self.	self updateActiveSpecs</body><body package="UIPainter">noticeOfWindowClose: aWindow	"The ApplicationWindow aWindow is in the process of closing.  You have been notified."	self release</body><body package="UIPainter">release	"Make sure that toolName is in sync with the current selection."	(UIPainter allInstances select: [:each | each mainWindow notNil])		do: [:each | each mainWindow removeAllActionsWithReceiver: self].	UIPainterController lastControllerWithSelectionChannel removeDependent: self.	self currentModeHolder retractInterestsFor: self.	super release</body></methods><methods><class-id>Tools.UIPalette</class-id> <category>controller delegated</category><body package="UIPainter">alignBottom	self painterController doVerticalAlign: #bottom forceNoPrimary: false</body><body package="UIPainter">alignHCenter	self painterController doHorizontalAlign: #center forceNoPrimary: false</body><body package="UIPainter">alignLeft	self painterController doHorizontalAlign: #left forceNoPrimary: false</body><body package="UIPainter">alignRight	self painterController doHorizontalAlign: #right forceNoPrimary: false</body><body package="UIPainter">alignTop	self painterController doVerticalAlign: #top forceNoPrimary: false</body><body package="UIPainter">alignVCenter	self painterController doVerticalAlign: #center forceNoPrimary: false</body><body package="UIPainter">distributeLTRCenters	self painterController doHorizontalDistribute: #centers spacing: nil</body><body package="UIPainter">distributeLTREdges	self painterController doHorizontalDistribute: #edges spacing: nil</body><body package="UIPainter">distributeTTBCenters	self painterController doVerticalDistribute: #centers spacing: nil</body><body package="UIPainter">distributeTTBEdges	self painterController doVerticalDistribute: #edges spacing: nil</body><body package="UIPainter">doCopy	self painterController doCopy</body><body package="UIPainter">doCut	self painterController doCut</body><body package="UIPainter">doOpen	self painterController doOpen</body><body package="UIPainter">doPaste	self painterController doPaste</body><body package="UIPainter">equalizeBoth	self		equalizeHeight; 		equalizeWidth.</body><body package="UIPainter">equalizeHeight	self painterController doVerticalSizing: #first spacing: nil</body><body package="UIPainter">equalizeWidth	self painterController doHorizontalSizing: #first spacing: nil</body><body package="UIPainter">openPainterTool	self painterController doPainterTool</body></methods><methods><class-id>Tools.UIPalette</class-id> <category>interface opening</category><body package="UIPainter">postBuildWith: aBuilder	"Add icons if the iconic palette is in use"	| composite prototypeSpec  | 	composite := aBuilder componentAt: #iconView.	composite isNil ifTrue: [^self].	composite := composite widget.	aBuilder newComposite: composite.	prototypeSpec  := self class interfaceSpecFor: #iconPrototypeSpec.	self populateSpec: prototypeSpec.	aBuilder endComposite.	self stickyStatus value: (#NotSticky &lt;&lt; #UIPainter &gt;&gt; 'Not Sticky') asText allBold.	aBuilder window keyboardProcessor keyboardHook: self trapEscOnDrop</body><body package="UIPainter">postOpenWith: aBuilder	self disableToolbarButtons.	self enableToolbarButtons.	self setStickyButtons: false.	self adjustMenu</body><body package="UIPainter">preBuildWith: aBuilder	"Install binding for special select and sticky icons."		self class currentMode: #{SelectModeTracker} value new. 	builder 		aspectAt: #Sticky 		put: UIPainterController stickyMode.	builder 		aspectAt: #Select 		put:			((PluggableAdaptor on: self currentModeHolder)				getBlock: [:m | m value class == #{SelectModeTracker} value]				putBlock: 					[:m :v | 					self noSticky.					m value: #{SelectModeTracker} value new]				updateBlock: [:m :v :p | true]).</body></methods><methods><class-id>Tools.UIPalette</class-id> <category>menu manipulation</category><body package="UIPainter">adjustMenu	| selections arrangeButton openWindowMenuItem |	self painterController isNil ifTrue: [^self].	selections := self painterController selections.	arrangeButton := builder window menuBar menuButtons			at: ((builder menuAt: #mainMenu) menuItems				indexOf: ((builder menuAt: #mainMenu) atNameKey: #arrangeMenu)). 	(selections isNil or: [selections size &lt;= 1])		ifTrue: 			[arrangeButton isEnabled: false.			self disableAdjustButtons]		ifFalse: 			[arrangeButton isEnabled: true.			self enableAdjustButtons].	openWindowMenuItem := (builder window menuBar menuButtons at: 1) menu atNameKey: #doOpen.	self painterController model targetClass isNil		ifTrue: [openWindowMenuItem disable]		ifFalse: [openWindowMenuItem enable]</body><body package="UIPainter">disableAdjustButtons	| buttons |	buttons := builder componentAt: #paletteToolBar.	self nonStickyButtons do: [:each | (buttons componentAt: each) isEnabled: false]</body><body package="UIPainter">disableToolbarButtons	(builder componentAt: #paletteToolBar) components do: [:each | each isEnabled: false]</body><body package="UIPainter">enableAdjustButtons	| buttons |	buttons := builder componentAt: #paletteToolBar.	self nonStickyButtons do: [:each | (buttons componentAt: each) isEnabled: true]</body><body package="UIPainter">enableToolbarButtons	(builder componentAt: #paletteToolBar) components do: [:each | each isEnabled: true]</body><body package="UIPainter">nonStickyButtons	^#(#distributeLTRCentersID #equalizeHeightID #alignTopID 	#alignBottomID #distributeLTREdgesID #alignVCenterID #alignLeftID 	#distributeTTBCentersID #alignHCenterID #equalizeWidthD 	#distributeTTBEdgesID #alignRightID #equalizeBoth)</body><body package="UIPainter">setStickyButtons: aBoolean	| buttons |	buttons := builder componentAt: #paletteToolBar.	(buttons componentAt: #makeSticky) isEnabled: aBoolean not</body></methods><methods><class-id>Tools.UIPalette</class-id> <category>updating</category><body package="UIPainter">update: anAspect with: parameter from: anObject	(builder window notNil and: [builder window key notNil and: [builder window isCollapsed not]])		ifFalse: [^self]. 	(#(#selectionChange #value #openedCanvas) includes: anAspect)		ifTrue: [self adjustMenu].	super update: anAspect with: parameter from: anObject</body></methods><methods><class-id>Tools.UIPalette</class-id> <category>aspects</category><body package="UIPainter">stickyStatus	^stickyStatus isNil 		ifTrue: [stickyStatus := String new asValue]		ifFalse: [stickyStatus]</body></methods><methods><class-id>Tools.UIPalette</class-id> <category>actions</category><body package="UIPainter">closePalette	self release.	self closeRequest</body><body package="UIPainter">helpAbout	AboutVisualWorksDialog open</body><body package="UIPainter">helpPalette	'topic:vw.help.tools.guiPalette' asURI open</body><body package="UIPainter">helpUserInterfacePainter	'topic:vw.help.tools.painter' asURI open</body></methods><methods><class-id>Tools.UIPalette class</class-id> <category>accessing-specs</category><body package="UIPainter">activeSpecsList	^ActiveSpecsList</body></methods><methods><class-id>Tools.UIPalette class</class-id> <category>private</category><body package="UIPainter">addSystemSpecs	"Add the system icons."	self standardSpecsForPalette do: [:spec | self activeSpecsList add: spec]</body><body package="UIPainter">currentMode	^CurrentMode value</body><body package="UIPainter">currentMode: aControlMode	CurrentMode value: aControlMode</body><body package="UIPainter">currentModeHolder	^CurrentMode</body><body package="UIPainter">flushIcons	"Drop the icon cache."	"UIPalette flushIcons"	selectIcon := nil.	stickyIcon := nil</body><body package="UIPainter">palettePlaceNear: mainWindow for: palExtent 	" palRectangle is passed in so that palette dimensions can vary dynamically. 	Return the preferred position for the origin (upper right) corner of the palette. 	Use user preference to establish the (unknown and unknowable) host window 	manager, on whose identity the proper offset depends."	| mainRectangle hackFactor screenBounds |	hackFactor := 0 @ 35.	mainRectangle := mainWindow getDisplayBox.	screenBounds := mainWindow == nil		ifTrue: [Screen default bounds]		ifFalse: [mainWindow screen bounds].	^Point		x: (((mainRectangle origin x + hackFactor x)			max: screenBounds left) min: screenBounds right)		y: (((mainRectangle origin y - hackFactor y - palExtent y)			max: screenBounds top) min: screenBounds bottom).</body><body package="UIPainter">standardSpecsForPalette	^#(#{UI.ActionButtonSpec} #{UI.CheckBoxSpec} #{UI.RadioButtonSpec} #{UI.SpinButtonSpec} #{UI.LabelSpec}	#{UI.InputFieldSpec} #{UI.TextEditorSpec} #{UI.MenuButtonSpec} #{UI.SequenceViewSpec} #{UI.ComboBoxSpec}	#{UI.HierarchicalViewSpec} #{UI.TreeViewSpec} #{UI.DividerSpec} #{UI.GroupBoxSpec} #{UI.ResizingSplitterSpec}	#{UI.RegionSpec} #{UI.ArbitraryComponentSpec} #{UI.SubCanvasSpec} #{UI.MappedClickWidgetSpec} #{UI.SliderSpec}	#{UI.ProgressWidgetSpec} #{UI.TableViewSpec} #{UI.DataSetSpec} #{UI.TabControlSpec} #{UI.DocumentViewSpec} #{UI.DocumentEditorSpec} #{UI.InputEditorSpec} )</body></methods><methods><class-id>Tools.UIPalette class</class-id> <category>class initialization</category><body package="UIPainter">initialize	"UIPalette initialize."	super initialize.	CurrentMode := ValueHolder new.	CurrentMode value: #{SelectModeTracker} value new.	ActiveSpecsList := OrderedCollection new.	self addSystemSpecs</body></methods><methods><class-id>Tools.UIPalette class</class-id> <category>resources</category><body package="UIPainter">iconPrototypeSpec	"Answer a prototype of an action button. This spec is copied 	modified and populated on the palette's window."	^#(#ActionButtonSpec 		#layout: #(#LayoutFrame 5 0 8 0 35 0 38 0) 		#flags: 0 		#name: #specIcon 		#tabable: false 		#hasCharacterOrientedLabel: false)</body></methods><methods><class-id>Tools.UIPalette class</class-id> <category>interface opening</category><body package="UIPainter">openPaletteNear: aWindow	"mainWindow is the (main) canvas window, or nil if the Palette location is 	to come from the user."	| builder palette | 	palette := self new.	builder :=  palette allButOpenInterface: #windowSpec. 	builder openAt: (self palettePlaceNear: aWindow for: builder window extent).	builder window label: (#Palette &lt;&lt; #UIPainter &gt;&gt; 'Palette').	palette postOpenWith: builder.	UIPainterController lastControllerWithSelectionChannel addDependent: palette.	aWindow when: #closing send: #canvasClosing to: palette.	^builder window</body></methods><methods><class-id>Tools.BitView</class-id> <category>accessing</category><body package="UIPainter">gridding	"Answer with the receiver's gridding."	^gridding</body><body package="UIPainter">gridding: aPoint	"Set the receiver's gridding to be aPoint."	gridding := aPoint.	pixmap notNil ifTrue: [ pixmap close ].</body><body package="UIPainter">imageAtPoint: aPoint	"Map aPoint onto the scaled image, and answer the image point	touched, or nil if aPoint doesn't map onto the image."	| p |	p := aPoint // scale.	^(model containsPoint: p) ifTrue: [ p ] ifFalse: [ nil ]</body><body package="UIPainter">model: aModel	super model: aModel.	pixmap notNil ifTrue: [ pixmap close ].	self fixScrollingOffset</body><body package="UIPainter">scale	^scale</body><body package="UIPainter">scale: aPoint	scale := aPoint.	pixmap notNil		ifTrue: [ pixmap close ].</body></methods><methods><class-id>Tools.BitView</class-id> <category>controller accessing</category><body package="UIPainter">defaultControllerClass	^BitEditor</body></methods><methods><class-id>Tools.BitView</class-id> <category>private</category><body package="UIPainter">fixScrollingOffset	"Make sure that the scrolling offset is valid."	| wrap | 	wrap := self container.	wrap isNil 		ifFalse: [wrap scrollOffsetHolder valueWithoutDisplaying: (wrap validateScrollPosition: wrap translation)]</body><body package="UIPainter">pixmap	"Answer with the receiver's pixmap.  If none is open, create a new one."	"Initialize the pixmap from the image, with a gridded overlayed."	| gc width height |	( pixmap isNil or: [ pixmap isOpen not ] ) ifTrue:		[ pixmap := Pixmap extent: model extent * self scale.		policy := OrderedDither new.		((model magnifiedBy: scale)			convertToPalette: pixmap palette			renderedBy: OrderedDither new)				displayOn: pixmap graphicsContext.		(gc := pixmap graphicsContext)			paint: ColorValue gray.		width := model width * scale x.		height := model height * scale y.		1 to: model width do:			[ :x | | sx |			sx := x * scale x.			gc displayLineFrom: sx @ 0 to: sx @ height ].		1 to:  model height do:			[ : y | | sy |			sy := y * scale y.			gc displayLineFrom: 0 @ sy to: width @ sy ].		gc paint: ColorValue black.		0 to: model width by: gridding x do:			[ :x | | sx |			sx := x * scale x.			gc displayLineFrom: sx @ 0 to: sx @ height ].		0 to: model height by: gridding y do:			[ :y | | sy |			sy := y * scale y.			gc displayLineFrom: 0 @ sy to: width @ sy ] ].	^pixmap</body></methods><methods><class-id>Tools.BitView</class-id> <category>updating</category><body package="UIPainter">update: aSymbol with: aRect 	aSymbol = #invalidate ifTrue: 		[| pixel r paint |		"aRect is in model (i.e. Image) coordinates."		aRect left to: aRect right - 1 do:			[:x |			aRect top to: aRect bottom - 1 do: 				[:y | 				pixel := model atPoint: x @ y.				paint := policy					renderPaint: (model palette at: pixel)					usingPalette: self topComponent palette					on: self topComponent graphicsDevice.				(self pixmap graphicsContext)					setDevicePattern: paint;					displayRectangle: (r := (x @ y * self scale + 1 extent: self scale - 1)).				(self graphicsContext)					setDevicePattern: paint;					displayRectangle: r]]]</body></methods><methods><class-id>Tools.BitView</class-id> <category>initialize-release</category><body package="UIPainter">initialize	super initialize.	scale := 8@8.	gridding := 8@8.</body></methods><methods><class-id>Tools.BitView</class-id> <category>displaying</category><body package="UIPainter">displayOn: aGraphicsContext	self pixmap displayOn: aGraphicsContext</body></methods><methods><class-id>Tools.BitView</class-id> <category>bounds accessing</category><body package="UIPainter">preferredExtent	^self pixmap preferredExtent</body></methods><methods><class-id>Tools.BitView class</class-id> <category>instance creation</category><body package="UIPainter">openOn: anImage 	"BitView openOn: Image fromUser"	"BitView openOn: (Image extent: 64@64 depth: 1 palette: MappedPalette 	whiteBlack)"	self openOn: anImage scale: 8@8</body><body package="UIPainter">openOn: anImage scale: aScale	"BitView openOn: (Image extent: 80@80 depth: 1 palette: MappedPalette whiteBlack) scale: 8@8"	| top view composite  w h |	top := ScheduledWindow new.	top label: (#BitEditor &lt;&lt; #UIPainter &gt;&gt; 'Bit Editor').	top component: (composite := CompositePart new).	view := self model: anImage.	view scale: aScale.	view := BorderedWrapper on: view.	view layout: (LayoutFrame new					rightOffset: (w := view preferredWidth);					bottomOffset: (h := view preferredHeight)).	composite add: view.	view := BorderedWrapper on: anImage.	anImage addDependent: view.	view layout: (LayoutFrame new					topOffset: h;					rightOffset: view preferredWidth;					bottomOffset: (h := h + view preferredHeight)).	composite add: view.	top openWithExtent: w@h.	^anImage</body></methods><methods><class-id>Tools.CornerDragModeTracker</class-id> <category>drag drop</category><body package="UIPainter">dragOverWidgets: aDragDropContext 	| currentPoint targetBounds controllerGrid |	(currentPoint := controller sensor mousePoint) = lastShowPoint 		ifTrue: [^self].	controllerGrid := controller gridValue.	controller sensor shiftDown 		ifTrue: 			[currentPoint := self constrainOrthogonally: currentPoint].	controller isFenced 		ifTrue: 			[currentPoint := self containedPointFor: currentPoint						in: controller view bounds].	self adjust: currentPoint toGrid: controllerGrid.	currentPoint = lastShowPoint ifTrue: [^self].	targetBounds := self 				stretchRectangle: originalBounds				from: lastShowPoint				to: currentPoint.	controller view 		newBounds: targetBounds		oldBounds: originalBounds		forWrapper: dragObject wrapper.	originalBounds := targetBounds.	lastShowPoint := currentPoint</body><body package="UIPainter">preDragDrop	drawByXAxis := drawByYAxis := false.	lastShowPoint := dragObject getOrigin.	originalBounds := dragObject wrapper bounds</body></methods><methods><class-id>Tools.CornerDragModeTracker</class-id> <category>private</category><body package="UIPainter">constrainOrthogonally: currentPoint 	"Constrain orthoPoint to differ from currentPoint in only one dimension, 	either x or y depending on whether drawByXAxis or drawByYAxis is true, so that handles 	and figures can be constrained to move only in a single dimension."	| diffVector orthoPoint |	diffVector := (currentPoint - lastShowPoint) abs.	diffVector &lt; (2 @ 2) ifTrue: [drawByXAxis := drawByYAxis := false].	drawByXAxis | drawByYAxis 		ifFalse: 			[drawByXAxis := diffVector x &gt; diffVector y.			drawByYAxis := diffVector x &lt; diffVector y].	orthoPoint := currentPoint.	drawByXAxis ifTrue: [orthoPoint := currentPoint x @ lastShowPoint y].	drawByYAxis ifTrue: [orthoPoint := lastShowPoint x @ currentPoint y].	^orthoPoint</body></methods><methods><class-id>Tools.SpecPlacementModeTracker</class-id> <category>private</category><body package="UIPainter">cancelDragDrop	dragee := nil.	UIPalette currentMode: #{SelectModeTracker} value new</body><body package="UIPainter">getSpecGenBlockForClass: aSpecClass	^self class specGenBlockForClass: aSpecClass</body><body package="UIPainter">specFor: aController at: aPoint	^self specGenBlock value: aController value: aPoint</body></methods><methods><class-id>Tools.SpecPlacementModeTracker</class-id> <category>accessing</category><body package="UIPainter">specClass	^specClass</body><body package="UIPainter">specClass: aSpecClass		specClass := aSpecClass</body><body package="UIPainter">specGenBlock	^specGenBlock</body><body package="UIPainter">specGenBlock: aBlock 	"The specGenBlock should take two arguments: the controller for 	the window being entered, and the coordinate of the entry point."	specGenBlock := aBlock</body></methods><methods><class-id>Tools.SpecPlacementModeTracker</class-id> <category>initialize-release</category><body package="UIPainter">initialize	specClass notNil ifTrue: [specGenBlock := self getSpecGenBlockForClass: specClass]</body></methods><methods><class-id>Tools.SpecPlacementModeTracker</class-id> <category>events</category><body package="UIPainter">mouseMovedEvent: anEvent 	^nil</body></methods><methods><class-id>Tools.SpecPlacementModeTracker class</class-id> <category>private</category><body package="UIPainter">placementExtentFor: aSpecClass inBuilder: aBuilder	| blk |	blk := self placementExtentBlockFor: aSpecClass.	^blk == nil		ifTrue: [aSpecClass defaultPlacementExtentInBuilder: aBuilder]		ifFalse: [blk value: aBuilder]</body><body package="UIPainter">placementExtentFor: aSpecClass withLabel: aString inBuilder: aBuilder	| blk |	blk := self placementExtentBlockFor: aSpecClass.	^blk == nil		ifTrue: [aSpecClass defaultPlacementExtentInBuilder: aBuilder]		ifFalse: [blk value: aString value: aBuilder]</body></methods><methods><class-id>Tools.SpecPlacementModeTracker class</class-id> <category>instance creation</category><body package="UIPainter">forSpecClass: aSpecClass	^(self new specClass: aSpecClass) initialize</body></methods><methods><class-id>Tools.SpecPlacementModeTracker class</class-id> <category>accessing</category><body package="UIPainter">placementExtentBlockFor: aSpecClass	^aSpecClass placementExtentBlock</body><body package="UIPainter">specGenBlockForClass: aSpecClass	^aSpecClass specGenerationBlock</body></methods><methods><class-id>Tools.DragPlacementModeTracker</class-id> <category>events</category><body package="UIPainter">enterEvent: anEvent 	lock ifTrue:[^self].	dragee ifNotNil: 			[lock := true.			[(dragee container controller)				quietlySelect: dragee;				doDelete] ensure: [lock := false]].	controller builder add: (self specFor: controller				at: (lastShowPoint := controller view 								globalPointToLocal: (controller gridPoint: anEvent point))).	dragee := controller builder wrapper.	targetWindow := anEvent window.	^super enterEvent: anEvent</body><body package="UIPainter">exitEvent: anEvent		dragee notNil ifTrue:		[controller view removeComponent: dragee.		dragee release.		dragee := nil].	^super exitEvent: anEvent</body><body package="UIPainter">mouseMovedEvent: anEvent 	targetWindow == anEvent window 		ifTrue: 			[| newPoint |			newPoint := controller view 						globalPointToLocal: (controller gridPoint: anEvent point).			(lastShowPoint y ~= newPoint y or: [lastShowPoint x ~= newPoint x]) 				ifFalse: [^nil].			controller view move: dragee to: newPoint.			lastShowPoint := newPoint]		ifFalse: [self enterEvent: anEvent]</body><body package="UIPainter">redButtonPressedEvent: anEvent	| formerDragee handle |	controller quietlyRemoveSelections.	controller quietlySelect: dragee.	formerDragee := dragee.	dragee := nil.	(self class placementExtentBlockFor: formerDragee spec class) notNil		ifTrue: 			[controller sensor cursorPoint: formerDragee component bounds corner.			dragee := nil.			handle := controller handles detect: [:h | h selector == #corner].			(controller dragModeFor: handle)				dragObject: handle				startingAt: (controller view globalPointToLocal: anEvent point)				inController: controller]		ifFalse: 			[controller canvasHasChanged: true].	controller modeIsSticky		ifTrue: 			[controller builder add:				(self specFor: controller at: (controller view globalPointToLocal: anEvent point)).			dragee := controller builder wrapper]		ifFalse:			[UIPalette currentMode: #{SelectModeTracker} value new].</body></methods><methods><class-id>Tools.DragPlacementModeTracker</class-id> <category>private</category><body package="UIPainter">cancelDragDrop	controller isNil ifFalse:		[controller quietlyRemoveSelections.		controller quietlySelect: dragee.		controller doDelete].	super cancelDragDrop</body></methods><methods><class-id>Tools.DragPlacementModeTracker</class-id> <category>initialize-release</category><body package="UIPainter">initialize	super initialize.	lock := false.</body></methods><methods><class-id>UI.HotSlice</class-id> <category>accessing</category><body package="UIPainter">index	^index</body><body package="UIPainter">index: aValue	index := aValue</body><body package="UIPainter">mask	^mask isNil ifFalse: [mask] 		ifTrue: [mask := parentRegions maskForIndex: self index].</body><body package="UIPainter">mask: aValue	mask := aValue</body><body package="UIPainter">parentRegions	^parentRegions</body><body package="UIPainter">parentRegions: aValue	parentRegions := aValue</body><body package="UIPainter">selector	^selector</body><body package="UIPainter">selector: aValue	selector := aValue.	self changed</body></methods><methods><class-id>UI.HotSlice</class-id> <category>private</category><body package="UIPainter">install	"update parent HotRegions to reflect this slice's current state"	parentRegions acceptSlice: self.</body></methods><methods><class-id>UI.HotSlice</class-id> <category>printing</category><body package="UIPainter">displayString	selector isNil ifTrue: [^(#none1 &lt;&lt; #UIPainter &gt;&gt; '[none]') asString].	^selector printString</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>controller delegated</category><body package="UIPainter">alignDialog	controller alignDialog</body><body package="UIPainter">beFixed	controller beFixedKey: nil</body><body package="UIPainter">beRelative	controller beRelativeKey: nil</body><body package="UIPainter">distributeDialog	controller distributeDialog</body><body package="UIPainter">doAccept	controller accept</body><body package="UIPainter">doBrowse	controller doBrowse</body><body package="UIPainter">doBrowseApplication	controller doBrowseApplication</body><body package="UIPainter">doCancel	controller cancel</body><body package="UIPainter">doCatalogID	controller doCatalogID</body><body package="UIPainter">doCopy	controller doCopy</body><body package="UIPainter">doCut	controller doCut</body><body package="UIPainter">doDefine	controller doDefine</body><body package="UIPainter">doDefineApplication	controller doDefineApplication</body><body package="UIPainter">doExtractSubCanvas 	controller doExtractSubCanvas</body><body package="UIPainter">doFileOutNamedFonts	controller doFileOutNamedFonts</body><body package="UIPainter">doGroup	controller doGroup</body><body package="UIPainter">doInstall	controller doInstall</body><body package="UIPainter">doInstallNamedFonts	controller doInstallNamedFonts</body><body package="UIPainter">doMakeBounded	controller doMakeBounded</body><body package="UIPainter">doMakeUnBounded	controller doMakeUnBounded</body><body package="UIPainter">doNameAll	controller doNameAll</body><body package="UIPainter">doNamedFonts	controller doNamedFonts</body><body package="UIPainter">doOpen	controller doOpen</body><body package="UIPainter">doPaintApplication	controller doPaintApplication</body><body package="UIPainter">doPalette	"Open a new palette."	controller doPalette</body><body package="UIPainter">doPaste	controller doPaste</body><body package="UIPainter">doSpawn	controller doSpawn</body><body package="UIPainter">doUngroup	controller doUngroup</body><body package="UIPainter">equalizeDialog	controller equalizeDialog</body><body package="UIPainter">fractionalConstraintDialog	controller fractionalConstraintDialog</body><body package="UIPainter">maskEditor	"Open mask editor."	controller maskEditor</body><body package="UIPainter">menuEditor	"Open menu editor."	controller menuEditor</body><body package="UIPainter">openReusableComponents	"If the Lens is loaded then open a canvas editor on the #reusableComponents spec of LensDataManager."	#{LensDataManager} ifDefinedDo:		[:definedClass| UIPainter new openOnClass: definedClass andSelector: #reusableComponents]</body><body package="UIPainter">regionsEditor	"Open menu editor."	controller regionsEditor</body><body package="UIPainter">setAllWindowInfo	controller setAllWindowInfo</body><body package="UIPainter">setWindowMaxSize	controller setWindowMaxSize</body><body package="UIPainter">setWindowMinSize	controller setWindowMinSize</body><body package="UIPainter">setWindowPrefSize	controller setWindowPrefSize</body><body package="UIPainter">setWindowToDefaults	controller setWindowToDefaults</body><body package="UIPainter">snapToGrid	controller doSnapSelectionToGrid</body><body package="UIPainter">toVisualBack	controller toVisualBack</body><body package="UIPainter">toVisualBackOne	controller toVisualBackOne</body><body package="UIPainter">toVisualFront	controller toVisualFront</body><body package="UIPainter">toVisualFrontOne	controller toVisualFrontOne</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>drag and drop</category><body package="UIPainter">canAcceptDropFrom: aContext 	"Answer true if an input field can accept a drop from aContext. For now, this 	means that the drop is a selector of zero or one arguments."	^aContext key == #selector 		and: [aContext sourceData clientData notNil		and: [(aContext sourceData clientData at: #selector) numArgs &lt; 2]]</body><body package="UIPainter">dragEnterSelectorAspect: aDragContext	|  ctrl | 	(self canAcceptDropFrom: aDragContext) ifFalse: [^#dropEffectNone].	ctrl := aDragContext clientData at: #ctrl.	aDragContext clientData at: #hasFocus put: ctrl view hasFocus.	ctrl view hasFocus: true.	^#dropEffectMove</body><body package="UIPainter">dragLeaveSelectorAspect: aDragContext	| c |	(self canAcceptDropFrom: aDragContext) 		ifFalse: [^#dropEffectNone].	c := aDragContext clientData at: #ctrl.	c view hasFocus: (aDragContext clientData at: #hasFocus).	^#dropEffectNone</body><body package="UIPainter">dragOverSelectorAspect: aDragContext 	^(self canAcceptDropFrom: aDragContext)		ifTrue: [#dropEffectMove]		ifFalse: [#dropEffectNone]</body><body package="UIPainter">dropInSelectorAspect: aDragContext	| selData |	(self canAcceptDropFrom: aDragContext) ifFalse: [^#dropEffectNone].	selData := aDragContext sourceData clientData at: #selector ifAbsent: [^#dropEffectNone].	(aDragContext clientData at: #ctrl) model value: selData.	^#dropEffectMove</body><body package="UIPainter">setDropTargets	"Set up any potential drop targets."	self subBuilder namedComponents values		do: 			[:aWrapper | 			| target |			target := aWrapper dropTarget.			target isNil				ifFalse: 					[| id |					id := IdentityDictionary new.					id at: #ctrl put: aWrapper widget controller.					target clientData: id]]</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>actions</category><body package="UIPainter">apply	"Copy the information in 'currentSpecCopy' to the selected components."	| labelM labelConstructor |	currentSpecCopy isDataValid ifFalse: [^self].	(controller == nil or: [controller view == nil]) ifTrue: [^self].	lock := true.	client preapply.	selectionKind == #single 		ifTrue: 			["replaceElement:etc. will cause change to be noted, and  select: will cause UIPainterWatchers to be alerted."			| selElem sel spec doReselect doInvalidate |			selElem := selection first.			sel := controller selectionList.			doReselect := sel size = 1 and: [sel first = selElem].			spec := currentSpecCopy copy.			doInvalidate := (spec getLabel isNil or: [selElem spec getLabel isNil]) not.			(spec shouldCompareLayouts: selElem spec) ifTrue: 				[spec layout: selElem spec layout.				currentSpecCopy layout = spec layout ifFalse: [currentSpecCopy layout: spec layout]].			selElem := controller 				replaceElement: selElem 				basedOnSpec: spec.			selection := Array with: selElem.			doReselect ifTrue: [controller select: selElem].			doInvalidate ifTrue: [currentView invalidate]]		ifFalse: 			[selectionKind == #multi				ifTrue: 					[| newSelection spec controllerSelections | 					newSelection := OrderedCollection new: selection size.					controllerSelections := controller selectionList.					controllerSelections copy do: 						[:selElem | 						spec := selElem spec copy.						currentSpecCopy copyPropertiesTo: spec.						newSelection add: (controller 							replaceElement: selElem 							basedOnSpec: spec)].					selection := newSelection.					controller selectionList: newSelection.					self fillCanvasTree.					self updateSelectionInTree]				ifFalse: 					[selectionKind == #window						ifTrue: 							[labelConstructor := (currentSpecBindings at: #labelConstructor ifAbsent: [nil]).							labelM := labelConstructor isNil 								ifTrue: [currentSpecCopy labelInBuilder: controller model builder]								ifFalse: [labelConstructor unsavedLabel].							(currentSpecCopy labelInBuilder: controller model builder) = labelM ifFalse: 								[(currentSpecBindings at: #labelConstructor) acceptUnsavedChanges.								labelM := currentSpecCopy labelInBuilder: controller model builder].							controller model windowSpec label: labelM.							controller model windowSpec: currentSpecCopy copy.							controller model fixBuildersWindow.							controller model builder window flushCaches.							labelM isNil ifFalse: [controller model builder window label: labelM].							controller canvasHasChanged: true.							canvasTree selection isNil ifTrue: [self updateSelectionInTree].							labelM isNil ifFalse: [canvasTree selection label: labelM]. 							(builder componentAt: #canvasTree) widget updateAt: 1.]]].	self statusBarText value: controller activePainterWindow label asString.	self displayButtonsForUnmodifiedState.	client postapply.	lock := false</body><body package="UIPainter">cancel	selection := nil.	self reloadSelectionInformation.	self displayButtonsForUnmodifiedState.	client notNil ifTrue: [client postcancel]</body><body package="UIPainter">doClosePainter	self release.	self closeRequest</body><body package="UIPainter">helpAbout	AboutVisualWorksDialog open</body><body package="UIPainter">helpComposingWindows	'topic:vw.help.gui.painter.newCanvas' asURI open</body><body package="UIPainter">helpGUIPainterTool	'topic:vw.help.tools.painter.GUIPainter' asURI open</body><body package="UIPainter">helpUserInterfacePainter	'topic:vw.help.tools.painter' asURI open</body><body package="UIPainter">postapply	"no-op"</body><body package="UIPainter">postcancel	"Do any post cancellation actions."</body><body package="UIPainter">preapply	"no-op"</body><body package="UIPainter">precancel	"Do any canceling on the model level (no model), and answer if this is 	sufficient cancelation (it isn't)."	^false</body><body package="UIPainter">reloadSelectionInformation	"If the new selection is really new then reload all selection 	information. Note: it is important that 'selection', 'controller', 	'selectionKind', and 'currentSpecCopy' be set at the same 	time (as they are in this method - and only this method and 	'setUpForNil')."	| newController newSelection newSpec |	lock == true ifTrue: [^self].	newController := selectionHolder value.	newController == nil ifTrue: [^self setUpForNil].	newSelection := newController selectionList.	newController == controller ifFalse: [self manageGridDependencies].	newSpec := self currentSpecFor: newSelection andController: newController.	((selection == newSelection 		and: [currentSpecCopy layout = newSpec layout]) 			or: [selection notNil and: [selection isEmpty and: [newSelection isEmpty]]]) 			ifTrue: 				[client isNil ifTrue: [^self adjustMenu].				client usesConservativeReload ifFalse: [^self adjustMenu]].	selection := newSelection.	controller := newController.	statusBarText value: controller activePainterWindow label asString.	currentSpecCopy := newSpec.	self computeSliceInfo.	self displayButtonsForUnmodifiedState.	slice value: slice value asSymbol.	self adjustMenu.</body><body package="UIPainter">selectNext	| sel |	controller == nil ifTrue: [^self].	(builder componentAt: #nextButton) isEnabled		ifFalse: [^self].	sel := controller selectionList.	sel size = 1 ifFalse: [^self].	sel := sel first. 	controller selectNextElement.	self reloadSelectionInformation.	self updateSelectionInTree</body><body package="UIPainter">selectPrev	| sel |	controller == nil ifTrue: [^self].	(builder componentAt: #prevButton) isEnabled		ifFalse: [^self].	sel := controller selectionList.	sel size = 1 ifFalse: [^self].	sel := sel first.	controller selectPrevElement.	self reloadSelectionInformation.	self updateSelectionInTree</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>grid actions</category><body package="UIPainter">gridHide	controller showGrid value: #'Hide'</body><body package="UIPainter">gridOff	controller griddedHorizontally value: false.	controller griddedVertically value: false</body><body package="UIPainter">gridOn	controller griddedHorizontally value: true.	controller griddedVertically value: true</body><body package="UIPainter">gridSettingsUpdate	self gridSettingsUpdate: controller</body><body package="UIPainter">gridSettingsUpdate: aController	| gridMenu keyOn gridStep |	menuBar isNil ifTrue: [^self].	gridMenu := (menuBar atNameKey: #gridMenu) submenu.	gridMenu menuItems do: [:item | item beOff].	aController == nil ifTrue: [^self].	keyOn := aController griddedVertically value				ifTrue: [aController griddedHorizontally value						ifTrue: [#gridOn]						ifFalse: [#gridYOnly]]				ifFalse: [aController griddedHorizontally value						ifTrue: [#gridXOnly]						ifFalse: [#gridOff]].	(gridMenu atNameKey: keyOn) beOn.	keyOn := aController showGrid value == #Show				ifTrue: [#gridShow]				ifFalse: [aController showGrid value == #Hide						ifTrue: [#gridHide]						ifFalse: [#gridShowIfOn]].	(gridMenu atNameKey: keyOn) beOn.	gridStep  := aController gridStep value.	keyOn := gridStep = 2				ifTrue: [#gridSize2]				ifFalse: [gridStep = 4				ifTrue: [#gridSize4]				ifFalse: [gridStep = 8				ifTrue: [#gridSize8]				ifFalse: [#gridSizeDialog]]].	(gridMenu atNameKey: keyOn) beOn.	aController fenced value		ifTrue: [(gridMenu atNameKey: #keepInWindow) beOn]	.</body><body package="UIPainter">gridShow	controller showGrid value: #'Show'</body><body package="UIPainter">gridShowIfOn	controller showGrid value: #'ShowIfOn'</body><body package="UIPainter">gridSize2	controller gridStep value: 2</body><body package="UIPainter">gridSize4	controller gridStep value: 4</body><body package="UIPainter">gridSize8	controller gridStep value: 8</body><body package="UIPainter">gridSizeDialog	| sz szInt |	sz := SimpleDialog new		request: (#GridSize &lt;&lt; #UIPainter &gt;&gt; 'Grid Size?')		initialAnswer: controller gridStep value printString		onCancel: [^self]		for: builder window.	szInt := Integer readFromString: sz.	szInt &lt; 1	ifTrue: [ Dialog warn: (#GenKey140 &lt;&lt; #UIPainter &gt;&gt; 'The grid size must be greater than 0.') for: builder window ]	ifFalse: [ controller gridStep value: szInt ]</body><body package="UIPainter">gridXOnly	controller griddedHorizontally value: true.	controller griddedVertically value: false</body><body package="UIPainter">gridYOnly	controller griddedHorizontally value: false.	controller griddedVertically value: true</body><body package="UIPainter">keepInWindow	controller fenced value: controller isFenced not</body><body package="UIPainter">manageGridDependencies	| newController |	controller notNil ifTrue: 		[controller griddedHorizontally retractInterestsFor: self.		controller griddedVertically retractInterestsFor: self.		controller showGrid retractInterestsFor: self.		controller gridStep retractInterestsFor: self.		controller fenced retractInterestsFor: self].	(newController := selectionHolder value) notNil ifTrue:		[newController griddedHorizontally onChangeSend: #gridSettingsUpdate to: self.		newController griddedVertically onChangeSend: #gridSettingsUpdate to: self.		newController showGrid onChangeSend: #gridSettingsUpdate to: self.		newController gridStep onChangeSend: #gridSettingsUpdate to: self.		newController fenced onChangeSend: #gridSettingsUpdate to: self.		self gridSettingsUpdate: newController]. 	builder notNil ifTrue: [self enableBasicButtons]</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>private</category><body package="UIPainter">canvasRequestsFocus: anUIPainter	| lastController |	(lastController := UIPainterController lastControllerWithSelectionChannel value) isNil ifTrue: [^self].	lastController notifySwitchingCanvas: anUIPainter findPainterController.</body><body package="UIPainter">changedStatusBar	| tx |	tx := self statusBarText value.	tx := (tx isNil or: [tx isEmpty])				ifTrue: [(#GUIPainterTool &lt;&lt; #UIPainter &gt;&gt; 'GUI Painter Tool')]				ifFalse: [((#GUIPainterToolOn1s &lt;&lt; #UIPainter &gt;&gt; 'GUI Painter Tool on: &lt;1s&gt;')			expandMacrosWith: tx)].	self builder window label = tx ifFalse: [self builder window label: tx]</body><body package="UIPainter">completeWorkOnPreviousSelection	subBuilder notNil ifTrue: 		[| keyboard |		keyboard := subBuilder keyboardProcessor.		keyboard notNil ifTrue: [keyboard requestGlobalAccept]].	(selection notNil and: [self hasUnAppliedChange]) ifTrue: 		[(client == nil or: [client shouldOpenDialogOnUnacceptedChange]) ifTrue: 			[^self openChangeDialog]].	^true</body><body package="UIPainter">component: aSymbol enable: aBoolean 	| comp |	subBuilder isNil ifTrue: [^self].	comp := subBuilder componentAt: aSymbol.	comp isNil ifTrue: [^self].	aBoolean		ifTrue: [comp enable]		ifFalse: [comp disable]</body><body package="UIPainter">countNonHandleWidgets	| count |	controller isNil ifTrue: [^0].	controller view isNil ifTrue: [^0].	count := 0.	controller view components do: [:el | (el isKindOf: DragHandle)			ifFalse: [count := count + 1]].	^count</body><body package="UIPainter">currentSpecFor: oneOrMoreUISpecifications andController: aController	"Answer the relevant spec and set the selectionKind for the oneOrMoreUISpecifications selected."	^oneOrMoreUISpecifications size = 0 		ifTrue: 			[selectionKind := #window.			aController model windowSpec copy]		ifFalse: 			[oneOrMoreUISpecifications size = 1 				ifTrue: 					[selectionKind := #single.					oneOrMoreUISpecifications first spec copy]				ifFalse: 					[selectionKind := #multi.					MultiSpec new]]</body><body package="UIPainter">hasUnAppliedChange	^(builder componentAt: #applyButton) isEnabled</body><body package="UIPainter">labelFor: labelName	^currentSpecCopy perform: labelName</body><body package="UIPainter">openChangeDialog	| selectionTracker choice |	choice := Dialog 				choose: #GenKey142 &lt;&lt; #UIPainter 						&gt;&gt; 'Properties have changed buthave not been applied.  Applythe changes or Cancel them?'				labels: (Array with: #Apply &lt;&lt; #UIPainter &gt;&gt; 'Apply'						with: #Cancel &lt;&lt; #UIPainter &gt;&gt; 'Cancel')				values: #(#apply #cancel)				default: #apply				for: (builder ifNotNil: [builder window]).	self perform: choice.	"While this dialog was open processing of a pending button release event may have reset the UIPainterController currentMode controller.  Ensure that its controller is not nil"	selectionTracker := controller currentMode value.	selectionTracker controller isNil 		ifTrue: [selectionTracker setController: controller].	^choice == #apply</body><body package="UIPainter">pendingSelectionChange	lock == true ifFalse: [self completeWorkOnPreviousSelection].</body><body package="UIPainter">reconfigureLabelModel	| cnvrtr isImage   | 	cnvrtr := currentSpecBindings at: #label.	isImage := (currentSpecBindings at: #hasImageOrientedLabel) value.	isImage		ifTrue: [cnvrtr symbolToText]		ifFalse: [cnvrtr stringOrSymbolToText].	(currentSpecBindings at: #label) changed: #value</body><body package="UIPainter">setFocus	"Set the keyboard input focus to be the first text input widget on the focus chain."	builder keyboardProcessor keyboardConsumers do: 			[:aWidget |			((aWidget isKindOf: TextEditorView) and: [aWidget isEnabled])				ifTrue: 					[builder keyboardProcessor focusedView: aWidget.					^aWidget controller selectEntireText]]</body><body package="UIPainter">setUpForNil	| subCanvas  |	"self completeWorkOnPreviousSelection. --- it is being closed anyhow, so don't bother"	statusBarText value: ''.	subCanvas := (builder componentAt: #specCanvas) widget.	selection := nil.	controller := nil.	selectionKind := #none.	subCanvas client: nil.	subBuilder := nil.	specChannel := nil.	slicesMenu value: nil.	self sliceMenu.	slice value: #None.	self replaceTheTabList: self masterList index: 1.	self adjustMenu.	self resetTree.</body><body package="UIPainter">shouldOpenDialogOnUnacceptedChange	^true</body><body package="UIPainter">spinButtonTypeChange	| spinSpec |	subBuilder isNil ifTrue: [^self].	spinSpec := subBuilder bindings at: #releasingAgent ifAbsent: [nil].	spinSpec notNil ifTrue:		[spinSpec enableHighLowFieldsWith: subBuilder bindings]</body><body package="UIPainter">updateResizerLabels: aResizer	aResizer horizontal		ifTrue: 			[(subBuilder componentAt: #leftTopSizeLabel) widget setLabelString: (#TopMinSize &lt;&lt; #UIPainter &gt;&gt; 'Top min size:').			(subBuilder componentAt: #leftTopWidgetsLabel) widget setLabelString: (#TopWidgets &lt;&lt; #UIPainter &gt;&gt; 'Top widgets:').			(subBuilder componentAt: #rightBottomSizeLabel) widget setLabelString: (#BottomMinSize &lt;&lt; #UIPainter &gt;&gt; 'Bottom min size:').			(subBuilder componentAt: #rightBottomWidgetsLabel) widget setLabelString: (#BottomWidgets &lt;&lt; #UIPainter &gt;&gt; 'Bottom widgets:')]		ifFalse: 			[(subBuilder componentAt: #leftTopSizeLabel) widget setLabelString: (#LeftMinSize &lt;&lt; #UIPainter &gt;&gt; ' Left min size:').			(subBuilder componentAt: #leftTopWidgetsLabel) widget setLabelString: (#LeftWidgets &lt;&lt; #UIPainter &gt;&gt; ' Left widgets:').			(subBuilder componentAt: #rightBottomSizeLabel) widget setLabelString: (#RightMinSize &lt;&lt; #UIPainter &gt;&gt; '    Right min size:').			(subBuilder componentAt: #rightBottomWidgetsLabel) widget setLabelString: (#RightWidgets &lt;&lt; #UIPainter &gt;&gt; '    Right widgets:')].	(self builder componentAt: #specCanvas) invalidate</body><body package="UIPainter">usesConservativeReload	^false</body><body package="UIPainter">validateChangeOfPage	(builder componentAt: #applyButton) isEnabled		ifTrue: [(client == nil or: [client shouldOpenDialogOnUnacceptedChange]) 			ifTrue: [^self okToQuitWithChanges]].	^true</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>menu manipulation</category><body package="UIPainter">adjustMenu	| sel selectedSpec selMenu arrangeMenu arrangeButton layoutMenu editMenu specialButton gridButton lensMenuItem ungroupItem |	selectionHolder value isNil ifTrue: 		[self disableMainMenu.		^self disableToolbarButtons]. 	self enableBasicMenuButtons.	sel := self selectionHolder value selectionList.	arrangeMenu := (menuBar atNameKey: #arrangeMenu) submenu.	editMenu := (menuBar atNameKey: #editMenu) submenu.	lensMenuItem := menuBar atNameKey: #openReusableComponents.	builder window menuBar menuButtons with: menuBar menuItems do:		[:eachButton :eachItem |		eachItem nameKey = #arrangeMenu ifTrue: [arrangeButton := eachButton].		eachItem nameKey = #gridMenu ifTrue: [gridButton := eachButton].		eachItem nameKey = #special ifTrue: [specialButton := eachButton]].	layoutMenu := (menuBar atNameKey: #layoutMenu) submenu.	lensMenuItem notNil ifTrue: 		[#{LensDataManager} bindingOrNil isNil			ifTrue: [lensMenuItem disable]			ifFalse: [lensMenuItem enable]].	gridButton isEnabled: true.	(editMenu atNameKey: #doSpawn) enable.	controller model targetClass isNil		ifTrue: 			[(editMenu atNameKey: #doCatalogID) disable.			(editMenu atNameKey: #doInstallNamedFonts) disable]		ifFalse: 			[(editMenu atNameKey: #doCatalogID) enable.			(editMenu atNameKey: #doInstallNamedFonts) enable].	self setEnablementOfApplicationModelActions.	sel size &gt; 1		ifTrue: 			[arrangeButton isEnabled: true.			(arrangeMenu atNameKey: #alignDialog) enable.			(arrangeMenu atNameKey: #distributeDialog) enable.			(arrangeMenu atNameKey: #equalizeDialog) enable.			(arrangeMenu atNameKey: #doUngroup) disable.			specialButton isEnabled: false.			(layoutMenu atNameKey: #beFixed) enable.			(layoutMenu atNameKey: #beRelative) enable.			(layoutMenu atNameKey: #fractionalConstraintDialog) disable.			(layoutMenu atNameKey: #doMakeBounded) enable.			(layoutMenu atNameKey: #doMakeUnBounded) enable.			self enableTabOrderButtons.			^menuBar].	sel size = 1		ifTrue:			[arrangeButton isEnabled: true.			(arrangeMenu atNameKey: #alignDialog) disable.			(arrangeMenu atNameKey: #distributeDialog) disable.			(arrangeMenu atNameKey: #equalizeDialog) disable.			selectedSpec := sel first spec. 			ungroupItem := arrangeMenu atNameKey: #doUngroup.			(selectedSpec isKindOf: CompositeSpec)				ifTrue:	 [ungroupItem enable]				ifFalse: [ungroupItem disable].			(selMenu := selectedSpec class selectionPullDownMenu) isNil				ifTrue: [specialButton isEnabled: false]				ifFalse:					[(menuBar atNameKey: #special) submenu: selMenu.					self menuBar updateMenu.					specialButton isEnabled: true].			(layoutMenu atNameKey: #beFixed) enable.			(layoutMenu atNameKey: #beRelative) enable.			(layoutMenu atNameKey: #fractionalConstraintDialog) enable.			(layoutMenu atNameKey: #doMakeBounded) enable.			(layoutMenu atNameKey: #doMakeUnBounded) enable.			self enableTabOrderButtons.			^menuBar].	sel size = 0		ifTrue:			[arrangeButton isEnabled: false.			specialButton isEnabled: false.			(layoutMenu atNameKey: #beFixed) disable.			(layoutMenu atNameKey: #beRelative) disable.			(layoutMenu atNameKey: #fractionalConstraintDialog) disable.			(layoutMenu atNameKey: #doMakeBounded) disable.			(layoutMenu atNameKey: #doMakeUnBounded) disable.			self disableTabOrderButtons.			^menuBar]</body><body package="UIPainter">disableMainMenu	builder window menuBar menuButtons do: [:each | each isEnabled: false]</body><body package="UIPainter">disableNonInstallButtons	| buttons |	buttons := builder componentAt: #painterToolBar.	#(#doBrowse #doDefine #doOpen) do: [:each | (buttons componentAt: each) isEnabled: false]</body><body package="UIPainter">disableTabOrderButtons	| buttons |	buttons := builder componentAt: #painterToolBar.	#(#toVisualFront #toVisualFrontOne #toVisualBack #toVisualBackOne) do: [:each | (buttons componentAt: each) isEnabled: false]</body><body package="UIPainter">disableToolbarButtons	(builder componentAt: #painterToolBar) components do: [:each | each isEnabled: false]</body><body package="UIPainter">displayButtonsForModifiedState	| nb |	self enableGroup: #(#applyButton #readButton).	self disableGroup: #(#nextButton #prevButton ).	(self builder componentAt: #sliceMenu) isNil		ifFalse: [self disableGroup: #(#sliceMenu )].	(nb := self builder componentAt: #specCanvas) isNil		ifFalse: [(nb widget respondsTo: #rightTabBar) ifTrue: [nb widget rightTabBar localEnabled: false]]</body><body package="UIPainter">displayButtonsForUnmodifiedState	self disableGroup: #(#applyButton #readButton).	(self builder componentAt: #sliceMenu) isNil		ifFalse: [self enableGroup: #(#sliceMenu )].		(selectionKind == #single and: [self countNonHandleWidgets &gt; 1])		ifTrue: [self enableGroup: #(#nextButton #prevButton )]		ifFalse: [self disableGroup: #(#nextButton #prevButton )]</body><body package="UIPainter">enableBasicButtons	| buttons |	buttons := (builder componentAt: #painterToolBar).	#(#doInstall #doNamedFonts) do: [:each | (buttons componentAt: each) isEnabled: true]</body><body package="UIPainter">enableBasicMenuButtons	builder window menuBar menuButtons with: menuBar menuItems do:		[:eachButton :eachItem |		(#(#arrangeMenu #gridMenu #special) includes: eachItem nameKey) ifFalse: [eachButton isEnabled: true]]</body><body package="UIPainter">enableMainMenu	builder window menuBar menuButtons do: [:each | each isEnabled: true]</body><body package="UIPainter">enableNonInstallButtons	| buttons |	buttons := builder componentAt: #painterToolBar.	#(#doBrowse #doDefine #doOpen) do: [:each | (buttons componentAt: each) isEnabled: true]</body><body package="UIPainter">enableTabOrderButtons	| buttons |	buttons := builder componentAt: #painterToolBar.	#(#toVisualFront #toVisualFrontOne #toVisualBack #toVisualBackOne) do: [:each | (buttons componentAt: each) isEnabled: true]</body><body package="UIPainter">enableToolbarButtons	(builder componentAt: #painterToolBar) components do: [:each | each isEnabled: true]</body><body package="UIPainter">menuBar	^self builder keyboardProcessor menuBar</body><body package="UIPainter">setEnablementOfApplicationModelActions	| modelPresent canOpen toolbar editMenu |	modelPresent := controller model targetClass notNil.	canOpen := modelPresent and: [controller model targetClass respondsTo: #openOn:withSpec:].	toolbar := builder componentAt: #painterToolBar.	editMenu := (menuBar atNameKey: #editMenu) submenu.	#(#doBrowse #doDefine) do: 		[:each |		(editMenu atNameKey: each) enabled: modelPresent.		(toolbar componentAt: each) isEnabled: modelPresent].	(editMenu atNameKey: #doOpen) enabled: canOpen.	(toolbar componentAt: #doOpen) isEnabled: canOpen</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>binding</category><body package="UIPainter">aspectFor: aKey 	| result |	currentSpecBindings isNil ifTrue: [^super aspectFor: aKey].	result := currentSpecBindings at: aKey ifAbsent: [super aspectFor: aKey].	result compute: [:v | lock == true ifFalse: [self enableGroup: #(#applyButton #readButton)]].	^result</body><body package="UIPainter">menuFor: aKey 	currentSpecBindings isNil ifTrue: [^super menuFor: aKey].	^currentSpecBindings at: aKey ifAbsent: [super menuFor: aKey]</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>aspects</category><body package="UIPainter">canvasTree	^canvasTree isNil		ifTrue: [canvasTree := MultiSelectionInTree new]		ifFalse: [canvasTree]</body><body package="UIPainter">helpConstructor	^HelpConstructor new		on: specChannel;		parentBuilderBlock: [self subBuilder] fieldMenuBlock: [self fieldMenu]</body><body package="UIPainter">labelConstructor	^LabelConstructor new		on: specChannel;		parentBuilderBlock: [self subBuilder] fieldMenuBlock: [self fieldMenu]</body><body package="UIPainter">statusBarText	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^statusBarText isNil		ifTrue: [statusBarText := String new asValue]		ifFalse: [statusBarText]</body><body package="UIPainter">subBuilder	^subBuilder</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>bound model accessing</category><body package="UIPainter">controller	^controller</body><body package="UIPainter">currentCanvasFullSpec	^controller model extractFullSpec</body><body package="UIPainter">invalidateCurrentSelection	self selection first invalidate</body><body package="UIPainter">selection	^selection</body><body package="UIPainter">selectionKind	^selectionKind</body><body package="UIPainter">showModifiedState	"Bound model is telling us that something has changed."	self displayButtonsForModifiedState</body><body package="UIPainter">showModifiedStateWithNavigationEnabled	"Bound model is telling us that something has changed."	self enableGroup: #(#applyButton #readButton).</body><body package="UIPainter">showUnmodifiedState	"Bound model is telling us that things are in an unchanged state."	self displayButtonsForUnmodifiedState</body><body package="UIPainter">spec		^currentSpecCopy</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>private-tab manipulation</category><body package="UIPainter">computeSliceInfo	"Retrieve the slice information and build a menu based on it."	| mb slicesArray found foundIndex key |	found := false.	mb := MenuBuilder new.	slicesArray := currentSpecCopy class slices.	sliceInfo := IdentityDictionary new.	foundIndex := 1.	1 to: slicesArray size		do: 			[:index | 			| info sliceName |			info := slicesArray at: index.			sliceName := info at: 1.			sliceName class == Array ifTrue: [sliceName := sliceName decodeAsLiteralArray].				"sliceName must be either a String/Symbol or UserMessage"			key := sliceName isString ifTrue: [sliceName asSymbol] ifFalse: [sliceName key].			mb add: sliceName -&gt; key.			sliceInfo at: key put: info.			key == slice value				ifTrue: 					[found := true.					foundIndex := index]].	slicesMenu value: mb menu.	self replaceTheTabList: self masterList index: foundIndex.	found ifFalse: [slice setValue: #Basics]</body><body package="UIPainter">masterList	| lst |	lst := List new.	slicesMenu value isNil ifFalse: [slicesMenu value menuItems do: [:el |		lst add: (LabelAndValue key: el label value: el value)]].	^lst</body><body package="UIPainter">replaceTheTabList: newList index: foundIndex 	newList = list list		ifFalse: 			[list list: newList.			foundIndex = list selectionIndex				ifFalse: [list selectionIndexHolder value: foundIndex]]		ifTrue: [foundIndex = list selectionIndexHolder value ifFalse: [list selectionIndexHolder value: foundIndex]]</body><body package="UIPainter">setSpecChannel	"Given a 'slice' and a 'currentSpecCopy', build and fill-in the slice." 	| subCanvas currentSpec info specHolder subSpecIdent specSelector |	lastSlice := slice value.	slice value == #None ifTrue: [^self sliceOrSelectionChanged].	(client notNil and: [client ~~ self ]) 		ifTrue: [ client release ].	(subBuilder notNil and: [ (subBuilder aspectAt: #releasingAgent) notNil ]) 		ifTrue: [ (subBuilder aspectAt: #releasingAgent) release ].	info := sliceInfo at: slice value.	specSelector := info at: 2.	subSpecIdent := info size &gt;= 4 				ifTrue: [info at: 4]				ifFalse: [nil].	specChannel := (subSpecIdent notNil				ifTrue: [currentSpecCopy subSpecFor: subSpecIdent]				ifFalse: [currentSpecCopy]) asValue.	currentSpecBindings := IdentityDictionary new.	(info size &gt;= 3 and: [(info at: 3) notNil])		ifTrue: 			[ specHolder := client := ( info at: 3) asQualifiedReference value new ]		ifFalse: 			[client := self.			specHolder := specChannel value].	currentSpecBindings at: #propertiesTool put: self.	specHolder class		addBindingsTo: currentSpecBindings		for: specHolder		channel: specChannel.	selectionKind == #window		ifTrue: 			[currentSpecCopy label: specChannel value label].	subCanvas := (builder componentAt: #specCanvas) widget.	subBuilder := builder newSubBuilder.	"use the bindings that were just collected"	subBuilder bindings: currentSpecBindings.	subBuilder aspectAt: #parentModel put: self.	currentSpec := UISpecification from: (specHolder class perform: specSelector). 	subCanvas		client: client		spec: currentSpec		builder: subBuilder.	specChannel dependents do:		[:dep |		[dep compute: [:v | self displayButtonsForModifiedState]]			on: Object messageNotUnderstoodSignal 			do: [:ex | ex return]].	(subBuilder aspectAt: #releasingAgent) notNil 		ifTrue: [ (subBuilder aspectAt: #releasingAgent) validateComponentsFor: subBuilder ].	self setDropTargets.	self sliceOrSelectionChanged.	(specHolder isKindOf: ResizingSplitterSpec) ifTrue: [self updateResizerLabels: specHolder]</body><body package="UIPainter">slice	^slice</body><body package="UIPainter">sliceChanged	sliceChanging ifTrue: [^self].	sliceChanging := true.	(slice value ~~ lastSlice or: [client == nil or: [client precancel not]]) ifTrue:		[(#(#Color #Position) includes: slice value) 			ifTrue: [Cursor execute showWhile: [self setSpecChannel]]			ifFalse: [self setSpecChannel]].	sliceChanging := false.	^self</body><body package="UIPainter">sliceMasterList	^list</body><body package="UIPainter">sliceOrSelectionChanged	builder window displayPendingInvalidation.	self setFocus.	self displayButtonsForUnmodifiedState.	self updateSelectionInTree</body><body package="UIPainter">sliceTabChanged	| index | 	sliceTabChanging ifTrue: [^self].	sliceTabChanging := true.	(index := list selectionIndexHolder value) = 0 ifFalse: [list selectionIndexHolder value &gt; list list size ifTrue: [index := 0]].	slice value: (index = 0			ifTrue: [#None]			ifFalse: [(list list at: index) value asSymbol]).	sliceTabChanging := false.	^self</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>resources</category><body package="UIPainter">fieldMenu	^MenuBuilder new		add: (#find &lt;&lt; #UIPainter &gt;&gt; 'find...')-&gt;[:ctrlr | ctrlr find];		add: (#replace &lt;&lt; #UIPainter &gt;&gt; 'replace...')-&gt;			[:ctrlr |			ctrlr replace.			ctrlr textHasChanged				ifTrue:					[self displayButtonsForModifiedState]];		line;		add: (#undo &lt;&lt; #UIPainter &gt;&gt; 'undo') -&gt;			[:ctrlr |			ctrlr undo.			ctrlr textHasChanged				ifTrue:					[self displayButtonsForModifiedState]];		line;		add: (#copy &lt;&lt; #UIPainter &gt;&gt; 'copy')-&gt;[:ctrlr | ctrlr copySelection];		add: (#cut &lt;&lt; #UIPainter &gt;&gt; 'cut')-&gt;			[:ctrlr |			ctrlr cut.			ctrlr textHasChanged				ifTrue:					[self displayButtonsForModifiedState]];		add: (#paste &lt;&lt; #UIPainter &gt;&gt; 'paste')-&gt;			[:ctrlr |			ctrlr paste.			ctrlr textHasChanged				ifTrue:					[self displayButtonsForModifiedState]];		line;		add: (#accept &lt;&lt; #UIPainter &gt;&gt; 'accept')-&gt;[:ctrlr | ctrlr accept];		add: (#cancel &lt;&lt; #UIPainter &gt;&gt; 'cancel')-&gt;[:ctrlr | ctrlr cancel];		menu</body><body package="UIPainter">painterMenu	menuBar := (Menu new) 		addItem: ((MenuItem labeled: (#_Edit &lt;&lt; #UIPainter &gt;&gt; '&amp;Edit')) nameKey: #editMenu; submenu: self class editMenu); 		addItem: ((MenuItem labeled: (#_Tools &lt;&lt; #UIPainter &gt;&gt; '&amp;Tools')) submenu: self class toolsMenu);  		addItem: ((MenuItem labeled: (#_Layout &lt;&lt; #UIPainter &gt;&gt; '&amp;Layout')) nameKey: #layoutMenu; submenu: self class layoutMenu); 		addItem: ((MenuItem labeled: (#_Arrange &lt;&lt; #UIPainter &gt;&gt; '&amp;Arrange')) nameKey: #arrangeMenu; submenu: self class arrangeMenu); 		addItem: ((MenuItem labeled: (#_Grid &lt;&lt; #UIPainter &gt;&gt; '&amp;Grid')) nameKey: #gridMenu; submenu: self class gridMenu); 		addItem: ((MenuItem labeled: (#_Special &lt;&lt; #UIPainter &gt;&gt; '&amp;Special')) nameKey: #special; submenu: self class nullMenu);		addItem: ((MenuItem labeled: (#_Help &lt;&lt; #UIPainter &gt;&gt; '&amp;Help')) nameKey: #help; submenu: self class helpMenu).	^menuBar</body><body package="UIPainter">sliceMenu	slicesMenu value isNil		ifTrue: 			[| mb |			mb := MenuBuilder new.			mb add: #None -&gt; #None.			slicesMenu value: mb menu].	^slicesMenu</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>private-tree manipulation</category><body package="UIPainter">addSelectionIndex: aSpec to: aCollection	self		find: aSpec		inSpecCollection: canvasTree list		ifFoundDo: [:index | ^aCollection add: index].	self fillCanvasTree.	self		find: aSpec		inSpecCollection: canvasTree list		ifFoundDo: [:index | ^aCollection add: index].</body><body package="UIPainter">fillCanvasTree	| wrapper widgetTree |	wrapper := builder componentAt: #canvasTree.	widgetTree := wrapper widget.	self canvasTree 		list: (UISpecificationTreeModel onSpec: self currentCanvasFullSpec).	widgetTree selectionIndex: 1.	widgetTree controller expandFully.	wrapper invalidate.	currentView := controller view</body><body package="UIPainter">find: aSpec inSpecCollection: aCollection ifFoundDo: aMonadicBlock	1 to: aCollection size do: 		[:index | | spec |		spec := aCollection at: index.		(aSpec class = spec class and: [aSpec name = spec name and: [aSpec layout = spec layout]]) ifTrue: 			[aMonadicBlock value: index]].</body><body package="UIPainter">findEmbeddedIn: aCollection using: aCollectionOfWrappers into: aCollectionOfFoundItems	| collectionSpecs sortedSelections |	aCollectionOfFoundItems size = canvasTree selections size ifTrue: [^self].	sortedSelections := canvasTree selectionIndexes asSortedCollection 		collect: [:each | canvasTree list at: each].	sortedSelections do:		[:each |		self 			find: each			inSpecCollection: aCollection 			ifFoundDo: [:index | aCollectionOfFoundItems add: (aCollectionOfWrappers at: index)]].	aCollectionOfFoundItems size = canvasTree selections size ifTrue: [^self].	collectionSpecs := Dictionary new.	aCollection keysAndValuesDo: 		[:index :each | 		(each isKindOf: CompositeSpecCollection) ifTrue: [collectionSpecs at: index put: each]].	collectionSpecs keysAndValuesDo:		[:key :value | 		self findEmbeddedIn: value collection using: (aCollectionOfWrappers at: key) widget components into: aCollectionOfFoundItems].</body><body package="UIPainter">resetTree 	self canvasTree tree: TreeModel new.</body><body package="UIPainter">updateSelectionInTree	| treeIndexes |	controller isNil ifTrue: [^self].	controller view == currentView ifFalse: [self fillCanvasTree].	selection isNil ifTrue: [^self].	selection isEmpty		ifTrue: [canvasTree selectionIndex: 1]		ifFalse: 			[treeIndexes := OrderedCollection new.			canvasTree resetSelections.			selection do: 					[:each |					((each widget respondsTo: #container)						ifTrue: [currentSpecCopy extractedSpecFor: each widget]						ifFalse: [each])							ifNotNil: [:targetSpec | self addSelectionIndex: targetSpec to: treeIndexes]].			canvasTree selectionIndexes: treeIndexes].	self mainWindow repairDamages.</body><body package="UIPainter">updateTreeItem: aString	| indexs |	((indexs := canvasTree selectionIndexes) includes: 0) ifTrue: 		[self updateSelectionInTree.		indexs := canvasTree selectionIndexes].	canvasTree selection name: aString. 	(builder componentAt: #canvasTree) widget updateAt: indexs last.	canvasTree selectionIndexes: indexs.</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>initialize-release</category><body package="UIPainter">canvasClosing	(UIPainter allInstances 		select: [:each | each mainWindow notNil and: [each mainWindow key notNil]]) 			size &lt;= 1 		ifTrue: [self doClosePainter]		ifFalse: [UIPainterController makeNextUIPainterActive]</body><body package="UIPainter">initialize	super initialize.	slicesMenu := nil asValue.	slice := #None asValue.	slice onChangeSend: #sliceChanged to: self.	list := SelectionInList new.	list list: self masterList.	list selectionIndex: 1.	list selectionIndexHolder onChangeSend: #sliceTabChanged to: self.	"Since SelectionInList resets its index to zero when the list changes I will	make use of implementation details to get around the problem"	list listHolder removeDependent: list.	sliceChanging := false.	sliceTabChanging := false.	self statusBarText onChangeSend: #changedStatusBar to: self.	self manageGridDependencies</body><body package="UIPainter">noticeOfWindowClose: aWindow	"The ApplicationWindow aWindow is in the process of closing.  You have been notified."	self release</body><body package="UIPainter">release	(UIPainter allInstances select: [:each | each mainWindow notNil])		do: [:each | each mainWindow removeAllActionsWithReceiver: self].	super release.</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>interface opening</category><body package="UIPainter">postBuildWith: aBuilder	| keyboardProcessor tree |	super postBuildWith: aBuilder.	(tree := (self builder componentAt: #canvasTree) widget)		lineGrid: (tree lineGrid max: 20).	(keyboardProcessor := builder keyboardProcessor) keyboardHook: 			[:event :activeViewController |			| keyValue |			(keyValue := event keyValue) == Ctrlp				ifTrue: 					[self selectPrev.					nil]				ifFalse: 					[keyValue == Ctrln						ifTrue: 							[self selectNext.							nil]						ifFalse: 							[(currentSpecBindings notNil and: 									[(keyboardProcessor focusedView isKindOf: TextEditorView) and: 											[event keyValue ~= Ctrlc												and: [event keyValue ~= Character tab and: [event keyValue ~= Character cr]]]])								ifTrue: 									[self displayButtonsForModifiedState.									controller quietlyNoteChangeToCanvas].							event]]]</body><body package="UIPainter">postOpenWith: aBuilder 	self disableToolbarButtons.	self enableToolbarButtons.	super postOpenWith: aBuilder.	aBuilder window sendWindowEvents: #(#expand).	self countNonHandleWidgets = 1 ifTrue: [self disableGroup: #(#nextButton #prevButton )].</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>updating</category><body package="UIPainter">update: anAspect with: parameter from: anObject 	| newSelection |	(builder window notNil 		and: [builder window key notNil and: [builder window isCollapsed not]]) 			ifFalse: [^self].	anAspect == #updateLabelIsImage ifTrue: [self updateLabelFromApplication].	(anAspect == #switchingCanvas and: [parameter ~= controller]) 		ifTrue: 			[lock := true.			self hasUnAppliedChange 				ifTrue: 					[self completeWorkOnPreviousSelection.					self displayButtonsForUnmodifiedState].			newSelection := parameter selectionList.			controller := parameter.			selection := newSelection.			statusBarText value: controller activePainterWindow label asString.			currentSpecCopy := self currentSpecFor: newSelection andController: controller.			self computeSliceInfo.			slice value: slice value asSymbol.			client notNil ifTrue: [client quietlyReloadSelectionInformation].			UIPalette currentMode: #{SelectModeTracker} value new.			self 				displayButtonsForUnmodifiedState;				adjustMenu.			lock := false].	(anAspect == #treeChange or: [anAspect == #openedCanvas]) 		ifTrue: 			[self 				fillCanvasTree;				updateSelectionInTree].	anAspect == #emptyTree ifTrue: [self resetTree].	anAspect == #treeItemNameChange ifTrue: [self updateTreeItem: parameter].	anAspect == #topLevelPainter 		ifTrue: 			[self enableMainMenu.			self enableToolbarButtons].	anAspect == #selectionChange ifTrue: [self updateSelectionInTree].	super 		update: anAspect		with: parameter		from: anObject</body><body package="UIPainter">updateLabelFromApplication	| labelConstructor hasImageValue |	subBuilder ifNil: [^self].	(labelConstructor := subBuilder aspectAt: #labelConstructor) ifNil: [^self].	(hasImageValue := subBuilder aspectAt: #hasImageOrientedLabel) ifNil: [^self].	hasImageValue value 		ifTrue: [labelConstructor suppliedByBuilder value: true]		ifFalse: [labelConstructor changedDynamicMode].</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>changing</category><body package="UIPainter">changeRequest	(client notNil and: [client ~~ self]) ifTrue: [client release].	(subBuilder notNil and: [(subBuilder aspectAt: #releasingAgent) notNil]) 		ifTrue: [(subBuilder aspectAt: #releasingAgent) release].	^(builder componentAt: #applyButton) isEnabled not 		ifTrue: [true]		ifFalse: [self okToQuitWithChanges]</body><body package="UIPainter">okToQuitWithChanges	| choice |	choice := Dialog 				choose: (#ApplyChangedProperties &lt;&lt; #UIPainter &gt;&gt; 'Apply changed properties?')				labels: (Array with: (#Yes &lt;&lt; #UIPainter &gt;&gt; 'Yes') with: (#No &lt;&lt; #UIPainter &gt;&gt; 'No') with: (#Cancel &lt;&lt; #UIPainter &gt;&gt; 'Cancel'))				values: #(#yes #no #cancel)				default: #yes.	choice = #cancel ifTrue: [^false].	choice = #yes ifTrue: [self apply].	choice = #no ifTrue: [self cancel].	^true</body><body package="UIPainter">treeSelectionChange	| targetSpec currentSpecCollection wrappers |	targetSpec := canvasTree selection.	targetSpec isNil ifTrue: [^controller removeSelections].	(targetSpec isKindOf: WindowSpec) ifTrue: 		[self fillCanvasTree.		canvasTree resetSelections.		canvasTree selectionIndex: 1.		^controller selectionList: #()].	canvasTree selections do: 		[:each | (each isKindOf: WindowSpec) ifTrue: 			[self fillCanvasTree.			canvasTree resetSelections.			canvasTree selectionIndex: 1.			^controller selectionList: #()]].	currentSpecCollection := controller model extractSpecCollection collection.	wrappers := OrderedCollection new.	self		findEmbeddedIn: currentSpecCollection		using: controller model builderComponentWrappers		into: wrappers.	controller selectionList: wrappers.</body><body package="UIPainter">validAspectSelector: anInputBoxController	"Valid if: the first is a valid selector, and the rest are valid selectors or integer numbers"	| targetSelectors targetString |	targetString := anInputBoxController editValue trimBlanks.	targetString isEmpty ifTrue: [^true].	targetString first = $# ifTrue: [targetString := targetString copyFrom: 2 to: targetString size].	targetSelectors := targetString trimBlanks tokensBasedOn: $ . 	^(targetSelectors allSatisfy:		[:each | 		(SpecialSelectorCounter specialSelectors includes: each asSymbol) or: 			[((each = targetSelectors first) not and: [each allSatisfy: [:eachChar | eachChar isDigit]])  or:			[each asSymbol = (Parser new parseSelector: each)]]])		ifFalse: 			[Dialog warn: (#GenKey143 &lt;&lt; #UIPainter &gt;&gt; 'The aspect must conform to a valid Smalltalk selector or aspect path!') expandMacros.			false]		ifTrue: 			[anInputBoxController view editText: '#', targetString.			true].</body></methods><methods><class-id>Tools.UIPainterTool class</class-id> <category>interface specs</category><body package="UIPainter">helpConstructorSpecSize	^31*5</body><body package="UIPainter">labelConstructorSpecSize	^31 * 4</body></methods><methods><class-id>UI.LabelConstructor</class-id> <category>initialize</category><body package="UIPainter">on: aValueHolder	labeledValueHolder := aValueHolder.	labeledValueHolder onChangeSend: #flushFields to: self</body><body package="UIPainter">parentBuilderBlock: builderBlock fieldMenuBlock: menuBlock	parentBuilderBlock := builderBlock.	fieldMenuBlock := menuBlock.	self setDropTargets</body></methods><methods><class-id>UI.LabelConstructor</class-id> <category>accessing</category><body package="UIPainter">labelDefaultString	| labelThing |	labelThing := labeledValueHolder value label.	^(labelThing == nil)		ifTrue: [nil]		ifFalse: [labelThing isString				ifTrue: [labelThing]				ifFalse: [labelThing defaultString]]</body><body package="UIPainter">labelDefaultString: aString 	| labelThing trimmed |	labelThing := labeledValueHolder value label.	trimmed := aString trimBlanks.	labeledValueHolder value 		label: ((labelThing isString or: [labelThing == nil]) 				ifTrue: 					[(parentBuilderBlock value aspectAt: #labelFromApplication) value 						ifTrue: [trimmed asSymbol]						ifFalse: [trimmed]]				ifFalse: [labelThing copy &gt;&gt; trimmed]).	self changed: #value</body><body package="UIPainter">labelKeyID	^[labeledValueHolder value label key]		on: Object messageNotUnderstoodSignal		do: [:ex | ex return: nil]</body><body package="UIPainter">labelKeyID: aSymbol 	| labelThing |	self suppliedByBuilder value ifTrue: [^self].	aSymbol == nil 		ifTrue: [labeledValueHolder value label: self labelDefaultString]		ifFalse: 			[labelThing := labeledValueHolder value label.			labeledValueHolder value 				label: ((labelThing isString or: [labelThing == nil]) 						ifTrue: [aSymbol &gt;&gt; labelThing]						ifFalse: [labelThing copy key: aSymbol])].	self changed: #value</body><body package="UIPainter">labelMessageSelector	| labelThing painterController applicationCatalogID |	painterController := (parentBuilderBlock value source respondsTo: #selectionHolder)		ifTrue: [parentBuilderBlock value source selectionHolder value]		ifFalse: [builder window model controller].	painterController isNil ifTrue: [^nil].	applicationCatalogID := (painterController model targetClass respondsTo: #messageCatalogID)		ifTrue: [painterController model targetClass messageCatalogID]		ifFalse: [nil].	labelThing := labeledValueHolder value label takesMessageCatalog		ifTrue: [labeledValueHolder value label catalogID]		ifFalse: [nil].	(labelThing isNil and: [applicationCatalogID isNil not])		ifTrue: [labelThing := applicationCatalogID].	^labelThing isSymbol		ifTrue: [labelThing]		ifFalse: [nil]</body><body package="UIPainter">labelMessageSelector: aSymbol 	| labelThing |	self suppliedByBuilder value ifTrue: [^self].	aSymbol == nil 		ifFalse: 			[labelThing := labeledValueHolder value label.			labeledValueHolder value 				label: ((labelThing isString or: [labelThing == nil]) 						ifTrue: 							[(UserMessage new)								defaultString: labelThing;								catalogID: aSymbol;								yourself]						ifFalse: [labelThing copy &lt;&lt; aSymbol])].	self changed: #value</body><body package="UIPainter">simpleLabel	^labeledValueHolder value label</body><body package="UIPainter">simpleLabel: newLabel	| label test |	test := parentBuilderBlock value aspectAt: #hasImageOrientedLabel.	(test notNil and: [test value])		ifTrue: [label := newLabel asSymbol]		ifFalse: [label := newLabel].	^labeledValueHolder value label: label</body><body package="UIPainter">unsavedLabel	| defaultString key catalogID |	defaultString := self currentLabelString.	key := self currentLookupKey.	(key notNil and: [key isEmpty]) ifTrue: [key := nil].	catalogID := self currentCatalog.	(catalogID notNil and: [catalogID isEmpty]) ifTrue: [catalogID := nil].	key isNil 		ifTrue: 			[^catalogID isNil 				ifTrue: [defaultString]				ifFalse: 					[UserMessage 						defaultString: defaultString						key: key						catalogID: catalogID]].	^UserMessage 		defaultString: defaultString		key: key asSymbol		catalogID: (catalogID ifNotNil: [catalogID asSymbol])</body></methods><methods><class-id>UI.LabelConstructor</class-id> <category>aspects</category><body package="UIPainter">acceptUnsavedChanges	"Don't ask why it looks backward between Catalog and Key... just remember it works!"	| cat string key |	cat := self currentCatalog.	string := self suppliedByBuilder value				ifTrue: [(self currentLabelString copyWithout: $#) asSymbol]				ifFalse: [self currentLabelString].	key := self currentLookupKey.	self labelDefaultString: string.	self labelMessageSelector: cat.	self labelKeyID: key</body><body package="UIPainter">clearSuppliedByBuilder	suppliedByBuilder := nil</body><body package="UIPainter">fieldMenu	^fieldMenuBlock value</body><body package="UIPainter">label	^TypeConverter onStringOrSymbolValue:		((PluggableAdaptor on: self)			getSelector: #simpleLabel			putSelector: #simpleLabel:)</body><body package="UIPainter">labelKey	^(PluggableAdaptor on: self)		getSelector: #labelKeyID		putSelector: #labelKeyID:</body><body package="UIPainter">labelMessage	^(PluggableAdaptor on: self)		getSelector: #labelMessageSelector		putSelector: #labelMessageSelector:</body><body package="UIPainter">labelString	^TypeConverter onStringOrSymbolValue:		((PluggableAdaptor on: self)			getSelector: #labelDefaultString			putSelector: #labelDefaultString:)</body><body package="UIPainter">suppliedByBuilder	suppliedByBuilder isNil		ifTrue:			[suppliedByBuilder := parentBuilderBlock value aspectAt: #labelFromApplication.			suppliedByBuilder isNil ifTrue: [suppliedByBuilder := false asValue].			suppliedByBuilder onChangeSend: #changedDynamicMode to: self].	^suppliedByBuilder</body></methods><methods><class-id>UI.LabelConstructor</class-id> <category>private</category><body package="UIPainter">changeDynamicLabel	(builder componentAt: #defaultLbl) label: (Label 		with: (self suppliedByBuilder value			ifTrue: [#MessageC &lt;&lt; #labels &gt;&gt; 'Message:']			ifFalse: [#StringC &lt;&lt; #labels &gt;&gt; 'String:'])		attributes: (builder componentAt: #defaultLbl) widget label attributes).</body><body package="UIPainter">changedDynamicMode	| comp hasImage |	#(#catalogLbl #catalog #messageLbl #message)		do: [:key | (comp := builder componentAt: key) isNil ifFalse: [comp isEnabled: true]].	self changeDynamicLabel.	hasImage := parentBuilderBlock value aspectAt: #hasImageOrientedLabel.	hasImage isNil		ifFalse: 			[(comp := builder componentAt: #suppliedByBuilder) isNil				ifFalse: [comp isEnabled: hasImage value not]].	self updatedLabelAsMessage.	(parentBuilderBlock value aspectAt: #propertiesTool) showModifiedState</body><body package="UIPainter">currentCatalog	^(builder componentAt: #message) widget editValue</body><body package="UIPainter">currentLabelString	^(builder componentAt: #default) widget editValue string trimBlanks</body><body package="UIPainter">currentLookupKey	^(builder componentAt: #catalog) widget editValue</body><body package="UIPainter">flushFields	self changed: #value.	suppliedByBuilder changed: #value</body><body package="UIPainter">postBuildWith: aBuilder	self changedDynamicMode</body><body package="UIPainter">updatedLabelAsMessage	| labelValue labelChanged shouldBeMessage |	labelChanged := false.	labelValue := labeledValueHolder value label.	labelValue isNil ifTrue: [labelValue := String new].	shouldBeMessage := self suppliedByBuilder value.	(parentBuilderBlock value aspectAt: #labelFromApplication) value = shouldBeMessage		ifFalse: [(parentBuilderBlock value aspectAt: #labelFromApplication) setValue: shouldBeMessage].	(parentBuilderBlock value aspectAt: #labelFromApplication) value		ifTrue: 			[labelValue isSymbol ifFalse: 				[labeledValueHolder value label: labelValue asString asSymbol.				labelChanged := true.]]		ifFalse: 			[labelValue isSymbol ifTrue: 				[labeledValueHolder value label: labelValue asString.				labelChanged := true]].	labelChanged ifTrue: [(parentBuilderBlock value aspectAt: #labelConstructor) changed: #value]</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>private</category><body package="UIPainter">buildListFrom: aMenu depth: depth into: list	"Write the build string for aMenu onto stream.  Indentation of depth levels of tabs is required."	| lines |	lines := aMenu lines.	1 to: aMenu menuItems size do: [:i |		| menuItem |		menuItem := aMenu menuItemAt: i.		list add: menuItem-&gt;depth.		menuItem hasSubmenu ifTrue: [			self buildListFrom: menuItem submenu depth: depth + 1 into: list].		(lines includes: i)			ifTrue: [list add: self lineToken-&gt;depth]]</body><body package="UIPainter">changeRequest	^super changeRequest and: 			[(modified and: [menu notNil]) 				ifTrue: [self okToQuitWithChanges]				ifFalse: [true]]</body><body package="UIPainter">constructSubmenuForIndex: i 	| list depth sublist str newMenu |	list := menuList list.	i = nil		ifTrue: 			[depth := 0.			sublist := 1 to: list size]		ifFalse: 			[depth := (list at: i) value + 1.			sublist := self indicesForAllChildren: i].	sublist := sublist select: [:n | (list at: n) value = depth].	sublist isEmpty ifTrue: [^nil].	sublist := sublist collect: [:n | (list at: n) key].	str := (Array new: 5) writeStream.	newMenu := Menu new.	sublist do:		[:item |		item = self lineToken			ifTrue:				[newMenu addItemGroup: str contents.				str := (Array new: 5) writeStream]			ifFalse: [str nextPut: item]].	newMenu addItemGroup: str contents.	^newMenu</body><body package="UIPainter">copySelection: list	PasteBuffer := list collect: [:i | i key copy-&gt;i value]</body><body package="UIPainter">doesNotUnderstand: aMessage 	"Menus with enablement or indication selectors can send messages to the editor that they expect their model to understand. 	See if this is the case and just say yes."	menu ifNotNil: [			(menu someMenuItemWhich:  [ :item :value | 					| selector |					selector := aMessage selector.					selector == item visibilitySelector or: [selector == item enablementSelector 						or: [selector == item indicationSelector ]] ] ifNone: [ nil ]) ~= nil 				ifTrue: [ ^true ].			(menu someMenuItemWhich: [ :item :value | aMessage selector == item actionPerformer ] ifNone: [ nil ]) ~= nil 				ifTrue: [ ^self ].			(menu someMenuItemWhich: [ :item :value | aMessage selector == item value ] ifNone: [ nil ]) ~= nil 				ifTrue: [ ^VetoAction raise ] ].	super doesNotUnderstand: aMessage</body><body package="UIPainter">findMenuBarFor: aWindow	^(aWindow component components detect: [:comp | comp component isKindOf: MenuBar]) component</body><body package="UIPainter">indicesForAllChildren: base	| stop items depth |	items := menuList list.	depth := (items at: base) value.	stop := (base+1 to: items size)			detect: [:n | (items at: n) value &lt;= depth]			ifNone: [items size+1].	^base to: stop-1</body><body package="UIPainter">installInSystem	| array s |	array := self menu literalArrayEncoding.	s := (String new: 100) writeStream.	s nextPutAll: self targetSelector; cr.	"Put in a nice comment for re-opening the painter."	s tab;		nextPutAll: ('"&lt;1s&gt; new openOnClass: self andSelector: #' expandMacrosWith: self class fullName);		nextPutAll: self targetSelector; nextPut: $"; cr;		crtab; nextPutAll: '&lt;resource: #menu&gt;';		crtab; nextPut: $^.	UISpecification prettyPrintSpecArray: array on: s tabLevel: 1.	s space; nextPutAll: 'decodeAsLiteralArray'.	self targetClass class compile: s contents classified: #'resources'.	Transcript cr; show: ((#x1s2sDefined &lt;&lt; #UIPainter &gt;&gt; '&lt;1s&gt;%&gt;&lt;2s&gt; defined')			expandMacrosWith: self targetClass class name			with: self targetSelector).	UIFinderVW2 installed: (Array with: self targetClass with: self targetSelector).	modified := false</body><body package="UIPainter">labelFor: view at: i	"Answer a Label for the MenuItem at the given slot in the view"	| item offs ts grid text n |	item := view sequence at: i.	ts := view textStyle.	offs := item value*ts lineGrid+5.	^item key = self lineToken		ifTrue: [			item := view widgetPolicy lookPolicyClass new defaultDivider.			item setLineWidth: 2.			item := BoundedWrapper on: item.			grid := ts lineGrid.			VisualBlock block:				[:gc :b |				item bounds: (offs@(grid//2-1) extent: 80@4);					displayOn: gc]]		ifFalse: [			"Be prepared to handle the degenerate case with a UserMessage."			text := [item key label asText] 				on: Error do: [:ex | ex return: nil].			text == nil 				ifTrue: [	text := (#UndefinedLabel &lt;&lt; #labels &gt;&gt; '&lt;undefined label&gt;') asText]				ifFalse: [					n := item key accessCharacterPosition.					n == nil ifFalse: [text emphasizeFrom: n to: n with: #underline]].			Label				with: text				attributes: ts				offset: offs@0].</body><body package="UIPainter">lineToken	^'-'</body><body package="UIPainter">menuIsAllHierarchical	"Answer whether all of the top level menu items in the menu have submenus."	menu isNil ifTrue: [^false].	menu menuItems do: [:menuItem |		menuItem hasSubmenu ifFalse: [^false]].	^true</body><body package="UIPainter">okToQuitWithChanges	| choice |	choice := Dialog 				choose: (#GenKey3 &lt;&lt; #UIPainter &gt;&gt; 'This menu has been changed. Install the changes?')				labels: (Array with: (#Yes &lt;&lt; #UIPainter &gt;&gt; 'Yes') with: (#No &lt;&lt; #UIPainter &gt;&gt; 'No') with: (#Cancel &lt;&lt; #UIPainter &gt;&gt; 'Cancel'))				values: #(#yes #no #cancel)				default: #yes.	choice = #cancel ifTrue: [^false].	choice = #yes ifTrue: [self install ifNil: [^false]].	^true</body><body package="UIPainter">pasteBufferDepth: newDepth	| delta |	PasteBuffer == nil ifTrue: [PasteBuffer := #()].	delta := PasteBuffer size = 0			ifTrue: [0]			ifFalse: [newDepth-PasteBuffer first value].	^PasteBuffer collect: [:i | i key copy-&gt;(i value+delta)]</body><body package="UIPainter">reloadSelectionInformation	self fixupToolBar.	self disableItemMovement.</body><body package="UIPainter">runInstallationDialog	^((ResourceInstallDialog new)		targetClass: self targetClass;		selector: self targetSelector;		resourceType: #menu;		select)			ifNotNil: 				[:definition |				self targetClass: definition implementingClass					selector: definition selector]</body><body package="UIPainter">selectionCanHaveMyMenu: isAllHierarchical	| controller sels |	(controller := selectionHolder value) isNil ifTrue: [^false].	^(sels := controller selectionList) isEmpty		ifTrue:			[controller model windowSpec hasMenuBar and:				[isAllHierarchical]]		ifFalse:			[sels first spec canHaveMenu]</body><body package="UIPainter">targetTrouble	| tgtClass tgtSelector |	^(tgtClass := self targetClass) isNil or:		[(tgtSelector := self targetSelector) isNil or:			[(tgtClass respondsTo: tgtSelector) not]]</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>private-item accessing</category><body package="UIPainter">catalogIDFor: item	^item rawLabel isString		ifTrue: [nil]		ifFalse: [item rawLabel catalogID]</body><body package="UIPainter">catalogIDFor: item put: aSymbolOrNil	| changed |	changed := true.	item rawLabel isString		ifTrue: 			[aSymbolOrNil isNil 				ifTrue: [changed := false]				ifFalse: [					item rawLabel: (UserMessage 						defaultString: item rawLabel 						key: nil 						catalogID: aSymbolOrNil)]]		ifFalse: 			[item rawLabel: ((aSymbolOrNil isNil and: [item rawLabel key isNil])				ifTrue: [item rawLabel defaultString]				ifFalse: [item rawLabel copy catalogID: aSymbolOrNil])].	changed ifTrue: [		self updateProperties.		menuList list changed: #at: with: menuList selectionIndexes asArray first].	self menuBar value: menu</body><body package="UIPainter">commandIDFor: item	^item commandID</body><body package="UIPainter">commandIDFor: item put: aSymbolStringOrNil	"The commandID is a Symbol or nil when reading from an existing MenuItem,	 or a String when entered through the finder dialog."	| changed |	changed := true.	aSymbolStringOrNil isNil 		ifTrue: [changed := false]		ifFalse: [			| ky |			ky := aSymbolStringOrNil isEmpty ifTrue: [nil] ifFalse: [aSymbolStringOrNil asSymbol].			item commandID = ky 				ifTrue: [changed := false]				ifFalse: [					(self checkExistingCommand: ky) ifFalse: [^self].					item commandID: ky]].	changed ifTrue: [		"Update the Label string as appropriate:			- if there is no label in the item, display the Command's label or an empty label			- if there is a label, keep it as a potential override (to remove it, deselect the override indicator)"		aSymbolStringOrNil isEmpty 			ifTrue: [				"Set a default string (not the entire UserMessage) or keep the label already in the MenuItem"				item definesLabel ifFalse: [item rawLabel: (#EmptyLabel &lt;&lt; #UIPainter &gt;&gt; '&lt;empty label&gt;') asString]].		self updateProperties.		menuList list changed: #at: with: menuList selectionIndexes asArray first].	self menuBar value: menu</body><body package="UIPainter">defaultHelpStringFor: item	^item helpText isString		ifTrue: [item helpText]		ifFalse: [			item helpText isNil				ifTrue: ['']				ifFalse: [item helpText defaultString]]</body><body package="UIPainter">defaultHelpStringFor: item put: aStringOrNil	| helpString |	helpString := aStringOrNil isNil ifTrue: [''] ifFalse: [aStringOrNil].	(item helpText isString or: [item helpText isNil])		ifTrue: [item helpText: helpString]		ifFalse: [			item helpText: (UserMessage defaultString: aStringOrNil key: item helpText key)].	menuList list changed: #at: with: menuList selectionIndexes asArray first.	self menuBar value: menu</body><body package="UIPainter">defaultStringFor: item	^item rawLabel isString		ifTrue: [item rawLabel]		ifFalse: [item rawLabel defaultString]</body><body package="UIPainter">defaultStringFor: item put: aStringOrNil	| ensuredString reset |	ensuredString := aStringOrNil ifNil: [String new] ifNotNil: [aStringOrNil trimBlanks].	reset := ensuredString isEmpty.	(reset or: [(item rawLabel isNil or: [item rawLabel isString])				or: [item rawLabel key isNil &amp; item rawLabel catalogID isNil]])		ifTrue: [item rawLabel: (reset ifTrue: [nil] ifFalse: [ensuredString])]		ifFalse: [item rawLabel: (item rawLabel copy defaultString: ensuredString)].	self updateProperties.	menuList list changed: #at: with: menuList selectionIndexes asArray first.	self menuBar value: menu</body><body package="UIPainter">helpCatalogIDFor: item	^(item helpText isNil or: [item helpText isString])		ifTrue: [nil]		ifFalse: [item helpText catalogID]</body><body package="UIPainter">helpCatalogIDFor: item put: aSymbolOrNil	| changed |	changed := true.	item helpText isString		ifTrue: [			aSymbolOrNil isNil				ifTrue: [changed := false]				ifFalse: [					item helpText: (UserMessage								defaultString: item helpText								key: nil								catalogID: aSymbolOrNil)]]		ifFalse: [			item helpText: ((aSymbolOrNil isNil and: [item helpText key isNil])						ifTrue: [item helpText defaultString]						ifFalse: [item helpText copy catalogID: aSymbolOrNil])].	changed ifTrue: [		menuList list changed: #at: with: menuList selectionIndexes asArray first].	self menuBar value: menu</body><body package="UIPainter">helpLabelKeyFor: item	^(item helpText isNil or: [item helpText isString])		ifTrue: [nil]		ifFalse: [item helpText key]</body><body package="UIPainter">helpLabelKeyFor: item put: aSymbolOrNil	| changed |	changed := true.	item helpText isString		ifTrue: [			aSymbolOrNil isNil				ifTrue: [changed := false]				ifFalse: [					item helpText: (UserMessage						defaultString: item helpText 						key: aSymbolOrNil)]]		ifFalse: [			item helpText: ((aSymbolOrNil isNil and: [item helpText catalogID isNil])						ifTrue: [item helpText defaultString]						ifFalse: [item helpText copy key: aSymbolOrNil])].	changed ifTrue: [		menuList list changed: #at: with: menuList selectionIndexes asArray first].	self menuBar value: menu</body><body package="UIPainter">imageClassNameFor: item	^item realLabelImage class == ResourceRetriever		ifTrue: [item realLabelImage className]		ifFalse: [nil]</body><body package="UIPainter">imageClassNameFor: item put: aStringOrNil	item realLabelImage class == ResourceRetriever		ifTrue: [			aStringOrNil				ifNil: [item labelImage: nil]					ifNotNil: [					item realLabelImage className: aStringOrNil asQualifiedReference.					item realLabelImage notDefined ifTrue: [item labelImage: nil]]]		ifFalse: 			[aStringOrNil ifNotNil: [item labelImage: (ResourceRetriever new className: aStringOrNil asQualifiedReference)]].	self menuBar value: menu</body><body package="UIPainter">imageSelectorFor: item	^item realLabelImage class == ResourceRetriever		ifTrue: [item realLabelImage selector]		ifFalse: [nil]</body><body package="UIPainter">imageSelectorFor: item put: aSymbol	| changed |	changed := true.	item realLabelImage class == ResourceRetriever		ifTrue:			[item realLabelImage selector: aSymbol.			item realLabelImage notDefined ifTrue: [item labelImage: nil]]		ifFalse: [aSymbol isNil 			ifTrue: [changed := false]			ifFalse: [item labelImage: (ResourceRetriever new								selector: aSymbol)]].	changed		ifTrue: [menuList list				changed: #at:				with: menuList selectionIndexes asArray first].	self menuBar value: menu</body><body package="UIPainter">indication: value	currentItem value indication: value.	currentItem changed: #value.	self modified</body><body package="UIPainter">labelKeyFor: item	^item rawLabel isString		ifTrue: [nil]		ifFalse: [item rawLabel key]</body><body package="UIPainter">labelKeyFor: item put: aSymbolOrNil	| changed |	changed := true.	item rawLabel isString		ifTrue: [			aSymbolOrNil isNil				ifTrue: [changed := false]				ifFalse: [					item rawLabel: (UserMessage 						defaultString: item rawLabel 						key: aSymbolOrNil)]]		ifFalse: [			item rawLabel: ((aSymbolOrNil isNil and: [item rawLabel catalogID isNil])						ifTrue: [item rawLabel defaultString]						ifFalse: [item rawLabel copy key: aSymbolOrNil])].	changed ifTrue: [		self updateProperties.		menuList list changed: #at: with: menuList selectionIndexes asArray first].	self menuBar value: menu</body><body package="UIPainter">labelOverrideFor: item	^item hasLabelOverride</body><body package="UIPainter">labelOverrideFor: item put: aBoolean	| command |	(self labelOverrideFor: item) = aBoolean ifTrue: [^self].	aBoolean 		ifFalse: [self defaultStringFor: item put: '']		ifTrue: [			command := CommandRegistry instance commandsById at: (self commandIDFor: item) ifAbsent: [nil].			command isNil ifTrue: [^self].			item rawLabel: command label.			self updateProperties].	self menuBar value: menu</body><body package="UIPainter">notDone	^nil</body><body package="UIPainter">notDone: x</body><body package="UIPainter">shortcutKeyFor: item put: aString	| ch |	aString size &gt; 1 ifTrue: [		item shortcutKeyCharacter: aString asSymbol.		^self].	aString size = 1 ifTrue: [ch := aString first].	(ch notNil and: [ch isAlphaNumeric])		ifTrue: [			item shortcutKeyCharacter: ch]		ifFalse: [			item shortcutKeyCharacter: nil.			self fixupTabBar].	self updateProperties.	currentItem changed: #value</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>testing</category><body package="UIPainter">canAddBelow	^self menu isNil or: 		[(self menu menuItems size = 0) or: 			[self selectionSizeOfOne or:				[self menuList selections size = 0] 			] 		]</body><body package="UIPainter">canAddChild	^(self selectionCanHaveSubmenus) and: [self selectionSizeOfOne]</body><body package="UIPainter">canShiftDown	| enableFlag sel2 items sel grp1 list |	enableFlag := self selectionSizeOfOne and:			[(menuList selectionIndexHolder value asSortedCollection at: 1) &lt; 					(menuList listHolder value size)].	enableFlag	ifTrue: [		list := menuList selectionIndexes.		items := menuList list.		sel := list asArray first.		grp1 := self indicesForAllChildren: sel.		sel2 := grp1 last + 1.		(sel2 &gt; items size or: [(items at: sel) value ~= (items at: sel2) value])		ifTrue: [enableFlag := false].	].	^enableFlag</body><body package="UIPainter">canShiftLeft	| enableFlag |	enableFlag :=	((menuList selectionIndexes contains: [:i | (menuList list at: i) value = 0]) not) and: [self selectionNotEmpty].	^enableFlag</body><body package="UIPainter">canShiftRight	"Don't move menu items that might cause a divider line to have a submenu, or cause an	item to be indented more than one level beyond the item preceding it"	^self selectionNotEmpty and: 			[| last |			last := -1.			menuList selectionIndexes asSortedCollection allSatisfy: 					[:i | 					| prev sel followsSeparator inSequence |					prev := i = 1 ifTrue: [nil -&gt; -1] ifFalse: [menuList list at: i - 1].					sel := menuList list at: i.					inSequence := last = (i - 1).					followsSeparator := prev key = self lineToken &amp; inSequence not.					last := i.					(inSequence or: [prev value &gt;= sel value]) &amp; followsSeparator not]]</body><body package="UIPainter">canShiftUp		| enableFlag sel items sel2 |	enableFlag := (self selectionSizeOfOne and: 			[(menuList selectionIndexHolder value asSortedCollection at: 1) &gt; 1]).	enableFlag	ifTrue: [		items := menuList list.		sel := menuList selectionIndexes asArray first.		sel2 := (sel-1 to: 1 by: -1)			detect: [:i | (items at: i) value &lt;= (items at: sel) value]			ifNone: [0].		(sel2 = 0 or: [(items at: sel) value ~= (items at: sel2) value])		ifTrue: [enableFlag := false]	].	^enableFlag</body><body package="UIPainter">disableItemMovement	"Check whether currently selected item(s) may be moved and enable/disable movement options accordingly.	 This logic mirrors that in the editing operations themselves."	| enableFlag button theToolBar |	"TheToolBar might be nil if the receiver is going to display the currently edited menu as a window Menu"	(theToolBar := builder componentAt: #toolBar) isNil 		ifTrue: [^self].	enableFlag := self canShiftUp.	button := theToolBar componentAt: #shiftUp.	button isEnabled: enableFlag.	enableFlag := self canShiftDown.	button := theToolBar componentAt: #shiftDown.	button isEnabled: enableFlag.	enableFlag := self canShiftLeft.	button := theToolBar componentAt: #shiftLeft.	button isEnabled: enableFlag.	enableFlag := self canShiftRight.	button := theToolBar componentAt: #shiftRight.	button isEnabled: enableFlag</body><body package="UIPainter">selectedWidgetHasMenu	| controller list wdgt wCtrlr spec |	(controller := selectionHolder value) isNil ifTrue: [^false].	((list := controller selectionList) size == 1 and:		[((wdgt := list first widget) respondsTo: #controller) and:			[((wCtrlr := wdgt controller) respondsTo: #menu) and:				[wCtrlr menu notNil]]])		ifTrue: [^true].	controller model targetClass isNil ifTrue: [^false].	(list := controller selectionList) isEmpty		ifTrue: [^controller model windowSpec hasMenuBar].	list size &gt; 1 ifTrue: [^false].	^(spec := list first spec) canHaveMenu and:		[spec menu notNil or:			[(wCtrlr respondsTo: #menu) and:				[wCtrlr menu notNil]]]</body><body package="UIPainter">selectionCanHaveSubmenus	| all |	all := menuList selections.	all size = 1 ifFalse: [^all size = 0].	^all asArray first key ~= self lineToken</body><body package="UIPainter">selectionNotEmpty	| all |	all := menuList selections.	^all size &gt; 0</body><body package="UIPainter">selectionSizeOfOne	| all |	all := menuList selections.	^all size = 1</body><body package="UIPainter">validLineTokens	"Check all the line tokens to make sure they are in valid places"	"Line tokens may not be the first item in a menu or submenu"	| list |	list := menuList list.	1 to: list size do:		[ :i | | item |			item := (list at: i) key.			item = self lineToken			ifTrue: [				( (i = 1) or: [(( list at: (i-1)) value) &lt; ((list at: i) value )])				ifTrue: [					Dialog warn: (#GenKey8 &lt;&lt; #UIPainter &gt;&gt; 'This menu contains a separator linein an invalid position. Please correctit before selecting this option').					^false]			]		].	^true</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>accessing</category><body package="UIPainter">controller	^self builder window controller</body><body package="UIPainter">menu		^menu</body><body package="UIPainter">menu: aMenuOrNil		menu := aMenuOrNil.	menu == nil ifFalse: [menu findGuiResourcesIn: targetClass].</body><body package="UIPainter">targetClass	(targetClass notNil and: [targetClass isObsolete])		ifTrue:			[targetClass := nil].	^targetClass</body><body package="UIPainter">targetClass: aClass selector: aSelector	targetClass := aClass.	targetSelector := aSelector</body><body package="UIPainter">targetSelector	^targetSelector</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>properties</category><body package="UIPainter">isOnMenu	^Menu new		addItem: ((MenuItem labeled: (#None &lt;&lt; #UIPainter &gt;&gt; 'None')) indication: nil; value: #(nil));		addItem: ((MenuItem labeled: (#InitiallyOn &lt;&lt; #UIPainter &gt;&gt; 'Initially On')) indication: true; value: #(true));		addItem: ((MenuItem labeled: (#InitiallyOff &lt;&lt; #UIPainter &gt;&gt; 'Initially Off')) indication: false; value: #(false));		yourself</body><body package="UIPainter">modified	modified := true</body><body package="UIPainter">sliceTabChanged	| wrapper |	wrapper := builder componentAt: #propertyCanvas.	wrapper isNil ifTrue: [^self].	wrapper widget		client: self		spec: (#(#basicSliceInt #detailSlice #defaultSlice)				at: (#(#Basic #Details #State) indexOf: properties selection key))		builder: builder</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>list control</category><body package="UIPainter">fakePerformer	^nil asValue</body><body package="UIPainter">menuBar	^menuBar</body><body package="UIPainter">menuList	^menuList</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>editing operations</category><body package="UIPainter">addBelow	| list firstItemIndex indent items |	(self menu isNil or: [self menu menuItems size = 0 or: [self menuList selections size = 0]]) 		ifTrue: [self addChild]		ifFalse: 			[list := menuList selectionIndexes.			self selectionSizeOfOne ifFalse: [^self flash].			items := menuList list.			firstItemIndex := list asArray first.			indent := (items at: firstItemIndex) value.			[(firstItemIndex := firstItemIndex + 1) &lt;= items size and: [(items at: firstItemIndex) value &gt; indent]] whileTrue.			items add: self newItem -&gt; indent beforeIndex: firstItemIndex.			menuList selectionIndexes: (OrderedCollection with: firstItemIndex).			self rebuildMenu]</body><body package="UIPainter">addChild	| list firstItemIndex indent |	self selectionCanHaveSubmenus ifFalse: [^self flash].	list := menuList selectionIndexes.	list size = 0 		ifTrue: 			[firstItemIndex := 1.			indent := 0]		ifFalse: 			[firstItemIndex := list asArray first + 1.			indent := (menuList list at: firstItemIndex - 1) value + 1].	menuList list add: self newItem -&gt; indent beforeIndex: firstItemIndex.	menuList selectionIndexes: (Set with: firstItemIndex).	self rebuildMenu</body><body package="UIPainter">addLine	| list firstItemIndex indent items |	list := menuList selectionIndexes.	self selectionSizeOfOne ifFalse: [^self flash].	items := menuList list.	firstItemIndex := list asArray first.	indent := (items at: firstItemIndex) value.	[(firstItemIndex := firstItemIndex + 1) &lt;= items size and: [(items at: firstItemIndex) value &gt; indent]] whileTrue.	items add: self lineToken -&gt; indent beforeIndex: firstItemIndex.	menuList selectionIndexes: (Set with: firstItemIndex).	self rebuildMenu</body><body package="UIPainter">copyItem	| items index |	items := menuList selectionIndexes.	self selectionSizeOfOne ifFalse: [^self flash].	index := items asArray first.	items := self indicesForAllChildren: index.	self copySelection: (menuList list copyFrom: items first to: items last).</body><body package="UIPainter">cutItem	"Try to hilite entry above after the cut item(s) have gone"	| items index sequenceView |	items := menuList selectionIndexes.	self selectionSizeOfOne ifFalse: [^self flash].	index := items asArray first.	items := self indicesForAllChildren: index.	self copySelection: (menuList list copyFrom: items first to: items last).	menuList list removeFrom: items first to: items last.	menuList selectionIndexes: Set new.	menuList list isEmpty not ifTrue: 			[sequenceView := (self builder componentAt: #menuList) widget.			(items first - 1 &lt;= menuList list size and: [items first &gt; 1]) 				ifTrue: 					[sequenceView useSingleSelectionIndex: items first - 1.					sequenceView targetIndex: items first - 1]				ifFalse: [sequenceView useSingleSelectionIndex: 1]].	self updateProperties.	self rebuildMenu</body><body package="UIPainter">flash	builder window component flash; flash</body><body package="UIPainter">newItem	^MenuItem labeled: (#newItem &lt;&lt; #UIPainter &gt;&gt; '&lt;new item&gt;') asString</body><body package="UIPainter">pasteBelow	| items index depth startIndex sequenceView |	items := menuList selectionIndexes.	self selectionSizeOfOne ifFalse: [^self flash].	PasteBuffer size = 0 ifTrue: [^self flash].	startIndex := items asArray first.	index := (self indicesForAllChildren: startIndex) last + 1.	depth := (menuList list at: startIndex) value.	(self pasteBufferDepth: depth) reverseDo:		[:item |		menuList list add: item beforeIndex: index].	sequenceView := (self builder componentAt: #menuList) widget.	sequenceView useSingleSelectionIndex: index.	sequenceView targetIndex: index.	self rebuildMenu</body><body package="UIPainter">pasteChild	| items index depth |	items := menuList selectionIndexes.	self selectionCanHaveSubmenus ifFalse: [^self flash].	PasteBuffer size = 0 ifTrue: [^self flash].	items isEmpty		ifTrue:			[index := 1.			depth := 0]		ifFalse:			[index := items asArray first+1.			depth := (menuList list at: index-1) value+1].	(self pasteBufferDepth: depth) reverseDo:		[:item |		menuList list add: item beforeIndex: index].	menuList selectionIndexes: (Set with: index).	self rebuildMenu</body><body package="UIPainter">rebuildMenu	| list |	self modified.	list := menuList list.	1 to: list size do:		[:i | | item |		item := (list at: i) key.		item = self lineToken			ifFalse: [item submenu: (self constructSubmenuForIndex: i)]].	self menu: (self constructSubmenuForIndex: nil).	self menuBar value: menu.</body><body package="UIPainter">removeSelection	| list items fullList lastRemoved sequenceView |	items := menuList list.	list := menuList selectionIndexes.	fullList := OrderedCollection new.	list do: [:each | fullList addAll: (self indicesForAllChildren: each)].	fullList asSortedCollection reverseDo: 			[:each | 			items removeAtIndex: each.			lastRemoved := each].	menuList selectionIndexes: Set new.	items isEmpty ifFalse: 			[sequenceView := (self builder componentAt: #menuList) widget.			lastRemoved &gt; 1 				ifTrue: 					[sequenceView useSingleSelectionIndex: lastRemoved - 1.					sequenceView targetIndex: lastRemoved - 1]				ifFalse: [sequenceView useSingleSelectionIndex: lastRemoved]].	"there are items left in menu"	self updateProperties.	self rebuildMenu</body><body package="UIPainter">shiftDown	"Swap the currently selected item with the next same-level item 	below it. Each menu item carries its submenu with it. If there is no 	same-level item below it, or if that item is not on the same 	submenu as the selected item, don't do anything."	| sel items sel2 grp cut |	self canShiftDown ifTrue: 			[items := menuList list.			sel := menuList selectionIndexes asArray first.			sel2 := (self indicesForAllChildren: sel) last + 1.			grp := self indicesForAllChildren: sel2.			cut := items removeFrom: grp first to: grp last.			items addAll: cut beforeIndex: sel.			menuList selectionIndexes: (Set with: sel + grp size).			self updateProperties.			self rebuildMenu]</body><body package="UIPainter">shiftLeft	"Move all selected items to the left. If one of the	selected items is already at the left margin, do nothing.	If a selected item has a submenu, then the submenu	is also shifted left in order to preserve the integrity of	the menu."	| list sel list1 |	list := menuList selectionIndexes copy.	list1 := list copy.		"Add in the submenu, but only if it has not		been added before. This means that the left		shift will add extra items ONLY when needed		to preserve the integrity of the menu, which		means that there's a greater chance that a		right shift will be able to undo the edit."	list copy do:		[:i | (list1 includes: i+1)			ifFalse: [list addAll: (self indicesForAllChildren: i)]].	menuList selectionIndexes: list.	(list contains: [:i | (menuList list at: i) value = 0])		ifTrue: [^self flash].	list do:		[:i |		sel := menuList list at: i.		sel value: (sel value-1 max: 0).		menuList list changed: #at: with: i.		].	self updateProperties.	self rebuildMenu</body><body package="UIPainter">shiftRight	"Move all selected items to the right. If this would	cause a divider line to have a submenu, or cause an	item to be indented more than one level beyond the	item preceding it, then don't move any of the items."	| list prev sel shiftedValues |	list := menuList selectionIndexes asSortedCollection.	shiftedValues := menuList list collect: [:i | i key -&gt; i value].	list do: 			[:i |			prev := i = 1 ifTrue: [nil -&gt; -1] ifFalse: [shiftedValues at: i - 1].			sel := menuList list at: i.			(prev key = self lineToken				ifTrue: [sel value &gt;= prev value]				ifFalse: [sel value &gt; prev value])					ifTrue: [^self flash]					ifFalse: [(shiftedValues at: i) value: sel value + 1].			menuList list changed: #at: with: i].	list do: 			[:i |			sel := menuList list at: i.			sel value: (shiftedValues at: i) value.			menuList list changed: #at: with: i].	self updateProperties.	self rebuildMenu</body><body package="UIPainter">shiftUp	"Swap the currently selected item with the next same-level item 	above it. Each menu item carries its submenu with it. If there is no 	same-level item above it, or if that item is not on the same 	submenu as the selected item, don't do anything."	| list sel items grp1 sel2 cut |	list := menuList selectionIndexes.	list size = 1 ifFalse: [^self flash].	items := menuList list.	sel := list asArray first.	grp1 := self indicesForAllChildren: sel.	sel2 := (sel - 1 to: 1 by: -1) 		detect: [:each | (items at: each) value &lt;= (items at: sel) value] 		ifNone: [0].	(sel2 = 0 or: [(items at: sel) value ~= (items at: sel2) value]) ifTrue: [^self flash].	cut := items removeFrom: grp1 first to: grp1 last.	items addAll: cut beforeIndex: sel2.	menuList selectionIndexes: (Set with: sel2).	self updateProperties.	self rebuildMenu</body><body package="UIPainter">showMenuBar	| oldB |	(menuBarView notNil and: [menuBarView isOpen])		ifTrue: [^menuBarView raise].	"Check that the menu is hierarchical"	(menuList list contains: [:l | l value &gt; 0])		ifFalse: [Dialog warn: (#GenKey7 &lt;&lt; #UIPainter &gt;&gt; 'Empty and single hierarchy menus are not available as Menu Bars')]		ifTrue: [			(self validLineTokens)			ifTrue: [				oldB := builder.				menuBarView := (self openInterface: #subWindowSpec) window.				menuBarView beSlave.					"The next line stops changeRequest detecting changes 				in the model and prompting for discard confirmation"				menuBarView controller model: nil.				builder := oldB			]	"check for invalid line tokens"		]	"check for empty/single hierarchy menu"</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>interface opening</category><body package="UIPainter">openOnClass: aClass andSelector: aSelector 	aSelector isNil ifFalse: [aSelector numArgs = 0			ifFalse: 				[Dialog warn: (#MethodDoesntReturnMenu &lt;&lt; #UIPainter &gt;&gt; 'The method did not return a menu') for: builder window.				^self]].	self targetClass: aClass selector: aSelector.	UIFinderVW2 visited: (Array with: aClass with: aSelector).	self open.	aSelector isNil ifFalse: [self initializeFromMenu: (aClass perform: aSelector)]</body><body package="UIPainter">postBuildWith: aBuilder	"Finish up the build phase."	| list canvas item |	super postBuildWith: aBuilder.	list := self widgetAt: #menuList.	list == nil		ifFalse: [list selectedVisualBlock:					[:v :i | | rw |					rw := ReversingWrapper on: (self labelFor: v at: i).					rw reverse setValue: true.					BoundedWrapper on: rw].				list visualBlock:					[:v :i |					BoundedWrapper on: (self labelFor: v at: i)]].	(canvas := self widgetAt: #propertyCanvas) notNil		ifTrue: [			canvas tabBar widget visualBlock:				[:view :index | 				| graphic |				graphic := (view sequence at: index) value evaluate.				BoundedWrapper on: graphic]].	self augmentLabelMenu.	self augmentValueMenu.	self installModuleMenus.	(self widgetAt: #iString) ifNotNil: [:iStr | iStr tooltip: [self stringInfoTooltip] ].	(self widgetAt: #iKey) ifNotNil: [:iStr | iStr tooltip: [self messageInfoTooltip] ].	(self widgetAt: #iCatalog) ifNotNil: [:iStr | iStr tooltip: [self messageInfoTooltip] ].	(self widgetAt: #iCommand) ifNotNil: [:iCmd | iCmd tooltip: [self commandInfoTooltip] ].	(self widgetAt: #iKeystroke) ifNotNil: [:iKy | iKy tooltip: [self keystrokeInfoTooltip] ].	(item := self widgetAt: #itemValue) notNil		ifTrue: [item converter initForLiteral].	currentItem changed: #value.</body><body package="UIPainter">postOpenWith: aBuilder	"Finish up the opening phase."	super postOpenWith: aBuilder.	properties == nil ifFalse: [properties selectionIndexHolder value: properties selectionIndex].	self updateProperties</body><body package="UIPainter">preBuildWith: aBuilder	"Finish up the build phase."	| finder idFinder |	aBuilder aspectAt: #currentNameKey		put: ((PluggableAdaptor on: currentItem)				getBlock: [:m | m value nameKey]				putBlock: [:m :v | m value nameKey: v.							self modified]				updateBlock: [:m :a :p | a == #value]).	aBuilder aspectAt: #itemLabelOverride		put: ((PluggableAdaptor on: currentItem)				getBlock: [:m | self labelOverrideFor: m value]				putBlock: [:m :v | self labelOverrideFor: m value put: v. 							self modified]				updateBlock: [:m :a :p | a == #value]).	aBuilder aspectAt: #labelDefaultString 		put: ((PluggableAdaptor on: currentItem)				getBlock: [:m | self defaultStringFor: m value]				putBlock: [:m :v | self defaultStringFor: m value put: v. 							self modified]				updateBlock: [:m :a :p | a == #value]).	aBuilder aspectAt: #labelKey		put: ((PluggableAdaptor on: currentItem)				getBlock: [:m | self labelKeyFor: m value]				putBlock: [:m :v | self labelKeyFor: m value put: v. 							self modified]				updateBlock: [:m :a :p | a == #value]).	aBuilder aspectAt: #catalogID		put: ((PluggableAdaptor on: currentItem)				getBlock: [:m | self catalogIDFor: m value]				putBlock: [:m :v | self catalogIDFor: m value put: v. 							self modified]				updateBlock: [:m :a :p | a == #value]).	aBuilder aspectAt: #shortCutChar		put: ((PluggableAdaptor on: currentItem)				getBlock: [:m | m value realAdornment shortcutKeyString]				putBlock: [:m :v | self shortcutKeyFor: m value put: v. 							self modified]				updateBlock: [:m :a :p | a == #value]).	aBuilder aspectAt: #functionKeys		put:#(F1 F2 F3 F4 F5 F6 F7 F8 F9 F11 F12 Home Left Right Up Down PageUp PageDown End) asValue.	aBuilder aspectAt: #hasAlt		put:((PluggableAdaptor on: currentItem)				getBlock:[:m | m value usesShortcutModifier: #altMask]				putBlock:[:m :v| m value enable: v shortcutModifier: #altMask]				updateBlock: [:m :a :p | a == #value]).	aBuilder aspectAt: #hasCtrl		put:((PluggableAdaptor on: currentItem)				getBlock:[:m | m value usesShortcutModifier: #ctrlMask]				putBlock:[:m :v| m value enable: v shortcutModifier: #ctrlMask]				updateBlock: [:m :a :p | a == #value]).	aBuilder aspectAt: #hasShift		put:((PluggableAdaptor on: currentItem)				getBlock:[:m | m value usesShortcutModifier: #shiftMask]				putBlock:[:m :v| m value enable: v shortcutModifier: #shiftMask]				updateBlock: [:m :a :p | a == #value]).	aBuilder aspectAt: #visibilitySelector		put: ((PluggableAdaptor on: currentItem)			getBlock: [:m | m value visibilitySelector]			putBlock: [:m :v | m value visibilitySelector: v.						self modified]			updateBlock: [:m :a :p | #value == a]).	aBuilder aspectAt: #enablementSelector		put: ((PluggableAdaptor on: currentItem)			getBlock: [:m | m value enablementSelector]			putBlock: [:m :v | m value enablementSelector: v.						self modified]			updateBlock: [:m :a :p | #value == a]).	aBuilder aspectAt: #indicationSelector		put: ((PluggableAdaptor on: currentItem)			getBlock: [:m | m value indicationSelector]			putBlock: [:m :v | m value indicationSelector: v.						self modified]			updateBlock: [:m :a :p | #value == a]).	idFinder := EntryWithPasteButtonModule forCommandID.	idFinder entryHolder compute: [:nm |				self commandIDFor: currentItem value put: nm.				self modified].	currentItem compute: [:itm | | nm |				nm := self commandIDFor: itm.				idFinder value = nm ifFalse: [					idFinder value: nm.					self updateLabelEnablement.					self updateKeystrokeEnablement.					self updateInfoIcons]].	aBuilder aspectAt: #commandKey put: idFinder.	finder := EntryWithPasteButtonModule forClasses.	finder entryHolder compute: [:nm |				| ref |				ref := nm isEmpty ifTrue: [nil] ifFalse: [nm asQualifiedReference].				self imageClassNameFor: currentItem value put: ref. 				self modified].	currentItem compute: [:itm | | nm |				nm := self imageClassNameFor: itm.				nm := nm == nil ifTrue: [''] ifFalse: [nm asString].				finder value = nm					ifFalse: [finder value: nm]].	aBuilder aspectAt: #labelImageClassName put: finder.	aBuilder aspectAt: #labelImageSelector		put: ((PluggableAdaptor on: currentItem)				getBlock: [:m | self imageSelectorFor: m value]				putBlock: [:m :v | self imageSelectorFor: m value put: v. 							self modified]				updateBlock: [:m :a :p | a == #value]).	aBuilder aspectAt: #itemColor		put: ((PluggableAdaptor on: currentItem)				getBlock: [:m | self notDone]				putBlock: [:m :v | self notDone: v. 							self modified]				updateBlock: [:m :a :p | a == #value]).	aBuilder aspectAt: #itemValue		put: ((PluggableAdaptor on: currentItem)				getBlock: [:m | m value value]				putBlock: [:m :v | m value value: v. 							self modified]				updateBlock: [:m :a :p | a == #value]).	aBuilder aspectAt: #itemVisible		put: ((PluggableAdaptor on: currentItem)				getBlock: [:m | m value isVisible]				putBlock: [:m :v | m value visible: v. 							self modified]				updateBlock: [:m :a :p | a == #value]).	aBuilder aspectAt: #itemEnabled		put: ((PluggableAdaptor on: currentItem)				getBlock: [:m | m value isEnabled]				putBlock: [:m :v | m value enabled: v. 							self modified]				updateBlock: [:m :a :p | a == #value]).	aBuilder aspectAt: #itemIsNormal		put: ((PluggableAdaptor on: currentItem)				getBlock: [:m | m value indication == nil]				putBlock: [:m :v | self indication: nil]				updateBlock: [:m :a :p | a == #value]).	aBuilder aspectAt: #itemIsOn		put: ((PluggableAdaptor on: currentItem)				getBlock: [:m | m value indication == true]				putBlock: [:m :v | self indication: true]				updateBlock: [:m :a :p | a == #value]).	aBuilder aspectAt: #itemIsOff		put: ((PluggableAdaptor on: currentItem)				getBlock: [:m | m value indication == false]				putBlock: [:m :v | self indication: false]				updateBlock: [:m :a :p | a == #value]).	aBuilder aspectAt: #helpText		put: ((PluggableAdaptor on: currentItem)				getBlock: [:m | self defaultHelpStringFor: m value]				putBlock: [:m :v | self defaultHelpStringFor: m value put: v. 							self modified]				updateBlock: [:m :a :p | a == #value]).	aBuilder aspectAt: #helpLookupKey		put: ((PluggableAdaptor on: currentItem)				getBlock: [:m | self helpLabelKeyFor: m value]				putBlock: [:m :v | self helpLabelKeyFor: m value put: v. 							self modified]				updateBlock: [:m :a :p | a == #value]).	aBuilder aspectAt: #helpCatalog		put: ((PluggableAdaptor on: currentItem)				getBlock: [:m | self helpCatalogIDFor: m value]				putBlock: [:m :v | self helpCatalogIDFor: m value put: v. 							self modified]				updateBlock: [:m :a :p | a == #value]).</body><body package="UIPainter">specificationFor: aName	^self perform: aName</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>menus</category><body package="UIPainter">editingMenuBar	| myMenu item |	myMenu := self class editingMenuBar.	(myMenu someMenuItemWithValue: #install)		enabled: [self menu notNil].	(myMenu someMenuItemWithValue: #addChild)		enabled: [self canAddChild].	(myMenu someMenuItemWithValue: #addBelow)		enabled: [self canAddBelow].	#(copyItem cutItem addLine ) do:		[:i |			item := myMenu someMenuItemWithValue: i.			item enabled: [self selectionSizeOfOne]		].	(myMenu someMenuItemWithValue: #shiftUp)		enabled: [self canShiftUp].	(myMenu someMenuItemWithValue: #shiftDown)		enabled: [self canShiftDown].	(myMenu someMenuItemWithValue: #shiftLeft)		enabled: [self canShiftLeft].	(myMenu someMenuItemWithValue: #shiftRight)		enabled: [self canShiftRight].	(myMenu someMenuItemWithValue: #pasteBelow)		enabled: [self selectionSizeOfOne and: [PasteBuffer size &gt; 0]].	(myMenu someMenuItemWithValue: #removeSelection)		enabled: [self selectionNotEmpty].	(myMenu someMenuItemWithValue: #read)		enabled: [self selectedWidgetHasMenu].	(myMenu someMenuItemWithValue: #apply)		enabled: [self selectionCanHaveMyMenu: self menuIsAllHierarchical].	(myMenu atNameKey: #testItem) submenu: [self testMenu].	^myMenu</body><body package="UIPainter">fixupTabBar	| comp |	(comp := builder componentAt: #propertyCanvas) isNil 		ifTrue: [^self].	comp widget invalidate</body><body package="UIPainter">fixupToolBar	"Note: #shiftUp, #shiftDown, #shiftRight and #shiftLeft are dependent on 	list position and are controlled by the method disableItemMovement"	| theToolBar |	"TheToolBar might be nil if the receiver is going to display the currently edited menu as a window 	Menu"	(theToolBar := builder componentAt: #toolBar) isNil 		ifTrue: [^self].	(theToolBar componentAt: #install)		isEnabled: self menu notNil.	(theToolBar componentAt: #addChild)		isEnabled: self canAddChild.	(theToolBar componentAt: #addBelow)		isEnabled: self canAddBelow.	#(copyItem cutItem addLine) do:		[:each |		(theToolBar componentAt: each)			isEnabled: self selectionSizeOfOne].	(theToolBar componentAt: #pasteBelow)		isEnabled: (self selectionSizeOfOne and: [PasteBuffer size &gt; 0]).	(theToolBar componentAt: #removeSelection)		isEnabled: self selectionNotEmpty</body><body package="UIPainter">itemsMenu	|  itemMenu  item |	itemMenu := self class itemsMenu.	(itemMenu someMenuItemWithValue: #pasteBelow)		enabled: [self selectionSizeOfOne and: [PasteBuffer size &gt; 0]].	(itemMenu someMenuItemWithValue: #removeSelection)		enabled: [self selectionNotEmpty].	#(copyItem cutItem) do:		[:i | 			item := itemMenu someMenuItemWithValue: i.			item enabled: [self selectionSizeOfOne]		].	^itemMenu</body><body package="UIPainter">testMenu	"Return a submenu for the MenuEditor Test option"	| hiddenMenu |	menu == nil ifTrue: [^Menu labelArray: (Array with: (#NoMenu &lt;&lt; #UIPainter &gt;&gt; '&lt;&lt; no menu &gt;&gt;')) values: #(0)].	(menuList list isEmpty)	ifTrue: [^Menu labelArray: (Array with: (#NoMenuItems &lt;&lt; #UIPainter &gt;&gt; '&lt;&lt; no menu items &gt;&gt;')) values: #(0)].	(self validLineTokens)	ifFalse: [		"The Editor menu expects a submenu. When the		menu under test is invalid, you don't want to display		anything, the above method will show a dialog. As		you can't return nil or an empty menu, create a dummy		item and hide it."		hiddenMenu := Menu labelArray: #(' ') values: #(0).		hiddenMenu hideItem: (hiddenMenu menuItemAt: 1).		^hiddenMenu	].	^menu</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>actions</category><body package="UIPainter">apply	| controller  sels spec mnuSym |	(controller := selectionHolder value) isNil ifTrue: [^self].	sels := controller selections.	spec := 		(sels isNil or: [sels isEmpty])		ifTrue: [controller model windowSpec]		ifFalse: [sels first spec].	mnuSym := spec menu.	mnuSym notNil 	ifTrue: [		mnuSym := mnuSym asSymbol.	].	self targetClass: controller model targetClass selector: mnuSym.	"install the menu on the target class - user can change selector"	self install.	(targetClass notNil and: [targetSelector notNil])	ifTrue: [		"set the menu of the spec to be what was just installed"		spec menu: self targetSelector asSymbol.		"update the originator of the menu"		(spec isKindOf: WindowSpec)		ifTrue: [			(self findMenuBarFor: controller view topComponent)			menuChannel: (targetClass perform: targetSelector).			self targetSelector~~ mnuSym			ifTrue: [controller canvasHasChanged: true]		]		ifFalse: [			self targetSelector ~~ mnuSym			ifTrue: [				"replaceElement:etc. will cause change to be noted, 				and select: will cause UIPainterWatchers to be alerted"				controller broadcastPendingSelectionChange.				controller select: (controller replaceElement: sels first  basedOnSpec: spec)			]	"selector has changed"		]	"not WindowSpec"	].	"class and selector not nil"</body><body package="UIPainter">install	self validLineTokens	ifTrue: [		(self targetTrouble or: [(UIPainter preferenceFor: #avoidInstallationDialog) not or: [builder window sensor shiftDown]])			ifTrue: [				self checkCommandConflicts ifFalse: [^nil].				self runInstallationDialog isNil ifTrue: [^nil]].		self resolveKeystrokeConflicts.		self removeDuplicateLabelOverrides.		self installInSystem	].</body><body package="UIPainter">load	| mnu result |	self changeRequest ifFalse: [^self].	result := (ResourceInstallDialog new)				targetClass: self targetClass;				resourceType: #menu;				loadSelect.	result ifNil: [^self].	self targetClass: result implementingClass selector: result selector.	mnu := nil.	self messageNotUnderstoodSignal		handle: 			[:ex |			ex parameter selector == self targetSelector				ifTrue: [ex return]				ifFalse: [ex pass]]		from: self targetClass		do: [mnu := self targetClass perform: self targetSelector].	(mnu isNil or: [((mnu := mnu value) isKindOf: Menu) not])		ifTrue: 			[Dialog warn: #MethodDoesntReturnMenu &lt;&lt; #UIPainter						&gt;&gt; 'The method did not return a menu'				for: builder window.			^self].	self initializeFromMenu: mnu</body><body package="UIPainter">newMenu	self changeRequest	ifTrue: [self targetClass: nil selector: nil.			self initializeFromMenu: Menu new].</body><body package="UIPainter">read	| isMenuBar spec controller mnu sels |	self changeRequest ifFalse: [^self].	isMenuBar := false.	controller := selectionHolder value.	sels := controller selections.	spec := (sels isNil or: [sels isEmpty])		ifTrue:			[isMenuBar := true.			controller model windowSpec]		ifFalse: [controller selections first spec].	"We are relying on Read not being enabled if the selected component's	controller does not understand #menu."	spec menu isNil		ifTrue:			[(isMenuBar not and: [(mnu := sels first widget controller menu copy) notNil])				ifFalse:					[Dialog warn: (#GenKey6 &lt;&lt; #UIPainter &gt;&gt; 'The selected component''s propertiesdon''t specify a menu') for: builder window.					^self]]		ifFalse:			[mnu := controller builder menuAt: spec menu].	(mnu isNil or: [((mnu := mnu value) isKindOf: Menu) not])		ifTrue:			[Dialog warn: (#GenKey5 &lt;&lt; #UIPainter &gt;&gt; 'The application did not supply a menu.') for: builder window.			^self].	self initializeFromMenu: mnu.	self targetClass: controller builder source selector: spec menu.</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>initialize-release</category><body package="UIPainter">basicSliceLabel	| row |	row := VisualRow new.	row add: (Label with: (#Basic &lt;&lt; #UIPainter &gt;&gt; 'Basic')).	self currentItemHasLabelConflict ifTrue: [		row add: (' ' asVisualPart).		row add: GeneralIcons warning].	^row</body><body package="UIPainter">detailsSliceLabel	| row |	row := VisualRow new.	row add: (Label with: (#Details &lt;&lt; #UIPainter &gt;&gt; 'Details')).	self currentItemHasKeystrokeConflict ifTrue: [		row add: (' ' asVisualPart).		row add: GeneralIcons warning].	^row</body><body package="UIPainter">initialize	super initialize.	currentItem := (MenuItem labeled: '') asValue.	menuBar := nil asValue.	menuList := MultiSelectionInList new.	menuList selectionIndexes: Set new.	menuList selectionIndexHolder onChangeSend: #updateProperties to: self.	modified := false.</body><body package="UIPainter">initializeFromMenu: aMenu	"Delay setting the menu instVar because the various blocks laden onto	the menuString ValueHolder will cause the instVar to get reset before	it can be used."		| theMenu s |	theMenu := aMenu.	(theMenu isKindOf: Array) ifTrue: [theMenu := theMenu decodeAsLiteralArray].	s := List new.	self buildListFrom: theMenu depth: 0 into: s.	menuList list: s.	self menu: theMenu.	self menuBar value: menu.	modified := false</body><body package="UIPainter">propertyPages	properties isNil ifTrue: 		[properties := SelectionInList new.		properties list add: (Association key: #Basic value: [self basicSliceLabel]).		properties list add: (Association key: #Details value: [self detailsSliceLabel]).		properties list add: (Association key: #State value: (Label with: #State &lt;&lt; #UIPainter &gt;&gt; 'State')).		properties selection: properties list first.		properties 			expressInterestIn: #selectionIndex			for: self			sendBack: #sliceTabChanged].	^properties</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>private-commands</category><body package="UIPainter">augmentLabelMenu	"When a menu is defined through the UIPainter, the menuHolder contains a menu and not a ValueHolder containing a menu."	| widget |	(widget := self widgetAt: #labelDefaultString) isNil		ifFalse: [			| mnu itm |			mnu := widget controller menu copy.			mnu addLine.			itm := MenuItem labeled: #CopyLabel &lt;&lt; #menus &gt;&gt; 'Copy label'.			itm value: [self currentItemCopyLabel].			mnu addItem: itm.			itm := MenuItem labeled: #PasteLabel &lt;&lt; #menus &gt;&gt; 'Paste label'.			itm value: [self currentItemPasteLabel].			mnu addItem: itm.			widget controller menuHolder: mnu]</body><body package="UIPainter">augmentValueMenu	"When a menu is defined through the UIPainter, the menuHolder contains a menu and not a ValueHolder containing a menu."	| widget |	(widget := self widgetAt: #itemValue) isNil		ifFalse: [			| mnu itm |			mnu := widget controller menu copy.			mnu addLine.			itm := MenuItem labeled: #InspectRBCommand &lt;&lt; #menus &gt;&gt; 'Inspect RBCommand'.			itm value: [self currentItemInspectRBCommand].			itm enablement: #currentItemIsRBCommand.			mnu addItem: itm.			widget controller menuHolder: mnu]</body><body package="UIPainter">commandInfoIcon	^self currentItemHasLabelConflict ifTrue: [self errorIcon] ifFalse: [self noIcon]</body><body package="UIPainter">commandInfoTooltip	^self currentItemHasLabelConflict		ifTrue: [^#CommandLabelConflict &lt;&lt; #labels &gt;&gt; 'Label defined by the Command conflicts with Menu Item label']		ifFalse: [nil]</body><body package="UIPainter">currentItemClearKeystroke	self shortcutKeyFor: currentItem value put: ''</body><body package="UIPainter">currentItemCopyLabel	labelPasteBuffer := currentItem value labelSource copy</body><body package="UIPainter">currentItemEditCommand	| cmd pragma |	cmd := (self commandIDFor: currentItem value) asSymbol.	pragma := ((Pragma allNamed: #command: in: CommandRegistry class)				select: [:ea | (ea argumentAt: 1) = cmd]) first.	(Refactory.Browser.SelectorEnvironment		onMethods: (Array with: pragma methodDefinition)) openEditor</body><body package="UIPainter">currentItemInspectRBCommand	| key |	key := (self widgetAt: #currentNameKey) model value.	(Refactory.Browser.RBCommand actionNamed: key asString) inspect</body><body package="UIPainter">currentItemPasteLabel	labelPasteBuffer isNil ifFalse: [		currentItem value rawLabel: labelPasteBuffer.		self updateProperties]</body><body package="UIPainter">errorIcon	^GeneralIcons warning</body><body package="UIPainter">infoIcon	(self currentItemHasCommand and: [self currentItemHasLabelOverride not]) ifTrue: [^self protectedIcon].	^self noIcon</body><body package="UIPainter">installModuleMenus	| widget |	(widget := self widgetAt: #commandKey) isNil ifFalse: [		| field |		field := widget children first widget.		field ifNotNil: [			| mnu itm |			mnu := self class inputBaseMenu.			mnu addLine.			itm := (MenuItem labeled: #EditCommand &lt;&lt; #menus &gt;&gt; 'Edit Command')				visible: [self currentItemHasCommand];				value: [self currentItemEditCommand];				yourself.			mnu addItem: itm.			field controller menuHolder value: mnu ] ].	(widget := self widgetAt: #labelImageClassName) isNil ifFalse: [		| field |		field := widget children first widget.		field ifNotNil: [			| mnu |			mnu := self class inputBaseMenu.			field controller menuHolder value: mnu ] ]</body><body package="UIPainter">keystrokeInfoIcon	self currentItemHasKeystrokeConflict ifTrue: [^self errorIcon].	^self noIcon</body><body package="UIPainter">keystrokeInfoTooltip	self currentItemHasKeystrokeConflict		ifTrue: [^#KeystrokeCommandConflict &lt;&lt; #labels &gt;&gt; 'Menu Item shortcut is invalid when using a Command'].	^nil</body><body package="UIPainter">messageInfoTooltip	^self currentItemHasCommand 		ifTrue: [#LabelFromCommand &lt;&lt; #labels &gt;&gt; 'Menu label is defined by the Command']		ifFalse: [nil]</body><body package="UIPainter">noIcon	^'' asVisualPart</body><body package="UIPainter">protectedIcon	^ToolListIcons protectedShield</body><body package="UIPainter">removeDuplicateLabelOverrides	menuList list do: [:each |		| item |		(item := each key) = self lineToken ifFalse: [			(item definesCommand and: [(self itemHasSameLabelSource: item)]) ifTrue: [self defaultStringFor: item put: '']]].</body><body package="UIPainter">resolveKeystrokeConflicts	"Resolve keystroke conflicts by removing the keystroke defined in the MenuItem."	menuList list do: [:each |		| item |		(item := each key) = self lineToken ifFalse: [			(self itemHasKeystrokeConflict: item) ifTrue: [self shortcutKeyFor: item put: '']]].	(self widgetAt: #menuList) invalidate</body><body package="UIPainter">resolveLabelConflicts	"Resolve label conflicts by removing the label defined in the MenuItem."	menuList list do: [:each |		| item |		(item := each key) = self lineToken ifFalse: [			(self itemHasLabelConflict: item) ifTrue: [self defaultStringFor: item put: '']]].</body><body package="UIPainter">stringInfoIcon	^self currentItemHasLabelConflict		ifTrue: [self errorIcon]		ifFalse: [self infoIcon]</body><body package="UIPainter">stringInfoTooltip	^self currentItemHasLabelConflict		ifTrue: [#LabelCommandConflict &lt;&lt; #labels &gt;&gt; 'Menu Label conflicts with label defined by Command.']		ifFalse: [self messageInfoTooltip]</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>updating</category><body package="UIPainter">updateConflictInfo	self updateLabelEnablement.	self updateKeystrokeEnablement.	self updateInfoIcons.	self fixupTabBar</body><body package="UIPainter">updateInfoIcons	(self widgetAt: #iString) ifNotNil: [:w | w visual: self stringInfoIcon].	#(#iKey #iCatalog) do: [:id |		(self widgetAt: id) ifNotNil: [:w | w visual: self infoIcon]].	(self widgetAt: #iCommand) ifNotNil: [:w | w visual: self commandInfoIcon].	(self widgetAt: #iKeystroke) ifNotNil: [:w | w visual: self keystrokeInfoIcon].</body><body package="UIPainter">updateKeystrokeEnablement	| enablement |	enablement := self currentItemHasCommand not or: [self currentItemHasKeystroke].	#(#hasCtrl #hasAlt #hasShift) do: [:id |		(self widgetAt: id) ifNotNil: [:w | w isEnabled: enablement]].	(self widgetAt: #shortCutChar) ifNotNil: [:w | w editor isEnabled: enablement]</body><body package="UIPainter">updateLabelEnablement	#(#labelDefaultString #labelKey #catalogID) do: [:id |		(self widgetAt: id) ifNotNil: [:w | w isEnabled: (self currentItemHasCommand not or: [self currentItemHasLabelOverride])]]</body><body package="UIPainter">updateProperties	| visible widget wasVisible selection |	selection := menuList selections asArray.	visible := self selectionCanHaveSubmenus and: [selection size = 1].	visible		ifTrue: [currentItem value: selection first key]		ifFalse: [currentItem value: (MenuItem labeled: '')].	widget := builder componentAt: #menuItemProperties.	widget isNil		ifFalse: 			[wasVisible := widget isEnabled.			wasVisible = visible ifFalse: [widget isEnabled: visible]].	widget := builder componentAt: #propertyCanvas.	widget isNil		ifFalse: 			[wasVisible := widget isEnabled.			wasVisible = visible ifFalse: [widget isEnabled: visible]].	self updateConflictInfo.	self fixupToolBar.	self disableItemMovement</body></methods><methods><class-id>Tools.MenuEditor</class-id> <category>testing-commands</category><body package="UIPainter">anyKeystrokeConflict	menuList list do: [:each |		| item |		(item := each key) = self lineToken ifFalse: [(self itemHasKeystrokeConflict: item) ifTrue: [^true]]].	^false</body><body package="UIPainter">anyLabelConflict	menuList list do: [:each |		| item |		(item := each key) = self lineToken ifFalse: [(self itemHasLabelConflict: item) ifTrue: [^true]]].	^false</body><body package="UIPainter">checkCommandConflicts	(self anyLabelConflict or: [self anyKeystrokeConflict])		ifTrue: [			^(Dialog confirm: (#CommandConflictWarning &lt;&lt; #UIPainter &gt;&gt; 'This menu contains items having either label or keystroke conflicts with the specified Command.&lt;n&gt;Proceeding will remove any conflicting keystroke definitions from your menu specification&lt;n&gt;but cannot automatically resolve label conflicts.&lt;n&gt;OK to proceed?') expandMacros)			ifTrue: [ true ]			ifFalse: [ false ] ].	^true</body><body package="UIPainter">checkExistingCommand: aSymbolOrNil	"A nil commandID is always acceptable."	aSymbolOrNil == nil ifTrue: [^true].	(CommandRegistry instance commandsById at: aSymbolOrNil ifAbsent: [nil]) == nil		ifTrue: [			Dialog warn: (#CommandNotFound &lt;&lt; #UIPainter 				&gt;&gt; 'No Command found for &lt;1p&gt;.&lt;n&gt;Please create the command first.'				expandMacrosWith: aSymbolOrNil).			self updateProperties.			^false].	^true</body><body package="UIPainter">currentItemHasCommand	^currentItem value definesCommand</body><body package="UIPainter">currentItemHasKeystroke	^currentItem value definesKeystroke</body><body package="UIPainter">currentItemHasKeystrokeConflict	^self itemHasKeystrokeConflict: currentItem value</body><body package="UIPainter">currentItemHasLabelConflict	^self itemHasLabelConflict: currentItem value</body><body package="UIPainter">currentItemHasLabelOverride	^currentItem value hasLabelOverride</body><body package="UIPainter">currentItemIsRBCommand	| key |	key := currentItem value nameKey.	^((currentItem value value == #action:) and: [ key notNil ]) 		and: [ (Refactory.Browser.RBCommand actions at: key asString ifAbsent: [ nil ]) notNil ].</body><body package="UIPainter">itemHasKeystrokeConflict: item	"A keystroke conflict exists if the MenuItem defines a shortcut key as well as a command."	item definesCommand ifFalse: [^false].	^item definesKeystroke</body><body package="UIPainter">itemHasLabelConflict: item	"A label conflict exists if the MenuItem defines a label with a UserMessage that uses the same key/catalogID as the label defined in the item's registered command, but the default label string does not match."	| labelSource command sameSource |	item definesCommand ifFalse: [^false].	item definesLabel ifFalse: [^false].	(labelSource := item labelSource) isString ifTrue: [^false].	command := CommandRegistry instance commandsById at: (self commandIDFor: item).	sameSource := [(labelSource key = command label key) and: [labelSource catalogID = command label catalogID]]		on: Error do: [:ex2 | ex2 return false].	sameSource ifFalse: [^false].	^[command label defaultString ~= item rawLabel defaultString] 		on: Error do: [:ex1 | ex1 return false].</body><body package="UIPainter">itemHasSameLabelSource: item	| labelSource command |	labelSource := item labelSource.	command := CommandRegistry instance commandsById at: (self commandIDFor: item).	^[labelSource = command label]		on: Error do: [:ex | ex return false].</body></methods><methods><class-id>Tools.MenuEditor class</class-id> <category>computed resources</category><body package="UIPainter">addBelowImage	^self eraseBackground: #CaddBelowImage</body><body package="UIPainter">addChildImage	^self eraseBackground: #CaddChildImage</body><body package="UIPainter">addLineImage	^self eraseBackground: #CaddLineImage</body><body package="UIPainter">applyImage	^self eraseBackground: #CapplyImage</body><body package="UIPainter">downArrowImage	^self eraseBackground: #CdownArrowImage</body><body package="UIPainter">eraseBackground: anImageName	| src pix im im2 anImage  |	anImage := self perform: anImageName.	im := Masks at: anImageName ifAbsent: [nil].	im == nil		ifTrue:			[src := anImage asImage.			pix := src atPoint: 0@0.			im := Image extent: src extent depth: 1 palette: CoveragePalette monoMaskPalette.			0 to: src width-1 do: [:x |				0 to: src height-1 do: [:y |					(src atPoint: x@y) = pix						ifFalse: [im atPoint: x@y put: 1]]].			im2 := im filledShapeAround: 0@0.			im copy: im bounds from: 0@0 in: im2 rule: 9.			im := CachedImage on: im.			Masks at: anImageName put: im].	InactiveMasks at: anImageName	ifAbsent: 			[InactiveMasks at: anImageName					put: (Masks at: anImageName)].	^OpaqueImageWithEnablement figure: anImage shape: im 				inactiveMask: (InactiveMasks at: anImageName).</body><body package="UIPainter">leftArrowImage	^self eraseBackground: #CleftArrowImage</body><body package="UIPainter">readImage	^self eraseBackground: #CreadImage</body><body package="UIPainter">rightArrowImage	^self eraseBackground: #CrightArrowImage</body><body package="UIPainter">upArrowImage	^self eraseBackground: #CupArrowImage</body></methods><methods><class-id>Tools.MenuEditor class</class-id> <category>class initialization</category><body package="UIPainter">initialize	"MenuEditor initialize"	Masks := IdentityDictionary new.	InactiveMasks := IdentityDictionary new.	PasteBuffer := nil.</body></methods><methods><class-id>Tools.MenuEditor class</class-id> <category>interface specs</category><body package="UIPainter">interfaceSpecFor: aSymbol	| spec |	spec := super interfaceSpecFor: aSymbol.	aSymbol == #windowSpec		ifTrue: [spec window toolBar: #toolBar].	^spec</body></methods><methods><class-id>Tools.OrientationResizeModeTracker</class-id> <category>drag drop</category><body package="UIPainter">dragOverWidgets: aDragDropContext	| currentPoint targetBounds controllerGrid |	(currentPoint := controller sensor mousePoint) = lastShowPoint ifTrue: [^self].	controllerGrid := controller gridValue.	controller isFenced ifTrue: 		[currentPoint := self 			containedPointFor: currentPoint 			in: controller view bounds].	self adjust: currentPoint toGrid: controllerGrid.	currentPoint = lastShowPoint ifTrue: [^self].	targetBounds := self stretchRectangle: originalBounds from: lastShowPoint to: currentPoint.	(horizontal xor: (targetBounds width &lt;= targetBounds height) not) ifTrue: 			[(horizontal := horizontal not)				ifTrue: 					[dragObject subject axis: Axis.Horizontal.					dragObject wrapper spec orientation: #horizontal]				ifFalse: 					[dragObject subject axis: Axis.Vertical.					dragObject wrapper spec orientation: #vertical]].	controller view		newBounds: targetBounds		oldBounds: originalBounds		forWrapper: dragObject wrapper.	originalBounds := targetBounds.	lastShowPoint := currentPoint</body><body package="UIPainter">preDragDrop	lastShowPoint := dragObject getOrigin.	originalBounds := dragObject wrapper bounds.	horizontal := originalBounds width &gt; originalBounds height</body></methods><methods><class-id>Tools.SelectModeTracker</class-id> <category>events</category><body package="UIPainter">dragOverWidgets: aDragDropContext	"Default, do nothing"</body><body package="UIPainter">mouseMovedEvent: aMouseMovedEvent	"The mouse was dragged in with button down. Need to do setUp 	before tracking mouse movement."	controller sensor redButtonPressed ifFalse: [^self].	^super mouseMovedEvent: aMouseMovedEvent</body><body package="UIPainter">redButtonPressedEvent: anEvent	dragging := false.	self doSimpleSelectionFor: anEvent.	^nil</body><body package="UIPainter">windowEnterEvent: anEvent	dragging := false.</body></methods><methods><class-id>Tools.SelectModeTracker</class-id> <category>selecting</category><body package="UIPainter">deepHitDetectIn: aVisualElement at: aPoint	| widget deepElement |	widget := aVisualElement widget.	widget isComposite ifFalse: [^aVisualElement].	deepElement := widget hitDetect: (widget globalPointToLocal: aPoint).	deepElement isNil ifTrue: [^aVisualElement].	(deepElement isKindOf: WidgetWrapper) ifFalse: [^aVisualElement].	^self deepHitDetectIn: deepElement at: aPoint</body><body package="UIPainter">deselectComponent: selection	"The visual component selection is to be removed from the current	selection(s) in the controller."	controller broadcastPendingSelectionChange.	controller removeSelection: selection</body><body package="UIPainter">doSelectionTrackingOperationAt: aPoint	"We initiate any dragging. 	If we're not on a widget, we draw the selection rectangle.	If we are on a widget, we invoke the appropriate widget and/or handle dragger"	| hitObject |	hitObject := controller view hitDetect: aPoint.	dragging isNil ifTrue: [dragging := false].	hitObject isNil ifTrue: 		[(dragging not and: [controller sensor shiftDown not])			ifTrue: [self removeSelections].		dragging ifFalse: 			[dragging := true.			^self displayRectangleStartingAt: aPoint]].	self selectIfNotSelected: hitObject at: aPoint.	dragging ifFalse: 		[dragging := true.		(controller dragModeFor: hitObject)			dragObject: hitObject			startingAt: aPoint			inController: controller]</body><body package="UIPainter">doSimpleSelectionFor: anEvent 	| hitObject |	hitObject := controller view 				hitDetect: (controller view globalPointToLocal: anEvent point).	hitObject isNil 		ifTrue: 			[anEvent shiftDown not ifTrue: [self removeSelections].			^self]		ifFalse: 			[(self processedDataSetViewSelection: hitObject from: anEvent) 				ifTrue: [^self]].	anEvent altDown 		ifTrue: [hitObject := self deepHitDetectIn: hitObject at: anEvent point].	self selectIfNotSelected: hitObject		at: (controller view globalPointToLocal: anEvent point)</body><body package="UIPainter">doesControllerHaveDataSetView	^controller primarySelection notNil and: [controller primarySelection widget isKindOf: self referenceToPaintedDataSetViewClass]</body><body package="UIPainter">extendSelection: selections	"Add the component(s) in selections to the current selection(s). This 	method assumes that objects is non-nil."	controller broadcastPendingSelectionChange.	controller appendSelections: selections.	^false</body><body package="UIPainter">processedDataSetViewSelection: aWidget from: anEvent 	"If we are not selecting data set itself, or we are selecting it's handles, we don't do 	much. If we did select on the handles, make sure that it's no longer in edit mode before passing off to possible to drag mode"	| editor targetWidget result |	targetWidget := aWidget.	result := false.	(self shouldUseDeepHitDetectOn: aWidget event: anEvent) 		ifTrue: [targetWidget := self deepHitDetectIn: aWidget at: anEvent point].	((targetWidget isKindOf: SpecWrapper) 		and: [targetWidget widget isKindOf: self referenceToPaintedDataSetViewClass]) 			ifFalse: 				[self doesControllerHaveDataSetView 					ifTrue: [self setPrimarySelectionToNoSelectionIndexAndNoEdit].				^result].	(self doesControllerHaveDataSetView and: 			[(anEvent ctrlDown or: [anEvent altDown]) 				and: [targetWidget widget editMode not]]) 		ifTrue: 			[result := true.			targetWidget widget editMode: true].	targetWidget widget editMode 		ifTrue: 			[editor := DataSetEditTracker dataSetOn: controller with: anEvent.			controller currentMode setValue: editor].	^result</body><body package="UIPainter">referenceToPaintedDataSetViewClass	^#{PaintedDataSetView} valueOrDo: []</body><body package="UIPainter">removeSelections	"Deselect all current selections. This involves removing all the 	handles from the picture and updating the selection and handle	state information."	controller broadcastPendingSelectionChange.	controller removeSelections.	controller notifySelectionChange.	^false</body><body package="UIPainter">selectComponent: selection	"The visual component selection is to be made the current selection. 	If there is anything else that is currently selected, then it is to be 	deselected. In addition, an appropriate set of selection handles are 	created and added to the picture. These handles are visual 	components themselves, and are added to the picture last, hence 	given the illusion that they float on a plane by themselves."	selection == nil ifTrue: [^self removeSelections].	controller broadcastPendingSelectionChange.	controller select: selection</body><body package="UIPainter">selectIfNotSelected: obj at: startPt	"The visual component obj HAS been clicked on by the user. 	Determine if it is a valid selection and, if so, incorporate it into	the current selection. "	| selections |	selections := controller selections.	selections == nil 		ifFalse:			[((selections includes: obj) or: [controller handles includes: obj])				ifTrue:					[controller sensor shiftDown						ifTrue: [self deselectComponent: obj]						ifFalse: [controller becomeLastControllerWithSelection]]				ifFalse:					[controller sensor shiftDown						ifTrue: [self extendSelection: (Array with: obj)]						ifFalse: [self selectComponent: obj]]]		ifTrue: [self selectComponent: obj].	controller notifySelectionChange.</body><body package="UIPainter">setPrimarySelectionToNoSelectionIndexAndNoEdit	(controller primarySelection widget)		selectionIndex: 0;		editMode: false</body><body package="UIPainter">shouldUseDeepHitDetectOn: aWidget event: anEvent 	^(aWidget isKindOf: SpecWrapper) 		and: [(aWidget widget isKindOf: CompositePart) and: [(self deepHitDetectIn: aWidget at: anEvent point) widget isKindOf: self referenceToPaintedDataSetViewClass]]</body></methods><methods><class-id>Tools.SelectModeTracker</class-id> <category>rectangle drag</category><body package="UIPainter">displayRectangleStartingAt: aPoint	| globalCurrentPoint globalStartingPoint drawnRectangle startPointLocalSpace 	view selections handles globalOrigin |	view := controller view.	globalOrigin := controller sensor window globalOrigin.	globalStartingPoint := (view localPointToGlobal: aPoint) + globalOrigin.	globalCurrentPoint := (view localPointToGlobal: controller sensor cursorPoint) + globalOrigin.	drawnRectangle := self resizeRectangle: (Rectangle vertex: globalStartingPoint vertex: globalCurrentPoint).	startPointLocalSpace :=  view globalPointToLocal: (drawnRectangle origin - globalOrigin).	drawnRectangle := startPointLocalSpace extent: drawnRectangle extent.	controller broadcastPendingSelectionChange.	selections := view components select: [:comp | drawnRectangle contains: comp bounds].	handles := controller handles.	handles == nil ifFalse: [selections := selections select: [:comp | (handles includes: comp) not]].	selections isEmpty ifTrue: [^self removeSelections].	(controller sensor shiftDown and: [controller selections notNil])		ifTrue: [^self extendSelection: selections].	controller selectionList: selections.</body><body package="UIPainter">resizeRectangle: aRectangle 	^Screen default		resizeRectangle: aRectangle		minimumExtent: 1 @ 1		resizeIncrement: 1 @ 1		boundedBy: nil		whileButton: 0		isDown: true</body></methods><methods><class-id>Tools.SelectModeTracker</class-id> <category>accessing</category><body package="UIPainter">specClass	^nil</body></methods><methods><class-id>Tools.SpecModel</class-id> <category>private</category><body package="UIPainter">notifyParent	"Notify parent that some of my aspect has changed."	| parent |	(parent := builder aspectAt: #parentModel) notNil ifTrue: [parent displayButtonsForModifiedState]</body></methods><methods><class-id>Tools.SpecModel</class-id> <category>testing</category><body package="UIPainter">shouldOpenDialogOnUnacceptedChange	^true</body><body package="UIPainter">usesConservativeReload	^false</body></methods><methods><class-id>Tools.SpecModel</class-id> <category>accessing</category><body package="UIPainter">specChannel: aValue 	specChannel := aValue.</body></methods><methods><class-id>Tools.SpecModel</class-id> <category>actions</category><body package="UIPainter">postapply	"Default, do nothing. Let specific subclassed do something if needed."</body><body package="UIPainter">postcancel	"Do any post cancellation actions."</body><body package="UIPainter">preapply	"In general, no-op"</body><body package="UIPainter">precancel	"Do any canceling on the model level, and answer if this 	is sufficient cancelation (otherwise model is recreated)."	^false</body><body package="UIPainter">quietlyReloadSelectionInformation	"Default do nothing"</body></methods><methods><class-id>Tools.SpecModel</class-id> <category>resources</category><body package="UIPainter">fieldMenu	^builder window model fieldMenu asValue</body></methods><methods><class-id>Tools.SpecModel class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	inst specChannel: aChannel</body></methods><methods><class-id>Tools.IntegratedSpecModel</class-id> <category>component visibility</category><body package="UIPainter">able: aBoolean components: idList	idList do:		[:id |		aBoolean			ifTrue: [(builder componentAt: id) enable]			ifFalse: [(builder componentAt: id) disable]]</body><body package="UIPainter">disableGroup: idList	self able: false components: idList</body><body package="UIPainter">disableRead	(builder componentAt:#readButton) disable</body><body package="UIPainter">enableGroup: idList	self able: true components: idList</body><body package="UIPainter">enableRead	(builder componentAt: #readButton) enable</body><body package="UIPainter">reappearGroup: idList	self visible: true components: idList</body><body package="UIPainter">vanishGroup: idList	self visible: false components: idList</body><body package="UIPainter">visible: aBoolean components: idList	idList do:		[:id |		aBoolean			ifTrue: [(builder componentAt: id) beVisible]			ifFalse: [(builder componentAt: id) beInvisible]]</body></methods><methods><class-id>Tools.IntegratedSpecModel</class-id> <category>private</category><body package="UIPainter">changedReadMode: oldValue 	oldValue = readMode value ifTrue: [^self].	readMode value		ifTrue: 			[self interruptedRead: false.			propertiesTool selectionKind == #multi 				ifFalse: [self reloadSelectionInformation]]		ifFalse: ["self enableApply"]</body><body package="UIPainter">disableApply	propertiesTool showUnmodifiedState</body><body package="UIPainter">enableApply	readMode value		ifTrue: [propertiesTool showModifiedState]		ifFalse: [propertiesTool showModifiedStateWithNavigationEnabled]</body><body package="UIPainter">interruptedRead	^interruptedRead</body><body package="UIPainter">interruptedRead: aBoolean	interruptedRead := aBoolean</body><body package="UIPainter">readMode	^readMode</body></methods><methods><class-id>Tools.IntegratedSpecModel</class-id> <category>initialize-release</category><body package="UIPainter">initialize	super initialize.	readMode := true asValue.	interruptedRead := false.	readMode onChangeSend: #changedReadMode: to: self.</body><body package="UIPainter">propertiesTool: aTool	propertiesTool := aTool</body><body package="UIPainter">specChannel: aChannel	super specChannel: aChannel.	"aChannel addDependent: somethingChanged"</body></methods><methods><class-id>Tools.IntegratedSpecModel</class-id> <category>interface opening</category><body package="UIPainter">preBuildWith: aBuilder	aBuilder		aspectAt: #readMode		put: self readMode</body></methods><methods><class-id>Tools.IntegratedSpecModel</class-id> <category>actions</category><body package="UIPainter">precancel	"Do any canceling on the model level, and answer if this 	is sufficient cancelation (otherwise model is recreated)."	self reloadSelectionInformation.	^true</body></methods><methods><class-id>Tools.IntegratedSpecModel</class-id> <category>testing</category><body package="UIPainter">shouldOpenDialogOnUnacceptedChange	^readMode value or: [interruptedRead value]</body></methods><methods><class-id>Tools.IntegratedSpecModel class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel.	inst propertiesTool: (env at: #propertiesTool).</body></methods><methods><class-id>Tools.PaintedDataSetView</class-id> <category>private</category><body package="UIPainter">bottom	^self bounds bottom.</body><body package="UIPainter">confirmColumnSize	| specWrapper ranges index |	selectionIndex == 0 ifTrue: [^self].	specWrapper := container.	index := selectionIndex.	[specWrapper container notNil and: [(specWrapper isKindOf: SpecWrapper) not]]		whileTrue: [specWrapper := specWrapper container].	(specWrapper spec columns at: selectionIndex)		width: (ranges := self xRangesFor: selectionIndex) last - ranges first.	selectionIndex - 1 = 0 ifFalse: 		[(specWrapper spec columns at: selectionIndex - 1)			width: (ranges := self xRangesFor: selectionIndex - 1) last - ranges first].	(selectionIndex + 1) &gt; specWrapper spec columns size ifFalse:		[(specWrapper spec columns at: selectionIndex + 1)			width: (ranges := self xRangesFor: selectionIndex + 1) last - ranges first].	specWrapper container controller select: specWrapper.		self scrollTo: scrollOffset value.	self selectionIndex: index.	self editMode: true</body><body package="UIPainter">displayBackgroundIfNeededOn: aGraphicsContext in: aRectangle 	(state isOpaque or: [state hasBackgroundColor])		ifTrue: [self displayBackgroundOn: aGraphicsContext in: aRectangle].	self paintSelectedColumnOn: aGraphicsContext</body><body package="UIPainter">displayDragHandleOn: gc	| handleRect tGc tColor |	tGc := gc copy.	handleRect := self dragHandleBounds.	handleRect extent y = 0 ifTrue: [ ^self ].	tColor := tGc paintPreferencesMatchAt: SymbolicPaint selectionForeground.	tGc paintPreferencesMatchAt: SymbolicPaint selectionBackground put: tColor.	tGc displayRectangle: self dragHandleBounds</body><body package="UIPainter">dragHandleBounds	| cellBounds handleOrigin |	(selectionIndex == 0 or: [ (columnDescriptors at: selectionIndex) rendererSpec == #rowSelector ]) ifTrue: [^0 @ 0 extent: 0 @ 0].	cellBounds := self boundsOfCellIndex: selectionIndex @ 1 inBounds: self bounds.	handleOrigin := cellBounds origin + (cellBounds extent // 2).	^(handleOrigin - 3) extent: (6@6)</body><body package="UIPainter">dropEdit</body><body package="UIPainter">editCell	^selectionIndex @ nil</body><body package="UIPainter">invalidateColumn: anInteger 	| ci |	ci := self xRangesFor: anInteger inBounds: self bounds.	self invalidateRectangle: (ci first @ self bounds top corner: ci last @ self bounds bottom )</body><body package="UIPainter">paintSelectedColumnOn: graphicsContext 	| ci gc first tf |	gc := graphicsContext copy.	gc paint: self selectionBackgroundColor.	ci := self xRangesFor: selectionIndex inBounds: self bounds.	(selectionIndex &gt; (numFrozen max: 2) and: [ ci first &lt; (tf := (self xRangesFor: numFrozen inBounds: self bounds) last) ])		ifTrue: [ first := tf ]		ifFalse: [ first := ci first ].	gc displayRectangle: (first @ self bounds top corner: ci last @ self bounds bottom).	self displayDragHandleOn: (gc clippingRectangle: ((first @ self bounds top corner: ci last @ self bounds bottom) intersect: self bounds))</body><body package="UIPainter">persistentInformation	"When this is asked for, the assumption is made that this instance is about to be replaced so It should release it's dependencies now"	| array |	self selectionChannel removeDependent: self.	array := Array new: 5.	array at: 1 put: (self selectionChannel);		at: 2 put: (self editMode);		at: 3 put: selectionIndex;		at:4 put: scrollOffset value;		at: 5 put: controller.	^array</body><body package="UIPainter">persistentInformation: anArray	controller release.	self controller: (anArray at: 5).	self selectionChannel: (anArray at: 1).	columnDescriptors size == 0 		ifTrue: [ ^self editMode: false ].	editMode := anArray at: 2.	self setSelectionIndex: ((anArray at: 3) min: columnDescriptors size).	self positionTo: (anArray at: 4).</body><body package="UIPainter">selectionIndex: anInteger 	| ci |	((self isSelected: anInteger) or:	[columnDescriptors isEmpty]) ifTrue: [^self].   	ci := self xRangesFor: selectionIndex inBounds: self bounds.	self invalidateRectangle: (ci first @ self bounds top corner: ci last @ self bounds bottom ).	selectionChannel value: (selectionIndex := anInteger).	ci := self xRangesFor: anInteger inBounds: self bounds.	self invalidateRectangle: (ci first @ self bounds top corner: ci last @ self bounds bottom )</body><body package="UIPainter">setSelectionIndex: anInteger 	| ci |	(self isSelected: anInteger) ifTrue: [ ^self ].	ci := self xRangesFor: selectionIndex inBounds: self bounds.	self invalidateRectangle: (ci first @ self bounds top corner: ci last @ self bounds bottom ).	selectionChannel setValue: (selectionIndex := anInteger).	ci := self xRangesFor: anInteger inBounds: self bounds.	self invalidateRectangle: (ci first @ self bounds top corner: ci last @ self bounds bottom )</body><body package="UIPainter">switchColumnIndex: col1 withIndex: col2 	| tCol specWrapper |	tCol := columnDescriptors at: col1.	columnDescriptors at: col1 put: (columnDescriptors at: col2).	columnDescriptors at: col2 put: tCol.	self setColumnDescriptors: columnDescriptors.	specWrapper := container.	[specWrapper container notNil and: [(specWrapper isKindOf: SpecWrapper) not]]		whileTrue: [specWrapper := specWrapper container].	tCol := specWrapper spec columns at: col1.	specWrapper spec columns at: col1 put: (specWrapper spec columns at: col2).	specWrapper spec columns at: col2 put: tCol</body></methods><methods><class-id>Tools.PaintedDataSetView</class-id> <category>controller accessing</category><body package="UIPainter">defaultControllerClass	^PaintedDataSetController</body></methods><methods><class-id>Tools.PaintedDataSetView</class-id> <category>accessing</category><body package="UIPainter">editMode	editMode isNil ifTrue: [ editMode := false ].	^ editMode and: [ columnDescriptors size &gt; 0 ]</body><body package="UIPainter">editMode: aBoolean	aBoolean ifFalse: [ self setSelectionIndex: 0 ].	^editMode := aBoolean</body></methods><methods><class-id>Tools.PaintedDataSetView</class-id> <category>bounds accessing</category><body package="UIPainter">fullBounds	"Answer the bounds that include any scrollbars"	^0 @ 0 extent: self container container container container bounds extent</body><body package="UIPainter">preferredExtent	"Answer the preferred bounds of the receiver."	sequence == nil ifTrue: [ ^Point zero ].	^self right @ (self lineGrid + self topOffsetForDisplay)</body></methods><methods><class-id>Tools.DataSetSpecColumnDetailsModel</class-id> <category>private</category><body package="UIPainter">changeTypeAlign	(currentColumn isNil or: [lock]) ifTrue: [^self].	currentColumn value alignment: (self typeAlign value == #system			ifTrue: [nil]			ifFalse: [ typeAlign value]).	changedBlock value: nil</body><body package="UIPainter">changeTypeFont	(currentColumn isNil or: [lock]) ifTrue: [^self].	currentColumn value font: (self typeFont value == #system			ifTrue: [nil]			ifFalse: [ typeFont value]).	changedBlock value: nil</body><body package="UIPainter">changeTypePopup	(currentColumn isNil or: [ lock ]) ifTrue: [ ^self ].	currentColumn value popUpStyle: self typePopup value.	changedBlock value: nil.</body><body package="UIPainter">changedDataType	(currentColumn isNil or: [ lock ]) ifTrue: [ ^self ].	currentColumn value type: (self typeDataType value == #string			ifTrue: [nil]			ifFalse: [typeDataType value]).	self checkFormatString.	changedBlock value: nil.</body><body package="UIPainter">changedFormatString	(currentColumn isNil or: [ lock ]) ifTrue: [ ^self ].	currentColumn value formatString: self formatString value.	changedBlock value: nil.</body><body package="UIPainter">changedPrintSelector	(currentColumn isNil or: [ lock ]) ifTrue: [ ^self ].	currentColumn value printSelector: (self printSelector value).	self checkFormatString.	changedBlock value: nil.</body><body package="UIPainter">changedReadSelector	(currentColumn isNil or: [ lock ]) ifTrue: [ ^self ].	currentColumn value readSelector: (self readSelector value).	self checkFormatString.	changedBlock value: nil.</body><body package="UIPainter">changedSelection	propertiesTool completeWorkOnPreviousSelection.	lock := true.	selectionChannel value == 0		ifTrue: 			[self currentColumn value: DataSetColumnSpec new.			self columnType value: currentColumn value editorType.			self updateOptions.			(self builder componentAt: #fields) disable]		ifFalse: 			[(self builder componentAt: #fields) isEnabled 				ifFalse: [(self builder componentAt: #fields) enable].			self currentColumn value: (specChannel value columns at: selectionChannel value).			self formatString value: currentColumn value formatString.			self typeDataType value: (currentColumn value type isNil					ifTrue: [#string]					ifFalse: [currentColumn value type]).			self columnType value: currentColumn value editorType.			self typeFont value: (currentColumn value font isNil					ifTrue: [#system]					ifFalse: [currentColumn value font]).			self typeAlign value: (currentColumn value alignment isNil					ifTrue: [#left]					ifFalse: [currentColumn value alignment]).			self typePopup value: currentColumn value popUpStyle.			self readSelector value: currentColumn value readSelector.			self printSelector value: currentColumn value printSelector.			self updateOptions].	lock := false</body><body package="UIPainter">checkFormatString	| action |	action := #disable.	typeDataType value == #number 		ifTrue: [self defaultFormats value: InputFieldSpec defaultNumberFormats.				action := #enable.].	(typeDataType value == #string or: [ typeDataType value isNil ])		ifTrue: [self defaultFormats value: InputFieldSpec defaultStringFormats.				action := #enable].	typeDataType value == #date 		ifTrue: [self defaultFormats value: InputFieldSpec defaultDateFormats.				action := #enable].	typeDataType value == #fixedpoint 		ifTrue: [self defaultFormats value: InputFieldSpec defaultNumberFormats.				action := #enable].	typeDataType value == #timestamp 		ifTrue: [self defaultFormats value: InputFieldSpec defaultTimeStampFormats.				action := #enable].	typeDataType value == #time 		ifTrue: [self defaultFormats value: InputFieldSpec defaultTimeFormats.				action := #enable].	(self builder isNil or: [ (self builder componentAt: #fields) isEnabled not ]) ifTrue: [ ^self ].	self columnType value == #ComboBox		ifTrue: [ |selAction|				(self builder componentAt: #ComboBoxFormatEditor) perform: action.				(self builder componentAt: #ComboBoxFormatLabel) perform: action.				typeDataType value == #object 					ifTrue: [selAction := #enable]					ifFalse: [selAction := #disable].				 (self builder componentAt: #ComboBoxReadSelectorLabel) perform: selAction.				 (self builder componentAt: #ComboBoxPrintSelectorLabel) perform: selAction.				 (self builder componentAt: #ComboBoxPrintSelector) perform: selAction.				 (self builder componentAt: #ComboBoxReadSelector) perform: selAction].	self columnType value == #InputField		ifTrue: [ (self builder componentAt: #InputFormatEditor) perform: action.				(self builder componentAt: #InputFormatLabel) perform: action].	self columnType value == #None		ifTrue: [ (self builder componentAt: #NoneFormatEditor) perform: action.				(self builder componentAt: #NoneFormatLabel) perform: action].		action == #disable ifTrue: [ self formatString value: String new ].</body><body package="UIPainter">compute: aBlock	changedBlock := aBlock</body><body package="UIPainter">postBuildWith: aBuilder	self initSelectionChannel.	self changedSelection.	specChannel notNil ifTrue: [ specChannel addDependent: self ].	self updateOptions.</body><body package="UIPainter">setColumnTypeLabel	| type |	type := self columnType value.	type notNil ifTrue: [(self builder componentAt: #label)			labelString: ((#DatasetColumn1s &lt;&lt; #UIPainter &gt;&gt; 'Dataset Column (&lt;1s&gt;)')			expandMacrosWith: (type == #None					ifTrue: [(#ReadOnly &lt;&lt; #UIPainter &gt;&gt; 'Read Only')]					ifFalse: [type asString]))]</body><body package="UIPainter">updateOptions	| type invisibleSet |	type := self columnType value.	invisibleSet := #(#None #InputField #ComboBox #CheckBox #rowSelector) asOrderedCollection.	invisibleSet remove: type ifAbsent: [type := nil].	invisibleSet do: [:i | (self builder componentAt: i) beInvisible].	type notNil ifTrue: [(self builder componentAt: type) beVisible].	self checkFormatString.	self setColumnTypeLabel</body></methods><methods><class-id>Tools.DataSetSpecColumnDetailsModel</class-id> <category>aspects</category><body package="UIPainter">columnType	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^columnType isNil ifTrue: [columnType := #InputField asValue] ifFalse: [columnType]</body><body package="UIPainter">currentColumn	^currentColumn isNil ifTrue: [ currentColumn := DataSetColumnSpec new beDefault asValue ] ifFalse: [ currentColumn ]</body><body package="UIPainter">defaultFormats	^defaultFormats isNil		ifTrue: [defaultFormats := List new asValue]		ifFalse: [defaultFormats]</body><body package="UIPainter">formatString	^typeDataFormat isNil ifTrue: [typeDataFormat := nil asValue] ifFalse: [typeDataFormat]</body><body package="UIPainter">modelGen	^modelGen isNil		ifTrue: [modelGen := String new asValue]		ifFalse: [modelGen]</body><body package="UIPainter">printSelector	printSelector isNil ifTrue: [printSelector :=nil asValue].	^printSelector</body><body package="UIPainter">readSelector	readSelector isNil ifTrue: [readSelector :=nil asValue].	^readSelector</body><body package="UIPainter">typeAlign	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^typeAlign isNil ifTrue: [typeAlign := #left asValue] ifFalse: [typeAlign]</body><body package="UIPainter">typeChoices	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^typeChoices isNil ifTrue: [typeChoices := (AspectAdaptor subjectChannel: self currentColumn sendsUpdates: false) forAspect: #choices ] ifFalse: [ typeChoices ]</body><body package="UIPainter">typeDataType	^typeDataType isNil ifTrue: [typeDataType := #string asValue] ifFalse: [typeDataType]</body><body package="UIPainter">typeFont	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^typeFont isNil ifTrue: [typeFont := #system asValue] ifFalse: [typeFont]</body><body package="UIPainter">typeMenu	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^typeMenu isNil ifTrue: [typeMenu := (AspectAdaptor subjectChannel: self currentColumn sendsUpdates: false) forAspect: #menu ] ifFalse: [ typeMenu ]</body><body package="UIPainter">typePopup	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^typePopup isNil ifTrue: [typePopup := false asValue] ifFalse: [typePopup]</body><body package="UIPainter">typeSize	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^typeSize isNil ifTrue: [typeSize := (AspectAdaptor subjectChannel: self currentColumn sendsUpdates: false) forAspect: #size ] ifFalse: [typeSize]</body></methods><methods><class-id>Tools.DataSetSpecColumnDetailsModel</class-id> <category>actions</category><body package="UIPainter">preapply	"trim the extra information"	| type fd fields | 	(type := self columnType value) isNil ifTrue: [ ^self ].	fd := self class fieldsDictionary.	fields := (fd at: #all) select: [ :field | ((fd at: type ifAbsent:[Array new]) includes: field value) not ].	fields do: [ :key | self currentColumn value perform: key with: nil ].</body><body package="UIPainter">precancel	^false</body></methods><methods><class-id>Tools.DataSetSpecColumnDetailsModel</class-id> <category>initialize-release</category><body package="UIPainter">initSelectionChannel	propertiesTool isNil ifTrue: [ ^self ].	selectionChannel := (propertiesTool selection at: 1) widget selectionChannel.	selectionChannel onChangeSend: #changedSelection to: self.</body><body package="UIPainter">initialize	super initialize.	changedBlock := [:v |].	self typeFont onChangeSend: #changeTypeFont to: self.	self typePopup onChangeSend: #changeTypePopup to: self.	self typeAlign onChangeSend: #changeTypeAlign to: self.	self typeDataType onChangeSend: #changedDataType to: self.	self formatString onChangeSend: #changedFormatString to: self.	self readSelector onChangeSend: #changedReadSelector to: self.	self printSelector onChangeSend: #changedPrintSelector to: self.	self checkFormatString.	lock := false.</body><body package="UIPainter">release	selectionChannel notNil 		ifTrue: [ 			selectionChannel retractInterestsFor: self].	specChannel notNil ifTrue: [ specChannel removeDependent: self ].</body></methods><methods><class-id>Tools.DataSetSpecColumnDetailsModel</class-id> <category>accessing</category><body package="UIPainter">specChannel: aValueHolder	"This is recieved when there is a new specModel being created "	self release. 	specChannel := aValueHolder.	self initSelectionChannel.</body></methods><methods><class-id>Tools.DataSetSpecColumnDetailsModel class</class-id> <category>resources</category><body package="UIPainter">dataType	^InputFieldSpec typeMenu</body><body package="UIPainter">fieldsDictionary	| d | 	d := Dictionary new.	d at: #all put: #(menu: choices: size: font: alignment: type: popUpStyle: cellLabel: formatString:).	d at: #None put: #(font: alignment: type: formatString:).	d at: #InputField put: #(menu: size: font: type: alignment: formatString:).	d at: #ComboBox put: #(menu: choices: size: font: alignment: popUpStyle: formatString: type: readSelector: printSelector:).	d at: #CheckBox put: #().	^d</body><body package="UIPainter">fontMenu	^UISpecification fontMenu</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private</category><body package="UIPainter">addDependencyWritingAccessFor: instVarNames 	"For each instance variable, add in the message category accessing a 	message whose selector is the instance variable as a keyword with 	one argument, and whose method stores the argument as the new 	value of the instance variable. If there is already a message selector 	with the instance variable name as keyword, no replacement is 	made."	| class |	class := self targetClass.	instVarNames do: [:eachName | (class includesSelector: (eachName , ':') asSymbol)			ifFalse: 				[| aStream |				aStream := String new writeStream.				aStream nextPutAll: eachName.				aStream nextPutAll: ': aValue'.				aStream cr; cr; tab.				aStream nextPutAll: eachName.				aStream nextPutAll: ' := aValue.'.				aStream cr; tab.				aStream nextPutAll: 'self changed: #'.				aStream nextPutAll: eachName.				class compile: aStream contents classified: #accessing]]</body><body package="UIPainter">addReadingAccessFor: instVarNames 	"Build read accessing messages to the reciever's target class."	| class |	class := self targetClass.	instVarNames do: [:eachName | (class includesSelector: eachName asSymbol)			ifFalse: 				[| aStream |				aStream := String new writeStream.				aStream nextPutAll: eachName.				aStream cr; cr; tab.				aStream nextPut: $^.				aStream nextPutAll: eachName.				class compile: aStream contents classified: #accessing]]</body><body package="UIPainter">addWritingAccessFor: instVarNames 	"For each instance variable, add in the message category accessing a 	message whose selector is the instance variable as a keyword with 	one argument, and whose method stores the argument as the new 	value of the instance variable. If there is already a message selector 	with the instance variable name as keyword, no replacement is 	made."	| class |	class := self targetClass.	instVarNames do: [:eachName | (class includesSelector: (eachName , ':') asSymbol)			ifFalse: 				[| aStream |				aStream := String new writeStream.				aStream nextPutAll: eachName.				aStream nextPutAll: ': aValue'.				aStream cr; cr; tab.				aStream nextPutAll: eachName.				aStream nextPutAll: ' := aValue'.				class compile: aStream contents classified: #accessing]]</body><body package="UIPainter">alertForMissingProperties: incompletes among: selectionList withNumberRequired: numberNeeded for: aController 	"Return true if we are to continue with defining, false otherwise."	| choice |	incompletes isEmpty ifTrue: [^true].	selectionList size = 1		ifTrue:			[((selectionList first widget class == CompositePart)					and: [(selectionList first spec isKindOf: SubCanvasSpec) not])				ifTrue:					[Dialog warn: (#GenKey34 &lt;&lt; #UIPainter &gt;&gt; 'The selected composite has componentswhose properties don''t specify their models') for: aController view.					^ numberNeeded &gt; incompletes size].			Dialog warn: (#GenKey33 &lt;&lt; #UIPainter &gt;&gt; 'This component lacks properties needed for defining its model.') for: aController view.			^false]		ifFalse:			[((selectionList size &gt; incompletes size or:				[selectionList isEmpty]) and:					[numberNeeded &gt; incompletes size])				ifTrue:					[(choice :=						Dialog							choose:								(#GenKey32 &lt;&lt; #UIPainter &gt;&gt; 'Some components lack properties needed for defining models.Define models for the others, or select the ones that need editing?')							labels: (Array with: (#Define &lt;&lt; #UIPainter &gt;&gt; 'Define') with: (#Select_Cancel &lt;&lt; #UIPainter &gt;&gt; 'Select &amp; Cancel') with: (#Cancel &lt;&lt; #UIPainter &gt;&gt; 'Cancel'))							values: #(#define #select #cancel)							default: #define							for: aController view) == #define						ifTrue: [^true].					choice == #select						ifTrue:							[aController broadcastPendingSelectionChange.							aController								selectionList:									(self findSelectablesIn: aController havingSpecs: incompletes)].					^false]				ifFalse:					[incompletes isEmpty						ifTrue:							[Dialog warn: (#GenKey31 &lt;&lt; #UIPainter &gt;&gt; 'Some components lack properties needed for defining models.') for: aController view]						ifFalse:							[(Dialog									choose: (#GenKey30 &lt;&lt; #UIPainter &gt;&gt; 'Some components lack properties needed for defining models.Select the items that need editing?')									labels: (Array with: (#Select_Cancel &lt;&lt; #UIPainter &gt;&gt; 'Select &amp; Cancel') with: (#Cancel &lt;&lt; #UIPainter &gt;&gt; 'Cancel'))									values: #(true false)									default: true									for: aController view)								ifTrue:									[aController broadcastPendingSelectionChange.									aController										selectionList:											(self findSelectablesIn: aController havingSpecs: incompletes)]].					^false]].</body><body package="UIPainter">aspectPathClassFor: someClass	| pathCl |	pathCl := [aClass aspectPathClass]				on: aClass messageNotUnderstoodSignal				do:					[:ex |					ex parameter selector == #aspectPathClass						ifTrue: [ex return: nil]						ifFalse: [ex pass]].	pathCl isNil ifTrue:		[pathCl := UIAspectPath].	^pathCl</body><body package="UIPainter">currentSkin	^UI.Skins.SkinRegistry current</body><body package="UIPainter">define: bindings for: aController	(self writeDefinitions: bindings for: aController) readStream fileIn.	UIFinderVW2 installed: (Array with: self targetClass with: #notUsed)</body><body package="UIPainter">defineEssentialsFor: anApplicationSpec	| cl |	(self writeEssentialsFor: anApplicationSpec) readStream fileIn.	cl := self getClassNamed: anApplicationSpec name.	cl notNil ifTrue:		[[cl rowType: nil]			on: cl messageNotUnderstoodSignal			do: [:exc |				exc parameter selector == #rowType:						ifTrue: [exc return]						ifFalse: [exc pass]]]</body><body package="UIPainter">does: someClass inheritFromClassNamed: anID	| cl | 	cl := anID asQualifiedReference valueOrDo: [nil].	^cl == nil		ifTrue: [false]		ifFalse: [someClass inheritsFrom: cl]</body><body package="UIPainter">enumeratorClass	^AspectEnumerator</body><body package="UIPainter">expandDetails: detailSlots 	"We need to check to see if there are details whose content aspects 	are aspect paths, since instance variables and accessors for such 	aspects will not be generated as part of the usual service for 	generating detail aspects. This also allows any of the heads of such 	paths needing defining to be presented in the dialog to the user."	| results |	results := Set new.	detailSlots do:		[:slot |		| path |		(path := (self aspectPathClassFor: aClass) forAspect: (slot value contentKey) fromBuilder: nil) tail notNil			ifTrue: [results add: path head -&gt; nil asValue]].	^results</body><body package="UIPainter">expandPaths: bindingSlots	| slotNames results |	slotNames := Set new.	results := Set new.	bindingSlots do:		[:slot |		| aspect |		aspect := (self aspectPathClassFor: aClass) forAspect: slot key fromBuilder: nil.		aspect tail notNil			ifTrue:				[slotNames add: aspect head.				aspect trigger notNil ifTrue: [slotNames add: aspect trigger]]			ifFalse:				[results add: slot]].	slotNames do: [:slnm | results add: slnm -&gt; nil asValue].	^results</body><body package="UIPainter">fetchExpressionForClientDetail: detailSlot on: aStream	| spec |	aStream		nextPutAll: 'self ';		nextPutAll: (spec := detailSlot value) clientKey;		nextPutAll:			(spec sourceType == #singular				ifTrue: [' rowValue: ']				ifFalse: [' rowsList: ']).	(self does: aClass inheritFromClassNamed: #{LensDataManager})		ifTrue: [self finishFetchExpressionForDataFormDetail: detailSlot on: aStream]		ifFalse: [self finishFetchExpressionForTopDetail: detailSlot on: aStream]</body><body package="UIPainter">fetchMethodBodyForDataFormDetail: detailSlot on: aStream	| spec |	aStream 		nextPutAll: (spec := detailSlot value) clientKey;		nextPutAll: ' isNil';		cr; tab; tab;		nextPutAll: 'ifFalse: [';		nextPutAll: spec clientKey;		nextPutAll:			(spec sourceType == #singular				ifTrue: [' rowValue: ']				ifFalse: [' rowsList: ']);		cr; tab; tab; tab; tab.	(spec := detailSlot value) sourceType == #query		ifTrue:			[aStream				nextPutAll: '(self row value isNil';				cr; tab; tab; tab; tab; tab;				nextPutAll: 'ifTrue: [Array new]';				cr; tab; tab; tab; tab; tab;				nextPutAll: 'ifFalse: ['.			spec contentKey notNil				ifTrue:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab; tab; tab;						nextPutAll: '[((self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery mixin: self ';						nextPutAll: spec contentKey;						nextPut: $);						cr; tab; tab; tab; tab; tab; tab; tab; tab;						nextPutAll: 'session: self session) values]']				ifFalse:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab; tab;						nextPutAll: '[(self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery session: self session) values]'].				aStream nextPutAll: '])]']		ifFalse:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: '(self retrieveAspect: ';						nextPutAll: spec contentKey printString;						nextPutAll: ') value]']				ifFalse:					[aStream nextPutAll: 'Array new]']]</body><body package="UIPainter">fetchMethodBodyForTopDetail: detailSlot on: aStream	| spec |	aStream 		nextPutAll: (spec := detailSlot value) clientKey;		nextPutAll: ' isNil';		cr; tab; tab;		nextPutAll: 'ifFalse: [';		nextPutAll: spec clientKey;		nextPutAll:			(spec sourceType == #singular				ifTrue: [' rowValue: ']				ifFalse: [' rowsList: ']);		cr; tab; tab; tab; tab.	(spec := detailSlot value) sourceType == #query		ifTrue:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: '(Cursor database showWhile:';						cr; tab; tab; tab; tab; tab;						nextPutAll: '[((self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery mixin: self ';						nextPutAll: spec contentKey;						nextPut: $);						cr; tab; tab; tab; tab; tab; tab;						nextPutAll: 'session: self session) values])]']				ifFalse:					[aStream						nextPutAll: '(Cursor database showWhile:';						cr; tab; tab; tab; tab; tab;						nextPutAll: '[(self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery session: self session) values])]']]		ifFalse:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: '(self retrieveAspect: ';						nextPutAll: spec contentKey printString;						nextPutAll: ') value]']				ifFalse:					[aStream nextPutAll: 'Array new]']]</body><body package="UIPainter">findDetailVars: detailSlots 	"detailSlots is a collection of associations of detail aspect symbols to 	detail specs.  The contentKey may be an aspect path."	| result |	result := OrderedCollection new.	detailSlots do:		[:assn |		| spec path |		result add: (spec := assn value) clientKey.		spec sourceType ~~ #query			ifTrue:				[path := (self aspectPathClassFor: aClass) forAspect: spec contentKey fromBuilder: nil.				path head notNil ifTrue: [result add: path head].				path trigger notNil ifTrue: [result add: path trigger]]].	^result</body><body package="UIPainter">findSelectablesIn: aController havingSpecs: specList	^aController view components		select:			[:cmp | (cmp isKindOf: SpecWrapper) and: [cmp includesSpecIn: specList]]</body><body package="UIPainter">finishFetchExpressionForDataFormDetail: detailSlot on: aStream	| spec |	(spec := detailSlot value) sourceType == #query		ifTrue:			[aStream				nextPutAll: '(self row value isNil';				cr; tab; tab; tab; tab; tab;				nextPutAll: 'ifTrue: [Array new]';				cr; tab; tab; tab; tab; tab;				nextPutAll: 'ifFalse: ['.			spec contentKey notNil				ifTrue:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab; tab; tab;						nextPutAll: '[((self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery mixin: self ';						nextPutAll: spec contentKey;						nextPut: $);						cr; tab; tab; tab; tab; tab; tab; tab; tab;						nextPutAll: 'session: self session) values]']				ifFalse:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab; tab; tab;						nextPutAll: '[(self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery session: self session) values]'].				aStream nextPutAll: '])']		ifFalse:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: '(self retrieveAspect: ';						nextPutAll: spec contentKey printString;						nextPutAll: ') value']				ifFalse:					[aStream nextPutAll: 'Array new']]</body><body package="UIPainter">finishFetchExpressionForTopDetail: detailSlot on: aStream	| spec |	(spec := detailSlot value) sourceType == #query		ifTrue:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab;						nextPutAll: '[((self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery mixin: self ';						nextPutAll: spec contentKey;						nextPut: $);						cr; tab; tab; tab; tab; tab; tab;						nextPutAll: 'session: self session) values]']				ifFalse:					[aStream						nextPutAll: 'Cursor database showWhile:';						cr; tab; tab; tab; tab; tab;						nextPutAll: '[(self ';						nextPutAll: spec clientKey;						nextPutAll: ' baseQuery session: self session) values]']]		ifFalse:			[spec contentKey notNil				ifTrue:					[aStream						nextPutAll: '(self retrieveAspect: ';						nextPutAll: spec contentKey printString;						nextPutAll: ') value']				ifFalse:					[aStream nextPutAll: 'Array new']]</body><body package="UIPainter">getClassNamed: aClassID	^aClassID asQualifiedReference valueOrDo: []</body><body package="UIPainter">initStringForClient: clientSlot on: aStream	aStream nextPutAll: clientSlot value asString; space;		nextPutAll: 'new'</body><body package="UIPainter">initStringForClientDetail: detailSlot on: aStream	| spec |	aStream		nextPutAll: (spec := detailSlot value) majorKey asString;		space;		nextPutAll: 'new'.	spec lockPolicy ~~ #current		ifTrue:			[aStream				cr; tab; tab; tab; tab;				nextPutAll: 'lockPolicy: ';				nextPutAll: spec lockPolicy printString; nextPut: $;;				cr; tab; tab; tab; tab;				nextPutAll: 'yourself']</body><body package="UIPainter">initStringForDSV: dsvSlot on: aStream 	| enum deps |	deps := Set new.	(enum := self enumeratorClass new source: aClass)			doSpecs: (dsvSlot value columns).	enum bindings keys		do:			[:colM |			| head |			(head := ((self aspectPathClassFor: aClass) forAspect: colM fromBuilder: nil) head) notNil				ifTrue:					[deps add: head]].	"the spec will give the correct aspect model"	aStream nextPutAll: ' ', dsvSlot value privateAspectModel name asString, ' new'.	deps isEmpty ifTrue: [^self].	aStream		nextPut: $.;		cr; tab; tab; tab;		nextPutAll: dsvSlot key;		nextPutAll: ' selectionIndexHolder compute:';		cr; tab; tab; tab; tab;		nextPutAll: '[:v |'.	deps do:		[:asp |		aStream			cr; tab; tab; tab; tab;			nextPutAll: (dsvSlot value privateConditionStringFor: dsvSlot);			nextPutAll: 'self ';			nextPutAll: asp;			nextPutAll: ' value: ';			nextPutAll: dsvSlot key;			nextPutAll: (' ', dsvSlot value privateAspectSelectionString), ' '].	aStream		skip: -1;		nextPutAll: '].';		cr; tab; tab; tab;		nextPutAll: dsvSlot key</body><body package="UIPainter">initStringForList: listSlot on: aStream	aStream 		nextPutAll: listSlot value class name;		space; 		nextPutAll: 'new'.	(listSlot value class respondsTo: #newEmptyInstance)		ifTrue: [aStream nextPutAll: 'EmptyInstance'].</body><body package="UIPainter">initStringForTable: tableSlot on: aStream	aStream nextPutAll: tableSlot value class name;		space; nextPutAll: 'new selectionInTable: SelectionInTable new'</body><body package="UIPainter">initStringForValue: valueSlot on: aStream	aStream nextPutAll: (self initializeStringFor: valueSlot value value);		space; nextPutAll: 'asValue'</body><body package="UIPainter">initializeStringFor: anObject		(anObject isKindOf: String)		ifTrue: [^'String new'].	anObject class == Text 		ifTrue: [^'Text new'].	anObject class == List		ifTrue: [^'List new'].	^anObject storeString</body><body package="UIPainter">interactivelyUpgradeDefns: selectionList for: aController	"NB: if necessary this can be modified so that each and every internal	aspect of a detail is shown in the define dialog, by linking them all to	the selfsame spec object and identifying them in terms of the associated	spec object at generation time (i.e. we tell that fooChannel is the channel	aspect by finding it at the channel place inside the associated spec)."	| enum requiredBindings bindingsWantingDefinition modelsToDefine tmp choice |	aController model targetTrouble		ifTrue:			[(UIPainter preferenceFor: #installForDefine)				ifTrue:					[(aController model installFor: aController) isNil						ifTrue: [^self]]				ifFalse:					[Dialog warn: (#CanvasNotInstalled &lt;&lt; #UIPainter &gt;&gt; 'The canvas isn''t installed on any class') for: aController view.					^self]].	(enum := self enumeratorClass new source: aController model builder source).	selectionList isEmpty		ifTrue:			[enum doSpec: (aController model extractFullSpec)]		ifFalse:			[selectionList do:				[:sw |				enum doSpec: sw extractedSpec]].	requiredBindings := enum actions.	requiredBindings addAll: (self expandPaths: enum bindings associations).	requiredBindings addAll: (self expandDetails: enum details associations).	requiredBindings addAll: (enum clients associations).	requiredBindings addAll: (enum details associations).		"Filter out those messages that must be inherited from LensDataManager."	(self does: aClass inheritFromClassNamed: #{LensApplicationModel})		ifTrue:			[requiredBindings associations do:				[:assn |				(aClass excludedBindings includes: assn key)					ifTrue: [requiredBindings removeKey: assn key]]].	(requiredBindings isEmpty and: [enum incompletes isEmpty])		ifTrue:			[self warnNoRequiredBindingsFor: selectionList.			^self].	(self			alertForMissingProperties: enum incompletes			among: selectionList			withNumberRequired: requiredBindings size + enum incompletes size			for: aController)		ifFalse:			[^self].	(aController canvasHasChanged and: [UIPainter preferenceFor: #installForDefine])		ifTrue:			[(choice :=				Dialog					choose: (#GenKey45 &lt;&lt; #UIPainter &gt;&gt; 'The canvas has changed since it was last installed.Install before defining models?')					labels: (Array with: (#InstallFirst &lt;&lt; #UIPainter &gt;&gt; 'Install First') with: (#DefineAsIs &lt;&lt; #UIPainter &gt;&gt; 'Define As Is') with: (#Cancel &lt;&lt; #UIPainter &gt;&gt; 'Cancel'))					values: #(#install #define #cancel)					default: #define					for: aController view) == #cancel				ifTrue: [^self].			(choice == #install and:				[(aController model installFor: aController) isNil]) 				ifTrue:					[^self]].		tmp := IdentityDictionary new.	tmp addAll:		(self excludedBindings associations reject:			[:assn |			((requiredBindings includesKey: assn key) not or:				[((requiredBindings at: assn key)					isKindOf: assn value class) not])]).	self excludedBindings: tmp.	bindingsWantingDefinition :=		requiredBindings associations select:			[:bndg | (self excludedBindings includesKey: bndg key) not].	modelsToDefine :=		self			openDefinitionDialogOn:				(requiredBindings associations collect: [:bndg | bndg key]) asSortedStrings			selecting: (bindingsWantingDefinition collect: [:bndg | bndg key]).	modelsToDefine isNil		ifTrue:			[^self].	self		define:			(modelsToDefine collect:				[:mdl | requiredBindings associationAt: mdl])		for: aController.	requiredBindings associations do:		[:bndg |		(modelsToDefine includes: bndg key)			ifTrue: [excludedBindings removeKey: bndg key ifAbsent: []]			ifFalse: [excludedBindings add: bndg]].	"this is required to reset DataSetSpecs slots used just for defining"	requiredBindings associations do:		[:bndg | | dsSpec |		(dsSpec := bndg value) class name == #DataSetSpec			ifTrue: [dsSpec resetColumnButtonsAsLabelsAttributes]]</body><body package="UIPainter">isDataFormSpec: obj	| c1 c2 |	c1 := #{LinkedDetailSpec} valueOrDo: [^false].	c2 := #{EmbeddedDetailSpec} valueOrDo: [^false].	^(obj isKindOf: c1) or: [obj isKindOf: c2]</body><body package="UIPainter">openDefinitionDialogOn: models selecting: modelsToDefine	| builder dialog modelList result |	builder := (dialog := SimpleDialog new) builder.	builder aspectAt: #addInitialization put: self initializeModels.	(modelList :=		builder			aspectAt: #modelList			put: (MultiSelectionInList with: models)).	modelList selections: modelsToDefine asOrderedCollection.	builder		aspectAt: #doOK		put:			[result := modelList selections.			dialog close].	builder		aspectAt: #doAbort		put:			[result := nil.			dialog close].	dialog openFrom:		(UISpecification from:			(models size == 1				ifTrue: [self class smallDefineDialogSpec]				ifFalse: [self class defineDialogSpec])).	^result</body><body package="UIPainter">saveNamedFontsOn: aFilename from: aFullSpec	| codeStream style fontDescription output usedStyles |	codeStream := String new writeStream.	usedStyles := aFullSpec window namedFontFileOutType == #all		ifTrue: [self currentSkin styles]		ifFalse: [self extractNamedStyles: aFullSpec].	usedStyles do: 		[:each | 		style := self currentSkin styleNamed: each.		fontDescription := style characterAttributes updatedQueryFor: Screen default defaultFontPolicy.		self writeFontDefinitionHeader: codeStream fontDescription: fontDescription.		codeStream 			nextPutAll: VariableSizeTextAttributes fullName;			nextPutAll: ' styleNamed: ';			store: each;			nextPutAll: ' put: newStyle!';			cr; cr].	[aFilename exists ifTrue: [aFilename delete].	output := aFilename readWriteStream.	output nextPutAll: codeStream contents.	output flush] ensure: [output close].</body><body package="UIPainter">setClass: class 	"Set the value of the target class to be class."	aClass := class</body><body package="UIPainter">warnNoRequiredBindingsFor: selectionList	Dialog warn:		(selectionList isEmpty			ifTrue: [				(#NoItemsNeedModel &lt;&lt; #UIPainter &gt;&gt; 'There are no items that need&lt;n&gt;models to be defined for them.') expandMacros]			ifFalse: [				selectionList size = 1					ifTrue: [						(selectionList first spec model notNil)							ifTrue: [(#AlreadyInheritsModel &lt;&lt; #UIPainter &gt;&gt; 'The application already inherits&lt;n&gt;a model for the selected item.') expandMacros]							ifFalse: [#ItemNeedsNoModel &lt;&lt; #UIPainter &gt;&gt;'The selected item needs no model.']]					ifFalse: [(#ItemsNeedNoModel &lt;&lt; #UIPainter &gt;&gt; 'The selected items need no&lt;n&gt;models to be defined for them.') expandMacros]])</body><body package="UIPainter">whereClauseForDetail: detailClass into: aCodeStream 	| qe qOp dcl whr |	dcl := detailClass asQualifiedReference valueOrDo:			[Dialog warn: ((#GenKey51 &lt;&lt; #UIPainter &gt;&gt; 'The Class: &lt;1s&gt;&lt;n&gt;is not defined yet.&lt;nn&gt;The restricting query method generated in the parent&lt;n&gt;will not contain the default joins that would make the&lt;n&gt;child DataForm''s fetch sensitive to the row selected&lt;n&gt;in the parent.&lt;nn&gt;You can edit the restricting query using the Query&lt;n&gt;Editor, or use ''define'' again after creating the class&lt;n&gt;for the child Data Form')			expandMacrosWith: detailClass asString).			^nil].	(dcl respondsTo: #rowType)		ifFalse: 			[^nil].	qOp := (#{QueryOperation} valueOrDo: [^nil]) new.	qOp containerNames: dcl rowType.	qOp mode: #mixin.	qe := (#{QueryEditor} valueOrDo: [^nil]) new.	qe ldm: self targetClass dataModel.	qe targetClass: self targetClass.	qe loadTheQuery: qOp.	whr := qe defaultMixinJoin.	whr size &gt; 0		ifTrue: 			[qe where value: whr.			qe putWhereInto: aCodeStream]</body><body package="UIPainter">writeAccessor: aspect for: assn initGen: initStringMethod on: aStream	aStream cr; cr; nextPutAll: aspect.	self initializeModels value		ifTrue:			[aStream cr; tab;				nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."']		ifFalse:			[aStream cr; tab;				nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."'].	aStream cr; cr; tab;		nextPutAll: '^' , aspect.	self initializeModels value		ifTrue:			[aStream				nextPutAll: ' isNil';				cr; tab; tab;				nextPutAll: 'ifTrue:';				cr; tab; tab; tab;				nextPut: $[; nextPutAll: aspect; nextPutAll: ' := '.			self perform: initStringMethod with: assn with: aStream.			aStream				nextPut: $];				cr; tab; tab;				nextPutAll: 'ifFalse:';				cr; tab; tab; tab;				nextPut: $[; nextPutAll: aspect; nextPut: $]].	aStream nextPut: $!</body><body package="UIPainter">writeAccessors: prop for: slots initGen: initGenMethod on: aStream	slots isEmpty not		ifTrue:			[slots do:				[:assn |				self					writeAccessor: (assn value perform: prop)					for: assn					initGen: initGenMethod					on: aStream]]</body><body package="UIPainter">writeAccessorsFor: slots initGen: initGenMethod on: codeStream	| aStream |	slots isEmpty not		ifTrue:			[aStream := String new writeStream.			slots do:				[:assn |				self					writeAccessor: assn key					for: assn					initGen: initGenMethod					on: aStream].			codeStream nextPutAll: aStream contents]</body><body package="UIPainter">writeAccessorsForClients: clientSlots andDetails: detailSlots on: aStream	(detailSlots isEmpty not or: [clientSlots isEmpty not])		ifTrue:			[aStream				cr; cr;				nextPut: $!;				nextPutAll: aClass fullName;				nextPutAll: ' methodsFor: ''accessing''!'.			self				writeAccessors: #clientKey				for: detailSlots				initGen: #initStringForClientDetail:on:				on: aStream.			self writeAccessorsFor: clientSlots initGen: #initStringForClient:on: on: aStream.			aStream nextPutAll: ' !'].</body><body package="UIPainter">writeAutoFetchMethod: autoFetchSlots on: aStream		aStream		cr; cr;		nextPutAll: 'autoFetchFor: aChild';		cr; tab;		nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	will be lost whenever methods are automatically defined."'; cr.	autoFetchSlots isEmpty		ifTrue:			[aStream cr; tab; nextPutAll: '^self']		ifFalse:			[autoFetchSlots				do:					[:detl |					aStream						cr; tab;						nextPutAll: 'aChild == self ';						nextPutAll: detl clientKey;						nextPutAll: ' ifTrue: [self ';						nextPutAll: detl fetchAction;						nextPutAll: '].']].	aStream nextPut: $!</body><body package="UIPainter">writeAutoOpenMethod: autoOpenSlots on: aStream		aStream		cr; cr;		nextPutAll: 'autoOpenChildren';		cr; tab;		nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	will be lost whenever methods are automatically defined."'; cr.	autoOpenSlots isEmpty		ifFalse:			[autoOpenSlots				do:					[:assn |					| spec cnv |					aStream						cr; tab;						nextPutAll: 'self openChild: self ';						nextPutAll: (spec := assn value) clientKey;						nextPutAll: ' with: ';						nextPutAll:							((cnv := spec minorKey) isNil								ifTrue: ['#windowSpec']								ifFalse: [cnv printString]);						nextPut: $.]].	aStream cr; tab; nextPutAll: 'super autoOpenChildren'.	aStream nextPut: $!</body><body package="UIPainter">writeChildRemovalMethod: detailSlots on: aStream	detailSlots isEmpty ifTrue: [^self].	aStream		cr; cr;		nextPutAll: 'removeChild: aChild';		cr; tab;		nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	will be lost whenever methods are automatically defined."';		cr; cr; tab;		nextPutAll: 'super removeChild: aChild'.	detailSlots do:		[:detl |		aStream			nextPut: $.;			cr; tab;			nextPutAll: 'aChild == ';			nextPutAll: detl clientKey;			nextPutAll: ' ifTrue: [';			nextPutAll: detl clientKey;			nextPutAll: ' := nil]'].	aStream nextPut: $!</body><body package="UIPainter">writeClassDefiningMessageForIVs: ivNames on: codeStream 	"Create a new class definition string starting with the current one. Build the 	instance variables string by taking the current one, adding a space and 	then adding the new instance variables separated by spaces. Then format 	the class definition message and put it as the next chunk in the code 	stream"	| aStream msg index |	aStream := String new writeStream.	msg := aClass definitionMessage.	index := msg selector keywords				indexOf: 'instanceVariableNames:'				ifAbsent: [self error: 'I can''t add any instance variable names'].	aStream nextPutAll: (msg arguments at: index).	aStream space.	ivNames do: [:e | aStream nextPutAll: e; space].	msg arguments at: index put: aStream contents.	aStream := String new writeStream.	msg receiver printOn: aStream.	msg selector keywords with: msg arguments		do: 			[:word :arg | 			arg == aClass name				ifTrue: [aStream space]				ifFalse: [aStream cr; tab].			aStream nextPutAll: word; space; store: arg].	codeStream nextChunkPut: aStream contents</body><body package="UIPainter">writeDefinitions: bindings for: aController	"bindings includes all required bindings in the selection set	that the user has not specifically disallowed.  Test to see whether	instance variables are already there.  Must check to see whether	action methods are already there, and do not redefine them if they	exist.  Always redefine aspect methods against the possibility that	the type of the model has changed.	NB: aspect methods incorporate lazy instVar initialization."	| allnames actionSlots valueSlots listSlots tableSlots clientSlots dsvSlots dsvColSlots detailSlots ivNames detailVars codeStream allDetails treeViewSlots |	allnames := aClass allInstVarNames asSet.	actionSlots := bindings select: [:e | e value isKindOf: BlockClosure].	valueSlots := bindings select: [:e | e value isKindOf: ValueModel].	listSlots := bindings select: [:e | e value isKindOf: SelectionInList].	tableSlots := bindings select: [:e | e value isKindOf: TableInterface].	clientSlots := bindings select: [:e | (e value isKindOf: Symbol) or: [e value isBindingReference]].	dsvSlots := bindings select: [:e | e value isKindOf: DataSetSpec].	treeViewSlots := bindings select: [:each | each value isKindOf: TreeViewSpec].	dsvColSlots := bindings select: [:e | e value isKindOf: DataSetColumnSpec].	detailSlots := bindings select:		[:e | self isDataFormSpec: e value].	detailVars := self findDetailVars: detailSlots.	ivNames :=		(((valueSlots, listSlots, tableSlots, clientSlots, dsvSlots) collect: [:e | e key ]), detailVars			select: [:e | (allnames includes: e asString) not]) asSet.	codeStream := String new writeStream.	self writeClassDefiningMessageForIVs: ivNames on: codeStream.	self writeAccessorsForClients: clientSlots andDetails: detailSlots on: codeStream.	self		writeSimpleActions: actionSlots		andDetailActions: detailSlots		andDSVSortActions: dsvColSlots		on: codeStream.	self writeTreeViewActions: treeViewSlots on: codeStream.	self		writeSimpleAspects: valueSlots		andListAspects: listSlots		andTableAspects: tableSlots		andDSVAspects: dsvSlots		on: codeStream.		allDetails := 		(self enumeratorClass new source: aController model builder source)			doSpec: aController model extractFullSpec; details.	(self does: aClass inheritFromClassNamed: #LensApplicationModel)		ifTrue:			[self				writeMixinQueryMethods: detailSlots on: codeStream.			"The private methods must be written to take into account all details			on the canvas, not just those currently selected."			self writePrivateMethods: allDetails for: aController on: codeStream]		ifFalse:			[allDetails isEmpty not				ifTrue:					[Dialog warn:(#GenKey60 &lt;&lt; #UIPainter &gt;&gt; 'A complete set of definitions could not be generatedto support the Data Form(s) being defined for, becausethis canvas is installed on a non-database class.  Youshould reinstall the canvas on a new class that is eithera Data Form or a Database Application, and try again.')]].			^codeStream contents</body><body package="UIPainter">writeDemandFetchMethod: detailSlots on: aStream		aStream		cr; cr;		nextPutAll: 'fetchFor: aChild';		cr; tab;		nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	will be lost whenever methods are automatically defined."'; cr.	detailSlots		do:			[:assn |			| dtl |			aStream				cr; tab;				nextPutAll: 'aChild == self ';				nextPutAll: (dtl := assn value) clientKey.			dtl fetchAction isNil				ifTrue:					[aStream						cr; tab; tab;						nextPutAll: 'ifTrue:';						cr; tab; tab; tab;						nextPut: $[.					self fetchExpressionForClientDetail: dtl on: aStream]				ifFalse:					[aStream						nextPutAll: ' ifTrue: [self ';						nextPutAll: assn value fetchAction].			aStream nextPutAll: '].'].	aStream nextPut: $!</body><body package="UIPainter">writeEssentialsFor: anApplicationSpec 	"The class decides what needs to be defined for it, inheriting from whichever behavior was defined in the superclass"	| codeStream |	codeStream := String new writeStream.	anApplicationSpec name asQualifiedReference ifDefinedDo:		[:cl|		  [cl			writeEssentialsFor: anApplicationSpec			using: self			into: codeStream]				on: cl messageNotUnderstoodSignal				do: [:ex |					ex parameter selector == #writeEssentialsFor:using:into:						ifTrue: [ex return: nil]						ifFalse: [ex pass]]].	^codeStream contents</body><body package="UIPainter">writeFetchActions: detailSlots on: aStream	(detailSlots isEmpty or:			[(detailSlots detect: [:assn | assn value fetchAction notNil] ifNone: []) isNil])		ifTrue: [^self].	detailSlots		do:			[:assn |			assn value fetchAction notNil				ifTrue:					[aStream						cr; cr;						nextPutAll: assn value fetchAction;						cr; tab;						nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."';						cr; cr; tab.					(self does: aClass inheritFromClassNamed: #{LensDataManager})						ifTrue: [self fetchMethodBodyForDataFormDetail: assn on: aStream]						ifFalse: [self fetchMethodBodyForTopDetail: assn on: aStream].					aStream nextPut: $!]]</body><body package="UIPainter">writeFontLoadingMethod: aString	| codeStream |	codeStream := String new writeStream.	self writePrivateMethodHeaderOn: codeStream.	codeStream 		nextPutAll: 'loadNamedFonts';		cr; tab;		nextPutAll: '"This method is created by the UIDefiner';		cr; tab;		nextPutAll: 'Any edits made here may be lost whenever named fonts are re-saved"';		cr; cr; tab;		nextPutAll: 'self loadNamedFontsFromFile: ';		nextPutAll: aString printString;		nextPut: $!.	codeStream contents readStream fileIn.</body><body package="UIPainter">writeMetaAccessorsOn: aStream		| app msg cat |	app := aClass new application.	(app class includesSelector: #messageCatalogID)		ifFalse:			[msg := (app respondsTo: #messageCatalogID)				ifTrue: [(#GenKey71 &lt;&lt; #UIPainter &gt;&gt; 'This application inherits its message catalog name&lt;n&gt;from its superclass. If it uses message catalogs and&lt;n&gt;is not delivered together with its superclass, you may&lt;n&gt;want to give it a different catalog name now. Enter&lt;n&gt;the name of the catalog, or Cancel if you don''t want&lt;n&gt;to change the catalog.')]				ifFalse: [(#GenKey70 &lt;&lt; #UIPainter &gt;&gt; 'This application does not respond to #messageCatalogID.&lt;n&gt;If it uses message catalogs, you must supply a message&lt;n&gt;catalog name before using the aplication. Enter the name&lt;n&gt;of the catalog, or Cancel if you don''t want to define the catalog.')].			cat := Dialog request: msg expandMacros.			cat isEmpty				ifFalse:					[aStream						cr; cr;						nextPut: $!;						nextPutAll: app class fullName;						nextPutAll: ' methodsFor: ''accessing''!'.					aStream cr; cr;						nextChunkPut: 'messageCatalogID	"This method was generated by UIDefiner."	^', cat asSymbol storeString.					aStream nextPutAll: ' !']].</body><body package="UIPainter">writeMixinQueryMethods: detailSlots on: aStream	| codeStream emptyPos |	detailSlots isEmpty not		ifTrue:			[codeStream := String new writeStream.			codeStream				cr; cr;				nextPut: $!;				nextPutAll: aClass fullName asString;				nextPutAll: ' methodsFor: ''query''!'.			emptyPos := codeStream writePosition.			detailSlots				do:					[:slot |					| spec mixQK |					((spec := slot value ) sourceType == #query and:						[(mixQK := spec contentKey) notNil])						ifTrue:							[codeStream								cr; cr;								nextPutAll:									(self										mixinQueryContentsForDetail: spec majorKeyReference										named: mixQK);								nextPut: $!.]].			emptyPos = codeStream writePosition				ifFalse:					[aStream						nextPutAll: codeStream contents;						nextPutAll: ' !']]</body><body package="UIPainter">writeOpenActions: detailSlots on: aStream	"If there is any detailSlot with an openAction defined, add the 	definition of the method to aStream for each such detailSlot"	(detailSlots isEmpty or:			[(detailSlots detect: [:assn |  assn value openAction notNil] ifNone: []) isNil])		ifTrue: [^self].	detailSlots		do:			[:assn |			| cnv spec |			(spec := assn value) openAction notNil				ifTrue:					[aStream						cr; cr;						nextPutAll: spec openAction;						cr; tab;						nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."';						cr; cr; tab;						nextPutAll: 'self openChild: self ';						nextPutAll: spec clientKey;						nextPutAll: ' with: ';						nextPutAll:							((cnv := spec minorKey) isNil								ifTrue: ['#windowSpec']								ifFalse: [cnv printString]);						nextPut: $!]]</body><body package="UIPainter">writePrivateMethodHeaderOn: aStream	aStream		cr; cr;		nextPut: $!;		nextPutAll: aClass fullName;		nextPutAll: ' methodsFor: ''private''!'.</body><body package="UIPainter">writePrivateMethods: allDetails for: aController on: aStream 	"Always rewrite the 'private' methods taking into account all of the 	details on the canvas, not just those that are currently selected."	self writePrivateMethodHeaderOn: aStream.	self		writeChildRemovalMethod: allDetails		on: aStream.	self		writeAutoOpenMethod:			(allDetails select: [:assn | assn value openAction notNil and: [assn value autoOpen]])		on: aStream.	self		writeAutoFetchMethod:			(allDetails select: [:assn | assn value fetchAction notNil and: [assn value autoFetch]])		on: aStream.	self		writeDemandFetchMethod: allDetails		on: aStream.	(self does: aClass inheritFromClassNamed: #{LensDataManager}) ifTrue:		[self			writeSynchronizeMethod: (allDetails select: [:assn | assn value synchronize])			on: aStream].	aStream nextPutAll: ' !'</body><body package="UIPainter">writeSimpleActions: actionSlots andDetailActions: detailSlots andDSVSortActions: dsvColSlots on: aStream	"Be careful never to rewrite simple actions that already exist,	however detail fetch and open actions must needs be rewritten	against the chance the user has changed these properties."	| codeStream emptyPos |	(actionSlots isEmpty not or: [detailSlots isEmpty not or: [dsvColSlots isEmpty not]])"	(actionSlots isEmpty not or: [detailSlots isEmpty not])"		ifTrue:			[codeStream := String new writeStream.			codeStream cr; cr; nextPutAll: '!' , aClass fullName ,				' methodsFor: ''actions''!'.			emptyPos := codeStream writePosition.			self				writeSimpleActions:					(actionSlots select: [:assn | (aClass canUnderstand: assn key) not])				on: codeStream.			self				writeFetchActions:					(detailSlots select:						[:assn | assn value fetchAction notNil])				on: codeStream.			self				writeOpenActions:					(detailSlots select:						[:assn | assn value openAction notNil])				on: codeStream.			self				writeSortActionsFor: dsvColSlots				initGen: #initStringForDSV:on:				on: codeStream.			emptyPos = codeStream writePosition				ifFalse:					[aStream						nextPutAll: codeStream contents;						nextPutAll: ' !']]</body><body package="UIPainter">writeSimpleActions: actionSlots andDetailActions: detailSlots on: aStream	"Be careful never to rewrite simple actions that already exist,	however detail fetch and open actions must needs be rewritten	against the chance the user has changed these properties."	| codeStream emptyPos |	(actionSlots isEmpty not or: [detailSlots isEmpty not])		ifTrue:			[codeStream := String new writeStream.			codeStream cr; cr; nextPutAll: '!' , aClass fullName ,				' methodsFor: ''actions''!'.			emptyPos := codeStream writePosition.			self				writeSimpleActions:					(actionSlots select: [:assn | (aClass canUnderstand: assn key) not])				on: codeStream.			self				writeFetchActions:					(detailSlots select:						[:assn | assn value fetchAction notNil])				on: codeStream.			self				writeOpenActions:					(detailSlots select:						[:assn | assn value openAction notNil])				on: codeStream.			emptyPos = codeStream writePosition				ifFalse:					[aStream						nextPutAll: codeStream contents;						nextPutAll: ' !']]</body><body package="UIPainter">writeSimpleActions: actionSlots on: aStream	actionSlots isEmpty ifTrue: [^self].	actionSlots		do:			[:actn |			aStream				nextPutAll: actn key;				cr; cr; tab;				nextPutAll: '"This stub method was generated by UIDefiner"';				cr; cr; tab;				nextPutAll: '^self!']</body><body package="UIPainter">writeSimpleAspects: valueSlots andListAspects: listSlots andTableAspects: tableSlots andDSVAspects: dsvSlots on: aStream	"Always redefine the more accessor-like methods"	| codeStream emptyPos |	(valueSlots isEmpty not or:		[listSlots isEmpty not or:			[tableSlots isEmpty not or:				[dsvSlots isEmpty not]]])		ifTrue:			[codeStream := String new writeStream.			codeStream				cr; cr;				nextPut: $!;				nextPutAll: aClass fullName;				nextPutAll: ' methodsFor: ''aspects''!'.			emptyPos := codeStream writePosition.			self writeAccessorsFor: valueSlots initGen: #initStringForValue:on: on: codeStream.			self				writeAccessorsFor: listSlots				initGen: #initStringForList:on:				on: codeStream.			self				writeAccessorsFor: tableSlots				initGen: #initStringForTable:on:				on: codeStream.			self				writeAccessorsFor: dsvSlots				initGen: #initStringForDSV:on:				on: codeStream.			emptyPos = codeStream writePosition				ifFalse:					[aStream						nextPutAll: codeStream contents;						nextPutAll: ' !']]</body><body package="UIPainter">writeSynchronizeMethod: synchroSlots on: aStream	aStream		cr; cr;		nextPutAll: 'synchronize: aChild';		cr; tab;		nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."'; cr.	synchroSlots isEmpty		ifTrue:			[aStream cr; tab; nextPutAll: '^self']		ifFalse:			[synchroSlots do:				[:slt |				| spec |				aStream					cr; tab;					nextPutAll: 'aChild == self ';					nextPutAll: (spec := slt) clientKey;					cr; tab; tab;					nextPutAll: ' ifTrue:';					cr; tab; tab; tab;					nextPutAll: '[self row '.				spec fetchAction isNil					ifTrue:						[aStream							nextPutAll: 'compute:';							cr; tab; tab; tab; tab;							nextPutAll: '[:v |';							cr; tab; tab; tab; tab.						self fetchExpressionForClientDetail: slt on: aStream.						aStream							nextPut:$];							cr; tab;tab;tab;							nextPutAll: 'for: aChild']					ifFalse:						[aStream							nextPutAll: 'onChangeSend: ';							nextPutAll: spec fetchAction printString;							nextPutAll: ' to: self for: aChild'].				aStream nextPutAll: '].']].	aStream nextPut: $!</body><body package="UIPainter">writeTreeViewActions: anOrderedCollection on: aStream 	anOrderedCollection isEmpty ifTrue: [^self].	aStream		cr; cr;		nextPut: $!;		nextPutAll: aClass fullName;		nextPutAll: ' methodsFor: ''tree view emphasis''!'.	anOrderedCollection do:		[:each | | selector |		selector := each value perform: each key.		aStream nextPutAll: selector.		(selector includes: $:) ifTrue: [aStream nextPutAll: ' aTreeValue'].		aStream			cr; tab;			nextPutAll: '"This stub method was generated by UIDefiner';			cr; tab;			nextPutAll: 'This method should answer an Array of Text emphasis values';			cr; tab;			nextPutAll: 'Examples:';			cr; tab; tab;			nextPutAll: 'Array with: #bold with: #color-&gt;ColorValue blue';			cr; tab; tab;			nextPutAll: '#(#bold #italic)"';			cr; cr; tab;			nextPutAll: '^#(#normal)!'].	aStream nextPutAll: ' !'</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private-Datasets</category><body package="UIPainter">ascendingSortBlockStringFor: aDataSetColumnSpec	| strm |	strm := WriteStream on: (String new: 50).	strm nextPutAll: '[:x :y | x '.	strm nextPutAll: aDataSetColumnSpec aspectPathForSort.	strm nextPutAll: ' displayString &lt;= y '.	strm nextPutAll: aDataSetColumnSpec aspectPathForSort. 	strm nextPutAll: ' displayString]'.	^strm contents</body><body package="UIPainter">descendingSortBlockStringFor: aDataSetColumnSpec	| strm |	strm := WriteStream on: (String new: 50).	strm nextPutAll: '[:x :y | x '.	strm nextPutAll: aDataSetColumnSpec aspectPathForSort.	strm nextPutAll: ' displayString &gt;= y '.	strm nextPutAll: aDataSetColumnSpec aspectPathForSort. 	strm nextPutAll: ' displayString]'.	^strm contents</body><body package="UIPainter">writeSortAction: aspect for: assn initGen: initStringMethod on: aStream	| dsvColSpec dsvSpec selector |	"Remove aspect path or buffer symbols"	selector := aspect copyReplaceAll: '|' with: String new.	selector := selector copyReplaceAll: '@' with: String new.	aStream cr; cr; nextPutAll: selector.	self initializeModels value		ifTrue:			[aStream cr; tab;				nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."']		ifFalse:			[aStream cr; tab;				nextPutAll: '"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."'].	dsvColSpec := assn value.	dsvSpec := dsvColSpec dataSetSpec.	aStream cr; cr; tab;		nextPutAll: '| ascSortBlock dscSortBlock sortBlock |'.	aStream cr; tab; 		nextPutAll: 'ascSortBlock := '.	aStream nextPutAll: (self ascendingSortBlockStringFor: dsvColSpec).	aStream nextPutAll: '.'.	aStream cr; tab; 		nextPutAll: 'dscSortBlock := '.	aStream nextPutAll: (self descendingSortBlockStringFor: dsvColSpec).	aStream nextPutAll: '.'.	aStream cr; cr; tab;		nextPutAll: 'sortBlock := self ', dsvSpec model, ' sortAspect == #', dsvColSpec fullColumnAspect.	aStream cr; tab; tab;		nextPutAll: 'ifTrue: ['.	aStream cr; tab; tab; tab;		nextPutAll: 'self ', dsvSpec model, ' sortDirection == #asc'.	aStream cr; tab; tab; tab; tab;		nextPutAll: 'ifTrue: [self ', dsvSpec model, ' sortDirection: #dsc.'.	aStream cr; tab; tab; tab; tab; tab;		nextPutAll: 'ascSortBlock]'.	aStream cr; tab; tab; tab; tab;		nextPutAll: 'ifFalse: [self ', dsvSpec model, ' sortDirection: #asc.'.	aStream cr; tab; tab; tab; tab; tab;		nextPutAll: 'dscSortBlock]]'.	aStream cr; tab; tab;		nextPutAll: 'ifFalse: [';		nextPutAll: 'self ', dsvSpec model, ' sortAspect: #', dsvColSpec fullColumnAspect, '.'.	aStream cr; tab; tab; tab; tab;		nextPutAll: 'self ', dsvSpec model, ' sortDirection: #dsc.'.	aStream cr; tab; tab; tab; tab;		nextPutAll: 'ascSortBlock].'.	aStream cr; cr; tab;		nextPutAll: 'self ', dsvSpec model, ' refreshList:'.	aStream cr; tab; tab.	aStream nextPutAll: '(SortedCollection withAll: (self ', dsvSpec model, ' list)'.	aStream cr; tab; tab; tab.	aStream nextPutAll: 'sortBlock: sortBlock) asList.'.	aStream nextPut: $!</body><body package="UIPainter">writeSortActionsFor: slots initGen: initGenMethod on: codeStream	| aStream |	slots isEmpty not		ifTrue:			[aStream := String new writeStream.			slots do:				[:assn |				self					writeSortAction: assn key					for: assn					initGen: initGenMethod					on: aStream].			codeStream nextPutAll: aStream contents]</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>accessing</category><body package="UIPainter">excludedBindings	^excludedBindings</body><body package="UIPainter">excludedBindings: aDictionary	excludedBindings := aDictionary</body><body package="UIPainter">initializeModels	^initializeModels</body><body package="UIPainter">targetClass	"Answer the target class of the receiver."	^aClass</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>defining</category><body package="UIPainter">addAccessing	"For each instance variable of the target class, add the reading and writing 	access interface."	self addReadingAccess.	self addWritingAccess</body><body package="UIPainter">addCatalogID: aString	| codeStream |	codeStream := (String new: 100) writeStream.	codeStream		cr; cr;		nextPut: $!;		nextPutAll: self targetClass class fullName;		nextPutAll: ' methodsFor: ''accessing''!';		cr; cr;		nextPutAll: 'messageCatalogID';		cr; tab;		nextPutAll: '"This method was generated by UIDefiner."';		cr; tab;		nextPut:$^;		nextPutAll: aString asSymbol storeString;		nextPutAll: ' !'.	codeStream contents readStream fileIn.</body><body package="UIPainter">addDependencyWritingAccess	"For each instance variable, add in the message category accessing a 	message whose selector is the instance variable as a keyword with 	one argument, and whose method stores the argument as the new 	value of the instance variable. If there is already a message selector 	with the instance variable name as keyword, no replacement is 	made."	self addDependencyWritingAccessFor: self targetClass instVarNames</body><body package="UIPainter">addReadingAccess	"Build read accessing messages to the reciever's target class."	self addReadingAccessFor: self targetClass instVarNames.</body><body package="UIPainter">addWritingAccess	"For each instance variable, add in the message category accessing a 	message whose selector is the instance variable as a keyword with 	one argument, and whose method stores the argument as the new 	value of the instance variable. If there is already a message selector 	with the instance variable name as keyword, no replacement is 	made."	self addWritingAccessFor: self targetClass instVarNames</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>initialize-release</category><body package="UIPainter">initialize	initializeModels := true asValue.	excludedBindings := Dictionary new</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private-named fonts</category><body package="UIPainter">extractNamedStyles: aFullSpec 	| enum styles |	styles := Set new.	enum := FilteredSpecEnumerator new.	enum block: 			[:each | 			(each respondsTo: #style) 				ifTrue: 					[| style |					style := each style.					styles add: (style == #system ifTrue: [#systemDefault] ifFalse: [style])].			true].	enum doSpec: aFullSpec.	^styles asOrderedCollection</body><body package="UIPainter">writeDefineNamedFontsMethod: aCollection	| codeStream style fontDescription |	codeStream := String new writeStream.	self writePrivateMethodHeaderOn: codeStream.	codeStream 		cr;		nextPutAll: 'definedNamedFonts';		cr; tab;		nextPutAll: '"This method is created by the UIDefiner';		cr; tab;		nextPutAll: 'Any edits made here may be lost whenever named fonts are re-defined"';		cr; cr; tab;		nextPutAll: '^#('.	aCollection do:		[:each |		codeStream			cr; tab; tab;			nextPutAll: '#(';			store: each.		style := self currentSkin styleNamed: each.		fontDescription := style characterAttributes updatedQueryFor: Screen default defaultFontPolicy.		UISpecification prettyPrintSpecArray: fontDescription literalArrayEncoding on: codeStream tabLevel: 2.		codeStream nextPut: $)].	codeStream 	nextPutAll: ') !'.	codeStream contents readStream fileIn.</body><body package="UIPainter">writeFontDefinitionHeader: aStream fontDescription: aFontDescription	aStream 		tab;		nextPutAll: '| characterAttributes newStyle |';		cr; tab;		nextPutAll: 'characterAttributes := VariableCharacterAttributes newWithDefaultAttributes.';		cr;tab;			nextPutAll: 'characterAttributes setDefaultQuery: ('.		UISpecification prettyPrintSpecArray: aFontDescription literalArrayEncoding on: aStream tabLevel: 2.	aStream 		space; 		nextPutAll: 'decodeAsLiteralArray).';		cr; tab;		nextPutAll: 'newStyle := VariableSizeTextAttributes characterAttributes: characterAttributes.';		cr; tab.</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>named fonts</category><body package="UIPainter">addNamedFontsMethod: aSymbol using: aFullSpec	| usedStyles |	usedStyles := aSymbol == #all		ifTrue: [self currentSkin styles copy]		ifFalse: [self extractNamedStyles: aFullSpec].	self writeDefineNamedFontsMethod: usedStyles.</body><body package="UIPainter">saveAndDefineNamedFonts: aFullSpec	| fileName |	fileName :=  aFullSpec window savedFontFileName.	fileName asFilename extension isNil ifTrue:		[fileName := fileName, '.ffo'].	aFullSpec window defineFontLoadingMethod ifTrue: [self writeFontLoadingMethod: fileName].	self 		saveNamedFontsOn: fileName asFilename		from: aFullSpec</body></methods><methods><class-id>Tools.UIDefiner class</class-id> <category>instance creation</category><body package="UIPainter">for: aClass	"Create an instance of the receiver for the class aClass."	^self new setClass: aClass</body><body package="UIPainter">new	^self basicNew initialize</body></methods><methods><class-id>Tools.ColorToolModel</class-id> <category>interface opening</category><body package="UIPainter">buildInSubCanvas: spec withBuilder: aBuilder	super buildInSubCanvas: spec withBuilder: aBuilder.	self initChips.	self reloadSelectionInformation</body><body package="UIPainter">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self setUpVisuals.	self showColors.	(builder componentAt: #saturation) beInvisible.	(builder componentAt: #saturationLabel) beInvisible.	(builder componentAt: #hue) beInvisible.	(builder componentAt: #hueLabel) beInvisible.</body></methods><methods><class-id>Tools.ColorToolModel</class-id> <category>private</category><body package="UIPainter">background	^#(#backgroundChipLabel #backgroundButton #backgroundChip)</body><body package="UIPainter">changedColor	colorValue value saturation = 0					ifTrue: [(builder componentAt: #hue) beInvisible.							(builder componentAt: #hueLabel) beInvisible]					ifFalse: [(builder componentAt: #hue) beVisible.							(builder componentAt: #hueLabel) beVisible].	colorValue value brightness = 0.0					ifTrue: [(builder componentAt: #saturation) beInvisible.							(builder componentAt: #saturationLabel) beInvisible]					ifFalse: [(builder componentAt: #saturation) beVisible.							(builder componentAt: #saturationLabel) beVisible].</body><body package="UIPainter">changedColorName	| cn cv |	cn := colorName value.	cv :=		(#(#foregroundColor #backgroundColor #selectionForegroundColor #selectionBackgroundColor) 				includes: cn)			ifTrue: [lookPreferences perform: cn]			ifFalse: [ColorValue perform: cn].	cv notNil ifTrue: [colorValue value: cv]</body><body package="UIPainter">changedCubesBrightness	cubesBrightness value = 1 ifTrue: [^self].	cubeColors do:		[:v |		| c |		c := v value.		v value: (ColorValue hue: c hue saturation: c saturation brightness: 1.0 - cubesBrightness value)].</body><body package="UIPainter">disableRead	self		disableGroup: #(#foregroundChipLabel #backgroundChipLabel #selectionForegroundChipLabel #selectionBackgroundChipLabel).	self readMode value		ifTrue:			[#(#foregroundChip #backgroundChip #selectionForegroundChip #selectionBackgroundChip)				do:					[:chip |					(builder componentAt: chip) getLookPreferences setBackgroundColor: nil].			#(#setForegroundColor: #setBackgroundColor: #setSelectionForegroundColor: #setSelectionBackgroundColor:)				do:					[:accessor |					lookPreferences perform: accessor with: nil]]</body><body package="UIPainter">enableRead	super enableRead.	self		enableGroup: #(#foregroundChipLabel #backgroundChipLabel #selectionForegroundChipLabel #selectionBackgroundChipLabel)</body><body package="UIPainter">foreground	^#(#foregroundChipLabel #foregroundButton #foregroundChip)</body><body package="UIPainter">hideColorGroup: aSymbol	self vanishGroup: (self perform: aSymbol)</body><body package="UIPainter">initChips	"Set the background colors of the color chips to be some actual	color (not nil) so that when showColors is initially called it will	definitely print 'none' on those chips that wind up having null	colors."	#(#foregroundChip #backgroundChip #selectionForegroundChip #selectionBackgroundChip)		do:			[:chpname |			(builder componentAt: chpname) getLookPreferences setBackgroundColor:				Screen default defaultPaintPreferences backgroundColor]</body><body package="UIPainter">reloadSelectionInformation	propertiesTool selectionKind == #multi		ifTrue: 			[self disableRead.			"self enableApply."]		ifFalse: 			[| selSpec |			selSpec := propertiesTool spec.			selSpec isNil ifTrue: [^self].			self enableRead.			self disableApply.			self showColorSettingsFor: selSpec colorSelections.			readMode value				ifTrue: 					[(lookPreferences := selSpec colors copy) == nil 						ifTrue: [lookPreferences := LookPreferences new].					self showColors]				ifFalse: [self enableApply]].	propertiesTool updateSelectionInTree</body><body package="UIPainter">selectedBackground	^#(#selectionBackgroundChipLabelTop #selectionBackgroundChipLabel #selectionBackgroundButton #selectionBackgroundChip)</body><body package="UIPainter">selectedForeground	^#(#selectionForegroundChipLabelTop #selectionForegroundChipLabel #selectionForegroundButton #selectionForegroundChip)</body><body package="UIPainter">setUpVisuals	|  ext  r c  brightness lead x y sats v cp grays|	(builder componentAt: #foregroundChip) setLookPreferences: LookPreferences new.	(builder componentAt: #backgroundChip)  setLookPreferences:  LookPreferences new.	(builder componentAt: #selectionForegroundChip)  setLookPreferences:  LookPreferences new.	(builder componentAt: #selectionBackgroundChip)  setLookPreferences:  LookPreferences new. 	(builder componentAt: #theActualColor) widget		add: (ColoredArea model: colorValue) in: (0@0 corner: 1@1).	cp := builder componentAt: #colorSpace.	ext := 14.	lead := 2.	grays :=  #(1 0.94 0.86 0.8 0.7 0.6 0.43 0 ).  	"these values are gama corrected using ((i/7)**(1/2.3))and hand edited to overlap with the system"	0 to: 7 do:		[:i |		r := (0@((i)*ext)+ (lead@lead)) extent: ext@ext - (lead@lead).		c := ValueHolder with: (ColorValue brightness: (grays at: i+1)).		v := ColoredArea new.		v controller: ColoredAreaController new.		v model: colorValue.		v select: c.		cp widget add: v in: r].			cubeColors := OrderedCollection new.	brightness := 1.0 - cubesBrightness value.	sats := 8* brightness.	y := 0.	1 to: sats do:		[:s |		|saturation |		saturation := s asFloat / sats.		x := 1.		#(0 30 60 90 120 150 180 210 240 270 300 330) do:			[:h | 			| hue |			hue := h asFloat /360.0.			r := ((x*ext)@(y*ext)+ (lead@lead) + (2@0)) extent: ext@ext - (lead@lead).			c := ValueHolder with: (ColorValue hue: hue saturation: saturation brightness: brightness).			v := ColoredArea new.			v controller: ColoredAreaController new.			v model: colorValue.			v select: c.			cubeColors add: c.			cp widget add: v in: r.			x := x + 1].		y := y + 1].</body><body package="UIPainter">showColorGroup: aSymbol	self reappearGroup: (self perform: aSymbol)</body><body package="UIPainter">showColorSettingsFor: aCollection	aCollection do: [:each | self showColorGroup: each].	#(#foreground #background #selectedForeground #selectedBackground) do: 		[:each | (aCollection includes: each)			ifFalse: [self hideColorGroup: each]]</body><body package="UIPainter">showColors	| button label oldColors |	readMode value ifFalse: [^self].	button := builder componentAt: #foregroundClear.	label := builder componentAt: #colorFGNone.	(oldColors := (builder componentAt: #foregroundChip) getLookPreferences)			backgroundColor ~= lookPreferences foregroundColor		ifTrue:			[oldColors setBackgroundColor: lookPreferences foregroundColor.			lookPreferences foregroundColor isNil				ifTrue: [label labelString: self msgNone]				ifFalse: [					button labelString: self msgClear.					label labelString: '']].	button := builder componentAt: #backgroundClear.	label := builder componentAt: #colorBGNone.	(oldColors := (builder componentAt: #backgroundChip) getLookPreferences)			backgroundColor ~= lookPreferences backgroundColor		ifTrue:			[oldColors setBackgroundColor: lookPreferences backgroundColor.			lookPreferences backgroundColor isNil				ifTrue: [label labelString: self msgNone]				ifFalse: [					button labelString: self msgClear.					label labelString: '']].	button := builder componentAt: #selectionForegroundClear.	label := builder componentAt: #colorSFGNone.	(oldColors := (builder componentAt: #selectionForegroundChip) getLookPreferences)			backgroundColor ~= lookPreferences selectionForegroundColor		ifTrue:			[oldColors setBackgroundColor: lookPreferences selectionForegroundColor.				lookPreferences selectionForegroundColor isNil				ifTrue: [label labelString: self msgNone]				ifFalse: [					button labelString: self msgClear.					label labelString: '']].	button := builder componentAt: #selectionBackgroundClear.	label := builder componentAt: #colorSBGNone.	(oldColors := (builder componentAt: #selectionBackgroundChip) getLookPreferences)			backgroundColor ~= lookPreferences selectionBackgroundColor		ifTrue:			[oldColors setBackgroundColor: lookPreferences selectionBackgroundColor.			lookPreferences selectionBackgroundColor isNil				ifTrue: [label labelString: self msgNone]				ifFalse: [					button labelString: self msgClear.					label labelString: '']]</body></methods><methods><class-id>Tools.ColorToolModel</class-id> <category>aspects</category><body package="UIPainter">brightness	^(PluggableAdaptor on: colorValue)		getBlock: [:m | m value brightness]		putBlock: 			[:m :v | 			m value:				(ColorValue					hue: m value hue					saturation: m value saturation					brightness: v).			v = 0				ifTrue: 					[(self builder componentAt: #saturation) beInvisible.					(self builder componentAt: #saturationLabel) beInvisible]				ifFalse: 					[(self builder componentAt: #saturation) beVisible.					(self builder componentAt: #saturationLabel) beVisible]]		updateBlock: [:m :a :p | true]</body><body package="UIPainter">colorName	^colorName</body><body package="UIPainter">hue	^(PluggableAdaptor on: colorValue)		getBlock: [:m | m value hue]		putBlock:			[:m :v |			m value:				(ColorValue					hue:  v					saturation: m value saturation					brightness: m value brightness)]		updateBlock: [:m :a :p | true].</body><body package="UIPainter">saturation	^(PluggableAdaptor on: colorValue)			getBlock: [:m | m value saturation]			putBlock:					[:m :v |					m value:							(ColorValue							hue: m value hue							saturation:  v							brightness: m value brightness)]			updateBlock: [:m :a :p | true].</body><body package="UIPainter">sliderModel	^cubesBrightness</body></methods><methods><class-id>Tools.ColorToolModel</class-id> <category>actions</category><body package="UIPainter">changeBGColor	| chip button label oldRM |	chip := builder componentAt: #backgroundChip.	button := builder componentAt: #backgroundClear.	label := builder componentAt: #colorBGNone.	lookPreferences backgroundColor == colorValue value		ifFalse: [			lookPreferences setBackgroundColor: colorValue value.			chip getLookPreferences setBackgroundColor: colorValue value.			button labelString: self msgClear.			label labelString: ''].	self enableApply.	oldRM := readMode value.	readMode value: false.	oldRM ifTrue: [self interruptedRead: true]</body><body package="UIPainter">changeFGColor	| chip button label oldRM |	chip := builder componentAt: #foregroundChip.	button := builder componentAt: #foregroundClear.	label := builder componentAt: #colorFGNone.	lookPreferences foregroundColor == colorValue value		ifFalse: [			lookPreferences setForegroundColor: colorValue value.			chip getLookPreferences setBackgroundColor: colorValue value.			button labelString: self msgClear.			label labelString: ''].	self enableApply.	oldRM := readMode value.	readMode value: false.	oldRM ifTrue: [self interruptedRead: true]</body><body package="UIPainter">changeSBGColor	| chip button label oldRM |	chip := builder componentAt: #selectionBackgroundChip.	button := builder componentAt: #selectionBackgroundClear.	label := builder componentAt: #colorSBGNone.	lookPreferences selectionBackgroundColor == colorValue value		ifFalse: [			lookPreferences setSelectionBackgroundColor: colorValue value.			chip getLookPreferences setBackgroundColor: colorValue value.			button labelString: self msgClear.			label labelString: ''].	self enableApply.	oldRM := readMode value.	readMode value: false.	oldRM ifTrue: [self interruptedRead: true]</body><body package="UIPainter">changeSFGColor	| chip button label oldRM |	chip := builder componentAt: #selectionForegroundChip.	button := builder componentAt: #selectionForegroundClear.	label := builder componentAt: #colorSFGNone.	lookPreferences selectionForegroundColor == colorValue value		ifFalse: [			lookPreferences setSelectionForegroundColor: colorValue value.			chip getLookPreferences setBackgroundColor: colorValue value.			button labelString: self msgClear.			label labelString: ''].	self enableApply.	oldRM := readMode value.	readMode value: false.	oldRM ifTrue: [self interruptedRead: true]</body><body package="UIPainter">clearBGColor	| chip button label oldRM |	chip := builder componentAt: #backgroundChip.	button := builder componentAt: #backgroundClear.	label := builder componentAt: #colorBGNone.	lookPreferences setBackgroundColor: nil.	chip getLookPreferences setBackgroundColor: nil.	button labelString: ''.	label labelString: self msgNone.	self enableApply.	oldRM := readMode value.	readMode value: false.	oldRM ifTrue: [self interruptedRead: true]</body><body package="UIPainter">clearFGColor	| chip button label oldRM |	chip := builder componentAt: #foregroundChip.	button := builder componentAt: #foregroundClear.	label := builder componentAt: #colorFGNone.	lookPreferences setForegroundColor: nil.	chip getLookPreferences setBackgroundColor: nil.	button labelString: ''.	label labelString: self msgNone.	self enableApply.	oldRM := readMode value.	readMode value: false.	oldRM ifTrue: [self interruptedRead: true]</body><body package="UIPainter">clearSBGColor	| chip button label oldRM |	chip := builder componentAt: #selectionBackgroundChip.	button := builder componentAt: #selectionBackgroundClear.	label := builder componentAt: #colorSBGNone.	lookPreferences setSelectionBackgroundColor: nil.	chip getLookPreferences setBackgroundColor: nil.	button labelString: ''.	label labelString: self msgNone.	self enableApply.	oldRM := readMode value.	readMode value: false.	oldRM ifTrue: [self interruptedRead: true]</body><body package="UIPainter">clearSFGColor	| chip button label oldRM |	chip := builder componentAt: #selectionForegroundChip.	button := builder componentAt: #selectionForegroundClear.	label := builder componentAt: #colorSFGNone.	lookPreferences setSelectionForegroundColor: nil.	chip getLookPreferences setBackgroundColor: nil.	button labelString: ''.	label labelString: self msgNone.	self enableApply.	oldRM := readMode value.	readMode value: false.	oldRM ifTrue: [self interruptedRead: true]</body><body package="UIPainter">postcancel	self readMode value: true</body><body package="UIPainter">preapply	| lp painterController |	painterController := propertiesTool controller.	painterController == nil ifTrue: [^self].	(lookPreferences backgroundColor isNil 			and: [lookPreferences foregroundColor isNil 			and: [lookPreferences selectionForegroundColor isNil 			and: [lookPreferences selectionBackgroundColor isNil]]])		ifTrue: [lp := nil]		ifFalse: [lp := lookPreferences copy].	propertiesTool selectionKind == #window		ifTrue: 			[| win temp default |			win := painterController sensor window.			lp == nil				ifTrue: [temp := nil]				ifFalse: 					[temp := win lookPreferences copy.					default := win defaultLookPreferences copy.					temp setForegroundColor: (lookPreferences foregroundColor == nil							ifTrue: [default foregroundColor]							ifFalse: [lookPreferences foregroundColor]).					temp setBackgroundColor: (lookPreferences backgroundColor == nil							ifTrue: [default backgroundColor]							ifFalse: [lookPreferences backgroundColor]).					temp setSelectionForegroundColor: (lookPreferences selectionForegroundColor == nil							ifTrue: [default selectionForegroundColor]							ifFalse: [lookPreferences selectionForegroundColor]).					temp setSelectionBackgroundColor: (lookPreferences selectionBackgroundColor == nil							ifTrue: [default selectionBackgroundColor]							ifFalse: [lookPreferences selectionBackgroundColor]).					temp setHiliteColor: nil.					temp setShadowColor: nil].			propertiesTool spec colors: temp.			win lookPreferences: temp]		ifFalse: 			[propertiesTool spec colors: lp.			propertiesTool selection do: [:wrpr | wrpr lookPreferences: lp]].	painterController canvasHasChanged: true.	self interruptedRead ifTrue: [self readMode value: true]</body></methods><methods><class-id>Tools.ColorToolModel</class-id> <category>initialize-release</category><body package="UIPainter">initialize	super initialize.	lookPreferences := LookPreferences new.	colorValue := ValueHolder with: ColorValue black.	colorName := ValueHolder with: String new.	cubesBrightness := 0.0 asValue.	colorValue onChangeSend: #changedColor to: self.	cubesBrightness onChangeSend: #changedCubesBrightness to: self.	colorName onChangeSend: #changedColorName to: self.</body></methods><methods><class-id>Tools.ColorToolModel</class-id> <category>constants</category><body package="UIPainter">msgClear	^#clear &lt;&lt; #UIPainter &gt;&gt; 'clear'.</body><body package="UIPainter">msgNone	^#_none_ &lt;&lt; #UIPainter &gt;&gt; '[none]'.</body></methods><methods><class-id>Tools.ColorToolModel class</class-id> <category>resources</category><body package="UIPainter">colorMenu	| menu list |	menu := self baseColorMenu.	list := ColorValue constantNames collect: [:nm | (ColorValue constantLabelForName: nm) -&gt; nm].	list := (list asSortedCollection: [:m1 :m2 | m1 key asString &lt; m2 key asString]) asArray.	(menu atNameKey: #namedColors)		submenu: (Menu labelArray: (list collect: [:a | a key]) values: (list collect: [:a | a value])).	^menu</body></methods><methods><class-id>UI.MultiSpec</class-id> <category>accessing</category><body package="UIPainter">changeAspect	changeAspect isNil ifTrue: [^false].	^changeAspect</body><body package="UIPainter">changeAspect: aBoolean	changeAspect := aBoolean.	propertiesTool component: #aspectLabel enable: changeAspect.	propertiesTool component: #model enable: changeAspect.</body><body package="UIPainter">changeBorder	changeBorder isNil ifTrue: [^false].	^changeBorder</body><body package="UIPainter">changeBorder: aBoolean	changeBorder := aBoolean.	propertiesTool component: #hasBorder enable: changeBorder.</body><body package="UIPainter">changeDefaultable	changeDefaultable isNil ifTrue: [^false].	^changeDefaultable</body><body package="UIPainter">changeDefaultable: aBoolean	changeDefaultable := aBoolean.	propertiesTool component: #defaultable enable: changeDefaultable.</body><body package="UIPainter">changeDisabled	changeDisabled isNil ifTrue: [^false].	^changeDisabled</body><body package="UIPainter">changeDisabled: aBoolean	changeDisabled := aBoolean.	propertiesTool component: #initiallyDisabled enable: changeDisabled.</body><body package="UIPainter">changeFont	changeFont isNil ifTrue: [^false].	^changeFont</body><body package="UIPainter">changeFont: aBoolean	changeFont := aBoolean.	propertiesTool component: #fontLabel enable: changeFont.	propertiesTool component: #fontMenu enable: changeFont.</body><body package="UIPainter">changeInvisible	changeInvisible isNil ifTrue: [^false].	^changeInvisible</body><body package="UIPainter">changeInvisible: aBoolean	changeInvisible := aBoolean.	propertiesTool component: #initiallyInvisible enable: changeInvisible.</body><body package="UIPainter">changeOpaque	changeOpaque isNil ifTrue: [^false].	^changeOpaque</body><body package="UIPainter">changeOpaque: aBoolean	changeOpaque := aBoolean.	propertiesTool component: #isOpaque enable: changeOpaque.</body><body package="UIPainter">changeTabable	changeTabable isNil ifTrue: [^false].	^changeTabable</body><body package="UIPainter">changeTabable: aBoolean	changeTabable := aBoolean.	propertiesTool component: #tabable enable: changeTabable.</body><body package="UIPainter">defaultable	"Answer the value for defaultable"	^defaultable == nil 		ifTrue: [false]		ifFalse: [defaultable]</body><body package="UIPainter">defaultable: aBoolean	"Answer the value for defaultable"	defaultable := aBoolean.	defaultable ifFalse: [defaultable := nil].</body><body package="UIPainter">extractedSpecFor: implementationComponent	| specComponent |	specComponent := implementationComponent.	[specComponent respondsTo: #spec] whileFalse: [specComponent := specComponent container ifNil:[^nil]].	^specComponent spec extractedSpecFor: implementationComponent</body><body package="UIPainter">propertiesTool: aTool	self initialize.	propertiesTool := aTool</body><body package="UIPainter">style	"Answer the value for style"	^style == nil 		ifTrue: [#default]		ifFalse: [style]</body><body package="UIPainter">style: aValue	"Set the value for style"	style := aValue.	style == #default ifTrue: [style := nil].</body></methods><methods><class-id>UI.MultiSpec</class-id> <category>initialize-release</category><body package="UIPainter">initialize	changeAspect := changeFont := changeBorder := changeOpaque := changeTabable := changeDefaultable := changeDisabled := changeInvisible := false</body></methods><methods><class-id>UI.MultiSpec</class-id> <category>property transfer</category><body package="UIPainter">copyPropertiesTo: aSpec	(self changeAspect and: [aSpec respondsTo: #model:]) ifTrue: [aSpec model: self model].	(self changeFont and: [aSpec respondsTo: #style:]) ifTrue: [aSpec style: self style].	(self changeBorder and: [aSpec respondsTo: #hasBorder]) ifTrue: [aSpec hasBorder: self hasBorder].	(self changeOpaque and: [aSpec respondsTo: #isOpaque:]) ifTrue: [aSpec isOpaque: self isOpaque].	(self changeTabable and: [aSpec respondsTo: #tabable:]) ifTrue: [aSpec tabable: self tabable].	(self changeDefaultable and: [aSpec respondsTo: #defaultable:]) ifTrue: [aSpec defaultable: self defaultable].	(self changeDisabled and: [aSpec respondsTo: #initiallyDisabled:]) ifTrue: [aSpec initiallyDisabled: self initiallyDisabled].	(self changeInvisible and: [aSpec respondsTo: #initiallyInvisible:]) ifTrue: [aSpec initiallyInvisible: self initiallyInvisible].</body></methods><methods><class-id>UI.MultiSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel.	inst propertiesTool: (env at: #propertiesTool).	env at: #style put: (self adapt: inst forAspect: #style channel: aChannel).	env at: #defaultable put: (self adapt: inst forAspect: #defaultable channel: aChannel).	env at: #changeAspect put: (self adapt: inst forAspect: #changeAspect channel: aChannel).	env at: #changeFont put: (self adapt: inst forAspect: #changeFont channel: aChannel).	env at: #changeBorder put: (self adapt: inst forAspect: #changeBorder channel: aChannel).	env at: #changeOpaque put: (self adapt: inst forAspect: #changeOpaque channel: aChannel).	env at: #changeTabable put: (self adapt: inst forAspect: #changeTabable channel: aChannel).	env at: #changeDefaultable put: (self adapt: inst forAspect: #changeDefaultable channel: aChannel).	env at: #changeDisabled put: (self adapt: inst forAspect: #changeDisabled channel: aChannel).	env at: #changeInvisible put: (self adapt: inst forAspect: #changeInvisible channel: aChannel).	env at: #fontMenu put: self fontMenu.</body><body package="UIPainter">componentName	"Identification of component"	^(#MultipleSelection &lt;&lt; #UIPainter &gt;&gt; 'Multiple Selection') asString</body></methods><methods><class-id>UI.MultiSpec class</class-id> <category>property slices</category><body package="UIPainter">dropTargetSlice	"Empty array means no page!"	^#(1 #())</body><body package="UIPainter">notificationSlice	"Empty array means no page!"	^#(1 #())</body><body package="UIPainter">validationSlice	"Empty array means no page!"	^#(1 #())</body></methods><methods><class-id>Tools.UISpecificationTreeModel</class-id> <category>initialize-release</category><body package="UIPainter">setFullSpec: aSpec	fullSpec := aSpec.	self root: aSpec window.	self childrenBlock: [:each | (each isKindOf: WindowSpec)		ifTrue: [fullSpec component collection]		ifFalse: [(each isKindOf: SpecCollection)			ifTrue: [each collection ]			ifFalse: [#()]]]</body></methods><methods><class-id>Tools.UISpecificationTreeModel class</class-id> <category>initialize-release</category><body package="UIPainter">onClass: aClass selector: aSymbol	^self onSpec: (aClass perform: aSymbol) decodeAsLiteralArray</body><body package="UIPainter">onSpec: aFullSpec	^self new setFullSpec: aFullSpec</body></methods><methods><class-id>Tools.ColumnReorderTracker</class-id> <category>private</category><body package="UIPainter">finishSelectionFor: aPoint	self controller selectUpAt: aPoint.	self controller unlockCallBacks.	oldCursor show.</body><body package="UIPainter">setUpFor: aMouseButtonEvent	oldCursor := Cursor currentCursor.	self controller adjustmentCursor show.</body><body package="UIPainter">trackSelectionFor: aPoint	self controller mouseMovedTo: aPoint.</body></methods><methods><class-id>Tools.ColumnReorderTracker</class-id> <category>events</category><body package="UIPainter">redButtonPressedEvent: aMouseButtonEvent	controller lockCallBacks.	super redButtonPressedEvent: aMouseButtonEvent</body></methods><methods><class-id>Tools.ColorBitView</class-id> <category>displaying</category><body package="UIPainter">defaultControllerClass	^ColorBitEditor</body></methods><methods><class-id>UI.HelpConstructor</class-id> <category>aspects</category><body package="UIPainter">fieldMenu	^fieldMenuBlock value</body><body package="UIPainter">helpCatalog	^(PluggableAdaptor on: self)		getSelector: #helpLabelCatalog		putSelector: #helpLabelCatalog:</body><body package="UIPainter">helpLabelKey	^(PluggableAdaptor on: self)		getSelector: #helpLabelKeyID		putSelector: #helpLabelKeyID:</body><body package="UIPainter">helpLabelMessage	^(PluggableAdaptor on: self)		getSelector: #helpLabelMessageSelector		putSelector: #helpLabelMessageSelector:</body><body package="UIPainter">helpLabelString	^(PluggableAdaptor on: self)		getSelector: #helpLabelDefaultString		putSelector: #helpLabelDefaultString:</body><body package="UIPainter">helpSuppliedByBuilder	helpSuppliedByBuilder == nil		ifTrue:			[helpSuppliedByBuilder := parentBuilderBlock value aspectAt: #helpLabelIsMessage.			helpSuppliedByBuilder == nil ifTrue: [helpSuppliedByBuilder := false asValue].			helpSuppliedByBuilder onChangeSend: #changedDynamicMode to: self].	^helpSuppliedByBuilder</body><body package="UIPainter">helpText	^TypeConverter onStringOrSymbolValue:		((PluggableAdaptor on: self)			getSelector: #simpleLabel			putSelector: #simpleLabel:)</body></methods><methods><class-id>UI.HelpConstructor</class-id> <category>accessing</category><body package="UIPainter">helpLabelCatalog	^Object messageNotUnderstoodSignal		handle: [:ex | ex returnWith: nil]		do: [helpLabeledValueHolder value helpText catalogID]</body><body package="UIPainter">helpLabelCatalog: aSymbol 	| labelThing |	self helpSuppliedByBuilder value ifTrue: [^self].	aSymbol == nil 		ifTrue: [helpLabeledValueHolder value helpText: self helpLabelDefaultString] 		ifFalse: 			[labelThing := helpLabeledValueHolder value helpText.			helpLabeledValueHolder value 				helpText: ((labelThing isString or: [labelThing == nil]) 						ifTrue: 							[(UserMessage new)								defaultString: labelThing;								catalogID: aSymbol;								yourself]						ifFalse: [labelThing copy &lt;&lt; aSymbol])].	 	self changed: #value</body><body package="UIPainter">helpLabelDefaultString	| labelThing |	labelThing := helpLabeledValueHolder value helpText.	^(labelThing isSymbol or: [labelThing == nil])		ifTrue: [nil]		ifFalse: [labelThing isString				ifTrue: [labelThing]				ifFalse: [labelThing defaultString]]</body><body package="UIPainter">helpLabelDefaultString: aString 	| labelThing |	self helpSuppliedByBuilder value ifTrue: [^self].	labelThing := helpLabeledValueHolder value helpText.	helpLabeledValueHolder value 		helpText: ((labelThing isString or: [labelThing == nil]) 				ifTrue: [aString]				ifFalse: [labelThing copy &gt;&gt; aString]).	self changed: #value</body><body package="UIPainter">helpLabelKeyID	^Object messageNotUnderstoodSignal		handle: [:ex | ex returnWith: nil]		do: [helpLabeledValueHolder value helpText key]</body><body package="UIPainter">helpLabelKeyID: aSymbol 	| labelThing |	self helpSuppliedByBuilder value ifTrue: [^self].	aSymbol == nil 		ifTrue: [helpLabeledValueHolder value helpText: self helpLabelDefaultString]		ifFalse: 			[labelThing := helpLabeledValueHolder value helpText.			helpLabeledValueHolder value 				helpText: ((labelThing isString or: [labelThing == nil]) 						ifTrue: [aSymbol &gt;&gt; labelThing]						ifFalse: [labelThing copy key: aSymbol])].	self changed: #value</body><body package="UIPainter">helpLabelMessageSelector	| labelThing |	labelThing := helpLabeledValueHolder value helpText.	^labelThing isSymbol		ifTrue: [labelThing]		ifFalse: [nil]</body><body package="UIPainter">helpLabelMessageSelector: aSymbol	self helpSuppliedByBuilder value ifFalse: [^self].	aSymbol == nil		ifTrue: [helpLabeledValueHolder value helpText: nil]		ifFalse: [helpLabeledValueHolder value helpText: aSymbol asSymbol].	self changed: #value</body><body package="UIPainter">labelDefaultString	| labelThing |	labelThing := helpLabeledValueHolder value label.	^(labelThing isSymbol or: [labelThing == nil])		ifTrue: [nil]		ifFalse: [labelThing isString				ifTrue: [labelThing]				ifFalse: [labelThing defaultString]]</body><body package="UIPainter">simpleLabel	^helpLabeledValueHolder value helpText</body><body package="UIPainter">simpleLabel: newLabel	^helpLabeledValueHolder value helpText: newLabel</body></methods><methods><class-id>UI.HelpConstructor</class-id> <category>initialize-release</category><body package="UIPainter">on: aValueHolder	helpLabeledValueHolder := aValueHolder.	helpLabeledValueHolder onChangeSend: #flushFields to: self</body><body package="UIPainter">parentBuilderBlock: builderBlock fieldMenuBlock: menuBlock 	parentBuilderBlock := builderBlock.	fieldMenuBlock := menuBlock.	self setDropTargets</body></methods><methods><class-id>UI.HelpConstructor</class-id> <category>private</category><body package="UIPainter">changedDynamicMode	| dynamic comp |	dynamic := helpSuppliedByBuilder value.	#(#helpMessageLbl #helpMessage) do: 			[:key |			(comp := builder componentAt: key) == nil				ifFalse: [comp isEnabled: dynamic]].	self updatedLabelAsMessage.	#(#helpDefaultLbl #helpDefault) do: 			[:key |			(comp := builder componentAt: key) == nil				ifFalse: [comp isEnabled: dynamic not]].	#(#helpLookupLbl #helpCatalogLbl #helpLabel #helpCatalog) do: 			[:key |			(comp := builder componentAt: key) == nil				ifFalse: [comp isEnabled: dynamic not]].	(parentBuilderBlock value aspectAt: #propertiesTool) showModifiedState</body><body package="UIPainter">flushFields	self changed: #value.	helpSuppliedByBuilder changed: #value</body><body package="UIPainter">postBuildWith: aBuilder	self changedDynamicMode</body><body package="UIPainter">updatedLabelAsMessage	| labelValue messageValue |	labelValue := self helpLabelString value.	labelValue ifNil: [labelValue := String new].	messageValue := self helpLabelMessage value.	messageValue ifNil: [messageValue := Symbol new].	self helpSuppliedByBuilder value		ifTrue: 			[(messageValue isEmpty and: [labelValue isEmpty not]) ifTrue: 				[self helpLabelMessage value: labelValue asSymbol.				self helpLabelString value: nil]]		ifFalse: 			[(labelValue isEmpty and: [messageValue isEmpty not]) 	ifTrue: 				[self helpLabelString value: messageValue asString.				self helpLabelMessage value: nil]]</body></methods><methods><class-id>Tools.DirectBitView</class-id> <category>displaying</category><body package="UIPainter">displayOn: aGraphicsContext	model notNil ifTrue: [model displayOn: aGraphicsContext]</body><body package="UIPainter">model: aModel	super model: aModel.	policy := OrderedDither new.</body><body package="UIPainter">update: aSymbol with: aRect 	aSymbol = #invalidate ifTrue: 		[| pixel paint |		aRect left to: aRect right - 1 do:			[:x |			aRect top to: aRect bottom - 1 do: 				[:y | 				pixel := model atPoint: x @ y.				paint := policy					renderPaint: (model palette at: pixel)						usingPalette: self topComponent palette						on: self topComponent graphicsDevice].				(self graphicsContext) setDevicePattern: paint; displayRectangle: aRect]]</body></methods><methods><class-id>Tools.DirectBitView</class-id> <category>bounds accessing</category><body package="UIPainter">preferredExtent	^model preferredExtent</body></methods><methods><class-id>Tools.UIPainterView</class-id> <category>moving</category><body package="UIPainter">changeExtent: aWrapper by: offsetPoint	"Modify the extent of the bounds of aWrapper by offsetPoint."	self setExtent: aWrapper to: aWrapper bounds extent + offsetPoint</body><body package="UIPainter">changeOrigin: aWrapper by: offsetPoint	"Modify the origin of the bounds of aWrapper by offsetPoint."	self setOrigin: aWrapper to: aWrapper bounds origin + offsetPoint</body><body package="UIPainter">setExtent: aWrapper to: aPoint	"Set the extent of the bounds of aWrapper to be aPoint."	| old |	old := aWrapper bounds.	self newBounds: (old origin extent: aPoint) oldBounds: old forWrapper: aWrapper</body><body package="UIPainter">setOrigin: aWrapper to: aPoint	"Set the origin of the bounds of aWrapper to be aPoint."	| old |	old := aWrapper bounds.	self newBounds: (aPoint corner: old corner) oldBounds: old forWrapper: aWrapper</body></methods><methods><class-id>Tools.UIPainterView</class-id> <category>private</category><body package="UIPainter">addHandleCollection: aCollection	aCollection do: [ :each |		components addLast: each.		each container: self.	].	self invalidateLayout</body><body package="UIPainter">handlerForMouseEvent: anEvent	^controller</body><body package="UIPainter">isModalDialog	^false</body><body package="UIPainter">newBounds: newBounds oldBounds: oldBounds forWrapper: aWrapper	aWrapper newBounds: newBounds containingBounds: aWrapper container bounds.	(newBounds intersects: oldBounds)		ifTrue: [self invalidateRectangle: (newBounds merge: oldBounds)]		ifFalse: [self invalidateRectangle: oldBounds.				self invalidateRectangle: newBounds]</body><body package="UIPainter">okToQuitWithChanges	| choice |	choice := Dialog 				choose: (#GenKey152 &lt;&lt; #UIPainter &gt;&gt; 'This canvas has been changed. Install the changes?')				labels: (Array with: (#Yes &lt;&lt; #UIPainter &gt;&gt; 'Yes') with: (#No &lt;&lt; #UIPainter &gt;&gt; 'No') with: (#Cancel &lt;&lt; #UIPainter &gt;&gt; 'Cancel'))				values: #(#yes #no #cancel)				default: #yes.	choice = #cancel ifTrue: [^false].	choice = #yes ifTrue: [(model installFor: controller) ifNil: [^false]].	^true</body><body package="UIPainter">removeComponent: aVisualComponent	"Remove aVisualComponent from the receiver's components (which may be in a composite).	Redisplay the canvas"	| path |	(path := self indexedPath: aVisualComponent) isNil ifTrue: [^self error: (#noSuchElement &lt;&lt; #UIPainter &gt;&gt; 'no such element')].	self removeComponent: aVisualComponent atPath: path.	aVisualComponent container: nil.	self invalidate.	^aVisualComponent</body><body package="UIPainter">removeHandleCollection: aCollection 	aCollection do: [ :each |		components remove: each.		each container: nil.	].	self invalidateLayout</body><body package="UIPainter">sensor	^self topComponent sensor</body><body package="UIPainter">toVisualBack: aCollection 	aCollection reverse do: 			[:each | 			(self indexedPath: each) ifNotNil: 					[:path | 					self removeComponent: each atPath: path.					self addComponent: each firstInPath: path.					each invalidate]]</body><body package="UIPainter">toVisualBackOneNotch: aCollection 	aCollection do: 			[:each | 			(self indexedPath: each) ifNotNil: 					[:path | 					path last = 1 ifTrue: [^self].					self removeComponent: each atPath: path.					path addLast: path removeLast - 1.					self addComponent: each atPath: path.					each invalidate]]</body><body package="UIPainter">toVisualFront: aCollection 	aCollection do: 			[:each | 			(self indexedPath: each) ifNotNil: 					[:path | 					self removeComponent: each atPath: path.					self addComponent: each lastInPath: path.					each invalidate]]</body><body package="UIPainter">toVisualFrontOneNotch: aCollection 	aCollection reverse do: 			[:each | 			(self indexedPath: each) ifNotNil: 					[:path | 					path last = components size ifTrue:[^self].					self removeComponent: each atPath: path.					path addLast: path removeLast + 1.					self addComponent: each atPath: path.					each invalidate]]</body></methods><methods><class-id>Tools.UIPainterView</class-id> <category>updating</category><body package="UIPainter">update: anAspectSymbol with: aParameter from: aSender	(anAspectSymbol = #windowState and: [aParameter key = #close])		ifTrue: [controller notifyEmptyTree].	super update: anAspectSymbol with: aParameter from: aSender</body><body package="UIPainter">updateRequest	"Answer regarding whether the receiver may change (most typically: whether the interface of which it is a part may close.)"	^self controller updateRequest or: [self okToQuitWithChanges]</body></methods><methods><class-id>Tools.UIPainterView</class-id> <category>accessing</category><body package="UIPainter">specComponents	"answer the receiver's components which are wrapped with a SpecWrapper."	^components select: [:c | c isKindOf: SpecWrapper]</body></methods><methods><class-id>Tools.UIPainterView class</class-id> <category>resources</category><body package="UIPainter">inactiveMask	InactiveMask isNil ifTrue: [self initializeActiveMask].	^InactiveMask.</body></methods><methods><class-id>Tools.UIPainterView class</class-id> <category>class initialization</category><body package="UIPainter">initializeActiveMask	"UIPainterView initializeActiveMask"	| m gc mask |	m := Mask extent: 100@100.	gc := m graphicsContext.	mask := self inactiveCell.	0 to: 100 by: 5 do: [ :x |		0 to: 100 by: 5 do: [ :y |			mask displayOn: gc at: x@y		]	].	InactiveMask := CachedImage on: (m asImage).</body></methods><methods><class-id>Tools.UIHotRegionEditor</class-id> <category>private - interface updating</category><body package="UIPainter">disableApply	"Disable Apply menu item"	(menuBar atNameKey: #applyRegions) disable</body><body package="UIPainter">disableForEmptyRegions	(menuBar atNameKey: #newSlice) disable.	(menuBar atNameKey: #showAllSlices) disable.	self disableToInstallRegions.</body><body package="UIPainter">disableForSelectedSlice	| menu |	menu := self builder menuAt: #mainMenuBar.	(menu atNameKey: #clearSlice) disable.	(menu atNameKey: #deleteSlice) disable.	(self builder componentAt: #paintControls) disable. 	(self builder componentAt: #selectorField) disable. 	(self builder componentAt: #selectorLabel) disable.</body><body package="UIPainter">disableRead	"Disable Read menu item"	(menuBar atNameKey: #readRegions) disable</body><body package="UIPainter">disableToInstallRegions	self disableApply.	(menuBar atNameKey: #installRegions) disable.</body><body package="UIPainter">enableApply	"Enable Apply menu item"	(menuBar atNameKey: #applyRegions) enable</body><body package="UIPainter">enableForBackdrop	(self hotRegions regionsImage isNil or: 	[self hotRegions regionsImage extent ~= self regionsView backdrop extent]) 		ifTrue: [			self hotRegions adoptExtent: self regionsView backdrop extent.			self modified.		]. 	self enableForValidLoadedRegions.	self reloadSelectionInformation.</body><body package="UIPainter">enableForSelectedSlice	| menu |	menu := self builder menuAt: #mainMenuBar.	(menu atNameKey: #clearSlice) enable.	(menu atNameKey: #deleteSlice) enable.	(self builder componentAt: #paintControls) enable. 	(self builder componentAt: #selectorField) enable. 	(self builder componentAt: #selectorLabel) enable.</body><body package="UIPainter">enableForValidLoadedRegions	(menuBar atNameKey: #newSlice) enable.	(menuBar atNameKey: #showAllSlices) enable.	(menuBar atNameKey: #installRegions) enable.</body><body package="UIPainter">enableRead	"Enable Read menu item"	(menuBar atNameKey: #readRegions) enable</body><body package="UIPainter">enableToInstallRegions	self enableApply.	(menuBar atNameKey: #installRegions) enable.</body><body package="UIPainter">reloadSelectionInformation	| sel controller |	controller := selectionHolder value.	controller == nil		ifTrue: 			[self disableRead; disableApply.			^self].	sel := controller selectionList.	(sel size = 0 or: [sel size &gt; 1])		ifTrue:			[self disableRead; disableApply.			^self].	(sel first spec isKindOf: MappedClickWidgetSpec)		ifTrue: [self enableApply]		ifFalse: [^self disableApply; disableRead].	(sel first spec mappingsSelector notNil or: [sel first spec visualSelector notNil])		ifTrue: [self enableRead]		ifFalse: [self disableRead]</body><body package="UIPainter">updateSlicesMenu	(self builder menuAt: #sliceMenu) value: self menuFromSlicesList</body><body package="UIPainter">updateToggleButton	| button |	button := self builder componentAt: #toggleButton.	self regionsView controller coveragePaint == (CoverageValue opaque)		ifTrue: [button widgetState colors setBackgroundColor: self regionsView onPaint.				button label: nil.]		ifFalse: [button widgetState colors setBackgroundColor: ColorValue white.				button labelString: (#clear &lt;&lt; #UIPainter &gt;&gt; 'clear').].	button invalidate.</body></methods><methods><class-id>Tools.UIHotRegionEditor</class-id> <category>private</category><body package="UIPainter">adoptBackdrop: aVisual	| pm |	pm := Pixmap extent: aVisual bounds extent.	aVisual displayOn: pm graphicsContext.	self regionsView backdrop: (CachedImage on: pm asImage). 	self enableForBackdrop.</body><body package="UIPainter">changedSelection	Cursor wait showWhile: [		self finishCurrentSlice.		currentSlice := self selectedSliceChannel value. 		self setupForNewCurrentSlice.	].</body><body package="UIPainter">edittedSelector	| mi menuButton |	mi := ((self builder menuAt: #sliceMenu) value menuItemWithValue: currentSlice ifNone: nil).	mi isNil ifTrue: [^self].	mi label: currentSlice selector printString.	menuButton := (self builder componentAt: #sliceMenu) widget.	menuButton setLabel: menuButton currentChoice.	menuButton invalidate.	hotRegions regionsSelectors at: currentSlice index put: currentSlice selector</body><body package="UIPainter">finishCurrentSlice	currentSlice isNil ifTrue: [^self].	(self regionsView controller isDirty) ifTrue: [		currentSlice mask: (self regionsView controller editMask asImage).		currentSlice install.		self modified. 	].	currentSlice mask: nil.</body><body package="UIPainter">menuFromSlicesList	| mb |	mb := MenuBuilder new.	slicesList do: [ :slice |		mb add: slice selector printString -&gt; slice	]. 	^mb menu</body><body package="UIPainter">setPaint: aPaint	self regionsView onPaint: aPaint.	self regionsView controller coveragePaint: CoverageValue opaque. 	self regionsView invalidate.	self updateToggleButton.</body><body package="UIPainter">setupForNewCurrentSlice	currentSlice isNil ifTrue: [		self disableForSelectedSlice.		self regionsView model: nil.		^self. 	]. 	self enableForSelectedSlice.	self regionsView model: 	currentSlice mask.</body></methods><methods><class-id>Tools.UIHotRegionEditor</class-id> <category>accessing</category><body package="UIPainter">currentSlice	^currentSlice</body><body package="UIPainter">currentSlice: aValue	currentSlice := aValue</body><body package="UIPainter">hotRegions	^hotRegions</body><body package="UIPainter">hotRegions: aValue	hotRegions := aValue</body><body package="UIPainter">slicesList	^slicesList</body><body package="UIPainter">slicesList: aValue	slicesList := aValue</body><body package="UIPainter">targetClass	(targetClass notNil and: [targetClass isObsolete])		ifTrue:			[targetClass := nil].	^targetClass</body><body package="UIPainter">targetClass: aClass selector: aSelector	targetClass := aClass.	targetSelector := aSelector</body><body package="UIPainter">targetSelector	^targetSelector</body></methods><methods><class-id>Tools.UIHotRegionEditor</class-id> <category>actions</category><body package="UIPainter">applyRegions	| controller sels spec mappingSymbol |	(controller := selectionHolder value) isNil ifTrue: [^self].	sels := controller selections.	spec := sels first spec.	mappingSymbol := spec mappingsSelector.	mappingSymbol notNil 	ifTrue: [		mappingSymbol := mappingSymbol asSymbol.	].	self targetClass: controller model targetClass selector: mappingSymbol.	"install the mappings on the target class - user can change selector"	self installRegions. 	(targetClass notNil and: [targetSelector notNil])	ifTrue: [		"set the mapping of the spec to be what was just installed"		spec mappingsSelector: self targetSelector asSymbol.		self targetSelector ~~ mappingSymbol			ifTrue: [				"replaceElement:etc. will cause change to be noted, 				and select: will cause UIPainterWatchers to be alerted"				controller broadcastPendingSelectionChange.				controller select: (controller replaceElement: sels first  basedOnSpec: spec)			]	"selector has changed"	].	"class and selector not nil"</body><body package="UIPainter">blackOn	self setPaint: ColorValue black.</body><body package="UIPainter">clearSlice	self regionsView controller clearMask.</body><body package="UIPainter">deleteSlice	(Dialog confirm: (#GenKey102 &lt;&lt; #UIPainter &gt;&gt; 'Are you sure you want to delete this slice?'))		ifFalse: [^self].	slicesList remove: currentSlice.	hotRegions deleteSliceAtIndex: currentSlice index.	self selectedSliceChannel value: nil.	self updateSlicesMenu.	self slicesList isEmpty ifTrue: [self disableToInstallRegions]</body><body package="UIPainter">installRegions	self finishCurrentSlice.	hotRegions compress.	self initializeFromRegions: hotRegions.	(self targetTrouble or:		[(UIPainter preferenceFor: #avoidInstallationDialog) not or:				[builder window sensor shiftDown]])		ifTrue:			[self runInstallationDialog isNil				ifTrue: [^nil]].	self installInSystem</body><body package="UIPainter">loadBackdrop	|  result backdrop |	result := (ResourceInstallDialog new)				targetClass: self targetClass;				resourceType: #image;				loadSelect.	result ifNil: [^self].	self finishCurrentSlice.	self selectedSliceChannel value: nil.  	backdrop := result implementingClass componentFor: result selector.	backdrop == nil		ifTrue: [backdrop := View new].	(backdrop isKindOf: VisualComponent)		ifFalse: 			[Dialog warn: (#GenKey104 &lt;&lt; #UIPainter &gt;&gt; 'The method did not return a visual') for: builder window.			^self].	self adoptBackdrop: backdrop.</body><body package="UIPainter">loadRegions	| regions result |	self changeRequest ifFalse: [^self].	result := (ResourceInstallDialog new)				targetClass: ResourceInstallDialog;				resourceType: #hotRegions;				loadSelect.	result ifNil: [^self].	self targetClass: result implementingClass selector: result selector.	regions := nil.	self messageNotUnderstoodSignal		handle: 			[:ex |			ex parameter selector == self targetSelector				ifTrue: [ex return]				ifFalse: [ex reject]]		from: self targetClass		do: [regions := self targetClass perform: self targetSelector].	(regions isNil or: [(regions isKindOf: (Smalltalk at: #HotRegions)) not])		ifTrue: 			[Dialog warn: #GenKey105 &lt;&lt; #UIPainter						&gt;&gt; 'The method did not return an instance of HotRegions'				for: builder window.			^self].	self initializeFromRegions: regions</body><body package="UIPainter">newRegions	self changeRequest		ifTrue: 			[self targetClass: nil selector: nil.			self regionsView backdrop: nil.			self initializeFromRegions: HotRegions new.			self disableForEmptyRegions]</body><body package="UIPainter">newSlice	| slice |	slice := self hotRegions newSlice.	slicesList add: slice. 	self updateSlicesMenu. 	self selectedSliceChannel value: slice.	self enableToInstallRegions.</body><body package="UIPainter">readRegions	| spec controller regions backdrop |	(controller := selectionHolder value) isNil ifTrue: [^self].	self changeRequest ifFalse: [^self].	controller := selectionHolder value.	spec := controller selections first spec.	(spec isKindOf: MappedClickWidgetSpec) ifFalse: [^self]. 	(spec visualSelector isNil or: [		(backdrop := controller builder arbitraryComponentAt: spec visualSelector) isNil])			ifTrue:				[^Dialog warn: (#GenKey108 &lt;&lt; #UIPainter &gt;&gt; 'The selected component''s propertiesdon''t specify a visual backdrop') for: builder window.]. 	spec mappingsSelector isNil		ifTrue:			[^Dialog warn: (#GenKey107 &lt;&lt; #UIPainter &gt;&gt; 'The selected component''s propertiesdon''t specify an instance of HotRegions') for: builder window.]		ifFalse:			[regions := controller builder mappingsAt: spec mappingsSelector].	(regions isNil or: [(regions isKindOf: (Smalltalk at:#HotRegions)) not])		ifTrue:			[regions := (Smalltalk at:#HotRegions) new. ].	self initializeFromRegions: regions.	self adoptBackdrop: backdrop. 	self targetClass: controller builder source selector: spec mappingsSelector.</body><body package="UIPainter">redOn	self setPaint: ColorValue red.</body><body package="UIPainter">showAllSlices	self finishCurrentSlice.	self selectedSliceChannel value: nil.	self regionsView controller mode: nil; brush: nil; model: hotRegions compositeOfAllSlices.	self regionsView invalidate.</body><body package="UIPainter">toggleCoverage	self regionsView controller coveragePaint == CoverageValue opaque		ifTrue: [ self regionsView controller coveragePaint: CoverageValue transparent ]		ifFalse: [  self regionsView controller coveragePaint: CoverageValue opaque ].	self updateToggleButton.</body><body package="UIPainter">undoEdit	self regionsView controller undo</body><body package="UIPainter">whiteOn	self setPaint: ColorValue white.</body><body package="UIPainter">zebraOn	self setPaint: self class zebraPattern.</body></methods><methods><class-id>Tools.UIHotRegionEditor</class-id> <category>resources</category><body package="UIPainter">mainMenuBar	menuBar := self class mainMenuBar.	^menuBar.</body></methods><methods><class-id>Tools.UIHotRegionEditor</class-id> <category>private - painter watcher</category><body package="UIPainter">changeRequest	^super changeRequest		and: [(modified and: [hotRegions notNil])			ifTrue: [Dialog confirm: (#GenKey101 &lt;&lt; #UIPainter &gt;&gt; 'The regions have been altered, but not installed.Do you wish to discard the changes?') for: builder window]			ifFalse: [true]]</body><body package="UIPainter">initializeFromRegions: aHotRegions	| menuButton |	modified := false.	hotRegions := aHotRegions.	self slicesList: hotRegions allSlices.	self selectedSliceChannel value: nil.	self updateSlicesMenu. 	menuButton := (self builder componentAt: #sliceMenu) widget.	menuButton setLabel: menuButton currentChoice.	menuButton invalidate.	self enableForValidLoadedRegions.</body><body package="UIPainter">installInSystem	| class s |	class := self targetClass class.	s := (String new: 100) writeStream.	s nextPutAll: self targetSelector; cr.	"Put in a nice comment for re-opening the painter."	s tab;		nextPutAll: ('"&lt;1s&gt; new openOnClass: self andSelector: #' expandMacrosWith: self class fullName);		nextPutAll: self targetSelector; nextPut: $"; cr;		crtab; nextPutAll: '&lt;resource: #hotRegions&gt;';		crtab; nextPutAll: '^HotRegions selectorArray: '; cr;		nextPutAll: hotRegions regionsSelectors storeString;		nextPutAll: ' copy '; cr; 		nextPutAll: ' mapImage: '; cr;		nextPutAll: hotRegions regionsImage storeString; cr.	class compile: s contents classified: #'resources'.	Transcript cr; show: ((#x1s2sDefined &lt;&lt; #UIPainter &gt;&gt; '&lt;1s&gt;%&gt;&lt;2s&gt; defined')			expandMacrosWith: self targetClass class name			with: self targetSelector).	UIFinderVW2 installed: (Array with: self targetClass with: self targetSelector).	modified := false</body><body package="UIPainter">modified	modified := true</body><body package="UIPainter">runInstallationDialog	^((ResourceInstallDialog new)		targetClass: self targetClass;		selector: self targetSelector;		resourceType: #hotRegions;		select)			ifNotNil: 				[:definition |				self targetClass: definition implementingClass					selector: definition selector]</body><body package="UIPainter">targetTrouble	| tgtClass tgtSelector |	^(tgtClass := self targetClass) isNil or:		[(tgtSelector := self targetSelector) isNil or:			[(tgtClass respondsTo: tgtSelector) not]]</body></methods><methods><class-id>Tools.UIHotRegionEditor</class-id> <category>views</category><body package="UIPainter">regionsView	^hotRegionView isNil ifTrue: [hotRegionView := (MaskPainterView new)]		ifFalse: [hotRegionView]</body></methods><methods><class-id>Tools.UIHotRegionEditor</class-id> <category>aspects</category><body package="UIPainter">brushAdaptor	^brushAdaptor isNil		ifTrue:			[brushAdaptor := (AspectAdaptor forAspect: #brush) subject: self regionsView controller ]		ifFalse:			[brushAdaptor]</body><body package="UIPainter">modeAdaptor	^modeAdaptor isNil		ifTrue:			[modeAdaptor := (AspectAdaptor forAspect: #mode) subject: self regionsView controller ]		ifFalse:			[modeAdaptor]</body><body package="UIPainter">selectedSliceChannel	^selectedSliceChannel isNil		ifTrue:			[selectedSliceChannel := nil asValue ]		ifFalse:			[selectedSliceChannel]</body><body package="UIPainter">selectorAdaptor	^selectorAdaptor isNil		ifTrue:			[selectorAdaptor := (AspectAdaptor forAspect: #selector) subjectChannel: self selectedSliceChannel ]		ifFalse:			[selectorAdaptor]</body></methods><methods><class-id>Tools.UIHotRegionEditor</class-id> <category>interface opening</category><body package="UIPainter">openOnClass: aClass andSelector: aSelector 	aSelector isNil ifFalse: [aSelector numArgs = 0			ifFalse: 				[Dialog warn: (#GenKey106 &lt;&lt; #UIPainter &gt;&gt; 'The method did not return a mapping') for: builder window.				^self]].	self targetClass: aClass selector: aSelector.	UIFinderVW2 visited: (Array with: aClass with: aSelector).	self open.	aSelector isNil ifFalse: [self initializeFromRegions: (aClass perform: aSelector)]</body><body package="UIPainter">postBuildWith: aBuilder 	| dummySpec |	super postBuildWith: aBuilder.	(aBuilder componentAt: #zebraOnButton)		setLookPreferences: ((aBuilder componentAt: #zebraOnButton) widget lookPreferences setBackgroundColor: self class zebraPattern).	(aBuilder componentAt: #toggleButton)		setLookPreferences: ((aBuilder componentAt: #toggleButton) widget lookPreferences setBackgroundColor: ColorValue red).	dummySpec := RadioButtonSpec new.	(aBuilder componentAt: #rectangleButton) widget model: (dummySpec adapt: self modeAdaptor select: #rectangle).	(aBuilder componentAt: #ellipseButton) widget model: (dummySpec adapt: self modeAdaptor select: #ellipse).	(aBuilder componentAt: #fillButton) widget model: (dummySpec adapt: self modeAdaptor select: #fill).	(aBuilder componentAt: #smallHorizButton) widget model: (dummySpec adapt: self brushAdaptor select: (aBuilder visualAt: #smallHorizBrush)).	(aBuilder componentAt: #smallVertButton) widget model: (dummySpec adapt: self brushAdaptor select: (aBuilder visualAt: #smallVertBrush)).	(aBuilder componentAt: #bigCircleButton) widget model: (dummySpec adapt: self brushAdaptor select: (aBuilder visualAt: #bigCircleBrush)).	(aBuilder componentAt: #bigSquareButton) widget model: (dummySpec adapt: self brushAdaptor select: (aBuilder visualAt: #bigSquareBrush)).	self brushAdaptor compute: [ :val | val isNil ifFalse: [self modeAdaptor value: #brush]].	self modeAdaptor compute: [ : val | val == #brush ifFalse: [self brushAdaptor value: nil]].	(aBuilder componentAt: #paintControls) disable.</body></methods><methods><class-id>Tools.UIHotRegionEditor</class-id> <category>initialize-release</category><body package="UIPainter">initialize	super initialize.	modified := false. 	hotRegions := #{UI.HotRegions} value new.	self slicesList: hotRegions allSlices.	self selectedSliceChannel onChangeSend: #changedSelection to: self.	self selectorAdaptor onChangeSend: #edittedSelector to: self.</body></methods><methods><class-id>Tools.UIHotRegionEditor class</class-id> <category>resources</category><body package="UIPainter">sliceMenu	^Menu new asValue</body></methods><methods><class-id>Tools.PositionToolModel</class-id> <category>actions</category><body package="UIPainter">emptyAlignmentX	alignmentX value: ''</body><body package="UIPainter">emptyAlignmentY	alignmentY value: ''</body><body package="UIPainter">emptyAllFields	self emptyLeft; emptyTop; emptyRight; emptyBottom; emptyAlignmentX; emptyAlignmentY; emptyHeight; emptyWidth</body><body package="UIPainter">emptyBottom	bottomOffset value: ''.	bottomFraction value: ''</body><body package="UIPainter">emptyHeight	sizeHeight value: ''</body><body package="UIPainter">emptyLeft	leftOffset value: ''.	leftFraction value: ''</body><body package="UIPainter">emptyOffsets	#(#leftOffset #rightOffset #topOffset #bottomOffset )		do: [:name | (self perform: name) value: ''].	readMode value		ifTrue:			[readMode value: false.			self interruptedRead: true]</body><body package="UIPainter">emptyRight	rightOffset value: ''.	rightFraction value: ''</body><body package="UIPainter">emptyTop	topOffset value: ''.	topFraction value: ''</body><body package="UIPainter">emptyWidth	sizeWidth value: ''</body><body package="UIPainter">makeBounded	| controller |	(controller := propertiesTool controller) isNil ifTrue: [^self].	controller doMakeBounded.	self reloadSelectionInformation</body><body package="UIPainter">makeOriginSize	| controller |	(controller := propertiesTool controller) isNil ifTrue: [^self].	controller doMakeOriginSize.	self reloadSelectionInformation</body><body package="UIPainter">makeUnbounded	| controller |	(controller := propertiesTool controller) isNil ifTrue: [^self].	controller doMakeUnBounded.	self reloadSelectionInformation</body><body package="UIPainter">postcancel	self readMode value: true</body><body package="UIPainter">preapply	| controller list frameList | 	controller := propertiesTool controller.	(controller == nil or: [(list := propertiesTool selection) isEmpty])		ifTrue: [^self].	frameList := list collect:		[:sel |		sel widget -&gt; (self frameFor: sel in: controller)].	(frameList			detect:				[:assn |				(self					validateFrame: assn value					for: assn key					in: controller) not]			ifNone: [nil]) notNil		ifTrue:			[^self].	1 to: list size do:		[:index |		(list at: index) newLayout: (frameList at: index) value reducedForm].	controller view bounds: controller view bounds.	controller view topComponent display.	controller canvasHasChanged: true.	self interruptedRead		ifTrue:			[self readMode value: true]</body></methods><methods><class-id>Tools.PositionToolModel</class-id> <category>private</category><body package="UIPainter">bottomOffsetChanged	(self tracking not and: [bottomFraction value = '' and: [(bottomOffset value = '') not]])		ifTrue: [bottomFraction value: '0']</body><body package="UIPainter">correctFraction: aValueModel	| num |	(num := self frameNumberFor: aValueModel) notNil		ifTrue:			[num &gt; 1.0 ifTrue: [aValueModel value: '1'].			num &lt; 0.0 ifTrue: [aValueModel value: '0']].</body><body package="UIPainter">disableFramingButtons	self disableGroup: #(#boundedButton #unboundedButton #originSizeButton)</body><body package="UIPainter">enableFramingButtons	| list enableBounded enableUnbounded enableOriginSize |	list := propertiesTool selection.	enableBounded := false.	enableUnbounded := false.	enableOriginSize := false.	list size = 1 		ifTrue: 			[ | layout |			layout := list first layout asLayout.			enableUnbounded := ((layout isKindOf: LayoutFrame) or: [layout isKindOf: LayoutSizedOrigin]) and: [list first spec hasInherentSize].			enableBounded := (layout isKindOf: LayoutFrame) not.			enableOriginSize := (layout isKindOf: LayoutSizedOrigin) not or: [(layout isKindOf: LayoutSizedOrigin) not and: [list first spec hasInherentSize]]]		ifFalse:			[list do:				[:each |				(each spec layout asLayout isKindOf: LayoutFrame)					ifTrue: [each spec hasInherentSize ifTrue: [enableUnbounded := true]]					ifFalse: [enableBounded := true].				(enableBounded and: [enableUnbounded])					ifTrue: [^self enableGroup: #(#boundedButton #unboundedButton #originSizeButton)]]].	self able: enableBounded components: #(#boundedButton).	self able: enableUnbounded components: #(#unboundedButton).	self able: enableOriginSize components: #(#originSizeButton)</body><body package="UIPainter">frameFor: aSelection in: aController	^(aSelection component isKindOf: BoundedWrapper)		ifTrue: [(#(#frame #na) includes: self selectionType)			ifTrue:[self frameRectangularSelection: aSelection in: aController]			ifFalse:[self frameSizedOriginSelection: aSelection in: aController]]		ifFalse: [self frameOriginalSelection: aSelection in: aController]</body><body package="UIPainter">frameNumberFor: aValueModel	| s |	s := aValueModel value.	s isEmpty ifTrue: [^nil].	^Locale current readNumberFrom: s readStream skipSeparators type: Number</body><body package="UIPainter">frameOriginalSelection: aSelection in: aController	"In underconstrained situations due to null values among the new 	numbers, attempt to maintain the current width and/or height of 	the selection. Otherwise, a nil value means the user doesn't want 	that part of the layout to change.  Begin by doing the equivalent	of an anchor, reestablishing the fractions of the layout while keeping	the figure stationary; then layer in the offset information."	"This method might be simplified considerably if LayoutOrigins	responded to AlignmentOrigin protocol."	| bounds frame  box newLeftFraction newTopFraction newLeftOffset newTopOffset newAlignmentX newAlignmentY |	bounds := aController view bounds.	frame := aSelection layout asLayout copy.	frame copy.	box := aSelection bounds.	newLeftOffset := self frameNumberFor: leftOffset.	newTopOffset := self frameNumberFor: topOffset.	newAlignmentX := self frameNumberFor: alignmentX.	newAlignmentY := self frameNumberFor: alignmentY.	(newAlignmentX notNil or: [newAlignmentY notNil])		ifTrue:			[((newAlignmentX ~= 0 or: [newAlignmentY ~= 0]) and:					[(frame isKindOf: AlignmentOrigin) not])				ifTrue: [frame := frame asAlignmentOrigin]].	(newLeftFraction := self frameNumberFor: leftFraction) notNil		ifTrue:			[frame leftFraction: newLeftFraction.			frame leftOffset:				(box left +					((frame isKindOf: AlignmentOrigin)						ifTrue: [box width * frame leftAlignmentFraction]						ifFalse: [0]) -					(bounds width * newLeftFraction) rounded)].	(newTopFraction := self frameNumberFor: topFraction) notNil		ifTrue:			[frame topFraction: newTopFraction.			frame topOffset:				(box top +					((frame isKindOf: AlignmentOrigin)						ifTrue: [box height * frame topAlignmentFraction]						ifFalse: [0]) -					(bounds height * newTopFraction) rounded)].	newLeftOffset notNil		ifTrue: [frame leftOffset: newLeftOffset]		ifFalse:			[newAlignmentX notNil				ifTrue:					[frame leftOffset: frame leftOffset +						(((newAlignmentX -							((frame isKindOf: AlignmentOrigin)								ifTrue: [frame leftAlignmentFraction]								ifFalse: [0])) * box width) rounded)]].	newTopOffset notNil		ifTrue: [frame topOffset: newTopOffset]		ifFalse:			[newAlignmentY notNil				ifTrue:					[frame topOffset: frame topOffset +						(((newAlignmentY -							((frame isKindOf: AlignmentOrigin)								ifTrue: [frame topAlignmentFraction]								ifFalse: [0])) * box height) rounded)]].	(frame isKindOf: AlignmentOrigin)		ifTrue:			[newAlignmentX notNil				ifTrue: [frame leftAlignmentFraction: newAlignmentX].			newAlignmentY notNil				ifTrue: [frame topAlignmentFraction: newAlignmentY]].	^frame</body><body package="UIPainter">frameRectangularSelection: aSelection in: aController	"In underconstrained situations due to null values among the new 	numbers, attempt to maintain the current width and/or height of 	the selection. Otherwise, a nil value means the user doesn't want 	that part of the layout to change.  Begin by doing the equivalent	of an anchor, reestablishing the fractions of the layout while keeping	the figure stationary; then layer in the offset information."	"This method might be simplified considerably if LayoutOrigins	responded to AlignmentOrigin protocol."	| bounds frame oldFrame box newLeftFraction newTopFraction newLeftOffset newTopOffset newRightFraction newBottomFraction newRightOffset newBottomOffset |	bounds := aSelection container bounds.	frame := aSelection layout asLayout copy.	oldFrame := frame copy.	box := aSelection bounds.	newLeftOffset := self frameNumberFor: leftOffset.	newTopOffset := self frameNumberFor: topOffset.	(newLeftFraction := self frameNumberFor: leftFraction) notNil		ifTrue:			[frame leftFraction: newLeftFraction.			frame leftOffset:				(box left - (bounds width * newLeftFraction) rounded)].	(newTopFraction := self frameNumberFor: topFraction) notNil		ifTrue:			[frame topFraction: newTopFraction.			frame topOffset:				(box top - (bounds height * newTopFraction) rounded)].	(newRightFraction := self frameNumberFor: rightFraction) notNil		ifTrue:			[frame rightFraction: newRightFraction.			frame rightOffset:				(box right - (bounds width * newRightFraction) rounded)].	(newBottomFraction := self frameNumberFor: bottomFraction) notNil		ifTrue:			[frame bottomFraction: newBottomFraction.			frame bottomOffset:				(box bottom - (bounds height * newBottomFraction) rounded)].	newRightOffset := self frameNumberFor: rightOffset.	newBottomOffset := self frameNumberFor: bottomOffset.	newLeftOffset notNil		ifTrue: [frame leftOffset: newLeftOffset]		ifFalse:			[newRightOffset notNil				ifTrue:					[frame leftOffset:						frame leftOffset +							(bounds width * (newRightFraction - oldFrame rightFraction)) rounded +							newRightOffset - oldFrame rightOffset]].	newTopOffset notNil		ifTrue: [frame topOffset: newTopOffset]		ifFalse:			[newBottomOffset notNil				ifTrue:					[frame topOffset:						frame topOffset +							(bounds height * (newBottomFraction - oldFrame bottomFraction)) rounded +							newBottomOffset - oldFrame bottomOffset]].	newRightOffset notNil		ifTrue: [frame rightOffset: newRightOffset]		ifFalse:			[newLeftOffset notNil				ifTrue:					[frame rightOffset:						frame rightOffset +							(bounds width * (newLeftFraction - oldFrame leftFraction)) rounded +							newLeftOffset - oldFrame leftOffset]].	newBottomOffset notNil		ifTrue: [frame bottomOffset: newBottomOffset]		ifFalse:			[newTopOffset notNil				ifTrue:					[frame bottomOffset:						frame bottomOffset +							(bounds height * (newTopFraction - oldFrame topFraction)) rounded +							newTopOffset - oldFrame topOffset]].	^frame</body><body package="UIPainter">frameSizedOriginSelection: aSelection in: aController	"In underconstrained situations due to null values among the new 	numbers, attempt to maintain the current width and/or height of 	the selection. Otherwise, a nil value means the user doesn't want 	that part of the layout to change.  Begin by doing the equivalent	of an anchor, reestablishing the fractions of the layout while keeping	the figure stationary; then layer in the offset information."	"This method might be simplified considerably if LayoutOrigins	responded to AlignmentOrigin protocol."	| bounds frame box newLeftFraction newTopFraction newLeftOffset newTopOffset newWidth newHeight |	bounds := aController view bounds.	frame := aSelection layout asLayout copy.	box := aSelection bounds.	newLeftOffset := self frameNumberFor: leftOffset.	newTopOffset := self frameNumberFor: topOffset.	(newLeftFraction := self frameNumberFor: leftFraction) notNil		ifTrue:			[frame leftFraction: newLeftFraction.			frame leftOffset:				(box left - (bounds width * newLeftFraction) rounded)].	(newTopFraction := self frameNumberFor: topFraction) notNil		ifTrue:			[frame topFraction: newTopFraction.			frame topOffset:				(box top - (bounds height * newTopFraction) rounded)].	newWidth := self frameNumberFor: sizeWidth.	newHeight := self frameNumberFor: sizeHeight.	newLeftOffset notNil		ifTrue: [frame leftOffset: newLeftOffset].	newTopOffset notNil		ifTrue: [frame topOffset: newTopOffset].	newWidth notNil		ifTrue: [frame width: newWidth].	newHeight notNil		ifTrue: [frame height: newHeight].	^frame</body><body package="UIPainter">hideBoundedItems	self vanishGroup: self groupBounded</body><body package="UIPainter">hideOriginSizeItems	self vanishGroup: self groupOriginSize</body><body package="UIPainter">hideUnboundedItems	self vanishGroup: self groupUnbounded</body><body package="UIPainter">leftOffsetChanged	(self tracking not and: [leftFraction value = '' and: [(leftOffset value = '') not]])		ifTrue: [leftFraction value: '0']</body><body package="UIPainter">loadDataFrom: aSelection 	| layout |	layout := aSelection layout asLayout.	self selectionType == #frame		ifTrue: [self loadFrameDataFrom: layout. ^self].	self selectionType == #origin		ifTrue: [self loadOriginDataFrom: layout. ^self].	self selectionType == #size		ifTrue: [self loadSizeDataFrom: layout. ^self].	self error: (#shouldntHappen &lt;&lt; #UIPainter &gt;&gt; 'shouldn''t happen')</body><body package="UIPainter">loadFrameDataFrom: aFrame 	#(#leftOffset #leftFraction #rightOffset #rightFraction #topOffset #topFraction #bottomOffset #bottomFraction ) do:		[:name |		(self perform: name)			value: (Locale current printAsNumber: (aFrame perform: name))]</body><body package="UIPainter">loadOriginDataFrom: anOrigin 	#(#leftOffset #leftFraction #topOffset #topFraction) do: 			[:name | 			(self perform: name) value: (Locale current printAsNumber: (anOrigin perform: name))].	(anOrigin isKindOf: AlignmentOrigin)		ifTrue: 			[alignmentX value: (Locale current printAsNumber: anOrigin leftAlignmentFraction).			alignmentY value: (Locale current printAsNumber: anOrigin topAlignmentFraction)]		ifFalse: 			[alignmentX value: '0'.			alignmentY value: '0']</body><body package="UIPainter">loadSizeDataFrom: anOrigin 	#(#leftOffset #leftFraction #topOffset #topFraction) do: 		[:name | 		(self perform: name) value: (Locale current printAsNumber: (anOrigin perform: name))].	self sizeHeight value: (Locale current printAsNumber: anOrigin height).	self sizeWidth value: (Locale current printAsNumber: anOrigin width)</body><body package="UIPainter">reloadSelectionInformation	self tracking: true.	(propertiesTool selectionKind == #none or: [propertiesTool selectionKind == #window]) ifTrue: 		[self selectionType: #na.		self disableFramingButtons.		readMode value ifTrue: [self emptyAllFields].		self disableApply.		self tracking: false.		^self].	propertiesTool selectionKind == #multi		ifTrue:			[self selectionType: #na.			self enableFramingButtons.			self 				hideOriginSizeItems; 				hideUnboundedItems; 				showBoundedItems.			readMode value				ifTrue:					[self emptyAllFields.					self disableApply]				ifFalse:					[self enableApply]]		ifFalse:			[self selectionType: #unknown.			self selectionType == #frame ifTrue: [self hideOriginSizeItems; hideUnboundedItems; showBoundedItems].			self selectionType == #origin ifTrue: [self hideOriginSizeItems; hideBoundedItems; showUnboundedItems].			self selectionType == #size ifTrue:  [self hideUnboundedItems; hideBoundedItems; showOriginSizeItems].			self enableFramingButtons.			readMode value				ifTrue: 					[self disableApply.					self loadDataFrom: propertiesTool selection first]				ifFalse:					[self enableApply]].	self tracking: false.	propertiesTool updateSelectionInTree</body><body package="UIPainter">rightOffsetChanged	(self tracking not and: [rightFraction value = '' and: [(rightOffset value = '') not]])		ifTrue: [rightFraction value: '0']</body><body package="UIPainter">showBoundedItems	self reappearGroup: self groupBounded</body><body package="UIPainter">showMutualItems	self reappearGroup: self groupMutual</body><body package="UIPainter">showOriginSizeItems	self reappearGroup: self groupOriginSize</body><body package="UIPainter">showUnboundedItems	self reappearGroup: self groupUnbounded</body><body package="UIPainter">sliderMoved	self tracking		ifFalse: 			[self enableApply.			self readMode value				ifTrue: 					[self readMode value: false.					self interruptedRead: true]]</body><body package="UIPainter">topOffsetChanged	(self tracking not and: [topFraction value = '' and: [(topOffset value = '') not]])		ifTrue: [topFraction value: '0']</body><body package="UIPainter">tracking	^tracking</body><body package="UIPainter">tracking: aBoolean	tracking := aBoolean</body><body package="UIPainter">validateFrame: aFrame for: aComponent in: aController	"Return true if the component's placement will be satisfactory (at	least partially within aController's view, and not inside-out),	otherwise return false.  As a side effect, generate a warning	dialog for the user."	| outerBox wSpec innerBox |	outerBox := aController view bounds.	wSpec := aController model windowSpec.	wSpec hasHorizontalScrollBar		ifTrue:			[outerBox width:				(outerBox extent x max: aController view preferredWidth)].	wSpec hasVerticalScrollBar		ifTrue:			[outerBox height:				(outerBox extent y max: aController view preferredHeight)].	innerBox := aFrame		rectangleRelativeTo: outerBox		preferred: aComponent preferredBounds.	(innerBox left &gt;= innerBox right or:			[innerBox top &gt;= innerBox bottom])		ifTrue:			[Dialog warn:				(aController selectionList size = 1					ifTrue:						[(#GenKey14 &lt;&lt; #UIPainter &gt;&gt; 'These settings would give the selected itema degenerate layout.  Apply cancelled')]					ifFalse:						[(#GenKey13 &lt;&lt; #UIPainter &gt;&gt; 'These settings would give one or more itemsdegenerate layouts.  Apply cancelled')]) for: builder window.			^false].	(aController isFenced			ifTrue: [outerBox contains: innerBox]			ifFalse: [innerBox intersects: outerBox])		ifFalse:			[Dialog warn:				(aController selectionList size = 1					ifTrue:						[(#GenKey12 &lt;&lt; #UIPainter &gt;&gt; 'These settings would put the selected itemout of bounds.  Apply cancelled')]					ifFalse:						[(#GenKey11 &lt;&lt; #UIPainter &gt;&gt; 'These settings would put one or more itemsout of bounds.  Apply cancelled')]) for: builder window.			^false].	^true</body><body package="UIPainter">wireControllers		#(#leftOffsetField #leftFractionField #topOffsetField #topFractionField #rightOffsetField #rightFractionField #bottomOffsetField #bottomFractionField #alignmentXField #alignmentYField #sizeHeightField #sizeWidthField)		do:			[:name |			(builder componentAt: name) widget controller				keyboardHook: 					[:ev :ctrl | 					(self readMode value and:						[ev keyValue ~= Character tab and:								[ev keyValue ~= Character cr]])						ifTrue:							[self readMode value: false.							self interruptedRead: true].					ev]]</body></methods><methods><class-id>Tools.PositionToolModel</class-id> <category>aspects</category><body package="UIPainter">alignmentX	^alignmentX</body><body package="UIPainter">alignmentXSlide	^alignmentXSlide</body><body package="UIPainter">alignmentY	^alignmentY</body><body package="UIPainter">alignmentYSlide	^alignmentYSlide</body><body package="UIPainter">bottomFraction	^bottomFraction</body><body package="UIPainter">bottomOffset	^bottomOffset</body><body package="UIPainter">bottomSlide	^bottomSlide</body><body package="UIPainter">leftFraction	^leftFraction</body><body package="UIPainter">leftOffset	^leftOffset</body><body package="UIPainter">leftSlide	^leftSlide</body><body package="UIPainter">rightFraction	^rightFraction</body><body package="UIPainter">rightOffset	^rightOffset</body><body package="UIPainter">rightSlide	^rightSlide</body><body package="UIPainter">sizeHeight	^sizeHeight</body><body package="UIPainter">sizeWidth	^sizeWidth</body><body package="UIPainter">topFraction	^topFraction</body><body package="UIPainter">topOffset	^topOffset</body><body package="UIPainter">topSlide	^topSlide</body></methods><methods><class-id>Tools.PositionToolModel</class-id> <category>modes</category><body package="UIPainter">selectionType	selectionType == #unknown		ifTrue:			[propertiesTool selectionKind == #single				ifTrue:					[ | layout |					(((layout := propertiesTool spec layout) isKindOf: LayoutFrame) or: [layout isKindOf: Rectangle])						ifTrue: [self selectionType: #frame]						ifFalse: 							[(layout isKindOf: LayoutSizedOrigin)								ifTrue: [self selectionType: #size]								ifFalse: [self selectionType: #origin]]]				ifFalse: [self selectionType: #na]].	^selectionType</body><body package="UIPainter">selectionType: aSymbol	selectionType := aSymbol</body></methods><methods><class-id>Tools.PositionToolModel</class-id> <category>interface opening</category><body package="UIPainter">buildInSubCanvas: spec withBuilder: aBuilder	super buildInSubCanvas: spec withBuilder: aBuilder.	self reloadSelectionInformation</body><body package="UIPainter">postBuildWith: aBuilder		super postBuildWith: aBuilder.	self wireControllers</body><body package="UIPainter">postOpenWith: aBuilder		builder window application: self.	builder window sendWindowEvents: #(#close ).	self showBoundedItems; hideUnboundedItems; showMutualItems.	self reloadSelectionInformation.	self wireControllers</body></methods><methods><class-id>Tools.PositionToolModel</class-id> <category>testing</category><body package="UIPainter">usesConservativeReload	^true</body></methods><methods><class-id>Tools.PositionToolModel</class-id> <category>constants</category><body package="UIPainter">groupBounded	^#(#rightOffsetField #bottomOffsetField	#rightFractionField #bottomFractionField #rightFractionSlider #bottomFractionSlider	#emptyRightButton #emptyBottomButton #boundedLabelGroup)</body><body package="UIPainter">groupMutual	^#(#leftOffsetField #topOffsetField	#leftFractionField #topFractionField #leftFractionSlider #topFractionSlider	#emptyLeftButton #emptyTopButton #labelProportion #labelOffset)</body><body package="UIPainter">groupOriginSize	^#(#sizeHeightField #emptyHeightButton #sizeWidthField #emptyWidthButton #originSizeGroup)</body><body package="UIPainter">groupUnbounded	^#(#alignmentXField #alignmentXSlider #alignmentYField #alignmentYSlider #emptyAlignmentXButton	 #emptyAlignmentYButton #unboundedLabelGroup)</body></methods><methods><class-id>Tools.PositionToolModel</class-id> <category>initialize-release</category><body package="UIPainter">initialize	super initialize.	sizeHeight := '' asValue.	sizeWidth := '' asValue.	(leftOffset := '' asValue) onChangeSend: #leftOffsetChanged to: self.	(leftFraction := '' asValue) compute: [:v | self correctFraction: leftFraction].	(rightOffset := '' asValue) onChangeSend: #rightOffsetChanged to: self.	rightFraction := '' asValue.	(rightFraction := '' asValue) compute: [:v | self correctFraction: rightFraction].	(bottomOffset := '' asValue) onChangeSend: #bottomOffsetChanged to: self.	bottomFraction := '' asValue.	(bottomFraction := '' asValue) compute: [:v | self correctFraction: bottomFraction].	(topOffset := '' asValue) onChangeSend: #topOffsetChanged to: self.	topFraction := '' asValue.	(topFraction := '' asValue) compute: [:v | self correctFraction: topFraction].	alignmentX := '' asValue.	(alignmentX := '' asValue) 	compute: [:v | self correctFraction: alignmentX].	alignmentY := '' asValue.	(alignmentY := '' asValue) 	compute: [:v | self correctFraction: alignmentY]. 	(leftSlide := (TypeConverter on: leftFraction) stringToNumber) onChangeSend: #sliderMoved to: self.	(topSlide := (TypeConverter on: topFraction) stringToNumber) onChangeSend: #sliderMoved to: self.	(bottomSlide := (TypeConverter on: bottomFraction) stringToNumber) onChangeSend: #sliderMoved to: self.	(rightSlide := (TypeConverter on: rightFraction) stringToNumber) onChangeSend: #sliderMoved to: self.	(alignmentXSlide := (TypeConverter on: alignmentX) stringToNumber) onChangeSend: #sliderMoved to: self.	(alignmentYSlide := (TypeConverter on: alignmentY) stringToNumber) onChangeSend: #sliderMoved to: self.	tracking := false.</body></methods><methods><class-id>Tools.PositionToolModel class</class-id> <category>resources</category><body package="UIPainter">fieldMenu	^MenuBuilder new		add: (#Again &lt;&lt; #UIPainter &gt;&gt; 'Again')-&gt;			[:ctrlr |			ctrlr again.			(ctrlr textHasChanged and:					[ctrlr performer readMode value])				ifTrue:					[ctrlr performer readMode value: false.					ctrlr performer interruptedRead: true]];		add: (#Undo &lt;&lt; #UIPainter &gt;&gt; 'Undo') -&gt;			[:ctrlr |			ctrlr undo.			(ctrlr textHasChanged and:					[ctrlr performer readMode value])				ifTrue:					[ctrlr performer readMode value: false.					ctrlr performer interruptedRead: true]];		line;		add: (#Copy &lt;&lt; #UIPainter &gt;&gt; 'Copy')-&gt;[:ctrlr | ctrlr copySelection];		add: (#Cut &lt;&lt; #UIPainter &gt;&gt; 'Cut')-&gt;			[:ctrlr |			ctrlr cut.			(ctrlr textHasChanged and:					[ctrlr performer readMode value])				ifTrue:					[ctrlr performer readMode value: false.					ctrlr performer interruptedRead: true]];		add: (#Paste &lt;&lt; #UIPainter &gt;&gt; 'Paste')-&gt;			[:ctrlr |			ctrlr paste.			(ctrlr textHasChanged and:					[ctrlr performer readMode value])				ifTrue:					[ctrlr performer readMode value: false.					ctrlr performer interruptedRead: true]];		line;		add: (#DoIt &lt;&lt; #UIPainter &gt;&gt; 'Do it')-&gt;[:ctrlr | ctrlr doIt];		add: (#PrintIt &lt;&lt; #UIPainter &gt;&gt; 'Print it')-&gt;			[:ctrlr |			ctrlr printIt.			(ctrlr textHasChanged and:					[ctrlr performer readMode value])				ifTrue:					[ctrlr performer readMode value: false.					ctrlr performer interruptedRead: true]];		add: (#InspectIt &lt;&lt; #UIPainter &gt;&gt; 'Inspect it')-&gt;[:ctrlr | ctrlr inspectIt];		line;		add: (#Accept &lt;&lt; #UIPainter &gt;&gt; 'Accept')-&gt;[:ctrlr | ctrlr accept];		add: (#Cancel &lt;&lt; #UIPainter &gt;&gt; 'Cancel')-&gt;[:ctrlr | ctrlr cancel];		line;		add: (#Hardcopy &lt;&lt; #UIPainter &gt;&gt; 'Hardcopy')-&gt;[:ctrlr | ctrlr hardcopy];		menuHolder</body></methods><methods><class-id>Tools.DSVDependencyAgent</class-id> <category>accessing</category><body package="UIPainter">bindings	^bindings</body><body package="UIPainter">bindings: aDictionary	bindings := aDictionary</body><body package="UIPainter">notificationAspects	^notificationAspects</body><body package="UIPainter">notificationAspects: anArray	notificationAspects := anArray</body><body package="UIPainter">spec: aDataSetSpec	spec := aDataSetSpec</body><body package="UIPainter">validationAspects	^validationAspects</body><body package="UIPainter">validationAspects: anArray	validationAspects := anArray</body></methods><methods><class-id>Tools.DSVDependencyAgent</class-id> <category>aspects</category><body package="UIPainter">focusInSelector	| cs index |	index := (bindings at: #dsvSelectionChannel) value.	index == 0 ifTrue: [ ^nil ].	cs :=  (spec columns at: index) callbacksSpec.	cs == nil ifTrue: [ ^nil ].	^cs focusInSelector</body><body package="UIPainter">focusInSelector: aString	| cs |	cs :=  (spec columns at: (bindings at: #dsvSelectionChannel) value) callbacksSpec.	cs focusInSelector: aString.	(bindings at: #propertiesTool) displayButtonsForModifiedState</body><body package="UIPainter">focusOutSelector	^nil</body><body package="UIPainter">focusOutSelector: aString	| cs |	cs := (spec columns at: (bindings at: #dsvSelectionChannel) value) callbacksSpec.	cs focusOutSelector: aString.	(bindings at: #propertiesTool) displayButtonsForModifiedState</body><body package="UIPainter">requestFocusInSelector	^nil</body><body package="UIPainter">requestFocusOutSelector	^nil</body><body package="UIPainter">requestValueChangeSelector	^nil</body><body package="UIPainter">valueChangeSelector	^nil</body></methods><methods><class-id>Tools.DSVDependencyAgent</class-id> <category>actions</category><body package="UIPainter">deleteColumn	| index min |	(spec columns size = 0 or: [(index := (bindings at: #dsvSelectionChannel) value) == 0 or: [(spec columns at: index) editorType == #rowSelector]])		ifTrue: [^self].	(spec columns at: 1) editorType == #rowSelector ifTrue: [ min := 2 ] ifFalse: [ min := 1 ].	(bindings at: #dsvSelectionChannel)		value: (spec columns size == 1				ifTrue: [0]				ifFalse: [index - 1 max: min]).	spec deleteColumnIndex: index from: (bindings at: #propertiesTool).	self validateComponents.</body><body package="UIPainter">validateComponents	| list validComponents comp index |	(bindings at: #propertiesTool) subBuilder isNil ifTrue: [^self].	(bindings at: #propertiesTool) completeWorkOnPreviousSelection.	list := #(#deleteColumn #fields ).	validComponents := Dictionary new.	list do: [:symbol | (comp := (bindings at: #propertiesTool) subBuilder componentAt: symbol) notNil ifTrue: [validComponents at: symbol put: comp]].	index := (bindings at: #dsvSelectionChannel) value.	(validComponents keys includes: (list at: 1))		ifTrue: [(index == 0 or: [(spec columns at: index) editorType == #rowSelector])				ifTrue: [(validComponents at: (list at: 1)) disable]				ifFalse: [(validComponents at: (list at: 1)) enable]].	(validComponents keys includes: (list at: 2)) 		ifTrue: [(index &gt; 0 and: [ #(#InputField #CheckBox #ComboBox ) includes: (spec columns at: index) editorType])			ifTrue: [(validComponents at: (list at: 2)) enable]			ifFalse: [(validComponents at: (list at: 2)) disable].			notificationAspects do: [ :aA | aA notNil ifTrue: [aA update: aA forAspect with: nil from: self ]].			validationAspects do: [ :aA | aA notNil ifTrue: [ aA update: aA forAspect with: nil from: self ]].			]</body><body package="UIPainter">validateComponentsFor: aBuilder	self validateComponents</body></methods><methods><class-id>Tools.DSVDependencyAgent</class-id> <category>initialize-release</category><body package="UIPainter">release	(bindings at: #dsvSelectionChannel) retractInterestsFor: self.</body></methods><methods><class-id>Tools.CodingAssistant</class-id> <category>initialize-release</category><body package="UIPainter">classNameChannel: aClassNameHolder	classNameChannel retractInterestIn: #value for: self.	classNameChannel := aClassNameHolder.	classNameChannel onChangeSend: #changedClassName to: self.	self changedClassName</body><body package="UIPainter">initialize	super initialize.	instVarList := MultiSelectionInList new.	readAccessing := true asValue.	writeAccessing := true asValue.	dependency := false asValue.	writeAccessing onChangeSend: #changedWriteAccessing to: self.	finder := EntryWithPasteButtonModule forClasses.	self classNameChannel: finder entryHolder</body><body package="UIPainter">targetClass	| name |	name := classNameChannel value asString.	^name asQualifiedReference valueOrDo: []</body></methods><methods><class-id>Tools.CodingAssistant</class-id> <category>interface opening</category><body package="UIPainter">postBuildWith: aBuilder	(aBuilder componentAt: #defineButton) disable</body></methods><methods><class-id>Tools.CodingAssistant</class-id> <category>aspects</category><body package="UIPainter">className	^classNameChannel</body><body package="UIPainter">dependency	^dependency</body><body package="UIPainter">instVarList	^instVarList</body><body package="UIPainter">readAccessing	^readAccessing</body><body package="UIPainter">writeAccessing	^writeAccessing</body></methods><methods><class-id>Tools.CodingAssistant</class-id> <category>private</category><body package="UIPainter">changedClassName	| cn tc| 	cn := classNameChannel value.	(cn == nil or: [cn isEmpty])		ifTrue:			[builder notNil ifTrue:				[(builder componentAt: #defineButton) disable].			instVarList list: List new]		ifFalse:			[(tc := self targetClass) == nil				ifTrue: [Dialog warn: ((#Class1sDoesNotExist &lt;&lt; #UIPainter &gt;&gt; 'Class &lt;1s&gt; does not exist.')			expandMacrosWith: cn) for: builder window.						builder notNil ifTrue:							[(builder componentAt: #defineButton) disable.							instVarList list: List new]]				ifFalse: [instVarList list: tc instVarNames.							builder notNil ifTrue:								[(builder componentAt: #defineButton) enable]]]</body><body package="UIPainter">changedWriteAccessing	writeAccessing value		ifTrue: [(builder componentAt: #dependency) enable]		ifFalse: [(builder componentAt: #dependency) disable]</body><body package="UIPainter">chosenInstVarNames	^instVarList selections</body><body package="UIPainter">doBuildAccessing	| assistant iv |	iv := self chosenInstVarNames.	(iv == nil or: [iv isEmpty]) ifTrue: [^self].	assistant := UIDefiner for: self targetClass.	readAccessing value		ifTrue: [assistant addReadingAccessFor: iv].	writeAccessing value		ifTrue: [dependency value					ifTrue: [assistant addDependencyWritingAccessFor: iv]					ifFalse: [assistant addWritingAccessFor: iv]]</body></methods><methods><class-id>Tools.CodingAssistant</class-id> <category>actions</category><body package="UIPainter">apply	self doBuildAccessing</body></methods><methods><class-id>Tools.CodingAssistant</class-id> <category>accessing</category><body package="UIPainter">finder	^finder</body></methods><methods><class-id>Tools.CodingAssistant class</class-id> <category>instance creation</category><body package="UIPainter">new	^super new initialize</body></methods><methods><class-id>UI.PaintTracker</class-id> <category>private</category><body package="UIPainter">finishSelectionFor: aPoint	self sensor windowSensor collapseEvents: true. 	super finishSelectionFor: aPoint</body><body package="UIPainter">setUpFor: aMouseButtonEvent	super setUpFor: aMouseButtonEvent. 	self sensor windowSensor collapseEvents: false. 	controller startDragAt: (self cursorPointFor: aMouseButtonEvent)</body></methods><methods><class-id>Tools.DataSetSpecColumnModel</class-id> <category>private</category><body package="UIPainter">changeFont	(currentColumn isNil or: [lock]) ifTrue: [^self].	currentColumn value labelFont: (self labelFont value == #system			ifTrue: [nil]			ifFalse: [labelFont value]).	changedBlock value: nil</body><body package="UIPainter">changeFrozen	(currentColumn isNil or: [lock]) ifTrue: [^self].	currentColumn value noScroll: self frozen value.	changedBlock value: nil</body><body package="UIPainter">changeImage	(currentColumn isNil or: [lock]) ifTrue: [^self].	currentColumn value labelIsImage: self labelIsImage value.	labelIsImage value 		ifTrue: 			[currentColumn value labelFromApplication: true.			(self builder aspectAt: #labelConstructor) suppliedByBuilder value: true.			self disableSuppliedByBuilder]		ifFalse: [self enableSuppliedByBuilder].	changedBlock value: nil</body><body package="UIPainter">changeLabelAsMessage	(currentColumn isNil or: [ lock ]) ifTrue: [ ^self ].	labelFromApplication value: self labelIsMessage value.	(self builder aspectAt: #labelConstructor) suppliedByBuilder setValue: self labelIsMessage value.	changedBlock value: nil.</body><body package="UIPainter">changeModelGen	(currentColumn isNil or: [ lock ]) ifTrue: [ ^self ].	currentColumn value model: self modelGen value asSymbol.	changedBlock value: nil.</body><body package="UIPainter">changeResizing	(currentColumn isNil or: [lock]) ifTrue: [^self].	currentColumn value allowResizing: self allowResizing value.	changedBlock value: nil</body><body package="UIPainter">changeSorting	(currentColumn isNil or: [lock]) ifTrue: [^self].	currentColumn value allowSorting: self allowSorting value.	changedBlock value: nil</body><body package="UIPainter">changeType	(currentColumn isNil or: [lock]) ifTrue: [^self].	self currentColumn value editorType: columnType value.	(#(#InputField #None #ComboBox) includes: columnType value) 		ifTrue: [currentColumn value rendererType: #Text].	columnType value = #Arbitrary 		ifTrue: 			[currentColumn value rendererType: #Arbitrary].	changedBlock value: nil</body><body package="UIPainter">changedSelection	| pendingChanges |	propertiesTool completeWorkOnPreviousSelection.	lock := true.	pendingChanges := propertiesTool hasUnAppliedChange.	selectionChannel value == 0		ifTrue: 			[self currentColumn value: DataSetColumnSpec new.			self modelGen value: String new.			self columnType value: currentColumn value editorType.			self disableFields]		ifFalse: 			[self enableFields.			self currentColumn value: (specChannel value columns at: selectionChannel value).			self builder ifNotNil: [:value | (value aspectAt: #labelConstructor) clearSuppliedByBuilder].			self frozen value: currentColumn value noScroll.			self allowResizing value: currentColumn value allowResizing.			self allowSorting value: currentColumn value allowSorting.			self modelGen value: currentColumn value model.			self labelIsImage value: currentColumn value labelIsImage.			self labelFromApplication value: (currentColumn value labelIsImage or: [(currentColumn value label isSymbol)]).			currentColumn value labelIsImage				ifTrue: [self disableSuppliedByBuilder]				ifFalse: [self enableSuppliedByBuilder].			self labelFont value: (currentColumn value labelFont isNil					ifTrue: [#system]					ifFalse: [currentColumn value labelFont]).			self columnType value: currentColumn value editorType.			self columnType value == #rowSelector				ifTrue: [(self builder componentAt: #aspectGroup) disable]				ifFalse: [(self builder componentAt: #aspectGroup) enable]].	pendingChanges ifFalse: [propertiesTool displayButtonsForUnmodifiedState].	lock := false</body><body package="UIPainter">compute: aBlock	changedBlock := aBlock</body><body package="UIPainter">disableFields	"Disable the fields of the Column slice"	(self builder componentAt: #nonlabelFields) disable.	(self builder componentAt: #label) disable.	(self builder componentAt: #labelIsImageButton) disable</body><body package="UIPainter">disableSuppliedByBuilder	((self builder aspectAt: #labelConstructor) builder componentAt: #suppliedByBuilder) disable</body><body package="UIPainter">enableFields	"Disable the fields of the Column slice"	(self builder componentAt: #nonlabelFields) enable.	(self builder componentAt: #label) enable.	(self builder componentAt: #labelIsImageButton) enable</body><body package="UIPainter">enableSuppliedByBuilder	((self builder aspectAt: #labelConstructor) builder componentAt: #suppliedByBuilder) enable</body><body package="UIPainter">postBuildWith: aBuilder 	self initSelectionChannel.	propertiesTool displayButtonsForUnmodifiedState.	self changedSelection.	specChannel notNil ifTrue: [specChannel addDependent: self]</body></methods><methods><class-id>Tools.DataSetSpecColumnModel</class-id> <category>aspects</category><body package="UIPainter">allowResizing	^allowResizing isNil 		ifTrue: [allowResizing := true asValue]		ifFalse: [allowResizing]</body><body package="UIPainter">allowSorting	^allowSorting isNil ifTrue: [allowSorting := true asValue ] ifFalse: [allowSorting]</body><body package="UIPainter">columnType	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^columnType isNil ifTrue: [columnType := #InputField asValue] ifFalse: [columnType]</body><body package="UIPainter">currentColumn	^currentColumn isNil ifTrue: [ currentColumn := DataSetColumnSpec new beDefault asValue ] ifFalse: [ currentColumn ]</body><body package="UIPainter">frozen	^frozen isNil ifTrue: [frozen := false asValue ] ifFalse: [frozen]</body><body package="UIPainter">label	^label isNil 		ifTrue: [label := (AspectAdaptor 						subjectChannel: self currentColumn						sendsUpdates: false) forAspect: #label]		ifFalse: [label]</body><body package="UIPainter">labelConstructor	^LabelConstructor new		on: self currentColumn;		parentBuilderBlock: [self builder] fieldMenuBlock: [propertiesTool fieldMenu]</body><body package="UIPainter">labelFont	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^labelFont isNil ifTrue: [labelFont := #system asValue ] ifFalse: [labelFont]</body><body package="UIPainter">labelFromApplication	labelFromApplication := (AspectAdaptor 						subjectChannel: self currentColumn 						sendsUpdates: false) forAspect: #labelFromApplication.	(currentColumn value label isSymbol or: [currentColumn value labelIsImage]) ifTrue: [currentColumn value labelFromApplication: true].	^labelFromApplication</body><body package="UIPainter">labelIsImage	^labelIsImage isNil ifTrue: [labelIsImage := false asValue ] ifFalse: [labelIsImage]</body><body package="UIPainter">labelIsMessage	| lblMode |	lblMode := self currentColumn value labelFromApplication asValue.	self labelIsImage		compute: 			[:v |			v				ifTrue: [lblMode value: true]				ifFalse: [lblMode value: currentColumn value labelFromApplication]].	self builder notNil ifTrue: [	(self builder aspectAt: #labelConstructor) ifNotNil: [:value |	value suppliedByBuilder setValue: lblMode value]].	^lblMode</body><body package="UIPainter">modelGen	^modelGen isNil ifTrue: [ modelGen := String new asValue ] ifFalse: [ modelGen ]</body><body package="UIPainter">width	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^width isNil ifTrue: [width := (AspectAdaptor subjectChannel: self currentColumn sendsUpdates: false) forAspect: #width ] ifFalse: [width]</body></methods><methods><class-id>Tools.DataSetSpecColumnModel</class-id> <category>actions</category><body package="UIPainter">disableAllowResize	self vanishGroup: #(#allowResizing)</body><body package="UIPainter">disableAllowSort	self vanishGroup: #(#allowSorting)</body><body package="UIPainter">enableAllowResize	self reappearGroup: #(#allowResizing)</body><body package="UIPainter">enableAllowSort	self reappearGroup: #(#allowSorting)</body><body package="UIPainter">precancel	^false</body></methods><methods><class-id>Tools.DataSetSpecColumnModel</class-id> <category>accessing</category><body package="UIPainter">specChannel: aValueHolder	"This is recieved when there is a new specModel being created "	self release. 	specChannel := aValueHolder.	self initSelectionChannel.</body></methods><methods><class-id>Tools.DataSetSpecColumnModel</class-id> <category>initialize-release</category><body package="UIPainter">initSelectionChannel	propertiesTool isNil ifTrue: [ ^self ].	selectionChannel := (propertiesTool selection at: 1) widget selectionChannel.	selectionChannel onChangeSend: #changedSelection to: self.	specChannel value labelsAsButtons 		ifTrue: [self enableAllowSort; enableAllowResize]		ifFalse: [self disableAllowSort; disableAllowResize]</body><body package="UIPainter">initialize	super initialize.	changedBlock := [:v |].	self labelFont onChangeSend: #changeFont to: self.	self columnType onChangeSend: #changeType to: self.	self labelIsImage onChangeSend: #changeImage to: self.	self frozen onChangeSend: #changeFrozen to: self.	self modelGen onChangeSend: #changeModelGen to: self.	self allowSorting onChangeSend: #changeSorting to: self.	self allowResizing onChangeSend: #changeResizing to: self.	lock := false.</body><body package="UIPainter">release	selectionChannel notNil 		ifTrue: [ 			selectionChannel retractInterestsFor: self].	specChannel notNil ifTrue: [ specChannel removeDependent: self ].	self builder notNil ifTrue: 		[(self builder aspectAt: #labelConstructor) suppliedByBuilder removeDependent: self]</body></methods><methods><class-id>Tools.DataSetSpecColumnModel class</class-id> <category>resources</category><body package="UIPainter">fontMenu	^UISpecification fontMenu</body></methods><methods><class-id>Tools.DataSetSpecColumnModel class</class-id> <category>interface specs</category><body package="UIPainter">columnEditSpec	| spec baseY y delta |	spec := self columnEditSpecLiteral decodeAsLiteralArray.	delta := UIPainterTool labelConstructorSpecSize - 31.	spec component collection do:		[:sp |		(sp class == SubCanvasSpec and: [sp clientKey = #labelConstructor])			ifTrue:				[baseY := sp layout bottomOffset.				sp layout bottomOffset: baseY+delta]].	spec component collection do:		[:sp |		y := sp layout class == Point			ifTrue: [sp layout y]			ifFalse: [sp layout topOffset].		y &gt;= baseY			ifTrue:				[[sp layout y: sp layout y + delta]					on: Object errorSignal					do: [:ex | ex return].				[sp layout topOffset: sp layout topOffset + delta]					on: Object errorSignal					do: [:ex | ex return].				[sp layout bottomOffset: sp layout bottomOffset + delta]					on: Object errorSignal					do: [:ex | ex return]]].	^spec</body></methods><methods><class-id>Tools.ResourceInstallDialog</class-id> <category>accessing</category><body package="UIPainter">classCache	classCache		ifNil: 			[classCache := IdentitySet new: 1000.			SystemUtils allClassesDo: [:each | classCache add: each ]].	^classCache</body><body package="UIPainter">selector	^selectorHolder value asSymbol</body><body package="UIPainter">targetDefinition	^accept value		ifTrue: [MethodDefinition class: self targetClass selector: self selector]		ifFalse: [nil]</body></methods><methods><class-id>Tools.ResourceInstallDialog</class-id> <category>initialize-release</category><body package="UIPainter">class: aClassOrNil selector: aSelector resource: aSymbol	aClassOrNil ifNotNil: [classModule value: aClassOrNil name].	selectorHolder value: aSelector.	resourceType := aSymbol.	self updateExistingSelectors</body><body package="UIPainter">initialize	super initialize.	existingSelectorsHolder := List new asValue.	selectorHolder := '' asValue.	classModule := EntryWithPasteButtonModule forClasses.	classModule pasteBlock: 			[IncrementalSearchDialog selectClass				ifNotNil: [:class | self printNameForClass: class]]</body><body package="UIPainter">resourceType: aSymbol	resourceType := aSymbol.	self updateExistingSelectors</body><body package="UIPainter">selector: aSelector	selectorHolder value: (aSelector ifNil: ['']) asString</body><body package="UIPainter">targetClass: aClassOrNil	aClassOrNil		ifNotNil: 			[classModule value: (self printNameForClass: aClassOrNil instanceBehavior)].	self updateExistingSelectors</body></methods><methods><class-id>Tools.ResourceInstallDialog</class-id> <category>private</category><body package="UIPainter">checkForMultipleClassBindings	"When we leave the class name field, if a simple name has been entered, we need to see if it has multiple bindings (e.g. Core.Text and XML.Text) and fill in a more specific reference after prompting."	| className matches selection |	className := classModule value asSymbol.	(className includes: $.) ifTrue: [^self].	matches := (self classesByName: className)				sorted: [:a :b | a fullName &lt; b fullName].	matches size &lt;= 1 ifTrue: [^self].	selection := Dialog				choose: ''				fromList: (matches collect: #fullName)				values: matches				lines: matches size				cancel: [^self].	classModule value: selection fullName</body><body package="UIPainter">classChanged	self updateExistingSelectors.	self updateAcceptEnablement</body><body package="UIPainter">classesByName: aSymbol	"Fetch all the classes in the system whose simple name matches aSymbol."	^self classCache select: [:each | each name = aSymbol].</body><body package="UIPainter">isCompleteEntry: aName	^(aName tokensBasedOn: $.)		allSatisfy: [:token | (SystemUtils validateName: token) notNil]</body><body package="UIPainter">printNameForClass: aClass	"If there is only one class in the system known by its simple name, we can use that simple name (true most of the time), otherwise we use the more verbose dotted name."	| matchingClasses |	matchingClasses := self classesByName: aClass name.	^matchingClasses size = 1 ifTrue: [aClass name] ifFalse: [aClass fullName]</body><body package="UIPainter">selectorChangeNotification: ignored	self updateAcceptEnablement</body><body package="UIPainter">targetClass	"The class field may have a simple name (e.g. RefactoringBrowser) which is resolvable without dots. Or it may be a fully specified name."	| className |	className := classModule value.	^(className includes: $.)		ifTrue: [className asQualifiedReference value]		ifFalse: [(self classesByName: className asSymbol) any]</body><body package="UIPainter">updateAcceptEnablement	(self widgetAt: #okButton)		isEnabled: (self hasValidClassEntry and: [self hasValidSelectorEntry])</body><body package="UIPainter">updateExistingSelectors	| selectors class |	selectors := List new.	self hasValidClassEntry		ifFalse: [^existingSelectorsHolder value: selectors].	class := self targetClass.	class classBehavior selectorsAndMethodsDo: 			[:eachSelector :eachMethod |			eachMethod resourceType == resourceType				ifTrue: [selectors add: eachSelector]].	selectors sort.	existingSelectorsHolder value: selectors</body></methods><methods><class-id>Tools.ResourceInstallDialog</class-id> <category>testing</category><body package="UIPainter">hasValidClassEntry	"Make sure the input in the class field is a simple name that resolves to one and only one class in the sytem OR is dotted and specifies an existing class."	| className matchingClasses |	className := classModule value.	(self isCompleteEntry: className) ifFalse:[^false].	(className includes: $.)		ifTrue: [^className asQualifiedReference bindingOrNil notNil].	matchingClasses := self classesByName: className asSymbol.	^matchingClasses size = 1</body><body package="UIPainter">hasValidSelectorEntry	"The selector field must have a unarySelector in it. Any smalltalk message symbol, is literal by definition, and then we can check for numArs (doesn't end in $:)."	^(Scanner isLiteralSymbol: self selector)		and: [self selector numArgs isZero]</body></methods><methods><class-id>Tools.ResourceInstallDialog</class-id> <category>aspects</category><body package="UIPainter">classModule	^classModule</body><body package="UIPainter">existingSelectorsHolder	^existingSelectorsHolder</body><body package="UIPainter">selectorHolder	^selectorHolder</body></methods><methods><class-id>Tools.ResourceInstallDialog</class-id> <category>interface opening</category><body package="UIPainter">loadSelect	"Open a dialog that does not offer an option to create a class"	self openInterface: #loadOnlySpec.	^accept value ifTrue: [self targetDefinition] ifFalse: [nil]</body><body package="UIPainter">postOpenWith: aBuilder	| classEntryController classEntryDispatcher |	super postOpenWith: aBuilder.	"For the class name field, we want continuous updating, when we leave the field, we want to see if it needs to be adjusted for ambiguity's sake."	classModule entryHolder onChangeSend: #classChanged to: self.	classEntryController := (classModule widgetAt: #entryField) controller.	classEntryDispatcher := UIDispatcher new.	classEntryDispatcher		receiver: self;		focusOutSelector: #checkForMultipleClassBindings.	classEntryController setDispatcher: classEntryDispatcher.	classEntryController continuousAccept: true.	classEntryController crBlock: 			[:char |			self checkForMultipleClassBindings.			self hasValidClassEntry				ifTrue: [classEntryController doDefaultAction]				ifFalse: 					[(aBuilder componentAt: #createNewClass) ifNotNil: [self openClassDialog]]].	"For the selector field, we also want continuous updating of the ok button."	(self widgetAt: #selectorComboBox) controller continuousAccept: true.	selectorHolder onChangeSend: #updateAcceptEnablement to: self.	self classChanged</body><body package="UIPainter">select	self open.	^accept value ifTrue: [self targetDefinition] ifFalse: [nil]</body></methods><methods><class-id>Tools.ResourceInstallDialog</class-id> <category>actions</category><body package="UIPainter">openClassDialog	| newClass creationDialog |	creationDialog := ClassCreationDialog new.	creationDialog superclass: ApplicationModel.	creationDialog nameHolder value: classModule value.	creationDialog open ifFalse: [^self].	newClass := (creationDialog nameSpaceOrDo: [^self])				defineClass: (creationDialog nameOrDo: [^self])				superclass: creationDialog superclassModule value asQualifiedReference				indexedType: creationDialog indexedType				private: creationDialog private				instanceVariableNames: creationDialog instanceVariables				classInstanceVariableNames: creationDialog classInstanceVariables				imports: creationDialog imports				category: ''				attributes: (Array with: (Array with: #package with: creationDialog packageModule value)).	self classCache add: newClass.	classModule value: (self printNameForClass: newClass).</body></methods><methods><class-id>Tools.ResourceInstallDialog class</class-id> <category>resources</category><body package="UIPainter">newClassGraphic	^Refactory.Browser.BrowserIcons addClass</body></methods><methods><class-id>Tools.DataSetEditTracker</class-id> <category>events</category><body package="UIPainter">currentScrollWidgetsHandle: anEvent	^(self currentScrollWidgetsHandler: anEvent) notNil</body><body package="UIPainter">currentScrollWidgetsHandler: anEvent	^self currentScrollWidgets		detect: [:each | each notNil and: [(each handlerForMouseEvent: anEvent) notNil]] 		ifNone: [nil]</body><body package="UIPainter">redButtonPressedEvent: anEvent	| localPoint |	self dataSetView		ifNil: 			[controller currentMode setValue: oldMode.			oldMode := nil.			^controller redButtonPressedEvent: anEvent].	localPoint := self dataSetView globalPointToLocal: anEvent point.	((self currentScrollWidgetsHandle: anEvent)		or: [self dataSetView bounds containsPoint: localPoint])			ifTrue: [self doSimpleSelectionFor: anEvent]			ifFalse: [self revertToPriorModeWith: anEvent]</body></methods><methods><class-id>Tools.DataSetEditTracker</class-id> <category>accessing</category><body package="UIPainter">currentScrollWidgets	^self dataSetView container dependents asOrderedCollection collect: 		[:each | 		(each isKindOf: Scrollbar)			ifTrue: [each]			ifFalse: [each myDependents]]</body><body package="UIPainter">dataSetView	controller primarySelection isNil ifTrue: [^nil].	^controller primarySelection widget</body><body package="UIPainter">specClass	^nil</body></methods><methods><class-id>Tools.DataSetEditTracker</class-id> <category>actions</category><body package="UIPainter">doSimpleSelectionFor: anEvent	| widget |	(self dataSetView bounds containsPoint: (self dataSetView globalPointToLocal: anEvent point))		ifTrue: [self dataSetView controller handleEvent: anEvent]		ifFalse: 			[((widget := self currentScrollWidgetsHandler: anEvent) isKindOf: Scrollbar)				ifTrue:[widget handleEvent: anEvent]				ifFalse: [widget controller selectEvent: anEvent]]</body><body package="UIPainter">revertToPriorModeWith: anEvent	controller currentMode setValue: oldMode.	self dataSetView 		selectionIndex: 0;		editMode: false.	oldMode := nil.	controller redButtonPressedEvent: anEvent.</body></methods><methods><class-id>Tools.DataSetEditTracker</class-id> <category>initialize-release</category><body package="UIPainter">setDataSetOn: aController with: anEvent	controller := aController.	oldMode := aController currentMode value.	self dataSetView notNil ifTrue: [self dataSetView controller handleEvent: anEvent].</body></methods><methods><class-id>Tools.DataSetEditTracker class</class-id> <category>initialize-release</category><body package="UIPainter">dataSetOn: aController with: anEvent	^self new setDataSetOn: aController with: anEvent</body></methods><methods><class-id>Tools.WindowOpenPositionToolModel</class-id> <category>actions</category><body package="UIPainter">clearUnusedValues: aWindowSpec	aWindowSpec 		positionType: nil;		sizeType: nil;		positionAutoSave: nil;		openPosition: nil;		sizeAutoSave: nil</body><body package="UIPainter">disableAdvanced	self disableGroup: self advancedGroup</body><body package="UIPainter">enableAdvanced	self enableGroup: self advancedGroup.	self disableGroup: #(#xPosition #yPosition #xLabel #yLabel)</body><body package="UIPainter">preapply	| workingValue windowSpec targetWindow |	windowSpec := propertiesTool spec.	(workingValue := self openType value) == #systemDefault 		ifTrue: [windowSpec openType: nil]		ifFalse: [windowSpec openType: workingValue].	propertiesTool controller model prefWindowExtent: self windowBounds extent.	windowSpec bounds: self windowBounds.	targetWindow := propertiesTool controller model mainWindow.	targetWindow setDisplayBox: (targetWindow globalOrigin extent: self windowBounds extent).	propertiesTool controller model minWindowExtent: self windowMin.	windowSpec min: self windowMin.	propertiesTool controller model maxWindowExtent: self windowMax.	windowSpec max: self windowMax.	self openType value ~= #advanced		ifTrue: [^self clearUnusedValues: windowSpec].	windowSpec positionType: self positionType value.	windowSpec sizeType: self sizeType value.	self positionType value == #lastSavedPosition		ifTrue: [windowSpec positionAutoSave: self positionAutoSave value]		ifFalse: [windowSpec positionAutoSave: nil].	self positionType value == #specifiedPosition		ifTrue: [windowSpec openPosition: self openPosition]		ifFalse: [windowSpec openPosition: nil].	self sizeType value == #lastSavedSize		ifTrue: [windowSpec sizeAutoSave: self sizeAutoSave value]		ifFalse: [windowSpec sizeAutoSave: nil]</body><body package="UIPainter">quietlyReloadSelectionInformation	specChannel setValue: propertiesTool spec.	self reloadSelectionInformation</body><body package="UIPainter">updateForOpenType	self openType value == #advanced 		ifTrue: [self enableAdvanced]		ifFalse: [self disableAdvanced].	self notifyParent.</body><body package="UIPainter">updateForPositionSave	self positionType value == #lastSavedPosition		ifTrue: [self enableGroup: #(#positionAutoSave)]		ifFalse: [self disableGroup: #(#positionAutoSave)].	self positionType value == #specifiedPosition		ifTrue: [self enableGroup: self specifiedPositionGroup]		ifFalse: [self disableGroup: self specifiedPositionGroup].	self notifyParent</body><body package="UIPainter">updateForSizeSave	self sizeType value == #lastSavedSize		ifTrue: [self enableGroup: #(#sizeAutoSave)]		ifFalse: [self disableGroup: #(#sizeAutoSave)].	self notifyParent</body><body package="UIPainter">updateMaximumSize	| rectangle |	(rectangle := self currentCanvasWindow bounds) notNil ifTrue:		[self maximumHeight value: rectangle height.		self maximumWidth value: rectangle width].</body><body package="UIPainter">updateMinimumSize	| rectangle |	(rectangle := self currentCanvasWindow bounds) notNil ifTrue:		[self minimumHeight value: rectangle height.		self minimumWidth value: rectangle width].</body><body package="UIPainter">updateSpecifiedSize	| rectangle |	(rectangle := self currentCanvasWindow bounds) notNil ifTrue:		[self height value: rectangle height.		self width value: rectangle width].</body></methods><methods><class-id>Tools.WindowOpenPositionToolModel</class-id> <category>aspects</category><body package="UIPainter">height	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^height isNil		ifTrue:			[height := 0 asValue]		ifFalse:			[height]</body><body package="UIPainter">maximumHeight	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^maximumHeight isNil		ifTrue:			[maximumHeight := 0 asValue]		ifFalse:			[maximumHeight]</body><body package="UIPainter">maximumWidth	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^maximumWidth isNil		ifTrue:			[maximumWidth := 0 asValue]		ifFalse:			[maximumWidth]</body><body package="UIPainter">minimumHeight	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^minimumHeight isNil		ifTrue:			[minimumHeight := 0 asValue]		ifFalse:			[minimumHeight]</body><body package="UIPainter">minimumWidth	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^minimumWidth isNil		ifTrue:			[minimumWidth := 0 asValue]		ifFalse:			[minimumWidth]</body><body package="UIPainter">openType	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^openType isNil		ifTrue:			[openType := #systemDefault asValue]		ifFalse:			[openType]</body><body package="UIPainter">positionAutoSave	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^positionAutoSave isNil		ifTrue:			[positionAutoSave := true asValue]		ifFalse:			[positionAutoSave]</body><body package="UIPainter">positionType	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^positionType isNil		ifTrue:			[positionType := #positionSystemDefault asValue]		ifFalse:			[positionType]</body><body package="UIPainter">sizeAutoSave	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^sizeAutoSave isNil		ifTrue:			[sizeAutoSave := true asValue]		ifFalse:			[sizeAutoSave]</body><body package="UIPainter">sizeType	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^sizeType isNil		ifTrue:			[sizeType := #specifiedSize asValue]		ifFalse:			[sizeType]</body><body package="UIPainter">width	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^width isNil		ifTrue:			[width := 0 asValue]		ifFalse:			[width]</body><body package="UIPainter">xPosition	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^xPosition isNil		ifTrue:			[xPosition := 0 asValue]		ifFalse:			[xPosition]</body><body package="UIPainter">yPosition	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^yPosition isNil		ifTrue:			[yPosition := 0 asValue]		ifFalse:			[yPosition]</body></methods><methods><class-id>Tools.WindowOpenPositionToolModel</class-id> <category>accessing</category><body package="UIPainter">openPosition	^self xPosition value @ self yPosition value</body><body package="UIPainter">windowBounds	^0 @ 0 extent: self width value @ self height value</body><body package="UIPainter">windowMax	^self maximumWidth value @ self maximumHeight value</body><body package="UIPainter">windowMin	^self minimumWidth value @ self minimumHeight value</body></methods><methods><class-id>Tools.WindowOpenPositionToolModel</class-id> <category>private</category><body package="UIPainter">advancedGroup	^#(#screenCenter #mouseCenter #lastSavedPosition #cascade #specifiedPosition #lastSavedSize #specifiedSize #xPosition #yPosition #xLabel #yLabel #positionSystemDefault)</body><body package="UIPainter">currentCanvasWindow	^UIPainterController lastControllerWithSelectionChannel value view topComponent</body><body package="UIPainter">loadDefaultMaximum	self maximumWidth value: 0.	self maximumHeight value: 0.</body><body package="UIPainter">loadDefaultMinimum	self minimumWidth value: WindowSpec initialMin x.	self minimumHeight value: WindowSpec initialMin y</body><body package="UIPainter">loadDefaultSpecfied	self height value: 200.	self width value: 200</body><body package="UIPainter">reloadSelectionInformation	| rectangle point |	(rectangle :=  specChannel value bounds) notNil 		ifTrue:			[self height value: rectangle height.			self width value: rectangle width]		ifFalse: [self loadDefaultSpecfied].	(point := specChannel value min) notNil 		ifTrue:			[self minimumWidth value: point x.			self minimumHeight value: point y]		ifFalse: [self loadDefaultMinimum].	(point := specChannel value max) notNil 		ifTrue:			[self maximumWidth value: point x.			self maximumHeight value: point y]		ifFalse: [self loadDefaultMaximum].	self openType value: specChannel value openType.	self openType value isNil ifTrue: [self openType value: #systemDefault].	self positionType value: specChannel value positionType.	self positionType value isNil ifTrue: [self positionType value: #positionSystemDefault].	self positionType value == #lastSavedPosition		ifTrue: [self positionAutoSave value: specChannel value positionAutoSave ~= false].	self yPosition value: specChannel value openPosition y.	self xPosition value: specChannel value openPosition x.	self sizeType value: specChannel value sizeType.	self sizeType value isNil ifTrue: [self sizeType value: #specifiedSize].	self sizeType value == #lastSavedSize		ifTrue: [self sizeAutoSave value: specChannel value sizeAutoSave ~= false].</body><body package="UIPainter">setInterestInHeightsAndWidths	self height onChangeSend: #notifyParent to: self.	self width onChangeSend: #notifyParent to: self.	self minimumHeight onChangeSend: #notifyParent to: self.	self minimumWidth onChangeSend: #notifyParent to: self.	self maximumHeight onChangeSend: #notifyParent to: self.	self maximumWidth onChangeSend: #notifyParent to: self.</body><body package="UIPainter">specifiedPositionGroup	^#(#xLabel #yLabel #xPosition #yPosition)</body></methods><methods><class-id>Tools.WindowOpenPositionToolModel</class-id> <category>interface opening</category><body package="UIPainter">buildInSubCanvas: spec withBuilder: aBuilder	super buildInSubCanvas: spec withBuilder: aBuilder.	self reloadSelectionInformation</body><body package="UIPainter">postBuildWith: aBuilder	self openType onChangeSend: #updateForOpenType to: self.	self positionType onChangeSend: #updateForPositionSave to: self.	self sizeType onChangeSend: #updateForSizeSave to: self.	self positionAutoSave onChangeSend: #notifyParent to: self.	self sizeAutoSave onChangeSend: #notifyParent to: self.	self setInterestInHeightsAndWidths.</body></methods><methods><class-id>Tools.BitEditor</class-id> <category>event driven</category><body package="UIPainter">blackenPointAt: pt 	"pt is an instance of Point, not the image pt 	touched"	| p |	p := view imageAtPoint: pt.	p isNil ifTrue: [^self].	model atPoint: p put: self foreground.	model changed: #invalidate with: (p extent: 1 @ 1).	self imageHasChanged: true</body><body package="UIPainter">redButtonPressedEvent: event	self selectEvent: event</body><body package="UIPainter">selectionTracker	^BitEditorTracker on: self.</body><body package="UIPainter">whitenPointAt: pt 	"pt is an instance of Point, not the image pt 	touched"	| p |	p := view imageAtPoint: pt.	p isNil ifTrue: [^self].	model atPoint: p put: self background.	model changed: #invalidate with: (p extent: 1 @ 1).	self imageHasChanged: true</body><body package="UIPainter">yellowButtonPressedEvent: event	self whitenPointAt: (self sensor cursorPointFor: event)</body></methods><methods><class-id>Tools.BitEditor</class-id> <category>accessing</category><body package="UIPainter">background	"Answer the receiver's background color."	background isNil		ifTrue: [ background := model palette indexOf: ColorValue white ].	^background</body><body package="UIPainter">background: aColorValue	"Set the receiver's background."	background := model palette indexOf: aColorValue.</body><body package="UIPainter">foreground	"Answer the receiver's foreground color."	foreground isNil		ifTrue: [ foreground := model palette indexOf: ColorValue black ].	^foreground</body><body package="UIPainter">foreground: aColorValue	"Set the receiver's foreground."	foreground := model palette indexOf: aColorValue.</body><body package="UIPainter">imageHasChanged	^imageHasChanged</body><body package="UIPainter">imageHasChanged: aBoolean	imageHasChanged := aBoolean</body><body package="UIPainter">updateRequest	"Answer false if the image has changed"	^self imageHasChanged not</body></methods><methods><class-id>Tools.BitEditor</class-id> <category>initialize-release</category><body package="UIPainter">initialize	super initialize.	imageHasChanged := false</body></methods><methods><class-id>Tools.SelectPlacementModeTracker</class-id> <category>events</category><body package="UIPainter">redButtonPressedEvent: anEvent 	| builder selectedWidget layout sensor |	builder := controller builder.	controller builder add: (self specFor: controller at: (controller gridPoint: (controller view globalPointToLocal: anEvent point))).	controller quietlySelect: (selectedWidget := builder wrapper).	(controller dragModeFor: selectedWidget)		dragObject: selectedWidget		startingAt: (controller gridPoint: (controller view globalPointToLocal: anEvent point))		inController: controller.	controller modeIsSticky		ifFalse: 			[UIPalette currentMode: #{SelectModeTracker} value new.			(layout := selectedWidget spec layout) class == Rectangle				ifTrue: [(sensor := controller sensor) cursorPoint: sensor cursorPoint + layout extent]].</body></methods><methods><class-id>UI.LabelAndValue</class-id> <category>accessing</category><body package="UIPainter">key: aKey value: anObject 	"Store the arguments as the variables of the receiver."	key := aKey.	value := anObject</body><body package="UIPainter">value	"Answer the value of the receiver."	^value</body><body package="UIPainter">value: anObject 	"Store the argument, anObject, as the value of the receiver."	value := anObject</body></methods><methods><class-id>UI.LabelAndValue</class-id> <category>printing</category><body package="UIPainter">displayString	"Allows a value to be quietly associated with the key that is 	displayed in a SequenceView."	^self key displayString</body></methods><methods><class-id>UI.LabelAndValue class</class-id> <category>instance creation</category><body package="UIPainter">key: newKey value: newValue	"Answer a new instance of the receiver with the arguments as the key and	value of the association."	^self new key: newKey value: newValue</body></methods><methods><class-id>Tools.DataSetCallbacksSpecModel</class-id> <category>aspects</category><body package="UIPainter">currentColumn	^currentColumn isNil ifTrue: [ currentColumn := DataSetColumnSpec new asValue ] ifFalse: [ currentColumn ]</body><body package="UIPainter">doubleClickSelector	"Use a BufferedValueHolder so that when the InputField 	does its autoaccept, it only gets accepted into the 	BufferedValueHolder.  Later, when either the 'accept' or 	the 'cancel' button is pressed, the trigger for the 	BufferedValueHolder is toggled appropriately"		^doubleClickSelector isNil		ifTrue: [doubleClickSelector := BufferedValueHolder subject: ((AspectAdaptor subjectChannel: self currentColumn sendsUpdates: false)							accessPath: #(#callbacksSpec);							forAspect: #doubleClickSelector) triggerChannel: self trigger]		ifFalse: [doubleClickSelector]</body><body package="UIPainter">focusInSelector	"Use a BufferedValueHolder so that when the InputField 	does its autoaccept, it only gets accepted into the 	BufferedValueHolder.  Later, when either the 'accept' or 	the 'cancel' button is pressed, the trigger for the 	BufferedValueHolder is toggled appropriately"		^focusInSelector isNil		ifTrue: [focusInSelector := BufferedValueHolder subject: ((AspectAdaptor subjectChannel: self currentColumn sendsUpdates: false)							accessPath: #(#callbacksSpec);							forAspect: #focusInSelector) triggerChannel: self trigger]		ifFalse: [focusInSelector]</body><body package="UIPainter">focusOutSelector	"Use a BufferedValueHolder so that when the InputField 	does its autoaccept, it only gets accepted into the 	BufferedValueHolder. Later, when either the 'accept' or 	the 'cancel' button is pressed, the trigger for the 	BufferedValueHolder is toggled appropriately"	^focusOutSelector isNil		ifTrue: [focusOutSelector := BufferedValueHolder subject: ((AspectAdaptor subjectChannel: self currentColumn sendsUpdates: false)							accessPath: #(#callbacksSpec);							forAspect: #focusOutSelector) triggerChannel: self trigger]		ifFalse: [focusOutSelector]</body><body package="UIPainter">requestDoubleClickSelector	"Use a BufferedValueHolder so that when the InputField 	does its autoaccept, it only gets accepted into the 	BufferedValueHolder. Later, when either the 'accept' or 	the 'cancel' button is pressed, the trigger for the 	BufferedValueHolder is toggled appropriately"	^requestDoubleClickSelector isNil		ifTrue: [requestDoubleClickSelector := BufferedValueHolder subject: ((AspectAdaptor subjectChannel: self currentColumn sendsUpdates: false)							accessPath: #(#callbacksSpec);							forAspect: #requestDoubleClickSelector) triggerChannel: self trigger]		ifFalse: [requestDoubleClickSelector]</body><body package="UIPainter">requestFocusInSelector	"Use a BufferedValueHolder so that when the InputField 	does its autoaccept, it only gets accepted into the 	BufferedValueHolder. Later, when either the 'accept' or 	the 'cancel' button is pressed, the trigger for the 	BufferedValueHolder is toggled appropriately"	^requestFocusInSelector isNil		ifTrue: [requestFocusInSelector := BufferedValueHolder subject: ((AspectAdaptor subjectChannel: self currentColumn sendsUpdates: false)							accessPath: #(#callbacksSpec);							forAspect: #requestFocusInSelector) triggerChannel: self trigger]		ifFalse: [requestFocusInSelector]</body><body package="UIPainter">requestFocusOutSelector	"Use a BufferedValueHolder so that when the InputField 	does its autoaccept, it only gets accepted into the 	BufferedValueHolder. Later, when either the 'accept' or 	the 'cancel' button is pressed, the trigger for the 	BufferedValueHolder is toggled appropriately"	^requestFocusOutSelector isNil		ifTrue: [requestFocusOutSelector := BufferedValueHolder subject: ((AspectAdaptor subjectChannel: self currentColumn sendsUpdates: false)							accessPath: #(#callbacksSpec);							forAspect: #requestFocusOutSelector) triggerChannel: self trigger]		ifFalse: [requestFocusOutSelector]</body><body package="UIPainter">requestValueChangeSelector	"Use a BufferedValueHolder so that when the InputField 	does its autoaccept, it only gets accepted into the 	BufferedValueHolder. Later, when either the 'accept' or 	the 'cancel' button is pressed, the trigger for the 	BufferedValueHolder is toggled appropriately"	^requestValueChangeSelector isNil		ifTrue: [requestValueChangeSelector := BufferedValueHolder subject: ((AspectAdaptor subjectChannel: self currentColumn sendsUpdates: false)							accessPath: #(#callbacksSpec);							forAspect: #requestValueChangeSelector) triggerChannel: self trigger]		ifFalse: [requestValueChangeSelector]</body><body package="UIPainter">trigger	"This is the trigger for accepting or canceling all of the 	buffered values"	^trigger isNil ifTrue: [ trigger := true asValue ] ifFalse: [ trigger ]</body><body package="UIPainter">valueChangeSelector	"Use a BufferedValueHolder so that when the InputField 	does its autoaccept, it only gets accepted into the 	BufferedValueHolder. Later, when either the 'accept' or 	the 'cancel' button is pressed, the trigger for the 	BufferedValueHolder is toggled appropriately"	^valueChangeSelector isNil		ifTrue: [valueChangeSelector := BufferedValueHolder subject: ((AspectAdaptor subjectChannel: self currentColumn sendsUpdates: false)							accessPath: #(#callbacksSpec);							forAspect: #valueChangeSelector) triggerChannel: self trigger]		ifFalse: [valueChangeSelector]</body></methods><methods><class-id>Tools.DataSetCallbacksSpecModel</class-id> <category>private</category><body package="UIPainter">changedSelection	"enable checkbox before the selection is changed or the next selection may remain incorrectly disabled	Check boxes support notification and validation but don't support d.clicks therefore disable the label and input field for d.clicks for checkboxes.	Finally, if the selection *was* just the dataset itself, don't do the pre-enabling of the check box's doubleClick info"	propertiesTool completeWorkOnPreviousSelection.	selectionChannel value == 0 		ifTrue: 			[self currentColumn value: specChannel value.			(self builder componentAt: #label) widget labelString: self class componentName]		ifFalse: 			[(self builder componentAt: #label) widget 				labelString: (#x1sColumn &lt;&lt; #UIPainter &gt;&gt; '&lt;1s&gt; Column' expandMacrosWith: self class componentName).			(self currentColumn value isKindOf: DataSetSpec) ifFalse: 					[(self builder componentAt: #fields) isEnabled ifFalse: [(self builder componentAt: #fields) enable].					self currentColumn value editorType = #CheckBox ifTrue: 							[(self builder componentAt: #doubleClickLabel) enable.							(self builder componentAt: #doubleClickMessage) enable]].			self currentColumn value: (specChannel value columns at: selectionChannel value).			self currentColumn value editorType = #CheckBox ifTrue: 					[(self builder componentAt: #doubleClickLabel) disable.					(self builder componentAt: #doubleClickMessage) disable].			(#(#rowSelector #None) includes: self currentColumn value editorType) ifTrue: 					[(self builder componentAt: #fields) disable.					self builder keyboardProcessor setFirstConsumer]]</body><body package="UIPainter">compute: aBlock	"do nothing, this block is never needed by this model"</body><body package="UIPainter">postBuildWith: aBuilder	self initSelectionChannel.	self changedSelection.	specChannel notNil ifTrue: [ specChannel addDependent: self ].</body></methods><methods><class-id>Tools.DataSetCallbacksSpecModel</class-id> <category>initialize-release</category><body package="UIPainter">initSelectionChannel	propertiesTool isNil ifTrue: [ ^self ].	selectionChannel := (propertiesTool selection at: 1) widget selectionChannel.	selectionChannel onChangeSend: #changedSelection to: self.</body><body package="UIPainter">release	selectionChannel notNil 		ifTrue: [ 			selectionChannel retractInterestsFor: self].	specChannel notNil ifTrue: [ specChannel removeDependent: self ].</body></methods><methods><class-id>Tools.DataSetCallbacksSpecModel</class-id> <category>actions</category><body package="UIPainter">preapply	"'Apply' has been pressed, trigger the BufferedValueHolders	so that their values are stored into their subjects"	self trigger value: true</body><body package="UIPainter">precancel	"drop all buffered values"	self trigger value: false.	^false</body></methods><methods><class-id>Tools.DataSetCallbacksSpecModel class</class-id> <category>private-interface building</category><body package="UIPainter">componentName	"Identification of component"	^(#Dataset &lt;&lt; #UIPainter &gt;&gt; 'Dataset') asString</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>private</category><body package="UIPainter">becomeLastControllerWithSelection	"Display any pending invalidation because setting	the value of LastControllerWithSelection may take	awhile."	self sensor window displayPendingInvalidation.	LastControllerWithSelection value: self</body><body package="UIPainter">broadcastPendingSelectionChange	LastControllerWithSelection changed: #pendingSelectionChange</body><body package="UIPainter">broadcastTopLevelPainter	LastControllerWithSelection changed: #topLevelPainter</body><body package="UIPainter">computeAlignmentPosition: aBlock forceNoPrimary: aBoolean	"Compute the box based on passed in block"	| currentSelections position |	(currentSelections := self selectionList) size &gt; 0 ifFalse: [^self].	position := aBlock value: currentSelections first bounds.	^(self primarySelection isNil or: [aBoolean])		ifFalse: [aBlock value: self primarySelection bounds]		ifTrue: 			[2 to: currentSelections size do: 				[:index | 				position := position max: (aBlock value: (currentSelections at: index) bounds)].			position]</body><body package="UIPainter">correctFraction: aValueModel	| num |	(num := self frameNumberFor: aValueModel) notNil		ifTrue:			[num &gt; 1.0 ifTrue: [aValueModel value: '1'].			num &lt; 0.0 ifTrue: [aValueModel value: '0']].</body><body package="UIPainter">defaultFraction: fractModel forOffsetString: offString	(fractModel value isEmpty and: [offString isEmpty not])		ifTrue: [fractModel value: '0']</body><body package="UIPainter">dispatchMenuSelection: aMenuItem 	"Set the receiver as the holder of the selection before invoking menu actions that use the selection."	aMenuItem value = 0 ifTrue: [ ^self ].	self becomeLastControllerWithSelection.	super dispatchMenuSelection: aMenuItem</body><body package="UIPainter">expandPaths: aSet	^(self model definer expandPaths: (aSet collect: [:asp | asp -&gt; nil])) collect: [:assn | assn key]</body><body package="UIPainter">fractionalConstraintDialogForOriginal: sel frame: aFrame	"In underconstrained situations due to null values among the new 	numbers, attempt to maintain the current width and/or height of 	the selection. Otherwise, a nil value means the user doesn't want 	that part of the layout to change.  Begin by doing the equivalent	of an anchor, reestablishing the fractions of the layout while keeping	the figure stationary; then layer in the offset information."	"This method could be simplified considerably if LayoutOrigins	responded to AlignmentOrigin protocol, but for the moment we	are trying to minimize changes to the base product."	|  frame  leftOffset leftFraction topOffset topFraction  alignmentX alignmentY dialog bounds  box newLeftFraction newTopFraction newLeftOffset newTopOffset newAlignmentX newAlignmentY builder |	frame := aFrame.	leftFraction := self frameValueHolderFor: frame leftFraction.	(leftOffset := self frameValueHolderFor: frame leftOffset)		compute:			[:v |			(leftFraction value = '' and: [(v = '') not])				ifTrue: [leftFraction value: '0']].	topFraction := self frameValueHolderFor: frame topFraction.	(topOffset := self frameValueHolderFor: frame topOffset)		compute:			[:v |			(topFraction value = '' and: [(v = '') not])				ifTrue: [topFraction value: '0']].	(frame isKindOf: AlignmentOrigin)		ifTrue: [alignmentX := self frameValueHolderFor: frame leftAlignmentFraction.				alignmentY := self frameValueHolderFor: frame topAlignmentFraction]		ifFalse: [alignmentX := self frameValueHolderFor: 0.				alignmentY := self frameValueHolderFor: 0].	dialog :=SimpleDialog new.	builder := dialog builder.	builder source: self.	builder aspectAt: #leftOffset put: leftOffset.	builder aspectAt: #leftFraction put: leftFraction.	builder aspectAt: #topOffset put: topOffset.	builder aspectAt: #topFraction put: topFraction.	builder aspectAt: #alignmentX put: alignmentX.	builder aspectAt: #alignmentY put: alignmentY.	builder aspectAt: #leftSlide put: (TypeConverter on: leftFraction) stringToNumber.	builder aspectAt: #topSlide put: (TypeConverter on: topFraction) stringToNumber.	builder aspectAt: #alignmentXSlide put: (TypeConverter on: alignmentX) stringToNumber.	builder aspectAt: #alignmentYSlide put: (TypeConverter on: alignmentY) stringToNumber.	builder aspectAt: #emptyAlignmentX put: [alignmentX value: ''].	builder aspectAt: #emptyAlignmentY put: [alignmentY value: ''].	builder aspectAt: #emptyLeft put: [leftOffset value: ''. leftFraction value: ''].	builder aspectAt: #emptyTop put: [topOffset value: ''. topFraction value: ''].	(dialog openFrom: (self class interfaceSpecFor: #placementFrameDialogSpec)) ifFalse: [^self].	bounds := self view bounds.	frame := sel layout asLayout copy.	box := sel bounds.	(newLeftFraction := self frameNumberFor: leftFraction) notNil		ifTrue:			[frame leftFraction: newLeftFraction.			frame leftOffset:				(box left +					((frame isKindOf: AlignmentOrigin)						ifTrue: [box width * frame leftAlignmentFraction]						ifFalse: [0]) -					(bounds width * newLeftFraction) rounded)].	(newTopFraction := self frameNumberFor: topFraction) notNil		ifTrue:			[frame topFraction: newTopFraction.			frame topOffset:				(box top +					((frame isKindOf: AlignmentOrigin)						ifTrue: [box height * frame topAlignmentFraction]						ifFalse: [0]) -					(bounds height * newTopFraction) rounded)].	newLeftOffset := self frameNumberFor: leftOffset.	newTopOffset := self frameNumberFor: topOffset.	newAlignmentX := self frameNumberFor: alignmentX.	newAlignmentY := self frameNumberFor: alignmentY.	(newAlignmentX notNil or: [newAlignmentY notNil])		ifTrue:			[((newAlignmentX ~= 0 or: [newAlignmentY ~= 0]) and:					[(frame isKindOf: AlignmentOrigin) not])				ifTrue: [frame := frame asAlignmentOrigin]].	newLeftOffset notNil		ifTrue: [frame leftOffset: newLeftOffset]		ifFalse:			[newAlignmentX notNil				ifTrue:					[frame leftOffset: frame leftOffset +						(((newAlignmentX -							((frame isKindOf: AlignmentOrigin)								ifTrue: [frame leftAlignmentFraction]								ifFalse: [0])) * box width) rounded)]].	newTopOffset notNil		ifTrue: [frame topOffset: newTopOffset]		ifFalse:			[newAlignmentY notNil				ifTrue:					[frame topOffset: frame topOffset +						(((newAlignmentY -							((frame isKindOf: AlignmentOrigin)								ifTrue: [frame topAlignmentFraction]								ifFalse: [0])) * box height) rounded)]].	(frame isKindOf: AlignmentOrigin)		ifTrue:			[newAlignmentX notNil				ifTrue: [frame leftAlignmentFraction: newAlignmentX].			newAlignmentY notNil				ifTrue: [frame topAlignmentFraction: newAlignmentY]].	(self validateFrame: frame for: sel widget)		ifFalse: [^self].	sel newLayout: frame reducedForm.	view bounds: view bounds.	view topComponent display.	self canvasHasChanged: true.	^self</body><body package="UIPainter">fractionalConstraintDialogForRectangular: sel frame: aFrame	|  frame  leftOffset leftFraction rightOffset rightFraction topOffset topFraction bottomOffset bottomFraction dialog bounds oldFrame box newLeftFraction newTopFraction newLeftOffset newTopOffset newRightFraction newBottomFraction newRightOffset newBottomOffset builder |	frame := aFrame.	(leftFraction := self frameValueHolderFor: frame leftFraction)		compute: [:v | self correctFraction: leftFraction].	(leftOffset := self frameValueHolderFor: frame leftOffset)		compute: [:v | self defaultFraction: leftFraction forOffsetString: v].	(rightFraction := self frameValueHolderFor: frame rightFraction)		compute: [:v | self correctFraction: rightFraction].	(rightOffset := self frameValueHolderFor: frame rightOffset)		compute: [:v | self defaultFraction: rightFraction forOffsetString: v].	(topFraction := self frameValueHolderFor: frame topFraction)		compute: [:v | self correctFraction: topFraction].	(topOffset := self frameValueHolderFor: frame topOffset)		compute: [:v | self defaultFraction: topFraction forOffsetString: v].	(bottomFraction := self frameValueHolderFor: frame bottomFraction)		compute: [:v | self correctFraction: bottomFraction].	(bottomOffset := self frameValueHolderFor: frame bottomOffset)		compute: [:v | self defaultFraction: bottomFraction forOffsetString: v].	dialog :=SimpleDialog new.	builder := dialog builder.	builder source: self.	builder aspectAt: #leftOffset put: leftOffset.	builder aspectAt: #leftFraction put: leftFraction.	builder aspectAt: #topOffset put: topOffset.	builder aspectAt: #topFraction put: topFraction.	builder aspectAt: #rightOffset put: rightOffset.	builder aspectAt: #rightFraction put: rightFraction.	builder aspectAt: #bottomOffset put: bottomOffset.	builder aspectAt: #bottomFraction put: bottomFraction.	builder aspectAt: #leftSlide put: (TypeConverter on: leftFraction) stringToNumber.	builder aspectAt: #topSlide put: (TypeConverter on: topFraction) stringToNumber.	builder aspectAt: #rightSlide put: (TypeConverter on: rightFraction) stringToNumber.	builder aspectAt: #bottomSlide put: (TypeConverter on: bottomFraction) stringToNumber.	builder aspectAt: #emptyLeft put: [leftOffset value: ''. leftFraction value: ''].	builder aspectAt: #emptyTop put: [topOffset value: ''. topFraction value: ''].	builder aspectAt: #emptyRight put: [rightOffset value: ''. rightFraction value: ''].	builder aspectAt: #emptyBottom put: [bottomOffset value: ''. bottomFraction value: ''].	(dialog openFrom: (self class interfaceSpecFor: #layoutFrameDialogSpec)) ifFalse: [^self].	bounds := self view bounds.	frame := sel layout asLayout copy.	oldFrame := frame copy.	box := sel bounds.	(newLeftFraction := self frameNumberFor: leftFraction) notNil		ifTrue:			[frame leftFraction: newLeftFraction.			frame leftOffset:				(box left - (bounds width * newLeftFraction) rounded)].	(newTopFraction := self frameNumberFor: topFraction) notNil		ifTrue:			[frame topFraction: newTopFraction.			frame topOffset:				(box top - (bounds height * newTopFraction) rounded)].	newLeftOffset := self frameNumberFor: leftOffset.	newTopOffset := self frameNumberFor: topOffset.	(newRightFraction := self frameNumberFor: rightFraction) notNil		ifTrue:			[frame rightFraction: newRightFraction.			frame rightOffset:				(box right - (bounds width * newRightFraction) rounded)].	(newBottomFraction := self frameNumberFor: bottomFraction) notNil		ifTrue:			[frame bottomFraction: newBottomFraction.			frame bottomOffset:				(box bottom - (bounds height * newBottomFraction) rounded)].	newRightOffset := self frameNumberFor: rightOffset.	newBottomOffset := self frameNumberFor: bottomOffset.	newLeftOffset notNil		ifTrue: [frame leftOffset: newLeftOffset]		ifFalse:			[newRightOffset notNil				ifTrue:					[frame leftOffset:						frame leftOffset							+ (bounds width * (newRightFraction - oldFrame rightFraction)) rounded							+ newRightOffset - oldFrame rightOffset]].	newTopOffset notNil		ifTrue: [frame topOffset: newTopOffset]		ifFalse:			[newBottomOffset notNil				ifTrue:					[frame topOffset:						frame topOffset							+ (bounds height * (newBottomFraction - oldFrame bottomFraction)) rounded							+ newBottomOffset - oldFrame bottomOffset]].	newRightOffset notNil		ifTrue: [frame rightOffset: newRightOffset]		ifFalse:			[newLeftOffset notNil				ifTrue:					[frame rightOffset:						frame rightOffset							+ (bounds width * (newLeftFraction - oldFrame leftFraction)) rounded							+ newLeftOffset - oldFrame leftOffset]].	newBottomOffset notNil		ifTrue: [frame bottomOffset: newBottomOffset]		ifFalse:			[newTopOffset notNil				ifTrue:					[frame bottomOffset:						frame bottomOffset							+ (bounds height * (newTopFraction - oldFrame topFraction)) rounded							+ newTopOffset - oldFrame topOffset]].	(self validateFrame: frame for: sel widget)		ifFalse: [^self].	sel newLayout: frame reducedForm.	view bounds: view bounds.	view topComponent display.	self canvasHasChanged: true.	^self</body><body package="UIPainter">frameNumberFor: aValueModel	| s |	s := aValueModel value.	s isEmpty ifTrue: [^nil].	^Locale current readNumberFrom: s readStream skipSeparators type: Number</body><body package="UIPainter">frameValueHolderFor: aNumber 	^(Locale current printAsNumber: aNumber) asValue</body><body package="UIPainter">installApplicationNamedFonts	"We're here to spoof what an ApplicationModel does, because I have window specs!"</body><body package="UIPainter">layoutSelectionsBy: aBlock 	| selectedComponents formerSelections formerPrimarySelectionSpec newSelections parents formerComposite |	self broadcastPendingSelectionChange.	selectedComponents := self selectedComponents.	selectedComponents isEmpty ifTrue: [^self].	formerSelections := SpecCollection new 				extractFromCollection: selectedComponents.	formerPrimarySelectionSpec := self primarySelection notNil 				ifTrue: [self primarySelection spec]				ifFalse: [nil].	self quietlyRemoveSelections.	parents := selectedComponents collect: [:each | each container].	selectedComponents do: 			[:each | 			aBlock value: each.			view remove: each.			each release].	newSelections := OrderedCollection new: selectedComponents size.	formerComposite := self builder composite.	formerSelections collection with: parents		do: 			[:each :parent | 			parent isComposite 				ifTrue: 					[self builder composite: parent.					newSelections add: (self builder add: each).					self builder composite: formerComposite]				ifFalse: [newSelections add: (self builder add: each)]].	newSelections := newSelections asArray.	formerPrimarySelectionSpec isNil 		ifTrue: [self selectionList: newSelections]		ifFalse: 			[self select: (newSelections 						detect: [:each | each spec == formerPrimarySelectionSpec]).			self appendSelections: (newSelections 						reject: [:each | each spec == formerPrimarySelectionSpec])].	self canvasHasChanged: true.	self notifyTreeChange</body><body package="UIPainter">quietlyNoteChangeToCanvas	canvasHasChanged := true</body><body package="UIPainter">replaceSubCanvasesOfClass: aClassName andSelector: aSelector	|  targetWrappers oldSels oldState |	oldSels := self selectionList copy.	targetWrappers := IdentitySet new.	view		downcastEvent: #mapBlock		with:			[:wrpr |			| spec |			((wrpr respondsTo: #spec) and: [((spec := wrpr spec) isKindOf: SubCanvasSpec) and:				[spec majorKey asQualifiedReference = aClassName asQualifiedReference and:					[spec minorKey == aSelector]]])				ifTrue:					[targetWrappers add: wrpr]]		from: view.	targetWrappers isEmpty ifTrue: [^self].	"The subcanvas that needs updating may be buried at any depth within the	structure."	targetWrappers copy do:		[:wrpr |		(view components includes: wrpr)			ifFalse:				[targetWrappers remove: wrpr.				targetWrappers addAll: (self model definer findSelectablesIn: self havingSpecs: (Array with: wrpr spec))]].	oldState := self canvasHasChanged.	targetWrappers do:		[:wrpr |		| new |		new := self replaceElement: wrpr basedOnSpec: wrpr spec.		(oldSels includes: wrpr)			ifTrue: [self quietlySelect: new]].	canvasHasChanged := oldState.	"The canvas that we just updated ourselves for may not be present in some	subcanvas structures that include us, simply because those structures were	built before the canvas was created.  Force the dependents that know about	us to update themselves.  This is going to result in some canvases getting	multiply updated; not nice, but better than missing updates."	(self model targetClass notNil and: [self model targetSelector notNil])		ifTrue:			[UIFinderVW2 changed: #installedCanvas					with: (Array with: model targetClass with: model targetSelector)]</body><body package="UIPainter">validateFrame: aFrame for: aComponent	"Return true if the component's placement will be satisfactory (at	least partially within aController's view, and not inside-out),	otherwise return false.  As a side effect, generate a warning	dialog for the user."	| outerBox wSpec innerBox |	outerBox := self view bounds.	wSpec := self model windowSpec.	wSpec hasHorizontalScrollBar		ifTrue:			[outerBox width:				(outerBox extent x max: self view preferredWidth)].	wSpec hasVerticalScrollBar		ifTrue:			[outerBox height:				(outerBox extent y max: self view preferredHeight)].	innerBox := aFrame		rectangleRelativeTo: outerBox		preferred: aComponent preferredBounds.	(innerBox left &gt;= innerBox right or:			[innerBox top &gt;= innerBox bottom])		ifTrue:			[Dialog warn:				(#GenKey137 &lt;&lt; #UIPainter &gt;&gt; 'Those settings would have given the selected itema degenerate layout.  Operation cancelled') for: view.			^false].	(self isFenced			ifTrue: [outerBox contains: innerBox]			ifFalse: [innerBox intersects: outerBox])		ifFalse:			[Dialog warn:				(#GenKey136 &lt;&lt; #UIPainter &gt;&gt; 'These settings would have put the selected itemout of bounds.  Operation cancelled') for: view.			^false].	^true</body><body package="UIPainter">visualFor: aSymbol	^self class perform: aSymbol</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>private-keyboard</category><body package="UIPainter">alignBottomKey: anEvent	self doVerticalAlign: #bottom forceNoPrimary: anEvent shiftDown</body><body package="UIPainter">alignDialogKey: event	self alignDialog</body><body package="UIPainter">alignLeftKey: anEvent	self doHorizontalAlign: #left forceNoPrimary: anEvent shiftDown</body><body package="UIPainter">alignRightKey: anEvent	self doHorizontalAlign: #right forceNoPrimary: anEvent shiftDown</body><body package="UIPainter">alignTopKey: anEvent	self doVerticalAlign: #top forceNoPrimary: anEvent shiftDown</body><body package="UIPainter">beFixedKey: aKey	| bounds |	bounds := view bounds.	self selectionList do: [:s | s beFixedIn: bounds].	self canvasHasChanged: true.</body><body package="UIPainter">beRelativeKey: aKey	| bounds sl |	bounds := view bounds.	sl := self selectionList.	1 to: sl size  do:		[:i |		| s |		s := sl at: i.		s beRelativeIn: bounds].	self canvasHasChanged: true.</body><body package="UIPainter">bumpDownKey: ignored	| delta sl |	self flushAllLeadingWithValue: #Down.	sl := self selectionList.	sl isEmpty ifTrue: [^self].	delta := griddedVertically value not		ifTrue: [0@1]		ifFalse: [0@gridStep value].	self hideHandles.	((self sensor shiftDown) or: [self sensor metaDown])		ifTrue: [sl do: [:w | view changeExtent: w by: delta]]		ifFalse:			[self sensor ctrlDown				ifTrue: [sl do: [:w | view changeOrigin: w by: delta]]				ifFalse: [sl do: [:w | view move: w by: delta]]].	self canvasHasChanged: true.	self showHandles.	view invalidate</body><body package="UIPainter">bumpLeftKey: ignored	| delta sl |	self flushAllLeadingWithValue: #Left.	sl := self selectionList.	sl isEmpty ifTrue: [^self].	delta := griddedHorizontally value not		ifTrue: [1 negated@0]		ifFalse: [gridStep value negated@0].	self hideHandles.	((self sensor shiftDown) or: [self sensor metaDown])		ifTrue: [sl do: [:w | view changeExtent: w by: delta]]		ifFalse:			[self sensor ctrlDown				ifTrue: [sl do: [:w | view changeOrigin: w by: delta]]				ifFalse: [sl do: [:w | view move: w by: delta]]].	self canvasHasChanged: true.	self showHandles.	view invalidate</body><body package="UIPainter">bumpRightKey: ignored	| delta sl |	self flushAllLeadingWithValue: #Right.	sl := self selectionList.	sl isEmpty ifTrue: [^self].	delta := griddedHorizontally value not		ifTrue: [1@0]		ifFalse: [gridStep value@0].	self hideHandles.	((self sensor shiftDown) or: [self sensor metaDown])		ifTrue: [sl do: [:w | view changeExtent: w by: delta]]		ifFalse:			[self sensor ctrlDown				ifTrue: [sl do: [:w | view changeOrigin: w by: delta]]				ifFalse: [sl do: [:w | view move: w by: delta]]].	self canvasHasChanged: true.	self showHandles.	view invalidate</body><body package="UIPainter">bumpUpKey: ignored	| delta sl |	self flushAllLeadingWithValue: #Up.	sl := self selectionList.	sl isEmpty ifTrue: [^self].	delta := griddedVertically value not		ifTrue: [0@1 negated]		ifFalse: [0@gridStep value negated].	self hideHandles.	((self sensor shiftDown) or: [self sensor metaDown])		ifTrue: [sl do: [:w | view changeExtent: w by: delta]]		ifFalse:			[self sensor ctrlDown				ifTrue: [sl do: [:w | view changeOrigin: w by: delta]]				ifFalse: [sl do: [:w | view move: w by: delta]]].	self canvasHasChanged: true.	self showHandles.	view invalidate</body><body package="UIPainter">circulateBackKey: ev	^self toVisualBackOne</body><body package="UIPainter">circulateFrontKey: ev	^self toVisualFrontOne</body><body package="UIPainter">circulateKey: ev	ev keyValue == Ctrlf		ifTrue: [^self circulateFrontKey: ev].	ev keyValue == Ctrlb		ifTrue: [^self circulateBackKey: ev]</body><body package="UIPainter">copyKey: event	self doCopy.</body><body package="UIPainter">cutKey: event	self doCut.</body><body package="UIPainter">dialogKey: event	self doPainterTool</body><body package="UIPainter">distributeDialogKey: event	self distributeDialog</body><body package="UIPainter">equalizeDialogKey: event	self equalizeDialog</body><body package="UIPainter">flushAllLeadingWithValue: eventCharacter	"Do nothing"</body><body package="UIPainter">groupKey: event	self doGroup</body><body package="UIPainter">ignoreInputKey: event</body><body package="UIPainter">installKey: anEvent	self doInstall</body><body package="UIPainter">keyboardActivity: anEvent for: aControl	KeyboardDispatchTable 		add: anEvent		do: [:charEvent :sel | self perform: sel with: charEvent].	^nil</body><body package="UIPainter">keyboardHook	^[:event :control | self keyboardActivity: event for: control]</body><body package="UIPainter">layoutKey: event	self fractionalConstraintDialog</body><body package="UIPainter">pasteKey: event	self doPaste.</body><body package="UIPainter">redoKey: event</body><body package="UIPainter">snapSelectionToGridKey: event	self doSnapSelectionToGrid</body><body package="UIPainter">undoKey: event	self doUndo.</body><body package="UIPainter">ungroupKey: event	self doUngroup</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>commands</category><body package="UIPainter">accept	model accept.	self notifyTreeChange</body><body package="UIPainter">alignDialog	| op builder dialog ornt anchor hAlignChoice vAlignChoice |	self selectionList size &gt; 1 ifFalse: [^self].	op := OperationParameters.	builder := (dialog := SimpleDialog new) builder.	builder aspectAt: #orientation put: (ornt := op at: #alignOrientation).	builder aspectAt: #anchor put:		(anchor := (self primarySelection isNil ifTrue: [#furthest] ifFalse: [#first]) asValue).	ornt		compute: 			[:v | 			v == #vertical				ifTrue: 					[(builder componentAt: #VertChoices) beVisible.					(builder componentAt: #HorizChoices) beInvisible].			v == #horizontal				ifTrue: 					[(builder componentAt: #VertChoices) beInvisible.					(builder componentAt: #HorizChoices) beVisible]].	hAlignChoice := builder aspectAt: #hAlign put: (op at: #hAlignChoices).	vAlignChoice := builder aspectAt: #vAlign put: (op at: #vAlignChoices).	builder 		aspectAt: #apply 		put: 			[ornt value == #horizontal				ifTrue:					[self doHorizontalAlign: hAlignChoice value forceNoPrimary: anchor value == #furthest]				ifFalse:					[self doVerticalAlign: vAlignChoice value forceNoPrimary: anchor value == #furthest].			dialog accept value: true].	dialog allButOpenFrom: (self class interfaceSpecFor: #alignDialogSpec).	ornt value: ornt value.	self primarySelection isNil		ifTrue:			[(builder componentAt: #firstButton1) disable.			(builder componentAt: #firstButton2) disable].	builder openDialog.	op do: [:value | value release]</body><body package="UIPainter">cancel	model cancel.	self notifyTreeChange</body><body package="UIPainter">distributeDialog	| op builder dialog ornt mode spacingConstant |	self selectionList size &gt; 1 ifFalse: [^self].	op := OperationParameters.	builder := (dialog := SimpleDialog new) builder.	ornt := builder aspectAt: #orientation put: (op at: #distributeOrientation).	mode := builder aspectAt: #mode put: (op at: #distributeChoices).	mode compute:		[:v |		v == #edgespace			ifTrue: [(builder componentAt: #constantField) enable]			ifFalse: [(builder componentAt: #constantField) disable]].	spacingConstant := builder aspectAt: #spacingConstant put: (op at: #distributeConstant).	builder aspectAt: #apply put: 		[ornt value == #horizontal			ifTrue:				[self					doHorizontalDistribute: mode value					spacing: (mode value == #edgespace								ifTrue: [spacingConstant value]								ifFalse: [nil])]			ifFalse:				[self					doVerticalDistribute: mode value					spacing: (mode value == #edgespace								ifTrue: [spacingConstant value]								ifFalse: [nil])].			dialog accept value: true].	dialog allButOpenFrom: (self class interfaceSpecFor: #distributeDialogSpec).	mode value: mode value.	builder openDialog.	op do: [:value | value release]</body><body package="UIPainter">doBrowse	| sels models targetClass |	sels := self selectionList.	models := Set new.	(sels isEmpty not and:			[| missing |			missing := false.			sels do:				[:sw |				| mdls |				(mdls := sw spec models) isEmpty not					ifTrue: [models addAll: mdls]					ifFalse: [missing := true]].			missing])		ifTrue:			[sels size == 1				ifTrue:					[Dialog warn: (#GenKey118 &lt;&lt; #UIPainter &gt;&gt; 'The selected component''s propertiesdon''t specify a model') for: view.					^self]				ifFalse:					[Dialog warn: (#GenKey117 &lt;&lt; #UIPainter &gt;&gt; 'Some of the selected components''properties don''t specify models') for: view]].	(targetClass :=self model targetClass) isNil		ifTrue:			[Dialog warn: (#GenKey116 &lt;&lt; #UIPainter &gt;&gt; 'The canvas isn''t installed on any class yet') for: view.			^self].	sels size == 0		ifTrue: [SmalltalkWorkbench browseClass: targetClass]		ifFalse:			[UIPainter				browseWiringTo: (self expandPaths: models) asOrderedCollection				within: targetClass]</body><body package="UIPainter">doBrowseApplication	| spec clName cl |	spec := self selectionList first spec.	(clName := spec majorKey) isNil		ifTrue:			[^Dialog warn: (#PropertiesSpecifyNoClass &lt;&lt; #UIPainter &gt;&gt; 'The selected subcanvas'' properties don''t specify a class') for: view].	cl := clName asQualifiedReference valueOrDo: [^Dialog warn: (#GenKey119 &lt;&lt; #UIPainter &gt;&gt; 'The selected subcanvas'' properties specify an undefined class') for: view].	SmalltalkWorkbench browseClass: cl</body><body package="UIPainter">doCatalogID	| dialogMessage newCatagory |	dialogMessage := (model targetClass class includesSelector: #messageCatalogID)		ifTrue: 			[(#GenKey123 &lt;&lt; #UIPainter &gt;&gt; 'This application has defined its message catalog name &lt;1p&gt;.&lt;n&gt;By default, all text labels which do not have their own&lt;n&gt;locally specified message catalogwill use this message catalog&lt;n&gt;Enter the name of a new default message catalog and press OK&lt;n&gt;Or press cancel to not change the default message catalog at this time') expandMacrosWith: model targetClass messageCatalogID asString]		ifFalse: 			[model targetClass messageCatalogID isNil				ifTrue: [(#GenKey122 &lt;&lt; #UIPainter &gt;&gt; 'This application does not define a default message catalog.&lt;n&gt;Enter the name for a message catalog and press OK&lt;n&gt;Or press cancel to not define a default message catalog at this time') expandMacros ]				ifFalse:[(#GenKey121 &lt;&lt; #UIPainter &gt;&gt; 'This application inherits its message catalog &lt;1p&gt; from its superclass. &lt;n&gt;Enter the name of a new default message catalog to use for this class only and press OK&lt;n&gt;Or press cancel to not change the default message catalog at this time') expandMacrosWith: model targetClass messageCatalogID asString]].	newCatagory := Dialog		request: dialogMessage		initialAnswer: (model targetClass messageCatalogID isNil ifTrue: [''] ifFalse: [model targetClass messageCatalogID])		onCancel: [^self]		windowLabel: (#CatalogMessageName &lt;&lt; #UIPainter &gt;&gt; 'Catalog Message Name')		for: self view topComponent.	newCatagory isEmpty ifFalse: [model definer addCatalogID: newCatagory]</body><body package="UIPainter">doCopy	| selectedComponents |	selectedComponents := self selectedComponents.	selectedComponents isEmpty ifTrue: [^self].	ScrapPrimary := self primarySelection notNil		ifTrue: [SpecCollection new fromCollection: (Array with: self primarySelection)]		ifFalse: [nil].	Scrap := SpecCollection new fromCollection:		(selectedComponents copyWithout: (selectedComponents detect: [:each | each == self primarySelection] ifNone: []))</body><body package="UIPainter">doCut	| sel  bldr walker |	self broadcastPendingSelectionChange.	sel := self selectedComponents.	sel isEmpty ifTrue: [^self].	self quietlyNoteChangeToCanvas.	ScrapPrimary :=		self primarySelection notNil			ifTrue:				[SpecCollection new fromCollection:					(Array with: self primarySelection)]			ifFalse: [nil].	Scrap :=		SpecCollection new fromCollection:			(sel copyWithout:				(sel detect: [:sw | sw == self primarySelection] ifNone: [])).	bldr := self builder.	walker := FilteredSpecEnumerator new.	walker block: [:s | s name == nil ifFalse: [bldr namedComponents removeKey: s name ifAbsent: []]. true].	ScrapPrimary == nil ifFalse: [walker doSpec: ScrapPrimary].	Scrap == nil ifFalse: [walker doSpec: Scrap]. 	self removeSelections.	sel do: [:s | view removeComponent: s. s release].	self notifyTreeChange.	view invalidateNow.</body><body package="UIPainter">doDefine	model definer		interactivelyUpgradeDefns: self selectionList copy		for: self</body><body package="UIPainter">doDefineApplication	"After defining the class bring a dialog canvas composer to give the utility of defining the interface just there"	| spec wrpr className  org newClass pntr finder |	spec := (wrpr := self selectionList first) spec.	(spec majorKey) isNil		ifTrue: 			[Dialog warn: (#PropertiesSpecifyNoClass &lt;&lt; #UIPainter &gt;&gt; 'The selected subcanvas'' properties don''t specify a class') for: view.			^self].	className := spec majorKey asQualifiedReference.	className isDefined		ifTrue: 			[(Dialog				choose: ((#GenKey124 &lt;&lt; #UIPainter &gt;&gt; 'Class &lt;1s&gt;&lt;nn&gt;is already defined.  Redefine it?')			expandMacrosWith: className asString)				labels: (Array with: (#Redefine &lt;&lt; #UIPainter &gt;&gt; 'Redefine') with: (#Cancel &lt;&lt; #UIPainter &gt;&gt; 'Cancel'))				values: #(#proceed #cancel )				default: #cancel				for: view)				~~ #proceed ifTrue: [^self].			(org := className value category) isNil ifTrue: [org := #'LensApplications-New']]		ifFalse: [org := (model targetClass isNil or: [org := model targetClass category]) isNil						ifTrue: [#'LensApplications-New']						ifFalse: [org]].	finder := ClassFinder new.	finder className value: className asString.	finder classCategory value: org asString.	finder createMode; findClass.	newClass := finder selectedClass.	newClass notNil		ifTrue:			[pntr := UIPainter new openOnClass: newClass andSelector: nil.			self select: wrpr.			spec minorKey notNil ifTrue: [pntr targetSelector: spec minorKey]]</body><body package="UIPainter">doDelete	| sel  bldr walker |	self broadcastPendingSelectionChange.	sel := self selectedComponents select:[:each| each isOpen].	sel isEmpty ifTrue: [^self].	self quietlyNoteChangeToCanvas.	bldr := self builder.	walker := FilteredSpecEnumerator new.	walker block: [:s | s name == nil ifFalse: [bldr namedComponents removeKey: s name ifAbsent: []]. true].	ScrapPrimary == nil ifFalse: [walker doSpec: ScrapPrimary].	Scrap == nil ifFalse: [walker doSpec: Scrap]. 	self removeSelections.	sel do: [:s | view removeComponent: s. s release].	self notifyTreeChange</body><body package="UIPainter">doFileOutNamedFonts	| dialog builder spec |	builder := (dialog := SimpleDialog new) builder.	spec := self model windowSpec.	builder aspectAt: #namedFontFileOutType put: spec namedFontFileOutTypeSelection asValue.	builder aspectAt: #defineFontLoadingMethod put: spec defineFontLoadingMethodSelection asValue.	builder aspectAt: #savedFontFileName put: spec savedFontFileNameSelection asValue.	builder 		aspectAt: #apply 		put: 			[ | fileName |			(fileName := (builder aspectAt: #savedFontFileName) value) isEmpty not ifTrue: 				[spec namedFontFileOutType: (builder aspectAt: #namedFontFileOutType) value.				spec defineFontLoadingMethod: (builder aspectAt: #defineFontLoadingMethod) value.				spec savedFontFileName: fileName.				model definer saveAndDefineNamedFonts: model extractFullSpec.				dialog accept value: true]].	dialog allButOpenFrom: (self class interfaceSpecFor: #namedFontSaveSpec).	(builder componentAt: #defineFontLoadingMethod) widget isEnabled: model targetClass notNil.	builder openDialog.</body><body package="UIPainter">doGroup	self doEmbed</body><body package="UIPainter">doInstall	self model installFor: self</body><body package="UIPainter">doLayoutFixed	self beFixedKey: nil</body><body package="UIPainter">doLayoutRelative	self beRelativeKey: nil</body><body package="UIPainter">doMakeBounded	self layoutSelectionsBy: 			[:each | 			| spec layout |			spec := each spec.			layout := spec layout.			spec layout: (layout notNil 						ifTrue: [layout asLayoutFrameWith: each bounds]						ifFalse: [each bounds])]</body><body package="UIPainter">doMakeOriginSize	self layoutSelectionsBy: 			[:each | 			| spec layout |			spec := each spec.			layout := spec layout.			spec layout: (layout notNil 						ifTrue: [layout asOriginSizeLayoutWith: each bounds]						ifFalse: [each bounds])]</body><body package="UIPainter">doMakeUnBounded	self layoutSelectionsBy: 			[:each | 			| spec |			spec := each spec.			spec hasInherentSize 				ifTrue: 					[| layout |					layout := spec layout.					spec layout: (layout notNil 								ifTrue: [layout asAlignmentOrigin]								ifFalse: [each bounds origin])]]</body><body package="UIPainter">doNameAll	| allSpecs |	allSpecs := NamedSpec new drilledWrappersFrom: view components.	allSpecs do:		[:each |		each spec name isNil			ifTrue: [each spec assignNameFrom: self]].	self notifyTreeChange</body><body package="UIPainter">doNamedFonts	NamedFontSelector new openAsDialog: model</body><body package="UIPainter">doOpen	| targetClass  choice |	model targetTrouble		ifTrue:			[(UIPainter preferenceFor: #installForOpen)				ifTrue:					[(self model installFor: self) isNil						ifTrue: [^self]]				ifFalse:					[Dialog warn: (#CanvasNotInstalled &lt;&lt; #UIPainter &gt;&gt; 'The canvas isn''t installed on any class') for: view.					^self]].	(self canvasHasChanged and: [UIPainter preferenceFor: #installForOpen])		ifTrue:			[(choice :=				Dialog					choose: (#GenKey128 &lt;&lt; #UIPainter &gt;&gt; 'The canvas has changed since it was last installed.Install before attempting to open?')					labels: (Array with: (#InstallFirst &lt;&lt; #UIPainter &gt;&gt; 'Install First') with: (#OpenAsIs &lt;&lt; #UIPainter &gt;&gt; 'Open As Is') with: (#Cancel &lt;&lt; #UIPainter &gt;&gt; 'Cancel'))					values: #(#install #open #cancel)					default: #open					for: view) == #cancel				ifTrue: [^self].			(choice == #install and:					[(self model installFor: self) isNil])				ifTrue: [^self]].		(targetClass := self model targetClass)		openOn: targetClass new		withSpec: self model targetSelector</body><body package="UIPainter">doPaintApplication	| spec clName cl canvasName |	spec := self selectionList first spec.	(clName := spec majorKey) isNil ifTrue:		[^Dialog			warn: (#GenKey133 &lt;&lt; #UIPainter &gt;&gt; 'The selected data form''s propertiesdon''t specify an application class')			for: view].	cl := clName asQualifiedReference valueOrDo:		[^Dialog			warn: (#GenKey132 &lt;&lt; #UIPainter &gt;&gt; 'The selected data form''s properties specifyan undefined application class')			for: view].	(canvasName := spec minorKey) isNil ifTrue:		[^Dialog			warn: (#GenKey131 &lt;&lt; #UIPainter &gt;&gt; 'The selected data form''s propertiesdon''t specify a canvas')			for: view].	[cl perform: canvasName]		on: cl messageNotUnderstoodSignal		do: [:ex |			ex parameter selector == canvasName				ifTrue: [^Dialog							warn: (#GenKey130 &lt;&lt; #UIPainter &gt;&gt; 'The selected data form''s propertiesspecify an undefined canvas')							for: view]				ifFalse: [ex pass]].	UIPainter new openOnClass: cl andSelector: canvasName</body><body package="UIPainter">doPainterTool	self model openPainterTool</body><body package="UIPainter">doPalette	self model openPaletteFor: self view topComponent</body><body package="UIPainter">doPaste	| newItems |	Scrap isNil ifTrue: [^self].	self quietlyNoteChangeToCanvas.	self broadcastPendingSelectionChange.	ScrapPrimary isNil		ifTrue: 			[newItems := self builder addCollection: Scrap collection.			newItems do: [:each | each assignNameFrom: self].			self selectionList: newItems]		ifFalse:			[newItems := self builder addCollection: ScrapPrimary collection.			newItems do: [:each | each assignNameFrom: self].			self select: newItems first.			newItems := self builder addCollection: Scrap collection.			newItems do: [:each | each assignNameFrom: self].			self appendSelections: newItems]</body><body package="UIPainter">doSnapSelectionToGrid	| sels |	(sels := self selectionList) size &gt; 0 ifFalse: [^self].	self canvasHasChanged: true.	self hideHandles.	sels do: [:s | view move: s to: (self snapPoint: s bounds origin)].	self showHandles</body><body package="UIPainter">doSpawn	"UIPainter new openOnSpec: model makeFullSpec."	| pntr spec win windowSpec |	pntr := UIPainter new.	pntr targetClass: model targetClass.	pntr targetSelector: model targetSelector.	pntr acceptedState: model acceptedState.	pntr setupBuilder.	spec := model makeFullSpec.	pntr windowSpec: spec window.	pntr builder add: spec component.	win := pntr builder window.	win controller: UIPainterSystemController new.	windowSpec := pntr windowSpec.	pntr minWindowExtent: model minWindowExtent.	pntr prefWindowExtent: model prefWindowExtent.	pntr maxWindowExtent: model maxWindowExtent.	pntr builder policy		finalHookupWindow: windowSpec		component: win component		into: pntr builder.	win application: pntr.	model spawnPainterWindows: win ofType: #normal</body><body package="UIPainter">doUndo	"The authors of this program can figure out how to do undo, but	they believe they don't have time to do it on this bounce."</body><body package="UIPainter">doUngroup	self doExtract</body><body package="UIPainter">equalizeDialog	| op builder dialog equalizeChoice equalizeConstant |	self selectionList size &gt; 1 ifFalse: [^self].	op := OperationParameters.	builder := (dialog := SimpleDialog new) builder.	builder aspectAt: #equalizeWidth put: (op at: #equalizeWidth).	builder aspectAt: #equalizeHeight put: (op at: #equalizeHeight).	equalizeChoice := builder aspectAt: #sizeChoice put: (op at: #equalizeChoice).	builder aspectAt: #absoluteSize put: (equalizeConstant := (op at: #equalizeConstant)).	builder aspectAt: #apply put: 		[(builder aspectAt: #equalizeWidth) value			ifTrue:				[self					doHorizontalSizing: equalizeChoice value					spacing: (equalizeChoice value == #absolute							ifTrue: [equalizeConstant value]							ifFalse: [nil])].		(builder aspectAt: #equalizeHeight) value			ifTrue:				[self					doVerticalSizing: equalizeChoice value					spacing: (equalizeChoice value == #absolute							ifTrue: [equalizeConstant value]							ifFalse: [nil])].		equalizeChoice value ~~ #first			ifTrue: [op at: #noFirstSelEqualizeDefault put: equalizeChoice value].		dialog accept value: true].	(builder aspectAt: #cancel) compute:		[:v |		equalizeChoice value ~~ #first			ifTrue: [op at: #noFirstSelEqualizeDefault put: equalizeChoice value]].	dialog allButOpenFrom: (self class interfaceSpecFor: #equalizeDialogSpec).	equalizeChoice compute:		[:v |		v == #absolute			ifTrue: [(builder componentAt: #constantField) enable]			ifFalse: [(builder componentAt: #constantField) disable]].	equalizeChoice value: equalizeChoice value.	self primarySelection notNil		ifTrue:			[(builder componentAt: #firstButton) enable.			equalizeChoice value: #first]		ifFalse:			[(builder componentAt: #firstButton) disable.			equalizeChoice value: (op at: #noFirstSelEqualizeDefault)].	builder openDialog.	op do: [:value | value release]</body><body package="UIPainter">fractionalConstraintDialog	| sel frame |	(sel := self selectionList) size = 1 ifFalse: [^self].	sel := sel first.	frame := sel layout asLayout.	(frame isKindOf: LayoutFrame)		ifTrue: [^self fractionalConstraintDialogForRectangular: sel frame: frame].	(frame isKindOf: LayoutOrigin)		ifTrue: [^self fractionalConstraintDialogForOriginal: sel frame: frame].</body><body package="UIPainter">hotRegionEditor	"Open hot region editor."	model targetClass == nil		ifTrue: [UIHotRegionEditor open]		ifFalse: [UIHotRegionEditor new openOnClass: model targetClass andSelector: nil]</body><body package="UIPainter">maskEditor	"Open mask editor."	model targetClass == nil		ifTrue: [UIMaskEditor open]		ifFalse: [UIMaskEditor new openOnClass: model targetClass andSelector: nil]</body><body package="UIPainter">menuEditor	"Open menu editor."	model targetClass == nil		ifTrue: [MenuEditor open]		ifFalse: [MenuEditor new openOnClass: model targetClass andSelector: nil]</body><body package="UIPainter">openReusableComponents	"Open a canvas editor on the #reusableComponents spec of LensDataManager"	#{LensDataManager} ifDefinedDo:		[:ldm|		UIPainter new			openOnClass: ldm			andSelector: #reusableComponents]</body><body package="UIPainter">regionsEditor	"Open regions editor."	model targetClass == nil		ifTrue: [UIHotRegionEditor open]		ifFalse: [UIHotRegionEditor new openOnClass: model targetClass andSelector: nil]</body><body package="UIPainter">replaceElement: selectedComponent basedOnSpec: newSpec 	"Change the element sel to match the given spec.  Keep position in the view the same.	Answer the new element.  We are relying on the sender to do something to jiggle the	LastControllerWithSelection model, for the sake of the UIPainterWatchers."	| newSpecCollection newElement oldSpec persistentInformation oldName selectedContainer formerComposite newElements path comps |	(path := view indexedPath: selectedComponent) isNil 		ifTrue: [^self error: 'no such element'].	persistentInformation := nil asValue.	selectedComponent downcastEvent: #returnPersistentInformation with: persistentInformation from: self.	oldSpec := selectedComponent spec.	oldName := oldSpec name.	selectedComponent spec: newSpec.	newSpecCollection := (SpecCollection new fromCollection: (Array with: selectedComponent)) collection.	selectedComponent spec: oldSpec.	canvasHasChanged := true.	(self selectionList includes: selectedComponent) 		ifTrue: 			[self primarySelection: nil.			self selections: nil.			self setHandles: nil].	selectedContainer := selectedComponent container.	selectedContainer remove: selectedComponent.	formerComposite := self builder composite.	comps := formerComposite ~= selectedContainer 		ifTrue: 			[self builder composite: selectedContainer.			newElements := self builder addCollection: newSpecCollection.			self builder composite: formerComposite.			selectedContainer components]		ifFalse: 			[newElements := self builder addCollection: newSpecCollection.			formerComposite components].	(path size = 1 and: [path last = comps size]) 		ifFalse: [view addComponent: comps removeLast atPath: path].	newElement := newElements last.	persistentInformation value notNil ifTrue:[newElement downcastEvent: #usePersistentInformation with: persistentInformation from: self].	newSpec name = oldName 		ifFalse: [self notifyTreeItemChange: newSpec name]		ifTrue: [self notifySelectionChange].	selectedComponent release.	^newElement</body><body package="UIPainter">setAllWindowInfo	| window size |	window := model builder window.	size := window getDisplayBox extent.	model		minWindowExtent: size;		prefWindowExtent: size;		maxWindowExtent: size.	self canvasHasChanged: true</body><body package="UIPainter">setWindowMaxSize	| window maxSize prefSize minSize |	window := model builder window.	maxSize := window getDisplayBox extent.	prefSize := maxSize min: model prefWindowExtent.	(minSize := model minWindowExtent) notNil		ifTrue:			[model minWindowExtent: (maxSize min: minSize)].	model		maxWindowExtent: maxSize;		prefWindowExtent: prefSize.	self canvasHasChanged: true</body><body package="UIPainter">setWindowMinSize	| window minSize prefSize maxSize |	window := model builder window.	minSize := window getDisplayBox extent.	prefSize := minSize max: model prefWindowExtent.	(maxSize := model maxWindowExtent) notNil		ifTrue:			[model maxWindowExtent: (minSize max: maxSize)].	model		minWindowExtent: minSize;		prefWindowExtent: prefSize.	self canvasHasChanged: true</body><body package="UIPainter">setWindowPrefSize	| window minSize maxSize prefSize |	window := model builder window.	prefSize := window getDisplayBox extent.	(minSize := model minWindowExtent) notNil		ifTrue:			[model minWindowExtent: (prefSize min: minSize)].	(maxSize := model maxWindowExtent) notNil		ifTrue:			[model maxWindowExtent: (prefSize max: maxSize)].	model prefWindowExtent: prefSize.	self canvasHasChanged: true</body><body package="UIPainter">setWindowToDefaults	"Set the default/preferred/maximum window extent for the painter window."	| window |	window := model builder window.	model		minWindowExtent: 40@20;		prefWindowExtent: window getDisplayBox extent;		maxWindowExtent: nil.	self canvasHasChanged: true</body><body package="UIPainter">toVisualBack	| sel |	(sel := self selectionList) isEmpty ifTrue: [^self].	self canvasHasChanged: true.	self hideHandles.	view toVisualBack: sel.	self showHandles.	self notifyTreeChange</body><body package="UIPainter">toVisualBackOne	| sel |	(sel := self selectionList) isEmpty ifTrue: [^self].	self canvasHasChanged: true.	self hideHandles.	view toVisualBackOneNotch: sel.	self showHandles.	self notifyTreeChange</body><body package="UIPainter">toVisualFront	| sel |	(sel := self selectionList) isEmpty ifTrue: [^self].	self canvasHasChanged: true.	self hideHandles.	view toVisualFront: sel.	self showHandles.	self notifyTreeChange</body><body package="UIPainter">toVisualFrontOne	| sel |	(sel := self selectionList) isEmpty ifTrue: [^self].	self canvasHasChanged: true.	self hideHandles.	view toVisualFrontOneNotch: sel.	self showHandles.	self notifyTreeChange</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>selection manipulation</category><body package="UIPainter">appendSelections: newSelections	| currentSelections newHandles currentHandles |	currentSelections := self selections.	currentSelections == nil		ifTrue:			[self error: (#shouldntHappen &lt;&lt; #UIPainter &gt;&gt; 'shouldn''t happen').			currentSelections := OrderedCollection new].	(newSelections reject: [:each | each isNil]) isEmpty ifTrue: [^self].	self selections: currentSelections, (newSelections reject: [:elt | currentSelections includes: elt]).	newHandles := OrderedCollection new.	newSelections do: [:sel | newHandles addAll: (self handlesFor: sel)].	currentHandles := self handles.	currentHandles == nil		ifTrue: [self handles: newHandles]		ifFalse: [self handles: currentHandles, newHandles].	newHandles do: [:h | view addWrapper: h].	newSelections isEmpty ifFalse: [self becomeLastControllerWithSelection].	self sensor window displayPendingInvalidation.</body><body package="UIPainter">quietlyRemoveSelections	self primarySelection: nil.	self selections: nil.	self setHandles: nil</body><body package="UIPainter">quietlySelect: selection	| sels newHandles |	selection == nil ifTrue: [^self].	self primarySelection: selection.	self selections: (sels := Array with: selection).	newHandles := OrderedCollection new.	sels do: [:sel | newHandles addAll: (self handlesFor: sel)].	self setHandles: newHandles.</body><body package="UIPainter">removeSelection: aSelection	| currentSelections |	currentSelections := self selections.	currentSelections == nil		ifTrue:			[self error: (#shouldntHappen &lt;&lt; #UIPainter &gt;&gt; 'shouldn''t happen').			currentSelections := OrderedCollection new].	aSelection notNil ifTrue: [ aSelection downcastLocalEvent: #deselecting with: nil at: (aSelection bounds origin) from: self].	self selections: (currentSelections copyWithout: aSelection).	self primarySelection == aSelection		ifTrue: 			[self primarySelection: nil.			self setHandles: nil.			self selectionList: self selections]		ifFalse:			["self setHandles:				(self handles reject: [:hndl | hndl wrapper == aSelection])"			view removeHandleCollection: (self handles select: [:hndl | hndl wrapper == aSelection]).			self sensor window displayPendingInvalidation.			self handles: (self handles reject: [:hndl | hndl wrapper == aSelection])].	self becomeLastControllerWithSelection.	self sensor window displayPendingInvalidation.</body><body package="UIPainter">removeSelections	self setSelections: nil.	self setHandles: nil.</body><body package="UIPainter">select: selection	selection == nil ifTrue: [^self].	self selectionList: (selection hasWidget						ifTrue: [(selection widget isMemberOf: UIPainterView) ifTrue: [#()] ifFalse: [Array with: selection]]						ifFalse: [Array with: selection])</body><body package="UIPainter">selectNextElement	| sel csize selIndex |	(csize :=view components size) = 0 ifTrue: [^self].	self broadcastPendingSelectionChange.	sel := self selections.	sel == nil		ifTrue: [^self selectionList: (Array with: view components first)].	sel size &gt; 1 ifTrue: [^self].	(csize :=view components size) = 0 ifTrue: [^self].	csize := csize - handles size.	selIndex := view components identityIndexOf: sel first.	selIndex = csize		ifTrue: [self selectionList: (Array with: view components first)]		ifFalse: [self selectionList: (Array with: (view components at: selIndex + 1))]</body><body package="UIPainter">selectPrevElement	| sel  selIndex  |	(view components size) = 0 ifTrue: [^self].	self broadcastPendingSelectionChange.	sel := self selections.	sel == nil		ifTrue: [^self selectionList: (Array with: view components last)].	sel size &gt; 1 ifTrue: [^self].	(view components size) = 0 ifTrue: [^self].	selIndex := view components identityIndexOf: sel first.	selIndex = 1		ifTrue: [| csize |				csize := view components size.				self selectionList: (Array with: (view components at: (csize - handles size)))]		ifFalse: [self selectionList: (Array with: (view components at: selIndex - 1))]</body><body package="UIPainter">selectedComponents	"Give back the components in the same order they appear in the view."	^selections == nil		ifTrue: [Array new]		ifFalse: [selections]</body><body package="UIPainter">selectionList	^selections == nil		ifTrue: [Array new]		ifFalse: [selections]</body><body package="UIPainter">selectionList: aCollection 	| newHandles |	self setHandles: nil.	newHandles := OrderedCollection new.	self primarySelection: (aCollection size &gt; 0 ifTrue: [aCollection first] ifFalse: [nil]).	self selections: aCollection.	aCollection do: [:sel | newHandles addAll: (self handlesFor: sel)].	self setHandles: newHandles.	self becomeLastControllerWithSelection</body><body package="UIPainter">setSelections: array	self primarySelection: (array size == 1 ifTrue: [array first] ifFalse: [nil]).	self selections: array.	self becomeLastControllerWithSelection</body><body package="UIPainter">tabSelectKey: anEvent	self selectNextElement</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>grid accessing</category><body package="UIPainter">fenced	"Answer the value model for fenced"	^fenced</body><body package="UIPainter">gridPoint: aPoint 		| g |	g := gridStep value.	^Point x: (griddedHorizontally value			ifTrue: [(aPoint x quo: g) * g]			ifFalse: [aPoint x])		y: (griddedVertically value				ifTrue: [(aPoint y quo: g) * g]				ifFalse: [aPoint y])</body><body package="UIPainter">gridStep	"Answer the value model for the grid increment."	^gridStep</body><body package="UIPainter">gridValue	| g |	g := gridStep value.	^Point x: (griddedHorizontally value			ifTrue: [g]			ifFalse: [1])		y: (griddedVertically value				ifTrue: [g]				ifFalse: [1])</body><body package="UIPainter">griddedHorizontally	"Answer the model that determines whether the grid constrains in the x dimension."	^griddedHorizontally</body><body package="UIPainter">griddedVertically	"Answer the model that determines whether the grid constrains in the y dimension."	^griddedVertically</body><body package="UIPainter">isFenced	^fenced value</body><body package="UIPainter">showGrid	"Answer the value model for showGrid"	^showGrid</body><body package="UIPainter">snapPoint: aPoint 		| g |	g := gridStep value.	^aPoint  // g * g</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>accessing</category><body package="UIPainter">activePainterView	^self view</body><body package="UIPainter">activePainterWindow	"answer the application window for the receiver's painter view."	^self activePainterView topComponent</body><body package="UIPainter">builder	^model builder</body><body package="UIPainter">canvasHasChanged	^canvasHasChanged</body><body package="UIPainter">canvasHasChanged: aBoolean 	canvasHasChanged := aBoolean.	self becomeLastControllerWithSelection</body><body package="UIPainter">currentMode	^currentMode</body><body package="UIPainter">currentMode: aValueHolder	currentMode := aValueHolder</body><body package="UIPainter">currentModeObject	^self currentMode value</body><body package="UIPainter">cursorPoint	^self gridPoint: self sensor cursorPoint</body><body package="UIPainter">globalCursorPoint	^model gridPoint: self sensor globalCursorPoint</body><body package="UIPainter">handles	^ handles</body><body package="UIPainter">handles: aValue	"Set the value for handles"	handles := aValue</body><body package="UIPainter">model: aModel 	"override super so the receiver can inform anyone who is interested if a top level painter	is being used. "	super model: aModel.	self model isNil ifFalse: [self broadcastTopLevelPainter]</body><body package="UIPainter">primarySelection	^primarySelection</body><body package="UIPainter">primarySelection: aWrapper 	aWrapper == primarySelection ifTrue: [^self].	primarySelection notNil ifTrue: [primarySelection downcastEvent: #deselecting with: nil from: self].	primarySelection := aWrapper</body><body package="UIPainter">selections	"Answer the value for selections"	^selections</body><body package="UIPainter">selections: aValue	"Set the value for selections"	selections := aValue</body><body package="UIPainter">updateRequest	"Answer false if the canvas has changed since the last save or install."	^self canvasHasChanged not</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>private-grouping</category><body package="UIPainter">doEmbed	| selectedComponents comp box newComposite targetComposite parents newWrapper |	self broadcastPendingSelectionChange.	(selectedComponents := self selectedComponents) size &gt; 0 ifFalse: [^self].	parents := (selectedComponents collect: [:each | each container]) asSet.	parents size &gt; 1 ifTrue: [^self onlyOneParentNotification].	targetComposite := parents asArray first.	self canvasHasChanged: true.	self removeSelections.	self builder newComposite.	comp := self builder composite.	box := selectedComponents first bounds.	2 to: selectedComponents size do: 		[:index |  | mergeBox |		mergeBox := (selectedComponents at: index) bounds.		box := box merge: mergeBox].	1 to: selectedComponents size do:		[:index |		| wrapper newBox |		wrapper := selectedComponents at: index.		newBox := wrapper bounds translatedBy: box origin negated.		wrapper newLayout: (self			embedLayout: wrapper layout			for: newBox			containedBy: box).		wrapper newBounds: newBox containingBounds: box.		targetComposite remove: wrapper.		comp addWrapper: wrapper].	newComposite := CompositeSpec new layout: box.	newWrapper := self builder add: newComposite.	targetComposite = view ifFalse: 		[self builder composite remove: newWrapper.		targetComposite addWrapper: newWrapper.		newWrapper container: targetComposite].	newComposite assignNameFrom: self.		self select: self builder wrapper.</body><body package="UIPainter">doExtract	| selectedComponents newSelections compositeSelections targetComposite | 	(selectedComponents := self selections) == nil ifTrue: [^self].	selectedComponents detect: [:each | each bottomComponent isKindOf: CompositePart] ifNone: [^self onlyOneCompositeNotify].	targetComposite := selectedComponents first container.	self canvasHasChanged: true.	self removeSelections.	newSelections := OrderedCollection new.	compositeSelections := OrderedCollection new.	self hideHandles.	selectedComponents do:		[:wrapper | 			(wrapper spec isKindOf: CompositeSpec)				ifTrue: [compositeSelections add: wrapper]				ifFalse: [newSelections add: wrapper]].	compositeSelections do:		[:wrapper |		| components composite box |		composite := wrapper widget.		components := composite components.		newSelections addAll: components.		box := wrapper bounds.		targetComposite remove: wrapper.		components do:			[:each | | newBox |			newBox := each bounds translatedBy: box origin.			each newLayout: (self				extractLayout: each layout				for: newBox				containedBy: targetComposite bounds).			each newBounds: newBox containingBounds: targetComposite bounds.			targetComposite addWrapper: each]].	self notifyTreeChange.	self selectionList: newSelections.</body><body package="UIPainter">doExtractSubCanvas	"Due to restrictions in the user interface, this method should	never execute unless there is a single selection and it is a	subcanvas."	| sels    newSelections  compositeSelections |	(sels := self selections) == nil ifTrue: [^self].	self canvasHasChanged: true.	self removeSelections.	newSelections := OrderedCollection new.	compositeSelections := OrderedCollection new.	self hideHandles.	sels do:		[:wrapper | 			(wrapper spec isKindOf: SubCanvasSpec)				ifTrue: [compositeSelections add: wrapper]				ifFalse: [newSelections add: wrapper]].	compositeSelections do:		[:wrapper |		| components composite box |		(composite := wrapper widget) notNil ifTrue: 			[components := composite components.			newSelections addAll: components.			box := wrapper bounds.			view remove: wrapper.			components do:				[:each | | newBox |				newBox := each bounds translatedBy: box origin.				each newLayout: (self					extractLayout: each layout					for: newBox					containedBy: view bounds).				each newBounds: newBox containingBounds: view bounds.				view addWrapper: each]]].	self  selectionList: newSelections.</body><body package="UIPainter">embedLayout: layout for: bounds containedBy: containingBounds	| l |	l := layout copy.	(layout isKindOf: LayoutOrigin)		ifTrue: [(layout leftFraction &gt; 0 and: [layout leftOffset ~= 0])					ifTrue: [l leftFraction: bounds left asFloat / containingBounds width offset: 0].				(layout topFraction &gt; 0 and: [layout topOffset ~= 0])					ifTrue: [l topFraction: bounds top asFloat / containingBounds height offset: 0].				(layout isKindOf: LayoutFrame) ifFalse: [^l].				(layout rightFraction &gt; 0 and: [layout rightOffset ~= 0])					ifTrue: [l rightFraction: bounds right asFloat / containingBounds width offset: 0].				(layout bottomFraction &gt; 0 and: [layout bottomOffset ~= 0])					ifTrue: [l bottomFraction: bounds bottom asFloat / containingBounds height offset: 0]].	^l</body><body package="UIPainter">extractLayout: layout for: bounds containedBy: containingBounds	| l |	l := layout copy.	(layout isKindOf: LayoutFrame)		ifTrue: [(layout leftFraction = 0 and: [layout leftOffset = 0 and: [(layout rightFraction + layout topFraction + layout bottomFraction) ~= 0]])					ifTrue: [l leftFraction: bounds left asFloat / containingBounds width].				(layout topFraction = 0 and: [layout topOffset = 0 and: [(layout bottomFraction + layout leftFraction + layout rightFraction ) ~= 0]])					ifTrue: [l topFraction: bounds top asFloat / containingBounds height]]		ifFalse: [(layout isKindOf: LayoutOrigin)					ifTrue: [(layout leftFraction = 0 and: [layout leftOffset = 0 and: [layout topFraction ~= 0]])								ifTrue: [l leftFraction: bounds left asFloat / containingBounds width].							(layout topFraction = 0 and: [layout topOffset = 0 and: [layout leftFraction ~= 0]])								ifTrue: [l topFraction: bounds top asFloat / containingBounds height]]].	^l</body><body package="UIPainter">onlyOneCompositeNotify	Dialog warn: (#GenKey134 &lt;&lt; #UIPainter &gt;&gt; 'Only a Composite Part may be selected for ungrouping')</body><body package="UIPainter">onlyOneParentNotification	Dialog warn: (#GenKey135 &lt;&lt; #UIPainter &gt;&gt; 'Grouping and ungrouping of widgetsrequires that each widgethave the same parent (window or composite)')</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>handle manipulation</category><body package="UIPainter">handlesFor: aWrapper	^aWrapper		painterDragHandles:			(self primarySelection isNil or:				[aWrapper == self primarySelection])</body><body package="UIPainter">hideHandles	handles == nil ifTrue: [^self].	view removeHandleCollection: handles.	self sensor window displayPendingInvalidation.</body><body package="UIPainter">setHandles: array	| oldhandles |	oldhandles :=  self handles.	oldhandles == nil		ifFalse: [view removeHandleCollection: oldhandles].	self sensor window displayPendingInvalidation. 	"do first because adding handles bashes the display for speed"	self handles: array.	array == nil		ifFalse: [view addHandleCollection: array].</body><body package="UIPainter">showHandles	handles == nil ifTrue: [^self].	self view addHandleCollection: handles.	self sensor window displayPendingInvalidation.</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>control modes</category><body package="UIPainter">dragModeFor: anObject 	"It is really up to the controller to decide what mode is appropriate	but we defer to the thing to be dragged (for UIPainterController,	it is either a Handle or a SpecWrapper) in typical object oriented	style."	^anObject painterDragMode</body><body package="UIPainter">modeIsSticky	^self class modeIsSticky</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>updating</category><body package="UIPainter">notifyCanvasClosing	LastControllerWithSelection changed: #canvasClosing</body><body package="UIPainter">notifyEmptyTree	LastControllerWithSelection changed: #emptyTree</body><body package="UIPainter">notifyOpenedCanvas	LastControllerWithSelection changed: #openedCanvas</body><body package="UIPainter">notifySelectionChange	LastControllerWithSelection changed: #selectionChange</body><body package="UIPainter">notifySwitchingCanvas: aController	LastControllerWithSelection changed: #switchingCanvas with: aController</body><body package="UIPainter">notifyTreeChange	LastControllerWithSelection changed: #treeChange</body><body package="UIPainter">notifyTreeItemChange: aString	LastControllerWithSelection changed: #treeItemNameChange with: aString</body><body package="UIPainter">update: anAspect with: aParameter from: anObject	anAspect == #installedCanvas		ifTrue:			[self model isNil ifTrue:				[^self].			(self model targetClass isNil or:				[(aParameter at: 1) ~~ self model targetClass or:					[(aParameter at: 2) ~~ self model targetSelector]])				ifTrue:					[self						replaceSubCanvasesOfClass: (aParameter at: 1) name						andSelector: (aParameter at: 2)]				ifFalse:					[^self]]</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>event forwarding</category><body package="UIPainter">dispatchEventToMode: event 	| mode |	(mode := self currentMode value) notNil		ifTrue: 			[mode setController: self.			^mode handleEvent: event].	^nil</body><body package="UIPainter">enterEvent: event	oldPoint := self sensor cursorPointFor: event.	self dispatchEventToMode: event</body><body package="UIPainter">exitEvent: event 	self dispatchEventToMode: event</body><body package="UIPainter">mouseMovedEvent: anEvent 	| newPoint |	newPoint := anEvent point.	newPoint ~= oldPoint		ifTrue: 			[self dispatchEventToMode: anEvent.			oldPoint := newPoint]</body><body package="UIPainter">redButtonPressedEvent: anEvent 	oldPoint := anEvent point.	self dispatchEventToMode: anEvent</body><body package="UIPainter">redButtonReleasedEvent: event	self dispatchEventToMode: event</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>menu processing</category><body package="UIPainter">adjustMenu: newMenu andModel: aModel 	| menuItem |	(aModel targetClass isNil and: [(UISettings preferenceFor: #installForDefine) not and: [(UISettings preferenceFor: #installForOpen) not]])		ifTrue: 			[(newMenu atNameKey: #doBrowse) disable.			(newMenu atNameKey: #doDefine) disable.			(newMenu atNameKey: #doOpen) disable]		ifFalse: 			[(newMenu atNameKey: #doBrowse) enable.			(newMenu atNameKey: #doDefine) enable.			(newMenu atNameKey: #doOpen) enable].	(menuItem := newMenu atNameKey: #special) submenu notNil		ifTrue: [menuItem enable]		ifFalse: [menuItem disable].	menuItem := newMenu atNameKey: #openReusableComponents.	#{LensDataManager} bindingOrNil isNil		ifTrue: [menuItem disable]		ifFalse: [menuItem enable].	^newMenu</body><body package="UIPainter">selectionPopUpMenu	| currentSelections |	^(currentSelections := self selectionList) isEmpty not		ifTrue:			[currentSelections size &gt; 1				ifTrue: [nil]				ifFalse: [currentSelections first spec class selectionPopUpMenu]]		ifFalse: [nil]</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>broadcast</category><body package="UIPainter">downcastLocalEvent: aKey with: aParameter at: aPoint from: anInitiator 	"This is a message passed down the view structure to some single 	part. Answer true if we accepted the event, or false if it should be 	passed on to whatever's behind us."	aKey == #interestedInDrop		ifTrue: [anInitiator dropTarget: self dropTarget].	^true</body><body package="UIPainter">dropTarget	^ConfigurableDropTarget new		dragOverSelector: #dragOverWidgets:;		receiver: self currentMode value;		yourself.</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>initialize-release</category><body package="UIPainter">doInstallNamedFonts	| dialog builder spec |	builder := (dialog := SimpleDialog new) builder.	spec := self model windowSpec.	builder aspectAt: #namedFontFileOutType put: spec namedFontFileOutTypeSelection asValue.	builder 		aspectAt: #whereTheMethodIsStored 		put: (#GenKey127 &lt;&lt; #UIPainter &gt;&gt; 'The named font defintion is placed in a method named&lt;n&gt;#definedNamedFonts&lt;n&gt;in the "private" protocol of the application model.') expandMacros asText asValue.	builder 		aspectAt: #apply 		put: 			[model definer 				addNamedFontsMethod: (builder aspectAt: #namedFontFileOutType) value 				using: model extractFullSpec.			dialog accept value: true].	dialog allButOpenFrom: (self class interfaceSpecFor: #namedFontDefineSpec).	builder openDialog.</body><body package="UIPainter">initialize	"UIPainterController initialize"	| gridMode |	super initialize.	self currentMode: (ValueHolder with: nil).	showGrid := ValueHolder with: (UIPainter preferenceFor: #initialGridDisplay).	gridStep := ValueHolder with: (UIPainter preferenceFor: #initialGridSize).	gridMode := UIPainter preferenceFor: #initialGridMode.	griddedHorizontally := ValueHolder with: (gridMode == #On or: [gridMode == #'X Only']).	griddedVertically := ValueHolder with: (gridMode == #On or: [gridMode == #'Y Only']).	fenced := ValueHolder with: false.	canvasHasChanged := false.</body><body package="UIPainter">initializeMenu	| currentSelections newMenu |		menuHolder := 		[newMenu := (currentSelections := self selectionList) isEmpty			ifTrue: [NoSelectMenu]			ifFalse: 				[currentSelections size = 1					ifTrue: [SingleSelectMenu]					ifFalse: [MultiSelectMenu]].		self adjustMenu: newMenu andModel: model]</body><body package="UIPainter">release	LastControllerWithSelection value == self ifTrue: [LastControllerWithSelection value: nil].	self currentMode value setController: nil.	super release</body></methods><methods><class-id>Tools.UIPainterController</class-id> <category>selection moving-sizing</category><body package="UIPainter">distributeHorizontal: aCollection fixedSpacing: anInteger	| delta widget |	2 to: aCollection size do: 		[:index | 		widget := aCollection at: index.		delta := widget bounds left - ((aCollection at: index -1) bounds right + anInteger).		view move: widget by: delta negated @ 0].	self canvasHasChanged: true.	view invalidate</body><body package="UIPainter">distributeHorizontalCenters: aCollection 	| firstCenter lastCenter index |	firstCenter := aCollection first bounds center x.	lastCenter := aCollection last bounds center x.	index := 0.	lastCenter - firstCenter ~= 0 ifTrue: 		[firstCenter to: lastCenter by: lastCenter - firstCenter / (aCollection size - 1) 			do: 				[:positionIndex | 				| widget boundingBox |				widget := aCollection at: (index := index + 1).				boundingBox := widget bounds.				view move: widget by: (positionIndex - boundingBox center x @ 0) truncated]].	self canvasHasChanged: true.	view invalidate</body><body package="UIPainter">distributeHorizontalEdges: aCollection	| box sumWidths spacing |	box := aCollection first bounds.	sumWidths := box width.	2 to: aCollection size do: 		[:index | | boundingBox |		boundingBox := (aCollection at: index) bounds.		box := box merge: boundingBox.		sumWidths := sumWidths + boundingBox width].	spacing := (box width - sumWidths / (aCollection size - 1)) truncated.	2 to: aCollection size do: 		[:index | | widget boundingBox delta |		widget := aCollection at: index.		boundingBox := widget bounds.		delta := boundingBox left - ((aCollection at: index - 1) bounds right + spacing).		view move: widget by: delta negated @ 0].	self canvasHasChanged: true.	view invalidate</body><body package="UIPainter">distributeVertical: aCollection fixedSpacing: anInteger	| delta widget |	2 to: aCollection size do: 		[:index |		widget := aCollection at: index.		delta :=  ((aCollection at: index - 1) bounds bottom + anInteger) - widget bounds top.		view move: widget by: 0 @ delta].	self canvasHasChanged: true.	view invalidate</body><body package="UIPainter">distributeVerticalCenters: aCollection 	| firstCenter lastCenter index |	firstCenter := aCollection first bounds center y.	lastCenter := aCollection last bounds center y.	index := 0.	lastCenter - firstCenter ~= 0 ifTrue: 		[firstCenter to: lastCenter by: lastCenter - firstCenter / (aCollection size - 1)			do: 				[:positionIndex | 				| widget boundingBox |				widget := aCollection at: (index := index + 1).				boundingBox := widget bounds.				view move: widget by: 0 @ (positionIndex  - boundingBox center y) truncated]].	self canvasHasChanged: true.	view invalidate</body><body package="UIPainter">distributeVerticalEdges: anOrderedCollection	| box sumHeights spacing |	box := anOrderedCollection first bounds.	sumHeights := box height.	2 to: anOrderedCollection size do: 		[:index | | boundingBox |		boundingBox := (anOrderedCollection at: index) bounds.		box := box merge: boundingBox.		sumHeights := sumHeights + boundingBox height].	spacing := ((box height - sumHeights) / (anOrderedCollection size - 1)) truncated.	2 to: anOrderedCollection size do: 		[:index | | widget boundingBox delta |		widget := anOrderedCollection at: index.		boundingBox := widget bounds.		delta := ((anOrderedCollection at: index -1) bounds bottom + spacing) - boundingBox top.		view move: widget by: 0@delta].	self canvasHasChanged: true.	view invalidate</body><body package="UIPainter">doHorizontalAlign: choice forceNoPrimary: aBoolean	"Assumes that choice is #left, #center, or #right 	and that aWrapper is a composite."	| block edge currentSelections |	(currentSelections := self selectionList) size &gt; 0 ifFalse: [^self].	self canvasHasChanged: true.	self hideHandles.	block := choice = #left		ifTrue: [[:bounds | bounds left]]		ifFalse: 			[choice = #center				ifTrue: [[:bounds | bounds center x]]				ifFalse: [[:bounds | bounds right]]].	edge := self computeAlignmentPosition: block forceNoPrimary: aBoolean.	currentSelections do: 		[:each | 		view move: each by: edge - (block value: each bounds) @ 0].	self showHandles.	self canvasHasChanged: true.	view invalidate</body><body package="UIPainter">doHorizontalDistribute: aSymbol spacing: anIntegerOrNil	| selectionList sortedSelections |	(selectionList := self selectionList) size &gt; 1 ifFalse: [^self].  	self hideHandles.	sortedSelections := selectionList asSortedCollection: [:a :b | a bounds left &lt;= b bounds left].	aSymbol = #edgespace ifTrue: [self distributeHorizontal: sortedSelections fixedSpacing: anIntegerOrNil].	aSymbol = #centers ifTrue: [self distributeHorizontalCenters: sortedSelections].	aSymbol = #edges ifTrue: [self distributeHorizontalEdges: sortedSelections].	self showHandles.	self canvasHasChanged: true.	view invalidate</body><body package="UIPainter">doHorizontalSizing: aSymbol spacing: anIntegerOrNil	| selectedWidgets newWidth |	(selectedWidgets := self selectionList) size &gt; 1 ifFalse: [^self].  	self hideHandles.	aSymbol == #absolute 	ifTrue: 		[newWidth := anIntegerOrNil].	aSymbol == #first ifTrue:		[newWidth := self computeAlignmentPosition: [:bounds | bounds width] forceNoPrimary: false].	aSymbol == #max ifTrue:		[newWidth := selectedWidgets inject: 0 into: [:sum :each | sum max: each bounds width]].	aSymbol == #min ifTrue:		[newWidth := selectedWidgets inject: SmallInteger maxVal into: [:sum :each | sum min: each bounds width]].	selectedWidgets do:		[:each  | | boundingBox |		boundingBox := each bounds.		view newBounds: (boundingBox copy width: newWidth) oldBounds: boundingBox forWrapper: each].	self showHandles.	self canvasHasChanged: true.	view invalidate</body><body package="UIPainter">doVerticalAlign: choice forceNoPrimary: aBoolean	"Assumes that choice is #left, #center, or #right 	and that aWrapper is a composite."	| currentSelections block edge |	(currentSelections := self selectionList) size &gt; 0 ifFalse: [^self].	self canvasHasChanged: true.	self hideHandles.	block := choice = #top		ifTrue: [[:bounds | bounds top]]		ifFalse: 			[choice = #center				ifTrue: [[:bounds | bounds center y]]				ifFalse: [[:bounds | bounds bottom]]].	edge := self computeAlignmentPosition: block forceNoPrimary: aBoolean.	currentSelections do: 		[:each |		view move: each by: 0 @ (edge - (block value: each bounds))].	self showHandles.	self canvasHasChanged: true.	view invalidate</body><body package="UIPainter">doVerticalDistribute: aSymbol spacing: anIntegerOrNil	| selectedList sortedSelections |	(selectedList := self selectionList) size &gt; 1 ifFalse: [^self].  	self hideHandles.	sortedSelections := selectedList asSortedCollection: [:a :b | a bounds top &lt;= b bounds top].	aSymbol == #edgespace ifTrue: [self distributeVertical: sortedSelections fixedSpacing: anIntegerOrNil].	aSymbol  == #centers ifTrue: [self distributeVerticalCenters: sortedSelections].	aSymbol  ==  #edges ifTrue: [self distributeVerticalEdges: sortedSelections]."		ifTrue: [ | box sumHeights spacing |				box := sortedSelections first bounds.				sumHeights := box height.				2 to: sortedSelections size					do: [:i |					| bb |					bb := (sortedSelections at: i) bounds.					box := box merge: bb.					sumHeights := sumHeights + bb height].			spacing := ((box height - sumHeights) / (sortedSelections size - 1)) truncated.			2 to: sortedSelections size do: 					[:i | | w bb |					w := sortedSelections at: i.					bb := w bounds.					delta := ((sortedSelections at: i -1) bounds bottom + spacing) - bb top.					view move: w by: 0@delta]]."	self showHandles.	self canvasHasChanged: true.	view invalidate</body><body package="UIPainter">doVerticalSizing: aSymbol spacing: anIntegerOrNil	| selectedWidgets newHeight |	(selectedWidgets := self selectionList) size &gt; 1 ifFalse: [^self].  	self hideHandles.	aSymbol == #absolute 	ifTrue: 		[newHeight := anIntegerOrNil].	aSymbol == #first ifTrue:		[newHeight := self computeAlignmentPosition: [:bounds | bounds height] forceNoPrimary: false].	aSymbol == #max ifTrue:		[newHeight := selectedWidgets inject: 0 into: [:sum :each | sum max: each bounds height]].	aSymbol == #min ifTrue:		[newHeight := selectedWidgets inject: SmallInteger maxVal into: [:sum :each | sum min: each bounds height]].	selectedWidgets do:		[:each  | | boundingBox |		boundingBox := each bounds.		view newBounds: (boundingBox copy height: newHeight) oldBounds: boundingBox forWrapper: each].	self showHandles.	self canvasHasChanged: true.	view invalidate</body></methods><methods><class-id>Tools.UIPainterController class</class-id> <category>class initialization</category><body package="UIPainter">initialize	"UIPainterController initialize"	Scrap := nil.	ScrapPrimary := nil. 	LastControllerWithSelection := ValueHolder with: nil.	StickyMode notNil ifTrue: [StickyMode release].	StickyMode := false asValue.	StickyMode compute: [:v | v ifFalse: [(UIPalette currentMode isKindOf: #{SelectModeTracker} value)				ifFalse: [UIPalette currentMode: #{SelectModeTracker} value new]]].	self initializeDispatchTable.	self initializeOperationParameters.	MultiSelectMenu := self canvasMenu.	(MultiSelectMenu atNameKey: #special) submenu: nil; disable.	(MultiSelectMenu atNameKey: #fractionalConstraintDialog) disable.	(MultiSelectMenu atNameKey: #doUngroup) disable.	SingleSelectMenu := self canvasMenu.	(SingleSelectMenu atNameKey: #alignDialog) disable.	(SingleSelectMenu atNameKey: #distributeDialog) disable.	(SingleSelectMenu atNameKey: #equalizeDialog) disable.	(SingleSelectMenu atNameKey: #special)		submenu:			[| ctrlr |			(ctrlr := LastControllerWithSelection value) notNil				ifTrue: [ctrlr selectionPopUpMenu]				ifFalse: [nil]].	NoSelectMenu := self canvasMenu.	(NoSelectMenu atNameKey: #doLayoutFixed) disable.	(NoSelectMenu atNameKey: #doLayoutRelative) disable.	(NoSelectMenu atNameKey: #fractionalConstraintDialog) disable.	(NoSelectMenu atNameKey: #doMakeBounded) disable.	(NoSelectMenu atNameKey: #doMakeUnBounded) disable.	(NoSelectMenu atNameKey: #arrange) disable.	(NoSelectMenu atNameKey: #special) submenu: nil; disable.</body><body package="UIPainter">initializeDispatchTable	"Initialize the keyboard dispatch table"	"UIPainterController initializeDispatchTable."	KeyboardDispatchTable := DispatchTable new.	KeyboardDispatchTable defaultForCharacters: #ignoreInputKey:.	KeyboardDispatchTable defaultForNonCharacters: #ignoreInputKey:.	KeyboardDispatchTable bindValue: #cutKey: to: Character del.	KeyboardDispatchTable bindValue: #pasteKey: to: Character lf.	KeyboardDispatchTable bindValue: #cutKey: to: Character backspace.	"Sun convention compatibility"	KeyboardDispatchTable bindValue: #undoKey: to: #L4.	KeyboardDispatchTable bindValue: #copyKey: to: #L6.	KeyboardDispatchTable bindValue: #pasteKey: to: #L8.	KeyboardDispatchTable bindValue: #cutKey: to: #L10.	"Mac convention compatibility"	KeyboardDispatchTable bindValue: #undoKey: toCommand: #undo.	KeyboardDispatchTable bindValue: #cutKey: toCommand: #cut.	KeyboardDispatchTable bindValue: #copyKey: toCommand: #copy.	KeyboardDispatchTable bindValue: #pasteKey: toCommand: #paste.		KeyboardDispatchTable bindValue: #circulateBackKey: toCommand: #uipainterCirculateBackwards.	KeyboardDispatchTable bindValue: #circulateFrontKey: toCommand: #uipainterCirculateFrontwards.	KeyboardDispatchTable bindValue: #tabSelectKey: to: Character tab.	KeyboardDispatchTable bindValue: #bumpUpKey: to: #Up.	KeyboardDispatchTable bindValue: #bumpDownKey: to: #Down.	KeyboardDispatchTable bindValue: #bumpLeftKey: to: #Left.	KeyboardDispatchTable bindValue: #bumpRightKey: to: #Right.	KeyboardDispatchTable bindValue: #alignTopKey: toCommand: #uipainterAlignTop.	KeyboardDispatchTable bindValue: #alignBottomKey: toCommand: #uipainterAlignBottom.	KeyboardDispatchTable bindValue: #alignRightKey: toCommand: #uipainterAlignRight.	KeyboardDispatchTable bindValue: #alignLeftKey: toCommand: #uipainterAlignLeft.	KeyboardDispatchTable bindValue: #alignDialogKey: toCommand: #uipainterAlign.	KeyboardDispatchTable bindValue: #distributeDialogKey: toCommand: #uipainterDistribute.	KeyboardDispatchTable bindValue: #equalizeDialogKey: toCommand: #uipainterEqualize.	KeyboardDispatchTable bindValue: #layoutKey: toCommand: #uipainterLayout.	KeyboardDispatchTable bindValue: #dialogKey: toCommand: #uipainterDialog.	KeyboardDispatchTable bindValue: #groupKey: toCommand: #uipainterGroup.	KeyboardDispatchTable bindValue: #ungroupKey: toCommand: #uipainterUngroup.	KeyboardDispatchTable bindValue: #beRelativeKey: toCommand: #uipainterBeRelative.	KeyboardDispatchTable bindValue: #beFixedKey: toCommand: #uipainterBeFixed.	KeyboardDispatchTable bindValue: #snapSelectionToGridKey: toCommand: #uipainterSnapSelectionToGrid.	KeyboardDispatchTable bindValue: #installKey: toCommand: #uipainterInstall.</body><body package="UIPainter">initializeOperationParameters	| op |	op := OperationParameters := Dictionary new.	op at: #alignOrientation put: #horizontal asValue.	op at: #hAlignChoices put: #left asValue.	op at: #vAlignChoices put: #top asValue.	op at: #distributeOrientation put: #vertical asValue.	op at: #distributeChoices put: #equicenter asValue.	op at: #distributeConstant put: 25 asValue.	op at: #equalizeWidth put: true asValue.	op at: #equalizeHeight put: false asValue.	op at: #noFirstSelEqualizeDefault put: #max.	op at: #equalizeChoice put: nil asValue.	op at: #equalizeConstant put: 25 asValue.</body></methods><methods><class-id>Tools.UIPainterController class</class-id> <category>global selection</category><body package="UIPainter">lastControllerWithSelectionChannel	^LastControllerWithSelection</body><body package="UIPainter">makeNextUIPainterActive	"The active UIPainter window is closing. Make the next scheduled UIPainter window active"	| currentUIPainter |	currentUIPainter := LastControllerWithSelection value ifNotNil:[:uicontroller| uicontroller view topComponent].	(ScheduledWindow scheduledWindows copyWithout: currentUIPainter) do: 			[:win | 			| candidate |			candidate := win model.			candidate class == UIPainter 				ifTrue: 					[LastControllerWithSelection value: candidate findPainterController.					win raise.					^self]].	LastControllerWithSelection value: nil</body></methods><methods><class-id>Tools.UIPainterController class</class-id> <category>control modes</category><body package="UIPainter">modeIsSticky	^StickyMode value</body><body package="UIPainter">modeIsSticky: aBoolean	StickyMode value: aBoolean</body><body package="UIPainter">stickyMode	^StickyMode</body></methods><methods><class-id>Tools.UIPainterController class</class-id> <category>private</category><body package="UIPainter">interfaceSpecFor: aSymbol	^UISpecification from: (self perform: aSymbol)</body></methods><methods><class-id>Tools.ColorBitEditor</class-id> <category>event driven</category><body package="UIPainter">colorPointAt: aPoint	| p |	currentColor isNil ifTrue: [currentColor := model palette indexOf: ColorValue black].	p := aPoint // view scale.	(model containsPoint: p)		ifFalse: [^self].	model atPoint: p put: currentColor.	model changed: #invalidate with: (p extent: 1 @ 1).	self imageHasChanged: true</body><body package="UIPainter">selectionTracker	^ColorBitEditorTracker on: self.</body><body package="UIPainter">yellowButtonPressedEvent: event 	^nil</body></methods><methods><class-id>Tools.ColorBitEditor</class-id> <category>accessing</category><body package="UIPainter">currentColor	^currentColor</body><body package="UIPainter">currentColor: newColor 	currentColor := newColor</body></methods><methods><class-id>UI.MaskPainterController</class-id> <category>private</category><body package="UIPainter">brushConstrain: aPoint	InputState default shiftDown ifFalse: [self constrainAxis: nil. ^aPoint].	aPoint = originInProgress ifTrue: [^aPoint]. 	constrainAxis isNil ifTrue: [		| dVec |	 	dVec := aPoint - originInProgress.		dVec x abs &gt; dVec y abs			ifTrue: [ self constrainAxis: #y ]			ifFalse: [ self constrainAxis: #x ].	].	^self constrainAxis == #x			ifTrue: [ originInProgress x @ aPoint y ]			ifFalse: [ aPoint x @ originInProgress y].</body><body package="UIPainter">brushStrokeOn: gc from: origin to: destination	| vector unit |	vector := destination - origin.	brush displayOn: gc at: destination.	vector = Point zero ifTrue: [^self]. 	unit := vector unitVector. 	1 to: vector r floor do: [ :units |		brush displayOn: gc at: (origin + (units * unit)).	].</body><body package="UIPainter">doFillAtPoint: aPoint	| im |	(self editMask bounds containsPoint: aPoint) ifFalse: [^self].	Cursor wait showWhile: [		im := self editMask asImage.		self editMask clear.		(im			fillShapeAround: aPoint 			to: im copyEmpty 			outlinedBy: (coveragePaint == CoverageValue opaque ifTrue: [1] ifFalse: [0] ))				 displayOn: self editMask graphicsContext.		self view invalidate. 	].</body><body package="UIPainter">geometricConstrain: aPoint	| dVec |	InputState default shiftDown ifFalse: [^aPoint].	dVec := aPoint - originInProgress.	dVec x abs &gt; dVec y abs		ifTrue: [ "keep y coordinate, translate x"			^(originInProgress x + (dVec x sign * dVec y abs)) @ (originInProgress y+ dVec y)	]	ifFalse: [ "keep x coordinate, translate y"			^(originInProgress x + dVec x) @ (originInProgress y+ (dVec y sign * dVec x abs))	].</body><body package="UIPainter">refreshBrushCursor	| tempMask tempColorImage tempMaskImage |	self brush isNil ifTrue: [brushCursor := nil. ^self]. 	tempMask := Mask extent: 16@16.	self brush displayOn: tempMask graphicsContext.	tempColorImage := tempMask asImage palette: (MonoMappedPalette whiteBlack).	tempMaskImage := tempMask asImage.	brushCursor := Cursor image: tempColorImage mask: tempMaskImage hotSpot: 0@0 name: nil.</body><body package="UIPainter">refreshUndoBuffer	(undoBuffer isNil or: [undoBuffer isOpen not or: [undoBuffer extent ~= self editMask extent]])		ifTrue: [undoBuffer := self editMask duplicate]		ifFalse: [ undoBuffer clear. self editMask displayOn: undoBuffer graphicsContext].</body><body package="UIPainter">restoreCursor		(self model notNil and: [oldCursor notNil]) ifTrue: [oldCursor beCursor]</body><body package="UIPainter">setCursor	mode == #brush ifTrue: [^brushCursor beCursor].	mode == #fill ifTrue: [^FillCursor beCursor]. 	Cursor origin beCursor.</body><body package="UIPainter">setCursorForMode		(self model notNil and: [self mode notNil])		ifTrue:			[oldCursor := Cursor currentCursor.			self setCursor]</body></methods><methods><class-id>UI.MaskPainterController</class-id> <category>accessing</category><body package="UIPainter">brush	^brush</body><body package="UIPainter">brush: aValue	brush := aValue.	self refreshBrushCursor.</body><body package="UIPainter">brushCursor	^brushCursor</body><body package="UIPainter">constrainAxis	^constrainAxis</body><body package="UIPainter">constrainAxis: aValue	constrainAxis := aValue</body><body package="UIPainter">coveragePaint	^coveragePaint</body><body package="UIPainter">coveragePaint: aValue	coveragePaint := aValue</body><body package="UIPainter">editMask	self model isNil ifTrue: [^nil].	(editMask isNil or: [editMask isOpen not]) ifTrue: [editMask := self model asRetainedMedium].	^editMask.</body><body package="UIPainter">editMask: aValue	editMask := aValue</body><body package="UIPainter">ellipseMode	self mode: #ellipse</body><body package="UIPainter">geometricInProgress	^geometricInProgress</body><body package="UIPainter">geometricInProgress: aValue	geometricInProgress := aValue</body><body package="UIPainter">mode	^mode</body><body package="UIPainter">mode: aValue	mode := aValue</body><body package="UIPainter">rectangleMode	self mode: #rectangle</body></methods><methods><class-id>UI.MaskPainterController</class-id> <category>event driven</category><body package="UIPainter">redButtonPressedEvent: event		(self model notNil and: [self mode notNil]) ifTrue: [super redButtonPressedEvent: event].</body><body package="UIPainter">selectionTracker	^PaintTracker on: self</body><body package="UIPainter">shutdownBecauseOfError		self restoreCursor.	super shutdownBecauseOfError</body></methods><methods><class-id>UI.MaskPainterController</class-id> <category>testing</category><body package="UIPainter">isDirty	^undoBuffer notNil</body></methods><methods><class-id>UI.MaskPainterController</class-id> <category>actions</category><body package="UIPainter">accept	self model value: self editMask asImage.</body><body package="UIPainter">clearMask	self refreshUndoBuffer.	self editMask clear.	self view invalidate.</body><body package="UIPainter">undo	| swap |	undoBuffer isNil ifTrue: [^self].	swap := self editMask.	self editMask: undoBuffer.	undoBuffer := swap.	self view invalidate.</body></methods><methods><class-id>UI.MaskPainterController</class-id> <category>model access</category><body package="UIPainter">model: aModel	super model: aModel.	self editMask: nil.	undoBuffer := nil.</body></methods><methods><class-id>UI.MaskPainterController</class-id> <category>initialize-release</category><body package="UIPainter">initialize	coveragePaint := CoverageValue opaque.</body></methods><methods><class-id>UI.MaskPainterController</class-id> <category>mouse tracking</category><body package="UIPainter">mouseMovedTo: aPoint	"Selection continues at relative point aPoint."	| oldBounds newBounds redisplayBounds gc |	gc := self editMask graphicsContext.	geometricInProgress notNil ifTrue: [ 		oldBounds := geometricInProgress bounds copy.		newBounds := Rectangle vertex: originInProgress vertex: (self geometricConstrain: aPoint).		redisplayBounds := oldBounds merge: newBounds. 	].  	mode == #fill ifTrue: [^self]. 	mode == #rectangle ifTrue: [		geometricInProgress origin: newBounds origin corner: newBounds corner.		gc clear.		undoBuffer displayOn: gc.		gc paint: coveragePaint. 		geometricInProgress displayFilledOn: gc. 	].	mode == #ellipse ifTrue: [		geometricInProgress setBoundingBox: newBounds startAngle: 0 sweepAngle: 360. 		gc clear.		undoBuffer displayOn: gc.		gc paint: coveragePaint. 		geometricInProgress displayFilledOn: gc. 	].	mode == #brush ifTrue: [		| constrainedPoint |		gc paint: coveragePaint. 		constrainedPoint := self brushConstrain: aPoint. 		self brushStrokeOn: gc from: originInProgress to: constrainedPoint.		redisplayBounds := (originInProgress extent: brush extent) merge: (constrainedPoint extent: brush extent).		originInProgress := constrainedPoint. 	]. 	view simpleRedisplayIn: redisplayBounds colorBackgroundIfNeeded: (view backdrop isNil).</body><body package="UIPainter">selectUpAt: aPoint	"End selection at the relative point aPoint."	self mouseMovedTo: aPoint. 	mode == #fill ifTrue: [ self doFillAtPoint: aPoint]. 	geometricInProgress := nil.	originInProgress := nil.	self setCursor.</body><body package="UIPainter">startDragAt: aPoint	self model isNil ifTrue: [^self].	self refreshUndoBuffer. 	originInProgress := aPoint. 	mode == #rectangle ifTrue: [		Cursor corner beCursor. 		geometricInProgress :=  (aPoint corner: aPoint).	].	mode == #ellipse ifTrue: [		Cursor corner beCursor. 		geometricInProgress := EllipticalArc boundingBox: (aPoint corner: aPoint).	].	mode == #brush ifTrue: [		self constrainAxis: nil.		brush displayOn: self editMask graphicsContext at: aPoint.	].</body></methods><methods><class-id>UI.MaskPainterController</class-id> <category>events</category><body package="UIPainter">enterEvent: event		self setCursorForMode.	^super enterEvent: event</body><body package="UIPainter">exitEvent: event		self restoreCursor.	^super exitEvent: event</body></methods><methods><class-id>UI.MaskPainterController class</class-id> <category>class initialization</category><body package="UIPainter">initialize	"MaskPainterController initialize"	FillCursor := Cursor image:  (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette whiteBlack usingBits: #[0 0 0 0 3 0 0 0 4 128 0 0 5 224 0 0 6 176 0 0 4 156 0 0 8 142 0 0 17 70 0 0 32 142 0 0 64 22 0 0 64 38 0 0 32 70 0 0 16 132 0 0 9 4 0 0 6 0 0 0 0 0 0 0])				mask:  (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[3 0 0 0 7 128 0 0 15 224 0 0 15 240 0 0 15 252 0 0 15 254 0 0 31 255 0 0 63 255 0 0 127 255 0 0 255 255 0 0 255 255 0 0 127 239 0 0 63 206 0 0 31 142 0 0 15 4 0 0 6 0 0 0])				hotSpot: 14@14 				name: 'PaintBucket'.</body></methods><methods><class-id>Tools.BitEditorTracker</class-id> <category>private</category><body package="UIPainter">finishSelectionFor: aPoint 	self controller imageHasChanged: true.	super finishSelectionFor: aPoint.</body><body package="UIPainter">setUpFor: aMouseButtonEvent	| point |	point := self cursorPointFor: aMouseButtonEvent.	point := self view imageAtPoint: point.	point isNil ifTrue: [^self].	(self model atPoint: point) == self controller background		ifTrue: [color := self controller foreground]		ifFalse: [color := self controller background].</body><body package="UIPainter">trackSelectionFor: aPoint 	| point |	point := self view imageAtPoint: aPoint.	(point notNil and: [point ~= lastPoint])		ifTrue: 			[(self model atPoint: point)				== color				ifFalse: 					[self model atPoint: point put: color.					self model changed: #invalidate with: (point extent: 1 @ 1)].			lastPoint := point]</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>actions</category><body package="UIPainter">addCanvas	UIPainter new		openOnClass: (self selectedClassOrDo: [^self classGone])		andSelector: nil</body><body package="UIPainter">addDataModel	| cl le |	le := #{LensEditor} valueOrDo: [^nil].	cl := self selectedClassOrDo: [^Dialog warn: (#FirstSelectAClass &lt;&lt; #UIPainter &gt;&gt; 'First select a class') for: builder window].	le new openOnClass: cl andSelector: nil</body><body package="UIPainter">addHotRegions	UIHotRegionEditor new		openOnClass: (self selectedClassOrDo: [^self classGone])		andSelector: nil</body><body package="UIPainter">addIcon	UIMaskEditor new openOnClass: (self selectedClassOrDo: [^self classGone])		andSelector: nil</body><body package="UIPainter">addMenu	MenuEditor new		openOnClass: (self selectedClassOrDo: [^self classGone])		andSelector: nil</body><body package="UIPainter">addQuery	"Opens the query editor in arbitrary mode"	| qe |	qe := #{QueryEditor} valueOrDo: [nil].	qe isNil ifTrue: [^self].	qe new openOnClass: (self selectedClassOrDo: [^self classGone]) andSelector: nil</body><body package="UIPainter">browse	| cl |	self hasClassSelected ifFalse:			[(builder componentAt: #ClassNameList) flash.			^self].	cl := self selectedClassOrDo: [^self classGone].	UIFinderVW2 visited: (Array with: cl with: nil).	SmalltalkWorkbench browseClass: cl</body><body package="UIPainter">edit	| sel cl editee list le qe meth |	self hasClassSelected ifFalse:			[(editee := UIFinderVW2 openSourceDialogForResource: #canvas) isNil				ifTrue: [^self].			UIPainter new openOnClass: (editee at: 1)				andSelector: (editee at: 2).			^self].	(sel := self selector) isNil ifTrue: [(list := self selectorList list) size == 1			ifTrue: [self selectorList selection: (sel := list at: 1)]			ifFalse: 				[list size == 0					ifTrue: [self referUserToSpecBearingParent]					ifFalse: [(builder componentAt: #SelectorList) flash].				^self]].	cl := self selectedClassOrDo: [^self classGone].	meth := cl class compiledMethodAt: sel ifAbsent: [].	(meth == nil or: [meth resourceType == nil])		ifTrue:			[meth := cl compiledMethodAt: sel ifAbsent: [].			(meth == nil or: [meth resourceType == nil])				ifTrue: [^self selectorGone]].	meth resourceType = #query		ifTrue:			[qe := #{QueryEditor} valueOrDo: [nil].			qe == nil ifFalse: [^qe new openOnClass: cl andSelector: sel]].	meth resourceType = #canvas		ifTrue: [^UIPainter new openOnClass: cl andSelector: sel].	meth resourceType = #menu		ifTrue: [^MenuEditor new openOnClass: cl andSelector: sel].	meth resourceType = #dataModel		ifTrue:			[le := #{LensEditor} valueOrDo: [nil].			le == nil ifFalse: [^le new openOnClass: cl andSelector: sel]].	meth resourceType = #image		ifTrue: [^UIMaskEditor new openOnClass: cl andSelector: sel].	meth resourceType = #hotRegions		ifTrue: [^UIHotRegionEditor new openOnClass: cl andSelector: sel]</body><body package="UIPainter">helpAbout	AboutVisualWorksDialog open</body><body package="UIPainter">helpResourceFinder	'topic:vw.help.tools.resourceFinder' asURI open</body><body package="UIPainter">helpResources	'topic:vw.help.resources.finder' asURI open</body><body package="UIPainter">remove	self hasClassSelected ifFalse: [^self].	self selector isNil		ifTrue: [self removeClass]		ifFalse: [self removeResource]</body><body package="UIPainter">removeClass	| cl |	cl := self selectedClassOrDo: [^self classGone].	self removeClass: cl</body><body package="UIPainter">showDatabaseApplicationStructure	"Opens a LensApplicationStructureView on the selected class. It works 	for any kind of class, but it's most useful when the selected class is 	a Data Form or a LensMainApplication. The opened window is a 	Slave of the finder. Sets the finder in the view so any selection there 	can be reflected in the finder"	| lasv lasvBuilder lcl cl |	lcl := #{LensApplicationStructureView} valueOrDo: [^self].	lasv := lcl new.	lasvBuilder := lasv allButOpenInterface: #windowSpec.	lasvBuilder window openWithExtent: lasvBuilder windowSpec bounds extent.	lasv postOpenWith: lasvBuilder.	(lasvBuilder window) application: self; model: lasv; beSlave.	lasv finder: self.	cl := self selectedClassOrDo: [nil].	cl notNil ifTrue: [lasv focus value: cl]</body><body package="UIPainter">sortByName	partSortType value = #byName		ifFalse: 			[partSortType value: #byName.			self showSelectors: self computeSelectorList].	self adjustMenuAccordingToElement</body><body package="UIPainter">sortByType	partSortType value = #byType		ifFalse: 			[partSortType value: #byType.			self showSelectors: self computeSelectorList].	self adjustMenuAccordingToElement</body><body package="UIPainter">startApplication	| cl |	cl := self selectedClassOrDo: [^self classGone].	UIFinderVW2 visited: (Array with: cl with: nil).	(self selector isNil or:			[((cl class whichSelectorsReferTo: #SpecCollection) includes: self selector) not])		ifTrue:			[cl open]		ifFalse:			[cl new openInterface: self selector]</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>private</category><body package="UIPainter">adjustClassListMenu 	| sm |	sm := (classListMenuWithSelection value atNameKey: #viewMenu) submenu.	1 to: 5 do: [:itemNbr | (sm menuItemAt: itemNbr)			indication: nil].	filter == #showAllClasses		ifTrue: 			[(sm atNameKey: #showAllClasses) beOn.			^self].	(filter == #showClassesByCategory or: [filter == #showClassesByLastCategory])		ifTrue: 			[(sm atNameKey: #showClassesByCategory) beOn.			^self].	filter == #showRecentlyVisitedClasses		ifTrue: 			[(sm atNameKey: #showRecentlyVisitedClasses) beOn.			^self].	^self</body><body package="UIPainter">adjustMenuAccordingToElement	| sm cm |	sm := (menuBar value atNameKey: #viewMenu) submenu.	cm := (classListMenuWithSelection atNameKey: #viewMenu) submenu.	#(#sortByName #sortByType) do: [:key |			(sm atNameKey: key) indication: nil.			(cm atNameKey: key) indication: nil.].	partSortType value == #byType		ifTrue: 			[(sm atNameKey: #sortByType) beOn.			(cm atNameKey: #sortByType) beOn.			^self].	partSortType value == #byName		ifTrue: 			[(sm atNameKey: #sortByName) beOn.			(cm atNameKey: #sortByName) beOn.			^self].	^self</body><body package="UIPainter">adjustMenuAccordingToFilter	| sm |	sm := (menuBar value atNameKey: #viewMenu) submenu.	1 to: 5 do: [:itemNbr | (sm menuItemAt: itemNbr)			indication: nil].	filter == #showAllClasses		ifTrue: 			[(sm atNameKey: #showAllClasses) beOn.			^self].	(filter == #showClassesByCategory or: [filter == #showClassesByLastCategory])		ifTrue: 			[(sm atNameKey: #showClassesByCategory) beOn.			^self].	filter == #showRecentlyVisitedClasses		ifTrue: 			[(sm atNameKey: #showRecentlyVisitedClasses) beOn.			^self].	^self</body><body package="UIPainter">adjustMenus	self adjustMenuAccordingToFilter.	self adjustMenuAccordingToElement.	self adjustClassListMenu</body><body package="UIPainter">allClassesInHierarchyOf: aClassOrMetaclass 	| set instanceBehavior |	instanceBehavior := aClassOrMetaclass instanceBehavior.	set := Set with: instanceBehavior with: instanceBehavior class.	set addAll: instanceBehavior allSuperclasses;		 addAll: instanceBehavior class allSuperclasses;		 addAll: instanceBehavior allSubclasses;		 addAll: instanceBehavior class allSubclasses.	^set</body><body package="UIPainter">changedClassName	| selList sm mi oldSel |	oldSel := selectorList selection.	selectorList list: (selList := self computeSelectorList).	self hasClassSelected		ifFalse: 			[#(#startButton #removeButton #browseButton #editButton ) do: [:n | (builder componentAt: n) disable].			menuBar value: menuBarMenuWithNoSelection.			(builder window menuBar menuButtons at: (menuBar value indexOfMenuItem: (mi := menuBar value atNameKey: #resourcesMenu))) isEnabled: mi isEnabled.			self adjustMenus.			^self]		ifTrue: 			[#(#removeButton #browseButton ) do: [:n | (builder componentAt: n) enable].			"If the old selection is present in the new list, select it (and update the Edit button).			Otherwise, select the first item if there is only one."			(oldSel isNil not and: [selectorList list includes: oldSel])				ifTrue: 					[selectorList selection: oldSel.					(builder componentAt: #editButton) enable]				ifFalse: 					[selList size = 1 ifTrue: 						[selectorList selection: (selList at: 1).						(builder componentAt: #editButton) enable]].			sm := (menuBar value atNameKey: #classMenu) submenu.			(self selectedClassOrDo: []) isVisualStartable				ifTrue: 					[(builder componentAt: #startButton) enable.					(sm atNameKey: #startApplication) enable]				ifFalse: 					[(builder componentAt: #startButton) disable.					(sm atNameKey: #startApplication) disable].			selList size &gt; 1				ifTrue: 					[menuBar value: menuBarMenuWithNoCanvasSelected.					(builder componentAt: #editButton) disable.					self adjustMenus]]</body><body package="UIPainter">changedSelector	| sel cls |	self hasClassSelected ifFalse: [^self].	(sel := self selector) isNil		ifTrue: 			[menuBar value: menuBarMenuWithNoCanvasSelected.			(builder componentAt: #editButton) disable.			self adjustMenus.			^self].	cls := self selectedClassOrDo: [^self classGone].	(self isInstanceSideSelector: sel class: cls)		ifTrue: [(cls includesSelector: sel)				ifFalse: [^self selectorGone]]		ifFalse: [(cls class includesSelector: sel)				ifFalse: [^self selectorGone]].	menuBar value: menuBarMenuWithSelection.	(builder componentAt: #editButton) enable.	self adjustMenus</body><body package="UIPainter">classGone	Dialog warn: ((#class1sNoLongerExists &lt;&lt; #UIPainter &gt;&gt; 'class &lt;1s&gt; no longer exists')			expandMacrosWith: self classID asString) for: builder window.	self removeClassAndAdjustSets: self classID.	UIFinderVW2 changed: #specBearers.	#(#startButton #removeButton #browseButton #editButton ) do: [:n | (builder componentAt: n) disable]</body><body package="UIPainter">computeSelectorList	| class classInstance list |	self hasClassSelected ifFalse: [^List new].	classInstance := self selectedClassOrDo: 					[self classGone.					^List new].	class := classInstance class.	list := List new.	classInstance selectorsAndMethodsDo:		[:sel :meth |		meth resourceType == nil			ifFalse: [list add: sel -&gt; meth resourceType]].	class selectorsAndMethodsDo:		[:sel :meth |		meth resourceType == nil			ifFalse: [list add: sel -&gt; meth resourceType]].	partSortType value = #byName		ifTrue: 			[list := list asSortedStrings: [:p :a :b | (p collate: a key to: b key) &lt;= 0]]		ifFalse: 			[list := list asSortedStrings:					[:p :first :second |					first value = second value						ifTrue: [(p collate: first key to: second key) &lt;= 0]						ifFalse: [first value &lt;= second value]]].	iconList := list asList.	^iconList collect: [:asc | asc key]</body><body package="UIPainter">does: aClass inheritFromClassNamed: aSymbol	^self class does: aClass inheritFromClassNamed: aSymbol</body><body package="UIPainter">getClassNamed: aClassID	^aClassID asQualifiedReference valueOrDo: []</body><body package="UIPainter">isInstanceSideSelector: sel class: class	^(class includesSelector: sel) and: [ (class compiledMethodAt: sel) resourceType notNil]</body><body package="UIPainter">pruneRemovedClasses	| deaders |	deaders := OrderedCollection new.	SpecBearingClasses do: [:classID | classID isDefined ifFalse: [deaders add: classID]].	deaders isEmpty		ifFalse: 			[deaders				do: 					[:ddr | 					SpecBearingClasses remove: ddr.					RecentlyVisitedClasses remove: ddr ifAbsent: []].			SpecBearingCategories := Set new.			SpecBearingClasses do: [:classID | SpecBearingCategories add: classID value category].			UIFinderVW2 changed: #specBearers]</body><body package="UIPainter">referUserToSpecBearingParent	| totalNumberOfSpecs specBearingParent soleSpec canvases cls |	totalNumberOfSpecs := 0.	canvases := Dictionary new.	(cls := self selectedClassOrDo: [^self classGone]) class allSuperclasses		do: 			[:sc | 			| specCount specs |			specCount := (specs := sc organization listAtCategoryNamed: #'interface specs') size.			specCount &gt; 0				ifTrue: 					[specBearingParent := sc instanceBehavior.					canvases at: specBearingParent put: specs].			totalNumberOfSpecs := totalNumberOfSpecs + specCount.			specs isEmpty not ifTrue: [soleSpec := specs first]].	totalNumberOfSpecs == 1		ifTrue: [(Dialog				choose: ((#GenKey92 &lt;&lt; #UIPainter &gt;&gt; '&lt;1s&gt; inherits a canvas from&lt;n&gt;&lt;2s&gt;.&lt;n&gt;Edit this canvas?')			expandMacrosWith: cls printString asString			with: specBearingParent name)				labels: (Array with: (#Edit &lt;&lt; #UIPainter &gt;&gt; 'Edit') with: (#Cancel &lt;&lt; #UIPainter &gt;&gt; 'Cancel'))				values: #(true false )				default: true				for: builder window)				ifTrue: [UIPainter new openOnClass: specBearingParent andSelector: soleSpec]]		ifFalse: [totalNumberOfSpecs == 0				ifTrue: [Dialog warn: ((#x1sHasNoCanvases &lt;&lt; #UIPainter &gt;&gt; '&lt;1s&gt; has no canvases')			expandMacrosWith: cls printString) for: builder window]				ifFalse: [self class openInheritedCanvasDialogOn: cls name with: canvases]]</body><body package="UIPainter">removeClass: aClass 	(Dialog confirm: ((#GenKey94 &lt;&lt; #UIPainter &gt;&gt; 'Are you certain that you want to remove&lt;n&gt;class &lt;1s&gt; from the system?')			expandMacrosWith: aClass printString) for: builder window)		ifFalse: [^self].	(aClass subclasses size == 0 or: [Dialog confirm: ((#GenKey93 &lt;&lt; #UIPainter &gt;&gt; '&lt;1s&gt; has subclasses&lt;n&gt;Proceed with removal?')			expandMacrosWith: aClass name) for: builder window])		ifTrue: 			[aClass removeFromSystem.			self removeClassAndAdjustSets: aClass fullyQualifiedReference.			UIFinderVW2 changed: #specBearers]</body><body package="UIPainter">removeClassAndAdjustSets: aClassID	((SpecBearingClasses remove: aClassID ifAbsent: []) isNil and:			[(RecentlyVisitedClasses remove: aClassID ifAbsent: []) isNil])		ifTrue: [^self].	SpecBearingCategories := Set new.	SpecBearingClasses copy do:		[:classID | | cl |		(cl := classID valueOrDo: []) notNil			ifTrue: [SpecBearingCategories add: cl category]			ifFalse: [SpecBearingClasses remove: classID]]</body><body package="UIPainter">selectorGone	Dialog warn: ((#GenKey96 &lt;&lt; #UIPainter &gt;&gt; 'selector &lt;1s&gt; no longer exists')			expandMacrosWith: self selector) for: builder window.	selectorList list isEmpty		ifTrue: 			[self removeClassAndAdjustSets: self classID.			self perform: filter]		ifFalse: [self changedClassName]</body><body package="UIPainter">showClasses: aSet 	| oldClassName oldSelector |	oldClassName := self classNameList selection.	oldSelector := self selector.	classNameList list: (List withAll:		(aSet asSortedCollection: [:x :y | x asString &lt; y asString])).	oldClassName notNil ifTrue: [classNameList selection: oldClassName].	oldSelector notNil ifTrue: [selectorList selection: oldSelector]</body><body package="UIPainter">showSelectors: aList 	| oldSelector |	oldSelector := self selector.	self selectorList list: aList.	(oldSelector notNil and: [aList includes: oldSelector])		ifTrue: [self selectorList selection: oldSelector]</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>accessing</category><body package="UIPainter">classID	| sel |	sel := self classNameList selection.	^sel == nil		ifTrue: [nil]		ifFalse: [sel asQualifiedReference]</body><body package="UIPainter">className	| sel |	sel := self classNameList selection.	^sel == nil		ifTrue: [nil]		ifFalse: [sel asSymbol]</body><body package="UIPainter">filter: aNewValue 	filter = aNewValue		ifFalse: 			[filter := aNewValue.			self adjustMenuAccordingToFilter]</body><body package="UIPainter">hasClassSelected	^self classNameList selection notNil</body><body package="UIPainter">iconList	^iconList</body><body package="UIPainter">selectedClassOrDo: aBlock	| sel |	sel := self classNameList selection.	^sel == nil		ifTrue: [aBlock value]		ifFalse: [sel asQualifiedReference valueOrDo: aBlock]</body><body package="UIPainter">selector	^self selectorList selection</body><body package="UIPainter">updateTrigger	^updateTrigger</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>aspects</category><body package="UIPainter">classNameList	^classNameList</body><body package="UIPainter">selectorList	^selectorList</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>commands</category><body package="UIPainter">addClass	"If the new class created understands #windowSpec then the painter is opened using that method. This case happens when the class is a mian application"	| newCl nm finder |	nm := self classID.	nm == nil ifFalse: [nm := nm asString].	finder := ClassFinder new.	finder createMode.	finder findClass.	newCl := finder selectedClass.	newCl isNil ifTrue: [^self].	self class markAsSpecBearer: newCl.	(self does: newCl inheritFromClassNamed: #{LensDataManager})		ifTrue: [self class openCanvasGeneratorForClass: newCl]		ifFalse: [UIPainter new openOnClass: newCl andSelector: ((newCl respondsTo: #windowSpec)					ifTrue: [#windowSpec]					ifFalse: [nil])].	self classNameList selection: newCl fullyQualifiedReference</body><body package="UIPainter">fileOutClass	| cl fileName fileManager |	cl := self selectedClassOrDo: [^self classGone].	fileName := Dialog requestNewFileName: (#FileOutOn &lt;&lt; #UIPainter &gt;&gt; 'File out on') default: (Filename filterFilename: ('&lt;1s&gt;.st' expandMacrosWith: cl name)).	fileName = '' ifTrue: [^nil].	fileManager := SourceCodeStream write: fileName.		[fileManager timeStamp.	cl fileOutSourceOn: fileManager]		ensure: [fileManager close]</body><body package="UIPainter">newImageFromFile	|cl aFilename newSelector|	cl := self selectedClassOrDo: [^self classGone].	(aFilename := Dialog 		requestFileName: (#NameOfBitmapFile &lt;&lt; #UIPainter &gt;&gt; 'Name of bitmap file') asString		default: '*.bmp') isEmpty  ifTrue: [^self].	(newSelector := Dialog request: (#GenKey91 &lt;&lt; #UIPainter &gt;&gt; 'Supply the name of the new method to be created:')) isEmpty		ifTrue: [^self].	(cl class includesSelector: newSelector asSymbol) 		ifTrue: 			[(Dialog 				confirm: ((#GenKey90 &lt;&lt; #UIPainter &gt;&gt; '#&lt;1s&gt; already exists in class &lt;2s&gt;!Are you sure you want to replace it?') expandMacrosWith: newSelector with: cl printString))				ifFalse: [^self]].	ImageReader 		imageFromFile: aFilename		toClass: cl  		selector: newSelector asSymbol.	"Force a refresh on the list we care about"	self changedClassName</body><body package="UIPainter">openNewHotRegions	UIHotRegionEditor open</body><body package="UIPainter">openNewIcon	UIMaskEditor open</body><body package="UIPainter">openNewMenu	MenuEditor open</body><body package="UIPainter">openNewWindowCanvas	"Open a new canvas."	UIPainter new openNewWindowCanvas</body><body package="UIPainter">removeResource	| cl sel isInstance |	cl := self selectedClassOrDo: [^self classGone].	sel := self selector.	(isInstance := self isInstanceSideSelector: sel class: cl)		ifTrue: [(cl includesSelector: sel)				ifFalse: [^self selectorGone]]		ifFalse: [(cl class includesSelector: sel)				ifFalse: [^self selectorGone]].	(Dialog confirm: (#GenKey95 &lt;&lt; #UIPainter &gt;&gt; 'Are you certain you want to remove this resource method?') for: builder window)		ifTrue: 			[isInstance				ifTrue: [cl removeSelector: sel]				ifFalse: [cl class removeSelector: sel].			(cl class organization listAtCategoryNamed: #'interface specs') isEmpty ifTrue: [cl class organization removeCategory: #'interface specs'].			(cl class organization listAtCategoryNamed: #resources) isEmpty ifTrue: [cl class organization removeCategory: #resources].			(cl class organization listAtCategoryNamed: #'lens data model specs') isEmpty ifTrue: [cl class organization removeCategory: #'lens data model specs'].			(cl organization listAtCategoryNamed: #query) isEmpty ifTrue: [cl organization removeCategory: #query].			selectorList list remove: sel.			(selectorList list isEmpty and: [(cl allSuperclasses detect: [:scl | (scl organization listAtCategoryNamed: #'interface specs') isEmpty not]					ifNone: [nil]) notNil])				ifTrue: 					[self removeClassAndAdjustSets: cl fullyQualifiedReference.					UIFinderVW2 changed: #specBearers].			self showSelectors: self computeSelectorList]</body><body package="UIPainter">renameClass	| cl clName aString newName |	cl := self selectedClassOrDo: [^self classGone].	aString := Dialog request: (#EnterNewClassName &lt;&lt; #UIPainter &gt;&gt; 'Enter new ClassName') initialAnswer: cl fullName for: builder window.	aString isEmpty ifTrue: [^self].	newName := SystemUtils			validateClassName: aString			for: builder window.	newName == nil ifTrue: [^self].	clName := cl fullyQualifiedReference.	SmalltalkWorkbench		rename: cl		to: newName		do: 			[:cls :nm | 			SpecBearingClasses remove: clName.			SpecBearingClasses add: cls fullyQualifiedReference.			RecentlyVisitedClasses remove: clName ifAbsent: [].			RecentlyVisitedClasses add: cls fullyQualifiedReference.			UIFinderVW2 changed: #specBearers.			self classNameList selection: cls fullyQualifiedReference]		for: builder window		browser: nil</body><body package="UIPainter">showAllClasses	self filter: #showAllClasses.	(builder componentAt: #ClassNameListLabel)		labelString: (#Classes &lt;&lt; #UIPainter &gt;&gt; 'Classes').	self showClasses: SpecBearingClasses</body><body package="UIPainter">showClassesByCategory	| selector categoryClasses stringSize |	stringSize := UISettings preferenceFor: #toolsLabelStringLimit.	selector := Dialog				choose: (#SelectClassCategory &lt;&lt; #UIPainter &gt;&gt; 'Select class category...')				fromList: (SpecBearingCategories asSortedStrings collect: [:sel | sel contractTo: stringSize])				values: SpecBearingCategories asSortedStrings				lines: 10				cancel: [nil]				for: builder window.	selector == nil		ifFalse: 			[self filter: #showClassesByLastCategory.				(builder componentAt: #ClassNameListLabel) widget labelString: ((#x1sClasses &lt;&lt; #UIPainter &gt;&gt; '&lt;1s&gt; Classes')			expandMacrosWith: selector asString).			categoryClasses := Set new.			lastCategory := selector.			SpecBearingClasses copy				do: 					[:classID | | cl cln |					(cl := classID valueOrDo: [SpecBearingClasses remove: classID. nil]) notNil						ifTrue:							[cln := cl category.							cln = selector								ifTrue: [categoryClasses add: classID]]].			self showClasses: categoryClasses]</body><body package="UIPainter">showClassesByLastCategory	| categoryClasses |	lastCategory isNil		ifTrue: 			[self showAllClasses.			^self].	self filter: #showClassesByLastCategory.	(builder componentAt: #ClassNameListLabel) widget labelString: ((#x1sClasses &lt;&lt; #UIPainter &gt;&gt; '&lt;1s&gt; Classes')			expandMacrosWith: lastCategory asString).	categoryClasses := Set new.	SpecBearingClasses copy		do: 			[:classID |			| cl cln |			(cl := classID valueOrDo: [SpecBearingClasses remove: classID. nil]) notNil				ifTrue:					[cln := cl category.					cln = lastCategory						ifTrue: [categoryClasses add: classID]]].	self showClasses: categoryClasses</body><body package="UIPainter">showRecentlyVisitedClasses	self filter: #showRecentlyVisitedClasses.	(builder componentAt: #ClassNameListLabel) widget labelString: (#RecentlyVisitedClasses &lt;&lt; #UIPainter &gt;&gt; 'Recently Visited Classes').	self showClasses: RecentlyVisitedClasses</body><body package="UIPainter">update	self class computeSpecBearingClasses.	self perform: filter.	self changed: #update</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>initialize-release</category><body package="UIPainter">initialize	super initialize.	addWhat := #cndCanvas asValue.	partSortType := #byType asValue.	updateTrigger := false asValue.	lastCategory := nil.	UIFinderVW2 dependents isEmpty ifTrue: [Cursor wait showWhile: [self class computeSpecBearingClasses]].	(classNameList := SelectionInList new) list: (List withAll: (SpecBearingClasses asSortedCollection: [:x :y | x asString &lt; y asString])).	self setMenus.	menuBar := menuBarMenuWithNoSelection asValue.	selectorList := SelectionInList new.	self filter: #showAllClasses.	self adjustMenus.	classNameList selectionIndexHolder onChangeSend: #changedClassName to: self.	selectorList selectionIndexHolder onChangeSend: #changedSelector to: self</body><body package="UIPainter">release	UIFinderVW2 removeDependent: self.	^super release</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>menus</category><body package="UIPainter">classNameListMenu	^[self hasClassSelected		ifFalse: [classListMenuForNoSelection]		ifTrue:			[| rslt cl |			rslt := classListMenuWithSelection.			(cl := self selectedClassOrDo: []) isVisualStartable				ifTrue:					[(rslt atNameKey: #startApplication) enable]				ifFalse:					[(rslt atNameKey: #startApplication) disable].			(cl canUnderstand: #dataModel)				ifTrue:					[(rslt atNameKey: #showDatabaseApplicationStructure) enable]				ifFalse:					[(rslt atNameKey: #showDatabaseApplicationStructure) disable].			rslt]]</body><body package="UIPainter">menuBar	^menuBar</body><body package="UIPainter">selectorListMenu	^[self selector isNil		ifTrue: [self hasClassSelected				ifTrue: [SelListMenuForNoSelection]				ifFalse: [nil]]		ifFalse: [SelListMenuWithSelection]]</body><body package="UIPainter">setMenus	| viewMenu selMenu noSelMenu classMenu helpMenu list |	viewMenu := self class viewMenu.	selMenu := self class selMenu.	noSelMenu := self class noSelMenu.	classMenu := self class classMenu.	helpMenu := self class helpMenu.	menuBarMenuWithNoSelection := (Menu new) 		addItem: ((MenuItem labeled: (#_View &lt;&lt; #UIPainter &gt;&gt; '&amp;View')) nameKey: #viewMenu; submenu: viewMenu); 		addItem: ((MenuItem labeled: (#_Class &lt;&lt; #UIPainter &gt;&gt; '&amp;Class')) nameKey: #classMenu; submenu: classMenu); 		addItem: ((MenuItem labeled: (#_Resources &lt;&lt; #UIPainter &gt;&gt; '&amp;Resources')) nameKey: #resourcesMenu; submenu: noSelMenu; disable);		addItem: ((MenuItem labeled: (#_Help &lt;&lt; #UIPainter &gt;&gt; '&amp;Help')) nameKey: #help; submenu: helpMenu).	classMenu := classMenu copy.	classMenu menuItems do: [:each | each enable].	(classMenu atNameKey: #showDatabaseApplicationStructure) 		enabled: [(self selectedClassOrDo: []) canUnderstand: #dataModel ].	menuBarMenuWithSelection := (Menu new)		addItem: ((MenuItem labeled: (#_View &lt;&lt; #UIPainter &gt;&gt; '&amp;View')) nameKey: #viewMenu; submenu: viewMenu); 		addItem: ((MenuItem labeled: (#_Class &lt;&lt; #UIPainter &gt;&gt; '&amp;Class')) nameKey: #classMenu; submenu: classMenu); 		addItem: ((MenuItem labeled: (#_Resources &lt;&lt; #UIPainter &gt;&gt; '&amp;Resources')) nameKey: #resourcesMenu; submenu: selMenu; disable);		addItem: ((MenuItem labeled: (#_Help &lt;&lt; #UIPainter &gt;&gt; '&amp;Help')) nameKey: #help; submenu: helpMenu).	menuBarMenuWithNoCanvasSelected := (Menu new)		addItem: ((MenuItem labeled: (#_View &lt;&lt; #UIPainter &gt;&gt; '&amp;View')) nameKey: #viewMenu; submenu: viewMenu); 		addItem: ((MenuItem labeled: (#_Class &lt;&lt; #UIPainter &gt;&gt; '&amp;Class')) nameKey: #classMenu; submenu: classMenu); 		addItem: ((MenuItem labeled: (#_Resources &lt;&lt; #UIPainter &gt;&gt; '&amp;Resources')) nameKey: #resourcesMenu; submenu: noSelMenu);		addItem: ((MenuItem labeled: (#_Help &lt;&lt; #UIPainter &gt;&gt; '&amp;Help')) nameKey: #help; submenu: helpMenu).	viewMenu := viewMenu copy.	viewMenu menuItems do: [ :item | item label: item label asLowercase.							item label = (#exit &lt;&lt; #UIPainter &gt;&gt; 'exit') asString ifTrue: [ viewMenu hideItem: item ] ].	classMenu := classMenu copy.	classMenu menuItems do: [  :item | item label: item label asLowercase].	classListMenuWithSelection := (Menu new)		addItemGroup: (Array with: ((MenuItem labeled: (#view &lt;&lt; #UIPainter &gt;&gt; 'view')) nameKey: #viewMenu; submenu: viewMenu)).	classMenu visibleMenuItemGroups 		do: [ :group | 1 to: group size 			do: [ :i | i == 1 					ifTrue: [ classListMenuWithSelection addItemGroup: (Array with: (group at: 1)) ] 					ifFalse:[ classListMenuWithSelection addItem: (group at: i)  ] ]].	list := classMenu values asOrderedCollection.	list addFirst: nil.	classListMenuWithSelection values: list. 	classListMenuForNoSelection := (Menu new)		addItemGroup: (Array with: ((MenuItem labeled: (#view &lt;&lt; #UIPainter &gt;&gt; 'view')) nameKey: #viewMenu; submenu: viewMenu));		addItemGroup: (Array with: (MenuItem labeled: (#adddots &lt;&lt; #UIPainter &gt;&gt; 'add...'))) values: #(addClass)</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>events</category><body package="UIPainter">windowEvent: anEvent from: aWindow 	super windowEvent: anEvent from: aWindow.	(#(#close #release ) includes: anEvent key)		ifTrue: [self release]</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>updating</category><body package="UIPainter">update: anAspect with: aParameter from: anObject 	| sb sm class cName |	anAspect == #recentlyVisited		ifTrue: 			[filter == #showRecentlyVisitedClasses ifTrue: [self showRecentlyVisitedClasses].			class := aParameter at: 1.			cName := class == nil ifTrue: [nil] ifFalse: [class fullyQualifiedReference].			(classNameList list includes: cName) not ifTrue: [self perform: filter].			((self selectedClassOrDo: []) == class and: [(aParameter at: 2) notNil and: [(self selectorList list includes: (aParameter at: 2)) not]])				ifTrue: 					[self showSelectors: self computeSelectorList.					((sb := builder componentAt: #startButton) isEnabled not and: [class isVisualStartable])						ifTrue: 							[sm := (menuBar value atNameKey: #classMenu) submenu.							(sm atNameKey: #startApplication) enable.							sb enable]].			self changed: #recentlyVisited with: aParameter.			^self].	anAspect == #specBearers ifTrue: [self perform: filter].	^super		update: anAspect		with: aParameter		from: anObject</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>interface opening</category><body package="UIPainter">postBuildWith: aBuilder	| widget val |	#(#browseButton #startButton #removeButton #editButton) do: [:n | (aBuilder componentAt: n) disable].	aBuilder window application: self.	aBuilder window sendWindowEvents: #(#close #release).	widget := (builder componentAt: #SelectorList) widget.	widget selectedVisualBlock: 			[:v :index |			| rw |			val := (self iconList at: index) value.			rw := ReversingWrapper on: ((LabelAndIcon with: (v displayStringAt: index) attributes: v textStyle)								icon: (TypeIcons at: val ifAbsent: [TypeIcons at: #other])).			rw reverse setValue: true.			BoundedWrapper on: rw].	widget visualBlock: 			[:v :i |			val := (self iconList at: i) value.			BoundedWrapper on: ((LabelAndIcon with: (v displayStringAt: i) attributes: v textStyle)						icon: (TypeIcons at: val ifAbsent: [TypeIcons at: #other]))]</body><body package="UIPainter">postOpenWith: aBuilder 	"Delay adding ourselves to UIFinderVW2's dependents until the 	very last possible moment."	| mi |	UIFinderVW2 addDependent: self.	(builder window menuBar menuButtons			at: (menuBar value indexOfMenuItem: (mi := menuBar value atNameKey: #resourcesMenu)))		isEnabled: mi isEnabled</body></methods><methods><class-id>Tools.UIFinderVW2</class-id> <category>browseSenders</category><body package="UIPainter">browseSenders	| theClass sel aSortedCollection |	self hasClassSelected ifFalse: [^self].	(sel := self selector) isNil ifTrue: [^self].	theClass := self selectedClassOrDo: [^self classGone].	(self isInstanceSideSelector: sel class: theClass)		ifTrue: [(theClass includesSelector: sel)				ifFalse: [^self selectorGone]]		ifFalse: [(theClass class includesSelector: sel)				ifFalse: [^self selectorGone]].	aSortedCollection := SortedCollection forStrings.	Cursor execute showWhile: [(self allClassesInHierarchyOf: theClass)			do: [:class | (class whichSelectorsReferTo: sel)					do: [:slctr | aSortedCollection add: (MethodDefinition class: class selector: slctr)]]].	MethodCollector new		openListBrowserOn: aSortedCollection		label: ((#GenKey88 &lt;&lt; #UIPainter &gt;&gt; 'Senders of #&lt;1s&gt; in hierarchy of &lt;2s&gt;')			expandMacrosWith: sel			with: theClass name)		initialSelection: sel</body></methods><methods><class-id>Tools.UIFinderVW2 class</class-id> <category>resources</category><body package="UIPainter">beOther	"An unknown resource has been used.  By default use a question mark as its icon in the UIFinder"	^self Cquestion</body><body package="UIPainter">noSelMenu 	^(Menu new) 		addItem: (MenuItem labeled: (#New_Canvas &lt;&lt; #UIPainter &gt;&gt; 'New &amp;Canvas')) value: #addCanvas; 		addItem: (MenuItem labeled: (#New_Menu &lt;&lt; #UIPainter &gt;&gt; 'New &amp;Menu')) value: #addMenu; 		addItem: (MenuItem labeled: (#New_Image &lt;&lt; #UIPainter &gt;&gt; 'New &amp;Image')) value: #addIcon; 		addItem: (MenuItem labeled: (#NewImageFrom_File &lt;&lt; #UIPainter &gt;&gt; 'New Image From &amp;File')) value: #newImageFromFile;		addItem: (MenuItem labeled: (#New_HotRegions &lt;&lt; #UIPainter &gt;&gt; 'New &amp;Hot Regions')) value: #openNewHotRegions; 		addItem: ((MenuItem labeled: (#New_Query &lt;&lt; #UIPainter &gt;&gt; 'New &amp;Query')) enabled: [#{QueryEditor} isDefined]) value: #addQuery; 		addItem: ((MenuItem labeled: (#New_DataModel &lt;&lt; #UIPainter &gt;&gt; 'New &amp;Data Model')) enabled: [#{LensEditor} isDefined]) value: #addDataModel; 		addItemGroup: 			(Array				with: (MenuItem labeled: (#_Edit &lt;&lt; #UIPainter &gt;&gt; '&amp;Edit')) disable				with: (MenuItem labeled: (#_Senders &lt;&lt; #UIPainter &gt;&gt; '&amp;Senders')) disable) values: #(#edit #browseSenders ); 		addItemGroup: 			(Array 				with: (MenuItem labeled: (#_Remove &lt;&lt; #UIPainter &gt;&gt; '&amp;Remove...')) disable) values: #(#removeResource ).</body><body package="UIPainter">selMenu 	^(Menu new) 		addItem: (MenuItem labeled: (#New_Canvas &lt;&lt; #UIPainter &gt;&gt; 'New &amp;Canvas')) value: #openNewWindowCanvas; 		addItem: (MenuItem labeled: (#New_Menu &lt;&lt; #UIPainter &gt;&gt; 'New &amp;Menu')) value: #openNewMenu; 		addItem: (MenuItem labeled: (#New_Image &lt;&lt; #UIPainter &gt;&gt; 'New &amp;Image')) value: #openNewIcon; 		addItem: (MenuItem labeled: (#NewImageFrom_File &lt;&lt; #UIPainter &gt;&gt; 'New Image From &amp;File')) value: #newImageFromFile;		addItem: (MenuItem labeled: (#New_HotRegions &lt;&lt; #UIPainter &gt;&gt; 'New &amp;Hot Regions')) value: #openNewHotRegions; 		addItem: ((MenuItem labeled: (#New_Query &lt;&lt; #UIPainter &gt;&gt; 'New &amp;Query')) enabled: [#{QueryEditor} isDefined]) value: #addQuery; 		addItem: ((MenuItem labeled: (#New_DataModel &lt;&lt; #UIPainter &gt;&gt; 'New &amp;Data Model')) enabled: [#{LensEditor} isDefined]) value: #addDataModel; 		addItemGroup: (Array						with: (MenuItem labeled: (#_Edit &lt;&lt; #UIPainter &gt;&gt; '&amp;Edit'))						with: (MenuItem labeled: (#_Senders &lt;&lt; #UIPainter &gt;&gt; '&amp;Senders')))					values: #(#edit #browseSenders ); 		addItemGroup: (Array with: (MenuItem labeled: (#_Remove &lt;&lt; #UIPainter &gt;&gt; '&amp;Remove...'))) values: #(#removeResource ).</body></methods><methods><class-id>Tools.UIFinderVW2 class</class-id> <category>private</category><body package="UIPainter">computeRecentlyVisitedMenu	"UIFinderVW2 computeRecentlyVisitedMenu"	| labels values |	RecentlyVisitedClasses isEmpty		ifTrue:			[Dialog warn: (#GenKey97 &lt;&lt; #UIPainter &gt;&gt; 'There are no recently visited classes')].	labels := OrderedCollection new.	values := OrderedCollection new.	RecentlyVisitedClasses copy do:		[:classID |		| list cl |		((cl := classID valueOrDo: [nil]) notNil and:				[(list := cl class organization listAtCategoryNamed: #'interface specs') isEmpty not])			ifTrue:				[labels add: classID asString.				values add:					(list size == 1						ifTrue:							[[UIPainter new openOnClass: cl andSelector: list first]]						ifFalse:							[Menu								labelArray:									(list collect: [:elt | elt asString]) asArray								values:									(list collect:										[:selName |										[UIPainter new openOnClass: cl andSelector: selName]])])]			ifFalse:				[RecentlyVisitedClasses remove: classID ifAbsent: [self error: (#shouldntHappen &lt;&lt; #UIPainter &gt;&gt; 'shouldn''t happen')]]].	^Menu		labelArray: labels asArray		lines: Array new		values: values asArray</body><body package="UIPainter">computeSpecBearingClasses	| deadRecents |	SpecBearingClasses := Set new.	SystemUtils allBehaviorsDo:		[:cls |		cls selectorsAndMethodsDo:			[:sel :meth |			meth resourceType == nil				ifFalse: [SpecBearingClasses add: cls instanceBehavior fullyQualifiedReference]]].	"SpecBearingClasses asOrderedCollection do: [:cn | cn value allSubclasses do: [:subC | SpecBearingClasses add: subC fullyQualifiedReference]]."	deadRecents := RecentlyVisitedClasses select: [:cln | (SpecBearingClasses includes: cln) not].	deadRecents isEmpty ifFalse: [RecentlyVisitedClasses removeAll: deadRecents].	self changed: #specBearers.	SpecBearingCategories := Set new.	SpecBearingClasses do: [:classID | SpecBearingCategories add: classID value category].	^SpecBearingClasses</body><body package="UIPainter">does: aClass inheritFromClassNamed: anID	| cl | 	cl := anID asQualifiedReference valueOrDo: [nil].	^cl == nil		ifTrue: [false]		ifFalse: [aClass inheritsFrom: cl]</body><body package="UIPainter">getClassNamed: aClassID	^aClassID asQualifiedReference valueOrDo: []</body><body package="UIPainter">markAsSpecBearer: aClass 	| anyChange newVisit |	newVisit := false.	anyChange := (SpecBearingClasses includes: aClass fullyQualifiedReference) not.	anyChange ifTrue: [SpecBearingClasses add: aClass fullyQualifiedReference].	(SpecBearingCategories includes: aClass category)		ifFalse: 			[SpecBearingCategories add: aClass category.			anyChange := true].	RecentlyVisitedClasses remove: aClass fullyQualifiedReference ifAbsent: [newVisit := true].	RecentlyVisitedClasses add: aClass fullyQualifiedReference.	anyChange		ifTrue: [self changed: #specBearers]		ifFalse: [newVisit ifTrue: [self changed: #recentlyVisited with: (Array with: aClass with: nil)]]</body><body package="UIPainter">obsolete	"The receiver was removed from the system and is now obsolete. Perform any necessary clean-up. Answer the receiver."	"When the receiver is removed, we disable any notion of it in the main launcher."	super obsolete.	#{VisualLauncher} ifDefinedDo:		[:launcher| launcher isNil ifFalse: [launcher checkInstalledComponents]]</body><body package="UIPainter">openCanvasGeneratorForClass: cl 		#{LensApplicationSpecEditor} value new openDialogForClass: cl</body><body package="UIPainter">resultsForClassName: className andSelectorList: selectorList orSelectorNamed: selectorName resource: resourceType	| cl sel |	^((cl := self getClassNamed: className) isNil or:			[(sel := self					selectorOnClass: cl					inList: selectorList					orNamed: selectorName					resource: resourceType) isNil])		ifTrue: [nil]		ifFalse: [Array with: cl with: sel]</body><body package="UIPainter">selectorOnClass: aClass inList: aSelectorList orNamed: selectorName resource: resourceType	| selector meth ok |	selectorName isNil ifTrue: [^nil].	^(selector := selectorName asSymbol) isEmpty		ifTrue: [(selector := aSelectorList selection) isNil				ifTrue: [nil]				ifFalse: [selector]]		ifFalse:			[meth := aClass compiledMethodAt: selector ifAbsent: [].			ok := meth == nil or: [meth resourceType = resourceType].			(ok or: [Dialog confirm:					(#GenKey100 &lt;&lt; #UIPainter &gt;&gt; 'That selector is already defined.&lt;n&gt;&lt;t&gt;&lt;t&gt;Redefine anyway?') expandMacros])				ifTrue: [selector]				ifFalse: [nil]]</body><body package="UIPainter">selectorsOfResource: type in: class	| all |	all := SortedCollection new.	class selectorsAndMethodsDo:		[:s :m |		m resourceType == type			ifTrue: [all add: s]].	^all asList</body><body package="UIPainter">upgradeICCSpecs	"UIFinderVW2 upgradeICCSpecs"	| methodNames class selector method source stop methodCollector newSource startIndex endIndex newMethod |	methodCollector := MethodCollector new.	methodNames := methodCollector allReferencesTo: #ICC2TabControlSpec.	methodNames addAll: (methodCollector allReferencesTo: #ICC2TreeViewSpec).	#{Kernel.Undeclared.ICC2SelectionInTree} bindingOrNil isNil ifFalse:		[methodNames addAll: (methodCollector allReferencesTo: #{Kernel.Undeclared.ICC2SelectionInTree} binding)].	stop := thisContext method.	methodNames asSet do: 		[:each | 		class := each implementingClass.		selector := each selector.		method := class compiledMethodAt: selector.		(method numArgs = 0 and: [method ~~ stop and: [(source := method getSource) notNil]]) ifTrue:			[newSource := String new writeStream.			startIndex := 1.			[endIndex := 0.			(endIndex := source findString: 'ICC2TabControlSpec' startingAt: startIndex) = 0.			endIndex &gt; 0] whileTrue: 				[newSource 					nextPutAll: (source copyFrom: startIndex to: endIndex -1);					nextPutAll: 'TabControlSpec'.				startIndex := endIndex + 18].			newSource nextPutAll: (source copyFrom: startIndex to: (source size)).			source := newSource contents. 			newSource := String new writeStream.			startIndex := 1.			[endIndex := 0.			(endIndex := source findString: 'ICC2TreeViewSpec' startingAt: startIndex) = 0.			endIndex &gt; 0] whileTrue: 				[newSource 					nextPutAll: (source copyFrom: startIndex to: endIndex -1);					nextPutAll: 'TreeViewSpec'.				startIndex := endIndex + 16].			newSource nextPutAll: (source copyFrom: startIndex to: (source size)).			source := newSource contents.			newSource := String new writeStream.			startIndex := 1.			[endIndex := 0.			(endIndex := source findString: 'ICC2SelectionInTree' startingAt: startIndex) = 0.			endIndex &gt; 0] whileTrue: 				[newSource 					nextPutAll: (source copyFrom: startIndex to: endIndex -1);					nextPutAll: 'SelectionInTree'.				startIndex := endIndex + 19].			newSource nextPutAll: (source copyFrom: startIndex to: (source size)).			source := newSource contents. 			newMethod := Compiler new parse: source in: class notifying: nil.			newMethod == nil ifFalse: [class compile: source]]].	#{Kernel.Undeclared.ICC2SelectionInTree} bindingOrNil isNil ifFalse:		[#{Kernel.Undeclared.ICC2SelectionInTree} removeFromSystem].</body><body package="UIPainter">upgradeOldStyleSpecs	"UIFinderVW2 upgradeOldStyleSpecs"	| methodNames class selector method src val newMethod stop match mc |	mc := MethodCollector new.	methodNames := mc allReferencesTo: #SpecCollection.	methodNames addAll: (mc allReferencesTo: #Menu).	methodNames addAll: (mc allReferencesTo: #PopUpMenu).	methodNames addAll: (mc allReferencesTo: #{Menu} binding).	methodNames addAll: (mc allReferencesTo: #extent:depth:palette:bits:).	methodNames addAll: (mc allReferencesTo: #extent:depth:palette:bits:pad:).	methodNames addAll: (mc allReferencesTo: #extent:depth:bitsPerPixel:palette:usingBits:).	methodNames addAll: (mc allReferencesTo: #LensStructureType).	"methodNames addAll: (mc allReferencesTo: #{QueryOperation} binding).	methodNames addAll: (mc allReferencesTo: #{LensQuery} binding)."	stop := thisContext method.	methodNames asSet		do: 			[:md | 			class := md implementingClass.			selector := md selector.			method := class compiledMethodAt: selector.			(method resourceType == nil and:					[method numArgs = 0 and:						[method ~~ stop and:							[(src := method getSource) notNil and:								[self findEditorComment: src]]]])				ifTrue:					[val := (class isMeta ifTrue: [class instanceBehavior perform: selector] ifFalse: [nil]).					match := false.					(val isKindOf: Menu)						ifTrue:							[ | tmp |							match := true.							src := src 								copyReplaceFrom: (tmp := src indexOf: $^)								to: tmp								with: '&lt;resource: #menu&gt;	^'].					(val isKindOf: VisualComponent)						ifTrue:							[ | tmp |							match := true.							src := src 								copyReplaceFrom: (tmp := src indexOf: $^)								to: tmp								with: '&lt;resource: #image&gt;	^'].					(val class == Array and: [val first = #FullSpec])						ifTrue:							[ | tmp |							match := true.							src := src 								copyReplaceFrom: (tmp := src indexOf: $^)								to: tmp								with: '&lt;resource: #canvas&gt;	^'].					(val class == Array and: [val first = #LensDataModel])						ifTrue:							[ | tmp |							match := true.							src := src 								copyReplaceFrom: (tmp := src indexOf: $^)								to: tmp								with: '&lt;resource: #dataModel&gt;	^'].					(val isNil and: [(class organization categoryOfElement: selector) == #query])						ifTrue:							[match := true.							src := src copyReplaceAll: '| _qo |' with: '&lt;resource: #query&gt;	| _qo |'].					match ifFalse: [Transcript cr; print: class; space; show: selector].					newMethod := Compiler new parse: src in: class notifying: nil.					newMethod == nil						ifFalse: [class compile: src].					]].</body></methods><methods><class-id>Tools.UIFinderVW2 class</class-id> <category>statistics</category><body package="UIPainter">installed: classSelectorArray 	| clName |	clName := (classSelectorArray at: 1) fullyQualifiedReference.	(SpecBearingClasses includes: clName) not		ifTrue: 			[SpecBearingClasses add: clName.			SpecBearingCategories := Set new.			SpecBearingClasses				do: [:classID | | cl |					cl := classID valueOrDo: [nil].					cl notNil ifTrue: [SpecBearingCategories add: cl category]].			RecentlyVisitedClasses add: clName].	self visited: classSelectorArray.	self changed: #installedCanvas		with: classSelectorArray</body><body package="UIPainter">recentlyVisitedClasses	^RecentlyVisitedClasses copy</body><body package="UIPainter">recentlyVisitedClassesMenu	^self computeRecentlyVisitedMenu</body><body package="UIPainter">resetRecentlyVisited	(Dialog confirm: (#GenKey99 &lt;&lt; #UIPainter &gt;&gt; 'Really forget which classeshave recently been visited?'))		ifTrue: 			[RecentlyVisitedClasses := OrderedCollection new.			self changed: #recentlyVisited				with: (Array with: nil with: nil)]</body><body package="UIPainter">visited: classSelectorArray 	"Used to collect an impression of what classes the user has been working 	with."	| clName shouldUpdate class |	class := classSelectorArray at: 1.	clName := class == nil				ifTrue: [class]				ifFalse: [class fullyQualifiedReference].	shouldUpdate := true.	(RecentlyVisitedClasses includes: clName)		ifTrue: 			[RecentlyVisitedClasses remove: clName.			"If we are just reordering a class, no need to update the dependents."			shouldUpdate := false].	RecentlyVisitedClasses addFirst: clName.	RecentlyVisitedClasses size &gt; 10 ifTrue: [RecentlyVisitedClasses removeLast].	shouldUpdate		ifTrue: [self changed: #recentlyVisited				with: classSelectorArray]</body></methods><methods><class-id>Tools.UIFinderVW2 class</class-id> <category>interface opening</category><body package="UIPainter">openInheritedCanvasDialogOn: aClassName with: canvases	| canvasNames builder dialog canvasList |	canvasNames := Dictionary new.	canvases keysDo:		[:cl |		| clName |		clName := cl name.		(canvases at: cl) do:			[:cnvName |			| fullName |			fullName := clName, ' ', cnvName.			canvasNames at: fullName put: cl -&gt; cnvName]].	builder := (dialog := SimpleDialog new) builder.	builder		aspectAt: #canvasList		put: (canvasList := SelectionInList with: canvasNames keys asOrderedCollection).	builder aspectAt: #doOK put:		[| entry |		(entry := canvasList selection) isNil			ifTrue: [(builder componentAt: #canvasList) flash]			ifFalse:				[entry := canvasNames at: entry.				[UIPainter new					openOnClass: entry key					andSelector: entry value] fork.				dialog close]].	builder aspectAt: #doAbort put: [dialog close].	dialog allButOpenFrom: (UISpecification from: self inheritedCanvasDialog).	dialog builder openDialog.</body><body package="UIPainter">openSourceDialogForClass: aClass andResource: resourceType 	"Open to collect an existing class and a new or existing selector as 	the destination of a UI specification."	| dialog selList newSel results builder ctrl uid listBlock finder |	dialog := SimpleDialog new.	builder := dialog builder.	builder aspectAt: #clientClass put: (finder := ClassFinder new).	finder className value: (aClass isNil					ifTrue: [String new]					ifFalse: [aClass fullName]).	listBlock := [:cl | | list |			list := List new.			cl == nil				ifFalse: [cl class selectorsAndMethodsDo:						[:sel :meth |						meth resourceType = resourceType ifTrue: [list add: sel]]].			list sort.			list].	builder aspectAt: #existingSelectors		put: ((selList := SelectionInList new)				list: (listBlock value: aClass);				selection: nil asValue;				yourself).	finder className		compute: 			[:v | | cl |			cl := finder selectedClass.			cl isNil				ifTrue: 					[selList list: Array new.					(dialog builder componentAt: #clientClass) flash]				ifFalse: 					[selList list: (listBlock value: cl)]].	builder aspectAt: #newSelector put: (newSel := String new asValue).	builder aspectAt: #doAbort put: [dialog close].	dialog		postBuildBlock: 			[:sd :bldr | 			ctrl := (bldr componentAt: #SelectorSIL) widget controller.			uid := ctrl dispatcher copy.			uid doubleClick: [(results := self							resultsForClassName: finder selectedClassID							andSelectorList: selList							orSelectorNamed: newSel value							resource: resourceType) notNil					ifTrue: [dialog close]					ifFalse: [(dialog builder componentAt: (finder foundClass								ifFalse: [#clientClass]								ifTrue: [#SelectorSIL])) flash]].			ctrl setDispatcher: uid].	builder aspectAt: #doOK put: [(results := self					resultsForClassName: finder selectedClassID					andSelectorList: selList					orSelectorNamed: newSel value					resource: resourceType) notNil			ifTrue: [dialog close]			ifFalse: [(dialog builder componentAt: (finder foundClass						ifFalse: [#clientClass]						ifTrue: [#SelectorSIL])) flash]].	dialog openFrom: (self interfaceSpecFor: #sourceDialog).	^results</body><body package="UIPainter">openSourceDialogForResource: resourceType	"Open to collect an existing class and a new or existing selector as 	the 	destination of a UI specification."	| dialog selList newSel results builder ctrl uid finder |	dialog := SimpleDialog new.	builder := dialog builder.	builder aspectAt: #clientClass put: (finder := ClassFinder new).	builder aspectAt: #existingSelectors put: (selList := (SelectionInList new) list: List new; selection: nil asValue; yourself).	finder className		compute: 			[:v | | cl |			cl := finder selectedClass.			cl isNil				ifTrue: 					[selList list: Array new.					(dialog builder componentAt: #ClassNameField) flash]				ifFalse: 					[selList list: (self selectorsOfResource: resourceType in: cl class)]].	builder aspectAt: #newSelector put: (newSel := String new asValue).	builder aspectAt: #doAbort put: [dialog close].	dialog		postBuildBlock: 			[:sd :bldr | 			ctrl := (bldr componentAt: #SelectorSIL) widget controller.			uid := ctrl dispatcher copy.			uid doubleClick: [(results := self							resultsForClassName: finder selectedClassID							andSelectorList: selList							orSelectorNamed: newSel value							resource: resourceType) notNil					ifTrue: [dialog close]					ifFalse: [(dialog builder componentAt: (finder foundClass								ifFalse: [#ClassNameField]								ifTrue: [#SelectorSIL])) flash]].			ctrl setDispatcher: uid].	builder aspectAt: #doOK put: [(results := self					resultsForClassName: finder selectedClassID					andSelectorList: selList					orSelectorNamed: newSel value					resource: resourceType) notNil			ifTrue: [dialog close]			ifFalse: [(dialog builder componentAt: (finder foundClass						ifFalse: [#ClassNameField]						ifTrue: [#SelectorSIL])) flash]].	dialog openFrom: (self interfaceSpecFor: #sourceDialog).	^results</body></methods><methods><class-id>Tools.UIFinderVW2 class</class-id> <category>class initialization</category><body package="UIPainter">findEditorComment: src	| comm |	^(comm := (Parser new) parseMethodComment: src setPattern: [:x |]) isEmpty not		ifTrue:			[(#('UIPainter' 'MenuEditor' 'UIMaskEditor' 'QueryEditor' 'LensEditor') includes: (comm first copyUpTo: Character space)) or:				[comm first = (#GenKey98 &lt;&lt; #UIPainter &gt;&gt; 'Answer a literal array encoding of a data model.') ]]		ifFalse: [false]</body><body package="UIPainter">initialize 	"Initialize the class." 	"UIFinderVW2 initialize"  	self resetIcons.	RecentlyVisitedClasses isNil 		ifTrue: [RecentlyVisitedClasses := OrderedCollection new] 		ifFalse: [RecentlyVisitedClasses removeAllSuchThat: [:cl | true]]. 	self changed: #recentlyVisited with: (Array new: 2). 	self computeSpecBearingClasses. 	SelListMenuForNoSelection := (MenuBuilder new)										add: (#newCanvas &lt;&lt; #UIPainter &gt;&gt; 'new canvas') -&gt; #addCanvas;										add: (#newMenu &lt;&lt; #UIPainter &gt;&gt; 'new menu') -&gt; #addMenu;										add: (#newImage &lt;&lt; #UIPainter &gt;&gt; 'new image') -&gt; #addIcon;										add: (#newImageFromFile &lt;&lt; #UIPainter &gt;&gt; 'new Image From File') -&gt; #newImageFromFile;										add: (#newHotRegions &lt;&lt; #UIPainter &gt;&gt; 'new hot regions') -&gt; #addHotRegions;										add: (#newQuery &lt;&lt; #UIPainter &gt;&gt; 'new query') -&gt; #addQuery;										add: (#newDataModel &lt;&lt; #UIPainter &gt;&gt; 'new data model') -&gt; #addDataModel;										menu. 	SelListMenuWithSelection := (Menu new)										addItemLabel: (#newCanvas &lt;&lt; #UIPainter &gt;&gt; 'new canvas') value: #addCanvas;										addItemLabel: (#newMenu &lt;&lt; #UIPainter &gt;&gt; 'new menu') value: #addMenu;										addItemLabel: (#newImage &lt;&lt; #UIPainter &gt;&gt; 'new image') value: #addIcon;										addItemLabel: (#newImageFromFile &lt;&lt; #UIPainter &gt;&gt; 'new Image From File') value: #newImageFromFile;										addItemLabel: (#newHotRegions &lt;&lt; #UIPainter &gt;&gt; 'new hot regions') value: #addHotRegions;										addItemLabel: (#newQuery &lt;&lt; #UIPainter &gt;&gt; 'new query') value: #addQuery;										addItemLabel: (#newDataModel &lt;&lt; #UIPainter &gt;&gt; 'new data model') value: #addDataModel;										addItemGroupLabels: (Array with: (#edit &lt;&lt; #UIPainter &gt;&gt; 'edit') with: (#senders &lt;&lt; #UIPainter &gt;&gt; 'senders'))											values: #(#edit #browseSenders );										addItemGroupLabels: (Array with: (#remove &lt;&lt; #UIPainter &gt;&gt; 'remove...'))											values: #(#removeResource ).	"Initialize the system launchers."	#{VisualLauncher} isDefined		ifTrue: [#{VisualLauncher} value checkInstalledComponents]</body><body package="UIPainter">resetIcons	TypeIcons := Dictionary new.	TypeIcons at: #canvas		put: (OpaqueImage				figure: self CcanvasIcon 				shape: self MskCanvasIcon). 	TypeIcons at: #image		put: (OpaqueImage				figure: self CiconIcon 				shape:  self MskIconIcon). 	TypeIcons at: #menu		put: (OpaqueImage				figure:  self CMenuIcon 				shape:  self MskMenuIcon). 	TypeIcons at: #dataModel		put: (OpaqueImage				figure:  self CModelIcon 				shape:  self MskModelIcon). 	TypeIcons at: #query		put: (OpaqueImage				figure:  self CQueryIcon 				shape:  self MskQueryIcon).	TypeIcons at: #hotRegions		put: (OpaqueImage				figure: self CRegionsIcon				shape: self MskIconIcon).	TypeIcons at: #other put: self Cquestion.	self class selectors do: [:sel |		('reset#*Icons' match: sel)			ifTrue: [self perform: sel]].</body></methods><methods><class-id>Tools.UIFinderVW2 class</class-id> <category>deprecated</category><body package="UIPainter">openDestinationDialogForResource: resourceType defaultSelector: defaultSelector	^self		openDestinationDialogWithClass: nil		andSelector: defaultSelector		andResource: resourceType</body><body package="UIPainter">openDestinationDialogForResource: resourceType defaultSelector: defaultSelector creationData: ignored	"Open to collect an existing class and a new or existing selector as 	the destination for a static resource."	^self		openDestinationDialogWithClass: nil		andSelector: defaultSelector		andResource: resourceType</body><body package="UIPainter">openDestinationDialogWithClass: aClass andSelector: aSelector andResource: resourceType	"Open either to confirm the current destination class or collect some 	other existing class and a new or existing selector as the destination of a 	static resource."	self deprecated: #(#version '7.8' #see 'ResourceInstallationDialog').	^((ResourceInstallDialog new)		targetClass: aClass;		selector: aSelector;		resourceType: resourceType;		select)			ifNotNil: [:definition | Array with: definition implementingClass with: definition selector]</body><body package="UIPainter">openDestinationDialogWithClass: aClass andSelector: aSelector andResource: resourceType creationData: ignored	"Open either to confirm the current destination class or collect some 	other existing class and a new or existing selector as the destination of a 	static resource."	^self		openDestinationDialogWithClass: aClass		andSelector: aSelector		andResource: resourceType</body></methods><methods><class-id>Tools.ColorBitEditorTracker</class-id> <category>private</category><body package="UIPainter">trackSelectionFor: aPoint 	self controller colorPointAt: aPoint</body></methods><methods><class-id>Tools.PaintedDataSetController</class-id> <category>broadcast</category><body package="UIPainter">downcastEvent: aKey with: aParameter from: anInitiator 	"This is a message passed down the view structure to some single 	part. Answer true if we accepted the event, or false if it should be 	passed on to whatever's behind us."	aKey == #deselecting		ifTrue: [view editMode: false.				^true]. 	aKey == #usePersistentInformation		ifTrue: [view persistentInformation: aParameter value.				^true]. 	aKey == #returnPersistentInformation		ifTrue: [aParameter value: view persistentInformation. 				^true]. 	^super downcastEvent: aKey with: aParameter from: anInitiator</body></methods><methods><class-id>Tools.PaintedDataSetController</class-id> <category>event driven</category><body package="UIPainter">redButtonPressedEvent: anEvent 	| index localPoint tracker |	self selectEvent: anEvent.	index := view columnIndexFor: (localPoint := self view globalPointToLocal: anEvent point).	self view selectionIndex: index.	(self view dragHandleBounds containsPoint: localPoint)		ifTrue: 			[self view editorFocusOut.			tracker := ColumnReorderTracker on: (ColumnReorderAgent new controller: self).			tracker redButtonPressedEvent: anEvent]</body></methods><methods><class-id>Tools.VisualLauncher class</class-id> <category>generated resources</category><body package="UIPainter">finderIcon	^ToolbarIconLibrary visualFor: #resourceFinder</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>private</category><body package="UIPainter">isVisualStartable	"Used by UIFinder to divine that the application will respond to Start"	^self canUnderstand: #open</body></methods><methods><class-id>UI.ApplicationModel class</class-id> <category>private</category><body package="UIPainter">isVisualStartable	"Used by UIFinder to divine that the application will respond to Start"	^(self ~~ ApplicationModel and:		[(self class canUnderstand: #windowSpec) or:			[self class selectors includes: #open]])</body></methods><methods><class-id>UI.ApplicationModel</class-id> <category>WaveCompatibility</category><body package="UIPainter">setDropTargets	"Default is to do nothing"</body></methods><methods><class-id>UI.SimpleDialog class</class-id> <category>private</category><body package="UIPainter">isVisualStartable	"Disable the Start button in the Application Finder for this class."	^false</body></methods><methods><class-id>UI.UIEventCallbackSubSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel.	env at: #focusInSelector put: (self adapt: inst forAspect: #focusInSelector channel: aChannel).	env at: #focusOutSelector put: (self adapt: inst forAspect: #focusOutSelector channel: aChannel).	env at: #valueChangeSelector put: (self adapt: inst forAspect: #valueChangeSelector channel: aChannel).	env at: #doubleClickSelector put: (self adapt: inst forAspect: #doubleClickSelector channel: aChannel).	env at: #requestFocusInSelector put: (self adapt: inst forAspect: #requestFocusInSelector channel: aChannel).	env at: #requestFocusOutSelector put: (self adapt: inst forAspect: #requestFocusOutSelector channel: aChannel).	env at: #requestValueChangeSelector put: (self adapt: inst forAspect: #requestValueChangeSelector channel: aChannel).	env at: #requestDoubleClickSelector put: (self adapt: inst forAspect: #requestDoubleClickSelector channel: aChannel).</body></methods><methods><class-id>UI.RadioButtonSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel.	env at: #select put: (TypeConverter on: (self adapt: inst forAspect: #select channel: aChannel)) simpleLiteralToText.</body></methods><methods><class-id>UI.RadioButtonSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	| spec baseY y delta |	spec := self basicsEditSpecLiteral decodeAsLiteralArray.	delta := UIPainterTool labelConstructorSpecSize - 31.	spec component collection do:		[:sp |		(sp class == SubCanvasSpec and: [sp clientKey = #labelConstructor])			ifTrue:				[baseY := sp layout bottomOffset.				sp layout bottomOffset: baseY+delta]].	spec component collection do:		[:sp |		y := sp layout class == Point			ifTrue: [sp layout y]			ifFalse: [sp layout topOffset].		y &gt;= baseY			ifTrue:				[[sp layout y: sp layout y + delta]					on: Object errorSignal					do: [:ex | ex return].				[sp layout topOffset: sp layout topOffset + delta]					on: Object errorSignal					do: [:ex | ex return].				[sp layout bottomOffset: sp layout bottomOffset + delta]					on: Object errorSignal					do: [:ex | ex return]]].	^spec</body></methods><methods><class-id>UI.RadioButtonSpec class</class-id> <category>private-interface building</category><body package="UIPainter">componentName	"Identification of component"	^(#RadioButton &lt;&lt; #UIPainter &gt;&gt; 'Radio Button') asString</body></methods><methods><class-id>UI.RadioButtonSpec class</class-id> <category>property slices</category><body package="UIPainter">dropTargetSlice	"Empty means remove page!"	^#(80 #())</body></methods><methods><class-id>UI.RadioButtonSpec class</class-id> <category>private</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #radioButton</body></methods><methods><class-id>UI.RadioButtonSpec class</class-id> <category>private-interface building</category><body package="UIPainter">placementExtentBlock	^nil</body><body package="UIPainter">specGenerationBlock	^[:ctrlr :point |	| spec |	spec := RadioButtonSpec		model: nil		label: (#RadioButton &lt;&lt; #UIPainter &gt;&gt; 'Radio Button') asString		select: nil		layout: (ctrlr gridPoint: point).	spec assignNameFrom: ctrlr.	spec]</body></methods><methods><class-id>UI.RadioButtonSpec</class-id> <category>private</category><body package="UIPainter">colorSelections	^#(#foreground #background #selectedBackground)</body></methods><methods><class-id>UI.ComboBoxSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel 	super		addBindingsTo: env		for: inst		channel: aChannel.	env at: #comboList put: (self			adapt: inst			forAspect: #comboList			channel: aChannel).	env at: #readSelector put: (TypeConverter onSymbolValue: (self				adapt: inst				forAspect: #readSelector				channel: aChannel)).	env at: #printSelector put: (TypeConverter onSymbolValue: (self				adapt: inst				forAspect: #printSelector				channel: aChannel))</body><body package="UIPainter">componentName	"Identification of component"	^(#ComboBox &lt;&lt; #UIPainter &gt;&gt; 'Combo Box') asString</body></methods><methods><class-id>UI.ComboBoxSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #comboBoxWidget</body></methods><methods><class-id>UI.ComboBoxSpec class</class-id> <category>property slices</category><body package="UIPainter">notificationSlice	^#(35 #(#(#{Kernel.UserMessage} #key: #Notification #defaultString: 'Notification' #catalogID: #UIPainter) #notificationEditSpec nil #callbacks))</body><body package="UIPainter">validationSlice	^#(30 #(#(#{Kernel.UserMessage} #key: #Validation #defaultString: 'Validation' #catalogID: #UIPainter) #validationEditSpec nil #callbacks))</body></methods><methods><class-id>UI.ComboBoxSpec</class-id> <category>private</category><body package="UIPainter">checkFormatStringWithBindings: env 	super checkFormatStringWithBindings: env.	type == #object		ifTrue: 			[((env at: #propertiesTool) subBuilder componentAt: #printSelectorLabel) enable.			((env at: #propertiesTool) subBuilder componentAt: #printSelector) enable.			((env at: #propertiesTool) subBuilder componentAt: #readSelectorLabel) enable.			((env at: #propertiesTool) subBuilder componentAt: #readSelector) enable]		ifFalse: 			[((env at: #propertiesTool) subBuilder componentAt: #printSelectorLabel) disable.			((env at: #propertiesTool) subBuilder componentAt: #printSelector) disable.			((env at: #propertiesTool) subBuilder componentAt: #readSelectorLabel) disable.			((env at: #propertiesTool) subBuilder componentAt: #readSelector) disable.			(env at: #readSelector)				value: String new.			(env at: #printSelector)				value: String new]</body><body package="UIPainter">models	^Set with: self model with: self comboList</body></methods><methods><class-id>UI.ComboBoxSpec</class-id> <category>accessing</category><body package="UIPainter">printSelector	^printSelector</body><body package="UIPainter">readSelector	^readSelector</body></methods><methods><class-id>UI.ButtonSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	"You might think it would be nice if the prepending # sign were 	removed when switching back to a non-image oriented label -- or 	you might not, since the name of an image can hardly ever be a 	decent literal label. In any case, the attempt to do so would break 	UIPropertiesTool, which would run the block even when simply 	initializing over a new label -- hence remote labels would not show 	up as symbols."	| lblAdptr lblCnvrtr hasImage lblMode |	super addBindingsTo: env for: inst channel: aChannel.	lblAdptr := (self adapt: inst forAspect: #label channel: aChannel).	env at: #label put: (lblCnvrtr :=		(inst hasImageOrientedLabel			ifTrue: [TypeConverter onSymbolValue: lblAdptr]			ifFalse: [TypeConverter onStringOrSymbolValue: lblAdptr])).	env at: #labelFromApplication put: (self adapt: inst forAspect: #labelFromApplication channel: aChannel).	env at: #labelIsMessage put: (lblMode := inst label isSymbol asValue).	inst label isSymbol ifTrue: [(env at: #labelFromApplication) value: true].	env at: #style put: (self adapt: inst forAspect: #style channel: aChannel).	env at: #hasImageOrientedLabel put:		(hasImage := self adapt: inst forAspect: #hasImageOrientedLabel channel: aChannel).	env at: #isDecorated put: (self adapt: inst forAspect: #isDecorated channel: aChannel).	env at: #fontMenu put: self fontMenu.	hasImage		compute: 			[:v |			v				ifTrue: [lblCnvrtr symbolToText]				ifFalse: [lblCnvrtr stringOrSymbolToText].			v				ifTrue: [lblMode value: true]				ifFalse: [lblMode value: inst label isSymbol].			(env at: #propertiesTool) update: #updateLabelIsImage with: nil from: nil.			(lblAdptr value notNil and: [lblAdptr value asString isEmpty not]) ifTrue: 				[lblAdptr changed: #value]]</body></methods><methods><class-id>UI.ButtonSpec class</class-id> <category>property slices</category><body package="UIPainter">flyByHelpSlice	^#(25 #(#(#{Kernel.UserMessage} #key: #FlyByHelp #defaultString: 'Fly-by Help' #catalogID: #UIPainter) #helpConstructorSpec))</body></methods><methods><class-id>UI.ButtonSpec</class-id> <category>accessing</category><body package="UIPainter">canHaveLabel	^true</body><body package="UIPainter">hasInherentSize	^true</body></methods><methods><class-id>UI.RegionSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	| adp  bs |	super addBindingsTo: env for: inst channel: aChannel.	env at: #regionType put: (self adapt: inst forAspect: #regionType channel: aChannel).	env at: #lineWidth put: (adp := self adapt: inst forAspect: #lineWidth channel: aChannel).	bs := PluggableAdaptor on: adp.	bs 		getBlock: [:m | self symbolForWidth: m value]		putBlock: [:m :v | m value: (self widthForSymbol: v)]		updateBlock: [:m :a :p | a == #value].	env at: #borderStyle put: bs</body><body package="UIPainter">componentName	"Identification of component"	^(#Region &lt;&lt; #UIPainter &gt;&gt; 'Region') asString</body></methods><methods><class-id>UI.RegionSpec class</class-id> <category>property slices</category><body package="UIPainter">detailsSlice	"Empty means NO PAGE!"	^#(1 #())</body></methods><methods><class-id>UI.RegionSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #regionWidget</body></methods><methods><class-id>UI.RegionSpec class</class-id> <category>private-interface building</category><body package="UIPainter">placementExtentBlock	^[:bldr | 50 @ 50]</body><body package="UIPainter">specGenerationBlock	^[:ctrlr :point | 	| spec |	spec := RegionSpec new		layout: ((ctrlr gridPoint: point)			extent: (ctrlr currentMode value class placementExtentFor: RegionSpec inBuilder: ctrlr builder));		lineWidth: 1.	spec assignNameFrom: ctrlr.	spec]</body></methods><methods><class-id>UI.RegionSpec</class-id> <category>private</category><body package="UIPainter">colorSelections	^#(#foreground #background)</body></methods><methods><class-id>UI.SubCanvasSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	| finder model |	super addBindingsTo: env for: inst channel: aChannel.	finder := EntryWithPasteButtonModule forClasses.	model := self adapt: inst forAspect: #majorKey channel: aChannel.	finder entryHolder compute:		[:val | | id |		id := finder value trimBlanks asQualifiedReference.		(id isDefined and:[id binding isForClass]) ifFalse:[id := nil].		id = model value			ifFalse: [model value: id]].	model compute:		[:val | finder value: (val == nil ifTrue: [''] ifFalse: [val asString])].	model changed: #value.	env at: #majorKey put: finder.	env at: #minorKey put: (TypeConverter onSymbolValue: (self adapt: inst forAspect: #minorKey channel: aChannel)).	env at: #clientKey put: (TypeConverter onSymbolValue: (self adapt: inst forAspect: #clientKey channel: aChannel)).</body><body package="UIPainter">componentName	"Identification of component"	^(#Subcanvas &lt;&lt; #UIPainter &gt;&gt; 'Subcanvas') asString</body></methods><methods><class-id>UI.SubCanvasSpec class</class-id> <category>property slices</category><body package="UIPainter">dropTargetSlice	^#(80 #(#(#{Kernel.UserMessage} #key: #DropTarget #defaultString: 'Drop Target' #catalogID: #UIPainter) #dropTargetSpec))</body></methods><methods><class-id>UI.SubCanvasSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #subCanvasWidget</body></methods><methods><class-id>UI.SubCanvasSpec</class-id> <category>private</category><body package="UIPainter">models	^Set with: self clientKey</body></methods><methods><class-id>UI.DocumentEditorSpec class</class-id> <category>private-interface building</category><body package="UIPainter">componentName	"Identification of component"	^(#DocumentEditor &lt;&lt; #UIPainter &gt;&gt; 'Document Editor') asString</body></methods><methods><class-id>UI.DocumentEditorSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #documentEditorWidget</body></methods><methods><class-id>UI.ResizingSplitterSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel 	super 		addBindingsTo: env		for: inst		channel: aChannel.	env at: #isDecorated put: (self adapt: inst forAspect: #isDecorated channel: aChannel).	env at: #horizontal		put: (self 				adapt: inst				forAspect: #horizontal				channel: aChannel).	(env at: #horizontal) compute: [(env at: #propertiesTool) updateResizerLabels: inst].	env at: #minAboveSize		put: (self 				adapt: inst				forAspect: #minAboveSize				channel: aChannel).	env at: #minBelowSize		put: (self 				adapt: inst				forAspect: #minBelowSize				channel: aChannel).	env at: #aboveWidgets		put: (self 				adapt: inst				forAspect: #aboveWidgets				channel: aChannel).	env at: #belowWidgets		put: (self 				adapt: inst				forAspect: #belowWidgets				channel: aChannel)</body><body package="UIPainter">componentName	^(#ResizingSplitter &lt;&lt; #UIPainter &gt;&gt; 'Resizing Splitter') asString</body></methods><methods><class-id>UI.ResizingSplitterSpec class</class-id> <category>property slices</category><body package="UIPainter">detailsSlice	"Empty means no page"	^#(1 #())</body><body package="UIPainter">dropTargetSlice	"Empty means no page"	^#(1 #())</body></methods><methods><class-id>UI.ResizingSplitterSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #resizingSplitterWidget</body></methods><methods><class-id>UI.ResizingSplitterSpec class</class-id> <category>property slices</category><body package="UIPainter">notificationSlice	"Empty means no page"	^#(1 #())</body></methods><methods><class-id>UI.ResizingSplitterSpec class</class-id> <category>private-interface building</category><body package="UIPainter">placementExtentBlock	^[:bldr |	(bldr window width / 2) min: (bldr window height / 2) @  4]</body><body package="UIPainter">specGenerationBlock	^[:ctrlr :point |	| spec |	spec := self layout:				((ctrlr gridPoint: point)					extent: (ctrlr currentMode value class placementExtentFor: self inBuilder: ctrlr builder)).	spec hasBorder: true.	(spec respondsTo: #name) ifTrue: [spec assignNameFrom: ctrlr].	spec]</body></methods><methods><class-id>UI.ResizingSplitterSpec class</class-id> <category>property slices</category><body package="UIPainter">validationSlice	"Empty means no page"	^#(1 #())</body></methods><methods><class-id>UI.ResizingSplitterSpec</class-id> <category>private</category><body package="UIPainter">colorSelections	^#(#background)</body><body package="UIPainter">shouldCompareLayouts: newSpec	^horizontal = newSpec horizontal</body></methods><methods><class-id>UI.HotRegions</class-id> <category>edit support</category><body package="UIPainter">acceptSlice: aHotSlice	| tempPixel |	regionsSelectors at: aHotSlice index put: aHotSlice selector.	aHotSlice mask pixelsDo: [ :x :y |		(((tempPixel := aHotSlice mask atX: x y: y) ~= 0) or: [( regionsImage atX: x y: y ) = aHotSlice index])			ifTrue: [regionsImage atX: x y: y put: tempPixel * aHotSlice index].	].</body><body package="UIPainter">adoptExtent: anExtentPoint	| oldImage |	regionsImage isNil ifTrue: [		regionsImage := Image extent: anExtentPoint depth: 1 palette: (CoveragePalette maxPixelValue: 1).		self initSelectorArray. 		^self. 	].	regionsImage extent = anExtentPoint ifTrue: [^self].	oldImage := regionsImage. 	regionsImage := Image extent: anExtentPoint depth: oldImage depth palette: oldImage palette.	regionsImage copy:( 0@0 extent: (oldImage extent)) from: 0@0 in: oldImage rule: RasterOp over.</body><body package="UIPainter">allSlices	| list |	list := List new.	(1 to: regionsSelectors size) do: [ :i | (regionsSelectors at: i) notNil ifTrue: [ list add: (self createSliceForIndex: i)]].	^list.</body><body package="UIPainter">compositeOfAllSlices	^regionsImage convertToCoverageWithTransparentPixel: 0.</body><body package="UIPainter">createSliceForIndex: anIndex	| slice |	slice := HotSlice new.	slice index: anIndex.	slice selector: (regionsSelectors at: anIndex).	slice mask: nil.	slice parentRegions: self. 	^slice.</body><body package="UIPainter">deleteSliceAtIndex: anIndex	regionsSelectors at: anIndex  put: nil.	regionsImage pixelsDo: [ :x :y |		( regionsImage atX: x y: y ) = anIndex			ifTrue: [regionsImage atX: x y: y put: 0].	].</body><body package="UIPainter">maskForIndex: anIndex	^(regionsImage convertToCoverageWithOpaquePixel: anIndex)</body><body package="UIPainter">newSlice	| slice |	slice := (self createSliceForIndex: (self emptyIndex)).	slice selector: #tbd.	regionsSelectors at: slice index put: slice selector. 	^slice.</body></methods><methods><class-id>UI.SpecCollection</class-id> <category>accessing</category><body package="UIPainter">extractFromCollection: aCollection	collection := Array new: aCollection size.	1 to: aCollection size do:		[:i |		collection at: i put: (aCollection at: i) extractedSpec]</body><body package="UIPainter">fromCollection: aCollection	collection := Array new: aCollection size.	1 to: aCollection size do:		[:i |		collection at: i put: (aCollection at: i) savableSpec]</body></methods><methods><class-id>UI.ActionButtonSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel.	env at: #isDefault put: (self adapt: inst forAspect: #isDefault channel: aChannel).	env at: #defaultable put: (self adapt: inst forAspect: #defaultable channel: aChannel).	env at: #legacyButtonLayout put: (self adapt: inst forAspect: #legacyButtonLayout channel: aChannel).</body></methods><methods><class-id>UI.ActionButtonSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	| spec baseY y delta |	spec := self basicsEditSpecLiteral decodeAsLiteralArray.	delta := UIPainterTool labelConstructorSpecSize - 31.	spec component collection do:		[:sp |		(sp class == SubCanvasSpec and: [sp clientKey = #labelConstructor])			ifTrue:				[baseY := sp layout bottomOffset.				sp layout bottomOffset: baseY+delta]].	spec component collection do:		[:sp |		y := sp layout class == Point			ifTrue: [sp layout y]			ifFalse: [sp layout topOffset].		y &gt;= baseY			ifTrue:				[[sp layout y: sp layout y + delta]					on: Object errorSignal					do: [:ex | ex return].				[sp layout topOffset: sp layout topOffset + delta]					on: Object errorSignal					do: [:ex | ex return].				[sp layout bottomOffset: sp layout bottomOffset + delta]					on: Object errorSignal					do: [:ex | ex return]]].	^spec</body></methods><methods><class-id>UI.ActionButtonSpec class</class-id> <category>private-interface building</category><body package="UIPainter">componentName	"Identification of component"	^(#ActionButton &lt;&lt; #UIPainter &gt;&gt; 'Action Button') asString</body></methods><methods><class-id>UI.ActionButtonSpec class</class-id> <category>private</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #actionButtonWidget</body></methods><methods><class-id>UI.ActionButtonSpec class</class-id> <category>private-interface building</category><body package="UIPainter">placementExtentBlock	^[:lab :bldr |	(bldr policy measureActionButtonLabel: lab) extent x @		bldr policy defaultableActionButtonHeight]</body><body package="UIPainter">specGenerationBlock	| class |	class := self specGenerationClass.		^[:ctrlr :point | 	| label spec |	spec := class		model: nil		label: (label := (#Action &lt;&lt; #UIPainter &gt;&gt; 'Action') asString)		layout: ((ctrlr gridPoint: point)			extent:				(ctrlr currentMode value class					placementExtentFor: class					withLabel: label					inBuilder: ctrlr builder))		properties: #(#canDefault ).	spec assignNameFrom: ctrlr.	spec]</body><body package="UIPainter">specGenerationClass	^ActionButtonSpec</body></methods><methods><class-id>UI.SequenceViewSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel.	env at: #multipleSelections put: (self adapt: inst forAspect: #multipleSelections channel: aChannel).	env at: #selectionType put: (self adapt: inst forAspect: #selectionType channel: aChannel).	env at: #useModifierKeys put: (self adapt: inst forAspect: #useModifierKeys channel: aChannel).	env at: #selectOnDownIfDragEnabled put: (self adapt: inst forAspect: #selectOnDownIfDragEnabled channel: aChannel).	env at: #style put: (self adapt: inst forAspect: #style channel: aChannel).	env at: #fontMenu put: self fontMenu.	env at: #autoSelect put: (self adapt: inst forAspect: #autoSelect channel: aChannel).	env at: #selectionTypeMenu put: self selectionTypeMenu</body><body package="UIPainter">componentName	"Identification of component"	^(#List &lt;&lt; #UIPainter &gt;&gt; 'List') asString</body></methods><methods><class-id>UI.SequenceViewSpec class</class-id> <category>property slices</category><body package="UIPainter">dragSourceSlice	^#(65 (#(#{Kernel.UserMessage} #key: #DragSource #defaultString: 'Drag Source' #catalogID: #UIPainter) #dropSourceSpec))</body><body package="UIPainter">flyByHelpSlice	^#(25 #(#(#{Kernel.UserMessage} #key: #FlyByHelp #defaultString: 'Fly-by Help' #catalogID: #UIPainter) helpConstructorSpec))</body></methods><methods><class-id>UI.SequenceViewSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #sequenceViewWidget</body></methods><methods><class-id>UI.SequenceViewSpec class</class-id> <category>property slices</category><body package="UIPainter">notificationSlice	^#(35 #(#(#{Kernel.UserMessage} #key: #Notification #defaultString: 'Notification' #catalogID: #UIPainter) #notificationDCEditSpec nil #callbacks))</body></methods><methods><class-id>UI.SequenceViewSpec class</class-id> <category>private-interface building</category><body package="UIPainter">specGenerationBlock	^[:ctrlr :point | 	| spec |	spec := self layout:			((ctrlr gridPoint: point)				extent: (ctrlr currentMode value class placementExtentFor: self inBuilder: ctrlr builder)).	"new specs should not use check marks and should use &lt;shift&gt; and &lt;ctrl&gt; modifiers for multiselection."	spec selectionType: #highlight.	spec useModifierKeys: true.	spec assignNameFrom: ctrlr.	spec]</body></methods><methods><class-id>UI.SequenceViewSpec class</class-id> <category>property slices</category><body package="UIPainter">validationSlice	^#(30 #(#(#{Kernel.UserMessage} #key: #Validation #defaultString: 'Validation' #catalogID: #UIPainter) #validationDCEditSpec nil #callbacks))</body></methods><methods><class-id>UI.WindowSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	| lblAdptr |	super addBindingsTo: env for: inst channel: aChannel.	env at: #hasBorder put: (self adapt: inst forAspect: #hasBorder channel: aChannel).	env at: #hasHorizontalScrollBar put: (self adapt: inst forAspect: #hasHorizontalScrollBar channel: aChannel).	env at: #hasMenuBar put: (self adapt: inst forAspect: #hasMenuBar channel: aChannel).	env at: #hasVerticalScrollBar put: (self adapt: inst forAspect: #hasVerticalScrollBar channel: aChannel).	env at: #menu put: (self adapt: inst forAspect: #menu channel: aChannel).	env at: #toolBar put: (self adapt: inst forAspect: #toolBar channel: aChannel).	env at: #performer put:  (TypeConverter onSymbolValue: (self adapt: inst forAspect: #performer channel: aChannel)).	env at: #dragEnterSelector put: (TypeConverter onSymbolValue: (self adapt: inst forAspect: #dragEnterSelector channel: aChannel)).	env at: #dragOverSelector put: (TypeConverter onSymbolValue: (self adapt: inst forAspect: #dragOverSelector channel: aChannel)).	env at: #dragExitSelector put: (TypeConverter onSymbolValue: (self adapt: inst forAspect: #dragExitSelector channel: aChannel)).	env at: #dropSelector put: (TypeConverter onSymbolValue: (self adapt: inst forAspect: #dropSelector channel: aChannel)).	env at: #openType put: (self adapt: inst forAspect: #openType channel: aChannel).	"Add label stuff"	lblAdptr := (self adapt: inst forAspect: #label channel: aChannel).	env at: #label put: (TypeConverter onStringOrSymbolValue: lblAdptr).	env at: #labelIsMessage put: inst label isSymbol asValue.	env at: #labelFromApplication put: (self adapt: inst forAspect: #labelFromApplication channel: aChannel).	inst label isSymbol ifTrue: [(env at: #labelFromApplication) value: true].</body></methods><methods><class-id>UI.WindowSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	| spec baseY y delta |	spec := self basicsEditSpecLiteral decodeAsLiteralArray.	delta := UIPainterTool labelConstructorSpecSize - 38.	spec component collection do:		[:sp |		(sp class == SubCanvasSpec and: [sp clientKey = #labelConstructor])			ifTrue:				[baseY := sp layout bottomOffset.				sp layout bottomOffset: baseY+delta]].	spec component collection do:		[:sp |		y := sp layout class == Point			ifTrue: [sp layout y]			ifFalse: [sp layout topOffset].		y &gt;= baseY			ifTrue:				[[sp layout y: sp layout y + delta]					on: Object errorSignal					do: [:ex | ex return].				[sp layout topOffset: sp layout topOffset + delta]					on: Object errorSignal					do: [:ex | ex return].				[sp layout bottomOffset: sp layout bottomOffset + delta]					on: Object errorSignal					do: [:ex | ex return]]].	^spec</body></methods><methods><class-id>UI.WindowSpec class</class-id> <category>private-interface building</category><body package="UIPainter">componentName	"Identification of component"	^(#Window &lt;&lt; #UIPainter &gt;&gt; 'Window') asString</body></methods><methods><class-id>UI.WindowSpec class</class-id> <category>property slices</category><body package="UIPainter">dropTargetSlice	^#(80 #(#(#{Kernel.UserMessage} #key: #DropTarget #defaultString: 'Drop Target' #catalogID: #UIPainter) #dropTargetSpec))</body></methods><methods><class-id>UI.WindowSpec class</class-id> <category>private</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #canvasWidget</body></methods><methods><class-id>UI.WindowSpec class</class-id> <category>property slices</category><body package="UIPainter">positionSlice	^#(21 #(#(#{Kernel.UserMessage} #key: #PositionSize #defaultString: 'Position/Size' #catalogID: #UIPainter) #windowSpec #WindowOpenPositionToolModel))</body></methods><methods><class-id>UI.WindowSpec</class-id> <category>private</category><body package="UIPainter">canHaveMenu	^true</body><body package="UIPainter">painterName	^((#MainWindow1s &lt;&lt; #UIPainter &gt;&gt; 'Main Window : &lt;1s&gt;')			expandMacrosWith: label asString) asString</body></methods><methods><class-id>UI.GroupBoxSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	"You might think it would be nice if the prepending # sign were 	removed when switching back to a non-image oriented label -- or 	you might not, since the name of an image can hardly ever be a 	decent literal label. In any case, the attempt to do so would break 	UIPropertiesTool, which would run the block even when simply 	initializing over a new label -- hence remote labels would not show 	up as symbols."	| lblAdptr lblCnvrtr hasImage lblMode |	super addBindingsTo: env for: inst channel: aChannel.	lblAdptr := (self adapt: inst forAspect: #label channel: aChannel).	env at: #label put: (lblCnvrtr :=		(inst hasImageOrientedLabel			ifTrue: [TypeConverter onSymbolValue: lblAdptr]			ifFalse: [TypeConverter onStringOrSymbolValue: lblAdptr])).	env at: #labelFromApplication put: (self adapt: inst forAspect: #labelFromApplication channel: aChannel).	env at: #labelIsMessage put: (lblMode := inst label isSymbol asValue).	inst label isSymbol ifTrue: [(env at: #labelFromApplication) value: true].	env at: #style put: (self adapt: inst forAspect: #style channel: aChannel).	env at: #hasImageOrientedLabel put:		(hasImage := self adapt: inst forAspect: #hasImageOrientedLabel channel: aChannel).	env at: #fontMenu put: self fontMenu.	env at: #mnemonic put: (self adapt: inst forAspect: #mnemonic channel: aChannel).	hasImage		compute: 			[:v |			v				ifTrue: [lblCnvrtr symbolToText]				ifFalse: [lblCnvrtr stringOrSymbolToText].			v				ifTrue: [lblMode value: true]				ifFalse: [lblMode value: inst label isSymbol].			(env at: #propertiesTool) update: #updateLabelIsImage with: nil from: nil.			(lblAdptr value notNil and: [lblAdptr value asString isEmpty not]) ifTrue: 				[lblAdptr changed: #value]]</body></methods><methods><class-id>UI.GroupBoxSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	| spec baseY y delta |	spec := self basicsEditSpecLiteral decodeAsLiteralArray.	delta := UIPainterTool labelConstructorSpecSize - 31.	spec component collection do:		[:sp |		(sp class == SubCanvasSpec and: [sp clientKey = #labelConstructor])			ifTrue:				[baseY := sp layout bottomOffset.				sp layout bottomOffset: baseY+delta]].	spec component collection do:		[:sp |		y := sp layout class == Point			ifTrue: [sp layout y]			ifFalse: [sp layout topOffset].		y &gt;= baseY			ifTrue:				[[sp layout y: sp layout y + delta]					on: Object errorSignal					do: [:ex | ex return].				[sp layout topOffset: sp layout topOffset + delta]					on: Object errorSignal					do: [:ex | ex return].				[sp layout bottomOffset: sp layout bottomOffset + delta]					on: Object errorSignal					do: [:ex | ex return]]].	^spec</body></methods><methods><class-id>UI.GroupBoxSpec class</class-id> <category>private-interface building</category><body package="UIPainter">componentName	"Identification of component"	^(#GroupBox &lt;&lt; #UIPainter &gt;&gt; 'Group Box') asString</body></methods><methods><class-id>UI.GroupBoxSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #groupBoxWidget</body></methods><methods><class-id>UI.GroupBoxSpec</class-id> <category>accessing</category><body package="UIPainter">canHaveLabel	^true</body></methods><methods><class-id>UI.GroupBoxSpec</class-id> <category>private</category><body package="UIPainter">colorSelections	^#(#foreground #background)</body></methods><methods><class-id>UI.DataSetSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel 	| ra |	super		addBindingsTo: env		for: inst		channel: aChannel.	env at: #multipleSelections put: (self adapt: inst forAspect: #multipleSelections channel: aChannel).	env at: #labelsAsButtons put: (self adapt: inst forAspect: #labelsAsButtons channel: aChannel).	env at: #rowLabelsAsButtons put: (self adapt: inst forAspect: #rowLabelsAsButtons channel: aChannel).	env at: #showHorizontalLines put: (self adapt: inst forAspect: #showHorizontalLines channel: aChannel).	env at: #showVerticalLines put: (self adapt: inst forAspect: #showVerticalLines channel: aChannel).	env at: #showLineNumbers put: (self adapt: inst forAspect: #showLineNumbers channel: aChannel).	env at: #allowSorting put: (self adapt: inst forAspect: #allowSorting channel: aChannel).	env at: #allowColumnResizing put: (self adapt: inst forAspect: #allowColumnResizing channel: aChannel).	env at: #allowColumnReordering put: (self adapt: inst forAspect: #allowColumnReordering channel: aChannel).	env at: #columns put: (TypeConverter onSymbolValue: (self				adapt: inst				forAspect: #columns				channel: aChannel)).	env at: #rowIndicator put: (self			adapt: inst			forAspect: #rowIndicator			channel: aChannel).	env at: #horizontalPolicy put: (self			adapt: inst			forAspect: #horizontalPolicy			channel: aChannel).	env at: #verticalPolicy put: (self			adapt: inst			forAspect: #verticalPolicy			channel: aChannel).	env at: #rowSize put: (self			adapt: inst			forAspect: #rowSize			channel: aChannel).	ra := DSVDependencyAgent new bindings: env.	ra spec: inst.	ra notificationAspects: (Array new: 3).	ra validationAspects: (Array new: 3).	env at: #addColumn put: [(env at: #propertiesTool) invalidateCurrentSelection. inst addColumnFrom: (env at: #propertiesTool)].	env at: #deleteColumn put: [ra deleteColumn].	env at: #dsvSelectionChannel put: ((env at: #propertiesTool) selection at: 1) widget selectionChannel. 	env at: #releasingAgent put: ra.	(env at: #dsvSelectionChannel) onChangeSend: #validateComponents to: ra.	ra validateComponents.</body></methods><methods><class-id>UI.DataSetSpec class</class-id> <category>property slices</category><body package="UIPainter">columnSlice		^#(30 #(#(#{Kernel.UserMessage} #key: #Column #defaultString: 'Column' #catalogID: #UIPainter) #columnEditSpec #DataSetSpecColumnModel #dsv))</body><body package="UIPainter">columnTypeSlice	^#(32 #(#(#{Kernel.UserMessage} #key: #ColumnType #defaultString: 'Column Type' #catalogID: #UIPainter) #columnDetailsEditSpec #DataSetSpecColumnDetailsModel #dsv))</body></methods><methods><class-id>UI.DataSetSpec class</class-id> <category>private-interface building</category><body package="UIPainter">componentName	"Identification of component"	^(#Dataset &lt;&lt; #UIPainter &gt;&gt; 'Dataset') asString</body></methods><methods><class-id>UI.DataSetSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #dataSetWidget</body></methods><methods><class-id>UI.DataSetSpec class</class-id> <category>property slices</category><body package="UIPainter">notificationSlice	^#(36 #(#(#{Kernel.UserMessage} #key: #Notification #defaultString: 'Notification' #catalogID: #UIPainter) #notificationDCEditSpec #DataSetCallbacksSpecModel))</body><body package="UIPainter">traversalSlice	^#(25 #(#(#{Kernel.UserMessage} #key: #Traversal #defaultString: 'Traversal' #catalogID: #UIPainter) #navigationEditSpec))</body><body package="UIPainter">validationSlice	^#(34 #(#(#{Kernel.UserMessage} #key: #Validation #defaultString: 'Validation' #catalogID: #UIPainter) #validationDCEditSpec #DataSetCallbacksSpecModel))</body></methods><methods><class-id>UI.DataSetSpec</class-id> <category>private-UIDefiner</category><body package="UIPainter">privateAspectModel	^self multipleSelections		ifTrue: 			[self labelsAsButtons				ifTrue: [MultiSelectionInListSortAware]				ifFalse: [MultiSelectionInList]]		ifFalse: 			[self labelsAsButtons				ifTrue: [SelectionInListSortAware]				ifFalse: [SelectionInList]]</body><body package="UIPainter">privateAspectSelectionString	^self multipleSelections		ifTrue: ['selections first]']		ifFalse: ['selection']</body><body package="UIPainter">privateConditionStringFor: aDsvSlot	"aDSVSlot is an &lt;Association&gt; used in UIDefiner"	| strm |	self multipleSelections ifFalse: [^String new].	strm := WriteStream on: (String new: 20).	strm nextPutAll: aDsvSlot key, ' selections isEmpty ifFalse: ['.	strm cr; tab; tab; tab; tab; tab.	^strm contents</body><body package="UIPainter">resetColumnButtonsAsLabelsAttributes	"reset the columnSpecs labelsAsButtons, dataModelSpec 	striclty for use by UIDefiner"	"if this is not done, then literalArrayEncoding breaks"	self labelsAsButtons		ifTrue: [self columns 				do: [:dsc | 						dsc labelsAsButtons: nil.						dsc dataSetSpec: nil]]</body><body package="UIPainter">setColumnButtonsAsLabelsAttributes	"reset the columnSpecs labelsAsButtons, dataModelSpec 	striclty for use by UIDefiner"	self labelsAsButtons		ifTrue: [self columns 				do: [:dsc | 						dsc labelsAsButtons: true.						dsc dataSetSpec: self]]</body></methods><methods><class-id>UI.DataSetSpec</class-id> <category>private</category><body package="UIPainter">specDo: anEnumerator	^anEnumerator doDataSetSpec: self</body></methods><methods><class-id>UI.TabControlSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel 	| editor |	super		addBindingsTo: env		for: inst		channel: aChannel.	editor := SimpleListEditor new.	editor list listHolder: (self			adapt: inst			forAspect: #labels			channel: aChannel).	editor changedBlock: [(env at: #propertiesTool) displayButtonsForModifiedState].	env at: #labelsModel put: editor.	env at: #style put: (self			adapt: inst			forAspect: #style			channel: aChannel).	env at: #fontMenu put: self fontMenu</body><body package="UIPainter">componentName	^(#TabControl &lt;&lt; #UIPainter &gt;&gt; 'TabControl') asString</body></methods><methods><class-id>UI.TabControlSpec class</class-id> <category>property slices</category><body package="UIPainter">dropTargetSlice	"Empty array means no page!"	^#(1 #())</body></methods><methods><class-id>UI.TabControlSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #tabControlWidget</body></methods><methods><class-id>UI.SpinButtonSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel  	super 		addBindingsTo: env 		for: inst 		channel: aChannel. 	env at: #comboList put: (self 			adapt: inst 			forAspect: #comboList 			channel: aChannel). 	env at: #readSelector put: (TypeConverter onSymbolValue: (self 				adapt: inst 				forAspect: #readSelector 				channel: aChannel)). 	env at: #printSelector put: (TypeConverter onSymbolValue: (self 				adapt: inst 				forAspect: #printSelector 				channel: aChannel)). 	env at: #low put: (TypeConverter on: (self adapt: inst forAspect: #low channel: aChannel)) numberOrNil. 	env at: #lowDate put: (TypeConverter onDateValue: (self adapt: inst forAspect: #lowDate channel: aChannel)). 	env at: #lowTime put: (TypeConverter onTimeValue: (self adapt: inst forAspect: #lowTime channel: aChannel)). 	env at: #lowTimestamp put: (TypeConverter onTimestampValue: (self adapt: inst forAspect: #lowTimestamp channel: aChannel)).  	env at: #high put: (TypeConverter on: (self adapt: inst forAspect: #high channel: aChannel)) numberOrNil. 	env at: #highDate put: (TypeConverter onDateValue: (self adapt: inst forAspect: #highDate channel: aChannel)). 	env at: #highTime put: (TypeConverter onTimeValue: (self adapt: inst forAspect: #highTime channel: aChannel)). 	env at: #highTimestamp put: (TypeConverter onTimestampValue: (self adapt: inst forAspect: #highTimestamp channel: aChannel)).  	env at: #interval put: (TypeConverter onNumberValue: (self adapt: inst forAspect: #interval channel: aChannel)). 	env at: #isWrapAround put:  (self adapt: inst forAspect: #isWrapAround channel: aChannel).</body><body package="UIPainter">componentName	"Identification of component"	^(#SpinButton &lt;&lt; #UIPainter &gt;&gt; 'Spin Button') asString</body></methods><methods><class-id>UI.SpinButtonSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #spinButtonWidget</body></methods><methods><class-id>UI.SpinButtonSpec class</class-id> <category>private-interface building</category><body package="UIPainter">typeMenu	"Answer a menu used to describe the various types support by input fields. Selecting a menu item will answer a Symbol that indicates the type."	| mb |	mb := MenuBuilder new.	mb add: 'String'-&gt;#string.	mb add: 'Symbol'-&gt;#symbol.	mb add: 'Text'-&gt;#text.	mb add: 'Number'-&gt;#number.	mb add: 'Date'-&gt;#date.	mb add: 'Time'-&gt;#time.	mb add: 'Timestamp'-&gt;#timestamp.	mb add: 'FixedPoint(2)'-&gt;#fixedpoint.	^mb menuHolder</body></methods><methods><class-id>UI.SpinButtonSpec</class-id> <category>private</category><body package="UIPainter">enableHighLowFieldsWith: aDictionary 	| selectionType |	selectionType := (aDictionary at: #type) value.	selectionType == #date ifTrue: [^self setDateEnablementWith: aDictionary].	selectionType == #time ifTrue: [^self setTimeEnablementWith: aDictionary].	selectionType == #timestamp ifTrue: [^self setTimestampEnablementWith: aDictionary].	self setOtherEnablementWith: aDictionary</body></methods><methods><class-id>UI.SpinButtonSpec</class-id> <category>private-enablement</category><body package="UIPainter">setDateEnablementOffWith: env	"date field off"	((env at: #propertiesTool) subBuilder componentAt: #lowDateField) beInvisible.	(env at: #lowDate) value: String new.	((env at: #propertiesTool) subBuilder componentAt: #highDateField) beInvisible.	(env at: #highDate) value: String new.</body><body package="UIPainter">setDateEnablementOnWith: env	"date field on"	((env at: #propertiesTool) subBuilder componentAt: #lowDateField) beVisible.	((env at: #propertiesTool) subBuilder componentAt: #highDateField) beVisible.</body><body package="UIPainter">setDateEnablementWith: env	"regular field off"	self setRegularEnablementOffWith: env.	"date field on"	self setDateEnablementOnWith: env.	"time field off"	self setTimeEnablementOffWith: env.	"timestamp field off"	self setTimestampEnablementOffWith: env.</body><body package="UIPainter">setOtherEnablementWith: env			"regular field on"	self setRegularEnablementOnWith: env.	"date field off"	self setDateEnablementOffWith: env.	"time field off"	self setTimeEnablementOffWith: env.	"timestamp field off"	self setTimestampEnablementOffWith: env.</body><body package="UIPainter">setRegularEnablementOffWith: env	"regular field off"	((env at: #propertiesTool) subBuilder componentAt: #lowField) beInvisible.	(env at: #low) value: String new.	((env at: #propertiesTool) subBuilder componentAt: #highField) beInvisible.	(env at: #high) value: String new.</body><body package="UIPainter">setRegularEnablementOnWith: env	"regular field on"	((env at: #propertiesTool) subBuilder componentAt: #lowField) beVisible.	((env at: #propertiesTool) subBuilder componentAt: #highField) beVisible.</body><body package="UIPainter">setTimeEnablementOffWith: env	"time field off"	((env at: #propertiesTool) subBuilder componentAt: #lowTimeField) beInvisible.	(env at: #lowTime) value: String new.	((env at: #propertiesTool) subBuilder componentAt: #highTimeField) beInvisible.	(env at: #highTime) value: String new.</body><body package="UIPainter">setTimeEnablementOnWith: env	"time field on"	((env at: #propertiesTool) subBuilder componentAt: #lowTimeField) beVisible.	((env at: #propertiesTool) subBuilder componentAt: #highTimeField) beVisible.</body><body package="UIPainter">setTimeEnablementWith: env	"regular field off"	self setRegularEnablementOffWith: env.	"date field off"	self setDateEnablementOffWith: env.	"time field on"	self setTimeEnablementOnWith: env.	"timestamp field off"	self setTimestampEnablementOffWith: env.</body><body package="UIPainter">setTimestampEnablementOffWith: env	"timestamp field off"	((env at: #propertiesTool) subBuilder componentAt: #lowTimestampField) beInvisible.	(env at: #lowTimestamp) value: String new.	((env at: #propertiesTool) subBuilder componentAt: #highTimestampField) beInvisible.	(env at: #highTimestamp) value: String new.</body><body package="UIPainter">setTimestampEnablementOnWith: env	"timestamp field on"	((env at: #propertiesTool) subBuilder componentAt: #lowTimestampField) beVisible.	((env at: #propertiesTool) subBuilder componentAt: #highTimestampField) beVisible.</body><body package="UIPainter">setTimestampEnablementWith: env	"regular field off"	self setRegularEnablementOffWith: env.	"date field off"	self setDateEnablementOffWith: env.	"time field off"	self setTimeEnablementOffWith: env.	"timestamp field on"	self setTimestampEnablementOnWith: env.</body></methods><methods><class-id>UI.SpinButtonSpec</class-id> <category>private</category><body package="UIPainter">validateComponentsFor: aBuilder 	super validateComponentsFor: aBuilder.	(aBuilder notNil and: [(aBuilder bindings at: #propertiesTool) slice value == #Basics]) 		ifTrue: [self enableHighLowFieldsWith: aBuilder bindings]</body></methods><methods><class-id>UI.UISpecEnumerator</class-id> <category>dispatching</category><body package="UIPainter">doDataSetSpec: aSpec	self doComponentSpec: aSpec.	aSpec setColumnButtonsAsLabelsAttributes.	self doSpecs: aSpec columns</body></methods><methods><class-id>UI.ArbitraryComponentSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel.	env 		at: #component 		put: (TypeConverter onSymbolValue: (self 			adapt: inst 			forAspect: #component 			channel: aChannel))</body><body package="UIPainter">componentName	"Identification of component"	^(#ViewHolder &lt;&lt; #UIPainter &gt;&gt; 'View Holder') asString</body></methods><methods><class-id>UI.ArbitraryComponentSpec class</class-id> <category>property slices</category><body package="UIPainter">dropTargetSlice	^#(80 #(#(#{Kernel.UserMessage} #key: #DropTarget #defaultString: 'Drop Target' #catalogID: #UIPainter) #dropTargetSpec))</body></methods><methods><class-id>UI.ArbitraryComponentSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #arbitraryComponentWidget</body></methods><methods><class-id>UI.MappedClickWidgetSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel 	super		addBindingsTo: env		for: inst		channel: aChannel.	env at: #visualSelector put: (self				adapt: inst				forAspect: #visualSelector				channel: aChannel).	env at: #mappingsSelector put: (self			adapt: inst			forAspect: #mappingsSelector			channel: aChannel).	env at: #performerSelector put: (self			adapt: inst			forAspect: #performerSelector			channel: aChannel).	env at: #defaultClickSelector put: (self			adapt: inst			forAspect: #defaultClickSelector			channel: aChannel).</body><body package="UIPainter">componentName	^(#ClickWidget &lt;&lt; #UIPainter &gt;&gt; 'Click Widget') asString</body></methods><methods><class-id>UI.MappedClickWidgetSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #mappedClickWidget</body></methods><methods><class-id>UI.DataSetColumnSpec class</class-id> <category>property slices</category><body package="UIPainter">notificationSlice	^#(35 #(#(#{Kernel.UserMessage} #key: #Notification #defaultString: 'Notification' #catalogID: #UIPainter) #notificationDCEditSpec nil #callbacks))</body><body package="UIPainter">validationSlice	^#(30 #(#(#{Kernel.UserMessage} #key: #Validation #defaultString: 'Validation' #catalogID: #UIPainter) validationDCEditSpec nil callbacks))</body></methods><methods><class-id>UI.DataSetColumnSpec</class-id> <category>private-UIDefiner</category><body package="UIPainter">aspectPathForSort	| tokens strm |	tokens := self model tokensBasedOn: (Character space).	tokens remove: tokens first.	strm := WriteStream on: (String new: 50).	tokens do: [:ea | strm nextPutAll: ea.					strm nextPutAll: ' '].	strm skip: -1.	^strm contents</body><body package="UIPainter">fullColumnAspect	"this is essentially the name of the column"	^(self camelCase: self model) asSymbol</body></methods><methods><class-id>UI.WidgetSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	| lblAdptr |	super addBindingsTo: env for: inst channel: aChannel.	env at: #model put: (TypeConverter onSymbolValue:		(self adapt: inst forAspect: #model channel: aChannel)) aspectToText.	env at: #tabable put: (self adapt: inst forAspect: #tabable channel: aChannel).	env at: #helpField put: ((TypeConverter onSymbolValue:		(self adapt: inst forAspect: #helpField channel: aChannel))).	lblAdptr := (self adapt: inst forAspect: #helpText channel: aChannel).	env at: #helpText put: (TypeConverter onStringOrSymbolValue: lblAdptr).	env at: #helpLabelIsMessage put: (inst helpText isSymbol asValue).</body></methods><methods><class-id>UI.WidgetSpec class</class-id> <category>property slices</category><body package="UIPainter">dropTargetSlice	^#(80 #(#(#{Kernel.UserMessage} #key: #DropTarget #defaultString: 'Drop Target' #catalogID: #UIPainter) #dropTargetSpec))</body></methods><methods><class-id>UI.WidgetSpec class</class-id> <category>interface specs</category><body package="UIPainter">helpConstructorSpec	| spec baseY y delta |	spec := self helpConstructorSpecLiteral decodeAsLiteralArray.	delta := UIPainterTool helpConstructorSpecSize - 31.	spec component collection do:		[:sp |		(sp class == SubCanvasSpec and: [sp clientKey = #helpConstructor])			ifTrue:				[baseY := sp layout bottomOffset.				sp layout bottomOffset: baseY+delta]].	spec component collection do:		[:sp |		y := sp layout class == Point			ifTrue: [sp layout y]			ifFalse: [sp layout topOffset].		y &gt;= baseY			ifTrue:				[Object errorSignal					handle: [:ex | ex return]					do: [sp layout y: sp layout y + delta].				Object errorSignal					handle: [:ex | ex return]					do: [sp layout topOffset: sp layout topOffset + delta].				Object errorSignal					handle: [:ex | ex return]					do: [sp layout bottomOffset: sp layout bottomOffset + delta]]].	^spec</body></methods><methods><class-id>UI.WidgetSpec class</class-id> <category>property slices</category><body package="UIPainter">notificationSlice	^#(35 #(#(#{Kernel.UserMessage} #key: #Notification #defaultString: 'Notification' #catalogID: #UIPainter) #notificationEditSpec nil #callbacks))</body><body package="UIPainter">validationSlice	^#(30 #(#(#{Kernel.UserMessage} #key: #Validation #defaultString: 'Validation' #catalogID: #UIPainter) #validationEditSpec nil #callbacks))</body></methods><methods><class-id>UI.WidgetSpec</class-id> <category>private</category><body package="UIPainter">models	^Set with: self model</body></methods><methods><class-id>UI.WidgetSpec</class-id> <category>accessing</category><body package="UIPainter">savableSpecFor: implementationComponent	| result |	result := super savableSpecFor: implementationComponent.	(self model isLiteral) ifFalse: [result model: nil].	callbacksSpec notNil ifTrue: [ result callbacksSpec: callbacksSpec copy].	^result</body><body package="UIPainter">subSpecFor: aSlice	"Given a slice answer an appropriate sub-spec.	Note that this action may create the sub-specs.	The view parameter is used for initialization of	some of the sub-specs. If the requested slice 	does not exist answer self." 	aSlice == #callbacks ifTrue: [^self callbacksSpec].	^self.</body></methods><methods><class-id>UI.LabelSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	"You might think it would be nice if the prepending # sign were 	removed when switching back to a non-image oriented label -- or 	you might not, since the name of an image can hardly ever be a 	decent literal label. In any case, the attempt to do so would break 	UIPropertiesTool, which would run the block even when simply 	initializing over a new label -- hence remote labels would not show 	up as symbols."	| lblAdptr lblCnvrtr hasImage lblMode |	super addBindingsTo: env for: inst channel: aChannel. 	lblAdptr := (self adapt: inst forAspect: #label channel: aChannel).	env at: #label put: (lblCnvrtr :=		(inst hasImageOrientedLabel			ifTrue: [TypeConverter onSymbolValue: lblAdptr]			ifFalse: [TypeConverter onStringOrSymbolValue: lblAdptr])).	env at: #labelFromApplication put: (self adapt: inst forAspect: #labelFromApplication channel: aChannel).	env at: #labelIsMessage put: (lblMode := inst label isSymbol asValue).	inst label isSymbol ifTrue: [(env at: #labelFromApplication) value: true].	env at: #target put: (self adapt: inst forAspect: #target channel: aChannel).	env at: #mnemonic put: (self adapt: inst forAspect: #mnemonic channel: aChannel). 	env at: #style put: (self adapt: inst forAspect: #style channel: aChannel).	env at: #hasImageOrientedLabel put: 		(hasImage := self adapt: inst forAspect: #hasImageOrientedLabel channel: aChannel).	env at: #fontMenu put: self fontMenu.	hasImage		compute: 			[:v | 			v				ifTrue: [lblCnvrtr symbolToText]				ifFalse: [lblCnvrtr stringOrSymbolToText].			v				ifTrue: [lblMode value: true]				ifFalse: [lblMode value: inst label isSymbol].			(env at: #propertiesTool) update: #updateLabelIsImage with: nil from: nil.			(lblAdptr value notNil and: [lblAdptr value asString isEmpty not]) ifTrue: 				[lblAdptr changed: #value]]</body></methods><methods><class-id>UI.LabelSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	| spec baseY y delta |	spec := self basicsEditSpecLiteral decodeAsLiteralArray.	delta := UIPainterTool labelConstructorSpecSize - 31.	spec component collection do:		[:sp |		(sp class == SubCanvasSpec and: [sp clientKey = #labelConstructor])			ifTrue:				[baseY := sp layout bottomOffset.				sp layout bottomOffset: baseY+delta]].	spec component collection do:		[:sp |		y := sp layout class == Point			ifTrue: [sp layout y]			ifFalse: [sp layout topOffset].		y &gt;= baseY			ifTrue:				[[sp layout y: sp layout y + delta]					on: Object errorSignal					do: [:ex | ex return].				[sp layout topOffset: sp layout topOffset + delta]					on: Object errorSignal					do: [:ex | ex return].				[sp layout bottomOffset: sp layout bottomOffset + delta]					on: Object errorSignal					do: [:ex | ex return]]].	^spec</body></methods><methods><class-id>UI.LabelSpec class</class-id> <category>private-interface building</category><body package="UIPainter">componentName	"Identification of component"	^(#Label &lt;&lt; #UIPainter &gt;&gt; 'Label') asString</body></methods><methods><class-id>UI.LabelSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #labelWidget</body></methods><methods><class-id>UI.LabelSpec class</class-id> <category>private-interface building</category><body package="UIPainter">placementExtentBlock	^nil</body><body package="UIPainter">specGenerationBlock	^[:ctrlr :point |	| spec |	spec :=  (LabelSpec		label: (#Label &lt;&lt; #UIPainter &gt;&gt; 'Label') asString		layout: (ctrlr gridPoint: point)).	spec assignNameFrom: ctrlr.	spec]</body></methods><methods><class-id>UI.LabelSpec</class-id> <category>accessing</category><body package="UIPainter">canHaveLabel	^true</body></methods><methods><class-id>UI.LabelSpec</class-id> <category>private</category><body package="UIPainter">colorSelections	^#(#foreground #background)</body></methods><methods><class-id>UI.LabelSpec</class-id> <category>accessing</category><body package="UIPainter">hasInherentSize	^true</body></methods><methods><class-id>UI.InputEditorSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel. 	env at: #defaultString put: (self adapt: inst forAspect: #defaultString channel: aChannel).	env at: #numChars put: (self adapt: inst forAspect: #numChars channel: aChannel).	env at: #alignment put: (self adapt: inst forAspect: #alignment channel: aChannel).	env at: #alignmentMenu put: self alignmentMenu</body><body package="UIPainter">alignmentMenu	| mb |	mb := MenuBuilder new.	mb add: (#Left &lt;&lt; #UIPainter &gt;&gt; 'Left')-&gt;#left.	mb add: (#Center &lt;&lt; #UIPainter &gt;&gt; 'Center')-&gt;#center.	mb add: (#Right &lt;&lt; #UIPainter &gt;&gt; 'Right')-&gt;#right.	^mb menuHolder</body><body package="UIPainter">componentName	"Identification of component"	^(#InputEditor &lt;&lt; #UIPainter &gt;&gt; 'Input Editor') asString</body></methods><methods><class-id>UI.InputEditorSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #inputEditorWidget</body></methods><methods><class-id>UI.InputEditorSpec class</class-id> <category>private-interface building</category><body package="UIPainter">placementExtentBlock	^[:bldr | 100 @ (bldr policy defaultableInputFieldHeight)]</body></methods><methods><class-id>UI.PassiveLabel</class-id> <category>private</category><body package="UIPainter">canHaveLabel	^true</body></methods><methods><class-id>UI.DividerSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel.	env at: #lineWidth put: (TypeConverter onNumberValue: (self adapt: inst forAspect: #lineWidth channel: aChannel)).		env at: #orientation put: (self adapt: inst accessWith: #orientation assignWith: #setOrientation: channel: aChannel).	env at: #align put: (TypeConverter onNumberValue: (self adapt: inst forAspect: #align channel: aChannel)).		env at: #color put: (TypeConverter onNumberValue: (self adapt: inst forAspect: #color channel: aChannel)).		env at: #size put: (TypeConverter onNumberValue: (self adapt: inst forAspect: #size channel: aChannel)).</body><body package="UIPainter">componentName	"Identification of component"	^(#Divider &lt;&lt; #UIPainter &gt;&gt; 'Divider') asString</body></methods><methods><class-id>UI.DividerSpec class</class-id> <category>property slices</category><body package="UIPainter">detailsSlice	"Empty means NO PAGE!"	^#(1 #())</body></methods><methods><class-id>UI.DividerSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #dividerWidget</body></methods><methods><class-id>UI.DividerSpec class</class-id> <category>private-interface building</category><body package="UIPainter">placementExtentBlock	^[:bldr | 80 @ 2]</body><body package="UIPainter">specGenerationBlock	^[:ctrlr :point | 	| spec |	spec := DividerSpec new		layout: ((ctrlr gridPoint: point) extent: 100@4).	spec assignNameFrom: ctrlr.	spec]</body></methods><methods><class-id>UI.DividerSpec</class-id> <category>private</category><body package="UIPainter">colorSelections	^#(#background)</body></methods><methods><class-id>UI.DividerSpec</class-id> <category>private-interface building</category><body package="UIPainter">dragHandlesFor: specWrapper subject: someWidget isPrimary: isPrimary	| a b |	a := Array		with: (#{DragHandle} value wrapper: specWrapper subject: someWidget isPrimary: isPrimary) asOrigin		with: (#{DragHandle} value wrapper: specWrapper subject: someWidget isPrimary: isPrimary) asDividerCorner.	b:= (specWrapper component class == #{LayoutWrapper} value		ifTrue: [[:h | #{NullDragModeTracker} value new]]		ifFalse: [[:h | #{DividerResizingDragModeTracker} value new]]).	a do: [:dh | dh dragModeBlock: b].	^a</body></methods><methods><class-id>UI.DividerSpec</class-id> <category>private</category><body package="UIPainter">shouldCompareLayouts: newSpec	^self orientation = newSpec orientation</body></methods><methods><class-id>UI.UISettings class</class-id> <category>user preferences</category><body package="UIPainter">addUIPainterSectionTo: aDictionary development: devSpecs runtime: runtimeSpecs	"Add the UIPainter's set of preferences and settings slices to the arguments."	| screenBounds |	screenBounds := WindowingSystem isHeadless 		ifTrue: [640 @ 480]		ifFalse: [Screen default bounds extent].	self ensure: aDictionary		hasModelFor: #placementFeel		editing:#placementFeelEditing		default: #DragPlacementModeTracker.	self ensure: aDictionary		hasModelFor: #maximumCanvasWidth		editing: #maximumCanvasWidthEditing		default: screenBounds x.	self ensure: aDictionary		hasModelFor: #maximumCanvasHeight		editing: #maximumCanvasHeightEditing		default: screenBounds y.	self ensure: aDictionary		hasModelFor: #initialGridSize		editing: #initialGridSizeEditing		default: 8.	self ensure: aDictionary		hasModelFor: #initialGridMode		editing: #initialGridModeEditing		default: #Off.	self ensure: aDictionary		hasModelFor: #initialGridDisplay		editing: #initialGridDisplayEditing		default: #'Show If On'.	aDictionary		at: #canvasAccept put: [self canvasAccept];		at: #canvasReset put: [self canvasReset].	self ensure: aDictionary		hasModelFor: #avoidInstallationDialog		editing: #avoidInstallationDialogEditing		default: false.	self ensure: aDictionary		hasModelFor: #installForDefine		editing: #installForDefineEditing		default: false.	self ensure: aDictionary		hasModelFor: #installForOpen		editing: #installForOpenEditing		default: false.	aDictionary		at: #verboseLevelAccept put: [self verboseLevelAccept];		at: #verboseLevelReset put: [self verboseLevelReset].	devSpecs		add: (#GUIPainter &lt;&lt; #UIPainter &gt;&gt; 'GUI Painter') asString -&gt;#(#guiPainterSpec #guiPainterHelp);		add: (#Install &lt;&lt; #UIPainter &gt;&gt; 'Install') asString -&gt;#(#verboseLevelSpec #verboseLevelHelp)</body></methods><methods><class-id>UI.UISettings class</class-id> <category>accessing preferences</category><body package="UIPainter">canvasAccept	| maxHeight maxWidth grid mode display |	(self preferenceModelFor: #placementFeel)		value: (self preferenceFor: #placementFeelEditing).	maxHeight := self preferenceFor: #maximumCanvasHeightEditing.	maxWidth := self preferenceFor: #maximumCanvasWidthEditing.	grid := self preferenceFor: #initialGridSizeEditing.	grid &lt; 1 ifTrue: 		[ Dialog warn: (#GenKey160 &lt;&lt; #UIPainter &gt;&gt; 'The grid size must be greater than 0.Your grid size change has not been accepted.').		grid := self preferenceFor: #initialGridSize ].	mode := self preferenceFor: #initialGridModeEditing.	display := self preferenceFor: #initialGridDisplayEditing.	maxHeight &lt; 20 ifTrue: [maxHeight := 20].	maxWidth &lt; 20 ifTrue: [maxWidth := 20].	(self preferenceModelFor: #maximumCanvasHeight)		value: maxHeight.	(self preferenceModelFor: #maximumCanvasWidth)		value: maxWidth.	(self preferenceModelFor: #initialGridSize)		value: grid.	(self preferenceModelFor: #initialGridMode)		value: mode.	(self preferenceModelFor: #initialGridDisplay)		value: display.	self canvasReset</body><body package="UIPainter">canvasReset	(self preferenceModelOrSubstituteFor: #maximumCanvasHeightEditing)		value: (self preferenceFor: #maximumCanvasHeight).	(self preferenceModelOrSubstituteFor: #maximumCanvasWidthEditing)		value: (self preferenceFor: #maximumCanvasWidth).	(self preferenceModelOrSubstituteFor: #initialGridSizeEditing)		value: (self preferenceFor: #initialGridSize).	(self preferenceModelOrSubstituteFor: #initialGridModeEditing)		value: (self preferenceFor: #initialGridMode).	(self preferenceModelOrSubstituteFor: #initialGridDisplayEditing)		value: (self preferenceFor: #initialGridDisplay).	(self preferenceModelFor: #placementFeelEditing)		value: (self preferenceFor: #placementFeel)</body></methods><methods><class-id>UI.UISettings</class-id> <category>help</category><body package="UIPainter">guiPainterHelp	^(#GenKey158 &lt;&lt; #UIPainter &gt;&gt; 'GUI Painter SettingsThe Maximum Size: fields set the maximum size for opening a canvas for painting.  This can be used to ensure that your application windows will fit on a screen that is smaller than your development machine''s screen.  It does not affect the maximum size for opening the window of a running application, it merely forces application developers to design within certain size limits.The Initial Grid Settings affect the behavior of canvas gridding. "Off" allows you to place components anywhere.  "On", "X Only", and "Y Only" will force a component to be aligned with the grid, whose size in pixels is determined by the Size: field.  "Show If On", "Show" and "Hide" control the visibility of the grid.Palette Placement Feel-This setting controls the behavior of interface components when you select them from a Palette and drop them in a canvas.  By default ("Drag with Button Up"), the component is visible even before you click in the canvas (unless you have click-to-raise turned on in your window manager''s settings), and if you hold down the mouse button you can resize it in the same gesture.  The alternative setting ("Drag with Button Down") is better on slower machines - the componet remains invisible until you click in the canvas, and holding the mouse button down lets you relocate the component rather than resize it.')</body><body package="UIPainter">verboseLevelHelp	^(#GenKey159 &lt;&lt; #UIPainter &gt;&gt; 'Install and Apply Verbosity SettingsBy default, each time you use the "install" command for a canvas, you are prompted to confirm the class and selector on which to install it.  You may wish to bypass the confirmation when you are merely reinstalling a canvas on the same class and selector.  To do so, turn on "Avoid Installation Dialog".  On the occasions when you specifically want the dialog, prehaps to transfer a canvas to a different class, hold a &lt;Shift&gt; key down while selecting the "install" command.The "define" and "open" commands operate on canvas as it was last installed.  When you forget to "install" a changed canvas before using those commands, a warning dialog asks whether you want to "install" first.  To arrange for a changed canvas to be automatically reinstalled during "define" and "open" operations, turn on the "Install for Define" and "Install for Open" settings.')</body></methods><methods><class-id>UI.MenuButtonSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel.	env at: #menu put: (TypeConverter onSymbolValue: (self adapt: inst forAspect: #menu channel: aChannel)).	env at: #isList put: (self adapt: inst forAspect: #isList channel: aChannel).	env at: #isPopUp put: (self adapt: inst forAspect: #isPopUp channel: aChannel).	env at: #isDecorated put: (self adapt: inst forAspect: #isDecorated channel: aChannel).</body></methods><methods><class-id>UI.MenuButtonSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	| spec baseY y delta |	spec := self basicsEditSpecLiteral decodeAsLiteralArray.	delta := UIPainterTool labelConstructorSpecSize - 31.	spec component collection do:		[:sp |		(sp class == SubCanvasSpec and: [sp clientKey = #labelConstructor])			ifTrue:				[baseY := sp layout bottomOffset.				sp layout bottomOffset: baseY+delta]].	spec component collection do:		[:sp |		y := sp layout class == Point			ifTrue: [sp layout y]			ifFalse: [sp layout topOffset].		y &gt;= baseY			ifTrue:				[[sp layout y: sp layout y + delta]					on: Object errorSignal					do: [:ex | ex return].				[sp layout topOffset: sp layout topOffset + delta]					on: Object errorSignal					do: [:ex | ex return].				[sp layout bottomOffset: sp layout bottomOffset + delta]					on: Object errorSignal					do: [:ex | ex return]]].	^spec</body></methods><methods><class-id>UI.MenuButtonSpec class</class-id> <category>private-interface building</category><body package="UIPainter">componentName	"Identification of component"	^(#MenuButton &lt;&lt; #UIPainter &gt;&gt; 'Menu Button') asString</body></methods><methods><class-id>UI.MenuButtonSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #menuButtonWidget</body></methods><methods><class-id>UI.MenuButtonSpec class</class-id> <category>private-interface builder</category><body package="UIPainter">placementExtentBlock	^[:bldr |	100 @ (bldr policy defaultableMenuButtonHeight)]</body></methods><methods><class-id>UI.MenuButtonSpec</class-id> <category>private</category><body package="UIPainter">canHaveMenu	^true</body></methods><methods><class-id>UI.MenuButtonSpec</class-id> <category>accessing</category><body package="UIPainter">hasInherentSize	^false</body><body package="UIPainter">savableSpecFor: implementationComponent	| result |	result := super savableSpecFor: implementationComponent.	(self menu isLiteral) ifFalse: [result menu: nil].	^result</body></methods><methods><class-id>UI.MenuComponentSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel.	env at: #menu put: (TypeConverter onSymbolValue: (self adapt: inst forAspect: #menu channel: aChannel)).	env at: #performer put:  (TypeConverter onSymbolValue: (self adapt: inst forAspect: #performer channel: aChannel))</body></methods><methods><class-id>UI.MenuComponentSpec</class-id> <category>private</category><body package="UIPainter">canHaveMenu	^true</body></methods><methods><class-id>UI.MenuComponentSpec</class-id> <category>accessing</category><body package="UIPainter">savableSpecFor: implementationComponent	| result |	result := super savableSpecFor: implementationComponent.	(self menu isLiteral) ifFalse: [result menu: nil].	^result</body></methods><methods><class-id>UI.ProgressWidgetSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel 	super		addBindingsTo: env		for: inst		channel: aChannel.	env at: #direction put: (self			adapt: inst			forAspect: #direction			channel: aChannel).	env at: #position put: (self			adapt: inst			forAspect: #position			channel: aChannel).	env at: #area put: (self			adapt: inst			forAspect: #area			channel: aChannel).	env at: #reverse put: (self			adapt: inst			forAspect: #reverse			channel: aChannel)</body><body package="UIPainter">componentName	^(#PercentDoneBar &lt;&lt; #UIPainter &gt;&gt; 'Percent Done Bar') asString</body></methods><methods><class-id>UI.ProgressWidgetSpec class</class-id> <category>property slices</category><body package="UIPainter">detailsSlice	"Empty array means no page!"	^#(1 #())</body><body package="UIPainter">dropTargetSlice	"Empty array means no page!"	^#(1 #())</body><body package="UIPainter">flyByHelpSlice	^#(25 #(#(#{Kernel.UserMessage} #key: #FlyByHelp #defaultString: 'Fly-by Help' #catalogID: #UIPainter) helpConstructorSpec))</body></methods><methods><class-id>UI.ProgressWidgetSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #progressWidget</body></methods><methods><class-id>UI.ProgressWidgetSpec class</class-id> <category>property slices</category><body package="UIPainter">notificationSlice	"Empty array means no page!"	^#(1 #())</body><body package="UIPainter">validationSlice	"Empty array means no page!"	^#(1 #())</body></methods><methods><class-id>UI.ProgressWidgetSpec</class-id> <category>private</category><body package="UIPainter">colorSelections	^#(#foreground #background)</body></methods><methods><class-id>UI.LegacyActionButtonSpec class</class-id> <category>private-interface building</category><body package="UIPainter">specGenerationClass	^LegacyActionButtonSpec</body></methods><methods><class-id>UI.DocumentViewSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel. 	env at: #isWrapped put: (self adapt: inst forAspect: #isWrapped channel: aChannel).	env at: #isReadOnly put: (self adapt: inst forAspect: #isReadOnly channel: aChannel).	env at: #autoAccept put: (self adapt: inst forAspect: #autoAccept channel: aChannel).	env at: #showHiddenCharacters put: (self adapt: inst forAspect: #showHiddenCharacters channel: aChannel).	env at: #showLineStriping put: (self adapt: inst forAspect: #showLineStriping channel: aChannel).	env at: #showInputCursor put: (self adapt: inst forAspect: #showInputCursor channel: aChannel).	env at: #showSelection put: (self adapt: inst forAspect: #showSelection channel: aChannel)</body><body package="UIPainter">componentName	"Identification of component"	^(#DocumentView &lt;&lt; #UIPainter &gt;&gt; 'Document View') asString</body></methods><methods><class-id>UI.DocumentViewSpec class</class-id> <category>property slices</category><body package="UIPainter">flyByHelpSlice	^#(25 #(#(#{Kernel.UserMessage} #key: #FlyByHelp #defaultString: 'Fly-by Help' #catalogID: #UIPainter) helpConstructorSpec))</body></methods><methods><class-id>UI.DocumentViewSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #documentViewWidget</body><body package="UIPainter">paletteMonoIcon	^self paletteIcon</body></methods><methods><class-id>UI.UIBuilder</class-id> <category>private</category><body package="UIPainter">fixWindowWith: aWindowSpec	| vc |	vc := composite container.  "this gets the Grid wrapper"	vc container setComponent: nil.	window component release.	window component: nil.	windowSpec := aWindowSpec.	policy finalHookupWindow: windowSpec component: vc into: self.	vc component setLayoutManagerFromSpec: aWindowSpec.	vc component isOpen ifTrue: [		vc component invalidateLayout.		vc component invalidateNow	]</body></methods><methods><class-id>UI.NamedSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel.	env at: #name put: (TypeConverter onSymbolValue: (self adapt: inst forAspect: #name channel: aChannel)).	env at: #dragEnterSelector put: (TypeConverter onSymbolValue: (self adapt: inst forAspect: #dragEnterSelector channel: aChannel)).	env at: #dragOverSelector put: (TypeConverter onSymbolValue: (self adapt: inst forAspect: #dragOverSelector channel: aChannel)).	env at: #dragExitSelector put: (TypeConverter onSymbolValue: (self adapt: inst forAspect: #dragExitSelector channel: aChannel)).	env at: #dropSelector put: (TypeConverter onSymbolValue: (self adapt: inst forAspect: #dropSelector channel: aChannel)).	env at: #dragOkSelector put: (TypeConverter onSymbolValue: (self adapt: inst forAspect: #dragOkSelector channel: aChannel)).	env at: #dragStartSelector put: (TypeConverter onSymbolValue: (self adapt: inst forAspect: #dragStartSelector channel: aChannel)).	env at: #decorationType put: (self adapt: inst forAspect: #decorationType channel: aChannel).	env at: #hasBorder put: (self adapt: inst forAspect: #hasBorder channel: aChannel).	env at: #hasHorizontalScrollBar put: (self adapt: inst forAspect: #hasHorizontalScrollBar channel: aChannel).	env at: #hasMenuBar put: (self adapt: inst forAspect: #hasMenuBar channel: aChannel).	env at: #hasVerticalScrollBar put: (self adapt: inst forAspect: #hasVerticalScrollBar channel: aChannel).	env at: #isOpaque put: (self adapt: inst forAspect: #isOpaque channel: aChannel).	env at: #initiallyDisabled put: (self adapt: inst forAspect: #initiallyDisabled channel: aChannel).	env at: #initiallyInvisible put: (self adapt: inst forAspect: #initiallyInvisible channel: aChannel)</body><body package="UIPainter">componentName	^(#DEFAULT &lt;&lt; #UIPainter &gt;&gt; 'DEFAULT') asString</body><body package="UIPainter">iconForWidgetTree	^[self paletteIcon]		on: MessageNotUnderstood		do: [:error | error return: super iconForWidgetTree]</body><body package="UIPainter">paletteIconImage	"Answer an image to reperesent spec on the palette"	paletteIcon isNil ifTrue: [paletteIcon :=Array						with: (CachedImage on: self paletteIcon)							with: (CachedImage on: self paletteMonoIcon)].	^paletteIcon at: (Screen default colorDepth == 1			ifTrue: [2]			ifFalse: [1])</body></methods><methods><class-id>UI.NamedSpec</class-id> <category>private</category><body package="UIPainter">assignNameFrom: aPainterController	| tempName wrappers specsLikeMe specNames index |	tempName := self componentName asString copyWithout: $ .	wrappers := self drilledWrappersFrom: aPainterController view components.	specsLikeMe := wrappers select: [:each | each spec isKindOf: self class].	specNames := specsLikeMe collect: [:each | each spec name].	index := 0.	[index := index + 1.	(specNames includes: (tempName, index printString) asSymbol)] whileTrue.	name := (tempName, index printString) asSymbol.</body><body package="UIPainter">componentName	^self class componentName</body><body package="UIPainter">drilledWrappersFrom: aCollection	| wrappers composites | 	wrappers := aCollection select: [:each | each isKindOf: SpecWrapper]. 	composites := wrappers select: [:each | each bottomComponent isComposite].	composites isEmpty ifFalse: 		[composites do: [:each | wrappers addAll: (self drilledWrappersFrom: each bottomComponent components)]].	^wrappers</body></methods><methods><class-id>UI.UISpecification class</class-id> <category>private-interface building</category><body package="UIPainter">adapt: inst accessWith: getSelector assignWith: putSelector channel: aChannel	^aChannel == nil		ifTrue: [(AspectAdaptor subject: inst)accessWith: getSelector assignWith: putSelector]		ifFalse: [(AspectAdaptor subjectChannel: aChannel) accessWith: getSelector assignWith: putSelector]</body><body package="UIPainter">adapt: inst forAspect: aspect channel: aChannel	^aChannel == nil		ifTrue: [(AspectAdaptor subject: inst) forAspect: aspect]		ifFalse: [(AspectAdaptor subjectChannel: aChannel) forAspect: aspect]</body><body package="UIPainter">addBindingsTo: env for: inst	self addBindingsTo: env for: inst channel: inst asValue</body><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	env at: #helpText put: (self adapt: inst forAspect: #helpText channel: aChannel).	env at: #webHelpText put: (self adapt: inst forAspect: #webHelpText channel: aChannel).	self addWebBindingsTo: env for: inst channel: aChannel.	self addJavaScriptBindingsTo: env for: inst channel: aChannel</body><body package="UIPainter">addJavaScriptBindingsTo: env for: inst channel: aChannel 	"By default do nothing. Subclasses with JavaScript	 behaviors override to add the relevant bindings."</body><body package="UIPainter">addWebBindingsTo: env for: inst channel: aChannel 	"By default do nothing. Subclasses with Wave	 behaviors override to add the relevant bindings."</body></methods><methods><class-id>UI.UISpecification class</class-id> <category>property slices</category><body package="UIPainter">basicSlice	^#(10 #(#(#{Kernel.UserMessage} #key: #Basics #defaultString: 'Basics' #catalogID: #UIPainter) #basicsEditSpec))</body><body package="UIPainter">colorSlice	^#(40 #(#(#{Kernel.UserMessage} #key: #Color #defaultString: 'Color' #catalogID: #UIPainter) #propSpec #ColorToolModel))</body><body package="UIPainter">detailsSlice	^#(20 #(#(#{Kernel.UserMessage} #key: #Details #defaultString: 'Details' #catalogID: #UIPainter) #detailsEditSpec))</body></methods><methods><class-id>UI.UISpecification class</class-id> <category>private-interface building</category><body package="UIPainter">fontMenu	"self fontMenu"	| menu |	menu := Menu new.	menu 		augmentFrom: self class		to: UISpecification class		menuName: #fontMenu		for: self.	(UI.Skins.SkinRegistry current userDefinedStyles) do: [:style |		| styleName |		styleName := style asString.		styleName at: 1 put: ((style at: 1) asUppercase).		menu addItem: (MenuItem labeled: styleName) value: style].	^menu asValue</body></methods><methods><class-id>UI.UISpecification class</class-id> <category>private</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #unknownWidget</body></methods><methods><class-id>UI.UISpecification class</class-id> <category>property slices</category><body package="UIPainter">positionSlice	^#(21 #(#(#{Kernel.UserMessage} #key: #Position #defaultString: 'Position' #catalogID: #UIPainter) #propSpec #PositionToolModel))</body></methods><methods><class-id>UI.UISpecification class</class-id> <category>private</category><body package="UIPainter">prettyPrintSpecArray: anArray on: aStream tabLevel: tabLevel	"Pretty print anArray."	"If this array contains any keywords, start it on a new line."	((anArray			detect: [:element | element isSymbol and: [element isKeyword]]			ifNone: [nil]) notNil and: [tabLevel &gt; 1])		ifTrue: [aStream crtab: tabLevel].	aStream nextPutAll: '#('.	aStream policy printCharactersLiterally: true while:		[1 to: anArray size do:			[:index |			| element |			element := anArray at: index.			"Every keyword causes a new line and extra indentation."			element isSymbol				ifTrue: [element isKeyword ifTrue: [aStream crtab: tabLevel + 1].						element storeOn: aStream]				ifFalse: [element class == Array							ifTrue: [self prettyPrintSpecArray: element on: aStream tabLevel: tabLevel + 1]							ifFalse: [element storeOn: aStream]].				aStream space]].	aStream nextPut: $)</body><body package="UIPainter">selectionPopUpMenu	^nil</body><body package="UIPainter">selectionPullDownMenu	^nil</body></methods><methods><class-id>UI.UISpecification class</class-id> <category>private-interface building</category><body package="UIPainter">slices	"We get the property page slices via a bit of reflection.	All specs need do is add a method in the protocol 'property slices'	and the information in those methods will be added to the property page.	A method in the protocol consists of an array (or array of arrays) with a number	in the first position, and an old style property page slice defintion in the second position.	The specs are read from the class (you can override by using the same method name as	the super class, just like normal) sorted by their 'page position' number, and then sent on 	for the property tool to use to build the pages	Default page number orders: Basics = 10, Details = 20, Color = 40, Position = 60.	Want to remove a page? Just override the method, give it any position number, 	but an empty array in the second position"	| specClass specMethods sortedSpecs |	specClass := self.	specMethods := Set new.	[specMethods addAll: (specClass class organization listAtCategoryNamed: #'property slices').	specClass = UISpecification] whileFalse: [specClass := specClass superclass].	sortedSpecs := (specMethods collect: [:each | self perform: each]) asSortedCollection: [:each :other | each first &lt; other first].	^(sortedSpecs collect: [:each | each last]) asArray reject: [:each | each isEmpty]</body></methods><methods><class-id>UI.UISpecification class</class-id> <category>private</category><body package="UIPainter">store: aSpec toClass: class methodName: methodName	| array s|	array := aSpec literalArrayEncoding.	s := (String new: 100) writeStream.	s nextPutAll: methodName; cr.	"Put in a nice comment for re-opening the painter."	s tab;		nextPutAll: ('"&lt;1s&gt; new openOnClass: self andSelector: #' expandMacrosWith: UIPainter fullName);		nextPutAll: methodName; nextPut: $"; cr;		crtab; nextPutAll: '&lt;resource: #canvas&gt;';		crtab; nextPut: $^.	self prettyPrintSpecArray: array on: s tabLevel: 1.	class compile: s contents classified: #'interface specs'</body></methods><methods><class-id>UI.UISpecification</class-id> <category>private-labels</category><body package="UIPainter">canHaveLabel	^false</body></methods><methods><class-id>UI.UISpecification</class-id> <category>private</category><body package="UIPainter">canHaveMenu	^false</body><body package="UIPainter">colorSelections	^#(#foreground #background #selectedForeground #selectedBackground)</body><body package="UIPainter">iconForWidgetTree	^self class iconForWidgetTree</body><body package="UIPainter">models	^Set new</body><body package="UIPainter">painterName	^self name isNil		ifTrue: [((#Unnamed1s &lt;&lt; #UIPainter &gt;&gt; '%&lt;Unnamed &lt;1s&gt;%&gt;')			expandMacrosWith: self class componentName asString)]		ifFalse: [self name].</body><body package="UIPainter">shouldCompareLayouts: newSpec	^true</body></methods><methods><class-id>UI.InputFieldSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel.	env at: #releasingAgent put: inst.	env at: #type put: (self adapt: inst forAspect: #type channel: aChannel).	(env at: #type) compute: [ inst checkFormatStringWithBindings: env ].	env at: #formatString put: (self adapt: inst forAspect: #formatString channel: aChannel).	env at: #typeMenu put: self typeMenu.	env at: #defaultFormats put: List new asValue.	env at: #isDecorated put: (self adapt: inst forAspect: #isDecorated channel: aChannel).</body><body package="UIPainter">componentName	"Identification of component"	^(#InputField &lt;&lt; #UIPainter &gt;&gt; 'Input Field') asString</body></methods><methods><class-id>UI.InputFieldSpec class</class-id> <category>formats</category><body package="UIPainter">defaultDateFormats	| list |	list := List new.	list add: 'm/d/yy'.	list add: 'd-mmm-yy'.	list add: 'd-mmm'.	list add: 'mmm-yy'.	^list</body><body package="UIPainter">defaultFixed2Formats	| list |	list := List new.	list add: '0.00'.	list add: '#,##0.00'.	list add: '#,##0.00;-#,##0.00'.	list add: '#,##0.00;[Red]-#,##0.00'.	list add: '$#,##0.00;-$#,##0.00'.	list add: '$#,##0.00;[Red]-$#,##0.00'.	list add: '$#,##0.00;[Red]($#,##0.00)'.	list add: '0.00%'.	^list</body><body package="UIPainter">defaultNumberFormats	| list |	list := List new.	list add: '0'.	list add: '0.00'.	list add: '#,##0'.	list add: '#,##0.00'.	list add: '#,##0;-#,##0'.	list add: '#,##0;[Red]-#,##0'.	list add: '#,##0.00;-#,##0.00'.	list add: '#,##0.00;[Red]-#,##0.00'.	list add: '$#,##0;-$#,##0'.	list add: '$#,##0;[Red]-$#,##0'.	list add: '$#,##0.00;-$#,##0.00'.	list add: '$#,##0.00;[Red]-$#,##0.00'.	list add: '$#,##0.00;[Red]($#,##0.00)'.	list add: '(000) 000-0000'.	list add: '#000-00-0000'.	list add: '0%'.	list add: '0.00%'.	list add: '0.00E+00'.	^list</body><body package="UIPainter">defaultStringFormats	| list |	list := List new.	list add: '(@@@) @@@-@@@@'.	list add: '#@@@-@@-@@@@'.	^list</body><body package="UIPainter">defaultTimeStampFormats	| list |	list := List new.	list add: 'm/d/yy h:mm AM/PM'.	list add: 'd-mm-yy h:mm AM/PM'.	list add: 'mmm-yy h:mm'.	^list</body></methods><methods><class-id>UI.InputFieldSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #inputFieldWidget</body></methods><methods><class-id>UI.InputFieldSpec class</class-id> <category>property slices</category><body package="UIPainter">notificationSlice	^#(35 #(#(#{Kernel.UserMessage} #key: #Notification #defaultString: 'Notification' #catalogID: #UIPainter) #notificationDCEditSpec nil #callbacks))</body></methods><methods><class-id>UI.InputFieldSpec class</class-id> <category>private-interface building</category><body package="UIPainter">placementExtentBlock	^[:bldr |	100 @ (bldr policy defaultableInputFieldHeight)]</body><body package="UIPainter">typeMenu	"Answer a menu used to describe the various types support by input fields. Selecting a menu item will answer a Symbol that indicates the type."	| mb |	mb := MenuBuilder new.	mb add: (#String &lt;&lt; #UIPainter &gt;&gt; 'String')-&gt;#string.	mb add: (#Symbol &lt;&lt; #UIPainter &gt;&gt; 'Symbol')-&gt;#symbol.	mb add: (#Text &lt;&lt; #UIPainter &gt;&gt; 'Text')-&gt;#text.	mb add: (#Number &lt;&lt; #UIPainter &gt;&gt; 'Number')-&gt;#number.	mb add: (#Password &lt;&lt; #UIPainter &gt;&gt; 'Password')-&gt;#password.	mb add: (#Date &lt;&lt; #UIPainter &gt;&gt; 'Date')-&gt;#date.	mb add: (#Time &lt;&lt; #UIPainter &gt;&gt; 'Time')-&gt;#time.	mb add: (#Timestamp &lt;&lt; #UIPainter &gt;&gt; 'Timestamp')-&gt;#timestamp.	mb add: (#FixedPoint2 &lt;&lt; #UIPainter &gt;&gt; 'FixedPoint(2)')-&gt;#fixedpoint.	mb add: (#Boolean &lt;&lt; #UIPainter &gt;&gt; 'Boolean')-&gt;#boolean.	mb add: (#ByteArray &lt;&lt; #UIPainter &gt;&gt; 'ByteArray')-&gt;#bytearray.	mb add: (#Object &lt;&lt; #UIPainter &gt;&gt; 'Object')-&gt;#object.	^mb menuHolder</body></methods><methods><class-id>UI.InputFieldSpec class</class-id> <category>property slices</category><body package="UIPainter">validationSlice	^#(30 #(#(#{Kernel.UserMessage} #key: #Validation #defaultString: 'Validation' #catalogID: #UIPainter) #validationDCEditSpec nil #callbacks))</body></methods><methods><class-id>UI.InputFieldSpec</class-id> <category>private</category><body package="UIPainter">checkFormatStringWithBindings: env 	| choices action |	action := #disable.	choices := env at: #defaultFormats.	type == #number 		ifTrue: [choices value: self class defaultNumberFormats.				action := #enable.].	(type == #string or: [ type isNil ])		ifTrue: [choices value: self class defaultStringFormats.				action := #enable].	type == #date 		ifTrue: [choices value: self class defaultDateFormats.				action := #enable].	type == #fixedpoint 		ifTrue: [choices value: self class defaultFixed2Formats.				action := #enable].	type == #timestamp 		ifTrue: [choices value: self class defaultTimeStampFormats.				action := #enable].	type == #time 		ifTrue: [choices value: self class defaultTimeFormats.				action := #enable].	(env at: #propertiesTool) subBuilder notNil 		ifTrue: [ ((env at: #propertiesTool) subBuilder componentAt: #formatEditor) perform: action.				((env at: #propertiesTool) subBuilder componentAt: #formatLabel) perform: action].	action == #disable ifTrue: [ (env at: #formatString) value: String new ].</body></methods><methods><class-id>UI.InputFieldSpec</class-id> <category>accessing</category><body package="UIPainter">formatString	^formatString</body></methods><methods><class-id>UI.InputFieldSpec</class-id> <category>private</category><body package="UIPainter">validateComponentsFor: aBuilder	(aBuilder notNil and: [ (aBuilder bindings at: #propertiesTool) slice value == #Basics ]) ifTrue: [ self checkFormatStringWithBindings: aBuilder bindings ]</body></methods><methods><class-id>UI.SpecWrapper</class-id> <category>private-interface building</category><body package="UIPainter">assignNameFrom: aPainterController 	self spec assignNameFrom: aPainterController.	self widget isComposite 		ifTrue: 			[self widget components 				do: [:each | each hasWidget ifTrue: [each assignNameFrom: aPainterController]]]</body><body package="UIPainter">extractedSpec	^(self widget respondsTo: #container)		ifTrue: [spec extractedSpecFor: self widget]		ifFalse: [spec]</body></methods><methods><class-id>UI.SpecWrapper</class-id> <category>private</category><body package="UIPainter">globalBounds	| globalBounds outerContainer outerBounds currentInnerWrapper |	currentInnerWrapper := self.	globalBounds := currentInnerWrapper bounds.	outerContainer := currentInnerWrapper container.	[outerContainer isNil or: [outerContainer isMemberOf: UIPainterView]] 		whileFalse: 			[outerBounds := outerContainer container container 						rectangleRelativeTo: outerContainer container container container container 								bounds.			globalBounds := globalBounds translatedBy: outerBounds origin.			currentInnerWrapper := outerContainer container.			outerContainer := outerContainer container container container container].	^globalBounds</body></methods><methods><class-id>UI.SpecWrapper</class-id> <category>private-interface building</category><body package="UIPainter">moveLayoutBy: offset	| layout |	layout := spec layout.	((layout isKindOf: Point) or: [ layout isKindOf: Rectangle])		ifTrue: [^self newLayout: (layout translatedBy: offset)]</body><body package="UIPainter">painterDragHandles: isPrimary 	"Answer an array of DragHandles for the receiver, suitable for use by 	UIPainterController. isPrimary indicates whether or not the receiver 	is the primary selection in the controller where the handles are 	wanted."	^spec		dragHandlesFor: self		subject: self widget		isPrimary: isPrimary</body></methods><methods><class-id>UI.SpecWrapper</class-id> <category>accessing</category><body package="UIPainter">painterDragMode	"Answer an object, appropriate for use by a UIPainterController, that will	respond to the message dragObject:startingAt:inController:."	^#{SelectionDragModeTracker} value new</body></methods><methods><class-id>UI.SpecWrapper</class-id> <category>private-interface building</category><body package="UIPainter">savableSpec	^spec savableSpecFor: self widget</body></methods><methods><class-id>Graphics.VisualPart</class-id> <category>private</category><body package="UIPainter">setContainer: aVisualPart	container := aVisualPart</body></methods><methods><class-id>UI.ComponentSpec class</class-id> <category>private-interface building</category><body package="UIPainter">defaultExtentInBuilderBlock	"Answer a block if the receiver has inherent bounds otherwise answer nil"	^nil</body><body package="UIPainter">defaultPlacementExtentInBuilder: aBuilder	^50@50</body><body package="UIPainter">placementExtentBlock	^[:bldr | 100@100]</body><body package="UIPainter">specGenerationBlock	^[:ctrlr :point |	| spec |	spec := self layout:				((ctrlr gridPoint: point)					extent: (ctrlr currentMode value class placementExtentFor: self inBuilder: ctrlr builder)).	(spec respondsTo: #name) ifTrue: [spec assignNameFrom: ctrlr].	spec]</body></methods><methods><class-id>UI.ComponentSpec</class-id> <category>private-interface building</category><body package="UIPainter">dragHandlesFor: specWrapper subject: someWidget isPrimary: isPrimary	| a b|	a:= Array		with: (#{DragHandle} value wrapper: specWrapper subject: someWidget isPrimary: isPrimary) asOrigin		with: (#{DragHandle} value wrapper: specWrapper subject: someWidget isPrimary: isPrimary) asTopRight		with: (#{DragHandle} value wrapper: specWrapper subject: someWidget isPrimary: isPrimary) asCorner		with: (#{DragHandle} value wrapper: specWrapper subject: someWidget isPrimary: isPrimary) asBottomLeft.	b:= (specWrapper component class == #{LayoutWrapper} value		ifTrue: [[:h | #{NullDragModeTracker} value new]]		ifFalse: [[:h | #{CornerDragModeTracker} value new]]).	a do: [:dh | dh dragModeBlock: b].	^a</body></methods><methods><class-id>UI.ComponentSpec</class-id> <category>accessing</category><body package="UIPainter">extractedSpecFor: implementationComponent	^self</body><body package="UIPainter">hasInherentSize	^false</body><body package="UIPainter">savableSpecFor: implementationComponent	^self copy</body></methods><methods><class-id>UI.BorderDecorator</class-id> <category>initialize-release</category><body package="UIPainter">downcastEvent: aKey with: aParameter from: anInitiator	"This is a message passed down the view structure to some single 	part. Answer true if we accepted the event, or false if it should be 	passed on to whatever's behind us."	aKey == #usePersistentInformation		ifTrue: [component downcastEvent: aKey with: aParameter from: anInitiator].	super downcastEvent: aKey with: aParameter from: anInitiator</body></methods><methods><class-id>Graphics.CompositePart</class-id> <category>accessing</category><body package="UIPainter">addComponent: aVisualComponent atPath: aPathCollection	"Insert the component is at the path specified by aPathCollection"	| owningContainer | 	owningContainer := self.	aPathCollection size &gt; 1 ifTrue:		[owningContainer := (aPathCollection copyFrom: 1 to: aPathCollection size - 1) 			inject: owningContainer 			into: [:sum :each | sum bottomComponent components at: each]].	owningContainer bottomComponent components add: aVisualComponent beforeIndex: aPathCollection last.	aVisualComponent setContainer: owningContainer bottomComponent</body><body package="UIPainter">addComponent: aVisualComponent firstInPath: aPathCollection	"Insert the component as the last element along the path specified by aPathCollection"	| owningContainer | 	owningContainer := self.	aPathCollection size &gt; 1 ifTrue:		[owningContainer := (aPathCollection copyFrom: 1 to: aPathCollection size - 1) 			inject: owningContainer 			into: [:sum :each | sum bottomComponent components at: each]].	owningContainer bottomComponent components addFirst: aVisualComponent.	aVisualComponent setContainer: owningContainer bottomComponent</body><body package="UIPainter">addComponent: aVisualComponent lastInPath: aPathCollection	"Insert the component as the last element along the path specified by aPathCollection"	| owningContainer | 	owningContainer := self.	aPathCollection size &gt; 1 ifTrue:		[owningContainer := (aPathCollection copyFrom: 1 to: aPathCollection size - 1) 			inject: owningContainer 			into: [:sum :each | sum bottomComponent components at: each]].	owningContainer bottomComponent components addLast: aVisualComponent.	aVisualComponent setContainer: owningContainer bottomComponent</body><body package="UIPainter">indexedPath: aVisualComponent	| path |	path := OrderedCollection new.	self components		keysAndValuesDo:			[:index :each | 			| result |			(each isKindOf: DragHandle)				ifFalse:					[(each bottomComponent isMemberOf: CompositePart) "do NOT go down subclass paths"						ifTrue:							[result := each bottomComponent indexedPath: aVisualComponent.							result notNil								ifTrue:									[^path										add: index;										addAll: result;										yourself]].					(each spec class = aVisualComponent spec class						and:							[each spec name = aVisualComponent spec name								and: [each spec layout = aVisualComponent spec layout]])						ifTrue: [^OrderedCollection with: index]]].	^nil</body><body package="UIPainter">removeComponent: aVisualComponent atPath: aPathCollection	"Remove whatever component is at the path specified by aPathCollection	Redisplay any now exposed component."	| owningContainer | 	owningContainer := self.	aPathCollection size &gt; 1 ifTrue:		[owningContainer := (aPathCollection copyFrom: 1 to: aPathCollection size - 1) 			inject: owningContainer 			into: [:sum :each | sum bottomComponent components at: each]].	owningContainer bottomComponent components removeAtIndex: aPathCollection last.	aVisualComponent container: nil.	self invalidateLayout.	^aVisualComponent</body></methods><methods><class-id>Graphics.CompositePart</class-id> <category>diving painter-private</category><body package="UIPainter">specComponents	"answer the receiver's components.  no distinction is made."	^self components</body></methods><methods><class-id>UI.MenuItem</class-id> <category>labeling</category><body package="UIPainter">hasLabelOverride	^self definesCommand and: [self definesLabel]</body></methods><methods><class-id>UI.CompositeSpec class</class-id> <category>private-interface building</category><body package="UIPainter">componentName	"Identification of component"	^(#Composite &lt;&lt; #UIPainter &gt;&gt; 'Composite') asString</body></methods><methods><class-id>UI.CompositeSpec</class-id> <category>accessing</category><body package="UIPainter">extractedSpecFor: aComposite	| csc |	csc := CompositeSpecCollection new.	csc compositeSpec: self.	csc extractFromCollection: aComposite specComponents.	^csc</body><body package="UIPainter">hasInherentSize	^true</body><body package="UIPainter">savableSpecFor: aComposite	| csc |	csc := CompositeSpecCollection new.	csc compositeSpec: self copy.	csc fromCollection: aComposite components.	^csc</body></methods><methods><class-id>UI.CheckBoxSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	| spec baseY y delta |	spec := self basicsEditSpecLiteral decodeAsLiteralArray.	delta := UIPainterTool labelConstructorSpecSize - 31.	spec component collection do:		[:sp |		(sp class == SubCanvasSpec and: [sp clientKey = #labelConstructor])			ifTrue:				[baseY := sp layout bottomOffset.				sp layout bottomOffset: baseY+delta]].	spec component collection do:		[:sp |		y := sp layout class == Point			ifTrue: [sp layout y]			ifFalse: [sp layout topOffset].		y &gt;= baseY			ifTrue:				[[sp layout y: sp layout y + delta]					on: Object errorSignal					do: [:ex | ex return].				[sp layout topOffset: sp layout topOffset + delta]					on: Object errorSignal					do: [:ex | ex return].				[sp layout bottomOffset: sp layout bottomOffset + delta]					on: Object errorSignal					do: [:ex | ex return]]].	^spec</body></methods><methods><class-id>UI.CheckBoxSpec class</class-id> <category>private-interface building</category><body package="UIPainter">componentName	"Identification of component"	^(#CheckBox &lt;&lt; #UIPainter &gt;&gt; 'Check Box') asString</body></methods><methods><class-id>UI.CheckBoxSpec class</class-id> <category>private</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #checkBox</body></methods><methods><class-id>UI.CheckBoxSpec class</class-id> <category>private-interface building</category><body package="UIPainter">placementExtentBlock	^nil</body><body package="UIPainter">specGenerationBlock	^[:ctrlr :point |	| spec |	spec := CheckBoxSpec		model: nil		label: (#CheckBox &lt;&lt; #UIPainter &gt;&gt; 'Check Box') asString		layout: (ctrlr gridPoint: point).	spec assignNameFrom: ctrlr.	spec]</body></methods><methods><class-id>UI.CheckBoxSpec</class-id> <category>private</category><body package="UIPainter">colorSelections	^#(#foreground #background #selectedBackground)</body></methods><methods><class-id>UI.CompositeSpecCollection class</class-id> <category>private</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #compositeWidget</body></methods><methods><class-id>UI.CompositeSpecCollection</class-id> <category>private</category><body package="UIPainter">name	^self compositeSpec name isNil		ifTrue: [(#UnnamedComposite &lt;&lt; #UIPainter &gt;&gt; '&lt;Unnamed Composite&gt;') asString]		ifFalse: [self compositeSpec name]</body></methods><methods><class-id>UI.TextEditorSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel. 	env at: #alignment put: (self adapt: inst forAspect: #alignment channel: aChannel).	env at: #style put: (self adapt: inst forAspect: #style channel: aChannel).	env at: #isReadOnly put:  (self adapt: inst forAspect: #isReadOnly channel: aChannel).		env at: #isWrapped put:  (self adapt: inst forAspect: #isWrapped channel: aChannel).	env at: #numChars put: (TypeConverter onNumberValue: (self adapt: inst forAspect: #numChars channel: aChannel)).	env at: #fontMenu put: self fontMenu.	env at: #alignmentMenu put: self alignmentMenu.	env at: #tabRequiresControl put: (self adapt: inst forAspect: #tabRequiresControl channel: aChannel)</body><body package="UIPainter">alignmentMenu	| mb |	mb := MenuBuilder new.	mb add: (#Left &lt;&lt; #UIPainter &gt;&gt; 'Left')-&gt;#left.	mb add: (#Center &lt;&lt; #UIPainter &gt;&gt; 'Center')-&gt;#center.	mb add: (#Right &lt;&lt; #UIPainter &gt;&gt; 'Right')-&gt;#right.	^mb menuHolder</body><body package="UIPainter">componentName	"Identification of component"	^(#TextEditor &lt;&lt; #UIPainter &gt;&gt; 'Text Editor') asString</body></methods><methods><class-id>UI.TextEditorSpec class</class-id> <category>property slices</category><body package="UIPainter">flyByHelpSlice	^#(25 #(#(#{Kernel.UserMessage} #key: #FlyByHelp #defaultString: 'Fly-by Help' #catalogID: #UIPainter) helpConstructorSpec))</body></methods><methods><class-id>UI.TextEditorSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #textEditorWidget</body></methods><methods><class-id>UI.SliderSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	| strt stp st |	super addBindingsTo: env for: inst channel: aChannel.	env at: #orientation put: (self adapt: inst forAspect: #orientation channel: aChannel).	env at: #start put:		(strt := (TypeConverter on: (self adapt: inst forAspect: #start channel: aChannel)) numberOrNil).	env at: #stop put:		(stp := (TypeConverter on: (self adapt: inst forAspect: #stop channel: aChannel)) numberOrNil).	env at: #step put:		(st := (TypeConverter on: (self adapt: inst forAspect: #step channel: aChannel)) numberOrNil).	strt		compute:			[:v |			(v isEmpty not and: [aChannel value startValidates not])				ifTrue:					[Dialog warn: aChannel value startWarningString.					strt value: '']].	stp		compute:			[:v |			(v isEmpty not and: [aChannel value stopValidates not])				ifTrue:					[Dialog warn: aChannel value stopWarningString.					stp value: '']].	st		compute:			[:v |			(v isEmpty not and: [aChannel value stepValidates not])				ifTrue:					[Dialog warn: aChannel value stepWarningString.					st value: '']]</body><body package="UIPainter">componentName	"Identification of component"	^(#Slider &lt;&lt; #UIPainter &gt;&gt; 'Slider') asString</body></methods><methods><class-id>UI.SliderSpec class</class-id> <category>property slices</category><body package="UIPainter">dropTargetSlice	"Empty array means no page!"	^#(1 #())</body><body package="UIPainter">flyByHelpSlice	^#(25 #(#(#{Kernel.UserMessage} #key: #FlyByHelp #defaultString: 'Fly-by Help' #catalogID: #UIPainter) helpConstructorSpec))</body></methods><methods><class-id>UI.SliderSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #sliderWidget</body></methods><methods><class-id>UI.SliderSpec class</class-id> <category>private-interface building</category><body package="UIPainter">placementExtentBlock	^[:bldr | 80 @ 24]</body><body package="UIPainter">specGenerationBlock	^[:ctrlr :point | 	| spec |	spec := SliderSpec		model: nil		layout: ((ctrlr gridPoint: point)			extent: (ctrlr currentMode value class placementExtentFor: SliderSpec inBuilder: ctrlr builder))		properties: (Array with: #horizontal ).	spec assignNameFrom: ctrlr.	spec]</body></methods><methods><class-id>UI.SliderSpec</class-id> <category>private</category><body package="UIPainter">colorSelections	^#(#background #selectedBackground)</body></methods><methods><class-id>UI.SliderSpec</class-id> <category>private-interface building</category><body package="UIPainter">dragHandlesFor: specWrapper subject: someWidget isPrimary: isPrimary	| a b|	a:= Array		with: (#{DragHandle} value wrapper: specWrapper subject: someWidget isPrimary: isPrimary) asOrigin		with: (#{DragHandle} value wrapper: specWrapper subject: someWidget isPrimary: isPrimary) asTopRight		with: (#{DragHandle} value wrapper: specWrapper subject: someWidget isPrimary: isPrimary) asCorner		with: (#{DragHandle} value wrapper: specWrapper subject: someWidget isPrimary: isPrimary) asBottomLeft.	b:= (specWrapper component class == #{LayoutWrapper} value		ifTrue: [[:h | #{NullDragModeTracker} value new]]		ifFalse: [[:h | #{OrientationResizeModeTracker} value new]]).	a do: [:dh | dh dragModeBlock: b].	^a</body></methods><methods><class-id>UI.SliderSpec</class-id> <category>private</category><body package="UIPainter">startValidates	^self stop isNil or:		[self step isNil or:			[self step &gt; 0				ifTrue: [self start &lt; self stop]				ifFalse: [self stop &lt; self start]]]</body><body package="UIPainter">startWarningString	^self step &gt; 0		ifTrue: [(#GenKey22 &lt;&lt; #UIPainter &gt;&gt; 'Start must be less than Stop') asString]		ifFalse: [(#GenKey21 &lt;&lt; #UIPainter &gt;&gt; 'Step is negative, so Start must be greater than Stop') asString]</body><body package="UIPainter">stepValidates	^(self stop isNil or: [self start isNil]) or:		[(self step isNil or: [self step &gt; 0])			ifTrue: [(self start + self step) &lt; self stop]			ifFalse: [(self stop - self step) &lt; self start]]</body><body package="UIPainter">stepWarningString	^self stop &gt; self start		ifTrue: [(#GenKey24 &lt;&lt; #UIPainter &gt;&gt; 'Step must be positive and&lt;n&gt;less than the range from Start to Stop') asString]		ifFalse: [(#GenKey23 &lt;&lt; #UIPainter &gt;&gt; 'Stop is less than Start, so Step must be negative&lt;n&gt;and greater than the range from Start to Stop')			expandMacros]</body><body package="UIPainter">stopValidates	^self start isNil or:		[self step isNil or:			[self step &gt; 0				ifTrue: [self start &lt; self stop]				ifFalse: [self stop &lt; self start]]]</body><body package="UIPainter">stopWarningString	^self step &gt; 0		ifTrue: [(#GenKey26 &lt;&lt; #UIPainter &gt;&gt; 'Stop must be greater than Start') asString]		ifFalse: [(#GenKey25 &lt;&lt; #UIPainter &gt;&gt; 'Step is negative, so Stop must be less than Start') asString]</body></methods><methods><class-id>UI.TableViewSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel.	env at: #showHGrid put: (self adapt: inst forAspect: #showHGrid channel: aChannel).	env at: #showVGrid put: (self adapt: inst forAspect: #showVGrid channel: aChannel).	env at: #style put: (self adapt: inst forAspect: #style channel: aChannel).	env at: #selectionStyle put: (self adapt: inst forAspect: #selectionStyle channel: aChannel).	env at: #fontMenu put: self fontMenu</body><body package="UIPainter">componentName	"Identification of component"	^(#Table &lt;&lt; #UIPainter &gt;&gt; 'Table') asString</body></methods><methods><class-id>UI.TableViewSpec class</class-id> <category>property slices</category><body package="UIPainter">dragSourceSlice	^#(65 (#(#{Kernel.UserMessage} #key: #DragSource #defaultString: 'Drag Source' #catalogID: #UIPainter) #dropSourceSpec))</body></methods><methods><class-id>UI.TableViewSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #tableViewWidget</body></methods><methods><class-id>UI.TableViewSpec class</class-id> <category>property slices</category><body package="UIPainter">notificationSlice	^#(35 #(#(#{Kernel.UserMessage} #key: #Notification #defaultString: 'Notification' #catalogID: #UIPainter) #notificationDCEditSpec nil #callbacks))</body><body package="UIPainter">validationSlice	^#(30 #(#(#{Kernel.UserMessage} #key: #Validation #defaultString: 'Validation' #catalogID: #UIPainter) #validationDCEditSpec nil #callbacks))</body></methods><methods><class-id>UI.HierarchicalViewSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel.	env 		at: #minimumHeight 		put: (self adapt: inst forAspect: #minimumHeight channel: aChannel).</body><body package="UIPainter">componentName	"Identification of component"	^(#HierarchicalList &lt;&lt; #UIPainter &gt;&gt; 'HierarchicalList') asString</body></methods><methods><class-id>UI.HierarchicalViewSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #hierarchicalViewWidget</body></methods><methods><class-id>UI.HierarchicalViewSpec class</class-id> <category>private-interface building</category><body package="UIPainter">specGenerationBlock	^[:ctrlr :point | 	| spec |	spec := self layout:			((ctrlr gridPoint: point)				extent: (ctrlr currentMode value class placementExtentFor: self inBuilder: ctrlr builder)).	"new specs should not use check marks and should use &lt;shift&gt; and &lt;ctrl&gt;	modifiers for multiselection."	spec selectionType: #highlight.	spec useModifierKeys: true.	spec assignNameFrom: ctrlr.	spec]</body></methods><methods><class-id>UI.TreeViewSpec class</class-id> <category>private-interface building</category><body package="UIPainter">addBindingsTo: env for: inst channel: aChannel 	super		addBindingsTo: env		for: inst		channel: aChannel.	env 		at: #minimumHeight 		put: (self adapt: inst forAspect: #minimumHeight channel: aChannel).	env at: #displayStringSelector put: (TypeConverter onSymbolValue: (self				adapt: inst				forAspect: #displayStringSelector				channel: aChannel)).	env at: #useIcons put: (self			adapt: inst			forAspect: #useIcons			channel: aChannel).	env at: #fullLineSelect put: (self			adapt: inst			forAspect: #fullLineSelect			channel: aChannel).	env at: #rootExpander put: ( self			adapt: inst			forAspect: #rootExpander			channel: aChannel).	env at: #iconSelectors put: ((TypeConverter on: (self				adapt: inst				forAspect: #iconSelectors				channel: aChannel))			getBlock: 				[:m | 				| val |				(val := m value) isNil					ifTrue: [String new]					ifFalse: 						[| str |						str := (String new: 80) writeStream.						val do: [:ea | str nextPutAll: ea printString; space].						str contents]]			putBlock: 				[:m :v | 				| tokens t |				v isEmpty					ifTrue: [t := #()]					ifFalse: 						[tokens := (v tokensBasedOn: Character space) reject: [:s | s = ''].						t := Array new: tokens size.						1 to: tokens size							do: 								[:i | 								| s |								s := tokens at: i.								s first == $# ifTrue: [s := s copyFrom: 2 to: s size].								t at: i put: s asSymbol]].				t isEmpty					ifTrue: [m value: nil]					ifFalse: [m value: t]]			updateBlock: [:m :a :p | true]).	env at: #inPlaceEditedSelector put: (self			adapt: inst			forAspect: #inPlaceEditedSelector			channel: aChannel).	env at: #openedEmphasis put: (self			adapt: inst			forAspect: #openedEmphasis			channel: aChannel).	env at: #closedEmphasis put: (self			adapt: inst			forAspect: #closedEmphasis			channel: aChannel).	env at: #leafEmphasis put: (self			adapt: inst			forAspect: #leafEmphasis			channel: aChannel).	env at: #useChildImages put: (self			adapt: inst			forAspect: #useChildImages			channel: aChannel).	env at: #useLines put: (self			adapt: inst			forAspect: #useLines			channel: aChannel)</body></methods><methods><class-id>UI.TreeViewSpec class</class-id> <category>property slices</category><body package="UIPainter">advancedSlice	^#(21 #(#(#{Kernel.UserMessage} #key: #Advanced #defaultString: 'Advanced' #catalogID: #UIPainter) #advancedEditSpec))</body></methods><methods><class-id>UI.TreeViewSpec class</class-id> <category>private-interface building</category><body package="UIPainter">componentName	"Identification of component"	^(#TreeView &lt;&lt; #UIPainter &gt;&gt; 'Tree View') asString</body></methods><methods><class-id>UI.TreeViewSpec class</class-id> <category>resources</category><body package="UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #treeViewWidget</body></methods><methods><class-id>UI.TreeViewSpec class</class-id> <category>property slices</category><body package="UIPainter">itemsSlice	^#(28 #(#(#{Kernel.UserMessage} #key: #Items #defaultString: 'Items' #catalogID: #UIPainter) #itemsEditSpec))</body></methods><methods><class-id>Tools.UIMaskEditor class</class-id> <category>resources</category><body package="UIPainter">changeColorImageBW	"UIMaskEditor new openOnClass: self andSelector: #changeColorImageBW"	&lt;resource: #image&gt;	^CachedImage on: (Image			extent: 31 @ 12			depth: 1			bitsPerPixel: 1			palette: MonoMappedPalette whiteBlack			usingBits: #[2 0 0 8 6 0 0 24 12 0 0 48 20 0 128 80 44 0 192 144 84 31 225 80 170 31 242 8 213 31 227 84 162 128 194 2 85 128 129 86 43 0 0 132 30 0 0 120 ])</body><body package="UIPainter">changeColorImageColor	"UIMaskEditor new openOnClass: self andSelector: 	#changeColorImageColor"	&lt;resource: #image&gt;	^CachedImage on: (Image			extent: 31 @ 12			depth: 2			bitsPerPixel: 2			palette: (MappedPalette withColors: ((Array new: 4)						at: 1 put: ColorValue black;						at: 2 put: (ColorValue							scaledRed: 6167							scaledGreen: 6167							scaledBlue: 6167);						at: 3 put: ColorValue yellow;						at: 4 put: ColorValue green; yourself))			usingBits: #[85 89 85 85 85 85 85 212 85 105 85 85 85 85 87 212 85 165 85 85 85 85 95 84 86 165 85 85 21 85 127 84 90 165 85 85 5 85 255 84 106 165 84 0 1 87 255 84 170 169 84 0 0 95 255 212 170 170 84 0 1 95 255 244 170 90 149 85 5 95 245 252 106 90 149 85 21 87 245 252 90 170 85 85 85 85 255 244 86 169 85 85 85 85 127 212 ])</body><body package="UIPainter">fillRectangleImageBW	"UIMaskEditor new openOnClass: self andSelector: #fillRectangleImageBW"	&lt;resource: #image&gt;	^CachedImage on: (Image			extent: 31 @ 12			depth: 1			bitsPerPixel: 1			palette: MonoMappedPalette blackWhite			usingBits: #[0 0 0 0 0 0 0 0 59 187 187 184 46 238 238 232 59 187 187 184 46 238 238 232 59 187 187 184 46 238 238 232 59 187 187 184 46 238 238 232 0 0 0 0 0 0 0 0 ])</body><body package="UIPainter">fillRectangleImageColor	"UIMaskEditor new openOnClass: self andSelector: 	#fillRectangleImageColor"	&lt;resource: #image&gt;	^CachedImage on: (Image			extent: 31 @ 12			depth: 1			bitsPerPixel: 1			palette: (MappedPalette withColors: ((Array new: 2)						at: 1 put: ColorValue black;						at: 2 put: ColorValue yellow; yourself))			usingBits: #[0 0 0 0 0 0 0 0 63 255 255 248 63 255 255 248 63 255 255 248 63 255 255 248 63 255 255 248 63 255 255 248 63 255 255 248 63 255 255 248 0 0 0 0 0 0 0 0 ])</body><body package="UIPainter">maskEditorMenu	"MenuEditor new openOnClass: self andSelector: #maskEditorMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Image #defaultString: 'Image' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Capture #defaultString: 'Capture' #catalogID: #UIPainter) 							#value: #grab ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #LoadDot #defaultString: 'Load...' #catalogID: #UIPainter) 							#value: #load ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #InstallDot #defaultString: 'Install...' #catalogID: #UIPainter) 							#value: #install ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Read #defaultString: 'Read' #catalogID: #UIPainter) 							#nameKey: #read							#value: #read ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Apply #defaultString: 'Apply' #catalogID: #UIPainter) 							#nameKey: #apply							#value: #apply ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #StoreB__WMask #defaultString: 'Store B&amp;&amp;W Mask' #catalogID: #UIPainter) 							#nameKey: #toggleStoreMask							#value: #toggleStoreMask ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #StoreCachedImage #defaultString: 'Store Cached Image' #catalogID: #UIPainter) 							#nameKey: #toggleUseCache							#value: #toggleUseCache ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ResizeImage #defaultString: 'Resize Image' #catalogID: #UIPainter) 							#value: #clip ) ) #(3 2 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Edit #defaultString: 'Edit' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #UIPainter) 							#value: #cancel ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Accept #defaultString: 'Accept' #catalogID: #UIPainter) 							#value: #accept ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Cut #defaultString: 'Cut' #catalogID: #UIPainter) 							#value: #cut ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Copy #defaultString: 'Copy' #catalogID: #UIPainter) 							#value: #copy ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Paste #defaultString: 'Paste' #catalogID: #UIPainter) 							#value: #paste ) ) #(2 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Draw #defaultString: 'Draw' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #FillRectangle #defaultString: 'Fill Rectangle' #catalogID: #UIPainter) 							#nameKey: #fillCurrentColor 							#value: #fillCurrentColor ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ReplaceColor #defaultString: 'Replace Color' #catalogID: #UIPainter) 							#nameKey: #toCurrentColor 							#value: #toCurrentColor ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ColorToB__W #defaultString: 'Color to B&amp;&amp;W' #catalogID: #UIPainter) 							#value: #maskify ) ) #(3 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.UIMaskEditor class</class-id> <category>interface specs</category><body package="UIPainter">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #ImageEditor #defaultString: 'Image Editor' #catalogID: #UIPainter) 			#min: #(#{Core.Point} 395 244 ) 			#bounds: #(#{Graphics.Rectangle} 603 478 998 722 ) 			#flags: 4 			#menu: #maskEditorMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 40 0 -16 0.333333 0 0.38 ) 					#name: #directBitView 					#component: #directBitView ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 0.25 32 0 ) 					#name: #readButton 					#model: #read 					#tabable: false 					#label: #(#{Kernel.UserMessage} #key: #Read #defaultString: 'Read' #catalogID: #UIPainter) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.25 0 0 0 0.5 32 0 ) 					#name: #applyButton 					#model: #apply 					#tabable: false 					#label: #(#{Kernel.UserMessage} #key: #Apply #defaultString: 'Apply' #catalogID: #UIPainter) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.75 0 0 0 1 32 0 ) 					#name: #installButton 					#model: #install 					#tabable: false 					#label: #(#{Kernel.UserMessage} #key: #InstallDot #defaultString: 'Install...' #catalogID: #UIPainter) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.5 0 0 0 0.75 32 0 ) 					#name: #loadButton 					#model: #load 					#tabable: false 					#label: #(#{Kernel.UserMessage} #key: #LoadDot #defaultString: 'Load...' #catalogID: #UIPainter) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -244 1 -44 1 -204 1 -24 1 ) 					#name: #redButton 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #red ) 						#setSelectionBackgroundColor: #(#ColorValue #red ) ) 					#model: #doRed 					#tabable: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -204 1 -44 1 -164 1 -24 1 ) 					#name: #yellowButton 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #yellow ) 						#setSelectionBackgroundColor: #(#ColorValue #yellow ) ) 					#model: #doYellow 					#tabable: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -164 1 -44 1 -124 1 -24 1 ) 					#name: #greenButton 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #green ) 						#setSelectionBackgroundColor: #(#ColorValue #green ) ) 					#model: #doGreen 					#tabable: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -124 1 -44 1 -84 1 -24 1 ) 					#name: #cyanButton 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #cyan ) 						#setSelectionBackgroundColor: #(#ColorValue #cyan ) ) 					#model: #doCyan 					#tabable: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -84 1 -44 1 -44 1 -24 1 ) 					#name: #blueButton 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #blue ) 						#setSelectionBackgroundColor: #(#ColorValue #blue ) ) 					#model: #doBlue 					#tabable: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -44 1 -44 1 -4 1 -24 1 ) 					#name: #magentaButton 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #magenta ) 						#setSelectionBackgroundColor: #(#ColorValue #magenta ) ) 					#model: #doMagenta 					#tabable: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -284 1 -44 1 -244 1 -24 1 ) 					#name: #greyButton 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #lightGray ) 						#setSelectionBackgroundColor: #(#ColorValue #lightGray ) ) 					#model: #doGrey 					#tabable: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -44 1 -24 1 -4 1 -4 1 ) 					#name: #darkMagentaButton 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #darkMagenta ) 						#setSelectionBackgroundColor: #(#ColorValue #darkMagenta ) ) 					#model: #doDarkMagenta 					#tabable: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -244 1 -24 1 -204 1 -4 1 ) 					#name: #darkRedButton 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #darkRed ) 						#setSelectionBackgroundColor: #(#ColorValue #darkRed ) ) 					#model: #doDarkRed 					#tabable: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -204 1 -24 1 -164 1 -4 1 ) 					#name: #darkYellowButton 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #olive ) 						#setSelectionBackgroundColor: #(#ColorValue #olive ) ) 					#model: #doDarkYellow 					#tabable: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -164 1 -24 1 -124 1 -4 1 ) 					#name: #darkGreenButton 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #darkGreen ) 						#setSelectionBackgroundColor: #(#ColorValue #darkGreen ) ) 					#model: #doDarkGreen 					#tabable: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -124 1 -24 1 -84 1 -4 1 ) 					#name: #darkCyanButton 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #darkCyan ) 						#setSelectionBackgroundColor: #(#ColorValue #darkCyan ) ) 					#model: #doDarkCyan 					#tabable: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -84 1 -24 1 -44 1 -4 1 ) 					#name: #darkBlueButton 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #navy ) 						#setSelectionBackgroundColor: #(#ColorValue #navy ) ) 					#model: #doDarkBlue 					#tabable: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -284 1 -24 1 -244 1 -4 1 ) 					#name: #darkGreyButton 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #gray ) 						#setSelectionBackgroundColor: #(#ColorValue #gray ) ) 					#model: #doDarkGrey 					#tabable: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -324 1 -44 1 -284 1 -24 1 ) 					#name: #whiteButton 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) 						#setSelectionBackgroundColor: #(#ColorValue #white ) ) 					#model: #doWhite 					#tabable: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -324 1 -24 1 -284 1 -4 1 ) 					#name: #blackButton 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #black ) 						#setSelectionBackgroundColor: #(#ColorValue #black ) ) 					#model: #doBlack 					#tabable: false ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 -44 1 -324 1 -4 1 ) 					#name: #currentColorID 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #black ) ) 					#model: #doTheCurrentColor 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 -72 1 55 0 -48 1 ) 					#model: #fillCurrentColor 					#label: #fillRectangleImage 					#hasCharacterOrientedLabel: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 61 0 -72 1 113 0 -48 1 ) 					#model: #toCurrentColor 					#label: #changeColorImage 					#hasCharacterOrientedLabel: false ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} -8 0.333333 40 0 -8 1 -48 1 ) 					#name: #magnifiedBitView 					#flags: 11 					#component: #magnifiedBitView ) ) ) )</body></methods><methods><class-id>Tools.UIPalette class</class-id> <category>resources</category><body package="UIPainter">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Edit 					#defaultString: '&amp;Edit' 					#catalogID: #UIPainter ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_CopyWidget 								#defaultString: '&amp;Copy Widget' 								#catalogID: #UIPainter ) 							#nameKey: #doCopy 							#value: #doCopy 							#shortcutKeyCharacter: $C 							#shortcutModifiers: 3 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Cu_tWidget 								#defaultString: 'Cu&amp;t Widget' 								#catalogID: #UIPainter ) 							#nameKey: #doCut 							#value: #doCut 							#shortcutKeyCharacter: $X 							#shortcutModifiers: 3 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_PasteWidget 								#defaultString: '&amp;Paste Widget' 								#catalogID: #UIPainter ) 							#nameKey: #doPaste 							#value: #doPaste 							#shortcutKeyCharacter: $V 							#shortcutModifiers: 3 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Open_Window 								#defaultString: 'Open &amp;Window' 								#catalogID: #UIPainter ) 							#nameKey: #doOpen 							#value: #doOpen ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_GUIPainterTool 								#defaultString: '&amp;GUI Painter Tool' 								#catalogID: #UIPainter ) 							#nameKey: #openPainterTool 							#value: #openPainterTool ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Clo_sePalette 								#defaultString: 'Clo&amp;se Palette' 								#catalogID: #UIPainter ) 							#nameKey: #closePalette 							#value: #closePalette 							#shortcutKeyCharacter: $X 							#shortcutModifiers: 8 ) ) #(3 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Arrange 					#defaultString: '&amp;Arrange' 					#catalogID: #UIPainter ) 				#nameKey: #arrangeMenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Align_TopEdges 								#defaultString: 'Align &amp;Top Edges' 								#catalogID: #UIPainter ) 							#nameKey: #alignTopID 							#value: #alignTop 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #alignTop ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #GenKey157 								#defaultString: 'Align Along &amp;Horizontal Center' 								#catalogID: #UIPainter ) 							#nameKey: #alignVCenter 							#value: #alignVCenter 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #alignHCenter ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Align_BottomEdges 								#defaultString: 'Align &amp;Bottom Edges' 								#catalogID: #UIPainter ) 							#nameKey: #alignBottom 							#value: #alignBottom 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #alignBottom ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Align_LeftEdges 								#defaultString: 'Align &amp;Left Edges' 								#catalogID: #UIPainter ) 							#nameKey: #alignLeft 							#value: #alignLeft 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #alignLeft ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AlignAlong_VerticalCenter 								#defaultString: 'Align Along &amp;Vertical Center' 								#catalogID: #UIPainter ) 							#nameKey: #alignHCenter 							#value: #alignHCenter 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #alignVCenter ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Align_RightEdges 								#defaultString: 'Align &amp;Right Edges' 								#catalogID: #UIPainter ) 							#nameKey: #alignRight 							#value: #alignRight 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #alignRight ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #GenKey156 								#defaultString: 'Distribute Vertically - &amp;Equal Spacing' 								#catalogID: #UIPainter ) 							#nameKey: #distributeTTBEdges 							#value: #distributeTTBEdges 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #verticalSpacing ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #GenKey155 								#defaultString: 'Distribute Vertically - &amp;Centers' 								#catalogID: #UIPainter ) 							#nameKey: #distributeTTBCenters 							#value: #distributeTTBCenters 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #verticalDistribution ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #GenKey154 								#defaultString: 'Distribute H&amp;orizontally - Equal Spacing' 								#catalogID: #UIPainter ) 							#nameKey: #distributeLTREdges 							#value: #distributeLTREdges 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #horizontalSpacing ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #GenKey153 								#defaultString: 'Distribute Hori&amp;zontally - Centers' 								#catalogID: #UIPainter ) 							#nameKey: #distributeLTRCenters 							#value: #distributeLTRCenters 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #horizontalDistribution ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #MakeSame_Height 								#defaultString: 'Make Same &amp;Height' 								#catalogID: #UIPainter ) 							#nameKey: #equalizeHeight 							#value: #equalizeHeight 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #equalHeight ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #MakeSame_Width 								#defaultString: 'Make Same &amp;Width' 								#catalogID: #UIPainter ) 							#nameKey: #equalizeWidth 							#value: #equalizeWidth 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #equalWidth ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #MakeSame_Size 								#defaultString: 'Make Same &amp;Size' 								#catalogID: #UIPainter ) 							#nameKey: #equalizeBoth 							#value: #equalizeBoth 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #equalBoth ) ) ) #(3 3 4 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #UIPainter ) 				#nameKey: #help 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Palette 								#defaultString: '&amp;Palette' 								#catalogID: #UIPainter ) 							#value: #helpPalette 							#shortcutKeyCharacter: #F1 							#shortcutModifiers: 0 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #help ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_UserInterfacePainter 								#defaultString: '&amp;User Interface Painter' 								#catalogID: #UIPainter ) 							#value: #helpUserInterfacePainter ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_AboutVisualWorksDot								#defaultString: '&amp;About VisualWorks...' 								#catalogID: #UIPainter ) 							#value: #helpAbout ) ) #(2 1 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="UIPainter">paletteToolBar	"MenuEditor new openOnClass: self andSelector: #paletteToolBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #selectOne 					#defaultString: 'Select One' 					#catalogID: #menus ) 				#nameKey: #noSticky 				#value: #noSticky 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #selectOnePalette ) 				#helpText: #(#{Kernel.UserMessage} #key: #SelectOne #defaultString: 'Select One' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #stickySelect 					#defaultString: 'Sticky Select' 					#catalogID: #menus ) 				#nameKey: #makeSticky 				#value: #makeSticky 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #stickyPalette ) 				#helpText: #(#{Kernel.UserMessage} #key: #StickySelect #defaultString: 'Sticky Select' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #alignTop 					#defaultString: 'Align Top' 					#catalogID: #menus ) 				#nameKey: #alignTopID 				#value: #alignTop 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #alignTop ) 				#helpText: #(#{Kernel.UserMessage} #key: #AlignTop #defaultString: 'Align Top' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #alignHorizontalCenter 					#defaultString: 'Align Horizontal Center' 					#catalogID: #menus ) 				#nameKey: #alignVCenterID 				#value: #alignVCenter 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #alignHCenter ) 				#helpText: #(#{Kernel.UserMessage} #key: #AlignCenteredHorizontally #defaultString: 'Align Centered Horizontally' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #alignBottm 					#defaultString: 'Align Bottom' 					#catalogID: #menus ) 				#nameKey: #alignBottomID 				#value: #alignBottom 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #alignBottom ) 				#helpText: #(#{Kernel.UserMessage} #key: #AlignBottom #defaultString: 'Align Bottom' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #alignLeft 					#defaultString: 'Align Left' 					#catalogID: #menus ) 				#nameKey: #alignLeftID 				#value: #alignLeft 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #alignLeft ) 				#helpText: #(#{Kernel.UserMessage} #key: #AlignLeft #defaultString: 'Align Left' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #alignVerticalCenter 					#defaultString: 'Align Vertical Center' 					#catalogID: #menus ) 				#nameKey: #alignHCenterID 				#value: #alignHCenter 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #alignVCenter ) 				#helpText: #(#{Kernel.UserMessage} #key: #AlignCenteredVertically #defaultString: 'Align Centered Vertically' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #alignRight 					#defaultString: 'Align Right' 					#catalogID: #menus ) 				#nameKey: #alignRightID 				#value: #alignRight 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #alignRight ) 				#helpText: #(#{Kernel.UserMessage} #key: #AlignRight #defaultString: 'Align Right' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #verticalEqualSpacing 					#defaultString: 'Vertical Equal Spacing' 					#catalogID: #menus ) 				#nameKey: #distributeTTBEdgesID 				#value: #distributeTTBEdges 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #verticalSpacing ) 				#helpText: #(#{Kernel.UserMessage} #key: #EqualVerticalSpacing #defaultString: 'Equal Vertical Spacing' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #verticalEqualDistribution 					#defaultString: 'Vertical Equal Distribution' 					#catalogID: #menus ) 				#nameKey: #distributeTTBCentersID 				#value: #distributeTTBCenters 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #verticalDistribution ) 				#helpText: #(#{Kernel.UserMessage} #key: #EqualVerticalDistribution #defaultString: 'Equal Vertical Distribution' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #horizontalEqualSpacing 					#defaultString: 'Horizontal Equal Spacing' 					#catalogID: #menus ) 				#nameKey: #distributeLTREdgesID 				#value: #distributeLTREdges 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #horizontalSpacing ) 				#helpText: #(#{Kernel.UserMessage} #key: #EqualHorizontalSpacing #defaultString: 'Equal Horizontal Spacing' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #horizontalEqualDistribution 					#defaultString: 'Horizontal Equal Distribution' 					#catalogID: #menus ) 				#nameKey: #distributeLTRCentersID 				#value: #distributeLTRCenters 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #horizontalDistribution ) 				#helpText: #(#{Kernel.UserMessage} #key: #EqualHorizontalDistribution #defaultString: 'Equal Horizontal Distribution' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #equalizeHeight 					#defaultString: 'Equalize Height' 					#catalogID: #menus ) 				#nameKey: #equalizeHeightID 				#value: #equalizeHeight 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #equalHeight ) 				#helpText: #(#{Kernel.UserMessage} #key: #SameHeight #defaultString: 'Same Height' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #equalizeWidth 					#defaultString: 'Equalize Width' 					#catalogID: #menus ) 				#nameKey: #equalizeWidthD 				#value: #equalizeWidth 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #equalWidth ) 				#helpText: #(#{Kernel.UserMessage} #key: #SameWidth #defaultString: 'Same Width' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #equalizeBoth 					#defaultString: 'Equalize Both' 					#catalogID: #menus ) 				#nameKey: #equalizeBoth 				#value: #equalizeBoth 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #equalBoth ) 				#helpText: #(#{Kernel.UserMessage} #key: #SameHeight_Width #defaultString: 'Same Height &amp; Width' #catalogID: #UIPainter) ) ) #(2 3 3 4 3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.UIPalette class</class-id> <category>interface specs</category><body package="UIPainter">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #Palette 				#defaultString: 'Palette' 				#catalogID: #UIPainter ) 			#min: #(#{Core.Point} 527 131 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 381 430 908 561 ) 			#flags: 4 			#menu: #mainMenu 			#toolBar: #paletteToolBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 2 0 -2 1 -28 1 ) 					#name: #iconView 					#flags: 40 					#colors: 					#(#{UI.LookPreferences} 						#setSelectionBackgroundColor: #(#{Graphics.ColorValue} #black ) ) 					#component: #iconView ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -26 1 -120 1 0 1 ) 					#name: #toolName 					#model: #toolName 					#tabable: false 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #CurrentlySelectedWidget 						#defaultString: 'Currently Selected Widget' 						#catalogID: #UIPainter ) 					#alignment: #center 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} -118 1 -26 1 0 1 0 1 ) 					#name: #InputField1 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} 7550 0 0 ) ) 					#model: #stickyStatus 					#tabable: false 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #CurrentStickyMode 						#defaultString: 'Current Sticky Mode' 						#catalogID: #UIPainter ) 					#alignment: #center 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>Tools.UIPainterTool class</class-id> <category>resources</category><body package="UIPainter">arrangeMenu	"MenuEditor new openOnClass: self andSelector: #arrangeMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Sna_pToGrid #defaultString: 'Sna&amp;p To Grid' #catalogID: #UIPainter) 				#value: #snapToGrid ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Group #defaultString: '&amp;Group' #catalogID: #UIPainter) 				#nameKey: #doGroup				#value: #doGroup ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Ungroup #defaultString: '&amp;Ungroup' #catalogID: #UIPainter) 				#nameKey: #doUngroup				#value: #doUngroup ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_BringToFront #defaultString: '&amp;Bring To Front' #catalogID: #UIPainter) 				#value: #toVisualFront 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #sendToTop ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Bring_Forward #defaultString: 'Bring &amp;Forward' #catalogID: #UIPainter) 				#value: #toVisualFrontOne 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #sendForwardOne ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_SendToBack #defaultString: '&amp;Send To Back' #catalogID: #UIPainter) 				#value: #toVisualBack 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #sendToBottom ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #SendBack_ward #defaultString: 'Send Back&amp;ward' #catalogID: #UIPainter) 				#value: #toVisualBackOne 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #sendBackOne ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Align #defaultString: '&amp;Align...' #catalogID: #UIPainter) 				#nameKey: #alignDialog				#value: #alignDialog ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Distribute #defaultString: '&amp;Distribute...' #catalogID: #UIPainter) 				#nameKey: #distributeDialog				#value: #distributeDialog ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Equalize #defaultString: '&amp;Equalize...' #catalogID: #UIPainter) 				#nameKey: #equalizeDialog				#value: #equalizeDialog ) ) #(1 2 4 3 ) nil ) decodeAsLiteralArray</body><body package="UIPainter">editMenu	"Tools.MenuEditor new openOnClass: self andSelector: #editMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_CopyWidget 					#defaultString: '&amp;Copy Widget' 					#catalogID: #UIPainter ) 				#value: #doCopy 				#shortcutKeyCharacter: $C 				#shortcutModifiers: 3 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cu_tWidget 					#defaultString: 'Cu&amp;t Widget' 					#catalogID: #UIPainter ) 				#value: #doCut 				#shortcutKeyCharacter: $X 				#shortcutModifiers: 3 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_PasteWidget 					#defaultString: '&amp;Paste Widget' 					#catalogID: #UIPainter ) 				#value: #doPaste 				#shortcutKeyCharacter: $V 				#shortcutModifiers: 3 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Install 					#defaultString: '&amp;Install' 					#catalogID: #UIPainter ) 				#nameKey: #doInstall 				#value: #doInstall 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #installWindow ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Define 					#defaultString: '&amp;Define' 					#catalogID: #UIPainter ) 				#nameKey: #doDefine 				#value: #doDefine 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #defineGUIMethods ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Browse 					#defaultString: '&amp;Browse' 					#catalogID: #UIPainter ) 				#nameKey: #doBrowse 				#value: #doBrowse 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #browseAppModel ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Open 					#defaultString: '&amp;Open' 					#catalogID: #UIPainter ) 				#nameKey: #doOpen 				#value: #doOpen 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #openWindow ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_BookmarkCanvas 					#defaultString: '&amp;Bookmark Canvas' 					#catalogID: #UIPainter ) 				#value: #doAccept 				#shortcutKeyCharacter: $B 				#shortcutModifiers: 8 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_RestoreFromBookmark 					#defaultString: '&amp;Restore From Bookmark' 					#catalogID: #UIPainter ) 				#shortcutKeyCharacter: $X 				#shortcutModifiers: 0 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Confirm 								#defaultString: 'Confirm' 								#catalogID: #UIPainter ) 							#value: #doCancel 							#shortcutKeyCharacter: $X 							#shortcutModifiers: 8 ) ) #(1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Spawn 					#defaultString: '&amp;Spawn' 					#catalogID: #UIPainter ) 				#nameKey: #doSpawn 				#value: #doSpawn 				#shortcutKeyCharacter: $N 				#shortcutModifiers: 8 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #NameAll_UnnamedWidgets 					#defaultString: 'Name All &amp;Unnamed Widgets' 					#catalogID: #UIPainter ) 				#nameKey: #doNameAll 				#value: #doNameAll ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Named_Fonts 					#defaultString: 'Named &amp;Fonts' 					#catalogID: #UIPainter ) 				#shortcutKeyCharacter: $F 				#shortcutModifiers: 8 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_DefineNamedFonts 								#defaultString: '&amp;Define Named Fonts' 								#catalogID: #UIPainter ) 							#nameKey: #doNamedFonts 							#value: #doNamedFonts 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #namedFonts ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_FileOut 								#defaultString: '&amp;File Out...' 								#catalogID: #UIPainter ) 							#value: #doFileOutNamedFonts ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_InstallInApplication 								#defaultString: '&amp;Install In Application...' 								#catalogID: #UIPainter ) 							#nameKey: #doInstallNamedFonts 							#value: #doInstallNamedFonts ) ) #(3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Catalo_g 					#defaultString: 'Catalo&amp;g...' 					#catalogID: #UIPainter ) 				#nameKey: #doCatalogID 				#value: #doCatalogID 				#shortcutKeyCharacter: $C 				#shortcutModifiers: 9 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Close_PainterTool 					#defaultString: 'Close &amp;Painter Tool' 					#catalogID: #UIPainter ) 				#nameKey: #doClosePainter 				#value: #doClosePainter ) ) #(3 4 2 2 2 1 ) nil ) decodeAsLiteralArray</body><body package="UIPainter">gridMenu	"MenuEditor new openOnClass: self andSelector: #gridMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_On #defaultString: '&amp;On' #catalogID: #UIPainter) 				#nameKey: #gridOn				#value: #gridOn ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #O_ff #defaultString: 'O&amp;ff' #catalogID: #UIPainter) 				#nameKey: #gridOff				#value: #gridOff ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_XOnly #defaultString: '&amp;X Only' #catalogID: #UIPainter) 				#nameKey: #gridXOnly				#value: #gridXOnly ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_YOnly #defaultString: '&amp;Y Only' #catalogID: #UIPainter) 				#nameKey: #gridYOnly				#value: #gridYOnly ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Hide #defaultString: '&amp;Hide' #catalogID: #UIPainter) 				#nameKey: #gridHide				#value: #gridHide ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Show #defaultString: '&amp;Show' #catalogID: #UIPainter) 				#nameKey: #gridShow				#value: #gridShow ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Show_IfOn #defaultString: 'Show &amp;If On' #catalogID: #UIPainter) 				#nameKey: #gridShowIfOn				#value: #gridShowIfOn ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #GridSize_2 #defaultString: 'Grid Size &amp;2' #catalogID: #UIPainter) 				#nameKey: #gridSize2				#value: #gridSize2 ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #GridSize_4 #defaultString: 'Grid Size &amp;4' #catalogID: #UIPainter) 				#nameKey: #gridSize4				#value: #gridSize4 ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #GridSize_8 #defaultString: 'Grid Size &amp;8' #catalogID: #UIPainter) 				#nameKey: #gridSize8				#value: #gridSize8 ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_GridSize #defaultString: '&amp;Grid Size ...' #catalogID: #UIPainter) 				#nameKey: #gridSizeDialog				#value: #gridSizeDialog ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #KeepInWindow #defaultString: 'Keep In Window' #catalogID: #UIPainter) 				#nameKey: #keepInWindow				#value: #keepInWindow ) ) #(4 3 4 1 ) nil ) decodeAsLiteralArray</body><body package="UIPainter">helpMenu	"Tools.MenuEditor new openOnClass: self andSelector: #helpMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_GUIPainterTool 					#defaultString: '&amp;GUI Painter Tool' 					#catalogID: #UIPainter ) 				#value: #helpGUIPainterTool 				#shortcutKeyCharacter: #F1 				#shortcutModifiers: 0 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #help ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_UserInterfacePainter 					#defaultString: '&amp;User Interface Painter' 					#catalogID: #UIPainter ) 				#value: #helpUserInterfacePainter ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ComposingWindows 					#defaultString: '&amp;Composing Windows' 					#catalogID: #UIPainter ) 				#value: #helpComposingWindows ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_AboutVisualWorksDot					#defaultString: '&amp;About VisualWorks...' 					#catalogID: #UIPainter ) 				#value: #helpAbout ) ) #(3 1 ) nil ) decodeAsLiteralArray</body><body package="UIPainter">layoutMenu	"MenuEditor new openOnClass: self andSelector: #layoutMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Fixed #defaultString: '&amp;Fixed' #catalogID: #UIPainter) 				#nameKey: #beFixed				#value: #beFixed ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Relative #defaultString: '&amp;Relative' #catalogID: #UIPainter) 				#nameKey: #beRelative				#value: #beRelative ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Constrained #defaultString: '&amp;Constrained...' #catalogID: #UIPainter) 				#nameKey: #fractionalConstraintDialog				#value: #fractionalConstraintDialog ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Be_Bounded #defaultString: 'Be &amp;Bounded' #catalogID: #UIPainter) 				#nameKey: #doMakeBounded				#value: #doMakeBounded ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Be_Unbounded #defaultString: 'Be &amp;Unbounded' #catalogID: #UIPainter) 				#nameKey: #doMakeUnBounded				#value: #doMakeUnBounded ) ) #(3 2 ) nil ) decodeAsLiteralArray</body><body package="UIPainter">nullMenu	"MenuEditor new openOnClass: self andSelector: #nullMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'null' 				#enabled: false 				#value: #menu ) ) #(1 ) nil ) decodeAsLiteralArray</body><body package="UIPainter">painterToolBar	"MenuEditor new openOnClass: self andSelector: #painterToolBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Install #defaultString: 'Install' #catalogID: #UIPainter) 				#nameKey: #doInstall 				#value: #doInstall 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #installWindow ) 				#helpText: #(#{Kernel.UserMessage} #key: #Install #defaultString: 'Install' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Define #defaultString: 'Define' #catalogID: #UIPainter) 				#nameKey: #doDefine 				#value: #doDefine 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #defineGUIMethods ) 				#helpText: #(#{Kernel.UserMessage} #key: #Define #defaultString: 'Define' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Browse #defaultString: 'Browse' #catalogID: #UIPainter) 				#nameKey: #doBrowse 				#value: #doBrowse 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #browseAppModel ) 				#helpText: #(#{Kernel.UserMessage} #key: #Browse #defaultString: 'Browse' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Open #defaultString: 'Open' #catalogID: #UIPainter) 				#nameKey: #doOpen 				#value: #doOpen 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #openWindow ) 				#helpText: #(#{Kernel.UserMessage} #key: #OpenWindow #defaultString: 'Open Window' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #BringToFront #defaultString: 'Bring To Front' #catalogID: #UIPainter) 				#nameKey: #toVisualFront 				#value: #toVisualFront 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #sendToTop ) 				#helpText: #(#{Kernel.UserMessage} #key: #GenKey149 #defaultString: 'Bring Widget To Visual Front/Last In Tab Order' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #BringForward #defaultString: 'Bring Forward' #catalogID: #UIPainter) 				#nameKey: #toVisualFrontOne 				#value: #toVisualFrontOne 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #sendForwardOne ) 				#helpText: #(#{Kernel.UserMessage} #key: #GenKey148 #defaultString: 'Bring Widget Forward Visually/Lower In Tab Order' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #SendBackward #defaultString: 'Send Backward' #catalogID: #UIPainter) 				#nameKey: #toVisualBackOne 				#value: #toVisualBackOne 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #sendBackOne ) 				#helpText: #(#{Kernel.UserMessage} #key: #GenKey147 #defaultString: 'Send Widget Backward Visually/Higher In Tab Order' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #SendToBack #defaultString: 'Send To Back' #catalogID: #UIPainter) 				#nameKey: #toVisualBack 				#value: #toVisualBack 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #sendToBottom ) 				#helpText: #(#{Kernel.UserMessage} #key: #GenKey146 #defaultString: 'Send Widget To Visual Back/First In Tab Order' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #NamedFonts #defaultString: 'Named Fonts' #catalogID: #UIPainter) 				#nameKey: #doNamedFonts 				#value: #doNamedFonts 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #namedFonts ) 				#helpText: #(#{Kernel.UserMessage} #key: #DefineNamedFonts #defaultString: 'Define Named Fonts' #catalogID: #UIPainter) ) ) #(4 4 1 ) nil ) decodeAsLiteralArray</body><body package="UIPainter">toolsMenu	"MenuEditor new openOnClass: self andSelector: #toolsMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Palette #defaultString: '&amp;Palette' #catalogID: #UIPainter) 				#value: #doPalette ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_ImageEditor #defaultString: '&amp;Image Editor' #catalogID: #UIPainter) 				#value: #maskEditor ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_MenuEditor #defaultString: '&amp;Menu Editor' #catalogID: #UIPainter) 				#value: #menuEditor ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_HotRegionsEditor #defaultString: '&amp;Hot Regions Editor' #catalogID: #UIPainter) 				#value: #regionsEditor ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #GenKey150 #defaultString: '&amp;Reusable Data Form Components' #catalogID: #UIPainter) 				#enabled: false 				#nameKey: #openReusableComponents				#value: #openReusableComponents ) ) #(1 3 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.UIPainterTool class</class-id> <category>interface specs</category><body package="UIPainter">changeDialog	"UIPainter new openOnClass: self andSelector: #changeDialog"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #ApplyChanges #defaultString: 'Apply Changes?' #catalogID: #UIPainter) 			#bounds: #(#{Graphics.Rectangle} 646 522 955 679 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 -39 1 75 0 -9 1 ) 					#model: #apply 					#label: #(#{Kernel.UserMessage} #key: #Apply #defaultString: 'Apply' #catalogID: #UIPainter) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -77 1 -39 1 -12 1 -9 1 ) 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #UIPainter) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 5 0 -4 1 25 0 ) 					#label: #(#{Kernel.UserMessage} #key: #GenKey145 #defaultString: 'Properties have been changed but' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 25 0 -4 1 45 0 ) 					#label: #(#{Kernel.UserMessage} #key: #notApplied #defaultString: 'not applied.' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 50 0 -4 1 70 0 ) 					#label: #(#{Kernel.UserMessage} #key: #PressApplyToApplyChanges #defaultString: 'Press Apply to apply changes.' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 75 0 -4 1 95 0 ) 					#label: #(#{Kernel.UserMessage} #key: #GenKey144 #defaultString: 'Press Cancel to discard changes.' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">helpConstructorSpec	"UIPainter new openOnClass: self andSelector: #helpConstructorSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 288 292 ) 			#max: #(#{Core.Point} 288 292 ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1088 892 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0 27 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #HelpTextC #defaultString: 'Help Text:' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 88 0 27 0 0 1 ) 					#name: #helpSuppliedByBuilder 					#model: #helpSuppliedByBuilder 					#label: #(#{Kernel.UserMessage} #key: #SuppliedByApplication #defaultString: 'Supplied by Application' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 15 0 56 0 0 1 ) 					#name: #helpDefaultLbl 					#label: #(#{Kernel.UserMessage} #key: #Default #defaultString: 'Default:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 15 0 87 0 0 1 ) 					#name: #helpLookupLbl 					#label: #(#{Kernel.UserMessage} #key: #LookupKeyC #defaultString: 'Lookup key:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 15 0 149 0 0 1 ) 					#name: #helpMessageLbl 					#label: #(#{Kernel.UserMessage} #key: #Message #defaultString: 'Message:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 15 93 ) 					#name: #helpCatalogLbl					#label: #(#{Kernel.UserMessage} #key: #CatalogC #defaultString: 'Catalog:' #catalogID: #UIPainter) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 100 0 31 0 0 1.0 56 0 ) 					#name: #helpDefault 					#model: #helpLabelString 					#menu: #fieldMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 100 0 62 0 0 1.0 87 0 ) 					#name: #helpLabel 					#model: #helpLabelKey 					#menu: #fieldMenu 					#type: #i18nkey ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 100 0 93 0 0 1.0 118 0 ) 					#name: #helpCatalog 					#model: #helpCatalog 					#menu: #fieldMenu 					#type: #symbol ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 100 0 124 0 0 1.0 149 0 ) 					#name: #helpMessage 					#model: #helpLabelMessage 					#menu: #fieldMenu 					#type: #symbol ) ) ) )</body><body package="UIPainter">labelConstructorSpec	"UIPainter new openOnClass: self andSelector: #labelConstructorSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 288 292 ) 			#max: #(#{Core.Point} 288 292 ) 			#bounds: #(#{Graphics.Rectangle} 656 454 944 746 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0 27 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #LabelC #defaultString: 'Label:' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 76 0 27 0 0 1 ) 					#name: #suppliedByBuilder 					#model: #suppliedByBuilder 					#label: #(#{Kernel.UserMessage} #key: #SuppliedByApplication #defaultString: 'Supplied by Application' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0 58 0 0 1 ) 					#name: #defaultLbl 					#label: #(#{Kernel.UserMessage} #key: #StringC #defaultString: 'String:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0 89 0 0 1 ) 					#name: #catalogLbl 					#label: #(#{Kernel.UserMessage} #key: #LookupKeyC #defaultString: 'Lookup key:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0 120 0 0 1 ) 					#name: #messageLbl 					#label: #(#{Kernel.UserMessage} #key: #CatalogC #defaultString: 'Catalog:' #catalogID: #UIPainter) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 76 0 31 0 0 1 56 0 ) 					#name: #default 					#model: #labelString 					#menu: #fieldMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 76 0 62 0 0 1 87 0 ) 					#name: #catalog 					#model: #labelKey 					#menu: #fieldMenu 					#type: #i18nkey ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 76 0 93 0 0 1 118 0 ) 					#name: #message 					#model: #labelMessage 					#menu: #fieldMenu 					#type: #symbol ) ) ) )</body><body package="UIPainter">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #GUIPainterTool 				#defaultString: 'GUI Painter Tool' 				#catalogID: #UIPainter ) 			#min: #(#{Core.Point} 447 415 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 1056 513 1656 1113 ) 			#flags: 4 			#menu: #painterMenu 			#toolBar: #painterToolBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.33 2 0 -2 1 -39 1 ) 					#name: #specCanvas 					#model: #sliceMasterList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: #validateChangeOfPage ) 					#labels: #() ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 2 0.33 -32 1 54 30 ) 					#name: #applyButton 					#model: #apply 					#label: 					#(#{Kernel.UserMessage} 						#key: #Apply 						#defaultString: 'Apply' 						#catalogID: #UIPainter ) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 56 0.33 -32 1 54 30 ) 					#name: #readButton 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #UIPainter ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -110 1 -32 1 -56 1 -2 1 ) 					#name: #prevButton 					#model: #selectPrev 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #Prev 						#defaultString: 'Prev' 						#catalogID: #UIPainter ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -56 1 -32 1 -2 1 -2 1 ) 					#name: #nextButton 					#model: #selectNext 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #Next 						#defaultString: 'Next' 						#catalogID: #UIPainter ) 					#defaultable: true ) 				#(#{UI.TreeViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 2 0 -2 0.33 -2 1 ) 					#name: #canvasTree 					#model: #canvasTree 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #treeSelectionChange 						#requestValueChangeSelector: #completeWorkOnPreviousSelection ) 					#multipleSelections: true 					#style: #system 					#useModifierKeys: true 					#selectionType: #highlight 					#displayStringSelector: #painterName 					#useIcons: #other 					#iconSelectors: #(#iconForWidgetTree ) ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.33 -2 0 2 0.33 2 1 ) 					#name: #ResizingSplitter1 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 220 					#aboveWidgets: 'canvasTree' 					#belowWidgets: 'specCanvas applyButton readButton' ) ) ) )</body></methods><methods><class-id>Tools.MenuEditor class</class-id> <category>resources</category><body package="UIPainter">CaddBelowImage	"UIMaskEditor new openOnClass: self andSelector: #CaddBelowImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: ColorValue yellow; at: 3 put: ColorValue lightGray; at: 4 put: (ColorValue scaledRed: 0 scaledGreen: 4112 scaledBlue: 0); yourself)) usingBits: #[170 170 170 170 170 170 0 0 170 170 170 170 170 170 0 0 170 170 175 255 255 234 0 0 170 170 175 255 255 234 0 0 170 170 170 170 170 170 0 0 170 170 170 170 170 170 0 0 170 170 175 255 255 234 0 0 160 170 175 255 255 234 0 0 160 170 170 170 170 170 0 0 160 138 170 170 170 170 0 0 160 162 170 170 170 170 0 0 160 0 165 85 85 106 0 0 160 0 165 85 85 106 0 0 170 162 170 170 170 170 0 0 170 138 170 170 170 170 0 0 170 170 170 170 170 170 0 0 170 170 175 255 255 234 0 0 170 170 175 255 255 234 0 0 170 170 170 170 170 170 0 0 170 170 170 170 170 170 0 0 170 170 175 255 255 234 0 0 170 170 175 255 255 234 0 0 170 170 170 170 170 170 0 0 170 170 170 170 170 170 0 0])</body><body package="UIPainter">CaddChildImage	"UIMaskEditor new openOnClass: self andSelector: #CaddChildImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue yellow; at: 2 put: ColorValue lightGray; at: 3 put: (ColorValue scaledRed: 0 scaledGreen: 4112 scaledBlue: 0); yourself)) usingBits: #[85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0 85 106 170 170 85 85 0 0 85 106 170 170 85 85 0 0 85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0 85 106 170 170 85 85 0 0 85 106 170 170 85 85 0 0 85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0 85 85 80 0 0 21 0 0 85 85 80 0 0 21 0 0 85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0 85 106 170 170 85 85 0 0 85 106 170 170 85 85 0 0 85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0 85 106 170 170 85 85 0 0 85 106 170 170 85 85 0 0 85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0])</body><body package="UIPainter">CaddLineImage	"UIMaskEditor new openOnClass: self andSelector: #CaddLineImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue lightGray; at: 3 put: (ColorValue scaledRed: 0 scaledGreen: 4112 scaledBlue: 0); yourself)) usingBits: #[85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0 85 85 90 170 170 149 0 0 85 85 90 170 170 149 0 0 85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0 85 85 90 170 170 149 0 0 80 85 90 170 170 149 0 0 80 85 85 85 85 85 0 0 80 69 85 85 85 85 0 0 80 81 85 85 85 85 0 0 80 0 80 0 0 21 0 0 80 0 85 85 85 85 0 0 85 81 85 85 85 85 0 0 85 69 85 85 85 85 0 0 85 85 85 85 85 85 0 0 85 85 90 170 170 149 0 0 85 85 90 170 170 149 0 0 85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0 85 85 90 170 170 149 0 0 85 85 90 170 170 149 0 0 85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0])</body><body package="UIPainter">CapplyImage	"UIMaskEditor new openOnClass: self andSelector: #CapplyImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 5) at: 1 put: ColorValue black; at: 2 put: ColorValue yellow; at: 3 put: ColorValue lightGray; at: 4 put: (ColorValue scaledRed: 0 scaledGreen: 4112 scaledBlue: 0); at: 5 put: ColorValue white; yourself)) usingBits: (ByteArray fromPackedString: 'H"H"H"H"H"H"H"H"L3L3L2H"H"H"H"H"H"H"H"H"H"H"H"H"L3L3L2H"H"H"H"H"H"H"H"H"H"H"H"H"L3L3L2H"H"H"H"H"H"H"H"H"H"H"H"H"L3L3L2HBH H"H"H"H"H"H"@@H H"H"H"L3L3L2H@@ H"H"H"H"H"H"H @@H"H"H"L3L3L2H"@@H"H"H"H"H"H"@@@@H"H"H"H"H"H"H"H"H@@"H"H"H"H"H"H"H H"H"H"H"H"H"H@@@@@@"H"H"H"H"H EAPT@"H"H"H"H"H @TEAPBH"H"H"H"H"AAPTE@H"H"H"H"H"@DEA@@H"H"H"H"H"HAP@@"H"H"H"H"H"H@@B@"H"H"H"H"H"H HBHBH"H"H"H"H"H"HBH"'))</body><body package="UIPainter">CdownArrowImage	"UIMaskEditor new openOnClass: self andSelector: #CdownArrowImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue lightGray; at: 3 put: (ColorValue scaledRed: 0 scaledGreen: 4112 scaledBlue: 0); yourself)) usingBits: #[85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0 85 85 0 1 85 85 0 0 85 85 42 161 85 85 0 0 85 85 42 161 85 85 0 0 85 85 42 161 85 85 0 0 85 85 42 161 85 85 0 0 85 85 42 161 85 85 0 0 85 85 42 161 85 85 0 0 85 85 42 161 85 85 0 0 85 85 42 161 85 85 0 0 85 85 42 161 85 85 0 0 84 0 42 160 0 85 0 0 85 42 170 170 161 85 0 0 85 74 170 170 133 85 0 0 85 82 170 170 21 85 0 0 85 84 170 168 85 85 0 0 85 85 42 161 85 85 0 0 85 85 74 133 85 85 0 0 85 85 82 21 85 85 0 0 85 85 84 85 85 85 0 0 85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0])</body><body package="UIPainter">CleftArrowImage	"UIMaskEditor new openOnClass: self andSelector: #CleftArrowImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue lightGray; at: 3 put: (ColorValue scaledRed: 0 scaledGreen: 4112 scaledBlue: 0); yourself)) usingBits: #[85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0 85 85 81 85 85 85 0 0 85 85 65 85 85 85 0 0 85 85 33 85 85 85 0 0 85 84 161 85 85 85 0 0 85 82 161 85 85 85 0 0 85 74 160 0 0 21 0 0 85 42 170 170 170 21 0 0 84 170 170 170 170 21 0 0 82 170 170 170 170 21 0 0 84 170 170 170 170 21 0 0 85 42 170 170 170 21 0 0 85 74 160 0 0 21 0 0 85 82 161 85 85 85 0 0 85 84 161 85 85 85 0 0 85 85 33 85 85 85 0 0 85 85 65 85 85 85 0 0 85 85 81 85 85 85 0 0 85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0])</body><body package="UIPainter">CrightArrowImage	"UIMaskEditor new openOnClass: self andSelector: #CrightArrowImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue lightGray; at: 3 put: (ColorValue scaledRed: 0 scaledGreen: 4112 scaledBlue: 0); yourself)) usingBits: #[85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0 85 85 85 69 85 85 0 0 85 85 85 65 85 85 0 0 85 85 85 72 85 85 0 0 85 85 85 74 21 85 0 0 85 85 85 74 133 85 0 0 84 0 0 10 161 85 0 0 84 170 170 170 168 85 0 0 84 170 170 170 170 21 0 0 84 170 170 170 170 133 0 0 84 170 170 170 170 21 0 0 84 170 170 170 168 85 0 0 84 0 0 10 161 85 0 0 85 85 85 74 133 85 0 0 85 85 85 74 21 85 0 0 85 85 85 72 85 85 0 0 85 85 85 65 85 85 0 0 85 85 85 69 85 85 0 0 85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0])</body><body package="UIPainter">CupArrowImage	"UIMaskEditor new openOnClass: self andSelector: #CupArrowImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue lightGray; at: 3 put: (ColorValue scaledRed: 0 scaledGreen: 4112 scaledBlue: 0); yourself)) usingBits: #[85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0 85 85 84 85 85 85 0 0 85 85 82 21 85 85 0 0 85 85 74 133 85 85 0 0 85 85 42 161 85 85 0 0 85 84 170 168 85 85 0 0 85 82 170 170 21 85 0 0 85 74 170 170 133 85 0 0 85 42 170 170 161 85 0 0 84 0 42 160 0 85 0 0 85 85 42 161 85 85 0 0 85 85 42 161 85 85 0 0 85 85 42 161 85 85 0 0 85 85 42 161 85 85 0 0 85 85 42 161 85 85 0 0 85 85 42 161 85 85 0 0 85 85 42 161 85 85 0 0 85 85 42 161 85 85 0 0 85 85 42 161 85 85 0 0 85 85 0 1 85 85 0 0 85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0 85 85 85 85 85 85 0 0])</body><body package="UIPainter">editingMenuBar	"MenuEditor new openOnClass: self andSelector: #editingMenuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Men_u #defaultString: '&amp;Men&amp;u' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_New #defaultString: '&amp;New' #catalogID: #UIPainter) 							#value: #newMenu 							#shortcutKeyCharacter: $N 							#shortcutModifiers: 8 ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_LoadDot #defaultString: '&amp;Load...' #catalogID: #UIPainter) 							#value: #load 							#shortcutKeyCharacter: $O 							#shortcutModifiers: 2 ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_InstallDot #defaultString: '&amp;Install...' #catalogID: #UIPainter) 							#value: #install 							#shortcutKeyCharacter: $C 							#shortcutModifiers: 8 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #installMenu ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_Read #defaultString: '&amp;Read' #catalogID: #UIPainter) 							#value: #read ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_ApplyDot #defaultString: '&amp;Apply...' #catalogID: #UIPainter) 							#value: #apply ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_Close #defaultString: '&amp;Close' #catalogID: #UIPainter) 							#value: #closeRequest 							#shortcutKeyCharacter: $Q 							#shortcutModifiers: 8 ) ) #(3 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Edit #defaultString: '&amp;Edit' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_NewItem #defaultString: '&amp;New Item' #catalogID: #UIPainter) 							#value: #addBelow 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #newMenuItem ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #New_Separator #defaultString: 'New &amp;Separator' #catalogID: #UIPainter) 							#value: #addLine 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #newMenuSeparator ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #NewS_ubmenuItem #defaultString: 'New S&amp;ubmenu Item' #catalogID: #UIPainter) 							#value: #addChild 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #newSubmenuItem ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Cu_tItem #defaultString: 'Cu&amp;t Item' #catalogID: #UIPainter) 							#value: #cutItem 							#shortcutKeyCharacter: $X 							#shortcutModifiers: 3 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #cut ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_CopyItem #defaultString: '&amp;Copy Item' #catalogID: #UIPainter) 							#value: #copyItem 							#shortcutKeyCharacter: $C 							#shortcutModifiers: 3 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copy ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_PasteItem #defaultString: '&amp;Paste Item' #catalogID: #UIPainter) 							#nameKey: #'$p' 							#value: #pasteBelow 							#shortcutKeyCharacter: $V 							#shortcutModifiers: 3 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #paste ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_DeleteItem #defaultString: '&amp;Delete Item' #catalogID: #UIPainter) 							#nameKey: #'''$d''' 							#value: #removeSelection 							#shortcutKeyCharacter: $D 							#shortcutModifiers: 3 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #delete ) ) ) #(3 4 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Move #defaultString: '&amp;Move' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_Up #defaultString: '&amp;Up' #catalogID: #UIPainter) 							#value: #shiftUp 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemUp ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_Down #defaultString: '&amp;Down' #catalogID: #UIPainter) 							#value: #shiftDown 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemDown ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_Right #defaultString: '&amp;Right' #catalogID: #UIPainter) 							#value: #shiftRight 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemRight ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_Left #defaultString: '&amp;Left' #catalogID: #UIPainter) 							#value: #shiftLeft 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemLeft ) ) ) #(4 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #V_iew #defaultString: 'V&amp;iew' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_SampleMenuBar #defaultString: '&amp;Sample Menu Bar' #catalogID: #UIPainter) 							#value: #showMenuBar ) ) #(1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Test #defaultString: '&amp;Test' #catalogID: #UIPainter) 				#nameKey: #testItem ) ) #(5 ) nil ) decodeAsLiteralArray</body><body package="UIPainter">inputBaseMenu	"Tools.MenuEditor new openOnClass: self andSelector: #commandGroupMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#commandID: #accept 				#value: #accept ) 			#(#{UI.MenuItem} 				#commandID: #cut 				#value: #cut ) 			#(#{UI.MenuItem} 				#commandID: #copy 				#value: #copy ) 			#(#{UI.MenuItem} 				#commandID: #paste 				#value: #paste ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cancel 					#defaultString: 'Cancel' 					#catalogID: #menus ) 				#value: #cancel ) ) #(1 3 1 ) nil ) decodeAsLiteralArray</body><body package="UIPainter">itemsMenu	"Tools.MenuEditor new openOnClass: self andSelector: #itemsMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cut 					#defaultString: 'Cut' 					#catalogID: #UIPainter ) 				#value: #cutItem 				#shortcutKeyCharacter: $X 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #cut ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Copy 					#defaultString: 'Copy' 					#catalogID: #UIPainter ) 				#value: #copyItem 				#shortcutKeyCharacter: $C 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Paste 					#defaultString: 'Paste' 					#catalogID: #UIPainter ) 				#value: #pasteBelow 				#shortcutKeyCharacter: $V 				#shortcutModifiers: 2 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #paste ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Delete 					#defaultString: 'Delete' 					#catalogID: #UIPainter ) 				#value: #removeSelection 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #delete ) ) ) #(3 1 ) nil ) decodeAsLiteralArray</body><body package="UIPainter">toolBar	"MenuEditor new openOnClass: self andSelector: #toolBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Install #defaultString: 'Install' #catalogID: #UIPainter) 				#nameKey: #install 				#value: #install 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #installMenu ) 				#helpText: #(#{Kernel.UserMessage} #key: #Install #defaultString: 'Install' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #InsertItem #defaultString: 'Insert Item' #catalogID: #UIPainter) 				#nameKey: #addBelow 				#value: #addBelow 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #newMenuItem ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #insertItem 					#defaultString: 'Insert Item' 					#catalogID: #menus ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #InsertSeparator #defaultString: 'Insert Separator' #catalogID: #UIPainter) 				#nameKey: #addLine 				#value: #addLine 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #newMenuSeparator ) 				#helpText: #(#{Kernel.UserMessage} #key: #InsertSeparator #defaultString: 'Insert Separator' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #InsertSubmenuItem #defaultString: 'Insert Submenu Item' #catalogID: #UIPainter) 				#nameKey: #addChild 				#value: #addChild 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #newSubmenuItem ) 				#helpText: #(#{Kernel.UserMessage} #key: #InsertSubmenuItem #defaultString: 'Insert Submenu Item' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #CutItem #defaultString: 'Cut Item' #catalogID: #UIPainter) 				#nameKey: #cutItem 				#value: #cutItem 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #cut ) 				#helpText: #(#{Kernel.UserMessage} #key: #CutItem #defaultString: 'Cut Item' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #CopyItem #defaultString: 'Copy Item' #catalogID: #UIPainter) 				#nameKey: #copyItem 				#value: #copyItem 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copy ) 				#helpText: #(#{Kernel.UserMessage} #key: #CopyItem #defaultString: 'Copy Item' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #PasteItem #defaultString: 'Paste Item' #catalogID: #UIPainter) 				#nameKey: #pasteBelow 				#value: #pasteBelow 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #paste ) 				#helpText: #(#{Kernel.UserMessage} #key: #PasteItem #defaultString: 'Paste Item' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #DeleteItem #defaultString: 'Delete Item' #catalogID: #UIPainter) 				#nameKey: #removeSelection 				#value: #removeSelection 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #delete ) 				#helpText: #(#{Kernel.UserMessage} #key: #DeleteItem #defaultString: 'Delete Item' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #MoveUp #defaultString: 'Move Up' #catalogID: #UIPainter) 				#nameKey: #shiftUp 				#value: #shiftUp 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemUp ) 				#helpText: #(#{Kernel.UserMessage} #key: #MoveUp #defaultString: 'Move Up' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #MoveDown #defaultString: 'Move Down' #catalogID: #UIPainter) 				#nameKey: #shiftDown 				#value: #shiftDown 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemDown ) 				#helpText: #(#{Kernel.UserMessage} #key: #MoveDown #defaultString: 'Move Down' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #MoveRight #defaultString: 'Move Right' #catalogID: #UIPainter) 				#nameKey: #shiftRight 				#value: #shiftRight 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemRight ) 				#helpText: #(#{Kernel.UserMessage} #key: #MoveRight #defaultString: 'Move Right' #catalogID: #UIPainter) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #MoveLeft #defaultString: 'Move Left' #catalogID: #UIPainter) 				#nameKey: #shiftLeft 				#value: #shiftLeft 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #moveMenuItemLeft ) 				#helpText: #(#{Kernel.UserMessage} #key: #MoveLeft #defaultString: 'Move Left' #catalogID: #UIPainter) ) ) #(1 3 4 4 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.MenuEditor class</class-id> <category>interface specs</category><body package="UIPainter">basicSliceInt	"Tools.UIPainter new openOnClass: self andSelector: #basicSliceInt"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #labels ) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 560 319 880 579 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 140 0 ) 					#name: #MenuLabelBox 					#label: 					#(#{Kernel.UserMessage} 						#key: #MenuLabel 						#defaultString: 'Menu Label' 						#catalogID: #labels ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.CheckBoxSpec} 							#layout: #(#{UI.AlignmentOrigin} 0 0 25 0 0 1 ) 							#name: #itemLabelOverride 							#model: #itemLabelOverride 							#label: 							#(#{Kernel.UserMessage} 								#key: #OverrideInMenu 								#defaultString: 'Override in Menu' 								#catalogID: #UIPainter ) ) 						#(#{UI.CompositeSpecCollection} 							#collection: #(								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 0 6 ) 									#name: #stringDefaultLabel 									#label: 									#(#{Kernel.UserMessage} 										#key: #StringC 										#defaultString: 'String:' 										#catalogID: #labels ) ) 								#(#{UI.MappedClickWidgetSpec} 									#layout: #(#{Graphics.LayoutSizedOrigin} 80 0 5 0 16 16 ) 									#name: #iString 									#flags: 0 									#visualSelector: #stringInfoIcon ) 								#(#{UI.InputFieldSpec} 									#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 0 1 25 0 ) 									#name: #labelDefaultString 									#model: #labelDefaultString 									#menu: #inputBaseMenu ) ) 							#compositeSpec: 							#(#{UI.CompositeSpec} 								#layout: #(#{Graphics.LayoutFrame} 0 0 30 0 0 1 55 0 ) 								#name: #StringGroup ) ) 						#(#{UI.CompositeSpecCollection} 							#collection: #(								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 0 6 ) 									#name: #lookupKeyLabel 									#label: 									#(#{Kernel.UserMessage} 										#key: #LookupKey 										#defaultString: 'Lookup key:' 										#catalogID: #labels ) ) 								#(#{UI.MappedClickWidgetSpec} 									#layout: #(#{Graphics.LayoutSizedOrigin} 80 0 5 0 16 16 ) 									#name: #iKey 									#flags: 0 									#visualSelector: #infoIcon ) 								#(#{UI.InputFieldSpec} 									#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 0 1 25 0 ) 									#name: #labelKey 									#model: #labelKey 									#menu: #inputBaseMenu 									#type: #i18nkey ) ) 							#compositeSpec: 							#(#{UI.CompositeSpec} 								#layout: #(#{Graphics.LayoutFrame} 0 0 60 0 0 1 85 0 ) 								#name: #KeyGroup ) ) 						#(#{UI.CompositeSpecCollection} 							#collection: #(								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 0 6 ) 									#name: #catalogLabel 									#label: 									#(#{Kernel.UserMessage} 										#key: #CatalogC 										#defaultString: 'Catalog:' 										#catalogID: #labels ) ) 								#(#{UI.MappedClickWidgetSpec} 									#layout: #(#{Graphics.LayoutSizedOrigin} 80 0 5 0 16 16 ) 									#name: #iCatalog 									#flags: 0 									#visualSelector: #infoIcon ) 								#(#{UI.InputFieldSpec} 									#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 0 1 25 0 ) 									#name: #catalogID 									#model: #catalogID 									#menu: #inputBaseMenu 									#type: #symbol ) ) 							#compositeSpec: 							#(#{UI.CompositeSpec} 								#layout: #(#{Graphics.LayoutFrame} 0 0 90 0 0 1 115 0 ) 								#name: #CatalogGroup ) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 15 0 15 0 -10 1 135 0 ) 						#name: #LabelGroup ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 140 0 0 1 190 0 ) 					#name: #CommandBox 					#label: 					#(#{Kernel.UserMessage} 						#key: #CommandID 						#defaultString: 'Command ID' 						#catalogID: #labels ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 6 ) 							#name: #commandKeyLabel 							#label: 							#(#{Kernel.UserMessage} 								#key: #CommandC 								#defaultString: 'Command:' 								#catalogID: #labels ) ) 						#(#{UI.MappedClickWidgetSpec} 							#layout: #(#{Graphics.LayoutSizedOrigin} 80 0 5 0 16 16 ) 							#name: #iCommand 							#flags: 0 							#visualSelector: #commandInfoIcon ) 						#(#{UI.SubCanvasSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 0 1 25 0 ) 							#name: #commandKey 							#flags: 0 							#majorKey: #{EntryWithPasteButtonModule} 							#minorKey: #windowSpec 							#clientKey: #commandKey ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 15 0 155 0 -5 1 180 0 ) 						#name: #CommandGroup ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 10 6 ) 							#name: #valueLabel 							#label: 							#(#{Kernel.UserMessage} 								#key: #ValueC 								#defaultString: 'Value:' 								#catalogID: #labels ) ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 95 0 0 0 0 1.0 25 0 ) 							#name: #itemValue 							#model: #itemValue 							#menu: #inputBaseMenu 							#type: #symbol ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 5 0 195 0 -5 1 220 0 ) 						#name: #ValueGroup ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 10 6 ) 							#name: #nameKeyLabel 							#label: 							#(#{Kernel.UserMessage} 								#key: #IDC 								#defaultString: 'ID:' 								#catalogID: #labels ) ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 95 0 0 0 0 1.0 25 0 ) 							#name: #currentNameKey 							#model: #currentNameKey 							#menu: #inputBaseMenu 							#type: #symbol ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 5 0 225 0 -5 1 250 0 ) 						#name: #NameKeyGroup ) ) ) ) )</body><body package="UIPainter">defaultSlice	"Tools.UIPainter new openOnClass: self andSelector: #defaultSlice"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #UIPainter ) 			#min: #(#{Core.Point} 250 200 ) 			#max: #(#{Core.Point} 1024 768 ) 			#bounds: #(#{Graphics.Rectangle} 576 290 861 580 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 80 0 ) 					#name: #visibilityBox 					#label: 					#(#{Kernel.UserMessage} 						#key: #Visibility 						#defaultString: 'Visibility' 						#catalogID: #UIPainter ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 0 0 ) 							#name: #itemVisible 							#model: #itemVisible 							#label: 							#(#{Kernel.UserMessage} 								#key: #InitiallyVisible 								#defaultString: 'Initially visible' 								#catalogID: #UIPainter ) ) 						#(#{UI.LabelSpec} 							#layout: #(#{UI.AlignmentOrigin} 0 0 45 0 0 1 ) 							#name: #visibilitySelectorLabel 							#label: 							#(#{Kernel.UserMessage} 								#key: #SelectorC 								#defaultString: 'Selector:' 								#catalogID: #UIPainter ) ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 75 0 25 0 0 1.0 50 0 ) 							#name: #visibilitySelector 							#model: #visibilitySelector 							#menu: #inputBaseMenu 							#type: #symbol ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 20 0 20 0 -10 1 70 0 ) 						#name: #VisibilityGroup ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 80 0 0 1 160 0 ) 					#name: #enablementBox 					#label: 					#(#{Kernel.UserMessage} 						#key: #Enablement 						#defaultString: 'Enablement' 						#catalogID: #UIPainter ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 0 0 ) 							#name: #itemEnabled 							#model: #itemEnabled 							#label: 							#(#{Kernel.UserMessage} 								#key: #InitiallyEnabled 								#defaultString: 'Initially enabled' 								#catalogID: #UIPainter ) ) 						#(#{UI.LabelSpec} 							#layout: #(#{UI.AlignmentOrigin} 0 0 45 0 0 1 ) 							#name: #enablementSelectorLabel 							#label: 							#(#{Kernel.UserMessage} 								#key: #SelectorC 								#defaultString: 'Selector:' 								#catalogID: #UIPainter ) ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 75 0 25 0 0 1.0 50 0 ) 							#name: #enablementSelector 							#model: #enablementSelector 							#menu: #inputBaseMenu 							#type: #symbol ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 20 0 100 0 -10 1 150 0 ) 						#name: #EnablementGroup ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 160 0 0 1 285 0 ) 					#name: #indicationBox 					#label: 					#(#{Kernel.UserMessage} 						#key: #Indication 						#defaultString: 'Indication' 						#catalogID: #UIPainter ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.RadioButtonSpec} 							#layout: #(#{Core.Point} 0 0 ) 							#name: #itemIsNormal 							#model: #itemIsNormal 							#label: 							#(#{Kernel.UserMessage} 								#key: #None 								#defaultString: 'None' 								#catalogID: #UIPainter ) ) 						#(#{UI.RadioButtonSpec} 							#layout: #(#{Core.Point} 0 20 ) 							#name: #itemIsOn 							#model: #itemIsOn 							#label: 							#(#{Kernel.UserMessage} 								#key: #InitiallyOn 								#defaultString: 'Initially On' 								#catalogID: #UIPainter ) ) 						#(#{UI.RadioButtonSpec} 							#layout: #(#{Core.Point} 0 40 ) 							#name: #itemIsOff 							#model: #itemIsOff 							#label: 							#(#{Kernel.UserMessage} 								#key: #InitiallyOff 								#defaultString: 'Initially Off' 								#catalogID: #UIPainter ) ) 						#(#{UI.LabelSpec} 							#layout: #(#{UI.AlignmentOrigin} 0 0 90 0 0 1 ) 							#name: #indicationSelectorLabel 							#label: 							#(#{Kernel.UserMessage} 								#key: #SelectorC 								#defaultString: 'Selector:' 								#catalogID: #UIPainter ) ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 75 0 70 0 0 1.0 95 0 ) 							#name: #indicationSelector 							#model: #indicationSelector 							#menu: #inputBaseMenu 							#type: #symbol ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 20 0 180 0 -10 1 275 0 ) 						#name: #IndicationGroup ) ) ) ) )</body><body package="UIPainter">detailSlice	"Tools.UIPainter new openOnClass: self andSelector: #detailSlice"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #UIPainter ) 			#min: #(#{Core.Point} 302 306 ) 			#max: #(#{Core.Point} 1600 1200 ) 			#bounds: #(#{Graphics.Rectangle} 569 337 871 562 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 50 0 ) 					#name: #shortcutKeysBox 					#label: 					#(#{Kernel.UserMessage} 						#key: #ShortcutCharacter 						#defaultString: 'Shortcut Character' 						#catalogID: #UIPainter ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 0 3 ) 							#name: #hasCtrl 							#model: #hasCtrl 							#label: 							#(#{Kernel.UserMessage} 								#key: #Ctrl 								#defaultString: 'Ctrl' 								#catalogID: #UIPainter ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 58 3 ) 							#name: #hasAlt 							#model: #hasAlt 							#label: 							#(#{Kernel.UserMessage} 								#key: #Alt 								#defaultString: 'Alt' 								#catalogID: #UIPainter ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 116 3 ) 							#name: #hasShift 							#model: #hasShift 							#label: 							#(#{Kernel.UserMessage} 								#key: #Shift 								#defaultString: 'Shift' 								#catalogID: #UIPainter ) ) 						#(#{UI.MappedClickWidgetSpec} 							#layout: #(#{Graphics.LayoutSizedOrigin} -22 0.7 5 0 16 16 ) 							#name: #iKeystroke 							#flags: 0 							#visualSelector: #keystrokeInfoIcon ) 						#(#{UI.ComboBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.7 0 0 0 1 25 0 ) 							#name: #shortCutChar 							#model: #shortCutChar 							#menu: #inputBaseMenu 							#isReadOnly: false 							#comboList: #functionKeys ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 15 0 15 0 -10 1 40 0 ) 						#name: #ShortcutKeysGroup ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 50 0 0 1 128 0 ) 					#name: #labelImageBox 					#label: 					#(#{Kernel.UserMessage} 						#key: #LabelImage 						#defaultString: 'Label Image' 						#catalogID: #UIPainter ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 3 ) 							#name: #classLabel 							#label: 							#(#{Kernel.UserMessage} 								#key: #ClassC 								#defaultString: 'Class:' 								#catalogID: #UIPainter ) ) 						#(#{UI.SubCanvasSpec} 							#layout: #(#{Graphics.LayoutFrame} 85 0 0 0 0 1.0 25 0 ) 							#name: #labelImageClassName 							#flags: 0 							#majorKey: #{EntryWithPasteButtonModule} 							#minorKey: #windowSpec 							#clientKey: #labelImageClassName ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 30 ) 							#name: #selectorLabel 							#label: 							#(#{Kernel.UserMessage} 								#key: #SelectorC 								#defaultString: 'Selector:' 								#catalogID: #UIPainter ) ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 85 0 28 0 0 1.0 53 0 ) 							#name: #labelImageSelector 							#model: #labelImageSelector 							#menu: #inputBaseMenu 							#type: #symbol ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 15 0 65 0 -10 1 118 0 ) 						#name: #LabelImageGroup ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 15 2 ) 							#name: #helpTextLabel 							#label: 							#(#{Kernel.UserMessage} 								#key: #HelpTextC 								#defaultString: 'Help Text:' 								#catalogID: #UIPainter ) ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 0 0 -10 1 25 0 ) 							#name: #helpText 							#model: #helpText 							#menu: #inputBaseMenu ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 15 31 ) 							#name: #helpLookupKeyLabel 							#label: 							#(#{Kernel.UserMessage} 								#key: #LookupKeyC 								#defaultString: 'Lookup key:' 								#catalogID: #UIPainter ) ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 29 0 -10 1 54 0 ) 							#name: #helpLookupKey 							#model: #helpLookupKey 							#menu: #inputBaseMenu 							#type: #symbol ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 15 60 ) 							#name: #helpCatalogLabel 							#label: 							#(#{Kernel.UserMessage} 								#key: #CatalogC 								#defaultString: 'Catalog:' 								#catalogID: #UIPainter ) ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 100 0 58 0 -10 1 83 0 ) 							#name: #helpCatalogID 							#model: #helpCatalog 							#menu: #inputBaseMenu 							#type: #symbol ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 0 0 132 0 0 1 215 0 ) 						#name: #HelpTextGroup ) ) ) ) )</body><body package="UIPainter">subWindowSpec	"UIPainter new openOnClass: self andSelector: #subWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #MenuEditor #defaultString: 'Menu Editor' #catalogID: #UIPainter) 			#min: #(#{Core.Point} 132 58 ) 			#bounds: #(#{Graphics.Rectangle} 641 530 959 670 ) 			#flags: 4 			#menu: #menuBar 			#performer: #fakePerformer ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #() ) )</body><body package="UIPainter">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #MenuEditor 				#defaultString: 'Menu Editor' 				#catalogID: #UIPainter ) 			#min: #(#{Core.Point} 40 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 519 439 1081 814 ) 			#flags: 4 			#menu: #editingMenuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 1 0 -1 0.4 -1 1 ) 					#name: #menuList 					#flags: 15 					#model: #menuList 					#tabable: true 					#menu: #itemsMenu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.4 1 0 -1 1 -1 1 ) 					#name: #propertyCanvas 					#model: #propertyPages 					#labels: #() ) ) ) )</body></methods><methods><class-id>Tools.DataSetSpecColumnDetailsModel class</class-id> <category>resources</category><body package="UIPainter">alignmentMenu	"MenuEditor new openOnClass: self andSelector: #alignmentMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Right #defaultString: 'Right' #catalogID: #UIPainter) 				#value: #right ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Center #defaultString: 'Center' #catalogID: #UIPainter) 				#value: #center ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Left #defaultString: 'Left' #catalogID: #UIPainter) 				#value: #left ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="UIPainter">columnTypesMenu	"Tools.MenuEditor new openOnClass: self andSelector: #columnTypesMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ReadOnly 					#defaultString: 'Read Only' 					#catalogID: #UIPainter ) 				#value: #None ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #InputField 					#defaultString: 'Input Field' 					#catalogID: #UIPainter ) 				#value: #InputField ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ComboBox 					#defaultString: 'Combo Box' 					#catalogID: #UIPainter ) 				#value: #ComboBox ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #CheckBox 					#defaultString: 'Check Box' 					#catalogID: #UIPainter ) 				#value: #CheckBox ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RowSelector 					#defaultString: 'Row Selector' 					#catalogID: #UIPainter ) 				#value: #rowSelector 				#visible: false ) ) #(5 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.DataSetSpecColumnDetailsModel class</class-id> <category>interface specs</category><body package="UIPainter">columnDetailsEditSpec	"UIPainter new openOnClass: self andSelector: #columnDetailsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#min: #(#{Core.Point} 440 472 ) 			#max: #(#{Core.Point} 440 472 ) 			#bounds: #(#{Graphics.Rectangle} 580 364 1020 836 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#name: #label 					#label: #(#{Kernel.UserMessage} #key: #Dataset #defaultString: 'Dataset' #catalogID: #UIPainter) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 							#name: #CheckBox 							#label: #(#{Kernel.UserMessage} #key: #NoAdditionalDetails #defaultString: 'No additional details' #catalogID: #UIPainter) ) 						#(#{UI.LabelSpec} 							#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 							#name: #rowSelector 							#label: #(#{Kernel.UserMessage} #key: #NoAdditionalDetails #defaultString: 'No additional details' #catalogID: #UIPainter) ) 						#(#{UI.CompositeSpecCollection} 							#collection: #(								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 111 31 ) 									#label: #(#{Kernel.UserMessage} #key: #AlignC #defaultString: 'Align:' #catalogID: #UIPainter) ) 								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 0 60 ) 									#label: #(#{Kernel.UserMessage} #key: #FontC #defaultString: 'Font:' #catalogID: #UIPainter) ) 								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 0 89 ) 									#label: #(#{Kernel.UserMessage} #key: #DataType #defaultString: 'Data Type:' #catalogID: #UIPainter) ) 								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 0 118 ) 									#name: #InputFormatLabel 									#label: #(#{Kernel.UserMessage} #key: #Format #defaultString: 'Format:' #catalogID: #UIPainter) ) 								#(#{UI.InputFieldSpec} 									#layout: #(#{Graphics.LayoutFrame} 70 0 0 0.0 0 1.0 25 0 ) 									#name: #InputFieldMenu 									#model: #typeMenu 									#menu: #fieldMenu 									#type: #symbol ) 								#(#{UI.InputFieldSpec} 									#layout: #(#{Graphics.Rectangle} 70 29 109 54 ) 									#name: #InputFieldSize 									#model: #typeSize 									#menu: #fieldMenu 									#alignment: #center 									#type: #number ) 								#(#{UI.MenuButtonSpec} 									#layout: #(#{Graphics.LayoutFrame} 166 0 29 0 0 1.0 54 0 ) 									#name: #InputFieldAlign 									#model: #typeAlign 									#menu: #alignmentMenu ) 								#(#{UI.MenuButtonSpec} 									#layout: #(#{Graphics.LayoutFrame} 70 0 58 0 0 1.0 83 0 ) 									#name: #InputFieldFont 									#model: #typeFont 									#menu: #fontMenu ) 								#(#{UI.MenuButtonSpec} 									#layout: #(#{Graphics.LayoutFrame} 94 0 87 0 0 1.0 112 0 ) 									#name: #InputFieldDataType 									#model: #typeDataType 									#menu: #dataType ) 								#(#{UI.ComboBoxSpec} 									#layout: #(#{Graphics.LayoutFrame} 94 0 116 0 0 1.0 141 0 ) 									#name: #InputFormatEditor 									#model: #formatString 									#menu: #fieldMenu 									#isReadOnly: false 									#comboList: #defaultFormats ) 								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 0 2 ) 									#label: #(#{Kernel.UserMessage} #key: #Menu #defaultString: 'Menu:' #catalogID: #UIPainter) ) 								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 0 31 ) 									#label: #(#{Kernel.UserMessage} #key: #Chars #defaultString: 'Chars:' #catalogID: #UIPainter) ) ) 							#compositeSpec: 							#(#{UI.CompositeSpec} 								#layout: #(#{Graphics.LayoutFrame} 2 0 0 0 0 1.0 146 0 ) 								#name: #InputField ) ) 						#(#{UI.CompositeSpecCollection} 							#collection: #(								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 0 89 ) 									#name: #NoneFormatLabel 									#label: #(#{Kernel.UserMessage} #key: #Format #defaultString: 'Format:' #catalogID: #UIPainter) ) 								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 0 60 ) 									#label: #(#{Kernel.UserMessage} #key: #DataType #defaultString: 'Data Type:' #catalogID: #UIPainter) ) 								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 0 31 ) 									#label: #(#{Kernel.UserMessage} #key: #AlignC #defaultString: 'Align:' #catalogID: #UIPainter) ) 								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 0 2 ) 									#label: #(#{Kernel.UserMessage} #key: #FontC #defaultString: 'Font:' #catalogID: #UIPainter) ) 								#(#{UI.MenuButtonSpec} 									#layout: #(#{Graphics.LayoutFrame} 94 0 0 0 0 1.0 25 0 ) 									#name: #InputFieldFont 									#model: #typeFont 									#menu: #fontMenu ) 								#(#{UI.MenuButtonSpec} 									#layout: #(#{Graphics.LayoutFrame} 94 0 29 0 0 1.0 54 0 ) 									#name: #InputFieldAlign 									#model: #typeAlign 									#menu: #alignmentMenu ) 								#(#{UI.MenuButtonSpec} 									#layout: #(#{Graphics.LayoutFrame} 94 0 58 0 0 1.0 83 0 ) 									#name: #InputFieldAlign 									#model: #typeDataType 									#menu: #dataType ) 								#(#{UI.ComboBoxSpec} 									#layout: #(#{Graphics.LayoutFrame} 94 0 87 0 0 1.0 112 0 ) 									#name: #NoneFormatEditor 									#model: #formatString 									#menu: #fieldMenu 									#isReadOnly: false 									#comboList: #defaultFormats ) ) 							#compositeSpec: 							#(#{UI.CompositeSpec} 								#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0 0 1.0 117 0 ) 								#name: #None ) ) 						#(#{UI.CompositeSpecCollection} 							#collection: #(								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 0 89 ) 									#label: #(#{Kernel.UserMessage} #key: #FontC #defaultString: 'Font:' #catalogID: #UIPainter) ) 								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 0 147 ) 									#name: #ComboBoxFormatLabel 									#label: #(#{Kernel.UserMessage} #key: #Format #defaultString: 'Format:' #catalogID: #UIPainter) ) 								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 0 118 ) 									#label: #(#{Kernel.UserMessage} #key: #DataType #defaultString: 'Data Type:' #catalogID: #UIPainter) ) 								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 111 60 ) 									#label: #(#{Kernel.UserMessage} #key: #AlignC #defaultString: 'Align:' #catalogID: #UIPainter) ) 								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 0 31 ) 									#label: #(#{Kernel.UserMessage} #key: #Choices #defaultString: 'Choices:' #catalogID: #UIPainter) ) 								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 0 2 ) 									#label: #(#{Kernel.UserMessage} #key: #Menu #defaultString: 'Menu:' #catalogID: #UIPainter) ) 								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 0 60 ) 									#label: #(#{Kernel.UserMessage} #key: #Chars #defaultString: 'Chars:' #catalogID: #UIPainter) ) 								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 0 176 ) 									#name: #ComboBoxReadSelectorLabel 									#label: #(#{Kernel.UserMessage} #key: #ReadC #defaultString: 'Read:' #catalogID: #UIPainter) ) 								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 0 205 ) 									#name: #ComboBoxPrintSelectorLabel 									#label: #(#{Kernel.UserMessage} #key: #Print #defaultString: 'Print:' #catalogID: #UIPainter) ) 								#(#{UI.InputFieldSpec} 									#layout: #(#{Graphics.LayoutFrame} 70 0 0 0.0 0 1.0 25 0 ) 									#name: #ComboBoxMenu 									#model: #typeMenu 									#menu: #fieldMenu 									#type: #symbol ) 								#(#{UI.InputFieldSpec} 									#layout: #(#{Graphics.LayoutFrame} 70 0 29 0 0 1.0 54 0 ) 									#name: #typeChoices 									#model: #typeChoices 									#menu: #fieldMenu 									#type: #symbol ) 								#(#{UI.InputFieldSpec} 									#layout: #(#{Graphics.Rectangle} 70 58 109 83 ) 									#name: #ComboBoxSize 									#model: #typeSize 									#menu: #fieldMenu 									#alignment: #center 									#type: #number ) 								#(#{UI.MenuButtonSpec} 									#layout: #(#{Graphics.LayoutFrame} 166 0 58 0 0 1.0 83 0 ) 									#name: #ComboBoxAlign 									#model: #typeAlign 									#menu: #alignmentMenu ) 								#(#{UI.MenuButtonSpec} 									#layout: #(#{Graphics.LayoutFrame} 70 0 87 0 0 1.0 112 0 ) 									#name: #ComboBoxFont 									#model: #typeFont 									#menu: #fontMenu ) 								#(#{UI.MenuButtonSpec} 									#layout: #(#{Graphics.LayoutFrame} 94 0 116 0 0 1.0 141 0 ) 									#name: #ComboBoxDataType 									#model: #typeDataType 									#menu: #dataType ) 								#(#{UI.ComboBoxSpec} 									#layout: #(#{Graphics.LayoutFrame} 94 0 145 0 0 1.0 170 0 ) 									#name: #ComboBoxFormatEditor 									#model: #formatString 									#menu: #fieldMenu 									#isReadOnly: false 									#comboList: #defaultFormats ) 								#(#{UI.InputFieldSpec} 									#layout: #(#{Graphics.LayoutFrame} 94 0 174 0 0 1.0 199 0 ) 									#name: #ComboBoxReadSelector 									#model: #readSelector 									#type: #symbol ) 								#(#{UI.InputFieldSpec} 									#layout: #(#{Graphics.LayoutFrame} 94 0 203 0 0 1.0 228 0 ) 									#name: #ComboBoxPrintSelector 									#model: #printSelector 									#type: #symbol ) ) 							#compositeSpec: 							#(#{UI.CompositeSpec} 								#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0 0 1.0 0 1.0 ) 								#name: #ComboBox ) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 5 0 31 0 -5 1 -10 1 ) 						#name: #fields ) ) ) ) )</body></methods><methods><class-id>Tools.UIDefiner class</class-id> <category>interface specs</category><body package="UIPainter">defineDialogSpec	"UIPainter new openOnClass: self andSelector: #defineDialogSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 242 242 ) 			#max: #(#{Core.Point} 242 242 ) 			#bounds: #(#{Graphics.Rectangle} 679 479 921 721 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 14 0 12 0 ) 					#label: #(#{Kernel.UserMessage} #key: #DEFINEModels #defaultString: 'DEFINE Models' #catalogID: #UIPainter) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -82 0.5 -35 1 -16 0.5 -5 1 ) 					#name: #okButton 					#model: #doOK 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #UIPainter) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0.5 -35 1 82 0.5 -5 1 ) 					#name: #cancelButton 					#model: #doAbort 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #UIPainter) 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 38 0 -14 1 -89 1 ) 					#model: #modelList 					#multipleSelections: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 16 0 -73 1 0 0 ) 					#model: #addInitialization 					#label: #(#{Kernel.UserMessage} #key: #AddInitialization #defaultString: 'Add Initialization' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">smallDefineDialogSpec	"UIPainter new openOnClass: self andSelector: #smallDefineDialogSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 241 160 ) 			#max: #(#{Core.Point} 241 160 ) 			#bounds: #(#{Graphics.Rectangle} 680 520 921 680 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 14 0 12 0 ) 					#label: #(#{Kernel.UserMessage} #key: #DEFINEModel #defaultString: 'DEFINE Model' #catalogID: #UIPainter) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -82 0.5 -35 1 -16 0.5 -5 1 ) 					#name: #okButton 					#model: #doOK 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #UIPainter) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0.5 -35 1 82 0.5 -5 1 ) 					#name: #cancelButton 					#model: #doAbort 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #UIPainter) 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 38 0 -15 1 -95 1 ) 					#flags: 12 					#model: #modelList 					#multipleSelections: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 16 0 -73 1 0 0 ) 					#model: #addInitialization 					#label: #(#{Kernel.UserMessage} #key: #AddInitialization #defaultString: 'Add Initialization' #catalogID: #UIPainter) ) ) ) )</body></methods><methods><class-id>Tools.ColorToolModel class</class-id> <category>resources</category><body package="UIPainter">baseColorMenu	"MenuEditor new openOnClass: self andSelector: #baseColorMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #NamedColors #defaultString: 'Named Colors' #catalogID: #menus) 				#nameKey: #namedColors ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #PolicyColors #defaultString: 'Policy Colors' #catalogID: #menus) 				#nameKey: #policyColors 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Foreground #defaultString: 'Foreground' #catalogID: #menus) 							#value: #foregroundColor ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Background #defaultString: 'Background' #catalogID: #menus) 							#value: #backgroundColor ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #SelnFrgnd #defaultString: 'Sel''n Frgnd' #catalogID: #menus) 							#value: #selectionForegroundColor ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #SelnBkgnd #defaultString: 'Sel''n Bkgnd' #catalogID: #menus) 							#value: #selectionBackgroundColor ) ) #(4 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.ColorToolModel class</class-id> <category>interface specs</category><body package="UIPainter">propSpec	"Tools.UIPainter new openOnClass: self andSelector: #propSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ColorTool 				#defaultString: 'Color Tool' 				#catalogID: #UIPainter ) 			#min: #(#{Core.Point} 243 260 ) 			#max: #(#{Core.Point} 360 317 ) 			#bounds: #(#{Graphics.Rectangle} 1100 573 1459 866 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -71 1 139 0 -7 1 164 0 ) 					#flags: 0 					#model: #colorName 					#label: ' ' 					#menu: #colorMenu ) 				#(#{UI.CompositeSpecCollection} 					#collection: #() 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} -71 1 130 0 -7 1 160 0 ) 						#name: #theActualColor 						#colors: #(#{UI.LookPreferences} ) ) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -72 1 130 0 -6 1 160 0 ) 					#flags: 0 					#model: #colorName 					#label: ' ' 					#menu: #colorMenu ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 6 0 6 0 27 0 125 0 ) 					#model: #sliderModel 					#orientation: #vertical ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 5 0 129 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #V 						#defaultString: 'V' 						#catalogID: #UIPainter ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 4 0 171 0 ) 					#name: #hueLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #H 						#defaultString: 'H' 						#catalogID: #UIPainter ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #() 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 32 0 6 0 -6 1 125 0 ) 						#name: #colorSpace 						#flags: 8 						#isOpaque: true ) ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 20 0 175 0 -80 1 192 0 ) 					#name: #hue 					#model: #hue 					#orientation: #horizontal 					#start: 0.0 					#stop: 0.999 					#step: 0.001 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 20 0 131 0 -80 1 148 0 ) 					#model: #brightness 					#orientation: #horizontal 					#start: 0.0 					#stop: 1.0 					#step: 0.001 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 20 0 153 0 -80 1 170 0 ) 					#name: #saturation 					#model: #saturation 					#orientation: #horizontal 					#start: 0.0 					#stop: 1.0 					#step: 0.001 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 4 0 151 0 ) 					#name: #saturationLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #S 						#defaultString: 'S' 						#catalogID: #UIPainter ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -72 1 168 0 -6 1 192 0 ) 					#name: #readButton 					#model: #readMode 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #Read 						#defaultString: 'Read' 						#catalogID: #UIPainter ) ) 				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.LayoutFrame} -72 1 131 0 -6 1 163 0 ) 					#lineWidth: 1 ) 				#(#{UI.CompositeSpecCollection} 					#collection: #() 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} -71 1 132 0 -7 1 162 0 ) 						#name: #theActualColor 						#colors: #(#{UI.LookPreferences} ) ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.119777 0 0.742671 0.5 0 ) 					#name: #foregroundChipLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Foregrnd 						#defaultString: 'Foregrnd' 						#catalogID: #UIPainter ) 					#style: #small ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.373259 0 0.742671 0.5 0 ) 					#name: #backgroundChipLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Backgrnd 						#defaultString: 'Backgrnd' 						#catalogID: #UIPainter ) 					#style: #small ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.62117 -20 0.742671 0.5 0 ) 					#name: #selectionForegroundChipLabelTop 					#label: 					#(#{Kernel.UserMessage} 						#key: #Selection 						#defaultString: 'Selection' 						#catalogID: #UIPainter ) 					#style: #small ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.62117 0 0.742671 0.5 0 ) 					#name: #selectionForegroundChipLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Foregrnd 						#defaultString: 'Foregrnd' 						#catalogID: #UIPainter ) 					#style: #small ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.869081 -20 0.742671 0.5 0 ) 					#name: #selectionBackgroundChipLabelTop 					#label: 					#(#{Kernel.UserMessage} 						#key: #Selection 						#defaultString: 'Selection' 						#catalogID: #UIPainter ) 					#style: #small ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.869081 0 0.742671 0.5 0 ) 					#name: #selectionBackgroundChipLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Backgrnd 						#defaultString: 'Backgrnd' 						#catalogID: #UIPainter ) 					#style: #small ) 				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 0 0.830619 -2 0.25 -23 1 ) 					#name: #foregroundChip 					#isOpaque: true 					#lineWidth: 1 ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 0 0.889286 -2 0.25 -5 1 ) 					#name: #foregroundButton 					#flags: 0 					#model: #changeFGColor 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #select 						#defaultString: 'select' 						#catalogID: #UIPainter ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.15 0 0.889286 -2 0.25 -5 1 ) 					#name: #foregroundClear 					#flags: 0 					#model: #clearFGColor 					#tabable: false ) 				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.25 0 0.830619 -2 0.5 -23 1 ) 					#name: #backgroundChip 					#isOpaque: true 					#lineWidth: 1 ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.25 0 0.889286 -2 0.5 -5 1 ) 					#name: #backgroundButton 					#flags: 0 					#model: #changeBGColor 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #select 						#defaultString: 'select' 						#catalogID: #UIPainter ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.4 0 0.889286 -2 0.5 -5 1 ) 					#name: #backgroundClear 					#flags: 0 					#model: #clearBGColor 					#tabable: false ) 				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 0 0.830619 -2 0.75 -23 1 ) 					#name: #selectionForegroundChip 					#isOpaque: true 					#lineWidth: 1 ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 0 0.889286 -2 0.75 -5 1 ) 					#name: #selectionForegroundButton 					#flags: 0 					#model: #changeSFGColor 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #select 						#defaultString: 'select' 						#catalogID: #UIPainter ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.65 0 0.889286 -2 0.75 -5 1 ) 					#name: #selectionForegroundClear 					#flags: 0 					#model: #clearSFGColor 					#tabable: false ) 				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.75 0 0.830619 -2 1 -23 1 ) 					#name: #selectionBackgroundChip 					#isOpaque: true 					#lineWidth: 1 ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.75 0 0.889286 -2 1 -5 1 ) 					#name: #selectionBackgroundButton 					#flags: 0 					#model: #changeSBGColor 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #select 						#defaultString: 'select' 						#catalogID: #UIPainter ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.9 0 0.889286 -2 1 -5 1 ) 					#name: #selectionBackgroundClear 					#flags: 0 					#model: #clearSBGColor 					#tabable: false ) 				#(#{UI.LabelSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 					#layout: #(#{UI.AlignmentOrigin} 15 0 0 0.849829 0 0 ) 					#name: #colorFGNone 					#style: #small ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 15 0.25 0 0.849829 0 0 ) 					#name: #colorBGNone 					#style: #small ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 15 0.5 0 0.849829 0 0 ) 					#name: #colorSFGNone 					#style: #small ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 15 0.75 0 0.849829 0 0 ) 					#name: #colorSBGNone 					#style: #small ) ) ) )</body></methods><methods><class-id>UI.MultiSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#min: #(#{Core.Point} 237 230 ) 			#max: #(#{Core.Point} 259 230 ) 			#bounds: #(#{Graphics.Rectangle} 671 485 930 715 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #MultipleSelection #defaultString: 'Multiple Selection' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 51 0 110 0 0 1 ) 					#name: #fontLabel 					#flags: 32 					#label: #(#{Kernel.UserMessage} #key: #FontC #defaultString: 'Font:' #catalogID: #UIPainter) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 118 0 87 0 -10 1 109 0 ) 					#name: #fontMenu 					#flags: 40 					#model: #style 					#menu: #fontMenu ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 7 26 ) 					#label: #(#{Kernel.UserMessage} #key: #ClickCheckBoxToEdit #defaultString: 'Click check box on left to edit.' #catalogID: #UIPainter) 					#style: #small ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 51 0 80 0 0 1 ) 					#name: #aspectLabel 					#flags: 32 					#label: #(#{Kernel.UserMessage} #key: #AspectC #defaultString: 'Aspect:' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 80 0 0 1 ) 					#model: #changeAspect 					#tabable: true 					#label: '-&gt;' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 118 0 53 0 -10 1 78 0 ) 					#name: #model 					#flags: 40 					#model: #model 					#tabable: true 					#menu: #fieldMenu 					#type: #string ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 110 0 0 1 ) 					#model: #changeFont 					#tabable: true 					#label: '-&gt;' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 114 ) 					#model: #changeBorder 					#tabable: true 					#label: '-&gt;' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 51 114 ) 					#name: #hasBorder 					#flags: 32 					#model: #hasBorder 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Bordered #defaultString: 'Bordered' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 134 ) 					#model: #changeOpaque 					#tabable: true 					#label: '-&gt;' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 51 134 ) 					#name: #isOpaque 					#flags: 32 					#model: #isOpaque 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Opaque #defaultString: 'Opaque' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 154 ) 					#model: #changeTabable 					#tabable: true 					#label: '-&gt;' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 51 154 ) 					#name: #tabable 					#flags: 32 					#model: #tabable 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #CanTab #defaultString: 'Can Tab' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">detailsEditSpec	"UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#min: #(#{Core.Point} 237 230 ) 			#max: #(#{Core.Point} 237 230 ) 			#bounds: #(#{Graphics.Rectangle} 682 485 919 715 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 79 0 0 1 ) 					#model: #changeFont 					#tabable: true 					#label: '-&gt;' ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 117 0 55 0 -8 1 78 0 ) 					#name: #fontMenu 					#flags: 40 					#model: #style 					#tabable: true 					#menu: #fontMenu ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 106 0 0 1 ) 					#model: #changeBorder 					#tabable: true 					#label: '-&gt;' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 51 0 106 0 0 1 ) 					#name: #hasBorder 					#flags: 32 					#model: #hasBorder 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Bordered #defaultString: 'Bordered' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 128 0 0 1 ) 					#model: #changeOpaque 					#tabable: true 					#label: '-&gt;' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 51 0 128 0 0 1 ) 					#name: #isOpaque 					#flags: 32 					#model: #isOpaque 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Opaque #defaultString: 'Opaque' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 150 0 0 1 ) 					#model: #changeTabable 					#tabable: true 					#label: '-&gt;' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 51 0 150 0 0 1 ) 					#name: #tabable 					#flags: 32 					#model: #tabable 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #CanTab #defaultString: 'Can Tab' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 172 0 0 1 ) 					#model: #changeDefaultable 					#tabable: true 					#label: '-&gt;' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 51 0 172 0 0 1 ) 					#name: #defaultable 					#flags: 32 					#model: #defaultable 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #SizeAsDefault #defaultString: 'Size as Default' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 194 0 0 1 ) 					#model: #changeDisabled 					#tabable: true 					#label: '-&gt;' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 51 0 194 0 0 1 ) 					#name: #initiallyDisabled 					#flags: 32 					#model: #initiallyDisabled 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyDisabled #defaultString: 'Initially Disabled' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 216 0 0 1 ) 					#model: #changeInvisible 					#tabable: true 					#label: '-&gt;' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 51 0 216 0 0 1 ) 					#name: #initiallyInvisible 					#flags: 32 					#model: #initiallyInvisible 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyInvisible #defaultString: 'Initially Invisible' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 53 0 79 0 0 1 ) 					#name: #fontLabel 					#flags: 32 					#label: #(#{Kernel.UserMessage} #key: #FontC #defaultString: 'Font:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 8 29 ) 					#label: #(#{Kernel.UserMessage} #key: #ClickCheckBoxToEdit #defaultString: 'Click check box on left to edit.' #catalogID: #UIPainter) 					#style: #small ) ) ) )</body></methods><methods><class-id>Tools.UIPainterView class</class-id> <category>resources</category><body package="UIPainter">inactiveCell	"UIMaskEditor new openOnClass: self andSelector: #inactiveMask"	&lt;resource: #image&gt;	^(Image extent: 5@5 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[136 0 0 0 80 0 0 0 32 0 0 0 80 0 0 0 136 0 0 0])</body></methods><methods><class-id>Tools.UIHotRegionEditor class</class-id> <category>resources</category><body package="UIPainter">bigCircleBrush	"UIMaskEditor new openOnClass: self andSelector: #bigCircleBrush"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 8@8 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[60 0 0 0 126 0 0 0 255 0 0 0 255 0 0 0 255 0 0 0 255 0 0 0 126 0 0 0 60 0 0 0])</body><body package="UIPainter">bigSquareBrush	"UIMaskEditor new openOnClass: self andSelector: #bigSquareBrush"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 8@8 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 0 0 0 255 0 0 0 255 0 0 0 255 0 0 0 255 0 0 0 255 0 0 0 255 0 0 0 255 0 0 0])</body><body package="UIPainter">ellipseIcon	"UIMaskEditor new openOnClass: self andSelector: #ellipseIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 19@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[112 0 0 0 64 240 0 0 67 252 0 0 15 255 0 0 31 255 128 0 31 255 128 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 31 255 128 0 31 255 128 0 15 255 0 0 3 252 32 0 0 240 32 0 0 0 224 0])</body><body package="UIPainter">fillIcon	"UIMaskEditor new openOnClass: self andSelector: #fillIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 17@17 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[7 0 0 0 8 128 0 0 8 128 0 0 9 192 0 0 10 176 0 0 12 156 0 0 8 142 0 0 17 71 0 0 32 131 128 0 64 7 128 0 128 11 128 0 128 19 128 0 64 35 128 0 32 67 0 0 16 130 0 0 9 0 0 0 6 0 0 0])</body><body package="UIPainter">mainMenuBar	"MenuEditor new openOnClass: self andSelector: #mainMenuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Regions #defaultString: '&amp;Regions' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_New #defaultString: '&amp;New' #catalogID: #UIPainter) 							#value: #newRegions 							#shortcutKeyCharacter: $n ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_Load #defaultString: '&amp;Load' #catalogID: #UIPainter) 							#value: #loadRegions 							#shortcutKeyCharacter: $o ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_Install #defaultString: '&amp;Install' #catalogID: #UIPainter) 							#enabled: false 							#nameKey: #installRegions							#value: #installRegions 							#shortcutKeyCharacter: $s ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_Read #defaultString: '&amp;Read' #catalogID: #UIPainter) 							#nameKey: #readRegions							#value: #readRegions ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_Apply #defaultString: '&amp;Apply' #catalogID: #UIPainter) 							#enabled: false 							#nameKey: #applyRegions							#value: #applyRegions ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #E_xit #defaultString: 'E&amp;xit' #catalogID: #UIPainter) 							#value: #closeRequest 							#shortcutKeyCharacter: $q ) ) #(3 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Edit #defaultString: '&amp;Edit' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_UndoPainting #defaultString: '&amp;Undo Painting' #catalogID: #UIPainter) 							#value: #undoEdit 							#shortcutKeyCharacter: $Z ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #New_Slice #defaultString: 'New &amp;Slice' #catalogID: #UIPainter) 							#enabled: false 							#nameKey: #newSlice							#value: #newSlice ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_ClearSlice #defaultString: '&amp;Clear Slice' #catalogID: #UIPainter) 							#enabled: false 							#nameKey: #clearSlice							#value: #clearSlice ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_DeleteSlice #defaultString: '&amp;Delete Slice' #catalogID: #UIPainter) 							#enabled: false 							#nameKey: #deleteSlice							#value: #deleteSlice 							#shortcutKeyCharacter: $d ) ) #(1 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_View #defaultString: '&amp;View' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Load_backdrop #defaultString: 'Load &amp;backdrop...' #catalogID: #UIPainter) 							#value: #loadBackdrop 							#shortcutKeyCharacter: $b ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #_AllSlices #defaultString: '&amp;All Slices' #catalogID: #UIPainter) 							#enabled: false 							#nameKey: #showAllSlices							#value: #showAllSlices 							#shortcutKeyCharacter: $a ) ) #(2 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="UIPainter">paintPattern	"UIMaskEditor new openOnClass: self andSelector: #paintPattern"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 4@4 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[48 0 0 0 144 0 0 0 192 0 0 0 96 0 0 0])</body><body package="UIPainter">polygonIcon	"UIMaskEditor new openOnClass: self andSelector: #polygonIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 12 0 0 32 60 0 0 48 252 0 0 59 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 128 0 0 63 128 0 0 63 128 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">rectangleIcon	"UIMaskEditor new openOnClass: self andSelector: #rectangleIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 19@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[112 0 0 0 64 0 0 0 95 255 128 0 31 255 128 0 31 255 128 0 31 255 128 0 31 255 128 0 31 255 128 0 31 255 128 0 31 255 128 0 31 255 128 0 31 255 128 0 31 255 128 0 31 255 160 0 0 0 32 0 0 0 224 0])</body><body package="UIPainter">smallHorizBrush	"UIMaskEditor new openOnClass: self andSelector: #smallHorizBrush"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 2@1 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[192 0 0 0])</body><body package="UIPainter">smallVertBrush	"UIMaskEditor new openOnClass: self andSelector: #smallVertBrush"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 1@2 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[128 0 0 0 128 0 0 0])</body><body package="UIPainter">zebraPattern 	&lt;resource: #image&gt;	^(Image extent: 4@4 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[48 0 0 0 144 0 0 0 192 0 0 0 96 0 0 0]) asPattern</body></methods><methods><class-id>Tools.UIHotRegionEditor class</class-id> <category>interface specs</category><body package="UIPainter">oldSpec	"UIPainter new openOnClass: self andSelector: #oldSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #HotRegionsEditor #defaultString: 'Hot Regions Editor' #catalogID: #UIPainter) 			#bounds: #(#{Graphics.Rectangle} 583 443 1017 758 ) 			#flags: 4 			#menu: #mainMenuBar 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#ColorValue #black ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 5734 5734 5734 ) 				#setSelectionForegroundColor: #(#ColorValue #white ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 0 0 4112 ) ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 -98 1 0 0.403226 0 1.00338 ) 					#name: #hotRegionsList 					#model: #hotRegionsList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 81 0 0 0 0 1.0 -101 1 ) 					#flags: 11 					#component: #regionsView ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0.4 -70 1 0 0.9 -45 1 ) 					#name: #selectorField 					#flags: 40 					#model: #selectorAdaptor 					#type: #symbol ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 40 0 -37.5 0.375 80 0 -50 0.5 ) 					#name: #rectangleButton 					#flags: 0 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#ColorValue #black ) 						#setBackgroundColor: #(#ColorValue #white ) 						#setSelectionForegroundColor: #(#ColorValue #black ) 						#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 5734 5734 5734 ) ) 					#model: #rectangleMode 					#label: #rectangleIcon 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -37.5 0.375 40 0 -50 0.5 ) 					#name: #ellipseButton 					#flags: 0 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#ColorValue #black ) 						#setBackgroundColor: #(#ColorValue #white ) 						#setSelectionForegroundColor: #(#ColorValue #black ) 						#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 5734 5734 5734 ) ) 					#model: #ellipseMode 					#label: #ellipseIcon 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 80 0.4 -57 1 1 0.5 ) 					#name: #selectorLabel 					#flags: 32 					#label: #(#{Kernel.UserMessage} #key: #Selector #defaultString: 'Selector' #catalogID: #UIPainter) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 40 0 -12.5 0.125 60 0 -25 0.25 ) 					#name: #bigCircleButton 					#flags: 0 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#ColorValue #black ) 						#setBackgroundColor: #(#ColorValue #white ) 						#setSelectionForegroundColor: #(#ColorValue #black ) 						#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 5734 5734 5734 ) ) 					#model: #bigCircleBrush 					#label: #bigCircleBrush 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 60 0 -12.5 0.125 80 0 -25 0.25 ) 					#name: #bigSquareButton 					#flags: 0 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#ColorValue #black ) 						#setBackgroundColor: #(#ColorValue #white ) 						#setSelectionForegroundColor: #(#ColorValue #black ) 						#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 5734 5734 5734 ) ) 					#model: #bigSquareBrush 					#label: #bigSquareBrush 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -12.5 0.125 20 0 -25 0.25 ) 					#name: #smallHorizButton 					#flags: 0 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#ColorValue #black ) 						#setBackgroundColor: #(#ColorValue #white ) 						#setSelectionForegroundColor: #(#ColorValue #black ) 						#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 5734 5734 5734 ) ) 					#model: #smallHorizBrush 					#label: #smallHorizBrush 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 20 0 -12.5 0.125 40 0 -25 0.25 ) 					#name: #smallVertButton 					#flags: 0 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#ColorValue #black ) 						#setBackgroundColor: #(#ColorValue #white ) 						#setSelectionForegroundColor: #(#ColorValue #black ) 						#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 5734 5734 5734 ) ) 					#model: #smallVertBrush 					#label: #smallVertBrush 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 -62.5 0.625 80 0 -75 0.75 ) 					#name: #toggleButton 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #black ) 						#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) ) 					#model: #toggleCoverage 					#tabable: false 					#style: #small 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 40 0 0 0.0625 0.5 0.5 ) 					#label: #(#{Kernel.UserMessage} #key: #Brushes #defaultString: 'Brushes' #catalogID: #UIPainter) 					#style: #small ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 40 0 -31.25 0.3125 0.5 0.5 ) 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#ColorValue #black ) 						#setBackgroundColor: #(#ColorValue #white ) 						#setSelectionForegroundColor: #(#ColorValue #black ) 						#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 5734 5734 5734 ) ) 					#label: #(#{Kernel.UserMessage} #key: #Shapes #defaultString: 'Shapes' #catalogID: #UIPainter) 					#style: #small ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 41 0 -56.25 0.5625 0.5 0.5 ) 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#ColorValue #black ) 						#setBackgroundColor: #(#ColorValue #white ) 						#setSelectionForegroundColor: #(#ColorValue #black ) 						#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 5734 5734 5734 ) ) 					#label: #(#{Kernel.UserMessage} #key: #SetClear #defaultString: 'Set/Clear' #catalogID: #UIPainter) 					#style: #small ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 41 0 -81.25 0.8125 0.5 0.5 ) 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#ColorValue #black ) 						#setBackgroundColor: #(#ColorValue #white ) 						#setSelectionForegroundColor: #(#ColorValue #black ) 						#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 5734 5734 5734 ) ) 					#label: #(#{Kernel.UserMessage} #key: #SetColor #defaultString: '''Set'' Color' #catalogID: #UIPainter) 					#style: #small ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -87.5 0.875 20 0 -100 1 ) 					#name: #blackOnButton 					#flags: 0 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #black ) 						#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) ) 					#model: #blackOn 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 40 0 -87.5 0.875 60 0 -100 1 ) 					#name: #whiteOnButton 					#flags: 0 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) 						#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) ) 					#model: #whiteOn 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 60 0 -87.5 0.875 80 0 -100 1 ) 					#name: #redOnButton 					#flags: 0 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #red ) 						#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) ) 					#model: #redOn 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 20 0 -87.5 0.875 40 0 -100 1 ) 					#name: #zebraOnButton 					#flags: 0 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) ) 					#model: #zebraOn 					#defaultable: true ) ) ) )</body><body package="UIPainter">testSpec	"UIPainter new openOnClass: self andSelector: #testSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #HotRegionsEditor #defaultString: 'Hot Regions Editor' #catalogID: #UIPainter) 			#bounds: #(#{Graphics.Rectangle} 610 449 991 752 ) 			#flags: 4 			#menu: #mainMenuBar 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#ColorValue #black ) 				#setBackgroundColor: nil 				#setSelectionForegroundColor: #(#ColorValue #white ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 0 0 4112 ) ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.Rectangle} 3 3 65 60 ) 					#name: #regionColor 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #black ) ) 					#lineWidth: 1 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 89 0.5 3 0 -3 1 29 0 ) 					#name: #selectorField 					#flags: 40 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #selectorAdaptor 					#tabable: false 					#type: #symbol ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 4 4 64 59 ) 					#name: #toggleButton 					#flags: 0 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #black ) 						#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) ) 					#model: #toggleCoverage 					#tabable: false 					#style: #small ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 115 0 3 0 16 0.5 29 0 ) 					#name: #sliceMenu 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #selectedSliceChannel 					#menu: #sliceMenu 					#isPopUp: true ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.RegionSpec} 							#layout: #(#{Graphics.Rectangle} 0 0 43 57 ) 							#colors: 							#(#{UI.LookPreferences} 								#setBackgroundColor: #(#ColorValue #black ) ) 							#lineWidth: 1 ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.Rectangle} 22 1 42 28 ) 							#name: #blackOnButton 							#flags: 0 							#isOpaque: true 							#colors: 							#(#{UI.LookPreferences} 								#setBackgroundColor: #(#ColorValue #black ) 								#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) ) 							#model: #blackOn 							#tabable: false ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.Rectangle} 22 29 42 56 ) 							#name: #whiteOnButton 							#flags: 0 							#isOpaque: true 							#colors: 							#(#{UI.LookPreferences} 								#setBackgroundColor: #(#ColorValue #white ) 								#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) ) 							#model: #whiteOn 							#tabable: false ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.Rectangle} 1 1 21 28 ) 							#name: #redOnButton 							#flags: 0 							#isOpaque: true 							#colors: 							#(#{UI.LookPreferences} 								#setBackgroundColor: #(#ColorValue #red ) 								#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) ) 							#model: #redOn 							#tabable: false ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.Rectangle} 1 29 21 56 ) 							#name: #zebraOnButton 							#flags: 0 							#isOpaque: true 							#colors: 							#(#{UI.LookPreferences} 								#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) ) 							#model: #zebraOn 							#tabable: false ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 68 3 111 60 ) 						#name: #colorsComposite ) ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 63 0 0 1.0 0 1.0 ) 					#name: #regionsView 					#flags: 11 					#component: #regionsView ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 88 0.5 17 0 1 0.5 ) 					#name: #selectorLabel 					#flags: 32 					#label: #(#{Kernel.UserMessage} #key: #SelectorC #defaultString: 'Selector:' #catalogID: #UIPainter) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.CompositeSpecCollection} 							#collection: #(								#(#{UI.ActionButtonSpec} 									#layout: #(#{Graphics.Rectangle} 64 0 95 27 ) 									#name: #bigCircleButton 									#colors: 									#(#{UI.LookPreferences} 										#setSelectionForegroundColor: #(#ColorValue #black ) 										#setSelectionBackgroundColor: #(#ColorValue #white ) ) 									#model: #bigCircleBrush 									#tabable: false 									#label: #bigCircleBrush 									#hasCharacterOrientedLabel: false ) 								#(#{UI.ActionButtonSpec} 									#layout: #(#{Graphics.Rectangle} 96 0 127 27 ) 									#name: #bigSquareButton 									#colors: 									#(#{UI.LookPreferences} 										#setSelectionForegroundColor: #(#ColorValue #black ) 										#setSelectionBackgroundColor: #(#ColorValue #white ) ) 									#model: #bigSquareBrush 									#tabable: false 									#label: #bigSquareBrush 									#hasCharacterOrientedLabel: false ) 								#(#{UI.ActionButtonSpec} 									#layout: #(#{Graphics.Rectangle} 0 0 31 27 ) 									#name: #smallHorizButton 									#colors: 									#(#{UI.LookPreferences} 										#setSelectionForegroundColor: #(#ColorValue #black ) 										#setSelectionBackgroundColor: #(#ColorValue #white ) ) 									#model: #smallHorizBrush 									#tabable: false 									#label: #smallHorizBrush 									#hasCharacterOrientedLabel: false ) 								#(#{UI.ActionButtonSpec} 									#layout: #(#{Graphics.Rectangle} 32 0 63 27 ) 									#name: #smallVertButton 									#colors: 									#(#{UI.LookPreferences} 										#setSelectionForegroundColor: #(#ColorValue #black ) 										#setSelectionBackgroundColor: #(#ColorValue #white ) ) 									#model: #smallVertBrush 									#tabable: false 									#label: #smallVertBrush 									#hasCharacterOrientedLabel: false ) ) 							#compositeSpec: 							#(#{UI.CompositeSpec} 								#layout: #(#{Graphics.Rectangle} 0 0 127 27 ) ) ) 						#(#{UI.CompositeSpecCollection} 							#collection: #(								#(#{UI.ActionButtonSpec} 									#layout: #(#{Graphics.Rectangle} 32 0 65 27 ) 									#name: #rectangleButton 									#colors: 									#(#{UI.LookPreferences} 										#setSelectionForegroundColor: #(#ColorValue #black ) 										#setSelectionBackgroundColor: #(#ColorValue #white ) ) 									#model: #rectangleMode 									#tabable: false 									#label: #rectangleIcon 									#hasCharacterOrientedLabel: false ) 								#(#{UI.ActionButtonSpec} 									#layout: #(#{Graphics.Rectangle} 0 0 31 27 ) 									#name: #ellipseButton 									#colors: 									#(#{UI.LookPreferences} 										#setSelectionForegroundColor: #(#ColorValue #black ) 										#setSelectionBackgroundColor: #(#ColorValue #white ) ) 									#model: #ellipseMode 									#tabable: false 									#label: #ellipseIcon 									#hasCharacterOrientedLabel: false ) ) 							#compositeSpec: 							#(#{UI.CompositeSpec} 								#layout: #(#{Graphics.Rectangle} 147 0 212 27 ) ) ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.Rectangle} 233 0 264 27 ) 							#name: #fillButton 							#colors: 							#(#{UI.LookPreferences} 								#setSelectionForegroundColor: #(#ColorValue #black ) 								#setSelectionBackgroundColor: #(#ColorValue #white ) ) 							#model: #fillMode 							#tabable: false 							#label: #fillIcon 							#hasCharacterOrientedLabel: false ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 114 33 378 60 ) 						#name: #paintControls ) ) ) ) )</body><body package="UIPainter">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #HotRegionsEditor #defaultString: 'Hot Regions Editor' #catalogID: #UIPainter) 			#bounds: #(#{Graphics.Rectangle} 610 449 991 752 ) 			#flags: 4 			#menu: #mainMenuBar 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#ColorValue #black ) 				#setBackgroundColor: nil 				#setSelectionForegroundColor: #(#ColorValue #white ) 				#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 0 0 4112 ) ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.Rectangle} 3 3 65 60 ) 					#name: #regionColor 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #black ) ) 					#lineWidth: 1 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 89 0.5 3 0 -3 1 29 0 ) 					#name: #selectorField 					#flags: 40 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #selectorAdaptor 					#tabable: false 					#type: #symbol ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 4 4 64 59 ) 					#name: #toggleButton 					#flags: 0 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #black ) 						#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) ) 					#model: #toggleCoverage 					#tabable: false 					#style: #small ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 115 0 3 0 16 0.5 29 0 ) 					#name: #sliceMenu 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#ColorValue #white ) ) 					#model: #selectedSliceChannel 					#menu: #sliceMenu 					#isPopUp: true ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.RegionSpec} 							#layout: #(#{Graphics.Rectangle} 0 0 43 57 ) 							#colors: 							#(#{UI.LookPreferences} 								#setBackgroundColor: #(#ColorValue #black ) ) 							#lineWidth: 1 ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.Rectangle} 22 1 42 28 ) 							#name: #blackOnButton 							#flags: 0 							#isOpaque: true 							#colors: 							#(#{UI.LookPreferences} 								#setBackgroundColor: #(#ColorValue #black ) 								#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) ) 							#model: #blackOn 							#tabable: false ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.Rectangle} 22 29 42 56 ) 							#name: #whiteOnButton 							#flags: 0 							#isOpaque: true 							#colors: 							#(#{UI.LookPreferences} 								#setBackgroundColor: #(#ColorValue #white ) 								#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) ) 							#model: #whiteOn 							#tabable: false ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.Rectangle} 1 1 21 28 ) 							#name: #redOnButton 							#flags: 0 							#isOpaque: true 							#colors: 							#(#{UI.LookPreferences} 								#setBackgroundColor: #(#ColorValue #red ) 								#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) ) 							#model: #redOn 							#tabable: false ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.Rectangle} 1 29 21 56 ) 							#name: #zebraOnButton 							#flags: 0 							#isOpaque: true 							#colors: 							#(#{UI.LookPreferences} 								#setSelectionBackgroundColor: #(#{Graphics.ColorValue} 4915 4915 4915 ) ) 							#model: #zebraOn 							#tabable: false ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 68 3 111 60 ) 						#name: #colorsComposite ) ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 63 0 0 1.0 0 1.0 ) 					#name: #regionsView 					#flags: 11 					#component: #regionsView ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 88 0.5 17 0 1 0.5 ) 					#name: #selectorLabel 					#flags: 32 					#label: #(#{Kernel.UserMessage} #key: #SelectorC #defaultString: 'Selector:' #catalogID: #UIPainter) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.CompositeSpecCollection} 							#collection: #(								#(#{UI.ActionButtonSpec} 									#layout: #(#{Graphics.Rectangle} 64 0 95 27 ) 									#name: #bigCircleButton 									#colors: 									#(#{UI.LookPreferences} 										#setSelectionForegroundColor: #(#ColorValue #black ) 										#setSelectionBackgroundColor: #(#ColorValue #white ) ) 									#model: #bigCircleBrush 									#tabable: false 									#label: #bigCircleBrush 									#hasCharacterOrientedLabel: false ) 								#(#{UI.ActionButtonSpec} 									#layout: #(#{Graphics.Rectangle} 96 0 127 27 ) 									#name: #bigSquareButton 									#colors: 									#(#{UI.LookPreferences} 										#setSelectionForegroundColor: #(#ColorValue #black ) 										#setSelectionBackgroundColor: #(#ColorValue #white ) ) 									#model: #bigSquareBrush 									#tabable: false 									#label: #bigSquareBrush 									#hasCharacterOrientedLabel: false ) 								#(#{UI.ActionButtonSpec} 									#layout: #(#{Graphics.Rectangle} 0 0 31 27 ) 									#name: #smallHorizButton 									#colors: 									#(#{UI.LookPreferences} 										#setSelectionForegroundColor: #(#ColorValue #black ) 										#setSelectionBackgroundColor: #(#ColorValue #white ) ) 									#model: #smallHorizBrush 									#tabable: false 									#label: #smallHorizBrush 									#hasCharacterOrientedLabel: false ) 								#(#{UI.ActionButtonSpec} 									#layout: #(#{Graphics.Rectangle} 32 0 63 27 ) 									#name: #smallVertButton 									#colors: 									#(#{UI.LookPreferences} 										#setSelectionForegroundColor: #(#ColorValue #black ) 										#setSelectionBackgroundColor: #(#ColorValue #white ) ) 									#model: #smallVertBrush 									#tabable: false 									#label: #smallVertBrush 									#hasCharacterOrientedLabel: false ) ) 							#compositeSpec: 							#(#{UI.CompositeSpec} 								#layout: #(#{Graphics.Rectangle} 0 0 127 27 ) ) ) 						#(#{UI.CompositeSpecCollection} 							#collection: #(								#(#{UI.ActionButtonSpec} 									#layout: #(#{Graphics.Rectangle} 32 0 65 27 ) 									#name: #rectangleButton 									#colors: 									#(#{UI.LookPreferences} 										#setSelectionForegroundColor: #(#ColorValue #black ) 										#setSelectionBackgroundColor: #(#ColorValue #white ) ) 									#model: #rectangleMode 									#tabable: false 									#label: #rectangleIcon 									#hasCharacterOrientedLabel: false ) 								#(#{UI.ActionButtonSpec} 									#layout: #(#{Graphics.Rectangle} 0 0 31 27 ) 									#name: #ellipseButton 									#colors: 									#(#{UI.LookPreferences} 										#setSelectionForegroundColor: #(#ColorValue #black ) 										#setSelectionBackgroundColor: #(#ColorValue #white ) ) 									#model: #ellipseMode 									#tabable: false 									#label: #ellipseIcon 									#hasCharacterOrientedLabel: false ) ) 							#compositeSpec: 							#(#{UI.CompositeSpec} 								#layout: #(#{Graphics.Rectangle} 147 0 212 27 ) ) ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.Rectangle} 233 0 264 27 ) 							#name: #fillButton 							#colors: 							#(#{UI.LookPreferences} 								#setSelectionForegroundColor: #(#ColorValue #black ) 								#setSelectionBackgroundColor: #(#ColorValue #white ) ) 							#model: #fillMode 							#tabable: false 							#label: #fillIcon 							#hasCharacterOrientedLabel: false ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 114 33 378 60 ) 						#name: #paintControls ) ) ) ) )</body></methods><methods><class-id>Tools.PositionToolModel class</class-id> <category>resources</category><body package="UIPainter">downArrow	"UIMaskEditor new openOnClass: self andSelector: #downArrow"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 8@4 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 0 0 0 126 0 0 0 60 0 0 0 24 0 0 0 ])</body><body package="UIPainter">insetXIcon	"UIMaskEditor new openOnClass: self andSelector: #insetXIcon"	&lt;resource: #image&gt;	^Image extent: 20@16 depth: 1 palette: CoveragePalette monoMaskPalette bits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 96 0 6 6 96 0 3 131 192 0 127 225 128 0 3 131 192 0 6 6 96 0 0 6 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ] pad: 32</body><body package="UIPainter">insetYIcon	"UIMaskEditor new openOnClass: self andSelector: #insetYIcon"	&lt;resource: #image&gt;	^Image extent: 19@16 depth: 1 palette: CoveragePalette monoMaskPalette bits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 4 12 96 0 4 12 96 0 4 6 192 0 21 6 192 0 31 3 128 0 14 3 128 0 14 1 128 0 4 1 0 0 4 3 0 0 0 6 0 0 0 0 0 0 ] pad: 32</body><body package="UIPainter">leftArrow	"UIMaskEditor new openOnClass: self andSelector: #leftArrow"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 4@8 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[16 0 0 0 48 0 0 0 112 0 0 0 240 0 0 0 240 0 0 0 112 0 0 0 48 0 0 0 16 0 0 0 ])</body><body package="UIPainter">rightArrow	"UIMaskEditor new openOnClass: self andSelector: #rightArrow"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 4@8 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[128 0 0 0 192 0 0 0 224 0 0 0 240 0 0 0 240 0 0 0 224 0 0 0 192 0 0 0 128 0 0 0 ])</body><body package="UIPainter">toBoundedIcon	"UIMaskEditor new openOnClass: self andSelector: #toBoundedIcon"	&lt;resource: #image&gt;	^Image extent: 44@17 depth: 1 palette: CoveragePalette monoMaskPalette bits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 14 0 0 0 0 0 0 15 255 254 0 0 0 0 0 8 14 2 0 0 0 0 0 8 0 2 0 0 0 0 192 8 0 2 0 0 0 0 112 28 0 7 0 0 0 15 252 28 0 7 0 0 0 0 112 28 0 7 0 0 0 0 192 8 0 2 0 0 0 0 0 8 0 2 0 0 0 0 0 8 14 2 0 0 0 0 0 15 255 254 0 0 0 0 0 0 14 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ] pad: 32</body><body package="UIPainter">toOriginSizeIcon	"UIMaskEditor new openOnClass: self andSelector: #toOriginSizeIcon"	&lt;resource: #image&gt;	^(Image extent: 44@17 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 14 0 0 0 0 0 0 15 255 242 0 0 0 0 0 8 14 2 0 0 0 0 0 8 0 7 0 0 0 0 192 8 0 7 0 0 0 0 112 28 0 15 128 0 0 15 252 28 0 10 128 0 0 0 112 28 0 2 0 0 0 0 192 8 0 2 0 0 0 0 0 8 0 98 0 0 0 0 0 8 0 56 0 0 0 0 0 9 255 254 0 0 0 0 0 0 0 56 0 0 0 0 0 0 0 96 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">toUnboundedIcon	"UIMaskEditor new openOnClass: self andSelector: #toUnboundedIcon"	&lt;resource: #image&gt;	^Image extent: 44@17 depth: 1 palette: CoveragePalette monoMaskPalette bits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 14 0 0 0 0 0 0 15 255 254 0 0 0 0 0 8 14 2 0 0 0 0 0 8 0 0 0 0 0 0 192 8 0 2 0 0 0 0 112 28 14 2 0 0 0 15 252 28 14 0 0 0 0 0 112 28 14 2 0 0 0 0 192 8 0 2 0 0 0 0 0 8 0 0 0 0 0 0 0 8 0 2 0 0 0 0 0 11 109 182 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ] pad: 32</body><body package="UIPainter">upArrow	"UIMaskEditor new openOnClass: self andSelector: #upArrow"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 8@4 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[24 0 0 0 60 0 0 0 126 0 0 0 255 0 0 0 ])</body></methods><methods><class-id>Tools.PositionToolModel class</class-id> <category>interface specs</category><body package="UIPainter">layoutSpec	"UIPainter new openOnClass: self andSelector: #layoutSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#bounds: #(#{Graphics.Rectangle} 684 482 917 719 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.Rectangle} 43 48 187 183 ) 					#lineWidth: 1 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 27 105 60 125 ) 					#isOpaque: true 					#menu: #fieldMenu 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 102 171 135 194 ) 					#isOpaque: true 					#menu: #fieldMenu 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 167 106 200 125 ) 					#isOpaque: true 					#menu: #fieldMenu 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 102 38 135 61 ) 					#isOpaque: true 					#menu: #fieldMenu 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 140 100 170 130 ) 					#label: #leftArrow 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 57 100 87 130 ) 					#label: #rightArrow 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 0 100 30 130 ) 					#label: #leftArrow 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 197 100 227 130 ) 					#label: #rightArrow 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 103 11 133 41 ) 					#label: #upArrow 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 103 58 133 88 ) 					#label: #downArrow 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 103 191 133 221 ) 					#label: #downArrow 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 103 144 133 174 ) 					#label: #upArrow 					#hasCharacterOrientedLabel: false 					#defaultable: true ) ) ) )</body><body package="UIPainter">propSpec	"Tools.UIPainter new openOnClass: self andSelector: #propSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #PositionTool 				#defaultString: 'Position Tool' 				#catalogID: #UIPainter ) 			#min: #(#{Core.Point} 258 265 ) 			#max: #(#{Core.Point} 407 258 ) 			#bounds: #(#{Graphics.Rectangle} 688 326 946 591 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 1 0 -26 0.5 22 0 ) 							#name: #leftFractionField 							#model: #leftFraction 							#menu: #fieldMenu 							#alignment: #center ) 						#(#{UI.SliderSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 22 0 -26 0.5 41 0 ) 							#name: #leftFractionSlider 							#model: #leftSlide 							#orientation: #horizontal 							#start: 0 							#stop: 1.0 							#step: 0.0833333 ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} -13 0.5 1 0 -41 1 22 0 ) 							#name: #leftOffsetField 							#model: #leftOffset 							#menu: #fieldMenu 							#alignment: #center ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.LayoutFrame} -32 1 1 0 -1 1 22 0 ) 							#name: #emptyLeftButton 							#model: #emptyLeft 							#tabable: true 							#helpText: 							#(#{Kernel.UserMessage} 								#key: #GenKey19 								#defaultString: 'Clear Left Proportion and Offset' 								#catalogID: #UIPainter ) 							#label: 							#(#{Kernel.UserMessage} 								#key: #Ã 								#defaultString: 'Ã' 								#catalogID: #UIPainter ) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 50 0 27 0 -9 1 68 0 ) 						#name: #leftFraction ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 1 0 -26 0.5 22 0 ) 							#name: #topFractionField 							#model: #topFraction 							#menu: #fieldMenu 							#alignment: #center ) 						#(#{UI.SliderSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 22 0 -26 0.5 41 0 ) 							#name: #topFractionSlider 							#model: #topSlide 							#orientation: #horizontal 							#start: 0 							#stop: 1.0 							#step: 0.0833333 ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} -13 0.5 1 0 -41 1 22 0 ) 							#name: #topOffsetField 							#model: #topOffset 							#menu: #fieldMenu 							#alignment: #center ) 						#(#{UI.ActionButtonSpec} 							#layout: #(#{Graphics.LayoutFrame} -32 1 1 0 -1 1 22 0 ) 							#name: #emptyTopButton 							#model: #emptyTop 							#tabable: true 							#helpText: 							#(#{Kernel.UserMessage} 								#key: #GenKey18 								#defaultString: 'Clear Top Proportion and Offset' 								#catalogID: #UIPainter ) 							#label: 							#(#{Kernel.UserMessage} 								#key: #Ã 								#defaultString: 'Ã' 								#catalogID: #UIPainter ) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 50 0 69 0 -9 1 110 0 ) 						#name: #topFraction ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.CompositeSpecCollection} 							#collection: #(								#(#{UI.InputFieldSpec} 									#layout: #(#{Graphics.LayoutFrame} 0 0 1 0 -26 0.5 22 0 ) 									#name: #alignmentYField 									#model: #alignmentY 									#menu: #fieldMenu 									#alignment: #center ) 								#(#{UI.SliderSpec} 									#layout: #(#{Graphics.LayoutFrame} 0 0 23 0 -26 0.5 42 0 ) 									#name: #alignmentYSlider 									#model: #alignmentYSlide 									#orientation: #horizontal 									#start: 0 									#stop: 1.0 									#step: 0.0833333 ) 								#(#{UI.ActionButtonSpec} 									#layout: #(#{Graphics.LayoutFrame} -32 1 1 0 -1 1 22 0 ) 									#name: #emptyAlignmentYButton 									#model: #emptyAlignmentY 									#tabable: true 									#helpText: 									#(#{Kernel.UserMessage} 										#key: #ClearYProportion 										#defaultString: 'Clear Y Proportion' 										#catalogID: #UIPainter ) 									#label: 									#(#{Kernel.UserMessage} 										#key: #Ã 										#defaultString: 'Ã' 										#catalogID: #UIPainter ) ) ) 							#compositeSpec: 							#(#{UI.CompositeSpec} 								#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 41 0 ) 								#name: #alignmentY ) ) 						#(#{UI.CompositeSpecCollection} 							#collection: #(								#(#{UI.InputFieldSpec} 									#layout: #(#{Graphics.LayoutFrame} 0 0 1 0 -26 0.5 22 0 ) 									#name: #bottomFractionField 									#model: #bottomFraction 									#menu: #fieldMenu 									#alignment: #center ) 								#(#{UI.SliderSpec} 									#layout: #(#{Graphics.LayoutFrame} 0 0 23 0 -26 0.5 42 0 ) 									#name: #bottomFractionSlider 									#model: #bottomSlide 									#orientation: #horizontal 									#start: 0 									#stop: 1.0 									#step: 0.0833333 ) 								#(#{UI.InputFieldSpec} 									#layout: #(#{Graphics.LayoutFrame} -13 0.5 1 0 -41 1 22 0 ) 									#name: #bottomOffsetField 									#model: #bottomOffset 									#menu: #fieldMenu 									#alignment: #center ) 								#(#{UI.ActionButtonSpec} 									#layout: #(#{Graphics.LayoutFrame} -32 1 1 0 -1 1 22 0 ) 									#name: #emptyBottomButton 									#model: #emptyBottom 									#tabable: true 									#helpText: 									#(#{Kernel.UserMessage} 										#key: #GenKey16 										#defaultString: 'Clear Bottom Proportion and Offset' 										#catalogID: #UIPainter ) 									#label: 									#(#{Kernel.UserMessage} 										#key: #Ã 										#defaultString: 'Ã' 										#catalogID: #UIPainter ) ) ) 							#compositeSpec: 							#(#{UI.CompositeSpec} 								#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 32 0 ) 								#name: #bottomFraction ) ) 						#(#{UI.CompositeSpecCollection} 							#collection: #(								#(#{UI.InputFieldSpec} 									#layout: #(#{Graphics.LayoutFrame} 0 0 1 0 -26 0.5 22 0 ) 									#name: #sizeWidthField 									#model: #sizeWidth 									#menu: #fieldMenu 									#alignment: #center ) 								#(#{UI.ActionButtonSpec} 									#layout: #(#{Graphics.LayoutFrame} -32 1 1 0 -1 1 22 0 ) 									#name: #emptyWidthButton 									#model: #emptyWidth 									#tabable: true 									#helpText: 									#(#{Kernel.UserMessage} 										#key: #ClearWidth 										#defaultString: 'Clear Width' 										#catalogID: #UIPainter ) 									#label: 									#(#{Kernel.UserMessage} 										#key: #Ã 										#defaultString: 'Ã' 										#catalogID: #UIPainter ) ) ) 							#compositeSpec: 							#(#{UI.CompositeSpec} 								#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 23 0 ) 								#name: #sizeWidth ) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 50 0 157 0 -9 1 198 0 ) 						#name: #alignBottomWidth ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.CompositeSpecCollection} 							#collection: #(								#(#{UI.InputFieldSpec} 									#layout: #(#{Graphics.LayoutFrame} 0 0 1 0 -26 0.5 22 0 ) 									#name: #rightFractionField 									#model: #rightFraction 									#menu: #fieldMenu 									#alignment: #center ) 								#(#{UI.SliderSpec} 									#layout: #(#{Graphics.LayoutFrame} 0 0 24 0 -26 0.5 43 0 ) 									#name: #rightFractionSlider 									#model: #rightSlide 									#orientation: #horizontal 									#start: 0 									#stop: 1.0 									#step: 0.0833333 ) 								#(#{UI.InputFieldSpec} 									#layout: #(#{Graphics.LayoutFrame} -13 0.5 1 0 -41 1 22 0 ) 									#name: #rightOffsetField 									#model: #rightOffset 									#menu: #fieldMenu 									#alignment: #center ) 								#(#{UI.ActionButtonSpec} 									#layout: #(#{Graphics.LayoutFrame} -32 1 1 0 -1 1 22 0 ) 									#name: #emptyRightButton 									#model: #emptyRight 									#tabable: true 									#helpText: 									#(#{Kernel.UserMessage} 										#key: #GenKey17 										#defaultString: 'Clear Right Proportion and Offset' 										#catalogID: #UIPainter ) 									#label: 									#(#{Kernel.UserMessage} 										#key: #Ã 										#defaultString: 'Ã' 										#catalogID: #UIPainter ) ) ) 							#compositeSpec: 							#(#{UI.CompositeSpec} 								#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 32 0 ) 								#name: #rightFraction ) ) 						#(#{UI.CompositeSpecCollection} 							#collection: #(								#(#{UI.InputFieldSpec} 									#layout: #(#{Graphics.LayoutFrame} 0 0 1 0 -26 0.5 22 0 ) 									#name: #sizeHeightField 									#model: #sizeHeight 									#menu: #fieldMenu 									#alignment: #center ) 								#(#{UI.ActionButtonSpec} 									#layout: #(#{Graphics.LayoutFrame} -32 1 1 0 -1 1 22 0 ) 									#name: #emptyHeightButton 									#model: #emptyHeight 									#tabable: true 									#helpText: 									#(#{Kernel.UserMessage} 										#key: #ClearHeight 										#defaultString: 'Clear Height' 										#catalogID: #UIPainter ) 									#label: 									#(#{Kernel.UserMessage} 										#key: #Ã 										#defaultString: 'Ã' 										#catalogID: #UIPainter ) ) ) 							#compositeSpec: 							#(#{UI.CompositeSpec} 								#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 22 0 ) 								#name: #sizeHeight ) ) 						#(#{UI.CompositeSpecCollection} 							#collection: #(								#(#{UI.InputFieldSpec} 									#layout: #(#{Graphics.LayoutFrame} 0 0 1 0 -26 0.5 22 0 ) 									#name: #alignmentXField 									#model: #alignmentX 									#menu: #fieldMenu 									#alignment: #center ) 								#(#{UI.SliderSpec} 									#layout: #(#{Graphics.LayoutFrame} 0 0 24 0 -26 0.5 43 0 ) 									#name: #alignmentXSlider 									#model: #alignmentXSlide 									#orientation: #horizontal 									#start: 0 									#stop: 1.0 									#step: 0.0833333 ) 								#(#{UI.ActionButtonSpec} 									#layout: #(#{Graphics.LayoutFrame} -32 1 1 0 -1 1 22 0 ) 									#name: #emptyAlignmentXButton 									#model: #emptyAlignmentX 									#tabable: true 									#helpText: 									#(#{Kernel.UserMessage} 										#key: #ClearXAlignment 										#defaultString: 'Clear X Alignment' 										#catalogID: #UIPainter ) 									#label: 									#(#{Kernel.UserMessage} 										#key: #Ã 										#defaultString: 'Ã' 										#catalogID: #UIPainter ) ) ) 							#compositeSpec: 							#(#{UI.CompositeSpec} 								#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 0 43 0 ) 								#name: #alignmentX ) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 50 0 114 0 -9 1 155 0 ) 						#name: #alignRightHeight ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 -81 1 61 0 -57 1 ) 					#name: #boundedButton 					#flags: 40 					#model: #makeBounded 					#tabable: true 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #MakeBounded 						#defaultString: 'Make Bounded' 						#catalogID: #UIPainter ) 					#label: #toBoundedIcon 					#hasCharacterOrientedLabel: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 -27 1 48 0.5 -3 1 ) 					#name: #clearAllButton 					#model: #emptyAllFields 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #ClearAll 						#defaultString: 'Clear All' 						#catalogID: #UIPainter ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 -27 1 61 0 -3 1 ) 					#name: #originSizeButton 					#flags: 40 					#model: #makeOriginSize 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #GenKey15 						#defaultString: 'Make Origin + Width and Height' 						#catalogID: #UIPainter ) 					#label: #toOriginSizeIcon 					#hasCharacterOrientedLabel: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -74 1 -54 1 -6 1 -30 1 ) 					#name: #readButton 					#model: #readMode 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #Read 						#defaultString: 'Read' 						#catalogID: #UIPainter ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -60 0.5 -54 1 48 0.5 -30 1 ) 					#name: #clearOffsetsButton 					#model: #emptyOffsets 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #ClrOffsets 						#defaultString: 'Clr Offsets' 						#catalogID: #UIPainter ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 -54 1 61 0 -30 1 ) 					#name: #unboundedButton 					#model: #makeUnbounded 					#tabable: true 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #MakeUnbounded 						#defaultString: 'Make Unbounded' 						#catalogID: #UIPainter ) 					#label: #toUnboundedIcon 					#hasCharacterOrientedLabel: false ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 49 0 1 0 ) 					#name: #labelProportion 					#label: 					#(#{Kernel.UserMessage} 						#key: #Proportion 						#defaultString: 'Proportion' 						#catalogID: #UIPainter ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.531008 1 0 ) 					#name: #labelOffset 					#label: 					#(#{Kernel.UserMessage} 						#key: #Offset 						#defaultString: 'Offset' 						#catalogID: #UIPainter ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 6 0 4 0 ) 							#name: #labelX 							#flags: 16 							#label: 							#(#{Kernel.UserMessage} 								#key: #X 								#defaultString: 'X' 								#catalogID: #UIPainter ) ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 91 0 ) 							#name: #labelInsetX 							#flags: 16 							#label: #insetXIcon 							#hasCharacterOrientedLabel: false ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 134 0 ) 							#name: #labelInsetY 							#flags: 16 							#label: #insetYIcon 							#hasCharacterOrientedLabel: false ) 						#(#{UI.LabelSpec} 							#layout: #(#{UI.AlignmentOrigin} 6 0 45 0 0 0 ) 							#name: #labelY 							#flags: 16 							#label: 							#(#{Kernel.UserMessage} 								#key: #Y 								#defaultString: 'Y' 								#catalogID: #UIPainter ) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 7 0 29 0 31 0 160 0 ) 						#name: #unboundedLabelGroup ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 4 0 ) 							#name: #labelLeft 							#label: 							#(#{Kernel.UserMessage} 								#key: #L 								#defaultString: 'L' 								#catalogID: #UIPainter ) ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 45 0 ) 							#name: #labelTop 							#label: 							#(#{Kernel.UserMessage} 								#key: #T 								#defaultString: 'T' 								#catalogID: #UIPainter ) ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 91 0 ) 							#name: #labelRight 							#label: 							#(#{Kernel.UserMessage} 								#key: #R 								#defaultString: 'R' 								#catalogID: #UIPainter ) ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 134 0 ) 							#name: #labelBottom 							#label: 							#(#{Kernel.UserMessage} 								#key: #B 								#defaultString: 'B' 								#catalogID: #UIPainter ) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 14 0 29 0 26 0 161 0 ) 						#name: #boundedLabelGroup ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 15 0 4 0 ) 							#name: #sizeLabelX 							#label: 							#(#{Kernel.UserMessage} 								#key: #X 								#defaultString: 'X' 								#catalogID: #UIPainter ) ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 15 0 45 0 ) 							#name: #sizeLabelY 							#label: 							#(#{Kernel.UserMessage} 								#key: #Y 								#defaultString: 'Y' 								#catalogID: #UIPainter ) ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 0 0 91 0 ) 							#name: #sizeLabelHeight 							#label: 							#(#{Kernel.UserMessage} 								#key: #Height 								#defaultString: 'Height' 								#catalogID: #UIPainter ) ) 						#(#{UI.LabelSpec} 							#layout: #(#{Graphics.LayoutOrigin} 2 0 134 0 ) 							#name: #sizeLabelWidth 							#label: 							#(#{Kernel.UserMessage} 								#key: #Width 								#defaultString: 'Width' 								#catalogID: #UIPainter ) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 5 0 28 0 48 0 163 0 ) 						#name: #originSizeGroup ) ) ) ) )</body><body package="UIPainter">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#bounds: #(#{Graphics.Rectangle} 684 482 917 719 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.Rectangle} 43 48 187 183 ) 					#lineWidth: 1 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 27 105 60 125 ) 					#isOpaque: true 					#menu: #fieldMenu 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 102 171 135 194 ) 					#isOpaque: true 					#menu: #fieldMenu 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 167 106 200 125 ) 					#isOpaque: true 					#menu: #fieldMenu 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 102 38 135 61 ) 					#isOpaque: true 					#menu: #fieldMenu 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 140 100 170 130 ) 					#label: #leftArrow 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 57 100 87 130 ) 					#label: #rightArrow 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 0 100 30 130 ) 					#label: #leftArrow 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 197 100 227 130 ) 					#label: #rightArrow 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 103 11 133 41 ) 					#label: #upArrow 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 103 58 133 88 ) 					#label: #downArrow 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 103 191 133 221 ) 					#label: #downArrow 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 103 144 133 174 ) 					#label: #upArrow 					#hasCharacterOrientedLabel: false 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.CodingAssistant class</class-id> <category>interface specs</category><body package="UIPainter">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #CodingAssistant 				#defaultString: 'Coding Assistant' 				#catalogID: #UIPainter ) 			#min: #(#{Core.Point} 242 320 ) 			#max: #(#{Core.Point} 242 320 ) 			#bounds: #(#{Graphics.Rectangle} 153 75 395 395 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 14 0 12 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #ADDACCESSORSToClass 						#defaultString: 'ADD ACCESSORS to Class' 						#catalogID: #UIPainter ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 16 0 65 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #forInstanceVariables 						#defaultString: 'for Instance Variables' 						#catalogID: #UIPainter ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 -128 1 -14 1 -14 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #AccessingMethods 						#defaultString: ' Accessing Methods ' 						#catalogID: #UIPainter ) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 85 0 -14 1 -134 1 ) 					#model: #instVarList 					#multipleSelections: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} -56 0.5 -95 1 0.5 0.5 ) 					#model: #readAccessing 					#label: 					#(#{Kernel.UserMessage} 						#key: #read 						#defaultString: 'read' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} -55 0.5 -74 1 0.5 0.5 ) 					#model: #writeAccessing 					#label: 					#(#{Kernel.UserMessage} 						#key: #write 						#defaultString: 'write' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.644628 -74 1 0.5 0.5 ) 					#name: #dependency 					#model: #dependency 					#label: 					#(#{Kernel.UserMessage} 						#key: #dependency 						#defaultString: 'dependency' 						#catalogID: #UIPainter ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 25 0 -55 1 -24 1 -23 1 ) 					#name: #defineButton 					#model: #apply 					#label: 					#(#{Kernel.UserMessage} 						#key: #Define 						#defaultString: 'Define' 						#catalogID: #UIPainter ) 					#isDefault: true ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0 38 0 -14 1 60 0 ) 					#flags: 0 					#majorKey: #{EntryWithPasteButtonModule} 					#minorKey: #windowSpec 					#clientKey: #finder ) ) ) )</body></methods><methods><class-id>Tools.DataSetSpecColumnModel class</class-id> <category>resources</category><body package="UIPainter">columnTypesMenu	"Tools.MenuEditor new openOnClass: self andSelector: #columnTypesMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ReadOnly 					#defaultString: 'Read Only' 					#catalogID: #UIPainter ) 				#value: #None ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #InputField 					#defaultString: 'Input Field' 					#catalogID: #UIPainter ) 				#value: #InputField ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ComboBox 					#defaultString: 'Combo Box' 					#catalogID: #UIPainter ) 				#value: #ComboBox ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #CheckBox 					#defaultString: 'Check Box' 					#catalogID: #UIPainter ) 				#value: #CheckBox ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #RowSelector 					#defaultString: 'Row Selector' 					#catalogID: #UIPainter ) 				#value: #rowSelector 				#visible: false ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ArbitraryView 					#defaultString: 'Arbitrary View' 					#catalogID: #UIPainter ) 				#value: #Arbitrary ) ) #(6 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.DataSetSpecColumnModel class</class-id> <category>interface specs</category><body package="UIPainter">columnEditSpecLiteral	"UIPainter new openOnClass: self andSelector: #columnEditSpecLiteral"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#min: #(#{Core.Point} 440 472 ) 			#max: #(#{Core.Point} 440 472 ) 			#bounds: #(#{Graphics.Rectangle} 935 544 1375 1016 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#name: #Label1 					#label: #(#{Kernel.UserMessage} #key: #Dataset #defaultString: 'Dataset' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 59 ) 					#name: #labelIsImageButton 					#model: #labelIsImage 					#label: #(#{Kernel.UserMessage} #key: #LabelIsImage #defaultString: 'Label Is Image' #catalogID: #UIPainter) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 91 0 ) 							#name: #Label2 							#label: #(#{Kernel.UserMessage} #key: #FontC #defaultString: 'Font:' #catalogID: #UIPainter) ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 8 0 ) 							#name: #Label3 							#label: #(#{Kernel.UserMessage} #key: #WidthC #defaultString: 'Width:' #catalogID: #UIPainter) ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.Rectangle} 50 0 89 25 ) 							#name: #InputField1 							#model: #width 							#menu: #fieldMenu 							#type: #number ) 						#(#{UI.MenuButtonSpec} 							#layout: #(#{Graphics.LayoutFrame} 125 0 0 0 0 1 25 0 ) 							#name: #labelFont 							#model: #labelFont 							#menu: #fontMenu ) 						#(#{UI.CompositeSpecCollection} 							#collection: #(								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 0 0 ) 									#name: #Label4 									#label: #(#{Kernel.UserMessage} #key: #AspectC #defaultString: 'Aspect:' #catalogID: #UIPainter) ) 								#(#{UI.InputFieldSpec} 									#layout: #(#{Graphics.LayoutFrame} 50 0 0 0 0 1 25 0 ) 									#name: #aspect 									#model: #modelGen 									#menu: #fieldMenu 									#type: #string ) ) 							#compositeSpec: 							#(#{UI.CompositeSpec} 								#layout: #(#{Graphics.LayoutFrame} 0 0.0 29 0 0 1.0 54 0 ) 								#name: #aspectGroup ) ) 						#(#{UI.CompositeSpecCollection} 							#collection: #(								#(#{UI.LabelSpec} 									#layout: #(#{Core.Point} 10 0 ) 									#name: #Label5 									#label: #(#{Kernel.UserMessage} #key: #TypeC #defaultString: 'Type:' #catalogID: #UIPainter) ) 								#(#{UI.MenuButtonSpec} 									#layout: #(#{Graphics.Rectangle} 50 0 193 25 ) 									#name: #columnType 									#model: #columnType 									#menu: #columnTypesMenu ) ) 							#compositeSpec: 							#(#{UI.CompositeSpec} 								#layout: #(#{Graphics.Rectangle} 0 58 213 83 ) 								#name: #typeGroup ) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 197 60 ) 							#name: #CheckBox1 							#model: #frozen 							#label: #(#{Kernel.UserMessage} #key: #Fixed #defaultString: 'Fixed' #catalogID: #UIPainter) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 49 82 ) 							#name: #allowSorting 							#model: #allowSorting 							#label: #(#{Kernel.UserMessage} #key: #AllowSorting #defaultString: 'Allow Sorting' #catalogID: #UIPainter) ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Core.Point} 157 82 ) 							#name: #allowResizing 							#model: #allowResizing 							#label: #(#{Kernel.UserMessage} #key: #AllowResizing #defaultString: 'Allow Resizing' #catalogID: #UIPainter) )  ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 90 0 -10 1 195 0 ) 						#name: #nonlabelFields ) ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 28 0 -10 1 59 0 ) 					#name: #label 					#flags: 0 					#majorKey: #{Tools.UIPainterTool} 					#minorKey: #labelConstructorSpec 					#clientKey: #labelConstructor ) ) ) )</body></methods><methods><class-id>Tools.ResourceInstallDialog class</class-id> <category>interface specs</category><body package="UIPainter">loadOnlySpec	"Tools.UIPainter new openOnClass: self andSelector: #loadOnlySpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #InstallResource 				#defaultString: 'Install Resource' 				#catalogID: #UIPainter ) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 503 420 778 570 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 25 0 0 1 ) 					#name: #ClassLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #ClassC 						#defaultString: 'Class:' 						#catalogID: #UIPainter ) ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 25 0 -10 1 50 0 ) 					#name: #classField 					#flags: 0 					#majorKey: #{EntryWithPasteButtonModule} 					#minorKey: #windowSpec 					#clientKey: #classModule ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 12 0 75 0 0 1 ) 					#name: #SelectorLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #SelectorC 						#defaultString: 'Selector:' 						#catalogID: #UIPainter ) ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 75 0 -10 1 100 0 ) 					#name: #selectorComboBox 					#model: #selectorHolder 					#isReadOnly: false 					#comboList: #existingSelectorsHolder ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 46 0 -31 1 127 0 -8 1 ) 					#name: #okButton 					#flags: 40 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #UIPainter ) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -126 1 -31 1 -45 1 -8 1 ) 					#name: #cancelButton 					#model: #closeCancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #UIPainter ) 					#defaultable: true ) ) ) )</body><body package="UIPainter">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #InstallResource 				#defaultString: 'Install Resource' 				#catalogID: #UIPainter ) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 840 525 1115 675 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 25 0 0 1 ) 					#name: #ClassLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #ClassC 						#defaultString: 'Class:' 						#catalogID: #UIPainter ) ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 25 0 -40 1 50 0 ) 					#name: #classField 					#flags: 0 					#majorKey: #{EntryWithPasteButtonModule} 					#minorKey: #windowSpec 					#clientKey: #classModule ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Graphics.LayoutFrame} -35 1 25 0 -10 1 50 0 ) 					#name: #createNewClass 					#model: #openClassDialog 					#label: #newClassGraphic 					#hasCharacterOrientedLabel: false ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 12 0 75 0 0 1 ) 					#name: #SelectorLabel 					#label: 					#(#{Kernel.UserMessage} 						#key: #SelectorC 						#defaultString: 'Selector:' 						#catalogID: #UIPainter ) ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 75 0 -10 1 100 0 ) 					#name: #selectorComboBox 					#model: #selectorHolder 					#isReadOnly: false 					#comboList: #existingSelectorsHolder ) 				#(#{UI.ActionButtonSpec} 					#layout:  #(#{Graphics.LayoutFrame} 46 0 -31 1 127 0 -8 1 ) 					#name: #okButton 					#flags: 40 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #UIPainter ) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -126 1 -31 1 -45 1 -8 1 ) 					#name: #cancelButton 					#model: #closeCancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #UIPainter ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.WindowOpenPositionToolModel class</class-id> <category>interface specs</category><body package="UIPainter">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#bounds: #(#{Graphics.Rectangle} 800 600 1094 890 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.DividerSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 11 0 0 1.0 15 0 ) 							#name: #Divider4 ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 7 0 ) 							#name: #Label6 							#isOpaque: true 							#label: #(#{Kernel.UserMessage} #key: #Position #defaultString: 'Position' #catalogID: #UIPainter) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} -1 46 295 71 ) 						#name: #Composite2 ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.DividerSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 13 0 0 1.0 17 0 ) 							#name: #Divider5 ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 7 0 ) 							#name: #Label7 							#isOpaque: true 							#label: #(#{Kernel.UserMessage} #key: #Size1 #defaultString: 'Size' #catalogID: #UIPainter) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} -1 157 295 182 ) 						#name: #Composite1 ) ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 10 0 ) 					#name: #systemDefault 					#model: #openType 					#label: #(#{Kernel.UserMessage} #key: #SystemDefault #defaultString: 'System Default' #catalogID: #UIPainter) 					#select: #systemDefault ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 10 16 ) 					#name: #userPlacement 					#model: #openType 					#label: #(#{Kernel.UserMessage} #key: #UserPlacement #defaultString: 'User Placement' #catalogID: #UIPainter) 					#select: #userPlacement ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 10 32 ) 					#name: #advanced 					#model: #openType 					#label: #(#{Kernel.UserMessage} #key: #AdvancedC #defaultString: 'Advanced:' #catalogID: #UIPainter) 					#select: #advanced ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 10 61 ) 					#name: #positionSystemDefault 					#flags: 32 					#model: #positionType 					#label: #(#{Kernel.UserMessage} #key: #GenKey162 #defaultString: 'System Default (Center/User Placement)' #catalogID: #UIPainter) 					#select: #positionSystemDefault ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 10 77 ) 					#name: #screenCenter 					#flags: 32 					#model: #positionType 					#label: #(#{Kernel.UserMessage} #key: #ScreenCenter #defaultString: 'Screen Center' #catalogID: #UIPainter) 					#select: #screenCenter ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 10 93 ) 					#name: #mouseCenter 					#flags: 32 					#model: #positionType 					#label: #(#{Kernel.UserMessage} #key: #MouseCenter #defaultString: 'Mouse Center' #catalogID: #UIPainter) 					#select: #mouseCenter ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 10 109 ) 					#name: #lastSavedPosition 					#flags: 32 					#model: #positionType 					#label: #(#{Kernel.UserMessage} #key: #LastSavedPostion #defaultString: 'Last/Saved Postion' #catalogID: #UIPainter) 					#select: #lastSavedPosition ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 10 125 ) 					#name: #cascade 					#flags: 32 					#model: #positionType 					#label: #(#{Kernel.UserMessage} #key: #Cascade #defaultString: 'Cascade' #catalogID: #UIPainter) 					#select: #cascade ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 10 141 ) 					#name: #specifiedPosition 					#flags: 32 					#model: #positionType 					#label: #(#{Kernel.UserMessage} #key: #SpecifiedPosition #defaultString: 'Specified Position:' #catalogID: #UIPainter) 					#select: #specifiedPosition ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 10 174 ) 					#name: #lastSavedSize 					#flags: 32 					#model: #sizeType 					#label: #(#{Kernel.UserMessage} #key: #LastSavedSize #defaultString: 'Last/Saved Size' #catalogID: #UIPainter) 					#select: #lastSavedSize ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 10 191 ) 					#name: #specifiedSize 					#flags: 32 					#model: #sizeType 					#label: #(#{Kernel.UserMessage} #key: #SpecifiedSize #defaultString: 'Specified Size:' #catalogID: #UIPainter) 					#select: #specifiedSize ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 66 234 113 257 ) 					#name: #width 					#model: #width 					#alignment: #center 					#numChars: 4 					#type: #number 					#formatString: '0' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 66 257 113 280 ) 					#name: #height 					#model: #height 					#alignment: #center 					#numChars: 4 					#type: #number 					#formatString: '0' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 149 234 196 257 ) 					#name: #minimumWidth 					#model: #minimumWidth 					#alignment: #center 					#numChars: 4 					#type: #number 					#formatString: '0' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 149 257 196 280 ) 					#name: #minimumHeight 					#model: #minimumHeight 					#alignment: #center 					#numChars: 4 					#type: #number 					#formatString: '0' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 232 234 279 257 ) 					#name: #maximumWidth 					#model: #maximumWidth 					#alignment: #center 					#numChars: 4 					#type: #number 					#formatString: '0' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 232 257 279 280 ) 					#name: #maximumHeight 					#model: #maximumHeight 					#alignment: #center 					#numChars: 4 					#type: #number 					#formatString: '0' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 6 233 ) 					#name: #Label1 					#label: #(#{Kernel.UserMessage} #key: #Width #defaultString: 'Width' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 1 255 ) 					#name: #Label2 					#label: #(#{Kernel.UserMessage} #key: #Height #defaultString: 'Height' #catalogID: #UIPainter) ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 50 0 219 0 1 1 223 0 ) 					#name: #Divider2 ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 47 219 132 283 ) 					#name: #specifiedGroupBox ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 50 0 281 0 1 1 285 0 ) 					#name: #Divider3 ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.Rectangle} 214 220 218 282 ) 					#name: #Divider1 					#orientation: #vertical ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 168 143 215 166 ) 					#name: #xPosition 					#flags: 40 					#model: #xPosition 					#alignment: #center 					#numChars: 4 					#type: #number 					#formatString: '0' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 234 143 281 166 ) 					#name: #yPosition 					#flags: 40 					#model: #yPosition 					#alignment: #center 					#numChars: 4 					#type: #number 					#formatString: '0' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 185 122 ) 					#name: #xLabel 					#flags: 32 					#label: #(#{Kernel.UserMessage} #key: #X #defaultString: 'X' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 251 122 ) 					#name: #yLabel 					#flags: 32 					#label: #(#{Kernel.UserMessage} #key: #Y #defaultString: 'Y' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 168 109 ) 					#name: #positionAutoSave 					#flags: 32 					#model: #positionAutoSave 					#label: #(#{Kernel.UserMessage} #key: #AutoSave #defaultString: 'Auto Save' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 168 174 ) 					#name: #sizeAutoSave 					#flags: 32 					#model: #sizeAutoSave 					#label: #(#{Kernel.UserMessage} #key: #AutoSave #defaultString: 'Auto Save' #catalogID: #UIPainter) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 54 213 125 234 ) 					#name: #updateSpecifiedSize 					#isOpaque: true 					#model: #updateSpecifiedSize 					#label: #(#{Kernel.UserMessage} #key: #Specified #defaultString: 'Specified' #catalogID: #UIPainter) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 137 213 208 234 ) 					#name: #updateMinimumSize 					#isOpaque: true 					#model: #updateMinimumSize 					#label: #(#{Kernel.UserMessage} #key: #Minimum #defaultString: 'Minimum' #catalogID: #UIPainter) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 220 213 291 234 ) 					#name: #updateMaximumSize 					#isOpaque: true 					#model: #updateMaximumSize 					#label: #(#{Kernel.UserMessage} #key: #Maximum #defaultString: 'Maximum' #catalogID: #UIPainter) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.DataSetCallbacksSpecModel class</class-id> <category>interface specs</category><body package="UIPainter">notificationDCEditSpec	"UIPainter new openOnClass: self andSelector: #notificationDCEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#bounds: #(#{Graphics.Rectangle} 452 285 652 485 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#name: #label 					#label: #(#{Kernel.UserMessage} #key: #DataSetColumn #defaultString: 'DataSet - Column' #catalogID: #UIPainter) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1.0 139 0 ) 							#label: #(#{Kernel.UserMessage} #key: #ActionOn #defaultString: 'Action On' #catalogID: #UIPainter) ) 						#(#{UI.LabelSpec} 							#layout: #(#{UI.AlignmentOrigin} 5 0 47 0 0 1 ) 							#label: #(#{Kernel.UserMessage} #key: #Entry #defaultString: 'Entry:' #catalogID: #UIPainter) ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 75 0 22 0 0 0.97191 47 0 ) 							#model: #focusInSelector 							#menu: #fieldMenu 							#type: #symbol ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 75 0 50 0 0 0.97191 75 0 ) 							#model: #valueChangeSelector 							#menu: #fieldMenu 							#type: #symbol ) 						#(#{UI.LabelSpec} 							#layout: #(#{UI.AlignmentOrigin} 5 0 75 0 0 1 ) 							#label: #(#{Kernel.UserMessage} #key: #Change #defaultString: 'Change:' #catalogID: #UIPainter) ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 5 80 ) 							#name: #doubleClickLabel 							#label: #(#{Kernel.UserMessage} #key: #DClick #defaultString: 'D. Click:' #catalogID: #UIPainter) ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 75 0 78 0 0 0.97191 103 0 ) 							#name: #doubleClickMessage 							#model: #doubleClickSelector 							#type: #symbol ) 						#(#{UI.LabelSpec} 							#layout: #(#{UI.AlignmentOrigin} 5 0 129 0 0 1 ) 							#label: #(#{Kernel.UserMessage} #key: #Exit #defaultString: 'Exit:' #catalogID: #UIPainter) ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 75 0 106 0 0 0.97191 131 0 ) 							#model: #focusOutSelector 							#menu: #fieldMenu 							#type: #symbol ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 11 0 32 0 -11 1 171 0 ) 						#name: #fields ) ) ) ) )</body><body package="UIPainter">notificationEditSpec	"UIPainter new openOnClass: self andSelector: #notificationEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#bounds: #(#{Graphics.Rectangle} 700 500 900 700 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#name: #label 					#label: #(#{Kernel.UserMessage} #key: #DataSetColumn #defaultString: 'DataSet - Column' #catalogID: #UIPainter) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1.0 110 0 ) 							#label: #(#{Kernel.UserMessage} #key: #ActionOn #defaultString: 'Action On' #catalogID: #UIPainter) ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 76 0 25 0 0 0.966667 50 0 ) 							#model: #focusInSelector 							#menu: #fieldMenu 							#type: #symbol ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 76 0 53 0 0 0.966667 78 0 ) 							#model: #valueChangeSelector 							#menu: #fieldMenu 							#type: #symbol ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 76 0 81 0 0 0.966667 106 0 ) 							#model: #focusOutSelector 							#menu: #fieldMenu 							#type: #symbol ) 						#(#{UI.LabelSpec} 							#layout: #(#{UI.AlignmentOrigin} 6 0 50 0 0 1 ) 							#label: #(#{Kernel.UserMessage} #key: #Entry #defaultString: 'Entry:' #catalogID: #UIPainter) ) 						#(#{UI.LabelSpec} 							#layout: #(#{UI.AlignmentOrigin} 6 0 78 0 0 1 ) 							#label: #(#{Kernel.UserMessage} #key: #Change #defaultString: 'Change:' #catalogID: #UIPainter) ) 						#(#{UI.LabelSpec} 							#layout: #(#{UI.AlignmentOrigin} 6 0 106 0 0 1 ) 							#label: #(#{Kernel.UserMessage} #key: #Exit #defaultString: 'Exit:' #catalogID: #UIPainter) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 29 0 -10 1 139 0 ) 						#name: #fields ) ) ) ) )</body><body package="UIPainter">validationDCEditSpec	"UIPainter new openOnClass: self andSelector: #validationDCEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #Validation #defaultString: 'Validation' #catalogID: #UIPainter) 			#bounds: #(#{Graphics.Rectangle} 682 484 918 717 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#name: #label 					#label: #(#{Kernel.UserMessage} #key: #DataSetColumn #defaultString: 'DataSet - Column' #catalogID: #UIPainter) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{UI.AlignmentOrigin} 6 0 78 0 0 1 ) 							#label: #(#{Kernel.UserMessage} #key: #Change #defaultString: 'Change:' #catalogID: #UIPainter) ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 76 0 25 0 0 0.958333 50 0 ) 							#model: #requestFocusInSelector 							#menu: #fieldMenu 							#type: #symbol ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 76 0 53 0 0 0.958333 78 0 ) 							#model: #requestValueChangeSelector 							#menu: #fieldMenu 							#type: #symbol ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 76 0 109 0 0 0.958139 134 0 ) 							#model: #requestFocusOutSelector 							#menu: #fieldMenu 							#type: #symbol ) 						#(#{UI.LabelSpec} 							#layout: #(#{UI.AlignmentOrigin} 6 0 50 0 0 1 ) 							#label: #(#{Kernel.UserMessage} #key: #Entry #defaultString: 'Entry:' #catalogID: #UIPainter) ) 						#(#{UI.LabelSpec} 							#layout: #(#{UI.AlignmentOrigin} 6 0 132 0 0 1 ) 							#label: #(#{Kernel.UserMessage} #key: #Exit #defaultString: 'Exit:' #catalogID: #UIPainter) ) 						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0.0 0 0.0 0 1.0 154 0 ) 							#label: #(#{Kernel.UserMessage} #key: #RequestValidationOn #defaultString: 'Request Validation On' #catalogID: #UIPainter) ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 6 83 ) 							#name: #doubleClickLabel 							#label: #(#{Kernel.UserMessage} #key: #DClick #defaultString: 'D. Click:' #catalogID: #UIPainter) ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 76 0 81 0 0 0.958333 106 0 ) 							#name: #doubleClickMessage 							#model: #requestDoubleClickSelector 							#menu: #fieldMenu 							#type: #symbol ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 29 0 -11 1 183 0 ) 						#name: #fields ) ) ) ) )</body><body package="UIPainter">validationEditSpec	"UIPainter new openOnClass: self andSelector: #validationEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #Validation #defaultString: 'Validation' #catalogID: #UIPainter) 			#bounds: #(#{Graphics.Rectangle} 682 484 918 717 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#name: #label 					#label: #(#{Kernel.UserMessage} #key: #DataSetColumn #defaultString: 'DataSet - Column' #catalogID: #UIPainter) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 76 0 25 0 0 0.972222 50 0 ) 							#model: #requestFocusInSelector 							#menu: #fieldMenu 							#type: #symbol ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 76 0 53 0 0 0.972222 78 0 ) 							#model: #requestValueChangeSelector 							#menu: #fieldMenu 							#type: #symbol ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 76 0 81 0 0 0.972222 106 0 ) 							#model: #requestFocusOutSelector 							#menu: #fieldMenu 							#type: #symbol ) 						#(#{UI.LabelSpec} 							#layout: #(#{UI.AlignmentOrigin} 6 0 78 0 0 1 ) 							#label: #(#{Kernel.UserMessage} #key: #Change #defaultString: 'Change:' #catalogID: #UIPainter) ) 						#(#{UI.LabelSpec} 							#layout: #(#{UI.AlignmentOrigin} 6 0 50 0 0 1 ) 							#label: #(#{Kernel.UserMessage} #key: #Entry #defaultString: 'Entry:' #catalogID: #UIPainter) ) 						#(#{UI.LabelSpec} 							#layout: #(#{UI.AlignmentOrigin} 6 0 106 0 0 1 ) 							#label: #(#{Kernel.UserMessage} #key: #Exit #defaultString: 'Exit:' #catalogID: #UIPainter) ) 						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1.0 110 0 ) 							#label: #(#{Kernel.UserMessage} #key: #RequestValidationOn #defaultString: 'Request Validation On' #catalogID: #UIPainter) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 10 0 29 0 -10 1 139 0 ) 						#name: #fields ) ) ) ) )</body></methods><methods><class-id>Tools.UIPainterController class</class-id> <category>resources</category><body package="UIPainter">canvasMenu	"MenuEditor new openOnClass: self andSelector: #canvasMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Edit #defaultString: 'Edit' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Copy #defaultString: 'Copy' #catalogID: #UIPainter) 							#value: #doCopy #command: #copy ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Cut #defaultString: 'Cut' #catalogID: #UIPainter) 							#value: #doCut #command: #cut ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Paste #defaultString: 'Paste' #catalogID: #UIPainter) 							#value: #doPaste #command: #paste ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Accept #defaultString: 'Accept' #catalogID: #UIPainter) 							#value: #accept #command: #accept) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #UIPainter) 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: #(#{Kernel.UserMessage} #key: #Confirm #defaultString: 'Confirm' #catalogID: #UIPainter) 										#value: #cancel ) ) #(1 ) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Spawn #defaultString: 'Spawn' #catalogID: #UIPainter) 							#value: #doSpawn ) ) #(3 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Tools #defaultString: 'Tools' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ImageEditor #defaultString: 'Image Editor' #catalogID: #UIPainter) 							#value: #maskEditor ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #MenuEditor #defaultString: 'Menu Editor' #catalogID: #UIPainter) 							#value: #menuEditor ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #HotRegionsEditor #defaultString: 'Hot Regions Editor' #catalogID: #UIPainter) 							#value: #regionsEditor ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #ReusableDataFormComponents #defaultString: 'Reusable Data Form Components' #catalogID: #UIPainter) 							#nameKey: #openReusableComponents							#value: #openReusableComponents ) ) #(3 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Layout #defaultString: 'Layout' #catalogID: #UIPainter) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Fixed #defaultString: 'Fixed' #catalogID: #UIPainter) 							#nameKey: #doLayoutFixed							#value: #doLayoutFixed #command: #uipainterBeFixed ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Relative #defaultString: 'Relative' #catalogID: #UIPainter) 							#nameKey: #doLayoutRelative							#value: #doLayoutRelative #command: #uipainterBeRelative ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Constrained #defaultString: 'Constrained...' #catalogID: #UIPainter) 							#nameKey: #fractionalConstraintDialog							#value: #fractionalConstraintDialog ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #BeBounded #defaultString: 'Be Bounded' #catalogID: #UIPainter) 							#nameKey: #doMakeBounded							#value: #doMakeBounded ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #BeUnbounded #defaultString: 'Be Unbounded' #catalogID: #UIPainter) 							#nameKey: #doMakeUnBounded							#value: #doMakeUnBounded ) ) #(3 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Arrange #defaultString: 'Arrange' #catalogID: #UIPainter) 				#nameKey: #arrange				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #SnapToGrid #defaultString: 'Snap To Grid' #catalogID: #UIPainter) 							#value: #doSnapSelectionToGrid #command: #uipainterSnapSelectionToGrid ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Group #defaultString: 'Group' #catalogID: #UIPainter) 							#nameKey: #doGroup 							#value: #doGroup #command: #uipainterGroup ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Ungroup #defaultString: 'Ungroup' #catalogID: #UIPainter) 							#nameKey: #doUngroup 							#value: #doUngroup #command: #uipainterUngroup ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #BringToFront #defaultString: 'Bring To Front' #catalogID: #UIPainter) 							#value: #toVisualFront   #command: #uipainterCirculateToFront ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #BringForward #defaultString: 'Bring Forward' #catalogID: #UIPainter) 							#value: #toVisualFrontOne  #command: #uipainterCirculateFrontwards ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #SendToBack #defaultString: 'Send To Back' #catalogID: #UIPainter) 							#value: #toVisualBack   #command: #uipainterCirculateToBack ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #SendBackward #defaultString: 'Send Backward' #catalogID: #UIPainter) 							#value: #toVisualBackOne  #command: #uipainterCirculateBackwards ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #AlignDot #defaultString: 'Align...' #catalogID: #UIPainter) 							#nameKey: #alignDialog 							#value: #alignDialog  #command: #uipainterAlign ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #DistributeDot #defaultString: 'Distribute...' #catalogID: #UIPainter) 							#nameKey: #distributeDialog 							#value: #distributeDialog #command: #uipainterDistribute ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #EqualizeDot #defaultString: 'Equalize...' #catalogID: #UIPainter) 							#nameKey: #equalizeDialog 							#value: #equalizeDialog #command: #uipainterEqualize) ) #(1 2 4 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Special #defaultString: 'Special' #catalogID: #UIPainter) 				#nameKey: #special ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #PainterTool #defaultString: 'Painter Tool' #catalogID: #UIPainter) 				#value: #doPainterTool ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Palette #defaultString: 'Palette' #catalogID: #UIPainter) 				#value: #doPalette ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #InstallDot #defaultString: 'Install...' #catalogID: #UIPainter) 				#value: #doInstall #command: #uipainterInstall ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #DefineDot #defaultString: 'Define...' #catalogID: #UIPainter) 				#nameKey: #doDefine				#value: #doDefine ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #BrowseDot #defaultString: 'Browse...' #catalogID: #UIPainter) 				#nameKey: #doBrowse				#value: #doBrowse ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Open #defaultString: 'Open' #catalogID: #UIPainter) 				#nameKey: #doOpen				#value: #doOpen #command: #open ) ) #(5 6 ) nil ) decodeAsLiteralArray</body><body package="UIPainter">insetXIcon	"UIMaskEditor new openOnClass: self andSelector: #insetXIcon"	&lt;resource: #image&gt;	^Image extent: 20@16 depth: 1 palette: CoveragePalette monoMaskPalette bits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 96 0 6 6 96 0 3 131 192 0 127 225 128 0 3 131 192 0 6 6 96 0 0 6 96 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ] pad: 32</body><body package="UIPainter">insetYIcon	"UIMaskEditor new openOnClass: self andSelector: #insetYIcon"	&lt;resource: #image&gt;	^Image extent: 19@16 depth: 1 palette: CoveragePalette monoMaskPalette bits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 0 0 0 4 12 96 0 4 12 96 0 4 6 192 0 21 6 192 0 31 3 128 0 14 3 128 0 14 1 128 0 4 1 0 0 4 3 0 0 0 6 0 0 0 0 0 0 ] pad: 32</body></methods><methods><class-id>Tools.UIPainterController class</class-id> <category>interface specs</category><body package="UIPainter">alignDialogSpec	"UIPainter new openOnClass: self andSelector: #alignDialogSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #AlignSelectedWidgets #defaultString: 'Align Selected Widgets' #catalogID: #UIPainter) 			#min: #(#{Core.Point} 353 201 ) 			#max: #(#{Core.Point} 353 211 ) 			#bounds: #(#{Graphics.Rectangle} 624 495 977 706 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 13 0 64 0 0 1 ) 					#name: #VertButton 					#model: #orientation 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #OnHorizontalLine #defaultString: 'On Horizontal Line' #catalogID: #UIPainter) 					#select: #vertical ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 13 0 88 0 0 1 ) 					#name: #HorizButton 					#model: #orientation 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #OnVerticalLine #defaultString: 'On Vertical Line' #catalogID: #UIPainter) 					#select: #horizontal ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.Rectangle} 175 0 333 96 ) 							#name: #vertThrough 							#label: #(#{Kernel.UserMessage} #key: #Through #defaultString: ' Through ' #catalogID: #UIPainter) ) 						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.Rectangle} 0 92 333 143 ) 							#name: #vertUsing 							#label: #(#{Kernel.UserMessage} #key: #Using #defaultString: ' Using ' #catalogID: #UIPainter) ) 						#(#{UI.RadioButtonSpec} 							#layout: #(#{Core.Point} 186 20 ) 							#name: #vertTop 							#model: #vAlign 							#label: #(#{Kernel.UserMessage} #key: #TopEdges #defaultString: 'Top Edges' #catalogID: #UIPainter) 							#select: #top ) 						#(#{UI.RadioButtonSpec} 							#layout: #(#{Core.Point} 186 43 ) 							#name: #vertCenter 							#model: #vAlign 							#label: #(#{Kernel.UserMessage} #key: #Centers #defaultString: 'Centers' #catalogID: #UIPainter) 							#select: #center ) 						#(#{UI.RadioButtonSpec} 							#layout: #(#{Core.Point} 186 66 ) 							#name: #vertBottom 							#model: #vAlign 							#label: #(#{Kernel.UserMessage} #key: #BottomEdges #defaultString: 'Bottom Edges' #catalogID: #UIPainter) 							#select: #bottom ) 						#(#{UI.RadioButtonSpec} 							#layout: #(#{UI.AlignmentOrigin} 25 0 139 0 0 1 ) 							#name: #firstButton1 							#model: #anchor 							#label: #(#{Kernel.UserMessage} #key: #FirstSelection #defaultString: 'First Selection' #catalogID: #UIPainter) 							#select: #first ) 						#(#{UI.RadioButtonSpec} 							#layout: #(#{UI.AlignmentOrigin} 179 0 139 0 0 1 ) 							#name: #vertFurthest 							#model: #anchor 							#label: #(#{Kernel.UserMessage} #key: #MergedBox #defaultString: 'Merged Box' #catalogID: #UIPainter) 							#select: #furthest ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 9 12 342 155 ) 						#name: #VertChoices ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 9 12 ) 					#name: #alignLabel 					#label: #(#{Kernel.UserMessage} #key: #Align #defaultString: 'Align' #catalogID: #UIPainter) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -82 0.5 -35 1 -16 0.5 -5 1 ) 					#name: #apply 					#model: #apply 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #UIPainter) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0.5 -35 1 82 0.5 -5 1 ) 					#name: #cancel 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #UIPainter) 					#defaultable: true ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.Rectangle} 175 0 333 96 ) 							#name: #horizUsing 							#label: #(#{Kernel.UserMessage} #key: #Using #defaultString: ' Using ' #catalogID: #UIPainter) ) 						#(#{UI.GroupBoxSpec} 							#layout: #(#{Graphics.Rectangle} 0 92 333 143 ) 							#name: #horizThrough 							#label: #(#{Kernel.UserMessage} #key: #Through #defaultString: ' Through ' #catalogID: #UIPainter) ) 						#(#{UI.RadioButtonSpec} 							#layout: #(#{Core.Point} 186 29 ) 							#name: #firstButton2 							#model: #anchor 							#label: #(#{Kernel.UserMessage} #key: #FirstSelection #defaultString: 'First Selection' #catalogID: #UIPainter) 							#select: #first ) 						#(#{UI.RadioButtonSpec} 							#layout: #(#{Core.Point} 186 57 ) 							#name: #horizFurthest 							#model: #anchor 							#label: #(#{Kernel.UserMessage} #key: #MergedBox #defaultString: 'Merged Box' #catalogID: #UIPainter) 							#select: #furthest ) 						#(#{UI.RadioButtonSpec} 							#layout: #(#{UI.AlignmentOrigin} 11 0 139 0 0 1 ) 							#name: #horizLeft 							#model: #hAlign 							#label: #(#{Kernel.UserMessage} #key: #LeftEdges #defaultString: 'Left Edges' #catalogID: #UIPainter) 							#select: #left ) 						#(#{UI.RadioButtonSpec} 							#layout: #(#{UI.AlignmentOrigin} 122 0 139 0 0 1 ) 							#name: #horizCenter 							#model: #hAlign 							#label: #(#{Kernel.UserMessage} #key: #Centers #defaultString: 'Centers' #catalogID: #UIPainter) 							#select: #center ) 						#(#{UI.RadioButtonSpec} 							#layout: #(#{UI.AlignmentOrigin} 212 0 139 0 0 1 ) 							#name: #horizRight 							#model: #hAlign 							#label: #(#{Kernel.UserMessage} #key: #RightEdges #defaultString: 'Right edges' #catalogID: #UIPainter) 							#select: #right ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 9 12 342 155 ) 						#name: #HorizChoices ) ) ) ) )</body><body package="UIPainter">distributeDialogSpec	"UIPainter new openOnClass: self andSelector: #distributeDialogSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #DistributeSelectedWidgets #defaultString: ' Distribute Selected Widgets ' #catalogID: #UIPainter) 			#min: #(#{Core.Point} 384 193 ) 			#max: #(#{Core.Point} 384 193 ) 			#bounds: #(#{Graphics.Rectangle} 608 504 992 697 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 45 0 -10 1 140 0 ) 					#name: #groupBpx ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 12 ) 					#name: #distributeLabel 					#label: #(#{Kernel.UserMessage} #key: #DistributeC #defaultString: 'Distribute:' #catalogID: #UIPainter) ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.432292 13 0 0.5 0 ) 					#name: #leftToRight 					#model: #orientation 					#label: #(#{Kernel.UserMessage} #key: #LeftToRight #defaultString: 'Left To Right' #catalogID: #UIPainter) 					#select: #horizontal ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.828125 13 0 0.5 0 ) 					#name: #topToBottom 					#model: #orientation 					#label: #(#{Kernel.UserMessage} #key: #TopToBottom #defaultString: 'Top To Bottom' #catalogID: #UIPainter) 					#select: #vertical ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 17 0 76 0 0 1 ) 					#name: #equalCenters 					#model: #mode 					#label: #(#{Kernel.UserMessage} #key: #EqualSpacingBetweenCenters #defaultString: 'Equal Spacing Between Centers' #catalogID: #UIPainter) 					#select: #centers ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 17 0 100 0 0 1 ) 					#name: #edgeSpace 					#model: #mode 					#label: #(#{Kernel.UserMessage} #key: #GenKey138 #defaultString: 'Constant Spacing Between Edges:' #catalogID: #UIPainter) 					#select: #edgespace ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 17 0 124 0 0 1 ) 					#name: #equalEdges 					#model: #mode 					#label: #(#{Kernel.UserMessage} #key: #EqualSpacingBetweenEdges #defaultString: 'Equal Spacing Between Edges' #catalogID: #UIPainter) 					#select: #edges ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} -63 1 76 0 -18 1 100 0 ) 					#name: #constantField 					#model: #spacingConstant 					#alignment: #center 					#numChars: 4 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -91 0.5 158 0 -11 0.5 184 0 ) 					#name: #okbutton 					#model: #apply 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #UIPainter) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0.5 158 0 91 0.5 184 0 ) 					#name: #cancelbutton 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #UIPainter) 					#defaultable: true ) ) ) )</body><body package="UIPainter">equalizeDialogSpec	"UIPainter new openOnClass: self andSelector: #equalizeDialogSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #EqualizeSelectedWidgetSize #defaultString: 'Equalize Selected Widget Size' #catalogID: #UIPainter) 			#min: #(#{Core.Point} 294 166 ) 			#max: #(#{Core.Point} 294 166 ) 			#bounds: #(#{Graphics.Rectangle} 653 517 947 683 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 15 0 65 0 0 1 ) 					#name: #width 					#model: #equalizeWidth 					#label: #(#{Kernel.UserMessage} #key: #Width #defaultString: 'Width' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{UI.AlignmentOrigin} 15 0 93 0 0 1 ) 					#name: #height 					#model: #equalizeHeight 					#label: #(#{Kernel.UserMessage} #key: #Height #defaultString: 'Height' #catalogID: #UIPainter) ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 107 0 62 0 0 1 ) 					#name: #firstButton 					#model: #sizeChoice 					#label: #(#{Kernel.UserMessage} #key: #FirstSelection #defaultString: 'First Selection' #catalogID: #UIPainter) 					#select: #first ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 107 0 86 0 0 1 ) 					#name: #min 					#model: #sizeChoice 					#label: #(#{Kernel.UserMessage} #key: #Min #defaultString: 'Min' #catalogID: #UIPainter) 					#select: #min ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 165 0 86 0 0 1 ) 					#name: #max 					#model: #sizeChoice 					#label: #(#{Kernel.UserMessage} #key: #Max #defaultString: 'Max' #catalogID: #UIPainter) 					#select: #max ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.Rectangle} 107 85 205 110 ) 					#name: #constant 					#model: #sizeChoice 					#label: #(#{Kernel.UserMessage} #key: #ConstantC #defaultString: 'Constant:' #catalogID: #UIPainter) 					#select: #absolute ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 229 0 83 0 -18 1 108 0 ) 					#name: #constantField 					#model: #absoluteSize 					#alignment: #center 					#numChars: 4 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -82 0.5 -35 1 -16 0.5 -5 1 ) 					#model: #apply 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #UIPainter) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0.5 -35 1 82 0.5 -5 1 ) 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #UIPainter) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 14 12 ) 					#name: #equalize 					#label: #(#{Kernel.UserMessage} #key: #Equalize #defaultString: 'Equalize' #catalogID: #UIPainter) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 99 0 13 0 -10 1 115 0 ) 					#name: #usingGrouping 					#label: #(#{Kernel.UserMessage} #key: #Using #defaultString: ' Using ' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">layoutFrameDialogSpec	"UIPainter new openOnClass: self andSelector: #layoutFrameDialogSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 237 238 ) 			#max: #(#{Core.Point} 237 238 ) 			#bounds: #(#{Graphics.Rectangle} 682 481 919 719 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 45 10 ) 					#name: #labelProportion 					#label: #(#{Kernel.UserMessage} #key: #Proportion #defaultString: 'Proportion' #catalogID: #UIPainter) ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.Rectangle} 40 59 114 68 ) 					#name: #leftFractionSlider 					#model: #leftSlide 					#orientation: #horizontal 					#start: 0 					#stop: 1.0 					#step: 0.0833333 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.Rectangle} 40 96 114 105 ) 					#name: #topFractionSlider 					#model: #topSlide 					#orientation: #horizontal 					#start: 0 					#stop: 1.0 					#step: 0.0833333 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 142 10 ) 					#name: #labelOffset 					#label: #(#{Kernel.UserMessage} #key: #Offset #defaultString: 'Offset' #catalogID: #UIPainter) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 0 ) 							#name: #labelLeft 							#label: #(#{Kernel.UserMessage} #key: #L #defaultString: 'L' #catalogID: #UIPainter) ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 37 ) 							#name: #labelTop 							#label: #(#{Kernel.UserMessage} #key: #T #defaultString: 'T' #catalogID: #UIPainter) ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 74 ) 							#name: #labelRight 							#label: #(#{Kernel.UserMessage} #key: #R #defaultString: 'R' #catalogID: #UIPainter) ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 111 ) 							#name: #labelBottom 							#label: #(#{Kernel.UserMessage} #key: #B #defaultString: 'B' #catalogID: #UIPainter) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 13 38 25 170 ) 						#name: #boundedLabelGroup ) ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.Rectangle} 40 133 114 142 ) 					#name: #rightFractionSlider 					#model: #rightSlide 					#orientation: #horizontal 					#start: 0 					#stop: 1.0 					#step: 0.0833333 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.Rectangle} 40 170 114 179 ) 					#name: #bottomFractionSlider 					#model: #bottomSlide 					#orientation: #horizontal 					#start: 0 					#stop: 1.0 					#step: 0.0833333 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 40 34 114 58 ) 					#name: #leftFractionField 					#model: #leftFraction 					#alignment: #center ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 126 34 200 58 ) 					#name: #leftOffsetField 					#model: #leftOffset 					#alignment: #center ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 210 36 227 56 ) 					#name: #emptyLeftButton 					#model: #emptyLeft 					#tabable: true 					#label: ' ' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 40 71 114 95 ) 					#name: #topFractionField 					#model: #topFraction 					#alignment: #center ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 126 71 200 95 ) 					#name: #topOffsetField 					#model: #topOffset 					#alignment: #center ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 210 73 227 93 ) 					#name: #emptyTopButton 					#model: #emptyTop 					#tabable: true 					#label: ' ' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 40 108 114 132 ) 					#name: #rightFractionField 					#model: #rightFraction 					#alignment: #center ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 126 108 200 132 ) 					#name: #rightOffsetField 					#model: #rightOffset 					#alignment: #center ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 211 110 228 130 ) 					#name: #emptyRightButton 					#model: #emptyRight 					#tabable: true 					#label: ' ' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 40 145 114 169 ) 					#name: #bottomFractionField 					#model: #bottomFraction 					#alignment: #center ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 126 145 200 169 ) 					#name: #bottomOffsetField 					#model: #bottomOffset 					#alignment: #center ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 211 147 228 167 ) 					#name: #emptyBottomButton 					#model: #emptyBottom 					#tabable: true 					#label: ' ' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -82 0.5 -35 1 -16 0.5 -5 1 ) 					#model: #accept 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #UIPainter) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0.5 -35 1 82 0.5 -5 1 ) 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #UIPainter) 					#defaultable: true ) ) ) )</body><body package="UIPainter">namedFontDefineSpec	"UIPainter new openOnClass: self andSelector: #namedFontDefineSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #DefineFonts #defaultString: 'Define Fonts' #catalogID: #UIPainter) 			#min: #(#{Core.Point} 212 342 ) 			#max: #(#{Core.Point} 212 342 ) 			#bounds: #(#{Graphics.Rectangle} 694 485 906 827 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 15 0 221 0 -15 1 286 0 ) ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 25 231 ) 					#name: #usedNamedFonts 					#model: #namedFontFileOutType 					#label: #(#{Kernel.UserMessage} #key: #UsedNamedFonts #defaultString: 'Used Named Fonts' #catalogID: #UIPainter) 					#select: #used ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 25 256 ) 					#name: #allNamedFonts 					#model: #namedFontFileOutType 					#label: #(#{Kernel.UserMessage} #key: #AllNamedFonts #defaultString: 'All Named Fonts' #catalogID: #UIPainter) 					#select: #all ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 15 0 -42 1 80 0 -15 1 ) 					#name: #installNamedFonts 					#model: #apply 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #UIPainter) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -80 1 -42 1 -15 1 -15 1 ) 					#name: #cancel 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #UIPainter) 					#defaultable: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 5 0 -5 1 206 0 ) 					#name: #whereTheMethodIsStored 					#flags: 12 					#isOpaque: true 					#model: #whereTheMethodIsStored 					#tabable: false 					#helpText: #(#{Kernel.UserMessage} #key: #GenKey139 #defaultString: 'This tells you the name of the method that is created for defining fonts in an application.' #catalogID: #UIPainter) 					#alignment: #center 					#isReadOnly: true 					#tabRequiresControl: false 					#isWrapped: true ) ) ) )</body><body package="UIPainter">namedFontSaveSpec	"UIPainter new openOnClass: self andSelector: #namedFontSaveSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #SaveFonts #defaultString: 'Save Fonts' #catalogID: #UIPainter) 			#min: #(#{Core.Point} 212 230 ) 			#max: #(#{Core.Point} 212 230 ) 			#bounds: #(#{Graphics.Rectangle} 694 485 906 715 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 15 0 15 0 -15 1 80 0 ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 15 0 -112 1 ) 					#label: #(#{Kernel.UserMessage} #key: #FileName #defaultString: 'File Name :' #catalogID: #UIPainter) ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 25 25 ) 					#name: #usedNamedFonts 					#model: #namedFontFileOutType 					#label: #(#{Kernel.UserMessage} #key: #UsedNamedFonts #defaultString: 'Used Named Fonts' #catalogID: #UIPainter) 					#select: #used ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 25 50 ) 					#name: #allNamedFonts 					#model: #namedFontFileOutType 					#label: #(#{Kernel.UserMessage} #key: #AllNamedFonts #defaultString: 'All Named Fonts' #catalogID: #UIPainter) 					#select: #all ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 25 90 ) 					#name: #defineFontLoadingMethod 					#model: #defineFontLoadingMethod 					#label: #(#{Kernel.UserMessage} #key: #CreateLoadingMethod #defaultString: 'Create loading method' #catalogID: #UIPainter) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 15 0 -90 1 -15 1 -60 1 ) 					#name: #savedFontFileName 					#model: #savedFontFileName ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 15 0 -42 1 80 0 -15 1 ) 					#name: #installNamedFonts 					#model: #apply 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #UIPainter) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -80 1 -42 1 -15 1 -15 1 ) 					#name: #cancel 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #UIPainter) 					#defaultable: true ) ) ) )</body><body package="UIPainter">placementFrameDialogSpec	"UIPainter new openOnClass: self andSelector: #placementFrameDialogSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 249 238 ) 			#max: #(#{Core.Point} 249 238 ) 			#bounds: #(#{Graphics.Rectangle} 676 481 925 719 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 6 0 ) 							#name: #labelX 							#label: #(#{Kernel.UserMessage} #key: #X #defaultString: 'X' #catalogID: #UIPainter) ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 6 37 ) 							#name: #labelY 							#label: #(#{Kernel.UserMessage} #key: #Y #defaultString: 'Y' #catalogID: #UIPainter) ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 74 ) 							#name: #labelInsetX 							#label: #insetXIcon 							#hasCharacterOrientedLabel: false ) 						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 111 ) 							#name: #labelInsetY 							#label: #insetYIcon 							#hasCharacterOrientedLabel: false ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 7 38 31 169 ) 						#name: #unboundedLabelGroup ) ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 40 0 133 0 0 0.482906 142 0 ) 					#name: #alignmentXSlider 					#model: #alignmentXSlide 					#orientation: #horizontal 					#start: 0 					#stop: 1.0 					#step: 0.0833333 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 40 0 170 0 0 0.482906 179 0 ) 					#name: #alignmentYSlider 					#model: #alignmentYSlide 					#orientation: #horizontal 					#start: 0 					#stop: 1.0 					#step: 0.0833333 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.189873 10 0 ) 					#name: #labelProportion 					#label: #(#{Kernel.UserMessage} #key: #Proportion #defaultString: 'Proportion' #catalogID: #UIPainter) ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 40 0 59 0 0 0.482906 68 0 ) 					#name: #leftFractionSlider 					#model: #leftSlide 					#orientation: #horizontal 					#start: 0 					#stop: 1.0 					#step: 0.0833333 ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.LayoutFrame} 40 0 96 0 0 0.482906 105 0 ) 					#name: #topFractionSlider 					#model: #topSlide 					#orientation: #horizontal 					#start: 0 					#stop: 1.0 					#step: 0.0833333 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} -36 0.75 10 0 ) 					#name: #labelOffset 					#label: #(#{Kernel.UserMessage} #key: #Offset #defaultString: 'Offset' #catalogID: #UIPainter) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 40 0 34 0 0 0.482906 58 0 ) 					#name: #leftFractionField 					#model: #leftFraction 					#alignment: #center ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.529915 34 0 -37 1 58 0 ) 					#name: #leftOffsetField 					#model: #leftOffset 					#alignment: #center ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -27 1 36 0 -10 1 56 0 ) 					#name: #emptyLeftButton 					#model: #emptyLeft 					#tabable: true 					#label: ' ' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 40 0 71 0 0 0.482906 95 0 ) 					#name: #topFractionField 					#model: #topFraction 					#alignment: #center ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.529915 71 0 -37 1 95 0 ) 					#name: #topOffsetField 					#model: #topOffset 					#alignment: #center ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -27 1 73 0 -10 1 93 0 ) 					#name: #emptyTopButton 					#model: #emptyTop 					#tabable: true 					#label: ' ' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 40 0 108 0 0 0.482906 132 0 ) 					#name: #alignmentXField 					#model: #alignmentX 					#alignment: #center ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -26 1 110 0 -9 1 130 0 ) 					#name: #emptyAlignmentXButton 					#model: #emptyAlignmentX 					#tabable: true 					#label: ' ' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 40 0 145 0 0 0.482906 169 0 ) 					#name: #alignmentYField 					#model: #alignmentY 					#alignment: #center ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -26 1 147 0 -9 1 167 0 ) 					#name: #emptyAlignmentYButton 					#model: #emptyAlignmentY 					#tabable: true 					#label: ' ' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -82 0.5 -35 1 -16 0.5 -5 1 ) 					#model: #accept 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #UIPainter) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0.5 -35 1 82 0.5 -5 1 ) 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #UIPainter) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>UI.MaskPainterController class</class-id> <category>resources</category><body package="UIPainter">fillCursorImage	"UIMaskEditor new openOnClass: self andSelector: #fillCursorImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 3 0 0 0 4 128 0 0 5 224 0 0 6 176 0 0 4 156 0 0 8 142 0 0 17 70 0 0 32 142 0 0 64 22 0 0 64 38 0 0 32 70 0 0 16 132 0 0 9 4 0 0 6 0 0 0 0 0 0 0])</body><body package="UIPainter">fillCursorMask	"UIMaskEditor new openOnClass: self andSelector: #fillCursorMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[3 0 0 0 7 128 0 0 15 224 0 0 15 240 0 0 15 252 0 0 15 254 0 0 31 255 0 0 63 255 0 0 127 255 0 0 255 255 0 0 255 255 0 0 127 239 0 0 63 206 0 0 31 142 0 0 15 4 0 0 6 0 0 0])</body></methods><methods><class-id>Tools.UIFinderVW2 class</class-id> <category>resources</category><body package="UIPainter">BWMenuIcon	"UIMaskEditor new openOnClass: self andSelector: #BWMenuIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 31 252 0 0 16 4 0 0 31 252 0 0 16 32 0 0 31 224 0 0 24 96 0 0 31 224 0 0 16 32 0 0 31 224 0 0 16 32 0 0 31 224 0 0 0 0 0 0 0 0 0 0 ])</body><body package="UIPainter">BWModelIcon	"UIMaskEditor new openOnClass: self andSelector: #BWModelIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 1 248 0 0 6 6 0 0 5 250 0 0 4 2 0 0 0 2 0 0 31 194 0 0 18 70 0 0 31 216 0 0 18 64 0 0 31 192 0 0 18 64 0 0 31 192 0 0 0 0 0 0 ])</body><body package="UIPainter">BWQueryIcon	"UIMaskEditor new openOnClass: self andSelector: #BWQueryIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 128 0 0 1 192 0 0 3 224 0 0 0 128 0 0 6 176 0 0 24 140 0 0 22 180 0 0 16 132 0 0 16 132 0 0 16 132 0 0 16 4 0 0 12 24 0 0 3 224 0 0 0 0 0 0 ])</body><body package="UIPainter">BWcanvasIcon	"UIMaskEditor new openOnClass: self andSelector: #BWcanvasIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 3 128 0 0 1 0 0 0 31 240 0 0 8 16 0 0 12 8 0 0 4 4 0 0 6 28 0 0 2 112 0 0 3 208 0 0 1 72 0 0 0 64 0 0 0 0 0 0 0 0 0 0 ])</body><body package="UIPainter">BWiconIcon	"UIMaskEditor new openOnClass: self andSelector: #BWiconIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 31 248 0 0 19 200 0 0 19 200 0 0 31 248 0 0 30 72 0 0 30 72 0 0 31 248 0 0 19 200 0 0 19 200 0 0 31 248 0 0 0 0 0 0 0 0 0 0 ])</body><body package="UIPainter">CMenuIcon	"UIMaskEditor new openOnClass: self andSelector: #CMenuIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 5) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4369); at: 3 put: ColorValue yellow; at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 0 scaledGreen: 4915 scaledBlue: 8191); yourself)) usingBits: #[51 51 51 51 51 51 51 48 51 48 0 0 0 0 0 48 51 48 34 34 34 34 32 48 51 48 0 0 0 0 0 48 51 48 51 51 51 3 51 48 51 48 17 17 17 3 51 48 51 48 68 68 68 3 51 48 51 48 17 17 17 3 51 48 51 48 51 51 51 3 51 48 51 48 17 17 17 3 51 48 51 48 51 51 51 3 51 48 51 48 0 0 0 3 51 48 51 51 51 51 51 51 51 48 51 51 51 51 51 51 51 48 ])</body><body package="UIPainter">CModelIcon	"UIMaskEditor new openOnClass: self andSelector: #CModelIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: ColorValue cyan; at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); yourself)) usingBits: #[170 170 170 168 170 168 0 40 170 131 255 192 170 132 0 16 170 133 85 80 170 165 85 80 168 0 5 80 168 162 133 64 168 0 4 40 168 162 138 168 168 0 10 168 168 162 138 168 168 0 10 168 170 170 170 168 ])</body><body package="UIPainter">CQueryIcon	"UIMaskEditor new openOnClass: self andSelector: #CQueryIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: ColorValue cyan; at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); yourself)) usingBits: #[170 170 42 168 170 168 10 168 170 160 2 168 170 170 42 168 170 130 32 168 168 62 47 8 168 66 32 72 168 86 37 72 168 86 37 72 168 86 37 72 168 85 149 72 170 5 84 40 170 160 2 168 170 170 170 168 ])</body><body package="UIPainter">CRegionsIcon	"UIMaskEditor new openOnClass: self andSelector: #CRegionsIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue red; at: 3 put: ColorValue white; yourself)) usingBits: #[170 170 170 168 170 170 170 168 168 0 0 40 168 0 0 40 168 21 64 40 168 21 64 40 168 21 84 40 168 5 84 40 168 5 84 40 168 5 84 40 168 0 0 40 168 0 0 40 170 170 170 168 170 170 170 168])</body><body package="UIPainter">CcanvasIcon	"UIMaskEditor new openOnClass: self andSelector: #CcanvasIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 3) at: 1 put: ColorValue black; at: 2 put: ColorValue yellow; at: 3 put: ColorValue white; yourself)) usingBits: #[170 170 170 168 170 160 42 168 170 168 170 168 168 0 0 168 170 25 152 168 170 6 102 40 170 137 153 136 170 130 100 8 170 161 128 168 170 160 8 168 170 168 138 40 170 170 138 168 170 170 170 168 170 170 170 168 ])</body><body package="UIPainter">CiconIcon	"UIMaskEditor new openOnClass: self andSelector: #CiconIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 5) at: 1 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 2 put: (ColorValue scaledRed: 0 scaledGreen: 4369 scaledBlue: 0); at: 3 put: ColorValue magenta; at: 4 put: ColorValue white; at: 5 put: ColorValue blue; yourself)) usingBits: #[51 51 51 51 51 51 51 48 51 51 51 51 51 51 51 48 51 48 0 0 0 0 3 48 51 48 51 1 16 51 3 48 51 48 51 1 16 51 3 48 51 48 0 0 0 0 3 48 51 48 34 3 48 51 3 48 51 48 34 3 48 51 3 48 51 48 0 0 0 0 3 48 51 48 51 4 64 51 3 48 51 48 51 4 64 51 3 48 51 48 0 0 0 0 3 48 51 51 51 51 51 51 51 48 51 51 51 51 51 51 51 48 ])</body><body package="UIPainter">Cquestion	"UIMaskEditor new openOnClass: self andSelector: #Cquestion"	"Icon of a question mark"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 254 0 0 248 126 0 0 240 62 0 0 227 30 0 0 231 158 0 0 255 30 0 0 254 62 0 0 252 126 0 0 252 254 0 0 252 254 0 0 255 254 0 0 252 254 0 0 252 254 0 0 255 254 0 0])</body><body package="UIPainter">MskCanvasIcon	"UIMaskEditor new openOnClass: self andSelector: #MskCanvasIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 3 128 0 0 1 0 0 0 31 240 0 0 15 240 0 0 15 248 0 0 7 252 0 0 7 252 0 0 3 240 0 0 3 208 0 0 1 72 0 0 0 64 0 0 0 0 0 0 0 0 0 0 ])</body><body package="UIPainter">MskIconIcon	"UIMaskEditor new openOnClass: self andSelector: #MskIconIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 31 248 0 0 31 248 0 0 31 248 0 0 31 248 0 0 31 248 0 0 31 248 0 0 31 248 0 0 31 248 0 0 31 248 0 0 31 248 0 0 0 0 0 0 0 0 0 0 ])</body><body package="UIPainter">MskMenuIcon	"UIMaskEditor new openOnClass: self andSelector: #MskMenuIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 31 252 0 0 31 252 0 0 31 252 0 0 31 224 0 0 31 224 0 0 31 224 0 0 31 224 0 0 31 224 0 0 31 224 0 0 31 224 0 0 31 224 0 0 0 0 0 0 0 0 0 0 ])</body><body package="UIPainter">MskModelIcon	"UIMaskEditor new openOnClass: self andSelector: #MskModelIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 1 248 0 0 7 254 0 0 7 254 0 0 7 254 0 0 3 254 0 0 31 254 0 0 31 254 0 0 31 248 0 0 31 192 0 0 31 192 0 0 31 192 0 0 31 192 0 0 0 0 0 0 ])</body><body package="UIPainter">MskQueryIcon	"UIMaskEditor new openOnClass: self andSelector: #MskQueryIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 15@14 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 128 0 0 1 192 0 0 3 224 0 0 0 128 0 0 7 240 0 0 31 252 0 0 31 252 0 0 31 252 0 0 31 252 0 0 31 252 0 0 31 252 0 0 15 248 0 0 3 224 0 0 0 0 0 0 ])</body><body package="UIPainter">MskRegionsIcon	"UIMaskEditor new openOnClass: self andSelector: #MskRegionsIcon"	&lt;resource: #image&gt;	^self MskIconIcon</body><body package="UIPainter">classMenu	"MenuEditor new openOnClass: self andSelector: #classMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Start #defaultString: '&amp;Start' #catalogID: #UIPainter) 				#enabled: false 				#nameKey: #startApplication				#value: #startApplication 				#shortcutKeyCharacter: $O ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Browse #defaultString: '&amp;Browse' #catalogID: #UIPainter) 				#enabled: false 				#value: #browse 				#shortcutKeyCharacter: $B ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Show_DataForms #defaultString: 'Show &amp;Data Forms' #catalogID: #UIPainter) 				#enabled: false 				#nameKey: #showDatabaseApplicationStructure				#value: #showDatabaseApplicationStructure ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_FileOutAs #defaultString: '&amp;File Out As...' #catalogID: #UIPainter) 				#enabled: false 				#value: #fileOutClass ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Re_nameAs #defaultString: 'Re&amp;name As...' #catalogID: #UIPainter) 				#enabled: false 				#value: #renameClass ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Remove #defaultString: '&amp;Remove...' #catalogID: #UIPainter) 				#enabled: false 				#value: #removeClass ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Add #defaultString: '&amp;Add...' #catalogID: #UIPainter) 				#value: #addClass 				#shortcutKeyCharacter: $N ) ) #(4 2 1 ) nil ) decodeAsLiteralArray</body><body package="UIPainter">helpMenu	"Tools.MenuEditor new openOnClass: self andSelector: #helpMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Resource_Finder 					#defaultString: 'Resource &amp;Finder' 					#catalogID: #UIPainter ) 				#value: #helpResourceFinder 				#shortcutKeyCharacter: #F1 				#shortcutModifiers: 0 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #help ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Resources 					#defaultString: 'Resources' 					#catalogID: #UIPainter ) 				#value: #helpResources ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_AboutVisualWorksDot					#defaultString: '&amp;About VisualWorks...' 					#catalogID: #UIPainter ) 				#value: #helpAbout ) ) #(2 1 ) nil ) decodeAsLiteralArray</body><body package="UIPainter">viewMenu	"Tools.MenuEditor new openOnClass: self andSelector: #viewMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_AllClasses 					#defaultString: '&amp;All Classes' 					#catalogID: #UIPainter ) 				#nameKey: #showAllClasses 				#value: #showAllClasses ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_RecentlyVisitedClasses 					#defaultString: '&amp;Recently Visited Classes' 					#catalogID: #UIPainter ) 				#nameKey: #showRecentlyVisitedClasses 				#value: #showRecentlyVisitedClasses ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ClassesBy_Category 					#defaultString: 'Classes by &amp;Category...' 					#catalogID: #UIPainter ) 				#nameKey: #showClassesByCategory 				#value: #showClassesByCategory ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SortBy_Name 					#defaultString: 'Sort by &amp;Name' 					#catalogID: #UIPainter ) 				#nameKey: #sortByName 				#value: #sortByName ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #SortBy_Type 					#defaultString: 'Sort by &amp;Type' 					#catalogID: #UIPainter ) 				#nameKey: #sortByType 				#value: #sortByType ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #U_pdate 					#defaultString: 'U&amp;pdate' 					#catalogID: #UIPainter ) 				#value: #update ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #E_xit 					#defaultString: 'E&amp;xit' 					#catalogID: #UIPainter ) 				#value: #closeRequest ) ) #(3 2 1 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.UIFinderVW2 class</class-id> <category>interface specs</category><body package="UIPainter">inheritedCanvasDialog	"UIPainter new openOnClass: self andSelector: #inheritedCanvasDialog"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 224 163 ) 			#max: #(#{Core.Point} 357 171 ) 			#bounds: #(#{Graphics.Rectangle} 688 519 912 682 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 12 ) 					#label: #(#{Kernel.UserMessage} #key: #EDITInheritedCanvas #defaultString: 'EDIT Inherited Canvas' #catalogID: #UIPainter) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -82 0.5 -35 1 -16 0.5 -5 1 ) 					#name: #okButton 					#model: #doOK 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #UIPainter) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0.5 -35 1 82 0.5 -5 1 ) 					#name: #cancelButton 					#model: #doAbort 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #UIPainter) 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 33 0 -10 1 -52 1 ) 					#model: #canvasList 					#multipleSelections: false ) ) ) )</body><body package="UIPainter">knownDestinationDialog	"UIPainter new openOnClass: self andSelector: #knownDestinationDialog"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 242 340 ) 			#max: #(#{Core.Point} 242 352 ) 			#bounds: #(#{Graphics.Rectangle} 679 430 921 770 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 33 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #INSTALLOnClass #defaultString: 'INSTALL on Class:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 82 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #andSelector #defaultString: 'and Selector:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 270 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #orEnterNewSelector #defaultString: 'or enter new Selector:' #catalogID: #UIPainter) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 270 0 -10 1 295 0 ) 					#name: #NewSelectorField 					#model: #newSelector 					#tabable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -82 0.5 -35 1 -16 0.5 -5 1 ) 					#name: #okButton 					#model: #doOK 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #UIPainter) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0.5 -35 1 82 0.5 -5 1 ) 					#name: #cancelButton 					#model: #doAbort 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #UIPainter) 					#defaultable: true ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 33 0 -10 1 58 0 ) 					#name: #ClassNameField 					#flags: 0 					#majorKey: #ClassFinder 					#minorKey: #nameOnlySpec 					#clientKey: #clientClass ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 82 0 -10 1 243 0 ) 					#name: #SelectorSIL 					#model: #existingSelectors ) ) ) )</body><body package="UIPainter">sourceDialog	"UIPainter new openOnClass: self andSelector: #sourceDialog"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 240 305 ) 			#max: #(#{Core.Point} 240 305 ) 			#bounds: #(#{Graphics.Rectangle} 680 448 920 753 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 33 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #LOADFromClass #defaultString: 'LOAD from Class:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 85 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #andSelector #defaultString: 'and Selector:' #catalogID: #UIPainter) ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 33 0 -10 1 58 0 ) 					#name: #clientClass 					#flags: 0 					#majorKey: #ClassFinder 					#minorKey: #nameOnlySpec 					#clientKey: #clientClass ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 85 0 -10 1 260 0 ) 					#name: #SelectorSIL 					#model: #existingSelectors ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -82 0.5 -35 1 -16 0.5 -5 1 ) 					#name: #okButton 					#model: #doOK 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #UIPainter) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0.5 -35 1 82 0.5 -5 1 ) 					#name: #cancelButton 					#model: #doAbort 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #UIPainter) 					#defaultable: true ) ) ) )</body><body package="UIPainter">unknownDestinationDialog	"UIPainter new openOnClass: self andSelector: #unknownDestinationDialog"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 242 341 ) 			#max: #(#{Core.Point} 242 352 ) 			#bounds: #(#{Graphics.Rectangle} 679 430 921 771 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 33 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #INSTALLOnClass #defaultString: 'INSTALL on Class:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 82 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #andSelector #defaultString: 'and Selector:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 270 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #orEnterNewSelector #defaultString: 'or enter new Selector:' #catalogID: #UIPainter) ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 33 0 -10 1 58 0 ) 					#name: #ClassNameField 					#flags: 0 					#majorKey: #ClassFinder 					#minorKey: #nameOnlySpec 					#clientKey: #clientClass ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 82 0 -10 1 243 0 ) 					#name: #SelectorSIL 					#model: #existingSelectors ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 270 0 -10 1 295 0 ) 					#name: #NewSelectorField 					#model: #newSelector 					#tabable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -82 0.5 -35 1 -16 0.5 -5 1 ) 					#name: #okButton 					#model: #doOK 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #UIPainter) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 16 0.5 -35 1 82 0.5 -5 1 ) 					#name: #cancelButton 					#model: #doAbort 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #UIPainter) 					#defaultable: true ) ) ) )</body><body package="UIPainter">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #ResourceFinder #defaultString: 'Resource Finder' #catalogID: #UIPainter) 			#min: #(#{Core.Point} 337 154 ) 			#bounds: #(#{Graphics.Rectangle} 579 474 1021 727 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.513575 33 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Resources #defaultString: 'Resources' #catalogID: #UIPainter) ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 62 0 0 0.498861 -4 1 ) 					#name: #ClassNameList 					#model: #classNameList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #browse ) 					#tabable: true 					#menu: #classNameListMenu ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.512528 62 0 -5 1 -4 1 ) 					#name: #SelectorList 					#model: #selectorList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #edit ) 					#tabable: true 					#menu: #selectorListMenu 					#multipleSelections: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.2 0 0 0 0.4 32 0 ) 					#name: #startButton 					#model: #startApplication 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Start #defaultString: 'Start' #catalogID: #UIPainter) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.4 0 0 0 0.6 32 0 ) 					#name: #addButton 					#model: #addClass 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Add #defaultString: 'Add...' #catalogID: #UIPainter) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.6 0 0 0 0.8 32 0 ) 					#name: #removeButton 					#model: #remove 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Remove #defaultString: 'Remove...' #catalogID: #UIPainter) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.8 0 0 0 1 32 0 ) 					#name: #editButton 					#model: #edit 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Edit #defaultString: 'Edit' #catalogID: #UIPainter) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 0.2 32 0 ) 					#name: #browseButton 					#model: #browse 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Browse #defaultString: 'Browse' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 33 0 0 0.505695 61 0 ) 					#name: #ClassNameListLabel 					#label: #(#{Kernel.UserMessage} #key: #Class #defaultString: 'Class' #catalogID: #UIPainter) ) ) ) )</body></methods><methods><class-id>Tools.UIPainterIcons class</class-id> <category>png imports</category><body package="UIPainter">uiPainter	"WARNING: This code was automatically generated during asset import. Regeneration will destroy any manual edits."	&lt;file: 'uiPainter.png'&gt;	&lt;md5sum: #[74 215 49 20 66 252 47 130 154 196 75 245 190 40 102 17]&gt;	^[AlphaCompositedImage image: ((Image extent: 24@24 depth: 32 bitsPerPixel: 32 palette: (Graphics.FixedPalette redShift: 0 redMask: 255 greenShift: 8 greenMask: 255 blueShift: 16 blueMask: 255) usingBits: (ByteArray fromPackedString: '@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;ABR1R$AEC_.D^Y&lt;I1I6/C@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&gt;UDDA9?15$/_&lt;&amp;[\''#J%JF@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???84OOWO?GFF7?2Y/3/&lt;*UH.IK#%H@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????!@8:[/&lt;[W+K?I''GS?2)V$J\.N44BK3@0@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???=9CS!)?1)[+_&lt;%\=#?JU&amp;U,B4=T P/LC@@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???3I$[7/=#Y&gt;5?3Q&gt;7_&lt;)V9*9KTAXA2&lt;0L@C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????HHB@ NN5-[[?6M#X?8RL%,L/P54IK3@0@O???0C???&lt;@????@O???0C???&lt;@????@O???6.,\D_47;B@?=:%Z_?^)F''?7JI)?=* Z_?V''&amp;W?5)1%?=R[X??Q&amp;FO?19Q#?;V.)??]7]7?&amp;)*Z16EYU X/LC@@????@O???0C???&lt;@????@O???0C???&lt;@????@O????7_*''[?:+^B?&gt;*7 /?+.HO?:+"C?&gt;*8 ??*-8K?:+"C?&gt;*7 /? ,XK?-:&gt;''?&gt;K"8/&gt;_''9??(H!/?\NNX0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O?????^)V''?7*U*?=:%Z_?^)V''?7*U)?=:%Z_?K%6K? U]]?7UHY/&gt;V 8#?8NC ?:V%)_&gt;X_6W?7*U)?&lt;JIV@C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O?????](&amp;+?=_W5??W5=_?5=_W?=/[6?&gt;K!8?&gt;FZH3?+7Z:?:%.-O&gt;]W:_?&amp;(2\?9"W&amp;O?6=/[?=/[6?;:EU C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O?????[(V''?=_W5??W5&lt;??4=_S?=OS4?9NA%??@#L/?2I_S?;&gt;K2/&gt;+\[[?$UN\?8*D"??B0,K?&lt;?O5?;2CT0C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O?????Z(F''?&lt;/K2?=U?RO?T_4#?5W=H?852$/?M'']#?8+''-?&lt;.[5/&gt;3^;;?"%NT?&lt;7L3/??????&lt;?O3?;!&gt;TPC???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O?????W''&amp;[?&lt;_G/??G0&lt;_?/&lt;_G?&lt;_C1?9M=%??D$\??3);Y?&lt;JP3_&gt;.]K''? FJE??3&lt;?O??????&lt;_G1?;Y&lt;T@C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O?????V''F[?;.7-?&gt;;.;/?/;.;?3&lt;7O?8I#"O&gt;/][+?-G2??:)1-_&gt;@X([?1K?E?&gt;?-;/?-;^7?;^7/?;M:S C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O?????S&amp;&amp;O?;N3,?&gt;3,:/?&amp;9.S?VS=]?7%A /=9R8G?]%Y&lt;?790 O&gt;&gt;/+;?0\GA?&lt;GA0_?A0\G?:&gt;/*?;E8S@C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@O?????N%VC?:^'')?=U?RO?T_4#?1WYC?&lt;/K2?&gt;5-[W?????????????????????????????????:^+*?:93R C???&lt;@????@O???0C???&lt;@????@O???0C???&lt;@????@P@@@O?L$&amp;C?9&gt;_''?&gt;#&amp;9/?&amp;9.[?9.[&amp;?&gt;[&amp;9/?B0,K?????????????????????????????????9&gt;_''?:11RPC???&lt;@????@O???0C???&lt;@????@O???0D@@@@CUUUUBI&gt;_''??J$E;?9^S$?&gt;S$9O?$9N[?9^W%?&gt;S$9O?&amp;9NS?9NS$?&gt;[%9_?$9^S?9^W%?&gt;W$9O?$9^W?9^S%?:)0Q VY&amp;Y$B HB@@O???0C???&lt;@????@O???0R@ H@]^7-;K).[&amp;&lt;N,^ES?1H1Z?&lt;FIVO&gt;?!U_?/XMT?;.AT/&gt;5_EC?,7)N?;M9SO&gt;/]4/?+7QL?:53R_&gt;*\T#?*&amp;=G/:-6T"^P"X$S^W%9@(B@ @C???&lt;@????@O???0%1\WD?_W5=W9:Y&amp;W3G/[&gt;F4&lt;#J"][K3X/W3L2M5&lt;3L#=#M3YGZ3-BR6,;P$]_L3(?X2&lt;6L6\3N"-#K3X#X2&lt;2D4&lt;_G\;*4-ERL"X$)_G1&lt;AY%&amp;Y C???&lt;@????@O???0U&amp;Y&amp;X# 8NCQI*R$%&gt;4+J9''/;V7Z\V;.6/F/K1.1[2&lt;\LZ=/WOH/;=42+?A\\&amp;&gt;0F?F/K=-1[.=Z,V&lt;/&amp;#D.+5%/[Z6VJ.")S"D!HPV]GQ4@(B@ @C???&lt;@????@O???0G???&lt;G[V5-D8ZF!!6^'')8!**J"H*6%)RN/*J $,Z**I[N,+B^7,[D)-J:.I;F**"V3+J0$,Z**H:&gt;(*BJ-)ZT )9&gt;_F9^W%0:@ H@CUUUU@O???0C???&lt;@????@O???0C???&lt;A@@@@@(B@ @MUUUTC****@:*** N***(C****AK&gt;@ @VY&amp;Y$E&amp;Y&amp;YAK&gt;?/0O?**(C****@:*** N***(C****@5UUUPG???&lt;@????@O???0C???&lt;@????')))] once</body></methods><methods><class-id>Tools.VisualLauncher class</class-id> <category>resources</category><body package="UIPainter">BWAppFinder24	"UIMaskEditor new openOnClass: self andSelector: #BWAppFinder24"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 255 254 0 64 0 2 0 127 255 250 0 127 255 250 0 95 255 250 0 84 0 10 0 74 0 10 0 73 255 106 0 72 137 106 0 72 127 10 0 68 41 106 0 68 31 106 0 68 9 10 0 68 5 106 0 68 3 106 0 68 1 10 0 71 240 138 0 65 254 74 0 64 15 42 0 64 1 242 0 64 0 122 0 127 255 254 0 0 0 0 0 ])</body><body package="UIPainter">CGAppFinder24	"UIMaskEditor new openOnClass: self andSelector: #CGAppFinder24"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 24@24 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 8) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 4369 scaledGreen: 4369 scaledBlue: 4369); at: 3 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); at: 4 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 5 put: ColorValue white; at: 6 put: ColorValue cyan; at: 7 put: ColorValue yellow; at: 8 put: ColorValue blue; yourself)) usingBits: (ByteArray fromPackedString: 'H"H"H"H"H"H"H"H"H@@@@@@@@@@@@@@BHEIRT%H%IRIRT%TBH@L@@@@@@@@@@@HBH@A7]7]7]7]7]0TBHE@C@@@@@@@@@@HBHB@ Y&amp;Y&amp;Y&amp;Y&amp;Y TBHEHBA&amp;Y&amp;Y&amp;Y&amp;Y HBHBTDHCL3L3M#M TBHEHBP QDMDM#M HBHBTDIB@3L3M&amp;Y TBHEIPP$HDMDM#M HBHBT QBP L3M#M TBHEIPQDIBADM&amp;Y HBHBT IDP$HDM#M TBHEIPH$QBP M#M HBHBT H"QDIBA&amp;Y HBHEIP@@@@P$HFY TBHBT%HQDQ@@P Y HBHEIRT%H%DQ@BA TBHBT%IRURT%DP@EHBHEIRT%H%IRIQD@TBH@@@@@@@@@@@@@@BH"H"H"H"H"H"H"H"'))</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - uipainter</category><body package="UIPainter">menuItemCodingAssistant	&lt;menuItemForCommand: #uipainterOpenCodingAssistant		nameKey: nil		menu: #(#menuBar #painter)		position: 30.2&gt;	self openApplicationForClassNamed: #{CodingAssistant} withSelector: #open</body><body package="UIPainter">menuItemHotRegionsEditor	&lt;menuItemForCommand: #uipainterOpenHotRegionsEditor		nameKey: nil		menu: #(#menuBar #painter)		position: 20.3&gt;	self applicationForClassNamed: #{UIHotRegionEditor} do: [:class| class open]</body><body package="UIPainter">menuItemMaskEditor	&lt;menuItemForCommand: #uipainterOpenImageEditor		nameKey: nil		menu: #(#menuBar #painter)		position: 20.2&gt;	self openApplicationForClassNamed: #{UIMaskEditor}</body><body package="UIPainter">menuItemMenuEditor	&lt;menuItemForCommand: #uipainterOpenMenuEditor		nameKey: nil		menu: #(#menuBar #painter)		position: 20.1&gt;	self openApplicationForClassNamed: #{MenuEditor}</body><body package="UIPainter">menuItemNewCanvas	&lt;menuItemForCommand: #uipainterOpenNewCanvas		icon: #(#{UI.ResourceRetriever} #{UIPainterIcons} #uiPainter)		nameKey: nil		menu: #(#menuBar #painter)		position: 10.1&gt;	self applicationForClassNamed: #{UIPainter} do: [ :class | class new openNewWindowCanvas ]</body><body package="UIPainter">menuItemResourceFinder	&lt;menuItemForCommand: #uipainterOpenResourceFinder		nameKey: nil		menu: #(#menuBar #painter)		position: 30.1&gt;	self openApplicationForClassNamed: #{UIFinderVW2}</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>toolbar</category><body package="UIPainter">toolbarItemNewCanvas	&lt;vwPrivileged&gt;	&lt;menuItemForCommand: #uipainterOpenNewCanvas		icon: #(#{UI.ResourceRetriever} #{UIPainterIcons} #uiPainter)		nameKey: nil		menu: #(#launcherToolBar)		position: 30.1		helpText: #(#EditANewCanvas #UIPainter 'Edit a New Canvas')&gt;	self applicationForClassNamed: #{UIPainter} do: [ :class | class new openNewWindowCanvas ]</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - uipainter</category><body package="UIPainter">topMenuUIPainter	&lt;submenu: #(#painterSubmenu #UIPainter '&amp;Painter')		nameKey: #painter		menu: #(#menuBar)		position: 100.1&gt;	^self</body></methods><methods><class-id>UI.UIEventCallbackSubSpec class</class-id> <category>interface specs</category><body package="UIPainter">notificationDCEditSpec	"UIPainter new openOnClass: self andSelector: #notificationDCEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#bounds: #(#Rectangle 393 279 629 512 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 29 0 -10 1 168 0 ) 					#label: #(#{Kernel.UserMessage} #key: #ActionOn #defaultString: 'Action On' #catalogID: #UIPainter) ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 54 0 -16 1 79 0 ) 					#name: #focusInField 					#model: #focusInSelector 					#menu: #fieldMenu 					#type: #symbol ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 82 0 -16 1 107 0 ) 					#name: #valueChangeField 					#model: #valueChangeSelector 					#menu: #fieldMenu 					#type: #symbol ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 110 0 -16 1 135 0 ) 					#name: #doubleClickField 					#model: #doubleClickSelector 					#menu: #fieldMenu 					#type: #symbol ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 138 0 -16 1 163 0 ) 					#name: #focusOutField 					#model: #focusOutSelector 					#menu: #fieldMenu 					#type: #symbol ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 16 0 107 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Change #defaultString: 'Change:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 16 0 135 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #DClick #defaultString: 'D. Click:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 16 0 79 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Entry #defaultString: 'Entry:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 16 0 163 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Exit #defaultString: 'Exit:' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">notificationEditSpec	"UIPainter new openOnClass: self andSelector: #notificationEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#bounds: #(#Rectangle 375 265 611 498 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 29 0 -10 1 139 0 ) 					#label: #(#{Kernel.UserMessage} #key: #ActionOn #defaultString: 'Action On' #catalogID: #UIPainter) ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 54 0 -16 1 79 0 ) 					#name: #focusInField 					#model: #focusInSelector 					#menu: #fieldMenu 					#type: #symbol ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 82 0 -16 1 107 0 ) 					#name: #valueChangeField 					#model: #valueChangeSelector 					#menu: #fieldMenu 					#type: #symbol ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 110 0 -16 1 135 0 ) 					#name: #focusOutField 					#model: #focusOutSelector 					#menu: #fieldMenu 					#type: #symbol ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 16 0 79 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Entry #defaultString: 'Entry:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 16 0 107 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Change #defaultString: 'Change:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 16 0 135 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Exit #defaultString: 'Exit:' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">validationDCEditSpec	"UIPainter new openOnClass: self andSelector: #validationDCEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#bounds: #(#Rectangle 386 269 622 502 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 29 0 -10 1 168 0 ) 					#label: #(#{Kernel.UserMessage} #key: #RequestValidationOn #defaultString: 'Request Validation On' #catalogID: #UIPainter) ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 54 0 -16 1 79 0 ) 					#name: #focusInField 					#model: #requestFocusInSelector 					#tabable: true 					#menu: #fieldMenu 					#type: #symbol ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 82 0 -16 1 107 0 ) 					#name: #valueChangeField 					#model: #requestValueChangeSelector 					#tabable: true 					#menu: #fieldMenu 					#type: #symbol ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 110 0 -16 1 135 0 ) 					#name: #doubleClickField 					#model: #requestDoubleClickSelector 					#tabable: true 					#menu: #fieldMenu 					#type: #symbol ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 138 0 -16 1 163 0 ) 					#name: #focusOutField 					#model: #requestFocusOutSelector 					#tabable: true 					#menu: #fieldMenu 					#type: #symbol ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 16 0 163 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Exit #defaultString: 'Exit:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 16 0 135 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #DClick #defaultString: 'D. Click:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 16 0 107 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Change #defaultString: 'Change:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 16 0 79 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Entry #defaultString: 'Entry:' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">validationEditSpec	"UIPainter new openOnClass: self andSelector: #validationEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#bounds: #(#Rectangle 395 267 631 500 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 29 0 -10 1 139 0 ) 					#label: #(#{Kernel.UserMessage} #key: #RequestValidationOn #defaultString: 'Request Validation On' #catalogID: #UIPainter) ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 54 0 -16 1 79 0 ) 					#name: #focusInField 					#model: #requestFocusInSelector 					#menu: #fieldMenu 					#type: #symbol ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 82 0 -16 1 107 0 ) 					#name: #valueChangeField 					#model: #requestValueChangeSelector 					#menu: #fieldMenu 					#type: #symbol ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 110 0 -16 1 135 0 ) 					#name: #focusOutField 					#model: #requestFocusOutSelector 					#menu: #fieldMenu 					#type: #symbol ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 16 0 107 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Change #defaultString: 'Change:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 16 0 79 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Entry #defaultString: 'Entry:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 16 0 135 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Exit #defaultString: 'Exit:' #catalogID: #UIPainter) ) ) ) )</body></methods><methods><class-id>UI.RadioButtonSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpecLiteral	"UIPainter new openOnClass: self andSelector: #basicsEditSpecLiteral"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 288 199 ) 			#max: #(#{Core.Point} 288 199 ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1088 799 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #RadioButton #defaultString: 'Radio Button' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 85 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #AspectC #defaultString: 'Aspect:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 116 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Select #defaultString: 'Select:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 147 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 28 0 -10 1 59 0 ) 					#flags: 0 					#minorKey: #labelConstructorSpec 					#clientKey: #labelConstructor ) 				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} 86 0 59 0 -10 1 84 0 ) 					#name: #modelField 					#model: #model 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#validAspectSelector: ) 					#menu: #fieldMenu ) 				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} 86 0 90 0 -10 1 115 0 ) 					#name: #selectField 					#model: #select 					#menu: #fieldMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 121 0 -10 1 146 0 ) 					#model: #name 					#menu: #fieldMenu ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 150 ) 					#model: #hasImageOrientedLabel 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #LabelIsImage #defaultString: 'Label Is Image' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">detailsEditSpec	"UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 288 199 ) 			#max: #(#Point 288 199 ) 			#bounds: #(#Rectangle 90 472 378 671 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 58 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #FontC #defaultString: 'Font:' #catalogID: #UIPainter) ) 				#(#MenuButtonSpec 					#layout: #(#LayoutFrame 86 0 35 0 -10 1 57 0 ) 					#model: #style 					#menu: #fontMenu ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 72 ) 					#model: #tabable 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #CanTab #defaultString: 'Can Tab' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 94 ) 					#model: #initiallyDisabled 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyDisabled #defaultString: 'Initially Disabled' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 115 ) 					#model: #initiallyInvisible 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyInvisible #defaultString: 'Initially Invisible' #catalogID: #UIPainter) ) ) ) )</body></methods><methods><class-id>UI.RadioButtonSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^(Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 6) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); at: 3 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 3822 scaledGreen: 0 scaledBlue: 0); at: 6 put: (ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 3822); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@L3L3L3L3L3L3L3L2@@@@@CDQDQDQDQDQDQDQD @@@@@1DQDQDQDQDQDQDQH@@@@@LQDQDQDQDQDQDQDR@@@@@CDQ@@DQDQDQDQDQD @@@@@1DDQ@DQDQDQDQDQH@@@@@LQADPAD3L3L1L1DR@@@@@CDPQD@QUUUUTUTQD @@@@@1DP@ADQDQDQDQDQH@@@@@LQDQDQDQDQDQDQDR@@@@@CDQ@@DQDQDQDQDQD @@@@@1DCL0DQDQDQDQDQH@@@@@LQ@3LAD3L3L1L1DR@@@@@CDPL3@QUUUUTUTQD @@@@@1DP@ADQDQDQDQDQH@@@@@LQDQDQDQDQDQDQDR@@@@@CDQ@@DQDQDQDQDQD @@@@@1DCL0DQDQDQDQDQH@@@@@LQ@3LAD3L3L1L1DR@@@@@CDPL3@QUUUUTUTQD @@@@@1DP@ADQDQDQDQDQH@@@@@LQDQDQDQDQDQDQDR@@@@@CDQDQDQDQDQDQDQD @@@@@"H"H"H"H"H"H"H"H@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 135 0 0 192 143 128 0 192 143 128 0 192 143 159 216 192 135 0 0 192 128 0 0 192 135 0 0 192 136 128 0 192 136 128 0 192 136 159 216 192 135 0 0 192 128 0 0 192 135 0 0 192 136 128 0 192 136 128 0 192 136 159 216 192 135 0 0 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192 ])</body></methods><methods><class-id>UI.ComboBoxSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 300 357 ) 			#max: #(#Point 300 357 ) 			#bounds: #(#Rectangle 320 204 620 561 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 4 0 144 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 4 0 54 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #AspectC #defaultString: 'Aspect:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 4 0 174 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #TypeC #defaultString: 'Type:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 4 0 84 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Menu #defaultString: 'Menu:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#Point 114 4 ) 					#label: #(#{Kernel.UserMessage} #key: #ComboBox #defaultString: 'Combo Box' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 4 0 114 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Choices #defaultString: 'Choices:' #catalogID: #UIPainter) ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 28 0 -10 1 53 0 ) 					#name: #modelField 					#model: #model 					#tabable: true 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#validAspectSelector: ) 					#menu: #fieldMenu ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 58 0 -10 1 83 0 ) 					#name: #menuField 					#model: #menu 					#tabable: true 					#menu: #fieldMenu ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 88 0 -10 1 113 0 ) 					#name: #choicesField 					#model: #comboList 					#tabable: true 					#menu: #fieldMenu 					#type: #symbol ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 86 0 118 0 -10 1 143 0 ) 					#model: #name 					#tabable: true 					#menu: #fieldMenu ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 4 0 204 0 0 1 ) 					#name: #formatLabel 					#label: #(#{Kernel.UserMessage} #key: #Format #defaultString: 'Format:' #catalogID: #UIPainter) ) 				#(#ComboBoxSpec 					#layout: #(#LayoutFrame 86 0 178 0 -10 1 203 0 ) 					#name: #formatEditor 					#model: #formatString 					#menu: #fieldMenu 					#isReadOnly: false 					#comboList: #defaultFormats ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 4 0 234 0 0 1 ) 					#name: #readSelectorLabel 					#label: #(#{Kernel.UserMessage} #key: #ReadC #defaultString: 'Read:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 4 0 264 0 0 1 ) 					#name: #printSelectorLabel 					#label: #(#{Kernel.UserMessage} #key: #Print #defaultString: 'Print:' #catalogID: #UIPainter) ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 86 0 208 0 -10 1 233 0 ) 					#name: #readSelector 					#model: #readSelector 					#type: #string ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 86 0 238 0 -10 1 263 0 ) 					#name: #printSelector 					#model: #printSelector 					#type: #string ) 				#(#MenuButtonSpec 					#layout: #(#LayoutFrame 86 0 148 0 -10 1 173 0 ) 					#model: #type 					#menu: #typeMenu ) ) ) )</body></methods><methods><class-id>UI.ComboBoxSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 7) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); at: 3 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 7099); at: 6 put: ColorValue yellow; at: 7 put: ColorValue blue; yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@L3L3L3L3L3L3L3L2@@@@@CDQDQDQDQDQDQDQD @@@@@1DQDQDQDQDQDQDQH@@@@@LQDP@@@@@@@@@ADR@@@@@CDQDEUUUUUPUU@QD @@@@@1DQAUAUUUTEUPDQH@@@@@LQDPT@AUUUAUTADR@@@@@CDQD@@@@@@@@@@QD @@@@@1DQ@3L3L3L3L0DQH@@@@@LQDPL@@@@@@CLADR@@@@@CDQDCL3L3L3L3@QD @@@@@1DQADQDQDQ&amp;Q@DQH@@@@@LQDPQCL3L3L4PADR@@@@@CDQDDQDQDQDQD@QD @@@@@1DQ@3L3L3L3L0DQH@@@@@LQDPL@@@@@@CLADR@@@@@CDQDCL3L3L3L3@QD @@@@@1DQ@3L3L3L3L0DQH@@@@@LQDPL@@@@@@CLADR@@@@@CDQDCL3L3L3L3@QD @@@@@1DQ@@@@@@@@@@DQH@@@@@LQDQDQDQDQDQDQDR@@@@@CDQDQDQDQDQDQDQD @@@@@"H"H"H"H"H"H"H"H@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 131 255 248 192 130 0 136 192 130 64 136 192 130 224 136 192 131 255 248 192 130 0 8 192 130 255 200 192 130 0 8 192 131 255 248 192 131 128 56 192 131 255 248 192 130 0 8 192 130 255 200 192 130 0 8 192 130 0 8 192 130 255 200 192 130 0 8 192 131 255 248 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192 ])</body></methods><methods><class-id>UI.RegionSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 1033 685 1333 981 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Region #defaultString: 'Region' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 60 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 35 0 -10 1 60 0 ) 					#model: #name 					#menu: #fieldMenu ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 115 0 -10 1 190 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Border #defaultString: 'Border' #catalogID: #UIPainter) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 58 0 -10 1 112 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Shape #defaultString: 'Shape' #catalogID: #UIPainter) ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 15 81 ) 					#model: #regionType 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Rectangle #defaultString: 'Rectangle' #catalogID: #UIPainter) 					#select: #rectangle ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 134 81 ) 					#model: #regionType 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Ellipse #defaultString: 'Ellipse' #catalogID: #UIPainter) 					#select: #ellipse ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 15 135 ) 					#model: #borderStyle 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #None #defaultString: 'None' #catalogID: #UIPainter) 					#select: #none ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 134 135 ) 					#model: #borderStyle 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Thin #defaultString: 'Thin' #catalogID: #UIPainter) 					#select: #thin ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 15 160 ) 					#model: #borderStyle 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Bold #defaultString: 'Bold' #catalogID: #UIPainter) 					#select: #bold ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 134 160 ) 					#model: #borderStyle 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Thick #defaultString: 'Thick' #catalogID: #UIPainter) 					#select: #thick ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 191 ) 					#name: #CheckBox1					#model: #isOpaque 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Opaque #defaultString: 'Opaque' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 211 ) 					#name: #CheckBox2					#model: #initiallyDisabled 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyDisabled #defaultString: 'Initially Disabled' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 232 ) 					#name: #CheckBox3					#model: #initiallyInvisible 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyInvisible #defaultString: 'Initially Invisible' #catalogID: #UIPainter) ) ) ) )</body></methods><methods><class-id>UI.RegionSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 5) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 3 put: (ColorValue scaledRed: 0 scaledGreen: 4915 scaledBlue: 8191); at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@L3L3L3L3L3L3L3L1@@@@@CQDQDQDQDQDQDQDPP@@@@@4QDQDQDQDQDQDQDD@@@@@MDQDQDQDQDQDQDQA@@@@@CQD@@@@@@@@QDQDPP@@@@@4Q@H"H"H"HDQDQDD@@@@@MDPBH"H"H"ADQDQA@@@@@CQD@"H"H"H QDQDPP@@@@@4Q@H"H"H@@@QDQDD@@@@@MDPBH"H@L3L0ADQA@@@@@CQD@"H @3L3L0ADPP@@@@@4Q@H"HCL3L3L0QDD@@@@@MDPBH L3L3L3L0QA@@@@@CQD@"HCL3L3L3LDPP@@@@@4Q@H"@3L3L3L3ADD@@@@@MDP@@@L3L3L3L0QA@@@@@CQDQDQ@L3L3L3ADPP@@@@@4QDQDP@L3L3L@QDD@@@@@MDQDQDP@L3L0ADQA@@@@@CQDQDQDQ@@@ADQDPP@@@@@4QDQDQDQDQDQDQDD@@@@@MDQDQDQDQDQDQDQA@@@@@CQDQDQDQDQDQDQDPP@@@@@QDQDQDQDQDQDQDQD@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 135 255 128 192 132 0 128 192 132 0 128 192 132 0 128 192 132 7 192 192 132 24 48 192 132 48 24 192 132 32 8 192 132 64 4 192 132 64 4 192 132 64 4 192 135 192 4 192 128 32 8 192 128 48 24 192 128 24 48 192 128 7 192 192 128 0 0 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192 ])</body></methods><methods><class-id>UI.SubCanvasSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	"Tools.UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #UIPainter ) 			#min: #(#{Core.Point} 223 154 ) 			#bounds: #(#{Graphics.Rectangle} 489 337 791 654 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #SubCanvas 						#defaultString: 'SubCanvas' 						#catalogID: #UIPainter ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 90 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #ClassC 						#defaultString: 'Class:' 						#catalogID: #UIPainter ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 122 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #CanvasC 						#defaultString: 'Canvas:' 						#catalogID: #UIPainter ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 58 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #NameC 						#defaultString: 'Name:' 						#catalogID: #UIPainter ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 154 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #IDC 						#defaultString: 'ID:' 						#catalogID: #UIPainter ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 31 0 -10 1 56 0 ) 					#model: #clientKey 					#menu: #fieldMenu 					#type: #string ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 63 0 -10 1 88 0 ) 					#flags: 0 					#majorKey: #{EntryWithPasteButtonModule} 					#minorKey: #windowSpec 					#clientKey: #majorKey ) 				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} 86 0 95 0 -10 1 120 0 ) 					#name: #canvasField 					#model: #minorKey 					#menu: #fieldMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 127 0 -10 1 152 0 ) 					#model: #name 					#menu: #fieldMenu ) ) ) )</body><body package="UIPainter">detailsEditSpec	"UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#min: #(#Point 237 219 ) 			#bounds: #(#Rectangle 250 201 552 518 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 27 0 -10 1 76 0 ) 					#label: #(#{Kernel.UserMessage} #key: #ScrollBars #defaultString: 'Scroll Bars' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#CheckBoxSpec 					#layout: #(#Point 15 46 ) 					#model: #hasHorizontalScrollBar 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Horizontal #defaultString: 'Horizontal' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 136 46 ) 					#model: #hasVerticalScrollBar 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Vertical #defaultString: 'Vertical' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 80 ) 					#model: #hasBorder 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Bordered #defaultString: 'Bordered' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 101 ) 					#model: #isOpaque 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Opaque #defaultString: 'Opaque' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 122 ) 					#model: #initiallyDisabled 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyDisabled #defaultString: 'Initially Disabled' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 143 ) 					#model: #initiallyInvisible 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyInvisible #defaultString: 'Initially Invisible' #catalogID: #UIPainter) ) ) ) )</body></methods><methods><class-id>UI.SubCanvasSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 7) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6007 scaledGreen: 6007 scaledBlue: 6007); at: 3 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); at: 4 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 5 put: ColorValue white; at: 6 put: (ColorValue scaledRed: 7645 scaledGreen: 0 scaledBlue: 0); at: 7 put: ColorValue blue; yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@QDQDQDQDQDQDQDQC@@@@@DH"H"H"H"H"H"H"H0@@@@ABH"H"H"H"H"H"H"L@@@@@P"@@@@@@@@@@@@H#@@@@@DH Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;XBH0@@@@ABH@@@@@@@@@@@@"L@@@@@P"ADQDQDQDQDQ@H#@@@@@DH QDQDQDQDQDPBH0@@@@ABHD@@QDQ@@@@D@"L@@@@@P"A@TD@@PDQDA@H#@@@@@DH P@ADQDADQ@PBH0@@@@ABHDQDQDQ@QDPD@"L@@@@@P"A@@DQDPDQDA@H#@@@@@DH PDA@@DADQ@PBH0@@@@ABHD@@QDQ@@@@D@"L@@@@@P"ADQDQDQDQDQ@H#@@@@@DH P@@@AD@@@@PBH0@@@@ABHDAADPQ@PQDD@"L@@@@@P"A@@@@DP@@@A@H#@@@@@DH QDQDQDQDQDPBH0@@@@ABH@@@@@@@@@@@@"L@@@@@P"H"H"H"H"H"H"H#@@@@@DH"H"H"H"H"H"H"H0@@@@@3L3L3L3L3L3L3L3L@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 143 255 252 192 136 0 4 192 143 255 252 192 136 0 4 192 136 0 4 192 139 131 244 192 139 186 20 192 139 130 20 192 136 2 20 192 139 130 20 192 138 186 20 192 139 131 244 192 136 0 4 192 139 243 244 192 138 18 20 192 139 243 244 192 136 0 4 192 143 255 252 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192 ])</body><body package="UIPainter">selectionPopUpMenu	"UIMenuEditor new openOnClass: self andSelector: #selectionPopUpMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #createSubApplication #defaultString: 'create sub application' #catalogID: #UIPainter) ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #paintSubApplication #defaultString: 'paint sub application' #catalogID: #UIPainter) ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #browseSubApplication #defaultString: 'browse sub application' #catalogID: #UIPainter) ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #extractContents #defaultString: 'extract contents' #catalogID: #UIPainter) ) ) #(3 1 ) #(#doDefineApplication #doPaintApplication #doBrowseApplication #doExtractSubCanvas ) ) decodeAsLiteralArray</body><body package="UIPainter">selectionPullDownMenu	"UIMenuEditor new openOnClass: self andSelector: #selectionPullDownMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #CreateSubApplication #defaultString: 'Create Sub Application' #catalogID: #UIPainter) ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #PaintSubApplication #defaultString: 'Paint Sub Application' #catalogID: #UIPainter) ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #BrowseSubApplication #defaultString: 'Browse Sub Application' #catalogID: #UIPainter) ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #ExtractContents #defaultString: 'Extract Contents' #catalogID: #UIPainter) ) ) #(3 1 ) #(#doDefineApplication #doPaintApplication #doBrowseApplication #doExtractSubCanvas ) ) decodeAsLiteralArray</body></methods><methods><class-id>UI.DocumentEditorSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3790 3790 3790)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6520 6520 6520)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 2537 4882)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@H"H"H"H"H"H"H"H!@@@@@BL3L3L3L3L3L3L3LP@@@@@#MDQDQDQDQDQDP3D@@@@@H3P"H"H"H"H"H$L1@@@@@BL4H"H"H"H"H"ICLP@@@@@#MBIDH"QBH"H"P3D@@@@@H3P"H$H"IBH"H$L1@@@@@BL4H$QBIDP"H"ICLP@@@@@#MBP"P$H$H"H"P3D@@@@@H3P$H$IBIBH"H$L1@@@@@BL4H$QBIDP"H"ICLP@@@@@#MBH"H"H"H"H"P3D@@@@@H3P"H"HB@"H"H$L1@@@@@BL4H$P"HBH"H"ICLP@@@@@#MBH"P"@"H"H"P3D@@@@@H3P"QDH H"H"H$L1@@@@@BL4IBIBHBH"H"ICLP@@@@@#MBP"P"@"H"H"P3D@@@@@H3P"QDH H"H"H$L1@@@@@BL4H"H"@ H"H"ICLP@@@@@#MBH"H"H"H"H"P3D@@@@@H3QDQDQDQDQDQDL1@@@@@BL3L3L3L3L3L3L3LP@@@@@QDQDQDQDQDQDQDQD@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body></methods><methods><class-id>UI.ResizingSplitterSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 300 243 ) 			#max: #(#{Core.Point} 300 243 ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1100 843 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 2 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Splitter #defaultString: 'Splitter' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 138 0 25 0 1 0 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 25 0 -5 1 50 0 ) 					#model: #name 					#menu: #fieldMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 55 0 -5 1 80 0 ) 					#name: #aboveWidgets 					#model: #aboveWidgets ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 85 0 -5 1 110 0 ) 					#name: #minAboveSize 					#model: #minAboveSize 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 115 0 -5 1 140 0 ) 					#name: #belowWidgets 					#model: #belowWidgets ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 145 0 -5 1 170 0 ) 					#name: #minBelowSize 					#model: #minBelowSize 					#type: #number ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 140 175 ) 					#name: #horizontal 					#model: #horizontal 					#label: #(#{Kernel.UserMessage} #key: #Horizontal #defaultString: 'Horizontal' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 138 0 55 0 1 0 ) 					#name: #leftTopWidgetsLabel 					#label: #(#{Kernel.UserMessage} #key: #TopWidgets #defaultString: 'Top widgets:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 138 0 115 0 1 0 ) 					#name: #rightBottomWidgetsLabel 					#label: #(#{Kernel.UserMessage} #key: #BottomWidgets #defaultString: 'Bottom widgets:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 138 0 85 0 1 0 ) 					#name: #leftTopSizeLabel 					#label: #(#{Kernel.UserMessage} #key: #TopMinSize #defaultString: 'Top min size:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 138 0 146 0 1 0 ) 					#name: #rightBottomSizeLabel 					#label: #(#{Kernel.UserMessage} #key: #BottomMinSize #defaultString: 'Bottom min size:' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 140 199 ) 					#name: #CheckBox1 					#model: #isDecorated 					#label: #(#{Kernel.UserMessage} #key: #Bordered #defaultString: 'Bordered' #catalogID: #UIPainter) ) ) ) )</body></methods><methods><class-id>UI.ResizingSplitterSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 4) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 3699 scaledGreen: 3699 scaledBlue: 3699); at: 3 put: Graphics.ColorValue white; at: 4 put: (Graphics.ColorValue scaledRed: 6605 scaledGreen: 6605 scaledBlue: 6605); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@*******)@@B???????4@@K???C???P@@/??0C??=@@B??&lt;@C??4@@K??@@C??P@@/?0@@C?=@@B???0???4@@K???C???P@@/??&lt;O??=@@B&lt;@@@@@O4@@K0@@@@@?P@@/??&lt;O??=@@B???0???4@@K???C???P@@/?0@@C?=@@B??0@@??4@@K??0@O??P@@/??0C??=@@B???0???4@@K???????P@@/??????=@@B???????4@@EUUUUUUUP@@@@@@@@@@@@@@a'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 12 0 192 128 30 0 192 128 63 0 192 128 127 128 192 128 255 192 192 128 12 0 192 128 12 0 192 128 12 0 192 143 255 248 192 143 255 248 192 128 12 0 192 128 12 0 192 128 12 0 192 128 255 192 192 128 127 128 192 128 63 0 192 128 30 0 192 128 12 0 192 128 0 0 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192])</body></methods><methods><class-id>UI.ActionButtonSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpecLiteral	"UIPainter new openOnClass: self andSelector: #basicsEditSpecLiteral"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 298 187 ) 			#max: #(#{Core.Point} 298 187 ) 			#bounds: #(#{Graphics.Rectangle} 651 507 949 694 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #ActionButton #defaultString: 'Action Button' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 117 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 86 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #ActionC #defaultString: 'Action:' #catalogID: #UIPainter) ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 28 0 -10 1 59 0 ) 					#flags: 0 					#minorKey: #labelConstructorSpec 					#clientKey: #labelConstructor ) 				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} 86 0 59 0 -10 1 84 0 ) 					#name: #modelField 					#model: #model 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#validAspectSelector: ) 					#menu: #fieldMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 90 0 -10 1 115 0 ) 					#model: #name 					#menu: #fieldMenu ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 118 ) 					#model: #isDefault 					#label: #(#{Kernel.UserMessage} #key: #BeDefault #defaultString: 'Be Default' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 138 ) 					#model: #defaultable 					#label: #(#{Kernel.UserMessage} #key: #SizeAsDefault #defaultString: 'Size as Default' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 157 ) 					#model: #hasImageOrientedLabel 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #LabelIsImage #defaultString: 'Label Is Image' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">detailsEditSpec	"Tools.UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 238 239 ) 			#max: #(#{Core.Point} 238 239 ) 			#bounds: #(#{Graphics.Rectangle} 1161 600 1399 839 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 35 0 -10 1 57 0 ) 					#model: #style 					#menu: #fontMenu ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0 68 0 ) 					#model: #isDecorated 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #Bordered 						#defaultString: 'Bordered' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0 88 0 ) 					#model: #isOpaque 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #Opaque 						#defaultString: 'Opaque' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0 108 0 ) 					#model: #tabable 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #CanTab 						#defaultString: 'Can Tab' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0 128 0 ) 					#model: #initiallyDisabled 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #InitiallyDisabled 						#defaultString: 'Initially Disabled' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0 149 0 ) 					#model: #initiallyInvisible 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #InitiallyInvisible 						#defaultString: 'Initially Invisible' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0 190 0 ) 					#model: #legacyButtonLayout 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #UseLegacyButtonLayout 						#defaultString: 'Use legacy button layout' 						#catalogID: #UIPainter ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 59 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #FontC 						#defaultString: 'Font:' 						#catalogID: #UIPainter ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) ) ) )</body></methods><methods><class-id>UI.ActionButtonSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@*******)@@B???????4@@K???????P@@/??????=@@B???????4@@K???????P@@/:****#=@@B?/????O4@@K&gt;????&lt;?P@@/;&lt;O333=@@B?/OOL?O4@@K&gt;&lt;&lt;&lt;O&lt;?P@@/;333O3=@@B?/0?OOO4@@K&gt;????&lt;?P@@/;????3=@@B?@@@@@O4@@K???????P@@/??????=@@B???????4@@K???????P@@/??????=@@B???????4@@EUUUUUUUP@@@@@@@@@@@@@@a'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 135 255 248 192 132 0 12 192 132 0 12 192 132 98 76 192 132 146 140 192 132 147 12 192 132 146 140 192 132 98 76 192 132 0 12 192 132 0 12 192 135 255 252 192 131 255 252 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192])</body></methods><methods><class-id>UI.SequenceViewSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 300 206 ) 			#max: #(#Point 300 206 ) 			#bounds: #(#Rectangle 230 206 530 412 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 55 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #AspectC #defaultString: 'Aspect:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 118 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 86 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Menu #defaultString: 'Menu:' #catalogID: #UIPainter) ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragEnterSelector 						#dragEnterSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: #dropSelector 						#dropInSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 29 0 -10 1 54 0 ) 					#name: #modelField 					#model: #model 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#validAspectSelector: ) 					#menu: #fieldMenu ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragEnterSelector 						#dragEnterSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: #dropSelector 						#dropInSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 60 0 -10 1 85 0 ) 					#name: #menuField 					#model: #menu 					#menu: #fieldMenu ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 86 0 92 0 -10 1 117 0 ) 					#model: #name 					#menu: #fieldMenu ) ) ) )</body><body package="UIPainter">detailsEditSpec	"UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 235 229 ) 			#max: #(#{Core.Point} 256 333 ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1056 933 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 28 ) 					#label: #(#{Kernel.UserMessage} #key: #FontC #defaultString: 'Font:' #catalogID: #UIPainter) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 50 0 -10 1 97 0 ) 					#label: #(#{Kernel.UserMessage} #key: #ScrollBars #defaultString: 'Scroll Bars' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 271 ) 					#label: #(#{Kernel.UserMessage} #key: #SelectionType #defaultString: 'Selection Type:' #catalogID: #UIPainter) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 55 0 28 0 -10 1 52 0 ) 					#name: #fontMenu 					#model: #style 					#menu: #fontMenu ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 17 69 ) 					#model: #hasHorizontalScrollBar 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Horizontal #defaultString: 'Horizontal' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 132 69 ) 					#model: #hasVerticalScrollBar 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Vertical #defaultString: 'Vertical' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 99 ) 					#model: #hasBorder 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Bordered #defaultString: 'Bordered' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 120 ) 					#model: #isOpaque 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Opaque #defaultString: 'Opaque' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 141 ) 					#model: #tabable 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #CanTab #defaultString: 'Can Tab' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 162 ) 					#model: #initiallyInvisible 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyInvisible #defaultString: 'Initially Invisible' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 183 ) 					#model: #initiallyDisabled 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyDisabled #defaultString: 'Initially Disabled' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 204 ) 					#model: #multipleSelections 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #MultiSelect #defaultString: 'Multi Select' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 225 ) 					#model: #useModifierKeys 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #GenKey20 #defaultString: 'Use Modifier Keys For Multi Select' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 246 ) 					#name: #CheckBox1					#model: #autoSelect 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #AutoSelectOnKeyNavigation #defaultString: 'Auto Select on Key Navigation' #catalogID: #UIPainter) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 115 0 271 0 -10 1 295 0 ) 					#model: #selectionType 					#menu: #selectionTypeMenu ) ) ) )</body><body package="UIPainter">dropSourceSpec	"UIPainter new openOnClass: self andSelector: #dropSourceSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#bounds: #(#Rectangle 327 243 563 476 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 29 0 -10 1 127 0 ) 					#label: #(#{Kernel.UserMessage} #key: #DragSource #defaultString: 'Drag Source' #catalogID: #UIPainter) ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 54 0 -16 1 79 0 ) 					#name: #dragOKField 					#model: #dragOkSelector 					#menu: #fieldMenu 					#type: #string ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 82 0 -16 1 107 0 ) 					#name: #dragStartField 					#model: #dragStartSelector 					#menu: #fieldMenu 					#type: #string ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 12 0 107 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #DragStart #defaultString: 'Drag Start:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 12 0 79 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #DragOk #defaultString: 'Drag Ok:' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 12 148 ) 					#name: #selectOnDownIfDragEnabled 					#model: #selectOnDownIfDragEnabled 					#label: #(#{Kernel.UserMessage} #key: #SelectOnDown #defaultString: 'Select On Down' #catalogID: #UIPainter) ) ) ) )</body></methods><methods><class-id>UI.SequenceViewSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 6) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); at: 3 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 7099); at: 6 put: (ColorValue scaledRed: 0 scaledGreen: 4915 scaledBlue: 8191); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@L3L3L3L3L3L3L3L2@@@@@CDQDQDQDQDQDQDQD @@@@@1DQDQDQDQDQDQDQH@@@@@LQ@@@@@@@@@@@@DR@@@@@CDPL3L3L3L3LCLAD @@@@@1DCL3L3L3L3@3@QH@@@@@LQ@0@@@@@@L0@@DR@@@@@CDPL3L3L3L3LETAD @@@@@1DCL3L3L3L3AU@QH@@@@@LQADQDQDQDP0UPDR@@@@@CDPQCL3L3MDLETAD @@@@@1DDQDQDQDQCAU@QH@@@@@LQ@3L3L3L3L0UPDR@@@@@CDPL3L3L3L3LETAD @@@@@1DC@@@@@@@3AU@QH@@@@@LQ@3L3L3L3L0UPDR@@@@@CDPL3L3L3L3LETAD @@@@@1DC@@@@@@@3@@@QH@@@@@LQ@3L3L3L3L0L0DR@@@@@CDPL3L3L3L3LCLAD @@@@@1D@@@@@@@@@@@@QH@@@@@LQDQDQDQDQDQDQDR@@@@@CDQDQDQDQDQDQDQD @@@@@"H"H"H"H"H"H"H"H@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 143 255 252 192 136 0 36 192 136 0 36 192 139 255 60 192 136 0 36 192 136 0 36 192 143 255 164 192 142 1 164 192 143 255 164 192 136 0 36 192 136 0 36 192 139 255 36 192 136 0 36 192 136 0 36 192 139 255 60 192 136 0 36 192 136 0 36 192 143 255 252 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192 ])</body><body package="UIPainter">selectionTypeMenu	"MenuEditor new openOnClass: self andSelector: #selectionTypeMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #Highlight #defaultString: 'Highlight' #catalogID: #UIPainter) 				#value: #highlight ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #HighlightWithGraphics #defaultString: 'Highlight with graphics' #catalogID: #UIPainter) 				#value: #normalSelection ) 			#(#MenuItem 				#rawLabel: #(#{Kernel.UserMessage} #key: #CheckMark #defaultString: 'Check Mark' #catalogID: #UIPainter) 				#value: #checkMark ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>UI.WindowSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpecLiteral	"UIPainter new openOnClass: self andSelector: #basicsEditSpecLiteral"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 300 222 ) 			#max: #(#{Core.Point} 300 222 ) 			#bounds: #(#{Graphics.Rectangle} 650 489 950 711 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Window #defaultString: 'Window' #catalogID: #UIPainter) ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 28 0 -10 1 59 0 ) 					#flags: 0 					#minorKey: #labelConstructorSpec 					#clientKey: #labelConstructor ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 16 82 ) 					#model: #hasMenuBar 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Enable #defaultString: 'Enable' #catalogID: #UIPainter) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 104 0 -16 1 129 0 ) 					#name: #menuField 					#model: #menu 					#tabable: true 					#menu: #fieldMenu 					#type: #symbol ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 16 0 129 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Menu #defaultString: 'Menu:' #catalogID: #UIPainter) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 63 0 -10 1 137 0 ) 					#label: #(#{Kernel.UserMessage} #key: #MenuBar #defaultString: 'Menu Bar' #catalogID: #UIPainter) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 137 0 -10 1 191 0 ) 					#label: #(#{Kernel.UserMessage} #key: #ToolBar #defaultString: 'Tool Bar' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 16 0 183 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Menu #defaultString: 'Menu:' #catalogID: #UIPainter) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 84 0 156 0 -16 1 185 0 ) 					#name: #toolBarField 					#model: #toolBar 					#tabable: true 					#menu: #fieldMenu 					#type: #symbol ) ) ) )</body><body package="UIPainter">detailsEditSpec	"UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 300 222 ) 			#max: #(#Point 300 222 ) 			#bounds: #(#Rectangle 507 367 807 589 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 26 0 -13 1 80 0 ) 					#label: #(#{Kernel.UserMessage} #key: #ScrollBars #defaultString: 'Scroll Bars' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Window #defaultString: 'Window' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 15 49 ) 					#model: #hasHorizontalScrollBar 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Horizontal #defaultString: 'Horizontal' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 130 49 ) 					#model: #hasVerticalScrollBar 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Vertical #defaultString: 'Vertical' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 91 ) 					#model: #hasBorder 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Bordered #defaultString: 'Bordered' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">dropTargetSpec	"Tools.UIPainter new openOnClass: self andSelector: #dropTargetSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #UIPainter ) 			#bounds: #(#{Graphics.Rectangle} 1162 604 1398 837 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 29 0 -8 1 185 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #DropTarget 						#defaultString: 'Drop Target' 						#catalogID: #UIPainter ) ) 				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} 86 0 54 0 -16 1 79 0 ) 					#name: #dragEnterField 					#model: #dragEnterSelector 					#menu: #fieldMenu 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} 86 0 82 0 -16 1 107 0 ) 					#name: #dragOverField 					#model: #dragOverSelector 					#menu: #fieldMenu 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} 86 0 110 0 -16 1 135 0 ) 					#name: #dragExitField 					#model: #dragExitSelector 					#menu: #fieldMenu 					#type: #string ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Window 						#defaultString: 'Window' 						#catalogID: #UIPainter ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 16 0 107 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Over 						#defaultString: 'Over:' 						#catalogID: #UIPainter ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 16 0 79 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Entry 						#defaultString: 'Entry:' 						#catalogID: #UIPainter ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 16 0 135 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Exit 						#defaultString: 'Exit:' 						#catalogID: #UIPainter ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 16 0 163 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Drop 						#defaultString: 'Drop:' 						#catalogID: #UIPainter ) ) 				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} 86 0 138 0 -16 1 163 0 ) 					#name: #dropField 					#model: #dropSelector 					#menu: #fieldMenu 					#type: #string ) ) ) )</body></methods><methods><class-id>UI.GroupBoxSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpecLiteral	"UIPainter new openOnClass: self andSelector: #basicsEditSpecLiteral"		&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 264 111 ) 			#max: #(#Point 299 115 ) 			#bounds: #(#Rectangle 170 364 434 479 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #GroupBox #defaultString: 'Group Box' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 87 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 10 0 29 0 -10 1 60 0 ) 					#flags: 0 					#minorKey: #labelConstructorSpec 					#clientKey: #labelConstructor ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 86 0 60 0 -10 1 85 0 ) 					#model: #name 					#menu: #fieldMenu ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 88 ) 					#model: #hasImageOrientedLabel 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #LabelIsImage #defaultString: 'Label Is Image' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">detailsEditSpec	"UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 294 106 ) 			#max: #(#{Core.Point} 299 195 ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1094 795 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 58 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #FontC #defaultString: 'Font:' #catalogID: #UIPainter) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 34 0 -10 1 57 0 ) 					#model: #style 					#menu: #fontMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 72 0 -10 1 95 0 ) 					#name: #mnemonic 					#model: #mnemonic 					#type: #symbol ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 109 ) 					#model: #initiallyDisabled 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyDisabled #defaultString: 'Initially Disabled' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 132 ) 					#model: #initiallyInvisible 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyInvisible #defaultString: 'Initially Invisible' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 71 ) 					#name: #mnemonicLabel 					#label: #(#{Kernel.UserMessage} #key: #Mnemonic #defaultString: 'Mnemonic:' #catalogID: #UIPainter) ) ) ) )</body></methods><methods><class-id>UI.GroupBoxSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@*******)@@B???????4@@K???????P@@/?O????=@@B?&lt;?????4@@K00LCL0OP@@/OL3OO&lt;=@@B&lt;&lt;C@3O34@@K3?????OP@@/O????&lt;=@@B&lt;?????34@@K3?????OP@@/O????&lt;=@@B&lt;?????34@@K3?????OP@@/O????&lt;=@@B&lt;?????34@@K3?????OP@@/O????&lt;=@@B&lt;?????34@@K0@@@@@OP@@/??????=@@B???????4@@EUUUUUUUP@@@@@@@@@@@@@@a'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 129 0 0 192 129 0 0 192 141 221 92 192 137 84 132 192 137 221 68 192 136 0 4 192 136 0 4 192 136 0 4 192 136 0 4 192 136 0 4 192 136 0 4 192 136 0 4 192 136 0 4 192 136 0 4 192 136 0 4 192 136 0 4 192 136 0 4 192 143 255 252 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192 ])</body></methods><methods><class-id>UI.DataSetSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	"Tools.UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 300 206 ) 			#max: #(#{Core.Point} 300 206 ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1100 883 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} -1 0 146 0 1 1 150 0 ) 					#name: #Divider1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 4 0 54 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #AspectC #defaultString: 'Aspect:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 4 0 108 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 4 0 81 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Menu #defaultString: 'Menu:' #catalogID: #UIPainter) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 28 0 -6 1 53 0 ) 					#model: #model 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#validAspectSelector: ) 					#menu: #fieldMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 55 0 -6 1 80 0 ) 					#model: #menu 					#menu: #fieldMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 82 0 -6 1 107 0 ) 					#model: #name 					#menu: #fieldMenu ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -127 0.5 114 0 -2 0.5 140 0 ) 					#name: #newColumn 					#model: #addColumn 					#label: #(#{Kernel.UserMessage} #key: #NewColumn #defaultString: 'New Column' #catalogID: #UIPainter) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 114 0 127 0.5 140 0 ) 					#name: #deleteColumn 					#model: #deleteColumn 					#label: #(#{Kernel.UserMessage} #key: #RemoveColumn #defaultString: 'Remove Column' #catalogID: #UIPainter) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} -40 0.5 3 0 ) 					#label: #componentName ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 151 ) 					#name: #CheckBox1 					#model: #rowIndicator 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #RowSelector #defaultString: 'Row Selector' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 122 151 ) 					#name: #CheckBox5 					#model: #rowLabelsAsButtons 					#label: #(#{Kernel.UserMessage} #key: #RowSelectorAsButtons #defaultString: 'Row Selector As Buttons' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 171 ) 					#name: #CheckBox3 					#model: #labelsAsButtons 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #ColumnLabelsAsButtons #defaultString: 'Column Labels as Buttons' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 191 ) 					#name: #CheckBox7 					#model: #allowColumnResizing 					#label: #(#{Kernel.UserMessage} #key: #AllowColumnResizing #defaultString: 'Allow Column Resizing' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 210 ) 					#name: #CheckBox9 					#model: #allowColumnReordering 					#label: #(#{Kernel.UserMessage} #key: #AllowColumnReordering #defaultString: 'Allow Column Reordering' #catalogID: #UIPainter) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 81 231 127 255 ) 					#name: #rowSize 					#model: #rowSize 					#menu: #fieldMenu 					#type: #number 					#formatString: '#' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 231 ) 					#name: #Label1 					#label: #(#{Kernel.UserMessage} #key: #RowSize #defaultString: 'Row Size :' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">detailsEditSpec	"UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 204 83 ) 			#max: #(#{Core.Point} 278 257 ) 			#bounds: #(#{Graphics.Rectangle} 1046 754 1333 1042 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 14 0 26 0 -14 1 70 0 ) 					#label: #(#{Kernel.UserMessage} #key: #ScrollBars #defaultString: 'Scroll Bars' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} -40 0.5 3 0 ) 					#label: #componentName ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 22 45 ) 					#model: #hasHorizontalScrollBar 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Horizontal #defaultString: 'Horizontal' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.5 45 0 ) 					#model: #hasVerticalScrollBar 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Vertical #defaultString: 'Vertical' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 14 77 ) 					#model: #hasBorder 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Bordered #defaultString: 'Bordered' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 14 98 ) 					#model: #isOpaque 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Opaque #defaultString: 'Opaque' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 14 119 ) 					#model: #tabable 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #CanTab #defaultString: 'Can Tab' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 14 140 ) 					#model: #initiallyDisabled 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyDisabled #defaultString: 'Initially Disabled' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 14 161 ) 					#model: #initiallyInvisible 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyInvisible #defaultString: 'Initially Invisible' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 14 182 ) 					#model: #multipleSelections 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #MultipleSelections #defaultString: 'Multiple Selections' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 14 203 ) 					#name: #CheckBox1 					#model: #showVerticalLines 					#label: #(#{Kernel.UserMessage} #key: #ShowVerticalLines #defaultString: 'Show Vertical Lines' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 14 224 ) 					#name: #CheckBox3 					#model: #showHorizontalLines 					#label: #(#{Kernel.UserMessage} #key: #ShowHorizontalLines #defaultString: 'Show Horizontal Lines' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 14 245 ) 					#name: #CheckBox4 					#model: #showLineNumbers 					#label: #(#{Kernel.UserMessage} #key: #ShowLineNumbers #defaultString: 'Show Line Numbers' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">navigationEditSpec	"UIPainter new openOnClass: self andSelector: #navigationEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#bounds: #(#Rectangle 808 356 1132 579 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#RadioButtonSpec 					#layout: #(#Point 22 45 ) 					#model: #verticalPolicy 					#label: #(#{Kernel.UserMessage} #key: #NoWrapping #defaultString: 'No Wrapping' #catalogID: #UIPainter) 					#select: #noWrap ) 				#(#RadioButtonSpec 					#layout: #(#Point 22 89 ) 					#model: #verticalPolicy 					#label: #(#{Kernel.UserMessage} #key: #None #defaultString: 'None' #catalogID: #UIPainter) 					#select: #none ) 				#(#RadioButtonSpec 					#layout: #(#Point 22 67 ) 					#model: #verticalPolicy 					#label: #(#{Kernel.UserMessage} #key: #Wrapping #defaultString: 'Wrapping' #catalogID: #UIPainter) 					#select: #wrap ) 				#(#RadioButtonSpec 					#layout: #(#Point 22 133 ) 					#model: #horizontalPolicy 					#label: #(#{Kernel.UserMessage} #key: #NoWrapping #defaultString: 'No Wrapping' #catalogID: #UIPainter) 					#select: #noWrap ) 				#(#RadioButtonSpec 					#layout: #(#Point 22 177 ) 					#model: #horizontalPolicy 					#label: #(#{Kernel.UserMessage} #key: #WrapOnSameRow #defaultString: 'Wrap on same row' #catalogID: #UIPainter) 					#select: #wrapSame ) 				#(#RadioButtonSpec 					#layout: #(#Point 22 155 ) 					#model: #horizontalPolicy 					#label: #(#{Kernel.UserMessage} #key: #WrapToNextRow #defaultString: 'Wrap to next row' #catalogID: #UIPainter) 					#select: #wrapNext ) 				#(#RadioButtonSpec 					#layout: #(#Point 22 199 ) 					#model: #horizontalPolicy 					#label: #(#{Kernel.UserMessage} #key: #None #defaultString: 'None' #catalogID: #UIPainter) 					#select: #none ) 				#(#LabelSpec 					#layout: #(#LayoutOrigin -40 0.5 3 0 ) 					#label: #componentName ) 				#(#LabelSpec 					#layout: #(#Point 14 25 ) 					#label: #(#{Kernel.UserMessage} #key: #VerticalPolicy #defaultString: 'Vertical Policy' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#Point 14 111 ) 					#label: #(#{Kernel.UserMessage} #key: #HorizontalPolicy #defaultString: 'Horizontal Policy' #catalogID: #UIPainter) ) ) ) )</body></methods><methods><class-id>UI.DataSetSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 6) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4369); at: 3 put: (ColorValue scaledRed: 4369 scaledGreen: 0 scaledBlue: 0); at: 4 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); at: 5 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 6 put: ColorValue white; yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@UUUUUUUUUUUUUUUT@@@@@EL3L3L3L3L3L3L3M@@@@@ASL3L3L3L3L3L3L3P@@@@@T3L3L3L3L3L3L3L4@@@@@EL0@@@@@@@@@@@CM@@@@@ASLEUUEUUQUUUU@3P@@@@@T3ARUQUUTUUUUPL4@@@@@EL0UUTUUUEUUUTCM@@@@@ASLADQDQDQDQDQ@3P@@@@@T3AUUQUUTUUUUPL4@@@@@EL0T%TUUUEUUUTCM@@@@@ASLEUUEUUQUUUU@3P@@@@@T3@QDQDQDQDQDPL4@@@@@EL0UUTUUUEUUUTCM@@@@@ASLEIUEUUQUUUU@3P@@@@@T3AUUQUUTUUUUPL4@@@@@EL0DQDQDQDQDQDCM@@@@@ASLEUUEUUQUUUU@3P@@@@@T3ARUQUUTUUUUPL4@@@@@EL0UUTUUUEUUUTCM@@@@@ASL@@@@@@@@@@@@3P@@@@@T3L3L3L3L3L3L3L4@@@@@EL3L3L3L3L3L3L3M@@@@@ADQDQDQDQDQDQDQDP@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 143 255 252 192 136 66 4 192 138 66 4 192 136 66 4 192 143 255 252 192 136 66 4 192 138 66 4 192 136 66 4 192 143 255 252 192 136 66 4 192 138 66 4 192 136 66 4 192 143 255 252 192 136 66 4 192 138 66 4 192 136 66 4 192 143 255 252 192 128 0 0 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192 ])</body></methods><methods><class-id>UI.TabControlSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#bounds: #(#{Graphics.Rectangle} 649 442 951 759 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 4 0 81 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 4 0 54 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Tabs #defaultString: 'Tabs:' #catalogID: #UIPainter) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 28 0 -6 1 53 0 ) 					#model: #model 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#validAspectSelector: ) 					#menu: #fieldMenu 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 58 0 -6 1 83 0 ) 					#model: #name 					#menu: #fieldMenu 					#type: #string ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) ) ) )</body><body package="UIPainter">detailsEditSpec	"UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#min: #(#{Core.Point} 266 263 ) 			#bounds: #(#{Graphics.Rectangle} 667 469 933 732 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 231 ) 					#model: #tabable 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #CanTab #defaultString: 'Can Tab' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 202 ) 					#label: #(#{Kernel.UserMessage} #key: #FontC #defaultString: 'Font:' #catalogID: #UIPainter) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 80 0 203 0 -10 1 225 0 ) 					#model: #style 					#menu: #fontMenu ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 30 0 -10 1 185 0 ) 					#flags: 0 					#majorKey: #SimpleListEditor 					#minorKey: #windowSpec 					#clientKey: #labelsModel ) ) ) )</body></methods><methods><class-id>UI.TabControlSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 6) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); at: 3 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 4112 scaledGreen: 4112 scaledBlue: 4112); at: 6 put: ColorValue lightGray; yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@L3L3L3L3L3L3L3L2@@@@@CDQDQDQDQDQDQDQD @@@@@1DQDQDQDQDQDQDQH@@@@@LQL3LQDQDQDQDQDR@@@@@CD5UUPCL3DQL3LQD @@@@@1MQDTAUUT@5UUPAH@@@@@LSTQE@TQE@MQDT@R@@@@@CD5DQP3L3L3L3M@D @@@@@1MQDQDQDQDQDQPAH@@@@@LSTQDQDQDQDQDT@R@@@@@CD5DQDQDQDQDQE@D @@@@@1MQDQDQDQDQDQPAH@@@@@LSTQDQDQDQDQDT@R@@@@@CD5DQDQDQDQDQE@D @@@@@1MQDQDQDQDQDQPAH@@@@@LSTQDQDQDQDQDT@R@@@@@CD5DQDQDQDQDQE@D @@@@@1MQDQDQDQDQDQPAH@@@@@LSQDQDQDQDQDQD@R@@@@@CD@@@@@@@@@@@@@D @@@@@1DQDQDQDQDQDQDQH@@@@@LQDQDQDQDQDQDQDR@@@@@CDQDQDQDQDQDQDQD @@@@@"H"H"H"H"H"H"H"H@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 143 128 0 192 144 126 252 192 144 65 2 192 144 65 2 192 144 127 254 192 144 0 2 192 144 0 2 192 144 0 2 192 144 0 2 192 144 0 2 192 144 0 2 192 144 0 2 192 144 0 2 192 144 0 2 192 144 0 2 192 144 0 2 192 159 255 254 192 128 0 0 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192])</body></methods><methods><class-id>UI.SpinButtonSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 300 357 ) 			#max: #(#{Core.Point} 300 357 ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1100 957 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 4 0 106 0 0 1 ) 					#name: #Label1 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 4 0 49 0 0 1 ) 					#name: #Label2 					#label: #(#{Kernel.UserMessage} #key: #AspectC #defaultString: 'Aspect:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 4 0 134 0 0 1 ) 					#name: #Label3 					#label: #(#{Kernel.UserMessage} #key: #TypeC #defaultString: 'Type:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 4 0 78 0 0 1 ) 					#name: #Label4 					#label: #(#{Kernel.UserMessage} #key: #Menu #defaultString: 'Menu:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 114 1 ) 					#name: #Label5 					#label: #(#{Kernel.UserMessage} #key: #SpinButton #defaultString: 'Spin Button' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 4 0 163 0 0 1 ) 					#name: #formatLabel 					#label: #(#{Kernel.UserMessage} #key: #Format #defaultString: 'Format:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 4 0 190 0 0 1 ) 					#name: #lowValueLabel 					#label: #(#{Kernel.UserMessage} #key: #ValueLow #defaultString: 'Value-Low:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} -132 1 190 0 0 1 ) 					#name: #highValueLabel 					#label: #(#{Kernel.UserMessage} #key: #High #defaultString: 'High:' #catalogID: #UIPainter) ) 				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} 80 0 23 0 -10 1 48 0 ) 					#name: #modelField 					#model: #model 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#validAspectSelector: ) 					#tabable: true 					#menu: #fieldMenu ) 				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} 80 0 52 0 -10 1 77 0 ) 					#name: #menuField 					#model: #menu 					#tabable: true 					#menu: #fieldMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 80 0 80 0 -10 1 105 0 ) 					#name: #InputField1 					#model: #name 					#tabable: true 					#menu: #fieldMenu ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 80 0 108 0 -10 1 133 0 ) 					#name: #MenuButton1 					#model: #type 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #spinButtonTypeChange ) 					#menu: #typeMenu ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 80 0 137 0 -10 1 162 0 ) 					#name: #formatEditor 					#model: #formatString 					#menu: #fieldMenu 					#isReadOnly: false 					#comboList: #defaultFormats ) 				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} 80 0 166 0 -135 1 191 0 ) 					#name: #lowField 					#model: #low 					#tabable: true 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} -95 1 166 0 -10 1 191 0 ) 					#name: #highField 					#model: #high 					#tabable: true 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} 80 0 194 0 -135 1 219 0 ) 					#name: #intervalField 					#model: #interval 					#tabable: true 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} 80 0 166 0 -135 1 191 0 ) 					#name: #lowDateField 					#model: #lowDate 					#tabable: true 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} -95 1 166 0 -10 1 191 0 ) 					#name: #highDateField 					#model: #highDate 					#tabable: true 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} 80 0 166 0 -135 1 191 0 ) 					#name: #lowTimeField 					#model: #lowTime 					#tabable: true 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} -95 1 166 0 -10 1 191 0 ) 					#name: #highTimeField 					#model: #highTime 					#tabable: true 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} 80 0 166 0 -135 1 191 0 ) 					#name: #lowTimestampField 					#model: #lowTimestamp 					#tabable: true 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} -95 1 166 0 -10 1 191 0 ) 					#name: #highTimestampField 					#model: #highTimestamp 					#tabable: true 					#type: #string ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 4 0 219 0 0 1 ) 					#name: #intervalLabel 					#label: #(#{Kernel.UserMessage} #key: #Interval #defaultString: 'Interval:' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} -129 1 196 0 ) 					#name: #CheckBox1 					#model: #isWrapAround 					#label: #(#{Kernel.UserMessage} #key: #WrapAround #defaultString: 'Wrap Around' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">detailsEditSpec	"UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 240 233 ) 			#max: #(#{Core.Point} 262 273 ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1062 873 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 35 0 -10 1 57 0 ) 					#name: #MenuButton1 					#model: #style 					#menu: #fontMenu ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 65 0 -10 1 87 0 ) 					#name: #MenuButton2 					#model: #alignment 					#menu: #alignmentMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 95 0 -10 1 118 0 ) 					#name: #InputField1 					#model: #numChars 					#menu: #fieldMenu 					#type: #string ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 126 ) 					#name: #CheckBox1 					#model: #hasBorder 					#label: #(#{Kernel.UserMessage} #key: #Bordered #defaultString: 'Bordered' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 148 ) 					#name: #CheckBox2 					#model: #isOpaque 					#label: #(#{Kernel.UserMessage} #key: #Opaque #defaultString: 'Opaque' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 170 ) 					#name: #CheckBox3 					#model: #tabable 					#label: #(#{Kernel.UserMessage} #key: #CanTab #defaultString: 'Can Tab' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 192 ) 					#name: #CheckBox4 					#model: #isReadOnly 					#label: #(#{Kernel.UserMessage} #key: #ReadOnly #defaultString: 'Read Only' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 214 ) 					#name: #CheckBox5 					#model: #initiallyDisabled 					#label: #(#{Kernel.UserMessage} #key: #InitiallyDisabled #defaultString: 'Initially Disabled' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 236 ) 					#name: #CheckBox6 					#model: #initiallyInvisible 					#label: #(#{Kernel.UserMessage} #key: #InitiallyInvisible #defaultString: 'Initially Invisible' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 88 0 0 1 ) 					#name: #Label1 					#label: #(#{Kernel.UserMessage} #key: #AlignC #defaultString: 'Align:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 58 0 0 1 ) 					#name: #Label2 					#label: #(#{Kernel.UserMessage} #key: #FontC #defaultString: 'Font:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 119 0 0 1 ) 					#name: #Label3 					#label: #(#{Kernel.UserMessage} #key: #SizeC #defaultString: 'Size:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#name: #Label4 					#label: #componentName ) ) ) )</body></methods><methods><class-id>UI.SpinButtonSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@*******)@@B???????4@@K???????P@@/??????=@@B???????4@@K???????P@@/??????=@@B???????4@@K0@@@@@OP@@/J****(=@@B&lt;" HB"#4@@K2JH*HBOP@@/H(B"*(=@@B&lt;""H*@#4@@K2J@"*JOP@@/J****(=@@B&lt;@@@@@C4@@K???????P@@/??????=@@B???????4@@K???????P@@/??????=@@B???????4@@EUUUUUUUP@@@@@@@@@@@@@@a'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 131 255 248 192 130 0 72 192 130 184 232 192 130 168 8 192 130 184 232 192 130 0 72 192 131 255 248 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192])</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - uipainter</category><body package="UIPainter">uipainterAlignBottomCommand	&lt;command: #uipainterAlignBottom&gt;	^Command		label: (#UIPainterAlignBottom &lt;&lt; #menus &gt;&gt; 'UIPainter: align bottom')		group: #uipainter		bindings: #(			#isMacOSX #(command Down)			#isMSWindows #(ctrl Down)			#isX11 #(ctrl Down)		)</body><body package="UIPainter">uipainterAlignCommand	&lt;command: #uipainterAlign&gt;	^Command		label: (#UIPainterAlign &lt;&lt; #menus &gt;&gt; 'UIPainter: align dialog')		group: #uipainter		bindings: #(			#isMacOSX #(command option A)			#isMSWindows #(ctrl shift A)			#isX11 #(ctrl alt A)		)</body><body package="UIPainter">uipainterAlignLeftCommand	&lt;command: #uipainterAlignLeft&gt;	^Command		label: (#UIPainterAlignLeft &lt;&lt; #menus &gt;&gt; 'UIPainter: align left')		group: #uipainter		bindings: #(			#isMacOSX #(command Left)			#isMSWindows #(ctrl Left)			#isX11 #(ctrl Left)		)</body><body package="UIPainter">uipainterAlignRightCommand	&lt;command: #uipainterAlignRight&gt;	^Command		label: (#UIPainterAlignRight &lt;&lt; #menus &gt;&gt; 'UIPainter: align right')		group: #uipainter		bindings: #(			#isMacOSX #(command Right)			#isMSWindows #(ctrl Right)			#isX11 #(ctrl Right)		)</body><body package="UIPainter">uipainterAlignTopCommand	&lt;command: #uipainterAlignTop&gt;	^Command		label: (#UIPainterAlignTop &lt;&lt; #menus &gt;&gt; 'UIPainter: align top')		group: #uipainter		bindings: #(			#isMacOSX #(command Up)			#isMSWindows #(ctrl Up)			#isX11 #(ctrl Up)		)</body><body package="UIPainter">uipainterBeFixedCommand	&lt;command: #uipainterBeFixed&gt;	^Command		label: (#UIPainterBeFixed &lt;&lt; #menus &gt;&gt; 'UIPainter: be fixed')		group: #uipainter		bindings: #(			#isMacOSX #(command option F)			#isX11 #(ctrl alt F)		)</body><body package="UIPainter">uipainterBeRelativeCommand	&lt;command: #uipainterBeRelative&gt;	^Command		label: (#UIPainterBeRelative &lt;&lt; #menus &gt;&gt; 'UIPainter: be relative')		group: #uipainter		bindings: #(			#isMacOSX #(command option R)			#isX11 #(ctrl alt R)		)</body><body package="UIPainter">uipainterCirculateBackwardsCommand	&lt;command: #uipainterCirculateBackwards&gt;	^Command		label: (#UIPainterCirculateBackwards &lt;&lt; #menus &gt;&gt; 'UIPainter: circulate backwards')		group: #uipainter		bindings: #(			#isMacOSX #(command B)			#isMSWindows #(ctrl B)			#isX11 #(ctrl B)		)</body><body package="UIPainter">uipainterCirculateFrontwardsCommand	&lt;command: #uipainterCirculateFrontwards&gt;	^Command		label: (#UIPainterCirculateFrontwards &lt;&lt; #menus &gt;&gt; 'UIPainter: circulate frontwards')		group: #uipainter		bindings: #(			#isMacOSX #(command F)			#isMSWindows #(ctrl F)			#isX11 #(ctrl F)		)</body><body package="UIPainter">uipainterCirculateToBackCommand	&lt;command: #uipainterCirculateToBack&gt;	^Command		label: (#UIPainterCirculateToBack &lt;&lt; #menus &gt;&gt; 'UIPainter: circulate to back')		group: #uipainter		bindings: #(			#isMacOSX #(command shift B)			#isMSWindows #(ctrl shift B)			#isX11 #(ctrl shift B)		)</body><body package="UIPainter">uipainterCirculateToFrontCommand	&lt;command: #uipainterCirculateToFront&gt;	^Command		label: (#UIPainterCirculateToFront &lt;&lt; #menus &gt;&gt; 'UIPainter: circulate to front')		group: #uipainter		bindings: #(			#isMacOSX #(command shift F)			#isMSWindows #(ctrl shift F)			#isX11 #(ctrl shift F)		)</body><body package="UIPainter">uipainterDialogCommand	&lt;command: #uipainterDialog&gt;	^Command		label: (#UIPainterDialog &lt;&lt; #menus &gt;&gt; 'UIPainter: dialog')		group: #uipainter		bindings: #(			#isMacOSX #(command option P)			#isMSWindows #(ctrl shift P)			#isX11 #(ctrl alt P)		)</body><body package="UIPainter">uipainterDistributeCommand	&lt;command: #uipainterDistribute&gt;	^Command		label: (#UIPainterDistribute &lt;&lt; #menus &gt;&gt; 'UIPainter: distribute dialog')		group: #uipainter		bindings: #(			#isMacOSX #(command option D)			#isMSWindows #(ctrl shift D)			#isX11 #(ctrl alt D)		)</body><body package="UIPainter">uipainterEqualizeCommand	&lt;command: #uipainterEqualize&gt;	^Command		label: (#UIPainterEqualize &lt;&lt; #menus &gt;&gt; 'UIPainter: equalize dialog')		group: #uipainter		bindings: #(			#isMacOSX #(command option E)			#isMSWindows #(ctrl shift E)			#isX11 #(ctrl alt E)		)</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>groups</category><body package="UIPainter">uipainterGroup	&lt;group: #uipainter&gt;	^CommandGroup		label: #GroupUIPainter &lt;&lt; #menus &gt;&gt; 'uipainter'</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - uipainter</category><body package="UIPainter">uipainterGroupCommand	&lt;command: #uipainterGroup&gt;	^Command		label: (#UIPainterGroup &lt;&lt; #menus &gt;&gt; 'UIPainter: group')		group: #uipainter		bindings: #(			#isMacOSX #(command option G)			#isMSWindows #(ctrl G)			#isX11 #(ctrl alt G)		)</body><body package="UIPainter">uipainterInstallCommand	&lt;command: #uipainterInstall&gt;	^Command		label: (#UIPainterInstall &lt;&lt; #menus &gt;&gt; 'UIPainter: install')		group: #uipainter		bindings: #(			#isMacOSX #(command option I)			#isMSWindows #(ctrl shift I)			#isX11 #(ctrl alt I)		)</body><body package="UIPainter">uipainterLayoutCommand	&lt;command: #uipainterLayout&gt;	^Command		label: (#UIPainterLayout &lt;&lt; #menus &gt;&gt; 'UIPainter: layout')		group: #uipainter		bindings: #(			#isMacOSX #(command option L)			#isMSWindows #(ctrl shift L)			#isX11 #(ctrl alt L)		)</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - launcher</category><body package="UIPainter">uipainterOpenCodingAssistantCommand	&lt;command: #uipainterOpenCodingAssistant&gt;	^Command		label: (#_CodingAssistant &lt;&lt; #UIPainter &gt;&gt; 'CodingAssistant')		group: #uip_launcher		bindings: #()</body><body package="UIPainter">uipainterOpenHotRegionsEditorCommand	&lt;command: #uipainterOpenHotRegionsEditor&gt;	^Command		label: (#_HotRegionsEditor &lt;&lt; #UIPainter &gt;&gt; '&amp;Hot Regions Editor')		group: #uip_launcher		bindings: #()</body><body package="UIPainter">uipainterOpenImageEditorCommand	&lt;command: #uipainterOpenImageEditor&gt;	^Command		label: (#_ImageEditor &lt;&lt; #UIPainter &gt;&gt; '&amp;Image Editor')		group: #uip_launcher		bindings: #()</body><body package="UIPainter">uipainterOpenMenuEditorCommand	&lt;command: #uipainterOpenMenuEditor&gt;	^Command		label: (#_MenuEditor &lt;&lt; #UIPainter &gt;&gt; '&amp;Menu Editor')		group: #uip_launcher		bindings: #()</body><body package="UIPainter">uipainterOpenNewCanvasCommand	&lt;command: #uipainterOpenNewCanvas&gt;	^Command		label: (#_NewCanvas &lt;&lt; #UIPainter &gt;&gt; '&amp;New Canvas')		group: #uip_launcher		bindings: #()</body><body package="UIPainter">uipainterOpenResourceFinderCommand	&lt;command: #uipainterOpenResourceFinder&gt;	^Command		label: (#_ResourceFinder &lt;&lt; #UIPainter &gt;&gt; '&amp;Resource Finder')		group: #uip_launcher		bindings: #()</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - uipainter</category><body package="UIPainter">uipainterSnapSelectionToGridCommand	&lt;command: #uipainterSnapSelectionToGrid&gt;	^Command		label: (#UIPainterSnapSelectionToGrid &lt;&lt; #menus &gt;&gt; 'UIPainter: snap selection to grid')		group: #uip_launcher		bindings: #(			#isMacOSX #(command option S)			#isX11 #(ctrl alt S)		)</body><body package="UIPainter">uipainterUngroupCommand	&lt;command: #uipainterUngroup&gt;	^Command		label: (#UIPainterUngroup &lt;&lt; #menus &gt;&gt; 'UIPainter: ungroup')		group: #uipainter		bindings: #(			#isMacOSX #(command option shift G)			#isMSWindows #(ctrl shift G)			#isX11 #(ctrl alt shift G)		)</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>groups</category><body package="UIPainter">uipLauncherGroup	&lt;group: #uip_launcher&gt;	^CommandGroup		label: #GroupUIPainter &lt;&lt; #menus &gt;&gt; 'uipainter'		path: #(#launcher)</body></methods><methods><class-id>UI.ArbitraryComponentSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 294 201 ) 			#max: #(#{Core.Point} 294 201 ) 			#bounds: #(#{Graphics.Rectangle} 653 500 947 701 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} 86 0 30 0 -10 1 55 0 ) 					#name: #componentField 					#model: #component 					#menu: #fieldMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 63 0 -10 1 88 0 ) 					#model: #name 					#menu: #fieldMenu ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #ViewHolder #defaultString: 'View Holder' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 89 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 56 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #View #defaultString: 'View:' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">detailsEditSpec	"UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 294 201 ) 			#max: #(#{Core.Point} 294 201 ) 			#bounds: #(#{Graphics.Rectangle} 653 500 947 701 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 12 0 28 0 -11 1 77 0 ) 					#label: #(#{Kernel.UserMessage} #key: #ScrollBars #defaultString: 'Scroll Bars' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 21 47 ) 					#model: #hasHorizontalScrollBar 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Horizontal #defaultString: 'Horizontal' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 136 47 ) 					#model: #hasVerticalScrollBar 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Vertical #defaultString: 'Vertical' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 81 ) 					#model: #hasBorder 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Bordered #defaultString: 'Bordered' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 102 ) 					#model: #initiallyDisabled 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyDisabled #defaultString: 'Initially Disabled' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 123 ) 					#model: #initiallyInvisible 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyInvisible #defaultString: 'Initially Invisible' #catalogID: #UIPainter) ) ) ) )</body></methods><methods><class-id>UI.ArbitraryComponentSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 6) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); at: 3 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 4 put: ColorValue white; at: 5 put: ColorValue blue; at: 6 put: (ColorValue scaledRed: 8191 scaledGreen: 3276 scaledBlue: 1638); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@L3L3L3L3L3L3L3L2@@@@@CDQDQDQDQDQDQDQD @@@@@1DQDQDQDQDQDQDQH@@@@@LQ@@@@@@@@@@@@DR@@@@@CDPQDQDQDQDQDPAD @@@@@1D@@@@@@@@@@@@QH@@@@@LQ@3L3L3L3L3L0DR@@@@@CDPL@@0@@@0@3LAD @@@@@1DCL3L3L3L3L3@QH@@@@@LQ@0@3L3L3L3L0DR@@@@@CDPL3L3L3L3L3LAD @@@@@1DCL3@@@CL3L3@QH@@@@@LQ@3L@LCLCL3L0DR@@@@@CDPL0@C@3@@L3LAD @@@@@1DC@@@@@@UP@3@QH@@@@@LQ@0UPTETEUP@0DR@@@@@CDPL@@@@@@@@@LAD @@@@@1DCL@@3L3@@L3@QH@@@@@LQ@3LCL3L3@3L0DR@@@@@CDPL3L3L3L3L3LAD @@@@@1D@@@@@@@@@@@@QH@@@@@LQDQDQDQDQDQDQDR@@@@@CDQDQDQDQDQDQDQD @@@@@"H"H"H"H"H"H"H"H@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 143 255 252 192 136 0 4 192 143 255 252 192 136 0 4 192 139 190 196 192 136 0 4 192 139 0 4 192 136 0 4 192 136 124 4 192 136 210 4 192 137 211 132 192 139 254 100 192 138 82 52 192 139 255 244 192 137 193 196 192 136 128 132 192 136 0 4 192 143 255 252 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192 ])</body></methods><methods><class-id>UI.MappedClickWidgetSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 292 206 ) 			#max: #(#{Core.Point} 393 383 ) 			#bounds: #(#{Graphics.Rectangle} 328 268 620 651 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.503472 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #ClickWidget #defaultString: 'Click Widget' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 4 0 60 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 53 0 36 0 -10 1 61 0 ) 					#model: #name 					#menu: #fieldMenu 					#type: #string ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 172 0 96 0 -10 1 121 0 ) 					#model: #visualSelector 					#type: #symbol ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 172 0 186 0 -10 1 211 0 ) 					#model: #defaultClickSelector 					#type: #symbol ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 172 0 217 0 -10 1 242 0 ) 					#model: #mappingsSelector 					#type: #symbol ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 4 96 ) 					#label: #(#{Kernel.UserMessage} #key: #Visual #defaultString: 'Visual:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 4 186 ) 					#label: #(#{Kernel.UserMessage} #key: #DefaultClick #defaultString: 'Default Click:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 4 215 ) 					#label: #(#{Kernel.UserMessage} #key: #MappingsSelector #defaultString: 'Mappings Selector:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 4 127 ) 					#label: #(#{Kernel.UserMessage} #key: #Performer #defaultString: 'Performer:' #catalogID: #UIPainter) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 172 0 127 0 -10 1 152 0 ) 					#model: #performerSelector 					#type: #symbol ) ) ) )</body><body package="UIPainter">detailsEditSpec	"UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 294 201 ) 			#max: #(#Point 294 201 ) 			#bounds: #(#Rectangle 321 411 615 612 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 35 ) 					#model: #hasBorder 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Bordered #defaultString: 'Bordered' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 56 ) 					#model: #initiallyDisabled 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyDisabled #defaultString: 'Initially Disabled' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 77 ) 					#model: #initiallyInvisible 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyInvisible #defaultString: 'Initially Invisible' #catalogID: #UIPainter) ) ) ) )</body></methods><methods><class-id>UI.MappedClickWidgetSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon" 	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 6) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); at: 3 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 4 put: ColorValue white; at: 5 put: ColorValue cyan; at: 6 put: ColorValue yellow; yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@L3L3L3L3L3L3L3L2@@@@@CDQDQDQDQDQDQDQD @@@@@1DQDQDQDQDQDQDQH@@@@@LQDQEDQ@DQDQDQDR@@@@@CDQDQQDPADQDQDQD @@@@@1DQDTQD@QDQDQDQH@@@@@LQDQEDQ@DQDQDQDR@@@@@CDQDQQDQDQDQDDQD @@@@@1DQDTQDQDQDQD@QH@@@@@LQDQEDQDQEQDQ@DR@@@@@CDQDQQDQDQTQDPAD @@@@@1EDQDQDUUUUUD@QH@@@@@LQQDQDQDQUUDQD@R@@@@@CDQQDQDQDAEQDPAD @@@@@1DQQDQDP@QEQD@QH@@@@@LQDQPAE@@DQD@ADR@@@@@CDQDQ@Q@@ADPADQD @@@@@1DQDQDQ@@Q@DQDQH@@@@@LQDQDQDPQD@QDQDR@@@@@CDQDQDQ@QQ@DQDQD @@@@@1DQDQDPDQPADQDQH@@@@@LQDQDQDQDQDQDQDR@@@@@CDQDQDQDQDQDQDQD @@@@@"H"H"H"H"H"H"H"H@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt; 	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[0 0 0 0 127 255 255 128 127 255 255 128 127 255 255 128 127 7 255 128 127 7 255 128 127 7 255 128 127 7 255 128 127 0 15 128 127 0 3 128 127 1 3 128 127 1 3 128 112 15 227 128 112 3 129 128 120 2 131 128 124 4 67 128 126 96 7 128 127 96 31 128 127 240 63 128 127 240 127 128 127 252 127 128 127 254 127 128 127 255 255 128 127 255 255 128 127 255 255 128 0 0 0 0])</body></methods><methods><class-id>UI.WidgetSpec class</class-id> <category>interface specs</category><body package="UIPainter">helpConstructorSpecLiteral	"UIPainter new openOnClass: self andSelector: #helpConstructorSpecLiteral"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 288 292 ) 			#max: #(#{Core.Point} 288 292 ) 			#bounds: #(#{Graphics.Rectangle} 368 238 656 530 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 28 0 -10 1 59 0 ) 					#flags: 0 					#minorKey: #helpConstructorSpec 					#clientKey: #helpConstructor ) ) ) )</body></methods><methods><class-id>UI.LabelSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpecLiteral	"UIPainter new openOnClass: self andSelector: #basicsEditSpecLiteral"		&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 301 127 ) 			#max: #(#Point 301 143 ) 			#bounds: #(#Rectangle 190 342 491 485 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Label #defaultString: 'Label' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 87 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 10 0 28 0 -10 1 59 0 ) 					#flags: 0 					#minorKey: #labelConstructorSpec 					#clientKey: #labelConstructor ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 86 0 60 0 -10 1 85 0 ) 					#model: #name 					#menu: #fieldMenu ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 92 ) 					#model: #hasImageOrientedLabel 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #LabelIsImage #defaultString: 'Label Is Image' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">detailsEditSpec	"UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 294 106 ) 			#max: #(#{Core.Point} 299 195 ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1094 795 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 58 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #FontC #defaultString: 'Font:' #catalogID: #UIPainter) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 34 0 -10 1 57 0 ) 					#model: #style 					#menu: #fontMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 72 0 -10 1 95 0 ) 					#name: #mnemonic 					#model: #mnemonic 					#type: #symbol ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 109 ) 					#model: #initiallyDisabled 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyDisabled #defaultString: 'Initially Disabled' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 132 ) 					#model: #initiallyInvisible 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyInvisible #defaultString: 'Initially Invisible' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 71 ) 					#name: #mnemonicLabel 					#label: #(#{Kernel.UserMessage} #key: #Mnemonic #defaultString: 'Mnemonic:' #catalogID: #UIPainter) ) ) ) )</body></methods><methods><class-id>UI.LabelSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@*******)@@B???????4@@K???????P@@/??????=@@B???????4@@K???????P@@/??&lt;???=@@B???@???4@@K??&lt;C???P@@/??@C??=@@B??&lt;&lt;O??4@@K??C0O??P@@/?&lt;?0??=@@B??C?@??4@@K?&lt;@@C??P@@/?C?&lt;C?=@@B?&lt;O?&lt;O?4@@K?C??0O?P@@/0C?&lt;@O=@@B???????4@@K???????P@@/??????=@@B???????4@@EUUUUUUUP@@@@@@@@@@@@@@a'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 8 0 192 128 28 0 192 128 28 0 192 128 62 0 192 128 38 0 192 128 103 0 192 128 67 0 192 128 195 128 192 128 255 128 192 129 129 192 192 129 128 192 192 131 0 224 192 135 129 240 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192 ])</body></methods><methods><class-id>UI.InputEditorSpec class</class-id> <category>interface specs</category><body package="UIPainter">detailsEditSpec	"Tools.UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 236 293 ) 			#max: #(#{Core.Point} 240 293 ) 			#bounds: #(#{Graphics.Rectangle} 850 529 1090 822 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20 0 72 0 ) 					#model: #hasBorder 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #Bordered 						#defaultString: 'Bordered' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20 0 93 0 ) 					#model: #isOpaque 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #Opaque 						#defaultString: 'Opaque' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20 0 114 0 ) 					#model: #tabable 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #CanTab 						#defaultString: 'Can Tab' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20 0 135 0 ) 					#name: #CheckBox6 					#model: #autoAccept 					#label: 'Auto Accept' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20 0 156 0 ) 					#model: #initiallyDisabled 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #InitiallyDisabled 						#defaultString: 'Initially Disabled' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20 0 177 0 ) 					#model: #initiallyInvisible 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #InitiallyInvisible 						#defaultString: 'Initially Invisible' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.5 72 0 ) 					#name: #CheckBox1 					#model: #isReadOnly 					#label: 'Read Only' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.5 120 0 -20 1 141 0 ) 					#name: #InputField1 					#model: #defaultString ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.5 100 0 ) 					#name: #Label1 					#label: 'Default String:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.5 150 0 ) 					#name: #Label2 					#label: 'Maximum Characters:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.5 170 0 -20 1 191 0 ) 					#name: #InputField2 					#model: #numChars 					#type: #number ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 32 0 -20 1 53 0 ) 					#model: #alignment 					#menu: #alignmentMenu ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20 0 36 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #AlignC 						#defaultString: 'Align:' 						#catalogID: #UIPainter ) ) ) ) )</body></methods><methods><class-id>UI.InputEditorSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3790 3790 3790)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6520 6520 6520)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 2537 4882)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@H"H"H"H"H"H"H"H!@@@@@BL3L3L3L3L3L3L3LP@@@@@#L3L3L3L3L3L3L3D@@@@@H3L3L3L3L3L3L3L1@@@@@BL3L3L3L3L3L3L3LP@@@@@#L3L3L3L3L3L3L3D@@@@@H3L3L3L3L3L3L3L1@@@@@BMDQDQDQDQDQDQDLP@@@@@#P"H"H"H"H"H"ICD@@@@@H4H"H"H"H HBH"P1@@@@@BMBIDH"QBH H"H$LP@@@@@#P"H$H"IBHBH"ICD@@@@@H4H$QBIDP"@"H"P1@@@@@BMBP"P$H$H H"H$LP@@@@@#P$H$IBIBHBH"ICD@@@@@H4H$QBIDP"@"H"P1@@@@@BMBH"H"H"HB@"H$LP@@@@@#P"H"H"H"H"H"ICD@@@@@H4QDQDQDQDQDQDP1@@@@@BL3L3L3L3L3L3L3LP@@@@@#L3L3L3L3L3L3L3D@@@@@H3L3L3L3L3L3L3L1@@@@@BL3L3L3L3L3L3L3LP@@@@@QDQDQDQDQDQDQDQD@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body></methods><methods><class-id>UI.DividerSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 300 171 ) 			#max: #(#{Core.Point} 300 171 ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1100 771 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 60 0 28 0 -10 1 53 0 ) 					#model: #name 					#menu: #fieldMenu ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 25 0 109 0 0 1 ) 					#model: #orientation 					#label: #(#{Kernel.UserMessage} #key: #Vertical #defaultString: 'Vertical' #catalogID: #UIPainter) 					#select: #vertical ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 124 0 109 0 0 1 ) 					#model: #orientation 					#label: #(#{Kernel.UserMessage} #key: #Horizontal #defaultString: 'Horizontal' #catalogID: #UIPainter) 					#select: #horizontal ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 63 0 -10 1 116 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Orientation #defaultString: 'Orientation' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Divider #defaultString: 'Divider' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 53 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 121 ) 					#name: #CheckBox1					#model: #initiallyDisabled 					#label: #(#{Kernel.UserMessage} #key: #InitiallyDisabled #defaultString: 'Initially Disabled' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 142 ) 					#name: #CheckBox2					#model: #initiallyInvisible 					#label: #(#{Kernel.UserMessage} #key: #InitiallyInvisible #defaultString: 'Initially Invisible' #catalogID: #UIPainter) ) ) ) )</body></methods><methods><class-id>UI.DividerSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@*******)@@B???????4@@K???????P@@/??????=@@B???3???4@@K???O???P@@/??&lt;???=@@B???3???4@@K???O???P@@/??&lt;???=@@B???3???4@@K???O???P@@/??&lt;???=@@B???3???4@@K???O???P@@/??&lt;???=@@B???3???4@@K???O???P@@/??????=@@B???????4@@K&lt;@@@@@?P@@/??????=@@B???????4@@EUUUUUUUP@@@@@@@@@@@@@@a'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 8 0 192 128 8 0 192 128 8 0 192 128 8 0 192 128 8 0 192 128 8 0 192 128 8 0 192 128 8 0 192 128 8 0 192 128 8 0 192 128 8 0 192 128 8 0 192 128 8 0 192 128 8 0 192 128 0 0 192 128 0 0 192 135 255 248 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192 ])</body></methods><methods><class-id>UI.UISettings class</class-id> <category>resources</category><body package="UIPainter">gridDisplayMenu	"UIMenuEditor new openOnClass: self andSelector: #gridDisplayMenu"	&lt;resource: #menu&gt;	^#(#Menu #(#(#MenuItem #rawLabel: #(#{Kernel.UserMessage} #key: #Hide #defaultString: 'Hide' #catalogID: #UIPainter) ) #(#MenuItem #rawLabel: #(#{Kernel.UserMessage} #key: #Show #defaultString: 'Show' #catalogID: #UIPainter) ) #(#MenuItem #rawLabel: #(#{Kernel.UserMessage} #key: #ShowIfOn #defaultString: 'Show If On' #catalogID: #UIPainter) ) ) #(3 ) #(#Hide #Show #'Show If On' ) ) decodeAsLiteralArray</body><body package="UIPainter">gridModeMenu	"UIMenuEditor new openOnClass: self andSelector: #gridModeMenu"	&lt;resource: #menu&gt;	^#(#Menu #(#(#MenuItem #rawLabel: #(#{Kernel.UserMessage} #key: #Off #defaultString: 'Off' #catalogID: #UIPainter) ) #(#MenuItem #rawLabel: #(#{Kernel.UserMessage} #key: #On #defaultString: 'On' #catalogID: #UIPainter) ) #(#MenuItem #rawLabel: #(#{Kernel.UserMessage} #key: #XOnly #defaultString: 'X Only' #catalogID: #UIPainter) ) #(#MenuItem #rawLabel: #(#{Kernel.UserMessage} #key: #YOnly #defaultString: 'Y Only' #catalogID: #UIPainter) ) ) #(4 ) #(#Off #On #'X Only' #'Y Only' ) ) decodeAsLiteralArray</body></methods><methods><class-id>UI.UISettings class</class-id> <category>interface specs</category><body package="UIPainter">guiPainterSpec	"UIPainter new openOnClass: self andSelector: #guiPainterSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#min: #(#{Core.Point} 50 50 ) 			#bounds: #(#{Graphics.Rectangle} 800 328 1065 600 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 4 0 -10 1 54 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Canvases #defaultString: ' Canvases ' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 192 21 ) 					#label: #(#{Kernel.UserMessage} #key: #x #defaultString: 'x' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 22 21 ) 					#label: #(#{Kernel.UserMessage} #key: #MaximumSize #defaultString: 'Maximum Size:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 23 111 ) 					#label: #(#{Kernel.UserMessage} #key: #SizeC #defaultString: 'Size:' #catalogID: #UIPainter) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 119 81 245 106 ) 					#name: #initialGridMode 					#model: #initialGridDisplayEditing 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#menu: #gridDisplayMenu ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0 56 0 -9 1 143 0 ) 					#label: #(#{Kernel.UserMessage} #key: #InitialGridSettings #defaultString: 'Initial Grid Settings' #catalogID: #UIPainter) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 25 81 107 106 ) 					#name: #initialGridMode 					#model: #initialGridModeEditing 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#menu: #gridModeMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 149 21 187 46 ) 					#model: #maximumCanvasWidthEditing 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#menu: #fieldMenu 					#alignment: #center 					#numChars: 4 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 211 21 249 46 ) 					#model: #maximumCanvasHeightEditing 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#menu: #fieldMenu 					#alignment: #center 					#numChars: 4 					#type: #number ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 67 111 107 136 ) 					#name: #InitialGridSize 					#model: #initialGridSizeEditing 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#menu: #fieldMenu 					#alignment: #center 					#numChars: 3 					#type: #number ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Core.Point} 10 240 ) 					#name: #acceptButton 					#flags: 40 					#model: #canvasAccept 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{Kernel.UserMessage} #key: #Accept #defaultString: 'Accept' #catalogID: #UIPainter) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Core.Point} 101 240 ) 					#name: #resetButton 					#flags: 40 					#model: #canvasReset 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #undisturb ) 					#label: #(#{Kernel.UserMessage} #key: #Reset #defaultString: 'Reset' #catalogID: #UIPainter) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Core.Point} 185 240 ) 					#model: #helpAction 					#label: #(#{Kernel.UserMessage} #key: #Help #defaultString: 'Help' #catalogID: #UIPainter) 					#defaultable: true ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 144 0 -9 1 220 0 ) 					#name: #GroupBox1					#label: #(#{Kernel.UserMessage} #key: #PalettePlacementFeel #defaultString: 'Palette Placement Feel' #catalogID: #UIPainter) ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 26 167 ) 					#name: #RadioButton1					#model: #placementFeelEditing 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #DragWithButtonUp #defaultString: 'Drag with Button Up' #catalogID: #UIPainter) 					#select: #DragPlacementModeTracker ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 25 190 ) 					#name: #RadioButton1					#model: #placementFeelEditing 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #DragWithButtonDown #defaultString: 'Drag with Button Down' #catalogID: #UIPainter) 					#select: #SelectPlacementModeTracker ) ) ) )</body><body package="UIPainter">verboseLevelSpec	"UIPainter new openOnClass: self andSelector: #verboseLevelSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#min: #(#Point 50 50 ) 			#bounds: #(#Rectangle 332 597 589 857 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #CanvasInstallation #defaultString: 'Canvas Installation' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 19 46 ) 					#model: #avoidInstallationDialogEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec						#valueChangeSelector: 						#disturb ) 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #AvoidInstallationDialog #defaultString: 'Avoid Installation Dialog' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 19 70 ) 					#model: #installForDefineEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec						#valueChangeSelector: 						#disturb ) 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InstallForDefine #defaultString: 'Install for Define' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 19 94 ) 					#model: #installForOpenEditing 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: 						#disturb ) 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InstallForOpen #defaultString: 'Install for Open' #catalogID: #UIPainter) ) 				#(#ActionButtonSpec 					#layout: #(#Point 10 240 ) 					#name: #acceptButton 					#flags: 40 					#model: #verboseLevelAccept 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #undisturb ) 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Accept #defaultString: 'Accept' #catalogID: #UIPainter) 					#isDefault: true 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Point 101 240 ) 					#name: #resetButton 					#flags: 40 					#model: #verboseLevelReset 					#callbacksSpec: 					#(#UIEventCallbackSubSpec 						#valueChangeSelector: #undisturb ) 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Reset #defaultString: 'Reset' #catalogID: #UIPainter) 					#defaultable: true ) 				#(#ActionButtonSpec 					#layout: #(#Point 185 240 ) 					#model: #helpAction 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Help #defaultString: 'Help' #catalogID: #UIPainter) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>UI.MenuButtonSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpecLiteral	"UIPainter new openOnClass: self andSelector: #basicsEditSpecLiteral"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 300 296 ) 			#max: #(#Point 300 296 ) 			#bounds: #(#Rectangle 188 307 488 603 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #MenuButton #defaultString: 'Menu Button' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 147 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 85 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #AspectC #defaultString: 'Aspect:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 116 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Menu #defaultString: 'Menu:' #catalogID: #UIPainter) ) 				#(#SubCanvasSpec 					#layout: #(#LayoutFrame 10 0 28 0 -10 1 59 0 ) 					#flags: 0 					#minorKey: #labelConstructorSpec 					#clientKey: #labelConstructor ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 86 0 59 0 -10 1 84 0 ) 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: ) 					#name: #modelField 					#model: #model 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#validAspectSelector: ) 					#menu: #fieldMenu ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 86 0 90 0 -10 1 115 0 ) 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: ) 					#name: #menuField 					#model: #menu 					#menu: #fieldMenu ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 86 0 121 0 -10 1 146 0 ) 					#model: #name 					#menu: #fieldMenu ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 155 ) 					#model: #hasImageOrientedLabel 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #LabelIsImage #defaultString: 'Label Is Image' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">detailsEditSpec	"UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 300 296 ) 			#max: #(#Point 300 296 ) 			#bounds: #(#Rectangle 110 363 410 659 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 54 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #FontC #defaultString: 'Font:' #catalogID: #UIPainter) ) 				#(#MenuButtonSpec 					#layout: #(#LayoutFrame 86 0 31 0 -10 1 53 0 ) 					#model: #style 					#menu: #fontMenu ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 66 ) 					#model: #isDecorated 					#label: #(#{Kernel.UserMessage} #key: #Bordered #defaultString: 'Bordered' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 87 ) 					#model: #isOpaque 					#label: #(#{Kernel.UserMessage} #key: #Opaque #defaultString: 'Opaque' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 129 ) 					#model: #isPopUp 					#label: #(#{Kernel.UserMessage} #key: #PopUpStyle #defaultString: 'PopUp Style' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 150 ) 					#model: #initiallyDisabled 					#label: #(#{Kernel.UserMessage} #key: #InitiallyDisabled #defaultString: 'Initially Disabled' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 171 ) 					#model: #initiallyInvisible 					#label: #(#{Kernel.UserMessage} #key: #InitiallyInvisible #defaultString: 'Initially Invisible' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 108 ) 					#model: #tabable 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #CanTab #defaultString: 'Can Tab' #catalogID: #UIPainter) ) ) ) )</body></methods><methods><class-id>UI.MenuButtonSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 6) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); at: 3 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 7099); at: 6 put: ColorValue yellow; yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@L3L3L3L3L3L3L3L2@@@@@CDQDQDQDQDQDQDQD @@@@@1DQDQDQDQDQDQDQH@@@@@LQDQDQDQDQDQDQDR@@@@@CDQ@@@@@@@@@@@AD @@@@@1DPUUUUUUUPUU@QH@@@@@LQDE@@@@@@TEUPDR@@@@@CDQAUUUUUUUAUTAD @@@@@1DP@@@@@@@@@@@QH@@@@@LQDCL3L3L3LADQDR@@@@@CDQ@3L3L3L3@QDQD @@@@@1DPL@@@@@@0DQDQH@@@@@LQDCL3L3L3LADQDR@@@@@CDQADQDQDQD@QDQD @@@@@1DPQCL3L3Q@DQDQH@@@@@LQDDQDQDQDPADQDR@@@@@CDQ@3L3L3L3@QDQD @@@@@1DPL@@@@@@0DQDQH@@@@@LQDCL3L3L3LADQDR@@@@@CDQ@@@@@@@@@QDQD @@@@@1DQDQDQDQDQDQDQH@@@@@LQDQDQDQDQDQDQDR@@@@@CDQDQDQDQDQDQDQD @@@@@"H"H"H"H"H"H"H"H@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 135 255 252 192 132 0 68 192 133 255 68 192 132 0 68 192 135 255 252 192 132 0 64 192 132 0 64 192 133 255 64 192 132 0 64 192 135 255 192 192 135 1 192 192 135 255 192 192 132 0 64 192 133 255 64 192 132 0 64 192 135 255 192 192 128 0 0 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192 ])</body></methods><methods><class-id>UI.ProgressWidgetSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 300 243 ) 			#max: #(#Point 300 243 ) 			#bounds: #(#Rectangle 565 290 865 533 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#DividerSpec 					#layout: #(#LayoutFrame 0 0.5 110 0 2 0.5 254 0 ) 					#orientation: #vertical ) 				#(#DividerSpec 					#layout: #(#LayoutFrame -33 1 110 0 -31 1 254 0 ) 					#orientation: #vertical ) 				#(#DividerSpec 					#layout: #(#LayoutFrame 0 0.5 109 0 -33 1 113 0 ) ) 				#(#DividerSpec 					#layout: #(#LayoutFrame 0 0.5 253 0 -33 1 257 0 ) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #ProgressBar #defaultString: 'Progress Bar' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 55 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #AspectC #defaultString: 'Aspect:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 87 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 86 0 28 0 -10 1 53 0 ) 					#model: #model 					#menu: #fieldMenu 					#type: #string ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 86 0 60 0 -10 1 85 0 ) 					#model: #name 					#menu: #fieldMenu ) 				#(#RadioButtonSpec 					#layout: #(#AlignmentOrigin 2 0.5 110 0 0.5 0.5 ) 					#model: #position 					#select: #topLeft ) 				#(#RadioButtonSpec 					#layout: #(#AlignmentOrigin -30 1 110 0 0.5 0.5 ) 					#model: #position 					#select: #topRight ) 				#(#RadioButtonSpec 					#layout: #(#AlignmentOrigin -15 0.75 182 0 0.5 0.5 ) 					#model: #position 					#select: #center ) 				#(#RadioButtonSpec 					#layout: #(#AlignmentOrigin 2 0.5 254 0 0.5 0.5 ) 					#model: #position 					#select: #bottomLeft ) 				#(#RadioButtonSpec 					#layout: #(#AlignmentOrigin -30 1 254 0 0.5 0.5 ) 					#model: #position 					#select: #bottomRight ) 				#(#RadioButtonSpec 					#layout: #(#Point 10 115 ) 					#model: #direction 					#label: #(#{Kernel.UserMessage} #key: #Horizontal #defaultString: 'Horizontal' #catalogID: #UIPainter) 					#select: #horizontal ) 				#(#RadioButtonSpec 					#layout: #(#Point 10 143 ) 					#model: #direction 					#label: #(#{Kernel.UserMessage} #key: #Vertical #defaultString: 'Vertical' #catalogID: #UIPainter) 					#select: #vertical ) 				#(#RadioButtonSpec 					#layout: #(#Point 10 171 ) 					#model: #direction 					#label: #(#{Kernel.UserMessage} #key: #Both #defaultString: 'Both' #catalogID: #UIPainter) 					#select: #both ) 				#(#CheckBoxSpec 					#layout: #(#Point 28 192 ) 					#model: #area 					#label: #(#{Kernel.UserMessage} #key: #Area #defaultString: 'Area' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 216 ) 					#model: #reverse 					#label: #(#{Kernel.UserMessage} #key: #Reverse #defaultString: 'Reverse' #catalogID: #UIPainter) ) ) ) )</body></methods><methods><class-id>UI.ProgressWidgetSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 5) at: 1 put: ColorValue black; at: 2 put: ColorValue blue; at: 3 put: (ColorValue scaledRed: 3699 scaledGreen: 3699 scaledBlue: 3699); at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 6605 scaledGreen: 6605 scaledBlue: 6605); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@L3L3L3L3L3L3L3L2@@@@@CQDQDQDQDQDQDQDP @@@@@4QDQDQDQDQDQDQDH@@@@@MDQDQDQDQDQDQDQB@@@@@CQDQDQDQDQDQDQDP @@@@@4QDQDQDQDQDQDQDH@@@@@MDP@@@@@@@@@@DQB@@@@@CQD@QDQDQDQQDMDP @@@@@4Q@DQDQDQDTQCQDH@@@@@MDPADTQAQDEDP4QB@@@@@CQD@QDQPQEAQDMDP @@@@@4Q@DQEADTDTQCQDH@@@@@MDPADQPQEAEDP4QB@@@@@CQD@QDQDQDQQDMDP @@@@@4Q@DQDQDQDTQCQDH@@@@@MDP3L3L3L3L3L4QB@@@@@CQDQDQDQDQDQDQDP @@@@@4QDQDQDQDQDQDQDH@@@@@MDQDQDQDQDQDQDQB@@@@@CQDQDQDQDQDQDQDP @@@@@4QDQDQDQDQDQDQDH@@@@@MDQDQDQDQDQDQDQB@@@@@CQDQDQDQDQDQDQDP @@@@@"H"H"H"H"H"H"H"H@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 143 255 248 192 143 255 0 192 143 17 0 192 143 221 0 192 143 187 0 192 143 187 0 192 143 255 0 192 143 255 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192])</body></methods><methods><class-id>UI.DocumentViewSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 242 147 ) 			#max: #(#{Core.Point} 300 316 ) 			#bounds: #(#{Graphics.Rectangle} 650 442 950 758 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} 86 0 28 0 -10 1 53 0 ) 					#name: #modelField 					#model: #model 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#validAspectSelector: ) 					#menu: #fieldMenu ) 				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} 86 0 60 0 -10 1 85 0 ) 					#name: #menuField 					#model: #menu 					#menu: #fieldMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 92 0 -10 1 117 0 ) 					#model: #name 					#menu: #fieldMenu ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #TextEditor #defaultString: 'Text Editor' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 94 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 30 ) 					#label: #(#{Kernel.UserMessage} #key: #AspectC #defaultString: 'Aspect:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 62 ) 					#label: #(#{Kernel.UserMessage} #key: #Menu #defaultString: 'Menu:' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">detailsEditSpec	"Tools.UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 236 293 ) 			#max: #(#{Core.Point} 240 293 ) 			#bounds: #(#{Graphics.Rectangle} 840 394 1080 687 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 21 0 -10 1 69 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #ScrollBars 						#defaultString: 'Scroll Bars' 						#catalogID: #UIPainter ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 20 40 ) 					#model: #hasHorizontalScrollBar 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #Horizontal 						#defaultString: 'Horizontal' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.5 40 0 ) 					#model: #hasVerticalScrollBar 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #Vertical 						#defaultString: 'Vertical' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 20 83 ) 					#model: #hasBorder 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #Bordered 						#defaultString: 'Bordered' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 20 104 ) 					#model: #isOpaque 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #Opaque 						#defaultString: 'Opaque' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 20 125 ) 					#model: #tabable 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #CanTab 						#defaultString: 'Can Tab' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 20 146 ) 					#name: #CheckBox6 					#model: #autoAccept 					#label: 'Auto Accept' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 20 167 ) 					#model: #initiallyDisabled 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #InitiallyDisabled 						#defaultString: 'Initially Disabled' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 20 188 ) 					#model: #initiallyInvisible 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #InitiallyInvisible 						#defaultString: 'Initially Invisible' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.5 83 0 ) 					#model: #isWrapped 					#label: 					#(#{Kernel.UserMessage} 						#key: #WordWrap 						#defaultString: 'Word Wrap' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.5 104 0 ) 					#name: #CheckBox1 					#model: #isReadOnly 					#label: 'Read Only' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.5 125 0 ) 					#name: #CheckBox2 					#model: #showSelection 					#label: 'Show Selection' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.5 146 0 ) 					#name: #CheckBox3 					#model: #showInputCursor 					#label: 'Show Input Cursor' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.5 167 0 ) 					#name: #CheckBox4 					#model: #showLineStriping 					#label: 'Show Striped Lines' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.5 188 0 ) 					#name: #CheckBox5 					#model: #showHiddenCharacters 					#label: 'Show Hidden Characters' ) ) ) )</body></methods><methods><class-id>UI.DocumentViewSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3790 3790 3790)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6520 6520 6520)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 2537 4882)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@H"H"H"H"H"H"H"H!@@@@@BL3L3L3L3L3L3L3LP@@@@@#MDQDQDQDQDQDP3D@@@@@H3P"H"H"H"H"H$L1@@@@@BL4H"H"H"H"H"ICLP@@@@@#MBIDH"QBH"H"P3D@@@@@H3P"H$H"IBH"H$L1@@@@@BL4H$QBIDP"H"ICLP@@@@@#MBP"P$H$H"H"P3D@@@@@H3P$H$IBIBH"H$L1@@@@@BL4H$QBIDP"H"ICLP@@@@@#MBH"H"H"@@H"P3D@@@@@H3P"H"H"HBH H$L1@@@@@BL4H$P"H"@"HBICLP@@@@@#MBH"P"H @@@"P3D@@@@@H3P"QDH"@3L3@$L1@@@@@BL4IBIBH L0L0ICLP@@@@@#MBP"P"HCLCLBP3D@@@@@H3P"QDH"@3L3@$L1@@@@@BL4H"H"H @@@@ICLP@@@@@#MBH"H"H"H"H"P3D@@@@@H3QDQDQDQDQDQDL1@@@@@BL3L3L3L3L3L3L3LP@@@@@QDQDQDQDQDQDQDQD@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body></methods><methods><class-id>UI.NamedSpec class</class-id> <category>interface specs</category><body package="UIPainter">dropSourceSpec	"UIPainter new openOnClass: self andSelector: #dropSourceSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#bounds: #(#Rectangle 445 280 681 513 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 29 0 -10 1 127 0 ) 					#label: #(#{Kernel.UserMessage} #key: #DropSource #defaultString: 'Drop Source' #catalogID: #UIPainter) ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragEnterSelector 						#dragEnterSelectorAspect: #dragOverSelector #'dragOverSelectorAspect;' #dragExitSelector 						#dragLeaveSelectorAspect: #dropSelector 						#dropInSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 54 0 -16 1 79 0 ) 					#name: #dragOKField 					#model: #dragOkSelector 					#menu: #fieldMenu 					#type: #string ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragEnterSelector 						#dragEnterSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: #dragExitSelector 						#dragleaveSelectorAspect: #dropSelector 						#dropInSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 82 0 -16 1 107 0 ) 					#name: #dragStartField 					#model: #dragStartSelector 					#menu: #fieldMenu 					#type: #string ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 12 0 107 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #DragStart #defaultString: 'Drag Start:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 12 0 79 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #DragOk #defaultString: 'Drag Ok:' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">dropTargetSpec	"UIPainter new openOnClass: self andSelector: #dropTargetSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#bounds: #(#Rectangle 274 263 510 496 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 29 0 -8 1 185 0 ) 					#label: #(#{Kernel.UserMessage} #key: #DropTarget #defaultString: 'Drop Target' #catalogID: #UIPainter) ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragEnterSelector 						#dragEnterSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: #dropSelector 						#dropInSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 54 0 -16 1 79 0 ) 					#name: #dragEnterField 					#model: #dragEnterSelector 					#menu: #fieldMenu 					#type: #string ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragEnterSelector 						#dragEnterSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: #dropSelector 						#dropInSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 82 0 -16 1 107 0 ) 					#name: #dragOverField 					#model: #dragOverSelector 					#menu: #fieldMenu 					#type: #string ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragEnterSelector 						#dragEnterSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: #dropSelector 						#dropInSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 110 0 -16 1 135 0 ) 					#name: #dragExitField 					#model: #dragExitSelector 					#menu: #fieldMenu 					#type: #string ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 16 0 107 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Over #defaultString: 'Over:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 16 0 79 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Entry #defaultString: 'Entry:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 16 0 135 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Exit #defaultString: 'Exit:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 16 0 163 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Drop #defaultString: 'Drop:' #catalogID: #UIPainter) ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragEnterSelector 						#dragEnterSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: #dropSelector 						#dropInSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 138 0 -16 1 163 0 ) 					#name: #dropField 					#model: #dropSelector 					#menu: #fieldMenu 					#type: #string ) ) ) )</body></methods><methods><class-id>UI.UISpecification class</class-id> <category>private-menu pragmas</category><body package="UIPainter">menuItemDefault	&lt;itemInMenu: #(#fontMenu) position: 10.2&gt;	^(MenuItem labeled: #Default &lt;&lt; #labels &gt;&gt; 'Default')		value: #default;		yourself</body><body package="UIPainter">menuItemStandardFixed	&lt;itemInMenu: #(#fontMenu #standard) position: 10.4&gt;	^(MenuItem labeled: #fixed &lt;&lt; #labels &gt;&gt; 'Standard fixed')		value: #fixed;		yourself</body><body package="UIPainter">menuItemStandardLarge	&lt;itemInMenu: #(#fontMenu #standard) position: 10.1&gt;	^(MenuItem labeled: #large &lt;&lt; #labels &gt;&gt; 'Standard large')		value: #large;		yourself</body><body package="UIPainter">menuItemStandardMedium	&lt;itemInMenu: #(#fontMenu #standard) position: 10.2&gt;	^(MenuItem labeled: #systemDefault &lt;&lt; #labels &gt;&gt; 'Standard medium (default)')		value: #systemDefault;		yourself</body><body package="UIPainter">menuItemStandardSmall	&lt;itemInMenu: #(#fontMenu #standard) position: 10.3&gt;	^(MenuItem labeled: #small &lt;&lt; #labels &gt;&gt; 'Standard small')		value: #small;		yourself</body><body package="UIPainter">menuItemSystem	&lt;itemInMenu: #(#fontMenu) position: 10.1&gt;	^(MenuItem labeled: #SystemTextStyle &lt;&lt; #labels &gt;&gt; 'System (Widget Text)')		value: #system;		yourself</body><body package="UIPainter">menuPragmas	&lt;pragmas: #class&gt;		^#( #itemInMenu:position: #submenu:nameKey:menu:position:)</body><body package="UIPainter">submenuFontsStandard	&lt;submenu: #(#Standard #labels 'Standard')		nameKey: #standard		menu: #(#fontMenu)		position: 10.3&gt;</body></methods><methods><class-id>UI.UISpecification class</class-id> <category>resources</category><body package="UIPainter">unknownWidgetC	"UIMaskEditor new openOnClass: self andSelector: #unknownWidgetC"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue blue; at: 2 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4111); at: 3 put: Graphics.ColorValue white; at: 4 put: (Graphics.ColorValue scaledRed: 2055 scaledGreen: 0 scaledBlue: 8191); at: 5 put: (Graphics.ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 8191); yourself)) usingBits: (ByteArray fromPackedString: 'H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H!L4H"H"H @@H"H"HP@@P"H"H @@H"H"D@@@ABH"H @@H"H!@DH ABH"H @@H"H"H"HPABH"H @@H"H"H!@@P"H"H @@H"H"HP@DH"H"H @@H"H"HPABH"H"H @@H"H"HSMBH"H"H @@H"H"H"H"H"H"H @@H"H"H#L"H"H"H @@H"H"HPABH"H"H @@H"H"HPABH"H"H @@H"H"H$P"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@'))</body></methods><methods><class-id>UI.InputFieldSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 300 357 ) 			#max: #(#Point 300 357 ) 			#bounds: #(#Rectangle 337 181 637 538 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 4 0 114 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 4 0 54 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #AspectC #defaultString: 'Aspect:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 4 0 140 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #TypeC #defaultString: 'Type:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #InputField #defaultString: 'Input Field' #catalogID: #UIPainter) ) 				#(#MenuButtonSpec 					#layout: #(#LayoutFrame 86 0 118 0 -10 1 140 0 ) 					#model: #type 					#menu: #typeMenu ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 4 0 83 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Menu #defaultString: 'Menu:' #catalogID: #UIPainter) ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 28 0 -10 1 53 0 ) 					#name: #modelField 					#model: #model 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#validAspectSelector: ) 					#menu: #fieldMenu ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 58 0 -10 1 83 0 ) 					#name: #menuField 					#model: #menu 					#menu: #fieldMenu ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 86 0 88 0 -10 1 113 0 ) 					#model: #name 					#menu: #fieldMenu ) 				#(#ComboBoxSpec 					#layout: #(#LayoutFrame 86 0 148 0 -10 1 173 0 ) 					#name: #formatEditor 					#model: #formatString 					#menu: #fieldMenu 					#isReadOnly: false 					#comboList: #defaultFormats ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 4 0 174 0 0 1 ) 					#name: #formatLabel 					#label: #(#{Kernel.UserMessage} #key: #Format #defaultString: 'Format:' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">detailsEditSpec	"UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 240 233 ) 			#max: #(#Point 262 273 ) 			#bounds: #(#Rectangle 317 240 579 513 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#MenuButtonSpec 					#layout: #(#LayoutFrame 86 0 35 0 -10 1 57 0 ) 					#model: #style 					#menu: #fontMenu ) 				#(#MenuButtonSpec 					#layout: #(#LayoutFrame 86 0 65 0 -10 1 87 0 ) 					#model: #alignment 					#menu: #alignmentMenu ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 86 0 95 0 -10 1 118 0 ) 					#model: #numChars 					#menu: #fieldMenu 					#type: #string ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 126 ) 					#model: #hasBorder 					#label: #(#{Kernel.UserMessage} #key: #Bordered #defaultString: 'Bordered' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 148 ) 					#model: #isOpaque 					#label: #(#{Kernel.UserMessage} #key: #Opaque #defaultString: 'Opaque' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 170 ) 					#model: #tabable 					#label: #(#{Kernel.UserMessage} #key: #CanTab #defaultString: 'Can Tab' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 192 ) 					#model: #isReadOnly 					#label: #(#{Kernel.UserMessage} #key: #ReadOnly #defaultString: 'Read Only' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 214 ) 					#model: #initiallyDisabled 					#label: #(#{Kernel.UserMessage} #key: #InitiallyDisabled #defaultString: 'Initially Disabled' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 236 ) 					#model: #initiallyInvisible 					#label: #(#{Kernel.UserMessage} #key: #InitiallyInvisible #defaultString: 'Initially Invisible' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 88 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #AlignC #defaultString: 'Align:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 58 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #FontC #defaultString: 'Font:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 119 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #SizeC #defaultString: 'Size:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) ) ) )</body></methods><methods><class-id>UI.InputFieldSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@*******)@@B???????4@@K???????P@@/??????=@@B???????4@@K???????P@@/??????=@@B???????4@@K0@@@@@OP@@/J****(=@@B&lt;*(***#4@@K2@ HJ*OP@@/H"H"((=@@B&lt; HBB@#4@@K2*****OP@@/J****(=@@B&lt;@@@@@C4@@K???????P@@/??????=@@B???????4@@K???????P@@/??????=@@B???????4@@EUUUUUUUP@@@@@@@@@@@@@@a'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 143 255 252 192 136 0 4 192 136 32 4 192 139 187 4 192 138 170 36 192 139 187 116 192 136 0 4 192 136 0 4 192 143 255 252 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192 ])</body></methods><methods><class-id>Tools.ToolbarIconLibrary class</class-id> <category>resources</category><body package="UIPainter">actionButtonWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #actionButtonWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: (Graphics.ColorValue scaledRed: 6167 scaledGreen: 6167 scaledBlue: 6167); at: 2 put: (Graphics.ColorValue scaledRed: 7227 scaledGreen: 7227 scaledBlue: 7227); at: 3 put: Graphics.ColorValue white; at: 4 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4111); at: 5 put: (Graphics.ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 4111); yourself)) usingBits: (ByteArray fromPackedString: 'H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@DQDQDQDQDQDQDP@@D@@@@@@@@@@@A@@@D@@@L0@C@C@@A@@@D@@C@C@C@0@@A@@@D@@C@C@CL@@@A@@@D@@C@C@C@0@@A@@@D@@@L0@C@C@@A@@@D@@@@@@@@@@@A@@@EDQDQDQDQDQDQ@@@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@'))</body><body package="UIPainter">actionButtonWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #actionButtonWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 255 255 240 0 128 0 16 0 131 18 16 0 132 148 16 0 132 152 16 0 132 148 16 0 131 18 16 0 128 0 16 0 255 255 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">actionButtonWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #actionButtonWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">alignBottom20x20	"UIMaskEditor new openOnClass: self andSelector: #alignBottom20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4227); at: 3 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); at: 4 put: Graphics.ColorValue white; at: 5 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L0@@L3L3L3L@@@@3L0@@L3L3L3LCL3@3L0@@L3L3L3LCDT@3L0@@L3L3L3LCDT@3L0@@L3L3L3LCDT@3L0@@L3L3L3LCDT@3L0@@L3@@@@LCDT@3L0@@L3@3L0LCDT@3L0@@L3@1E@LCDT@3L0@@L3@1E@LCDT@3L0@@L3@1E@LCDT@3L0@@L3@1E@LCDT@3L0@@L3@1E@LCDT@3L0@@L3@4Q@LCQD@3L0@@L3@@@@L@@@@3L0@@L3L3L3L3L3L3L0@@L"H"H"H"H"H"L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@'))</body><body package="UIPainter">alignBottom20x20bw	"UIMaskEditor new openOnClass: self andSelector: #alignBottom20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 63 0 0 0 33 0 0 0 33 0 0 0 33 0 0 0 33 0 0 0 33 0 0 31 161 0 0 16 161 0 0 16 161 0 0 16 161 0 0 16 161 0 0 16 161 0 0 16 161 0 0 16 161 0 0 31 191 0 0 0 0 0 0 127 255 192 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">alignBottom20x20mask	"UIMaskEditor new openOnClass: self andSelector: #alignBottom20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 63 0 0 0 63 0 0 0 63 0 0 0 63 0 0 0 63 0 0 0 63 0 0 31 191 0 0 31 191 0 0 31 191 0 0 31 191 0 0 31 191 0 0 31 191 0 0 31 191 0 0 31 191 0 0 31 191 0 0 0 0 0 0 127 255 192 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">alignHCenter20x20	"UIMaskEditor new openOnClass: self andSelector: #alignHCenter20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4227); at: 3 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); at: 4 put: Graphics.ColorValue white; at: 5 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L@@@@3L0@@L3L3L3LCL3@3L0@@L3L3L3LCDT@3L0@@L3@@@@LCDT@3L0@@L3@3L0LCDT@3L0@@L3@1E@LCDT@3L0@@L3@1E@LCDT@3L0@@L"H"H"H"H"H"L0@@L3@1E@LCDT@3L0@@L3@1E@LCDT@3L0@@L3@4Q@LCDT@3L0@@L3@@@@LCDT@3L0@@L3L3L3LCDT@3L0@@L3L3L3LCQD@3L0@@L3L3L3L@@@@3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@'))</body><body package="UIPainter">alignHCenter20x20bw	"UIMaskEditor new openOnClass: self andSelector: #alignHCenter20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 63 0 0 0 33 0 0 0 33 0 0 31 161 0 0 16 161 0 0 16 161 0 0 16 161 0 0 127 255 192 0 16 161 0 0 16 161 0 0 16 161 0 0 31 161 0 0 0 33 0 0 0 33 0 0 0 63 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">alignHCenter20x20mask	"UIMaskEditor new openOnClass: self andSelector: #alignHCenter20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 63 0 0 0 63 0 0 0 63 0 0 31 191 0 0 31 191 0 0 31 191 0 0 31 191 0 0 127 255 192 0 31 191 0 0 31 191 0 0 31 191 0 0 31 191 0 0 0 63 0 0 0 63 0 0 0 63 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">alignLeft20x20	"UIMaskEditor new openOnClass: self andSelector: #alignLeft20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4227); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 4 put: Graphics.ColorValue white; at: 5 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L0@@L4L3L3L3L3L3L0@@L4L3L3L3L3L3L0@@L4L@@@@@@3L3L0@@L4LCL3L3@3L3L0@@L4LCDQDR@3L3L0@@L4LCDQDR@3L3L0@@L4LCH"H"@3L3L0@@L4L@@@@@@3L3L0@@L4L3L3L3L3L3L0@@L4L@@@@@@@@@@0@@L4LCL3L3L3L3@0@@L4LCDQDQDQDR@0@@L4LCDQDQDQDR@0@@L4LCH"H"H"H"@0@@L4L@@@@@@@@@@0@@L4L3L3L3L3L3L0@@L4L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@'))</body><body package="UIPainter">alignLeft20x20bw	"UIMaskEditor new openOnClass: self andSelector: #alignLeft20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 32 0 0 0 32 0 0 0 47 248 0 0 40 8 0 0 40 8 0 0 40 8 0 0 40 8 0 0 47 248 0 0 32 0 0 0 47 255 224 0 40 0 32 0 40 0 32 0 40 0 32 0 40 0 32 0 47 255 224 0 32 0 0 0 32 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">alignLeft20x20mask	"UIMaskEditor new openOnClass: self andSelector: #alignLeft20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 32 0 0 0 32 0 0 0 47 248 0 0 47 248 0 0 47 248 0 0 47 248 0 0 47 248 0 0 47 248 0 0 32 0 0 0 47 255 224 0 47 255 224 0 47 255 224 0 47 255 224 0 47 255 224 0 47 255 224 0 32 0 0 0 32 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">alignRight20x20	"UIMaskEditor new openOnClass: self andSelector: #alignRight20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4227); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 4 put: Graphics.ColorValue white; at: 5 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L0@@L3L3L3L3L3L4L0@@L3L3L3L3L3L4L0@@L3L3L@@@@@@4L0@@L3L3LCL3L3@4L0@@L3L3LCDQDR@4L0@@L3L3LCDQDR@4L0@@L3L3LCH"H"@4L0@@L3L3L@@@@@@4L0@@L3L3L3L3L3L4L0@@L@@@@@@@@@@4L0@@LCL3L3L3L3@4L0@@LCDQDQDQDR@4L0@@LCDQDQDQDR@4L0@@LCH"H"H"H"@4L0@@L@@@@@@@@@@4L0@@L3L3L3L3L3L4L0@@L3L3L3L3L3L4L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@'))</body><body package="UIPainter">alignRight20x20bw	"UIMaskEditor new openOnClass: self andSelector: #alignRight20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 64 0 0 0 64 0 1 255 64 0 1 1 64 0 1 1 64 0 1 1 64 0 1 1 64 0 1 255 64 0 0 0 64 0 127 255 64 0 64 1 64 0 64 1 64 0 64 1 64 0 64 1 64 0 127 255 64 0 0 0 64 0 0 0 64 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">alignRight20x20mask	"UIMaskEditor new openOnClass: self andSelector: #alignRight20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 64 0 0 0 64 0 1 255 64 0 1 255 64 0 1 255 64 0 1 255 64 0 1 255 64 0 1 255 64 0 0 0 64 0 127 255 64 0 127 255 64 0 127 255 64 0 127 255 64 0 127 255 64 0 127 255 64 0 0 0 64 0 0 0 64 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">alignTop20x20	"UIMaskEditor new openOnClass: self andSelector: #alignTop20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4227); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 4 put: Graphics.ColorValue white; at: 5 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@MDQDQDQDQDQDL0@@L3L3L3L3L3L3L0@@L3@@@@L@@@@3L0@@L3@3L0LCL3@3L0@@L3@1D LCDR@3L0@@L3@1D LCDR@3L0@@L3@1D LCDR@3L0@@L3@1D LCDR@3L0@@L3@1D LCDR@3L0@@L3@2H LCDR@3L0@@L3@@@@LCDR@3L0@@L3L3L3LCDR@3L0@@L3L3L3LCDR@3L0@@L3L3L3LCDR@3L0@@L3L3L3LCDR@3L0@@L3L3L3LCH"@3L0@@L3L3L3L@@@@3L0@@L3L3L3L3L3L3L0@@'))</body><body package="UIPainter">alignTop20x20bw	"UIMaskEditor new openOnClass: self andSelector: #alignTop20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 127 255 192 0 0 0 0 0 31 191 0 0 16 161 0 0 16 161 0 0 16 161 0 0 16 161 0 0 16 161 0 0 16 161 0 0 16 161 0 0 31 161 0 0 0 33 0 0 0 33 0 0 0 33 0 0 0 33 0 0 0 33 0 0 0 63 0 0 0 0 0 0])</body><body package="UIPainter">alignTop20x20mask	"UIMaskEditor new openOnClass: self andSelector: #alignTop20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 127 255 192 0 0 0 0 0 31 191 0 0 31 191 0 0 31 191 0 0 31 191 0 0 31 191 0 0 31 191 0 0 31 191 0 0 31 191 0 0 31 191 0 0 0 63 0 0 0 63 0 0 0 63 0 0 0 63 0 0 0 63 0 0 0 63 0 0 0 0 0 0])</body><body package="UIPainter">alignVCenter20x20	"UIMaskEditor new openOnClass: self andSelector: #alignVCenter20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4227); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 4 put: Graphics.ColorValue white; at: 5 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L0@@L3L3L3P3L3L3L0@@L3L3L3P3L3L3L0@@L3L0@@P@@CL3L0@@L3L0L3P3LCL3L0@@L3L0LQPQHCL3L0@@L3L0LQPQHCL3L0@@L3L0L"P"HCL3L0@@L3L0@@P@@CL3L0@@L3L3L3P3L3L3L0@@L0@@@@P@@@@CL0@@L0L3L3P3L3LCL0@@L0LQDQPQDQHCL0@@L0LQDQPQDQHCL0@@L0L"H"P"H"HCL0@@L0@@@@P@@@@CL0@@L3L3L3P3L3L3L0@@L3L3L3P3L3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@'))</body><body package="UIPainter">alignVCenter20x20bw	"UIMaskEditor new openOnClass: self andSelector: #alignVCenter20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 64 0 0 0 64 0 0 7 252 0 0 4 68 0 0 4 68 0 0 4 68 0 0 4 68 0 0 7 252 0 0 0 64 0 0 63 255 128 0 32 64 128 0 32 64 128 0 32 64 128 0 32 64 128 0 63 255 128 0 0 64 0 0 0 64 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">alignVCenter20x20mask	"UIMaskEditor new openOnClass: self andSelector: #alignVCenter20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 64 0 0 0 64 0 0 7 252 0 0 7 252 0 0 7 252 0 0 7 252 0 0 7 252 0 0 7 252 0 0 0 64 0 0 63 255 128 0 63 255 128 0 63 255 128 0 63 255 128 0 63 255 128 0 63 255 128 0 0 64 0 0 0 64 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">arbitraryComponentWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #arbitraryComponentWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 22@22 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 4) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue blue; at: 3 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 3276 scaledBlue: 1638); at: 4 put: Graphics.ColorValue white; yourself)) usingBits: #[255 255 255 255 255 240 0 0 255 255 255 255 255 240 0 0 240 0 0 0 0 240 0 0 241 85 85 85 84 240 0 0 240 0 0 0 0 240 0 0 243 255 255 255 252 240 0 0 243 3 0 48 252 240 0 0 243 255 255 255 252 240 0 0 243 15 255 255 252 240 0 0 243 255 255 255 252 240 0 0 243 252 0 255 252 240 0 0 243 240 207 63 252 240 0 0 243 192 207 3 252 240 0 0 243 0 0 40 60 240 0 0 243 40 138 42 12 240 0 0 243 0 0 0 12 240 0 0 243 192 255 192 252 240 0 0 243 243 255 243 252 240 0 0 243 255 255 255 252 240 0 0 240 0 0 0 0 240 0 0 255 255 255 255 255 240 0 0 255 255 255 255 255 240 0 0])</body><body package="UIPainter">arbitraryComponentWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #arbitraryComponentWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 22@22 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 63 255 240 0 63 255 240 0 63 255 240 0 32 0 16 0 46 251 16 0 32 0 16 0 44 0 16 0 32 0 16 0 33 240 16 0 35 72 16 0 39 78 16 0 47 255 144 0 47 255 208 0 47 255 208 0 39 7 16 0 34 2 16 0 32 0 16 0 63 255 240 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">arbitraryComponentWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #arbitraryComponentWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 22@22 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 63 255 240 0 63 255 240 0 63 255 240 0 63 255 240 0 63 255 240 0 63 255 240 0 63 255 240 0 63 255 240 0 63 255 240 0 63 255 240 0 63 255 240 0 63 255 240 0 63 255 240 0 63 255 240 0 63 255 240 0 63 255 240 0 63 255 240 0 63 255 240 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">browseAClass20x20	"UIMaskEditor new openOnClass: self andSelector: #browseAClass20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 6) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4240); at: 3 put: (Graphics.ColorValue scaledRed: 6874 scaledGreen: 6874 scaledBlue: 6874); at: 4 put: Graphics.ColorValue white; at: 5 put: Graphics.ColorValue yellow; at: 6 put: (Graphics.ColorValue scaledRed: 4497 scaledGreen: 6070 scaledBlue: 6617); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3L@@@@@@3L3L0@@L3LADQDT@3L3L0@@L3LADTQD@3L3L0@@L3LDQDQD@3L3L0@@L3L@@@@@@3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3@0@@L3L3L3L3L3L0L@@@L0@CL3L@@3LCL@@@LEUPL3AUTC@3L0@@ASMU@@T3UPL3L0@@ASUU@0T5UPL3L0@@AUUR@0UUT L3L0@@LET L3AUHCL3L0@@L0@CL3L@@3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@'))</body><body package="UIPainter">browseAClass20x20bw	"UIMaskEditor new openOnClass: self andSelector: #browseAClass20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 15 248 0 0 8 8 0 0 8 8 0 0 8 8 0 0 15 248 0 0 0 0 0 0 0 0 32 0 0 0 80 0 56 56 144 0 124 125 0 0 203 202 0 0 150 150 0 0 170 170 0 0 84 84 0 0 56 56 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">browseAClass20x20mask	"UIMaskEditor new openOnClass: self andSelector: #browseAClass20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 15 248 0 0 15 248 0 0 15 248 0 0 15 248 0 0 15 248 0 0 0 0 0 0 0 0 32 0 0 0 80 0 56 56 144 0 124 125 0 0 255 254 0 0 254 254 0 0 254 254 0 0 124 124 0 0 56 56 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">browseAppModel20x20	"UIMaskEditor new openOnClass: self andSelector: #browseAppModel20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 7) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 4 put: (Graphics.ColorValue scaledRed: 4491 scaledGreen: 6077 scaledBlue: 6605); at: 5 put: Graphics.ColorValue white; at: 6 put: (Graphics.ColorValue scaledRed: 6605 scaledGreen: 6605 scaledBlue: 6605); at: 7 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'QDQDQDQDQDQDQ@@@QDQDPDQDQDQDQ@@@QDQDA@QDQDQDQ@@@QDQ@Q$ADQDQDQ@@@QDPFYEPDQDQDQ@@@QDA&amp;QUU@QDQDQ@@@Q@Y$UUUTADQDQ@@@PDYEUUT%DDQDQ@@@Q@QUUUUQADQDQ@@@QD@UUUTPQDQDQ@@@QDPAUUDDQDQDA@@@QDQ@EQADQDQ@P@@@Q@@D@PP@ADPDP@@@PCL0PD@3LDADQ@@@@4P3A@MDL0QDQ@@@@4L3@@MCL0QDQ@@@@3L2A@L3L QDQ@@@PCL QD@3HDQDQ@@@Q@@DQDP@ADQDQ@@@QDQDQDQDQDQDQ@@@'))</body><body package="UIPainter">browseAppModel20x20bw	"UIMaskEditor new openOnClass: self andSelector: #browseAppModel20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 1 0 0 0 2 128 0 0 5 64 0 0 14 32 0 0 28 16 0 0 56 8 0 0 80 4 0 0 32 8 0 0 16 16 0 0 8 32 32 0 4 64 80 0 58 184 144 0 69 69 0 0 130 130 0 0 131 130 0 0 130 130 0 0 68 68 0 0 56 56 0 0 0 0 0 0])</body><body package="UIPainter">browseAppModel20x20mask	"UIMaskEditor new openOnClass: self andSelector: #browseAppModel20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 1 0 0 0 3 128 0 0 7 192 0 0 15 224 0 0 31 240 0 0 63 248 0 0 127 252 0 0 63 248 0 0 31 240 0 0 15 224 32 0 7 192 80 0 59 184 144 0 125 125 0 0 254 254 0 0 255 254 0 0 254 254 0 0 124 124 0 0 56 56 0 0 0 0 0 0])</body><body package="UIPainter">canvasWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #canvasWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4111); at: 3 put: Graphics.ColorValue white; at: 4 put: (Graphics.ColorValue scaledRed: 4111 scaledGreen: 8191 scaledBlue: 8191); at: 5 put: (Graphics.ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 4111); yourself)) usingBits: (ByteArray fromPackedString: 'H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H@@@@@@@@"H @@H"IBHQDQD"@"H @@H"IBHQDQD"@"H @@H"IADQDQDQ@"H @@H"IBH"H"H"@"H @@H"IBH"H"H#@"H @@H"IBH"H"H3@"H @@H"IBH"H2L#@"H @@H"IBH"L#H3@"H @@H"IBH"H2L3@"H @@H"IBH"L#L3@"H @@H"IBH#H3L3@"H @@H"IBH3L3L3@"H @@H"I@@@@@@@@"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@'))</body><body package="UIPainter">canvasWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #canvasWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 255 240 0 255 255 240 0 240 0 240 0 246 6 240 0 246 6 240 0 240 0 240 0 247 254 240 0 247 252 240 0 247 248 240 0 247 212 240 0 247 168 240 0 247 208 240 0 247 160 240 0 247 64 240 0 246 0 240 0 240 0 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0])</body><body package="UIPainter">canvasWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #canvasWidget20x20mask"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 15 255 0 0 9 249 0 0 9 249 0 0 15 255 0 0 15 255 0 0 15 255 0 0 15 255 0 0 15 255 0 0 15 255 0 0 15 255 0 0 15 255 0 0 15 255 0 0 15 255 0 0 15 255 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">checkBox20x20	"UIMaskEditor new openOnClass: self andSelector: #checkBox20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 8) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 6167 scaledGreen: 6167 scaledBlue: 6167); at: 3 put: Graphics.ColorValue white; at: 4 put: (Graphics.ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 4111); at: 5 put: (Graphics.ColorValue scaledRed: 7387 scaledGreen: 7387 scaledBlue: 7387); at: 6 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 4111 scaledBlue: 8191); at: 7 put: (Graphics.ColorValue scaledRed: 2055 scaledGreen: 0 scaledBlue: 8191); at: 8 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4111); yourself)) usingBits: (ByteArray fromPackedString: 'H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H!DQDQDQDQDPH @@H!L3L3L3L3M0H @@H!L@@@@@@@]PH @@H!LBH"H"H''U H @@H!LBH"H"I5U H @@H!LBH"H"]UX0H @@H!LBI2H"]VD0H @@H!LB]WH''U"D0H @@H!LGUWI5U"D0H @@H!M5UU]5X"D0H @@H!LGUU]UX"D0H @@H!LB]UUVH"D0H @@H!LBI5UVH"D0H @@H!LDQGUVDQD0H @@H!L3L3]#L3L0H @@H!@@@@@@@@@@H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@'))</body><body package="UIPainter">checkBox20x20bw	"UIMaskEditor new openOnClass: self andSelector: #checkBox20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 255 240 0 255 255 240 0 192 0 48 0 192 1 48 0 192 2 176 0 199 252 176 0 199 248 48 0 199 241 48 0 198 241 48 0 196 98 48 0 200 66 48 0 208 6 48 0 208 6 48 0 204 14 48 0 198 30 48 0 193 32 48 0 192 160 48 0 192 64 48 0 255 255 240 0 255 255 240 0])</body><body package="UIPainter">checkBox20x20mask	"UIMaskEditor new openOnClass: self andSelector: #checkBox20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">comboBoxWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #comboBoxWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 6) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue white; at: 3 put: (Graphics.ColorValue scaledRed: 5460 scaledGreen: 5460 scaledBlue: 5460); at: 4 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 7098); at: 5 put: Graphics.ColorValue yellow; at: 6 put: Graphics.ColorValue blue; yourself)) usingBits: (ByteArray fromPackedString: 'DQDQDQDQDQDQDP@@DP@@@@@@@@@@DP@@DPQDQDQDPDQ@DP@@DPQ@QDQDPDQ@DP@@DPP@ADQDPDQ@DP@@DP@@@@@@@@@@DP@@DPDQDQDQDQDPDP@@DPD@@@@@@@@PDP@@DPDQDQDQDQDPDP@@DPUUUUUUUUUPDP@@DPURH"H"H"UPDP@@DPUUUUL5T5UPDP@@DPDQDQDQDQDPDP@@DPD@@@@@@@@PDP@@DPDQDQDQDQDPDP@@DPDQDQDQDQDPDP@@DPD@@@@@@@@PDP@@DPDQDQDQDQDPDP@@DP@@@@@@@@@@DP@@DQDQDQDQDQDQDP@@'))</body><body package="UIPainter">comboBoxWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #comboBoxWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 63 255 192 0 32 4 64 0 36 4 64 0 46 4 64 0 63 255 192 0 32 0 64 0 47 255 64 0 32 0 64 0 63 255 192 0 56 1 192 0 63 255 192 0 32 0 64 0 47 255 64 0 32 0 64 0 32 0 64 0 47 255 64 0 32 0 64 0 63 255 192 0 0 0 0 0])</body><body package="UIPainter">comboBoxWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #comboBoxWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 0 0 0 0])</body><body package="UIPainter">compositeWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #compositeWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 7) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 7227 scaledGreen: 7227 scaledBlue: 7227); at: 3 put: Graphics.ColorValue white; at: 4 put: (Graphics.ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 4111); at: 5 put: (Graphics.ColorValue scaledRed: 4111 scaledGreen: 8191 scaledBlue: 8191); at: 6 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 4111 scaledBlue: 8191); at: 7 put: Graphics.ColorValue blue; yourself)) usingBits: (ByteArray fromPackedString: 'H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H @@@@@@@@@@H @@H Y&amp;Y&amp;Y&amp;Y&amp;Y H @@H Y&amp;Y&amp;Y&amp;Y&amp;Y H @@H Y#L3L3L3Y H @@H Y#UUUUUSY H @@H Y#UUUUUSY H @@H Y#UQDQUSY H @@H Y#UQQAUSY H @@H Y#UQQAUSY H @@H Y#UQDQUSY H @@H Y#UUUUUSY H @@H Y#UUUUUSY H @@H Y#L3L3L3Y H @@H Y&amp;Y&amp;Y&amp;Y&amp;Y H @@H Y&amp;Y&amp;Y&amp;Y&amp;Y H @@H @@@@@@@@@@H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@'))</body><body package="UIPainter">compositeWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #compositeWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 255 240 0 255 255 240 0 192 0 48 0 223 255 176 0 223 255 176 0 216 1 176 0 218 169 176 0 217 85 176 0 218 9 176 0 217 101 176 0 218 105 176 0 217 5 176 0 218 169 176 0 217 85 176 0 216 1 176 0 223 255 176 0 223 255 176 0 192 0 48 0 255 255 240 0 255 255 240 0])</body><body package="UIPainter">compositeWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #compositeWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">dataSetWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #dataSetWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@21 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 4) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4368); at: 3 put: (Graphics.ColorValue scaledRed: 4368 scaledGreen: 0 scaledBlue: 0); at: 4 put: Graphics.ColorValue white; yourself)) usingBits: #[255 255 255 255 255 0 0 0 255 255 255 255 255 0 0 0 192 0 0 0 3 0 0 0 207 247 253 255 243 0 0 0 206 247 253 255 243 0 0 0 207 247 253 255 243 0 0 0 197 85 85 85 83 0 0 0 207 247 253 255 243 0 0 0 206 247 253 255 243 0 0 0 207 247 253 255 243 0 0 0 197 85 85 85 83 0 0 0 207 247 253 255 243 0 0 0 206 247 253 255 243 0 0 0 207 247 253 255 243 0 0 0 197 85 85 85 83 0 0 0 207 247 253 255 243 0 0 0 206 247 253 255 243 0 0 0 207 247 253 255 243 0 0 0 192 0 0 0 3 0 0 0 255 255 255 255 255 0 0 0 255 255 255 255 255 0 0 0])</body><body package="UIPainter">dataSetWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #dataSetWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@21 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 127 255 224 0 66 16 32 0 82 16 32 0 66 16 32 0 127 255 224 0 66 16 32 0 82 16 32 0 66 16 32 0 127 255 224 0 66 16 32 0 82 16 32 0 66 16 32 0 127 255 224 0 66 16 32 0 82 16 32 0 66 16 32 0 127 255 224 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">dataSetWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #dataSetWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@21 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">defineGUIMethods20x20	"UIMaskEditor new openOnClass: self andSelector: #defineGUIMethods20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 4 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 10) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 4 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4227); at: 5 put: (Graphics.ColorValue scaledRed: 3170 scaledGreen: 3170 scaledBlue: 3170); at: 6 put: Graphics.ColorValue white; at: 7 put: (Graphics.ColorValue scaledRed: 6605 scaledGreen: 6605 scaledBlue: 6605); at: 8 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); at: 9 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 7398 scaledBlue: 7926); at: 10 put: (Graphics.ColorValue scaledRed: 4227 scaledGreen: 4227 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'UUUUUUUUUUUUUP@@UUUUUUUUUUUUUP@@UUUUUTQDQDUUUP@@UUUUUTL3L4QUUP@@UUUUUTMUUTUEUP@@UUUUATMUUT@@UP@@UUUPTDMUUUDPUP@@UUTE]TMUUUV@UP@@UUA7U%%UUU!PUP@@UP]5Y&amp;VUUXV@UP@@TG]VY&amp;YYVE"@UP@@AWU&amp;Y&amp;I!AX"@UP@@TEY&amp;Y&amp;XP&amp;H"@UP@@UPE&amp;Y&amp;DI"H"@UP@@UU@VY!BX"H"@UP@@UUTAXP@@@@@@UP@@UUUPDEUUUUUUUP@@UUUUAUUUUUUUUP@@UUUUUUUUUUUUUP@@UUUUUUUUUUUUUP@@'))</body><body package="UIPainter">defineGUIMethods20x20bw	"UIMaskEditor new openOnClass: self andSelector: #defineGUIMethods20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 254 0 0 0 131 0 0 0 130 128 0 2 131 192 0 5 128 64 0 10 128 64 0 28 64 64 0 56 32 64 0 112 16 64 0 160 8 64 0 64 16 64 0 32 32 64 0 16 64 64 0 8 255 192 0 5 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">defineGUIMethods20x20mask	"UIMaskEditor new openOnClass: self andSelector: #defineGUIMethods20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 254 0 0 0 255 0 0 0 255 128 0 2 255 192 0 7 255 192 0 15 255 192 0 31 255 192 0 63 255 192 0 127 255 192 0 255 255 192 0 127 255 192 0 63 255 192 0 31 255 192 0 15 255 192 0 7 0 0 0 2 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">dividerWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #dividerWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 3) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue white; at: 3 put: (Graphics.ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 4111); yourself)) usingBits: #[85 85 85 85 85 0 0 0 85 85 33 85 85 0 0 0 85 85 33 85 85 0 0 0 85 85 33 85 85 0 0 0 85 85 33 85 85 0 0 0 85 85 33 85 85 0 0 0 85 85 33 85 85 0 0 0 85 85 33 85 85 0 0 0 85 85 33 85 85 0 0 0 85 85 33 85 85 0 0 0 85 85 33 85 85 0 0 0 85 85 33 85 85 0 0 0 85 85 33 85 85 0 0 0 85 85 33 85 85 0 0 0 85 85 33 85 85 0 0 0 85 85 85 85 85 0 0 0 86 170 170 170 149 0 0 0 84 0 0 0 21 0 0 0 86 170 170 170 149 0 0 0 85 85 85 85 85 0 0 0])</body><body package="UIPainter">dividerWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #dividerWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 0 0 0 31 255 128 0 31 255 128 0 31 255 128 0 0 0 0 0])</body><body package="UIPainter">dividerWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #dividerWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 224 0 0 0 0 0 0 31 255 128 0 31 255 128 0 31 255 128 0 0 0 0 0])</body><body package="UIPainter">documentEditorWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #documentEditorWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: ((Image extent: 20@20 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 2537 4882)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[170 170 170 170 170 0 0 0 149 85 85 85 86 0 0 0 149 85 85 85 86 0 0 0 149 165 105 85 86 0 0 0 149 89 86 85 86 0 0 0 149 169 106 85 86 0 0 0 150 89 150 85 86 0 0 0 150 89 150 85 86 0 0 0 149 169 106 85 86 0 0 0 149 85 85 85 86 0 0 0 149 85 17 85 86 0 0 0 149 165 69 85 86 0 0 0 149 89 69 85 86 0 0 0 149 169 69 85 86 0 0 0 150 89 69 85 86 0 0 0 150 89 69 85 86 0 0 0 149 169 69 85 86 0 0 0 149 85 17 85 86 0 0 0 149 85 85 85 86 0 0 0 170 170 170 170 170 0 0 0]))</body><body package="UIPainter">documentEditorWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #documentEditorWidget20x20bw"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 240 0 128 0 16 0 128 0 16 0 140 96 16 0 130 16 16 0 142 112 16 0 146 144 16 0 146 144 16 0 142 112 16 0 128 0 16 0 128 160 16 0 140 64 16 0 130 64 16 0 142 64 16 0 146 64 16 0 146 64 16 0 142 64 16 0 128 160 16 0 128 0 16 0 255 255 240 0])</body><body package="UIPainter">documentEditorWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #documentEditorWidget20x20mask"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0])</body><body package="UIPainter">documentViewWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #documentViewWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: ((Image extent: 20@20 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6520 6520 6520)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 2537 4882)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[255 255 255 255 255 0 0 0 234 170 170 170 171 0 0 0 234 170 170 170 171 0 0 0 234 250 190 170 171 0 0 0 234 174 171 170 171 0 0 0 234 254 191 170 171 0 0 0 235 174 235 170 171 0 0 0 235 174 235 170 171 0 0 0 234 254 191 170 171 0 0 0 234 170 170 2 171 0 0 0 234 170 168 168 171 0 0 0 234 250 168 168 171 0 0 0 234 174 168 0 171 0 0 0 234 254 161 85 43 0 0 0 235 174 161 69 43 0 0 0 235 174 161 69 43 0 0 0 234 254 161 85 43 0 0 0 234 170 160 0 43 0 0 0 234 170 170 170 171 0 0 0 255 255 255 255 255 0 0 0]))</body><body package="UIPainter">documentViewWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #documentViewWidget20x20mask"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0])</body><body package="UIPainter">documentViewWidget20x20w	"UIMaskEditor new openOnClass: self andSelector: #documentViewWidget20x20bw"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 240 0 128 0 16 0 128 0 16 0 140 96 16 0 130 16 16 0 142 112 16 0 146 144 16 0 146 144 16 0 142 112 16 0 128 14 16 0 128 17 16 0 140 17 16 0 130 31 16 0 142 63 144 0 146 63 144 0 146 63 144 0 142 63 144 0 128 63 144 0 128 0 16 0 255 255 240 0])</body><body package="UIPainter">equalBoth20x20	"UIMaskEditor new openOnClass: self andSelector: #equalBoth20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4227); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 4 put: Graphics.ColorValue white; at: 5 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L0@@L0@@@@@CP3L3L0@@L0L3L3LCMCMCL0@@L0LQDQHCL4QCL0@@L0LQDQHCL4QCL0@@L0LQDQHCMDQCL0@@L0LQDQHCL3L3L0@@L0PTEAP4MCP4L0@@L0LQDQHCL3L3L0@@L0LQDQHCL3L4L0@@L0L"H"HCL3L3L0@@L0@@@@@DMCP4L0@@L3L3L3L3L3L3L0@@L0@@@@@@@@@@L0@@L0L3L3L3L3L0L0@@L0LQDQDQDQD L0@@L0L"H"H"H"H L0@@L0@@@@@@@@@@L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@'))</body><body package="UIPainter">equalBoth20x20bw	"UIMaskEditor new openOnClass: self andSelector: #equalBoth20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 63 232 0 0 32 36 128 0 32 35 128 0 32 35 128 0 32 39 128 0 32 32 0 0 53 85 64 0 32 32 0 0 32 32 64 0 32 32 0 0 63 245 64 0 0 0 0 0 63 255 192 0 32 0 64 0 32 0 64 0 32 0 64 0 63 255 192 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">equalBoth20x20mask	"UIMaskEditor new openOnClass: self andSelector: #equalBoth20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 63 232 0 0 63 228 128 0 63 227 128 0 63 227 128 0 63 231 128 0 63 224 0 0 63 213 64 0 63 224 0 0 63 224 64 0 63 224 0 0 63 245 64 0 0 0 0 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">equalHeight20x20	"UIMaskEditor new openOnClass: self andSelector: #equalHeight20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4227); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 4 put: Graphics.ColorValue white; at: 5 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3QDQDL@@@@3L0@@L3L3L3LCL3@3L0@@L3L4L3LCDR@3L0@@L3MDP3LCDR@3L0@@L3QDQCLCDR@3L0@@L3L4L3LCDR@3L0@@L3L4L3LCDR@3L0@@L3L3L3LCDR@3L0@@L3@@@@LCDR@3L0@@L3@3L0LCDR@3L0@@L3@1D LCDR@3L0@@L3@1D LCDR@3L0@@L3@1D LCDR@3L0@@L3@1D LCDR@3L0@@L3@2H LCH"@3L0@@L3@@@@L@@@@3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@'))</body><body package="UIPainter">equalHeight20x20bw	"UIMaskEditor new openOnClass: self andSelector: #equalHeight20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 31 191 0 0 0 33 0 0 4 33 0 0 14 33 0 0 31 33 0 0 4 33 0 0 4 33 0 0 0 33 0 0 31 161 0 0 16 161 0 0 16 161 0 0 16 161 0 0 16 161 0 0 16 161 0 0 16 161 0 0 31 191 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">equalHeight20x20mask	"UIMaskEditor new openOnClass: self andSelector: #equalHeight20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 31 191 0 0 0 63 0 0 4 63 0 0 14 63 0 0 31 63 0 0 4 63 0 0 4 63 0 0 0 63 0 0 31 191 0 0 31 191 0 0 31 191 0 0 31 191 0 0 31 191 0 0 31 191 0 0 31 191 0 0 31 191 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">equalWidth20x20	"UIMaskEditor new openOnClass: self andSelector: #equalWidth20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4227); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 4 put: Graphics.ColorValue white; at: 5 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L0@@@@@3MCL4L0@@L0L3L3@3MDL4L0@@L0LQDR@4QDP4L0@@L0LQDR@3MDL4L0@@L0L"H"@3MCL4L0@@L0@@@@@3L3L4L0@@L3L3L3L3L3L3L0@@L0@@@@@@@@@@L0@@L0L3L3L3L3L0L0@@L0LQDQDQDQD L0@@L0LQDQDQDQD L0@@L0L"H"H"H"H L0@@L0@@@@@@@@@@L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@'))</body><body package="UIPainter">equalWidth20x20bw	"UIMaskEditor new openOnClass: self andSelector: #equalWidth20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 63 196 64 0 32 70 64 0 32 95 64 0 32 70 64 0 32 68 64 0 63 192 64 0 0 0 0 0 63 255 192 0 32 0 64 0 32 0 64 0 32 0 64 0 32 0 64 0 63 255 192 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">equalWidth20x20mask	"UIMaskEditor new openOnClass: self andSelector: #equalWidth20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 63 196 64 0 63 198 64 0 63 223 64 0 63 198 64 0 63 196 64 0 63 192 64 0 0 0 0 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 63 255 192 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">groupBoxWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #groupBoxWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 3) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 6552 scaledGreen: 6552 scaledBlue: 6552); at: 3 put: Graphics.ColorValue white; yourself)) usingBits: #[170 170 170 170 170 0 0 0 170 42 170 170 170 0 0 0 170 42 170 170 170 0 0 0 129 1 1 17 2 0 0 0 133 17 17 69 82 0 0 0 133 1 1 17 82 0 0 0 133 85 85 85 82 0 0 0 133 85 85 85 82 0 0 0 133 85 85 85 82 0 0 0 133 85 85 85 82 0 0 0 133 85 85 85 82 0 0 0 133 85 85 85 82 0 0 0 133 85 85 85 82 0 0 0 133 85 85 85 82 0 0 0 133 85 85 85 82 0 0 0 133 85 85 85 82 0 0 0 133 85 85 85 82 0 0 0 133 85 85 85 82 0 0 0 128 0 0 0 2 0 0 0 170 170 170 170 170 0 0 0])</body><body package="UIPainter">groupBoxWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #groupBoxWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 8 0 0 0 8 0 0 0 110 234 224 0 74 164 32 0 78 234 32 0 64 0 32 0 64 0 32 0 64 0 32 0 64 0 32 0 64 0 32 0 64 0 32 0 64 0 32 0 64 0 32 0 64 0 32 0 64 0 32 0 64 0 32 0 64 0 32 0 127 255 224 0 0 0 0 0])</body><body package="UIPainter">groupBoxWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #groupBoxWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 8 0 0 0 8 0 0 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 0 0 0 0])</body><body package="UIPainter">hierarchicalViewWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #hierarchicalViewWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 3) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 4914 scaledBlue: 8191); at: 3 put: Graphics.ColorValue white; yourself)) usingBits: #[170 170 170 170 170 0 0 0 128 0 0 0 2 0 0 0 138 170 170 168 162 0 0 0 138 170 170 168 162 0 0 0 136 0 0 8 2 0 0 0 138 170 170 168 82 0 0 0 138 128 0 8 82 0 0 0 138 170 170 168 82 0 0 0 138 128 0 8 82 0 0 0 138 170 170 168 82 0 0 0 138 168 0 8 82 0 0 0 138 170 170 168 82 0 0 0 138 168 0 8 82 0 0 0 138 170 170 168 82 0 0 0 138 168 0 8 82 0 0 0 138 170 170 168 2 0 0 0 138 168 0 8 162 0 0 0 138 170 170 168 162 0 0 0 128 0 0 0 2 0 0 0 170 170 170 170 170 0 0 0])</body><body package="UIPainter">hierarchicalViewWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #hierarchicalViewWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 255 224 0 64 1 32 0 64 1 32 0 95 253 224 0 64 1 224 0 71 253 224 0 64 1 224 0 71 253 224 0 64 1 224 0 65 253 224 0 64 1 224 0 65 253 224 0 64 1 224 0 65 253 224 0 64 1 224 0 65 253 32 0 64 1 32 0 127 255 224 0 0 0 0 0])</body><body package="UIPainter">hierarchicalViewWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #hierarchicalViewWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 0 0 0 0])</body><body package="UIPainter">horizontalDistribution20x20	"UIMaskEditor new openOnClass: self andSelector: #horizontalDistribution20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4227); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 4 put: Graphics.ColorValue white; at: 5 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3P3L3P3L3P3L0@@L4QDQDQDQDQCL0@@L3P3L3P3L3P3L0@@L3P3L3P3L3P3L0@@L3P3L3P3L3P3L0@@L3L3L3L3L3L3L0@@L@@@L@@@L@@@L0@@LCL0LCL0LCL0L0@@LCD LCD LCD L0@@LCD LCD LCD L0@@LCD LCD LCD L0@@LCD LCD LCD L0@@LCD LCD LCD L0@@LCD LCD LCD L0@@LCH LCH LCH L0@@L@@@L@@@L@@@L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@'))</body><body package="UIPainter">horizontalDistribution20x20bw	"UIMaskEditor new openOnClass: self andSelector: #horizontalDistribution20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 16 65 0 0 63 255 128 0 16 65 0 0 16 65 0 0 16 65 0 0 0 0 0 0 125 247 192 0 69 20 64 0 69 20 64 0 69 20 64 0 69 20 64 0 69 20 64 0 69 20 64 0 69 20 64 0 69 20 64 0 125 247 192 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">horizontalDistribution20x20mask	"UIMaskEditor new openOnClass: self andSelector: #horizontalDistribution20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 16 65 0 0 63 255 128 0 16 65 0 0 16 65 0 0 16 65 0 0 0 0 0 0 125 247 192 0 125 247 192 0 125 247 192 0 125 247 192 0 125 247 192 0 125 247 192 0 125 247 192 0 125 247 192 0 125 247 192 0 125 247 192 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">horizontalSpacing20x20	"UIMaskEditor new openOnClass: self andSelector: #horizontalSpacing20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4227); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 4 put: Graphics.ColorValue white; at: 5 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3L4MCL4MCL3L0@@L3MDQDMDQDL3L0@@L3L4MCL4MCL3L0@@L3L4MCL4MCL3L0@@L3L4MCL4MCL3L0@@L3L3L3L3L3L3L0@@L@@@L@@@L@@@L0@@LCL0LCL0LCL0L0@@LCD LCD LCD L0@@LCD LCD LCD L0@@LCD LCD LCD L0@@LCD LCD LCD L0@@LCD LCD LCD L0@@LCD LCD LCD L0@@LCH LCH LCH L0@@L@@@L@@@L@@@L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@'))</body><body package="UIPainter">horizontalSpacing20x20bw	"UIMaskEditor new openOnClass: self andSelector: #horizontalSpacing20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 5 20 0 0 15 190 0 0 5 20 0 0 5 20 0 0 5 20 0 0 0 0 0 0 125 247 192 0 69 20 64 0 69 20 64 0 69 20 64 0 69 20 64 0 69 20 64 0 69 20 64 0 69 20 64 0 69 20 64 0 125 247 192 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">horizontalSpacing20x20mask	"UIMaskEditor new openOnClass: self andSelector: #horizontalSpacing20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 5 20 0 0 15 190 0 0 5 20 0 0 5 20 0 0 5 20 0 0 0 0 0 0 125 247 192 0 125 247 192 0 125 247 192 0 125 247 192 0 125 247 192 0 125 247 192 0 125 247 192 0 125 247 192 0 125 247 192 0 125 247 192 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">inputEditorWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #inputEditorWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: ((Image extent: 20@20 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 2537 4882)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[85 85 85 85 85 0 0 0 85 85 85 85 85 0 0 0 85 85 85 85 85 0 0 0 85 85 85 85 85 0 0 0 170 170 170 170 170 0 0 0 149 85 85 85 86 0 0 0 149 85 85 17 86 0 0 0 150 149 165 69 86 0 0 0 149 101 89 69 86 0 0 0 150 165 169 69 86 0 0 0 153 102 89 69 86 0 0 0 153 102 89 69 86 0 0 0 150 165 169 69 86 0 0 0 149 85 85 17 86 0 0 0 149 85 85 85 86 0 0 0 170 170 170 170 170 0 0 0 85 85 85 85 85 0 0 0 85 85 85 85 85 0 0 0 85 85 85 85 85 0 0 0 85 85 85 85 85 0 0 0]))</body><body package="UIPainter">inputEditorWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #inputEditorWidget20x20bw"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 255 255 240 0 128 0 16 0 128 10 16 0 152 196 16 0 132 36 16 0 156 228 16 0 165 36 16 0 165 36 16 0 156 228 16 0 128 10 16 0 128 0 16 0 255 255 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">inputEditorWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #inputEditorWidget20x20mask"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">inputFieldWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #inputFieldWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 4) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue blue; at: 3 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4111); at: 4 put: Graphics.ColorValue white; yourself)) usingBits: #[255 255 255 255 255 0 0 0 255 255 255 255 255 0 0 0 255 255 255 255 255 0 0 0 255 255 255 255 255 0 0 0 255 255 255 255 255 0 0 0 0 0 0 0 0 0 0 0 63 255 255 255 252 0 0 0 63 253 255 255 252 0 0 0 63 253 255 255 252 0 0 0 53 93 87 85 252 0 0 0 63 221 247 127 252 0 0 0 53 93 247 127 252 0 0 0 55 221 247 127 236 0 0 0 53 93 87 85 168 0 0 0 63 255 255 255 252 0 0 0 0 0 0 0 0 0 0 0 255 255 255 255 255 0 0 0 255 255 255 255 255 0 0 0 255 255 255 255 255 0 0 0 255 255 255 255 255 0 0 0])</body><body package="UIPainter">inputFieldWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #inputFieldWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 255 255 240 0 128 0 16 0 129 0 16 0 129 0 16 0 189 239 16 0 133 40 16 0 189 40 16 0 165 40 80 0 189 239 240 0 128 0 16 0 255 255 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">inputFieldWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #inputFieldWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">installMenu20x20	"UIMaskEditor new openOnClass: self andSelector: #installMenu20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 4 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 11) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 3 put: (Graphics.ColorValue scaledRed: 5020 scaledGreen: 5020 scaledBlue: 5020); at: 4 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 5 put: (Graphics.ColorValue scaledRed: 3170 scaledGreen: 3170 scaledBlue: 3170); at: 6 put: Graphics.ColorValue white; at: 7 put: (Graphics.ColorValue scaledRed: 6605 scaledGreen: 6605 scaledBlue: 6605); at: 8 put: (Graphics.ColorValue scaledRed: 5812 scaledGreen: 5812 scaledBlue: 5812); at: 9 put: Graphics.ColorValue yellow; at: 10 put: (Graphics.ColorValue scaledRed: 2113 scaledGreen: 2113 scaledBlue: 2113); at: 11 put: (Graphics.ColorValue scaledRed: 4227 scaledGreen: 4227 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'UUUUUUUUUUUUUP@@UUUUUUUUUUUUUP@@UUUUUUUUUUUUUP@@UUUUVUUUUUUUUP@@UUUUQPUUUUT@UP@@UUUTU''AUUUAUAP@@UUUEL3\EUPVEAP@@UUQVL3M0TE PUP@@UTU&amp;L3L7AXDEUP@@UEX3L3M$VAAUUP@@UPT3L3YE PUUUP@@UUASL6QXDJAUUP@@UUTEM&amp;RAB&amp;HEUP@@UUUPU&amp;@@)"AUUP@@UUUUAVZ*X UUUP@@UUUUTEY&amp;HEUUUP@@UUUUUPU"AUUUUP@@UUUUUU@ UUUUUP@@UUUUUUTEUUUUUP@@UUUUUUUUUUUUUP@@'))</body><body package="UIPainter">installMenu20x20bw	"UIMaskEditor new openOnClass: self andSelector: #installMenu20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 2 128 192 0 4 65 32 0 8 162 32 0 16 20 192 0 34 41 128 0 64 19 0 0 40 166 0 0 16 77 0 0 10 88 128 0 4 113 0 0 2 130 0 0 1 4 0 0 0 136 0 0 0 80 0 0 0 32 0 0 0 0 0 0])</body><body package="UIPainter">installMenu20x20mask	"UIMaskEditor new openOnClass: self andSelector: #installMenu20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 3 128 192 0 7 193 224 0 15 227 224 0 31 247 192 0 63 255 128 0 127 255 0 0 63 254 0 0 31 255 0 0 15 255 128 0 7 255 0 0 3 254 0 0 1 252 0 0 0 248 0 0 0 112 0 0 0 32 0 0 0 0 0 0])</body><body package="UIPainter">installWindow20x20	"UIMaskEditor new openOnClass: self andSelector: #installWindow20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 8) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 3 put: (Graphics.ColorValue scaledRed: 3170 scaledGreen: 3170 scaledBlue: 3170); at: 4 put: Graphics.ColorValue white; at: 5 put: (Graphics.ColorValue scaledRed: 6605 scaledGreen: 6605 scaledBlue: 6605); at: 6 put: Graphics.ColorValue yellow; at: 7 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); at: 8 put: (Graphics.ColorValue scaledRed: 4227 scaledGreen: 4227 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L0@3L0@@L3L3L3L3LCLCL0@@L3L3L0L3@5LCL0@@L3L3LC@0MQ@3L0@@L3L3@6LCTPL3L0@@L3L0Y#H5DCL3L0@@L3LFX2MQ@3L3L0@@L3A&amp;L#TP\CL3L0@@L0M#P%DGPPL3L0@@L3@4P@A4DCL3L0@@L3LAQG]A@3L3L0@@L3L0EDPPL3L3L0@@L3L3@TDCL3L3L0@@L3L3LA@3L3L3L0@@L3L3L0L3L3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@'))</body><body package="UIPainter">installWindow20x20bw	"UIMaskEditor new openOnClass: self andSelector: #installWindow20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 3 0 0 0 4 128 0 0 136 128 0 1 81 0 0 2 162 0 0 7 68 0 0 14 136 0 0 29 20 0 0 41 34 0 0 17 196 0 0 8 8 0 0 4 16 0 0 2 32 0 0 1 64 0 0 0 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">installWindow20x20mask	"UIMaskEditor new openOnClass: self andSelector: #installWindow20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 3 0 0 0 7 128 0 0 143 128 0 1 223 0 0 3 254 0 0 7 252 0 0 15 248 0 0 31 252 0 0 63 254 0 0 31 252 0 0 15 248 0 0 7 240 0 0 3 224 0 0 1 192 0 0 0 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">labelWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #labelWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 2) at: 1 put: Graphics.ColorValue blue; at: 2 put: Graphics.ColorValue white; yourself)) usingBits: #[255 255 240 0 255 255 240 0 255 255 240 0 255 63 240 0 255 63 240 0 255 31 240 0 254 159 240 0 254 159 240 0 254 207 240 0 253 207 240 0 253 207 240 0 252 7 240 0 251 231 240 0 251 231 240 0 243 243 240 0 224 192 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0])</body><body package="UIPainter">labelWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #labelWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 192 0 0 0 192 0 0 0 224 0 0 1 96 0 0 1 96 0 0 1 48 0 0 2 48 0 0 2 48 0 0 3 248 0 0 4 24 0 0 4 24 0 0 12 12 0 0 31 63 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">labelWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #labelWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 192 0 0 0 192 0 0 0 224 0 0 1 96 0 0 1 96 0 0 1 48 0 0 2 48 0 0 2 48 0 0 3 248 0 0 4 24 0 0 4 24 0 0 12 12 0 0 31 63 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">mappedClickWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #mappedClickWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 6) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue white; at: 3 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 3822); at: 4 put: (Graphics.ColorValue scaledRed: 2923 scaledGreen: 2923 scaledBlue: 8191); at: 5 put: Graphics.ColorValue blue; at: 6 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4111); yourself)) usingBits: (ByteArray fromPackedString: 'DQDQDQDQDQDQDP@@DQDSL3TQDQDQDP@@DQDSL3TQDQDQDP@@DQDSL3TQDQDQDP@@DQDSL3TQDQDQDP@@DQDSL3TQDQDQDP@@DQDSL3L3L3L3DP@@DQDSL3L3L#L3TP@@DQDSL3L3L#L3TP@@L3L3L3L"H"H#TP@@L3L3L3L3H"L3MP@@D3L3L3L3@2L3TP@@DSL3L3L0@3H3TP@@DQL3L3L@@3L3TP@@DQD5DS@@@3UUDP@@DQDUDP@@@5DQDP@@DQDQDQP@AQDQDP@@DQDQDQ@CAQDQDP@@DQDQDP@SMQDQDP@@DQDQDPDQMQDQDP@@'))</body><body package="UIPainter">mappedClickWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #mappedClickWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 7 192 0 0 4 64 0 0 4 64 0 0 4 64 0 0 4 64 0 0 4 127 192 0 4 4 32 0 4 4 32 0 252 63 160 0 128 14 16 0 64 10 32 0 32 25 32 0 23 184 32 0 12 249 192 0 4 254 0 0 0 124 0 0 0 100 0 0 0 212 0 0 0 140 0 0])</body><body package="UIPainter">mappedClickWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #mappedClickWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 7 192 0 0 7 192 0 0 7 192 0 0 7 192 0 0 7 192 0 0 7 255 192 0 7 255 224 0 7 255 224 0 255 255 224 0 255 255 240 0 127 255 224 0 63 255 224 0 31 255 224 0 12 255 192 0 4 254 0 0 0 124 0 0 0 124 0 0 0 220 0 0 0 140 0 0])</body><body package="UIPainter">menuButtonWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #menuButtonWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue blue; at: 3 put: Graphics.ColorValue yellow; at: 4 put: Graphics.ColorValue white; at: 5 put: (Graphics.ColorValue scaledRed: 5460 scaledGreen: 5460 scaledBlue: 5460); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L@@@@@@@@@@@@0@@LBH"H"H"H H"@0@@LB@@@@@@@ H"@0@@LBH"H"H"H H"@0@@L@@@@@@@@@@@@0@@LCL3L3L3L0L3L0@@LCL3L3L3L0L3L0@@LC@@@@@@@0L3L0@@LCL3L3L3L0L3L0@@LADQDQDQDPL3L0@@LAQDQDQDPPL3L0@@LADQDQDQDPL3L0@@LCL3L3L3L0L3L0@@LC@@@@@@@0L3L0@@LCL3L3L3L0L3L0@@L@@@@@@@@@L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@'))</body><body package="UIPainter">menuButtonWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #menuButtonWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 127 255 224 0 64 2 32 0 95 250 32 0 64 2 32 0 127 255 224 0 64 2 0 0 64 2 0 0 95 250 0 0 64 2 0 0 127 254 0 0 96 6 0 0 127 254 0 0 64 2 0 0 95 250 0 0 64 2 0 0 127 254 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">menuButtonWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #menuButtonWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 254 0 0 127 254 0 0 127 254 0 0 127 254 0 0 127 254 0 0 127 254 0 0 127 254 0 0 127 254 0 0 127 254 0 0 127 254 0 0 127 254 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">moveMenuItemDown20x20	"UIMaskEditor new openOnClass: self andSelector: #moveMenuItemDown20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 7) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 4 put: (Graphics.ColorValue scaledRed: 3170 scaledGreen: 3170 scaledBlue: 3170); at: 5 put: Graphics.ColorValue white; at: 6 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); at: 7 put: (Graphics.ColorValue scaledRed: 4227 scaledGreen: 4227 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'QDQDQDQDQDQDQ@@@QDQDQDQDQDQDQ@@@QDQDQ&amp;Y&amp;Y&amp;Y&amp;M@@@QDUDQ$QDQDQBA@@@QDUDQ$H"H"H!A@@@QUUUQ$H"H"H!A@@@QEUTQ$H"H"H!A@@@QDUDQ$H"H"H!A@@@QDQDQ$H"H"H!A@@@QDQ&amp;Y&amp;Y&amp;Y&amp;L!A@@@QDQ$QDQDQBA!A@@@QDQ$H"H"H!@6A@@@QDQ"DQDQDQA"A@@@QDP0@@@@@@A!A@@@QDQFX6Y&amp;Y&amp;Y!A@@@QDQDQ$H"H"H!A@@@QDQDQ!DQDQDQA@@@QDQDP0@@@@@@A@@@QDQDQDQDQDQDQ@@@QDQDQDQDQDQDQ@@@'))</body><body package="UIPainter">moveMenuItemDown20x20bw	"UIMaskEditor new openOnClass: self andSelector: #moveMenuItemDown20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 1 255 224 0 17 0 32 0 17 0 32 0 125 0 32 0 57 0 32 0 17 0 32 0 1 0 32 0 15 255 32 0 8 1 32 0 8 1 224 0 8 1 32 0 15 255 32 0 1 0 32 0 1 0 32 0 1 0 32 0 1 255 224 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">moveMenuItemDown20x20mask	"UIMaskEditor new openOnClass: self andSelector: #moveMenuItemDown20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 1 255 224 0 17 255 224 0 17 255 224 0 125 255 224 0 57 255 224 0 17 255 224 0 1 255 224 0 15 255 224 0 15 255 224 0 15 255 224 0 15 255 224 0 15 255 224 0 7 255 224 0 1 255 224 0 1 255 224 0 1 255 224 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">moveMenuItemLeft20x20	"UIMaskEditor new openOnClass: self andSelector: #moveMenuItemLeft20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 7) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 4 put: (Graphics.ColorValue scaledRed: 3170 scaledGreen: 3170 scaledBlue: 3170); at: 5 put: Graphics.ColorValue white; at: 6 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); at: 7 put: (Graphics.ColorValue scaledRed: 4227 scaledGreen: 4227 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'QDQDQDQDQDQDQ@@@Q&amp;Y&amp;Y&amp;Y&amp;MDQDQ@@@Q$QDQDQBADQDQ@@@Q$H"H"H!ADQDQ@@@Q$H"H"H!ADQDQ@@@Q$H"H"H!ADQDQ@@@Q$H"H"H!ADQDQ@@@Q$H"H"H!ADQDQ@@@Q$H"H"H!ADQDQ@@@Q$H"H"H!ADQDQ@@@Q"DQDQDQADQDQ@@@P0@@@@@@ADQDQ@@@QDQDQDQDQDQDQ@@@P3L3L3L3MDQEQ@@@P4QDQDQBA$QUQ@@@P4H"H"H!A$UUUP@@P2DQDQDQA$QUQ@@@P0@@@@@@A$QEQ@@@QFY&amp;Y&amp;Y&amp;Y$QDQ@@@QDQDQDQDQDQDQ@@@'))</body><body package="UIPainter">moveMenuItemLeft20x20bw	"UIMaskEditor new openOnClass: self andSelector: #moveMenuItemLeft20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 248 0 0 64 8 0 0 64 8 0 0 64 8 0 0 64 8 0 0 64 8 0 0 64 8 0 0 64 8 0 0 64 8 0 0 64 8 0 0 127 248 0 0 0 0 0 0 127 248 64 0 64 8 192 0 64 9 240 0 64 8 192 0 127 248 64 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">moveMenuItemLeft20x20mask	"UIMaskEditor new openOnClass: self andSelector: #moveMenuItemLeft20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 248 0 0 127 248 0 0 127 248 0 0 127 248 0 0 127 248 0 0 127 248 0 0 127 248 0 0 127 248 0 0 127 248 0 0 127 248 0 0 127 248 0 0 0 0 0 0 127 248 64 0 127 252 192 0 127 253 240 0 127 252 192 0 127 252 64 0 63 252 0 0 0 0 0 0])</body><body package="UIPainter">moveMenuItemRight20x20	"UIMaskEditor new openOnClass: self andSelector: #moveMenuItemRight20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 7) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 4 put: (Graphics.ColorValue scaledRed: 3170 scaledGreen: 3170 scaledBlue: 3170); at: 5 put: Graphics.ColorValue white; at: 6 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); at: 7 put: (Graphics.ColorValue scaledRed: 4227 scaledGreen: 4227 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'QDQDQDQDQDQDQ@@@Q&amp;Y&amp;Y&amp;Y&amp;MDQDQ@@@Q$QDQDQBADQDQ@@@Q$H"H"H!ADQDQ@@@Q$H"H"H!ADQDQ@@@Q$H"H"H!ADQDQ@@@Q$H"H"H!ADQDQ@@@Q$H"H"T!ADQDQ@@@Q$H"H"UQADQDQ@@@Q$H"H"T!ADQDQ@@@Q"DQDQDQADQDQ@@@P0@@@@@@ADQDQ@@@QDQDQDQDQDQDQ@@@QDUDP3L3L3L3M@@@QDUTP4QDQDQBA @@QUUUP4H"H"H!A @@QDUTP2DQDQDQA @@QDUDP0@@@@@@A @@QDQDQFY&amp;Y&amp;Y&amp;Y @@QDQDQDQDQDQDQ@@@'))</body><body package="UIPainter">moveMenuItemRight20x20bw	"UIMaskEditor new openOnClass: self andSelector: #moveMenuItemRight20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 248 0 0 64 8 0 0 64 8 0 0 64 8 0 0 64 8 0 0 64 8 0 0 64 8 0 0 64 8 0 0 64 8 0 0 64 8 0 0 127 248 0 0 0 0 0 0 17 255 224 0 25 0 32 0 125 0 32 0 25 0 32 0 17 255 224 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">moveMenuItemRight20x20mask	"UIMaskEditor new openOnClass: self andSelector: #moveMenuItemRight20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 248 0 0 127 248 0 0 127 248 0 0 127 248 0 0 127 248 0 0 127 248 0 0 127 248 0 0 127 248 0 0 127 248 0 0 127 248 0 0 127 248 0 0 0 0 0 0 17 255 224 0 25 255 240 0 125 255 240 0 25 255 240 0 17 255 240 0 0 255 240 0 0 0 0 0])</body><body package="UIPainter">moveMenuItemUp20x20	"UIMaskEditor new openOnClass: self andSelector: #moveMenuItemUp20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 7) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 4 put: (Graphics.ColorValue scaledRed: 3170 scaledGreen: 3170 scaledBlue: 3170); at: 5 put: Graphics.ColorValue white; at: 6 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); at: 7 put: (Graphics.ColorValue scaledRed: 4227 scaledGreen: 4227 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'QDQDQDQDQDQDQ@@@QDQDQDQDQDQDQ@@@QDQDQ&amp;Y&amp;Y&amp;Y&amp;M@@@QDQDQ$QDQDQBA@@@QDQDQ"H"H"H!A@@@QDQ&amp;Y&amp;Y&amp;Y&amp;LQA@@@QDQ$QDQDQBA!A@@@QDQ$H"H"H!@6A@@@QDQ"DQDQDQA"A@@@QDP0@@@@@@A!A@@@QDQFX6Y&amp;Y&amp;Y!A@@@QDUDQ$H"H"H!A@@@QEUTQ$H"H"H!A@@@QUUUQ$H"H"H!A@@@QDUDQ$H"H"H!A@@@QDUDQ$H"H"H!A@@@QDQDQ!DQDQDQA@@@QDQDP0@@@@@@A@@@QDQDQDQDQDQDQ@@@QDQDQDQDQDQDQ@@@'))</body><body package="UIPainter">moveMenuItemUp20x20bw	"UIMaskEditor new openOnClass: self andSelector: #moveMenuItemUp20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 1 255 224 0 1 0 32 0 1 0 32 0 15 255 32 0 8 1 32 0 8 1 224 0 8 1 32 0 15 255 32 0 1 0 32 0 17 0 32 0 57 0 32 0 125 0 32 0 17 0 32 0 17 0 32 0 1 0 32 0 1 255 224 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">moveMenuItemUp20x20mask	"UIMaskEditor new openOnClass: self andSelector: #moveMenuItemUp20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 1 255 224 0 1 255 224 0 1 255 224 0 15 255 224 0 15 255 224 0 15 255 224 0 15 255 224 0 15 255 224 0 7 255 224 0 17 255 224 0 57 255 224 0 125 255 224 0 17 255 224 0 17 255 224 0 1 255 224 0 1 255 224 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">namedFonts20x20	"UIMaskEditor new openOnClass: self andSelector: #namedFonts20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 4 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 12) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 6341 scaledGreen: 6341 scaledBlue: 0); at: 3 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4756); at: 4 put: Graphics.ColorValue white; at: 5 put: (Graphics.ColorValue scaledRed: 4756 scaledGreen: 4756 scaledBlue: 2378); at: 6 put: (Graphics.ColorValue scaledRed: 5020 scaledGreen: 5020 scaledBlue: 0); at: 7 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); at: 8 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 3699); at: 9 put: (Graphics.ColorValue scaledRed: 5812 scaledGreen: 5812 scaledBlue: 8191); at: 10 put: (Graphics.ColorValue scaledRed: 3170 scaledGreen: 3170 scaledBlue: 8191); at: 11 put: (Graphics.ColorValue scaledRed: 2113 scaledGreen: 2113 scaledBlue: 2113); at: 12 put: (Graphics.ColorValue scaledRed: 6605 scaledGreen: 6605 scaledBlue: 8191); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L0@@L3L:****(3L3L0@@L3N"H"H"LCL3L0@@L3("H"H#PCL3L0@@L:H"H"H4PCL3L0@@N#L3L3MDPCL3L0@@N'']7]7UDPCL3L0@@N'']6]7UDPCL3L0@@N'']!Y7UDR*L3L0@@N'']!Y7UJ*;*#L0@@N''Y&amp;Y''*+.;.:(0@@N''Y7]''*CN;L9@0@@N'']7]7*H 3&amp;Y@0@@L0@@@@*H"I&amp;Y@0@@L3L3L3*H"I&amp;Y@0@@L3L3L3*H"I&amp;Y@0@@L3L3L3(H"I&amp;P@0@@L3L3L3L:BI@CL0@@L3L3L3L3N L3L0@@L3L3L3L3L3L3L0@@'))</body><body package="UIPainter">namedFonts20x20bw	"UIMaskEditor new openOnClass: self andSelector: #namedFonts20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 7 248 0 0 8 12 0 0 16 20 0 0 32 44 0 0 127 212 0 0 64 108 0 0 68 84 0 0 74 110 0 0 74 89 128 0 95 96 96 0 81 89 224 0 64 70 160 0 63 193 96 0 0 66 160 0 0 65 96 0 0 98 224 0 0 25 128 0 0 6 0 0 0 0 0 0])</body><body package="UIPainter">namedFonts20x20mask	"UIMaskEditor new openOnClass: self andSelector: #namedFonts20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 7 248 0 0 15 252 0 0 31 252 0 0 63 252 0 0 127 252 0 0 127 252 0 0 127 252 0 0 127 254 0 0 127 255 128 0 127 255 224 0 127 255 224 0 127 255 224 0 63 255 224 0 0 127 224 0 0 127 224 0 0 127 224 0 0 31 128 0 0 6 0 0 0 0 0 0])</body><body package="UIPainter">newMenuItem20x20	"UIMaskEditor new openOnClass: self andSelector: #newMenuItem20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 8) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 3434); at: 4 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 5 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4227); at: 6 put: (Graphics.ColorValue scaledRed: 3170 scaledGreen: 3170 scaledBlue: 3170); at: 7 put: Graphics.ColorValue white; at: 8 put: (Graphics.ColorValue scaledRed: 4227 scaledGreen: 4227 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y @@Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y @@Y&amp;Y&amp;]7]7]7]5Y @@Y&amp;Y&amp;]&amp;Y&amp;Y&amp;X0Y @@Y&amp;Y&amp;\3L3L3LPY @@Y&amp;]7]7]7]5DPY @@Y&amp;]&amp;Y&amp;Y&amp;Y@\PY @@Y&amp;]$QDQDP U5Y @@Y&amp;]BH"H"H \7Y @@Y&amp;T@@@@@@@\PY @@Y&amp;Y7U7]7]7\PY @@Y&amp;Y&amp;\3L3L3LPY @@Y&amp;Y&amp;\3L3L3LPY @@Y&amp;Y&amp;\3L3L3LPY @@Y&amp;Y&amp;\3L3L3LPY @@Y&amp;Y&amp;\3L3L3LPY @@Y&amp;Y&amp;\QDQDQDPY @@Y&amp;Y&amp;T@@@@@@@Y @@Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y @@Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y @@'))</body><body package="UIPainter">newMenuItem20x20bw	"UIMaskEditor new openOnClass: self andSelector: #newMenuItem20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 3 255 192 0 2 0 64 0 2 0 64 0 31 254 64 0 16 2 64 0 16 3 192 0 16 2 64 0 31 254 64 0 2 0 64 0 2 0 64 0 2 0 64 0 2 0 64 0 2 0 64 0 2 0 64 0 2 0 64 0 3 255 192 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">newMenuItem20x20mask	"UIMaskEditor new openOnClass: self andSelector: #newMenuItem20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 3 255 192 0 3 255 192 0 3 255 192 0 31 255 192 0 31 255 192 0 31 255 192 0 31 255 192 0 31 255 192 0 15 255 192 0 3 255 192 0 3 255 192 0 3 255 192 0 3 255 192 0 3 255 192 0 3 255 192 0 3 255 192 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">newMenuSeparator20x20	"UIMaskEditor new openOnClass: self andSelector: #newMenuSeparator20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 4 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 9) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 3434); at: 4 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 5 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4227); at: 6 put: (Graphics.ColorValue scaledRed: 3170 scaledGreen: 3170 scaledBlue: 3170); at: 7 put: Graphics.ColorValue white; at: 8 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); at: 9 put: (Graphics.ColorValue scaledRed: 4227 scaledGreen: 4227 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y @@Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y @@Y&amp;Y&amp;"H"H"H"EY @@Y&amp;Y&amp;!&amp;Y&amp;Y&amp;X0Y @@Y&amp;Y&amp;!#L3L3LPY @@Y&amp;"H"H"H"EDPY @@Y&amp;!&amp;Y&amp;Y&amp;Y@ PY @@Y&amp;!'']7]7\ VEY @@Y&amp;!BH"H"H  8Y @@Y&amp;T@@@@@@@ PY @@Y&amp;ZHVH"H"H PY @@Y&amp;Y&amp;!#L3L3LPY @@Y&amp;Y&amp;!#L3L3LPY @@Y&amp;Y&amp;!#L3L3LPY @@Y&amp;Y&amp;!#L3L3LPY @@Y&amp;Y&amp;!#L3L3LPY @@Y&amp;Y&amp; QDQDQDPY @@Y&amp;Y&amp;T@@@@@@@Y @@Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y @@Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y @@'))</body><body package="UIPainter">newMenuSeparator20x20bw	"UIMaskEditor new openOnClass: self andSelector: #newMenuSeparator20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 3 255 192 0 2 0 64 0 2 0 64 0 31 254 64 0 16 2 64 0 23 251 192 0 16 2 64 0 31 254 64 0 2 0 64 0 2 0 64 0 2 0 64 0 2 0 64 0 2 0 64 0 2 0 64 0 2 0 64 0 3 255 192 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">newMenuSeparator20x20mask	"UIMaskEditor new openOnClass: self andSelector: #newMenuSeparator20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 3 255 192 0 3 255 192 0 3 255 192 0 31 255 192 0 31 255 192 0 31 255 192 0 31 255 192 0 31 255 192 0 15 255 192 0 3 255 192 0 3 255 192 0 3 255 192 0 3 255 192 0 3 255 192 0 3 255 192 0 3 255 192 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">newSubmenuItem20x20	"UIMaskEditor new openOnClass: self andSelector: #newSubmenuItem20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 4 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 9) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 3434); at: 4 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 5 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4227); at: 6 put: (Graphics.ColorValue scaledRed: 3170 scaledGreen: 3170 scaledBlue: 3170); at: 7 put: Graphics.ColorValue white; at: 8 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); at: 9 put: (Graphics.ColorValue scaledRed: 4227 scaledGreen: 4227 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y @@Y("H"H"H!VY&amp;Y @@Y(Y&amp;Y&amp;Y&amp;LFY&amp;Y @@Y(X3L3L3DFY&amp;Y @@Y(X3L3L3DFY&amp;Y @@Y(X3L3L3DFY&amp;Y @@Y(X3L3L3DFY&amp;Y @@Y(X3L3M3DFY&amp;Y @@Y(X3L3M7DFY&amp;Y @@Y(X3L3M3DFY&amp;Y @@Y(LQDQDQDFY&amp;Y @@Y%@@@@@@@FY&amp;Y @@Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y @@Y&amp;Y&amp;UUUUUUUUY @@Y&amp;Y&amp;U&amp;Y&amp;Y&amp;Y@! @@Y&amp;Y&amp;U$QDQDP ! @@Y&amp;Y&amp;UBH"H"H ! @@Y&amp;Y&amp;T@@@@@@@! @@Y&amp;Y&amp;ZH"H"H"H! @@Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y&amp;Y @@'))</body><body package="UIPainter">newSubmenuItem20x20bw	"UIMaskEditor new openOnClass: self andSelector: #newSubmenuItem20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 63 252 0 0 32 4 0 0 32 4 0 0 32 4 0 0 32 4 0 0 32 4 0 0 32 36 0 0 32 52 0 0 32 36 0 0 32 4 0 0 63 252 0 0 0 0 0 0 3 255 192 0 2 0 64 0 2 0 64 0 2 0 64 0 3 255 192 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">newSubmenuItem20x20mask	"UIMaskEditor new openOnClass: self andSelector: #newSubmenuItem20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 0 0 0 0 3 255 192 0 3 255 224 0 3 255 224 0 3 255 224 0 3 255 224 0 1 255 224 0 0 0 0 0])</body><body package="UIPainter">nudgeDown20x20	"UIMaskEditor new openOnClass: self andSelector: #nudgeDown20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 4240 scaledGreen: 4240 scaledBlue: 4240); at: 3 put: Graphics.ColorValue white; at: 4 put: (Graphics.ColorValue scaledRed: 5557 scaledGreen: 5557 scaledBlue: 5557); at: 5 put: (Graphics.ColorValue scaledRed: 5557 scaledGreen: 7387 scaledBlue: 7934); yourself)) usingBits: (ByteArray fromPackedString: 'H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H @@@"H"H @@H"H"H H"@"H"H @@H"H"H L"@"H"H @@H"H"H L"@"H"H @@H"H"H L"@"H"H @@H"H"H L"@"H"H @@H"H@@CIBH@@BH @@H"HAQDP$H"HBH @@H"H EDQBP"@"H @@H"H"@TQDI@H"H @@H"H"HAQDPBH"H @@H"H"H ED@"H"H @@H"H"H"@PH"H"H @@H"H"H"HBH"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@'))</body><body package="UIPainter">nudgeDown20x20bw	"UIMaskEditor new openOnClass: self andSelector: #nudgeDown20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 248 0 0 0 136 0 0 0 200 0 0 0 200 0 0 0 200 0 0 0 200 0 0 15 167 128 0 15 208 128 0 7 233 0 0 3 246 0 0 1 252 0 0 0 248 0 0 0 112 0 0 0 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">nudgeDown20x20mask	"UIMaskEditor new openOnClass: self andSelector: #nudgeDown20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 248 0 0 0 248 0 0 0 248 0 0 0 248 0 0 0 248 0 0 0 248 0 0 15 255 128 0 15 255 128 0 7 255 0 0 3 254 0 0 1 252 0 0 0 248 0 0 0 112 0 0 0 32 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">nudgeUp20x20	"UIMaskEditor new openOnClass: self andSelector: #nudgeUp20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 4240 scaledGreen: 4240 scaledBlue: 4240); at: 3 put: Graphics.ColorValue white; at: 4 put: (Graphics.ColorValue scaledRed: 5557 scaledGreen: 7387 scaledBlue: 7934); at: 5 put: (Graphics.ColorValue scaledRed: 5557 scaledGreen: 5557 scaledBlue: 5557); yourself)) usingBits: (ByteArray fromPackedString: 'H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H"HBH"H"H @@H"H"H"@PH"H"H @@H"H"H D3@"H"H @@H"H"HAL3LBH"H @@H"H"@SL3H0H"H @@H"H D3L2L"@"H @@H"HAL3L#H"HBH @@H"H@@DH2H@@BH @@H"H"H P"@"H"H @@H"H"H P"@"H"H @@H"H"H P"@"H"H @@H"H"H P"@"H"H @@H"H"H H"@"H"H @@H"H"H @@@"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@'))</body><body package="UIPainter">nudgeUp20x20bw	"UIMaskEditor new openOnClass: self andSelector: #nudgeUp20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 32 0 0 0 112 0 0 0 248 0 0 1 252 0 0 3 246 0 0 7 233 0 0 15 208 128 0 15 167 128 0 0 200 0 0 0 200 0 0 0 200 0 0 0 200 0 0 0 136 0 0 0 248 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">nudgeUp20x20mask	"UIMaskEditor new openOnClass: self andSelector: #nudgeUp20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 32 0 0 0 112 0 0 0 248 0 0 1 252 0 0 3 254 0 0 7 255 0 0 15 255 128 0 15 255 128 0 0 248 0 0 0 248 0 0 0 248 0 0 0 248 0 0 0 248 0 0 0 248 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">openWindow20x20	"UIMaskEditor new openOnClass: self andSelector: #openWindow20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 4 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 9) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 3 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4227); at: 4 put: (Graphics.ColorValue scaledRed: 3170 scaledGreen: 3170 scaledBlue: 3170); at: 5 put: Graphics.ColorValue white; at: 6 put: (Graphics.ColorValue scaledRed: 6605 scaledGreen: 6605 scaledBlue: 6605); at: 7 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); at: 8 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 7134 scaledBlue: 0); at: 9 put: (Graphics.ColorValue scaledRed: 2113 scaledGreen: 2113 scaledBlue: 2113); yourself)) usingBits: (ByteArray fromPackedString: 'QDQDQDQDQDQDQ@@@QDQDQDQDQDQDQ@@@QDQDQDQDQDPDQ@@@QDQDPDQDQDBDQ@@@QDQDA@QDQ@ADQ@@@QDQ@Q$ADPB!DQ@@@QDPFYEPD@ QDQ@@@QDA&amp;QUUHH QDQ@@@Q@Y$UUT2H @@A@@@PDYEUUL"IBI0Q@@@Q@QUUSH"P"\DQ@@@QD@UT3L8H''ADQ@@@QDPAUQD0I0QDQ@@@QDQ@EQA@\DQDQ@@@QDQD@PRGADQDQ@@@QDQDPDP@QDQDQ@@@QDQDQD DQDQDQ@@@QDQDQDADQDQDQ@@@QDQDQDQDQDQDQ@@@QDQDQDQDQDQDQ@@@'))</body><body package="UIPainter">openWindow20x20bw	"UIMaskEditor new openOnClass: self andSelector: #openWindow20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 128 0 1 1 128 0 2 131 0 0 5 69 0 0 14 42 0 0 28 18 0 0 56 35 224 0 80 64 64 0 32 128 128 0 17 241 0 0 8 50 0 0 4 84 0 0 2 168 0 0 1 48 0 0 0 96 0 0 0 64 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">openWindow20x20mask	"UIMaskEditor new openOnClass: self andSelector: #openWindow20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 128 0 1 1 128 0 3 131 0 0 7 199 0 0 15 238 0 0 31 254 0 0 63 255 224 0 127 255 192 0 63 255 128 0 31 255 0 0 15 254 0 0 7 220 0 0 3 184 0 0 1 48 0 0 0 96 0 0 0 64 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">progressWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #progressWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 7291 scaledGreen: 7291 scaledBlue: 7291); at: 3 put: Graphics.ColorValue white; at: 4 put: (Graphics.ColorValue scaledRed: 2055 scaledGreen: 0 scaledBlue: 8191); at: 5 put: (Graphics.ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 4111); yourself)) usingBits: (ByteArray fromPackedString: 'H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@A@@@@CL3L3L3LQDQE@@@@CH"H2H"LP@PE@@@@CL3H3L2LP@PE@@@@CL2L3L#LQDAE@@@@CL#L3H3LQ@QE@@@@CL#L3H3LPD@E@@@@CL#L3H3LPD@E@@@@CL3L3L3LQDQE@@@QDQDQDQDQDQDQ@@@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@'))</body><body package="UIPainter">progressWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #progressWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 255 255 240 0 255 255 240 0 255 248 16 0 225 11 80 0 253 235 80 0 251 216 144 0 247 185 16 0 247 186 208 0 247 186 208 0 255 248 16 0 255 255 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">progressWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #progressWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">radioButton20x20	"UIMaskEditor new openOnClass: self andSelector: #radioButton20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 8) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 6167 scaledGreen: 6167 scaledBlue: 6167); at: 3 put: Graphics.ColorValue white; at: 4 put: (Graphics.ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 4111); at: 5 put: (Graphics.ColorValue scaledRed: 7387 scaledGreen: 7387 scaledBlue: 7387); at: 6 put: (Graphics.ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 8191); at: 7 put: (Graphics.ColorValue scaledRed: 2055 scaledGreen: 0 scaledBlue: 8191); at: 8 put: (Graphics.ColorValue scaledRed: 4111 scaledGreen: 8191 scaledBlue: 8191); yourself)) usingBits: (ByteArray fromPackedString: 'H"H"H"H"H"H"H @@H"H"HQDQD"H"H @@H"H!DSL3LPH"H @@H"HSL3@@L3ABH @@H"D3@AIDQCLBH @@H!L0H"H"H$L0H @@IALBH"H"H"D0H @@HQLBH"I"H"D0D @@HSLRH&amp;Y&amp;X"P3@ @@HSABH&amp;UUX"HS@ @@HSABI&amp;U5Y"HS@ @@HSLRH&amp;UUX"H3@ @@HQLBH&amp;Y&amp;X"D0D @@IALBH"I"H"D0H @@H!L0H"H"H!L0H @@H"D3@TH$DSLBH @@H"HSL3DSL3ABH @@H"H!@CL3L@H"H @@H"H"HP@@EBH"H @@H"H"H"H"H"H"H @@'))</body><body package="UIPainter">radioButton20x20bw	"UIMaskEditor new openOnClass: self andSelector: #radioButton20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 255 240 0 254 7 240 0 248 1 240 0 240 0 112 0 224 96 112 0 195 252 48 0 199 254 48 0 135 158 16 0 142 7 16 0 142 7 16 0 140 3 16 0 142 7 16 0 134 6 16 0 199 158 48 0 195 252 48 0 225 248 112 0 240 0 240 0 248 1 240 0 254 3 240 0 255 255 240 0])</body><body package="UIPainter">radioButton20x20mask	"UIMaskEditor new openOnClass: self andSelector: #radioButton20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 1 248 0 0 7 254 0 0 15 255 128 0 31 255 128 0 63 255 192 0 127 255 192 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 192 0 63 255 192 0 31 255 128 0 15 255 128 0 7 254 0 0 1 252 0 0 0 0 0 0])</body><body package="UIPainter">regionWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #regionWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 3) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 4914 scaledBlue: 8191); at: 3 put: Graphics.ColorValue white; yourself)) usingBits: #[170 170 170 170 170 0 0 0 170 170 170 170 170 0 0 0 160 0 0 10 170 0 0 0 161 85 85 74 170 0 0 0 161 85 85 74 170 0 0 0 161 85 85 74 170 0 0 0 161 85 80 2 170 0 0 0 161 85 10 168 42 0 0 0 161 84 42 170 10 0 0 0 161 84 170 170 138 0 0 0 161 82 170 170 162 0 0 0 161 82 170 170 162 0 0 0 161 82 170 170 162 0 0 0 160 2 170 170 162 0 0 0 170 168 170 170 138 0 0 0 170 168 42 170 10 0 0 0 170 170 10 168 42 0 0 0 170 170 160 2 170 0 0 0 170 170 170 170 170 0 0 0 170 170 170 170 170 0 0 0])</body><body package="UIPainter">regionWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #regionWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 63 252 0 0 42 172 0 0 53 84 0 0 42 172 0 0 53 126 0 0 42 193 128 0 53 128 192 0 43 0 64 0 54 0 32 0 42 0 32 0 54 0 32 0 62 0 32 0 1 0 64 0 1 128 192 0 0 193 128 0 0 62 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">regionWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #regionWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 252 0 0 63 254 0 0 63 255 128 0 63 255 192 0 63 255 192 0 63 255 224 0 63 255 224 0 63 255 224 0 63 255 224 0 1 255 192 0 1 255 192 0 0 255 128 0 0 62 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">resizingSplitterWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #resizingSplitterWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 255 240 0 255 207 240 0 255 135 240 0 255 3 240 0 254 1 240 0 252 0 240 0 255 207 240 0 255 207 240 0 255 207 240 0 192 0 16 0 192 0 16 0 255 207 240 0 255 207 240 0 255 207 240 0 252 0 240 0 254 1 240 0 255 3 240 0 255 135 240 0 255 207 240 0 255 255 240 0])</body><body package="UIPainter">resizingSplitterWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #resizingSplitterWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 48 0 0 0 120 0 0 0 252 0 0 1 254 0 0 3 255 0 0 0 48 0 0 0 48 0 0 0 48 0 0 63 255 224 0 63 255 224 0 0 48 0 0 0 48 0 0 0 48 0 0 3 255 0 0 1 254 0 0 0 252 0 0 0 120 0 0 0 48 0 0 0 0 0 0])</body><body package="UIPainter">resizingSplitterWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #resizingSplitterWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 48 0 0 0 120 0 0 0 252 0 0 1 254 0 0 3 255 0 0 0 48 0 0 0 48 0 0 0 48 0 0 63 255 224 0 63 255 224 0 0 48 0 0 0 48 0 0 0 48 0 0 3 255 0 0 1 254 0 0 0 252 0 0 0 120 0 0 0 48 0 0 0 0 0 0])</body><body package="UIPainter">selectOnePalette20x20	"UIMaskEditor new openOnClass: self andSelector: #selectOnePalette20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 255 240 0 255 255 240 0 252 255 240 0 253 127 240 0 253 191 240 0 253 223 240 0 253 239 240 0 253 247 240 0 253 251 240 0 253 253 240 0 253 243 240 0 253 239 240 0 253 55 240 0 252 215 240 0 255 219 240 0 255 235 240 0 255 237 240 0 255 243 240 0 255 255 240 0 255 255 240 0])</body><body package="UIPainter">selectOnePalette20x20bw	"UIMaskEditor new openOnClass: self andSelector: #selectOnePalette20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 3 0 0 0 2 128 0 0 2 64 0 0 2 32 0 0 2 16 0 0 2 8 0 0 2 4 0 0 2 2 0 0 2 12 0 0 2 16 0 0 2 200 0 0 3 40 0 0 0 36 0 0 0 20 0 0 0 18 0 0 0 12 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">selectOnePalette20x20mask	"UIMaskEditor new openOnClass: self andSelector: #selectOnePalette20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 3 0 0 0 3 128 0 0 3 192 0 0 3 224 0 0 3 240 0 0 3 248 0 0 3 252 0 0 3 254 0 0 3 252 0 0 3 240 0 0 3 248 0 0 3 56 0 0 0 60 0 0 0 28 0 0 0 30 0 0 0 12 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">sendBackOne20x20	"UIMaskEditor new openOnClass: self andSelector: #sendBackOne20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 6) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 4 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4227); at: 5 put: Graphics.ColorValue white; at: 6 put: (Graphics.ColorValue scaledRed: 2113 scaledGreen: 2113 scaledBlue: 2113); yourself)) usingBits: (ByteArray fromPackedString: 'QDQDQDQDQDQDQ@@@QDQDQDQDQDQDQ@@@QDQDQDQDQDQDQ@@@QDUUUUUUTDQDQ@@@QDUDQDQDPDQDQ@@@QDUCL3L3HDQDQ@@@QDUCL3L3HDQDQ@@@QDUCL3L3HDQDQ@@@QDUCL5UUUUTDQ@@@QDUCL5DQDQDDQ@@@QDUCL5DQDQDDQ@@@QDUCL5DQDQDDQ@@@QDUBH%DQDQDDQ@@@QD@@@EDQDQDDQ@@@QDQDQEDQDQDDQ@@@QDQDQEDQDQDDQ@@@QDQDQ@@@@@@DQ@@@QDQDQDQDQDQDQ@@@QDQDQDQDQDQDQ@@@QDQDQDQDQDQDQ@@@'))</body><body package="UIPainter">sendBackOne20x20bw	"UIMaskEditor new openOnClass: self andSelector: #sendBackOne20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 31 252 0 0 16 4 0 0 16 4 0 0 16 4 0 0 16 4 0 0 16 255 128 0 16 170 128 0 16 213 128 0 16 170 128 0 16 213 128 0 31 170 128 0 0 213 128 0 0 170 128 0 0 255 128 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">sendBackOne20x20mask	"UIMaskEditor new openOnClass: self andSelector: #sendBackOne20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 31 252 0 0 31 252 0 0 31 252 0 0 31 252 0 0 31 252 0 0 31 255 128 0 31 255 128 0 31 255 128 0 31 255 128 0 31 255 128 0 31 255 128 0 0 255 128 0 0 255 128 0 0 255 128 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">sendForwardOne20x20	"UIMaskEditor new openOnClass: self andSelector: #sendForwardOne20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 7) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 4 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4227); at: 5 put: (Graphics.ColorValue scaledRed: 4756 scaledGreen: 4756 scaledBlue: 4756); at: 6 put: Graphics.ColorValue white; at: 7 put: (Graphics.ColorValue scaledRed: 2113 scaledGreen: 2113 scaledBlue: 2113); yourself)) usingBits: (ByteArray fromPackedString: 'UUUUUUUUUUUUUP@@UUUUUUUUUUUUUP@@UUUUUUUUUUUUUP@@UUY&amp;Y&amp;Y&amp;XEUUUP@@UUYUUUUUTEUUUP@@UUYSL3L3HEUUUP@@UUYSL3L3HEUUUP@@UUYSL3L3HEUUUP@@UUYSL3L3HFXEUP@@UUYSL3L3HDDEUP@@UUYSL3L3HDDEUP@@UUYSL3L3HDDEUP@@UUYRH"H"HDDEUP@@UU@@@@@@@DDEUP@@UUUUUVQDQDDEUP@@UUUUUVDQDQDEUP@@UUUUUP@@@@@EUP@@UUUUUUUUUUUUUP@@UUUUUUUUUUUUUP@@UUUUUUUUUUUUUP@@'))</body><body package="UIPainter">sendForwardOne20x20bw	"UIMaskEditor new openOnClass: self andSelector: #sendForwardOne20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 31 252 0 0 16 4 0 0 16 4 0 0 16 4 0 0 16 4 0 0 16 7 128 0 16 6 128 0 16 5 128 0 16 6 128 0 16 5 128 0 31 254 128 0 0 213 128 0 0 170 128 0 0 255 128 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">sendForwardOne20x20mask	"UIMaskEditor new openOnClass: self andSelector: #sendForwardOne20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 31 252 0 0 31 252 0 0 31 252 0 0 31 252 0 0 31 252 0 0 31 255 128 0 31 255 128 0 31 255 128 0 31 255 128 0 31 255 128 0 31 255 128 0 0 255 128 0 0 255 128 0 0 255 128 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">sendToBottom20x20	"UIMaskEditor new openOnClass: self andSelector: #sendToBottom20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 6) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 4 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4227); at: 5 put: Graphics.ColorValue white; at: 6 put: (Graphics.ColorValue scaledRed: 2113 scaledGreen: 2113 scaledBlue: 2113); yourself)) usingBits: (ByteArray fromPackedString: 'QDQDQDQDQDQDQ@@@QDQDQDQDQDQDQ@@@QEUUUUADQDQDQ@@@QEDQDQADQDQDQ@@@QEDQDQADQDQDQ@@@QEDQDQAUUPQDQ@@@QEDQDQADQ@QDQ@@@QEDQDQ@#L QDQ@@@QEDQDQ@#L QDQ@@@Q@@@@@@#L QDQ@@@QDQEP"IUUUUPQ@@@QDQEP3MQDQDPQ@@@QDQEP3MQDQDPQ@@@QDQEP"IQDQDPQ@@@QDQ@@@AQDQDPQ@@@QDQDQDQQDQDPQ@@@QDQDQDQQDQDPQ@@@QDQDQDP@@@@@Q@@@QDQDQDQDQDQDQ@@@QDQDQDQDQDQDQ@@@'))</body><body package="UIPainter">sendToBottom20x20bw	"UIMaskEditor new openOnClass: self andSelector: #sendToBottom20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 63 192 0 0 42 192 0 0 53 64 0 0 42 254 0 0 53 66 0 0 42 194 0 0 53 66 0 0 63 194 0 0 4 63 192 0 4 42 192 0 4 53 64 0 4 42 192 0 7 245 64 0 0 42 192 0 0 53 64 0 0 63 192 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">sendToBottom20x20mask	"UIMaskEditor new openOnClass: self andSelector: #sendToBottom20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 63 192 0 0 63 192 0 0 63 192 0 0 63 254 0 0 63 254 0 0 63 254 0 0 63 254 0 0 63 254 0 0 7 255 192 0 7 255 192 0 7 255 192 0 7 255 192 0 7 255 192 0 0 63 192 0 0 63 192 0 0 63 192 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">sendToTop20x20	"UIMaskEditor new openOnClass: self andSelector: #sendToTop20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 7) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 4 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4227); at: 5 put: (Graphics.ColorValue scaledRed: 4756 scaledGreen: 4756 scaledBlue: 4756); at: 6 put: Graphics.ColorValue white; at: 7 put: (Graphics.ColorValue scaledRed: 2113 scaledGreen: 2113 scaledBlue: 2113); yourself)) usingBits: (ByteArray fromPackedString: 'UUUUUUUUUUUUUP@@UUUUUUUUUUUUUP@@UVY&amp;Y&amp;AUUUUUUP@@UVDQDQAUUUUUUP@@UVDQDQAUUUUUUP@@UVDVY&amp;Y&amp;Y UUUP@@UVDVUUUUUPUUUP@@UVDVT3L3L UUUP@@UVDVT3L3L UUUP@@UP@FT3L3L UUUP@@UUUVT3L3L Y UP@@UUUVT3L3L PPUP@@UUUVT3L3L PPUP@@UUUVT"H"H PPUP@@UUUP@@@@@@PPUP@@UUUUUUU$QDPPUP@@UUUUUUU!DQDPUP@@UUUUUUT@@@@@UP@@UUUUUUUUUUUUUP@@UUUUUUUUUUUUUP@@'))</body><body package="UIPainter">sendToTop20x20bw	"UIMaskEditor new openOnClass: self andSelector: #sendToTop20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 63 192 0 0 42 192 0 0 53 64 0 0 47 254 0 0 52 2 0 0 44 2 0 0 52 2 0 0 60 2 0 0 4 3 192 0 4 2 192 0 4 3 64 0 4 2 192 0 7 255 64 0 0 42 192 0 0 53 64 0 0 63 192 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">sendToTop20x20mask	"UIMaskEditor new openOnClass: self andSelector: #sendToTop20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 63 192 0 0 63 192 0 0 63 192 0 0 63 254 0 0 63 254 0 0 63 254 0 0 63 254 0 0 63 254 0 0 7 255 192 0 7 255 192 0 7 255 192 0 7 255 192 0 7 255 192 0 0 63 192 0 0 63 192 0 0 63 192 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">sequenceViewWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #sequenceViewWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 4) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 4914 scaledBlue: 8191); at: 3 put: Graphics.ColorValue blue; at: 4 put: Graphics.ColorValue white; yourself)) usingBits: #[255 255 255 255 255 0 0 0 192 0 0 0 3 0 0 0 207 255 255 252 243 0 0 0 207 255 255 252 243 0 0 0 204 0 0 12 3 0 0 0 207 255 255 252 83 0 0 0 207 255 255 252 83 0 0 0 202 170 170 168 83 0 0 0 202 255 255 232 83 0 0 0 202 170 170 168 83 0 0 0 207 255 255 252 83 0 0 0 207 255 255 252 83 0 0 0 204 0 0 12 83 0 0 0 207 255 255 252 83 0 0 0 207 255 255 252 83 0 0 0 204 0 0 12 3 0 0 0 207 255 255 252 243 0 0 0 207 255 255 252 243 0 0 0 192 0 0 0 3 0 0 0 255 255 255 255 255 0 0 0])</body><body package="UIPainter">sequenceViewWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #sequenceViewWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 255 224 0 64 1 32 0 64 1 32 0 95 253 224 0 64 1 224 0 64 1 224 0 127 255 224 0 112 7 224 0 127 255 224 0 64 1 224 0 64 1 224 0 95 253 224 0 64 1 224 0 64 1 224 0 95 253 224 0 64 1 32 0 64 1 32 0 127 255 224 0 0 0 0 0])</body><body package="UIPainter">sequenceViewWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #sequenceViewWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 0 0 0 0])</body><body package="UIPainter">sliderWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #sliderWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue red; at: 3 put: (Graphics.ColorValue scaledRed: 5460 scaledGreen: 5460 scaledBlue: 5460); at: 4 put: Graphics.ColorValue white; at: 5 put: (Graphics.ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3@3LCL0L3@3L0@@L3@3LCL0L3@3L0@@L3@3LCL0L3@3L0@@L3L3L3L3L3L3L0@@L3L3L3D3L3L3L0@@L3L3L1D#L3L3L0@@@@@@AAD P@@@@0@@ADQDQAD QDQD@0@@@"H"H!D H"H"@0@@@@@@AAD P@@@@0@@MDQDQBH QDQDP0@@L3L3L0@@L3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@'))</body><body package="UIPainter">sliderWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #sliderWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 17 17 0 0 17 17 0 0 17 17 0 0 0 0 0 0 0 64 0 0 0 192 0 0 255 223 224 0 213 213 96 0 128 208 32 0 255 223 224 0 85 26 160 0 0 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">sliderWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #sliderWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 17 17 0 0 17 17 0 0 17 17 0 0 0 0 0 0 0 64 0 0 0 224 0 0 255 255 224 0 255 255 224 0 255 255 224 0 255 255 224 0 127 255 224 0 0 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">sourceCodeEditorWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #sourceCodeEditorWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: ((Image extent: 20@20 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 2537 4882)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[170 170 170 170 170 0 0 0 149 85 85 85 86 0 0 0 149 85 85 85 86 0 0 0 150 166 106 85 86 0 0 0 150 150 90 85 86 0 0 0 150 150 90 85 86 0 0 0 150 150 90 85 86 0 0 0 150 150 90 85 86 0 0 0 150 166 106 85 86 0 0 0 149 85 85 85 86 0 0 0 149 85 85 68 86 0 0 0 150 166 106 81 86 0 0 0 150 150 90 81 86 0 0 0 150 150 90 81 86 0 0 0 150 150 90 81 86 0 0 0 150 150 90 81 86 0 0 0 150 166 106 81 86 0 0 0 149 85 85 68 86 0 0 0 149 85 85 85 86 0 0 0 170 170 170 170 170 0 0 0]))</body><body package="UIPainter">sourceCodeEditorWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #sourceCodeEditorWidget20x20bw"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 240 0 128 0 16 0 128 0 16 0 157 112 16 0 153 48 16 0 153 48 16 0 153 48 16 0 153 48 16 0 157 112 16 0 128 0 16 0 128 5 16 0 157 114 16 0 153 50 16 0 153 50 16 0 153 50 16 0 153 50 16 0 157 114 16 0 128 5 16 0 128 0 16 0 255 255 240 0])</body><body package="UIPainter">sourceCodeEditorWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #sourceCodeEditorWidget20x20mask"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0])</body><body package="UIPainter">spinButtonWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #spinButtonWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 5460 scaledGreen: 5460 scaledBlue: 5460); at: 3 put: Graphics.ColorValue blue; at: 4 put: Graphics.ColorValue white; at: 5 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4111); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@@@@@@@@@@@@@@@@@@3L3L3L3L3D1L@@@@2L2H"L"H#MDD@@@@2L2L2L3L#QDP@@@@2L2H"L3H3LSD@@@@2L3L2L2L3D1L@@@@2L3L2L2L3QDP@@@@2L2H"L2L3EDL@@@@3L3L3L3L3LSD@@@@@@@@@@@@@@@@@@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@'))</body><body package="UIPainter">spinButtonWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #spinButtonWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 255 255 240 0 128 0 16 0 167 188 208 0 164 133 240 0 167 136 16 0 160 144 16 0 160 145 240 0 167 144 208 0 128 0 16 0 255 255 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">spinButtonWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #spinButtonWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">stickyPalette20x20	"UIMaskEditor new openOnClass: self andSelector: #stickyPalette20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue white; at: 3 put: (Graphics.ColorValue scaledRed: 4227 scaledGreen: 4227 scaledBlue: 4227); at: 4 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 5 put: (Graphics.ColorValue scaledRed: 2113 scaledGreen: 2113 scaledBlue: 2113); yourself)) usingBits: (ByteArray fromPackedString: 'DQDQDQDQDQDQDP@@DQDQDQDQDQDQDP@@DQ@@@@@@@QDQDP@@DQ@QDQDQ@QDQDP@@DQ@SL3L2@QDQDP@@DQ@SQDQD@@@QDP@@DQ@SPQDQDQ@QDP@@DQ@RPSL3L2@QDP@@DQ@@@SL3L2@QDP@@DQDQ@SL@L2@QDP@@DQDQ@RHA@"@QDP@@DQDQ@@@AD@@QDP@@DQDQDQDADPDQDP@@DQDQDQDADQ@QDP@@DQDQDQDADPDQDP@@DQDQDQDA@PDQDP@@DQDQDQD@DA@QDP@@DQDQDQDQDA@QDP@@DQDQDQDQDPDQDP@@DQDQDQDQDQDQDP@@'))</body><body package="UIPainter">stickyPalette20x20bw	"UIMaskEditor new openOnClass: self andSelector: #stickyPalette20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 31 248 0 0 16 8 0 0 16 8 0 0 19 255 0 0 18 1 0 0 18 1 0 0 30 1 0 0 2 49 0 0 2 41 0 0 3 231 0 0 0 34 0 0 0 33 0 0 0 34 0 0 0 42 0 0 0 53 0 0 0 5 0 0 0 2 0 0 0 0 0 0])</body><body package="UIPainter">stickyPalette20x20mask	"UIMaskEditor new openOnClass: self andSelector: #stickyPalette20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 31 248 0 0 31 248 0 0 31 248 0 0 31 255 0 0 31 255 0 0 31 255 0 0 31 255 0 0 3 255 0 0 3 255 0 0 3 255 0 0 0 62 0 0 0 63 0 0 0 62 0 0 0 62 0 0 0 55 0 0 0 7 0 0 0 2 0 0 0 0 0 0])</body><body package="UIPainter">subCanvasWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #subCanvasWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue blue; at: 3 put: (Graphics.ColorValue scaledRed: 7644 scaledGreen: 0 scaledBlue: 0); at: 4 put: Graphics.ColorValue white; at: 5 put: (Graphics.ColorValue scaledRed: 6006 scaledGreen: 6006 scaledBlue: 6006); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L0@@L@@@@@@@@@@@@0@@LADQDQDQDQDQ@0@@L@@@@@@@@@@@@0@@LCL3L3L3L3L3@0@@LCL3L3L3L3L3@0@@LC@@L3L0@@@C@0@@LC@ L@@0L3LC@0@@LC@@L3L0L3LC@0@@LCL3L3L0L3LC@0@@LC@@L3L0L3LC@0@@LC@0L@@0L3LC@0@@LC@@L3L0@@@C@0@@LCL3L3L3L3L3@0@@LC@@@@L0@@@C@0@@LC@4Q@L0MDPC@0@@LC@@@@L0@@@C@0@@LCL3L3L3L3L3@0@@L@@@@@@@@@@@@0@@L3L3L3L3L3L3L0@@'))</body><body package="UIPainter">subCanvasWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #subCanvasWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 255 224 0 64 0 32 0 127 255 224 0 64 0 32 0 64 0 32 0 92 31 160 0 85 208 160 0 92 16 160 0 64 16 160 0 92 16 160 0 85 208 160 0 92 31 160 0 64 0 32 0 95 159 160 0 80 144 160 0 95 159 160 0 64 0 32 0 127 255 224 0 0 0 0 0])</body><body package="UIPainter">subCanvasWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #subCanvasWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 0 0 0 0])</body><body package="UIPainter">tabControlWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #tabControlWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: (Graphics.ColorValue scaledRed: 5460 scaledGreen: 5460 scaledBlue: 5460); at: 2 put: Graphics.ColorValue black; at: 3 put: (Graphics.ColorValue scaledRed: 6552 scaledGreen: 6552 scaledBlue: 6552); at: 4 put: Graphics.ColorValue white; at: 5 put: (Graphics.ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 4111); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L@@DD3L3L3L3L0@@LBH$D@@DD0@@PP@@LBH$DBH$D0H"PP@@LBH$L3L3L3L3PP@@LBH"H"H"H"H"PP@@LBH"H"H"H"H"PP@@LBH"H"H"H"H"PP@@LBH"H"H"H"H"PP@@LBH"H"H"H"H"PP@@LBH"H"H"H"H"PP@@LBH"H"H"H"H"PP@@LBH"H"H"H"H"PP@@LBH"H"H"H"H"PP@@LBH"H"H"H"H"PP@@MDQDQDQDQDQDPP@@LQDQDQDQDQDQDP@@L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@'))</body><body package="UIPainter">tabControlWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #tabControlWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 126 0 0 0 67 255 240 0 67 12 48 0 67 12 48 0 67 12 48 0 64 0 48 0 64 0 48 0 64 0 48 0 64 0 48 0 64 0 48 0 64 0 48 0 64 0 48 0 64 0 48 0 64 0 48 0 127 255 240 0 127 255 240 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">tabControlWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #tabControlWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 126 0 0 0 127 255 240 0 127 255 240 0 127 255 240 0 127 255 240 0 127 255 240 0 127 255 240 0 127 255 240 0 127 255 240 0 127 255 240 0 127 255 240 0 127 255 240 0 127 255 240 0 127 255 240 0 127 255 240 0 127 255 240 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">tableViewWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #tableViewWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 4) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4368); at: 3 put: (Graphics.ColorValue scaledRed: 5460 scaledGreen: 5460 scaledBlue: 5460); at: 4 put: Graphics.ColorValue white; yourself)) usingBits: #[255 255 255 255 255 0 0 0 255 255 255 255 255 0 0 0 255 195 240 252 63 0 0 0 255 255 255 255 255 0 0 0 252 0 0 0 3 0 0 0 252 255 127 223 243 0 0 0 12 235 122 222 179 0 0 0 252 255 127 223 243 0 0 0 252 85 85 85 83 0 0 0 252 255 127 223 243 0 0 0 12 235 122 222 179 0 0 0 252 255 127 223 243 0 0 0 252 85 85 85 83 0 0 0 252 255 127 223 243 0 0 0 12 235 122 222 179 0 0 0 252 255 127 223 243 0 0 0 252 0 0 0 3 0 0 0 255 255 255 255 255 0 0 0 255 255 255 255 255 0 0 0 255 255 255 255 255 0 0 0])</body><body package="UIPainter">tableViewWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #tableViewWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 6 49 128 0 0 0 0 0 31 255 224 0 16 132 32 0 214 181 160 0 16 132 32 0 31 255 224 0 16 132 32 0 214 181 160 0 16 132 32 0 31 255 224 0 16 132 32 0 214 181 160 0 16 132 32 0 31 255 224 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">tableViewWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #tableViewWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 6 49 128 0 0 0 0 0 31 255 224 0 31 255 224 0 223 255 224 0 31 255 224 0 31 255 224 0 31 255 224 0 223 255 224 0 31 255 224 0 31 255 224 0 31 255 224 0 223 255 224 0 31 255 224 0 31 255 224 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">textEditorWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #textEditorWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 3) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4111); at: 3 put: Graphics.ColorValue white; yourself)) usingBits: #[0 0 0 0 0 0 0 0 42 170 170 170 168 0 0 0 42 166 170 170 168 0 0 0 41 101 150 170 168 0 0 0 41 101 150 85 104 0 0 0 42 170 170 170 168 0 0 0 42 170 170 170 168 0 0 0 41 105 86 149 104 0 0 0 42 170 170 170 168 0 0 0 42 170 170 170 168 0 0 0 41 85 85 85 104 0 0 0 42 170 170 170 168 0 0 0 42 170 170 170 168 0 0 0 41 85 165 85 104 0 0 0 42 170 170 170 168 0 0 0 42 170 170 162 168 0 0 0 41 85 90 128 168 0 0 0 42 170 170 0 40 0 0 0 42 170 170 170 168 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">textEditorWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #textEditorWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 240 0 128 0 16 0 130 0 16 0 155 96 16 0 155 111 144 0 128 0 16 0 128 0 16 0 153 231 144 0 128 0 16 0 128 0 16 0 159 255 144 0 128 0 16 0 128 0 16 0 159 63 144 0 128 0 16 0 128 2 16 0 159 199 16 0 128 15 144 0 128 0 16 0 255 255 240 0])</body><body package="UIPainter">textEditorWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #textEditorWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0 255 255 240 0])</body><body package="UIPainter">treeViewWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #treeViewWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 4) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue red; at: 3 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 4914 scaledBlue: 8191); at: 4 put: Graphics.ColorValue white; yourself)) usingBits: #[255 255 255 255 255 0 0 0 192 0 0 0 3 0 0 0 207 255 255 252 243 0 0 0 205 255 255 252 243 0 0 0 197 64 0 60 3 0 0 0 205 255 255 252 163 0 0 0 207 223 255 252 163 0 0 0 207 84 0 60 163 0 0 0 207 223 255 252 163 0 0 0 207 255 127 252 163 0 0 0 207 253 80 60 163 0 0 0 207 255 127 252 163 0 0 0 205 255 255 252 163 0 0 0 197 64 0 60 163 0 0 0 205 255 255 252 163 0 0 0 207 223 255 252 3 0 0 0 207 84 0 60 243 0 0 0 207 223 255 252 243 0 0 0 192 0 0 0 3 0 0 0 255 255 255 255 255 0 0 0])</body><body package="UIPainter">treeViewWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #treeViewWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 255 224 0 64 1 32 0 80 1 32 0 127 249 224 0 80 1 96 0 68 1 160 0 79 249 96 0 68 1 160 0 64 129 96 0 65 249 160 0 64 129 96 0 80 1 160 0 127 249 96 0 80 1 160 0 68 1 224 0 79 249 32 0 68 1 32 0 127 255 224 0 0 0 0 0])</body><body package="UIPainter">treeViewWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #treeViewWidget20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 127 255 224 0 0 0 0 0])</body><body package="UIPainter">unknownWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #unknownWidget20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue blue; at: 2 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4111); at: 3 put: Graphics.ColorValue white; at: 4 put: (Graphics.ColorValue scaledRed: 2055 scaledGreen: 0 scaledBlue: 8191); at: 5 put: (Graphics.ColorValue scaledRed: 4111 scaledGreen: 4111 scaledBlue: 8191); yourself)) usingBits: (ByteArray fromPackedString: 'H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H!L4H"H"H @@H"H"HP@@P"H"H @@H"H"D@@@ABH"H @@H"H!@DH ABH"H @@H"H"H"HPABH"H @@H"H"H!@@P"H"H @@H"H"HP@DH"H"H @@H"H"HPABH"H"H @@H"H"HSMBH"H"H @@H"H"H"H"H"H"H @@H"H"H#L"H"H"H @@H"H"HPABH"H"H @@H"H"HPABH"H"H @@H"H"H$P"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@H"H"H"H"H"H"H @@'))</body><body package="UIPainter">unknownWidget20x20bw	"UIMaskEditor new openOnClass: self andSelector: #unknownWidget20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 255 240 0 255 255 240 0 255 255 240 0 255 15 240 0 254 7 240 0 252 3 240 0 248 99 240 0 255 195 240 0 255 7 240 0 254 15 240 0 254 31 240 0 254 31 240 0 255 255 240 0 255 63 240 0 254 31 240 0 254 31 240 0 255 63 240 0 255 255 240 0 255 255 240 0 255 255 240 0])</body><body package="UIPainter">unknownWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #unknownWidget20x20mask"	&lt;resource: #image&gt;	^(Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 240 0 0 1 248 0 0 3 252 0 0 7 156 0 0 0 60 0 0 0 248 0 0 1 240 0 0 1 224 0 0 1 224 0 0 0 0 0 0 0 192 0 0 1 224 0 0 1 224 0 0 0 192 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="UIPainter">verticalDistribution20x20	"UIMaskEditor new openOnClass: self andSelector: #verticalDistribution20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4227); at: 3 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); at: 4 put: Graphics.ColorValue white; at: 5 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L0@@@@@@L3L3L0@@L0L3L3L0L3MCL0@@L0LQDQD MDQDL0@@L0L"H"H L3MCL0@@L0@@@@@@L3MCL0@@L3L3L3L3L3MCL0@@L0@@@@@@L3MCL0@@L0L3L3L0L3MCL0@@L0LQDQD MDQDL0@@L0L"H"H L3MCL0@@L0@@@@@@L3MCL0@@L3L3L3L3L3MCL0@@L0@@@@@@L3MCL0@@L0L3L3L0L3MCL0@@L0LQDQD MDQDL0@@L0L"H"H L3MCL0@@L0@@@@@@L3L3L0@@L3L3L3L3L3L3L0@@'))</body><body package="UIPainter">verticalDistribution20x20bw	"UIMaskEditor new openOnClass: self andSelector: #verticalDistribution20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 63 240 0 0 32 16 128 0 32 23 192 0 32 16 128 0 63 240 128 0 0 0 128 0 63 240 128 0 32 16 128 0 32 23 192 0 32 16 128 0 63 240 128 0 0 0 128 0 63 240 128 0 32 16 128 0 32 23 192 0 32 16 128 0 63 240 0 0 0 0 0 0])</body><body package="UIPainter">verticalDistribution20x20mask	"UIMaskEditor new openOnClass: self andSelector: #verticalDistribution20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 63 240 0 0 63 240 128 0 63 247 192 0 63 240 128 0 63 240 128 0 0 0 128 0 63 240 128 0 63 240 128 0 63 247 192 0 63 240 128 0 63 240 128 0 0 0 128 0 63 240 128 0 63 240 128 0 63 247 192 0 63 240 128 0 63 240 0 0 0 0 0 0])</body><body package="UIPainter">verticalSpacing20x20	"UIMaskEditor new openOnClass: self andSelector: #verticalSpacing20x20"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 8191 scaledGreen: 8191 scaledBlue: 4227); at: 3 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); at: 4 put: Graphics.ColorValue white; at: 5 put: (Graphics.ColorValue scaledRed: 6869 scaledGreen: 6869 scaledBlue: 6869); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L0@@L3L3L3L3L3L3L0@@L0@@@@@@L3L3L0@@L0L3L3L0L3L3L0@@L0LQDQE@L3L3L0@@L0MDQDQ@L3L#L0@@L0@@@@@@L"H"L0@@L3L3L3L3L3L#L0@@L0@@@@@@L"H"L0@@L0L3L3L0L3L#L0@@L0LQDQE@L3L3L0@@L0MDQDQ@L3L#L0@@L0@@@@@@L"H"L0@@L3L3L3L3L3L#L0@@L0@@@@@@L"H"L0@@L0L3L3L0L3L#L0@@L0LQDQE@L3L3L0@@L0MDQDQ@L3L3L0@@L0@@@@@@L3L3L0@@L3L3L3L3L3L3L0@@'))</body><body package="UIPainter">verticalSpacing20x20bw	"UIMaskEditor new openOnClass: self andSelector: #verticalSpacing20x20bw"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 63 240 0 0 32 16 0 0 32 16 0 0 32 16 128 0 63 247 192 0 0 0 128 0 63 247 192 0 32 16 128 0 32 16 0 0 32 16 128 0 63 247 192 0 0 0 128 0 63 247 192 0 32 16 128 0 32 16 0 0 32 16 0 0 63 240 0 0 0 0 0 0])</body><body package="UIPainter">verticalSpacing20x20mask	"UIMaskEditor new openOnClass: self andSelector: #verticalSpacing20x20mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 20@20 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 63 240 0 0 63 240 0 0 63 240 0 0 63 240 128 0 63 247 192 0 0 0 128 0 63 247 192 0 63 240 128 0 63 240 0 0 63 240 128 0 63 247 192 0 0 0 128 0 63 247 192 0 63 240 128 0 63 240 0 0 63 240 0 0 63 240 0 0 0 0 0 0])</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-painter</category><body package="UIPainter">painter10MaximumCanvasWidth	&lt;setting: #(tools painter maximumCanvasWidth)&gt;	^((IntegerSetting min: 20) 			onUISetting: #maximumCanvasWidth)		default: 1024;		label: #MaximumCanvasWidth &lt;&lt; #labels &gt;&gt; 'Maximum canvas width';		helpText: #MaximumCanvasWidthHelpText &lt;&lt; #dialogs &gt;&gt; 'The maximum width for opening a canvas for painting.  This can be used to ensure that your application windows will fit on a screen that is smaller than your development machine''s screen.  It does not affect the maximum size for opening the window of a running application, it merely forces application developers to design within certain size limits.'</body><body package="UIPainter">painter20MaximumCanvasHeight	&lt;setting: #(tools painter maximumCanvasHeight)&gt;	^((IntegerSetting min: 20) 			onUISetting: #maximumCanvasHeight)		default: 768;		label: #MaximumCanvasHeight &lt;&lt; #labels &gt;&gt; 'Maximum canvas height';		helpText: #MaximumCanvasHeightHelpText &lt;&lt; #dialogs &gt;&gt; 'The maximum height for opening a canvas for painting.'</body><body package="UIPainter">painter30initialGridMode	&lt;setting: #(tools painter initialGridMode)&gt;	^((EnumerationSetting 				choices: #(Off On #'X Only' #'Y Only')				labels: (Array with: (#Off &lt;&lt; #UIPainter &gt;&gt; 'Off') with: (#On &lt;&lt; #UIPainter &gt;&gt; 'On') with: (#XOnly &lt;&lt; #UIPainter &gt;&gt; 'X Only') with: (#YOnly &lt;&lt; #UIPainter &gt;&gt; 'Y Only')))			onUISetting: #initialGridMode)		default: #Off;		label: #InitialGridMode &lt;&lt; #labels &gt;&gt; 'Grid:';		helpText: #InitialGridModeHelpText &lt;&lt; #dialogs &gt;&gt; 'The Initial Grid Settings affect the behavior of canvas gridding. "Off" allows you to place components anywhere.  "On", "X Only", and "Y Only" will force a component to be aligned with the grid, whose size in pixels is determined by the Size: field.  "Show If On", "Show" and "Hide" control the visibility of the grid.'</body><body package="UIPainter">painter35initialGridDisplay	&lt;setting: #(tools painter initialGridDisplay)&gt;	^((EnumerationSetting				choices: #(#Hide #Show #'Show If On' )				labels: (Array with: (#Hide &lt;&lt; #UIPainter &gt;&gt; 'Hide') with: (#Show &lt;&lt; #UIPainter &gt;&gt; 'Show') with: (#ShowIfOn &lt;&lt; #UIPainter &gt;&gt; 'Show If On')))			onUISetting: #initialGridDisplay)		default: #'Show If On';		label: #InitialGridDisplay &lt;&lt; #labels &gt;&gt; 'Grid display';		helpText: #InitialGridDisplayHelpText &lt;&lt; #dialogs &gt;&gt; 'This setting controls the visibility of the grid.'</body><body package="UIPainter">painter40gridSize	&lt;setting: #(tools painter gridSize)&gt;	^((IntegerSetting min: 1) 			onUISetting: #initialGridSize)		default: 8;		label: #DefaultGridSize &lt;&lt; #labels &gt;&gt; 'Default grid size';		helpText: #DefaultGridSizeHelpText &lt;&lt; #dialogs &gt;&gt; 'The size of one cell of the grid.'</body><body package="UIPainter">painter50placementFeel	&lt;setting: #(tools painter placementFeel)&gt;	^((EnumerationSetting 				choices: #(#DragPlacementModeTracker #SelectPlacementModeTracker)				labels: (Array with: (#Released &lt;&lt; #UIPainter &gt;&gt; 'Released') with: (#HeldDown &lt;&lt; #UIPainter &gt;&gt; 'Held Down')))			onUISetting: #placementFeel)		label: #PlaceWidgetsWithButton &lt;&lt; #labels &gt;&gt; 'Place widgets with button';		helpText: #PlaceWindowsWithButtonHelpText &lt;&lt; #dialogs &gt;&gt; 'This setting controls the behavior of interface components when you select them from a Palette and drop them in a canvas.  By default ("Released"), the component is visible even before you click in the canvas (unless you have click-to-raise turned on in your window manager''s settings), and if you hold down the mouse button you can resize it in the same gesture.  The alternative setting ("Held Down") is better on slower machines - the componet remains invisible until you click in the canvas, and holding the mouse button down lets you relocate the component rather than resize it.'</body><body package="UIPainter">painter60avoidInstallationDialog	&lt;setting: #(tools painter avoidInstallationDialog)&gt;	^(BooleanSetting onUISetting: #avoidInstallationDialog)		default: false;		label: #AvoidInstallationDialog &lt;&lt; #labels &gt;&gt; 'Avoid installation dialog when possible';		helpText: #AvoidInstallationDialogHelpText &lt;&lt; #dialogs &gt;&gt; 'By default, each time you use the "install" command for a canvas, you are prompted to confirm the class and selector on which to install it.  You may wish to bypass the confirmation when you are merely reinstalling a canvas on the same class and selector.  To do so, turn on "Avoid Installation Dialog".  On the occasions when you specifically want the dialog, prehaps to transfer a canvas to a different class, hold a &lt;Shift&gt; key down while selecting the "install" command.'</body><body package="UIPainter">painter60installForDefine	&lt;setting: #(tools painter installForDefine)&gt;	^(BooleanSetting onUISetting: #installForDefine)		default: false;		label: #AutoInstallWhenDefining &lt;&lt; #labels &gt;&gt; 'Auto-install when defining';		helpText: #AutoInstallWhenDefiningHelpText &lt;&lt; #dialogs &gt;&gt; 'The "define" and "open" commands operate on canvas as it was last installed.  When you forget to "install" a changed canvas before using those commands, a warning dialog asks whether you want to "install" first.  To arrange for a changed canvas to be automatically reinstalled during the "define" operation, turn on this setting.'</body><body package="UIPainter">painter60installForOpen	&lt;setting: #(tools painter installForOpen)&gt;	^(BooleanSetting onUISetting: #installForOpen)		default: false;		label: #AutoInstallWhenOpening &lt;&lt; #labels &gt;&gt; 'Auto-install when opening';		helpText: #AutoInstallWhenOpeningHelpText &lt;&lt; #dialogs &gt;&gt; 'To arrange for a changed canvas to be automatically reinstalled during the "open" operation, turn on this setting.'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="UIPainter">uiPainterPage	&lt;settingsPage: #(tools painter)&gt;	^ModularSettingsPage new		label: #UIPainter &lt;&lt; #labels &gt;&gt; 'UI Painter';		icon: (ListIconLibrary visualFor: #canvas);		settings: (self settingsWithPrefix: #(tools painter))</body></methods><methods><class-id>UI.CompositeSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 300 180 ) 			#max: #(#Point 300 180 ) 			#bounds: #(#Rectangle 129 294 429 474 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Composite #defaultString: 'Composite' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 60 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 86 0 33 0 -10 1 58 0 ) 					#model: #name 					#menu: #fieldMenu ) ) ) )</body><body package="UIPainter">detailsEditSpec	"UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 204 83 ) 			#max: #(#Point 238 186 ) 			#bounds: #(#Rectangle 141 308 379 494 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 26 0 -10 1 78 0 ) 					#label: #(#{Kernel.UserMessage} #key: #ScrollBars #defaultString: 'Scroll Bars' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Composite #defaultString: 'Composite' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 20 46 ) 					#model: #hasHorizontalScrollBar 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Horizontal #defaultString: 'Horizontal' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 135 45 ) 					#model: #hasVerticalScrollBar 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Vertical #defaultString: 'Vertical' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 84 ) 					#model: #hasBorder 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Bordered #defaultString: 'Bordered' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 108 ) 					#model: #isOpaque 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Opaque #defaultString: 'Opaque' #catalogID: #UIPainter) ) ) ) )</body></methods><methods><class-id>UI.CheckBoxSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpecLiteral	"UIPainter new openOnClass: self andSelector: #basicsEditSpecLiteral"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 299 240 ) 			#max: #(#{Core.Point} 299 240 ) 			#bounds: #(#{Graphics.Rectangle} 651 480 950 720 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #CheckBox #defaultString: 'Check Box' #catalogID: #UIPainter) ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 28 0 -10 1 59 0 ) 					#flags: 0 					#minorKey: #labelConstructorSpec 					#clientKey: #labelConstructor ) 				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} 86 0 60 0 -10 1 85 0 ) 					#name: #modelField 					#model: #model 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#validAspectSelector:  ) 					#menu: #fieldMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 92 0 -10 1 117 0 ) 					#model: #name 					#menu: #fieldMenu ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 124 ) 					#model: #hasImageOrientedLabel 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #LabelIsImage #defaultString: 'Label Is Image' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 86 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #AspectC #defaultString: 'Aspect:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 118 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">detailsEditSpec	"UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 299 240 ) 			#max: #(#{Core.Point} 299 240 ) 			#bounds: #(#{Graphics.Rectangle} 651 480 950 720 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 58 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #FontC #defaultString: 'Font:' #catalogID: #UIPainter) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 35 0 -10 1 57 0 ) 					#model: #style 					#menu: #fontMenu ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 72 ) 					#model: #tabable 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #CanTab #defaultString: 'Can Tab' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 92 ) 					#model: #initiallyDisabled 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyDisabled #defaultString: 'Initially Disabled' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 113 ) 					#model: #initiallyInvisible 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyInvisible #defaultString: 'Initially Invisible' #catalogID: #UIPainter) ) ) ) )</body></methods><methods><class-id>UI.CheckBoxSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 6) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); at: 3 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 3822 scaledGreen: 0 scaledBlue: 0); at: 6 put: (ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 3822); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@L3L3L3L3L3L3L3L2@@@@@CDQDQDQDQDQDQDQD @@@@@1DQDQDQDQDQDQDQH@@@@@LQDQDQDQDQDQDQDR@@@@@CDQDQDQDQDQDQDQD @@@@@1DQDQDQDQDQDQDQH@@@@@LQDQDQDQDQDQDQDR@@@@@CDQDQDQDQDQDQDQD @@@@@1DP@@@@@ADQDQDQH@@@@@LQDCL3L3@QDQDQDR@@@@@CDQ@4L3P0DQDQDQD @@@@@1DPMDMDLADQDQDQH@@@@@LQDCMDP3@QL3D3LR@@@@@CDQ@4P4P0DUUQUUD @@@@@1DPMCL4LADQDQDQH@@@@@LQDCL3L3@QDQDQDR@@@@@CDQ@@@@@@DQDQDQD @@@@@1DQDQDQDQDQDQDQH@@@@@LQDQDQDQDQDQDQDR@@@@@CDQDQDQDQDQDQDQD @@@@@1DQDQDQDQDQDQDQH@@@@@LQDQDQDQDQDQDQDR@@@@@CDQDQDQDQDQDQDQD @@@@@"H"H"H"H"H"H"H"H@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 135 252 0 192 132 4 0 192 133 20 0 192 133 180 0 192 132 228 0 192 133 180 238 192 133 20 0 192 132 4 0 192 135 252 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192 ])</body></methods><methods><class-id>UI.TextEditorSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 242 147 ) 			#max: #(#{Core.Point} 300 316 ) 			#bounds: #(#{Graphics.Rectangle} 650 442 950 758 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} 86 0 28 0 -10 1 53 0 ) 					#name: #modelField 					#model: #model 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#validAspectSelector: ) 					#menu: #fieldMenu ) 				#(#{UI.InputFieldSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: ) 					#layout: #(#{Graphics.LayoutFrame} 86 0 60 0 -10 1 85 0 ) 					#name: #menuField 					#model: #menu 					#menu: #fieldMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 92 0 -10 1 117 0 ) 					#model: #name 					#menu: #fieldMenu ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #TextEditor #defaultString: 'Text Editor' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 94 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 30 ) 					#label: #(#{Kernel.UserMessage} #key: #AspectC #defaultString: 'Aspect:' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 62 ) 					#label: #(#{Kernel.UserMessage} #key: #Menu #defaultString: 'Menu:' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">detailsEditSpec	"Tools.UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 236 293 ) 			#max: #(#{Core.Point} 240 293 ) 			#bounds: #(#{Graphics.Rectangle} -394 527 -154 820 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 21 0 -10 1 69 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #ScrollBars 						#defaultString: 'Scroll Bars' 						#catalogID: #UIPainter ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 104 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #AlignC 						#defaultString: 'Align:' 						#catalogID: #UIPainter ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 77 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #FontC 						#defaultString: 'Font:' 						#catalogID: #UIPainter ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 20 40 ) 					#model: #hasHorizontalScrollBar 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #Horizontal 						#defaultString: 'Horizontal' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.5 40 0 ) 					#model: #hasVerticalScrollBar 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #Vertical 						#defaultString: 'Vertical' 						#catalogID: #UIPainter ) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 75 0 -10 1 99 0 ) 					#model: #style 					#menu: #fontMenu ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 103 0 -10 1 127 0 ) 					#model: #alignment 					#menu: #alignmentMenu ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 158 ) 					#model: #hasBorder 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #Bordered 						#defaultString: 'Bordered' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 179 ) 					#model: #isOpaque 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #Opaque 						#defaultString: 'Opaque' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 200 ) 					#model: #tabable 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #CanTab 						#defaultString: 'Can Tab' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 92 179 ) 					#model: #tabRequiresControl 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #TabRequiresControlKey 						#defaultString: 'Tab Requires Control Key' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 221 ) 					#model: #isReadOnly 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #ReadOnly 						#defaultString: 'Read Only' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 242 ) 					#model: #initiallyDisabled 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #InitiallyDisabled 						#defaultString: 'Initially Disabled' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 263 ) 					#model: #initiallyInvisible 					#tabable: true 					#label: 					#(#{Kernel.UserMessage} 						#key: #InitiallyInvisible 						#defaultString: 'Initially Invisible' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 92 200 ) 					#model: #isWrapped 					#label: 					#(#{Kernel.UserMessage} 						#key: #WordWrap 						#defaultString: 'Word Wrap' 						#catalogID: #UIPainter ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 155 0 0 1 ) 					#name: #Label1 					#label: 					#(#{Kernel.UserMessage} 						#key: #SizeC 						#defaultString: 'Size:' 						#catalogID: #UIPainter ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 131 0 -10 1 154 0 ) 					#name: #InputField1 					#model: #numChars 					#menu: #fieldMenu 					#type: #string ) ) ) )</body></methods><methods><class-id>UI.TextEditorSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 2 bitsPerPixel: 2 palette: (MappedPalette withColors: ((Array new: 4) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 3 put: ColorValue white; at: 4 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@*******)@@B???????4@@K???????P@@,@@@@@@=@@B2*"***#4@@KJBBB**OP@@,(HHH@(=@@B2*****#4@@KJ*****OP@@,(B@H@(=@@B2*****#4@@KJ*****OP@@,(@@@@(=@@B2*****#4@@KJ*****OP@@,(@@@*(=@@B2*****#4@@KJ***(*OP@@,(@ *@(=@@B2*****#4@@KJ*****OP@@,@@@@@@=@@B???????4@@EUUUUUUUP@@@@@@@@@@@@@@a'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 159 255 252 192 144 64 4 192 147 108 4 192 147 109 228 192 144 0 4 192 144 0 4 192 147 189 228 192 144 0 4 192 144 0 4 192 147 255 228 192 144 0 4 192 144 0 4 192 147 255 4 192 144 0 4 192 144 0 68 192 147 216 228 192 144 0 4 192 144 0 4 192 159 255 252 192 128 0 0 192 255 255 255 192 255 255 255 192 ])</body></methods><methods><class-id>UI.SliderSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 300 243 ) 			#max: #(#Point 300 243 ) 			#bounds: #(#Rectangle 316 232 616 475 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Slider #defaultString: 'Slider' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 55 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #AspectC #defaultString: 'Aspect:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 149 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #StopC #defaultString: 'Stop:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 87 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 117 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #StartC #defaultString: 'Start:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 181 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #StepC #defaultString: 'Step:' #catalogID: #UIPainter) ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 28 0 -10 1 53 0 ) 					#name: #modelField 					#model: #model 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#validAspectSelector: ) 					#menu: #fieldMenu ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 86 0 60 0 -10 1 85 0 ) 					#model: #name 					#menu: #fieldMenu ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 86 90 176 115 ) 					#model: #start 					#menu: #fieldMenu ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 86 122 176 147 ) 					#model: #stop 					#menu: #fieldMenu ) 				#(#InputFieldSpec 					#layout: #(#Rectangle 86 154 176 179 ) 					#model: #step 					#menu: #fieldMenu ) ) ) )</body><body package="UIPainter">detailsEditSpec	"UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 245 233 ) 			#max: #(#Point 300 243 ) 			#bounds: #(#Rectangle 296 294 596 537 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 31 0 -10 1 83 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Orientation #defaultString: 'Orientation' #catalogID: #UIPainter) ) 				#(#RadioButtonSpec 					#layout: #(#Point 15 53 ) 					#model: #orientation 					#label: #(#{Kernel.UserMessage} #key: #Vertical #defaultString: 'Vertical' #catalogID: #UIPainter) 					#select: #vertical ) 				#(#RadioButtonSpec 					#layout: #(#Point 124 53 ) 					#model: #orientation 					#label: #(#{Kernel.UserMessage} #key: #Horizontal #defaultString: 'Horizontal' #catalogID: #UIPainter) 					#select: #horizontal ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 88 ) 					#model: #initiallyDisabled 					#label: #(#{Kernel.UserMessage} #key: #InitiallyDisabled #defaultString: 'Initially Disabled' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 109 ) 					#model: #initiallyInvisible 					#label: #(#{Kernel.UserMessage} #key: #InitiallyInvisible #defaultString: 'Initially Invisible' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) ) ) )</body></methods><methods><class-id>UI.SliderSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 5) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 3 put: ColorValue red; at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@L3L3L3L3L3L3L3L1@@@@@CQDQDQDQDQDQDQDPP@@@@@4QDQDQDQDQDQDQDD@@@@@MDQDQDQDQDQDQDQA@@@@@CQDQDQDQDQDQDQDPP@@@@@4QDQDQDQDQDQDQDD@@@@@MDQDADPDQ@QDADQA@@@@@CQDQ@QDADPDQ@QDPP@@@@@4QDPDQ@QDADPDQDD@@@@@MDQDQDQDQDQDQDQA@@@@@CQDQDQDQDQDQDQDPP@@@@@4QDQDQDH$QDQDQDD@@@@@MD@@@@@RI@D@@@AA@@@@@CQ@DQDQD"PADQDPPP@@@@@4PCL3L3H$@3L3LDD@@@@@MD@@@@@RI@D@@@AA@@@@@CQDDQDQEDPADQDQPP@@@@@4QDQDQD@@ADQDQDD@@@@@MDQDQDQDQDQDQDQA@@@@@CQDQDQDQDQDQDQDPP@@@@@4QDQDQDQDQDQDQDD@@@@@MDQDQDQDQDQDQDQA@@@@@CQDQDQDQDQDQDQDPP@@@@@QDQDQDQDQDQDQDQD@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 129 17 16 192 129 17 16 192 129 17 16 192 128 0 0 192 128 0 0 192 128 12 0 192 143 253 254 192 143 253 254 192 136 13 2 192 143 253 254 192 135 241 254 192 128 15 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192 ])</body></methods><methods><class-id>UI.TableViewSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#bounds: #(#Rectangle 310 217 612 534 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.491694 15 0 0.5 0.5 ) 					#label: #(#{Kernel.UserMessage} #key: #Table #defaultString: 'Table' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 4 0 114 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 4 0 54 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #AspectC #defaultString: 'Aspect:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 4 0 84 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Menu #defaultString: 'Menu:' #catalogID: #UIPainter) ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 28 0 -6 1 53 0 ) 					#name: #modelField 					#model: #model 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#validAspectSelector: ) 					#menu: #fieldMenu ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 58 0 -6 1 83 0 ) 					#name: #menuField 					#model: #menu 					#menu: #fieldMenu ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 86 0 88 0 -6 1 113 0 ) 					#model: #name 					#menu: #fieldMenu ) ) ) )</body><body package="UIPainter">detailsEditSpec	"UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#min: #(#Point 261 294 ) 			#max: #(#Point 261 294 ) 			#bounds: #(#Rectangle 362 245 623 539 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 60 0 -10 1 110 0 ) 					#label: #(#{Kernel.UserMessage} #key: #ScrollBars #defaultString: 'Scroll Bars' #catalogID: #UIPainter) ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 113 0 -10 1 163 0 ) 					#label: #(#{Kernel.UserMessage} #key: #GridLines #defaultString: 'Grid Lines' #catalogID: #UIPainter) ) 				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 148 0 170 0 -10 1 277 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Selection #defaultString: 'Selection' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 15 79 ) 					#model: #hasHorizontalScrollBar 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Horizontal #defaultString: 'Horizontal' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 130 79 ) 					#model: #hasVerticalScrollBar 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Vertical #defaultString: 'Vertical' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 15 132 ) 					#model: #showHGrid 					#label: #(#{Kernel.UserMessage} #key: #Horizontal #defaultString: 'Horizontal' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 130 132 ) 					#model: #showVGrid 					#label: #(#{Kernel.UserMessage} #key: #Vertical #defaultString: 'Vertical' #catalogID: #UIPainter) ) 				#(#RadioButtonSpec 					#layout: #(#Point 166 194 ) 					#model: #selectionStyle 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Cell #defaultString: 'Cell' #catalogID: #UIPainter) 					#select: #element ) 				#(#RadioButtonSpec 					#layout: #(#Point 166 219 ) 					#model: #selectionStyle 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Row #defaultString: 'Row' #catalogID: #UIPainter) 					#select: #row ) 				#(#RadioButtonSpec 					#layout: #(#Point 166 244 ) 					#model: #selectionStyle 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Column #defaultString: 'Column' #catalogID: #UIPainter) 					#select: #column ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 170 ) 					#model: #hasBorder 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Bordered #defaultString: 'Bordered' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 192 ) 					#model: #isOpaque 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Opaque #defaultString: 'Opaque' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 214 ) 					#model: #tabable 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #CanTab #defaultString: 'Can Tab' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 236 ) 					#model: #initiallyDisabled 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyDisabled #defaultString: 'Initially Disabled' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 10 258 ) 					#model: #initiallyInvisible 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyInvisible #defaultString: 'Initially Invisible' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #(#{Kernel.UserMessage} #key: #Table #defaultString: 'Table' #catalogID: #UIPainter) ) 				#(#MenuButtonSpec 					#layout: #(#LayoutFrame 85 0 33 0 -11 1 55 0 ) 					#model: #style 					#menu: #fontMenu ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 56 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #FontC #defaultString: 'Font:' #catalogID: #UIPainter) ) ) ) )</body></methods><methods><class-id>UI.TableViewSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 5) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 3 put: (ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4369); at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@L3L3L3L3L3L3L3L1@@@@@CQDQDQDQDQDQDQDPP@@@@@4QDQDQDQDQDQDQDD@@@@@MDQDQDQDQDQDQDQA@@@@@CQDQD@DQ@ADP@QDPP@@@@@4QDQDQDQDQDQDQDD@@@@@MDQ@@@@@@@@@@@QA@@@@@CQDPCL3H3L2L3LDPP@@@@@4@D@3L2L3L#L3ADD@@@@@MDQ@L3L#L3H3L0QA@@@@@CQDPBH"H"H"H"HDPP@@@@@4QD@3L2L3L#L3ADD@@@@@M@A@L3L#L3H3L0QA@@@@@CQDPCL3H3L2L3LDPP@@@@@4QD@"H"H"H"H"ADD@@@@@MDQ@L3L#L3H3L0QA@@@@@CP@PCL3H3L2L3LDPP@@@@@4QD@3L2L3L#L3ADD@@@@@MDQ@@@@@@@@@@@QA@@@@@CQDQDQDQDQDQDQDPP@@@@@4QDQDQDQDQDQDQDD@@@@@MDQDQDQDQDQDQDQA@@@@@CQDQDQDQDQDQDQDPP@@@@@QDQDQDQDQDQDQDQD@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 198 48 192 128 0 0 192 131 255 252 192 130 16 132 192 154 16 132 192 130 16 132 192 131 255 252 192 130 16 132 192 154 16 132 192 130 16 132 192 131 255 252 192 130 16 132 192 154 16 132 192 130 16 132 192 131 255 252 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192 ])</body></methods><methods><class-id>UI.HierarchicalViewSpec class</class-id> <category>interface specs</category><body package="UIPainter">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 300 206 ) 			#max: #(#Point 300 206 ) 			#bounds: #(#Rectangle 230 206 530 412 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 55 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #AspectC #defaultString: 'Aspect:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 118 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 86 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Menu #defaultString: 'Menu:' #catalogID: #UIPainter) ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragEnterSelector 						#dragEnterSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: #dropSelector 						#dropInSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 29 0 -10 1 54 0 ) 					#name: #modelField 					#model: #model 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#validAspectSelector: ) 					#menu: #fieldMenu ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragEnterSelector 						#dragEnterSelectorAspect: #dragOverSelector 						#dragOverSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: #dropSelector 						#dropInSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 60 0 -10 1 85 0 ) 					#name: #menuField 					#model: #menu 					#menu: #fieldMenu ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 86 0 92 0 -10 1 117 0 ) 					#model: #name 					#menu: #fieldMenu ) ) ) )</body><body package="UIPainter">detailsEditSpec	"UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 235 229 ) 			#max: #(#{Core.Point} 256 333 ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1056 933 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 -1 0 0.5 0 ) 					#name: #Label1 					#label: #componentName ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 21 ) 					#name: #Label2 					#label: #(#{Kernel.UserMessage} #key: #FontC #defaultString: 'Font:' #catalogID: #UIPainter) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 45 0 -10 1 91 0 ) 					#name: #GroupBox1 					#label: #(#{Kernel.UserMessage} #key: #ScrollBars #defaultString: 'Scroll Bars' #catalogID: #UIPainter) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 55 0 22 0 -10 1 46 0 ) 					#name: #fontMenu 					#model: #style 					#menu: #fontMenu ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 18 64 ) 					#name: #CheckBox1 					#model: #hasHorizontalScrollBar 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Horizontal #defaultString: 'Horizontal' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.5 64 0 ) 					#name: #CheckBox2 					#model: #hasVerticalScrollBar 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Vertical #defaultString: 'Vertical' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 91 ) 					#name: #CheckBox3 					#model: #hasBorder 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Bordered #defaultString: 'Bordered' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 109 ) 					#name: #CheckBox4 					#model: #isOpaque 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Opaque #defaultString: 'Opaque' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 127 ) 					#name: #CheckBox5 					#model: #tabable 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #CanTab #defaultString: 'Can Tab' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 145 ) 					#name: #CheckBox6 					#model: #initiallyInvisible 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyInvisible #defaultString: 'Initially Invisible' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 163 ) 					#name: #CheckBox7 					#model: #initiallyDisabled 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyDisabled #defaultString: 'Initially Disabled' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 181 ) 					#name: #CheckBox1					#model: #autoSelect 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #AutoSelectOnKeyNavigation #defaultString: 'Auto Select on Key Navigation' #catalogID: #UIPainter) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.LabelSpec} 							#layout: #(#{Core.Point} 0 0 ) 							#name: #Label1							#label: #(#{Kernel.UserMessage} #key: #MinimumItemHeight #defaultString: 'Minimum Item Height:' #catalogID: #UIPainter) ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 135 0 0 0 0 1.0 24 0 ) 							#name: #InputField1							#model: #minimumHeight 							#alignment: #right 							#numChars: 3 							#type: #number 							#formatString: '###' ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.Rectangle} 10 205 240 233 ) 						#name: #Composite1 ) ) ) ) )</body><body package="UIPainter">dropSourceSpec	"UIPainter new openOnClass: self andSelector: #dropSourceSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #UIPainter) 			#bounds: #(#Rectangle 327 243 563 476 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#GroupBoxSpec 					#layout: #(#LayoutFrame 10 0 29 0 -10 1 127 0 ) 					#label: #(#{Kernel.UserMessage} #key: #DropSource #defaultString: 'Drop Source' #catalogID: #UIPainter) ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 54 0 -16 1 79 0 ) 					#name: #dragOKField 					#model: #dragOkSelector 					#menu: #fieldMenu 					#type: #string ) 				#(#InputFieldSpec 					#properties: 					#(#PropertyListDictionary #dragOverSelector 						#dragOverSelectorAspect: #dropSelector 						#dropInSelectorAspect: #dragExitSelector 						#dragLeaveSelectorAspect: #dragEnterSelector 						#dragEnterSelectorAspect: ) 					#layout: #(#LayoutFrame 86 0 82 0 -16 1 107 0 ) 					#name: #dragStartField 					#model: #dragStartSelector 					#menu: #fieldMenu 					#type: #string ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 12 0 107 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #DragStart #defaultString: 'Drag Start:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 12 0 79 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #DragOk #defaultString: 'Drag Ok:' #catalogID: #UIPainter) ) 				#(#CheckBoxSpec 					#layout: #(#Point 12 148 ) 					#name: #selectOnDownIfDragEnabled 					#model: #selectOnDownIfDragEnabled 					#label: #(#{Kernel.UserMessage} #key: #SelectOnDown #defaultString: 'Select On Down' #catalogID: #UIPainter) ) ) ) )</body></methods><methods><class-id>UI.HierarchicalViewSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 5) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 3 put: (ColorValue scaledRed: 6552 scaledGreen: 6552 scaledBlue: 6552); at: 4 put: ColorValue white; at: 5 put: (ColorValue scaledRed: 0 scaledGreen: 4914 scaledBlue: 8191); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@L3L3L3L3L3L3L3L1@@@@@CH"H"H"H"H"H"H"HP@@@@@2H"H"H"H"H"H"H"D@@@@@L"@@@@@@@@@@@@H!@@@@@CH L3L3L3L3LCLBHP@@@@@2HCL3L3L3L3@3@"D@@@@@L"@0@@@@@@@0@@H!@@@@@CH L3L3L3L3LDPBHP@@@@@2HCL0@@@@@CAD@"D@@@@@L"@3L3L3L3L0Q@H!@@@@@CH L3@@@@@@LDPBHP@@@@@2HCL3L3L3L3AD@"D@@@@@L"@3L3@@@@@0Q@H!@@@@@CH L3L3L3L3LDPBHP@@@@@2HCL3L@@@@CAD@"D@@@@@L"@3L3L3L3L0Q@H!@@@@@CH L3L0@@@@LDPBHP@@@@@2HCL3L3L3L3@@@"D@@@@@L"@3L3@@@@@0L0H!@@@@@CH L3L3L3L3LCLBHP@@@@@2H@@@@@@@@@@@@"D@@@@@L"H"H"H"H"H"H"H!@@@@@CH"H"H"H"H"H"H"HP@@@@@QDQDQDQDQDQDQDQD@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 143 255 252 192 136 0 36 192 136 0 36 192 139 255 188 192 136 0 36 192 137 255 164 192 136 0 36 192 137 255 164 192 136 0 36 192 136 127 164 192 136 0 36 192 136 127 164 192 136 0 36 192 136 127 164 192 136 0 60 192 136 127 164 192 136 0 36 192 143 255 252 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192])</body></methods><methods><class-id>UI.TreeViewSpec class</class-id> <category>interface specs</category><body package="UIPainter">advancedEditSpec	"UIPainter new openOnClass: self andSelector: #advancedEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #GenKey27 #defaultString: 'TreeView Advanced Settings Page' #catalogID: #UIPainter) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 1600 1200 ) 			#bounds: #(#{Graphics.Rectangle} 801 597 1102 886 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 127 0 47 0 -15 1 72 0 ) 					#name: #openedEmphasis 					#model: #openedEmphasis 					#menu: #fieldMenu 					#type: #symbol ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 127 0 81 0 -15 1 104 0 ) 					#name: #closedEmphaisis 					#model: #closedEmphasis 					#menu: #fieldMenu 					#type: #symbol ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 127 0 114 0 -15 1 137 0 ) 					#name: #leafEmphasis 					#model: #leafEmphasis 					#menu: #fieldMenu 					#type: #symbol ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 12 47 ) 					#name: #Label1 					#label: #(#{Kernel.UserMessage} #key: #OpenedSelector #defaultString: 'Opened Selector' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 18 80 ) 					#name: #Label2 					#label: #(#{Kernel.UserMessage} #key: #ClosedSelector #defaultString: 'Closed Selector' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 35 113 ) 					#name: #Label3 					#label: #(#{Kernel.UserMessage} #key: #LeafSelector #defaultString: 'Leaf Selector' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 6 0 0.5 0 ) 					#name: #Label4 					#label: #(#{Kernel.UserMessage} #key: #TreeView #defaultString: 'Tree View' #catalogID: #UIPainter) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 26 0 -5 1 147 0 ) 					#name: #GroupBox1 					#label: #(#{Kernel.UserMessage} #key: #ItemTextEmphasis #defaultString: 'Item Text Emphasis' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">basicsEditSpec	"UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: ' ' 			#min: #(#Point 300 206 ) 			#max: #(#Point 300 206 ) 			#bounds: #(#Rectangle 335 347 635 553 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#LabelSpec 					#layout: #(#AlignmentOrigin 0 0.5 4 0 0.5 0 ) 					#label: #componentName ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 55 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #AspectC #defaultString: 'Aspect:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 118 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #IDC #defaultString: 'ID:' #catalogID: #UIPainter) ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin 10 0 86 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #Menu #defaultString: 'Menu:' #catalogID: #UIPainter) ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 86 0 29 0 -10 1 54 0 ) 					#model: #model 					#menu: #fieldMenu ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 86 0 60 0 -10 1 85 0 ) 					#model: #menu 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#validAspectSelector: ) 					#menu: #fieldMenu ) 				#(#InputFieldSpec 					#layout: #(#LayoutFrame 86 0 92 0 -10 1 117 0 ) 					#model: #name 					#menu: #fieldMenu ) ) ) )</body><body package="UIPainter">detailsEditSpec	"UIPainter new openOnClass: self andSelector: #detailsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 235 229 ) 			#max: #(#{Core.Point} 235 292 ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1035 892 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 56 0 -10 1 110 0 ) 					#name: #GroupBox1 					#label: #(#{Kernel.UserMessage} #key: #ScrollBars #defaultString: 'Scroll Bars' #catalogID: #UIPainter) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 4 0 0.5 0 ) 					#name: #Label1 					#label: #componentName ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 35 ) 					#name: #Label2 					#label: #(#{Kernel.UserMessage} #key: #FontC #defaultString: 'Font:' #catalogID: #UIPainter) ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 55 0 29 0 -10 1 52 0 ) 					#name: #fontMenu 					#model: #style 					#menu: #fontMenu ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 15 79 ) 					#name: #CheckBox1 					#model: #hasHorizontalScrollBar 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Horizontal #defaultString: 'Horizontal' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 130 79 ) 					#name: #CheckBox2 					#model: #hasVerticalScrollBar 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Vertical #defaultString: 'Vertical' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 112 ) 					#name: #CheckBox3 					#model: #hasBorder 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Bordered #defaultString: 'Bordered' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 129 ) 					#name: #CheckBox4 					#model: #isOpaque 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #Opaque #defaultString: 'Opaque' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 146 ) 					#name: #CheckBox5 					#model: #tabable 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #CanTab #defaultString: 'Can Tab' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 164 ) 					#name: #CheckBox6 					#model: #initiallyDisabled 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyDisabled #defaultString: 'Initially Disabled' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 182 ) 					#name: #CheckBox7 					#model: #initiallyInvisible 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #InitiallyInvisible #defaultString: 'Initially Invisible' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 199 ) 					#name: #CheckBox8 					#model: #autoSelect 					#tabable: true 					#label: #(#{Kernel.UserMessage} #key: #AutoSelectOnKeyNavigation #defaultString: 'Auto Select on Key Navigation' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 218 ) 					#name: #CheckBox1 					#model: #multipleSelections 					#label: #(#{Kernel.UserMessage} #key: #MultiSelect #defaultString: 'Multi Select' #catalogID: #UIPainter) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 236 ) 					#name: #CheckBox9 					#model: #fullLineSelect 					#helpText: #(#{Kernel.UserMessage} #key: #GenKey28 #defaultString: 'Checked = Select From Container Left to Full Right. Unchecked = Select Only Text' #catalogID: #UIPainter) 					#label: #(#{Kernel.UserMessage} #key: #WholeLineSelection #defaultString: 'Whole Line Selection' #catalogID: #UIPainter) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 170 261 220 284 ) 					#name: #InputField1					#model: #minimumHeight 					#alignment: #right 					#numChars: 3 					#type: #number 					#formatString: '###' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 259 ) 					#name: #Label1 					#label: #(#{Kernel.UserMessage} #key: #MinimumElementHeight #defaultString: 'Minimum Element Height:' #catalogID: #UIPainter) ) ) ) )</body><body package="UIPainter">itemsEditSpec	"Tools.UIPainter new openOnClass: self andSelector: #itemsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 235 229 ) 			#max: #(#{Core.Point} 235 325 ) 			#bounds: #(#{Graphics.Rectangle} 640 512 875 819 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 40 0 -10 1 64 0 ) 					#model: #displayStringSelector ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 2 0 0.5 0 ) 					#label: #componentName ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 18 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #DisplayString 						#defaultString: 'Display String:' 						#catalogID: #UIPainter ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 64 0 -10 1 170 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Icons 						#defaultString: 'Icon(s)' 						#catalogID: #UIPainter ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 242 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #InPlaceEditedSelector 						#defaultString: 'In-Place Edited Selector:' 						#catalogID: #UIPainter ) ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 20 80 ) 					#model: #useIcons 					#label: 					#(#{Kernel.UserMessage} 						#key: #None 						#defaultString: 'None' 						#catalogID: #UIPainter ) 					#select: #none ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 20 98 ) 					#model: #useIcons 					#label: 					#(#{Kernel.UserMessage} 						#key: #Folder 						#defaultString: 'Folder' 						#catalogID: #UIPainter ) 					#select: #folder ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 20 116 ) 					#model: #useIcons 					#label: 					#(#{Kernel.UserMessage} 						#key: #UserDefined 						#defaultString: 'User Defined:' 						#catalogID: #UIPainter ) 					#select: #other ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 20 0 137 0 195 24 ) 					#model: #iconSelectors ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 22 184 ) 					#model: #useChildImages 					#label: 					#(#{Kernel.UserMessage} 						#key: #ChildExpansion 						#defaultString: 'Child Expansion' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 22 202 ) 					#name: #showRootImage 					#model: #rootExpander 					#label: 					#(#{Kernel.UserMessage} 						#key: #RootExpansion 						#defaultString: 'Root Expansion' 						#catalogID: #UIPainter ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 22 219 ) 					#model: #useLines 					#label: 					#(#{Kernel.UserMessage} 						#key: #Lines 						#defaultString: 'Lines' 						#catalogID: #UIPainter ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 267 0 -10 1 291 0 ) 					#name: #inPlaceEditedSelector 					#model: #inPlaceEditedSelector 					#type: #symbol ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 9 0 170 0 -10 1 244 0 ) 					#name: #GroupBox1 					#label: 					#(#{Kernel.UserMessage} 						#key: #Visibility 						#defaultString: 'Visibility' 						#catalogID: #UIPainter ) ) ) ) )</body></methods><methods><class-id>UI.TreeViewSpec class</class-id> <category>resources</category><body package="UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 6) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); at: 3 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 4 put: ColorValue white; at: 5 put: ColorValue red; at: 6 put: (ColorValue scaledRed: 0 scaledGreen: 4915 scaledBlue: 8191); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@L3L3L3L3L3L3L3L2@@@@@CDQDQDQDQDQDQDQD @@@@@1DQDQDQDQDQDQDQH@@@@@LQ@@@@@@@@@@@@DR@@@@@CDPL3L3L3L3LCLAD @@@@@1DCP3L3L3L3@3@QH@@@@@LQ@4P@@@@@L0@@DR@@@@@CDPL3L3L3L3LETAD @@@@@1DCL4L3L3L3AU@QH@@@@@LQ@3MD@@@@L0UPDR@@@@@CDPL3L3L3L3LETAD @@@@@1DCL3L4L3L3AU@QH@@@@@LQ@3L3MD@@L0UPDR@@@@@CDPL3L3L3L3LETAD @@@@@1DCP3L3L3L3AU@QH@@@@@LQ@4P@@@@@L0UPDR@@@@@CDPL3L3L3L3LETAD @@@@@1DCL4L3L3L3@@@QH@@@@@LQ@3MD@@@@L0L0DR@@@@@CDPL3L3L3L3LCLAD @@@@@1D@@@@@@@@@@@@QH@@@@@LQDQDQDQDQDQDQDR@@@@@CDQDQDQDQDQDQDQD @@@@@"H"H"H"H"H"H"H"H@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body><body package="UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 143 255 252 192 136 0 36 192 139 0 36 192 139 255 60 192 136 0 36 192 136 192 36 192 136 255 36 192 136 0 36 192 136 24 36 192 136 31 36 192 136 0 36 192 139 0 36 192 139 255 36 192 136 0 36 192 136 192 60 192 136 255 36 192 136 0 36 192 143 255 252 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192])</body></methods><initialize><class-id>Tools.ColumnReorderAgent</class-id></initialize><initialize><class-id>Tools.UIPainter</class-id></initialize><initialize><class-id>Tools.UIPalette</class-id></initialize><initialize><class-id>Tools.MenuEditor</class-id></initialize><initialize><class-id>Tools.UIPainterController</class-id></initialize><initialize><class-id>UI.MaskPainterController</class-id></initialize><initialize><class-id>Tools.UIFinderVW2</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>UISpecification</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>ComponentSpec</name><environment>UI</environment><super>UI.UISpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>layout vAlignment hAlignment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>NamedSpec</name><environment>UI</environment><super>UI.ComponentSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name flags isOpaque colors </inst-vars><class-inst-vars>paletteIcon </class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>WidgetSpec</name><environment>UI</environment><super>UI.NamedSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model callbacksSpec tabable helpText helpField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>MenuComponentSpec</name><environment>UI</environment><super>UI.WidgetSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menu performer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>SubCanvasSpec</name><environment>UI</environment><super>UI.NamedSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>majorKey minorKey clientKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>SpecCollection</name><environment>UI</environment><super>UI.UISpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection layoutManagerClass layoutManagerConfiguration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>CompositeSpecCollection</name><environment>UI</environment><super>UI.SpecCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>compositeSpec </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>DataSetSpec</name><environment>UI</environment><super>UI.MenuComponentSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>columns verticalPolicy horizontalPolicy multipleSelections labelsAsButtons </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>GroupBoxSpec</name><environment>UI</environment><super>UI.NamedSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label style hasCharacterOrientedLabel mnemonic </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>ButtonSpec</name><environment>UI</environment><super>UI.WidgetSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label hasCharacterOrientedLabel style </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>MenuButtonSpec</name><environment>UI</environment><super>UI.ButtonSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menu isList isPopUp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>ControllerWithMenu</name><environment>UI</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuHolder performer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>DataSetController</name><environment>UI</environment><super>UI.ControllerWithMenu</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outside dispatcher callbackLock rowSelect clicked oldCursor tabLock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Datasets</category><attributes><package>UIBasics-Datasets</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>UISettings</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list disturbed subBuilder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>InputFieldSpec</name><environment>UI</environment><super>UI.TextEditorSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type formatString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>MenuItem</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>enabled visible label adornment nameKey value position helpText command </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Menus</category><attributes><package>Interface-Menus</package></attributes></class><class><name>ProgressWidgetSpec</name><environment>UI</environment><super>UI.WidgetSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>direction position area reverse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>ComboBoxSpec</name><environment>UI</environment><super>UI.InputFieldSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comboList readSelector printSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>VisualComponent</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>VisualPart</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>container eventHandlers properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>PassiveLabel</name><environment>UI</environment><super>UI.SimpleComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label textStyle margin mnemonic controller artist </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>View</name><environment>UI</environment><super>Graphics.DependentPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>SimpleView</name><environment>UI</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>ResizingSplitterSpec</name><environment>UI</environment><super>UI.WidgetSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>horizontal minAboveSize minBelowSize aboveWidgets belowWidgets </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>CompositePart</name><environment>Graphics</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components preferredExtent layoutManager layoutIsInvalid minimumExtent maximumExtent alignmentRectInsets baseline </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>SelectionTracker</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Trackers</category><attributes><package>Interface-Events-Trackers</package></attributes></class><class><name>SelectTracker</name><environment>UI</environment><super>UI.SelectionTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inside </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Trackers</category><attributes><package>Interface-Events-Trackers</package></attributes></class><class><name>SpinButtonSpec</name><environment>UI</environment><super>UI.InputFieldSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>readSelector printSelector low lowDate lowTime lowTimestamp high highDate highTime highTimestamp interval isWrapAround </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>LabelSpec</name><environment>UI</environment><super>UI.NamedSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label style hasCharacterOrientedLabel mnemonic </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>DividerSpec</name><environment>UI</environment><super>UI.NamedSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lineWidth orientation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>TreeModel</name><environment>UI</environment><super>Core.List</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root childrenBlock hasChildrenBlock mayHaveNilValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Collections</category><attributes><package>UIBasics-Collections</package></attributes></class><class><name>Wrapper</name><environment>Graphics</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>LookupKey</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>RadioButtonSpec</name><environment>UI</environment><super>UI.ButtonSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>select </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>CheckBoxSpec</name><environment>UI</environment><super>UI.ButtonSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>SliderSpec</name><environment>UI</environment><super>UI.WidgetSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>orientation start stop step </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>SpecWrapper</name><environment>UI</environment><super>UI.WidgetWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>spec </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Support</category><attributes><package>UIBuilder-Support</package></attributes></class><class><name>RegionSpec</name><environment>UI</environment><super>UI.NamedSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lineWidth regionType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>WindowSpec</name><environment>UI</environment><super>UI.UISpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model label min max bounds flags menu toolBar performer colors pushMode pushOn pushAspect dynamism backgroundPattern defineFontLoadingMethod namedFontFileOutType savedFontFileName layoutManagerClass layoutManagerConfiguration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>UISpecEnumerator</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Support</category><attributes><package>UIBuilder-Support</package></attributes></class><class><name>AlphaBlendedIcons</name><environment>Smalltalk</environment><super>Core.Assets</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Tools-Resources</package></attributes></class><class><name>CompositeSpec</name><environment>UI</environment><super>UI.NamedSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>layoutManagerClass layoutManagerConfiguration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>ApplicationStandardSystemController</name><environment>UI</environment><super>UI.StandardSystemController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>eventDispatcher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>DataSetColumnSpec</name><environment>UI</environment><super>UI.WidgetSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label labelFont labelIsImage width rendererType editorType menu choices size font alignment type popUpStyle bordered noScroll cellLabel formatString readSelector printSelector dataSetSpec labelsAsButtons </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>ScrollingTracker</name><environment>UI</environment><super>UI.SelectionTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>process </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Trackers</category><attributes><package>Interface-Events-Trackers</package></attributes></class><class><name>SelectController</name><environment>UI</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyboardHook dispatcher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>CompositeView</name><environment>UI</environment><super>Graphics.DependentComposite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>BorderDecorator</name><environment>UI</environment><super>Graphics.CompositePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>component policy hasBorder hasHorizontalScrollbar hasVerticalScrollbar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>DataSetView</name><environment>UI</environment><super>UI.SelectionView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>columnDescriptors right starts numFrozen editor editorWrapper editValue editCellChannel showingSelection useHiliteSelection rowSelectorIndex verticalPolicy horizontalPolicy labelsAsButtons rowLabelsAsButtons showVerticalLines showHorizontalLines showLineNumbers sortColumn allowColumnReordering allowSorting allowColumnResizing gridLineColor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Datasets</category><attributes><package>UIBasics-Datasets</package></attributes></class><class><name>UIBuilder</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bindings namedComponents labels visuals subCanvasSpecs source policy spec window keyboardProcessor composite component decorator wrapper stack isEditing cacheWhileEditing windowSpec converterClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>HotRegions</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>regionsImage regionsSelectors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>ColumnResizeAgent</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller outside index leftLimit leftEdge </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Datasets</category><attributes><package>UIBasics-Datasets</package></attributes></class></st-source>