<?xml version="1.0"?><st-source><!-- Name: MemoryPolicyCheckerNotice: Copyright 2010-2013 Cincom Systems, Inc.  All rights reserved.Comment: This package contains an SUnit test suite that can be used to validate memory policy classes.DbIdentifier: bear73DbTrace: 415057DbUsername: avalloudDbVersion: 8.0 - 3DevelopmentPrerequisites: #(#(#any 'SUnit' ''))PackageName: MemoryPolicyCheckerParcel: #('MemoryPolicyChecker')PrerequisiteDescriptions: #(#(#name 'SUnit' #componentType #package))PrerequisiteParcels: #(#('SUnit' ''))PrintStringCache: (8.0 - 3,avalloud)Version: 8.0 - 3Date: 12:14:13 PM November 8, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (nov13.2) of November 8, 2013 on November 8, 2013 at 12:14:13 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>MemoryPolicyTest</name><environment>Smalltalk</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentObjectMemory cachedObjectMemory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MemoryPolicyChecker</package></attributes></class><comment><class-id>MemoryPolicyTest</class-id><body>These test cases test various aspects of memory policy functionality.</body></comment><class><name>AbstractMemoryPolicyChecker</name><environment>Smalltalk</environment><super>MemoryPolicyTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MemoryPolicyChecker</package></attributes></class><comment><class-id>AbstractMemoryPolicyChecker</class-id><body>Policy checker test cases enforce various memory policy working assumptions.</body></comment><class><name>PotentialMemoryPolicyChecker</name><environment>Smalltalk</environment><super>AbstractMemoryPolicyChecker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MemoryPolicyChecker</package></attributes></class><comment><class-id>PotentialMemoryPolicyChecker</class-id><body>Potential memory policy checkers ensure the correct operation of memory policies that could potentially become the current memory policy.  Note that tests are refined to make assertions for many memory upper bound values.</body></comment><class><name>LargeGrainMemoryPolicyChecker</name><environment>Smalltalk</environment><super>PotentialMemoryPolicyChecker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MemoryPolicyChecker</package></attributes></class><comment><class-id>LargeGrainMemoryPolicyChecker</class-id><body>This test checks the large grain memory policy.</body></comment><class><name>MediumGrainMemoryPolicyChecker</name><environment>Smalltalk</environment><super>PotentialMemoryPolicyChecker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MemoryPolicyChecker</package></attributes></class><comment><class-id>MediumGrainMemoryPolicyChecker</class-id><body>This test checks the medium grain memory policy.</body></comment><class><name>CurrentMemoryPolicyChecker</name><environment>Smalltalk</environment><super>AbstractMemoryPolicyChecker</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>MemoryPolicyChecker</package></attributes></class><comment><class-id>CurrentMemoryPolicyChecker</class-id><body>This policy checker ensures that the current memory policy is working correctly.  Note that the current memory policy is subject to additional tests because, being current, more assertions can be made about it.</body></comment><methods><class-id>MemoryPolicyTest</class-id> <category>setup</category><body package="MemoryPolicyChecker">memoryPolicy	"Refine this method to retarget these tests for other, inactive memory policies"	^self objectMemory currentMemoryPolicy</body><body package="MemoryPolicyChecker">minimumHardLowSpaceLimit	^self newBytesAvailableForStorage		+ self stackZoneFlushBytes</body><body package="MemoryPolicyChecker">objectMemory	^ObjectMemory</body></methods><methods><class-id>MemoryPolicyTest</class-id> <category>setup - memory policy</category><body package="MemoryPolicyChecker">availableSpaceSafetyMargin	^self memoryPolicy availableSpaceSafetyMargin</body><body package="MemoryPolicyChecker">contiguousSpaceSafetyMargin	^self memoryPolicy contiguousSpaceSafetyMargin</body><body package="MemoryPolicyChecker">freeFixedMemoryUpperBound	^self memoryPolicy freeFixedMemoryUpperBound</body><body package="MemoryPolicyChecker">freeMemoryUpperBound	^self memoryPolicy freeMemoryUpperBound</body><body package="MemoryPolicyChecker">growthRegimeUpperBound	^self memoryPolicy growthRegimeUpperBound</body><body package="MemoryPolicyChecker">growthRetryDecrement	^self memoryPolicy growthRetryDecrement</body><body package="MemoryPolicyChecker">idleLoopAllocationThreshold	^self memoryPolicy idleLoopAllocationThreshold</body><body package="MemoryPolicyChecker">incHardMinQuota	^self memoryPolicy incHardMinQuota</body><body package="MemoryPolicyChecker">incMarkQuota	^self memoryPolicy incMarkQuota</body><body package="MemoryPolicyChecker">incSweepQuota	^self memoryPolicy incSweepQuota</body><body package="MemoryPolicyChecker">incUnmarkQuota	^self memoryPolicy incUnmarkQuota</body><body package="MemoryPolicyChecker">incrementalAllocationThreshold	^self memoryPolicy incrementalAllocationThreshold</body><body package="MemoryPolicyChecker">initHardLowSpaceLimit	^self memoryPolicy initHardLowSpaceLimit</body><body package="MemoryPolicyChecker">initSoftLowSpaceLimit	^self memoryPolicy initSoftLowSpaceLimit</body><body package="MemoryPolicyChecker">memoryUpperBound	^self memoryPolicy memoryUpperBound</body><body package="MemoryPolicyChecker">minimumGrowthDueToAllocationFailure	^self memoryPolicy minimumGrowthDueToAllocationFailure</body><body package="MemoryPolicyChecker">newHardLowSpaceLimit	^self memoryPolicy newHardLowSpaceLimit</body><body package="MemoryPolicyChecker">newSoftLowSpaceLimit	^self memoryPolicy newSoftLowSpaceLimit</body><body package="MemoryPolicyChecker">oopSizeFactor	^ObjectMemory is64Bit ifTrue: [2] ifFalse: [1]</body><body package="MemoryPolicyChecker">paddedAvailableSpaceSafetyMargin	^self memoryPolicy paddedAvailableSpaceSafetyMargin</body><body package="MemoryPolicyChecker">preferredFixedGrowthIncrement	^self memoryPolicy preferredFixedGrowthIncrement</body><body package="MemoryPolicyChecker">preferredGrowthIncrement	^self memoryPolicy preferredGrowthIncrement</body></methods><methods><class-id>MemoryPolicyTest</class-id> <category>setup - object memory</category><body package="MemoryPolicyChecker">availableFreeOldSpaceBytes	^self cachedObjectMemory availableFreeOldSpaceBytes</body><body package="MemoryPolicyChecker">bytesPerOOP	^self cachedObjectMemory bytesPerOOP</body><body package="MemoryPolicyChecker">bytesPerOTE	^self cachedObjectMemory bytesPerOTE</body><body package="MemoryPolicyChecker">currentHardLowSpaceLimit	^self objectMemory hardLowSpaceLimit</body><body package="MemoryPolicyChecker">currentSoftLowSpaceLimit	^self objectMemory softLowSpaceLimit</body><body package="MemoryPolicyChecker">dynamicallyAllocatedFootprint	^self cachedObjectMemory dynamicallyAllocatedFootprint</body><body package="MemoryPolicyChecker">fixedBytes	^self cachedObjectMemory fixedBytes</body><body package="MemoryPolicyChecker">fixedSegments	^self cachedObjectMemory fixedSegments</body><body package="MemoryPolicyChecker">largeBytes	^self cachedObjectMemory largeBytes</body><body package="MemoryPolicyChecker">nativeStackSpills	^self cachedObjectMemory nativeStackSpills</body><body package="MemoryPolicyChecker">newBytesAvailableForStorage	^self cachedObjectMemory newBytesAvailableForStorage</body><body package="MemoryPolicyChecker">oldRtBytes	^self cachedObjectMemory oldRtBytes</body><body package="MemoryPolicyChecker">oldRtEntries	^self cachedObjectMemory oldRtEntries</body><body package="MemoryPolicyChecker">oldSegments	^self cachedObjectMemory oldSegments</body><body package="MemoryPolicyChecker">oldSpaceSegmentSizes	| answer |	answer := OrderedCollection new.	1 to: self oldSegments do:		[:each | answer add: (self cachedObjectMemory oldSegmentSizeAt: each)].	^answer</body><body package="MemoryPolicyChecker">rtBytes	^self cachedObjectMemory rtBytes</body><body package="MemoryPolicyChecker">rtEntries	^self cachedObjectMemory rtEntries</body><body package="MemoryPolicyChecker">stackBytes	^self cachedObjectMemory stackBytes</body><body package="MemoryPolicyChecker">stackZoneFlushBytes	^self cachedObjectMemory stackZoneFlushBytes</body></methods><methods><class-id>MemoryPolicyTest</class-id> <category>setup - sizes at startup</category><body package="MemoryPolicyChecker">defaultSizesAtStartup	^self objectMemory defaultSizesAtStartup</body><body package="MemoryPolicyChecker">defaultStartupEdenSize	^self defaultSizesAtStartup at: 1</body><body package="MemoryPolicyChecker">defaultStartupFixedSpaceHeadroom	^self defaultSizesAtStartup at: 7</body><body package="MemoryPolicyChecker">defaultStartupOldSpaceHeadroom	^self defaultSizesAtStartup at: 6</body><body package="MemoryPolicyChecker">defaultStartupStackSize	^self defaultSizesAtStartup at: 4</body><body package="MemoryPolicyChecker">defaultStartupSurvivorSemispaceSize	^self defaultSizesAtStartup at: 2</body><body package="MemoryPolicyChecker">fixedSpaceHeadroomMultiplier	^self sizesAtStartup at: 7</body><body package="MemoryPolicyChecker">sizesAtStartup	^ObjectMemory sizesAtStartup</body><body package="MemoryPolicyChecker">startupEdenMultiplier	^self sizesAtStartup at: 1</body><body package="MemoryPolicyChecker">startupFixedSpaceHeadroomMultiplier	^self sizesAtStartup at: 7</body><body package="MemoryPolicyChecker">startupOldSpaceHeadroomMultiplier	^self sizesAtStartup at: 6</body><body package="MemoryPolicyChecker">startupStackMultiplier	^self sizesAtStartup at: 4</body><body package="MemoryPolicyChecker">startupSurvivorSemispaceMultiplier	^self sizesAtStartup at: 2</body></methods><methods><class-id>MemoryPolicyTest</class-id> <category>accessing</category><body package="MemoryPolicyChecker">cachedObjectMemory	cachedObjectMemory notNil ifTrue: [^cachedObjectMemory].	self cachedObjectMemory: self currentObjectMemory.	^cachedObjectMemory</body><body package="MemoryPolicyChecker">cachedObjectMemory: anObject	cachedObjectMemory := anObject</body><body package="MemoryPolicyChecker">currentObjectMemory	^self objectMemory current</body></methods><methods><class-id>AbstractMemoryPolicyChecker</class-id> <category>testing - growth regime upper bound</category><body package="MemoryPolicyChecker">testGrowthRegimeUpperBoundIsLargeEnough	self		assert: self growthRegimeUpperBound &gt; self availableSpaceSafetyMargin		description: 'The memory upper bound should larger than the available space safety margin'.	self		assert: self growthRegimeUpperBound &gt; self contiguousSpaceSafetyMargin		description: 'The memory upper bound should larger than the contiguous space safety margin'.	self		assert: self growthRegimeUpperBound &gt; self preferredGrowthIncrement		description: 'The memory upper bound should larger than the preferredGrowthIncrement'.	self		assert: self memoryUpperBound &gt; (self growthRegimeUpperBound + self preferredGrowthIncrement)		description: 'The memory upper bound should be significantly larger than the growth regime upper bound'</body></methods><methods><class-id>AbstractMemoryPolicyChecker</class-id> <category>testing - priorities</category><body package="MemoryPolicyChecker">testLowSpacePriorityIsHigherThanFinalizationPriority	"See WeakArray class&gt;&gt;outerFinalizationLoop"	self		assert: Processor lowSpacePriority &gt; Processor lowIOPriority		description: 'Actual finalization work should yield to low space processing'</body></methods><methods><class-id>AbstractMemoryPolicyChecker</class-id> <category>testing - free fixed memory upper bound</category><body package="MemoryPolicyChecker">testFreeFixedMemoryUpperBoundIsLargeEnough	self		assert: self freeFixedMemoryUpperBound &gt;= 0		description: 'The free fixed memory upper bound should be positive'</body><body package="MemoryPolicyChecker">testFreeFixedMemoryUpperBoundIsNotTooLarge	self		assert: self memoryUpperBound &gt; self freeFixedMemoryUpperBound		description: 'The free fixed memory upper bound should be less than the memory upper bound'</body></methods><methods><class-id>AbstractMemoryPolicyChecker</class-id> <category>testing</category><body package="MemoryPolicyChecker">testIdleLoopAllocationThresholdIsLargeEnough	self		assert: self idleLoopAllocationThreshold &gt; self newBytesAvailableForStorage		description: 'The idle loop allocation threshold should be larger than new space'.	self		assert: self idleLoopAllocationThreshold // 2 &gt;= self preferredGrowthIncrement		description: 'The idle loop allocation threshold seems too small'</body><body package="MemoryPolicyChecker">testIncrementalAllocationThresholdIsLargeEnough	self		assert: self incrementalAllocationThreshold * 10 &gt;= self preferredGrowthIncrement		description: 'The incremental allocation threshold seems too small'</body><body package="MemoryPolicyChecker">testMemoryUpperBoundMinimum	self		assert: self memoryPolicy class defaultMemoryUpperBound &gt;= (64 bitShift: 20)		description: 'Memory policy class tested for memory upper bounds no less than 64mb'</body><body package="MemoryPolicyChecker">testMemoryUpperBoundMinimumEnforced	| previousMemoryUpperBound minimumEnforced |	previousMemoryUpperBound := self memoryPolicy class defaultMemoryUpperBound.	self memoryPolicy class defaultMemoryUpperBound: 1.	minimumEnforced := self memoryPolicy class defaultMemoryUpperBound &gt; 1.	self memoryPolicy class defaultMemoryUpperBound: previousMemoryUpperBound.	self		assert: minimumEnforced		description: 'Memory policy class tested for memory upper bounds no less than 64mb'</body></methods><methods><class-id>AbstractMemoryPolicyChecker</class-id> <category>testing - preferred growth increment</category><body package="MemoryPolicyChecker">testGrowthRetryDecrementIsLargeEnough	self		assert: self growthRetryDecrement * 100 &gt; self preferredGrowthIncrement		description: 'The growth retry decrement seems too small'.	self		assert: self growthRetryDecrement * 100 &gt; self preferredFixedGrowthIncrement		description: 'The growth retry decrement seems too small'.	self		assert: self growthRetryDecrement &gt; 16384		description: 'The growth retry decrement seems too small'</body><body package="MemoryPolicyChecker">testGrowthRetryDecrementIsNotTooLarge	self		assert: self preferredGrowthIncrement // 10 &gt; self growthRetryDecrement		description: 'The growth retry decrement should be much smaller than the preferred growth increment'.	self		assert: self preferredFixedGrowthIncrement // 10 &gt; self growthRetryDecrement		description: 'The growth retry decrement should be much smaller than the preferred fixed growth increment'</body><body package="MemoryPolicyChecker">testPreferredGrowthIncrementIsLargeEnough	self		assert: self preferredGrowthIncrement &gt;= self minimumHardLowSpaceLimit		description: 'The preferred growth increment must be greater than the minimum hard low space limit'.	self		assert: self preferredGrowthIncrement &gt;= self newHardLowSpaceLimit		description: 'The preferred growth increment must be greater than the hard low space limit'.	self		assert: self preferredGrowthIncrement &gt;= self newBytesAvailableForStorage		description: 'The preferred growth increment must be greater than new space'.	self		assert: self preferredGrowthIncrement &gt;= self contiguousSpaceSafetyMargin		description: 'The preferred growth increment must be greater than contiguous space safety margin'</body><body package="MemoryPolicyChecker">testPreferredGrowthIncrementIsNotTooLarge	self		assert: self preferredGrowthIncrement * 5 &lt; self memoryUpperBound		description: 'The preferred growth increment seems too large in comparison to the memory upper bound'</body><body package="MemoryPolicyChecker">testPreferredGrowthIncrementLargerThanMinimumGranularity	self		assert: self preferredGrowthIncrement &gt; self minimumGrowthDueToAllocationFailure		description: 'The preferred growth increment must be larger than the minimum granularity growth'</body></methods><methods><class-id>AbstractMemoryPolicyChecker</class-id> <category>testing - free memory upper bound</category><body package="MemoryPolicyChecker">testFreeMemoryUpperBoundIsLargeEnough	self		assert: self freeMemoryUpperBound &gt; self availableSpaceSafetyMargin		description: 'The free memory upper bound should be larger than the available space safety margin'.	self		assert: self freeMemoryUpperBound &gt; self preferredGrowthIncrement		description: 'The free memory upper bound should be larger than the growth increment'.	self		assert: self freeMemoryUpperBound // 2 &gt;= self preferredGrowthIncrement		description: 'The free memory upper bound should be at least twice as large as the preferred growth increment'.	self		assert: self freeMemoryUpperBound &gt; self currentHardLowSpaceLimit		description: 'The free memory upper bound should be larger than the hard low space limit'.	self		assert: self freeMemoryUpperBound &gt; self initHardLowSpaceLimit		description: 'The free memory upper bound should be larger than the hard low space limit'.	self		assert: self freeMemoryUpperBound &gt; self newHardLowSpaceLimit		description: 'The free memory upper bound should be larger than the hard low space limit'.</body><body package="MemoryPolicyChecker">testFreeMemoryUpperBoundIsNotTooLarge	self		assert: self memoryUpperBound &gt; self freeMemoryUpperBound		description: 'The free memory upper bound should be less than the memory upper bound'.	self		assert: self memoryUpperBound &gt; (self freeMemoryUpperBound + self availableSpaceSafetyMargin)		description: 'The free memory upper bound should be significantly less than the memory upper bound'</body></methods><methods><class-id>AbstractMemoryPolicyChecker</class-id> <category>testing - preferred fixed growth increment</category><body package="MemoryPolicyChecker">testPreferredFixedGrowthIncrementIsLargeEnough	| minimumPreferredFixedGrowthIncrement |	minimumPreferredFixedGrowthIncrement := self defaultStartupFixedSpaceHeadroom.	self		assert: self preferredFixedGrowthIncrement &gt;= minimumPreferredFixedGrowthIncrement		description: 'The preferred growth increment should be larger than the minimum fixed space headroom'</body><body package="MemoryPolicyChecker">testPreferredFixedGrowthIncrementIsNotTooLarge	self		assert: self preferredFixedGrowthIncrement * 10 &lt; self memoryUpperBound		description: 'The preferred fixed growth increment seems too large in comparison to the memory upper bound'</body></methods><methods><class-id>AbstractMemoryPolicyChecker</class-id> <category>testing - sizes at startup</category><body package="MemoryPolicyChecker">testOldSpaceHeadroom	| oldSpaceHeadroom edenBytes survivorBytes stackFlushBytes enoughRtBytes minimumOldSpaceHeadroom |	oldSpaceHeadroom := self defaultStartupOldSpaceHeadroom * self startupOldSpaceHeadroomMultiplier.	edenBytes := self defaultStartupEdenSize * self startupEdenMultiplier.	survivorBytes := self defaultStartupSurvivorSemispaceSize * self startupSurvivorSemispaceMultiplier.	stackFlushBytes := self stackZoneFlushBytes / self stackBytes * self defaultStartupStackSize * self startupStackMultiplier.	enoughRtBytes := self rtBytes + self oldRtBytes * 2.	minimumOldSpaceHeadroom := edenBytes + survivorBytes + stackFlushBytes + enoughRtBytes.	self		assert: oldSpaceHeadroom &gt; minimumOldSpaceHeadroom		description: 'The old space headroom should be increased so that the image can perform a worst case scenario scavenge at startup'</body></methods><methods><class-id>AbstractMemoryPolicyChecker</class-id> <category>testing - space safety margins</category><body package="MemoryPolicyChecker">testAvailableSpaceSafetyMarginIsLargeEnough	| allRtBytes |	allRtBytes := self rtBytes + self oldRtBytes.	self		assert: self availableSpaceSafetyMargin // 2 &gt; allRtBytes		description: 'The available space safety margin should be increased to make sure the RTs can grow'.	self		assert: self availableSpaceSafetyMargin &gt; self newBytesAvailableForStorage		description: 'The available space safety margin should be increased to make sure a worst case scavenge will succeed'.	self		assert: self availableSpaceSafetyMargin &gt;= (allRtBytes * 2 + self newBytesAvailableForStorage)		description: 'The available space safety margin should be increased to avoid scavenger failure or failure to grow RTs'.	self		assert: self availableSpaceSafetyMargin &gt;= (allRtBytes * 2 + self newBytesAvailableForStorage + self largeBytes)		description: 'The available space safety margin should be increased to avoid scavenger failure, failure to grow RTs, or failure to scavenge large space'.	self		assert: self availableSpaceSafetyMargin &gt;= (allRtBytes * 2 + self newBytesAvailableForStorage + self largeBytes + self stackZoneFlushBytes)		description: 'The available space safety margin should be increased to avoid GC scavenger failure, failure to grow RTs, or failure to scavenge large space'.	self		assert: self availableSpaceSafetyMargin &gt; self contiguousSpaceSafetyMargin		description: 'The available space safety margin should be larger than the contiguous space safety margin'</body><body package="MemoryPolicyChecker">testContiguousSpaceSafetyMarginIsLargeEnough	self		assert: self contiguousSpaceSafetyMargin // 2 &gt; self rtBytes		description: 'The contiguous space safety margin should be increased to make sure the RT can grow'.	self		assert: self contiguousSpaceSafetyMargin &gt; self newBytesAvailableForStorage		description: 'The contiguous space safety margin should be increased to make sure a worst case scavenge will succeed'.	self		assert: self contiguousSpaceSafetyMargin &gt;= (self rtBytes * 2 + self newBytesAvailableForStorage)		description: 'The contiguous space safety margin should be increased to avoid scavenger failure or failure to grow RTs'.	self		assert: self contiguousSpaceSafetyMargin &gt;= (self rtBytes * 2 + self newBytesAvailableForStorage + self largeBytes)		description: 'The contiguous space safety margin should be increased to avoid scavenger failure, failure to grow RTs, or failure to scavenge large space'</body><body package="MemoryPolicyChecker">testPaddedAvailableSpaceSafetyMarginSize	self		assert: self paddedAvailableSpaceSafetyMargin - 262144 &gt; self availableSpaceSafetyMargin		description: 'The padding on the available space safety margin should be sizable'.	self		assert: self paddedAvailableSpaceSafetyMargin &lt; self freeMemoryUpperBound		description: 'The padded available space safety margin should be less than the free memory upper bound'</body></methods><methods><class-id>AbstractMemoryPolicyChecker</class-id> <category>testing - IGC</category><body package="MemoryPolicyChecker">testIncHardMinQuotaLargeEnough	self		assert: self incHardMinQuota &lt;= self incMarkQuota		description: 'The mark quota should be greater than the hard min quota'.	self		assert: self incHardMinQuota &lt;= self incSweepQuota		description: 'The sweep quota should be greater than the hard min quota'.	self		assert: self incHardMinQuota &lt;= self incUnmarkQuota		description: 'The unmark quota should be greater than the hard min quota'.</body></methods><methods><class-id>AbstractMemoryPolicyChecker class</class-id> <category>testing</category><body package="MemoryPolicyChecker">isAbstract	^self subclasses notEmpty</body></methods><methods><class-id>PotentialMemoryPolicyChecker</class-id> <category>testing - priorities</category><body package="MemoryPolicyChecker">testLowSpacePriorityIsHigherThanFinalizationPriority	self evaluateTestMethod: [super testLowSpacePriorityIsHigherThanFinalizationPriority]</body></methods><methods><class-id>PotentialMemoryPolicyChecker</class-id> <category>testing</category><body package="MemoryPolicyChecker">testIdleLoopAllocationThresholdIsLargeEnough	self evaluateTestMethod: [super testIdleLoopAllocationThresholdIsLargeEnough]</body><body package="MemoryPolicyChecker">testIncrementalAllocationThresholdIsLargeEnough	self evaluateTestMethod: [super testIncrementalAllocationThresholdIsLargeEnough]</body><body package="MemoryPolicyChecker">testMemoryUpperBoundMinimum	self evaluateTestMethod: [super testMemoryUpperBoundMinimum]</body><body package="MemoryPolicyChecker">testMemoryUpperBoundMinimumEnforced	self evaluateTestMethod: [super testMemoryUpperBoundMinimumEnforced]</body></methods><methods><class-id>PotentialMemoryPolicyChecker</class-id> <category>testing - free fixed memory upper bound</category><body package="MemoryPolicyChecker">testFreeFixedMemoryUpperBoundIsLargeEnough	self evaluateTestMethod: [super testFreeFixedMemoryUpperBoundIsLargeEnough]</body><body package="MemoryPolicyChecker">testFreeFixedMemoryUpperBoundIsNotTooLarge	self evaluateTestMethod: [super testFreeFixedMemoryUpperBoundIsNotTooLarge]</body></methods><methods><class-id>PotentialMemoryPolicyChecker</class-id> <category>testing - preferred growth increment</category><body package="MemoryPolicyChecker">testGrowthRetryDecrementIsLargeEnough	self evaluateTestMethod: [super testGrowthRetryDecrementIsLargeEnough]</body><body package="MemoryPolicyChecker">testGrowthRetryDecrementIsNotTooLarge	self evaluateTestMethod: [super testGrowthRetryDecrementIsNotTooLarge]</body><body package="MemoryPolicyChecker">testPreferredGrowthIncrementIsLargeEnough	self evaluateTestMethod: [super testPreferredGrowthIncrementIsLargeEnough]</body><body package="MemoryPolicyChecker">testPreferredGrowthIncrementIsNotTooLarge	self evaluateTestMethod: [super testPreferredGrowthIncrementIsNotTooLarge]</body><body package="MemoryPolicyChecker">testPreferredGrowthIncrementLargerThanMinimumGranularity	self evaluateTestMethod: [super testPreferredGrowthIncrementLargerThanMinimumGranularity]</body></methods><methods><class-id>PotentialMemoryPolicyChecker</class-id> <category>testing - free memory upper bound</category><body package="MemoryPolicyChecker">testFreeMemoryUpperBoundIsLargeEnough	self evaluateTestMethod: [super testFreeMemoryUpperBoundIsLargeEnough]</body><body package="MemoryPolicyChecker">testFreeMemoryUpperBoundIsNotTooLarge	self evaluateTestMethod: [super testFreeMemoryUpperBoundIsNotTooLarge]</body></methods><methods><class-id>PotentialMemoryPolicyChecker</class-id> <category>testing - redefinitions</category><body package="MemoryPolicyChecker">testTestSelectors	"PotentialMemoryPolicyChecker should redefine all the inherited test methods	so they run with various memory upper bound values.  This is not an ideal	solution, but vanilla-SUnit tests are strongly desirable for this application"	self assert:		(PotentialMemoryPolicyChecker testSelectors asSet remove: #testTestSelectors; yourself)			= AbstractMemoryPolicyChecker testSelectors asSet</body></methods><methods><class-id>PotentialMemoryPolicyChecker</class-id> <category>testing - sizes at startup</category><body package="MemoryPolicyChecker">testOldSpaceHeadroom	self evaluateTestMethod: [super testOldSpaceHeadroom]</body></methods><methods><class-id>PotentialMemoryPolicyChecker</class-id> <category>testing - growth regime upper bound</category><body package="MemoryPolicyChecker">testGrowthRegimeUpperBoundIsLargeEnough	self evaluateTestMethod: [super testGrowthRegimeUpperBoundIsLargeEnough]</body></methods><methods><class-id>PotentialMemoryPolicyChecker</class-id> <category>testing - preferred fixed growth increment</category><body package="MemoryPolicyChecker">testPreferredFixedGrowthIncrementIsLargeEnough	self evaluateTestMethod: [super testPreferredFixedGrowthIncrementIsLargeEnough]</body><body package="MemoryPolicyChecker">testPreferredFixedGrowthIncrementIsNotTooLarge	self evaluateTestMethod: [super testPreferredFixedGrowthIncrementIsNotTooLarge]</body></methods><methods><class-id>PotentialMemoryPolicyChecker</class-id> <category>testing - space safety margins</category><body package="MemoryPolicyChecker">testAvailableSpaceSafetyMarginIsLargeEnough	self evaluateTestMethod: [super testAvailableSpaceSafetyMarginIsLargeEnough]</body><body package="MemoryPolicyChecker">testContiguousSpaceSafetyMarginIsLargeEnough	self evaluateTestMethod: [super testContiguousSpaceSafetyMarginIsLargeEnough]</body><body package="MemoryPolicyChecker">testPaddedAvailableSpaceSafetyMarginSize	self evaluateTestMethod: [super testPaddedAvailableSpaceSafetyMarginSize]</body></methods><methods><class-id>PotentialMemoryPolicyChecker</class-id> <category>setup</category><body package="MemoryPolicyChecker">evaluateTestMethod: aBlock	"64 bit images may have larger fixed size spaces and so	require a larger lowestUpperBound.  Lower bounds can	be achieved by reconfiguring sizesAtStartup"	| previousBound policyClass |	policyClass := self memoryPolicy class.	previousBound := policyClass defaultMemoryUpperBound.	[		| lowestUpperBound |		lowestUpperBound := ObjectMemory is64Bit			ifTrue: [96 bitShift: 20]			ifFalse: [64 bitShift: 20].		lowestUpperBound to: (4 bitShift: 30) by: (32 bitShift: 20) do:			[:eachBound |				policyClass defaultMemoryUpperBound: eachBound.				aBlock value			]	] ensure: [policyClass defaultMemoryUpperBound: previousBound]</body></methods><methods><class-id>PotentialMemoryPolicyChecker</class-id> <category>testing - IGC</category><body package="MemoryPolicyChecker">testIncHardMinQuotaLargeEnough	self evaluateTestMethod: [super testIncHardMinQuotaLargeEnough]</body></methods><methods><class-id>LargeGrainMemoryPolicyChecker</class-id> <category>setup</category><body package="MemoryPolicyChecker">memoryPolicy	^LargeGrainMemoryPolicy new</body></methods><methods><class-id>MediumGrainMemoryPolicyChecker</class-id> <category>setup</category><body package="MemoryPolicyChecker">memoryPolicy	^MediumGrainMemoryPolicy new</body></methods><methods><class-id>CurrentMemoryPolicyChecker</class-id> <category>testing - soft and hard limits</category><body package="MemoryPolicyChecker">testCurrentHardLowSpaceLimitIsSufficient	self		assert: self minimumHardLowSpaceLimit &lt;= self currentHardLowSpaceLimit		description: 'The hard low space limit is not high enough to prevent scavenger failure'</body><body package="MemoryPolicyChecker">testCurrentSoftLowSpaceHigherThanHardLowSpace	"Under some circumstances, the soft low space limit	may be zero, thus lower than the hard low space limit"	self currentSoftLowSpaceLimit = 0 ifTrue: [^self].	self		assert: self currentSoftLowSpaceLimit &gt; self currentHardLowSpaceLimit		description: 'The soft low space limit should be higher than the hard low space limit'</body><body package="MemoryPolicyChecker">testInitialHardLowSpaceLimitIsSufficient	self		assert: self minimumHardLowSpaceLimit &lt;= self initHardLowSpaceLimit		description: 'The hard low space limit is not high enough to prevent scavenger failure'</body><body package="MemoryPolicyChecker">testInitialSoftLowSpaceHigherThanHardLowSpace	"Under some circumstances, the soft low space limit	may be zero, thus lower than the hard low space limit"	self initSoftLowSpaceLimit = 0 ifTrue: [^self].	self		assert: self initSoftLowSpaceLimit &gt; self initHardLowSpaceLimit		description: 'The soft low space limit should be higher than the hard low space limit'</body><body package="MemoryPolicyChecker">testNewHardLowSpaceLimitIsSufficient	self		assert: self minimumHardLowSpaceLimit &lt;= self newHardLowSpaceLimit		description: 'The hard low space limit is not high enough to prevent scavenger failure'</body><body package="MemoryPolicyChecker">testNewSoftLowSpaceHigherThanHardLowSpace	"Under some circumstances, the soft low space limit	may be zero, thus lower than the hard low space limit"	self newSoftLowSpaceLimit = 0 ifTrue: [^self].	self		assert: self newSoftLowSpaceLimit &gt; self newHardLowSpaceLimit		description: 'The soft low space limit should be higher than the hard low space limit'</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>TestCase</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestAsserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class></st-source>