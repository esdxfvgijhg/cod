<?xml version="1.0"?><st-source><!-- Name: Browser-RefactoringsNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Portions © 1998-2002 The Refactory, IncComment: The actual refactorings that the RB performs. These are intended to preserve the behavior of the program.DbIdentifier: bear73DbTrace: 500021DbUsername: cgundelDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'Browser-Environments' '') #(#any 'Browser-ChangeObjects' ''))PackageName: Browser-RefactoringsParcel: #('Browser-Refactorings')ParcelName: Browser-RefactoringsPrerequisiteParcels: #(#('Browser-Environments' '') #('Browser-ChangeObjects' ''))PrintStringCache: (8.3 - 1,cgundel)Version: 8.3 - 1Pre-Unload Block: 	[:package | ]Date: 3:26:53 PM June 30, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (jun17.4) of June 23, 2017 on June 30, 2017 at 3:26:53 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>Refactoring</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model options methodClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.Refactoring</class-id><body>Refactoring is the abstract superclass of all the refactorings in the system. A refactoring is a behavior-preserving source-to-source transformation. Every refactoring has a set of preconditions that must be met for the refactoring to be legally applied. Several refactorings require additional information from the user. The options dictionary allows this information to either be obtained from the user, or be client-specified, depending upon the block stored in a particular named option.Subclasses must implement the following messages:	preconditions		preconditions	transforming		transformInstance Variables:	methodClass	&lt;RBAbstractClass&gt;	The class of the method currently being transformed. This is kind of ugly, but allows communication between the refactoring and the rewriter.	model	&lt;RBRootNamespace&gt;	The model to perform the refactoring against.	options	&lt;Dictionary key: Symbol value: BlockClosure&gt;	Dictinoary of named options. The value of each option is obtained at runtime by evaluating the corresponding block.Shared Variables:	RefactoringsOptions	&lt;Dictionary key: Symbol value: BlockClosure&gt;	the default options for the options instance variable</body></comment><class><name>MethodRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.Refactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.MethodRefactoring</class-id><body>MethodRefactoring is the abstract superclass of all refactorings that operate on an entire method.Instance Variables:	class	&lt;RBAbstractClass&gt;	The class that contains the method to refactor.</body></comment><class><name>MoveVariableDefinitionRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.MethodRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector interval name sourceTree blockNodes definingNode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.MoveVariableDefinitionRefactoring</class-id><body>MoveVariableDefinitionRefactoring moves the definition of a temporary within a method into the tightest-binding scope.Instance Variables:	blockNodes	&lt;(Collection of: RBBlockNode)&gt;	The set of block nodes that will get the new definition.	definingNode	&lt;RBSequenceNode&gt;	The node that currently defines the variable.	interval	&lt;Interval&gt;	The interval into the source code of the original variable definition	name	&lt;String&gt;	The name of the variable to move	sourceTree	&lt;RBProgramNode&gt;	The parse tree of the method to transform.	selector	&lt;Symbol&gt;	The name of the method to transform</body></comment><class><name>VariableRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.Refactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class variableName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.VariableRefactoring</class-id><body>VariableRefactoring is the abstract superclass of refactorings that manipulate variables.Instance Variables:	class	&lt;RBAbstractClass&gt;	The class containing the variable to refactor.	variableName	&lt;String&gt;	The name of the variable to refactor.</body></comment><class><name>ProtectInstanceVariableRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.VariableRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.ProtectInstanceVariableRefactoring</class-id><body>ProtectInstanceVariableRefactoring is the opposite of AbstractInstancVariableRefactoring. It replaces all self calls to accessors with direct references to the variable. If there are no more senders of the accessors, they are removed.</body></comment><class><name>RemoveInstanceVariableRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.VariableRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RemoveInstanceVariableRefactoring</class-id><body>RemoveInstanceVariableRefactoring removes an instance variable if it is unreferenced.</body></comment><class><name>ExtractMethodToComponentRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.MethodRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector extractionInterval extractedMethodSelector sourceTree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.ExtractMethodToComponentRefactoring</class-id><body>ExtractMethodToComponentRefactoring is a composite refactoring that extracts a portion of code from a method and creates a method implementing that code on a class that the original class has a reference to either through an instance variable or a temporary variable.Instance Variables:	extractedMethodSelector	&lt;Symbol&gt;	Name of the extracted method.	extractionInterval	&lt;Interval&gt;	Interval within the original source to extract.	selector	&lt;Symbol&gt;	Selector to extract code from.	parseTree &lt;ProgramNode&gt; the parse tree of the method being worked on, may be preset by clients</body></comment><class><name>AbstractVariablesRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.Refactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tree fromClass instVarReaders instVarWriters toClasses ignore sharedVariableReaders sharedVariableWriters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.AbstractVariablesRefactoring</class-id><body>AbstractVariablesRefactoring modifies a parse tree to replace all references to variables that don't exist in the scope of toClasses but did exist in fromClass. This allows the parse tree to be moved into toClasses.Instance Variables:	fromClass	&lt;RBAbstractClass&gt;	The class that the parseTree current resides in.	ignore	&lt;String&gt;	The name of a variable to ignore during the transformation.	instVarReaders	&lt;Set of: String&gt;	Instance variables read by parse tree.	instVarWriters	&lt;Set of: String&gt;	Instance variables written parse tree.	sharedVariableReaders	&lt;Set of: String&gt;	Shared Variables read by parse tree.	sharedVariableWriters	&lt;Set of: String&gt;	Shared Variables written by parse tree.	toClasses	&lt;Collection or: RBAbstractClass&gt;	Classes whose scopes the parse tree must be transformed to exist within.	tree	&lt;RBProgramNode&gt;	ParseTree to transform</body></comment><class><name>RBAbstractCondition</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>errorMacro </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Conditions</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RBAbstractCondition</class-id><body>RBAbstractCondition is an abstract class. It represents a precondition that is used whenever a Refactoring is performed. All preconditions must evaluate successfully in order for the Refactoring to be performed.Subclasses must implement the following messages:	checking		checkInstance Variables:	errorMacro	&lt;String&gt;	the error string that is used when the condition fails</body></comment><class><name>RefactoringError</name><environment>Refactory.Browser</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Support</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RefactoringError</class-id><body>RefactoringError is signaled whenever a refactoring's precondition is violated.</body></comment><class><name>RenameInstanceVariableRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.VariableRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>newName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RenameInstanceVariableRefactoring</class-id><body>RenameInstanceVariableRefactoring renames an instance variable and updates all references.Instance Variables:	newName	&lt;String&gt;	The new name of the instance variable</body></comment><class><name>RBMethod</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class compiledMethod source selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Model</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RBMethod</class-id><body>RBMethod is the RB's model's representation of a method.Instance Variables:	class	&lt;RBAbstractClass&gt;	The class containing this method	compiledMethod	&lt;CompiledCode&gt;	The compiled form of this method.	parcels	&lt;Collection of: Parcel&gt;	The parcels to which this method belongs.	selector	&lt;Symbol&gt;	This method's selector.	source	&lt;String&gt;	The source code of the method.</body></comment><class><name>RBProgramItem</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isPrivate name environment binding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Model</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RBProgramItem</class-id><body>RBProgramItem is the abstract superclass of all of the classes in the RB's model of the system. This model is maniuplated by the Refactorings instead of the system. When this model is manipulated, it generates a CompositeChangeObject. When this ChangeObject is executed, it changes the system to match the model.Subclasses must implement the following messages:	private		basicRemoveInstance Variables:	category	&lt;Symbol&gt;	The category/protocol that this object resides in.	environment	&lt;RBNamespace&gt;	The namespace that contains this object.	isPrivate	&lt;Boolean&gt;	True if this object is private to its containing namespace.	name	&lt;String&gt;	The name of the object.	parcels	&lt;Collection of: Parcel&gt;	The parcels that contain this object.	realItem	&lt;BlockClosure | DeferredBinding | VariableBinding | nil&gt;	The system object (if any) that this model object represents.</body></comment><class><name>RBBasicNameSpace</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>removedItems items imports </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Model</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RBBasicNameSpace</class-id><body>RBBasicNamespace is the abstract superclass of all of the Namespace-like entities in the RB's model of the system.Subclasses must implement the following messages:	private		recompileObjectInstance Variables:	imports	&lt;(Collection of: NameSpaceImport)&gt;	Namespaces imported by this namespace.	items	&lt;Dictionary&gt;	Things added to the model that aren't in the real system.	removedItems	&lt;Collection&gt;	Things removed from the model that are in the real system.</body></comment><class><name>RBAbstractClass</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBBasicNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>newMethods instanceVariableNames superclass subclasses removedMethods </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Model</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RBAbstractClass</class-id><body>RBAbstractClass is an abstract class. It represents classes in the system. Refactorings operate on these objects, producing change objects. These change objects are then performed on the real code.Subclasses must implement the following messages:	accessing		metaclass		nonMetaclass	testing		isAbstract		isMetaInstance Variables:	instanceVariableNames	&lt;SequenceableCollection of: String&gt;	instance variables that the class defines	newMethods	&lt;Dictionary of: RBMethod&gt;	methods that have been added to the class	removedMethods	&lt;Collection of: Symbol&gt;	method names that have been removed	subclasses	&lt;Collection of: RBAbstractClass&gt;	my subclasses	superclass	&lt;RBAbstractClass&gt;	the superclass (or LookupSuperclass if we haven't assigned it yet).Class Variables:	LookupSuperclass	&lt;Object&gt;	a special object denoting that our superclass hasn't been assigned yet</body></comment><class><name>RBMetaclass</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBAbstractClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nonMetaclass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Model</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RBMetaclass</class-id><body>RBMetaclass is the RB's model's representation of a metaclass.Instance Variables:	nonMetaclass	&lt;RBClass&gt;	Our class</body></comment><class><name>MoveMethodRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.MethodRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector variable moveToClasses parseTree hasOnlySelfReturns selfVariableName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.MoveMethodRefactoring</class-id><body>MoveMethodRefactoring moves a method from one class to another. The original class must have a reference to the new class. The original method is then replaced with a forwarding call to the new method. This maintains the interface of the original class. To eliminate the forwarder, you can use the inline method refactoring.Instance Variables:	hasOnlySelfReturns	&lt;Boolean&gt;	True if the method to be moved only returns self.	moveToClasses	&lt;(Collection of: RBAbstractClass)&gt;	The set of classes that method will be moved to.	parseTree	&lt;RBMethodNode&gt;	The parse tree of the method being moved.	selector	&lt;Symbol&gt;	The name of the method being moved.	selfVariableName	&lt;String&gt;	The name of the parameter used to pass the original 'self' into the moved method.	variable	&lt;String&gt;	The variable from the original method's scope that contains the reference to the class that we are moving the method to.</body></comment><class><name>RefactoringWarning</name><environment>Refactory.Browser</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Support</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RefactoringWarning</class-id><body>RefactoringWarning is a non-fatal warning that usually requires the user to validate. This is used in situations where either the behavior of the program will not be strictly preserved or the change may have a wider impact than the user may think.</body></comment><class><name>PushUpMethodRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.MethodRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>removeDuplicates selectors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.PushUpMethodRefactoring</class-id><body>PushUpMethodRefactoring removes a set of methods from a class and defines them in the superclass.Instance Variables:	removeDuplicates	&lt;Boolean&gt;	If true, we removed duplicated methods from the subclasses.	selectors	&lt;(Collection of: Symbol)&gt;	Set of methods to push up.</body></comment><class><name>ExtractToTemporaryRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.MethodRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceInterval selector newVariableName sourceTree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.ExtractToTemporaryRefactoring</class-id><body>ExtractToTemporaryRefactoring extracts a portion of code and assigns it to a new temporary variable.Instance Variables:	newVariableName	&lt;String&gt;	The name of the new temporary.	sourceTree	&lt;RBProgramNode&gt;	Parse tree to modify.	selector	&lt;Symbol&gt;	Selector of the method to modify.	sourceInterval	&lt;Interval&gt;	Interval into the original source to extract.</body></comment><class><name>RBNameSpace</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBBasicNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Model</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RBNameSpace</class-id><body>RBNamespace is the RB's models representation of a Namespace.</body></comment><class><name>RefactoryTyper</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model class variableTypes bestGuesses variableMessages backpointers methodName selectorLookup </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Support</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RefactoryTyper</class-id><body>RefactoryTyper can figure of types of variables based on the set of messages sent to them. This is used to suggest classes in the move method refactoring and to generate the default comment for uncommented classes.Instance Variables:	backpointers	&lt;Dictionary&gt;	a pointer from variables and methods to the methods that return them (e.g., if a method return a variable, then there will be a variable -&gt; method link).	bestGuesses	&lt;Dictionary&gt;	the best guesses for the variable types	class	&lt;RBAbstractClass&gt;	the class we are performing the type analysis on	methodName	&lt;Symbol&gt;	the name of the method we are currently looking at	model	&lt;RBRootNamespace&gt;	the model we are performing type analysis on	selectorLookup	&lt;Dictionary&gt;	map from selectors to classes that implement the selector	variableMessages	&lt;Dictionary&gt;	the messages sent to each variable	variableTypes	&lt;Dictionary&gt;	the possible variable types</body></comment><class><name>ClassRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.Refactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>className </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.ClassRefactoring</class-id><body>ClassRefactoring is the abstract superclass of all refactorings that create new classes (or globals).Instance Variables:	className	&lt;String&gt;	Name of the new class.</body></comment><class><name>RenameObjectRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ClassRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>newName object </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RenameObjectRefactoring</class-id><body>RenameObjectRefactoring changes the name of a global object (class, shared var., etc.) and updates all references. It also updates all symbols that match the original name.Instance Variables:	newName	&lt;String&gt;	Name to rename to.	object	&lt;RBAbstractClass&gt;	The model object that is being renamed.</body></comment><class><name>RenameObjectAndMethodsRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RenameObjectRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodRefactorings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RenameObjectAndMethodsRefactoring</class-id><body>RenameObjectAndMethodsRefactoring will raise a warning offering to rename a method whose selector fits one of the hard-coded patterns and contains the class name.  (This occurs only when renaming a class;  namespaces and shared variables are not checked.)Later, provide a pragma means of adding to the patterns.</body></comment><class><name>InlineAllSelfSendersRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.MethodRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector numberReplaced numberNotReplaced </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.InlineAllSelfSendersRefactoring</class-id><body>InlineAllSelfSendersRefactoring this composite refactoring inlines all self sends of a method. If, after the inlining, there are no references to the method, it is removed.Instance Variables:	numberNotReplaced	&lt;ArithmeticValue&gt;	Number of sends not inlined.	numberReplaced	&lt;ArithmeticValue&gt;	Number of send inlined.	selector	&lt;Symbol&gt;	Selector of method to inline.</body></comment><class><name>ChangeMethodNameRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.MethodRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>newSelector oldSelector permutation implementors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.ChangeMethodNameRefactoring</class-id><body>ChangeMethodNameRefactoring is the abstract superclass of all refactorings that change a method name somehow. Therefore, all references to the method must be updated. Note that since we can't distinguish between method sends, we must transform _all_ implementors of the method.Subclasses must implement the following messages:	preconditions		myConditions	Returns the Condition object that must be satisfied for the refactoring to be valid.Instance Variables:	implementors	&lt;(Collection of: RBAbstractClass)&gt;	All of the classes that implement this method.	newSelector	&lt;Symbol&gt;	The selector to be changed to.	oldSelector	&lt;Symbol&gt;	The original selector.	permutation	&lt;(SequenceableCollection of: Integer)&gt;	The permutation of the original argument list to the new argument list.</body></comment><class><name>RemoveParameterRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ChangeMethodNameRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parameterIndex argument </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RemoveParameterRefactoring</class-id><body>RemoveParameterRefactoring removes an unreferenced parameter from a method signature (and updates all calls).Instance Variables:	argument	&lt;String&gt;	The name of the argument to remove.	parameterIndex	&lt;Integer&gt;	The position of the parameter in the parameter list.</body></comment><class><name>InlineParameterRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RemoveParameterRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expressions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.InlineParameterRefactoring</class-id><body>InlineParameterRefactoring removes a parameter from a method and replaces it with a temporary in the body of the method and an assignment if every call to the method assigns the same, constant value to the parameter.Instance Variables:	expressions	&lt;(SequenceableCollection of: RBProgramNode)&gt;	All expressions assigned to the parameter.</body></comment><class><name>ExpandNameSpaceReferencesRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.Refactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fromClass toClasses referencedVars parseTree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.ExpandNameSpaceReferencesRefactoring</class-id><body>ExpandNamespaceReferenceRefactoring is a refactoring that expands a Namespaces's scope for a method that is being moved from one class to another. This refactoring is primarily used to support other, more complicated refactorings such as MoveMethod.Instance Variables:	fromClass	&lt;RBClass&gt;			The class that the method is being moved from.	parseTree	&lt;RBProgramNode&gt;	The method whose pool references need to be expanded.	referencedVars	&lt;Collection of: Symbol&gt;	The collection of Namespace References in parseTree.	toClasses	&lt;Collection of: RBClass&gt;	The classes into which the pools must be expanded.</body></comment><class><name>PullUpInstanceVariableRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.VariableRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.PullUpInstanceVariableRefactoring</class-id><body>PullUpInstanceVariableRefactoring removes an instance variable from all subclasses that define it and defines it in the superclass.</body></comment><class><name>RBInitializerMethod</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBMethod</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sharedVariable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Model</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RBInitializerMethod</class-id><body>RBInitializerMethod is the RB's model's representation of an initializer method for a Shared Variable.Instance Variables:	sharedVariable	&lt;RBSharedVariable&gt;	The shared variable for which we are the initializer.</body></comment><class><name>AbstractInstanceVariableRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.VariableRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessorsRefactoring </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.AbstractInstanceVariableRefactoring</class-id><body>AbstractInstanceVariableRefactoring is the refactoring that 1) creates accessors for the instance variable if they don't exist and 2) replaces all direct references to the instance variable will calls to either the setter or getter. It uses the CreateAccessorsForVariableRefactoring as a component.Instance Variables:	accessorsRefactoring	&lt;CreateAccessorsForVariableRefactoring&gt;	The component refactoring that creates the accessors.</body></comment><class><name>AddClassRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ClassRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass subclasses attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.AddClassRefactoring</class-id><body>AddClassRefactoring adds an unreferenced class. This can be used to insert an empty class into the middle of the hierarchy.Instance Variables	attributes	&lt;Array&gt;	extraAttributesForDefinition if the new class has any, otherwise empty.	subclasses	&lt;(Collection of: RBClass)&gt;	Existing classes that are to be subclasses of the new class. 												Note: These must be subclasses of superclass.	superclass	&lt;RBClass&gt;	The (existing) superclass of the new class.</body></comment><class><name>PushDownMethodRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.MethodRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.PushDownMethodRefactoring</class-id><body>PushDownMethodRefactoring moves a set of methods from a class into all of its subclasses. This can only be done if the original class is abstract and there are no self sends of the method in that class. This takes a set of selectors since sometimes a group should be in a subclass, but they all refer to each other.Instance Variables:	selectors	&lt;(Collection of: Symbol)&gt;	Selectors to push down</body></comment><class><name>AddParameterRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ChangeMethodNameRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>initializer newArgName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.AddParameterRefactoring</class-id><body>AddParameterRefactoring adds a parameter to a method. All calls to the method are updated with the additional parameter with the value of initializer.Instance Variables:	initializer	&lt;String&gt;	Default value of new parameter.</body></comment><class><name>RBClass</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBAbstractClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars>metaclass indexedType attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Model</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RBClass</class-id><body>RBClass is RB's model's representation of a class.Instance Variables:	indexedType	&lt;ByteSymbol&gt;	Type of indexing for this class.	metaclass	&lt;RBAbstractClass&gt;	The model's metaclass for this class.</body></comment><class><name>RBMethodName</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Support</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RBMethodName</class-id><body>RBMethodName is a first-class representation of the name of a method along with its arguments.Instance Variables:	arguments	&lt;OrderedCollection of: RBProgramNode&gt;	The arguments to the method.	selector	&lt;Symbol&gt;	The name of the method.</body></comment><class><name>RenameMethodRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ChangeMethodNameRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hasPermutedArguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RenameMethodRefactoring</class-id><body>RenameMethodRefactoring renames a method and updates all selectors in the image. Note that this will rename ALL implementors of a selector, thus preserving behavior. Also note that this will rename all symbols in the image matching the selector.Instance Variables:	hasPermutedArguments	&lt;Boolean&gt;	True if the arguments occur in a different order after the rename.</body></comment><class><name>RBRootNameSpace</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>implementorsCache sendersCache changes rootClasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Model</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RBRootNameSpace</class-id><body>RBRootNamespace is the RB's model's representation of the system's Root namespace. This also holds the changes that the model's manipulation has generated and the cached results of senders and implementors queries.Instance Variables:	changes	&lt;RefactoryChange&gt;	The change that has been generated by the manipulation of the model.	implementorsCache	&lt;Dictionary key: Symbol value: (Set of: RBAbstractClass)&gt;	Mapping from selectors to the classes that implement that selector.	sendersCache	&lt;Dictionary key: Symbol value: (Set of: RBMethod) &gt;	Mapping from selectors to the methods that refer to that selector.	rootClasses	&lt;Collection of: RBAbstractClass&gt;	Classes stored in the Root namespace.</body></comment><class><name>RBConjunctiveCondition</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBAbstractCondition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>left right failed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Conditions</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RBConjunctiveCondition</class-id><body>ConjunctiveCondition represents and-ing two AbstractConditions together.Instance Variables:	failed	&lt;Symbol&gt;	which condition failed (#leftFailed, #rightFailed, or #unknownFailed)	left	&lt;RBAbstractCondition&gt;	the condition on the left side of the and	right	&lt;RBAbstractCondition&gt;	the condition on the right side of the and</body></comment><class><name>InlineMethodRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.MethodRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceInterval inlineParseTree sourceSelector sourceMessage inlineClass sourceTree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.InlineMethodRefactoring</class-id><body>InlineMethodRefactoring replaces a call to a method by body of that method. This is often used to get rid of forwarding methods left behind from earlier refactorings.Instance Variables:	inlineClass	&lt;RBAbstractClass&gt;	The class that contains the method to inline.	inlineParseTree	&lt;RBMethodNode&gt;	The parse tree of the method to inline.	sourceInterval	&lt;Interval&gt;	The interval into the original source of the call to inline.	sourceMessage	&lt;RBProgramNode&gt;	The subtree of the call to inline.	sourceTree	&lt;RBMethodNode&gt;	The parse tree of the method containing the call to inline.	sourceSelector	&lt;Symbol&gt;	The selector of the method containing the call to inline.</body></comment><class><name>InlineTemporaryRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.MethodRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceInterval selector sourceTree assignmentNode definingNode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.InlineTemporaryRefactoring</class-id><body>InlineTemporaryRefactoring replaces all references to a singly-assigned temporary with the right-hand side of that assignment.Instance Variables:	assignmentNode	&lt;RBAssignmentNode&gt;	The assignment statement to inline.	definingNode	&lt;RBSequenceNode&gt;	The sequence node that defines the variable that we are inlining away.	selector	&lt;Symbol&gt;	The selector of the method to transform.	sourceInterval	&lt;Interval&gt;	The interval into the original source of the code to inline.	sourceTree	&lt;RBProgramNode&gt;	Parse tree of the method to transform.</body></comment><class><name>ExtractMethodRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.MethodRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector extractionInterval extractedParseTree modifiedParseTree parameters needsReturn sourceTree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.ExtractMethodRefactoring</class-id><body>ExtractMethodRefactoring extracts a portion of code as a new method. Don't try to understand it. John is afraid of it. It works for nearly all cases.Instance Variables:	sourceTree &lt;RBProgramNode&gt; the source parse tree, can be set by clients, or will be lazily cached from class/selector	extractedParseTree	&lt;RBProgramNode&gt;	The subtree of the parse tree to extract.	extractionInterval	&lt;Interval&gt;	The interval within the original source code of the text to extract.	modifiedParseTree	&lt;RBProgramNode&gt;	The resulting parse tree of the original method after the extraction.	needsReturn	&lt;Boolean&gt;	True if the extracted method is used as an rvalue.	parameters	&lt;Collection of: String&gt;	Parameters that must be passed to extracted method.	selector	&lt;Symbol&gt;	Name of the extracted method.</body></comment><class><name>RenameTemporaryRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.MethodRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector interval oldName newName sourceTree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RenameTemporaryRefactoring</class-id><body>RenameTemporaryRefactoring renames a temporary variable within a method.Instance Variables:	interval	&lt;Interval&gt;	The selection within the code of the variable to rename.	newName	&lt;String&gt;	New name for the variable.	oldName	&lt;String&gt;	Original name for the variable.	selector	&lt;Symbol&gt;	The selector of the method containing the variable to be renamed.	sourceTree &lt;ProgramNode&gt; parse tree of method to rewrite</body></comment><class><name>RBSharedVariable</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>initializer constant category </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Model</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RBSharedVariable</class-id><body>RBSharedVariable is the RB's model's representation of shared variables.Instance Variables	constant		&lt;Boolean&gt;	True if the shared variable is constant.	initializer	&lt;RBInitializerMethod&gt;	The initialization code for the variable.</body></comment><class><name>InlineMethodFromComponentRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.InlineMethodRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.InlineMethodFromComponentRefactoring</class-id><body>InlineMethodFromComponentRefactoring inlines the body of a method of another class.</body></comment><class><name>Condition</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBAbstractCondition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block type errorBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Conditions</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.Condition</class-id><body>Condition represents a condition that must be true for a refactoring to be performed.Instance Variables:	block	&lt;BlockClosure&gt;	this is the block that gets evaluated to check the condition	errorBlock	&lt;BlockClosure | nil&gt;	if not nil, this is a block that if the condition fails, will produce some means of browsing the failure (such as opening a browser on the failures)	type	&lt;Array&gt;		This array holds a symbol identifying the type of condition this is along						with its parameters. Right now this is pretty useless, other than for printing,						but in the future, we hope to be able to use this to assert postconditions of						refactorings.</body></comment><class><name>RemoveMethodRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.MethodRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RemoveMethodRefactoring</class-id><body>RemoveMethodRefactoring removes a set of methods if they are not called. If there are any calls to any of the selectors, the refactoring fails.Instance Variables:	selectors	&lt;(Collection of: Symbol)&gt;	The selectors of the methods to remove</body></comment><class><name>CreateAccessorsForVariableRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.VariableRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>getterMethod setterMethod needsReturn </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.CreateAccessorsForVariableRefactoring</class-id><body>CreateAccessorsForVariableRefactoring creates simple accessors for an instance variable. If a simple accessor already exists (regardless of the name of the method), it does nothing. If a method name already exists that matches the instance variable name, a unique name is generated by appending a number.Instance Variables:	getterMethod	&lt;Symbol&gt;	Selector of the getter method	setterMethod	&lt;Symbol&gt;	Selector of the setter method	needsReturn	&lt;Boolean&gt;	True if the generated setter needs a return (an assignment was used as an rvalue somewhere).</body></comment><class><name>RBNegationCondition</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBAbstractCondition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>condition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Conditions</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RBNegationCondition</class-id><body>NegationCondition represents negating another condition.Instance Variables:	condition	&lt;RBAbstractCondition&gt;	the condition that is to be negated</body></comment><class><name>MoveObjectRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.Refactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object targetScope originalScope referencesTo fromReferences </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.MoveObjectRefactoring</class-id><body>I move an object (class, namespace) from it's current scope to another.There are basically two parts to this refactoring, aside from the actual move. When the object is moved, we must look at all references to it and determine what changes need to be made to them. We call these "to" references. We also have to consider everything that the object itself references, and consider whether they need to be adjusted to accommodate the new home of the object. We call these "from" references.An additional term that shows up in this work is the term "outer referencing variable". This is basically what we used to call "globals". It is a reference to any namespace, class, or share. Or otherwords, any thing that is above the scope of an instance variable.Instance Variables	targetScope 	&lt;RBProgramItem&gt; the namespace we're moving to	originalScope &lt;RBProgramItem&gt; the namespace we moved from, captured when the object is set	object	&lt;RBProgramItem&gt;	The model object that is being relocated.</body></comment><class><name>AddInstanceVariableRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.VariableRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.AddInstanceVariableRefactoring</class-id><body>AddInstanceVariableRefactoring adds an unreferenced instance variable to a class.</body></comment><class><name>TemporaryToInstanceVariableRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.MethodRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector temporaryVariableName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.TemporaryToInstanceVariableRefactoring</class-id><body>TemporaryToInstanceVariableRefactoring promotes a temporary of a method to an instance variable of the containing class. This is usually performed in the context of a Method Object refactoring to eliminate a large, complex method.Instance Variables:	selector	&lt;Symbol&gt;	Name of the method containing the temporary variable.	temporaryVariableName	&lt;String&gt;	The name of the variable to convert.</body></comment><class><name>ChildrenToSiblingsRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ClassRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.ChildrenToSiblingsRefactoring</class-id><body>ChildrenToSiblingsRefactoring converts a concrete superclass with concrete subclasses into an abstract superclass with all concrete subclasses. This refactoring creates the new superclass, rearranges the hierarchy, and moves the formerly inherited methods and instance variables into the new abstract class.Instance Variables:	parent	&lt;RBAbstractClass&gt;	Original concrete superclass	subclasses	&lt;(Collection of: RBAbstractClass)&gt;	Subclasses of parent which are to become it's siblings.</body></comment><class><name>RemoveObjectRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.Refactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.RemoveObjectRefactoring</class-id><body>RemoveObjectRefactoring removes unreferenced global objects (classes, shared vars, etc.). It can also remove empty classes from the middle of hierarchies, reparenting all of its children.Instance Variables:	objectNames	&lt;(Collection of: String)&gt;	Names of the objects to remove.</body></comment><class><name>PushDownInstanceVariableRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.VariableRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.PushDownInstanceVariableRefactoring</class-id><body>PushDownInstanceVariableRefactoring removes and instance variable from a class and defines in only those subclasses that reference it.</body></comment><class><name>CompositeRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.Refactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>refactorings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.CompositeRefactoring</class-id><body>CompositeRefactoring is a refactoring that is composed of smaller refactorings. Since each step is supposed to be behavior-preserving, the composition is behavior-preserving.Instance Variables:	refactorings	&lt;(SequenceableCollection of: Refactoring)&gt;	The refactorings that comprise this one.</body></comment><class><name>AddMethodRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.MethodRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>protocols source </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Refactorings</category><attributes><package>Browser-Refactorings</package></attributes></class><comment><class-id>Refactory.Browser.AddMethodRefactoring</class-id><body>AddMethodRefactoring adds a new method to a classInstance Variables:	protocols	&lt;Collection of: SYmbol&gt;	Protocols to compile method into.	source	&lt;String&gt;	Method source code</body></comment><shared-variable><name>RefactoringOptions</name><environment>Refactory.Browser.Refactoring</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Browser-Refactorings</package></attributes></shared-variable><shared-variable><name>LookupSuperclass</name><environment>Refactory.Browser.RBAbstractClass</environment><private>false</private><constant>false</constant><category>private-statics</category><initializer>Core.Object new</initializer><attributes><package>Browser-Refactorings</package></attributes></shared-variable><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>testing</category><body package="Browser-Refactorings">canReferenceVariable: aString in: aClass 	^(aClass referencedItem: aString) notNil 		or: [aClass definesInstanceVariable: aString]</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>accessing</category><body package="Browser-Refactorings">changes	^self model changes</body><body package="Browser-Refactorings">copyOptionsFrom: aDictionary 	| dict |	dict := self options.	dict == self class refactoringOptions 		ifTrue: [^self options: aDictionary copy].	dict keysAndValuesDo: 			[:key :value | 			value == (self class refactoringOptions at: key) 				ifTrue: [dict at: key put: (aDictionary at: key)]].	self options: dict</body><body package="Browser-Refactorings">options	^options isNil ifTrue: [self class refactoringOptions] ifFalse: [options]</body><body package="Browser-Refactorings">options: aDictionary 	options := aDictionary</body><body package="Browser-Refactorings">setOption: aSymbol toUse: aBlock	| dict |	dict := self options.	dict == self class refactoringOptions ifTrue: [self options: dict copy].	^self options at: aSymbol put: aBlock</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>support</category><body package="Browser-Refactorings">checkClass: aRBClass selector: aSelector using: aMatcher 	| parseTree |	parseTree := aRBClass parseTreeFor: aSelector.	parseTree notNil ifTrue: [aMatcher executeTree: parseTree].	^aMatcher answer</body><body package="Browser-Refactorings">convertAllReferencesTo: aSymbol using: searchReplacer 	self model allReferencesTo: aSymbol		do: [:method | self convertMethod: method using: searchReplacer]</body><body package="Browser-Refactorings">convertAllReferencesToObject: aRBProgramItem using: searchReplacer 	self model allReferencesToObject: aRBProgramItem		do: [:method | self convertMethod: method using: searchReplacer]</body><body package="Browser-Refactorings">convertClasses: classSet select: aBlock using: searchReplacer 	classSet do: 			[:aClass | 			(aBlock value: aClass) 				do: [:selector | self convertMethod: (aClass methodFor: selector) using: searchReplacer]]</body><body package="Browser-Refactorings">convertMethod: aMethod using: searchReplacer 	"Convert the parse tree for selector using the searchReplacer. If a	change is made then compile it into the changeBuilder."	| parseTree |	methodClass := aMethod modelClass.	parseTree := aMethod parseTree.	parseTree isNil 		ifTrue: 			[methodClass := nil.			^self].	(searchReplacer executeTree: parseTree) 		ifTrue: [aMethod compileTree: searchReplacer tree].	methodClass := nil</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">checkPreconditions	| conditions block |	conditions := self preconditions.	conditions check 		ifFalse: 			[block := conditions errorBlock.			block notNil 				ifTrue: [self refactoringError: conditions errorString with: block]				ifFalse: [self refactoringError: conditions errorString]]</body><body package="Browser-Refactorings">offerReviewChangesOption	"Generically-phrased button lets the user see the change list before executing whether that option is set on their browser or not.  Override it, or pass a different parameter to the refactoring warning, if a particular refactoring warning wants more specific behaviour, or just more specific button text."	^self promptOnRefactoring ifFalse:	"ifTrue: [nil]; already set, don't ask again"		['Show changes...' -&gt;			[self setOption: #promptOnRefactoring toUse: true]]"Evaluating returns true, so the refactoring will resume after executing it if the option is chosen."</body><body package="Browser-Refactorings">preconditions	self subclassResponsibility</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>private</category><body package="Browser-Refactorings">classObjectFor: anObject 	anObject isBehavior ifTrue: [^self model classFor: anObject].	anObject isString ifTrue: [^self model classNamed: anObject].	^anObject</body><body package="Browser-Refactorings">methodClass	^methodClass</body><body package="Browser-Refactorings">onError: aBlock do: errorBlock 	^aBlock on: self class preconditionSignal		do: 			[:ex | 			errorBlock value.			ex return: nil]</body><body package="Browser-Refactorings">primitiveExecute	self checkPreconditions.	self transform</body><body package="Browser-Refactorings">refactoringError: aString 	RefactoringError raiseSignal: aString</body><body package="Browser-Refactorings">refactoringError: aString with: aBlock 	RefactoringError raiseSignal: aString with: aBlock</body><body package="Browser-Refactorings">refactoringWarning: aString 	RefactoringWarning raiseSignal: aString</body><body package="Browser-Refactorings">refactoringWarning: aString with: aStringBlockAssociation	"Warnings, like errors, may need a third alternative to resume and exit."	RefactoringWarning raiseSignal: aString with: aStringBlockAssociation</body><body package="Browser-Refactorings">uniqueMethodNameFor: anInteger 	| before after index name |	before := 'a'.	after := ''.	anInteger timesRepeat: [after := after , 'z:'].	index := 0.		[name := before , index printString , after.	(Symbol findInterned: name) notNil] 			whileTrue: [index := index + 1].	^name asSymbol</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">execute	self primitiveExecute.	RefactoryChangeManager instance performChange: self changes</body><body package="Browser-Refactorings">model	^model isNil 		ifTrue: 			[model := (RBRootNameSpace new)						description: self printString;						yourself]		ifFalse: [model]</body><body package="Browser-Refactorings">performComponentRefactoring: aRefactoring 	aRefactoring copyOptionsFrom: self options.	aRefactoring primitiveExecute</body><body package="Browser-Refactorings">transform	self subclassResponsibility</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">initialize</body><body package="Browser-Refactorings">model: aRBNameSpace 	model := aRBNameSpace</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>requests</category><body package="Browser-Refactorings">methodForExpandingScopeOf: aVar 	^(self options at: #sharedVariableScopeExpansion) value: self value: aVar</body><body package="Browser-Refactorings">openBrowserOn: anEnvironment 	^(self options at: #openBrowser) value: self value: anEnvironment</body><body package="Browser-Refactorings">requestImplementorToInline: implementorsCollection 	^(self options at: #implementorToInline) value: self		value: implementorsCollection</body><body package="Browser-Refactorings">requestMethodNameFor: aMethodName 	^(self options at: #methodName) value: self value: aMethodName</body><body package="Browser-Refactorings">requestSelfArgumentName	^(self options at: #selfArgumentName) value: self</body><body package="Browser-Refactorings">selectVariableToMoveMethodTo: aSelector class: aClass 	^(self options at: #selectVariableToMoveTo) 		value: self		value: aClass		value: aSelector</body><body package="Browser-Refactorings">selectVariableTypesFrom: initialTypeCollection selected: selectedTypeCollection 	^(self options at: #variableTypes) 		value: self		value: initialTypeCollection		value: selectedTypeCollection</body><body package="Browser-Refactorings">shouldExtractAssignmentTo: aString 	^(self options at: #extractAssignment) value: self value: aString</body><body package="Browser-Refactorings">shouldInlineExpression: aString 	^(self options at: #inlineExpression) value: self value: aString</body><body package="Browser-Refactorings">shouldOverride: aSelector in: aClass 	^(self options at: #alreadyDefined) 		value: self		value: aClass		value: aSelector</body><body package="Browser-Refactorings">shouldUseExistingMethod: aSelector 	^(self options at: #useExistingMethod) value: self value: aSelector</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	aStream		nextPutAll: (self class name first isVowel ifTrue: ['an '] ifFalse: ['a ']);		nextPutAll: self class name</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>transforming-class/namespace names</category><body package="Browser-Refactorings">replaceFullReferenceTo: aRBProgramItem inVariable: aNode toBe: aString 	| path nameStream |	path := self 				replaceReferenceTo: aRBProgramItem				inPath: ((aNode name tokensBasedOn: $.) collect: [:each | each asSymbol])				toBe: aString.	nameStream := WriteStream on: String new.	path do: [:each | nameStream nextPutAll: each]		separatedBy: [nameStream nextPut: $.].	^RBVariableNode named: nameStream contents</body><body package="Browser-Refactorings">replaceReferenceTo: aRBProgramItem inPath: path toBe: aString 	| newPath index nameStream |	newPath := path copy.	index := path size + 1.		[index := path 				prevIndexOf: aRBProgramItem name				from: index - 1				to: 1.	index notNil] 			whileTrue: 				[nameStream := WriteStream on: String new.				(1 to: index) do: [:i | nameStream nextPutAll: (path at: i)]					separatedBy: [nameStream nextPut: $.].				(self methodClass referencedItem: nameStream contents) == aRBProgramItem 					ifTrue: [newPath at: index put: aString]].	^newPath</body></methods><methods><class-id>Refactory.Browser.Refactoring</class-id> <category>utilities</category><body package="Browser-Refactorings">checkInstanceVariableName: aName in: aClass 	^Condition checkInstanceVariableName: aName in: aClass</body><body package="Browser-Refactorings">checkMethodName: aName in: aClass 	^Condition checkMethodName: aName in: aClass</body><body package="Browser-Refactorings">safeMethodNameFor: aClass basedOn: aString 	"Creates an unused method name containing aString"	| baseString newString hasParam i |	baseString := aString copy.	baseString at: 1 put: baseString first asLowercase.	newString := baseString.	hasParam := newString last = $:.	hasParam 		ifTrue: [baseString := newString copyFrom: 1 to: newString size - 1].	i := 0.	[aClass hierarchyDefinesMethod: newString asSymbol] whileTrue: 			[i := i + 1.			newString := baseString , i printString 						, (hasParam ifTrue: [':'] ifFalse: [''])].	^newString asSymbol</body><body package="Browser-Refactorings">whichVariableNode: aParseTree inInterval: anInterval name: aName 	| matcher block |	matcher := ParseTreeSearcher new.	block := 			[:aNode :answer | 			(aNode intersectsInterval: anInterval) ifTrue: [aNode] ifFalse: [answer]].	matcher		matches: aName do: block;		matchesArgument: aName do: block.	^matcher executeTree: aParseTree initialAnswer: nil</body></methods><methods><class-id>Refactory.Browser.Refactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.Browser.Refactoring class</class-id> <category>accessing signal</category><body package="Browser-Refactorings">preconditionSignal	^RefactoringError , RefactoringWarning</body></methods><methods><class-id>Refactory.Browser.Refactoring class</class-id> <category>accessing</category><body package="Browser-Refactorings">refactoringOptions	RefactoringOptions isNil ifTrue: [self initializeRefactoringOptions].	^RefactoringOptions</body><body package="Browser-Refactorings">setDefaultOption: aSymbol to: aBlock 	self refactoringOptions at: aSymbol put: aBlock</body></methods><methods><class-id>Refactory.Browser.MethodRefactoring</class-id> <category>private</category><body package="Browser-Refactorings">buildSelectorString: aSelector 	aSelector numArgs = 0 ifTrue: [^aSelector].	^self buildSelectorString: aSelector		withPermuteMap: (1 to: aSelector numArgs)</body><body package="Browser-Refactorings">buildSelectorString: aSelector withPermuteMap: anIntegerCollection 	| stream keywords |	aSelector numArgs == 0 ifTrue: [^aSelector asString].	stream := WriteStream on: String new.	keywords := aSelector keywords.	keywords with: anIntegerCollection		do: 			[:each :i | 			stream				nextPutAll: each;				nextPutAll: ' ``@arg';				nextPutAll: i printString;				nextPut: $ ].	^stream contents</body><body package="Browser-Refactorings">safeVariableNameFor: aClass temporaries: allTempVars basedOn: aString	| baseString i newString |	newString := baseString := aString.	i := 0.		[(allTempVars includes: newString) 		or: [aClass definesInstanceVariable: newString]] 			whileTrue: 				[i := i + 1.				newString := baseString , i printString].	^newString</body></methods><methods><class-id>Refactory.Browser.MoveVariableDefinitionRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">checkNodes: sequenceNodes 	(sequenceNodes anySatisfy: 			[:each | 			RBReadBeforeWrittenTester isVariable: name readBeforeWrittenIn: each]) 		ifTrue: [^false].	sequenceNodes do: 			[:each | 			(self usesDirectly: each body) 				ifTrue: [blockNodes add: each]				ifFalse: 					[(self checkNodes: (self subblocksIn: each body)) 						ifFalse: [blockNodes add: each]]].	^true</body><body package="Browser-Refactorings">checkParseTree		| node |	blockNodes := OrderedCollection new.	node := self		whichVariableNode: self sourceTree		inInterval: interval		name: name.	node isNil		ifTrue:			[self				refactoringError:					#UnableToLocateNode &lt;&lt; #browser &gt;&gt; 'Unable to locate node in parse tree'].	definingNode := node whoDefines: name.	definingNode isNil		ifTrue:			[self				refactoringError:					#CannotLocateVarDef &lt;&lt; #browser &gt;&gt; 'Cannot locate variable definition'].	definingNode isSequence		ifFalse:			[self				refactoringError:					#VariableIsAnArgument &lt;&lt; #browser &gt;&gt; 'Variable is an argument'].	(self usesDirectly: definingNode)		ifTrue:			[self				refactoringError:					#VariableAlreadyTight &lt;&lt; #browser &gt;&gt;							'Variable already bound as tightly as possible'].	(self checkNodes: (self subblocksIn: definingNode))		ifFalse:			[self				refactoringError:					#VariablePossiblyReadBeforeWrite &lt;&lt; #browser &gt;&gt;							'Variable is possibly read before written']</body><body package="Browser-Refactorings">subblocksIn: aParseTree 	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: '[:`@blockTemps | | `@temps | `@.Statements]'		do: 			[:aNode :answer | 			(aNode references: name) ifTrue: [answer add: aNode].			answer].	^searcher executeTree: aParseTree initialAnswer: OrderedCollection new</body><body package="Browser-Refactorings">transform		definingNode removeTemporaryNamed: name.	blockNodes do: [:each | each body addTemporaryNamed: name].	class compileTree: self sourceTree</body><body package="Browser-Refactorings">usesDirectly: aParseTree 	| searcher |	searcher := ParseTreeSearcher new.	searcher		matches: '[:`@args | | `@temps | `@.Statements]'			do: [:aNode :answer | answer];		matches: name do: [:aNode :answer | true].	^searcher executeTree: aParseTree initialAnswer: false</body></methods><methods><class-id>Refactory.Browser.MoveVariableDefinitionRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">class: aClass selector: aSelector interval: anInterval 	interval := anInterval.	class := self classObjectFor: aClass.	selector := aSelector</body></methods><methods><class-id>Refactory.Browser.MoveVariableDefinitionRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream	aStream nextPutAll: 'Move variable definition refactoring'</body><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' bindTight: '.	interval storeOn: aStream.	aStream nextPutAll: ' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: selector.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.MoveVariableDefinitionRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">preconditions		^(Condition definesSelector: selector in: class)		&amp;			(Condition				withBlock:					[| methodSource |					interval first &lt;= interval last						ifFalse:							[self								refactoringError:									#InvalidVariableName &lt;&lt; #browser &gt;&gt; 'Invalid variable name'].					methodSource := self sourceTree source asString.					methodSource size &gt;= interval last						ifFalse:							[self								refactoringError:									#InvalidRangeForVariable &lt;&lt; #browser &gt;&gt; 'Invalid range for variable'].					name := methodSource						copyFrom: interval first						to: interval last.					(self checkInstanceVariableName: name in: class)						ifFalse:							[self								refactoringError:									(#x1sIsInvalidVariableName &lt;&lt; #browser &gt;&gt;											'&lt;1s&gt; does not seem to be a valid variable name.'										expandMacrosWith: name)].					self checkParseTree.					true])</body></methods><methods><class-id>Refactory.Browser.MoveVariableDefinitionRefactoring</class-id> <category>accessing</category><body package="Browser-Refactorings">sourceTree		^sourceTree ifNil: [sourceTree := class parseTreeFor: selector]</body><body package="Browser-Refactorings">sourceTree: aParseTree		sourceTree := aParseTree</body></methods><methods><class-id>Refactory.Browser.MoveVariableDefinitionRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">bindTight: anInterval in: aClass selector: aSelector 	^(self new)		class: aClass			selector: aSelector			interval: anInterval;		yourself</body><body package="Browser-Refactorings">model: aRBNameSpace bindTight: anInterval in: aClass selector: aSelector 	^(self new)		model: aRBNameSpace;		class: aClass			selector: aSelector			interval: anInterval;		yourself</body></methods><methods><class-id>Refactory.Browser.VariableRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' variable: '.	variableName storeOn: aStream.	aStream nextPutAll: ' class: '.	class storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.VariableRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">variable: aVarName class: aClass 	class := self classObjectFor: aClass.	variableName := aVarName</body></methods><methods><class-id>Refactory.Browser.VariableRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">model: aRBNameSpace variable: aVarName class: aClass 	^(self new)		model: aRBNameSpace;		variable: aVarName class: aClass;		yourself</body><body package="Browser-Refactorings">variable: aVarName class: aClass 	^(self new)		variable: aVarName class: aClass;		yourself</body></methods><methods><class-id>Refactory.Browser.ProtectInstanceVariableRefactoring</class-id> <category>private-accessing</category><body package="Browser-Refactorings">getterSetterMethods	| matcher |	matcher := ParseTreeSearcher new.	matcher		answer: Set new;		matchesAnyMethodOf: (Array 					with: '`method ^' , variableName					with: ('`method: `arg &lt;1s&gt; := `arg' expandMacrosWith: variableName)					with: ('`method: `arg ^&lt;1s&gt; := `arg' expandMacrosWith: variableName))			do: 				[:aNode :answer | 				(class subclassRedefines: aNode selector) 					ifFalse: [answer add: aNode selector].				answer].	(class whichSelectorsReferToInstanceVariable: variableName) do: 			[:each | 			self 				checkClass: class				selector: each				using: matcher].	^matcher answer</body></methods><methods><class-id>Refactory.Browser.ProtectInstanceVariableRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">inline: aSelector 	self onError: 			[self performComponentRefactoring: (InlineAllSelfSendersRefactoring 						model: self model						sendersOf: aSelector						in: class)]		do: []</body><body package="Browser-Refactorings">transform	self setOption: #inlineExpression toUse: [:ref :string | true].	self getterSetterMethods do: [:each | self inline: each]</body></methods><methods><class-id>Refactory.Browser.ProtectInstanceVariableRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream	aStream nextPutAll: 'Protect instance variable refactoring'</body></methods><methods><class-id>Refactory.Browser.ProtectInstanceVariableRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">preconditions	^Condition definesInstanceVariable: variableName in: class</body></methods><methods><class-id>Refactory.Browser.RemoveInstanceVariableRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream	aStream nextPutAll: 'Remove instance variable refactoring'</body></methods><methods><class-id>Refactory.Browser.RemoveInstanceVariableRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">transform	class removeInstanceVariable: variableName</body></methods><methods><class-id>Refactory.Browser.RemoveInstanceVariableRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">preconditions	| references |	references := Condition hierarchyOf: class				referencesInstanceVariable: variableName.	class realClass isNil 		ifTrue: 			[references 				errorMacro: ((#x1sIsReferenced &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is referenced.') expandMacrosWith: variableName)]		ifFalse: 			[references				errorMacro: ((#x1sIsReferencedBrowseQ &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is referenced.&lt;n&gt;Browse references?') 							expandMacrosWith: variableName);				errorBlock: 						[self openBrowserOn: (BrowserEnvironment new instVarRefsTo: variableName									in: class realClass)]].	^(Condition definesInstanceVariable: variableName asString in: class) 		&amp; references not</body></methods><methods><class-id>Refactory.Browser.ExtractMethodToComponentRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">extract: anInterval from: aSelector in: aClass 	class := self classObjectFor: aClass.	selector := aSelector.	extractionInterval := anInterval</body></methods><methods><class-id>Refactory.Browser.ExtractMethodToComponentRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">extractMethod		| refactoring |	refactoring := ExtractMethodRefactoring		model: self model		extract: extractionInterval		from: selector		in: class.	refactoring sourceTree: sourceTree.	refactoring		setOption: #methodName		toUse:			[:ref :methodName | 			extractedMethodSelector := ref				uniqueMethodNameFor: methodName arguments size.			methodName				selector: extractedMethodSelector;				yourself].	self performComponentRefactoring: refactoring</body><body package="Browser-Refactorings">inlineForwarder	| refactoring |	refactoring := InlineAllSelfSendersRefactoring 				model: self model				sendersOf: extractedMethodSelector				in: class.	refactoring setOption: #inlineExpression toUse: [:ref :string | true].	self performComponentRefactoring: refactoring</body><body package="Browser-Refactorings">moveMethod	| variable refactoring |	variable := self selectVariableToMoveMethodTo: extractedMethodSelector				class: class.	variable isNil ifTrue: [self refactoringError: (#DidNotExtractMethod &lt;&lt; #browser &gt;&gt; 'Did not extract method')].	refactoring := MoveMethodRefactoring 				model: self model				selector: extractedMethodSelector				class: class				variable: variable.	self performComponentRefactoring: refactoring</body><body package="Browser-Refactorings">transform	self		extractMethod;		moveMethod;		inlineForwarder</body></methods><methods><class-id>Refactory.Browser.ExtractMethodToComponentRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	aStream nextPutAll: 'Extract method to component refactoring'</body><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' extract: '.	extractionInterval storeOn: aStream.	aStream		nextPutAll: ' from: #';		nextPutAll: selector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.ExtractMethodToComponentRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">preconditions	^Condition empty</body></methods><methods><class-id>Refactory.Browser.ExtractMethodToComponentRefactoring</class-id> <category>accessing</category><body package="Browser-Refactorings">sourceTree		^sourceTree ifNil: [sourceTree := class parseTreeFor: selector]</body><body package="Browser-Refactorings">sourceTree: aParseTree		sourceTree := aParseTree</body></methods><methods><class-id>Refactory.Browser.ExtractMethodToComponentRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">extract: anInterval from: aSelector in: aClass 	^(self new)		extract: anInterval			from: aSelector			in: aClass;		yourself</body><body package="Browser-Refactorings">model: aRBNameSpace extract: anInterval from: aSelector in: aClass 	^(self new)		model: aRBNameSpace;		extract: anInterval			from: aSelector			in: aClass;		yourself</body></methods><methods><class-id>Refactory.Browser.AbstractVariablesRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">abstractInstanceVariable: aString 	| refactoring rewriter |	refactoring := CreateAccessorsForVariableRefactoring 				model: self model				variable: aString				class: fromClass.	self performComponentRefactoring: refactoring.	rewriter := ParseTreeRewriter new.	rewriter		replace: aString , ' := ``@object'			with: ('self &lt;1s&gt; ``@object' expandMacrosWith: refactoring setterMethod);		replace: aString with: 'self ' , refactoring getterMethod.	(rewriter executeTree: tree) ifTrue: [tree := rewriter tree]</body><body package="Browser-Refactorings">abstractInstanceVariables	| variables |	variables := Set new.	variables		addAll: instVarReaders;		addAll: instVarWriters.	variables do: [:each | self abstractInstanceVariable: each]</body><body package="Browser-Refactorings">computeVariablesToAbstract	| searcher |	instVarReaders := Set new.	instVarWriters := Set new.	sharedVariableReaders := Set new.	sharedVariableWriters := Set new.	searcher := ParseTreeSearcher new.	searcher		matches: '`var := ``@anything'			do: [:aNode :answer | self processAssignmentNode: aNode];		matches: '`var' do: [:aNode :answer | self processReferenceNode: aNode].	searcher executeTree: tree.	self removeImportedSharedVariables</body><body package="Browser-Refactorings">instanceVariableNames	^fromClass allInstanceVariableNames asSet</body><body package="Browser-Refactorings">processAssignmentNode: aNode 	| varName |	varName := aNode variable name.	ignore = varName ifTrue: [^self].	(aNode whoDefines: varName) notNil ifTrue: [^self].	((self instanceVariableNames includes: varName) 		ifTrue: [instVarWriters]		ifFalse: [sharedVariableWriters]) add: varName</body><body package="Browser-Refactorings">processReferenceNode: aNode 	| varName |	varName := aNode name.	ignore = varName ifTrue: [^self].	(#('self' 'super' 'true' 'false' 'nil' 'thisContext') includes: varName) 		ifTrue: [^self].	(aNode whoDefines: varName) notNil ifTrue: [^self].	((self instanceVariableNames includes: varName) 		ifTrue: [instVarReaders]		ifFalse: [sharedVariableReaders]) add: varName</body><body package="Browser-Refactorings">removeImportedSharedVariables	| selectionBlock |	selectionBlock := 			[:varName | 			| var |			var := fromClass referencedItem: varName.			toClasses anySatisfy: [:each | (each canAccess: var) not]].	sharedVariableReaders := sharedVariableReaders select: selectionBlock.	sharedVariableWriters := sharedVariableWriters select: selectionBlock</body><body package="Browser-Refactorings">transform	self hasVariablesToAbstract 		ifTrue: 			[self 				refactoringWarning: (#MethodHasVarRefsToConvertToAccessors &lt;&lt; #browser &gt;&gt; 'This method has direct variable references which&lt;n&gt;will need to be converted to getter/setters.') 						expandMacros].	self abstractInstanceVariables</body></methods><methods><class-id>Refactory.Browser.AbstractVariablesRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">abstractVariablesIn: aBRProgramNode from: fromBehavior toAll: behaviorCollection ignoring: aVariableName 	tree := aBRProgramNode.	fromClass := self classObjectFor: fromBehavior.	toClasses := behaviorCollection 				collect: [:each | self classObjectFor: each].	ignore := aVariableName.	self computeVariablesToAbstract</body></methods><methods><class-id>Refactory.Browser.AbstractVariablesRefactoring</class-id> <category>testing</category><body package="Browser-Refactorings">hasVariablesToAbstract	^(instVarReaders isEmpty &amp; instVarWriters isEmpty 		&amp; sharedVariableReaders isEmpty &amp; sharedVariableWriters isEmpty) 		not</body></methods><methods><class-id>Refactory.Browser.AbstractVariablesRefactoring</class-id> <category>accessing</category><body package="Browser-Refactorings">parseTree	^tree</body></methods><methods><class-id>Refactory.Browser.AbstractVariablesRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	aStream 		nextPutAll: 'Abstract all variable references in method refactoring'</body></methods><methods><class-id>Refactory.Browser.AbstractVariablesRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">preconditions	^Condition empty</body></methods><methods><class-id>Refactory.Browser.AbstractVariablesRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">model: aRBNameSpace abstractVariablesIn: aBRProgramNode from: fromBehavior toAll: behaviorCollection 	^self 		model: aRBNameSpace		abstractVariablesIn: aBRProgramNode		from: fromBehavior		toAll: behaviorCollection		ignoring: nil</body><body package="Browser-Refactorings">model: aRBNameSpace abstractVariablesIn: aBRProgramNode from: fromBehavior toAll: behaviorCollection ignoring: aVariableName 	^(self new)		model: aRBNameSpace;		abstractVariablesIn: aBRProgramNode			from: fromBehavior			toAll: behaviorCollection			ignoring: aVariableName;		yourself</body></methods><methods><class-id>Refactory.Browser.RBAbstractCondition</class-id> <category>logical operations</category><body package="Browser-Refactorings">&amp; aCondition 	^RBConjunctiveCondition new left: self right: aCondition</body><body package="Browser-Refactorings">not	^RBNegationCondition on: self</body><body package="Browser-Refactorings">| aCondition 	"(A | B) = (A not &amp; B not) not"	^(self not &amp; aCondition not) not</body></methods><methods><class-id>Refactory.Browser.RBAbstractCondition</class-id> <category>checking</category><body package="Browser-Refactorings">check	self subclassResponsibility</body></methods><methods><class-id>Refactory.Browser.RBAbstractCondition</class-id> <category>accessing</category><body package="Browser-Refactorings">errorBlock	^self errorBlockFor: false</body><body package="Browser-Refactorings">errorString	^self errorStringFor: false</body></methods><methods><class-id>Refactory.Browser.RBAbstractCondition</class-id> <category>private</category><body package="Browser-Refactorings">errorBlockFor: aBoolean 	^nil</body><body package="Browser-Refactorings">errorMacro	^errorMacro isNil ifTrue: ['unknown'] ifFalse: [errorMacro]</body><body package="Browser-Refactorings">errorMacro: aString 	errorMacro := aString</body><body package="Browser-Refactorings">errorStringFor: aBoolean	^self errorMacro expandMacrosWith: aBoolean</body></methods><methods><class-id>Refactory.Browser.RefactoringError class</class-id> <category>signalling</category><body package="Browser-Refactorings">raiseSignal: aString with: aNoArgBlock	"The handleError: method sends #value to a non-nil parameter of a RefactoringError."	^self new		searchFrom: thisContext sender;		originator: thisContext sender homeReceiver;		messageText: aString;		parameter: aNoArgBlock;		raiseSignal</body></methods><methods><class-id>Refactory.Browser.RenameInstanceVariableRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream	aStream nextPutAll: 'Rename instance variable refactoring'</body><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' rename: ''';		nextPutAll: variableName;		nextPutAll: ''' to: ''';		nextPutAll: newName;		nextPutAll: ''' in: '.	class storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.RenameInstanceVariableRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">rename: aVarName to: aName in: aClass	self variable: aVarName class: aClass.	newName := aName</body></methods><methods><class-id>Refactory.Browser.RenameInstanceVariableRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">renameReferences	| replacer |	replacer := ParseTreeRewriter 				rename: variableName				to: newName				handler: 					[self 						refactoringError: ((#x1sAlreadyDefinedAsTemp &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is already defined as a method or block temporary &lt;n&gt; variable in this class or one of its subclasses') 								expandMacrosWith: newName)].	self 		convertClasses: class withAllSubclasses		select: [:aClass | aClass whichSelectorsReferToInstanceVariable: variableName]		using: replacer</body><body package="Browser-Refactorings">transform	class renameInstanceVariable: variableName to: newName around: nil.	self renameReferences</body></methods><methods><class-id>Refactory.Browser.RenameInstanceVariableRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">preconditions	^(Condition isValidInstanceVariableName: newName for: class) 		&amp; (Condition definesInstanceVariable: variableName in: class) 			&amp; (Condition hierarchyOf: class definesVariable: newName) not 			&amp; (Condition hierarchyOf: class canAccessVariableNamed: newName) not</body></methods><methods><class-id>Refactory.Browser.RenameInstanceVariableRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">model: aRBNameSpace rename: aVarName to: aName in: aClass 	^(self new)		model: aRBNameSpace;		rename: aVarName			to: aName			in: aClass;		yourself</body><body package="Browser-Refactorings">rename: aVarName to: aName in: aClass 	^(self new)		rename: aVarName			to: aName			in: aClass;		yourself</body></methods><methods><class-id>Refactory.Browser.RBMethod</class-id> <category>accessing</category><body package="Browser-Refactorings">method	^compiledMethod</body><body package="Browser-Refactorings">method: aCompiledMethod 	compiledMethod := aCompiledMethod</body><body package="Browser-Refactorings">modelClass	^class</body><body package="Browser-Refactorings">modelClass: aRBClass	class := aRBClass</body><body package="Browser-Refactorings">package	^Store.Registry		containingPackageForSelector: selector		class: self modelClass realItem</body><body package="Browser-Refactorings">parseTree	^RBParser parseMethod: self source onError: [:str :pos | ^nil]</body><body package="Browser-Refactorings">protocols	^self modelClass protocolsFor: self selector</body><body package="Browser-Refactorings">scope	^compiledMethod		ifNil: [self modelClass environment]		ifNotNil:			[self modelClass rootNameSpace nameSpaceNamed: compiledMethod environment absoluteName]</body><body package="Browser-Refactorings">selector	^selector</body><body package="Browser-Refactorings">selector: aSymbol 	selector := aSymbol</body><body package="Browser-Refactorings">source	^source isNil 		ifTrue: [source := compiledMethod getSource]		ifFalse: [source]</body><body package="Browser-Refactorings">source: aString 	source := aString</body></methods><methods><class-id>Refactory.Browser.RBMethod</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	class printOn: aStream.	aStream		nextPutAll: '&gt;&gt;';		nextPutAll: self selector</body></methods><methods><class-id>Refactory.Browser.RBMethod</class-id> <category>testing</category><body package="Browser-Refactorings">canReferenceObject: anRBProgramItem	| searchScope |	searchScope := self modelClass.	self isPackageExtension		ifTrue:			[self package environment				ifNotNil:					[searchScope := self modelClass rootNameSpace						nameSpaceNamed: compiledMethod environment absoluteName]].	^searchScope canReferenceObject: anRBProgramItem</body><body package="Browser-Refactorings">hasOuterVariables	^compiledMethod		ifNil: [self searchSourceForOuterVariables]		ifNotNil: [compiledMethod hasOuterVariables]</body><body package="Browser-Refactorings">isPackageExtension	^self package		ifNotNil:			[:methodPackage | 			self modelClass				ifNil: [false]				ifNotNil: [:classPackage | classPackage == methodPackage]]		ifNil: [false]</body><body package="Browser-Refactorings">referencedItem: aString	| searchScope |	searchScope := self modelClass.	self isPackageExtension		ifTrue:			[self package environment				ifNotNil:					[searchScope := self modelClass rootNameSpace						nameSpaceNamed: compiledMethod environment absoluteName]].	^searchScope referencedItem: aString</body><body package="Browser-Refactorings">refersToClassReference: aRBClass 	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: '`#literal'		do: 			[:node :answer | 			answer or: [self modelClass checkLiteral: node value references: aRBClass]].	^searcher executeTree: self parseTree initialAnswer: false</body><body package="Browser-Refactorings">refersToObject: aRBProgramItem 	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: '`var'		do: 			[:node :answer | 			answer 				or: [self modelClass doesName: node name includeObject: aRBProgramItem]].	^(searcher executeTree: self parseTree initialAnswer: false) 		or: [self refersToClassReference: aRBProgramItem]</body><body package="Browser-Refactorings">refersToSymbol: aSymbol 	| searcher |	searcher := ParseTreeSearcher new.	searcher		matches: aSymbol printString do: [:node :answer | true];		matches: '`#literal'			do: [:node :answer | answer or: [self literal: node value containsReferenceTo: aSymbol]].	(RBScanner isSelector: aSymbol) 		ifTrue: 			[searcher 				matches: '`@object ' , (ParseTreeSearcher buildSelectorString: aSymbol)				do: [:node :answer | true]].	^searcher executeTree: self parseTree initialAnswer: false</body><body package="Browser-Refactorings">refersToVariable: aString 	| searcher tree |	tree := self parseTree.	((tree defines: aString) or: [tree body defines: aString]) 		ifTrue: [^false].	searcher := ParseTreeSearcher new.	searcher		matches: aString do: [:node :answer | true];		matches: '[:`@vars | | `@temps | `@.Stmts]'			do: 				[:node :answer | 				answer or: 						[((node defines: aString) or: [node body defines: aString]) not 							and: [searcher executeTree: node body initialAnswer: false]]].	^searcher executeTree: self parseTree initialAnswer: false</body></methods><methods><class-id>Refactory.Browser.RBMethod</class-id> <category>private</category><body package="Browser-Refactorings">literal: anObject containsReferenceTo: aSymbol 	anObject = aSymbol ifTrue: [^true].	anObject class = Array ifFalse: [^false].	^anObject 		anySatisfy: [:each | self literal: each containsReferenceTo: aSymbol]</body><body package="Browser-Refactorings">searchSourceForOuterVariables	| searcher |	searcher := ParseTreeSearcher new.	searcher		matches: '`var'		do:			[:node :answer | 			answer				or:					[(node whoDefines: node name) isNil						and: [(self modelClass definesInstanceVariable: node name) not]]].	^searcher		executeTree: self parseTree		initialAnswer: false</body></methods><methods><class-id>Refactory.Browser.RBMethod</class-id> <category>compiling</category><body package="Browser-Refactorings">compileTree: aBRMethodNode		| method sourceCode change oldChange |	oldChange := self modelClass isMeta		ifTrue:			[self modelClass rootNameSpace changes				changeForMetaclass: self modelClass nonMetaclass fullName				selector: self selector]		ifFalse:			[self modelClass rootNameSpace changes				changeForClass: self modelClass fullName				selector: self selector].	sourceCode := aBRMethodNode newSource.	change := self modelClass environment		compile: sourceCode		in: self modelClass		classified: self protocols.	change copyAttributesFrom: self selector.	oldChange notNil ifTrue: [change package: oldChange package].	method := self class		for: self modelClass		source: sourceCode		selector: aBRMethodNode selector.	self modelClass addMethod: method.	^change</body></methods><methods><class-id>Refactory.Browser.RBMethod</class-id> <category>compatibility</category><body package="Browser-Refactorings">environment	^compiledMethod		ifNil: [self modelClass environment]		ifNotNil:			[self modelClass rootNameSpace				nameSpaceNamed: compiledMethod environment absoluteName]</body></methods><methods><class-id>Refactory.Browser.RBMethod class</class-id> <category>instance creation</category><body package="Browser-Refactorings">for: aRBClass fromMethod: aCompiledMethod andSelector: aSymbol 	^(self new)		modelClass: aRBClass;		method: aCompiledMethod;		selector: aSymbol;		yourself</body><body package="Browser-Refactorings">for: aRBClass source: aString selector: aSelector 	^(self new)		modelClass: aRBClass;		selector: aSelector;		source: aString;		yourself</body></methods><methods><class-id>Refactory.Browser.RBProgramItem</class-id> <category>comparing</category><body package="Browser-Refactorings">= aRBProgramItem 	^self class = aRBProgramItem class and: 			[self name = aRBProgramItem name 				and: [self environment = aRBProgramItem environment]]</body><body package="Browser-Refactorings">hash	^self name hash bitXor: self class hash</body></methods><methods><class-id>Refactory.Browser.RBProgramItem</class-id> <category>accessing</category><body package="Browser-Refactorings">allNameSpacesDo: aBlock</body><body package="Browser-Refactorings">binding	^binding</body><body package="Browser-Refactorings">changes	^self rootNameSpace changes</body><body package="Browser-Refactorings">fullName	^(self environment == self smalltalkNameSpace or: [self environment isNil]) 		ifTrue: [self name asString]		ifFalse: [self environment fullName , '.' , self name]</body><body package="Browser-Refactorings">name	^name</body><body package="Browser-Refactorings">name: aSymbol 	name := aSymbol</body><body package="Browser-Refactorings">rootNameSpace	environment isNil ifTrue: [^self].	^environment rootNameSpace</body><body package="Browser-Refactorings">smalltalkNameSpace	| root |	root := self rootNameSpace.	^root smalltalkNameSpace</body><body package="Browser-Refactorings">unambiguousName	| dottedName |	dottedName := self fullName.	(dottedName includes: $.) ifTrue: [^dottedName].	self == self smalltalkNameSpace ifTrue: [^dottedName].	^'Smalltalk.' , dottedName</body></methods><methods><class-id>Refactory.Browser.RBProgramItem</class-id> <category>initialize-release</category><body package="Browser-Refactorings">initialize	isPrivate := false</body><body package="Browser-Refactorings">isPrivate: aBoolean 	isPrivate := aBoolean</body><body package="Browser-Refactorings">parent: aNameSpace 	environment := aNameSpace</body><body package="Browser-Refactorings">realBinding: aVariableBinding	name := aVariableBinding key.	binding := aVariableBinding.	isPrivate := aVariableBinding isPrivate</body></methods><methods><class-id>Refactory.Browser.RBProgramItem</class-id> <category>private</category><body package="Browser-Refactorings">basicRemove	self subclassResponsibility</body><body package="Browser-Refactorings">environment	^environment</body><body package="Browser-Refactorings">flushCaches	self rootNameSpace flushCaches</body><body package="Browser-Refactorings">prepareForRemoval</body><body package="Browser-Refactorings">realItem	^binding value</body></methods><methods><class-id>Refactory.Browser.RBProgramItem</class-id> <category>testing</category><body package="Browser-Refactorings">isClassObject	^false</body><body package="Browser-Refactorings">isDefined	^binding notNil</body><body package="Browser-Refactorings">isNameSpace	^false</body><body package="Browser-Refactorings">isPrivate	^isPrivate</body><body package="Browser-Refactorings">isSharedVariable	^false</body></methods><methods><class-id>Refactory.Browser.RBProgramItem class</class-id> <category>instance creation</category><body package="Browser-Refactorings">named: aSymbol model: aRBNameSpace 	^(self new)		name: aSymbol;		parent: aRBNameSpace;		yourself</body><body package="Browser-Refactorings">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.Browser.RBBasicNameSpace</class-id> <category>testing</category><body package="Browser-Refactorings">canAccess: aProgramItem 	((self referencedItem: aProgramItem name) == aProgramItem 		and: [(self hasRemoved: aProgramItem name) not]) ifTrue: [^true].	^false</body><body package="Browser-Refactorings">canReference: aString 	^(self referencedItem: aString) notNil</body><body package="Browser-Refactorings">canReferenceObject: anObject	^(self referencedItem: anObject name) = anObject</body><body package="Browser-Refactorings">checkLiteral: aLiteral references: aRBProgramItem 	aLiteral == aRBProgramItem name ifTrue: [^self canAccess: aRBProgramItem].	aLiteral isBindingReference 		ifTrue: [^self doesReference: aLiteral includeObject: aRBProgramItem].	aLiteral class == Array 		ifTrue: 			[^aLiteral 				anySatisfy: [:each | self checkLiteral: each references: aRBProgramItem]].	^false</body><body package="Browser-Refactorings">definesAnyItem	(self privateItems notNil and: [self privateItems notEmpty]) 		ifTrue: [^true].	self realItem isNil ifTrue: [^false].	self realItem asNameSpace 		bindingsDo: [:each | (self hasRemoved: each key) ifFalse: [^true]].	^false</body><body package="Browser-Refactorings">doesName: aString includeObject: aRBProgramItem 	^self 		doesPath: ((aString tokensBasedOn: $.) collect: [:each | each asSymbol])		includeObject: aRBProgramItem</body><body package="Browser-Refactorings">doesPath: path includeObject: aRBProgramItem 	| index nameStream |	index := 0.		[index := path 				nextIndexOf: aRBProgramItem name				from: index + 1				to: path size.	index notNil] 			whileTrue: 				[nameStream := WriteStream on: String new.				(1 to: index) do: [:i | nameStream nextPutAll: (path at: i)]					separatedBy: [nameStream nextPut: $.].				(self referencedItem: nameStream contents) == aRBProgramItem 					ifTrue: [^true]].	^false</body><body package="Browser-Refactorings">doesReference: aReference includeObject: aRBClass 	^self doesPath: aReference path includeObject: aRBClass</body><body package="Browser-Refactorings">hasRemoved: aSymbol 	^self privateRemovedItems notNil 		and: [self privateRemovedItems includes: aSymbol]</body><body package="Browser-Refactorings">isNameSpace	^true</body></methods><methods><class-id>Refactory.Browser.RBBasicNameSpace</class-id> <category>private-accessing</category><body package="Browser-Refactorings">createClassFor: aBinding 	| nonMeta |	nonMeta := RBClass existing: aBinding model: self.	^self items at: nonMeta name put: nonMeta</body><body package="Browser-Refactorings">createNameSpaceFor: aBinding 	| ns |	ns := RBNameSpace onBinding: aBinding.	ns parent: self.	^self items at: ns name put: ns</body><body package="Browser-Refactorings">createProgramItemFrom: aVariableBinding 	aVariableBinding isForClass 		ifTrue: [^self createClassFor: aVariableBinding].	aVariableBinding isForNameSpace 		ifTrue: [^self createNameSpaceFor: aVariableBinding].	aVariableBinding isForGeneral 		ifTrue: [^self createSharedVariableFor: aVariableBinding].	^nil</body><body package="Browser-Refactorings">createSharedVariableFor: aVariableBinding 	| sharedVariable |	sharedVariable := RBSharedVariable onBinding: aVariableBinding.	sharedVariable parent: self.	^self items at: aVariableBinding key put: sharedVariable</body><body package="Browser-Refactorings">generalImports	^self imports reject: [:each | each isSpecific]</body><body package="Browser-Refactorings">itemFor: aSymbol 	(self includesItem: aSymbol) ifFalse: [^nil].	^self items at: aSymbol		ifAbsentPut: 			[| realBinding item |			realBinding := self realItem asNameSpace bindingFor: aSymbol.			realBinding notNil ifTrue: [item := self createProgramItemFrom: realBinding].			item isNil ifTrue: [^nil].			item]</body><body package="Browser-Refactorings">items	items isNil ifTrue: [items := IdentityDictionary new].	^items</body><body package="Browser-Refactorings">privateItems	^items</body><body package="Browser-Refactorings">privateRemovedItems	^removedItems</body><body package="Browser-Refactorings">removedItems	removedItems isNil ifTrue: [removedItems := Set new].	^removedItems</body><body package="Browser-Refactorings">specificImports	^self imports select: [:each | each isSpecific]</body></methods><methods><class-id>Refactory.Browser.RBBasicNameSpace</class-id> <category>accessing-imports</category><body package="Browser-Refactorings">addImport: aNameSpaceImport 	| newImports |	newImports := OrderedCollection withAll: self imports.	newImports add: aNameSpaceImport.	self changeImportsTo: newImports</body><body package="Browser-Refactorings">imports	^imports isNil 		ifTrue: 			[imports := self isDefined 						ifTrue: [self realItem importDefinitions]						ifFalse: [#()]]		ifFalse: [imports]</body></methods><methods><class-id>Refactory.Browser.RBBasicNameSpace</class-id> <category>accessing</category><body package="Browser-Refactorings">allInitializersDo: aBlock 	| seen |	seen := IdentitySet new.	self items do: 			[:each | 			each allInitializersDo: aBlock.			seen add: each name].	self isDefined ifFalse: [^self].	self realNameSpace bindingsDo: 			[:each | 			| variable |			variable := each key.			((seen includes: variable) or: [self hasRemoved: variable]) 				ifFalse: [(self itemFor: variable) allInitializersDo: aBlock]]</body><body package="Browser-Refactorings">allNameSpacesDo: aBlock 	aBlock value: self.	self itemsDo: 			[:each | 			each isNameSpace 				ifTrue: 					[aBlock value: each.					each allNameSpacesDo: aBlock]]</body><body package="Browser-Refactorings">realNameSpace	^self realItem asNameSpace</body></methods><methods><class-id>Refactory.Browser.RBBasicNameSpace</class-id> <category>accessing-objects</category><body package="Browser-Refactorings">localReferencedItem: aSymbol includePrivates: aBoolean alreadySearched: aCollection currentlyChecking: aSet 	| item |	(aCollection includes: self) ifTrue: [^nil].	aCollection add: self.	item := self itemFor: aSymbol.	(item notNil and: [item isPrivate and: [aBoolean not]]) 		ifTrue: [item := nil].	item isNil 		ifTrue: 			[item := self 						searchImportsFor: aSymbol						includePrivates: aBoolean						alreadySearched: aCollection						currentlyChecking: aSet].	^item</body><body package="Browser-Refactorings">lookupItemPath: aString currentlyChecking: aSet 	| index fullName item localName |	fullName := aString.	item := self.	[item notNil &amp; fullName notNil] whileTrue: 			[index := fullName indexOf: $..			index = 0 				ifTrue: 					[localName := fullName.					fullName := nil]				ifFalse: 					[localName := fullName copyFrom: 1 to: index - 1.					fullName := fullName copyFrom: index + 1 to: fullName size].			item := item 						localReferencedItem: localName asSymbol						includePrivates: true						alreadySearched: IdentitySet new						currentlyChecking: aSet].	^item</body><body package="Browser-Refactorings">referencedItem: aString	^(aString includes: $.)		ifTrue: 			[aString first == $_				ifTrue: 					[self lookupItemPath: (aString copyFrom: 3 to: aString size)						currentlyChecking: Set new]				ifFalse: [self rootNameSpace fullItemNamed: aString]]		ifFalse: 			[(self rootNameSpace fullItemNamed: aString)				ifNil: 					[self						localReferencedItem: aString asSymbol						includePrivates: true						alreadySearched: IdentitySet new						currentlyChecking: Set new]]</body><body package="Browser-Refactorings">searchImportsFor: aSymbol includePrivates: aBoolean alreadySearched: aCollection currentlyChecking: aSet 	self specificImports do: 			[:each | 			each isPrivate not | aBoolean 				ifTrue: 					[each simpleName = aSymbol 						ifTrue: 							[^self rootNameSpace fullItemNamed: each asString currentlyChecking: aSet]]].	self generalImports do: 			[:each | 			| item ns |			each isPrivate not | aBoolean 				ifTrue: 					[ns := self rootNameSpace fullItemNamed: each asString								currentlyChecking: aSet.					ns notNil 						ifTrue: 							[item := ns 										localReferencedItem: aSymbol										includePrivates: false										alreadySearched: aCollection										currentlyChecking: aSet].					item notNil ifTrue: [^item]]].	^nil</body><body package="Browser-Refactorings">sharedVariableNames	| names |	names := Set new.	self 		itemsDo: [:each | each isSharedVariable ifTrue: [names add: each name]].	^names</body></methods><methods><class-id>Refactory.Browser.RBBasicNameSpace</class-id> <category>changes</category><body package="Browser-Refactorings">changeImportsTo: aCollection 	self imports: aCollection.	self recompileObject</body><body package="Browser-Refactorings">changeImportsTo: aCollection withRename: renameRefactor	"The receiver must be recompiled in order to achieve a rename refactoring - that	 is, because it's import definitions have changed as a result thereof.  However,	 it is possible that the receiver is in fact the object being renamed.  If so detect	 that condition to produce the correct definition."	self imports: aCollection.	self recompileObjectWithRename: renameRefactor</body><body package="Browser-Refactorings">defineSharedVariable: aString 	| change |	change := self changes defineSharedVariable: aString.	^(self rootNameSpace nameSpaceNamed: change nameSpaceName) 		addSharedVariableFrom: change</body></methods><methods><class-id>Refactory.Browser.RBBasicNameSpace</class-id> <category>private</category><body package="Browser-Refactorings">addSharedVariableFrom: anAddSharedVariableChange 	| modelStatic sharedVariableName |	sharedVariableName := anAddSharedVariableChange objectName.	sharedVariableName := (sharedVariableName 				copyFrom: (sharedVariableName lastIndexOf: $.) + 1				to: sharedVariableName size) asSymbol.	modelStatic := self itemFor: sharedVariableName.	modelStatic isNil 		ifTrue: 			[self privateRemovedItems notNil 				ifTrue: [self privateRemovedItems remove: sharedVariableName ifAbsent: []].			modelStatic := RBSharedVariable named: sharedVariableName model: self.			self items at: sharedVariableName put: modelStatic].	modelStatic		isPrivate: anAddSharedVariableChange isPrivate;		category: anAddSharedVariableChange category;		initializer: anAddSharedVariableChange initializer;		constant: anAddSharedVariableChange isConstant.	^anAddSharedVariableChange</body><body package="Browser-Refactorings">itemsDo: aBlock 	| seen |	seen := IdentitySet new.	self items copy do: 			[:each | 			aBlock value: each.			seen add: each name].	self isDefined ifFalse: [^self].	self realNameSpace bindingsDo: 			[:each | 			| variable item |			variable := each key.			((seen includes: variable) or: [(item := self itemFor: variable) isNil]) 				ifFalse: [aBlock value: item]]</body><body package="Browser-Refactorings">prepareForRemoval	self itemsDo: [:each | self removeLocalObject: each]</body><body package="Browser-Refactorings">recompileObject	self subclassResponsibility</body><body package="Browser-Refactorings">recompileObjectWithRename: renameRefactor	"The receiver must be recompiled in order to achieve a rename refactoring, but	 it is possible that the receiver is in fact the object being renamed.  If so detect	 that condition to produce the correct definition."	self subclassResponsibility</body><body package="Browser-Refactorings">removeLocalObject: aRBProgramItem 	aRBProgramItem prepareForRemoval.	self removedItems add: aRBProgramItem name.	self privateItems notNil 		ifTrue: [self privateItems removeKey: aRBProgramItem name ifAbsent: []].	self flushCaches.	^aRBProgramItem basicRemove</body></methods><methods><class-id>Refactory.Browser.RBBasicNameSpace</class-id> <category>accessing-namespaces</category><body package="Browser-Refactorings">nameSpaceFor: aNameSpace 	| parent ns |	aNameSpace isNil ifTrue: [^nil].	aNameSpace isBehavior ifTrue: [^self classFor: aNameSpace].	self realNameSpace == aNameSpace ifTrue: [^self].	parent := aNameSpace.	[parent notNil] whileTrue: 			[parent environment == self realNameSpace 				ifTrue: 					[ns := self itemFor: parent name.					^ns notNil ifTrue: [ns nameSpaceFor: aNameSpace] ifFalse: [nil]].			parent := parent environment].	^self rootNameSpace nameSpaceFor: aNameSpace</body><body package="Browser-Refactorings">nameSpaceNamed: aSymbol 	| index var |	aSymbol isNil ifTrue: [^nil].	(index := aSymbol indexOf: $.) = 0 		ifFalse: 			[^(self nameSpaceNamed: (aSymbol copyFrom: 1 to: index - 1)) 				nameSpaceNamed: (aSymbol copyFrom: index + 1 to: aSymbol size)].	var := self itemFor: aSymbol asSymbol.	(var isNil or: [var isNameSpace]) ifTrue: [^var].	var isSharedVariable ifTrue: [^var asNameSpace].	^var</body></methods><methods><class-id>Refactory.Browser.RBBasicNameSpace</class-id> <category>initialize-release</category><body package="Browser-Refactorings">imports: aCollection 	imports := aCollection</body></methods><methods><class-id>Refactory.Browser.RBBasicNameSpace</class-id> <category>private-testing</category><body package="Browser-Refactorings">includesItem: aSymbol 	(self hasRemoved: aSymbol) ifTrue: [^false].	(self privateItems notNil and: [self privateItems includesKey: aSymbol]) 		ifTrue: [^true].	^self isDefined and: [self realItem asNameSpace includesKey: aSymbol]</body></methods><methods><class-id>Refactory.Browser.RBBasicNameSpace</class-id> <category>accessing-classes</category><body package="Browser-Refactorings">classFor: aBehavior 	| nonMetaclass ns class |	aBehavior isNil ifTrue: [^nil].	aBehavior isBehavior ifFalse: [^aBehavior nonMetaclass].	nonMetaclass := aBehavior instanceBehavior.	ns := self nameSpaceFor: aBehavior environment.	class := ns itemFor: nonMetaclass name.	class isNil ifTrue: [^nil].	class isClassObject ifFalse: [^nil].	class attributes: nonMetaclass extraAttributesForDefinition.	^aBehavior isMeta ifTrue: [class metaclass] ifFalse: [class]</body></methods><methods><class-id>Refactory.Browser.RBBasicNameSpace</class-id> <category>method accessing</category><body package="Browser-Refactorings">outerReferencingMethodsDo: aBlock	self itemsDo: [:each | each outerReferencingMethodsDo: aBlock]</body></methods><methods><class-id>Refactory.Browser.RBAbstractClass</class-id> <category>variable accessing</category><body package="Browser-Refactorings">addInstanceVariable: aString 	self privateInstanceVariableNames add: aString.	environment addInstanceVariable: aString to: self</body><body package="Browser-Refactorings">removeInstanceVariable: aString 	self privateInstanceVariableNames remove: aString.	environment removeInstanceVariable: aString from: self</body><body package="Browser-Refactorings">renameInstanceVariable: oldName to: newName around: aBlock 	self privateInstanceVariableNames 		at: (self privateInstanceVariableNames indexOf: oldName asString)		put: newName asString.	environment 		renameInstanceVariable: oldName		to: newName		in: self</body><body package="Browser-Refactorings">whoDefinesInstanceVariable: aString 	| sprClass |	(self directlyDefinesInstanceVariable: aString) ifTrue: [^self].	sprClass := self superclass.	^sprClass isNil 		ifTrue: [nil]		ifFalse: [sprClass whoDefinesInstanceVariable: aString]</body></methods><methods><class-id>Refactory.Browser.RBAbstractClass</class-id> <category>private</category><body package="Browser-Refactorings">addMethod: aRBMethod 	self newMethods at: aRBMethod selector put: aRBMethod.	removedMethods notNil 		ifTrue: [removedMethods remove: aRBMethod selector ifAbsent: []]</body><body package="Browser-Refactorings">addSubclass: aRBClass 	self subclasses add: aRBClass</body><body package="Browser-Refactorings">basicRemove	^self changes removeClassNamed: self unambiguousName</body><body package="Browser-Refactorings">existingMethodsThatReferTo: aSymbol 	| existingMethods |	existingMethods := self realClass whichSelectorsReferTo: aSymbol.	(newMethods isNil and: [removedMethods isNil]) ifTrue: [^existingMethods].	^existingMethods reject: 			[:each | 			(self hasRemovedMethod: each) or: [self newMethods includesKey: each]]</body><body package="Browser-Refactorings">existingMethodsThatReferToInstanceVariable: aString 	^(self realClass whichSelectorsAccess: aString) reject: 			[:each | 			(self hasRemovedMethod: each) or: [self newMethods includesKey: each]]</body><body package="Browser-Refactorings">mirrorRealSubclasses	| realClass |	self isDefined		ifTrue: 			[realClass := self realClass.			realClass subclasses do: 					[:each |					(environment rootNameSpace classFor: each)						ifNotNil: [:anotherRBClass | anotherRBClass superclass: self]]]</body><body package="Browser-Refactorings">newMethods	^newMethods isNil 		ifTrue: [newMethods := IdentityDictionary new]		ifFalse: [newMethods]</body><body package="Browser-Refactorings">prepareForRemoval	super prepareForRemoval.	self superclass isNil ifTrue: [self rootNameSpace removeRootClass: self].	self subclasses copy do: 			[:each | 			each isMeta 				ifTrue: [each superclass: nil]				ifFalse: [each environment removeLocalObject: each]].	self superclass notNil ifTrue: [self superclass removeSubclass: self].	self metaclass superclass notNil 		ifTrue: [self metaclass superclass removeSubclass: self metaclass]</body><body package="Browser-Refactorings">privateInstanceVariableNames	instanceVariableNames isNil 		ifTrue: 			[self isDefined 				ifTrue: [self instanceVariableNames: self realClass instVarNames]				ifFalse: [instanceVariableNames := OrderedCollection new]].	^instanceVariableNames</body><body package="Browser-Refactorings">superclass: aRBClass 	self superclass notNil ifTrue: [self superclass removeSubclass: self].	superclass := aRBClass.	superclass notNil ifTrue: [superclass addSubclass: self].</body></methods><methods><class-id>Refactory.Browser.RBAbstractClass</class-id> <category>accessing</category><body package="Browser-Refactorings">allInstanceVariableNames	| sprClass |	sprClass := self superclass.	^sprClass isNil 		ifTrue: [self instanceVariableNames]		ifFalse: [sprClass allInstanceVariableNames , self instanceVariableNames]</body><body package="Browser-Refactorings">allSubclasses	| allSubclasses index |	index := 1.	allSubclasses := OrderedCollection withAll: self subclasses.	[index &lt;= allSubclasses size] whileTrue: 			[allSubclasses addAll: (allSubclasses at: index) subclasses.			index := index + 1].	^allSubclasses</body><body package="Browser-Refactorings">allSuperclasses	| supers sprClass |	supers := OrderedCollection new.	sprClass := self superclass.	[sprClass notNil] whileTrue: 			[supers add: sprClass.			sprClass := sprClass superclass].	^supers</body><body package="Browser-Refactorings">instanceBehavior	^self nonMetaclass</body><body package="Browser-Refactorings">instanceVariableNames	^self privateInstanceVariableNames copy</body><body package="Browser-Refactorings">instanceVariableNames: aCollectionOfStrings 	instanceVariableNames := aCollectionOfStrings asOrderedCollection</body><body package="Browser-Refactorings">metaclass	^self subclassResponsibility</body><body package="Browser-Refactorings">nonMetaclass	^self subclassResponsibility</body><body package="Browser-Refactorings">primaryInstance	^self nonMetaclass</body><body package="Browser-Refactorings">protocolsFor: aSelector 	| change |	change := self isMeta 				ifTrue: 					[self changes changeForMetaclass: self nonMetaclass unambiguousName						selector: aSelector]				ifFalse: 					[self changes changeForClass: self unambiguousName selector: aSelector].	^change isNil 		ifTrue: 			[self isDefined 				ifTrue: 					[Array with: (BrowserEnvironment new whichProtocolIncludes: aSelector								in: self realClass)]				ifFalse: [#(#accessing)]]		ifFalse: [change protocols]</body><body package="Browser-Refactorings">realClass	^self realItem</body><body package="Browser-Refactorings">removedMethods	^removedMethods isNil 		ifTrue: [removedMethods := Set new]		ifFalse: [removedMethods]</body><body package="Browser-Refactorings">removeSubclass: aRBClass 	self subclasses remove: aRBClass ifAbsent: []</body><body package="Browser-Refactorings">soleInstance	^self nonMetaclass</body><body package="Browser-Refactorings">subclasses	^subclasses		ifNil:			[subclasses := OrderedCollection new.			self mirrorRealSubclasses.			subclasses]</body><body package="Browser-Refactorings">superclass	^superclass == LookupSuperclass 		ifTrue: [superclass := environment classFor: self realClass superclass]		ifFalse: [superclass]</body><body package="Browser-Refactorings">withAllSubclasses	^(self allSubclasses)		add: self;		yourself</body><body package="Browser-Refactorings">withAllSuperclasses	^(self allSuperclasses)		add: self;		yourself</body></methods><methods><class-id>Refactory.Browser.RBAbstractClass</class-id> <category>method accessing</category><body package="Browser-Refactorings">allSelectors	| class selectors |	class := self.	selectors := Set new.	[class notNil] whileTrue: 			[selectors addAll: class selectors.			class := class superclass].	^selectors</body><body package="Browser-Refactorings">compile: aString 	^self compile: aString		withAttributesFrom: (self methodFor: (RBParser parseMethodPattern: aString))</body><body package="Browser-Refactorings">compile: aString classified: aSymbolCollection		| change method |	change := environment compile: aString in: self classified:			aSymbolCollection.	method := RBMethod		for: self		source: aString		selector: change selector.	self addMethod: method.	^change</body><body package="Browser-Refactorings">compile: aString withAttributesFrom: aRBMethod 	| change method |	change := environment 				compile: aString				in: self				classified: aRBMethod protocols.	change copyAttributesFrom: aRBMethod selector		in: aRBMethod modelClass realClass.	method := RBMethod 				for: self				source: aString				selector: change selector.	self addMethod: method.	^change</body><body package="Browser-Refactorings">compileTree: aRBMethodNode 	^(self methodFor: aRBMethodNode selector) compileTree: aRBMethodNode</body><body package="Browser-Refactorings">methodFor: aSelector 	^self newMethods at: aSelector		ifAbsent: 			[| compiledMethod class |			(self hasRemovedMethod: aSelector) ifTrue: [^nil].			class := self realClass.			class isNil ifTrue: [^nil].			compiledMethod := class compiledMethodAt: aSelector ifAbsent: [nil].			compiledMethod isNil 				ifTrue: [nil]				ifFalse: 					[RBMethod 						for: self						fromMethod: compiledMethod						andSelector: aSelector]]</body><body package="Browser-Refactorings">outerReferencingMethodsDo: aBlock	"Enumerate all methods that refer to variables beyond the scope of the instance."	super outerReferencingMethodsDo: aBlock.	self realClass		outerReferencingMethodsDo:			[:selector :method | 			(self hasRemovedMethod: selector)				ifFalse:					[aBlock						value: selector						value: (self methodFor: selector)]].	newMethods		ifNotNil:			[newMethods				keysAndValuesDo:					[:selector :method | method hasOuterVariables ifTrue: [aBlock value: selector value: method]]]</body><body package="Browser-Refactorings">parseTreeFor: aSelector 	| class |	class := self whoDefinesMethod: aSelector.	class isNil ifTrue: [^nil].	^(class methodFor: aSelector) parseTree</body><body package="Browser-Refactorings">removeMethod: aSelector 	self newMethods removeKey: aSelector ifAbsent: [].	environment removeMethod: aSelector from: self.	self removedMethods add: aSelector</body><body package="Browser-Refactorings">selectors	| selectors |	selectors := Set new.	selectors addAll: self newMethods keys.	self isDefined 		ifTrue: 			[selectors addAll: self realClass selectors.			removedMethods notNil 				ifTrue: [removedMethods do: [:each | selectors remove: each ifAbsent: []]]].	^selectors</body><body package="Browser-Refactorings">sourceCodeFor: aSelector 	| class |	class := self whoDefinesMethod: aSelector.	class isNil ifTrue: [^nil].	^(class methodFor: aSelector) source</body><body package="Browser-Refactorings">whichMethodsReferToSymbol: aSymbol 	| selectors |	selectors := Set new.	self newMethods 		do: [:each | (each refersToSymbol: aSymbol) ifTrue: [selectors add: each selector]].	self isDefined 		ifTrue: [selectors addAll: (self existingMethodsThatReferTo: aSymbol)].	^selectors collect: [:sel | self methodFor: sel]</body><body package="Browser-Refactorings">whichSelectorsReferToInstanceVariable: aString 	| selectors |	selectors := Set new.	self newMethods 		do: [:each | (each refersToVariable: aString) ifTrue: [selectors add: each selector]].	self isDefined 		ifTrue: 			[selectors 				addAll: (self existingMethodsThatReferToInstanceVariable: aString)].	^selectors</body><body package="Browser-Refactorings">whichSelectorsReferToObject: aRBProgramItem 	| selectors |	selectors := Set new.	self newMethods do: 			[:each | 			(each refersToObject: aRBProgramItem) 				ifTrue: [selectors add: each selector]].	(self isDefined and: [aRBProgramItem isDefined]) 		ifTrue: 			[selectors 				addAll: (self existingMethodsThatReferTo: aRBProgramItem binding)].	^selectors</body><body package="Browser-Refactorings">whoDefinesMethod: aSelector 	| sprClass |	(self directlyDefinesMethod: aSelector) ifTrue: [^self].	sprClass := self superclass.	^sprClass isNil 		ifTrue: [nil]		ifFalse: [sprClass whoDefinesMethod: aSelector]</body></methods><methods><class-id>Refactory.Browser.RBAbstractClass</class-id> <category>testing</category><body package="Browser-Refactorings">definesInstanceVariable: aString 	(self directlyDefinesInstanceVariable: aString) ifTrue: [^true].	^self superclass notNil 		and: [self superclass definesInstanceVariable: aString]</body><body package="Browser-Refactorings">definesMethod: aSelector 	(self directlyDefinesMethod: aSelector) ifTrue: [^true].	^self superclass notNil and: [self superclass definesMethod: aSelector]</body><body package="Browser-Refactorings">definesSharedVariable: aString 	(self directlyDefinesSharedVariable: aString) ifTrue: [^true].	^self superclass notNil 		and: [self superclass definesSharedVariable: aString]</body><body package="Browser-Refactorings">definesVariable: aVariableName 	^(self definesInstanceVariable: aVariableName) 		or: [self definesSharedVariable: aVariableName]</body><body package="Browser-Refactorings">directlyDefinesInstanceVariable: aString 	^self instanceVariableNames includes: aString</body><body package="Browser-Refactorings">directlyDefinesMethod: aSelector 	self isDefined 		ifTrue: 			[(self hasRemovedMethod: aSelector) ifTrue: [^false].			(self realClass includesSelector: aSelector) ifTrue: [^true]].	^newMethods notNil and: [newMethods includesKey: aSelector]</body><body package="Browser-Refactorings">directlyDefinesSharedVariable: aString 	^self includesItem: aString asSymbol</body><body package="Browser-Refactorings">directlyDefinesVariable: aVariableName 	^(self directlyDefinesSharedVariable: aVariableName) 		or: [self directlyDefinesInstanceVariable: aVariableName]</body><body package="Browser-Refactorings">hasRemovedMethod: aSelector 	^removedMethods notNil and: [removedMethods includes: aSelector]</body><body package="Browser-Refactorings">hierarchyCanAccessVariableNamed: aString 	(self canReference: aString) ifTrue: [^true].	^self allSubclasses anySatisfy: [:each | each canReference: aString]</body><body package="Browser-Refactorings">hierarchyDefinesInstanceVariable: aString 	(self definesInstanceVariable: aString) ifTrue: [^true].	^self allSubclasses 		anySatisfy: [:each | each directlyDefinesInstanceVariable: aString]</body><body package="Browser-Refactorings">hierarchyDefinesMethod: aSelector 	(self definesMethod: aSelector) ifTrue: [^true].	^self subclassRedefines: aSelector</body><body package="Browser-Refactorings">hierarchyDefinesVariable: aString 	(self definesVariable: aString) ifTrue: [^true].	^self allSubclasses 		anySatisfy: [:each | each directlyDefinesVariable: aString]</body><body package="Browser-Refactorings">includesClass: aRBClass 	| currentClass |	currentClass := self.	[currentClass notNil and: [currentClass ~= aRBClass]] 		whileTrue: [currentClass := currentClass superclass].	^currentClass = aRBClass</body><body package="Browser-Refactorings">isAbstract	(self whichMethodsReferToSymbol: #subclassResponsibility) notEmpty 		ifTrue: [^true].	self rootNameSpace allReferencesToObject: self do: [:each | ^false].	^true</body><body package="Browser-Refactorings">isClassObject	^true</body><body package="Browser-Refactorings">isMeta	self subclassResponsibility</body><body package="Browser-Refactorings">referencedItem: aString in: aNamespace	"Search for the named item, giving access to both our local names (e.g. shared variables) but searching aNamespace rather than our namespace and imports. The simplest thing that could possibly work seems to be to copy ourselves, tweak the namespace, and hope."	| copy |	aNamespace isNil ifTrue: [^self referencedItem: aString].	copy := self copy.	copy parent: aNamespace.	^copy referencedItem: aString</body><body package="Browser-Refactorings">subclassRedefines: aSelector 	^self allSubclasses 		anySatisfy: [:each | each directlyDefinesMethod: aSelector]</body></methods><methods><class-id>Refactory.Browser.RBAbstractClass</class-id> <category>initialize-release</category><body package="Browser-Refactorings">initialize	super initialize.	name := #'Unknown Class'</body><body package="Browser-Refactorings">realBinding: aBinding 	super realBinding: aBinding.	superclass isNil ifTrue: [superclass := LookupSuperclass]</body></methods><methods><class-id>Refactory.Browser.RBAbstractClass</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	aStream nextPutAll: self name</body><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPutAll: self unambiguousName</body></methods><methods><class-id>Refactory.Browser.RBAbstractClass</class-id> <category>accessing-objects</category><body package="Browser-Refactorings">searchImportsFor: aSymbol includePrivates: aBoolean alreadySearched: aCollection currentlyChecking: aSet 	| sprClass item |	sprClass := self superclass.	sprClass notNil 		ifTrue: 			[item := sprClass 						localReferencedItem: aSymbol						includePrivates: false						alreadySearched: aCollection						currentlyChecking: aSet.			item notNil ifTrue: [^item]].	item := super 				searchImportsFor: aSymbol				includePrivates: aBoolean				alreadySearched: aCollection				currentlyChecking: aSet.	(aBoolean not or: [item notNil]) ifTrue: [^item].	^self environment 		localReferencedItem: aSymbol		includePrivates: aBoolean		alreadySearched: aCollection		currentlyChecking: aSet</body></methods><methods><class-id>Refactory.Browser.RBMetaclass</class-id> <category>accessing</category><body package="Browser-Refactorings">fullName	^super fullName , ' class'</body><body package="Browser-Refactorings">imports	^nonMetaclass imports</body><body package="Browser-Refactorings">metaclass	^self</body><body package="Browser-Refactorings">nonMetaclass	^nonMetaclass</body><body package="Browser-Refactorings">unambiguousName	^self nonMetaclass unambiguousName , ' class'</body></methods><methods><class-id>Refactory.Browser.RBMetaclass</class-id> <category>testing</category><body package="Browser-Refactorings">isMeta	^true</body></methods><methods><class-id>Refactory.Browser.RBMetaclass</class-id> <category>initialize-release</category><body package="Browser-Refactorings">nonMetaclass: aRBClass 	aRBClass metaclass: self.	nonMetaclass := aRBClass.	binding := aRBClass binding.	(superclass isNil and: [self isDefined]) 		ifTrue: [superclass := LookupSuperclass]</body></methods><methods><class-id>Refactory.Browser.RBMetaclass</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' class'</body><body package="Browser-Refactorings">storeOn: aStream 	super storeOn: aStream.	aStream nextPutAll: ' class'</body></methods><methods><class-id>Refactory.Browser.RBMetaclass</class-id> <category>private</category><body package="Browser-Refactorings">realItem	| class |	class := super realItem.	^class isNil ifTrue: [nil] ifFalse: [class class]</body><body package="Browser-Refactorings">recompileObject	self nonMetaclass recompileObject</body><body package="Browser-Refactorings">recompileObjectWithRename: renameRefactor	"The receiver must be recompiled in order to achieve a rename refactoring, but	 it is possible that the receiver is in fact the object being renamed.  If so detect	 that condition to produce the correct definition."	self nonMetaclass recompileObjectWithRename: renameRefactor</body></methods><methods><class-id>Refactory.Browser.RBMetaclass</class-id> <category>private-accessing</category><body package="Browser-Refactorings">items	^self nonMetaclass items</body><body package="Browser-Refactorings">privateItems	^self nonMetaclass privateItems</body><body package="Browser-Refactorings">privateRemovedItems	^self nonMetaclass privateRemovedItems</body></methods><methods><class-id>Refactory.Browser.RBMetaclass</class-id> <category>accessing-objects</category><body package="Browser-Refactorings">referencedItem: aString 	^self nonMetaclass referencedItem: aString</body></methods><methods><class-id>Refactory.Browser.RBMetaclass class</class-id> <category>instance creation</category><body package="Browser-Refactorings">newOn: aRBClass model: aRBBasicNameSpace 	^(self new)		name: aRBClass name;		parent: aRBBasicNameSpace;		nonMetaclass: aRBClass;		yourself</body></methods><methods><class-id>Refactory.Browser.MoveMethodRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">abstractVariables	self performComponentRefactoring: self abstractVariablesRefactoring.	parseTree := self abstractVariablesRefactoring parseTree</body><body package="Browser-Refactorings">abstractVariablesRefactoring	^AbstractVariablesRefactoring 		model: self model		abstractVariablesIn: parseTree		from: class		toAll: moveToClasses		ignoring: variable</body><body package="Browser-Refactorings">addSelfReturn	self hasOnlySelfReturns ifTrue: [^self].	parseTree addSelfReturn</body><body package="Browser-Refactorings">compileDelagatorMethod	| statementNode delegatorNode tree | 	delegatorNode := RBMessageNode 				receiver: (RBVariableNode named: variable)				selectorParts: parseTree selectorParts				arguments: (parseTree argumentNames collect: 							[:each | 							RBVariableNode 								named: (each = selfVariableName ifTrue: ['self'] ifFalse: [each])]).	self hasOnlySelfReturns 		ifFalse: [delegatorNode := RBReturnNode value: delegatorNode].	statementNode := RBSequenceNode temporaries: #()				statements: (Array with: delegatorNode).	(tree := class parseTreeFor: selector) body: statementNode.	class compileTree: tree</body><body package="Browser-Refactorings">compileNewMethods	moveToClasses do: 			[:each | 			each compile: parseTree newSource				withAttributesFrom: (class methodFor: selector)]</body><body package="Browser-Refactorings">expandScopes	| refactoring |	refactoring := ExpandNameSpaceReferencesRefactoring 				model: self model				for: parseTree				fromClass: class				toClasses: moveToClasses.	self performComponentRefactoring: refactoring.	parseTree := refactoring parseTree</body><body package="Browser-Refactorings">getArgumentNameForSelf	self needsToReplaceSelfReferences ifFalse: [^self].		[selfVariableName := self requestSelfArgumentName.	(self checkInstanceVariableName: selfVariableName in: class) 		ifTrue: 			[self verifyTemporaryVariableDoesNotOverride 				ifFalse: 					[self 						refactoringWarning: (#VarDefinedTryAnotherQ &lt;&lt; #browser &gt;&gt; 'The variable is already defined in one of the classes you''re moving the method to.&lt;n&gt;Try another?') 								expandMacros.					selfVariableName := nil]]		ifFalse: 			[self 				refactoringWarning: (#VarNameInvalidTryAgainQ &lt;&lt; #browser &gt;&gt; 'The variable name is not a valid Smalltalk temporary variable name&lt;n&gt;Try again?') 						expandMacros.			selfVariableName := nil].	selfVariableName isNil] 			whileTrue: []</body><body package="Browser-Refactorings">getNewMethodName	| newSelector parameters alreadyDefined methodName newMethodName |	parameters := OrderedCollection withAll: parseTree argumentNames.	parameters remove: variable ifAbsent: [].	self needsToReplaceSelfReferences 		ifTrue: [parameters add: selfVariableName].	methodName := RBMethodName selector: selector arguments: parameters.		[newMethodName := self requestMethodNameFor: methodName.	newMethodName isNil ifTrue: [self refactoringError: (#DidNotMoveMethod &lt;&lt; #browser &gt;&gt; 'Did not move method')].	newMethodName isValid 		ifTrue: [newSelector := newMethodName selector]		ifFalse: [self refactoringWarning: (#InvalidMethodName &lt;&lt; #browser &gt;&gt; 'Invalid method name')].	parameters := newMethodName arguments.	(self checkMethodName: newSelector in: class) 		ifFalse: 			[self refactoringWarning: ((#x1sIsInvalidSelector &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is not a valid selector name.')			expandMacrosWith: newMethodName selector).			newSelector := nil].	alreadyDefined := moveToClasses 				detect: [:each | each hierarchyDefinesMethod: newSelector]				ifNone: [nil].	alreadyDefined notNil 		ifTrue: 			[self 				refactoringWarning: ((#x1sDefinedBy2pTryAnotherQ &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is already defined by &lt;2p&gt; or a super/subclass&lt;n&gt;Try another?') 						expandMacrosWith: newSelector						with: alreadyDefined).			newSelector := nil].	newSelector isNil] 			whileTrue: [].	parseTree renameSelector: newSelector		andArguments: (parameters collect: [:each | RBVariableNode named: each]) 				asArray</body><body package="Browser-Refactorings">hasOnlySelfReturns	^hasOnlySelfReturns isNil 		ifTrue: 			[| searcher |			searcher := ParseTreeSearcher new.			searcher				matches: '^self' do: [:aNode :answer | answer];				matches: '^`@object' do: [:aNode :answer | false].			hasOnlySelfReturns := searcher executeTree: parseTree initialAnswer: true]		ifFalse: [hasOnlySelfReturns]</body><body package="Browser-Refactorings">replaceSelfReferences	| replacer |	selfVariableName isNil ifTrue: [^self].	replacer := ParseTreeRewriter new.	replacer replace: 'self' with: selfVariableName.	self hasOnlySelfReturns ifTrue: [replacer replace: '^self' with: '^self'].	replacer executeTree: parseTree.	parseTree := replacer tree</body><body package="Browser-Refactorings">replaceVariableReferences	| replacer |	replacer := ParseTreeRewriter new.	replacer replace: variable with: 'self'.	replacer executeTree: parseTree.	parseTree := replacer tree</body><body package="Browser-Refactorings">transform	self		abstractVariables;		expandScopes;		getNewMethodName;		addSelfReturn;		replaceSelfReferences;		replaceVariableReferences;		compileNewMethods;		compileDelagatorMethod</body><body package="Browser-Refactorings">verifyTemporaryVariableDoesNotOverride	(parseTree allDefinedVariables includes: selfVariableName) 		ifTrue: [^false].	^(moveToClasses 		anySatisfy: [:each | each definesVariable: selfVariableName]) not</body></methods><methods><class-id>Refactory.Browser.MoveMethodRefactoring</class-id> <category>private</category><body package="Browser-Refactorings">buildParseTree	parseTree := (class parseTreeFor: selector) copy.	parseTree isNil ifTrue: [self refactoringError: (#CouldNotParseMethod &lt;&lt; #browser &gt;&gt; 'Could not parse method')]</body></methods><methods><class-id>Refactory.Browser.MoveMethodRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">checkAssignmentsToVariable	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: variable , ' := `@object' do: [:aNode :answer | true].	(searcher executeTree: parseTree initialAnswer: false) 		ifTrue: 			[self 				refactoringError: ((#CannotMoveMethodTo1sAssigned &lt;&lt; #browser &gt;&gt; 'Cannot move the method into &lt;1s&gt; since it is assigned') 						expandMacrosWith: variable)]</body><body package="Browser-Refactorings">checkForPrimitiveMethod	parseTree isPrimitive 		ifTrue: [self refactoringError: (#CannotMovePrimitiveMethods &lt;&lt; #browser &gt;&gt; 'Cannot move primitive methods')]</body><body package="Browser-Refactorings">checkForSuperReferences	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: 'super `@message: `@args' do: [:aNode :answer | true].	(searcher executeTree: parseTree initialAnswer: false) 		ifTrue: 			[self 				refactoringError: (#CannotMoveMethodHasSuperSend &lt;&lt; #browser &gt;&gt; 'Cannot move the method since it has a super message send.')]</body><body package="Browser-Refactorings">checkTemporaryVariableNames	| varNames |	varNames := parseTree allDefinedVariables.	selfVariableName notNil ifTrue: [varNames add: selfVariableName].	varNames do: 			[:name | 			moveToClasses do: 					[:each | 					(self canReferenceVariable: name in: each) 						ifTrue: 							[self refactoringError: ((#x1pAlreadyDefinesVar2s &lt;&lt; #browser &gt;&gt; '&lt;1p&gt; already defines a variable called &lt;2s&gt;') 										expandMacrosWith: each										with: name)]]]</body><body package="Browser-Refactorings">preconditions	^(Condition definesSelector: selector in: class) 		&amp; (Condition withBlock: 					[self buildParseTree.					self checkForPrimitiveMethod.					self checkForSuperReferences.					self checkAssignmentsToVariable.					self getClassesToMoveTo.					self getArgumentNameForSelf.					self checkTemporaryVariableNames.					true])</body></methods><methods><class-id>Refactory.Browser.MoveMethodRefactoring</class-id> <category>private-accessing</category><body package="Browser-Refactorings">getClassesForInstanceVariable	| definingClass typer types |	definingClass := class whoDefinesInstanceVariable: variable.	typer := RefactoryTyper newFor: self model.	typer runOn: definingClass.	types := typer typesFor: variable.	types isEmpty 		ifTrue: [types := OrderedCollection with: (self model classFor: Object)].	moveToClasses := self selectVariableTypesFrom: types				selected: (typer guessTypesFor: variable).	moveToClasses isNil ifTrue: [self refactoringError: (#MethodNotMoved &lt;&lt; #browser &gt;&gt; 'Method not moved')]</body><body package="Browser-Refactorings">getClassesForTemporaryVariable	| types |	types := RefactoryTyper 				typesFor: variable				in: parseTree				model: self model.	types isEmpty 		ifTrue: [types := OrderedCollection with: (self model classFor: Object)].	moveToClasses := self selectVariableTypesFrom: types selected: types.	moveToClasses isNil ifTrue: [self refactoringError: (#MethodNotMoved &lt;&lt; #browser &gt;&gt; 'Method not moved')]</body><body package="Browser-Refactorings">getClassesToMoveTo	self isMovingToArgument 		ifTrue: [self getClassesForTemporaryVariable]		ifFalse: 			[self isMovingToInstVar 				ifTrue: [self getClassesForInstanceVariable]				ifFalse: [self getClassForGlobalOrClassVariable]].	moveToClasses isEmpty 		ifTrue: [self refactoringError: (#NoClassesSelectedMethodNotMoved &lt;&lt; #browser &gt;&gt; 'No classes selected, method not moved.')]</body><body package="Browser-Refactorings">getClassForGlobalOrClassVariable	| object type |	object := class referencedItem: variable.	type := self model classFor: ((object notNil and: [object isDefined]) 						ifTrue: 							[(object isSharedVariable 								ifTrue: [object realItem value]								ifFalse: [object realItem]) class]						ifFalse: [Object]).	moveToClasses := self selectVariableTypesFrom: (Array with: type)				selected: (Array with: type).	moveToClasses isNil ifTrue: [self refactoringError: (#MethodNotMoved &lt;&lt; #browser &gt;&gt; 'Method not moved')]</body></methods><methods><class-id>Refactory.Browser.MoveMethodRefactoring</class-id> <category>testing</category><body package="Browser-Refactorings">hasSelfReferences	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: 'self' do: [:aNode :answer | true].	self hasOnlySelfReturns 		ifTrue: [searcher matches: '^self' do: [:aNode :answer | answer]].	^searcher executeTree: parseTree initialAnswer: false</body><body package="Browser-Refactorings">isMovingToArgument	^(parseTree arguments collect: [:each | each name]) includes: variable</body><body package="Browser-Refactorings">isMovingToInstVar	^self isMovingToArgument not 		and: [(class whoDefinesInstanceVariable: variable) notNil]</body><body package="Browser-Refactorings">needsToReplaceSelfReferences	^self hasSelfReferences 		or: [self abstractVariablesRefactoring hasVariablesToAbstract]</body></methods><methods><class-id>Refactory.Browser.MoveMethodRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream	aStream nextPutAll: 'Move method to component refactoring'</body><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: selector;		nextPutAll: ' class: '.	class storeOn: aStream.	aStream		nextPutAll: ' variable: ''';		nextPutAll: variable;		nextPutAll: ''')'</body></methods><methods><class-id>Refactory.Browser.MoveMethodRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">selector: aSymbol class: aClass variable: aVariableName 	selector := aSymbol.	class := self classObjectFor: aClass.	variable := aVariableName</body></methods><methods><class-id>Refactory.Browser.MoveMethodRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">model: aRBNameSpace selector: aSymbol class: aClass variable: aVariableName 	^(self new)		model: aRBNameSpace;		selector: aSymbol			class: aClass			variable: aVariableName;		yourself</body><body package="Browser-Refactorings">selector: aSymbol class: aClass variable: aVariableName 	^(self new)		selector: aSymbol			class: aClass			variable: aVariableName;		yourself</body></methods><methods><class-id>Refactory.Browser.RefactoringWarning</class-id> <category>private - actions</category><body package="Browser-Refactorings">defaultAction	"Proceed through warnings"	^nil</body></methods><methods><class-id>Refactory.Browser.RefactoringWarning class</class-id> <category>signalling</category><body package="Browser-Refactorings">raiseSignal: aString with: aStringNoArgBlockAssociation	"The handleError: method expects the parameter of a warning, if not nil, to be an association whose key will name a third button in a confirmer and whose value is a block executed when that button is chosen. (e.g. 'ThirdWay' -&gt; [self doAmazingThing])"	^self new		searchFrom: thisContext sender;		originator: thisContext sender homeReceiver;		messageText: aString;		parameter: aStringNoArgBlockAssociation;		raiseSignal</body></methods><methods><class-id>Refactory.Browser.PushUpMethodRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">checkBackReferencesTo: aSelector 	| definingClass pushUpParseTree |	definingClass := class superclass whoDefinesMethod: aSelector.	definingClass isNil ifTrue: [^self].	pushUpParseTree := class parseTreeFor: aSelector.	class superclass allSubclasses do: 			[:each | 			each selectors do: 					[:sel | 					| parseTree |					parseTree := each parseTreeFor: sel.					(parseTree notNil and: 							[(parseTree superMessages includes: aSelector) 								and: [definingClass == (each whoDefinesMethod: aSelector)]]) 						ifTrue: 							[removeDuplicates := true.							(aSelector == sel 								and: [parseTree equalTo: pushUpParseTree exceptForVariables: #()]) 									ifFalse: 										[self 											refactoringError: ((#CannotPushUpWouldOverride &lt;&lt; #browser &gt;&gt; 'Cannot push up &lt;1s&gt; since it would override the method defined in &lt;2p&gt;') 													expandMacrosWith: aSelector													with: definingClass)]]]]</body><body package="Browser-Refactorings">checkInstVars	selectors do: [:each | self checkInstVarsFor: each]</body><body package="Browser-Refactorings">checkInstVarsFor: aSelector 	class instanceVariableNames do: 			[:each | 			((class whichSelectorsReferToInstanceVariable: each) includes: aSelector) 				ifTrue: 					[self refactoringError: ((#x1sRefersTo2sDefinedIn3s &lt;&lt; #browser &gt;&gt; '&lt;1p&gt; refers to &lt;2s&gt; which is defined in &lt;3p&gt;') 								expandMacrosWith: aSelector								with: each								with: class)]]</body><body package="Browser-Refactorings">checkSiblingSuperSendsFrom: aRBClass 	selectors do: 			[:aSelector | 			(aRBClass whichMethodsReferToSymbol: aSelector) do: 					[:each | 					| tree |					tree := each parseTree.					tree notNil 						ifTrue: 							[(tree superMessages includes: aSelector) 								ifTrue: 									[| definer |									definer := aRBClass superclass whoDefinesMethod: aSelector.									(definer notNil and: [class includesClass: definer]) 										ifTrue: 											[self 												refactoringError: ((#CannotPushUp1sSuperSend &lt;&lt; #browser &gt;&gt; 'Cannot push up &lt;1s&gt; since &lt;2p&gt;&gt;&gt;&lt;3s&gt; sends a super message to it.') 														expandMacrosWith: aSelector														with: aRBClass														with: each selector)]]]]].	aRBClass allSubclasses do: [:each | self checkSiblingSuperSendsFrom: each]</body><body package="Browser-Refactorings">checkSuperclass	| overrideSelectors |	overrideSelectors := selectors 				select: [:each | class superclass definesMethod: each].	overrideSelectors := overrideSelectors reject: 					[:each | 					| myTree superTree |					myTree := class parseTreeFor: each.					superTree := class superclass parseTreeFor: each.					superTree equalTo: myTree exceptForVariables: #()].	overrideSelectors isEmpty ifTrue: [^self].	class superclass isAbstract 		ifFalse: 			[self 				refactoringError: ((#NonAbstract2pOrSuperDefine1p &lt;&lt; #browser &gt;&gt; 'Non-abstract class &lt;2p&gt; or one of its superclasses already define &lt;1p&gt;') 						expandMacrosWith: overrideSelectors asArray first						with: class superclass)].	overrideSelectors do: [:each | self checkBackReferencesTo: each]</body><body package="Browser-Refactorings">checkSuperMessages	self checkSuperSendsFromPushedUpMethods.	self checkSuperSendsFromSiblings</body><body package="Browser-Refactorings">checkSuperSendsFromPushedUpMethods	selectors do: 			[:each | 			| parseTree |			parseTree := class parseTreeFor: each.			(parseTree superMessages 				anySatisfy: [:sup | class superclass directlyDefinesMethod: sup]) 					ifTrue: 						[self 							refactoringError: ((#CannotPushUp1sSuperSendInSuper &lt;&lt; #browser &gt;&gt; 'Cannot push up &lt;1s&gt; since it sends a super message that is defined in the superclass.') 									expandMacrosWith: each)]]</body><body package="Browser-Refactorings">checkSuperSendsFromSiblings	| siblings |	siblings := class superclass subclasses reject: [:each | each = class].	siblings do: [:each | self checkSiblingSuperSendsFrom: each]</body><body package="Browser-Refactorings">preconditions	^(selectors inject: (Condition hasSuperclass: class)		into: [:cond :each | cond &amp; (Condition definesSelector: each in: class)]) 			&amp; (Condition withBlock: 						[self checkInstVars.						"self checkClassVars."						self checkSuperclass.						self checkSuperMessages.						true])</body></methods><methods><class-id>Refactory.Browser.PushUpMethodRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">copyDownMethods	selectors do: [:each | self copyDownMethod: each]</body><body package="Browser-Refactorings">pushUp: aSelector 	| refactoring source |	refactoring := ExpandNameSpaceReferencesRefactoring 				model: self model				for: (class parseTreeFor: aSelector)				fromClass: class				toClasses: (Array with: class superclass).	self performComponentRefactoring: refactoring.	source := refactoring parseTree = (class parseTreeFor: aSelector) 				ifTrue: [class sourceCodeFor: aSelector]				ifFalse: [refactoring parseTree printString].	class superclass compile: source		withAttributesFrom: (class methodFor: aSelector)</body><body package="Browser-Refactorings">pushUpMethods	selectors do: [:each | self pushUp: each]</body><body package="Browser-Refactorings">removeDuplicateMethods	selectors do: [:each | self removeDuplicatesOf: each]</body><body package="Browser-Refactorings">removeDuplicatesOf: aSelector 	| tree |	tree := class superclass parseTreeFor: aSelector.	class superclass allSubclasses do: 			[:each | 			((each directlyDefinesMethod: aSelector) and: 					[(tree equalTo: (each parseTreeFor: aSelector) exceptForVariables: #()) 						and: [(each superclass whoDefinesMethod: aSelector) == class superclass]]) 				ifTrue: 					[removeDuplicates 						ifFalse: 							[removeDuplicates := true.							self 								refactoringWarning: (#RemoveDuplicateSubclassMethodsQ &lt;&lt; #browser &gt;&gt; 'Subclasses of the target class have duplicate copies of this method.&lt;n&gt;Pushing up the method will remove the copies. Proceed?') expandMacros].					each removeMethod: aSelector]]</body><body package="Browser-Refactorings">removePushedUpMethods	selectors do: [:each | class removeMethod: each]</body><body package="Browser-Refactorings">transform	self		copyDownMethods;		pushUpMethods;		removePushedUpMethods;		removeDuplicateMethods</body></methods><methods><class-id>Refactory.Browser.PushUpMethodRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream	aStream nextPutAll: 'Push up method refactoring'</body><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' pushUp: '.	selectors asArray storeOn: aStream.	aStream nextPutAll: ' from: '.	class storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.PushUpMethodRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">pushUp: selectorCollection from: aClass 	class := self classObjectFor: aClass.	selectors := selectorCollection.	removeDuplicates := false</body></methods><methods><class-id>Refactory.Browser.PushUpMethodRefactoring</class-id> <category>private</category><body package="Browser-Refactorings">copyDownMethod: aSelector 	| oldSource superclassDefiner subclasses refactoring |	superclassDefiner := class superclass whoDefinesMethod: aSelector.	superclassDefiner isNil ifTrue: [^self].	oldSource := superclassDefiner sourceCodeFor: aSelector.	oldSource isNil 		ifTrue: 			[self 				refactoringError: ((#SourceFor1sSuperNA &lt;&lt; #browser &gt;&gt; 'Source code for &lt;1s&gt; superclass method not available') 						expandMacrosWith: aSelector)].	subclasses := class superclass subclasses 				reject: [:each | each directlyDefinesMethod: aSelector].	subclasses isEmpty ifTrue: [^self].	((superclassDefiner parseTreeFor: aSelector) superMessages 		anySatisfy: [:each | superclassDefiner directlyDefinesMethod: each]) 			ifTrue: 				[self 					refactoringError: ((#CannotPushUp1sMustCopyDownAndSuperOverridden &lt;&lt; #browser &gt;&gt; 'Cannot push up &lt;1s&gt; since we must copy down the superclass method in &lt;2p&gt;&lt;n&gt;to the other subclasses, and the superclass method sends a super message which is overridden.') 							expandMacrosWith: aSelector							with: superclassDefiner)].	self 		refactoringWarning: ((#CopyDownSuperMethod1s &lt;&lt; #browser &gt;&gt; 'Do you want to copy down the superclass method to the classes that don''t define &lt;1s&gt;')			expandMacrosWith: aSelector).	refactoring := ExpandNameSpaceReferencesRefactoring 				model: self model				for: (superclassDefiner parseTreeFor: aSelector)				fromClass: superclassDefiner				toClasses: subclasses.	self performComponentRefactoring: refactoring.	subclasses do: 			[:each | 			each compile: refactoring parseTree printString				withAttributesFrom: (superclassDefiner methodFor: aSelector)]</body></methods><methods><class-id>Refactory.Browser.PushUpMethodRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">model: aRBNameSpace pushUp: selectorCollection from: aClass 	^(self new)		model: aRBNameSpace;		pushUp: selectorCollection from: aClass;		yourself</body><body package="Browser-Refactorings">pushUp: selectorCollection from: aClass 	^(self new)		pushUp: selectorCollection from: aClass;		yourself</body></methods><methods><class-id>Refactory.Browser.ExtractToTemporaryRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">checkVariableName		(class whoDefinesInstanceVariable: newVariableName) notNil		ifTrue:			[self				refactoringError:					(#x1pDefinesInstVar2s &lt;&lt; #browser &gt;&gt;							'&lt;1p&gt; defines an instance variable named &lt;2s&gt;' expandMacrosWith:							class with: newVariableName)].	(self sourceTree allDefinedVariables includes: newVariableName)		ifTrue:			[self				refactoringError:					(#x1sIsAlreadyTempName &lt;&lt; #browser &gt;&gt;							'&lt;1s&gt; is already a temporary variable name' expandMacrosWith:							newVariableName)]</body><body package="Browser-Refactorings">preconditions	^(Condition definesSelector: selector in: class) 		&amp; (Condition isValidInstanceVariableName: newVariableName for: class) 			&amp; (Condition withBlock: 						[self verifySelectedInterval.						self checkVariableName.						true])</body><body package="Browser-Refactorings">verifySelectedInterval	| selectedParseTree selectedSources |	selectedSources := self selectedSource.	selectedParseTree := RBParser parseExpression: selectedSources				onError: [:message :position | self refactoringError: (#InvalidSelection &lt;&lt; #browser &gt;&gt; 'Invalid selection')].	selectedParseTree isSequence 		ifTrue: [self refactoringError: (#CannotAssignTempToMultiple &lt;&lt; #browser &gt;&gt; 'Cannot assign temp to multiple statements')]</body></methods><methods><class-id>Refactory.Browser.ExtractToTemporaryRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">compileNewMethod		class compileTree: self sourceTree</body><body package="Browser-Refactorings">constructAssignmentFrom: aNode 	| valueNode |	valueNode := RBVariableNode named: newVariableName.	^RBAssignmentNode variable: valueNode value: aNode</body><body package="Browser-Refactorings">insertTemporary		| node statementNode |	node := self sourceTree whichNodeIsContainedBy: sourceInterval.	(node notNil and: [node isValue])		ifFalse:			[self				refactoringError:					#CannotAssignToNonValueNodes &lt;&lt; #browser &gt;&gt;							'Cannot assign to non-value nodes'].	statementNode := node statementNode.	node replaceWith: (RBVariableNode named: newVariableName).	(statementNode parent)		addNode: (self constructAssignmentFrom: node)			before:				(node == statementNode					ifTrue: [RBVariableNode named: newVariableName]					ifFalse: [statementNode]);		addTemporaryNamed: newVariableName</body><body package="Browser-Refactorings">transform	self		insertTemporary;		compileNewMethod</body></methods><methods><class-id>Refactory.Browser.ExtractToTemporaryRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">extract: anInterval to: aString from: aSelector in: aClass 	class := self classObjectFor: aClass.	selector := aSelector.	sourceInterval := anInterval.	newVariableName := aString</body></methods><methods><class-id>Refactory.Browser.ExtractToTemporaryRefactoring</class-id> <category>private-accessing</category><body package="Browser-Refactorings">selectedSource		| source |	source := self sourceTree source.	source isNil		ifTrue:			[self				refactoringError:					#CouldntFindSources &lt;&lt; #browser &gt;&gt; 'Couldn''t find sources'].	((sourceInterval first		between: 1		and: source size)		and:			[sourceInterval last				between: 1				and: source size])		ifFalse:			[self refactoringError: #InvalidInterval &lt;&lt; #browser &gt;&gt; 'Invalid interval'].	^source		copyFrom: sourceInterval first		to: sourceInterval last</body><body package="Browser-Refactorings">sourceTree		^sourceTree ifNil: [sourceTree := class parseTreeFor: selector]</body><body package="Browser-Refactorings">sourceTree: aParseTree		sourceTree := aParseTree</body></methods><methods><class-id>Refactory.Browser.ExtractToTemporaryRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	aStream nextPutAll: 'Extract to temporary refactoring'</body><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' extract: '.	sourceInterval storeOn: aStream.	aStream		nextPutAll: ' to: ''';		nextPutAll: newVariableName;		nextPutAll: ''' from: #';		nextPutAll: selector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.ExtractToTemporaryRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">extract: anInterval to: aString from: aSelector in: aClass 	^(self new)		extract: anInterval			to: aString			from: aSelector			in: aClass;		yourself</body><body package="Browser-Refactorings">model: aRBNameSpace extract: anInterval to: aString from: aSelector in: aClass 	^(self new)		model: aRBNameSpace;		extract: anInterval			to: aString			from: aSelector			in: aClass;		yourself</body></methods><methods><class-id>Refactory.Browser.RBNameSpace</class-id> <category>private</category><body package="Browser-Refactorings">allNewClassesDo: aBlock 	self privateItems isNil ifTrue: [^self].	self privateItems do: 			[:each | 			each isClassObject 				ifTrue: 					[aBlock						value: each nonMetaclass;						value: each metaclass]				ifFalse: [each isNameSpace ifTrue: [each allNewClassesDo: aBlock]]]</body><body package="Browser-Refactorings">basicRemove	^self changes removeNameSpaceNamed: self unambiguousName</body><body package="Browser-Refactorings">recompileObject	self rootNameSpace defineNameSpace: self definitionString</body><body package="Browser-Refactorings">recompileObjectWithRename: renameRefactor	"The receiver must be recompiled in order to achieve a rename refactoring, but	 it is possible that the receiver is in fact the object being renamed.  If so detect	 that condition to produce the correct definition."	| save |	save := name.	^[renameRefactor modelObject == self		ifTrue: [name := renameRefactor newName].	self rootNameSpace defineNameSpace: self definitionString]				ensure: [name := save]</body></methods><methods><class-id>Refactory.Browser.RBNameSpace</class-id> <category>private-changes</category><body package="Browser-Refactorings">addClassFrom: aClassChange 	| newClass newClassName |	newClassName := aClassChange objectName.	(newClassName includes: $.) 		ifTrue: 			[newClassName := (newClassName copyFrom: (newClassName lastIndexOf: $.) + 1						to: newClassName size) asSymbol].	newClass := self itemFor: newClassName.	newClass isNil 		ifTrue: 			[self privateRemovedItems notNil 				ifTrue: [self privateRemovedItems remove: newClassName ifAbsent: []].			newClass := RBClass named: newClassName model: self.			self items at: newClassName put: newClass].	newClass superclass: (aClassChange superclassName isNil 				ifTrue: [nil]				ifFalse: [self rootNameSpace classNamed: aClassChange superclassName]).	newClass superclass isNil 		ifTrue: 			[self rootNameSpace rootClasses add: newClass.			newClass metaclass superclass: (self classFor: Object class superclass)]		ifFalse: [newClass metaclass superclass: newClass superclass metaclass].	newClass imports: aClassChange imports.	newClass indexedType: aClassChange indexedType.	newClass isPrivate: aClassChange isPrivate.	newClass instanceVariableNames: aClassChange instanceVariableNames.	newClass attributes: aClassChange attributes.	newClass metaclass 		instanceVariableNames: aClassChange classInstanceVariableNames.	^aClassChange</body><body package="Browser-Refactorings">addInstanceVariable: aString to: aRBClass 	^self changes addInstanceVariable: aString to: aRBClass</body><body package="Browser-Refactorings">addNameSpaceFrom: aNameSpaceChange		| ns nameSpaceName |	nameSpaceName := aNameSpaceChange newNameSpaceName.	(nameSpaceName includes: $.)		ifTrue:			[nameSpaceName := (nameSpaceName				copyFrom: (nameSpaceName lastIndexOf: $.) + 1				to: nameSpaceName size) asSymbol].	ns := self itemFor: nameSpaceName.	ns isNil		ifTrue:			[self privateRemovedItems notNil				ifTrue:					[self privateRemovedItems						remove: nameSpaceName						ifAbsent: []].			ns := RBNameSpace named: nameSpaceName model: self.			self items at: nameSpaceName put: ns].	ns imports: aNameSpaceChange imports.	ns isPrivate: aNameSpaceChange isPrivate.	^aNameSpaceChange</body><body package="Browser-Refactorings">changeClass: aRBClass 	self flushCaches</body><body package="Browser-Refactorings">compile: aString in: aRBClass classified: aSymbol 	| change |	change := self changes 				compile: aString				in: aRBClass				classified: aSymbol.	self flushCaches.	^change</body><body package="Browser-Refactorings">performChange: aCompositeRefactoryChange around: aBlock 	| oldChanges |	self changes addChange: aCompositeRefactoryChange.	oldChanges := self changes.	self rootNameSpace changes: aCompositeRefactoryChange.	aBlock ensure: [self rootNameSpace changes: oldChanges].	^aCompositeRefactoryChange</body><body package="Browser-Refactorings">removeInstanceVariable: aString from: aRBClass 	^self changes removeInstanceVariable: aString from: aRBClass</body><body package="Browser-Refactorings">removeMethod: aSelector from: aRBClass 	self flushCaches.	^self changes removeMethod: aSelector from: aRBClass</body><body package="Browser-Refactorings">renameInstanceVariable: oldName to: newName in: aRBClass 	^self changes addChange: (RenameInstanceVariableChange 				rename: oldName				to: newName				in: aRBClass)</body><body package="Browser-Refactorings">replaceClassNameIn: definitionString to: aReference 	| parseTree |	parseTree := RBParser parseExpression: definitionString.	parseTree arguments at: 2 put: (RBLiteralNode value: aReference).	^parseTree formattedCode</body></methods><methods><class-id>Refactory.Browser.RBNameSpace</class-id> <category>changes</category><body package="Browser-Refactorings">defineClass: aString 	| change |	change := self changes defineClass: aString.	^(self nameSpaceNamed: change nameSpaceName) addClassFrom: change</body><body package="Browser-Refactorings">defineNameSpace: aString 	| change |	change := self changes defineNameSpace: aString.	^(self nameSpaceNamed: change nameSpaceName) addNameSpaceFrom: change</body><body package="Browser-Refactorings">moveObject: anRBProgramItem toScope: anRBNamespace	self changes		moveObjectNamed: anRBProgramItem unambiguousName		to: anRBNamespace unambiguousName.	anRBNamespace items		at: anRBProgramItem name		put: anRBProgramItem.	anRBProgramItem environment removedItems add: anRBProgramItem name.	anRBProgramItem parent: anRBNamespace</body><body package="Browser-Refactorings">renameClass: aRBClass to: aSymbol around: aBlock 	| change |	change := RenameObjectChange rename: aRBClass unambiguousName to: aSymbol.	aRBClass environment items at: aSymbol put: aRBClass.	self performChange: change around: aBlock.	self flushCaches.	aRBClass environment removedItems add: aRBClass name.	aRBClass environment items at: aRBClass name.	aRBClass environment items removeKey: aRBClass name.	aRBClass name: aSymbol.	aRBClass isClassObject 		ifTrue: 			[aRBClass subclasses do: [:each | each superclass: aRBClass].			aRBClass metaclass subclasses 				do: [:each | each superclass: aRBClass metaclass]].	^change</body><body package="Browser-Refactorings">reparentClasses: aRBClassCollection to: newClass 	aRBClassCollection do: 			[:aClass | 			self defineClass: (self replaceClassNameIn: aClass definitionString						to: (newClass isNil ifTrue: [nil] ifFalse: [newClass asReference]))]</body></methods><methods><class-id>Refactory.Browser.RBNameSpace</class-id> <category>accessing</category><body package="Browser-Refactorings">definitionString	| definitionStream |	definitionStream := WriteStream on: String new.	definitionStream		nextPutAll: self environment unambiguousName;		nextPutAll: ' defineNameSpace: #';		nextPutAll: self name;		cr;		tab;		nextPutAll: 'private: ';		nextPutAll: isPrivate printString;		cr;		tab;		nextPutAll: 'imports: '''.	self imports do: [:each | each printDefinitionOn: definitionStream]		separatedBy: 			[definitionStream				cr;				tab].	definitionStream		nextPutAll: '''';		cr;		tab;		nextPutAll: 'category: '''''.	^definitionStream contents</body></methods><methods><class-id>Refactory.Browser.RBNameSpace</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	aStream		nextPutAll: '[RB]';		nextPutAll: self fullName</body></methods><methods><class-id>Refactory.Browser.RBNameSpace class</class-id> <category>instance creation</category><body package="Browser-Refactorings">onBinding: aBinding 	^(self new)		realBinding: aBinding;		yourself</body></methods><methods><class-id>Refactory.Browser.RefactoryTyper</class-id> <category>printing</category><body package="Browser-Refactorings">collectionNameFor: aString 	^'-&lt;1s&gt;-' expandMacrosWith: aString</body><body package="Browser-Refactorings">printOn: aStream 	aStream		nextPutAll: class fullName;		cr.	class instanceVariableNames do: 			[:each | 			aStream				tab;				nextPutAll: each;				tab;				nextPut: $&lt;.			self printTypeFor: each on: aStream.			aStream				nextPut: $&gt;;				cr]</body><body package="Browser-Refactorings">printType: aClass for: aString on: aStream 	| name colTypes |	colTypes := #().	name := self collectionNameFor: aString.	(aClass includesClass: (model classFor: Collection)) 		ifTrue: [colTypes := self guessTypesFor: name].	colTypes notEmpty ifTrue: [aStream nextPut: $(].	aStream nextPutAll: aClass name.	colTypes notEmpty 		ifTrue: 			[aStream nextPutAll: ' of: '.			colTypes size &gt; 1 ifTrue: [aStream nextPut: $(].			self printTypeFor: name on: aStream.			colTypes size &gt; 1 ifTrue: [aStream nextPut: $)]].	colTypes notEmpty ifTrue: [aStream nextPut: $)]</body><body package="Browser-Refactorings">printTypeFor: aString on: aStream 	| types |	types := (self guessTypesFor: aString) 				asSortedCollection: [:a :b | a name &lt; b name].	1 to: types size		do: 			[:i | 			i == 1 ifFalse: [aStream nextPutAll: ' | '].			self 				printType: (types at: i)				for: aString				on: aStream]</body></methods><methods><class-id>Refactory.Browser.RefactoryTyper</class-id> <category>selectors</category><body package="Browser-Refactorings">computeMessagesSentToVariables	| searcher |	variableMessages := Dictionary new.	class instanceVariableNames 		do: [:each | variableMessages at: each put: Set new].	searcher := ParseTreeSearcher new.	class instanceVariableNames do: 			[:each | 			| block |			block := 					[:aNode :answer | 					(variableMessages at: each ifAbsentPut: [Set new]) add: aNode selector.					self processCollectionMessagesFor: each in: aNode].			searcher matches: each , ' `@messageName: ``@args' do: block.			(backpointers at: each) do: 					[:sel | 					sel isSymbol 						ifTrue: 							[searcher 								matches: ('(self &lt;1s&gt;) `@messageName: ``@args' 										expandMacrosWith: (ParseTreeSearcher buildSelectorString: sel)) asString								do: block]]].	searcher answer: variableMessages.	self executeSearch: searcher</body></methods><methods><class-id>Refactory.Browser.RefactoryTyper</class-id> <category>computing types</category><body package="Browser-Refactorings">computeTypes	variableMessages		keysAndValuesDo: [:key :value | variableTypes at: key put: (self findTypeFor: value)]</body><body package="Browser-Refactorings">findTypeFor: selectorCollection 	^selectorCollection inject: model rootClasses		into: 			[:classes :each | 			self refineTypes: classes				with: (selectorLookup at: each ifAbsentPut: [self implementorsOf: each])]</body><body package="Browser-Refactorings">implementorsOf: aSelector 	| classes |	classes := OrderedCollection new.	model rootClasses do: 			[:each | 			self 				implementorsOf: aSelector				in: each				storeIn: classes].	^classes</body><body package="Browser-Refactorings">implementorsOf: aSelector in: aClass storeIn: classes 	(aClass directlyDefinesMethod: aSelector) 		ifTrue: 			[classes add: aClass.			^self].	aClass subclasses do: 			[:each | 			self 				implementorsOf: aSelector				in: each				storeIn: classes]</body><body package="Browser-Refactorings">refineTypes: aClassCollection with: anotherClassCollection 	| classSet |	classSet := Set new.	aClassCollection do: 			[:each | 			anotherClassCollection do: 					[:cls | 					(cls includesClass: each) 						ifTrue: [classSet add: cls]						ifFalse: [(each includesClass: cls) ifTrue: [classSet add: each]]]].	^classSet</body></methods><methods><class-id>Refactory.Browser.RefactoryTyper</class-id> <category>private</category><body package="Browser-Refactorings">executeSearch: searcher 	class withAllSubclasses do: 			[:each | 			each selectors do: 					[:sel | 					| parseTree |					methodName := sel.					parseTree := each parseTreeFor: sel.					parseTree notNil ifTrue: [searcher executeTree: parseTree]]]</body><body package="Browser-Refactorings">model	^model</body><body package="Browser-Refactorings">model: aRBNameSpace 	model := aRBNameSpace</body></methods><methods><class-id>Refactory.Browser.RefactoryTyper</class-id> <category>assignments</category><body package="Browser-Refactorings">guessTypeFromAssignment: aNode 	| type set newType |	type := nil.	aNode value isAssignment 		ifTrue: 			[^self guessTypeFromAssignment: (RBAssignmentNode variable: aNode variable						value: aNode value value)].	aNode value isBlock ifTrue: [type := model classFor: [] class].	aNode value isLiteralNode 		ifTrue: 			[aNode value value isNil ifTrue: [^self].			type := model classFor: (self typeFor: aNode value value)].	aNode value isMessage 		ifTrue: 			[aNode value receiver isVariable 				ifTrue: [type := model classNamed: aNode value receiver name asSymbol].			aNode value selector == #asValue 				ifTrue: [type := model classNamed: #ValueHolder].			(#(#and: #or: #= #== #~= #~~ #&lt;= #&lt; #~~ #&gt; #&gt;=) 				includes: aNode value selector) ifTrue: [type := model classFor: Boolean]].	type isNil ifTrue: [^self].	set := variableTypes at: aNode variable name.	newType := set detect: [:each | type includesClass: each] ifNone: [nil].	newType isNil ifTrue: [^self].	newType = (model classFor: Object) ifTrue: [newType := type].	(bestGuesses at: aNode variable name ifAbsentPut: [Set new]) add: newType</body><body package="Browser-Refactorings">refineTypesByLookingAtAssignments	| searcher needsSearch |	needsSearch := false.	searcher := ParseTreeSearcher new.	variableTypes keysAndValuesDo: 			[:key :value | 			key first == $- 				ifFalse: 					[needsSearch := true.					searcher matches: key , ' := ``@object'						do: [:aNode :answer | self guessTypeFromAssignment: aNode]]].	needsSearch ifTrue: [self executeSearch: searcher]</body><body package="Browser-Refactorings">typeFor: anObject 	'' class == anObject class ifTrue: [^String].	^(#(true false) includes: anObject) 		ifTrue: [Boolean]		ifFalse: [anObject class]</body></methods><methods><class-id>Refactory.Browser.RefactoryTyper</class-id> <category>accessing</category><body package="Browser-Refactorings">guessTypesFor: anInstVarName 	^bestGuesses at: anInstVarName ifAbsent: [self typesFor: anInstVarName]</body><body package="Browser-Refactorings">guessTypesFor: anInstVarName in: aClass 	class = aClass ifFalse: [self runOn: aClass].	^bestGuesses at: anInstVarName		ifAbsent: [self typesFor: anInstVarName in: aClass]</body><body package="Browser-Refactorings">runOn: aClass 	variableTypes := Dictionary new.	variableMessages := Dictionary new.	bestGuesses := Dictionary new.	class := model classFor: aClass.	class instanceVariableNames isEmpty ifTrue: [^self].	self		selectedClass: aClass;		computeEquivalenceClassesForMethodsAndVars;		computeMessagesSentToVariables;		computeTypes;		refineTypesByLookingAtAssignments</body><body package="Browser-Refactorings">selectedClass: aClass 	class := model classFor: aClass</body><body package="Browser-Refactorings">typesFor: anInstVarName 	^variableTypes at: anInstVarName ifAbsent: [Set new]</body><body package="Browser-Refactorings">typesFor: anInstVarName in: aClass 	class = aClass ifFalse: [self runOn: aClass].	^variableTypes at: anInstVarName ifAbsent: [Set new]</body></methods><methods><class-id>Refactory.Browser.RefactoryTyper</class-id> <category>initialize-release</category><body package="Browser-Refactorings">initialize	model := RBRootNameSpace new.	class := model classFor: Object.	variableTypes := Dictionary new.	variableMessages := Dictionary new.	selectorLookup := IdentityDictionary new.	bestGuesses := Dictionary new</body></methods><methods><class-id>Refactory.Browser.RefactoryTyper</class-id> <category>selectors-collections</category><body package="Browser-Refactorings">processCollectionFor: key messagesTo: aName in: aBlock 	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: aName , ' `@message: ``@args'		do: 			[:aNode :answer | 			self processCollectionMessagesFor: key in: aNode.			answer				add: aNode selector;				yourself].	searcher executeTree: aBlock		initialAnswer: (variableMessages at: (self collectionNameFor: key)				ifAbsentPut: [Set new])</body><body package="Browser-Refactorings">processCollectionMessagesFor: variableName in: aParseTree 	| parent block |	aParseTree isMessage ifFalse: [^self].	(#(#first #at: #last) includes: aParseTree selector) 		ifTrue: 			[parent := aParseTree parent.			(parent notNil and: [parent isMessage]) ifFalse: [^self].			aParseTree == parent receiver ifFalse: [^self].			(variableMessages at: (self collectionNameFor: variableName)				ifAbsentPut: [Set new]) add: parent selector.			self processCollectionMessagesFor: (self collectionNameFor: variableName)				in: parent].	(#(#do: #do:separatedBy: #collect: #reject: #select: #detect: #detect:ifNone:) 		includes: aParseTree selector) 			ifTrue: 				[block := aParseTree arguments first.				block isBlock ifFalse: [^self].				self 					processCollectionFor: variableName					messagesTo: block arguments first name					in: block].	#inject:into: == aParseTree selector 		ifTrue: 			[block := aParseTree arguments last.			block isBlock ifFalse: [^self].			self 				processCollectionFor: variableName				messagesTo: block arguments last name				in: block]</body></methods><methods><class-id>Refactory.Browser.RefactoryTyper</class-id> <category>equivalence classes</category><body package="Browser-Refactorings">computeEquivalenceClassesForMethodsAndVars	| searcher |	backpointers := Dictionary new.	class instanceVariableNames 		do: [:each | backpointers at: each put: (Set with: each)].	class withAllSubclasses 		do: [:sub | sub selectors do: [:each | backpointers at: each put: (Set with: each)]].	searcher := ParseTreeSearcher new.	searcher matches: '^``@object'		do: [:aNode :answer | self processNode: aNode value].	self executeSearch: searcher</body><body package="Browser-Refactorings">merge: aName 	| set1 set2 |	set1 := backpointers at: methodName ifAbsent: [nil].	set2 := backpointers at: aName ifAbsent: [nil].	(set1 isNil or: [set2 isNil or: [set1 == set2]]) ifTrue: [^self].	set1 addAll: set2.	set2 do: [:each | backpointers at: each put: set1]</body><body package="Browser-Refactorings">processNode: aNode 	(aNode isVariable and: [class instanceVariableNames includes: aNode name]) 		ifTrue: [^self merge: aNode name].	(aNode isMessage 		and: [aNode receiver isVariable and: [aNode receiver name = 'self']]) 			ifTrue: [^self merge: aNode selector].	aNode isAssignment 		ifTrue: 			[self				processNode: aNode value;				processNode: aNode variable].	(aNode isMessage and: 			[#(#ifTrue: #ifFalse: #ifTrue:ifFalse: #ifFalse:ifTrue:) 				includes: aNode selector]) 		ifTrue: 			[aNode arguments do: 					[:each | 					each isBlock 						ifTrue: 							[each body statements notEmpty 								ifTrue: [self processNode: each body statements last]]]]</body></methods><methods><class-id>Refactory.Browser.RefactoryTyper class</class-id> <category>instance creation</category><body package="Browser-Refactorings">new	^(super new)		initialize;		yourself</body><body package="Browser-Refactorings">newFor: aRBNameSpace 	^(self new)		model: aRBNameSpace;		yourself</body></methods><methods><class-id>Refactory.Browser.RefactoryTyper class</class-id> <category>accessing</category><body package="Browser-Refactorings">typesFor: variableName in: aParseTree model: aRBNameSpace 	| searcher messages |	searcher := ParseTreeSearcher new.	searcher matches: variableName , ' `@message: ``@args'		do: 			[:aNode :answer | 			answer				add: aNode selector;				yourself].	messages := searcher executeTree: aParseTree initialAnswer: Set new.	^(self new)		model: aRBNameSpace;		findTypeFor: messages</body></methods><methods><class-id>Refactory.Browser.ClassRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">className: aName	className := aName</body></methods><methods><class-id>Refactory.Browser.ClassRefactoring</class-id> <category>private</category><body package="Browser-Refactorings">definitionName	| index |	index := className lastIndexOf: $..	^className copyFrom: index + 1 to: className size</body><body package="Browser-Refactorings">nameSpace	^self model nameSpaceNamed: self nameSpaceName</body><body package="Browser-Refactorings">nameSpaceName	| nameSpaceName index |	index := className lastIndexOf: $..	nameSpaceName := index = 0 				ifTrue: ['']				ifFalse: [className copyFrom: 1 to: index - 1].	nameSpaceName isEmpty ifTrue: [nameSpaceName := 'Smalltalk'].	^nameSpaceName</body><body package="Browser-Refactorings">unambiguousNameSpaceName	| ns |	ns := self nameSpaceName.	^(ns includes: $.)		ifTrue: [ns]		ifFalse: ['Smalltalk.', ns]</body></methods><methods><class-id>Refactory.Browser.ClassRefactoring</class-id> <category>accessing</category><body package="Browser-Refactorings">package	^self options at: #package ifAbsent: [nil]</body><body package="Browser-Refactorings">package: aPackageModel	self options at: #package put: aPackageModel</body></methods><methods><class-id>Refactory.Browser.ClassRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">className: aName 	^(self new)		className: aName;		yourself</body><body package="Browser-Refactorings">model: aRBNameSpace className: aName 	^(self new)		model: aRBNameSpace;		className: aName;		yourself</body></methods><methods><class-id>Refactory.Browser.RenameObjectRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">className: aName newName: aNewName 	className := aName.	object := self model fullItemNamed: className.	newName := aNewName asSymbol</body></methods><methods><class-id>Refactory.Browser.RenameObjectRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	aStream nextPutAll: 'Rename object'</body><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' renameObjectNamed: ''';		nextPutAll: className;		nextPutAll: ''' to: ''';		nextPutAll: newName;		nextPutAll: ''')'</body></methods><methods><class-id>Refactory.Browser.RenameObjectRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">parseTreeRewriter	^(ParseTreeRewriter new)		replace: '`#literal'			withValueFrom: [:aNode | self replaceLiteralNode: aNode]			when: [:aNode | self methodClass checkLiteral: aNode value references: object];		replace: object name			with: newName			when: [:node | self methodClass canAccess: object];		replace: '`var'			withValueFrom: 				[:aNode | 				self 					replaceFullReferenceTo: object					inVariable: aNode					toBe: newName]			when: 				[:node | 				(node name includes: $.) 					and: [self methodClass doesName: node name includeObject: object]];		replaceArgument: newName			withValueFrom: 				[:aNode | 				self 					refactoringError: ((#x1sAlreadyExistsInScope &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; already exists within the reference scope')			expandMacrosWith: newName)];		yourself</body><body package="Browser-Refactorings">renameImportReferences	"It is possible that the object being renamed is a component of the fully qualified name of its own import, so make sure we handle that condition."	methodClass := model smalltalkNameSpace.	model allNameSpacesDo: 			[:each | 			(each imports 				anySatisfy: [:lit | each doesPath: lit path includeObject: object]) 					ifTrue: 						[each 							changeImportsTo: (each imports collect: 										[:lit | 										(each doesPath: lit path includeObject: object) 											ifTrue: [self replaceBindingReference: lit]											ifFalse: [lit]])							withRename: self]].	methodClass := nil</body><body package="Browser-Refactorings">renameReferences	self		renameSourceCodeReferences;		renameImportReferences</body><body package="Browser-Refactorings">renameSourceCodeReferences	| replacer |	replacer := self parseTreeRewriter.	self model allReferencesToObject: object		do: 			[:method | 			(method modelClass isClassObject and: 					[(method modelClass hierarchyDefinesVariable: newName) and: 							[(object environment isClassObject 								and: [method modelClass nonMetaclass includesClass: object environment]) 									not]]) 				ifTrue: 					[self refactoringError: ((#x1sAlreadyDefinedInHierarchyOf2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is already defined in hierarchy of &lt;2s&gt;')			expandMacrosWith: newName			with: method modelClass printString)].			self convertMethod: method using: replacer]</body><body package="Browser-Refactorings">replaceBindingReference: aReference 	| path newPath |	path := aReference path.	newPath := self 				replaceReferenceTo: object				inPath: path				toBe: newName.	^(aReference copy)		path: newPath;		yourself</body><body package="Browser-Refactorings">replaceLiteral: aLiteral 	(aLiteral == object name and: [self methodClass canAccess: object]) 		ifTrue: [^newName].	aLiteral isBindingReference 		ifTrue: [^self replaceBindingReference: aLiteral].	aLiteral class == Array 		ifTrue: [^aLiteral collect: [:each | self replaceLiteral: each]].	^aLiteral</body><body package="Browser-Refactorings">replaceLiteralNode: aNode 	^RBLiteralNode value: (self replaceLiteral: aNode value)</body><body package="Browser-Refactorings">transform	self model 		renameClass: object		to: newName		around: [self renameReferences]</body></methods><methods><class-id>Refactory.Browser.RenameObjectRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">preconditions	object isNil 		ifTrue: [self refactoringError: ((#x1sIsInvalidObjectName &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is not a valid object name')			expandMacrosWith: className)].	^(Condition withBlock: [object isClassObject not or: [object isMeta not]]		errorString: ((#x1sIsInvalidObjectName &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is not a valid object name')			expandMacrosWith: className)) 			&amp; (Condition isValidClassName: newName) 			&amp; (Condition canReference: newName in: object environment) not</body></methods><methods><class-id>Refactory.Browser.RenameObjectRefactoring</class-id> <category>accessing</category><body package="Browser-Refactorings">modelObject	^object</body><body package="Browser-Refactorings">newName	^newName</body></methods><methods><class-id>Refactory.Browser.RenameObjectRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">model: aRBNameSpace renameObjectNamed: aString to: aNewName 	^(self new)		model: aRBNameSpace;		className: aString newName: aNewName;		yourself</body><body package="Browser-Refactorings">renameObjectNamed: aString to: aNewName 	^(self new)		className: aString newName: aNewName;		yourself</body></methods><methods><class-id>Refactory.Browser.RenameObjectAndMethodsRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">classNameInSelectorPatterns	"Offer to rename methods matching a pattern and containing the class name."	^(Pragma allNamed: #classNameInSelectorPatterns: in: self class)		inject: Set new		into: [:all :pragma | all addAll: (pragma argumentAt: 1). all]"A pragma extension method adding to the patterns for framework-method-rename-synched-to-class-rename will look like e.g.	RenameObjectAndMethodsRefactoring&gt;&gt;classNameInSelectorPatternsGlorp		&lt;classNameInSelectorPatterns: #('classModelFor&lt;1s&gt;:' 'descriptorFor&lt;1s&gt;:')&gt;This pragma means that invoking rename of MyClass to YourClass will offer also to rename any methods #classModelForMyClass: and #descriptorForMyClass: to #classModelForYourClass: and #descriptorForYourClass:.  Add pragmas as needed to support similar class-name / method-name synchronicities of other frameworks.  (Put the framework's name in the pragma extension method's name to avoid risk of clashing with others.)"</body><body package="Browser-Refactorings">preconditions	^super preconditions		&amp; (Condition withBlock:			[self modelObject isClassObject not or:				[self warnClassNameInSelector. true]])</body><body package="Browser-Refactorings">renameClassNameInSelector: aString	"The model caches the implementors so we need not do so here in a temp when getting them twice.  We return nil if there are none."	| oldDescriptorSystemSelector newDescriptorSystemSelector |	oldDescriptorSystemSelector := (aString expandMacrosWith: object name) asSymbol.	newDescriptorSystemSelector := (aString expandMacrosWith: newName) asSymbol.	^(self model allImplementorsOf: oldDescriptorSystemSelector) isEmpty ifFalse:		[RenameMethodRefactoring				model: self model				renameMethod: oldDescriptorSystemSelector				in: (self model allImplementorsOf: oldDescriptorSystemSelector) any				to: newDescriptorSystemSelector				permutation: (1 to: (oldDescriptorSystemSelector occurrencesOf: $:))]</body><body package="Browser-Refactorings">warnClassNameInSelector	"If the class name appears in descriptor system methods, ask the user whether we should rename those methods as well."	| matchingMethodRefactorings |	matchingMethodRefactorings := Set new.	self classNameInSelectorPatterns do:		[:each | matchingMethodRefactorings add: (self renameClassNameInSelector: each)].	matchingMethodRefactorings isEmpty ifTrue: [^self].	self		refactoringWarning:			(#RenameClassNameInMethods &lt;&lt; #browser &gt;&gt; 'The name &lt;1s&gt; appears in the methods&lt;2s&gt;'				expandMacrosWith: object name				with: (self classNameInSelectorPatterns						inject: String new writeStream						into: [:stream :each | stream crtab; nextPut: $#; nextPutAll: (each expandMacrosWith: object name). stream])							contents)		with: 'Also rename in selectors' -&gt;			[methodRefactorings addAll: matchingMethodRefactorings.			true].	"Return true to ensure main refactoring proceeds""Notes=====1) We could use	(self model fullItemNamed: 'Glorp.DescriptorSystem')		 subclassRedefines: 'classModelFor...to verify whether there are matching selector(s) to be found in the descriptor system hierarchy but this would complicate the UI.  The user will be warned if there is more than one implementor and should be expecting the presence or absence of descriptor system references.  Unless dynamic method renaming is loaded, the code will only offer to rename all matching selectors or none, whether in DescriptorSystem subclasses or not.2) This warning hardcodes descriptor system references.  It should be generalised to warn of all class name references in nethod names, with a list UI to let the user select which matching methods get renamed."</body></methods><methods><class-id>Refactory.Browser.RenameObjectAndMethodsRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">initialize	super initialize.	methodRefactorings := OrderedCollection new.</body></methods><methods><class-id>Refactory.Browser.RenameObjectAndMethodsRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">transform	"The method refactorings need to be done after, not before, the super transform. The methods to rename will often have references to the renamed class, so will have their source rewritten in the super transform.  If the method already has a rename change, the source rewrite change will lose the protocol setting, which doesn't prevent the refactoring but DNUs on undo.  (This should be fixed in the framework, but for now, we just avoid it.)"	super transform.	methodRefactorings do: [:each | self performComponentRefactoring: each].</body></methods><methods><class-id>Refactory.Browser.InlineAllSelfSendersRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">checkInlinedMethods	numberReplaced = 0 		ifTrue: [self refactoringError: (#CouldNotInlineAnySenders &lt;&lt; #browser &gt;&gt; 'Could not inline any senders')]</body><body package="Browser-Refactorings">inlineMessagesInClass: aClass andSelector: aSelector 	| messagesToInline previousCountOfMessages |	previousCountOfMessages := 4294967295.	"Some really large number &gt; # of initial self sends."		[| tree |	tree := aClass parseTreeFor: aSelector.	messagesToInline := tree isNil 				ifTrue: [0]				ifFalse: [self numberOfSelfSendsIn: tree].	messagesToInline &gt; 0 and: [previousCountOfMessages &gt; messagesToInline]] 			whileTrue: 				[| node |				previousCountOfMessages := messagesToInline.				node := self selfSendIn: (aClass parseTreeFor: aSelector).				self onError: 						[self performComponentRefactoring: (InlineMethodRefactoring 									model: self model									inline: node sourceInterval									inMethod: aSelector									forClass: aClass).						numberReplaced := numberReplaced + 1]					do: []].	numberNotReplaced := numberNotReplaced + messagesToInline</body><body package="Browser-Refactorings">inlineSelfSends	class withAllSubclasses do: 			[:each | 			| selectors |			selectors := (each whichMethodsReferToSymbol: selector) 						collect: [:method | method selector].			selectors remove: selector ifAbsent: [].			selectors do: [:sel | self inlineMessagesInClass: each andSelector: sel]]</body><body package="Browser-Refactorings">messagePattern	^'self ' , (self buildSelectorString: selector)</body><body package="Browser-Refactorings">numberOfSelfSendsIn: aParseTree 	| search |	search := ParseTreeSearcher new.	search matches: self messagePattern do: [:aNode :answer | answer + 1].	^search executeTree: aParseTree initialAnswer: 0</body><body package="Browser-Refactorings">removeMethod	self onError: 			[self performComponentRefactoring: (RemoveMethodRefactoring 						model: self model						removeMethods: (Array with: selector)						from: class)]		do: []</body><body package="Browser-Refactorings">selfSendIn: aTree 	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: self messagePattern do: [:aNode :answer | ^aNode].	^searcher executeTree: aTree initialAnswer: nil</body><body package="Browser-Refactorings">transform	self		inlineSelfSends;		removeMethod;		checkInlinedMethods</body></methods><methods><class-id>Refactory.Browser.InlineAllSelfSendersRefactoring</class-id> <category>accessing</category><body package="Browser-Refactorings">messagesNotReplaced	^numberNotReplaced</body></methods><methods><class-id>Refactory.Browser.InlineAllSelfSendersRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	aStream nextPutAll: 'Inline all senders refactoring'</body><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' sendersOf: #';		nextPutAll: selector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.InlineAllSelfSendersRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">sendersOf: aSelector in: aClass 	class := self classObjectFor: aClass.	selector := aSelector.	numberReplaced := numberNotReplaced := 0</body></methods><methods><class-id>Refactory.Browser.InlineAllSelfSendersRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">preconditions	^Condition canUnderstand: selector in: class</body></methods><methods><class-id>Refactory.Browser.InlineAllSelfSendersRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">model: aRBNameSpace sendersOf: aSelector in: aClass 	^(self new)		model: aRBNameSpace;		sendersOf: aSelector in: aClass;		yourself</body><body package="Browser-Refactorings">sendersOf: aSelector in: aClass 	^(self new)		sendersOf: aSelector in: aClass;		yourself</body></methods><methods><class-id>Refactory.Browser.ChangeMethodNameRefactoring</class-id> <category>testing</category><body package="Browser-Refactorings">hasPermutedArguments	oldSelector numArgs = newSelector numArgs ifFalse: [^true].	1 to: oldSelector numArgs		do: [:i | (permutation at: i) = i ifFalse: [^true]].	^false</body><body package="Browser-Refactorings">implementorsCanBePrimitives	^false</body></methods><methods><class-id>Refactory.Browser.ChangeMethodNameRefactoring</class-id> <category>private</category><body package="Browser-Refactorings">implementors	implementors isNil 		ifTrue: [implementors := self model allImplementorsOf: oldSelector].	^implementors</body><body package="Browser-Refactorings">modifyImplementorParseTree: parseTree in: aClass 	| oldArgs |	oldArgs := parseTree arguments.	parseTree renameSelector: newSelector		andArguments: (permutation collect: [:each | oldArgs at: each])</body><body package="Browser-Refactorings">parseTreeRewriter	| rewriteRule oldString newString |	rewriteRule := ParseTreeRewriter new.	oldString := self buildSelectorString: oldSelector.	newString := self buildSelectorString: newSelector				withPermuteMap: permutation.	rewriteRule replace: '``@object ' , oldString		with: '``@object ' , newString.	^rewriteRule</body></methods><methods><class-id>Refactory.Browser.ChangeMethodNameRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">errorImplementedIn: aClass	"The rename would overwrite an existing method;  give the user the chance to browse the would-be-overwritten method.  (We could make this a warning calling openDialogBrowserOn: instead of an error:  after browsing, the user could resume to overwrite the method or cancel to abort.)"	self		refactoringError:			('&lt;1p&gt; already defines #&lt;2s&gt;&lt;n&gt;Browse Implementor?'				expandMacrosWith: aClass with: newSelector)		with: [self openBrowserOn:					(BrowserEnvironment new						forClass: aClass realClass						selectors: (Array with: newSelector))]</body><body package="Browser-Refactorings">multipleImplementorsWarning	"If the user decides not to proceed, the handler will exit. Thus callers always returns true on the calling branch, the correct value if the user proceeds.  The third option lets the user view the changes and implement all, some or none.  (If RBDynamicRefactoringUI is loaded, my RenameMethodRefactoring subclass will instead offer dynamic renaming of the polymorphic methods.)"	self		refactoringWarning:			(#WillRename2pImplementorsOf1sIn3pSenders &lt;&lt; #browser &gt;&gt; 'This will refactor all of the &lt;2p&gt; implementors and &lt;3p&gt; senders of&lt;n&gt;&lt;t&gt;#&lt;1s&gt;'				expandMacrosWith: oldSelector				with: self implementors size				with: (self model allReferencesTo: oldSelector) size)		with: self offerReviewChangesOption.</body><body package="Browser-Refactorings">myConditions	^self subclassResponsibility</body><body package="Browser-Refactorings">preconditions	"This refactoring only preserves behavior if all implementors are renamed."	| conditions |	conditions := self myConditions 				&amp; (Condition definesSelector: oldSelector in: class) 					&amp; (Condition isValidMethodName: newSelector for: class).	conditions := self implementors inject: conditions				into: 					[:condition :each | 					condition 						&amp; (Condition withBlock: 									[(each directlyDefinesMethod: newSelector) 										ifTrue: 											[self errorImplementedIn: each.											false	"bool not really needed"]										ifFalse: 											[(each hierarchyDefinesMethod: newSelector) 												ifTrue: [self warningImplementedInHierarchyOf: each].											true]])].	^conditions 		&amp; (Condition withBlock: 					[self implementors size &gt; 1 ifTrue: [self multipleImplementorsWarning].					true])</body><body package="Browser-Refactorings">warningImplementedInHierarchyOf: aClass	"A prior check in the calling method ensures that it cannot be implemented in self by the time we reach this.  Give the user the chance to browse the conflicting implementor(s) that raise the warning.  (We could call openDialogBrowserOn: to let the user browse, then either resume or abort;  the block in the parameter below cannot return true when evaluated, so will always abort.)"	self		refactoringWarning:			('At least one super or subclass of &lt;1p&gt; already defines&lt;n&gt;&lt;t&gt;&lt;2s&gt;'				expandMacrosWith: aClass realClass				with: newSelector)		with: 'Browse rival(s)...' -&gt;			[self openBrowserOn:				((BrowserEnvironment new forClassHierarchy: aClass realClass)					implementorsOf: newSelector)]."We map from the refactoring model to the image's realClass before browsing because (a) more custom refactoring code must be ported to the base before the browser can open on an RBNamespace (note spelling!) of a non-real class and/or non-real hierarchy and (b) it is debatable whether this UI effect would actually be used or useful in the kind of complex multiple refactoring where alone there would be a difference."</body></methods><methods><class-id>Refactory.Browser.ChangeMethodNameRefactoring</class-id> <category>accessing</category><body package="Browser-Refactorings">newSelector	^newSelector</body></methods><methods><class-id>Refactory.Browser.ChangeMethodNameRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">removeRenamedImplementors	oldSelector == newSelector ifTrue: [^self].	self implementors do: [:each | each removeMethod: oldSelector]</body><body package="Browser-Refactorings">renameImplementors	self implementors do: 			[:each | 			| parseTree |			parseTree := each parseTreeFor: oldSelector.			parseTree isNil 				ifTrue: [self refactoringError: (#CouldNotParseSourceCode &lt;&lt; #browser &gt;&gt; 'Could not parse source code.')].			self implementorsCanBePrimitives 				ifFalse: 					[parseTree isPrimitive 						ifTrue: 							[self refactoringError: ((#x1p1sIsPrimitive &lt;&lt; #browser &gt;&gt; '&lt;1p&gt;''s implementation of #&lt;2s&gt; is a primitive') 										expandMacrosWith: each										with: oldSelector)]].			self modifyImplementorParseTree: parseTree in: each.			(each methodFor: oldSelector) compileTree: parseTree]</body><body package="Browser-Refactorings">renameMessageSends	self convertAllReferencesTo: oldSelector using: self parseTreeRewriter</body><body package="Browser-Refactorings">transform	self renameImplementors.	self renameMessageSends.	self removeRenamedImplementors</body></methods><methods><class-id>Refactory.Browser.ChangeMethodNameRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">renameMethod: aSelector in: aClass to: newSel permutation: aMap 	oldSelector := aSelector asSymbol.	newSelector := newSel asSymbol.	class := self classObjectFor: aClass.	permutation := aMap</body></methods><methods><class-id>Refactory.Browser.RemoveParameterRefactoring</class-id> <category>private</category><body package="Browser-Refactorings">computeNewSelector	| keywords stream |	oldSelector numArgs == 0 		ifTrue: [self refactoringError: (#MethodHasNoArgs &lt;&lt; #browser &gt;&gt; 'This method contains no arguments')].	oldSelector isInfix 		ifTrue: [self refactoringError: (#CannotRemoveParamsOfInfix &lt;&lt; #browser &gt;&gt; 'Cannot remove parameters of infix selectors')].	keywords := oldSelector keywords asOrderedCollection.	keywords size = 1 ifTrue: [^(keywords first copyWithout: $:) asSymbol].	keywords removeAtIndex: parameterIndex.	stream := WriteStream on: String new.	keywords do: [:each | stream nextPutAll: each].	^stream contents asSymbol</body></methods><methods><class-id>Refactory.Browser.RemoveParameterRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">getNewSelector	| tree args rivalSize |	(class directlyDefinesMethod: oldSelector)		ifFalse: [self refactoringError: (#MethodDoesntExist &lt;&lt; #browser &gt;&gt; 'Method doesn''t exist.')].	tree := class parseTreeFor: oldSelector.	tree isNil ifTrue: [self refactoringError: (#CannotParseSources &lt;&lt; #browser &gt;&gt; 'Cannot parse sources.')].	args := tree argumentNames.	parameterIndex := args indexOf: argument			ifAbsent: [self refactoringError: (#SelectAParameter &lt;&lt; #browser &gt;&gt; 'Select a parameter!')].	permutation := (1 to: args size) copyWithout: parameterIndex.	newSelector := self computeNewSelector.	rivalSize := (self model allImplementorsOf: newSelector) size.	rivalSize isZero ifFalse:		[self			refactoringWarning: (#WillClashWith2pImplementorsOf1sIn3pSenders &lt;&lt; #browser &gt;&gt;				'There are already &lt;2p&gt; other implementors and &lt;3p&gt; other senders of the proposed new name&lt;n&gt;&lt;t&gt;#&lt;1s&gt;'					expandMacrosWith: newSelector with: rivalSize with: (self model allReferencesTo: newSelector) size)			with: 'Rename...' -&gt;				[| newMethodName newArgs |				newMethodName := self requestMethodNameFor:					(RBMethodName selector: newSelector arguments: (args copyWithout: argument)).				newMethodName notNil and:					[newSelector := newMethodName selector.					newArgs := newMethodName arguments asOrderedCollection.					permutation := (1 to: newArgs size) collect: [:i | args indexOf: (newArgs at: i)].					true]]].	"if the user provides a name, assume they intend it and proceed"</body><body package="Browser-Refactorings">hasReferencesToTemporaryIn: each 	| tree |	tree := each parseTreeFor: oldSelector.	tree isNil ifTrue: [self refactoringError: (#CannotParseSources &lt;&lt; #browser &gt;&gt; 'Cannot parse sources.')].	^tree references: (tree argumentNames at: parameterIndex)</body></methods><methods><class-id>Refactory.Browser.RemoveParameterRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	aStream nextPutAll: 'Remove parameter refactoring'</body><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' removeParameter: ''';		nextPutAll: argument;		nextPutAll: ''' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: oldSelector.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.RemoveParameterRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">removeParameter: aString in: aClass selector: aSelector 	oldSelector := aSelector.	class := self classObjectFor: aClass.	argument := aString</body></methods><methods><class-id>Refactory.Browser.RemoveParameterRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">myConditions	| imps |	imps := self model allImplementorsOf: oldSelector.	self getNewSelector.	^imps inject: (Condition definesSelector: oldSelector in: class)		into: 			[:cond :each | 			cond &amp; (Condition withBlock: [(self hasReferencesToTemporaryIn: each) not]						errorString: (#ArgumentStillReferenced &lt;&lt; #browser &gt;&gt; 'This argument is still referenced in at least one implementor!'))]</body></methods><methods><class-id>Refactory.Browser.RemoveParameterRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">model: aRBNameSpace removeParameter: aString in: aClass selector: aSelector 	^(self new)		model: aRBNameSpace;		removeParameter: aString			in: aClass			selector: aSelector;		yourself</body><body package="Browser-Refactorings">removeParameter: aString in: aClass selector: aSelector 	^(self new)		removeParameter: aString			in: aClass			selector: aSelector;		yourself</body></methods><methods><class-id>Refactory.Browser.InlineParameterRefactoring</class-id> <category>private</category><body package="Browser-Refactorings">allExpressionsToInline	| coll |	coll := Set new.	self model allReferencesTo: oldSelector		do: 			[:each | 			| tree |			tree := each parseTree.			tree notNil ifTrue: [coll addAll: (self expressionsToInlineFrom: tree)]].	^coll asOrderedCollection</body><body package="Browser-Refactorings">expressionsToInlineFrom: aTree 	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: '``@obj ' , (self buildSelectorString: oldSelector)		do: 			[:aNode :answer | 			answer				add: (aNode arguments at: parameterIndex);				yourself].	^searcher executeTree: aTree initialAnswer: OrderedCollection new</body></methods><methods><class-id>Refactory.Browser.InlineParameterRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">inlineParameter: aString in: aClass selector: aSelector	oldSelector := aSelector.	class := self classObjectFor: aClass.	argument := aString</body></methods><methods><class-id>Refactory.Browser.InlineParameterRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">modifyImplementorParseTree: parseTree in: aClass 	| node assignment |	node := (parseTree arguments at: parameterIndex) copy.	parseTree body addTemporaryNamed: node name.	assignment := RBAssignmentNode variable: node copy value: expressions first.	parseTree body addNodeFirst: assignment.	super modifyImplementorParseTree: parseTree in: aClass</body></methods><methods><class-id>Refactory.Browser.InlineParameterRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	aStream nextPutAll: 'Inline parameter refactoring'</body><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' inlineParameter: ''';		nextPutAll: argument;		nextPutAll: ''' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: oldSelector;		nextPut: $)</body></methods><methods><class-id>Refactory.Browser.InlineParameterRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">myConditions	self getNewSelector.	expressions := self allExpressionsToInline.	^(Condition definesSelector: oldSelector in: class) 		&amp; ((Condition withBlock: [expressions notEmpty]) 				errorMacro: (#NoCallersUseRemove &lt;&lt; #browser &gt;&gt; 'No callers. Use Remove Method instead.') asString) 			&amp; ((Condition withBlock: [expressions size = 1]) 					errorMacro: (#AllValuesMustBeIdentical &lt;&lt; #browser &gt;&gt; 'All values passed as this argument must be identical.') asString) 			&amp; ((Condition withBlock: [expressions first isLiteralNode]) 					errorMacro: (#AllValuesMustBeLiteral &lt;&lt; #browser &gt;&gt; 'All values passed must be literal.') asString)</body></methods><methods><class-id>Refactory.Browser.InlineParameterRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">inlineParameter: aString in: aClass selector: aSelector 	^(self new)		inlineParameter: aString			in: aClass			selector: aSelector;		yourself</body><body package="Browser-Refactorings">model: aRBNameSpace inlineParameter: aString in: aClass selector: aSelector 	^(self new)		model: aRBNameSpace;		inlineParameter: aString			in: aClass			selector: aSelector;		yourself</body></methods><methods><class-id>Refactory.Browser.ExpandNameSpaceReferencesRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">for: aParseTree fromClass: aClass toClasses: classCollection 	fromClass := self model classFor: aClass.	parseTree := aParseTree.	toClasses := classCollection collect: [:each | self model classFor: each]</body></methods><methods><class-id>Refactory.Browser.ExpandNameSpaceReferencesRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	aStream 		nextPutAll: 'Expand scope of shared variables referenced by method to class refactoring'</body><body package="Browser-Refactorings">storeOn: aStream 	"fill in later"</body></methods><methods><class-id>Refactory.Browser.ExpandNameSpaceReferencesRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">addImports	referencedVars do: [:var | self expandScopeOf: var]</body><body package="Browser-Refactorings">computeReferencedVars	| searcher |	referencedVars := Set new.	searcher := ParseTreeSearcher new.	searcher matches: '`var'		do: 			[:aNode :answer | 			| varName |			varName := aNode name.			((aNode whoDefines: varName) isNil 				and: [(fromClass allInstanceVariableNames includes: varName) not]) 					ifTrue: [referencedVars add: varName]].	searcher executeTree: parseTree</body><body package="Browser-Refactorings">createAccessors: aString 	| refactoring rewriter |	refactoring := CreateAccessorsForVariableRefactoring 				model: self model				variable: aString				class: fromClass.	self performComponentRefactoring: refactoring.	rewriter := ParseTreeRewriter new.	rewriter		replace: aString , ' := ``@object'			with: ('self &lt;1s&gt; ``@object' expandMacrosWith: refactoring setterMethod);		replace: aString with: 'self ' , refactoring getterMethod.	rewriter executeTree: parseTree.	parseTree := rewriter tree</body><body package="Browser-Refactorings">expandScopeOf: aString 	| sel |	sel := self methodForExpandingScopeOf: aString.	sel isNil ifTrue: [self refactoringError: (#RefactoringAborted &lt;&lt; #browser &gt;&gt; 'Refactoring aborted')].	self perform: sel with: aString</body><body package="Browser-Refactorings">removeAccessibleVariables	| result |	result := Set new.	toClasses do: 			[:cls | 			referencedVars do: 					[:each | 					| from to |					from := fromClass referencedItem: each.					to := cls referencedItem: each.					from == to ifFalse: [result add: each]]].	referencedVars := result</body><body package="Browser-Refactorings">specificImport: aString 	| item |	item := fromClass referencedItem: aString.	toClasses do: 			[:each | 			each nonMetaclass 				addImport: (SpecificNameSpaceImport pathString: item fullName)]</body><body package="Browser-Refactorings">transform	self computeReferencedVars.	self removeAccessibleVariables.	self mustAddImports 		ifTrue: 			[self 				refactoringWarning: (#InaccessibleVarRefWarning &lt;&lt; #browser &gt;&gt; 'This method contains references to variables&lt;n&gt;which are inaccessible in the&lt;n&gt;name space of the destination.') 						expandMacros].	self addImports</body></methods><methods><class-id>Refactory.Browser.ExpandNameSpaceReferencesRefactoring</class-id> <category>accessing</category><body package="Browser-Refactorings">parseTree	^parseTree</body></methods><methods><class-id>Refactory.Browser.ExpandNameSpaceReferencesRefactoring</class-id> <category>testing</category><body package="Browser-Refactorings">mustAddImports	^referencedVars notEmpty</body></methods><methods><class-id>Refactory.Browser.ExpandNameSpaceReferencesRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">preconditions	^Condition empty</body></methods><methods><class-id>Refactory.Browser.ExpandNameSpaceReferencesRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">for: aSelector fromClass: aClass toClasses: classCollection 	^(self new)		for: aSelector			fromClass: aClass			toClasses: classCollection;		yourself</body><body package="Browser-Refactorings">model: aRBNameSpace for: aSelector fromClass: aClass toClasses: classCollection 	^(self new)		model: aRBNameSpace;		for: aSelector			fromClass: aClass			toClasses: classCollection;		yourself</body></methods><methods><class-id>Refactory.Browser.PullUpInstanceVariableRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream	aStream nextPutAll: 'Push up instance variable refactoring'</body></methods><methods><class-id>Refactory.Browser.PullUpInstanceVariableRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">transform	class allSubclasses do: 			[:each | 			(each directlyDefinesInstanceVariable: variableName) 				ifTrue: [each removeInstanceVariable: variableName]].	class addInstanceVariable: variableName</body></methods><methods><class-id>Refactory.Browser.PullUpInstanceVariableRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">preconditions	^Condition withBlock: 			[(class hierarchyDefinesInstanceVariable: variableName) 				ifFalse: [self refactoringError: ((#NoSubclassDefines1s &lt;&lt; #browser &gt;&gt; 'No subclass defines &lt;1s&gt;')			expandMacrosWith: variableName)].			(class directlyDefinesInstanceVariable: variableName) 				ifTrue: 					[self refactoringError: (#VariableAlreadyDefined &lt;&lt; #browser &gt;&gt; 'The variable is already defined by the class')].			(class subclasses 				allSatisfy: [:each | each directlyDefinesInstanceVariable: variableName]) 					ifFalse: 						[self 							refactoringWarning: ((#NotAllSubclassesHaveInstVar1s &lt;&lt; #browser &gt;&gt; 'Not all subclasses have an instance variable named &lt;1s&gt;.')			expandMacrosWith: variableName)].			true]</body></methods><methods><class-id>Refactory.Browser.RBInitializerMethod</class-id> <category>compiling</category><body package="Browser-Refactorings">compileTree: aRBProgramNode 	sharedVariable initializer: aRBProgramNode formattedCode.	^self modelClass defineSharedVariable: sharedVariable definitionString</body></methods><methods><class-id>Refactory.Browser.RBInitializerMethod</class-id> <category>accessing</category><body package="Browser-Refactorings">parseTree	^RBParser parseExpression: self source onError: [:str :pos | ^nil]</body><body package="Browser-Refactorings">sharedVariable	^sharedVariable</body><body package="Browser-Refactorings">sharedVariable: aRBSharedVariable 	sharedVariable := aRBSharedVariable</body></methods><methods><class-id>Refactory.Browser.RBInitializerMethod class</class-id> <category>instance creation</category><body package="Browser-Refactorings">for: anRBStatic fromMethod: aCompiledMethod 	^(self new)		modelClass: anRBStatic environment;		sharedVariable: anRBStatic;		method: aCompiledMethod;		selector: #'static Initializer Method for ' , anRBStatic name;		yourself</body><body package="Browser-Refactorings">for: anRBStatic source: aString 	^(self new)		modelClass: anRBStatic environment;		sharedVariable: anRBStatic;		source: aString;		selector: #'static Initializer Method for ' , anRBStatic name;		yourself</body></methods><methods><class-id>Refactory.Browser.AbstractInstanceVariableRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">abstractReferences	| replacer |	replacer := ParseTreeRewriter 				variable: variableName				getter: self accessorsRefactoring getterMethod				setter: self accessorsRefactoring setterMethod.	self 		convertClasses: class withAllSubclasses		select: 			[:aClass | 			(aClass whichSelectorsReferToInstanceVariable: variableName) reject: 					[:each | 					aClass == class and: 							[each == self accessorsRefactoring getterMethod 								or: [each == self accessorsRefactoring setterMethod]]]]		using: replacer</body><body package="Browser-Refactorings">createAccessors	self performComponentRefactoring: self accessorsRefactoring</body><body package="Browser-Refactorings">transform	self createAccessors.	self abstractReferences</body></methods><methods><class-id>Refactory.Browser.AbstractInstanceVariableRefactoring</class-id> <category>private-accessing</category><body package="Browser-Refactorings">accessorsRefactoring	^accessorsRefactoring isNil 		ifTrue: 			[accessorsRefactoring := CreateAccessorsForVariableRefactoring 						model: self model						variable: variableName						class: class]		ifFalse: [accessorsRefactoring]</body></methods><methods><class-id>Refactory.Browser.AbstractInstanceVariableRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	aStream nextPutAll: 'Abstract instance variable refactoring'</body></methods><methods><class-id>Refactory.Browser.AbstractInstanceVariableRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">preconditions	^Condition directlyDefinesInstanceVariable: variableName in: class</body></methods><methods><class-id>Refactory.Browser.AddClassRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">addClass: aName superclass: aClass subclasses: aCollection	self className: aName.	superclass := self classObjectFor: aClass.	subclasses := aCollection collect: [:each | self classObjectFor: each]</body></methods><methods><class-id>Refactory.Browser.AddClassRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	aStream		nextPutAll: 'Add class, ';		nextPutAll: className;		nextPutAll: ', as subclass of ';		nextPutAll: superclass printString;		nextPutAll: ' refactoring'</body><body package="Browser-Refactorings">storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' addClass: #''';		nextPutAll: className;		nextPutAll: ''' superclass: '.	superclass storeOn: aStream.	aStream nextPutAll: ' subclasses: '.	subclasses asArray storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.AddClassRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">transform	| nameSpaceName definitionName definitionString |	nameSpaceName := self unambiguousNameSpaceName.	definitionName := self definitionName.	definitionString := '&lt;1s&gt; defineClass: #&lt;2s&gt;&lt;nt&gt;superclass: &lt;3p&gt;&lt;nt&gt;indexedType: #&lt;4s&gt;&lt;nt&gt;private: false&lt;nt&gt;instanceVariableNames: ''''&lt;nt&gt;classInstanceVariableNames: ''''&lt;nt&gt;imports: ''''&lt;nt&gt;category: '''''		expandMacrosWith: nameSpaceName		with: definitionName		with: superclass asReference makeUnambiguous		with: superclass indexedType.	self attributes isEmpty ifFalse:		[definitionString := '&lt;1s&gt;&lt;nt&gt;attributes: &lt;2p&gt;' 			expandMacrosWith: definitionString			with: self attributes].	(self model defineClass: definitionString) package: self package.	self model		reparentClasses: subclasses		to: (self model classNamed: className asSymbol).</body></methods><methods><class-id>Refactory.Browser.AddClassRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">preconditions	| cond |	cond := ((Condition isMetaclass: superclass)		errorMacro:			(#SuperMustNotBeMeta &lt;&lt; #browser &gt;&gt; 'Superclass must not be a metaclass')				asString) not.	cond := subclasses		inject: cond		into:			[:sub :each | 			sub				&amp;					((Condition isMetaclass: each)						errorMacro:							(#SubMust1QBeMeta &lt;&lt; #browser &gt;&gt; 'Subclass must &lt;1?not :&gt;be a metaclass')								asString) not				&amp;					(Condition						isImmediateSubclass: each						of: superclass)].	^cond &amp; (Condition isValidClassName: self definitionName)		&amp;			(Condition				canReference: self definitionName				in: self nameSpace) not</body></methods><methods><class-id>Refactory.Browser.AddClassRefactoring</class-id> <category>accessing</category><body package="Browser-Refactorings">attributes	attributes isNil ifTrue: [attributes := superclass extraAttributesForDefinition].	^attributes</body><body package="Browser-Refactorings">attributes: anArray	attributes := anArray.</body></methods><methods><class-id>Refactory.Browser.AddClassRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">addClass: aName superclass: aClass subclasses: aCollection	^(self new)		addClass: aName			superclass: aClass			subclasses: aCollection;		yourself</body><body package="Browser-Refactorings">model: aRBNameSpace addClass: aName superclass: aClass subclasses: aCollection	^self new		model: aRBNameSpace;		addClass: aName superclass: aClass subclasses: aCollection;		yourself</body><body package="Browser-Refactorings">model: aRBNameSpace addClass: aName superclass: aClass subclasses: aCollection attributes: anArray	^(self model: aRBNameSpace addClass: aName superclass: aClass subclasses: aCollection)		attributes: anArray;		yourself</body></methods><methods><class-id>Refactory.Browser.PushDownMethodRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream	aStream nextPutAll: 'Push down method refactoring'</body><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' pushDown: '.	selectors asArray storeOn: aStream.	aStream nextPutAll: ' from: '.	class storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.PushDownMethodRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">pushDown: selectorCollection from: aClass 	class := self classObjectFor: aClass.	selectors := selectorCollection</body></methods><methods><class-id>Refactory.Browser.PushDownMethodRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">pushDown: aSelector 	| code refactoring |	refactoring := ExpandNameSpaceReferencesRefactoring 				model: self model				for: (class parseTreeFor: aSelector)				fromClass: class				toClasses: class subclasses.	self performComponentRefactoring: refactoring.	code := refactoring parseTree printString.	class subclasses do: 			[:each | 			(each directlyDefinesMethod: aSelector) 				ifFalse: [each compile: code withAttributesFrom: (class methodFor: aSelector)]]</body><body package="Browser-Refactorings">transform	selectors do: [:each | self pushDown: each].	selectors do: [:each | class removeMethod: each]</body></methods><methods><class-id>Refactory.Browser.PushDownMethodRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">preconditions	| condition |	condition := selectors inject: Condition empty				into: 					[:cond :each | 					cond &amp; (Condition definesSelector: each in: class) 						&amp; (Condition subclassesOf: class referToSelector: each) not 							&amp; (Condition withBlock: 										[| tree |										tree := class parseTreeFor: each.										tree isNil or: 												[tree superMessages 													allSatisfy: [:superMessage | (class directlyDefinesMethod: superMessage) not]]]									errorString: ((#x1sSendOverriddenSuperMessage &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; sends super message that is overridden.')			expandMacrosWith: each))].	^condition &amp; (Condition isAbstractClass: class)</body></methods><methods><class-id>Refactory.Browser.PushDownMethodRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">model: aRBNameSpace pushDown: selectorCollection from: aClass 	^(self new)		model: aRBNameSpace;		pushDown: selectorCollection from: aClass;		yourself</body><body package="Browser-Refactorings">pushDown: selectorCollection from: aClass 	^(self new)		pushDown: selectorCollection from: aClass;		yourself</body></methods><methods><class-id>Refactory.Browser.AddParameterRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">addParameterToMethod: aSelector in: aClass newSelector: newSel initializer: init 	self 		renameMethod: aSelector		in: aClass		to: newSel		permutation: (1 to: newSel numArgs).	initializer := init</body><body package="Browser-Refactorings">addParameterToMethod: aSelector in: aClass newSelector: newSel initializer: init newArgName: aString permutation: aCollectionOfIntegers	self 		renameMethod: aSelector		in: aClass		to: newSel		permutation: aCollectionOfIntegers.	initializer := init.	newArgName := aString.</body><body package="Browser-Refactorings">initialize	newArgName := 'anObject'.</body></methods><methods><class-id>Refactory.Browser.AddParameterRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">checkSendersAccessTo: name 	| searcher method |	(#('self' 'super') includes: name) ifTrue: [^self].	searcher := ParseTreeSearcher new.	searcher matches: ((#anObject1s &lt;&lt; #browser &gt;&gt; '``@anObject &lt;1s&gt;')			expandMacrosWith: (self buildSelectorString: oldSelector))		do: 			[:aNode :answer | 			(aNode whoDefines: name) isNil 				ifTrue: 					[self refactoringError: ((#x1sNotDefinedIn2p &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; doesn''t appear to be defined in &lt;2p&gt;') 								expandMacrosWith: name								with: method)]].	self model allReferencesTo: oldSelector		do: 			[:each | 			method := each.			(self canReferenceVariable: name in: each modelClass) 				ifFalse: [searcher executeTree: each parseTree]]</body><body package="Browser-Refactorings">checkVariableReferencesIn: aParseTree 	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: '`var'		do: 			[:aNode :answer | 			| name |			name := aNode name.			(aNode whoDefines: name) isNil ifTrue: [self checkSendersAccessTo: name]].	searcher executeTree: aParseTree</body><body package="Browser-Refactorings">myConditions	^Condition withBlock: 			[oldSelector numArgs + 1 = newSelector numArgs 				ifFalse: 					[self refactoringError: ((#x1sDoesNotHaveProperArgNum &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; doesn''t have the proper number of arguments.')			expandMacrosWith: newSelector printString)].			self verifyInitializationExpression.			true]</body><body package="Browser-Refactorings">verifyInitializationExpression	| tree |	tree := RBParser parseExpression: initializer				onError: 					[:msg :index | 					self refactoringError: ((#IllegalInitCodeBecause1s &lt;&lt; #browser &gt;&gt; 'Illegal initialization code because:.&lt;1s&gt;')			expandMacrosWith: msg)].	tree isValue 		ifFalse: 			[self 				refactoringError: (#InitCodeCannotBeReturnOrList &lt;&lt; #browser &gt;&gt; 'The initialization code cannot be a return node or a list of statements')].	self checkVariableReferencesIn: tree</body></methods><methods><class-id>Refactory.Browser.AddParameterRefactoring</class-id> <category>private</category><body package="Browser-Refactorings">modifyImplementorParseTree: parseTree in: aClass 	| name newArg allTempVars |	allTempVars := parseTree allDefinedVariables.	name := self safeVariableNameFor: aClass temporaries: allTempVars.	newArg := RBVariableNode named: name.	parseTree arguments: parseTree arguments , (Array with: newArg).	super modifyImplementorParseTree: parseTree in: aClass</body><body package="Browser-Refactorings">newSelectorString	| stream keywords |	stream := WriteStream on: String new.	keywords := newSelector keywords.	1 to: keywords size		do: 			[:i | 			stream nextPutAll: (keywords at: i).			(permutation at: i) == keywords size				ifTrue: 					[stream						nextPut: $(;						nextPutAll: initializer;						nextPut: $)]				ifFalse: 					[stream						nextPutAll: ' ``@arg';						nextPutAll: (permutation at: i) printString].			stream nextPut: $ ].	^stream contents</body><body package="Browser-Refactorings">parseTreeRewriter	| rewriteRule oldString newString |	rewriteRule := ParseTreeRewriter new.	oldString := self buildSelectorString: oldSelector.	newString := self newSelectorString.	rewriteRule replace: '``@object ' , oldString		with: '``@object ' , newString.	^rewriteRule</body><body package="Browser-Refactorings">safeVariableNameFor: aClass temporaries: allTempVars 	^self 		safeVariableNameFor: aClass		temporaries: allTempVars		basedOn: newArgName</body></methods><methods><class-id>Refactory.Browser.AddParameterRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' addParameterToMethod: #';		nextPutAll: oldSelector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' newSelector: #';		nextPutAll: newSelector;		nextPutAll: ' initializer: ''';		nextPutAll: initializer;		nextPutAll: ''')'</body></methods><methods><class-id>Refactory.Browser.AddParameterRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">addParameterToMethod: aSelector in: aClass newSelector: newSelector initializer: init 	^(self new)		addParameterToMethod: aSelector			in: aClass			newSelector: newSelector			initializer: init;		yourself</body><body package="Browser-Refactorings">addParameterToMethod: aSelector in: aClass newSelector: newSelector initializer: init newArgName: aString permutation: aCollectionOfIntegers	^(self new)		addParameterToMethod: aSelector			in: aClass			newSelector: newSelector			initializer: init			newArgName: aString			permutation: aCollectionOfIntegers;		yourself</body><body package="Browser-Refactorings">model: aRBNameSpace addParameterToMethod: aSelector in: aClass newSelector: newSelector initializer: init 	^(self new)		model: aRBNameSpace;		addParameterToMethod: aSelector			in: aClass			newSelector: newSelector			initializer: init;		yourself</body><body package="Browser-Refactorings">model: aRBNameSpace addParameterToMethod: aSelector in: aClass newSelector: newSelector initializer: init newArgName: aString permutation: aCollectionOfIntegers	^(self new)		model: aRBNameSpace;		addParameterToMethod: aSelector			in: aClass			newSelector: newSelector			initializer: init		 	newArgName: aString			permutation: aCollectionOfIntegers;		yourself</body></methods><methods><class-id>Refactory.Browser.RBClass</class-id> <category>accessing</category><body package="Browser-Refactorings">asReference	^self fullName asQualifiedReference</body><body package="Browser-Refactorings">attributes: anArray	attributes := anArray.</body><body package="Browser-Refactorings">definitionString	| definitionStream |	definitionStream := WriteStream on: String new.	definitionStream		nextPutAll: self environment unambiguousName;		nextPutAll: ' defineClass: #';		nextPutAll: self name;		cr;		tab;		nextPutAll: 'superclass: ';		print: (self superclass isNil 					ifTrue: [nil]					ifFalse: [self superclass asReference makeUnambiguous]);		cr;		tab;		nextPutAll: 'indexedType: #';		nextPutAll: indexedType;		cr;		tab;		nextPutAll: 'private: ';		nextPutAll: isPrivate printString;		cr;		tab;		nextPutAll: 'instanceVariableNames: '''.	self instanceVariableNames do: 			[:each | 			definitionStream				nextPutAll: each;				nextPut: $ ].	definitionStream		nextPutAll: '''';		cr;		tab;		nextPutAll: 'classInstanceVariableNames: '''.	self metaclass instanceVariableNames do: 			[:each | 			definitionStream				nextPutAll: each;				nextPut: $ ].	definitionStream		nextPutAll: '''';		cr;		tab;		nextPutAll: 'imports: '''.	self imports do: 			[:each | 			definitionStream				cr;				next: 3 put: Character tab.			each printDefinitionOn: definitionStream].	definitionStream		cr;		next: 3 put: Character tab;		nextPutAll: '''';		cr;		tab;		nextPutAll: 'category: '''''.	attributes isEmpty ifFalse:		[definitionStream cr;			tab;			nextPutAll: 'attributes: ';			print: attributes].	^definitionStream contents</body><body package="Browser-Refactorings">extraAttributesForDefinition	"Polymorphic with real class, hence the name."	^attributes</body><body package="Browser-Refactorings">indexedType	^indexedType</body><body package="Browser-Refactorings">indexedType: aSymbol 	indexedType := aSymbol</body><body package="Browser-Refactorings">metaclass	^metaclass</body><body package="Browser-Refactorings">nonMetaclass	^self</body><body package="Browser-Refactorings">package	^Store.Registry containingPackageForClass: self realItem</body></methods><methods><class-id>Refactory.Browser.RBClass</class-id> <category>initialize-release</category><body package="Browser-Refactorings">initialize	super initialize.	indexedType := #none.	attributes := #().</body><body package="Browser-Refactorings">metaclass: aRBMetaclass	metaclass := aRBMetaclass</body><body package="Browser-Refactorings">realBinding: aBinding	super realBinding: aBinding.	indexedType := aBinding value behaviorType.	attributes := aBinding value extraAttributesForDefinition.</body></methods><methods><class-id>Refactory.Browser.RBClass</class-id> <category>testing</category><body package="Browser-Refactorings">isMeta	^false</body></methods><methods><class-id>Refactory.Browser.RBClass</class-id> <category>private</category><body package="Browser-Refactorings">recompileObject	self rootNameSpace defineClass: self definitionString</body><body package="Browser-Refactorings">recompileObjectWithRename: renameRefactor	"The receiver must be recompiled in order to achieve a rename refactoring, but	 it is possible that the receiver is in fact the object being renamed.  If so detect	 that condition to produce the correct definition."	| save |	save := name.	^[renameRefactor modelObject == self		ifTrue: [name := renameRefactor newName].	self rootNameSpace defineClass: self definitionString]				ensure: [name := save]</body></methods><methods><class-id>Refactory.Browser.RBClass</class-id> <category>method accessing</category><body package="Browser-Refactorings">outerReferencingMethodsDo: aBlock	super outerReferencingMethodsDo: aBlock.	self metaclass outerReferencingMethodsDo: aBlock</body></methods><methods><class-id>Refactory.Browser.RBClass class</class-id> <category>instance creation</category><body package="Browser-Refactorings">existing: aBinding model: aRBBasicNameSpace	| inst |	inst := (self new)		parent: aRBBasicNameSpace;		realBinding: aBinding;		yourself.	RBMetaclass newOn: inst model: aRBBasicNameSpace.	^inst</body><body package="Browser-Refactorings">named: aSymbol model: aRBBasicNameSpace 	| inst |	inst := super named: aSymbol model: aRBBasicNameSpace.	RBMetaclass newOn: inst model: aRBBasicNameSpace.	^inst</body></methods><methods><class-id>Refactory.Browser.RBMethodName</class-id> <category>accessing</category><body package="Browser-Refactorings">arguments	^arguments</body><body package="Browser-Refactorings">arguments: nameCollection 	arguments := nameCollection.	self changed: #arguments</body><body package="Browser-Refactorings">moveArgument: aName before: anotherName 	arguments remove: aName ifAbsent: [^self].	arguments add: aName before: anotherName.	self changed: #arguments</body><body package="Browser-Refactorings">selector	^selector</body><body package="Browser-Refactorings">selector: aSymbol 	selector := aSymbol asSymbol.	self changed: #selector</body></methods><methods><class-id>Refactory.Browser.RBMethodName</class-id> <category>testing</category><body package="Browser-Refactorings">isValid	^(Condition checkMethodName: self selector in: self class) 		and: [self selector numArgs == self arguments size]</body></methods><methods><class-id>Refactory.Browser.RBMethodName class</class-id> <category>instance creation</category><body package="Browser-Refactorings">selector: aSymbol arguments: stringCollection 	^(self new)		selector: aSymbol;		arguments: stringCollection;		yourself</body></methods><methods><class-id>Refactory.Browser.RenameMethodRefactoring</class-id> <category>testing</category><body package="Browser-Refactorings">hasPermutedArguments	^hasPermutedArguments isNil 		ifTrue: [hasPermutedArguments := super hasPermutedArguments]		ifFalse: [hasPermutedArguments]</body><body package="Browser-Refactorings">implementorsCanBePrimitives	^self hasPermutedArguments not</body></methods><methods><class-id>Refactory.Browser.RenameMethodRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">parseTreeRewriter	| rewriteRule oldString newString |	oldString := self buildSelectorString: oldSelector.	newString := self buildSelectorString: newSelector				withPermuteMap: permutation.	rewriteRule := self hasPermutedArguments 				ifTrue: [ParseTreeRewriter new]				ifFalse: [ParseTreeRewriter replaceLiteral: oldSelector with: newSelector].	rewriteRule replace: '``@object ' , oldString		with: '``@object ' , newString.	^rewriteRule</body></methods><methods><class-id>Refactory.Browser.RenameMethodRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	aStream nextPutAll: 'Rename method refactoring'</body><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' renameMethod: #';		nextPutAll: oldSelector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' to: #';		nextPutAll: newSelector;		nextPutAll: ' permuation: '.	permutation storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.RenameMethodRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">myConditions	^Condition withBlock: [oldSelector numArgs = newSelector numArgs]		errorString: ((#x1sDoesNotHaveCorrectArgNum &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; doesn''t have the correct number of arguments.')			expandMacrosWith: newSelector printString)</body><body package="Browser-Refactorings">preconditions	| newCondition |	newCondition := (Condition withBlock: [newSelector = oldSelector]				errorString: (#Selectors1QEquivalent &lt;&lt; #browser &gt;&gt; 'The selectors are &lt;1?:not &gt;equivalent') asString) &amp; (Condition 							withBlock: [permutation asArray ~= (1 to: oldSelector numArgs) asArray]							errorString: (#Arguments1QPermuted &lt;&lt; #browser &gt;&gt; 'The arguments are &lt;1?:not &gt;permuted') asString).	^newCondition | super preconditions</body></methods><methods><class-id>Refactory.Browser.RenameMethodRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">model: aRBNameSpace renameMethod: aSelector in: aClass to: newSelector permutation: aMap 	^(self new)		model: aRBNameSpace;		renameMethod: aSelector			in: aClass			to: newSelector			permutation: aMap;		yourself</body><body package="Browser-Refactorings">renameMethod: aSelector in: aClass to: newSelector permutation: aMap 	^(self new)		renameMethod: aSelector			in: aClass			to: newSelector			permutation: aMap;		yourself</body></methods><methods><class-id>Refactory.Browser.RBRootNameSpace</class-id> <category>accessing</category><body package="Browser-Refactorings">allClassesDo: aBlock 	| seen |	seen := IdentitySet new.	self allNewClassesDo: 			[:each | 			seen add: each.			aBlock value: each].	self rootClasses do: 			[:each | 			each withAllSubclasses 				do: [:sub | (seen includes: sub) ifFalse: [aBlock value: sub]]]</body><body package="Browser-Refactorings">allImplementorsOf: aSelector 	^implementorsCache at: aSelector		ifAbsentPut: [self privateImplementorsOf: aSelector]</body><body package="Browser-Refactorings">allReferencesTo: aSymbol	^sendersCache at: aSymbol ifAbsentPut:		[| refs | refs := OrderedCollection new.		self allClassesDo: [:each | refs addAll: (each whichMethodsReferToSymbol: aSymbol)].		self allInitializersDo: [:init | (init refersToSymbol: aSymbol) ifTrue: [refs add: init]].		refs]</body><body package="Browser-Refactorings">allReferencesTo: aSymbol do: aBlock	(self allReferencesTo: aSymbol) do: aBlock</body><body package="Browser-Refactorings">allReferencesToObject: aRBProgramItem do: aBlock 	self allClassesDo: 			[:each | 			(each whichSelectorsReferToObject: aRBProgramItem) 				do: [:sel | aBlock value: (each methodFor: sel)]].	self allInitializersDo: 			[:init | 			(init refersToObject: aRBProgramItem) ifTrue: [aBlock value: init]]</body><body package="Browser-Refactorings">changes	^changes</body><body package="Browser-Refactorings">description	^self changes name</body><body package="Browser-Refactorings">description: aString	^self changes name: aString</body><body package="Browser-Refactorings">rootClasses	rootClasses isNil 		ifTrue: 			[rootClasses := OrderedCollection new.			Class rootsOfTheWorld do: 					[:each | 					| class |					class := self classFor: each.					(class notNil and: [class superclass isNil]) 						ifTrue: [rootClasses add: class]]].	^rootClasses</body></methods><methods><class-id>Refactory.Browser.RBRootNameSpace</class-id> <category>private</category><body package="Browser-Refactorings">changes: aCompositeRefactoryChange	changes := aCompositeRefactoryChange</body><body package="Browser-Refactorings">flushCaches	implementorsCache := IdentityDictionary new.	sendersCache := IdentityDictionary new</body><body package="Browser-Refactorings">privateImplementorsOf: aSelector 	| classes |	classes := Set new.	self allClassesDo: 			[:each | 			(each directlyDefinesMethod: aSelector) ifTrue: [classes add: each]].	^classes</body><body package="Browser-Refactorings">removeRootClass: aRBClass 	rootClasses notNil ifTrue: [rootClasses remove: aRBClass ifAbsent: []]</body></methods><methods><class-id>Refactory.Browser.RBRootNameSpace</class-id> <category>accessing-objects</category><body package="Browser-Refactorings">fullItemNamed: aString 	^self fullItemNamed: aString currentlyChecking: Set new</body><body package="Browser-Refactorings">fullItemNamed: aString currentlyChecking: aSet 	| st item |	(aSet includes: aString) ifTrue: [^nil].	st := self smalltalkNameSpace.	st isNil ifTrue: [^nil].	st isNameSpace ifFalse: [^nil].	aSet add: aString.	item := st lookupItemPath: aString currentlyChecking: aSet.	aSet remove: aString.	^item</body><body package="Browser-Refactorings">smalltalkNameSpace	^self itemFor: #Smalltalk</body></methods><methods><class-id>Refactory.Browser.RBRootNameSpace</class-id> <category>changes</category><body package="Browser-Refactorings">removeObject: aRBProgramItem 	aRBProgramItem environment removeLocalObject: aRBProgramItem</body><body package="Browser-Refactorings">removeObjectNamed: aSymbol 	| item |	item := self fullItemNamed: aSymbol.	item isNil ifTrue: [^self].	self removeObject: item</body></methods><methods><class-id>Refactory.Browser.RBRootNameSpace</class-id> <category>testing</category><body package="Browser-Refactorings">includesClassNamed: aSymbol 	^(self classNamed: aSymbol) notNil</body></methods><methods><class-id>Refactory.Browser.RBRootNameSpace</class-id> <category>initialize-release</category><body package="Browser-Refactorings">initialize	super initialize.	changes := CompositeRefactoryChange new.	self realBinding: (Smalltalk bindingFor: #Root).	implementorsCache := IdentityDictionary new.	sendersCache := IdentityDictionary new</body></methods><methods><class-id>Refactory.Browser.RBRootNameSpace</class-id> <category>accessing-classes</category><body package="Browser-Refactorings">classNamed: aSymbol 	| class index meta className |	className := aSymbol.	index := aSymbol indexOfSubCollection: ' class' startingAt: 1.	(meta := index &gt; 0) 		ifTrue: [className := aSymbol copyFrom: 1 to: index - 1].	class := self fullItemNamed: className.	(class notNil and: [class isClassObject]) 		ifTrue: [^meta ifTrue: [class metaclass] ifFalse: [class]].	^nil</body><body package="Browser-Refactorings">metaclassNamed: aSymbol 	| class |	class := self classNamed: aSymbol.	class isNil ifTrue: [^nil].	^class metaclass</body></methods><methods><class-id>Refactory.Browser.RBRootNameSpace</class-id> <category>accessing-namespaces</category><body package="Browser-Refactorings">nameSpaceNamed: nameSpaceName 	| item |	nameSpaceName = 'Root' ifTrue: [^self].	item := super nameSpaceNamed: nameSpaceName.	item isNil 		ifTrue: [^(self nameSpaceNamed: #Smalltalk) nameSpaceNamed: nameSpaceName].	^item</body></methods><methods><class-id>Refactory.Browser.RBConjunctiveCondition</class-id> <category>checking</category><body package="Browser-Refactorings">check	left check		ifFalse: 			[failed := #leftFailed.			^false].	right check		ifFalse: 			[failed := #rightFailed.			^false].	^true</body></methods><methods><class-id>Refactory.Browser.RBConjunctiveCondition</class-id> <category>private</category><body package="Browser-Refactorings">errorBlockFor: aBoolean 	^aBoolean		ifTrue: [nil]		ifFalse: 			[failed == #leftFailed ifTrue: [left errorBlock] ifFalse: [right errorBlock]]</body><body package="Browser-Refactorings">errorMacro	^errorMacro isNil ifTrue: [self longMacro] ifFalse: [super errorMacro]</body><body package="Browser-Refactorings">errorStringFor: aBoolean 	^aBoolean ifTrue: [self neitherFailed] ifFalse: [self perform: failed]</body><body package="Browser-Refactorings">leftFailed	^left errorStringFor: false</body><body package="Browser-Refactorings">longMacro	^'(' , left errorMacro , ') &lt;1?AND:OR&gt; (' , right errorMacro , ')'</body><body package="Browser-Refactorings">neitherFailed	^(left errorStringFor: true) , ' AND ' , (right errorStringFor: true)</body><body package="Browser-Refactorings">rightFailed	^right errorStringFor: false</body><body package="Browser-Refactorings">unknownFailed	^(left errorStringFor: false) , ' OR ' , (right errorStringFor: false)</body></methods><methods><class-id>Refactory.Browser.RBConjunctiveCondition</class-id> <category>initialize-release</category><body package="Browser-Refactorings">left: aCondition right: aCondition2 	left := aCondition.	right := aCondition2.	failed := #unknownFailed</body></methods><methods><class-id>Refactory.Browser.RBConjunctiveCondition</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	aStream		print: left;		nextPutAll: ' &amp; ';		print: right</body></methods><methods><class-id>Refactory.Browser.InlineMethodRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">addSelfReturn	inlineParseTree addSelfReturn</body><body package="Browser-Refactorings">addTemporary: sourceNode assignedTo: replacementNode 	| newName |	newName := self renameConflictingTemporary: sourceNode name.	(inlineParseTree body)		addTemporaryNamed: newName;		addNodeFirst: (RBAssignmentNode variable: (RBVariableNode named: newName)					value: replacementNode)</body><body package="Browser-Refactorings">checkSuperMessages	self inlineClass = class ifTrue: [^self].	self inlineClass superclass isNil ifTrue: [^self].	inlineParseTree superMessages do: 			[:each | 			(self inlineClass superclass whoDefinesMethod: each) 				= (class superclass whoDefinesMethod: each) 					ifFalse: 						[self 							refactoringError: ((#CannotInline1sSuperMessageOverridden &lt;&lt; #browser &gt;&gt; 'Cannot inline method since it sends a super message &lt;1s&gt; that is overridden') 									expandMacrosWith: each)]]</body><body package="Browser-Refactorings">compileMethod		class compileTree: self sourceTree</body><body package="Browser-Refactorings">findSelectedMessage		sourceMessage := self sourceTree whichNodeIsContainedBy: sourceInterval.	sourceMessage isNil		ifTrue:			[self				refactoringError:					#SelectionNotMessageSend &lt;&lt; #browser &gt;&gt;							'The selection doesn''t appear to be a message send'].	sourceMessage isCascade		ifTrue: [sourceMessage := sourceMessage messages last].	sourceMessage isMessage		ifFalse:			[self				refactoringError:					#SelectionNotMessageSend &lt;&lt; #browser &gt;&gt;							'The selection doesn''t appear to be a message send'].	(sourceMessage receiver isVariable		and: [#('self' 'super') includes: sourceMessage receiver name])		ifFalse:			[self				refactoringError:					#CannotInlineNonSelfMessage &lt;&lt; #browser &gt;&gt;							'Cannot inline non-self messages']</body><body package="Browser-Refactorings">inlineClass	^inlineClass isNil 		ifTrue: 			[inlineClass := (sourceMessage receiver name = 'super' 						ifTrue: [class superclass]						ifFalse: [class]) whoDefinesMethod: self inlineSelector]		ifFalse: [inlineClass]</body><body package="Browser-Refactorings">inlineSelector	sourceMessage isNil ifTrue: [self findSelectedMessage].	^sourceMessage selector</body><body package="Browser-Refactorings">inlineSourceReplacing: aParseTree 	| statements nodeUnderSequence |	statements := inlineParseTree body statements.	(statements size &gt; 1 and: [aParseTree isEvaluatedFirst not]) 		ifTrue: 			[self 				refactoringWarning: (#OrderOfExecutionChangeWarning &lt;&lt; #browser &gt;&gt; 'To inline this method, we need to move some of its statements before the original message send.&lt;n&gt;This could change the order of execution, which can change the behavior.&lt;n&gt;Do you want to proceed?') 						expandMacros].	nodeUnderSequence := aParseTree.	[nodeUnderSequence parent isSequence] 		whileFalse: [nodeUnderSequence := nodeUnderSequence parent].	(nodeUnderSequence parent)		addNodes: (statements copyFrom: 1 to: (statements size - 1 max: 0))			before: nodeUnderSequence;		addTemporariesNamed: inlineParseTree body temporaryNames.	aParseTree replaceWith: (statements isEmpty 				ifTrue: [RBVariableNode named: 'self']				ifFalse: [statements last])</body><body package="Browser-Refactorings">insertInlinedMethod		| node |	node := sourceMessage.	self moveComments.	node parent isCascade		ifTrue:			[self rewriteCascadedMessage.			node := node parent].	node parent isReturn		ifTrue: [node := node parent]		ifFalse: [self removeReturns].	self replaceArguments.	self inlineSourceReplacing: node.	self sourceTree removeDeadCode.	self removeEmptyIfTrues.	self removeImmediateBlocks</body><body package="Browser-Refactorings">moveComments		inlineParseTree		nodesDo:			[:each | 			each				comments:					(each comments						collect:							[:anInterval | 							| start stop source |							source := self sourceTree source.							start := source size + 1.							source := source								,									(inlineParseTree source										copyFrom: anInterval first										to: anInterval last).							stop := source size.							self sourceTree source: source.							start to: stop])]</body><body package="Browser-Refactorings">normalizeIfTrues	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter		replace: '| `@temps | ``@.s1. ``@boolean ifTrue: [| `@t1 | ``@.Stmts1. ^`@r1]. ``@.s2. ^``@r2'			with: '| `@temps | ``@.s1. ``@boolean ifTrue: [| `@t1 | ``@.Stmts1. ^`@r1] ifFalse: [``@.s2. ^``@r2]';		replace: '| `@temps | ``@.s1. ``@boolean ifFalse: [| `@t1 | ``@.Stmts1. ^`@r1]. ``@.s2. ^``@r2'			with: '| `@temps | ``@.s1. ``@boolean ifTrue: [``@.s2. ^``@r2] ifFalse: [| `@t1 | ``@.Stmts1. ^`@r1]'.	[rewriter executeTree: inlineParseTree] 		whileTrue: [inlineParseTree := rewriter tree]</body><body package="Browser-Refactorings">normalizeReturns	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter		replace: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ^``@r1] ifFalse: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ^``@r1] ifTrue: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ^``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]'			with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ^``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]'			with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '``@boolean ifTrue: [| `@t1 | `@.Stmts1. ^``@r1] ifFalse: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '``@boolean ifFalse: [| `@t1 | `@.Stmts1. ^``@r1] ifTrue: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]'.	[rewriter executeTree: inlineParseTree] 		whileTrue: [inlineParseTree := rewriter tree]</body><body package="Browser-Refactorings">parseInlineMethod	self inlineClass isNil 		ifTrue: 			[self 				refactoringError: ((#x1pDoesNotContainMethod2s &lt;&lt; #browser &gt;&gt; '&lt;1p&gt; or its superclasses don''t contain method &lt;2s&gt;') 						expandMacrosWith: class						with: self inlineSelector)].	inlineParseTree := self inlineClass parseTreeFor: self inlineSelector.	inlineParseTree isNil 		ifTrue: [self refactoringError: (#CouldNotParseSources &lt;&lt; #browser &gt;&gt; 'Could not parse sources')].	inlineParseTree lastIsReturn ifFalse: [inlineParseTree addSelfReturn]</body><body package="Browser-Refactorings">removeEmptyIfTrues		| rewriter |	rewriter := ParseTreeRewriter new.	rewriter		replace: '``@boolean ifTrue: [] ifFalse: [| `@temps | ``@.Stmts]' with:				'``@boolean ifFalse: [|`@temps | ``@.Stmts]';		replace: '``@boolean ifFalse: [] ifTrue: [| `@temps | ``@.Stmts]' with:				'``@boolean ifTrue: [|`@temps | ``@.Stmts]';		replace: '``@boolean ifTrue: [| `@temps | ``@.Stmts] ifFalse: []' with:				'``@boolean ifTrue: [|`@temps | ``@.Stmts]';		replace: '``@boolean ifFalse: [| `@temps | ``@.Stmts] ifTrue: []' with:				'``@boolean ifFalse: [|`@temps | ``@.Stmts]'.	(rewriter executeTree: self sourceTree)		ifTrue: [sourceTree := rewriter tree]</body><body package="Browser-Refactorings">removeImmediateBlocks		| rewriter |	rewriter := ParseTreeRewriter new.	rewriter		replace: '[^``@object] value'			with: '``.object'			when: [:aNode | aNode parent isSequence];		replace: '[``.object `{:node | node isReturn not}] value'			with: '``.object'			when: [:aNode | aNode parent isCascade not].	rewriter replace:			'| `@temps | ``@.Stmts1. [| `@bTemps | ``@.bStmts] value. ``@.Stmts2'		with: '| `@temps `@bTemps | ``@.Stmts1. ``@.bStmts. ``@.Stmts2'.	(rewriter executeTree: self sourceTree)		ifTrue: [sourceTree := rewriter tree]</body><body package="Browser-Refactorings">removeReturns	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter replace: '^``@object' with: '``@object'.	(rewriter executeTree: inlineParseTree) 		ifTrue: [inlineParseTree := rewriter tree]</body><body package="Browser-Refactorings">renameConflictingTemporaries	inlineParseTree allDefinedVariables 		do: [:each | self renameConflictingTemporary: each]</body><body package="Browser-Refactorings">renameConflictingTemporary: aName 	| allNames newName index seqNode |	allNames := (Set new)				addAll: inlineParseTree allDefinedVariables;				yourself.	allNames remove: aName ifAbsent: [].	seqNode := sourceMessage.	[seqNode isSequence] whileFalse: [seqNode := seqNode parent].	allNames addAll: seqNode allDefinedVariables.	"Add those variables defined in blocks. This might cause a few 													variables to be renamed that don't need to be, but this should be safe."	newName := aName.	index := 0.		[(sourceMessage whoDefines: newName) notNil or: 			[(class hierarchyDefinesVariable: newName) or: [allNames includes: newName]]] 			whileTrue: 				[index := index + 1.				newName := aName , index printString].	newName = aName ifFalse: [self renameTemporary: aName to: newName].	^newName</body><body package="Browser-Refactorings">renameTemporary: oldName to: newName 	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter		replace: oldName with: newName;		replaceArgument: oldName with: newName.	(rewriter executeTree: inlineParseTree) 		ifTrue: [inlineParseTree := rewriter tree]</body><body package="Browser-Refactorings">replaceArgument: sourceNode with: replacementNode 	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter replaceTree: sourceNode withTree: replacementNode.	(rewriter executeTree: inlineParseTree body) 		ifTrue: [inlineParseTree body: rewriter tree]</body><body package="Browser-Refactorings">replaceArguments	sourceMessage arguments reverse with: inlineParseTree arguments reverse		do: 			[:replacement :source | 			(replacement isImmediateNode 				or: [self shouldInlineExpression: replacement newSource]) 					ifTrue: [self replaceArgument: source with: replacement]					ifFalse: [self addTemporary: source assignedTo: replacement]]</body><body package="Browser-Refactorings">rewriteCascadedMessage	| index messages |	messages := sourceMessage parent messages.	index := (1 to: messages size) 				detect: [:i | sourceMessage == (messages at: i)]				ifNone: [0].	inlineParseTree body addNodesFirst: (messages copyFrom: 1 to: index - 1).	self removeReturns.	inlineParseTree body 		addNodes: (messages copyFrom: index + 1 to: messages size).	inlineParseTree addReturn</body><body package="Browser-Refactorings">rewriteInlinedTree		sourceMessage parent isReturn		ifTrue:			[(self sourceTree isLast: sourceMessage parent)				ifFalse: [self addSelfReturn]]		ifFalse:			[self				writeGuardClauses;				normalizeIfTrues;				normalizeReturns;				addSelfReturn]</body><body package="Browser-Refactorings">transform	self		renameConflictingTemporaries;		insertInlinedMethod;		compileMethod</body><body package="Browser-Refactorings">writeGuardClauses	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter		replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2. ^`@r2'			with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1] ifFalse: [`@.s2. ^`@r2]';		replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2. ^`@r2'			with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [`@.s2. ^`@r2] ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]';		replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2'			with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1] ifFalse: [`@.s2. ^self]';		replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2'			with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [`@.s2. ^self] ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]'.	[rewriter executeTree: inlineParseTree] 		whileTrue: [inlineParseTree := rewriter tree]</body></methods><methods><class-id>Refactory.Browser.InlineMethodRefactoring</class-id> <category>testing</category><body package="Browser-Refactorings">hasMultipleReturns	"Do we have multiple returns? If the last statement isn't a return, then we have an implicit return of self."	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: '^``@object'		do: 			[:aNode :hasAReturn | 			hasAReturn ifTrue: [^true].			true].	searcher executeTree: inlineParseTree		initialAnswer: inlineParseTree lastIsReturn not.	^false</body><body package="Browser-Refactorings">isOverridden	^class allSubclasses 		anySatisfy: [:each | each directlyDefinesMethod: self inlineSelector]</body><body package="Browser-Refactorings">isPrimitive	^inlineParseTree isPrimitive</body></methods><methods><class-id>Refactory.Browser.InlineMethodRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">inline: anInterval inMethod: aSelector forClass: aClass 	sourceSelector := aSelector.	class := self classObjectFor: aClass.	sourceInterval := anInterval</body></methods><methods><class-id>Refactory.Browser.InlineMethodRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream	aStream nextPutAll: 'Inline method refactoring'</body><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' inline: '.	sourceInterval storeOn: aStream.	aStream		nextPutAll: ' inMethod: #';		nextPutAll: sourceSelector;		nextPutAll: ' forClass: '.	class storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.InlineMethodRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">preconditions	^(Condition definesSelector: sourceSelector in: class) 		&amp; (Condition withBlock: 					[self findSelectedMessage.					self parseInlineMethod.					self isOverridden 						ifTrue: 							[self 								refactoringWarning: ((#x1p2sOverriddenInlineQ &lt;&lt; #browser &gt;&gt; '&lt;1p&gt;&gt;&gt;&lt;2s&gt; is overridden. Do you want to inline it anyway?') 										expandMacrosWith: self inlineClass										with: self inlineSelector)].					self isPrimitive 						ifTrue: [self refactoringError: (#CannotInlinePrimitives &lt;&lt; #browser &gt;&gt; 'Cannot inline primitives')].					self checkSuperMessages.					self rewriteInlinedTree.					(sourceMessage parent isReturn or: [self hasMultipleReturns not]) 						ifFalse: 							[self 								refactoringError: (#CannotInlineWithMultipleReturns &lt;&lt; #browser &gt;&gt; 'Cannot inline method since it contains multiple returns that cannot be rewritten')].					true])</body></methods><methods><class-id>Refactory.Browser.InlineMethodRefactoring</class-id> <category>accessing</category><body package="Browser-Refactorings">sourceTree		^sourceTree ifNil: [sourceTree := class parseTreeFor: sourceSelector]</body><body package="Browser-Refactorings">sourceTree: aParseTree		sourceTree := aParseTree</body></methods><methods><class-id>Refactory.Browser.InlineMethodRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">inline: anInterval inMethod: aSelector forClass: aClass 	^(self new)		inline: anInterval			inMethod: aSelector			forClass: aClass;		yourself</body><body package="Browser-Refactorings">model: aRBNameSpace inline: anInterval inMethod: aSelector forClass: aClass 	^(self new)		model: aRBNameSpace;		inline: anInterval			inMethod: aSelector			forClass: aClass;		yourself</body></methods><methods><class-id>Refactory.Browser.InlineTemporaryRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">checkMultipleAssignments	self hasOnlyOneAssignment 		ifFalse: 			[self refactoringError: (#MultipleAssignmentsExist &lt;&lt; #browser &gt;&gt; 'There are multiple assignments to the variable')]</body><body package="Browser-Refactorings">checkReadBeforeWritten	(RBReadBeforeWrittenTester isVariable: assignmentNode variable name		writtenBeforeReadIn: definingNode) 			ifFalse: 				[self 					refactoringError: (#VariableReadBeforeAssigned &lt;&lt; #browser &gt;&gt; 'The variable is possible read before it is assigned')]</body><body package="Browser-Refactorings">determineAssignmentNode		assignmentNode := self sourceTree whichNodeIsContainedBy: sourceInterval.	assignmentNode isNil		ifTrue:			[self				refactoringError:					#SelectionDoesNotLookLikeAssignment &lt;&lt; #browser &gt;&gt;							'The selection does not appear to be an assignment'].	assignmentNode isAssignment		ifFalse:			[self				refactoringError:					#SelectionIsNotAssignment &lt;&lt; #browser &gt;&gt;							'The selected node is not an assignment statement']</body><body package="Browser-Refactorings">determineVariableDefinition	definingNode := assignmentNode whoDefines: assignmentNode variable name.	definingNode isNil 		ifTrue: 			[self 				refactoringError: (#VariableDoesNotLookLikeTemp &lt;&lt; #browser &gt;&gt; 'The variable does not appear to be a temporary variable.')]</body><body package="Browser-Refactorings">preconditions	^(Condition definesSelector: selector in: class) 		&amp; (Condition withBlock: 					[self verifySelectedInterval.					true])</body><body package="Browser-Refactorings">verifySelectedInterval		self determineAssignmentNode.	self determineVariableDefinition.	self checkMultipleAssignments.	self checkReadBeforeWritten</body></methods><methods><class-id>Refactory.Browser.InlineTemporaryRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">compileMethod		class compileTree: self sourceTree</body><body package="Browser-Refactorings">replaceAssignment	assignmentNode isUsed 		ifTrue: [assignmentNode replaceWith: assignmentNode value]		ifFalse: [assignmentNode parent removeNode: assignmentNode]</body><body package="Browser-Refactorings">replaceReferences	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter replaceTree: assignmentNode variable		withTree: assignmentNode value.	definingNode removeTemporaryNamed: assignmentNode variable name.	rewriter executeTree: definingNode</body><body package="Browser-Refactorings">transform	self		replaceAssignment;		replaceReferences;		compileMethod</body></methods><methods><class-id>Refactory.Browser.InlineTemporaryRefactoring</class-id> <category>testing</category><body package="Browser-Refactorings">hasOnlyOneAssignment	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: assignmentNode variable name , ' := ``@object'		do: [:aNode :answer | answer + 1].	^(searcher executeTree: definingNode initialAnswer: 0) == 1</body></methods><methods><class-id>Refactory.Browser.InlineTemporaryRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">inline: anInterval from: aSelector in: aClass 	class := self classObjectFor: aClass.	selector := aSelector.	sourceInterval := anInterval</body></methods><methods><class-id>Refactory.Browser.InlineTemporaryRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream	aStream nextPutAll: 'Inline temporary refactoring'</body><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' inline: '.	sourceInterval storeOn: aStream.	aStream		nextPutAll: ' from: #';		nextPutAll: selector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.InlineTemporaryRefactoring</class-id> <category>accessing</category><body package="Browser-Refactorings">sourceTree		^sourceTree ifNil: [sourceTree := class parseTreeFor: selector]</body><body package="Browser-Refactorings">sourceTree: aParseTree		^sourceTree := aParseTree</body></methods><methods><class-id>Refactory.Browser.InlineTemporaryRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">inline: anInterval from: aSelector in: aClass 	^(self new)		inline: anInterval			from: aSelector			in: aClass;		yourself</body><body package="Browser-Refactorings">model: aRBNameSpace inline: anInterval from: aSelector in: aClass 	^(self new)		model: aRBNameSpace;		inline: anInterval			from: aSelector			in: aClass;		yourself</body></methods><methods><class-id>Refactory.Browser.ExtractMethodRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">checkAssignments: variableNames 	| node outsideVars removeAssigned |	removeAssigned := variableNames copy.	node := self placeholderNode.	outsideVars := variableNames 				select: [:each | (node whoDefines: each) references: each].	outsideVars size == 1 		ifTrue: [self checkSingleAssignment: outsideVars asArray first].	outsideVars size &gt; 1 		ifTrue: 			[self refactoringError: (#CannotExtractAssignmentWithoutAllRefs &lt;&lt; #browser &gt;&gt; 'Cannot extract assignment without all references.')].	removeAssigned removeAll: outsideVars.	(RBReadBeforeWrittenTester readBeforeWritten: removeAssigned		in: extractedParseTree) notEmpty 		ifTrue: 			[self refactoringError: (#CannotExtractAssignmentIfReadBeforeWritten &lt;&lt; #browser &gt;&gt; 'Cannot extract assignment if read before written.')].	removeAssigned 		do: [:each | (node whoDefines: each) removeTemporaryNamed: each].	self createTemporariesInExtractedMethodFor: variableNames</body><body package="Browser-Refactorings">checkReturn	needsReturn := self placeholderNode isUsed.	extractedParseTree containsReturn ifFalse: [^self].	extractedParseTree lastIsReturn ifTrue: [^self].	(modifiedParseTree isLast: self placeholderNode) 		ifFalse: 			[self 				refactoringError: (#CannotExtractReturn &lt;&lt; #browser &gt;&gt; 'Couldn''t extract code since it contains a return.')].	self checkSelfReturns</body><body package="Browser-Refactorings">checkSelfReturns	| searcher |	searcher := ParseTreeSearcher new.	searcher		matches: '^self' do: [:aNode :answer | answer];		matches: '^`@anything' do: [:aNode :answer | true].	(searcher executeTree: extractedParseTree initialAnswer: false) 		ifTrue: [self placeholderNode asReturn]</body><body package="Browser-Refactorings">checkSingleAssignment: varName 	((RBReadBeforeWrittenTester isVariable: varName		readBeforeWrittenIn: extractedParseTree) 			or: [extractedParseTree containsReturn]) 			ifTrue: 				[self 					refactoringError: (#CannotExtractAssignmentsToTempsWithoutAllRefs &lt;&lt; #browser &gt;&gt; 'Cannot extract assignments to temporaries without all references')].	extractedParseTree 		addNode: (RBReturnNode value: (RBVariableNode named: varName)).	modifiedParseTree := ParseTreeRewriter 				replace: self methodDelimiter				with: varName , ' := ' , self methodDelimiter				in: modifiedParseTree</body><body package="Browser-Refactorings">checkSpecialExtractions	| node |	node := self placeholderNode parent.	node isNil ifTrue: [^self].	(node isAssignment and: [node variable = self placeholderNode]) 		ifTrue: 			[self refactoringError: (#CannotExtractLHS &lt;&lt; #browser &gt;&gt; 'Cannot extract left hand side of an assignment')].	node isCascade 		ifTrue: 			[self 				refactoringError: (#CannotExtractFirstInCascade &lt;&lt; #browser &gt;&gt; 'Cannot extract first message of a cascaded message')]</body><body package="Browser-Refactorings">checkTemporaries	| temps accesses assigned |	temps := self remainingTemporaries.	accesses := temps select: [:each | extractedParseTree references: each].	assigned := accesses select: [:each | extractedParseTree assigns: each].	assigned notEmpty ifTrue: [self checkAssignments: assigned].	^parameters := (accesses asOrderedCollection)				removeAll: assigned;				yourself</body><body package="Browser-Refactorings">createTemporariesInExtractedMethodFor: assigned 	assigned do: [:each | extractedParseTree body addTemporaryNamed: each]</body><body package="Browser-Refactorings">existingSelector	"Try to find an existing method instead of creating a new one"	^class allSelectors detect: 			[:each | 			(class subclassRedefines: each) not and: [self isMethodEquivalentTo: each]]		ifNone: [nil]</body><body package="Browser-Refactorings">extractMethod		| isSequence extractCode subtree newCode |	extractCode := self getExtractedSource.	extractedParseTree := RBParser		parseExpression: extractCode		onError:			[:string :pos | 			self				refactoringError:					#InvalidSourceToExtract &lt;&lt; #browser &gt;&gt; 'Invalid source to extract'].	extractedParseTree isNil		ifTrue:			[self				refactoringError:					#InvalidSourceToExtract &lt;&lt; #browser &gt;&gt; 'Invalid source to extract'].	(extractedParseTree isSequence		and: [extractedParseTree statements isEmpty])		ifTrue:			[self				refactoringError:					#SelectSomeCodeToExtract &lt;&lt; #browser &gt;&gt; 'Select some code to extract'].	isSequence := extractedParseTree isSequence		or: [extractedParseTree isReturn].	extractedParseTree := RBMethodNode		selector: #value		arguments: #()		body:			(extractedParseTree isSequence				ifTrue: [extractedParseTree]				ifFalse:					[RBSequenceNode						temporaries: #()						statements: (OrderedCollection with: extractedParseTree)]).	extractedParseTree body temporaries notEmpty		ifTrue: [extractedParseTree body temporaries: #()].	extractedParseTree source: extractCode.	subtree := isSequence		ifTrue:			[ParseTreeSearcher				treeMatchingStatements: extractedParseTree body formattedCode				in: self sourceTree]		ifFalse:			[ParseTreeSearcher				treeMatching: extractCode				in: self sourceTree].	subtree isNil		ifTrue:			[self				refactoringError:					#CouldNotExtractSourceFromMethod &lt;&lt; #browser &gt;&gt;							'Could not extract code from method'].	newCode := self methodDelimiter.	isSequence		ifTrue:			[| stmts |			stmts := extractedParseTree body statements.			stmts notEmpty				ifTrue:					[stmts last isAssignment						ifTrue:							[| name |							name := stmts last variable name.							(self shouldExtractAssignmentTo: name)								ifFalse:									[newCode := '&lt;1s&gt; := &lt;2s&gt;' expandMacrosWith: name with: newCode.									stmts										at: stmts size										put: stmts last value]]]].	modifiedParseTree := isSequence		ifTrue:			[ParseTreeRewriter				replaceStatements: subtree formattedCode				with: newCode				in: self sourceTree				onInterval: extractionInterval]		ifFalse:			[ParseTreeRewriter				replace: subtree formattedCode				with: newCode				in: self sourceTree				onInterval: extractionInterval]</body><body package="Browser-Refactorings">getExtractedSource		| source |	source := self sourceTree source.	((extractionInterval first		between: 1		and: source size)		and:			[extractionInterval last				between: 1				and: source size])		ifFalse:			[self refactoringError: #InvalidInterval &lt;&lt; #browser &gt;&gt; 'Invalid interval'].	^source		copyFrom: extractionInterval first		to: extractionInterval last</body><body package="Browser-Refactorings">getNewMethodName	| newSelector methodName newMethodName |	methodName := RBMethodName new.	methodName arguments: parameters.		[newMethodName := self requestMethodNameFor: methodName.	newMethodName isNil 		ifTrue: [self refactoringError: (#DidNotExtractCode &lt;&lt; #browser &gt;&gt; 'Did not extract code')].	newSelector := newMethodName selector.	(self checkMethodName: newSelector in: class) 		ifFalse: 			[self refactoringWarning: ((#x1sIsInvalidSelector &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is not a valid selector name.')			expandMacrosWith: newSelector).			newSelector := nil].	(class hierarchyDefinesMethod: newSelector asSymbol) 		ifTrue: 			[(self shouldOverride: newSelector in: class) ifFalse: [newSelector := nil]].	newSelector isNil] 			whileTrue: [].	parameters := newMethodName arguments asOrderedCollection.	^newSelector asSymbol</body><body package="Browser-Refactorings">isMethodEquivalentTo: aSelector 	selector == aSelector ifTrue: [^false].	aSelector numArgs ~~ parameters size ifTrue: [^false].	(self isParseTreeEquivalentTo: aSelector) ifFalse: [^false].	self reorderParametersToMatch: aSelector.	^true</body><body package="Browser-Refactorings">isParseTreeEquivalentTo: aSelector 	| tree definingClass |	definingClass := class whoDefinesMethod: aSelector.	tree := definingClass parseTreeFor: aSelector.	tree isNil ifTrue: [^false].	tree isPrimitive ifTrue: [^false].	(tree body equalTo: extractedParseTree body		exceptForVariables: (tree arguments collect: [:each | each name])) 			ifFalse: [^false].	(definingClass = class or: 			[(tree superMessages anySatisfy: 					[:each | 					(class superclass whichClassIncludesSelector: aSelector) 						~= (definingClass superclass whichClassIncludesSelector: each)]) 				not]) 		ifFalse: [^false].	^self shouldUseExistingMethod: aSelector</body><body package="Browser-Refactorings">methodDelimiter	^'#''place.holder.for.method'''</body><body package="Browser-Refactorings">nameNewMethod: aSymbol 	| args newSend |	args := parameters collect: [:each | RBVariableNode named: each].	extractedParseTree renameSelector: aSymbol andArguments: args asArray.	aSymbol numArgs = 0 		ifTrue: 			[modifiedParseTree := ParseTreeRewriter 						replace: self methodDelimiter						with: 'self ' , aSymbol asString						in: modifiedParseTree.			^self].	newSend := WriteStream on: String new.	aSymbol keywords with: parameters		do: 			[:key :arg | 			newSend				nextPutAll: key asString;				nextPut: $ ;				nextPutAll: arg asString;				nextPut: $ ].	modifiedParseTree := ParseTreeRewriter 				replace: self methodDelimiter				with: 'self ' , newSend contents				in: modifiedParseTree</body><body package="Browser-Refactorings">placeholderNode	| node |	node := ParseTreeSearcher treeMatching: self methodDelimiter				in: modifiedParseTree.	node isNil ifTrue: [self refactoringError: (#CannotExtractCode &lt;&lt; #browser &gt;&gt; 'Cannot extract code')].	^node</body><body package="Browser-Refactorings">remainingTemporaries	| temps |	temps := modifiedParseTree allDefinedVariables asSet.	extractedParseTree allDefinedVariables 		do: [:each | temps remove: each ifAbsent: []].	^temps</body><body package="Browser-Refactorings">reorderParametersToMatch: aSelector 	| tree dictionary |	tree := class parseTreeFor: aSelector.	dictionary := Dictionary new.	tree body equalTo: extractedParseTree body withMapping: dictionary.	parameters := tree arguments collect: 					[:each | 					dictionary at: each name						ifAbsent: 							[self 								refactoringError: (#InternalErrorPleaseReport &lt;&lt; #browser &gt;&gt; 'An internal error occured, please report this error.')]]</body><body package="Browser-Refactorings">transform	| existingSelector |	existingSelector := self existingSelector.	self nameNewMethod: (existingSelector isNil 				ifTrue: [self getNewMethodName]				ifFalse: [existingSelector]).	existingSelector isNil 		ifTrue: 			[class compile: extractedParseTree newSource				withAttributesFrom: (class methodFor: selector)].	class compileTree: modifiedParseTree</body></methods><methods><class-id>Refactory.Browser.ExtractMethodRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">extract: anInterval from: aSelector in: aClass 	class := self classObjectFor: aClass.	selector := aSelector.	extractionInterval := anInterval</body></methods><methods><class-id>Refactory.Browser.ExtractMethodRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	aStream nextPutAll: 'Extract method refactoring'</body><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' extract: '.	extractionInterval storeOn: aStream.	aStream		nextPutAll: ' from: #';		nextPutAll: selector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.ExtractMethodRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">preconditions	^(Condition definesSelector: selector in: class) 		&amp; (Condition withBlock: 					[self extractMethod.					self checkSpecialExtractions.					self checkReturn.					needsReturn ifTrue: [extractedParseTree addReturn].					self checkTemporaries.					true])</body></methods><methods><class-id>Refactory.Browser.ExtractMethodRefactoring</class-id> <category>accessing</category><body package="Browser-Refactorings">sourceTree		^sourceTree ifNil: [sourceTree := class parseTreeFor: selector]</body><body package="Browser-Refactorings">sourceTree: aParseTree		sourceTree := aParseTree</body></methods><methods><class-id>Refactory.Browser.ExtractMethodRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">extract: anInterval from: aSelector in: aClass 	^(self new)		extract: anInterval			from: aSelector			in: aClass;		yourself</body><body package="Browser-Refactorings">model: aRBNameSpace extract: anInterval from: aSelector in: aClass 	^(self new)		model: aRBNameSpace;		extract: anInterval			from: aSelector			in: aClass;		yourself</body></methods><methods><class-id>Refactory.Browser.RenameTemporaryRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">class: aClass selector: aSelector interval: anInterval newName: aString 	class := self classObjectFor: aClass.	selector := aSelector.	interval := anInterval.	newName := aString</body></methods><methods><class-id>Refactory.Browser.RenameTemporaryRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream	aStream nextPutAll: 'Rename temporary refactoring'</body><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' renameTemporaryFrom: '.	interval storeOn: aStream.	aStream		nextPutAll: ' to: ''';		nextPutAll: newName;		nextPutAll: ''' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: selector.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.RenameTemporaryRefactoring</class-id> <category>tranforming</category><body package="Browser-Refactorings">renameNode: aParseTree 	(aParseTree whoDefines: newName) notNil 		ifTrue: [self refactoringError: ((#x1sIsAlreadyDefined &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is already defined')			expandMacrosWith: newName)].	(aParseTree allDefinedVariables includes: newName) 		ifTrue: [self refactoringError: ((#x1sIsAlreadyDefined &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is already defined')			expandMacrosWith: newName)].	(ParseTreeRewriter rename: oldName to: newName) executeTree: aParseTree</body></methods><methods><class-id>Refactory.Browser.RenameTemporaryRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">preconditions		^(Condition definesSelector: selector in: class)		&amp; (Condition isValidInstanceVariableName: newName for: class)		&amp; (Condition definesVariable: newName in: class) not		&amp;			(Condition				withBlock:					[| methodSource |					interval first &gt; interval last						ifTrue:							[self								refactoringError:									#InvalidVariableName &lt;&lt; #browser &gt;&gt; 'Invalid variable name'].					methodSource := self sourceTree source.					methodSource size &gt;= interval last						ifFalse:							[self								refactoringError:									#InvalidRangeForVariable &lt;&lt; #browser &gt;&gt; 'Invalid range for variable'].					oldName := (methodSource						copyFrom: interval first						to: interval last) asString.					true])</body></methods><methods><class-id>Refactory.Browser.RenameTemporaryRefactoring</class-id> <category>accessing</category><body package="Browser-Refactorings">sourceTree		^sourceTree ifNil: [sourceTree := class parseTreeFor: selector]</body><body package="Browser-Refactorings">sourceTree: aParseTree		sourceTree := aParseTree</body></methods><methods><class-id>Refactory.Browser.RenameTemporaryRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">transform		| definingNode variableNode |	variableNode := self		whichVariableNode: self sourceTree		inInterval: interval		name: oldName.	(variableNode isNil or: [variableNode isVariable not])		ifTrue:			[self				refactoringError:					(#x1sIsntAValidVariable &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; isn''t a valid variable'						expandMacrosWith: oldName)].	variableNode name = oldName		ifFalse:			[self				refactoringError: #InvalidSelection &lt;&lt; #browser &gt;&gt; 'Invalid selection'].	definingNode := variableNode whoDefines: oldName.	definingNode isNil		ifTrue:			[self				refactoringError:					(#x1sIsNotDefinedByMethod &lt;&lt; #browser &gt;&gt;							'&lt;1s&gt; isn''t defined by the method' expandMacrosWith: oldName)].	self renameNode: definingNode.	class compileTree: self sourceTree</body></methods><methods><class-id>Refactory.Browser.RenameTemporaryRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">model: aRBNameSpace renameTemporaryFrom: anInterval to: newName in: aClass selector: aSelector 	^(self new)		model: aRBNameSpace;		class: aClass			selector: aSelector			interval: anInterval			newName: newName;		yourself</body><body package="Browser-Refactorings">renameTemporaryFrom: anInterval to: newName in: aClass selector: aSelector 	^(self new)		class: aClass			selector: aSelector			interval: anInterval			newName: newName;		yourself</body></methods><methods><class-id>Refactory.Browser.RBSharedVariable</class-id> <category>accessing</category><body package="Browser-Refactorings">allInitializersDo: aBlock 	aBlock value: (RBInitializerMethod for: self source: self initializer)</body><body package="Browser-Refactorings">asNameSpace	(self isDefined 		and: [self realItem isNameSpace or: [self realItem isBehavior]]) 			ifTrue: [^self rootNameSpace nameSpaceFor: self realItem].	^nil</body><body package="Browser-Refactorings">category	^category ifNil: [binding category]</body><body package="Browser-Refactorings">category: anObject	category := anObject</body><body package="Browser-Refactorings">constant	^constant</body><body package="Browser-Refactorings">constant: aBoolean 	constant := aBoolean</body><body package="Browser-Refactorings">definitionString	| definitionStream |	definitionStream := WriteStream on: String new.	definitionStream		nextPutAll: self environment unambiguousName;		nextPutAll: ' defineSharedVariable: #';		nextPutAll: self name;		cr;		tab;		nextPutAll: 'private: ';		nextPutAll: isPrivate printString;		cr;		tab;		nextPutAll: 'constant: ';		nextPutAll: constant printString;		cr;		tab;		nextPutAll: 'category: ';		nextPutAll: self category asString printString;		cr;		tab;		nextPutAll: 'initializer: '.	initializer isNil 		ifTrue: [definitionStream nextPutAll: 'nil']		ifFalse: [definitionStream nextPutAll: initializer asString printString].	^definitionStream contents</body><body package="Browser-Refactorings">initializer	initializer isNil ifFalse: [^initializer].	initializer := self isDefined 				ifTrue: 					[| method |					method := binding method.					method isNil ifTrue: [''] ifFalse: [method getSource]]				ifFalse: [''].	^initializer</body><body package="Browser-Refactorings">initializer: aStringOrNil 	initializer := aStringOrNil</body><body package="Browser-Refactorings">outerReferencingMethodsDo: aBlock	| method |	method := RBInitializerMethod		for: self		source: self initializer.	method hasOuterVariables ifTrue: [aBlock value: nil value: method]</body></methods><methods><class-id>Refactory.Browser.RBSharedVariable</class-id> <category>testing</category><body package="Browser-Refactorings">isSharedVariable	^true</body></methods><methods><class-id>Refactory.Browser.RBSharedVariable</class-id> <category>initialize-release</category><body package="Browser-Refactorings">realBinding: aVariableBinding 	super realBinding: aVariableBinding.	constant := aVariableBinding isConstant</body></methods><methods><class-id>Refactory.Browser.RBSharedVariable</class-id> <category>private</category><body package="Browser-Refactorings">basicRemove	^self changes removeSharedVariableNamed: self unambiguousName</body></methods><methods><class-id>Refactory.Browser.RBSharedVariable</class-id> <category>accessing-objects</category><body package="Browser-Refactorings">localReferencedItem: aSymbol includePrivates: aBoolean alreadySearched: aCollection currentlyChecking: aSet 	| ns |	ns := self asNameSpace.	ns isNil ifTrue: [^nil].	^ns 		localReferencedItem: aSymbol		includePrivates: aBoolean		alreadySearched: aCollection		currentlyChecking: aSet</body></methods><methods><class-id>Refactory.Browser.RBSharedVariable class</class-id> <category>instance creation</category><body package="Browser-Refactorings">onBinding: aVariableBinding 	^(self new)		realBinding: aVariableBinding;		yourself</body></methods><methods><class-id>Refactory.Browser.InlineMethodFromComponentRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">abstractVariableReferences	| refactoring |	refactoring := AbstractVariablesRefactoring 				model: self model				abstractVariablesIn: inlineParseTree				from: inlineClass				toAll: (Array with: class).	self performComponentRefactoring: refactoring.	inlineParseTree := refactoring parseTree</body><body package="Browser-Refactorings">addArgumentToSelector: aSymbol 	^aSymbol isInfix 		ifTrue: [#value:value:]		ifFalse: [(aSymbol , 'value:') asSymbol]</body><body package="Browser-Refactorings">addSelfReferenceToInlineParseTree	| variableName rewriter newArguments |	variableName := self newNameForSelf.	rewriter := ParseTreeRewriter rename: 'self' to: variableName.	(rewriter executeTree: inlineParseTree) 		ifTrue: [inlineParseTree := rewriter tree].	newArguments := OrderedCollection withAll: inlineParseTree arguments.	newArguments addFirst: (RBVariableNode named: variableName).	inlineParseTree 		renameSelector: (self addArgumentToSelector: inlineParseTree selector)		andArguments: newArguments.	sourceMessage receiver replaceWith: (RBVariableNode named: variableName)</body><body package="Browser-Refactorings">addSelfReferenceToSourceMessage	| newArguments |	newArguments := OrderedCollection withAll: sourceMessage arguments.	newArguments addFirst: sourceMessage receiver copy.	sourceMessage 		renameSelector: (self addArgumentToSelector: sourceMessage selector)		andArguments: newArguments</body><body package="Browser-Refactorings">checkSuperMessages	inlineParseTree superMessages notEmpty 		ifTrue: 			[self 				refactoringError: (#CannotInlineWithSuperSend &lt;&lt; #browser &gt;&gt; 'Cannot inline method since it sends a super message')]</body><body package="Browser-Refactorings">findSelectedMessage		sourceMessage := self sourceTree whichNodeIsContainedBy: sourceInterval.	sourceMessage isNil		ifTrue:			[self				refactoringError:					#SelectionNotMessageSend &lt;&lt; #browser &gt;&gt;							'The selection doesn''t appear to be a message send'].	sourceMessage isCascade		ifTrue: [sourceMessage := sourceMessage messages last].	sourceMessage isMessage		ifFalse:			[self				refactoringError:					#SelectionNotMessageSend &lt;&lt; #browser &gt;&gt;							'The selection doesn''t appear to be a message send']</body><body package="Browser-Refactorings">inlineClass	| imps |	inlineClass notNil ifTrue: [^inlineClass].	imps := (self model allImplementorsOf: self inlineSelector) 				asOrderedCollection.	imps size = 1 ifTrue: [^inlineClass := imps first].	imps isEmpty 		ifTrue: 			[self 				refactoringError: ((#NobodyDefinesMethod1s &lt;&lt; #browser &gt;&gt; 'Nobody defines a method named &lt;1s&gt;')			expandMacrosWith: self inlineSelector)].	inlineClass := self requestImplementorToInline: imps.	inlineClass isNil 		ifTrue: [self refactoringError: (#NoImplementorSelected &lt;&lt; #browser &gt;&gt; 'No implementor selected')].	^inlineClass</body><body package="Browser-Refactorings">newNameForSelf	| variableName index originalName nonMetaClass |	nonMetaClass := inlineClass nonMetaclass.	variableName := originalName := 		((nonMetaClass name first isVowel 			ifTrue: [(#an &lt;&lt; #browser &gt;&gt; 'an')]			ifFalse: [(#a &lt;&lt; #browser &gt;&gt; 'a')])) asString, nonMetaClass name.	index := 1.		[variableName := self safeVariableNameBasedOn: variableName.	inlineParseTree allDefinedVariables includes: variableName] 			whileTrue: 				[variableName := originalName , index printString.				index := index + 1].	^variableName</body><body package="Browser-Refactorings">renameSelfReferences	self addSelfReferenceToSourceMessage.	self addSelfReferenceToInlineParseTree.</body><body package="Browser-Refactorings">safeVariableNameBasedOn: aString 	"Creates an unused variable name containing aString"	| baseString newString i allTempVars |	allTempVars := inlineParseTree allTemporaryVariables.	baseString := aString copy.	baseString at: 1 put: baseString first asLowercase.	newString := baseString.	i := 0.		[(allTempVars includes: newString) 		or: [class definesInstanceVariable: newString]] 			whileTrue: 				[i := i + 1.				newString := baseString , i printString].	^newString</body><body package="Browser-Refactorings">transform	self abstractVariableReferences.	self renameSelfReferences.	super transform</body></methods><methods><class-id>Refactory.Browser.InlineMethodFromComponentRefactoring</class-id> <category>testing</category><body package="Browser-Refactorings">isOverridden	^self inlineClass allSubclasses 		anySatisfy: [:each | each directlyDefinesMethod: self inlineSelector]</body></methods><methods><class-id>Refactory.Browser.InlineMethodFromComponentRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream	aStream nextPutAll: 'Inline method from component refactoring'</body></methods><methods><class-id>Refactory.Browser.Condition</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	type printOn: aStream</body></methods><methods><class-id>Refactory.Browser.Condition</class-id> <category>initialize-release</category><body package="Browser-Refactorings">errorBlock: anObject	errorBlock := anObject</body><body package="Browser-Refactorings">type: aSymbol block: aBlock errorString: aString 	type := aSymbol.	block := aBlock.	self errorMacro: aString</body><body package="Browser-Refactorings">withBlock: aBlock 	block := aBlock.	type := #(#generic)</body></methods><methods><class-id>Refactory.Browser.Condition</class-id> <category>checking</category><body package="Browser-Refactorings">check	^block value</body></methods><methods><class-id>Refactory.Browser.Condition</class-id> <category>accessing</category><body package="Browser-Refactorings">errorBlockFor: aBoolean	^errorBlock</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>instance creation</category><body package="Browser-Refactorings">canReference: aString in: aRBNameSpace 	^self new 		type: (Array with: #isGlobal with: aString)		block: [aRBNameSpace notNil and: [aRBNameSpace canReference: aString]]		errorString: ((#x1sExistsORdoesnotInNameSpace &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; %&lt;1?already exists :does not exist %&gt;in the name space')			expandMacrosWith: aString)</body><body package="Browser-Refactorings">canUnderstand: aSelector in: aClass 	^(self new)		type: (Array 					with: #understandsSelector					with: aClass					with: aSelector)			block: [aClass definesMethod: aSelector]			errorString: ((#x1sQundestandsQ2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; %&lt;1?:does not %&gt;understand%&lt;1?s:%&gt; &lt;2s&gt;')			expandMacrosWith: aClass printString			with: aSelector printString);		yourself</body><body package="Browser-Refactorings">definesInstanceVariable: aString in: aClass 	^self new 		type: (Array 				with: #definesInstVar				with: aClass				with: aString)		block: [aClass definesInstanceVariable: aString]		errorString: ((#x1sQdefinesQInstVar2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; %&lt;1?:does not %&gt;define%&lt;1?s:%&gt; instance variable &lt;2s&gt;')			expandMacrosWith: aClass printString			with: aString)</body><body package="Browser-Refactorings">definesSelector: aSelector in: aClass 	^(self new)		type: (Array 					with: #definesSelector					with: aClass					with: aSelector)			block: [aClass directlyDefinesMethod: aSelector]			errorString: ((#x1sQdoesnotdefineQ2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; %&lt;1?:does not %&gt;define%&lt;1?s:%&gt; &lt;2s&gt;')			expandMacrosWith: aClass printString			with: aSelector printString);		yourself</body><body package="Browser-Refactorings">definesVariable: aString in: aClass 	^(self new)		type: (Array 					with: #definesVar					with: aClass					with: aString)			block: [aClass definesVariable: aString]			errorString: ((#x1sQdoesnotdefineQVariable2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; %&lt;1?:does not %&gt;define%&lt;1?s:%&gt; variable &lt;2s&gt;')			expandMacrosWith: aClass printString			with: aString);		yourself</body><body package="Browser-Refactorings">directlyDefinesInstanceVariable: aString in: aClass 	^(self new)		type: (Array 					with: #directlyDefinesInstanceVariable					with: aClass					with: aString)			block: [aClass directlyDefinesInstanceVariable: aString]			errorString: ((#x1sQdoesnotdirectlydefineQinstVar2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; %&lt;1?:does not %&gt;directly define%&lt;1?s:%&gt; instance variable &lt;2s&gt;')			expandMacrosWith: aClass printString			with: aString);		yourself</body><body package="Browser-Refactorings">empty	"Returns an empty condition"	^self new 		type: (Array with: #empty)		block: [true]		errorString: (#Empty &lt;&lt; #browser &gt;&gt; 'Empty') asString</body><body package="Browser-Refactorings">hasSuperclass: aClass 	^self new 		type: (Array with: #hasSuperclass with: aClass)		block: [aClass superclass isNil not]		errorString: ((#x1sHasQnoQsuperclass &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; has %&lt;1?a:no%&gt; superclass')			expandMacrosWith: aClass printString)</body><body package="Browser-Refactorings">hierarchyOf: aClass canAccessVariableNamed: aString 	^self new 		type: (Array 				with: #hierarchyCanAccessVariable				with: aClass				with: aString)		block: [aClass hierarchyCanAccessVariableNamed: aString]		errorString: ((#x1sOrSubclassDoesNotDefineVar2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; or one of its subclasses %&lt;1?:does not %&gt;define%&lt;1?s:%&gt; variable &lt;2s&gt;')			expandMacrosWith: aClass printString			with: aString)</body><body package="Browser-Refactorings">hierarchyOf: aClass canUnderstand: aSelector 	^(self new)		type: (Array 					with: #hierarchyUnderstandsSelector					with: aClass					with: aSelector)			block: [aClass hierarchyDefinesMethod: aSelector]			errorString: ((#x1sQorsubclassORallsubclassesQdoNotUnderstand2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; %&lt;1?or a subclass:and all subclasses do not%&gt; understand%&lt;1?s:%&gt; &lt;2s&gt;')			expandMacrosWith: aClass printString			with: aSelector printString);		yourself</body><body package="Browser-Refactorings">hierarchyOf: aClass definesVariable: aString 	^self new 		type: (Array 				with: #hierarchyDefinesInstVar				with: aClass				with: aString)		block: [aClass hierarchyDefinesVariable: aString]		errorString: ((#x1sOrSubclassDoesNotDefineVar2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; or one of its subclasses %&lt;1?:does not %&gt;define%&lt;1?s:%&gt; variable &lt;2s&gt;')			expandMacrosWith: aClass printString			with: aString)</body><body package="Browser-Refactorings">hierarchyOf: aClass referencesInstanceVariable: aString 	^self new 		type: (Array 				with: #hierarchyReferencesInstVar				with: aClass				with: aString)		block: 			[aClass withAllSubclasses 				anySatisfy: [:each | (each whichSelectorsReferToInstanceVariable: aString) notEmpty]]		errorString: ((#x1sOrSubclassQdoesnotQreferenceInstVar2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; or subclass %&lt;1?:does not %&gt;reference%&lt;1?s:%&gt; instance variable &lt;2s&gt;')			expandMacrosWith: aClass printString			with: aString)</body><body package="Browser-Refactorings">isAbstractClass: aClass 	^self new 		type: (Array with: #IsAbstractClass with: aClass)		block: [aClass isAbstract]		errorString: ((#x1sIsQnotQAbstract &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is %&lt;1?:not %&gt;an abstract class')			expandMacrosWith: aClass printString)</body><body package="Browser-Refactorings">isImmediateSubclass: subclass of: superClass 	^(self new)		type: (Array 					with: #immediateSubclass					with: superClass					with: subclass)			block: [subclass superclass = superClass]			errorString: ((#x1sIsQnotQimmediateSubclassOf2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is %&lt;1?:not %&gt;an immediate subclass of &lt;2s&gt;')			expandMacrosWith: subclass printString			with: superClass printString);		yourself</body><body package="Browser-Refactorings">isMetaclass: anObject 	^(self new)		type: (Array with: #IsMetaclass with: anObject)			block: [anObject isMeta]			errorString: ((#x1sIsQnotQAMetaclass &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is %&lt;1?:not %&gt;a metaclass')			expandMacrosWith: anObject printString);		yourself</body><body package="Browser-Refactorings">isSymbol: aString 	^(self new)		type: (Array with: #isSymbol with: aString)			block: [aString isSymbol]			errorString: ((#x1sIs1notASymbol &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is %&lt;1?:not %&gt;a symbol')			expandMacrosWith: aString);		yourself</body><body package="Browser-Refactorings">isValidClassName: aString 	^(self new)		type: (Array with: #validClassName with: aString)			block: [self validClassName: aString]			errorString: ((#x1sIs1notAValidClassName &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is %&lt;1?:not %&gt;a valid class name')			expandMacrosWith: aString);		yourself</body><body package="Browser-Refactorings">isValidInstanceVariableName: aString for: aClass 	^self new 		type: (Array 				with: #validInstVarName				with: aString				with: aClass)		block: [self checkInstanceVariableName: aString in: aClass]		errorString: ((#x1sIs1notAValidInstVarName &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is %&lt;1?:not %&gt;a valid instance variable name')			expandMacrosWith: aString)</body><body package="Browser-Refactorings">isValidMethodName: aString for: aClass 	^(self new)		type: (Array 					with: #validMethodName					with: aString					with: aClass)			block: [self checkMethodName: aString in: aClass]			errorString: ((#x1sIsNotValidMethodName &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is %&lt;1?:not %&gt;a valid method name')			expandMacrosWith: aString printString);		yourself</body><body package="Browser-Refactorings">referencesInstanceVariable: aString in: aClass 	^(self new)		type: (Array 					with: #referencesInstVar					with: aClass					with: aString)			block: [(aClass whichSelectorsReferToInstanceVariable: aString) notEmpty]			errorString: ((#x1s1doesNotReferenceInstVar2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; %&lt;1?:does not %&gt;reference%&lt;1?s:%&gt; instance variable &lt;2s&gt;')			expandMacrosWith: aClass printString			with: aString);		yourself</body><body package="Browser-Refactorings">subclassesOf: aClass referToSelector: aSelector 	^self new 		type: (Array 				with: #subclassReferences				with: aClass				with: aSelector)		block: 			[aClass subclasses anySatisfy: 					[:each | 					each selectors anySatisfy: 							[:sel | 							| tree |							tree := each parseTreeFor: sel.							tree notNil and: [tree superMessages includes: aSelector]]]]		errorString: ((#x1noORaSubclassRefersTo2s &lt;&lt; #browser &gt;&gt; '%&lt;1?:no:a%&gt; subclass of &lt;1s&gt; refers to &lt;2s&gt;')			expandMacrosWith: aClass printString			with: aSelector printString)</body><body package="Browser-Refactorings">withBlock: aBlock 	^(self new)		withBlock: aBlock;		yourself</body><body package="Browser-Refactorings">withBlock: aBlock errorString: aString 	^(self new)		type: #unknown			block: aBlock			errorString: aString;		yourself</body></methods><methods><class-id>Refactory.Browser.Condition class</class-id> <category>utilities</category><body package="Browser-Refactorings">checkInstanceVariableName: aName in: aClass 	| string |	aName isString ifFalse: [^false].	string := aName asString.	string isEmpty ifTrue: [^false].	(self reservedNames includes: string) ifTrue: [^false].	string first isUppercase ifTrue: [^false].	^RBScanner isVariable: string</body><body package="Browser-Refactorings">checkMethodName: aName in: aClass 	^aName isString and: [RBScanner isSelector: aName]</body><body package="Browser-Refactorings">reservedNames	^#('self' 'true' 'false' 'nil' 'thisContext' 'super')</body><body package="Browser-Refactorings">validClassName: aString 	"Class names and class variable names have the same restrictions"	| string |	aString isString ifFalse: [^false].	string := aString asString.	(string includes: $.) ifTrue: [^false].	(self reservedNames includes: string) ifTrue: [^false].	string isEmpty ifTrue: [^false].	string first isLowercase ifTrue: [^false].	^RBScanner isVariable: string</body></methods><methods><class-id>Refactory.Browser.RemoveMethodRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">checkReferencesToAnyOf: aSelectorCollection 	aSelectorCollection do: 			[:each | 			self model allReferencesTo: each				do: 					[:aRBMethod | 					(aSelectorCollection includes: aRBMethod selector) 						ifFalse: 							[self 								refactoringError: ((#PossibleCallTo2sFrom1pBrowseQ &lt;&lt; #browser &gt;&gt; 'Possible call to &lt;2s&gt; in &lt;1p&gt;&lt;n&gt;Browse references?') 										expandMacrosWith: aRBMethod modelClass										with: each)								with: [self openBrowserOn: (BrowserEnvironment new referencesTo: each)]]]]</body><body package="Browser-Refactorings">checkReferencesToSuperSendsToAnyOf: superMessages 	[superMessages isEmpty] whileFalse: 			[self 				refactoringWarning: ((#AlmostEqButHasSuperSend &lt;&lt; #browser &gt;&gt; 'Although &lt;1s&gt; is equivalent to a superclass method,&lt;n&gt;it contains a super send so it might modify behavior.') 						expandMacrosWith: superMessages first).			superMessages remove: superMessages first]</body><body package="Browser-Refactorings">checkSuperMethods	| superMessages nonSupers |	nonSupers := OrderedCollection new.	superMessages := OrderedCollection new.	(selectors reject: [:each | self justSendsSuper: each]) do: 			[:each | 			(self superclassEquivalentlyDefines: each) 				ifTrue: 					[(class parseTreeFor: each) superMessages notEmpty 						ifTrue: [superMessages add: each]]				ifFalse: [nonSupers add: each]].	nonSupers isEmpty &amp; superMessages isEmpty ifTrue: [^self].	self checkReferencesToAnyOf: nonSupers.	self checkReferencesToSuperSendsToAnyOf: superMessages</body><body package="Browser-Refactorings">justSendsSuper: aSelector 	| matcher parseTree superclass |	matcher := ParseTreeSearcher justSendsSuper.	parseTree := class parseTreeFor: aSelector.	(matcher executeTree: parseTree initialAnswer: false) ifFalse: [^false].	parseTree lastIsReturn ifTrue: [^true].	superclass := class superclass whoDefinesMethod: aSelector.	superclass isNil ifTrue: [^true].	"Since there isn't a superclass that implements the message, we can 								 delete it since it would be an error anyway."	parseTree := superclass parseTreeFor: aSelector.	matcher := ParseTreeSearcher new.	matcher matches: '^``@object'		do: 			[:aNode :answer | 			answer				add: aNode value;				yourself].	matcher executeTree: parseTree initialAnswer: Set new.	^matcher answer 		allSatisfy: [:each | each isVariable and: [each name = 'self']]</body><body package="Browser-Refactorings">preconditions	^(selectors inject: Condition empty		into: [:cond :each | cond &amp; (Condition definesSelector: each in: class)]) 			&amp; (Condition withBlock: 						[self checkSuperMethods.						true])</body><body package="Browser-Refactorings">superclassEquivalentlyDefines: aSelector 	| superTree myTree |	class superclass isNil ifTrue: [^false].	superTree := class superclass parseTreeFor: aSelector.	myTree := class parseTreeFor: aSelector.	(superTree isNil or: [myTree isNil]) ifTrue: [^false].	^superTree equalTo: myTree exceptForVariables: #()</body></methods><methods><class-id>Refactory.Browser.RemoveMethodRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream	aStream nextPutAll: 'Remove method refactoring'</body><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' removeMethods: '.	selectors asArray storeOn: aStream.	aStream nextPutAll: ' from: '.	class storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.RemoveMethodRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">removeMethods: selectorCollection from: aClass 	class := self classObjectFor: aClass.	selectors := selectorCollection</body></methods><methods><class-id>Refactory.Browser.RemoveMethodRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">transform	selectors do: [:each | class removeMethod: each]</body></methods><methods><class-id>Refactory.Browser.RemoveMethodRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">model: aRBNameSpace removeMethods: selectorCollection from: aClass 	^(self new)		model: aRBNameSpace;		removeMethods: selectorCollection from: aClass;		yourself</body><body package="Browser-Refactorings">removeMethods: selectorCollection from: aClass 	^(self new)		removeMethods: selectorCollection from: aClass;		yourself</body></methods><methods><class-id>Refactory.Browser.CreateAccessorsForVariableRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">createGetterAccessor	getterMethod := self findGetterMethod.	getterMethod isNil ifTrue: [getterMethod := self defineGetterMethod]</body><body package="Browser-Refactorings">createSetterAccessor	setterMethod := self findSetterMethod.	setterMethod isNil ifTrue: [setterMethod := self defineSetterMethod]</body><body package="Browser-Refactorings">defineGetterMethod	| selector definingClass |	definingClass := self definingClass.	selector := self safeMethodNameFor: definingClass				basedOn: variableName asString.	definingClass		compile: (RBParser				parseMethod: ('&lt;1s&gt;&lt;n&gt;&lt;t&gt;^&lt;2s&gt;' expandMacrosWith: selector						with: variableName))					formattedCode		classified: #(#accessing).	^selector</body><body package="Browser-Refactorings">defineSetterMethod	| selector definingClass string |	definingClass := self definingClass.	string := self needsReturnForSetter				ifTrue: ['&lt;1s&gt; anObject&lt;n&gt;&lt;t&gt;^&lt;2s&gt; := anObject']				ifFalse: ['&lt;1s&gt; anObject&lt;n&gt;&lt;t&gt;&lt;2s&gt; := anObject'].	selector := self safeMethodNameFor: definingClass				basedOn: variableName asString , ':'.	definingClass		compile: (RBParser				parseMethod: (string expandMacrosWith: selector with: variableName))					formattedCode		classified: #accessing.	^selector</body><body package="Browser-Refactorings">transform	self		createGetterAccessor;		createSetterAccessor</body></methods><methods><class-id>Refactory.Browser.CreateAccessorsForVariableRefactoring</class-id> <category>private-accessing</category><body package="Browser-Refactorings">definingClass	^class</body><body package="Browser-Refactorings">findGetterMethod	| definingClass matcher |	definingClass := self definingClass.	matcher := ParseTreeSearcher getterMethod: variableName.	^self possibleGetterSelectors detect: 			[:each | 			(self 				checkClass: definingClass				selector: each				using: matcher) notNil 				and: [(definingClass subclassRedefines: each) not]]		ifNone: [nil]</body><body package="Browser-Refactorings">findSetterMethod	| definingClass matcher |	definingClass := self definingClass.	matcher := self needsReturnForSetter 				ifTrue: [ParseTreeSearcher returnSetterMethod: variableName]				ifFalse: [ParseTreeSearcher setterMethod: variableName].	^self possibleSetterSelectors detect: 			[:each | 			(self 				checkClass: definingClass				selector: each				using: matcher) notNil 				and: [(definingClass subclassRedefines: each) not]]		ifNone: [nil]</body><body package="Browser-Refactorings">getterMethod	^getterMethod</body><body package="Browser-Refactorings">methodsReferencingVariable	^self definingClass whichSelectorsReferToInstanceVariable: variableName</body><body package="Browser-Refactorings">possibleGetterSelectors	^self methodsReferencingVariable select: [:each | each numArgs == 0]</body><body package="Browser-Refactorings">possibleSetterSelectors	^self methodsReferencingVariable select: [:each | each numArgs == 1]</body><body package="Browser-Refactorings">setterMethod	^setterMethod</body></methods><methods><class-id>Refactory.Browser.CreateAccessorsForVariableRefactoring</class-id> <category>testing</category><body package="Browser-Refactorings">needsReturnForSetter	needsReturn isNil 		ifTrue: [needsReturn := self usesAssignmentOf: variableName in: class].	^needsReturn</body><body package="Browser-Refactorings">usesAssignmentOf: aString in: aClass 	| matcher definingClass |	matcher := ParseTreeSearcher new.	matcher		answer: false;		matches: aString , ' := ``@object'			do: [:aNode :answer | answer or: [aNode isUsed]].	definingClass := aClass.	^definingClass withAllSubclasses anySatisfy: 			[:each | 			(each whichSelectorsReferToInstanceVariable: aString) anySatisfy: 					[:sel | 					self 						checkClass: each						selector: sel						using: matcher]]</body></methods><methods><class-id>Refactory.Browser.CreateAccessorsForVariableRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream	aStream nextPutAll: 'Create accessors refactoring'</body></methods><methods><class-id>Refactory.Browser.CreateAccessorsForVariableRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">preconditions	^(Condition definesInstanceVariable: variableName in: class) 		| (Condition canReference: variableName in: class)</body></methods><methods><class-id>Refactory.Browser.RBNegationCondition</class-id> <category>checking</category><body package="Browser-Refactorings">check	^condition check not</body></methods><methods><class-id>Refactory.Browser.RBNegationCondition</class-id> <category>initialize-release</category><body package="Browser-Refactorings">condition: aCondition 	condition := aCondition.	self errorMacro: condition errorMacro</body></methods><methods><class-id>Refactory.Browser.RBNegationCondition</class-id> <category>private</category><body package="Browser-Refactorings">errorBlockFor: aBoolean 	^condition errorBlockFor: aBoolean not</body><body package="Browser-Refactorings">errorStringFor: aBoolean 	^condition errorStringFor: aBoolean not</body></methods><methods><class-id>Refactory.Browser.RBNegationCondition</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	aStream		nextPutAll: 'NOT ';		print: condition</body></methods><methods><class-id>Refactory.Browser.RBNegationCondition class</class-id> <category>instance creation</category><body package="Browser-Refactorings">on: aCondition 	^(self new)		condition: aCondition;		yourself</body></methods><methods><class-id>Refactory.Browser.MoveObjectRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">doLocalMove	"Make the changes to the RB model. This does not change any actual classes yet, but makes the model look like we want it to. This allows the rewrites to see the soon to be view of the world."	targetScope items		at: object name		put: object.	object environment removedItems add: object name.	object parent: targetScope</body><body package="Browser-Refactorings">findReferencesFromObject	fromReferences := Set new.	object		outerReferencingMethodsDo:			[:selector :method | fromReferences add: method]</body><body package="Browser-Refactorings">findReferencesToObject	referencesTo := OrderedCollection new.	self model		allReferencesToObject: object		do:			[:method | method modelClass = object ifFalse: [referencesTo add: method]]</body><body package="Browser-Refactorings">fixReferencesFromObject	fromReferences		do:			[:method | 			self				convertMethod: method				using: (self referenceFromObjectRewriter: method)]</body><body package="Browser-Refactorings">fixReferencesToObject		referencesTo		do:			[:method | 			self				convertMethod: method				using: (self referenceToObjectRewriter: method)]</body><body package="Browser-Refactorings">migrateObject	self model changes		addChange:			(MigrateObjectChange				move: object unambiguousName				to: targetScope unambiguousName)</body><body package="Browser-Refactorings">transform	self findReferencesToObject.	self findReferencesFromObject.	self migrateObject.	self doLocalMove.	self fixReferencesToObject.	self fixReferencesFromObject</body></methods><methods><class-id>Refactory.Browser.MoveObjectRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">move: anObjectName to: aTargetScopeName	"AnObjectName and aTargetScopeName should be results of absoluteName, not fullName."	object := self model fullItemNamed: anObjectName.	originalScope := object environment.	targetScope := self model fullItemNamed: aTargetScopeName</body></methods><methods><class-id>Refactory.Browser.MoveObjectRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">preconditions	^(Condition		withBlock: [object isClassObject not or: [object isMeta not]]		errorString:			(#x1sIsInvalidObjectName &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is not a valid object name'				expandMacrosWith: object name))		&amp;			(Condition				withBlock: [targetScope isClassObject not]				errorString:					(#x1sIsInvalidTargetScope &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is not a valid move target'						expandMacrosWith: targetScope name))</body></methods><methods><class-id>Refactory.Browser.MoveObjectRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	aStream nextPutAll: 'Move object'</body><body package="Browser-Refactorings">storeOn: aStream	aStream		nextPutAll:			('(&lt;1s&gt; moveObjectNamed: &lt;2p&gt; to: &lt;3p&gt;)'				expandMacrosWith: self class unambiguousName				with: object name				with: targetScope name)</body></methods><methods><class-id>Refactory.Browser.MoveObjectRefactoring</class-id> <category>rewriter-references to</category><body package="Browser-Refactorings">initReferencesToRewriter: aParseTreeRewriter toAdjustDottedNamesIn: anRBMethod		aParseTreeRewriter		replace: '`var'		withValueFrom:			[:node | 			| restOfPath originalPath newPath |			originalPath := node name tokensBasedOn: $..			restOfPath := originalPath				allButFirst: (originalPath indexOf: object name asString).			newPath := (object unambiguousName tokensBasedOn: $.) , restOfPath.			(newPath size &gt; 2 and: [newPath first asString = 'Smalltalk'])				ifTrue: [newPath := newPath allButFirst: 1].			RBVariableNode named: (newPath fold: [:a :b | a , '.' , b])]		when:			[:node | 			(node name includes: $.)				and:					[((node name tokensBasedOn: $.) includes: object name asString)						and:							[((self model fullItemNamed: node name)								ifNotNil: [:variable | anRBMethod canReferenceObject: variable]								ifNil: [false]) not or: [(node name first: 2) = '_.']]]]</body><body package="Browser-Refactorings">initReferencesToRewriter: aParseTreeRewriter toExpandSimpleNamesIn: anRBMethod		aParseTreeRewriter		replace: '`var'		withValueFrom: [:node | RBVariableNode named: object unambiguousName]		when:			[:node | 			node name asString = object name asString				and: [(anRBMethod canReferenceObject: object) not]]</body><body package="Browser-Refactorings">initReferencesToRewriter: aParseTreeRewriter toReduceDottedNamesIn: anRBMethod		aParseTreeRewriter		replace: '`var'		withValueFrom: [:node | RBVariableNode named: object name]		when:			[:node | 			(node name includes: $.)				and:					[(node name tokensBasedOn: $.) last = object name asString						and: [anRBMethod canReferenceObject: object]]]</body><body package="Browser-Refactorings">initReferencesToRewriterToFixBindingReferencesIn: aParseTreeRewriter		aParseTreeRewriter		replace: '`#literal'		withValueFrom:			[:node | 			RBLiteralNode				value:					(targetScope realNameSpace fullyQualifiedReferenceOf: node value path last)						makeUnambiguous]		when:			[:node | 			node value isBindingReference				and: [node value refersToLiteral: object binding]]</body><body package="Browser-Refactorings">referenceToObjectRewriter: anRBMethod		| rewriter |	rewriter := ParseTreeRewriter new.	self initReferencesToRewriter: rewriter toExpandSimpleNamesIn: anRBMethod.	self initReferencesToRewriter: rewriter toReduceDottedNamesIn: anRBMethod.	self initReferencesToRewriter: rewriter toAdjustDottedNamesIn: anRBMethod.	self initReferencesToRewriterToFixBindingReferencesIn: rewriter.	^rewriter</body></methods><methods><class-id>Refactory.Browser.MoveObjectRefactoring</class-id> <category>rewriter-references from</category><body package="Browser-Refactorings">initReferenceFromRewriter: aParseTreeRewriter toAdjustBindingReferencesIn: anRBMethod		aParseTreeRewriter		replace: '`#literal'		withValueFrom:			[:node | 			RBLiteralNode				value:					(originalScope realNameSpace						fullyQualifiedReferenceOf: node value path last) makeUnambiguous]		when:			[:node | 			node value isBindingReference				and:					[node value path size = 1						and: [(anRBMethod modelClass canReference: node value path last) not]]]</body><body package="Browser-Refactorings">initReferenceFromRewriter: aParseTreeRewriter toExpandSimpleNamesIn: anRBMethod	aParseTreeRewriter		replace: '`var'		withValueFrom: 			[:node |			| reference |			reference := (originalScope realNameSpace						fullyQualifiedReferenceOf: node name) makeUnambiguous.	"this does not necessarily return a path that represents the definition, just one whereby it can be reached"			reference bindingOrNil				ifNotNil: 					[:binding |					"if we have a binding, then we can further resolve it, by using the actual variable binding to create the reference, rather than an arbitrary one that can reach it"					reference := binding environment fullyQualifiedReferenceOf: binding key].			RBVariableNode named: reference asString]		when: 			[:node |			node isLocalVariable not and: 					[(node name includes: $.) not and: 							[(node name asString = object name asString) not and: 									[(anRBMethod modelClass definesInstanceVariable: node name) not										and: [(anRBMethod modelClass canReference: node name) not]]]]]</body><body package="Browser-Refactorings">initReferenceFromRewriter: aParseTreeRewriter toReducedDottedNamesIn: anRBMethod		aParseTreeRewriter		replace: '`var'		withValueFrom:			[:node | RBVariableNode named: (node name tokensBasedOn: $.) last]		when:			[:node | 			(node name includes: $.)				and:					[| item |					(item := anRBMethod referencedItem: node name) notNil						and:							[item = (anRBMethod referencedItem: (node name tokensBasedOn: $.) last)]]]</body><body package="Browser-Refactorings">initReferenceFromRewriterForRelativeNames: aParseTreeRewriter		aParseTreeRewriter		replace: '`var'		withValueFrom:			[:node | 			| newBinding |			newBinding := BindingReference				path:					originalScope realItem fullyQualifiedReference path						, ((node name tokensBasedOn: $.) allButFirst: 1).	"Strip off redundant Smalltalk"			(newBinding path size &gt; 2				and: [newBinding path first asString = 'Smalltalk'])				ifTrue:					[newBinding := BindingReference path: (newBinding path allButFirst: 1)].			RBVariableNode named: newBinding asString]		when: [:node | (node name first: 2) = '_.']</body><body package="Browser-Refactorings">referenceFromObjectRewriter: anRBMethod	| rewriter |	rewriter := ParseTreeRewriter new.	self initReferenceFromRewriter: rewriter toExpandSimpleNamesIn: anRBMethod.	"expand to dotted names if need be"	self initReferenceFromRewriter: rewriter toReducedDottedNamesIn: anRBMethod.	"next is a rule that turns _. names into true references"	self initReferenceFromRewriterForRelativeNames: rewriter.	"this is for reducing dotted names that don't need to be anymore"	self initReferenceFromRewriter: rewriter		toAdjustBindingReferencesIn: anRBMethod.	"This third condition is for doctoring up #{BindingReferences} that don't have dots"	^rewriter</body></methods><methods><class-id>Refactory.Browser.MoveObjectRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">model: aRBNameSpace moveObjectNamed: anObjectName to: aTargetScopeName	^(self new)		model: aRBNameSpace;		move: anObjectName to: aTargetScopeName;		yourself</body><body package="Browser-Refactorings">moveObjectNamed: anObjectName to: aTargetScopeName	^(self new)		move: anObjectName to: aTargetScopeName;		yourself</body></methods><methods><class-id>Refactory.Browser.AddInstanceVariableRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">transform	class addInstanceVariable: variableName</body></methods><methods><class-id>Refactory.Browser.AddInstanceVariableRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	aStream nextPutAll: 'Add instance variable refactoring'</body></methods><methods><class-id>Refactory.Browser.AddInstanceVariableRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">preconditions	^(Condition isValidInstanceVariableName: variableName for: class) 		&amp; (Condition hierarchyOf: class definesVariable: variableName) not 			&amp; (Condition hierarchyOf: class canAccessVariableNamed: variableName) not</body></methods><methods><class-id>Refactory.Browser.TemporaryToInstanceVariableRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">checkForValidTemporaryVariable	| parseTree |	parseTree := class parseTreeFor: selector.	(parseTree allTemporaryVariables includes: temporaryVariableName) 		ifFalse: 			[self refactoringError: ((#x1sIsInvalidTempName &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; isn''t a valid temporary variable name')			expandMacrosWith: temporaryVariableName)].	(parseTree allArgumentVariables includes: temporaryVariableName) 		ifTrue: 			[self refactoringError: ((#x1sIsABlockParameter &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is a block parameter')			expandMacrosWith: temporaryVariableName)].	(RBReadBeforeWrittenTester isVariable: temporaryVariableName		readBeforeWrittenIn: parseTree) 			ifTrue: 				[self 					refactoringWarning: ((#x1sReadBeforeWrittenProceedQ &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is read before it is written.&lt;n&gt;Proceed anyway?') 							expandMacrosWith: temporaryVariableName)]</body><body package="Browser-Refactorings">preconditions	^(Condition definesSelector: selector in: class) 		&amp; (Condition hierarchyOf: class				definesVariable: temporaryVariableName asString) not 			&amp; (Condition withBlock: 						[self checkForValidTemporaryVariable.						true])</body></methods><methods><class-id>Refactory.Browser.TemporaryToInstanceVariableRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">class: aClass selector: aSelector variable: aVariableName 	class := self classObjectFor: aClass.	selector := aSelector.	temporaryVariableName := aVariableName</body></methods><methods><class-id>Refactory.Browser.TemporaryToInstanceVariableRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream	aStream nextPutAll: 'Convert temporary to instance variable refactoring'</body><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' class: '.	class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: selector;		nextPutAll: ' variable: ''';		nextPutAll: temporaryVariableName;		nextPut: $'.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.TemporaryToInstanceVariableRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">transform	| parseTree matcher method |	method := class methodFor: selector.	parseTree := method parseTree.	parseTree isNil ifTrue: [self refactoringError: (#CouldNotParseMethod &lt;&lt; #browser &gt;&gt; 'Could not parse method')].	class removeMethod: selector.	class addInstanceVariable: temporaryVariableName.	(matcher := ParseTreeRewriter removeTemporaryNamed: temporaryVariableName) 		executeTree: parseTree.	method compileTree: matcher tree</body></methods><methods><class-id>Refactory.Browser.TemporaryToInstanceVariableRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">class: aClass selector: aSelector variable: aVariableName 	^(self new)		class: aClass			selector: aSelector			variable: aVariableName;		yourself</body><body package="Browser-Refactorings">model: aRBNameSpace class: aClass selector: aSelector variable: aVariableName 	^(self new)		model: aRBNameSpace;		class: aClass			selector: aSelector			variable: aVariableName;		yourself</body></methods><methods><class-id>Refactory.Browser.ChildrenToSiblingsRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">addSuperclass	"If we handled attributes as we do imports, updating the RBClass at the end after the component refactoring is done instead of including them in that refactoring, then the execution sequence would be:  add abstract superclass, then make parent its subclass, then add attributes to abstract superclass;  the intermediate step would fail in #relinkToNewSuperRemovingOld: as super momentarily lacked attributes."	| newClass |	self performComponentRefactoring:		(AddClassRefactoring			model: self model			addClass: className			superclass: parent superclass			subclasses: (Array with: parent)			attributes: parent extraAttributesForDefinition).	newClass := self abstractSuperclass.	parent imports do:		[:each |		(parent extraAttributesForDefinition isEmpty		or: [each name asString ~= (parent name, 'Dictionary')		or: [each environmentName asString ~= parent environment fullName]])			ifTrue: [newClass addImport: each]].</body><body package="Browser-Refactorings">changeIsKindOfReferences	| replacer |	replacer := (ParseTreeRewriter new)				replace: '``@rcv isKindOf: ' , parent name					with: '``@rcv isKindOf: ' , self definitionName					when: [:node | self methodClass canAccess: parent];				replace: '``@rcv isKindOf: `var'					withValueFrom: 						[:aNode | 						aNode 							arguments: (Array with: (self 											replaceFullReferenceTo: parent											inVariable: aNode arguments first											toBe: self definitionName)).						aNode]					when: 						[:node | 						(node arguments first name includes: $.) 							and: [self methodClass doesName: node arguments first name includeObject: parent]];				replaceArgument: self definitionName					withValueFrom: 						[:aNode | 						self refactoringError: ((#x1sAlreadyExistsInScope &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; already exists within the reference scope')			expandMacrosWith: self definitionName)];				yourself.	self convertAllReferencesToObject: parent using: replacer</body><body package="Browser-Refactorings">pushUpMethods	self pushUpMethodsFrom: parent.	self pushUpMethodsFrom: parent metaclass</body><body package="Browser-Refactorings">pushUpVariables	self pullUpInstanceVariables.	self pullUpClassInstanceVariables.	self pullUpSharedVariables</body><body package="Browser-Refactorings">reparentSubclasses	self model reparentClasses: subclasses to: self abstractSuperclass</body><body package="Browser-Refactorings">transform	self		addSuperclass;		pushUpVariables;		pushUpMethods;		changeIsKindOfReferences;		reparentSubclasses</body></methods><methods><class-id>Refactory.Browser.ChildrenToSiblingsRefactoring</class-id> <category>private-methods</category><body package="Browser-Refactorings">computeSubclassSupersOf: aClass 	| selectors |	selectors := Set new.	aClass subclasses do: 			[:each | 			each selectors 				do: [:sel | selectors addAll: (each parseTreeFor: sel) superMessages]].	^selectors</body><body package="Browser-Refactorings">createSubclassResponsibilityFor: aSelector in: aClass 	| source |	(aClass superclass definesMethod: aSelector) ifTrue: [^self].	source := self subclassResponsibilityFor: aSelector in: aClass.	source isNil ifTrue: [^self].	aClass superclass compile: source		withAttributesFrom: (aClass methodFor: aSelector)</body><body package="Browser-Refactorings">pushUp: aSelector in: aClass 	| source |	source := aClass sourceCodeFor: aSelector.	source isNil 		ifFalse: 			[aClass superclass compile: source				withAttributesFrom: (aClass methodFor: aSelector)]</body><body package="Browser-Refactorings">pushUpMethodsFrom: aClass 	| selectorsToPushUp |	selectorsToPushUp := self selectorsToPushUpFrom: aClass.	aClass selectors do: 			[:each | 			(selectorsToPushUp includes: each) 				ifTrue: [self pushUp: each in: aClass]				ifFalse: [self createSubclassResponsibilityFor: each in: aClass]].	selectorsToPushUp do: [:each | aClass removeMethod: each]</body><body package="Browser-Refactorings">selectorsToPushUpFrom: aClass 	| superSelectors |	superSelectors := self computeSubclassSupersOf: aClass.	^aClass selectors select: 			[:each | 			(superSelectors includes: each) or: [self shouldPushUp: each from: aClass]]</body><body package="Browser-Refactorings">shouldPushUp: aSelector from: aClass 	^(aClass isMeta 		ifTrue: [subclasses collect: [:each | each metaclass]]		ifFalse: [subclasses]) 			anySatisfy: [:each | (each directlyDefinesMethod: aSelector) not]</body><body package="Browser-Refactorings">subclassResponsibilityFor: aSelector in: aClass 	| methodNode position source |	source := aClass sourceCodeFor: aSelector.	methodNode := RBParser parseMethod: source onError: [:err :pos | ^nil].	position := methodNode arguments isEmpty 				ifTrue: [methodNode selectorParts last stop]				ifFalse: [methodNode arguments last stop].	^'&lt;1s&gt;&lt;n&gt;&lt;t&gt;self subclassResponsibility' 		expandMacrosWith: (source copyFrom: 1 to: position)</body></methods><methods><class-id>Refactory.Browser.ChildrenToSiblingsRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">name: aClassName class: aClass subclasses: subclassCollection 	className := aClassName asSymbol.	parent := self model classFor: aClass.	subclasses := subclassCollection 				collect: [:each | self model classFor: each]</body></methods><methods><class-id>Refactory.Browser.ChildrenToSiblingsRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	aStream nextPutAll: 'Convert children to siblings refactoring'</body><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' name: #''';		nextPutAll: className;		nextPutAll: ''' class: '.	parent storeOn: aStream.	aStream nextPutAll: ' subclasses: '.	subclasses asArray storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.ChildrenToSiblingsRefactoring</class-id> <category>private-variables</category><body package="Browser-Refactorings">pullUpClassInstanceVariables	| newSuperclass |	newSuperclass := self abstractSuperclass metaclass.	parent metaclass instanceVariableNames do: 			[:each | 			self performComponentRefactoring: (PullUpInstanceVariableRefactoring 						model: self model						variable: each						class: newSuperclass)]</body><body package="Browser-Refactorings">pullUpInstanceVariables	| newSuperclass |	newSuperclass := self abstractSuperclass.	parent instanceVariableNames do: 			[:each | 			self performComponentRefactoring: (PullUpInstanceVariableRefactoring 						model: self model						variable: each						class: newSuperclass)]</body><body package="Browser-Refactorings">pullUpSharedVariables	| newSuperclass |	newSuperclass := self abstractSuperclass.	parent sharedVariableNames do: 			[:each | 			| sv definition |			sv := parent referencedItem: each.			definition := RBParser parseExpression: sv definitionString.			self model removeObject: sv.			definition receiver: (RBVariableNode named: newSuperclass unambiguousName).			self model defineSharedVariable: definition formattedCode]</body></methods><methods><class-id>Refactory.Browser.ChildrenToSiblingsRefactoring</class-id> <category>private-accessing</category><body package="Browser-Refactorings">abstractSuperclass	^self model classNamed: className</body></methods><methods><class-id>Refactory.Browser.ChildrenToSiblingsRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">preconditions	^subclasses 		inject: ((Condition isMetaclass: parent) 				errorMacro: (#SuperMustNotBeMeta &lt;&lt; #browser &gt;&gt; 'Superclass must not be a metaclass') asString) not		into: 			[:sub :each | 			sub 				&amp; ((Condition isMetaclass: each) 						errorMacro: (#SubMust1QBeMeta &lt;&lt; #browser &gt;&gt; 'Subclass must &lt;1?not :&gt;be a metaclass') asString) not 					&amp; (Condition isImmediateSubclass: each of: parent)]</body></methods><methods><class-id>Refactory.Browser.ChildrenToSiblingsRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">model: aRBNameSpace name: aClassName class: aClass subclasses: subclassCollection 	^(self new)		model: aRBNameSpace;		name: aClassName			class: aClass			subclasses: subclassCollection;		yourself</body><body package="Browser-Refactorings">name: aClassName class: aClass subclasses: subclassCollection 	^(self new)		name: aClassName			class: aClass			subclasses: subclassCollection;		yourself</body></methods><methods><class-id>Refactory.Browser.RemoveObjectRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">hasReferencesTo: aRBProgramItem 	model allReferencesToObject: aRBProgramItem do: [:each | ^true].	^false</body><body package="Browser-Refactorings">preconditions	^objectNames inject: Condition empty		into: 			[:sum :each | 			| item |			item := self model fullItemNamed: each.			item isNil ifTrue: [self refactoringError: (#NoSuchObject &lt;&lt; #browser &gt;&gt; 'No such object')].			sum 				&amp; (Condition withBlock: 							[(self hasReferencesTo: item) 								ifTrue: 									[self refactoringError: ((#x1IsReferencedBrowseQ &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is referenced.%&lt;n%&gt;Browse references?')			expandMacrosWith: each) 												expandMacros										with: 											[self openBrowserOn: (BrowserEnvironment new referencesTo: item binding)]].							item isNameSpace 								ifTrue: 									[item definesAnyItem 										ifTrue: 											[self refactoringError: ((#x1sDefinesOtherObjects &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is not empty. It defines other shared variables, name spaces, or classes')			expandMacrosWith: each)].									item isClassObject 										ifTrue: 											[(item instanceVariableNames isEmpty and: 													[item selectors isEmpty and: 															[item metaclass instanceVariableNames isEmpty 																and: [item metaclass selectors isEmpty]]]) 												ifFalse: 													[item subclasses notEmpty 														ifTrue: 															[self 																refactoringError: (#CannotRemoveWithInstVarsAndSubclasses &lt;&lt; #browser &gt;&gt; 'Cannot remove class that defines instance variables or methods when it has subclasses.')]].											(item subclasses notEmpty  and: [item superclass isNil]) 												ifTrue: 													[self 														refactoringError: (#CannotRemoveTopWithSubclasses &lt;&lt; #browser &gt;&gt; 'Cannot remove top level class when it has subclasses')]]].							true])]</body></methods><methods><class-id>Refactory.Browser.RemoveObjectRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">objectNames: aStringCollection 	objectNames := aStringCollection</body></methods><methods><class-id>Refactory.Browser.RemoveObjectRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">removeClasses	objectNames do: [:each | self model removeObjectNamed: each]</body><body package="Browser-Refactorings">reparentSubclasses	objectNames do: 			[:each | 			| class |			class := self model classNamed: each.			class notNil 				ifTrue: 					[self model reparentClasses: class subclasses copy to: class superclass]]</body><body package="Browser-Refactorings">transform	self		reparentSubclasses;		removeClasses</body></methods><methods><class-id>Refactory.Browser.RemoveObjectRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream	aStream nextPutAll: 'Remove object refactoring'</body><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' objectNames: '.	objectNames asArray storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.RemoveObjectRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">model: aRBNameSpace objectNames: aStringCollection 	^(self new)		model: aRBNameSpace;		objectNames: aStringCollection;		yourself</body><body package="Browser-Refactorings">objectNames: aStringCollection 	^(self new)		objectNames: aStringCollection;		yourself</body></methods><methods><class-id>Refactory.Browser.PushDownInstanceVariableRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream	aStream nextPutAll: 'Push down instance variable refactoring'</body></methods><methods><class-id>Refactory.Browser.PushDownInstanceVariableRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">transform	| classesToPushInto |	class removeInstanceVariable: variableName.	classesToPushInto := class subclasses reject:		[:each | 		each withAllSubclasses allSatisfy: 			[:aClass | 			(aClass whichSelectorsReferToInstanceVariable: variableName) isEmpty]].	classesToPushInto isEmpty ifTrue:		[self refactoringWarning: (#PushingDownWillRemoveVariableProceedQ &lt;&lt; #browser &gt;&gt; 'None of the subclasses use this variable.&lt;n&gt;Pushing down will remove it. Proceed?') expandMacros].	classesToPushInto do: [:each | each addInstanceVariable: variableName]</body></methods><methods><class-id>Refactory.Browser.PushDownInstanceVariableRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">preconditions	| references |	references := Condition referencesInstanceVariable: variableName in: class.	class realClass isNil 		ifTrue: 			[references 				errorMacro: ((#x1sIsReferenced &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is referenced.') expandMacrosWith: variableName)]		ifFalse: 			[references				errorMacro: ((#x1sIsReferencedBrowseQ &lt;&lt; #browser &gt;&gt; '&lt;1s&gt; is referenced.&lt;n&gt;Browse references?') 							expandMacrosWith: variableName);				errorBlock: 						[self openBrowserOn: (BrowserEnvironment new instVarRefsTo: variableName									in: class realClass)]].	^(Condition definesInstanceVariable: variableName in: class) 		&amp; references not</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">transform	refactorings do: [:each | self performComponentRefactoring: each]</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">preconditions	"Preconditions are checked on the component refactorings."	^Condition empty</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">initialize	super initialize.	refactorings := #()</body><body package="Browser-Refactorings">refactorings: aCollection 	| oldName |	oldName := self printString.	refactorings := aCollection.	(model notNil and: [model description = oldName]) 		ifTrue: [model description: self printString]</body></methods><methods><class-id>Refactory.Browser.CompositeRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	refactorings isEmpty ifTrue: [^super printOn: aStream].	refactorings first printOn: aStream</body></methods><methods><class-id>Refactory.Browser.AddMethodRefactoring</class-id> <category>initialize-release</category><body package="Browser-Refactorings">addMethod: aString toClass: aClass inProtocols: protocolList 	class := self classObjectFor: aClass.	source := aString.	protocols := protocolList</body></methods><methods><class-id>Refactory.Browser.AddMethodRefactoring</class-id> <category>printing</category><body package="Browser-Refactorings">printOn: aStream 	aStream nextPutAll: 'Add method refactoring'</body><body package="Browser-Refactorings">storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' addMethod: ''';		nextPutAll: source;		nextPutAll: ''' toClass: '.	class storeOn: aStream.	aStream nextPutAll: ' inProtocols: '.	protocols storeOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>Refactory.Browser.AddMethodRefactoring</class-id> <category>transforming</category><body package="Browser-Refactorings">transform	class compile: source classified: protocols</body></methods><methods><class-id>Refactory.Browser.AddMethodRefactoring</class-id> <category>preconditions</category><body package="Browser-Refactorings">preconditions	| selector method |	method := RBParser parseMethod: source				onError: 					[:string :position | 					^Condition 						withBlock: [self refactoringError: (#SourcesCouldNotBeParsed &lt;&lt; #browser &gt;&gt; 'The sources could not be parsed')]].	selector := method selector.	selector isNil ifTrue: [self refactoringError: (#InvalidSource &lt;&lt; #browser &gt;&gt; 'Invalid source.')].	^(Condition canUnderstand: selector in: class) not</body></methods><methods><class-id>Refactory.Browser.AddMethodRefactoring class</class-id> <category>instance creation</category><body package="Browser-Refactorings">addMethod: aString toClass: aClass inProtocols: protocolList 	^(self new)		addMethod: aString			toClass: aClass			inProtocols: protocolList;		yourself</body><body package="Browser-Refactorings">model: aRBNameSpace addMethod: aString toClass: aClass inProtocols: protocolList 	^(self new)		model: aRBNameSpace;		addMethod: aString			toClass: aClass			inProtocols: protocolList;		yourself</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>accessing-literals</category><body package="Browser-Refactorings">hasOuterVariables	self		allLiteralsDo:			[:each | (each isVariableBinding or: [each isBindingReference]) ifTrue: [^true]].	^false</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>RefactoringBrowser</category><body package="Browser-Refactorings">withAllEnvironments	| envs env |	envs := OrderedCollection new.	env := self.	[env isNil] whileFalse: 			[envs add: env.			env := env environment].	^envs</body></methods><methods><class-id>Core.Behavior</class-id> <category>RefactoringBrowser</category><body package="Browser-Refactorings">outerReferencingMethodsDo: aBlock	"Enumerate all methods which contain variable bindings beyond the instance variable scope. aBlock takes the selector and method for which this is true."	methodDict		keysAndValuesDo:			[:selector :method | method hasOuterVariables ifTrue: [aBlock value: selector value: method]]</body><body package="Browser-Refactorings">whichClassDefinesInstVar: aString 	^self whichClassSatisfies: [:aClass | aClass instVarNames includes: aString]</body><body package="Browser-Refactorings">whichClassDefinesSharedVariable: aSymbol 	^self 		whichClassSatisfies: [:aClass | aClass asNameSpace includesKey: aSymbol]</body><body package="Browser-Refactorings">whichClassSatisfies: aBlock 	(aBlock value: self) ifTrue: [^self].	^superclass isNil 		ifTrue: [nil]		ifFalse: [superclass whichClassSatisfies: aBlock]</body></methods><methods><class-id>Refactory.Browser.RenameObjectAndMethodsRefactoring class</class-id> <category>pragmas</category><body package="Browser-Refactorings">pragmas	&lt;pragmas: #instance&gt;	^#(classNameInSelectorPatterns:)</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CompiledCode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>bytes </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>NameSpace</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class></st-source>