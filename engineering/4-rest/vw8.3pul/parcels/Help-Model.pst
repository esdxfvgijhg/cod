<?xml version="1.0"?><st-source><!-- Name: Help-ModelNotice: Copyright 2017 Cincom Systems, Inc.  All rights reserved.Comment: This package contains the domain objects for modeling and parsing the contents of a DITA file.DbIdentifier: bear73DbTrace: 502950DbUsername: cgundelDbVersion: 8.3 - 9DevelopmentPrerequisites: #(#(#any 'HTTP' '') #(#any 'URISupport' '') #(#any 'ImageReaders' ''))PackageName: Help-ModelParcel: #('Help-Model')ParcelName: Help-ModelPrerequisiteDescriptions: #(#(#name 'HTTP' #componentType #package) #(#name 'URISupport' #componentType #package) #(#name 'ImageReaders' #componentType #package))PrerequisiteParcels: #(#('HTTP' '') #('URISupport' '') #('ImageReaders' ''))PrintStringCache: (8.3 - 9,cgundel)Version: 8.3 - 9Date: 3:30:14 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:30:14 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Help</name><environment>Smalltalk</environment><private>false</private><imports>			private Core.*			private UI.*			private Graphics.*			</imports><category></category><attributes><package>Help-Model</package></attributes></name-space><class><name>DocumentationStyles</name><environment>Help</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fontSelectors styleSelectors fonts styles formattingFonts formattingFontSelectors </inst-vars><class-inst-vars>default </class-inst-vars><imports>			Text2.*			</imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.DocumentationStyles</class-id><body>This class defines the basic styles used by the documentation system.OverviewClass DocumentationStyles includes a number of class-side methods to generate predefined Text2 DocumentStyle objects. For this purpose, class DocumentationStyles does not need to be instantiated by a DITAToText2Writer. If it is necessary to modify and particularize one of these predefined DocumentStyle objects, a copy is made inside DITAToText2Writer, and that in turn gets manipulated.ImplementationThe shared variable DocumentStyles is used as a cache for Text2 DocumentStyle objects. Each unique style is keyed using a Symbol, such that a minimal number of DocumentStyle objects can be used for every Text2 document that is generated during conversion by class DITAToText2Writer.</body></comment><class><name>DitaRenderer</name><environment>Help</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>canvas tagMap currentStyle headingLevel trimSeparators lineIndent showFontNames keepWhiteSpace linkResolutionBlock ignoreEmptyText ditaObject beginningOfBlock insideLI elementStack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.DitaRenderer</class-id><body>DitaRenderer creates a Test2.Document using a DocumentCanvas. It produces the document from XML.Element objects.Usage	DitaRenderer documentForElement: anXMLElementInstance Variables:	canvas		&lt;DocumentCanvas&gt;	the object that creates the Document	currentStyle	&lt;DocumentStyle&gt;		the style that's being applied when text is rendered	headingLevel	&lt;ArithmeticValue&gt;		the level of heading (temporaily incremented in #increaseHeadingWhile:)	lineIndent		&lt;ArithmeticValue&gt;	the current number of pixels that the lines are indented. (temporarily incremented in #indentWhile:)	showFontNames 	&lt;Boolean&gt; 		if true, the resolved font names will be put in the hover-help of text	tagMap			&lt;Dictionary&gt;		maps element-tags to selectors (like "li" to #renderLI:)	trimSeparators		&lt;Boolean&gt;		if true, the next text that is rendered, will be trimmed of its separators	keepWhiteSpace 	&lt;Boolean&gt; 		if true, whitespaces are kept	linkResolutionBlock 	&lt;BlockClosure&gt; 	block that's called when a link is clicked	ignoreEmptyText 	&lt;Boolean&gt;		if true, empty text is not printed. 	ditaObject 		&lt;DitaTopic&gt; 		the dita topic that's currently rendered. Used to resolve links to images	beginningOfBlock 	&lt;Boolean&gt; 		true if a group is rendered and the first element has not been rendered.									used to clean up empty text at the beginning of a bloc	insideLI 			&lt;Boolean&gt; 		true while a LI is rendered	elementStack		&lt;OrderedCollection&gt; 	stores the stack of the rendered elements. Used in the inspector									 to see where the renderer is.</body></comment><class><name>DitaObject</name><environment>Help</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourcePosition file searchString searchTrie </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.DitaObject</class-id><body>DitaObject is an abstract object that represents the DITA data read from an XML file.Instance Variables:	file				&lt;DitaFile&gt;		the file that defines this object. 	sourcePosition		&lt;Integer&gt;		the byte-position in &lt;file&gt; where this object's xml starts	searchString 		&lt;Strring&gt; 		the string on which the seach is performed.	searchTrie 		&lt;StringTrie&gt;	the trie that makes the search perform in reasonable time.</body></comment><class><name>DitaGroup</name><environment>Help</environment><super>Help.DitaObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>topics </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.DitaGroup</class-id><body>DitaGroup is a DitaObject that contains other topicsInstance Variables:	topics	&lt;(SequenceableCollection of: DitaTopic)&gt;	the topics that are sub-elements of this object</body></comment><class><name>DitaNamedGroup</name><environment>Help</environment><super>Help.DitaGroup</super><private>false</private><indexed-type>none</indexed-type><inst-vars>title chunkCombination chunkSelection chunkRendering </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.DitaNamedGroup</class-id><body>DitaNamedGroup is a group that has a title stored in a &lt;title&gt; element or in a "title" attribute. Subclasses take care of choosing the right method to extract the topic. This class also takes care of the #chunk-attributeInstance Variables:	chunkCombination	&lt;Symbol&gt;		value of the "chunk" attribute with the "by-" prefix	chunkRendering		&lt;Symbol&gt; 	value of the "chunk" attribute with the "to-" prefix	chunkSelection		&lt;Symbol&gt;		value of the "chunk" attribute with the "select-" prefix	title	&lt;String&gt;					the title of the object. </body></comment><class><name>DitaTopic</name><environment>Help</environment><super>Help.DitaNamedGroup</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.DitaTopic</class-id><body>DitaTopic represents a &lt;topic&gt; objectInstance Variables:	id	&lt;String&gt;	the id of the topic as defined in the XML file. Topics can be resolved using URLs that have a fragme that specifies the ID of a topic like "file.dita#topicId"</body></comment><class><name>DitaGlossaryEntry</name><environment>Help</environment><super>Help.DitaTopic</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.DitaGlossaryEntry</class-id><body>DitaGlossaryEntry represents a &lt;glossentry&gt; object</body></comment><class><name>DitaSaxStackNode</name><environment>Help</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent object name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.DitaSaxStackNode</class-id><body>DitaSaxStackNode is an object used by the DitaSaxDriver. The driver creates one node for each new element-level in the xml file. Each node can have an object. This object will be used for feed it character-data from the xml-files. When a node is popped from the stack, it'll ask its parent's object to do something with its own object so that the created objects are properly linked hierarchically.Instance Variables:	name	&lt;String&gt;		name of the xml-element for which this node was created	object	&lt;DitaObject&gt;	a dita-object that was created to represent the xml-element	parent	&lt;DitaSaxStackNode | nil&gt;	the parent node on the stack.</body></comment><class><name>ScratchPad</name><environment>Help</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>window </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.ScratchPad</class-id><body>ScratchPad is used mainly by Examples in the Help content in order to draw on a GraphicsContext. It opens a window with a certain extent and its window can provide a graphicsContext to draw to.Usage	"open or reopen the scratch-window with default extent. Returns the ScheduledWindow"	ScratchPad prepareWindow	"open or reopen the scratch-window with custom extent. Returns the ScheduledWindow"	ScratchPad prepareWindowOfSize: 600 @ 200Instance Variables:	window 		&lt;ScheduledWindow&gt; 		the scratch pad window</body></comment><class><name>DitaRelTable</name><environment>Help</environment><super>Help.DitaNamedGroup</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.DitaRelTable</class-id><body>DitaRelTable represents a &lt;reltable&gt; object</body></comment><class><name>WordGroupMatch</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>wordMatches bestIndices </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Core.WordGroupMatch</class-id><body>WordGroupMatch provides comparable metrics for how close words are inside a string. It works on WordMatch objects that know where in the string their words were found.These criteria are: 	#numberOfMatches -- returns the number of words that were found (not the number of how often they were found, that's what #totalNumberOfWords does)	#averageDistance -- return how many characters the word are appart from each other (in average)	#totalNumberOfWords -- returns how many words were found in the search string, accumulating all occurances.The main problem that this class solves is to find out which touple of words is closest to each other in a string where multiple occurances of these words can be found.This algorithm is implemented in #computeBestIndicesConsider the following example: (implemented in WordGroupMatch class&gt;&gt;example)	searchTrie := 'Alice, Bob and Charly go to a bar. Alice and Bob know each other since they were kids. Charly and Bob work together in the same company. Alice and Charly met at Bob''s birthday party.' asStringTrie.	alices := searchTrie indicesForWord: 'Alice'. "=&gt; #(0 35 137)"	bobs := searchTrie indicesForWord: 'Bob'.  "=&gt; #(7 45 98 161)"	charlies := searchTrie indicesForWord: 'Charly'. "=&gt; #(15 87 147)"To find out all the combinations of Alice, Bob and Charly in this text a Scan-Line-Algorithm is used that stops at the beginnings of matches:	indices := (alices , bobs , charlies) sorted.the idea is to see which occurance of Alice, Bob or Charly are nearest to the current index. For that ReadStreams are created on the indices for each word.	aliceRs := alices readStream.	bobRs := bobs readStream.	charlyRs := charlies readStream.At the beginning the last index for each word is the next index.	aliceLast := aliceRs next.	bobLast := bobRs next.	charlyLast := charlyRs next.	possibleCombinations := OrderedCollection with: (Array with: aliceLast with: bobLast with: charlyLast).The loop then tests if the distance from last is further than the distance to the next. If it is, the next index is used. After that was done for all words, remember the current indices.	(aliceLast - index) abs &gt; (aliceRs peek - index) abs ifTrue:[aliceLast := aliceRs next.].	currentAlice := aliceLast.	...	currentIndices := Array with: currentAlice with: currentBob with: currentCharly.	possibleCombinations add: currentIndicesThis is repeated for all indices. At the end, the best combination is choosen	sortedCombinations := possibleCombinations sorted:[:each | self averageDistanceBetween: each inWords: #('Alice' 'Bob' 'Charly')] ascending.	bestCombination := sortedCombinations first. "=&gt; #(0 7 15)"To debug the algorithm on the example use the following:	WordGroupMatch exampleInstance Variables:	bestIndices	&lt;Array of: Integer&gt;			the starting locations of words so that their distances are smallest. The result of the algorithm	wordMatches	&lt;Array of: WordMatch&gt;		the words with their occurances. The input data to the algorithm.</body></comment><class><name>StringTrie</name><environment>Help</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rootNode searchString wordCount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.StringTrie</class-id><body>StringTrie is a Trie structure for Strings, used for searching text. Their data is stored in StringTreeNode objects. Each node is like a dictionary of characters to other StringTreeNodes. Each node also stores a collection of numbers. The path from the rootNode to another node describes a word. Each node stores the indices where this word was found in the search-string.Each Trie also remebers its searchString so that it can be converted back to that string if needed (like when it needs to be displayed).Usage	|trie|	trie := CaseInsensitiveStringTrie fromString:'Alice and Bob try to send a package of almond ice to Charly'.	trie indicesForWord:'to'. "=&gt;  #(18 50)"	trie indicesForWord:'ice'. "=&gt; #(46) -- alice contains ice, but doesn't begin with it"	trie indicesForWord:'al'. "=&gt; #(0 39) -- both alice and almond start with 'al' "Instance Variables:	rootNode		&lt;StringTreeNode&gt;	the node that stores the indices for the empty string. From it all other nodes follow.	searchString	&lt;CharacterArray&gt;	the string from which this Trie was created	wordCount 	&lt;Integer&gt; 		number of words, used to compute the term frequency of words</body></comment><class><name>WordMatch</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>word matches termFrequency </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Core.WordMatch</class-id><body>WordMatch is like a Bag for occurances of a word in a search-string. It knows its word and it knows the indices where these words were found in a string.Instance Variables:	matches	&lt;(SequenceableCollection of: Number)&gt;		the indices where &lt;word&gt; was found in the searched String.	word	&lt;String&gt;								the word that was searched	termFrequency 	&lt;Number&gt; 					how often did the word appear in the searched text relative to the number of words in the searched text</body></comment><class><name>CaseInsensitiveStringTrie</name><environment>Help</environment><super>Help.StringTrie</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.CaseInsensitiveStringTrie</class-id><body>CaseInsensitiveStringTrie stores its word in all uppercase</body></comment><class><name>MultiWordFuzzyStringSearch</name><environment>Core</environment><super>Core.FuzzyStringSearch</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Core.MultiWordFuzzyStringSearch</class-id><body>MultiWordFuzzyStringSearch is a match algorithm that finds words in a string, not necessarily starting at the beginning.It relies on WordMatch and WordGroupMatch. WordMatch knows where a word (part of the &lt;criteria&gt;) is found in another string (the suggested search-string).The WordMatches are then used by the WordGroupMatch to identify which words are closest to each other and thus help score one match (a collection of WordMatch objects) against another match.The MultiWordFuzzyStringSearch uses the StringTrie object for improved search-performance. The provided suggestions and &lt;criteria&gt; are sent #asStringTrie before they are used for matching. That allows the MultiWordFuzzyStringSearch to be used with either Strings or precomputed StringTrie objects. As StringTries can be case-insensitive, case-insensitive matching is also supported.Usage	"the following code will show that &lt;..quick brown fox...&gt; is closer to the search criteria than &lt;...quick brown yellow or blue fox...&gt;	but both examples are matches.	&lt;the brown cat...&gt; is also a match, but scores even lower than &lt;...quick brown yellow or blue fox...&gt;.	&lt;cats are not dogs&gt; is not matched at all."	| search |	search := MultiWordFuzzyStringSearch criteria: 'brown fox'.	search searchIn:'The quick brown fox jumps of the lazy dog' for: #a as: #type.	search searchIn:'the quick brown yellow or blue fox lives a lazy life' for: #b as: #type.	search searchIn: 'the brown cat likes to play' for: #c as:#type.	search searchIn:'cats are not dogs' for:#d as: #type.	search suggestions inspect</body></comment><class><name>DocumentCanvas</name><environment>Help</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>document listItemStack listNumberStack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.DocumentCanvas</class-id><body>DocumentCanvas is a class that allows for creating a Text2.Document using a streaming API. It performes all changes on a Text2.Document instance and the instance can be queried any time using #documentUsage	DocumentCanvas new 		appendHeading:'Hello World';		appendParagraph:'it sure is nice to be here';		documentInstance Variables:	document		&lt;Document&gt;		the document that's being filled	listItemStack	&lt;OrderedCollection&gt;	stores the list-item segments that are currently active. calling #appendListItem:* will insert a new list-item to the top-most list by using the last object on the stack.	listNumberStack &lt;OrderedCollection&gt; 	stores the list-item numbers. calling #appendListItem:style: will count the last element up.								If a new document is created between two listItems, their numbering should still be								consistent. Thus their numbering is made explicit using this stack.</body></comment><class><name>APINameKind</name><environment>Help</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>kind description handlerBlock testBlock name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.APINameKind</class-id><body>APINameKind is an object that describes a kind of API. It is used to render the &lt;apiname&gt; dita tag.Example apiname tag:	&lt;apiname&gt;Collection&lt;/apiname&gt; &lt;- refers to the binding Collection	&lt;apiname otherprops="pundle" title="Open a browser on the Collections component"&gt;Collections&lt;/apiname&gt;  &lt;- explicitly refers to the pundle, also provides a tooltipThe idea is that an apiname tag can explicitly define which kind of api is meant. If it doesn't, a heursitic is used to determine the kind of api.Instances are created using: #named:description:if:handleWith:. This is however done only in Pragma methods on class-side which are automatically executed as part of #apinameKind:named:. This method will either return the right APINameKind that matches the kind and string or it returns nil if nothing appropriate was found.Usage	| nameKind |	"create a namekind of this package"	nameKind := APINameKind apinameKind: #pundle named:'Help-Model'.	"returns the description of what's done when the nameKind is handled"	nameKind description inspect.	"open the browser on the pundle"	nameKind handle.Instance Variables:	description	&lt;String&gt;					a tooltip kind of help-text for what happens when this nameKind is handled	handlerBlock	&lt;BlockClosure value: String&gt;	the block that is executed when this nameKind is handled	kind			&lt;Symbol&gt;				symbol describing the kind of apiname	name 		&lt;String&gt; 					once the instance is chosen to handle a string, this is stored in &lt;name&gt; so											that it doesn't need to be passed to the handlerBlock from outside.	testBlock		&lt;BlockClosure value: String&gt;	the block that determines if this nameKind can handle a certain name</body></comment><class><name>DitaFolder</name><environment>Help</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>files path rootMap images </inst-vars><class-inst-vars>lastFolder </class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.DitaFolder</class-id><body>DitaFolder contains all DitaFiles that are read from a folder. On instantiation it'll parse all files and remember them as DitaFile objects in a dictionary.Instance Variables:	files		&lt;Dictionary key: URI value: DitaFile&gt;		the files of the folder, stored by their relative URLs	path		&lt;Filename&gt;							path of the folder	rootMap	&lt;DitaRootMap&gt;						the rootMap of the folder	images 	&lt;Dictionary key: Filename value: Image&gt; 	the images by their pathClass Instance Variables:	lastFolder &lt;DitaFolder&gt;		the last parsed folder. Typically the folder doesn't change so it's a good canditate for caching</body></comment><class><name>DitaFile</name><environment>Help</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rootObject folder url dtd </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.DitaFile</class-id><body>DitaFile represents a file containing dita information. The file knows its folder and has a URL. As a result it can resolve urls to access DitaObjects. It can also access the file to return the XML-Data of a DitaObject, given the DitaObject's source-position.Instance Variables:	dtd		&lt;XML.DocumentType&gt;	the document-type. Stored to initialize the XMLParser that reads the xml of an object. The parser will start at any given position in the file, 								it needs to know the dtd because it doesn't read it itself.	folder	&lt;DitaFolder&gt;			the folder of all files, used to resolve URLs	rootObject	&lt;DitaGroup&gt;			the first dita object in the file	url		&lt;URI&gt;				the URI of the file. The URI is relative to the folder</body></comment><class><name>DitaTopicRef</name><environment>Help</environment><super>Help.DitaNamedGroup</super><private>false</private><indexed-type>none</indexed-type><inst-vars>href type format </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.DitaTopicRef</class-id><body>DitaTopicRef represents a &lt;topicref&gt; object. Instance Variables:	href		&lt;String&gt;	the url to the referenced topic. taken from the "href" xml-attribute.	type 	&lt;String&gt;	the type of the reference (typically 'topic'). taken from the "type" xml-attribute	format 	&lt;String&gt; 	the format of the reference (could be 'ditamap'). taken from the "format" xml-attribute</body></comment><class><name>HelpNotFoundError</name><environment>Help</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.HelpNotFoundError</class-id><body>HelpNotFoundError is raised when the help folder was not found</body></comment><class><name>DitaMap</name><environment>Help</environment><super>Help.DitaNamedGroup</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.DitaMap</class-id><body>DitaMap represents a &lt;map&gt; object</body></comment><class><name>StringTrieNode</name><environment>Help</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>indices subTrieNodes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.StringTrieNode</class-id><body>StringTrieNode is a class private to StringTrie. It forms a trie of nodes. Each node has children that are stored in a dictionary with Characters as keys. The path to a node describes the Word whose data the node stores.This class is specifically build for the purpose of finding words in a text. It stores all the indices under which a word was found in a text. When asked for its indices it will also return the indices of its children. This allows for searching by prefix and not only by exact match.Instance Variables:	indices		&lt;Collection of: Integer&gt;		the occurances of the node's word in the search-text	subTrieNodes	&lt;(Dictionary key: Character value: StringTreeNode)&gt;	the child-nodes for words that begin with this node's word</body></comment><class><name>Dita</name><environment>Help</environment><super>Help.DitaGroup</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.Dita</class-id><body>Dita represents the &lt;dita&gt; xml object</body></comment><class><name>DitaRelColSpec</name><environment>Help</environment><super>Help.DitaObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.DitaRelColSpec</class-id><body>DitaRelColSpec represents a &lt;relcolspec&gt; objectInstance Variables:	type	&lt;String&gt;		the type of the relation. either 'concept', 'task' or 'reference'</body></comment><class><name>DitaRelRow</name><environment>Help</environment><super>Help.DitaGroup</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.DitaRelRow</class-id><body>DitaRelRow represents a &lt;relrow&gt; object</body></comment><class><name>DitaSaxDriver</name><environment>Help</environment><super>XML.SAXDriver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stack nameClassMapping </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.DitaSaxDriver</class-id><body>DitaSaxDriver is a SaxDriver to parse ditamap or xml files. It'll generate instances of DitaObject based on the information found in the files.Instance Variables:	documentUrl		&lt;URL&gt;	the relative url of the document being parsed. All created DitaObjects will know 							this url to resolve referenced objects.	nameClassMapping	&lt;Dictionary&gt;	maps xml-element names to classes. If a name matches, an instance 								of that class will be put on the stack.	stack	&lt;(OrderedCollection of: DitaSaxStackNode)&gt;	a stack of interconnected objects. the nodes can have DitaObject 								instances associated with them and once a node is popped from the stack, its object 								will be passed to the parent node's object in order to connect the finished objects.</body></comment><class><name>DitaReader</name><environment>Help</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ditaFolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Help-Model</package></attributes></class><comment><class-id>Help.DitaReader</class-id><body>DitaReader reads ditamap files and xml files with dita data from a folder. It creates instances of DitaObject from the files that were found in the folder.This file is private to the DitaFolder, which uses the reader to go through its files and parse them.Instance Variables:	ditaFolder	&lt;Filename&gt;	the folder that's parsed</body></comment><shared-variable><name>Default</name><environment>Help.ScratchPad</environment><private>true</private><constant>false</constant><category>singleton</category><attributes><package>Help-Model</package></attributes></shared-variable><methods><class-id>Help.DocumentationStyles</class-id> <category>private</category><body package="Help-Model">definitionsForPragma: singlePragma withArgument: argumentPragma	| pragmasPerSymbol |	pragmasPerSymbol := Dictionary new.	(Tools.Pragma allNamed: singlePragma in: self class)		do: [:each | pragmasPerSymbol at: each selector put: each selector].	(Tools.Pragma allNamed: argumentPragma in: self class)		do: [:each | pragmasPerSymbol at: (each argumentAt: 1) put: each selector].	^pragmasPerSymbol</body><body package="Help-Model">fontAt: aSymbol	^self fontAt: aSymbol ifAbsent:[self defaultFont]</body><body package="Help-Model">fontAt: aSymbol ifAbsent: aBlock	^self		resolve: aSymbol		in: fonts		using: fontSelectors		ifAbsent: aBlock</body><body package="Help-Model">formattingStyleAt: aSymbol	^self formattingStyleAt: aSymbol ifAbsent: [self defaultStyle]</body><body package="Help-Model">formattingStyleAt: aSymbol ifAbsent: aBlock	^self		resolve: aSymbol		in: formattingFonts		using: formattingFontSelectors		ifAbsent: aBlock</body><body package="Help-Model">headingFontWithSize: aNumber	^(self defaultFontWithSize: aNumber)		boldness: 0.8;		yourself</body><body package="Help-Model">resolve: aSymbol in: aDictionary using: lookup ifAbsent: aBlock	| selector |	^aDictionary at: aSymbol asSymbol		ifAbsentPut: 			[selector := lookup at: aSymbol asSymbol ifAbsent: [^aBlock value].			selector numArgs &gt; 0 ifTrue:[^aBlock value].			self perform: selector]</body><body package="Help-Model">styleAt: aSymbol	^self styleAt: aSymbol ifAbsent: [self defaultStyle]</body><body package="Help-Model">styleAt: aSymbol ifAbsent: aBlock	^self		resolve: aSymbol		in: styles		using: styleSelectors		ifAbsent: aBlock</body></methods><methods><class-id>Help.DocumentationStyles</class-id> <category>fonts</category><body package="Help-Model">defaultNarrowFont	^self narrowFontWithSize: self defaultSystemFontSize</body><body package="Help-Model">defaultSystemFont	^Refactory.Browser.SourceCodeTheme defaultFontDescription</body><body package="Help-Model">defaultSystemFontSize	^self defaultSystemFont pixelSize</body><body package="Help-Model">narrowFontWithSize: size	^(self defaultFontWithSize: size)		boldness: 0.7;		yourself</body></methods><methods><class-id>Help.DocumentationStyles</class-id> <category>initialize-release</category><body package="Help-Model">initialize	super initialize.	fontSelectors := self definitionsForPragma: #font withArgument: #font:.	styleSelectors := self definitionsForPragma: #style withArgument: #style:.	formattingFontSelectors := self definitionsForPragma: #formattingStyle				withArgument: #formattingStyle:.	styles := Dictionary new.	fonts := Dictionary new.	formattingFonts := Dictionary new</body></methods><methods><class-id>Help.DocumentationStyles</class-id> <category>utility</category><body package="Help-Model">fontReport	| ws each font |	ws := String new writeStream.	fontSelectors keys sorted do: 			[:key |			each := self fontAt: key ifAbsent: [nil].			each notNil				ifTrue: 					[font := Screen default defaultFontPolicy findFont: each.					ws						nextPutAll: key;						tab;						nextPutAll: font name;						cr]].	^ws contents</body></methods><methods><class-id>Help.DocumentationStyles class</class-id> <category>tabs</category><body package="Help-Model">defListIndent	"Return the number of points to indent a definition list"	^18</body></methods><methods><class-id>Help.DocumentationStyles class</class-id> <category>instance creation</category><body package="Help-Model">new	^super new initialize</body></methods><methods><class-id>Help.DocumentationStyles class</class-id> <category>class initialization</category><body package="Help-Model">default	default isNil ifTrue: [default := self new].	^default</body><body package="Help-Model">fontAt: aName	^self default fontAt: aName</body><body package="Help-Model">fontAt: aName ifAbsent: aBlock	^self default fontAt: aName ifAbsent: aBlock</body><body package="Help-Model">formattingStyleAt: aSymbol	^self default formattingStyleAt: aSymbol</body><body package="Help-Model">formattingStyleAt: aSymbol ifAbsent: aBlock	^self default formattingStyleAt: aSymbol ifAbsent: aBlock</body><body package="Help-Model">initialize	"self initialize"	default := nil</body><body package="Help-Model">styleAt: aSymbol	^self default styleAt: aSymbol</body><body package="Help-Model">styleAt: aSymbol ifAbsent: aBlock	^self default styleAt: aSymbol ifAbsent: aBlock</body></methods><methods><class-id>Help.DocumentationStyles class</class-id> <category>compiling</category><body package="Help-Model">instanceMethodsChanged	super instanceMethodsChanged.	self initialize</body></methods><methods><class-id>Help.DitaRenderer</class-id> <category>initialize-release</category><body package="Help-Model">initialize	super initialize.	canvas := DocumentCanvas new.	tagMap := Dictionary				withAll: ((Tools.Pragma						allNamed: #tag:						from: self class						to: DitaRenderer)							collect: [:each | (each argumentAt: 1) asString -&gt; each selector]).	currentStyle := self styleAt: #defaultStyle.	headingLevel := 1.	trimSeparators := false.	lineIndent := DocumentationStyles defListIndent.	keepWhiteSpace := false.	linkResolutionBlock := [:href | self error: 'link resolution block unspecified'].	ignoreEmptyText := true.	showFontNames := false.	beginningOfBlock := false.	insideLI := false.	elementStack := OrderedCollection new.</body><body package="Help-Model">resolveLinksUsing: aBlock	linkResolutionBlock := aBlock</body></methods><methods><class-id>Help.DitaRenderer</class-id> <category>utility</category><body package="Help-Model">appendString: text	| cleanString |	cleanString := self cleanString: text.	(cleanString = ' ' and: [ignoreEmptyText or: [beginningOfBlock]])		ifTrue: [^self].	self privateAppendString: cleanString</body><body package="Help-Model">basicRenderDitaObject: aDitaObject	| xml |	xml := aDitaObject xmlSource.	self renderElement: xml</body><body package="Help-Model">cleanString: string	| rs char c ws |	string isNil ifTrue:[^''].	keepWhiteSpace ifTrue: [^string].	rs := string readStream.	ws := String new writeStream.	[rs atEnd] whileFalse: 			[char := rs next.			char isSeparator				ifTrue: 					[					[c := rs peek.					c notNil and: [c isSeparator]] whileTrue: [rs next].					ws nextPut: Character space]				ifFalse: [ws nextPut: char]].	^ws contents</body><body package="Help-Model">currentHeadingStyle	^('heading&lt;1p&gt;' expandMacrosWith: ((headingLevel min: 3) max: 1))</body><body package="Help-Model">currentIndent	^currentStyle lineIndent</body><body package="Help-Model">currentIndent: aNumber	currentStyle := self modifyStyle: currentStyle				with: 					[:style |					style						lineIndent: aNumber;						firstLineIndent: aNumber]</body><body package="Help-Model">ignoreEmptyText: aBoolean while: aBlock	| oldValue |	oldValue := ignoreEmptyText.	ignoreEmptyText := aBoolean.	aBlock ensure: [ignoreEmptyText := oldValue]</body><body package="Help-Model">increaseHeadingWhile: aBlock	headingLevel := headingLevel + 1.	aBlock ensure: [headingLevel := headingLevel - 1]</body><body package="Help-Model">increaseLineIndentBy: increment while: aBlock	| oldIndent |	oldIndent := lineIndent.	lineIndent := lineIndent + increment.	[self pushStyle: currentStyle while: aBlock]		ensure: [lineIndent := oldIndent]</body><body package="Help-Model">indentWhile: aBlock	self increaseLineIndentBy: DocumentationStyles defListIndent while: aBlock</body><body package="Help-Model">keepWhiteSpaceWhile: aBlock	keepWhiteSpace := true.	aBlock ensure: [keepWhiteSpace := false]</body><body package="Help-Model">linkTo: actionBlock named: helpString while: aBlock	self		linkTo: actionBlock		named: helpString		while: aBlock		usingStyleNamed: #linkStyle</body><body package="Help-Model">linkTo: actionBlock named: helpString while: aBlock usingStyleNamed: styleName	self pushStyle: (self modifyStyle: (self styleAt: styleName)				with: 					[:style |					helpString notNil ifTrue: [style hover: helpString].					style action: ((Text2.DocumentActionScript new)								block: actionBlock;								yourself)])		while: aBlock</body><body package="Help-Model">modifyFontOf: style with: aBlock	| font newFont |	font := style fontDescription copy.	newFont := aBlock value: font.	style fontDescription: newFont</body><body package="Help-Model">modifyStyle: originalStyle with: aBlock	| style |	style := originalStyle copy.	aBlock value: style.	^style intern</body><body package="Help-Model">openLink: href	"Hook up with the still missing Documentation URL-Opening Schema."	linkResolutionBlock cull: href</body><body package="Help-Model">privateAppendString: cleanString	canvas appendString: cleanString		style: 			[:style |			showFontNames				ifTrue: 					[(currentStyle copy)						hover: (Screen default defaultFontPolicy									findFont: currentStyle fontDescription) name;						yourself]				ifFalse: [currentStyle]]</body><body package="Help-Model">pushFont: fontBlock while: contentBlock	self pushStyle: (self modifyStyle: currentStyle				with: 					[:style |					fontBlock isSymbol						ifTrue: [style fontDescription: (DocumentationStyles fontAt: fontBlock)]						ifFalse: [self modifyFontOf: style with: fontBlock]])		while: contentBlock</body><body package="Help-Model">pushStyle: newStyleOrSymbol while: aBlock	| oldStyle indentedStyle unindentedStyle |	oldStyle := currentStyle copy.	unindentedStyle := newStyleOrSymbol isString				ifTrue: [self styleAt: newStyleOrSymbol asSymbol]				ifFalse: 					[(newStyleOrSymbol isKindOf: Kernel.BlockClosure)						ifTrue: [newStyleOrSymbol cull: currentStyle copy]						ifFalse: [newStyleOrSymbol]].	indentedStyle := self modifyStyle: unindentedStyle				with: 					[:style |					style						lineIndent: lineIndent;						firstLineIndent: lineIndent].	currentStyle := indentedStyle.	aBlock ensure: [currentStyle := oldStyle]</body><body package="Help-Model">pushStyleAndFontNamed: tag while: aBlock	| style font |	style := DocumentationStyles styleAt: tag ifAbsent: [currentStyle].	font := DocumentationStyles fontAt: tag ifAbsent: [nil].	self pushStyle: (self modifyStyle: style				with: [:each | each propertyAt: #tag put: tag asSymbol])		while: [self pushFont: [:oldFont | font ifNil: [oldFont]] while: aBlock]</body><body package="Help-Model">renderBlock: blockElement	canvas beginBlock.	beginningOfBlock := true.	self ignoreEmptyText: true while: [self renderGroup: blockElement].	canvas endBlock</body><body package="Help-Model">renderElement: xmlElement	| selector text tag |	xmlElement isNil ifTrue: [^self].	xmlElement isText		ifTrue: 			[text := xmlElement text.			self appendString: text.			^self].	xmlElement isElement		ifTrue: 			[elementStack add: xmlElement.						[tag := self tagOfElement: xmlElement.			selector := self renderSelectorForElementTag: tag.			self pushStyleAndFontNamed: tag				while: [self perform: selector with: xmlElement]]					ensure: [elementStack removeLast]]</body><body package="Help-Model">renderGroup: xmlElementOrBlock	xmlElementOrBlock class = XML.Element		ifTrue: 			[xmlElementOrBlock elements do: 					[:each |					self renderElement: each.					"after the first element we're not at the beginning of a block anymore"					beginningOfBlock := false]]		ifFalse: 			[xmlElementOrBlock value.			beginningOfBlock := false]</body><body package="Help-Model">renderInlineBlock: elementOrBlock	self ignoreEmptyText: false while: [self renderGroup: elementOrBlock].</body><body package="Help-Model">renderSelectorForElementTag: tag	^tagMap at: tag ifAbsent: [self error: 'unsupported tag: ' , tag]</body><body package="Help-Model">renderSoftBlock: pElement	canvas beginSoftBlock.	beginningOfBlock := true.	self renderGroup: pElement.	canvas endSoftBlock</body><body package="Help-Model">styleAt: name	^DocumentationStyles styleAt: name</body><body package="Help-Model">tagOfElement: xmlElement	^xmlElement tag type asString asLowercase</body><body package="Help-Model">trimSeparatorsWhile: aBlock	trimSeparators := true.	aBlock ensure: [trimSeparators := false]</body></methods><methods><class-id>Help.DitaRenderer</class-id> <category>tags-list</category><body package="Help-Model">renderElement: ulOlElement asList: listStyle	self indentWhile: 			[self renderBlock: 					[canvas						appendList: listStyle						with: [self renderGroup: ulOlElement]						style: [:style | currentStyle]].			insideLI				ifTrue: 					["the bullet-list implementation expects all bullets in the same paragraph"					canvas endsWithParagraphBreak						ifTrue: 							[canvas cleanEndOfDocumentIncludingParagraphBreak: true.							canvas lineBreak.							insideLI								ifTrue: 									["add a blank list item in case the next Element to be rendered is 									something else than another LI. The continued ListItem ensures 									correct indentation"									canvas continueListItem]]]]</body></methods><methods><class-id>Help.DitaRenderer</class-id> <category>tags-table</category><body package="Help-Model">renderChildrenNamed: childNameOrNames of: rowElement	| children names |	names := childNameOrNames isString				ifTrue: [Set with: childNameOrNames]				ifFalse: [Set withAll: childNameOrNames].	children := rowElement realElements				select: [:each | names includes: each tag asString].	^children do: [:each | self renderElement: each]</body></methods><methods><class-id>Help.DitaRenderer</class-id> <category>tags-special</category><body package="Help-Model">browseApiName: name ofKind: kind	"	This method is basically a leftover for testing.	This is not a unit-test kind of test, it'll open browsers or dialogs.		-- these should succeed and open a browser --	self basicNew browseApiName: #DitaRenderer ofKind: nil.	self basicNew browseApiName: #Help ofKind: #binding.	self basicNew browseApiName: #Help ofKind: nil.	self basicNew browseApiName: 'Help.DitaRenderer' ofKind: nil.	self basicNew browseApiName: 'Help.ScratchPad.Default' ofKind: nil.	self basicNew browseApiName: #browseApiName:ofKind: ofKind: nil.	self basicNew browseApiName: #unknown ofKind: nil.	-- these should fail and open a warning dialog --		self basicNew browseApiName: #Help ofKind: #pundle.	self basicNew browseApiName: #help ofKind: #senders.	self basicNew browseApiName: 'erm, right' ofKind: nil.	"	| apinameKind |	apinameKind := APINameKind apinameKind: kind named: name.	^self executeAPINameKind: apinameKind with: name</body><body package="Help-Model">detectApiNameKindOf: name defaultTo: kind	(#(#class #package #method) includes: kind asSymbol)		ifTrue: [^kind asSymbol].	name asQualifiedReference ifDefinedDo: [:cls | ^#class].	(Store.Registry pundleNamed: name) ifNotNil: [^#package].	^#method</body><body package="Help-Model">executeAPINameKind: apinameKind with: name	apinameKind isNil		ifTrue: 			[^Dialog warn: (#_1sNotFoundInImage &lt;&lt; #help &gt;&gt; '''&lt;1s&gt;'' was not found.'						expandMacrosWith: name)].	apinameKind handle</body><body package="Help-Model">handlePrerequisteHref: href	"href has the form 'prereq:parcelName:smalltalk code'	The parcel is loaded if needed, the code is then executed"	| rs code prereq |	rs := href readStream.	rs upTo: $:.	prereq := rs upTo: $:.	code := rs upToEnd.	(Kernel.Parcel parcelOrPundleNamed: prereq) isNil		ifTrue: 			[Notice show: #loadingPrerequisite &lt;&lt; #help &gt;&gt; 'Loading Prerequisite'				while: 					[Kernel.Parcel						ensureLoadedParcel: prereq						withVersion: nil						forPundle: nil						with: nil]].	^Kernel.Compiler evaluate: code</body><body package="Help-Model">runXref: href format: format scope: scope	| arguments pragmas |	arguments := Array with: format asSymbol with: scope asSymbol.	pragmas := Tools.Pragma				allNamed: #xref:scope:				from: self class				to: DitaRenderer.	pragmas do: 			[:each |			each arguments = arguments				ifTrue: [^self perform: each selector with: href]]</body></methods><methods><class-id>Help.DitaRenderer</class-id> <category>instance creation</category><body package="Help-Model">documentForElement: element	self renderElement: element.	^self document</body></methods><methods><class-id>Help.DitaRenderer</class-id> <category>accessing</category><body package="Help-Model">document	^canvas document</body><body package="Help-Model">pushDitaObject: aDitaObject while: aBlockClosure	| oldObject |	oldObject := ditaObject.	ditaObject := aDitaObject.	aBlockClosure ensure: [ditaObject := oldObject]</body><body package="Help-Model">showFontNames	^showFontNames</body><body package="Help-Model">showFontNames: anObject	showFontNames := anObject</body></methods><methods><class-id>Help.DitaRenderer class</class-id> <category>instance creation</category><body package="Help-Model">documentForElement: element	| renderer |	renderer := self new.	^renderer documentForElement: element</body><body package="Help-Model">new	^super new initialize</body></methods><methods><class-id>Help.DitaObject</class-id> <category>accessing</category><body package="Help-Model">appendToSearchString: aString	searchString := searchString isNil				ifTrue: [aString]				ifFalse: [searchString , ' ' , aString]</body><body package="Help-Model">beInFile: aFile	file := aFile.	searchTrie := CaseInsensitiveStringTrie fromString: searchString</body><body package="Help-Model">children	^#()</body><body package="Help-Model">documentName	^self fullUrl tail readStream upTo: $.</body><body package="Help-Model">filePath	^file path</body><body package="Help-Model">fullUrl	^file url</body><body package="Help-Model">imageAt: url	^file imageAt: url</body><body package="Help-Model">pathOfFileAt: url	^file pathOfFileAt: url</body><body package="Help-Model">resolveUrl: aUrl	| resolvedFile |	resolvedFile := file resolveUrl: aUrl asURI.	^resolvedFile rootObject</body><body package="Help-Model">xmlAttributeMapping	^Dictionary new</body><body package="Help-Model">xmlElementStackTextMapping		^Dictionary new</body><body package="Help-Model">xmlObjectCompleted: anObject	"anObject was read as a child in the xml file"</body><body package="Help-Model">xmlSource	^file xmlFromSourcePointer: sourcePosition</body><body package="Help-Model">xmlSourcePosition: anInteger	sourcePosition := anInteger</body><body package="Help-Model">xmlText: aString elementStack: elementStack	| mapping key |	mapping := self xmlElementStackTextMapping.	key := mapping keys detect: [:each | elementStack endsWith: each]				ifNone: [^self].	mapping at: key		ifPresent: [:selector | self perform: selector with: aString]</body></methods><methods><class-id>Help.DitaObject</class-id> <category>initialize-release</category><body package="Help-Model">topicRefs	^#()</body><body package="Help-Model">topics	^#()</body><body package="Help-Model">withXMLAttributes: attributes	| mapping |	mapping := self xmlAttributeMapping.	attributes do: 			[:each |			mapping at: each key type asSymbol				ifPresent: [:selector | self perform: selector with: each value]]</body></methods><methods><class-id>Help.DitaObject</class-id> <category>printing</category><body package="Help-Model">displayString	^self documentName</body><body package="Help-Model">title	^''</body></methods><methods><class-id>Help.DitaObject</class-id> <category>testing</category><body package="Help-Model">isTopic	^false</body><body package="Help-Model">isTopicRef	^false</body></methods><methods><class-id>Help.DitaObject</class-id> <category>rendering</category><body package="Help-Model">renderTitleOn: aDitaRenderer</body></methods><methods><class-id>Help.DitaObject</class-id> <category>user interface</category><body package="Help-Model">inspectorHierarchies	^file inspectorHierarchies</body></methods><methods><class-id>Help.DitaObject class</class-id> <category>instance creation</category><body package="Help-Model">new	^super new initialize</body><body package="Help-Model">withXMLAttributes: attributes	^self new withXMLAttributes: attributes</body></methods><methods><class-id>Help.DitaGroup</class-id> <category>initialize-release</category><body package="Help-Model">initialize	super initialize.	topics := OrderedCollection new</body></methods><methods><class-id>Help.DitaGroup</class-id> <category>accessing</category><body package="Help-Model">beInFile: aFile	super beInFile: aFile.	topics do: [:each | each beInFile: aFile]</body><body package="Help-Model">children	^topics</body><body package="Help-Model">objectWithID: id	(id isNil or:[id isEmpty]) ifTrue:[^self].	topics do: [:each | (each topicWithId: id) ifNotNil: [:topic | ^topic]].	^nil</body><body package="Help-Model">resolveObjectAtUrl: aUrl	| rootObject |	rootObject := self resolveUrl: aUrl.	rootObject isNil ifTrue: [^nil].	^rootObject objectWithID: aUrl asURI fragment</body><body package="Help-Model">resolveTopicAtUrl: aUrl	| rootObject |	rootObject := self resolveUrl: aUrl.	rootObject isNil ifTrue: [^nil].	^rootObject topicWithId: aUrl asURI fragment</body><body package="Help-Model">topicRefs	^topics select: #isTopicRef</body><body package="Help-Model">topicWithId: id	topics do: [:each | (each topicWithId: id) ifNotNil: [:topic | ^topic]].	^nil</body><body package="Help-Model">topics	^topics</body><body package="Help-Model">xmlObjectCompleted: anObject	super xmlObjectCompleted: anObject.	topics add: anObject</body></methods><methods><class-id>Help.DitaGroup</class-id> <category>printing</category><body package="Help-Model">topic	topics isEmpty ifTrue: [^nil].	^topics first topic</body></methods><methods><class-id>Help.DitaGroup</class-id> <category>testing</category><body package="Help-Model">combineByDocument	^false</body><body package="Help-Model">renderToContent	^false</body><body package="Help-Model">selectOnlyTopic	^false</body><body package="Help-Model">selectWholeBranch	^false</body><body package="Help-Model">selectWholeDocument	^false</body><body package="Help-Model">splitByTopic	^false</body></methods><methods><class-id>Help.DitaNamedGroup</class-id> <category>printing</category><body package="Help-Model">printOn: aStream	super printOn: aStream.	aStream		space;		print: title;		space;		print: self fullUrl</body><body package="Help-Model">title	^title ifNil: ['']</body></methods><methods><class-id>Help.DitaNamedGroup</class-id> <category>accessing</category><body package="Help-Model">chunkTagFrom: symbols startingWith: aString	^symbols detect: [:each | each beginsWith: aString] ifNone: []</body><body package="Help-Model">directTopicRefs	^topics collect: #asTopicRef</body><body package="Help-Model">xmlAttributeMapping	^(super xmlAttributeMapping)		at: #chunk put: #xmlChunkString:;		yourself</body><body package="Help-Model">xmlChunkString: aString	| chunkTags |	chunkTags := (aString tokensBasedOn: Character space) collect: #asSymbol.	chunkSelection := self chunkTagFrom: chunkTags startingWith: 'select-'.	chunkCombination := self chunkTagFrom: chunkTags startingWith: 'by-'.	chunkRendering := self chunkTagFrom: chunkTags startingWith: 'to-'</body></methods><methods><class-id>Help.DitaNamedGroup</class-id> <category>initialize-release</category><body package="Help-Model">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	title := nil.	^self</body></methods><methods><class-id>Help.DitaNamedGroup</class-id> <category>testing</category><body package="Help-Model">combineByDocument	^chunkCombination = #'by-document'</body><body package="Help-Model">renderToContent	^chunkRendering = #'to-content'</body><body package="Help-Model">selectOnlyTopic	^chunkSelection = #'select-topic'</body><body package="Help-Model">selectWholeBranch	^chunkSelection = #'select-branch'</body><body package="Help-Model">selectWholeDocument	^chunkSelection = #'select-document'</body><body package="Help-Model">splitByTopic	^chunkCombination = #'by-topic'</body></methods><methods><class-id>Help.DitaNamedGroup</class-id> <category>rendering</category><body package="Help-Model">renderTitleOn: aDitaRenderer	aDitaRenderer renderElement: (XML.Element tag: 'title'				elements: (Array with: (XML.Text text: title)))</body></methods><methods><class-id>Help.DitaTopic</class-id> <category>accessing</category><body package="Help-Model">documentName	^id</body><body package="Help-Model">id	^id</body><body package="Help-Model">searchString	^searchTrie</body><body package="Help-Model">topic	^self</body><body package="Help-Model">topicWithId: anID	anID isNil ifTrue: [^self].	id = anID ifTrue: [^self].	topics do: [:each | (each topicWithId: anID) ifNotNil: [:topic | ^topic]].	^nil</body><body package="Help-Model">xmlAttributeMapping	^(super xmlAttributeMapping)		at: #id put: #xmlID:;		yourself</body><body package="Help-Model">xmlElementStackTextMapping	^(super xmlElementStackTextMapping)		at: #('topic' 'title') put: #xmlTitle:;		yourself</body><body package="Help-Model">xmlID: aString	id := aString.</body><body package="Help-Model">xmlTitle: aString	title := aString</body></methods><methods><class-id>Help.DitaTopic</class-id> <category>printing</category><body package="Help-Model">displayString	^self title</body></methods><methods><class-id>Help.DitaTopic</class-id> <category>converting</category><body package="Help-Model">asTopicRef	^DitaTopicRef fromTopicAt: ('#' , id) asURI in: file</body></methods><methods><class-id>Help.DitaTopic</class-id> <category>testing</category><body package="Help-Model">isTopic	^true</body></methods><methods><class-id>Help.DitaGlossaryEntry</class-id> <category>accessing</category><body package="Help-Model">xmlElementStackTextMapping	^(super xmlElementStackTextMapping)		at: #('glossentry' 'glossterm') put: #xmlTitle:;		yourself</body></methods><methods><class-id>Help.DitaSaxStackNode</class-id> <category>accessing</category><body package="Help-Model">object	^object</body><body package="Help-Model">object: anObject	object := anObject</body></methods><methods><class-id>Help.DitaSaxStackNode</class-id> <category>initialize-release</category><body package="Help-Model">allNames	| names |	names := parent ifNil: [#()] ifNotNil: #allNames.	^names copyWith: name</body><body package="Help-Model">finishedSubObject: anObject	object isNil		ifTrue: 			[parent ifNotNil: [parent finishedSubObject: anObject].			^self].	object xmlObjectCompleted: anObject</body><body package="Help-Model">informParentAboutCompletion	(parent isNil or: [object isNil]) ifTrue: [^self].	parent finishedSubObject: object</body><body package="Help-Model">initialize	super initialize.	parent := nil.	object := nil</body><body package="Help-Model">named: aString parent: anObject	name := aString.	parent := anObject.</body><body package="Help-Model">startedElementAt: filePosition	object notNil ifTrue: [object xmlSourcePosition: filePosition]</body><body package="Help-Model">subNodeNamed: aString	| subNode |	subNode := self class named: aString parent: self.	^subNode</body></methods><methods><class-id>Help.DitaSaxStackNode</class-id> <category>printing</category><body package="Help-Model">printNamePathOn: aStream	parent notNil		ifTrue: 			[parent printNamePathOn: aStream.			aStream space].	aStream print: name</body><body package="Help-Model">printOn: aStream	super printOn: aStream.	aStream space.	self printNamePathOn: aStream</body></methods><methods><class-id>Help.DitaSaxStackNode class</class-id> <category>instance creation</category><body package="Help-Model">named: aString	^self named: aString parent: nil</body><body package="Help-Model">named: aString parent: anObject	^self new named: aString parent: anObject</body><body package="Help-Model">new	^super new initialize</body></methods><methods><class-id>Help.ScratchPad</class-id> <category>initialize-release</category><body package="Help-Model">initialize	super initialize.	window := ApplicationWindow new label: 'Scratch Window'.	window component: CompositePart new</body><body package="Help-Model">prepareForSize: windowExtent	"Make sure the scratch window is open, expanded and has the	specified size, in preparation for example code to display on it."	window isOpen		ifTrue: 			["Resize if necessary."			window extent ~= windowExtent				ifTrue: 					[| newDisplayBox screenBox |					window sensor skipNextDamage.					newDisplayBox := window displayBox origin extent: windowExtent.					screenBox := Screen default preferredRectangleToConstrain: newDisplayBox.					newDisplayBox insetOriginBy: window class windowTopLeftHeadroom						cornerBy: 0 @ 0.					newDisplayBox := newDisplayBox								translatedBy: (newDisplayBox amountToTranslateWithin: screenBox).					window displayBox: newDisplayBox].			"Expand if necessary."			window isCollapsed				ifTrue: 					[window sensor skipNextDamage.					window expand].			"Erase."			window display]		ifFalse: 			[window sensor skipNextDamage.			window openIn: (window class windowTopLeftHeadroom extent: windowExtent)].	^window</body><body package="Help-Model">release	window controller closeAndUnschedule.	window release.	super release</body></methods><methods><class-id>Help.ScratchPad class</class-id> <category>instance creation</category><body package="Help-Model">default	Default isNil ifTrue: [Default := self new].	^Default</body><body package="Help-Model">new	^super new initialize</body><body package="Help-Model">prepareWindow	^self prepareWindowOfSize: 400 @ 400</body><body package="Help-Model">prepareWindowOfSize: windowExtent	^self default prepareForSize: windowExtent</body></methods><methods><class-id>Help.ScratchPad class</class-id> <category>class initialization</category><body package="Help-Model">initialize	Default ifNotNil: #release.	Default := nil</body></methods><methods><class-id>Help.DitaRelTable</class-id> <category>accessing</category><body package="Help-Model">xmlAttributeMapping	^(super xmlAttributeMapping)		at: #title put: #xmlTitle:;		yourself</body><body package="Help-Model">xmlElementStackTextMapping	^(super xmlElementStackTextMapping)		at: #('topic' 'title') put: #xmlTitle:;		yourself</body><body package="Help-Model">xmlTitle: aString	title := aString</body></methods><methods><class-id>Core.WordGroupMatch</class-id> <category>accessing</category><body package="Help-Model">averageDistance	| distances |	distances := self distances.	^self averageDistanceBetween: distances</body><body package="Help-Model">averageDistanceBetween: indices inWords: words	| locations start word distances previous |	locations := (1 to: indices size) collect: 					[:i |					start := indices at: i.					word := words at: i.					start to: start + word size].	distances := OrderedCollection new.	previous := nil.	(locations sorted: #first ascending) do: 			[:interval |			previous notNil ifTrue: [distances add: interval first - previous last].			previous := interval].	^self averageDistanceBetween: distances</body><body package="Help-Model">bestRange	| matchesWithIndex start end |	matchesWithIndex := self bestMatchesWithIndex.	start := matchesWithIndex first key.	end := matchesWithIndex last key + matchesWithIndex last value word size.	^start to: end</body><body package="Help-Model">distances	| distances |	distances := OrderedCollection new.	self wordsDo: [:each | ] distancesDo: [:distance | distances add: distance].	^distances</body><body package="Help-Model">numberOfMatches	^wordMatches size</body><body package="Help-Model">totalNumberOfWords	^wordMatches inject: 0 into: [:all :each | all + each numberOfOccurances]</body></methods><methods><class-id>Core.WordGroupMatch</class-id> <category>private</category><body package="Help-Model">averageDistanceBetween: distances	| sum |	distances isEmpty		ifTrue: [^wordMatches isEmpty ifTrue: [SmallInteger maxVal] ifFalse: [0]].	sum := distances inject: 0 into: [:all :each | all + each].	^sum / distances size</body><body package="Help-Model">bestMatchesWithIndex	bestIndices isNil ifTrue: [self computeBestIndices].	^((1 to: bestIndices size) collect: 			[:i |			| best |			best := bestIndices at: i.			best -&gt; (wordMatches at: i)])		sorted: #key ascending</body><body package="Help-Model">wordsDo: wordBlock distancesDo: distanceBlock	| lastIndex word distance lastWord index matchesWithIndex |	lastIndex := nil.	lastWord := nil.	matchesWithIndex := self bestMatchesWithIndex.	matchesWithIndex do: 			[:each |			word := each value word.			index := each key.			lastIndex notNil				ifTrue: 					[distance := lastIndex + lastWord size - index.					wordBlock value: lastWord.					distanceBlock value: distance abs].			lastWord := word.			lastIndex := index].	wordBlock value: lastWord</body></methods><methods><class-id>Core.WordGroupMatch</class-id> <category>printing</category><body package="Help-Model">printOn: aStream	super printOn: aStream.	aStream		space;		nextPut: $(.	self wordsDo: [:word | aStream print: word]		distancesDo: 			[:each |			aStream				space;				print: each;				space].	aStream nextPut: $)</body></methods><methods><class-id>Core.WordGroupMatch</class-id> <category>initialize-release</category><body package="Help-Model">computeBestIndices	"this is a scan-line algorithm to efficiently find words that are close to other words.	&lt;allIndices&gt; contains all locations in the searched string where words were found.	These indices are iterated from left to right.	The task of this loop is to find all possible combinations of the &lt;words&gt; that are next to each other. These possible combinations are 	then sorted to identify the combination where the words are closest to each other.	See the class comment for more information on the algorithm"	| indices words indexCollections lastIndices streams next allIndices |	words := wordMatches collect: #word.	streams := wordMatches collect: #matchIndexStream.	allIndices := (wordMatches inject: Set new				into: 					[:all :each |					all						addAll: each matchIndices;						yourself])					sorted.	lastIndices := streams collect: #next.	indexCollections := Set new.	allIndices do: 			[:index |			indices := OrderedCollection new.			1 to: wordMatches size				do: 					[:i |					| stream closest last |					stream := streams at: i.					last := lastIndices at: i.					closest := last.					(index &gt; last and: [stream atEnd not])						ifTrue: 							[next := stream peek.							(index - last) abs &gt; (index - next) abs								ifTrue: 									[closest := next.									lastIndices at: i put: next.									stream next]].					indices add: closest].			indexCollections add: indices].	bestIndices := (indexCollections				sorted: [:each | self averageDistanceBetween: each inWords: words]						ascending)					first</body><body package="Help-Model">initialize	super initialize.	wordMatches := OrderedCollection new.	bestIndices := #()</body><body package="Help-Model">termFrequency	| combinedFrequency |	wordMatches isEmpty ifTrue: [^0].	combinedFrequency := wordMatches inject: 0				into: [:all :each | all + each termFrequency].	^combinedFrequency / wordMatches size</body><body package="Help-Model">withWords: matches	wordMatches := matches select: #hasMatches.	wordMatches isEmpty ifTrue: [^self].	wordMatches size = 1		ifTrue: 			[bestIndices := Array with: wordMatches first firstMatchIndex.			^self].	bestIndices := nil.</body></methods><methods><class-id>Core.WordGroupMatch class</class-id> <category>instance creation</category><body package="Help-Model">example	"	self example	"	| searchTrie alices bobs charlies wordGroupMatch |	searchTrie := Help.StringTrie fromString: 'Alice, Bob and Charly go to a bar. Alice and Bob know each other since they were kids. Charly and Bob work together in the same company. Alice and Charly met at Bob''s birthday party.'.	alices := searchTrie indicesForWord: 'Alice'.	"=&gt; #(0 35 137)"	bobs := searchTrie indicesForWord: 'Bob'.	"=&gt; #(7 45 98 161)"	charlies := searchTrie indicesForWord: 'Charly'.	"=&gt; #(15 87 147)"	wordGroupMatch := self withWords: (Array						with: (WordMatch named: 'Alice' occurances: alices)						with: (WordMatch named: 'Bob' occurances: bobs)						with: (WordMatch named: 'Charly' occurances: charlies)).	^wordGroupMatch computeBestIndices</body><body package="Help-Model">new	^super new initialize</body><body package="Help-Model">withWords: wordMatches	^self new withWords: wordMatches</body></methods><methods><class-id>Help.StringTrie</class-id> <category>accessing</category><body package="Help-Model">asString	^searchString</body><body package="Help-Model">searchString	^searchString</body><body package="Help-Model">searchString: aString	searchString := aString</body><body package="Help-Model">size	^searchString size</body></methods><methods><class-id>Help.StringTrie</class-id> <category>private-writing</category><body package="Help-Model">asUppercase	| result |	result := CaseInsensitiveStringTrie new.	self		wordsAndIndicesDo: [:word :wordIndices | result add: word atAll: wordIndices].	result searchString: searchString asUppercase.	^result</body><body package="Help-Model">words	| words |	words := OrderedCollection new.	self wordsAndIndicesDo: [:word :wordIndices | words add: word].	^words</body><body package="Help-Model">wordsAndIndicesDo: aBlock	rootNode withWord: '' andIndicesDo: aBlock</body></methods><methods><class-id>Help.StringTrie</class-id> <category>writing</category><body package="Help-Model">add: word at: index	self add: word atAll: (Array with: index)</body><body package="Help-Model">add: word atAll: allIndices	| rs node |	rs := word readStream.	node := rootNode insertNodeAtStream: rs.	allIndices do: [:each | node addIndex: each].	wordCount := wordCount + allIndices size</body></methods><methods><class-id>Help.StringTrie</class-id> <category>converting</category><body package="Help-Model">asStringTrie	^self</body></methods><methods><class-id>Help.StringTrie</class-id> <category>reading</category><body package="Help-Model">indicesForWord: aWord	| node normalizedWord |	normalizedWord := self normalizeWord: aWord.	node := rootNode nodeAtStream: normalizedWord readStream ifAbsent: [^#()].	^node indices</body></methods><methods><class-id>Help.StringTrie</class-id> <category>initialize-release</category><body package="Help-Model">fromString: aString	| rs index word normalizedWord |	rs := aString readStream.	[rs atEnd] whileFalse: 			[index := rs position.			word := self nextWordFrom: rs.			normalizedWord := self normalizeWord: word.			normalizedWord notEmpty ifTrue: [self add: normalizedWord at: index]].	searchString := self removeLineBreaksFrom: aString.	^self</body><body package="Help-Model">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	rootNode := StringTrieNode new.	wordCount := 0.	^self</body><body package="Help-Model">nextWordFrom: rs	| ws next |	ws := String new writeStream.	[rs atEnd or: 			[next := rs next.			next isAlphaNumeric not]]		whileFalse: [ws nextPut: next].	^ws contents</body><body package="Help-Model">wordCount	^wordCount</body></methods><methods><class-id>Help.StringTrie</class-id> <category>private</category><body package="Help-Model">normalizeWord: word	^(word collect: #basePart) select:#isAlphaNumeric</body></methods><methods><class-id>Help.StringTrie</class-id> <category>printing</category><body package="Help-Model">printOn: aStream	super printOn: aStream.	aStream space.	self wordsAndIndicesDo: 			[:word :wordIndices |			aStream				nextPutAll: word;				space;				print: wordIndices size;				space]</body></methods><methods><class-id>Help.StringTrie</class-id> <category>instance creation</category><body package="Help-Model">removeLineBreaksFrom: aString	"this method removes Line-Breaks, multiple spaces and tabs from aString 	so that aString can appear completely on a single line.	It is important that the resulting string has the same length as aString.	Otherwise the indices that are stored in this Trie do not match with the resulting string, 	which results in incorrect highlighting when the found words are to be highlighted in the resulting string.	To ensure the same length, zero-width space characters are used to replace multiple separator characters"	| rs ws visibleSpaceWasSet each |	rs := aString readStream.	ws := (String new: aString size) writeStream.	visibleSpaceWasSet := false.	[rs atEnd] whileFalse: 			[each := rs next.			each isSeparator				ifTrue: 					[visibleSpaceWasSet						ifTrue: 							["successive separators are replaced by zero-width spaces"							ws nextPut: 16r200B asCharacter]						ifFalse: 							["the first separator is replaced by a non-breaking space"							ws nextPut: 16ra0 asCharacter.							visibleSpaceWasSet := true]]				ifFalse: 					[visibleSpaceWasSet := false.					ws nextPut: each]].	^ws contents</body></methods><methods><class-id>Help.StringTrie class</class-id> <category>instance creation</category><body package="Help-Model">fromString: aString	aString isNil ifTrue: [^nil].	^self new fromString: aString</body><body package="Help-Model">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Core.WordMatch</class-id> <category>accessing</category><body package="Help-Model">addOccuranceAt: anIndex	matches add: anIndex</body><body package="Help-Model">firstMatchIndex	^matches first</body><body package="Help-Model">lastMatchIndex	^matches last</body><body package="Help-Model">matchIndexStream	^matches readStream</body><body package="Help-Model">matchIndices	^matches</body><body package="Help-Model">numberOfOccurances	^matches size</body><body package="Help-Model">ranges	^matches collect: [:each | each to: each + word size]</body><body package="Help-Model">setTermFrequencyFromTrie: aTrie	termFrequency := aTrie wordCount = 0				ifTrue: [0]				ifFalse: [matches size / aTrie wordCount]</body><body package="Help-Model">termFrequency	^termFrequency</body><body package="Help-Model">word	^word</body></methods><methods><class-id>Core.WordMatch</class-id> <category>testing</category><body package="Help-Model">hasMatches	^matches notEmpty</body><body package="Help-Model">isInRange: anInterval	^matches anySatisfy: 			[:each |			each &gt; anInterval first and: [each + word size &lt; anInterval last]]</body></methods><methods><class-id>Core.WordMatch</class-id> <category>initialize-release</category><body package="Help-Model">named: aString	word := aString.	matches := OrderedCollection new.</body></methods><methods><class-id>Core.WordMatch</class-id> <category>printing</category><body package="Help-Model">printOn: aStream	super printOn: aStream.	aStream		space;		nextPutAll: word.	aStream		space;		nextPut: $(.	matches do: [:each | aStream print: each]		separatedBy: [aStream nextPutAll: ', '].	aStream nextPut: $)</body></methods><methods><class-id>Core.WordMatch class</class-id> <category>instance creation</category><body package="Help-Model">named: aString	^self new named: aString</body><body package="Help-Model">named: aString occurances: occurances	"this method is for convenience to debug WordGroupMatch&gt;&gt;example"	| match |	match := self named: aString.	occurances do: [:each | match addOccuranceAt: each].	^match</body></methods><methods><class-id>Help.CaseInsensitiveStringTrie</class-id> <category>private-writing</category><body package="Help-Model">asUppercase	^self</body></methods><methods><class-id>Help.CaseInsensitiveStringTrie</class-id> <category>writing</category><body package="Help-Model">add: word atAll: allIndices	super add: word asUppercase atAll: allIndices</body></methods><methods><class-id>Help.CaseInsensitiveStringTrie</class-id> <category>reading</category><body package="Help-Model">indicesForWord: aWord	^super indicesForWord: aWord asUppercase</body></methods><methods><class-id>Help.CaseInsensitiveStringTrie</class-id> <category>testing</category><body package="Help-Model">isEmpty	^searchString isEmpty</body></methods><methods><class-id>Help.CaseInsensitiveStringTrie</class-id> <category>private</category><body package="Help-Model">normalizeWord: word	^(super normalizeWord: word) asUppercase</body></methods><methods><class-id>Help.CaseInsensitiveStringTrie</class-id> <category>initialize-release</category><body package="Help-Model">fromString: aString	super fromString: aString asUppercase.	searchString := self removeLineBreaksFrom: aString</body></methods><methods><class-id>Core.MultiWordFuzzyStringSearch</class-id> <category>private</category><body package="Help-Model">canFindCriteriaInSuggestion: aSuggestion	"lets try in any case, matching is so complicated, no need to reimplement something here"	^true</body><body package="Help-Model">scoreMatch: aMatch against: anotherMatch	"scoring is done using WordGroupMatch objects. These objects implement a number of metrics that help bring an order to the matches.	the FuzzyMatch objects contain WordMatch objects at #matchingIndices, which would otherwise be Interval objects (hence the 'indices' name)."		| aMatches bMatches sortFunction aGroup bGroup |	aMatches := aMatch indices.	bMatches := anotherMatch indices.	aGroup := WordGroupMatch withWords: aMatches.	bGroup := WordGroupMatch withWords: bMatches.	sortFunction := #termFrequency descending,  #numberOfMatches descending, #averageDistance ascending, #totalNumberOfWords descending.	^sortFunction value: aGroup value: bGroup</body></methods><methods><class-id>Core.MultiWordFuzzyStringSearch</class-id> <category>api</category><body package="Help-Model">findMatchesIn: searchString	"matching is done using WordMatch objects. 	If at least one word (possibly as the beginning of another word) is found, this is a match already.	This method does not return Intervals or Arrays with numbers. Instead it returns a collection of WordMatch objects. 	These WordMatch objects are later used to score matches, where numbers are not enough knowledge"	| words wordMatches stringTrie |	stringTrie := Help.StringTrie fromString: searchString asString.	caseInsensitive ifTrue: [stringTrie := stringTrie asUppercase].	words := (Help.StringTrie fromString: criteria asString) words reject: #isEmpty.	words isEmpty ifTrue: [^#()].	wordMatches := words collect: [:each | WordMatch named: each].	words with: wordMatches		do: 			[:word :match |			(stringTrie indicesForWord: word)				do: [:index | match addOccuranceAt: index]].	(wordMatches anySatisfy: #hasMatches) ifFalse: [^#()].	wordMatches do:[:each | each setTermFrequencyFromTrie: stringTrie].	^wordMatches</body></methods><methods><class-id>Help.DocumentCanvas</class-id> <category>configuration</category><body package="Help-Model">appendBoldString: aText	self appendString: aText		style: [:style | self applyFontChange: [:font | font boldness: 1] onStyle: style]</body><body package="Help-Model">appendHeading: aString	self appendHeading: aString style: nil</body><body package="Help-Model">appendHeading: aString style: aBlock	self appendParagraph: aString		style: [:style | self applyStyle: aBlock to: (self applyHeadingStyle: style)]</body><body package="Help-Model">appendImage: anImage style: style	document insert: (Text2.DocumentImage fromImage: anImage style: style)</body><body package="Help-Model">appendLink: aString to: url	self appendString: aString</body><body package="Help-Model">appendList: listType with: aBlock style: styleBlock	| listItem |	listItem := Text2.DocumentListItem type: listType				style: (self applyStyle: styleBlock to: Text2.DocumentStyle default).	listType = #bullet ifTrue: [listItem suffix: ''].	listItemStack add: listItem.	listNumberStack add: 0.	[aBlock value] ensure: 			[listItemStack removeLast.			listNumberStack removeLast].	self beginBlock</body><body package="Help-Model">appendListItem: aString	self appendListItem: aString style: nil</body><body package="Help-Model">appendListItem: aString style: aBlock	| item |	listItemStack isEmpty		ifTrue: 			[self error: 'wrap list items in a #appendListWith: call'.			^self].	self cleanEndOfDocumentIncludingParagraphBreak: false.	listNumberStack addLast: listNumberStack removeLast + 1.	item := listItemStack last copy.	item first: listNumberStack last.	document insert: item.	self appendString: aString style: aBlock</body><body package="Help-Model">appendParagraph: aString 	self appendParagraph: aString style: nil</body><body package="Help-Model">appendParagraph: aString style: aBlock	self appendString: (aString copyWith: self paragraphBreakCharacter) style: aBlock</body><body package="Help-Model">appendString: aString	self appendString: aString style: nil</body><body package="Help-Model">appendString: aString style: aBlock	| newDocument |	aString isEmpty ifTrue: [^self].	newDocument := aString asDocument		replaceBetween: 0		and: aString size		apply: [:style | self applyStyle: aBlock to: style].	document insert: newDocument</body><body package="Help-Model">beginBlock	self endsWithParagraphBreak ifFalse: [self paragraphBreak]</body><body package="Help-Model">beginSoftBlock	self cleanEndOfDocumentIncludingParagraphBreak: false.	self shouldBreakAtBlockBeginning ifTrue: [self lineBreak]</body><body package="Help-Model">cleanEmptyListItem	"remove the ListItems at the end of the document that were added by #continueListItem.	These DocumentListItems have a type #blank, which is why the blankString is created by sending	#blank to the DocumentListItem class.	The reason for the cleanup is that they are generally added at the end of a UL or OL if this is a nested list.	If a LI is rendered next, the blank ListItem would create an undesired line-break."		| node count blankString |	self cleanEndOfDocumentIncludingParagraphBreak: true.	self cleanEndOfDocumentUsing: 			[count := 0.			blankString := Text2.DocumentListItem blank value: 0.			node := document nodeAtPositionBefore: document size.						[node notNil				and: [node value isListItem and: [node value asString = blankString]]]					whileTrue: 						[count := count + 1.						node := node previous].			count]</body><body package="Help-Model">cleanEndOfDocumentIncludingParagraphBreak: includeParagraphBeaks	self cleanEndOfDocumentUsing: 			[self				numberOfTrailingSeparatorsIncludingParagraphBreaks: includeParagraphBeaks]</body><body package="Help-Model">cleanEndOfDocumentUsing: aBlock	| charactersToDelete |	document isEmpty ifTrue: [^self].	charactersToDelete := aBlock value.	charactersToDelete = 0 ifTrue: [^self].	document		replaceBetween: document size - charactersToDelete		and: document size		with: ''</body><body package="Help-Model">continueListItem	"inserts an 'empty' listItem so that the next text will be rendered at the same level as the previous list-Item.	It works around the limitation that the following construct is currently not supported by DocumentListItems:	- primary1		- sub1	  CONTINUE of primary1	- primary2 	the CONTINUE text is only then correctly indented when there's an empty listItem between sub1 and CONTINUED.	Numbering of List-Items is not an issue as this is already ensured by &lt;listNumberStack&gt;"		| item |	listItemStack isEmpty		ifTrue: 			[self error: 'wrap list items in a #appendListWith: call'.			^self].	self cleanEndOfDocumentIncludingParagraphBreak: true.	item := listItemStack last copy.	item		type: #blank;		prefix: '';		suffix: ''.	document insert: item.	self appendString: '' style: [:style | ]</body><body package="Help-Model">deleteLast		document isEmpty ifTrue:[^self].	document		replaceBetween: document size		and: document size		with: ''</body><body package="Help-Model">endBlock	self endsWithParagraphBreak ifFalse: [self paragraphBreak]</body><body package="Help-Model">endSoftBlock	"if the block already ends with a paragraph-break don't replace it with a simple line break. 	Otherwise the end of a UL might get lost and the next paragraph would be appended to the last bullet of the UL."	self cleanEndOfDocumentIncludingParagraphBreak: false.	self endsWithParagraphBreak ifFalse: [self lineBreak]</body><body package="Help-Model">endsWithLineBreak	| segment |	document isEmpty ifTrue: [^true].	segment := document segmentAtPositionBefore: document size ifAbsent: [nil].	(segment isKindOf: Text2.DocumentSpan)		ifTrue: [			"Testing if the text ends with line or paragraph break characters is less error prone			 than using #isLineBreakPosition: which answers true in so many situations."			^document last = self lineBreakCharacter				or: [document last = self paragraphBreakCharacter]].	(segment isKindOf: Text2.DocumentImage)		ifTrue: [			"Images falsely report that they are lineBreaks when asked via #isLineBreakPosition:.			 Images are inline and text does not break around them."			^false].	"Let the other segements decide if there's a line break."	^document isLineBreakPosition: document size</body><body package="Help-Model">endsWithParagraphBreak	^document isEmpty or: [document last = self paragraphBreakCharacter]</body><body package="Help-Model">lineBreak	"this method appends a line break, which is not to be confused with a paragraph break (see #br)"	self appendString: (String with: self lineBreakCharacter) style: [:style | ]</body><body package="Help-Model">lineBreakCharacter	^16r2028 asCharacter</body><body package="Help-Model">listDepth	^listItemStack size</body><body package="Help-Model">numberOfTrailingSeparatorsIncludingParagraphBreaks: includeParagraphBreaks	| number specialSeparators |	number := 0.	specialSeparators := Set with: self lineBreakCharacter.	includeParagraphBreaks ifTrue:[specialSeparators add: self paragraphBreakCharacter].	document reverseDo: 			[:each |			(each isSeparator or: [specialSeparators includes: each])				ifTrue: [number := number + 1]				ifFalse: [^number]].	^number</body><body package="Help-Model">paragraphBreak	self cleanEndOfDocumentIncludingParagraphBreak: true.	self appendParagraph: ''</body><body package="Help-Model">paragraphBreakCharacter	"this is a paragraph break character"	^Character codePoint: 16r2029</body><body package="Help-Model">shouldBreakAtBlockBeginning	"this also handles bullet list items, where this method returns false in order to avoid breaks right after a bullet"	^(self endsWithLineBreak or: [self endsWithParagraphBreak]) not</body><body package="Help-Model">skip: aNumber	aNumber &gt;= 0		ifTrue: 			[self error: 'skipping only works for negative numbers'.			^self].	document		replaceBetween: document size + aNumber		and: document size		with: ''</body></methods><methods><class-id>Help.DocumentCanvas</class-id> <category>private</category><body package="Help-Model">applyFontChange: aBlock onStyle: style	| font |	font := style fontDescription copy.	aBlock value: font.	^(style copy)		fontDescription: font;		intern</body><body package="Help-Model">applyHeadingStyle: style	^self applyFontChange: 			[:fd |			fd pixelSize: 20.			fd boldness: 1]		onStyle: style</body><body package="Help-Model">applyStyle: styleBlock to: style	^styleBlock isNil		ifTrue: [style]		ifFalse: [(styleBlock value: style copy) intern]</body></methods><methods><class-id>Help.DocumentCanvas</class-id> <category>accessing</category><body package="Help-Model">document	^document</body></methods><methods><class-id>Help.DocumentCanvas</class-id> <category>initialize-release</category><body package="Help-Model">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	listItemStack := OrderedCollection new.	listNumberStack := OrderedCollection new.	self startNewDocument.	^self</body><body package="Help-Model">interruptDocument	"This method allows for generating a sequence of documents while keeping the current style accross documents."	| oldDocument |	oldDocument := document.	document := '' asDocument.	^oldDocument</body><body package="Help-Model">startNewDocument	listItemStack := listItemStack collect: #copy.	document := Text2.Document new.	^document</body></methods><methods><class-id>Help.DocumentCanvas class</class-id> <category>instance creation</category><body package="Help-Model">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Help.APINameKind</class-id> <category>accessing</category><body package="Help-Model">description	^description</body><body package="Help-Model">handle	^handlerBlock value: name</body><body package="Help-Model">setupForName: aString	name := aString</body></methods><methods><class-id>Help.APINameKind</class-id> <category>testing</category><body package="Help-Model">canHandleName: aName	^testBlock value: aName</body><body package="Help-Model">isKind: aSymbol	^kind = aSymbol</body></methods><methods><class-id>Help.APINameKind</class-id> <category>initialize-release</category><body package="Help-Model">named: kindName description: aString if: aTestBlock handleWith: aHandleBlock	kind := kindName.	description := aString.	testBlock := aTestBlock.	handlerBlock := aHandleBlock</body></methods><methods><class-id>Help.APINameKind class</class-id> <category>utility</category><body package="Help-Model">findBindingNamed: aString	| symbol |	(aString includes: $.)		ifTrue: [^aString asQualifiedReference bindingOrNil].	symbol := aString asSymbol.	Smalltalk.Root withAllNameSpacesDo: 			[:namespace |			namespace ~~ Kernel.Undeclared				ifTrue: 					[namespace						localNamesAndBindingsDo: [:key :binding | key = symbol ifTrue: [^binding]]]].	^nil</body></methods><methods><class-id>Help.APINameKind class</class-id> <category>instance creation</category><body package="Help-Model">apinameKind: kind named: aString	| pragmas apinameKinds apinameKind |	pragmas := (Tools.Pragma allNamed: #apiname: in: self classBehavior)				sorted: [:each | each argumentAt: 1] ascending.	apinameKinds := pragmas collect: [:each | self perform: each selector].	apinameKind := kind notNil				ifTrue: 					[apinameKinds detect: 							[:each |							(each isKind: kind) and: 									["also test if the name can be handled. 							If not the dialog will tell that. Otherwise nothing could happen, which							is bad as a result of user interaction"									each canHandleName: aString]]						ifNone: [nil]]				ifFalse: 					[apinameKinds detect: [:each | each canHandleName: aString] ifNone: [nil]].	apinameKind isNil ifTrue: [^nil].	apinameKind setupForName: aString.	^apinameKind</body><body package="Help-Model">named: kindName description: description if: testBlock handleWith: handleBlock	^self new		named: kindName		description: description		if: testBlock		handleWith: handleBlock</body></methods><methods><class-id>Help.DitaFolder</class-id> <category>accessing</category><body package="Help-Model">contentsOfFolderAt: aFilename ifAbsent: aBlock	aFilename tail first = $. ifTrue: [^aBlock value].	^aFilename directoryContents collect: [:each | aFilename / each]</body><body package="Help-Model">fileAt: aUrl	| nonFragmentedUrl |	nonFragmentedUrl := self removeFragmentFromUrl: aUrl.	^files at: nonFragmentedUrl ifAbsent: [nil]</body><body package="Help-Model">fileAt: aUrl put: aFile	^files at: (self removeFragmentFromUrl: aUrl) put: aFile</body><body package="Help-Model">filenameAt: aUrl	^aUrl asURI path inject: path into: [:all :each | all / each]</body><body package="Help-Model">imageAt: aUrl	| imagePath |	imagePath := self pathOfFileAt: aUrl.	^images at: imagePath		ifAbsentPut: [(Graphics.ImageReader fromFile: imagePath) image]</body><body package="Help-Model">path	^path</body><body package="Help-Model">pathOfFileAt: aUrl	^aUrl path inject: path into: [:all :each | all / each]</body><body package="Help-Model">readStreamOnFile: absoluteFilename	^(absoluteFilename withEncoding: #utf8) readStream</body><body package="Help-Model">removeFragmentFromUrl: aURI	^(aURI copy)		fragment: nil;		yourself</body><body package="Help-Model">rootMap	^rootMap</body></methods><methods><class-id>Help.DitaFolder</class-id> <category>testing</category><body package="Help-Model">hasRoot: aByteString	| file |	file := self fileAt: aByteString asURI.	^file notNil and: [file rootObject = rootMap]</body><body package="Help-Model">isFileAt: aFilename	^aFilename isDirectory not</body></methods><methods><class-id>Help.DitaFolder</class-id> <category>instance creation</category><body package="Help-Model">isForFolder: aFilename rootMap: rootName	^path = aFilename asFilename and: [self hasRoot: rootName]</body></methods><methods><class-id>Help.DitaFolder</class-id> <category>initialize-release</category><body package="Help-Model">forPath: aFilename withRoot: rootName	| rootFile |	images := Dictionary new.	path := aFilename asFilename.	self pathExists ifFalse: [HelpNotFoundError raiseWith: aFilename asString].	files := (DitaReader onFolder: self) parseFiles.	files do: 			[:each |			"as soon as a file knows its folder it can resolve urls"			each folder: self].	rootFile := self fileAt: rootName asURI.	rootFile isNil		ifTrue: [HelpNotFoundError raiseWith: (path / rootName) asString].	rootMap := rootFile rootObject</body><body package="Help-Model">pathExists	^path exists</body></methods><methods><class-id>Help.DitaFolder class</class-id> <category>instance creation</category><body package="Help-Model">cacheLastFolder	"this method is for debugging purposes"	^true</body><body package="Help-Model">forPath: aFilename withRoot: rootName	| newFolder |	(lastFolder notNil		and: [lastFolder isForFolder: aFilename rootMap: rootName])			ifTrue: [^lastFolder].	newFolder := self new forPath: aFilename asFilename withRoot: rootName.	self cacheLastFolder ifTrue: [lastFolder := newFolder].	^newFolder</body><body package="Help-Model">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Help.DitaFolder class</class-id> <category>class initialization</category><body package="Help-Model">initialize	lastFolder := nil</body></methods><methods><class-id>Help.DitaFile</class-id> <category>accessing</category><body package="Help-Model">dtd	^dtd</body><body package="Help-Model">dtd: anObject	dtd := anObject</body><body package="Help-Model">ensureNBSPEntityExistsWhile: aBlock	"some dita maps use &amp;nbsp; without it being defined in the doctype. The easiest way around it is to define it in the PredefinedEntities.	In the long term it would be better to define that directly in the XML files though."	XML.PredefinedEntities at: 'nbsp'		put: ((XML.GeneralEntity new)				name: 'nbsp';				text: (String with: 16ra0 asCharacter)).	^aBlock ensure: [XML.PredefinedEntities removeKey: 'nbsp']</body><body package="Help-Model">folder: aDitaFolder	folder := aDitaFolder</body><body package="Help-Model">imageAt: aUrl	^folder imageAt: url , aUrl asURI</body><body package="Help-Model">path	^folder pathOfFileAt: url</body><body package="Help-Model">pathOfFileAt: aUrl	^folder pathOfFileAt: url , aUrl asURI</body><body package="Help-Model">resolveUrl: aUrl	^folder fileAt: url , aUrl asURI</body><body package="Help-Model">rootObject	^rootObject</body><body package="Help-Model">url	^url</body><body package="Help-Model">url: aUrl	url := aUrl</body><body package="Help-Model">xmlFromSourcePointer: sourcePointer	| file rs parser xmlElement |	file := folder filenameAt: url.	rs := folder readStreamOnFile: file.	xmlElement := nil.	[rs position: sourcePointer.	parser := XML.XMLParser new.	self ensureNBSPEntityExistsWhile: 			[xmlElement := parser parseElement: rs withDtd: dtd]]			ensure: [rs close].	DitaSaxDriver new fixAttributesInElement: xmlElement.	^xmlElement</body><body package="Help-Model">xmlObjectCompleted: anObject	"anObject was read as a child in the xml file"	rootObject := anObject.	rootObject beInFile: self</body></methods><methods><class-id>Help.DitaFile</class-id> <category>printing</category><body package="Help-Model">printOn: aStream	super printOn: aStream.	aStream		space;		print: url</body></methods><methods><class-id>Help.DitaFile</class-id> <category>user interface</category><body package="Help-Model">inspectorHierarchies	^Array with: (Tools.Trippy.Hierarchy				id: #dita				label: 'Dita Hierarchy'				root: rootObject				childrenBlock: #children)</body></methods><methods><class-id>Help.DitaTopicRef</class-id> <category>accessing</category><body package="Help-Model">documentName	^self target documentName</body><body package="Help-Model">href	^href</body><body package="Help-Model">target	^self resolveUrl: href</body><body package="Help-Model">topic	^self resolveTopicAtUrl: href</body><body package="Help-Model">topicRefs	super topicRefs isEmpty ifTrue: [^self topic topicRefs].	^super topicRefs</body><body package="Help-Model">topicWithId: id	^self topic topicWithId: id</body><body package="Help-Model">topics	super topics isEmpty ifTrue: [^self topic topics].	^super topics</body><body package="Help-Model">type	^type</body><body package="Help-Model">typeConformTarget	format = 'ditamap' ifTrue: [^self target].	type = 'topic' ifTrue: [^self topic].	^self target</body><body package="Help-Model">xmlAttributeMapping	^(super xmlAttributeMapping)		at: #navtitle put: #xmlNavTitle:;		at: #href put: #xmlHref:;		at: #type put: #xmlType:;		at: #format put: #xmlFormat:;		yourself</body><body package="Help-Model">xmlFormat: aString	format := aString</body><body package="Help-Model">xmlHref: aString	"make sure to have proper slashed, otherwise #asURL wouldn't work correctly, making it harder to resolve the href"	href := aString</body><body package="Help-Model">xmlNavTitle: aString	title := aString</body><body package="Help-Model">xmlType: aString	type := aString</body></methods><methods><class-id>Help.DitaTopicRef</class-id> <category>printing</category><body package="Help-Model">printOn: aStream	super printOn: aStream.	aStream		nextPutAll: ' -&gt; ';		print: href</body><body package="Help-Model">title	^title ifNil: [self topic title]</body></methods><methods><class-id>Help.DitaTopicRef</class-id> <category>testing</category><body package="Help-Model">isTopicRef	^true</body></methods><methods><class-id>Help.DitaTopicRef</class-id> <category>initialize-release</category><body package="Help-Model">fromTopicAt: url in: aFile	href := url asString.	file := aFile</body><body package="Help-Model">initialize	super initialize.	"according to the documentation the type defaults to 'topic' and the format defaults to 'dita' "	type := 'topic'.	format := 'dita'</body></methods><methods><class-id>Help.DitaTopicRef</class-id> <category>converting</category><body package="Help-Model">asTopicRef	^self</body></methods><methods><class-id>Help.DitaTopicRef class</class-id> <category>instance creation</category><body package="Help-Model">fromTopicAt: url in: file	^self new fromTopicAt: url in: file</body></methods><methods><class-id>Help.DitaMap</class-id> <category>accessing</category><body package="Help-Model">asDitaMapIfPossible	^self</body><body package="Help-Model">xmlAttributeMapping	^(super xmlAttributeMapping)		at: #title put: #xmlTitle:;		yourself</body><body package="Help-Model">xmlElementStackTextMapping	^(super xmlElementStackTextMapping)		at: #('map' 'title') put: #xmlTitle:;		yourself</body><body package="Help-Model">xmlTitle: aString	title := aString</body></methods><methods><class-id>Help.DitaMap</class-id> <category>printing</category><body package="Help-Model">displayString	^title ifNil: [super displayString]</body></methods><methods><class-id>Help.StringTrieNode</class-id> <category>private-reading</category><body package="Help-Model">indices	| writeStream |	writeStream := Array new writeStream.	self indicesOn: writeStream.	^writeStream contents</body><body package="Help-Model">indicesOn: writeStream	writeStream nextPutAll: indices.	subTrieNodes do: [:each | each indicesOn: writeStream]</body><body package="Help-Model">nodeAtStream: readStream ifAbsent: aBlock	| character subTrie |	readStream atEnd ifTrue: [^self].	character := readStream next.	subTrie := subTrieNodes at: character ifAbsent: [^aBlock value].	^subTrie nodeAtStream: readStream ifAbsent: aBlock</body></methods><methods><class-id>Help.StringTrieNode</class-id> <category>private-writing</category><body package="Help-Model">addIndex: aNumber	indices add: aNumber</body><body package="Help-Model">atStream: rs addIndex: index	| node |	node := self insertNodeAtStream: rs.	node addIndex: index</body><body package="Help-Model">insertNodeAtStream: readStream	| character subTrie |	readStream atEnd ifTrue: [^self].	character := readStream next.	subTrie := subTrieNodes at: character ifAbsentPut: [self class new].	^subTrie insertNodeAtStream: readStream</body><body package="Help-Model">withWord: word andIndicesDo: aBlock	indices notEmpty ifTrue: [aBlock value: word value: indices].	subTrieNodes		keysAndValuesDo: [:char :each | each withWord: (word copyWith: char) andIndicesDo: aBlock]</body></methods><methods><class-id>Help.StringTrieNode</class-id> <category>initialize-release</category><body package="Help-Model">initialize	super initialize.	subTrieNodes := IdentityDictionary new.	indices := OrderedCollection new.</body></methods><methods><class-id>Help.StringTrieNode class</class-id> <category>instance creation</category><body package="Help-Model">new	^super new initialize</body></methods><methods><class-id>Help.Dita</class-id> <category>printing</category><body package="Help-Model">printOn: aStream	super printOn: aStream.	aStream		space;		print: self fullUrl</body></methods><methods><class-id>Help.DitaRelColSpec</class-id> <category>accessing</category><body package="Help-Model">xmlAttributeMapping	^(super xmlAttributeMapping)		at: #type put: #xmlType:;		yourself</body><body package="Help-Model">xmlType: aString	type := aString</body></methods><methods><class-id>Help.DitaSaxDriver</class-id> <category>entity resolver</category><body package="Help-Model">resolveEntity: publicID systemID: systemID	"This avoids fetching any DTDs during parsing; e.g. in the DOCTYPE element."	^XML.InputSource		uri: systemID		encoding: nil		stream: String new readStream</body></methods><methods><class-id>Help.DitaSaxDriver</class-id> <category>content handler</category><body package="Help-Model">characters: aString	| characterReceiver index |	index := stack findLast: [:each | each object notNil].	index &lt;= 1		ifTrue: 			["&gt;1 because the file is in 1 and the file doesn't care about characters"			^self].	characterReceiver := (stack at: index) object.	characterReceiver appendToSearchString: aString.	characterReceiver xmlText: aString elementStack: self elementStack</body><body package="Help-Model">create: class withAttributes: attributes	| newObject |	newObject := class withXMLAttributes: attributes.	stack last object: newObject.</body><body package="Help-Model">ditaFile	^stack first object</body><body package="Help-Model">elementStack	^stack last allNames</body><body package="Help-Model">endElement: namespaceURI localName: localName qName: name	| completedStackNode |	completedStackNode := stack removeLast.	completedStackNode informParentAboutCompletion</body><body package="Help-Model">fixAttributes: attributes	attributes do: 			[:each |			each expandedName = 'href'				ifTrue: [each value: (each value copyReplaceAll: '\' with: '/')]]</body><body package="Help-Model">fixAttributesInElement: anXMLElement	self fixAttributes: anXMLElement attributes.	anXMLElement realElements do: [:each | self fixAttributesInElement: each]</body><body package="Help-Model">rememberDtd: dtd	self ditaFile dtd: dtd</body><body package="Help-Model">startElement: namespaceURI localName: localName qName: name attributes: attributes	self fixAttributes: attributes.	stack add: (stack last subNodeNamed: localName).	nameClassMapping at: localName asLowercase		ifPresent: [:class | ^self create: class withAttributes: attributes]</body></methods><methods><class-id>Help.DitaSaxDriver</class-id> <category>other</category><body package="Help-Model">sourcePosition: position inStream: stream	stack last startedElementAt: position</body></methods><methods><class-id>Help.DitaSaxDriver</class-id> <category>initialize-release</category><body package="Help-Model">forUrl: aUrl	self ditaFile url: aUrl</body><body package="Help-Model">initialize	super initialize.	stack := OrderedCollection with: (DitaSaxStackNode named: 'file').	stack last object: DitaFile new.	nameClassMapping := (Dictionary new)				at: 'map' put: DitaMap;				at: 'topicref' put: DitaTopicRef;				at: 'dita' put: Dita;				at: 'topic' put: DitaTopic;				at: 'glossentry' put: DitaGlossaryEntry;				at: 'relrow' put: DitaRelRow;				at: 'relcolspec' put: DitaRelColSpec;				at: 'reltable' put: DitaRelTable;				yourself.</body></methods><methods><class-id>Help.DitaSaxDriver class</class-id> <category>instance creation</category><body package="Help-Model">forUrl: aUrl	^self new forUrl: aUrl</body><body package="Help-Model">new	^super new initialize.</body></methods><methods><class-id>Help.DitaReader</class-id> <category>accessing</category><body package="Help-Model">documentationFilenames: aDirectory do: aBlock	| files |	files := ditaFolder contentsOfFolderAt: aDirectory ifAbsent: [^self].	files do: 			[:each |			(ditaFolder isFileAt: each)				ifTrue: [aBlock value: each]				ifFalse: [self documentationFilenames: each do: aBlock]]</body><body package="Help-Model">documentationFilenamesDo: aBlock	| documentationFilenameComponents |	documentationFilenameComponents := ditaFolder path components.	self documentationFilenames: ditaFolder path		do: 			[:absoluteFilename |			"use a unix filename for the forward slashes / "			| relativeURL |			relativeURL := OS.UnixFilename						fromComponents: (absoluteFilename components								allButFirst: documentationFilenameComponents size).			aBlock value: absoluteFilename value: relativeURL asString asURI]</body><body package="Help-Model">parseDocument: absoluteFilename atUrl: documentUrl	| parser saxDriver readStream |	parser := XML.XMLParser new.	parser validate: false.	saxDriver := DitaSaxDriver forUrl: documentUrl.	parser saxDriver: saxDriver.	readStream := ditaFolder readStreamOnFile: absoluteFilename.	readStream peek = $&lt; ifFalse: [readStream next].	parser parse: readStream.	saxDriver rememberDtd: parser dtd.	^saxDriver ditaFile</body><body package="Help-Model">parseFiles	| files |	files := Dictionary new.	self documentationFilenamesDo: 			[:absoluteFilename :relativeURL |			(#('.xml' '.dita' '.ditamap') includes: absoluteFilename extension)				ifTrue: 					[| file |					file := self parseDocument: absoluteFilename atUrl: relativeURL.					file ifNotNil: [files at: relativeURL put: file]]].	^files</body><body package="Help-Model">readStreamOnFile: absoluteFilename	^(absoluteFilename withEncoding: #utf8) readStream</body></methods><methods><class-id>Help.DitaReader</class-id> <category>initialize-release</category><body package="Help-Model">onFolder: folder	ditaFolder := folder</body></methods><methods><class-id>Help.DitaReader class</class-id> <category>instance creation</category><body package="Help-Model">new	^super new initialize.</body><body package="Help-Model">onFolder: ditaFolder	^self new onFolder: ditaFolder</body></methods><methods><class-id>XML.XMLParser</class-id> <category>SAX accessing</category><body package="Help-Model">parseElement: dataSource withDtd: docType	self validate: false.	self on: dataSource.	dtd := docType.	^self parseElement</body></methods><methods><class-id>XML.Element</class-id> <category>accessing</category><body package="Help-Model">attributeAt: aString 	^(self attributes detect: [:ea | ea tag type = aString] ifNone: [^nil])</body></methods><methods><class-id>Help.DocumentationStyles</class-id> <category>styles</category><body package="Help-Model">actionLink	&lt;style&gt;	| style |	style := (self linkStyle)				fontDescription: self actionFont;				yourself.	style padding top: 1.	^style</body><body package="Help-Model">breadCrumpLink	&lt;style&gt;	^(self actionLink)		fontDescription: self breadCrumpFont;		padding: (0 @ 2 corner: 0 @ 2);		lineIndent: 0;		firstLineIndent: 0;		yourself</body><body package="Help-Model">breadCrumpSeparator	&lt;style&gt;	^(self defaultStyle)		fontDescription: self breadCrumpFont;		cursor: #normal;		yourself</body><body package="Help-Model">codeBlockStyle	&lt;style&gt;	^(DocumentStyle new)		fontDescription: self codeStyleFont;		lineIndent: 24;		firstLineIndent: 24;		lineSpacing: 1;		padding: 1;		yourself</body><body package="Help-Model">defaultStyle	&lt;style&gt;	^(DocumentStyle new)		fontDescription: self defaultFont;		lineIndent: 24;		firstLineIndent: 24;		lineSpacing: 5;		padding: 5;		yourself</body><body package="Help-Model">heading1Style	&lt;style: #heading1&gt;	^(DocumentStyle new)		lineIndent: 24;		firstLineIndent: 24;		padding: 5;		yourself</body><body package="Help-Model">heading2Style	&lt;style: #heading2&gt;	^(DocumentStyle new)		lineIndent: 24;		firstLineIndent: 24;		padding: 5;		yourself</body><body package="Help-Model">heading3Style	&lt;style: #heading3&gt;	^(DocumentStyle new)		lineIndent: 36;		firstLineIndent: 36;		padding: 5;		yourself</body><body package="Help-Model">linkStyle	&lt;style&gt;	^(self defaultStyle)		cursor: UI.Cursor fingerPointer;		adornment: #underline;		adornmentColor: (Graphics.ColorValue perform: #blue);		color: (Graphics.ColorValue perform: #blue);		yourself</body><body package="Help-Model">mapStyle	&lt;style: #map&gt;	^self heading1Style</body><body package="Help-Model">noteStyle	&lt;style: #note&gt;	^self defaultStyle</body></methods><methods><class-id>Help.DocumentationStyles</class-id> <category>fonts</category><body package="Help-Model">actionFont	&lt;font&gt;	^self smallFont</body><body package="Help-Model">breadCrumpFont	"this font uses a fixed size so that the bread-crump's text doesn't appear bigger than its input field.	In that case the text would be clipped"	&lt;font&gt;	| defaultFont |	defaultFont := UI.Skins.SkinRegistry current				platformFontDescriptionForLists.	^(defaultFont copy)		pixelSize: (defaultFont pixelSize - 2) / NativeGUIPolicy current globalDPIScaleFactor;		yourself</body><body package="Help-Model">codeStyleFont	&lt;font: #codeph&gt;	^(self defaultNarrowFont)		color: (Graphics.ColorValue red: 0.0 green: 0.0 blue: 0.34);		yourself</body><body package="Help-Model">defaultFont	&lt;font&gt;	^self defaultFontWithSize: self defaultSystemFontSize</body><body package="Help-Model">defaultFontWithSize: aNumber	&lt;font&gt;	| defaultFontSize sizeDiff defaultFont |	defaultFont := self defaultSystemFont.	defaultFontSize := defaultFont pixelSize.	sizeDiff := aNumber - defaultFontSize.	defaultFont pixelSize: defaultFontSize + sizeDiff.	^defaultFont</body><body package="Help-Model">filePathFont	&lt;font: #filepath&gt;	^(self defaultFont)		family: #('courier narrow' 'courier' 'courier_narrow');		boldness: 0.7;		yourself</body><body package="Help-Model">heading1Font	&lt;font: #heading1&gt;	^self headingFontWithSize: 24</body><body package="Help-Model">heading2Font	&lt;font: #heading2&gt;	^self headingFontWithSize: 20</body><body package="Help-Model">heading3Font	&lt;font: #heading3&gt;	^self headingFontWithSize: 18</body><body package="Help-Model">noteTitle	&lt;font&gt;	^(self defaultNarrowFont)		color: (ColorValue red: 0.4 green: 0 blue: 0);		yourself</body><body package="Help-Model">smallFont	&lt;font&gt;	^self defaultFontWithSize: 14</body><body package="Help-Model">uiControlFont	&lt;font: #uicontrol&gt;	^self defaultNarrowFont</body></methods><methods><class-id>Help.DocumentationStyles</class-id> <category>annotation fonts</category><body package="Help-Model">boldFont	"this style is not used for the DitaRenderer. It is only used to add boldness to source-code after it was formatted. 	See Help.DitaAnnotationDecorator&gt;&gt;annotate:in:from:to: for details"	&lt;font: #b&gt;	^(self defaultFont)		boldness: 1;		yourself</body><body package="Help-Model">italicFont	"this style is not used for the DitaRenderer. It is only used to add italics to source-code after it was formatted. 	See Help.DitaAnnotationDecorator&gt;&gt;annotate:in:from:to: for details"	&lt;font: #i&gt;	^(self defaultFont)		italic: true;		yourself</body></methods><methods><class-id>Help.DocumentationStyles class</class-id> <category>class initialization</category><body package="Help-Model">stylePragmas	&lt;pragmas: #instance&gt;	^#(#style: #style #font #font: #formttingStyle #formattingStyle:)</body></methods><methods><class-id>Help.DitaRenderer</class-id> <category>utility</category><body package="Help-Model">inspectorExtraAttributes	&lt;inspectorFields&gt;	^Array with: (Tools.Trippy.DerivedAttribute label: #elementStack				valueBlock: 					[| ws |					ws := String new writeStream.					elementStack do: 							[:each |							ws nextPutAll: ('%&lt;&lt;1s&gt;&gt;&lt;2s&gt;...' expandMacrosWith: each tag asString										with: (each characterData trimSeparators first: 10))]						separatedBy: [ws cr].					ws contents])</body></methods><methods><class-id>Help.DitaRenderer</class-id> <category>tags-inline</category><body package="Help-Model">renderB: bElement	&lt;tag: #b&gt;	self renderInlineBlock: 			[self pushFont: [:font | font boldness: 0.8]				while: [self renderGroup: bElement]]</body><body package="Help-Model">renderCITE: citeElement	&lt;tag: #cite&gt;	self renderGroup: citeElement</body><body package="Help-Model">renderCODEPH: codephElement	&lt;tag: #codeph&gt;	self renderInlineBlock: 			[self renderGroup: codephElement]</body><body package="Help-Model">renderFILEPATH: codephElement	&lt;tag: #filepath&gt;	self renderInlineBlock: [self renderGroup: codephElement]</body><body package="Help-Model">renderI: iElement	&lt;tag: #i&gt;	self renderInlineBlock: 			[self pushFont: [:font | font italic: true]				while: [self renderGroup: iElement]]</body><body package="Help-Model">renderOPTION: optionElement	&lt;tag: #option&gt;	self renderI: optionElement</body><body package="Help-Model">renderQ: quoteElement	&lt;tag: #q&gt;	self renderInlineBlock: 			[canvas appendString: (String with: 16r201c asCharacter).			self renderGroup: quoteElement.			canvas appendString: (String with: 16r201d asCharacter)]</body><body package="Help-Model">renderTERM: termElement	&lt;tag: #term&gt;	self renderI: termElement</body><body package="Help-Model">renderUICONTROL: uicontrolElement	&lt;tag: #uicontrol&gt;	self renderB: uicontrolElement</body><body package="Help-Model">renderUSERINPUT: userinputElement	&lt;tag: #userinput&gt;	self renderInlineBlock: 			[self renderGroup: userinputElement]</body></methods><methods><class-id>Help.DitaRenderer</class-id> <category>tags-deflist</category><body package="Help-Model">renderDD: ddElement	&lt;tag: #dd&gt;	self indentWhile: [self indentWhile: [self renderBlock: ddElement]]</body><body package="Help-Model">renderDL: dlElement	&lt;tag: #dl&gt;	self indentWhile: [self renderBlock: dlElement]</body><body package="Help-Model">renderDLENTRY: dlentryElement	&lt;tag: #dlentry&gt;	self renderBlock: dlentryElement</body><body package="Help-Model">renderDT: dtElement	&lt;tag: #dt&gt;	self indentWhile: [self renderB: dtElement]</body></methods><methods><class-id>Help.DitaRenderer</class-id> <category>tags-dita</category><body package="Help-Model">renderBODY: bodyElement	&lt;tag: #body&gt;	self renderBlock: bodyElement</body><body package="Help-Model">renderDITA: ditaElement	&lt;tag: #dita&gt;	self renderBlock: ditaElement</body><body package="Help-Model">renderSECTION: sectionElement	&lt;tag: #section&gt;	self		increaseHeadingWhile: [self indentWhile: [self renderBlock: sectionElement]]</body></methods><methods><class-id>Help.DitaRenderer</class-id> <category>tags-dita-meta</category><body package="Help-Model">renderCOPYRIGHT: copyrightYearElement	&lt;tag: #copyright&gt;	self renderBlock: copyrightYearElement</body><body package="Help-Model">renderCOPYRIGHTHOLDER: copyrightHolderElement	&lt;tag: #copyrholder&gt;	self renderBlock: copyrightHolderElement</body><body package="Help-Model">renderCOPYRIGHTYEAR: copyrightYearElement	&lt;tag: #copyryear&gt;	self renderBlock: copyrightYearElement</body><body package="Help-Model">renderMAP: mapElement	&lt;tag: #map&gt;	self		renderBlock: [self appendString: (mapElement attributeAt: 'title') value].	self renderBlock: mapElement</body><body package="Help-Model">renderSHORTDESC: shortdescElement	&lt;tag: #shortdesc&gt;	self renderBlock: shortdescElement</body><body package="Help-Model">renderTITLE: titleElement	&lt;tag: #title&gt;	| indent |	self renderBlock: 			[indent := 0.			self pushStyleAndFontNamed: self currentHeadingStyle				while: 					[self renderGroup: titleElement.					indent := self currentIndent].			self currentIndent: indent]</body><body package="Help-Model">renderTOPIC: topicElement	&lt;tag: #topic&gt;	self increaseHeadingWhile:[self renderBlock: topicElement]</body><body package="Help-Model">renderTOPICGROUP: topicGroupElement	&lt;tag: #topicgroup&gt;	self renderBlock: topicGroupElement</body><body package="Help-Model">renderTOPICHEAD: headElement	&lt;tag: #topichead&gt;	self renderBlock: headElement</body><body package="Help-Model">renderTOPICMETA: topicMetaElement	&lt;tag: #topicmeta&gt;	self renderBlock: topicMetaElement</body></methods><methods><class-id>Help.DitaRenderer</class-id> <category>tags-glossary</category><body package="Help-Model">renderGLOSSARYDEF: glossaryDefElement	&lt;tag: #glossdef&gt;	self renderDD: glossaryDefElement</body><body package="Help-Model">renderGLOSSARYENTRY: glossaryEntryElement	&lt;tag: #glossentry&gt;	self renderBlock: glossaryEntryElement</body><body package="Help-Model">renderGLOSSARYTERM: glossaryTermElement	&lt;tag: #glossterm&gt;	self renderDT: glossaryTermElement</body></methods><methods><class-id>Help.DitaRenderer</class-id> <category>tags-list</category><body package="Help-Model">renderLI: liElement	&lt;tag: #li&gt;	| wasInLI |	canvas cleanEmptyListItem.	canvas appendListItem: '' style: [:style | currentStyle].	wasInLI := insideLI.	insideLI := true.	[self renderGroup: liElement] ensure: [insideLI := wasInLI]</body><body package="Help-Model">renderOL: olElement	&lt;tag: #ol&gt;	self renderElement: olElement asList: #decimal</body><body package="Help-Model">renderSL: olElement	&lt;tag: #sl&gt;	self		renderOL: olElement</body><body package="Help-Model">renderSLI: sliElement	&lt;tag: #sli&gt;	self renderGroup: sliElement</body><body package="Help-Model">renderUL: ulElement	&lt;tag: #ul&gt;	self renderElement: ulElement asList: #bullet.</body></methods><methods><class-id>Help.DitaRenderer</class-id> <category>tags-block</category><body package="Help-Model">renderCODEBLOCK: codeblockElement	&lt;tag: #codeblock&gt;	self renderPRE: codeblockElement</body><body package="Help-Model">renderEXAMPLE: exampleElement	&lt;tag: #example&gt;	self renderBlock: exampleElement</body><body package="Help-Model">renderNOTE: noteElement	&lt;tag: #note&gt;	| type capitalizedLabel |	self renderBlock: 			[self pushFont: #noteTitle						while: 							[type := (noteElement attributeAt: 'type') value										ifNil: [(#Note &lt;&lt; #help &gt;&gt; 'Note') asString].							capitalizedLabel := '&lt;1s&gt;&lt;2s&gt;: '										expandMacrosWith: (type first: 1) asUppercase										with: (type allButFirst: 1).							self appendString: capitalizedLabel].					self renderGroup: noteElement]</body><body package="Help-Model">renderP: pElement	&lt;tag: #p&gt;	self renderBlock: 			["render an inline-block in order to preserve spaces between &lt;b&gt; or &lt;codeph&gt; elements like in:			&lt;codeph&gt;#a&lt;/codeph&gt; &lt;codeph&gt;#b&lt;/codeph&gt;. The symbols are &lt;codeph&gt; the spaces are not			but the space should still be printed"			self renderInlineBlock: pElement]</body><body package="Help-Model">renderPRE: preElement	&lt;tag: #pre&gt;	self indentWhile: 			[self keepWhiteSpaceWhile: 					[self trimSeparatorsWhile: 							[self pushStyle: #codeBlockStyle while: [self renderSoftBlock: preElement]]]]</body></methods><methods><class-id>Help.DitaRenderer</class-id> <category>tags-table</category><body package="Help-Model">renderCOLUMNSPEC: colSpecElement	&lt;tag: #colspec&gt;	self renderBlock: colSpecElement</body><body package="Help-Model">renderTABLE: tableElement	&lt;tag: #table&gt;	self renderChildrenNamed: #('title' 'desc' 'tgroup') of: tableElement</body><body package="Help-Model">renderTABLEBODY: tableBodyElement	&lt;tag: #tbody&gt;	self renderChildrenNamed: 'row' of: tableBodyElement</body><body package="Help-Model">renderTABLEENTRY: tableEntryElement	&lt;tag: #entry&gt;	self renderBlock: tableEntryElement</body><body package="Help-Model">renderTABLEGROUP: tableGroupElement	&lt;tag: #tgroup&gt;	self renderChildrenNamed: #('colspec' 'thead' 'tbody') of: tableGroupElement</body><body package="Help-Model">renderTABLEHEAD: tableHeadElement	&lt;tag: #thead&gt;	self renderChildrenNamed: 'row' of: tableHeadElement</body><body package="Help-Model">renderTABLEROW: rowElement	&lt;tag: #row&gt;	self renderBlock: [self renderChildrenNamed: 'entry' of: rowElement]</body></methods><methods><class-id>Help.DitaRenderer</class-id> <category>tags-special</category><body package="Help-Model">renderALT: altElement	&lt;tag: #alt&gt;	"for now do not render ALT elements"</body><body package="Help-Model">renderAPINAME: apinameElement	&lt;tag: #apiname&gt;	| kind title apinameKind |	kind := nil.	(apinameElement attributeAt: 'otherprops')		ifNotNil: [:attr | kind := attr value asSymbol].	apinameKind := APINameKind apinameKind: kind named: apinameElement characterData.	title := (apinameElement attributeAt: 'title')				ifNotNil: #value				ifNil: [apinameKind ifNotNil: #description].	self		linkTo: [self executeAPINameKind: apinameKind with: apinameKind]		named: title		while: [self renderGroup: apinameElement]</body><body package="Help-Model">renderIMAGE: imageElement	&lt;tag: #image&gt;	| href image |	href := (imageElement attributeAt: 'href') value.	image := ditaObject imageAt: href.	image isNil ifTrue: [^self].	self renderInlineBlock: [canvas appendImage: image style: currentStyle]</body><body package="Help-Model">renderIMG: imgElement	&lt;tag: #img&gt;	self renderInlineBlock:[canvas appendString: ('[IMG]')]</body><body package="Help-Model">renderINDEXTERM: indexTermElement	&lt;tag: #indexterm&gt;	"currently the indexterm is not rendered"</body><body package="Help-Model">renderXREF: xrefElement	&lt;tag: #xref&gt;	| href format scope title |	href := (xrefElement attributeAt: 'href') ifNotNil: #value.	format := (xrefElement attributeAt: 'format')				ifNil: ['st']				ifNotNil: #value.	scope := (xrefElement attributeAt: 'scope')				ifNil: ['external']				ifNotNil: #value.	title := (xrefElement attributeAt: 'title') ifNotNil:#value.	self		linkTo: [self runXref: href format: format scope: scope]		named: title		while: [self renderGroup: xrefElement]</body></methods><methods><class-id>Help.DitaRenderer</class-id> <category>xref</category><body package="Help-Model">xrefHandleHtml: href 	&lt;xref: #html scope: #external&gt;		Smalltalk.ExternalWebBrowser open: href</body><body package="Help-Model">xrefHandlePdf: href	"The href argument is expected to be relative to $(VISUALWORKS).	 The final URL path name 'dummy' is needed because FileURL(URLWithPath) &gt;&gt; mergeRelativePath: deliberately drops its last component before merging something into it."	&lt;xref: #pdf scope: #external&gt;	| subUrl baseUrl |	subUrl := OS.URI fromString: href.	baseUrl := OS.FileURL fromFilename: (OS.LogicalFilename named: '$(VISUALWORKS)') asFilename / 'dummy'.	Smalltalk.ExternalWebBrowser open: (baseUrl , subUrl) asFilename asString</body><body package="Help-Model">xrefHandleSmalltalk: href 	&lt;xref: #st scope: #external&gt;		(href beginsWith: 'st:')		ifTrue: [^Kernel.Compiler evaluate: (href allButFirst: 'st:' size)].	(href beginsWith: 'prereq:') ifTrue: [^self handlePrerequisteHref: href]</body></methods><methods><class-id>Help.DitaRenderer class</class-id> <category>instance creation</category><body package="Help-Model">tagPragmas	&lt;pragmas: #instance&gt;	^#(#tag:)</body><body package="Help-Model">xrefPragmas	&lt;pragmas: #instance&gt;	^#(#xref: #xref:scope:)</body></methods><methods><class-id>Help.APINameKind class</class-id> <category>tags-special</category><body package="Help-Model">apinameBinding	&lt;apiname: 1&gt;	^self		named: #binding		description: (#BrowseThisDefinition &lt;&lt; #help &gt;&gt; 'Browse this definition') asString		if: [:aString | (self findBindingNamed: aString) notNil]		handleWith: 			[:aString |			| browser |			browser := Refactory.Browser.RefactoringBrowser open.			browser navigator setBinding: (self findBindingNamed: aString)]</body><body package="Help-Model">apinameImplementors	&lt;apiname: 3&gt;	^self		named: #implementors		description: (#BrowseImplementorsOfThisMethod &lt;&lt; #help &gt;&gt; 'Browse implementors of this method') asString		if: 			[:aString |			(Refactory.Browser.BrowserEnvironment new implementorsOf: aString asSymbol)				notEmpty]		handleWith: 			[:aString |			(Refactory.Browser.BrowserEnvironment new implementorsOf: aString asSymbol)				openEditor]</body><body package="Help-Model">apinamePundle	&lt;apiname: 2&gt;	| browser |	^self		named: #pundle		description: (#BrowseThisComponent &lt;&lt; #help &gt;&gt; 'Browse this component') asString		if: [:aString | (Store.Registry pundleNamed: aString) notNil]		handleWith: 			[:aString |			(Store.Registry pundleNamed: aString)				ifNotNil: 					[:pundle |					browser := Refactory.Browser.RefactoringBrowser open.					browser navigator selectPundle: pundle]]</body><body package="Help-Model">apinameSenders	&lt;apiname: 4&gt;	^self		named: #sender		description: (#BrowseSendersOfThisMethod &lt;&lt; #help &gt;&gt; 'Browse senders of this method')	asString		if: 			[:aString |			(Refactory.Browser.BrowserEnvironment new referencesTo: aString asSymbol)				notEmpty]		handleWith: 			[:aString |			(Refactory.Browser.BrowserEnvironment new referencesTo: aString asSymbol)				openEditor]</body></methods><methods><class-id>Help.APINameKind class</class-id> <category>pragmas</category><body package="Help-Model">apinamePragmas	&lt;pragmas: #class&gt;	^#(#apiname:)</body></methods><initialize><class-id>Help.DocumentationStyles</class-id></initialize><initialize><class-id>Help.ScratchPad</class-id></initialize><initialize><class-id>Help.DitaFolder</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>FuzzyStringSearch</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>suggestions criteria caseInsensitive </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Collections-Text</package></attributes></class><class><name>Element</name><environment>XML</environment><super>XML.Node</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tag attributes namespaces elements definition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Nodes</category><attributes><package>XML</package></attributes></class><class><name>XMLParser</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceStack hereChar hereCharNumBytes lastSource currentSource dtd unresolvedIDREFs definedIDs latestID sax elementStack validating flags eol buffer nameBuffer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-Parsing</category><attributes><package>XML</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>SAXDriver</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>locator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-SAX</category><attributes><package>XML</package></attributes></class></st-source>