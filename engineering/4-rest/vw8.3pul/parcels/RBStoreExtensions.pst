<?xml version="1.0"?><st-source><!-- Name: RBStoreExtensionsNotice: Copyright 1999-2015 Cincom Systems, Inc.  All rights reserved.This utility was written by John Brant.  It was extended by Georg Heeg, Clemens Hoffmann, Dirk Hofmann, Taylan Kraus, Daniel Kümmel and Niall Ross.Comment: This package contains the Version History tool for Store.  While it is loaded, the Version History tab is shown in the RB when a Bundle, Package, Class, Method, Namespace or Shared Variable is selected.  From its graphical display, you can browse versions, compare differences between versions,  load a version, etc..  Drop-down menus let you control whether to show all versions or only a specific number or (for packages and bundles) only those above a specific blessing level.The currently-loaded version is shown with a bold outline box and a bold label.  If you select another version and load it, the bold outline will move to the new version immediately the load completes, but the bold label will stay on the original version until the graph is redisplayed.  (This may be useful when using the tool to compare versions, or to compare the effects of loading versions.)If you click on an item, it is coloured yellow and information about it is shown in the pane below:  its blessings for packages or bundles, its containing packages for items within packages.If you drag-drop one item on another, a comparison browser is opened.This version adds presentation of merges.DbIdentifier: bear73DbTrace: 454551DbUsername: nrossDbVersion: 8.1 - 2DevelopmentPrerequisites: #(#(#any 'HotDraw Framework' '') #(#any 'Browser-BrowserUI' '') #(#any 'StoreBase' ''))PackageName: RBStoreExtensionsParcel: #('RBStoreExtensions')ParcelName: RBStoreExtensionsPrerequisiteDescriptions: #(#(#name 'HotDraw Framework') #(#name 'Browser-BrowserUI') #(#name 'StoreBase' #componentType #bundle))PrerequisiteParcels: #(#('HotDraw Framework' '') #('Browser-BrowserUI' '') #('StoreBase' ''))PrintStringCache: (8.1 - 2,nross)Version: 8.1 - 2Post-Load Block: 	[ :pkg |Refactory.HotDraw.Tool reinitialize.Refactory.Browser.VersionFigure instanceMethodsChanged.(ExternalDatabaseConnection allSubclasses reject: [:each | each glorpStoreDatabasePlatformClass isNil]) isEmpty ifTrue:	[Transcript cr; show: 'WARNING:  load a StoreFor... parcel or package to make:'; cr; tab; show:'- Store menus usable'; cr; tab; show: '- RBStoreExtensions usable'; cr]]Post-Unload Block: 	[	Refactory.HotDraw.Tool reinitialize]Date: 7:20:43 AM January 9, 2015 --><time-stamp>From VisualWorks®, Pre-Release 8.1 (jan15.1) of January 9, 2015 on January 9, 2015 at 7:20:43 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>VersionFigure</name><environment>Refactory.Browser</environment><super>Refactory.HotDraw.CompositeFigure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>wasLoaded text versionInformation </inst-vars><class-inst-vars>popupMenu dragDropAction </class-inst-vars><imports>			Store.Glorp.*			Store.*			</imports><category>Browser-StoreExtensions</category><attributes><package>RBStoreExtensions</package></attributes></class><comment><class-id>Refactory.Browser.VersionFigure</class-id><body>VersionFigure is a Figure that is used to display a version of a program item.Subclasses must implement the following messages:	accessing		browse			this method should open a browser on the specific version of the program item</body></comment><class><name>PundleVersionFigure</name><environment>Refactory.Browser</environment><super>Refactory.Browser.VersionFigure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-StoreExtensions</category><attributes><package>RBStoreExtensions</package></attributes></class><comment><class-id>Refactory.Browser.PundleVersionFigure</class-id><body>PundleVersionFigure is the version figure for bundles and packages.Subclasses must implement the following messages:	private		codeComponent			returns the package or bundle we are viewing</body></comment><class><name>PundleShadowVersionFigure</name><environment>Refactory.Browser</environment><super>Refactory.Browser.PundleVersionFigure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mergeTraces </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-StoreExtensions</category><attributes><package>RBStoreExtensions</package></attributes></class><comment><class-id>Refactory.Browser.PundleShadowVersionFigure</class-id><body>PundleShadowVersionFigure is the abstract superclass of pundles which are only in the database.Subclasses must implement the following messages:	private		replicateTo:Instance Variables	mergeTraces	&lt;Object | ProtoObject | RemoteObject&gt;	description of mergeTraces</body></comment><class><name>PackageVersionFigure</name><environment>Refactory.Browser</environment><super>Refactory.Browser.PundleShadowVersionFigure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-StoreExtensions</category><attributes><package>RBStoreExtensions</package></attributes></class><comment><class-id>Refactory.Browser.PackageVersionFigure</class-id><body>PackageVersionFigure is the version figure for packages.</body></comment><class><name>VersionDrawingEditor</name><environment>Refactory.Browser</environment><super>Refactory.HotDraw.DrawingEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>versionInformationHolder activeFigure blessingFilter countingFilter allFigures selectedFigure </inst-vars><class-inst-vars></class-inst-vars><imports>			private Refactory.HotDraw.*			private Store.Glorp.*			private Store.*			</imports><category>Browser-StoreExtensions</category><attributes><package>RBStoreExtensions</package></attributes></class><comment><class-id>Refactory.Browser.VersionDrawingEditor</class-id><body>VersionDrawingEditor is the drawing editor for the version history diagram.Instance Variables:	versionInformationHolder	&lt;ValueHolder&gt;	a value holder that is used to display the information of the program item that the mouse is currently over</body></comment><class><name>VersionCodeTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.CodeTool</super><private>false</private><indexed-type>none</indexed-type><inst-vars>versionEditor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-StoreExtensions</category><attributes><package>RBStoreExtensions</package></attributes></class><comment><class-id>Refactory.Browser.VersionCodeTool</class-id><body>VersionCodeTool is the code tool that displays a version history diagram of the selected item.Instance Variables:	versionEditor	&lt;VersionDrawingEditor&gt;	the HotDraw diagram of the version history</body></comment><class><name>PackageItemFigure</name><environment>Refactory.Browser</environment><super>Refactory.Browser.VersionFigure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>package </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-StoreExtensions</category><attributes><package>RBStoreExtensions</package></attributes></class><comment><class-id>Refactory.Browser.PackageItemFigure</class-id><body>PackageItemFigure is the version figure for items contained within packages (e.g., classes and methods).Instance Variables:	package	&lt;Store.Package&gt;	the package we are contained within</body></comment><class><name>SharedVariableVersionFigure</name><environment>Refactory.Browser</environment><super>Refactory.Browser.PackageItemFigure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>RBStoreExtensions</package></attributes></class><comment><class-id>Refactory.Browser.SharedVariableVersionFigure</class-id><body>SharedVariableVersionFigure is a version figure for a shared variable.</body></comment><class><name>PundleCurrentVersionFigure</name><environment>Refactory.Browser</environment><super>Refactory.Browser.PundleVersionFigure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-StoreExtensions</category><attributes><package>RBStoreExtensions</package></attributes></class><comment><class-id>Refactory.Browser.PundleCurrentVersionFigure</class-id><body>PundleCurrentVersionFigure is the abstract superclass of pundles which are in the image.</body></comment><class><name>BundleCurrentVersionFigure</name><environment>Refactory.Browser</environment><super>Refactory.Browser.PundleCurrentVersionFigure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-StoreExtensions</category><attributes><package>RBStoreExtensions</package></attributes></class><comment><class-id>Refactory.Browser.BundleCurrentVersionFigure</class-id><body>BundleCurrentVersionFigure is the class of bundles which are in the image.</body></comment><class><name>TreeReference</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tree type isImmediate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-StoreExtensions</category><attributes><package>RBStoreExtensions</package></attributes></class><comment><class-id>Refactory.Browser.TreeReference</class-id><body>TreeReference is a helper class for the version code tool.Instance Variables	isImmediate	&lt;Boolean&gt;	description of isImmediate	tree	&lt;&gt;	description of tree	type	&lt;Object | RemoteObject&gt;	description of type</body></comment><class><name>NamespaceVersionFigure</name><environment>Refactory.Browser</environment><super>Refactory.Browser.PackageItemFigure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>RBStoreExtensions</package></attributes></class><comment><class-id>Refactory.Browser.NamespaceVersionFigure</class-id><body>NamespaceVersionFigure is a version figure for a name space.</body></comment><class><name>MethodVersionFigure</name><environment>Refactory.Browser</environment><super>Refactory.Browser.PackageItemFigure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-StoreExtensions</category><attributes><package>RBStoreExtensions</package></attributes></class><comment><class-id>Refactory.Browser.MethodVersionFigure</class-id><body>MethodVersionFigure is the version figure for a method.</body></comment><class><name>Tree</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>figure subtrees tops bottoms parentRefs childRefs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-StoreExtensions</category><attributes><package>RBStoreExtensions</package></attributes></class><comment><class-id>Refactory.Browser.Tree</class-id><body>Tree is a helper class for the version code tool. It performs the layout of the nodes in the diagram. It makes an approximation of the optimal tree layout.Instance Variables:	bottoms	&lt;OrderedCollection of: Integer&gt;	the bottoms of each level in the tree	figure	&lt;Refactory.HotDraw.Figure&gt;	the version figure for us	subtrees	&lt;SequenceableCollection of: Tree&gt;	our subtrees	tops	&lt;OrderedCollection of: Integer&gt;	the tops of each level in the tree</body></comment><class><name>PackageCurrentVersionFigure</name><environment>Refactory.Browser</environment><super>Refactory.Browser.PundleCurrentVersionFigure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-StoreExtensions</category><attributes><package>RBStoreExtensions</package></attributes></class><comment><class-id>Refactory.Browser.PackageCurrentVersionFigure</class-id><body>PackageCurrentVersionFigure  is the class of packages which are in the image.</body></comment><class><name>ClassVersionFigure</name><environment>Refactory.Browser</environment><super>Refactory.Browser.PackageItemFigure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-StoreExtensions</category><attributes><package>RBStoreExtensions</package></attributes></class><comment><class-id>Refactory.Browser.ClassVersionFigure</class-id><body>ClassVersionFigure is the version figure for a class.</body></comment><class><name>BundleVersionFigure</name><environment>Refactory.Browser</environment><super>Refactory.Browser.PundleShadowVersionFigure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-StoreExtensions</category><attributes><package>RBStoreExtensions</package></attributes></class><comment><class-id>Refactory.Browser.BundleVersionFigure</class-id><body>BundleVersionFigure is the version figure for a bundle.</body></comment><shared-variable><name>Images</name><environment>Store.BasicBlessingPolicy</environment><private>false</private><constant>false</constant><category>resources</category><attributes><package>RBStoreExtensions</package></attributes></shared-variable><shared-variable><name>Images</name><environment>Refactory.Browser.PundleVersionFigure</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RBStoreExtensions</package></attributes></shared-variable><methods><class-id>Refactory.Browser.VersionFigure</class-id> <category>testing</category><body package="RBStoreExtensions">isLoaded	^false	"This is hard to compute for some code components"</body></methods><methods><class-id>Refactory.Browser.VersionFigure</class-id> <category>displaying</category><body package="RBStoreExtensions">displayOn: aGraphicsContext 	self isLoaded = wasLoaded ifFalse:		[wasLoaded := wasLoaded not.		text paragraph text emphasizeAllWith: (wasLoaded ifTrue: [#bold] ifFalse: [nil]).		self components first lineWidth: (wasLoaded ifTrue: [2] ifFalse: [1])].	super displayOn: aGraphicsContext.</body><body package="RBStoreExtensions">printOn: aStream	aStream		nextPut: $|;		nextPutAll: self label;		nextPut: $|</body></methods><methods><class-id>Refactory.Browser.VersionFigure</class-id> <category>accessing</category><body package="RBStoreExtensions">blessingLevel	^nil</body><body package="RBStoreExtensions">menuAt: aPoint 	^self class popupMenu		setDynamicPropertiesFrom: self;		yourself</body><body package="RBStoreExtensions">mergeTraces	^#()</body><body package="RBStoreExtensions">primaryKey	^self model primaryKey</body><body package="RBStoreExtensions">timestamp	^self model localTimestamp</body><body package="RBStoreExtensions">trace	^self model previous ifNotNil: #primaryKey</body><body package="RBStoreExtensions">versionInformation	^versionInformation 		ifNil: [versionInformation := self buildVersionInformation]</body></methods><methods><class-id>Refactory.Browser.VersionFigure</class-id> <category>initialize-release</category><body package="RBStoreExtensions">initialize	super initialize.	wasLoaded := false.	self opaque</body><body package="RBStoreExtensions">label	^self model timeStampString</body><body package="RBStoreExtensions">on: aPackage 	| box |	model := aPackage.	(text := Refactory.HotDraw.TextFigure new)		setParagraph: self label asComposedText origin: 0 @ 0;		bottomRight: text bottomRight + (7 @ 0);		alignUsing: #centered.	box := Refactory.HotDraw.RectangleFigure new		rectangle: (text bounds expandedBy: 7@0).	self		add: box;		add: text</body></methods><methods><class-id>Refactory.Browser.VersionFigure</class-id> <category>private</category><body package="RBStoreExtensions">buildVersionInformation	^self subclassResponsibility</body><body package="RBStoreExtensions">dispatchMenuSelector: aSelector with: aMenuItem	"Execute aSelector and answer the result. The selector may have	zero or one arguments (the menuitem)."	^[aSelector last = $: 		ifTrue: [self perform: aSelector with: aMenuItem]		ifFalse: [self perform: aSelector]] 			on: Error			do: 				[:error | 				Transcript 					show: (#errMenuDNU &lt;&lt; #dialogs &gt;&gt; '&lt;n&gt;Menu in &lt;1p&gt; does not understand &lt;2p&gt; for &lt;3p&gt;.&lt;n&gt;Answering true.' 									expandMacrosWith: self									with: aSelector 									with: self topComponent model).					error return: true]</body><body package="RBStoreExtensions">dragDrop: aFigure	self class dragDropAction ifNotNil:		[:dda | self perform: dda with: aFigure model]</body><body package="RBStoreExtensions">load	[self model loadSource] withStoreFeedbackOn: self topComponent</body></methods><methods><class-id>Refactory.Browser.VersionFigure</class-id> <category>attribute accessing</category><body package="RBStoreExtensions">beVisible	super beVisible.	self invalidateRectangle: self bounds repairNow: true</body></methods><methods><class-id>Refactory.Browser.VersionFigure</class-id> <category>removing</category><body package="RBStoreExtensions">removeAll: aCollection	super removeAll: aCollection.	self invalidateRectangle: self bounds repairNow: true.	^aCollection</body></methods><methods><class-id>Refactory.Browser.VersionFigure class</class-id> <category>instance creation</category><body package="RBStoreExtensions">on: storeRecord 	^(self new)		on: storeRecord;		yourself</body></methods><methods><class-id>Refactory.Browser.VersionFigure class</class-id> <category>class initialization</category><body package="RBStoreExtensions">clearMenu	popupMenu := nil</body><body package="RBStoreExtensions">initialize	self rebuildMenu</body><body package="RBStoreExtensions">instanceMethodsChanged	"A Menu has changed.  Flush all subclasses' popupMenu.  Note that, when loading from scratch, this method may be called before all of my methods that rebuildiMenu needs are installed, specifically #actionDictionary and #rebuildMenu itself.  We therefore flush for lazy rebuild, in accord with #instanceMethodsChanged coding style (see super comment) rather than attempt to rebuild."	self withAllSubclasses do: [:cl | cl clearMenu]</body></methods><methods><class-id>Refactory.Browser.VersionFigure class</class-id> <category>private</category><body package="RBStoreExtensions">actionDictionary	| actions |	actions := Dictionary new.	(Pragma allNamed: #actionNamed:overrideLevel: from: self to: VersionFigure sortedByArgument: 2)		do: [:pragma | actions at: (pragma argumentAt: 1) put: pragma selector].	^actions</body><body package="RBStoreExtensions">rebuildMenu		| builder actions groupIndex |	builder := MenuBuilder new.	actions := self actionDictionary.	dragDropAction := actions at: #dragDrop ifAbsent: [].	groupIndex := 0.	(Pragma allNamed: #menuItem:position:action:enabled: from: self to: VersionFigure sortedByArgument: 2) do:		[:pragma || label group action enablement |		label := pragma argumentAt: 1.		group := (pragma argumentAt: 2) truncated.		action := actions at: (pragma argumentAt: 3) ifAbsent: [#halt].		(enablement := pragma argumentAt: 4) isSymbol			ifTrue: [enablement := actions at: enablement ifAbsent: []].		group = groupIndex ifFalse: [builder line. groupIndex := group].		builder addItem:			((MenuItem labeled: label)				enablement: enablement;				value: action;				yourself)].	popupMenu := builder menu</body></methods><methods><class-id>Refactory.Browser.VersionFigure class</class-id> <category>menu</category><body package="RBStoreExtensions">dragDropAction	^dragDropAction</body><body package="RBStoreExtensions">popupMenu	popupMenu isNil ifTrue: [self rebuildMenu].	^popupMenu</body></methods><methods><class-id>Refactory.Browser.PundleVersionFigure</class-id> <category>private</category><body package="RBStoreExtensions">codeComponent	^self subclassResponsibility</body><body package="RBStoreExtensions">connectToDatabaseName	| names |	names := Store.ConnectionDialog profiles collect: [:each | each name].	^Dialog 		choose: (#SelectADatabaseToReplicateToC &lt;&lt; #browser &gt;&gt; 'Select a database to replicate to:')		fromList: names		values: names		lines: 8		cancel: [nil]</body><body package="RBStoreExtensions">label	^self model version</body></methods><methods><class-id>Refactory.Browser.PundleVersionFigure</class-id> <category>accessing</category><body package="RBStoreExtensions">blessingLevel	^self model blessingLevel</body><body package="RBStoreExtensions">reconcileIt	^[self model getImagePundle reconcileWithDbVersion: self model]		withStoreFeedbackOn: self topComponent</body><body package="RBStoreExtensions">versionInformation	^((#x1sBlessingC2s &lt;&lt; #browser &gt;&gt; '&lt;1s&gt;; Blessing: &lt;2s&gt;')			expandMacrosWith: super versionInformation			with: self model blessingLevelString)</body></methods><methods><class-id>Refactory.Browser.PundleVersionFigure</class-id> <category>testing</category><body package="RBStoreExtensions">isLoaded	| bundleModel |	bundleModel := self codeComponent.	bundleModel isNil ifTrue: [^false].	^bundleModel dbTrace = self model primaryKey</body></methods><methods><class-id>Refactory.Browser.PundleShadowVersionFigure</class-id> <category>actions</category><body package="RBStoreExtensions">browseIt	"This blocks invoking browse (meaning open an RB on the class) if you are debugging an instance of this."	(StoreForGlorpBrowserEnvironment on: self model) openEditor.</body></methods><methods><class-id>Refactory.Browser.PundleShadowVersionFigure</class-id> <category>private</category><body package="RBStoreExtensions">buildVersionInformation	| blessings str |	blessings := model blessings.	str := (blessings isNil or: [blessings isEmpty])		ifTrue: ['No blessings']		ifFalse: [Policies blessingPolicy describeBlessings: blessings].	^str</body><body package="RBStoreExtensions">calculateMergeTraces	"This is just a fallback for lazy initialization.	The normal way to load merge traces is via #prefetchMergeTracesFor:"	| traces names |	traces := OrderedCollection new.	(names := self integratedVersionsNames) isEmpty ifTrue: [^#()].	names := names asSet.	(self model class allVersionsWithName: self model name) do:		[:pundle | (names includes: (pundle version ifNil:[''])) ifTrue: [traces add: pundle primaryKey]].	^traces asArray</body><body package="RBStoreExtensions">connectToDatabaseName	| names |	names := Store.ConnectionDialog profiles collect: [:each | each name].	^Dialog 		choose: 'Select a database to replicate to:'		fromList: names		values: names		lines: 8		cancel: [nil]</body><body package="RBStoreExtensions">integratedVersionsNames	"The blessingLevel guard statement makes the check less exact because it misses versions that have been re-blessed since integration.  On the other hand, it speeds the process up considerably:  the slower code has been measured as taking up to three times as long.  As the time is still in the milliseconds for 20 versions, whether to have the guard or comment it out depends on how often you re-bless your pundles and how far and how fat your database is."	| mergedBlessing lastMerged |	mergedBlessing := Policies mergePolicy blessingForMerged.	self blessingLevel = mergedBlessing ifFalse: [^#()].	"comment out for slower, more exact check"	lastMerged := self model blessings				detect: [:b | b blessingLevel = mergedBlessing]				ifNone: [^#()].	^self class integratedVersionNamesIn: lastMerged</body><body package="RBStoreExtensions">label	^self model version ifNil: ['&lt;missing&gt;']</body><body package="RBStoreExtensions">replicateTo: aString 	self subclassResponsibility</body><body package="RBStoreExtensions">replicateTo: aString withMethod: replicationSelector	Notice 		showNotice: (#Replicating &lt;&lt; #browser &gt;&gt; 'Replicating')		complete: 0		while: 			[ | sessionBuilder currentLoginName targetSession |			sessionBuilder := #{Store.Glorp.StoreAutoReplicator} value default.			currentLoginName := model session accessor currentLogin name.			targetSession := sessionBuilder sessionForName: aString.			(#{Store.Glorp.StoreReplicator} value new)				replicationLog: #{ProgressNotifierLog} value new;				sourceSession: (sessionBuilder sessionForName: currentLoginName);				targetSession: targetSession;				login;				perform: replicationSelector with: self model name with: self model version.				[targetSession accessor logout] on: Error do: [:ex | ex return: nil]]		title: (#Store &lt;&lt; #browser &gt;&gt; 'Store')</body></methods><methods><class-id>Refactory.Browser.PundleShadowVersionFigure</class-id> <category>testing</category><body package="RBStoreExtensions">isLoaded	| pundleModel |	pundleModel := self codeComponent.	^pundleModel notNil and:		[pundleModel dbTrace = self model primaryKey and:		[pundleModel hasBeenModified not]]</body></methods><methods><class-id>Refactory.Browser.PundleShadowVersionFigure</class-id> <category>accessing</category><body package="RBStoreExtensions">mergeTraces	^mergeTraces isNil		ifTrue: [mergeTraces := self calculateMergeTraces]		ifFalse: [mergeTraces]</body><body package="RBStoreExtensions">mergeTraces: someTraces	mergeTraces := someTraces</body></methods><methods><class-id>Refactory.Browser.PundleShadowVersionFigure</class-id> <category>initialize-release</category><body package="RBStoreExtensions">on: aPackage	| image offset |	super on: aPackage.	image := Policies blessingPolicy imageFor:		(self model blessingLevelNumber ifNil: [^self]).	offset := image bounds width @ 0.	text translateBy: offset.	self add: ((Refactory.HotDraw.ViewAdapterFigure view: image in: image bounds)				translateBy: 0 @ 1).	self components first rectangle: self bounds.</body></methods><methods><class-id>Refactory.Browser.PundleShadowVersionFigure class</class-id> <category>private</category><body package="RBStoreExtensions">mergeRelationsInBlessing: blessing nameMap: version2key do: block 	^blessing blessingLevel = Store.Policies mergePolicy blessingForMerged 		ifTrue: 			[(self integratedVersionNamesIn: blessing) do: 				[:version | version2key at: version					ifPresent: [:integratedKey | block value: blessing pkgID value: integratedKey]]]		ifFalse: 			[version2key at: (self mergedVersionNameIn: blessing)				ifPresent: [:mergedKey | block value: mergedKey value: blessing pkgID]]</body><body package="RBStoreExtensions">primaryKeyByVersionName: instances 	^instances inject: Dictionary new into: 		[:dict :inst | 		dict			at: inst label put: inst primaryKey;			yourself]</body></methods><methods><class-id>Refactory.Browser.PundleShadowVersionFigure class</class-id> <category>db proxy</category><body package="RBStoreExtensions">prefetchBlessingCommentsFor: blessings	| ids dict toFetch |	toFetch := blessings select: [:b | b commentString isNil].	ids := toFetch collect: [:b | b commentID].	dict := Store.Glorp.StoreBlessing definitionClass theRecordsWithIDs: ids.	toFetch do: [:b | b commentString: ((dict at: b commentID ifAbsent: [])		ifNil: [String new]		ifNotNil: [:blob | blob definition])]</body></methods><methods><class-id>Refactory.Browser.PundleShadowVersionFigure class</class-id> <category>blessing comment parsing</category><body package="RBStoreExtensions">integratedVersionNamesIn: mergedBlessing	"The blessing comments for merged versions contain the branch history starting with VisualWorks 7.6.	This information has to be surpressed when computing the direct predecessors for a version"	| result stream mergeText |	result := OrderedCollection new.	mergeText := mergedBlessing comment readStream upToAll: 'Branch history:'.	stream := mergeText readStream.	stream skipThroughAll: 'versions integrated:'.	[stream atEnd] whileFalse: 			[| raw |			stream skipThroughAll: '('.			stream atEnd ifFalse:				[raw := stream upTo: $).				result add: (raw copyFrom: 1 to: ((raw lastIndexOf: $,) - 1 max: 0))]].	^result</body><body package="RBStoreExtensions">mergedVersionNameIn: integratedBlessing	"We accept two patterns for manually and automatic merged pundles"	| stream comment candidate pattern |	comment := integratedBlessing comment.	pattern := 'Integrated by Merge Tool into version '.	((pattern copyWith: $*) match: comment)		ifFalse: [pattern := 'Manually integrated into version '].	candidate := (stream := comment readStream)		skipThroughAll: pattern;		nextAvailable: (comment size - stream position max: 0).	candidate := candidate trimBlanks.	(candidate notEmpty and: [candidate last = $.]) ifTrue:		[candidate := candidate copyFrom: 1 to: candidate size - 1].	^candidate</body></methods><methods><class-id>Refactory.Browser.PackageVersionFigure</class-id> <category>private</category><body package="RBStoreExtensions">codeComponent	^#{Store.Registry} value packageNamed: self model name</body><body package="RBStoreExtensions">replicateTo: aString 	self replicateTo: aString withMethod: #replicatePackageNamed:version:</body></methods><methods><class-id>Refactory.Browser.PackageVersionFigure</class-id> <category>accessing</category><body package="RBStoreExtensions">blessingLevel	^self model blessingLevelNumber</body></methods><methods><class-id>Refactory.Browser.VersionDrawingEditor</class-id> <category>aspects</category><body package="RBStoreExtensions">blessingFilter	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^blessingFilter isNil		ifTrue:			[blessingFilter := Store.Policies blessingPolicy defaultBlessing asValue]		ifFalse:			[blessingFilter]</body><body package="RBStoreExtensions">countingFilter	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^countingFilter isNil		ifTrue:			[countingFilter := 20 asValue]		ifFalse:			[countingFilter]</body><body package="RBStoreExtensions">versionInformationHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^versionInformationHolder isNil		ifTrue:			[versionInformationHolder := String new asValue]		ifFalse:			[versionInformationHolder]</body></methods><methods><class-id>Refactory.Browser.VersionDrawingEditor</class-id> <category>layout</category><body package="RBStoreExtensions">basicDisplayFigures	| trees figures current |	drawing beInvisible.	Cursor execute showWhile: 		[trees := self buildTreesFor: self selectFigures.		self filterTrees: trees.		figures := trees inject: OrderedCollection new					into: 						[:all :root |						all							addAll: root allFigures;							yourself].		figures			do: [:each | each translateTo: self xSeparation @ self ySeparation].		self layoutFiguresUsing: trees.		current := figures detect: [:f | f isLoaded] ifNone: [0 @ 0 corner: 1 @ 1].		figures addAll: (self createConnectionsFor: trees)].	drawing		addAll: figures;		recomputePreferredBounds;		mergeBounds: (0 @ 0 corner: 1 @ 1).	drawing container		ifNotNil: 			[:container |			container setOrigin: (drawing container						validateScrollPosition: current bottomLeft negated).			drawing beVisible]</body><body package="RBStoreExtensions">buildTreesFor: figures	| traceMap trees |	trees := figures collect: [:figure | Tree figure: figure].	traceMap := Dictionary new.	trees do: [:tree | traceMap at: tree primaryKey put: tree].	trees copy do: 			[:tree |			traceMap at: tree trace yourSelf				ifPresent: 					[:parent |					parent adopt: tree.					trees remove: tree].			tree mergeTraces				do: [:mergeTrace | traceMap at: mergeTrace ifPresent: [:parent | parent mergeAdopt: tree]]].	^trees</body><body package="RBStoreExtensions">connectionColorFor: childTreeRef 	^childTreeRef type == #normal 		ifTrue: 			[childTreeRef isImmediate 				ifTrue: [ColorValue black]				ifFalse: [ColorValue gray]]		ifFalse: 			[childTreeRef isImmediate 				ifTrue: [ColorValue blue]				ifFalse: [ColorValue royalBlue]]</body><body package="RBStoreExtensions">connectionFrom: parentFigure to: childFigure color: color 	^(parentFigure 		connectFromPoint: parentFigure center		to: childFigure		at: childFigure center)		lineColor: color;		yourself</body><body package="RBStoreExtensions">createConnectionsFor: trees 	^trees inject: OrderedCollection new into: 		[:figures :root | 		root withDeepChildrenDo: 			[:parentTree | 			parentTree childReferences do: 				[:childTreeRef | 				figures add: (self 					connectionFrom: parentTree figure					to: childTreeRef value figure				color: (self connectionColorFor: childTreeRef))]].		figures]</body><body package="RBStoreExtensions">displayFigures	self stopDisplay.	self basicDisplayFigures</body><body package="RBStoreExtensions">displayFigures: figures	| map traceMap previousMap |	self clearDrawing.	traceMap := Dictionary new.	figures do: [:each | traceMap at: each primaryKey put: each].	map := Dictionary new.	previousMap := Dictionary new.	figures do:		[:each || figure |		figure := traceMap at: each trace ifAbsent: [nil].		figure notNil			ifTrue: 				[previousMap at: each put: figure.				(map					at: figure					ifAbsentPut: [SortedCollection sortBlock: [:a :b | a timestamp &lt; b timestamp]])						add: each]			ifFalse: [previousMap at: each put: nil]].	figures do: [:each | each translateTo: self xSeparation @ self ySeparation].	self layoutFiguresUsingForwardMap: map backwardMap: previousMap.	previousMap keysAndValuesDo:		[:key :value |		value notNil ifTrue:			[figures add: (key connectFromPoint: key center to: value at: value center)]].	drawing		addAll: figures;		recomputePreferredBounds;		mergeBounds: (0 @ 0 corner: 1 @ 1).</body><body package="RBStoreExtensions">filterTrees: trees	trees do: [:root | root withDeepChildrenCopyDo:		[:tree |		(tree isLoaded not			and: [tree isRoot not			and: [(tree blessingLevel ifNil: [false] ifNotNil: [:bl | bl &lt; self blessingFilter value])				or: [self countingFilter value = -2					and: [tree isLocallyLinear]]]])			ifTrue: [tree unlink]]]</body><body package="RBStoreExtensions">layoutFiguresUsing: trees	(Tree		figure: (RectangleFigure createAt: self xSeparation negated @ self ySeparation)		children: trees)			layoutWithSpacing: self xSeparation @ self ySeparation</body><body package="RBStoreExtensions">layoutFiguresUsingForwardMap: map backwardMap: previousMap 	| initialNodes root trees |	initialNodes := (previousMap keys 				select: [:each | (previousMap at: each) isNil]) 					asSortedCollection: [:a :b | a timestamp &lt; b timestamp].	trees := initialNodes collect: [:each | self treeFor: each using: map].	root := Tree figure: (RectangleFigure 						createAt: self xSeparation negated @ self ySeparation)				subtrees: trees.	root layoutWithSpacing: self xSeparation @ self ySeparation</body><body package="RBStoreExtensions">selectFigures	"figures are the figures to be displayed (filtered by blessinglevel and count).	 Note that we have to return figures that were filtered by blessinglevel as well  because otherwise the graph would contain holes.	 These are later filtered in filterTrees:"	| max figures |	max := self countingFilter value &lt; 0				ifTrue: [allFigures size]				ifFalse: [self countingFilter value min: allFigures size].	figures := OrderedCollection new.	allFigures doWithIndex: [ :figure :index |		(figure blessingLevel isNil or: [figure blessingLevel &gt;= self blessingFilter value])			ifTrue: [figures add: figure].		figures size &gt;= max ifTrue: [^allFigures copyFrom: 1 to: index]].	^allFigures</body><body package="RBStoreExtensions">stopDisplay	self clearDrawing</body><body package="RBStoreExtensions">treeFor: aFigure using: mapDictionary	^Tree		figure: aFigure		subtrees:			((mapDictionary at: aFigure ifAbsent: [#()]) collect:				[:each | self treeFor: each using: mapDictionary])</body><body package="RBStoreExtensions">xSeparation	^20</body><body package="RBStoreExtensions">ySeparation	^20</body></methods><methods><class-id>Refactory.Browser.VersionDrawingEditor</class-id> <category>drawing description</category><body package="RBStoreExtensions">toolNames	^(Array with: (#VersionTool &lt;&lt; #browser &gt;&gt; 'Version Tool') asString)</body></methods><methods><class-id>Refactory.Browser.VersionDrawingEditor</class-id> <category>accessing</category><body package="RBStoreExtensions">activeFigure: figure 	"This is not done via start pattern because the initial state always forgets everything,	so I can't store information across subsequent transitions."	| box |	activeFigure isNil 		ifFalse: [activeFigure remove: activeFigure components last].	activeFigure := figure.	box := Refactory.HotDraw.RectangleFigure new 				rectangle: (activeFigure components first bounds expandedBy: -2);				lineColor: (Pattern from: self class patternImage);				transparent.	activeFigure add: box</body><body package="RBStoreExtensions">clearDrawing	self drawing removeAll: self drawing figures copy.	self versionInformationHolder value: String new</body><body package="RBStoreExtensions">displayBundle: aBundleModel	| allPundles |	allPundles := StoreBundle				allVersionsWithName: aBundleModel name.	allFigures := allPundles asOrderedCollection				collect: [:each | BundleVersionFigure on: each].	aBundleModel hasBeenModified		ifTrue: [allFigures addFirst: (BundleCurrentVersionFigure on: aBundleModel)].	self displayFigures</body><body package="RBStoreExtensions">displayClass: aClass 	| classRecords package |	classRecords := (StoreClassDefinition allVersionsWithName: aClass name) asOrderedCollection.	package := Registry containingPackageForClass: aClass.	allFigures := (classRecords 		collect: [:each | ClassVersionFigure on: each package: package]).	self displayFigures</body><body package="RBStoreExtensions">displayNameSpace: aNameSpace	| nameSpaces package |	nameSpaces := StoreNameSpace allVersionsWithName: aNameSpace name.	package := Registry containingPackageForNameSpace: aNameSpace.	allFigures := (nameSpaces collect: [:each | NamespaceVersionFigure on: each package: package]).	self displayFigures.</body><body package="RBStoreExtensions">displayPackage: aPackageModel	| packages |	packages := StorePackage				allVersionsWithName: aPackageModel name.	allFigures := packages asOrderedCollection collect: [:each | PackageVersionFigure on: each].	aPackageModel hasBeenModified		ifTrue: [allFigures addFirst: (PackageCurrentVersionFigure on: aPackageModel)].	self displayFigures</body><body package="RBStoreExtensions">displaySelector: aSelector in: aClass	| methods package |	methods := StoreMethod		allMethodVersionsNamed: aSelector asString		inClass: aClass absoluteName asString		meta: aClass isMeta.	package := (Registry		allContainingPackagesForSelector: aSelector		class: aClass)			detect: [:each | true] ifNone: [nil].	allFigures := methods collect:		[:each | MethodVersionFigure on: each package: package].	allFigures := allFigures asOrderedCollection.	"convert from Array so we can remove from it"	self displayFigures.</body><body package="RBStoreExtensions">displaySharedVariable: anInitializerDefinition	| sharedVariables ref package |	ref := anInitializerDefinition fullName asQualifiedReference.	package := Registry packageForDataKey: ref name owner: ref environment.	sharedVariables := Store.Glorp.StoreSharedVariable				allVersionsNamed: ref name asString				inOwner: ref environment absoluteName				in: nil.	allFigures := sharedVariables				collect: [:each | SharedVariableVersionFigure on: each package: package].	self displayFigures</body><body package="RBStoreExtensions">selectedFigure: figure 	"This is not done via start pattern because the initial state always forgets everything,	so I can't store information across subsequent transitions."	self activeFigure: figure.	selectedFigure isNil ifFalse: [selectedFigure fillColor: ColorValue white].	selectedFigure := figure.	selectedFigure fillColor: ColorValue lightYellow.	[self versionInformationHolder value: selectedFigure versionInformation] 		forkAt: Processor userBackgroundPriority</body></methods><methods><class-id>Refactory.Browser.VersionDrawingEditor</class-id> <category>interface opening</category><body package="RBStoreExtensions">postBuildWith: aBuilder 	super postBuildWith: aBuilder.	self blessingFilter onChangeSend: #displayFigures to: self.	self countingFilter onChangeSend: #displayFigures to: self.	builder window damageRepairPolicy: DoubleBufferingWindowDisplayPolicy new</body></methods><methods><class-id>Refactory.Browser.VersionDrawingEditor class</class-id> <category>opening</category><body package="RBStoreExtensions">openOnBundle: aBundleModel 	"self openOnBundle: (Store.Registry bundleNamed: 'StoreBase')"	(self new)		displayBundle: aBundleModel;		open</body><body package="RBStoreExtensions">openOnClass: aClass 	"self openOnClass: Refactoring"	(self new)		displayClass: aClass;		open</body><body package="RBStoreExtensions">openOnNameSpace: aNameSpace 	"self openOnNameSpace: Refactory.Browser"	(self new)		displayNameSpace: aNameSpace;		open</body><body package="RBStoreExtensions">openOnPackage: aPackageModel 	"self openOnPackage: (Store.Registry packageNamed: 'Assets')"	(self new)		displayPackage: aPackageModel;		open</body><body package="RBStoreExtensions">openOnSelector: aSelector in: aClass 	"self openOnSelector: #execute in: Refactoring"	(self new)		displaySelector: aSelector in: aClass ;		open</body></methods><methods><class-id>Refactory.Browser.VersionDrawingEditor class</class-id> <category>resources</category><body package="RBStoreExtensions">blessingLevelsMenu	^[[Store.Policies blessingPolicy blessingLevelsMenu] on: Error do: [:ex | Menu new]]</body><body package="RBStoreExtensions">countingMenu	^MenuBuilder new		add: 'Show the last   10 versions' -&gt; 10;		add: 'Show the last   20 versions' -&gt; 20;		add: 'Show the last   50 versions' -&gt; 50;		add: 'Show the last 100 versions' -&gt; 100;		line;		add: 'Show all versions' -&gt; -1;		line;		add: 'Show structure' -&gt; -2;		menu</body></methods><methods><class-id>Refactory.Browser.VersionCodeTool</class-id> <category>updating</category><body package="RBStoreExtensions">updateContents	super updateContents.	self updateDrawing</body><body package="RBStoreExtensions">updateDisplay	super updateDisplay.	self updateDrawing</body><body package="RBStoreExtensions">updateDrawing	[self selector ifNotNil:		[:sel | ^self versionEditor displaySelector: sel in: self selectedClass].	self sharedVariableName ifNotNil:		"there is no CodeTool&gt;&gt; or CodeModel&gt;&gt;sharedVariableDefinition" 		[:name | ^self versionEditor displaySharedVariable: self definition].	self nonMetaClass ifNotNil:		[:nmClass | ^self versionEditor displayClass: nmClass].	self selectedBinding ifNotNil:		[:bind | bind isForNameSpace ifTrue:			[^self versionEditor displayNameSpace: bind value]].	self pundle ifNotNil:		[:pundle |		^pundle isPackage			ifTrue: [self versionEditor displayPackage: pundle]			ifFalse: [self versionEditor displayBundle: pundle]].	self versionEditor clearDrawing]			on: Error			do: [:ex | ex return]</body><body package="RBStoreExtensions">updateNavigator	self navigator changed</body></methods><methods><class-id>Refactory.Browser.VersionCodeTool</class-id> <category>tab APIs</category><body package="RBStoreExtensions">isActive	^(#{Store.DbRegistry} valueOrDo: [^false]) isOnlineImage and:		[#(#codeComponent #object #definition) includes: codeModel state narrowestSelectionType]</body><body package="RBStoreExtensions">tabName	^(#VersionHistory &lt;&lt; #browser &gt;&gt; 'Version History') asString</body></methods><methods><class-id>Refactory.Browser.VersionCodeTool</class-id> <category>accessing</category><body package="RBStoreExtensions">versionEditor	versionEditor ifNil: [ self initializeVersionEditor ].	^versionEditor</body></methods><methods><class-id>Refactory.Browser.VersionCodeTool</class-id> <category>initialize-release</category><body package="RBStoreExtensions">initializeVersionEditor	versionEditor := VersionDrawingEditor new.	versionEditor expressInterestIn: #loadSrc for: self sendBack: #updateNavigator</body><body package="RBStoreExtensions">release	self releaseVersionEditor.	super release</body><body package="RBStoreExtensions">releaseVersionEditor	versionEditor retractInterestIn: #loadSrc for: self.	versionEditor := nil</body></methods><methods><class-id>Refactory.Browser.VersionCodeTool</class-id> <category>private</category><body package="RBStoreExtensions">resetBuilder	super resetBuilder.	self versionEditor stopDisplay.	versionEditor := nil</body></methods><methods><class-id>Refactory.Browser.PackageItemFigure</class-id> <category>accessing</category><body package="RBStoreExtensions">containingVersionInformation	| versions query |	query := Glorp.Query		read: self model class inPackageClass		where: [:each | each definition = self model AND:					[each package name = package name]].	query retrieve: [:each | each package version].	query orderBy: [:each | each package timestamp].	versions := Store.Glorp.StoreLoginFactory currentStoreSession execute: query.	^versions size &gt; 10		ifFalse: [versions]		ifTrue: [(versions first: 5), #('...(more)...'), (versions last: 5)]"If performance recovering many package versions just to throw them away were ever a problem, we could get the first 11 versions and, if needed, the last 5, as shown below.  However I expect one trip to the DB will beat two in all but very unusual usage scenarios and do not immediately see how to write this as a single query.	| versions query mostRecentVersions |	query := Glorp.Query		read: self model class inPackageClass		where: [:each | each definition = self model AND:					[each package name = package name]]		limit: 11.	query retrieve: [:each | each package version].	query orderBy: [:each | each package timestamp].	versions := Store.Glorp.StoreLoginFactory currentStoreSession execute: query.	^versions size &gt; 10		ifFalse: [versions]		ifTrue:			[query limit: 5; setOrdering: nil; orderBy: [:each | each package timestamp descending].			mostRecentVersions := Store.Glorp.StoreLoginFactory currentStoreSession execute: query.			(versions first: 5), #('...(more)...'),  (versions last: 5)]"</body><body package="RBStoreExtensions">definitionText	^self model definition asText</body><body package="RBStoreExtensions">package	^package</body><body package="RBStoreExtensions">package: aPackageModel	package := aPackageModel</body></methods><methods><class-id>Refactory.Browser.PackageItemFigure</class-id> <category>testing</category><body package="RBStoreExtensions">isLoaded	^self model sameAsImage</body></methods><methods><class-id>Refactory.Browser.PackageItemFigure</class-id> <category>private</category><body package="RBStoreExtensions">buildVersionInformation	| s |	(s := TextStream on: (String new: 2000))		emphasis: #(#bold #underline);		nextPutAll: 'User: ';		emphasis: #underline;		nextPutAll: self model userName;		emphasis: #(#bold #underline);		nextPutAll: ' Time: ';		emphasis: #underline;		nextPutAll: self model timeStampString;		emphasis: #(#bold #underline);		nextPutAll: ' From:  ';		emphasis: #underline;		nextPutAll: package name;		emphasis: #(#bold #underline);		nextPutAll: ' Versions: ';		emphasis: #underline.	self containingVersionInformation do: [:p | s nextPutAll: p]		separatedBy: [s nextPutAll: ', '].	^s		cr;		nextPutAllText: self definitionText;		contents</body><body package="RBStoreExtensions">toolCreationMethod	self subclassResponsibility</body></methods><methods><class-id>Refactory.Browser.PackageItemFigure</class-id> <category>actions</category><body package="RBStoreExtensions">browseIt	| tool versions |	[versions := self model allStoreVersions]		withStoreFeedbackOn: self container model mainWindow.	tool := DefinitionForListTool perform: self toolCreationMethod with: versions.	tool selectDefinition: model.</body></methods><methods><class-id>Refactory.Browser.PackageItemFigure class</class-id> <category>instance creation</category><body package="RBStoreExtensions">on: aClassRecord package: aPackageModel 	^(self on: aClassRecord)		package: aPackageModel;		yourself</body></methods><methods><class-id>Refactory.Browser.SharedVariableVersionFigure</class-id> <category>private</category><body package="RBStoreExtensions">toolCreationMethod	^#forSharedVariables:</body></methods><methods><class-id>Refactory.Browser.PundleCurrentVersionFigure</class-id> <category>accessing</category><body package="RBStoreExtensions">primaryKey	^#image</body><body package="RBStoreExtensions">timestamp	^Timestamp now asSeconds</body><body package="RBStoreExtensions">trace	| t |	t := self model dbTrace.	^t isNil ifTrue: [0] ifFalse: [t]</body></methods><methods><class-id>Refactory.Browser.PundleCurrentVersionFigure</class-id> <category>private</category><body package="RBStoreExtensions">buildVersionInformation	^''</body><body package="RBStoreExtensions">label	^'Image'</body></methods><methods><class-id>Refactory.Browser.PundleCurrentVersionFigure</class-id> <category>testing</category><body package="RBStoreExtensions">isLoaded	^true</body></methods><methods><class-id>Refactory.Browser.PundleCurrentVersionFigure</class-id> <category>actions</category><body package="RBStoreExtensions">browseIt	(BrowserEnvironment new forCodeComponents: (Array with: self model)) openEditor</body></methods><methods><class-id>Refactory.Browser.BundleCurrentVersionFigure</class-id> <category>private</category><body package="RBStoreExtensions">codeComponent	^#{Store.Registry} value bundleNamed: self model name</body></methods><methods><class-id>Refactory.Browser.TreeReference</class-id> <category>proxy</category><body package="RBStoreExtensions">adopt: childRef	tree adopt: childRef value type: (self typeSupremumWith: childRef) immediate: false</body><body package="RBStoreExtensions">parent: aParent	tree parent: aParent</body><body package="RBStoreExtensions">removeChild: child	tree removeChild: child</body><body package="RBStoreExtensions">removeParent: parent	tree removeParent: parent</body><body package="RBStoreExtensions">withDeepChildrenCopyDo: aBlock	tree withDeepChildrenCopyDo: aBlock</body></methods><methods><class-id>Refactory.Browser.TreeReference</class-id> <category>accessing</category><body package="RBStoreExtensions">isImmediate	^isImmediate</body><body package="RBStoreExtensions">tree: aTree type: typeSymbol immediate: immediate	tree := aTree.	type := typeSymbol.	isImmediate := immediate</body><body package="RBStoreExtensions">type	^type</body><body package="RBStoreExtensions">value	^tree</body></methods><methods><class-id>Refactory.Browser.TreeReference</class-id> <category>private</category><body package="RBStoreExtensions">typeSupremumWith: otherReference	type == #merge ifTrue: [^#merge].	otherReference type == #merge ifTrue: [^#merge].	^#normal</body></methods><methods><class-id>Refactory.Browser.TreeReference</class-id> <category>printing</category><body package="RBStoreExtensions">printOn: aStream	tree printOn: aStream.	aStream		nextPut: (isImmediate ifTrue: [$+] ifFalse: [$-]);		nextPut: type displayString first</body></methods><methods><class-id>Refactory.Browser.TreeReference class</class-id> <category>instance creation</category><body package="RBStoreExtensions">tree: tree type: typeSymbol immediate: isImmediate	^self new tree: tree type: typeSymbol immediate: isImmediate</body></methods><methods><class-id>Refactory.Browser.NamespaceVersionFigure</class-id> <category>private</category><body package="RBStoreExtensions">toolCreationMethod		^#forNameSpaces:</body></methods><methods><class-id>Refactory.Browser.MethodVersionFigure</class-id> <category>actions</category><body package="RBStoreExtensions">compareVersionTo: aMethod 	((#{TextMatchBrowser} ifDefinedDo: [:x | x] elseDo: [Differator]) 		newOn: self model sourceCode		and: aMethod sourceCode) open</body></methods><methods><class-id>Refactory.Browser.MethodVersionFigure</class-id> <category>private</category><body package="RBStoreExtensions">toolCreationMethod	^#forMethods:</body></methods><methods><class-id>Refactory.Browser.MethodVersionFigure</class-id> <category>accessing</category><body package="RBStoreExtensions">definitionText	| definition |	definition := super definitionText.	(self model longName asQualifiedReference valueOrDo: [])		ifNotNil: [:recordClass | definition makeSelectorBoldIn: recordClass]		ifNil: 			[definition				emphasizeFrom: 1				to: (definition indexOf: Character cr)				with: #bold].	^definition</body></methods><methods><class-id>Refactory.Browser.Tree</class-id> <category>layout</category><body package="RBStoreExtensions">addBottomsFrom: aTree 	aTree bottoms keysAndValuesDo: 			[:index :each | 			index &gt; bottoms size 				ifTrue: [bottoms add: each]				ifFalse: [(bottoms at: index) &lt; each ifTrue: [bottoms at: index put: each]]]</body><body package="RBStoreExtensions">addSubtreesInto: aCollection level: aNumber 	aCollection size &lt; aNumber 		ifTrue: [aCollection add: OrderedCollection new].	(aCollection at: aNumber) add: figure.	subtrees 		do: [:each | each addSubtreesInto: aCollection level: aNumber + 1]</body><body package="RBStoreExtensions">addTopsFrom: aTree 	aTree tops keysAndValuesDo: 			[:index :each | 			index &gt; tops size 				ifTrue: [tops add: each]				ifFalse: [(tops at: index) &gt; each ifTrue: [tops at: index put: each]]]</body><body package="RBStoreExtensions">bottom	^bottoms inject: 0 into: [:sum :each | sum max: each]</body><body package="RBStoreExtensions">bottoms	^bottoms</body><body package="RBStoreExtensions">childrenByLevel	"Considering merge relations, the tree is really just a cycle-free graph.	Such a graph can still be divided into levels, but the level are not integers but intervals.	This method uses the maximum value of these intervals as the level of each node."	"For performance, traverse the graph only once.	Because each node (except the root) gets added to the toDo collection as often as it has parents,	process it only if it has been encoutered this often."	| figuresByLevel parentsToDo toDo skipped |	figuresByLevel := OrderedCollection new.	parentsToDo := Dictionary new.	toDo := OrderedCollection with: self -&gt; 1.	skipped := OrderedCollection new.	[skipped isEmpty and: [toDo isEmpty]] whileFalse:		[| current parentsLeft |		current := toDo isEmpty ifTrue: [skipped removeFirst] ifFalse: [toDo removeFirst].		skipped remove: current ifAbsent: [].		parentsLeft := parentsToDo at: current key ifAbsent: [current key noOfParents].		"(parentsLeft &lt; 1 and: [current key isRoot not]) ifTrue: [self error: 'Cycle']."		parentsToDo at: current key put: parentsLeft - 1.		(parentsLeft = 1 or: [current key isRoot])			ifTrue:				[figuresByLevel size &lt; current value ifTrue: [figuresByLevel add: OrderedCollection new].				(figuresByLevel at: current value) add: current key figure.				current key childrenDo: [:child | toDo add: child -&gt; (current value + 1)]]			ifFalse: [parentsLeft &lt; 1 ifFalse: [skipped add: current]]].	^figuresByLevel</body><body package="RBStoreExtensions">layoutBelow: aCollection space: aNumber 	| moveDistance top bottom |	moveDistance := 0.	1 to: (self tops size max: aCollection size)		do: 			[:index | 			top := index &gt; self tops size 						ifTrue: [SmallInteger maxVal]						ifFalse: [self tops at: index].			bottom := index &gt; aCollection size 						ifTrue: [SmallInteger minVal]						ifFalse: [aCollection at: index].			moveDistance := moveDistance max: bottom + aNumber - top].	moveDistance ~~ 0 ifTrue: [self moveDownBy: moveDistance]</body><body package="RBStoreExtensions">layoutWithHorizontalSpacing: aNumber 	| levels |	levels := self childrenByLevel.	levels inject: aNumber negated		into: 			[:x :collection | 			| max |			max := collection inject: 0 into: [:sum :each | sum max: each extent x].			collection do: [:each | each translateBy: x @ 0].			x + max + aNumber]</body><body package="RBStoreExtensions">layoutWithSpacing: aPoint	self		layoutWithHorizontalSpacing: aPoint x;		layoutWithVerticalSpacing: aPoint y</body><body package="RBStoreExtensions">layoutWithVerticalSpacing: aNumber 	| hasChildren |	hasChildren := false.	tops := OrderedCollection new.	bottoms := OrderedCollection new.	self normalChildrenDo:		[:child |		child			layoutWithVerticalSpacing: aNumber;			layoutBelow: bottoms space: aNumber.		self			addBottomsFrom: child;			addTopsFrom: child.		hasChildren := true].	hasChildren ifTrue: [figure translateTo: figure left @ ((self bottom + self top) // 2 - (figure extent // 2) y)].	tops addFirst: figure top.	bottoms addFirst: figure bottom.</body><body package="RBStoreExtensions">moveDownBy: aNumber 	figure translateBy: 0 @ aNumber.	self normalChildrenDo: [:each | each moveDownBy: aNumber].	tops notNil ifTrue: [tops := tops collect: [:each | each + aNumber]].	bottoms notNil ifTrue: [bottoms := bottoms collect: [:each | each + aNumber]]</body><body package="RBStoreExtensions">top	^tops inject: SmallInteger maxVal into: [:sum :each | sum min: each]</body><body package="RBStoreExtensions">tops	^tops</body></methods><methods><class-id>Refactory.Browser.Tree</class-id> <category>initialize-release</category><body package="RBStoreExtensions">figure: aFigure children: aTreeCollection 	figure := aFigure.	childRefs := OrderedCollection new.	parentRefs := OrderedCollection new.	aTreeCollection do: [:tree | self adopt: tree]</body><body package="RBStoreExtensions">figure: aFigure subtrees: aTreeCollection 	figure := aFigure.	subtrees := aTreeCollection</body></methods><methods><class-id>Refactory.Browser.Tree</class-id> <category>accessing-figure</category><body package="RBStoreExtensions">allFigures	| result |	result := OrderedCollection new.	self withDeepChildrenDo: [:child | result add: child figure].	^result</body><body package="RBStoreExtensions">blessingLevel	^figure blessingLevel</body><body package="RBStoreExtensions">figure	^figure</body><body package="RBStoreExtensions">mergeTraces	^figure mergeTraces</body><body package="RBStoreExtensions">primaryKey	^figure primaryKey</body><body package="RBStoreExtensions">trace	^figure trace</body></methods><methods><class-id>Refactory.Browser.Tree</class-id> <category>testing</category><body package="RBStoreExtensions">isLoaded	^figure isLoaded</body><body package="RBStoreExtensions">isLocallyLinear	^self noOfChildren = 1		and: [self noOfParents = 1		and: [self anyChild noOfParents = 1		and: [self anyParent noOfChildren = 1]]]</body><body package="RBStoreExtensions">isRoot	^parentRefs isEmpty</body></methods><methods><class-id>Refactory.Browser.Tree</class-id> <category>printing</category><body package="RBStoreExtensions">printOn: aStream	figure printOn: aStream</body></methods><methods><class-id>Refactory.Browser.Tree</class-id> <category>building</category><body package="RBStoreExtensions">adopt: child	self adopt: child type: #normal immediate: true</body><body package="RBStoreExtensions">mergeAdopt: child	self adopt: child type: #merge immediate: true</body><body package="RBStoreExtensions">unlink	parentRefs do:		[:parentRef |		childRefs do: [:childRef | parentRef adopt: childRef].		parentRef removeChild: self].	childRefs do: [:childRef | childRef removeParent: self]</body></methods><methods><class-id>Refactory.Browser.Tree</class-id> <category>private-building</category><body package="RBStoreExtensions">addChild: child type: typeSymbol immediate: isImmediate	childRefs add: (TreeReference tree: child type: typeSymbol immediate: isImmediate)</body><body package="RBStoreExtensions">addParent: parent type: typeSymbol immediate: isImmediate	parentRefs add: (TreeReference tree: parent type: typeSymbol immediate: isImmediate)</body><body package="RBStoreExtensions">adopt: child type: typeSymbol immediate: isImmediate	child addParent: self type: typeSymbol immediate: isImmediate.	self addChild: child type: typeSymbol immediate: isImmediate</body><body package="RBStoreExtensions">removeChild: child 	childRefs remove:		(childRefs detect: [:treeRef | treeRef value = child] ifNone: [])</body><body package="RBStoreExtensions">removeParent: parent 	parentRefs remove:		(parentRefs detect: [:treeRef | treeRef value = parent] ifNone: [])</body></methods><methods><class-id>Refactory.Browser.Tree</class-id> <category>enumerating</category><body package="RBStoreExtensions">withDeepChildrenCopyDo: aBlock	childRefs copy do: [:ref | ref type = #normal ifTrue: [ref withDeepChildrenCopyDo: aBlock]].	aBlock value: self.</body><body package="RBStoreExtensions">withDeepChildrenDo: aBlock	self normalChildrenDo: [:child | child withDeepChildrenDo: aBlock].	aBlock value: self</body></methods><methods><class-id>Refactory.Browser.Tree</class-id> <category>accessing-hierarchy</category><body package="RBStoreExtensions">childReferences	^childRefs</body></methods><methods><class-id>Refactory.Browser.Tree</class-id> <category>private-enumerating</category><body package="RBStoreExtensions">childrenDo: aBlock	^childRefs do: [:ref | aBlock value: ref value]</body><body package="RBStoreExtensions">normalChildrenDo: aBlock	^childRefs do: [:ref | ref type == #normal ifTrue: [aBlock value: ref value]]</body></methods><methods><class-id>Refactory.Browser.Tree</class-id> <category>private-accessing</category><body package="RBStoreExtensions">anyChild	^(childRefs detect: [:ref | true]) value</body><body package="RBStoreExtensions">anyParent	^(parentRefs detect: [:ref | true]) value</body><body package="RBStoreExtensions">noOfChildren	^childRefs size</body><body package="RBStoreExtensions">noOfParents	^parentRefs size</body></methods><methods><class-id>Refactory.Browser.Tree class</class-id> <category>instance creation</category><body package="RBStoreExtensions">figure: aFigure	^self figure: aFigure children: OrderedCollection new</body><body package="RBStoreExtensions">figure: aFigure children: aTreeCollection 	^(self new)		figure: aFigure children: aTreeCollection;		yourself</body><body package="RBStoreExtensions">figure: aFigure subtrees: aTreeCollection 	^(self new)		figure: aFigure subtrees: aTreeCollection;		yourself</body></methods><methods><class-id>Refactory.Browser.PackageCurrentVersionFigure</class-id> <category>private</category><body package="RBStoreExtensions">codeComponent	^#{Store.Registry} value packageNamed: self model name</body></methods><methods><class-id>Refactory.Browser.ClassVersionFigure</class-id> <category>private</category><body package="RBStoreExtensions">toolCreationMethod	^#forClasses:</body></methods><methods><class-id>Refactory.Browser.BundleVersionFigure</class-id> <category>private</category><body package="RBStoreExtensions">codeComponent	^#{Store.Registry} value bundleNamed: self model name</body><body package="RBStoreExtensions">replicateTo: aString 	self replicateTo: aString withMethod: #replicateBundleNamed:version:</body></methods><methods><class-id>Refactory.Browser.BundleVersionFigure</class-id> <category>accessing</category><body package="RBStoreExtensions">blessingLevel	^self model blessingLevelNumber</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>blessing numbers</category><body package="RBStoreExtensions">describeBlessings: aCollection	"Answer a string that describes a collection of database blessings."	| output blessingsToPrint |	output := WriteStream on: String new.	blessingsToPrint := aCollection				reject: [:each | self blessingLevelsNotToBeDisplayed includes: each blessingLevel].	blessingsToPrint do: 			[:each |			each printTallOn: output.			output cr].	^output contents</body></methods><methods><class-id>Store.BasicBlessingPolicy</class-id> <category>resources</category><body package="RBStoreExtensions">imageFor: blessingLevel	"Install the images that are displayed as icon in the nodes of the version graph"	"Images := nil"		Images isNil ifTrue: [Images := Dictionary new].	^Images		at: blessingLevel		ifAbsentPut:			[| image |			image := self installImageFor: blessingLevel.			ExtendedLabelAndIcon eraseBackgroundOnImage: image]</body><body package="RBStoreExtensions">installImageFor: blessingLevel	"Answer the image that is displayed as icon in the nodes of the version graph for a defined blessing level"	blessingLevel &lt;= self brokenBlessing ifTrue: [^self class brokenImage].	blessingLevel &lt;= self workInProgressBlessing ifTrue: [^self class workInProgressImage].	blessingLevel &lt;= self developmentBlessing ifTrue: [^self class developmentImage].	blessingLevel = self toReviewBlessing ifTrue: [^self class toReviewImage].	blessingLevel = self patchBlessing ifTrue: [^self class patchImage].	blessingLevel = self integrationReadyBlessing ifTrue: [^self class integrationReadyImage].	blessingLevel = self integratedBlessing ifTrue: [^self class integratedImage].	blessingLevel = self readyToMergeBlessing ifTrue: [^self class readToMergeImage].	blessingLevel = self mergedBlessing ifTrue: [^self class mergedImage].	blessingLevel = self testedBlessing ifTrue: [^self class testedImage].	blessingLevel = self internalReleaseBlessing ifTrue: [^self class internalReleaseImage].	blessingLevel &gt;= self releasedBlessing ifTrue: [^self class releasedImage].	^self class otherImage</body></methods><methods><class-id>Store.Glorp.DefinitionForListTool</class-id> <category>actions</category><body package="RBStoreExtensions">selectDefinition: aDefinition	| itemList selectionIndexes |	itemList := self listOfThings itemsInList.	selectionIndexes := (1 to: itemList list size)				select: [:i | (itemList list at: i) primaryKey = aDefinition primaryKey].	^itemList selectionIndexes: selectionIndexes</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="RBStoreExtensions">blessingLevelString	"This is a pundle model that is currently not published. Thus there is no blessing comment"	^''</body></methods><methods><class-id>Refactory.HotDraw.Tool class</class-id> <category>tool states</category><body package="RBStoreExtensions">versionInformationToolStates	"This method was automatically generated by the HotDraw ToolStateMachineEditor.	To edit this method, evaluate the comment below"	"| states transitions stateTable |	states := ((Core.OrderedCollection new) add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Version Tool'; instVarAt: 3 put: '[:tool :event | ]'; instVarAt: 4 put: (Core.Point x: 24 y: 112); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Enter VersionFigure'; instVarAt: 3 put: '[:tool :event |tool drawing model activeFigure: (tool figureAtEvent: event)]'; instVarAt: 4 put: (Core.Point x: 243 y: 111); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Menu'; instVarAt: 3 put: '[:tool :event | ]'; instVarAt: 4 put: (Core.Point x: 242 y: 266); instVarAt: 5 put: false; instVarAt: 6 put: true; yourself); add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Drag Drop'; instVarAt: 3 put: '[:tool :event | | startFigure endFigure origin |origin := tool valueAt: #startPoint.tool drawing 	invalidateRectangle:		(Rectangle vertex: origin vertex: (tool valueAt: #lastPoint))	repairNow: true.startFigure := tool valueAt: #figure.endFigure := tool figureAtEvent: event.startFigure ~~ endFigure ifTrue: [startFigure dragDrop: endFigure]]'; instVarAt: 4 put: (Core.Point x: 784 y: 502); instVarAt: 5 put: true; instVarAt: 6 put: false; yourself); add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Mouse Press'; instVarAt: 3 put: '[:tool :event | | startPoint |startPoint := tool cursorPointFor: event.tool 	valueAt: #figure put: (tool figureAtEvent: event);	valueAt: #startPoint put: startPoint;	valueAt: #lastPoint put: startPoint]'; instVarAt: 4 put: (Core.Point x: 819 y: 275); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Abort Drag'; instVarAt: 3 put: '[:tool :event | | origin |origin := tool valueAt: #startPoint.tool drawing 	invalidateRectangle:		(Rectangle vertex: origin vertex: (tool valueAt: #lastPoint))	repairNow: true]'; instVarAt: 4 put: (Core.Point x: 584 y: 502); instVarAt: 5 put: true; instVarAt: 6 put: false; yourself); add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Mouse Move Drag'; instVarAt: 3 put: '[:tool :event | | currentPoint origin |origin := tool valueAt: #startPoint.tool drawing 	invalidateRectangle:		(Rectangle vertex: origin vertex: (tool valueAt: #lastPoint))	repairNow: true.currentPoint := tool cursorPointFor: event.(LineSegment from: currentPoint to: origin)	displayStrokedOn: tool graphicsContext.tool valueAt: #lastPoint put: currentPoint]'; instVarAt: 4 put: (Core.Point x: 636 y: 409); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Browse'; instVarAt: 3 put: '[:tool :event | (tool figureAtEvent: event) browse]'; instVarAt: 4 put: (Core.Point x: 550 y: 282); instVarAt: 5 put: true; instVarAt: 6 put: false; yourself); add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Over VersionFigure'; instVarAt: 3 put: '[:tool :event | ]'; instVarAt: 4 put: (Core.Point x: 521 y: 113); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Exit VersionFigure'; instVarAt: 3 put: '[:tool :event | ]'; instVarAt: 4 put: (Core.Point x: 243 y: 23); instVarAt: 5 put: true; instVarAt: 6 put: false; yourself); add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Select Figure'; instVarAt: 3 put: '[:tool :event |tool drawing model selectedFigure: (tool figureAtEvent: event)]'; instVarAt: 4 put: (Core.Point x: 961 y: 371); instVarAt: 5 put: true; instVarAt: 6 put: false; yourself); add: (Refactory.HotDraw.ToolStateModel basicNew instVarAt: 1 put: nil; instVarAt: 2 put: 'Possible Drag'; instVarAt: 3 put: '[:tool :event | ]'; instVarAt: 4 put: (Core.Point x: 596 y: 324); instVarAt: 5 put: false; instVarAt: 6 put: false; yourself); yourself).	stateTable := Dictionary new.	states do: [:each | stateTable at: each name put: each].	transitions := OrderedCollection new.	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Version Tool'); to: (stateTable at: 'Enter VersionFigure'); type: (Refactory.HotDraw.FigureTransitionType basicNew instVarAt: 1 put: #mouseMove; instVarAt: 2 put: ((Core.Array new: 1) at: 1 put: Refactory.Browser.VersionFigure; yourself); yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 107.45 y: 126.801); add: (Core.Point x: 242.471 y: 126.999); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Mouse Move Drag'); to: (stateTable at: 'Drag Drop'); type: (Refactory.HotDraw.FigureTransitionType basicNew instVarAt: 1 put: #redButtonRelease; instVarAt: 2 put: ((Core.Array new: 1) at: 1 put: Refactory.Browser.VersionFigure; yourself); yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 748.129 y: 430.461); add: (Core.Point x: 811.692 y: 501.447); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Mouse Move Drag'); to: (stateTable at: 'Abort Drag'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #redButtonRelease; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 687.123 y: 440.637); add: (Core.Point x: 638.775 y: 502.434); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Mouse Move Drag'); to: (stateTable at: 'Mouse Move Drag'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #mouseMove; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 639.842 y: 417.374); add: (Core.Point x: 479 y: 404); add: (Core.Point x: 473 y: 422); add: (Core.Point x: 634.635 y: 420.911); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Enter VersionFigure'); to: (stateTable at: 'Over VersionFigure'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #immediate; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 368.598 y: 125.889); add: (Core.Point x: 519.969 y: 125.047); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Over VersionFigure'); to: (stateTable at: 'Over VersionFigure'); type: (Refactory.HotDraw.FigureTransitionType basicNew instVarAt: 1 put: #mouseMove; instVarAt: 2 put: ((Core.Array new: 1) at: 1 put: Refactory.Browser.VersionFigure; yourself); yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 586.013 y: 112.491); add: (Core.Point x: 586 y: 71); add: (Core.Point x: 555 y: 59); add: (Core.Point x: 571.554 y: 112.388); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Over VersionFigure'); to: (stateTable at: 'Exit VersionFigure'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #mouseMove; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 546.418 y: 114.395); add: (Core.Point x: 361.008 y: 37.0245); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Over VersionFigure'); to: (stateTable at: 'Mouse Press'); type: (Refactory.HotDraw.FigureTransitionType basicNew instVarAt: 1 put: #redButtonPress; instVarAt: 2 put: ((Core.Array new: 1) at: 1 put: Refactory.Browser.VersionFigure; yourself); yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 603.724 y: 143.81); add: (Core.Point x: 818.218 y: 288.689); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Over VersionFigure'); to: (stateTable at: 'Browse'); type: (Refactory.HotDraw.FigureTransitionType basicNew instVarAt: 1 put: #doubleClick; instVarAt: 2 put: ((Core.Array new: 1) at: 1 put: Refactory.Browser.VersionFigure; yourself); yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 575.303 y: 144.726); add: (Core.Point x: 578.113 y: 281.406); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Over VersionFigure'); to: (stateTable at: 'Menu'); type: (Refactory.HotDraw.FigureTransitionType basicNew instVarAt: 1 put: #yellowButtonPress; instVarAt: 2 put: ((Core.Array new: 1) at: 1 put: Refactory.Browser.VersionFigure; yourself); yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 544.187 y: 141.562); add: (Core.Point x: 283.894 y: 275.299); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Mouse Press'); to: (stateTable at: 'Select Figure'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #redButtonRelease; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 870.507 y: 307.959); add: (Core.Point x: 980.991 y: 371.435); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Mouse Press'); to: (stateTable at: 'Possible Drag'); type: (Refactory.HotDraw.FigureTransitionType basicNew instVarAt: 1 put: #mouseMove; instVarAt: 2 put: ((Core.Array new: 1) at: 1 put: Refactory.Browser.VersionFigure; yourself); yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 820.014 y: 296.798); add: (Core.Point x: 684.875 y: 332.933); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Possible Drag'); to: (stateTable at: 'Select Figure'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #redButtonRelease; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 685.009 y: 345.33); add: (Core.Point x: 961.886 y: 379.78); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Possible Drag'); to: (stateTable at: 'Possible Drag'); type: (Refactory.HotDraw.FigureTransitionType basicNew instVarAt: 1 put: #mouseMove; instVarAt: 2 put: ((Core.Array new: 1) at: 1 put: Refactory.Browser.VersionFigure; yourself); yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 599.028 y: 331.178); add: (Core.Point x: 455 y: 322); add: (Core.Point x: 455 y: 342); add: (Core.Point x: 597.261 y: 332.724); yourself); yourself).	transitions add: (ToolStateTransitionModel new from: (stateTable at: 'Possible Drag'); to: (stateTable at: 'Mouse Move Drag'); type: (Refactory.HotDraw.TransitionType basicNew instVarAt: 1 put: #mouseMove; yourself); points: ((Core.OrderedCollection new) add: (Core.Point x: 650.75 y: 354.938); add: (Core.Point x: 683.428 y: 408.353); yourself); yourself).	ToolStateMachineEditor openWithStates: states connections: transitions"	Tool states at: 'Version Tool' put: (ToolState name: 'Version Tool' command: [:tool :event | ]).	Tool states at: 'Enter VersionFigure' put: (ToolState name: 'Enter VersionFigure' command: [:tool :event |tool drawing model activeFigure: (tool figureAtEvent: event)]).	Tool states at: 'Drag Drop' put: (EndToolState name: 'Drag Drop' command: [:tool :event | | startFigure endFigure origin |origin := tool valueAt: #startPoint.tool drawing 	invalidateRectangle:		(Rectangle vertex: origin vertex: (tool valueAt: #lastPoint))	repairNow: true.startFigure := tool valueAt: #figure.endFigure := tool figureAtEvent: event.startFigure ~~ endFigure ifTrue: [startFigure dragDrop: endFigure]]).	Tool states at: 'Mouse Press' put: (ToolState name: 'Mouse Press' command: [:tool :event | | startPoint |startPoint := tool cursorPointFor: event.tool 	valueAt: #figure put: (tool figureAtEvent: event);	valueAt: #startPoint put: startPoint;	valueAt: #lastPoint put: startPoint]).	Tool states at: 'Abort Drag' put: (EndToolState name: 'Abort Drag' command: [:tool :event | | origin |origin := tool valueAt: #startPoint.tool drawing 	invalidateRectangle:		(Rectangle vertex: origin vertex: (tool valueAt: #lastPoint))	repairNow: true]).	Tool states at: 'Mouse Move Drag' put: (ToolState name: 'Mouse Move Drag' command: [:tool :event | | currentPoint origin |origin := tool valueAt: #startPoint.tool drawing 	invalidateRectangle:		(Rectangle vertex: origin vertex: (tool valueAt: #lastPoint))	repairNow: true.currentPoint := tool cursorPointFor: event.(LineSegment from: currentPoint to: origin)	displayStrokedOn: tool graphicsContext.tool valueAt: #lastPoint put: currentPoint]).	Tool states at: 'Browse' put: (EndToolState name: 'Browse' command: [:tool :event | (tool figureAtEvent: event) browseIt]).	Tool states at: 'Over VersionFigure' put: (ToolState name: 'Over VersionFigure' command: [:tool :event | ]).	Tool states at: 'Exit VersionFigure' put: (EndToolState name: 'Exit VersionFigure' command: [:tool :event | ]).	Tool states at: 'Select Figure' put: (EndToolState name: 'Select Figure' command: [:tool :event |tool drawing model selectedFigure: (tool figureAtEvent: event)]).	Tool states at: 'Possible Drag' put: (ToolState name: 'Possible Drag' command: [:tool :event | ]).	(Tool stateFor: 'Version Tool') mouseMove: ((FigureTransitionTable new)  on: Refactory.Browser.VersionFigure goto: (Tool stateFor: 'Enter VersionFigure'); yourself).	(Tool stateFor: 'Mouse Move Drag') mouseMove: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Mouse Move Drag'); yourself).	(Tool stateFor: 'Mouse Move Drag') redButtonRelease: ((FigureTransitionTable new)  on: Refactory.Browser.VersionFigure goto: (Tool stateFor: 'Drag Drop'); goto: (Tool stateFor: 'Abort Drag'); yourself).	(Tool stateFor: 'Mouse Press') mouseMove: ((FigureTransitionTable new)  on: Refactory.Browser.VersionFigure goto: (Tool stateFor: 'Possible Drag'); yourself).	(Tool stateFor: 'Mouse Press') redButtonRelease: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Select Figure'); yourself).	(Tool stateFor: 'Over VersionFigure') redButtonPress: ((FigureTransitionTable new)  on: Refactory.Browser.VersionFigure goto: (Tool stateFor: 'Mouse Press'); yourself).	(Tool stateFor: 'Over VersionFigure') mouseMove: ((FigureTransitionTable new)  on: Refactory.Browser.VersionFigure goto: (Tool stateFor: 'Over VersionFigure'); goto: (Tool stateFor: 'Exit VersionFigure'); yourself).	(Tool stateFor: 'Over VersionFigure') yellowButtonPress: ((FigureTransitionTable new)  on: Refactory.Browser.VersionFigure goto: (Tool stateFor: 'Menu'); yourself).	(Tool stateFor: 'Over VersionFigure') doubleClick: ((FigureTransitionTable new)  on: Refactory.Browser.VersionFigure goto: (Tool stateFor: 'Browse'); yourself).	(Tool stateFor: 'Enter VersionFigure') immediate: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Over VersionFigure'); yourself).	(Tool stateFor: 'Possible Drag') mouseMove: ((FigureTransitionTable new)  on: Refactory.Browser.VersionFigure goto: (Tool stateFor: 'Possible Drag'); goto: (Tool stateFor: 'Mouse Move Drag'); yourself).	(Tool stateFor: 'Possible Drag') redButtonRelease: ((SimpleTransitionTable new) goto: (Tool stateFor: 'Select Figure'); yourself).</body></methods><methods><class-id>Refactory.Browser.VersionFigure</class-id> <category>actions</category><body package="RBStoreExtensions">browseIt	"This blocks invoking browse (meaning open an RB on the class) if you are debugging an instance of a subclass of this."	&lt;actionNamed: #browse overrideLevel: 0&gt;	self subclassResponsibility</body><body package="RBStoreExtensions">compareVersionTo: aStoreSourceObject	&lt;actionNamed: #dragDrop overrideLevel: 0&gt;</body><body package="RBStoreExtensions">inspect	&lt;actionNamed: #inspect overrideLevel: 0&gt;	super inspect</body><body package="RBStoreExtensions">loadSrc	&lt;actionNamed: #load overrideLevel: 0&gt;	self model loadSrc.	self container ifNotNil: [ :c |		c invalidate.		c model changed: #loadSrc ]</body></methods><methods><class-id>Refactory.Browser.VersionFigure</class-id> <category>menu</category><body package="RBStoreExtensions">menuItems	&lt;menuItem: 'Inspect' position: 10.1 action: #inspect enabled: true&gt;	&lt;menuItem: 'Browse' position: 20.1 action: #browse enabled: true&gt;</body></methods><methods><class-id>Refactory.Browser.VersionFigure class</class-id> <category>private</category><body package="RBStoreExtensions">menuPragmas	&lt;pragmas: #instance&gt;	^#(		#menuItem:position:action:enabled:		#actionNamed:overrideLevel:	)</body></methods><methods><class-id>Refactory.Browser.PundleVersionFigure</class-id> <category>actions</category><body package="RBStoreExtensions">showPrerequisites	&lt;actionNamed: #showPrerequisites overrideLevel: 0&gt;	| stream prereqs |	stream := TextStream on: String new.	stream		emphasis: #bold;		nextPutAll: self model name;		space;		nextPutAll: self model version;		nextPutAll: ': ';		emphasis: nil.	self model developmentPrerequisites do: 			[:prereqArray | 			stream crtab.			prereqArray do: [:each | stream nextPutAll: each]				separatedBy: [stream space]].	prereqs := stream contents asComposedText.	(ApplicationWindow new)		label: 'Development Prerequisites';		component: prereqs;		openWithExtent: prereqs bounds extent andType: #normal.	ParagraphEditor currentSelection: stream contents asString</body></methods><methods><class-id>Refactory.Browser.PundleVersionFigure</class-id> <category>menu</category><body package="RBStoreExtensions">menuItems	&lt;menuItem: 'Development Prerequisites' position: 70.2 action: #showPrerequisites enabled: true&gt;</body></methods><methods><class-id>Refactory.Browser.PundleVersionFigure</class-id> <category>accessing</category><body package="RBStoreExtensions">compareVersionTo: aPundle	&lt;actionNamed: #dragDrop overrideLevel: 0&gt;	self model isBundle &amp; InputState default ctrlDown		ifTrue: 			[^(BundleStructureComparisonView new)				left: aPundle right: self model;				openScrolledWindow].	ComparePackages compareFromAll: (Array with: aPundle)		toAll: (Array with: self model)</body></methods><methods><class-id>Refactory.Browser.PundleShadowVersionFigure</class-id> <category>actions</category><body package="RBStoreExtensions">bless	&lt;actionNamed: #setBlessing overrideLevel: 0&gt;	Store.BlessingDialog setBlessingFor: self model</body><body package="RBStoreExtensions">compare	&lt;actionNamed: #compare overrideLevel: 0&gt;	self compareVersionTo: self model getImagePundle</body><body package="RBStoreExtensions">fileItOut	&lt;actionNamed: #fileOut overrideLevel: 0&gt;	self model fileOut</body><body package="RBStoreExtensions">mergeIntoImage	&lt;actionNamed: #merge overrideLevel: 0&gt;	Store.Glorp.MergeTool openOnPundles: (Array with: self model)</body><body package="RBStoreExtensions">reconcileIt	&lt;actionNamed: #reconcile overrideLevel: 0&gt;		[self model getImagePundle reconcileWithDbVersion: self model]		withStoreFeedbackOn: self topComponent</body><body package="RBStoreExtensions">replicate	&lt;actionNamed: #replicate overrideLevel: 0&gt;	| name |	name := self connectToDatabaseName.	name isNil ifTrue: [^self].	Cursor wait showWhile: [self replicateTo: name]</body><body package="RBStoreExtensions">replicationPossible	&lt;actionNamed: #replicateEnablement overrideLevel: 0&gt;	^#{Store.Glorp.StoreReplicator} isDefined</body></methods><methods><class-id>Refactory.Browser.PundleShadowVersionFigure</class-id> <category>menu</category><body package="RBStoreExtensions">menuItems	&lt;menuItem: 'Load' position: 30.1 action: #load enabled: true&gt;	&lt;menuItem: 'Merge Into Image' position: 30.2 action: #merge enabled: true&gt;	&lt;menuItem: 'Reconcile' position: 30.3 action: #reconcile enabled: true&gt;	&lt;menuItem: 'File out' position: 40.1 action: #fileOut enabled: true&gt;	&lt;menuItem: 'Compare with Image' position: 50.1 action: #compare enabled: true&gt;	&lt;menuItem: 'Set Blessing Level' position: 60.1 action: #setBlessing enabled: true&gt;	&lt;menuItem: 'Replicate to...' position: 70.1 action: #replicate enabled: #replicateEnablement&gt;</body></methods><methods><class-id>Refactory.Browser.VersionDrawingEditor class</class-id> <category>resources</category><body package="RBStoreExtensions">patternImage	"Tools.UIMaskEditor new openOnClass: self andSelector: #patternImage"	&lt;resource: #image&gt;	^(Image extent: 8@8 depth: 1 bitsPerPixel: 1 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 2) at: 1 put: Graphics.ColorValue white; at: 2 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); yourself)) usingBits: #[204 0 0 0 204 0 0 0 51 0 0 0 51 0 0 0 204 0 0 0 204 0 0 0 51 0 0 0 51 0 0 0])</body></methods><methods><class-id>Refactory.Browser.VersionDrawingEditor class</class-id> <category>interface specs</category><body package="RBStoreExtensions">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Drawing Editor' 			#bounds: #(#{Graphics.Rectangle} 2603 300 3158 780 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 2 2 ) 					#name: #LblessingFilter 					#label: 'Show only above blessing' ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.Rectangle} 156 2 300 25 ) 					#name: #blessingFilter 					#model: #blessingFilter 					#menu: #blessingLevelsMenu ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -200 1 2 0 -2 1 25 0 ) 					#name: #countingFilter 					#model: #countingFilter 					#menu: #countingMenu ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 30 0 0 1 0 0.55 ) 					#name: #DrawingPane 					#flags: 11 					#component: #drawing ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 0 0.55 2 1 3 0.55 ) 					#name: #ResizingSplitter1 					#horizontal: true 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'DrawingPane' 					#belowWidgets: 'versionInformationHolder' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 3 0.55 0 1 0 1 ) 					#name: #versionInformationHolder 					#model: #versionInformationHolder 					#style: #small 					#tabRequiresControl: true ) ) ) )</body></methods><methods><class-id>Refactory.Browser.VersionCodeTool class</class-id> <category>interface specs</category><body package="RBStoreExtensions">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #DrawingEditor #defaultString: 'Drawing Editor' #catalogID: #browser) 			#bounds: #(#{Graphics.Rectangle} 800 600 1355 1080 ) 			#colors: #(#{UI.LookPreferences} ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #versionEditor 					#flags: 0 					#majorKey: #{Refactory.Browser.VersionDrawingEditor} 					#minorKey: #windowSpec 					#clientKey: #versionEditor ) ) ) )</body></methods><methods><class-id>Refactory.Browser.PackageItemFigure</class-id> <category>menu</category><body package="RBStoreExtensions">menuItems	&lt;menuItem: 'Load' position: 30.1 action: #load enabled: true&gt;</body></methods><methods><class-id>Refactory.Browser.PundleCurrentVersionFigure</class-id> <category>menu</category><body package="RBStoreExtensions">menuItems	&lt;menuItem: 'Publish ...' position: 30.1 action: #publish enabled: true&gt;</body></methods><methods><class-id>Refactory.Browser.PundleCurrentVersionFigure</class-id> <category>actions</category><body package="RBStoreExtensions">publish	&lt;actionNamed: #publish overrideLevel: 0&gt;	self codeComponent storeInDB</body></methods><methods><class-id>Refactory.Browser.ClassVersionFigure</class-id> <category>actions</category><body package="RBStoreExtensions">compareVersionTo: aClassRecord	&lt;actionNamed: #dragDrop overrideLevel: 0&gt;	Store.ComparePackages compareClass: self model toClass: aClassRecord</body></methods><methods><class-id>Refactory.Browser.BundleVersionFigure</class-id> <category>menu</category><body package="RBStoreExtensions">menuItems	&lt;menuItem: 'List Contents' position: 20.2 action: #listContents enabled: true&gt;</body></methods><methods><class-id>Refactory.Browser.BundleVersionFigure</class-id> <category>actions</category><body package="RBStoreExtensions">listContents	&lt;actionNamed: #listContents overrideLevel: 0&gt;		[DefinitionForListTool forBundleContents: self model]		 withStoreFeedbackOn: self container model mainWindow.</body></methods><methods><class-id>Store.BasicBlessingPolicy class</class-id> <category>resources</category><body package="RBStoreExtensions">brokenImage	"Tools.UIMaskEditor new openOnClass: self andSelector: #brokenImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 19@19 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 3) at: 1 put: Graphics.ColorValue red; at: 2 put: Graphics.ColorValue white; at: 3 put: (Graphics.ColorValue scaledRed: 4227 scaledGreen: 0 scaledBlue: 0); yourself)) usingBits: #[85 85 85 85 84 0 0 0 85 85 85 85 84 0 0 0 85 85 85 85 84 0 0 0 85 85 85 85 84 0 0 0 85 85 85 85 84 0 0 0 85 85 85 85 84 0 0 0 85 85 85 85 84 0 0 0 85 73 80 85 84 0 0 0 85 5 104 149 84 0 0 0 85 2 84 149 84 0 0 0 85 9 80 149 84 0 0 0 85 37 66 149 84 0 0 0 85 105 90 85 84 0 0 0 85 85 85 85 84 0 0 0 85 85 85 85 84 0 0 0 85 85 85 85 84 0 0 0 85 85 85 85 84 0 0 0 85 85 85 85 84 0 0 0 85 85 85 85 84 0 0 0])</body><body package="RBStoreExtensions">developmentImage	"Tools.UIMaskEditor new openOnClass: self andSelector: #developmentImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 19@19 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 6) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 3 put: Graphics.ColorValue white; at: 4 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 4227 scaledBlue: 0); at: 5 put: Graphics.ColorValue green; at: 6 put: (Graphics.ColorValue scaledRed: 4227 scaledGreen: 4227 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"H"DQDQH"H@@@H"H"H"D@@@H"H@@@H"H"H"D@@@@"H@@@H"H"H"H!T"H"H@@@H"IDQBH!T"H"H@@@H"QDQCH!T"H"H@@@H"QDQCH!T"H"H@@@H"QDQCH!T"H"H@@@H"QDP3H!T"H"H@@@H"H3L2H!T"H"H@@@H"H"H"H!T"H"H@@@H"H"H"H!T"H"H@@@H"H"H"H!T"H"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@'))</body><body package="RBStoreExtensions">integratedImage	"Tools.UIMaskEditor new openOnClass: self andSelector: #integratedImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 19@19 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 6) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 4227 scaledGreen: 0 scaledBlue: 4227); at: 3 put: Graphics.ColorValue white; at: 4 put: Graphics.ColorValue magenta; at: 5 put: (Graphics.ColorValue scaledRed: 4227 scaledGreen: 0 scaledBlue: 0); at: 6 put: Graphics.ColorValue blue; yourself)) usingBits: (ByteArray fromPackedString: 'H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"H"H"P"H"H@@@H"H"H"H"P@H"H@@@H"H"H"H"P@H"H@@@H"H"H"QDQDP"H@@@H"H"H"H P"H"H@@@H"H3L2HBP"H"H@@@H"L3L1H"P"H"H@@@H"L3L1H"H"H"H@@@H"L3L1H"H"H"H@@@H"L3LQH"H"H"H@@@H"HQDRIRH"H"H@@@H"H"H"H%H"H"H@@@H"H"H"H"T%H"H@@@H"H"H"H"IUH"H@@@H"H"H"H"UUH"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@'))</body><body package="RBStoreExtensions">integrationReadyImage	"Tools.UIMaskEditor new openOnClass: self andSelector: #integrationReadyImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 19@19 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5460 5460 5460)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4111 4111 4111)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[85 85 85 85 84 0 0 0 85 85 85 85 84 0 0 0 85 85 85 21 84 0 0 0 85 85 85 41 84 0 0 0 85 85 85 41 84 0 0 0 85 85 64 0 84 0 0 0 85 85 86 21 84 0 0 0 85 0 89 21 84 0 0 0 84 0 149 21 84 0 0 0 84 0 149 85 84 0 0 0 84 0 149 85 84 0 0 0 84 2 149 85 84 0 0 0 85 170 89 85 84 0 0 0 85 85 86 85 84 0 0 0 85 85 85 153 84 0 0 0 85 85 85 105 84 0 0 0 85 85 85 169 84 0 0 0 85 85 85 85 84 0 0 0 85 85 85 85 84 0 0 0])</body><body package="RBStoreExtensions">internalReleaseImage	"Tools.UIMaskEditor new openOnClass: self andSelector: #internalReleaseImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 19@19 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue yellow; at: 3 put: Graphics.ColorValue white; at: 4 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 5 put: (Graphics.ColorValue scaledRed: 4227 scaledGreen: 4227 scaledBlue: 0); yourself)) usingBits: (ByteArray fromPackedString: 'H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"L2HQDRH"H@@@H"H"H"DQDTH"H@@@H"H3L2DQDTH"H@@@H"H"H"DQDTH"H@@@H#L3L2DQEDH"H@@@H"H"H"IDQBH"H@@@H@@@@@@@@@@"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@'))</body><body package="RBStoreExtensions">mergedImage	"Tools.UIMaskEditor new openOnClass: self andSelector: #mergedImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 19@19 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 4) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue blue; at: 3 put: Graphics.ColorValue white; at: 4 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 0 scaledBlue: 4227); yourself)) usingBits: #[170 170 170 170 168 0 0 0 170 170 170 170 168 0 0 0 170 170 170 170 168 0 0 0 169 170 170 170 168 0 0 0 170 106 170 170 168 0 0 0 170 153 170 170 168 0 0 0 170 165 170 170 168 0 0 0 170 149 165 90 168 0 0 0 170 170 149 94 168 0 0 0 170 170 149 94 168 0 0 0 170 170 149 94 168 0 0 0 170 170 149 126 168 0 0 0 170 128 175 250 168 0 0 0 170 160 170 170 168 0 0 0 170 136 170 170 168 0 0 0 170 42 170 170 168 0 0 0 168 170 170 170 168 0 0 0 170 170 170 170 168 0 0 0 170 170 170 170 168 0 0 0])</body><body package="RBStoreExtensions">noImage	"Tools.UIMaskEditor new openOnClass: self andSelector: #noImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 1@19 depth: 1 bitsPerPixel: 1 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 1) at: 1 put: Graphics.ColorValue white; yourself)) usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="RBStoreExtensions">otherImage	"Tools.UIMaskEditor new openOnClass: self andSelector: #otherImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 19@19 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 3) at: 1 put: Graphics.ColorValue white; at: 2 put: (Graphics.ColorValue scaledRed: 4227 scaledGreen: 4227 scaledBlue: 4227); at: 3 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); yourself)) usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 10 168 0 0 0 0 0 0 42 169 0 0 0 0 0 0 42 169 0 0 0 0 0 0 36 41 0 0 0 0 0 0 0 36 0 0 0 0 0 170 0 36 0 0 0 0 2 170 64 144 0 0 0 0 2 170 64 128 0 0 0 0 2 170 64 128 0 0 0 0 2 169 64 64 0 0 0 0 0 85 0 0 0 0 0 0 0 0 2 144 0 0 0 0 0 0 2 144 0 0 0 0 0 0 1 80 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="RBStoreExtensions">patchImage	"Tools.UIMaskEditor new openOnClass: self andSelector: #patchImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 19@19 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 4111 4111)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[85 85 85 85 84 0 0 0 85 86 85 85 84 0 0 0 85 106 102 85 84 0 0 0 85 96 170 101 84 0 0 0 86 170 34 165 84 0 0 0 85 128 34 42 148 0 0 0 86 168 0 32 148 0 0 0 85 128 0 10 164 0 0 0 90 160 0 2 84 0 0 0 86 0 0 42 148 0 0 0 106 128 0 2 84 0 0 0 88 0 0 170 84 0 0 0 88 128 0 9 84 0 0 0 90 136 128 170 84 0 0 0 85 170 136 37 84 0 0 0 85 153 168 37 84 0 0 0 85 89 154 165 84 0 0 0 85 85 89 85 84 0 0 0 85 85 85 85 84 0 0 0])</body><body package="RBStoreExtensions">readToMergeImage	"Tools.UIMaskEditor new openOnClass: self andSelector: #readToMergeImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 19@19 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5460 5460 5460)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4111 4111 4111)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[170 170 170 170 168 0 0 0 170 170 170 170 168 0 0 0 170 170 170 170 168 0 0 0 168 170 170 170 168 0 0 0 170 42 170 170 168 0 0 0 170 136 170 170 168 0 0 0 170 160 170 170 168 0 0 0 170 128 160 10 168 0 0 0 170 170 128 14 168 0 0 0 170 170 128 14 168 0 0 0 170 170 128 14 168 0 0 0 170 170 128 62 168 0 0 0 170 149 175 250 168 0 0 0 170 165 170 170 168 0 0 0 170 153 170 170 168 0 0 0 170 106 170 170 168 0 0 0 169 170 170 170 168 0 0 0 170 170 170 170 168 0 0 0 170 170 170 170 168 0 0 0])</body><body package="RBStoreExtensions">releasedImage	"Tools.UIMaskEditor new openOnClass: self andSelector: #releasedImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 19@19 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 5) at: 1 put: Graphics.ColorValue black; at: 2 put: Graphics.ColorValue green; at: 3 put: Graphics.ColorValue white; at: 4 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 5 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 4227 scaledBlue: 0); yourself)) usingBits: (ByteArray fromPackedString: 'H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"L2HQDRH"H@@@H"H"H"DQDTH"H@@@H"H3L2DQDTH"H@@@H"H"H"DQDTH"H@@@H#L3L2DQEDH"H@@@H"H"H"IDQBH"H@@@H@@@@@@@@@@"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@'))</body><body package="RBStoreExtensions">testedImage	"Tools.UIMaskEditor new openOnClass: self andSelector: #testedImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 19@19 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 8191 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 4111 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[255 255 255 255 252 0 0 0 255 255 255 255 252 0 0 0 255 255 255 255 92 0 0 0 255 255 255 253 124 0 0 0 255 0 0 5 252 0 0 0 255 63 255 213 252 0 0 0 253 127 255 87 252 0 0 0 254 95 253 83 252 0 0 0 255 151 245 115 252 0 0 0 255 21 213 243 252 0 0 0 255 37 85 243 252 0 0 0 255 57 87 243 252 0 0 0 255 57 87 243 252 0 0 0 255 61 95 243 252 0 0 0 255 2 80 3 252 0 0 0 255 254 95 255 252 0 0 0 255 255 175 255 252 0 0 0 255 255 255 255 252 0 0 0 255 255 255 255 252 0 0 0])</body><body package="RBStoreExtensions">toReviewImage	"Tools.UIMaskEditor new openOnClass: self andSelector: #toReviewImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 19@19 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 6) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 4227 scaledGreen: 4227 scaledBlue: 0); at: 3 put: Graphics.ColorValue white; at: 4 put: Graphics.ColorValue yellow; at: 5 put: (Graphics.ColorValue scaledRed: 0 scaledGreen: 4227 scaledBlue: 0); at: 6 put: Graphics.ColorValue green; yourself)) usingBits: (ByteArray fromPackedString: 'H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"H"H3L3H"H@@@H"H"H"L3L3D"H@@@H"H"H"L3L3D"H@@@H"H"H"LRH3D"H@@@H"H"H"H"H1H"H@@@H"IUURH"H1H"H@@@H"UUUTH"LRH"H@@@H"UUUTH"L"H"H@@@H"UUUTH"L"H"H@@@H"UUUDH"D"H"H@@@H"IDQBH"H"H"H@@@H"H"H"H#LRH"H@@@H @@@@@CLP@BH@@@H"H"H"H!DRH"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@H"H"H"H"H"H"H@@@'))</body><body package="RBStoreExtensions">workInProgressImage	"Tools.UIMaskEditor new openOnClass: self andSelector: #workInProgressImage"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 19@19 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 6) at: 1 put: Graphics.ColorValue black; at: 2 put: (Graphics.ColorValue scaledRed: 5548 scaledGreen: 5548 scaledBlue: 5548); at: 3 put: (Graphics.ColorValue scaledRed: 4227 scaledGreen: 4227 scaledBlue: 0); at: 4 put: Graphics.ColorValue white; at: 5 put: Graphics.ColorValue yellow; at: 6 put: (Graphics.ColorValue scaledRed: 4227 scaledGreen: 4227 scaledBlue: 4227); yourself)) usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L@@@L3L3L3L3L3L3L@@@L3L3L3L3L3L3L@@@L3L3L3DQDQL3L@@@L3L3L3D@@@L3L@@@L3L3L3D@@@@3L@@@L3L3L3L1T3L3L@@@L3MDQCL1T3L3L@@@L3QDQBL1T3L3L@@@L3QDQBL1T3L3L@@@L3QDQBL1T3L3L@@@L3QDP"L1T3L3L@@@L3L"H#L1T3L3L@@@L3L3L3L1T3L3L@@@L3L3L3L1T3L3L@@@L3L3L3L1T3L3L@@@L3L3L3L3L3L3L@@@L3L3L3L3L3L3L@@@L3L3L3L3L3L3L@@@'))</body></methods><methods><class-id>Refactory.Browser.CodeModel class</class-id> <category>tool registration</category><body package="RBStoreExtensions">versionCodeToolClass	&lt;tool: 980&gt;	^VersionCodeTool</body></methods><initialize><class-id>Refactory.Browser.VersionFigure</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>DefinitionForListTool</name><environment>Store.Glorp</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definition listPart status </inst-vars><class-inst-vars></class-inst-vars><imports>			private Store.Glorp.*			</imports><category></category><attributes><package>Store-UI</package></attributes></class><class><name>CompositeFigure</name><environment>Refactory.HotDraw</environment><super>Refactory.HotDraw.Figure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Framework</category><attributes><package>HotDraw Framework</package></attributes></class><class><name>PundleModel</name><environment>Store</environment><super>Kernel.CodeComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbInfo readonly </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>BasicBlessingPolicy</name><environment>Store</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blessings defaultBlessing </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-User Management</category><attributes><package>Store-User Management</package></attributes></class><class><name>CodeTool</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>codeModel menu </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Code Tools</category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>DrawingEditor</name><environment>Refactory.HotDraw</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>buttons drawing </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>HotDraw-Framework</category><attributes><package>HotDraw Framework</package></attributes></class></st-source>