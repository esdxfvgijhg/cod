<?xml version="1.0"?><st-source><!-- Name: Model-ObservablesNotice: Copyright 1999-2013 Cincom Systems, Inc.  All rights reserved.Comment: This package contains the implementation of ObservedValue, BufferedValue, ObservedList and other Announcements-aware models.DbIdentifier: bear73DbTrace: 400480DbUsername: nrossDbVersion: 7.10 - 1DevelopmentPrerequisites: #(#(#any 'System-Announcements' ''))PackageName: Model-ObservablesParcel: #('Model-Observables')PrerequisiteParcels: #(#('System-Announcements' ''))PrintStringCache: (7.10 - 1,nross)Version: 7.10 - 1Date: 6:44:39 AM April 3, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (mar13.5) of April 3, 2013 on April 3, 2013 at 6:44:39 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ObservedValue</name><environment>Core</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>Model-Observables</package></attributes></class><comment><class-id>Core.ObservedValue</class-id><body>A ObservedValue is an Announcements-aware equilvalent of ValueHolder. It holds onto an object, accessible through #value/value: pair of messages, and announces ValueAboutToChange, ValueChanging and ValueChanged announcements as the value is being changed.Instance Variables:	value	&lt;Object&gt;	The value that, when gets replaced via #value: will broadcast the standard sequence of three change announcements (see below).Announcements	ValueAboutToChange	Announced when the value held by the receiver is about to change. This announcement is vetoable, and if the #veto message is sent to it, the change is aborted and none of the following announcements are broadcast.	ValueChanging		Announced just before changing the value, when the change is imminent.	ValueChanged		Announced right after changing the value.</body></comment><class><name>BufferedValue</name><environment>Core</environment><super>Core.ObservedValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model coordinator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>Model-Observables</package></attributes></class><comment><class-id>Core.BufferedValue</class-id><body>BufferedValue hides behing itself another ObservedValue object (the model). Any #value: messages sent to BufferedValue store the argument in the BufferedValue rather than the model. Sending #value to the BufferedValue answers that locally stored value if it's present rather than the value of the model. This stored value can later be committed into the model by sending the #commit message to the buffered value. #reset message will cause the BufferedValue to discard its current local value.In addition to this #commit/#reset protocol, a BufferedValue can be configured to commit and reset its value by watching a "coordinator" object. This way, a group of BufferedValues can be controlled centrally by changing a single observed value. Changing the coordinator's value to true commits all BufferedValues watching it, and changing it to false resets them. A coordinator is set by sending the #coordinator: message to the BufferedValue.Instance Variables:	model	&lt;ObservedValue&gt;	This is the model object whose value the receiver is buffering.	coordinator	&lt;(ObservedValue on: Boolean) | nil&gt;	The optional coordinator triggering the receiver's commits and resets..Class Variables:	NotYetAssigned	&lt;Object&gt; 	A distinguished value used to indicate that the receiver has no local value set yet, so that the model's current value is "showing through".</body></comment><class><name>ContentsChangeAnnouncement</name><environment>Core</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>indexes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>Model-Observables</package></attributes></class><comment><class-id>Core.ContentsChangeAnnouncement</class-id><body>ContentsChangeAnnouncement is an abstract superclass of announcements notifying about the change in elements of an ObservedList of ObservedTwoDList. It typically includes the Interval of collection idexes affected by the change, accessible as #indexes. Announcements from ObservedTwoDList use the point of the change instead, accessible as #location.Instance Variables:	indexes	&lt;Interval | Point | nil&gt;	The location of the change, if applicable.</body></comment><class><name>ElementsReordered</name><environment>Core</environment><super>Core.ContentsChangeAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>Model-Observables</package></attributes></class><comment><class-id>Core.ElementsReordered</class-id><body>ElementsReordered notifies about the change of order of elements in the collection, without adding or removing any elements. The 'indexes' attribute is not used by this announcement.</body></comment><class><name>ElementsTransposed</name><environment>Core</environment><super>Core.ElementsReordered</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transposed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>Model-Observables</package></attributes></class><comment><class-id>Core.ElementsTransposed</class-id><body>ElementsTransposed notifies about transposing an ObservedTwoDList. The 'transposed' attribute contains the new state of the transposed flag of the collection.Instance Variables:	transposed	&lt;Boolean&gt;	Shows whether the 2D list is transposed or not after the change.</body></comment><class><name>ValueChangeAnnouncement</name><environment>Core</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>newValue oldValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>Model-Observables</package></attributes></class><comment><class-id>Core.ValueChangeAnnouncement</class-id><body>ValueChangeAnnouncement is an abstract superclass of announcements informing of an object's value changing. It can carry both the old and the new value if the announces chooses to provide them.Instance Variables:	newValue	&lt;Object | nil&gt;	The new value.	oldValue	&lt;Object | nil&gt;	The old value.</body></comment><class><name>ObservedTwoDList</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection rows columns transposed subscriptionRegistry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>Model-Observables</package></attributes></class><comment><class-id>Core.ObservedTwoDList</class-id><body>ObservedTwoDList is the two-dimensional analogue of an ObservedList.  However, while ObservedLists are dynamically extensible, ObservedTwoDLists are not.  The individual elements of the TwoDList are accessible either in terms of index points or in terms of their position in the underlying sequence.This class has the idea of transposing the data that it is responsible for.  When an ObservedTwoDList has "transposed" the data, all that is actually occuring is that the interpretation of the 'x' and 'y' values is swapped.  Thus the data is still in it's original list form, only the point access is transposed to give the behavior of having actually transposed the data.  Instance Variables:	collection	&lt;ArrayedCollection&gt;  The elements of the TwoDList in linear array	rows	&lt;Integer&gt;  The number of rows	columns	&lt;Integer&gt;  The number of columns	transposed	&lt;Boolean&gt;	A flag to indicate whether or not this list have been "transposed"	subscriptionRegistry	&lt;SubscriptionRegistry | nil&gt; The locally stored registry for subscriptions to announcements of the receiver.Announcements	ValueAboutToChange	Announced when the value held by the receiver is about to change in any way. This announcement is vetoable, and if the #veto message is sent to it, the change is aborted and none of the following announcements are broadcast. Note that ObservedLists don't set newValue and oldValue attributes of this announcement.	ValueChanging		Announced just before changing the value, when the change is imminent. Note that ObservedLists don't set newValue and oldValue attributes of this announcement.	ValueChanged		Announced right after changing the value. Note that ObservedLists don't set newValue and oldValue attributes of this announcement.	ElementsReplaced	Announced after some elements within a contiguous range have been replaced with other objects without changing the size of the collection, for example by using #at:put: or #repaceFrom:to:with:startingAt:. The 'indexes' attribute of the announcement contains an Interval of indexes affected. The 'elements' attribute contains the elements that used to reside at those indexes.	ElementsReordered	Announced after the order of elements in the collection has been changed, without adding or removing any elements. For example, the #sort: message causes this to be triggered.	ElementsTransposed	Announced after transposing the list.Object Reference:An ObservedTwoDList is a two-dimensional list, representing rows and columns in a table. It is typically used to hold the data for a Grid. Because its size cannot be changed dynamically, it is only used for a Grid whose size does not change. For a dynamically extensible Grid, use a ObservedList instead. An ObservedTwoDList has an underlying one-dimensional collection of elements. It is typically created by sending a variant of #on:columns:rows: to this class, with the collection of elements as the first argument. The specified number of rows and columns, when multiplied together, are expected to equal the size of the base collection. An element in an ObservedTwoDList can be accessed either via column-and-row numbers or via a flat index number for the underlying collection. </body></comment><class><name>ValueAboutToChange</name><environment>Core</environment><super>Core.ValueChangeAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>vetoed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>Model-Observables</package></attributes></class><comment><class-id>Core.ValueAboutToChange</class-id><body>ValueAboutToChange is one of the three announcements of the standard value change sequence. An object notifying about the change of the value does so as a sequence of three announcements:	ValueAboutToChange		sequence stops here if the above is vetoed	ValueChanging	&lt;value changes at this point&gt;	ValueChangedAll announcements carry the old and the new values, if at all possible.ValueAboutToChange is vetoable; vetoing it cancels the value change. Subscribe to it if you are interested in preventing some of the value changes to happen.ValueChanging is broadcast before an imminent value change. Subscribe to it to be notified before a value change. Do not use AboutToChangeValue for that purpose--AboutToChangeValue doesn't guarantee that the value change is imminent, since a subscriber receiving an announcement later could veto it.ValueChanged is broadcast after a value change.</body></comment><class><name>ElementsInserted</name><environment>Core</environment><super>Core.ContentsChangeAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>Model-Observables</package></attributes></class><comment><class-id>Core.ElementsInserted</class-id><body>ElementsInserted notifies about adding new elements to a collection, thus increasing its size. The indexes of the new elements are included as the 'indexes' attribute.</body></comment><class><name>ValueChanged</name><environment>Core</environment><super>Core.ValueChangeAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>Model-Observables</package></attributes></class><comment><class-id>Core.ValueChanged</class-id><body>ValueChanged is one of the three announcements of the standard value change sequence. An object notifying about the change of a value does so as a sequence of three announcements:	ValueAboutToChange		sequence stops here if the above is vetoed	ValueChanging	&lt;value changes at this point&gt;	ValueChangedAll announcements carry the old and the new values, if at all possible.ValueAboutToChange is vetoable; vetoing it cancels the value change. Subscribe to it if you are interested in preventing some of the value changes to happen.ValueChanging is broadcast before an imminent value change. Subscribe to it to be notified before a value change. Do not use AboutToChangeValue for that purpose--AboutToChangeValue doesn't guarantee that the value change is imminent, since a subscriber receiving an announcement later could veto it.ValueChanged is broadcast after a value change.</body></comment><class><name>AccessAdaptor</name><environment>Core</environment><super>Core.Announcer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model accessor mutator accessPath privateModelValue modelAnnouncesUpdate modelUpdateAnnouncement </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>Model-Observables</package></attributes></class><comment><class-id>Core.AccessAdaptor</class-id><body>AccessAdaptor encapsulates a complex way of retrieving data from the model behind the uniform #value/#value: interface.One creates an AccessAdaptor (either by "AccessAdaptor new model: &lt;anObject&gt;" or "AccessAdaptor with: &lt;anObject&gt;") and then sets the various attributes to configure how the adaptor should access the model to retrieve the value it reports (the "accessor") and update the model to store the value (the "mutator"). The accessor and mutator values may be either a Symbol, an Integer or a Block. If the accessor is a Symbol, it is a unary selector sent to the model as a message and the result is returned as the adaptor's value. If the mutator is a Symbol, it is a one-argument selector sent to the model as a message with the new value as the argument. If no mutator is configured explicitly, the accessor with ':' appended is used as the mutator.If an accessor is an Integer, then when accessing, the #at: method is sent with the accessor as the argument, and when mutating, #at:put: with the accessor as the first argument and the new value as the second.If the accessor is a Block, it should be a one-argument block, where the model is sent in as parameter. The value returned by the block is the value returned by the adaptor. If the mutator is a block, it is a two-argument block where the first parameter is the underlying model and the second is the new value that is to be assigned for that model.The accessPath, if specified, contains a collection of vaid accessors (Symbols or Integers). When getting or setting, each item in the accessPath is performed against the model, before the final accessor or mutator is performed. This array of selectors and/or numbers, allows one to "drill" into a domain model. For example, if one had a collection of companies as a domain object for which one wanted the first item, and from that item the shipping address, and from the address the state, one could specify the accessPath: #(1 #shippingAddress) and the accessor: #state.The user may also send in a ObservedValue to the model: message. This allows the user to embed the model object into something they can change later without having to touch the AccessAdaptor. When the user does this, the ObservedValue is set to let the AccessAdaptor know if the user changes the value in the ObservedValue, and to rehook itself to now work on THAT new value. If the user is using a domain object that itself triggers events when it is changed, the user may set the modelUpdateAnnouncement to be the announcement class broadcast by the domain model that we want to watch for. Once that is set, the AccessAdaptor will itself trigger the ModelUpdated announcements, which the user can then subscribe to and be notified about.Instance Variables:	accessor	&lt;Symbol | BlockContext | Integer&gt;	The access executor for this model	accessPath	&lt;(Collection of: (Symbol | Integer))&gt;	The default is nil	model	&lt;Object&gt;	The model object being managed by this adaptor	modelAnnouncesUpdate	&lt;Boolean&gt;	True if the receiver should subscribe to and listed to modelUpdateAnnouncements.	mutator	&lt;Symbol | BlockContext | Integer | nil&gt;	Default is nil.	privateModelValue	&lt;ObservedValue | nil&gt;	PRIVATE: Used internally when the model is wrapped in an ObservedValue object	modelUpdateAnnouncement	&lt;Announcement class | nil&gt;	If not nil, the announcement class the reeiver should listen to to respond to changes in the model.Announcements	ValueAboutToChange	Announced when the value held by the receiver is about to change. This announcement is vetoable, and if the #veto message is sent to it, the change is aborted and none of the following announcements are broadcast.	ValueChanging		Announced just before changing the value, when the change is imminent.	ValueChanged		Announced right after changing the value.	ModelUpdated	Announced when the underlying model broadcasts "modelUpdateAnnouncement" thus notifying the world that the value in the model itself, or the value in the model has changed external to the behavior of this AccessAdaptor</body></comment><class><name>ObservedList</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection limit collectionSize subscriptionRegistry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>Model-Observables</package></attributes></class><comment><class-id>Core.ObservedList</class-id><body>ObservedList is an OrderedCollection-like object which announces changes of its contents. It has both the fast #at:put: commands of an Arrayed object, as well as the ability to use the #add: protocol of an growable collection.Instance Variables:	collection	&lt;SequenceableCollection of: Object&gt;	Private: The raw collection it holds.	collectionSize	&lt;ArithmeticValue&gt;	Private: The raw collection size.	limit	&lt;Number&gt;	Private: The maximum position inside the collection that is used.	subscriptionRegistry	&lt;SubscriptionRegistry | nil&gt; Holds subscriptions to announcements of the receiver.Announcements	ValueAboutToChange	Announced when the value held by the receiver is about to change in any way. This announcement is vetoable, and if the #veto message is sent to it, the change is aborted and none of the following announcements are broadcast. Note that ObservedLists don't set newValue and oldValue attributes of this announcement.	ValueChanging		Announced just before changing the value, when the change is imminent. Note that ObservedLists don't set newValue and oldValue attributes of this announcement.	ValueChanged		Announced right after changing the value. Note that ObservedLists don't set newValue and oldValue attributes of this announcement.	ElementsReplaced	Announced after some elements within a contiguous range have been replaced with other objects without changing the size of the collection, for example by using #at:put: or #repaceFrom:to:with:startingAt:. The 'indexes' attribute of the announcement contains an Interval of indexes affected. The 'elements' attribute contains the elements that used to reside at those indexes.	ElementsInserted		Announced after new elements have been inserted into the collection, increasing its size. For example, #add:, #addLast:, #addAll:, #insertCollection:before: all broadcast this announcement.  The 'indexes' attribute of the announcement contains an Interval of indexes affected.	ElementsRemoved	Announced after elements have been removed from the collection, reducing its size. The 'elements' attribute contains a collection of removed objects.	ElementsReordered	Announced after the order of elements in the collection has been changed, without adding or removing any elements. For example, the #sort: message causes this to be triggered.</body></comment><class><name>ElementsReplaced</name><environment>Core</environment><super>Core.ContentsChangeAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>Model-Observables</package></attributes></class><comment><class-id>Core.ElementsReplaced</class-id><body>ElementsReplaced notifies about replacing a range of elements in a collection (even if the range includes only one element) with other elements. The 'indexes' variable shows the location of the change, and the 'elements' holds the collection of objects previously at the affected indexes.Instance Variables:	elements	&lt;Collection&gt;	</body></comment><class><name>ValueChanging</name><environment>Core</environment><super>Core.ValueChangeAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>Model-Observables</package></attributes></class><comment><class-id>Core.ValueChanging</class-id><body>ValueChanging is one of the three announcements of the standard value change sequence. An object notifying about the change of the value does so as a sequence of three announcements:	ValueAboutToChange		sequence stops here if the above is vetoed	ValueChanging	&lt;value changes at this point&gt;	ValueChangedAll announcements carry the old and the new values, if at all possible.ValueAboutToChange is vetoable; vetoing it cancels the value change. Subscribe to it if you are interested in preventing some of the value changes to happen.ValueChanging is broadcast before an imminent value change. Subscribe to it to be notified before a value change. Do not use AboutToChangeValue for that purpose--AboutToChangeValue doesn't guarantee that the value change is imminent, since a subscriber receiving an announcement later could veto it.ValueChanged is broadcast after a value change.</body></comment><class><name>CopiedBufferedValue</name><environment>Core</environment><super>Core.BufferedValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>Model-Observables</package></attributes></class><comment><class-id>Core.CopiedBufferedValue</class-id><body>CopiedBufferedValue is exactly like a BufferedValue except that it copies the underlying object in the model into the local value, rather than having the model's value "show through" when there is no local one. In other words, for a newly created BufferedValue "bufferedValue value == bufferedValue model value" is true, while for CopiedBufferedValue it's false (unless the value is an object for which copy does not create a new instance, such as immediates and Symbols).</body></comment><class><name>ModelUpdated</name><environment>Core</environment><super>Core.Announcement</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>Model-Observables</package></attributes></class><comment><class-id>Core.ModelUpdated</class-id><body>ModelUpdated is broadcast by an AccessAdaptor to notify any interested parties about the model of the adaptor signaling a changed event.</body></comment><class><name>ElementsRemoved</name><environment>Core</environment><super>Core.ContentsChangeAnnouncement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>Model-Observables</package></attributes></class><comment><class-id>Core.ElementsRemoved</class-id><body>ElementsRemoved notifies about removing a contiguous range of elements from a collection (or a single element). The 'indexes' attribute contains the indexes of the removed elements *before the removal*. The 'elements' attribute contains a collection of elements that have been removed.Instance Variables:	elements	&lt;Collection&gt;	A collection of objects just removed from the collection. This is always a collection, even if only one element has been removed.</body></comment><shared-variable><name>NotYetAssigned</name><environment>Core.BufferedValue</environment><private>false</private><constant>true</constant><category>unassigned value</category><initializer>Object new</initializer><attributes><package>Model-Observables</package></attributes></shared-variable><methods><class-id>Core.ObservedValue</class-id> <category>converting</category><body package="Model-Observables">asObservedValue	^self</body></methods><methods><class-id>Core.ObservedValue</class-id> <category>testing</category><body package="Model-Observables">isObservedValue	^true</body></methods><methods><class-id>Core.ObservedValue</class-id> <category>accessing</category><body package="Model-Observables">numArgs	^0</body><body package="Model-Observables">object	^value</body><body package="Model-Observables">quietlySetValue: anObject	value := anObject.</body><body package="Model-Observables">setValue: anObject	value := anObject.</body><body package="Model-Observables">value	^value</body><body package="Model-Observables">value: anObject	"Lines to be removed when breaking dependency on TriggerEvent framework	are marked with a double double quote."	| oldValue |	oldValue := value.	(self announce: (ValueAboutToChange from: oldValue to: anObject)) isVetoed		ifTrue: [^self].	self announce: (ValueChanging from: oldValue to: anObject).	self setValue: anObject.	self announce: (ValueChanged from: oldValue to: anObject)</body></methods><methods><class-id>Core.ObservedValue class</class-id> <category>instance creation</category><body package="Model-Observables">with: anIntialValue	^self new setValue: anIntialValue</body></methods><methods><class-id>Core.BufferedValue</class-id> <category>testing</category><body package="Model-Observables">isBufferedValue	^true</body></methods><methods><class-id>Core.BufferedValue</class-id> <category>accessing</category><body package="Model-Observables">coordinator	^coordinator</body><body package="Model-Observables">coordinator: anObservedValue	coordinator ifNotNil: [coordinator unsubscribe: self].	coordinator := anObservedValue.	coordinator when: ValueChanged send: #coordinatorValueChanged: to: self.</body><body package="Model-Observables">model	^model</body><body package="Model-Observables">model: anObservedValue	model := anObservedValue</body><body package="Model-Observables">notYetAssigned	^self class notYetAssigned</body><body package="Model-Observables">value	^value == self notYetAssigned ifTrue: [ self model value ] ifFalse: [ value ]</body></methods><methods><class-id>Core.BufferedValue</class-id> <category>private</category><body package="Model-Observables">coordinatorValueChanged: aChangedValue	aChangedValue newValue		ifTrue: [self commit]		ifFalse: [self reset].	coordinator setValue: nil</body></methods><methods><class-id>Core.BufferedValue</class-id> <category>commands</category><body package="Model-Observables">commit	value == self notYetAssigned ifTrue: [^self].	model value: value</body><body package="Model-Observables">reset	value := self notYetAssigned</body></methods><methods><class-id>Core.BufferedValue</class-id> <category>initialize-release</category><body package="Model-Observables">initialize	super initialize.	model := nil asObservedValue.	value := self notYetAssigned</body></methods><methods><class-id>Core.BufferedValue class</class-id> <category>instance creation</category><body package="Model-Observables">model: aValueEvent	^self new model: aValueEvent</body></methods><methods><class-id>Core.BufferedValue class</class-id> <category>accessing</category><body package="Model-Observables">notYetAssigned	NotYetAssigned isNil ifTrue: [#{Core.BufferedValue.NotYetAssigned} initialize].	^NotYetAssigned</body></methods><methods><class-id>Core.ContentsChangeAnnouncement</class-id> <category>initialize-release</category><body package="Model-Observables">from: startInteger to: endInteger	"The change is between the the indexes passed as the arguments.	The indexes are inclusive, just like copyFrom:to:."	indexes := startInteger to: endInteger</body><body package="Model-Observables">index: anInteger	"The change affects only one elements at the given index."	indexes := anInteger to: anInteger</body><body package="Model-Observables">location: anObject	"The change affects a single element identified by a key which is not an integer."	indexes := anObject</body></methods><methods><class-id>Core.ContentsChangeAnnouncement</class-id> <category>accessing</category><body package="Model-Observables">indexes	"Answer the indexes affected by the change."	^indexes</body><body package="Model-Observables">location	"Answer the location affected by the change. This is intended for collections where	the location is identified by an arbitrary key (such as point coordinates in a 2D list)."	^indexes</body></methods><methods><class-id>Core.ElementsTransposed</class-id> <category>accessing</category><body package="Model-Observables">transposed	^transposed</body><body package="Model-Observables">transposed: anObject	transposed := anObject</body></methods><methods><class-id>Core.ValueChangeAnnouncement</class-id> <category>accessing</category><body package="Model-Observables">newValue	^newValue</body><body package="Model-Observables">newValue: anObject	newValue := anObject</body><body package="Model-Observables">oldValue	^oldValue</body><body package="Model-Observables">oldValue: anObject	oldValue := anObject</body></methods><methods><class-id>Core.ValueChangeAnnouncement class</class-id> <category>instance creation</category><body package="Model-Observables">from: anObject to: anotherObject	^self new		oldValue: anObject;		newValue: anotherObject</body><body package="Model-Observables">newValue: anObject oldValue: anotherObject	^self new		newValue: anObject;		oldValue: anotherObject</body></methods><methods><class-id>Core.ObservedTwoDList</class-id> <category>accessing</category><body package="Model-Observables">at: anIntegerOrPoint	^anIntegerOrPoint indexAccessInto: self</body><body package="Model-Observables">at: anIntegerOrPoint put: anElement	^anIntegerOrPoint indexAccessInto: self put: anElement</body><body package="Model-Observables">atInteger: anInteger	^collection at: anInteger</body><body package="Model-Observables">atInteger: anInteger put: anObject	| oldValue |		(self announce: ValueAboutToChange) isVetoed ifTrue: [^nil].	self announce: ValueChanging.	oldValue := collection at: anInteger.	collection at: anInteger put: anObject.	self announce: (ElementsReplaced new 		location: (self pointIndexFor: anInteger);		elements: (Array with: oldValue)).	self announce: ValueChanged.	^anObject</body><body package="Model-Observables">atPoint: aPoint 	^self atInteger: (self integerIndexFor: (self isTransposed ifTrue: [aPoint transpose] ifFalse: [aPoint]))</body><body package="Model-Observables">atPoint: aPoint put: anObject 	^self 		atInteger: (self integerIndexFor: (self isTransposed ifTrue: [aPoint transpose] ifFalse: [aPoint])) 		put: anObject</body><body package="Model-Observables">columnSize	^self isTransposed ifTrue: [rows] ifFalse: [columns]</body><body package="Model-Observables">dimensions	^self isTransposed ifTrue: [rows @ columns] ifFalse: [columns @ rows]</body><body package="Model-Observables">rowSize	^self isTransposed ifTrue: [columns] ifFalse: [rows]</body><body package="Model-Observables">size	^collection size</body><body package="Model-Observables">subscriptionRegistryOrNil	^subscriptionRegistry</body><body package="Model-Observables">transpose	self transposed: self isTransposed not</body><body package="Model-Observables">transposed: aBoolean 	aBoolean == self isTransposed ifTrue: [^self].	transposed := aBoolean.	self announce: (ElementsTransposed new transposed: aBoolean)</body></methods><methods><class-id>Core.ObservedTwoDList</class-id> <category>enumerating</category><body package="Model-Observables">collectRows: aBlock	| newCollection start |	newCollection := self species withSize: self rowSize.	start := 1.	1 to: self rowSize do: 		[:index |		newCollection at: index put: (aBlock value: (self copyFrom: start to: start + self columnSize - 1)).		start := start + self columnSize].	^newCollection</body></methods><methods><class-id>Core.ObservedTwoDList</class-id> <category>private</category><body package="Model-Observables">defaultElement	^collection defaultElement</body><body package="Model-Observables">executeWithoutEvents: aBlock	self subscriptionRegistry allSubscriptions suspendWhile: aBlock</body><body package="Model-Observables">integerIndexFor: aPoint 	^columns * (aPoint y - 1) + aPoint x</body><body package="Model-Observables">pointIndexFor: anInteger 	| base |	base := (anInteger - 1) // columns.	^(anInteger - (base * columns)) @ (base + 1)</body><body package="Model-Observables">setCollection: aCollection columns: columnsInteger rows: rowsInteger	collection := aCollection.	rows := rowsInteger.	columns := columnsInteger</body><body package="Model-Observables">species	^ObservedList</body><body package="Model-Observables">subscriptionRegistry: aSubscriptionRegistry	subscriptionRegistry := aSubscriptionRegistry</body></methods><methods><class-id>Core.ObservedTwoDList</class-id> <category>testing</category><body package="Model-Observables">isObservedTwoDList	^true</body><body package="Model-Observables">isTransposed	^transposed isNil ifTrue: [transposed := false] ifFalse: [transposed]</body></methods><methods><class-id>Core.ObservedTwoDList</class-id> <category>copying</category><body package="Model-Observables">postCopy	subscriptionRegistry := nil.	collection := collection copy</body></methods><methods><class-id>Core.ObservedTwoDList</class-id> <category>sorting</category><body package="Model-Observables">sort	| sortCollection |	(self announce: ValueAboutToChange) isVetoed ifTrue: [^nil].	self announce: ValueChanging.	sortCollection := self collectRows: [:each | each].	self executeWithoutEvents: 		[ | start |		SequenceableCollectionSorter 			sort: sortCollection 			using: [:each :other | each first displayString &lt; other first displayString].		collection := Array new: rows * columns.		start := 1.		sortCollection do: 			[:eachArray |			eachArray do: 				[:eachValue |				collection at: start put: eachValue.				start := start + 1]]].	self announce: ValueChanged.	self announce: ElementsReordered</body><body package="Model-Observables">sortWith: aBlock	| sortCollection |	(self announce: ValueAboutToChange) isVetoed ifTrue: [^nil].	self announce: ValueChanging.	sortCollection := self collectRows: [:each | each].	self executeWithoutEvents: 		[ | start |		SequenceableCollectionSorter 			sort: sortCollection 			using: aBlock.		collection := Array new: rows * columns.		start := 1.		sortCollection do: 			[:eachArray |			eachArray do: 				[:eachValue |				collection at: start put: eachValue.				start := start + 1]]].	self announce: ValueChanged.	self announce: ElementsReordered</body></methods><methods><class-id>Core.ObservedTwoDList</class-id> <category>initialize-release</category><body package="Model-Observables">release	collection := nil.	subscriptionRegistry release.	subscriptionRegistry := nil.	super release</body></methods><methods><class-id>Core.ObservedTwoDList class</class-id> <category>instance creation</category><body package="Model-Observables">columns: columnsInteger rows: rowsInteger 	| collection instance |	collection := Array new: rowsInteger * columnsInteger.	instance := self basicNew.	^instance 		setCollection: collection		columns: columnsInteger		rows: rowsInteger</body><body package="Model-Observables">on: aCollection columns: columnsInteger 	^self 		on: aCollection		columns: columnsInteger		rows: (aCollection size asFloat / columnsInteger) ceiling</body><body package="Model-Observables">on: aCollection columns: columnsInteger rows: rowsInteger 	| collection instance arraySize columnSize |	arraySize := columnsInteger * rowsInteger.	columnSize := aCollection size.	instance := self basicNew.	arraySize = columnSize ifTrue: 		[^instance 			setCollection: aCollection			columns: columnsInteger			rows: rowsInteger].	collection := aCollection species new: rowsInteger * columnsInteger.	collection 		replaceFrom: 1		to: (arraySize min: columnSize)		with: aCollection		startingAt: 1.	instance := self basicNew.	^instance 		setCollection: collection		columns: columnsInteger		rows: rowsInteger</body><body package="Model-Observables">on: aCollection rows: rowsInteger 	^self 		on: aCollection		columns: (aCollection size asFloat / rowsInteger) floor		rows: rowsInteger</body><body package="Model-Observables">on: aCollection rows: rowsInteger columns: columnsInteger	^self on: aCollection columns: columnsInteger rows: rowsInteger</body><body package="Model-Observables">rows: rowsInteger columns: columnsInteger	| collection instance |	collection := Array new: rowsInteger * columnsInteger.	instance := self basicNew.	^instance 		setCollection: collection		columns: columnsInteger		rows: rowsInteger</body></methods><methods><class-id>Core.ValueAboutToChange</class-id> <category>vetoing</category><body package="Model-Observables">isVetoed	^vetoed notNil</body><body package="Model-Observables">veto	vetoed := true</body></methods><methods><class-id>Core.AccessAdaptor</class-id> <category>accessing</category><body package="Model-Observables">accessPath	^accessPath</body><body package="Model-Observables">accessPath: nilOrACollectionOfSymbolAndOrInteger	accessPath := nilOrACollectionOfSymbolAndOrInteger</body><body package="Model-Observables">accessor	^accessor</body><body package="Model-Observables">accessor: aUnarySymbolOrIntegerOrOneArgBlock	accessor := aUnarySymbolOrIntegerOrOneArgBlock.	(accessor notNil and: [modelAnnouncesUpdate and: [modelUpdateAnnouncement isNil]])		ifTrue: [self setUpdateForModel]</body><body package="Model-Observables">model	^model</body><body package="Model-Observables">model: anObjectOrObservedValue 		privateModelValue ifNotNil: [privateModelValue removeAllActionsWithReceiver: self].	model := anObjectOrObservedValue isObservedValue 		ifTrue: [self setPrivateModelValue: anObjectOrObservedValue]		ifFalse: [anObjectOrObservedValue].	modelAnnouncesUpdate ifTrue: [self setUpdateForModel].	self announce: ModelUpdated</body><body package="Model-Observables">modelAnnouncesUpdate	^modelAnnouncesUpdate</body><body package="Model-Observables">modelAnnouncesUpdate: aBoolean 	modelAnnouncesUpdate = aBoolean ifTrue: [^self].	modelAnnouncesUpdate := aBoolean.	modelAnnouncesUpdate 		ifTrue: [self setUpdateForModel] 		ifFalse: [self removeUpdateForModel]</body><body package="Model-Observables">modelUpdateAnnouncement	^modelUpdateAnnouncement</body><body package="Model-Observables">modelUpdateAnnouncement: announcementClassOrSetOrNil 	| rehookup |	modelUpdateAnnouncement = announcementClassOrSetOrNil ifTrue: [^self].	self removeUpdateForModel.	rehookup := modelUpdateAnnouncement ~= announcementClassOrSetOrNil and: [announcementClassOrSetOrNil notNil].	modelUpdateAnnouncement := announcementClassOrSetOrNil.	modelUpdateAnnouncement notNil ifTrue: [modelAnnouncesUpdate := true].	rehookup ifTrue: [self setUpdateForModel]</body><body package="Model-Observables">mutator	mutator ifNil: [self accessor isSymbol ifTrue: [^(self accessor, ':') asSymbol]].	^mutator</body><body package="Model-Observables">mutator: aKeywordSymbolOrIntegerOrOneArgBlockOrNil	mutator := aKeywordSymbolOrIntegerOrOneArgBlockOrNil</body><body package="Model-Observables">value	accessPath isNil ifTrue: [^self accessorValueFor: model].	^self accessorValueFor: self finalAccessPathValue.</body><body package="Model-Observables">value: anObject	| originalValue |	originalValue := self value.	(self announce: (ValueAboutToChange from: originalValue to: anObject)) isVetoed		ifTrue: [^self].	self		announce: (ValueChanging from: originalValue to: anObject);		setObjectFrom: anObject;		announce: (ValueChanged from: originalValue to: anObject)</body></methods><methods><class-id>Core.AccessAdaptor</class-id> <category>private</category><body package="Model-Observables">accessorValueFor: anObject	^self valueFor: anObject using: self accessor</body><body package="Model-Observables">execute: executor on: target with: anObject 	"If the mutator is a Block, we assume that the block will mutate the model in some way. 	We never directly assign to the model"	(executor isKindOf: BlockClosure) ifTrue: 		[^executor value: target value: anObject].	(executor isNil and: [target isObservedValue]) ifTrue: 		[^target value: anObject].	executor isSymbol 		ifTrue: [target perform: executor with: anObject] 		ifFalse: [target at: executor put: anObject]</body><body package="Model-Observables">finalAccessPathValue	^accessPath inject: model into: 		[:sum :each | 		self valueFor: sum using: each].</body><body package="Model-Observables">modelChanged	model := privateModelValue value.	self announce: ModelUpdated</body><body package="Model-Observables">modelUpdated	self announce: ModelUpdated</body><body package="Model-Observables">removeUpdateForModel	model unsubscribe: self</body><body package="Model-Observables">setModelTo: anObject 	^self 		execute: self mutator		on: (privateModelValue isObservedValue 			ifTrue: [privateModelValue] 			ifFalse: [model])		with: anObject</body><body package="Model-Observables">setObjectFrom: anObject 	"Do nothing if the model is nil AND the privateModelValue is not an ObservedValue"	(model isNil and: [privateModelValue isObservedValue not]) ifTrue: [^nil].	accessPath isNil		ifTrue: [self setModelTo: anObject]		ifFalse: [self execute: self mutator on: self finalAccessPathValue with: anObject]</body><body package="Model-Observables">setPrivateModelValue: anObjectOrValueEventAnswering	privateModelValue := anObjectOrValueEventAnswering.	privateModelValue 		when: ValueChanged		send: #modelChanged		to: self.	^privateModelValue value</body><body package="Model-Observables">setUpdateForModel	self modelUpdateAnnouncement ifNotNil: 		[:announcementClass | model ifNotNil: 			[model when: announcementClass send: #modelUpdated to: self]]</body><body package="Model-Observables">setValue: anObject	self setObjectFrom: anObject</body><body package="Model-Observables">valueFor: anObject using: aParameter 	"By the time we get here, if anObject came from our model, then if the model was a value event, it is now the inner value"	anObject isNil ifTrue: [^nil].	(aParameter isKindOf: BlockClosure) ifTrue: [^aParameter value: anObject].	(aParameter isNil and: [privateModelValue isObservedValue]) ifTrue: 		[^privateModelValue value].	^aParameter isSymbol ifTrue: [anObject perform: aParameter] ifFalse: [anObject at: aParameter]</body></methods><methods><class-id>Core.AccessAdaptor</class-id> <category>testing</category><body package="Model-Observables">isAccessAdaptor	^true</body><body package="Model-Observables">isObservedValue	^true</body></methods><methods><class-id>Core.AccessAdaptor</class-id> <category>initialize-release</category><body package="Model-Observables">initialize	super initialize.	modelAnnouncesUpdate := false</body></methods><methods><class-id>Core.AccessAdaptor class</class-id> <category>instance creation</category><body package="Model-Observables">with: anIntialValue	^self new model: anIntialValue</body><body package="Model-Observables">with: anObject accessor: anAccessingEvaluable	^self with: anObject updateAnnouncement: nil accessor: anAccessingEvaluable mutator: nil</body><body package="Model-Observables">with: anObject accessor: anAccessingEvaluable mutator: aMutatingEvaluable	^self with: anObject updateAnnouncement: nil accessor: anAccessingEvaluable mutator: aMutatingEvaluable</body><body package="Model-Observables">with: anObject mutator: aMutatingEvaluable	^self with: anObject updateAnnouncement: nil accessor: nil mutator: aMutatingEvaluable</body><body package="Model-Observables">with: anObject updateAnnouncement: aClass	^self with: anObject updateAnnouncement: aClass accessor: nil mutator: nil</body><body package="Model-Observables">with: anObject updateAnnouncement: aClass accessor: anAccessingEvaluable	^self with: anObject updateAnnouncement: aClass accessor: anAccessingEvaluable mutator: nil</body><body package="Model-Observables">with: anObject updateAnnouncement: aClass accessor: anAccessingEvaluable mutator: aMutatingEvaluable	| instance |	instance := self with: anObject.	instance modelUpdateAnnouncement: aClass.	instance accessor: anAccessingEvaluable.	instance mutator: aMutatingEvaluable.	^instance</body><body package="Model-Observables">with: anObject updateAnnouncement: aClass  mutator: aMutatingEvaluable	^self with: anObject updateAnnouncement: aClass accessor: nil mutator: aMutatingEvaluable</body></methods><methods><class-id>Core.ObservedList</class-id> <category>adding</category><body package="Model-Observables">add: anObject	"Include newObject as one of the receiver's elements.  Answer newObject."	^self addLast: anObject</body><body package="Model-Observables">add: newObject after: oldObject 	"Add the argument, newObject, as an element of the receiver.  Put it	in the position just succeeding oldObject.  Answer newObject."		| index |	index := self findIndexOf: oldObject.	self add: newObject beforeIndex: index + 1.	^newObject</body><body package="Model-Observables">add: newObject before: oldObject 	"Add the argument, newObject, as an element of the receiver.  Put it	in the position just preceding oldObject.  Answer newObject."		| index |	index := self findIndexOf: oldObject.	self add: newObject beforeIndex: index.	^newObject</body><body package="Model-Observables">add: anObject beforeIndex: anIndex 	"Add the argument, newObject, as an element of the receiver.  Put it	in the position just preceding the indexed position spot.  Answer anObject."	anIndex &lt;= limit 		ifTrue: [self privateInsertObject: anObject beforeIndex: anIndex]		ifFalse: 			[anIndex = (limit + 1) 				ifTrue: [self addLast: anObject]				ifFalse: 					[^self 						subscriptBoundsErrorFor: #add:beforIndex:						index: anIndex						value: anObject]].	^anObject</body><body package="Model-Observables">addAll: aCollection 	"Add each element of aCollection at the end of the instance. Answer 	aCollection."	^self addAllLast: aCollection</body><body package="Model-Observables">addAll: aCollection after: oldObject 	"Add the argument, aCollection, as elements of the receiver.   Put it	in the position just succeeding oldObject.  Answer newObject."		| index |	index := self findIndexOf: oldObject.	self addAll: aCollection beforeIndex: index + 1.	^aCollection</body><body package="Model-Observables">addAll: aCollection before: oldObject 	"Add the argument, aCollection, as elements of the receiver.   Put it	in the position just preceding oldObject.  Answer newObject."		| index |	index := self findIndexOf: oldObject.	self addAll: aCollection beforeIndex: index.	^aCollection</body><body package="Model-Observables">addAll: aCollection beforeIndex: anIndex 	"Add the argument, aCollection, as elements of the receiver.  Put them	in the position just preceding the indexed position spot.  Answer aCollection."	self insertCollection: aCollection before: anIndex.	^aCollection</body><body package="Model-Observables">addAllFirst: aCollection 	"Add each element of aCollection at the beginning of the 	receiver.	Answer aCollection."	^self addAll: aCollection beforeIndex: 1</body><body package="Model-Observables">addAllLast: aCollection 	"Add each element of aCollection at the end of the receiver.  Answer aCollection."	| newCollectionSize |	(self announce: ValueAboutToChange) isVetoed		ifTrue: [^nil].	self announce: ValueChanging.	newCollectionSize := aCollection size.	limit + newCollectionSize &gt; collectionSize ifTrue: [self growCollectionBy: (self growSize max: newCollectionSize)].	self 		moveElementsFrom: aCollection		ofSize: newCollectionSize		toMyCollectionStartingAt: limit + 1.	limit := limit + newCollectionSize.	self announce: (ElementsInserted new from: self size - aCollection size + 1 to: self size).	self announce: ValueChanged.	^aCollection</body><body package="Model-Observables">addFirst: anObject 	"Add anObject to the beginning of the receiver.  Add anObject."	^self add: anObject beforeIndex: 1</body><body package="Model-Observables">addLast: anObject 	"Add newObject to the end of the receiver.  Answer newObject."	limit = collectionSize ifTrue: [self growCollection].	^self privateAddLast: anObject</body><body package="Model-Observables">changeSizeTo: newSize 	"The receiver changes its size to newSize."	| newCollection |	newSize &lt; 0 ifTrue: 		[self error: #errNeedPositiveIntegerArg &lt;&lt; #dialogs &gt;&gt; 'This message needs a positive integer argument'].	collectionSize &gt;= newSize ifTrue: 		[newSize + 1 to: limit do: 			[:index | 			collection at: index put: nil].		limit := newSize.		^self].	newCollection := self biggerCollectionWithAtLeast: newSize.	newCollection 		replaceFrom: 1		to: self size		with: collection		startingAt: 1.	collection := newCollection.	collectionSize := collection size.	limit := newSize</body></methods><methods><class-id>Core.ObservedList</class-id> <category>accessing</category><body package="Model-Observables">after: anObject 	"Answer the element after anObject.  If the receiver does not contain 	anObject or if the receiver contains no elements after anObject, 	provide an error notification."	| index |	index := self findIndexOf: anObject.	^index = limit		ifTrue: [self lastObjectError]		ifFalse: [self privateAt: index + 1]</body><body package="Model-Observables">at: anIndex 	"Answer the element at index anIndex."	^anIndex &gt; limit 		ifTrue: [self errorSubscriptBounds: anIndex]		ifFalse: [self privateAt: anIndex]</body><body package="Model-Observables">at: anIndex put: anObject 	"Put anObject at element anIndex."	^anIndex &lt;= limit 		ifTrue: [self privateAt: anIndex put: anObject]		ifFalse: 			[anIndex = (limit + 1) 				ifTrue: [self addLast: anObject]				ifFalse: [self errorSubscriptBounds: anIndex]]</body><body package="Model-Observables">before: anObject 	"Answer the element before anObject.  If the receiver does not  	contain anObject or if the receiver contains no elements before 	anObject, provide an error notification."	| index |	index := self findIndexOf: anObject.	^index = 1		ifTrue: [self firstObjectError]		ifFalse: [self privateAt: index - 1]</body><body package="Model-Observables">capacity	^collectionSize</body><body package="Model-Observables">first	"Answer the first element.  If the receiver is empty, provide an error notification."	limit = 0 ifTrue: [^self emptyCollectionError].	^self privateAt: 1</body><body package="Model-Observables">indexOf: anElement ifAbsent: exceptionBlock 	"Answer the index of anElement within the receiver.  If the receiver does	not contain anElement, answer the result of evaluating the exceptionBlock."	^self privateIndexOf: anElement ifAbsent: exceptionBlock</body><body package="Model-Observables">last	"Answer the last element.  If the receiver is empty, create an error notification."	limit = 0 ifTrue: [^self emptyCollectionError].	^self privateAt: limit</body><body package="Model-Observables">replaceAllWith: aCollection	(self subscriptionRegistry subscriptionsFor: ValueChanged)		suspendWhile: [self removeFrom: 1 to: self size].	^(self subscriptionRegistry subscriptionsFor: ValueAboutToChange, ValueChanging) 		suspendWhile: [self addAll: aCollection].</body><body package="Model-Observables">replaceFrom: start to: stop with: replacement startingAt: repStart 	"This destructively replaces elements from start to stop in the 	receiver starting at index, repStart, in the collection, replacement. 	Answer the receiver."	| oldElements |	start &gt; (limit + 1) ifTrue: [^self errorSubscriptBounds: start].	^stop &lt;= limit 		ifTrue: 			[(self announce: ValueAboutToChange) isVetoed				ifTrue: [^nil].			self announce: ValueChanging.			oldElements := collection copyFrom: start to: stop.			collection 				replaceFrom: start				to: stop				with: replacement				startingAt: repStart.			self announce: (ElementsReplaced new 				from: start to: stop;				elements: oldElements).			self announce: ValueChanged.			self]		ifFalse: [self errorSubscriptBounds: stop]</body><body package="Model-Observables">size	"Answer how many elements the receiver contains."	^limit</body><body package="Model-Observables">zeroIndex	^0</body></methods><methods><class-id>Core.ObservedList</class-id> <category>converting</category><body package="Model-Observables">asObservedList	"I am myself"	^self</body></methods><methods><class-id>Core.ObservedList</class-id> <category>private</category><body package="Model-Observables">biggerCollectionWithAtLeast: anAmount	"Answer a collection for the receiver with at least anAmount room for storage."	 ^collection species new: (collectionSize + self growSize max: anAmount)</body><body package="Model-Observables">changeCapacityTo: aSize	"Make the receiver's collection be larger by aSize."	| newCollection |	aSize &lt; self size ifTrue: [self error: (#errSmallSizeError &lt;&lt; #dialogs &gt;&gt; 'I can''t shrink that small')].	newCollection := collection species new: aSize.	newCollection replaceFrom: 1 to: limit with: collection startingAt: 1.	collection := newCollection.	collectionSize := newCollection size</body><body package="Model-Observables">executeWithoutEvents: aBlock	self subscriptionRegistry allSubscriptions		suspendWhile: aBlock</body><body package="Model-Observables">findIndexOf: anObject 	"Answer the index of an anObject in the receiver's collection."	^self privateIndexOf: anObject ifAbsent: [self notFoundError]</body><body package="Model-Observables">growCollection	"Make the receiver's collection be larger."	self growCollectionBy: self growSize</body><body package="Model-Observables">growCollectionBy: anInteger	"Make the receiver's collection be larger by anInteger."	self changeCapacityTo: self capacity+anInteger</body><body package="Model-Observables">growSize	"Answer a size by which to grow the receiver's collection."	^collection growSize</body><body package="Model-Observables">insertCollection: aCollection before: anIndex 	"Insert aCollection before anIndex in the receiver's collection."		^anIndex &lt;= limit 		ifTrue: 			[| newCollectionSize |			(self announce: ValueAboutToChange) isVetoed				ifTrue: [^nil].			self announce: ValueChanging.			newCollectionSize := aCollection size.			self 				moveDown: newCollectionSize				fromIndex: anIndex.			self 				moveElementsFrom: aCollection				ofSize: newCollectionSize				toMyCollectionStartingAt: anIndex.			limit := limit + newCollectionSize.			self announce: (ElementsInserted new from: anIndex to: anIndex + aCollection size - 1).			self announce: ValueChanged]		ifFalse: 			[anIndex = (limit + 1) 				ifTrue: [self addAllLast: aCollection]				ifFalse: 					[self 						subscriptBoundsErrorFor: #insertCollection:before:						index: anIndex						value: aCollection]]</body><body package="Model-Observables">setCollection: anArray limit: aSmallInteger	"Set the receiver's collection to be anArray with initial limit of aSmallInteger."	collection := anArray.	limit := aSmallInteger.	collectionSize := collection size</body><body package="Model-Observables">trim	"Discard the extra slots that the collection was reserving for	future growth room."	self changeCapacityTo: self size</body></methods><methods><class-id>Core.ObservedList</class-id> <category>enumerating</category><body package="Model-Observables">do: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument."	1 to: limit do: 		[:index | 		aBlock value: (self privateAt: index)]</body><body package="Model-Observables">reverseDo: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument, starting	with the last element and taking each in sequence up to the first."	"Override the superclass for performance"	limit to: 1 by: -1 do: 		[:index | 		aBlock value: (self privateAt: index)]</body><body package="Model-Observables">select: aBlock 	"Evaluate aBlock with each of my elements as the argument.  Collect into a new 	collection like the receiver, only those elements for which aBlock evaluates to true."	| newCollection |	newCollection := self species new.	1 to: limit do: 		[:index | | element |		element := self at: index.		(aBlock value: element) ifTrue: [newCollection addLast: element]].	^newCollection</body></methods><methods><class-id>Core.ObservedList</class-id> <category>private-errors</category><body package="Model-Observables">errorSubscriptBounds: anIndex	self error: (#errAttemptedNonExistentElement &lt;&lt; #dialogs &gt;&gt; 'attempt to index non-existent element')</body><body package="Model-Observables">firstObjectError	self error: (#errFirstObject &lt;&lt; #dialogs &gt;&gt; 'specified object is first object')</body><body package="Model-Observables">lastObjectError	self error: (#errLastObject &lt;&lt; #dialogs &gt;&gt; 'specified object is last object')</body><body package="Model-Observables">notEnoughElementsError	self error: (#errRemovedTooManyCollection &lt;&lt; 		#dialogs &gt;&gt; 'attempt to remove more elements than are in the collection')</body></methods><methods><class-id>Core.ObservedList</class-id> <category>testing</category><body package="Model-Observables">isTextEmphasis	self class == ObservedList ifFalse: [^false].	^self allSatisfy: [:each | each isSymbol or: [each isAssociation]]</body></methods><methods><class-id>Core.ObservedList</class-id> <category>private-collection accessing</category><body package="Model-Observables">moveDown: anAmount fromIndex: anIndex 	"Move elements in collection down by anAmount starting at anIndex."	limit + anAmount &gt; collectionSize		ifTrue: [| newCollection |				newCollection := self biggerCollectionWithAtLeast: limit + anAmount.				newCollection					replaceFrom: 1					to: anIndex -1					with: collection					startingAt: 1.				newCollection					replaceFrom: anIndex + anAmount					to: limit+ anAmount					with: collection					startingAt: anIndex.				collection := newCollection.				collectionSize := collection size]		ifFalse: [collection					replaceFrom: anIndex + anAmount					to: limit + anAmount					with: collection					startingAt: anIndex].</body><body package="Model-Observables">moveElementsFrom: aCollection ofSize: cSize toMyCollectionStartingAt: anIndex	"Move the elements from aCollection into the receivers collection starting at anIndex."	aCollection isSequenceable		ifTrue: [collection					replaceFrom: anIndex					to: anIndex + cSize - 1					with: aCollection					startingAt: 1]		ifFalse: [| index |				index := anIndex.				aCollection do:					[:element |					collection at: index put: element.					index := index + 1]].</body><body package="Model-Observables">privateAddLast: anObject	"Add anObject to the valid end of the receiver's collection."	(self announce: ValueAboutToChange) isVetoed		ifTrue: [^nil].	self announce: ValueChanging.	limit := limit + 1.	collection at: limit put: anObject.	self announce: (ElementsInserted new index: limit).	self announce: ValueChanged.	^anObject</body><body package="Model-Observables">privateAt: anIndex	"Answer the object stored at anIndex in collection."	^collection at: anIndex</body><body package="Model-Observables">privateAt: anInteger put: anObject	"Store anObject into an index in collection."	| oldValue |	(self announce: ValueAboutToChange) isVetoed		ifTrue: [^nil].	self announce: ValueChanging.	oldValue := collection at: anInteger.	collection at: anInteger put: anObject.	self announce: (ElementsReplaced new		index: anInteger;		elements: (Array with: oldValue)).	self announce: ValueChanged.	^anObject</body><body package="Model-Observables">privateIndexOf: anElement ifAbsent: exceptionBlock 	"Answer the index of anElement within the receiver.  If the receiver does	not contain anElement, answer the result of evaluating the exceptionBlock."	1 to: limit do: [:index | (collection at: index) = anElement ifTrue: [^index]].	^exceptionBlock value</body><body package="Model-Observables">privateInsertObject: anObject beforeIndex: anIndex 	"Insert anObject in collection before index anIndex."	(self announce: ValueAboutToChange) isVetoed		ifTrue: [^nil].	self announce: ValueChanging.	self moveDown: 1 fromIndex: anIndex.	collection at: anIndex put: anObject.	limit := limit + 1.	self announce: (ElementsInserted new index: anIndex).	self announce: ValueChanged.</body><body package="Model-Observables">privateRemoveIndex: anIndex 	"Remove the element of the collection at position anIndex."	| object |	(self announce: ValueAboutToChange) isVetoed ifTrue: [^nil].	self announce: ValueChanging.	object := collection at: anIndex.	collection replaceFrom: anIndex to: limit - 1 with: collection startingAt: anIndex + 1.	collection at: limit put: self defaultElement.	limit := limit - 1.	self announce: 		(ElementsRemoved new 			index: anIndex;			elements: (Array with: object)).	self announce: ValueChanged.	^object</body><body package="Model-Observables">privateRemoveIndex: start to: stop returnElements: returnBoolean 	"Remove the elements in the range start to stop within collection.	Answer a collection of the removed elements if returnBoolean is true."	| removedElements numElements newLimit default |	(self announce: ValueAboutToChange) isVetoed		ifTrue: [^nil].	self announce: ValueChanging.	numElements := stop - start + 1.	removedElements := Array new: numElements.	removedElements replaceFrom: 1 to: numElements with: collection startingAt: start.	newLimit := limit - numElements.	collection replaceFrom: start to: newLimit with: collection startingAt: stop + 1.	default := self defaultElement.	newLimit + 1 to: limit do: 		[:index | 		collection at: index put: default].	limit := newLimit.	self announce: 		(ElementsRemoved new 			from: start to: stop; 			elements: removedElements).	self announce: ValueChanged.	^returnBoolean ifTrue: [removedElements] ifFalse: [nil]</body></methods><methods><class-id>Core.ObservedList</class-id> <category>removing</category><body package="Model-Observables">remove: oldObject ifAbsent: anExceptionBlock  	"Remove oldObject as one of the receiver's elements.  If several of the	elements are equal to oldObject, only one is removed. If no element is equal to	oldObject, answer the result of evaluating anExceptionBlock.  Otherwise,	answer the argument, oldObject."	| index |	index := self indexOf: oldObject ifAbsent: [^anExceptionBlock value].	^self removeAtIndex: index</body><body package="Model-Observables">removeAllSuchThat: aBlock 	"Evaluate aBlock for each element of the receiver. Remove each element for 	which aBlock evaluates to true. "	| newCollection element index |	newCollection := self class new.	index := 1.	[index &lt;= limit]		whileTrue: 			[element := self privateAt: index.			(aBlock value: element)				ifTrue: 					[newCollection addLast: element.					self privateRemoveIndex: index]				ifFalse: [index := index + 1]].	^newCollection</body><body package="Model-Observables">removeAtIndex: anIndex 	"Remove the element of the collection at position anIndex. Answer 	the object removed."	^anIndex &gt; limit		ifTrue: [self errorSubscriptBounds: anIndex]		ifFalse: [self privateRemoveIndex: anIndex]</body><body package="Model-Observables">removeFirst	"Remove the first element of the receiver.  If the receiver is empty, 	provide an error notification."		^self removeAtIndex: 1</body><body package="Model-Observables">removeFirst: numElements	"Remove the first numElements elements of the receiver,	and answer an Array of them.  If the receiver has fewer	than numElements elements, create an error	notification."	numElements &gt; limit ifTrue: [^self notEnoughElementsError].	^self privateRemoveIndex: 1 to: numElements returnElements: true</body><body package="Model-Observables">removeFrom: start to: stop	"Remove the elements in the range start to stop.	Answer a collection of the removed elements."	^self removeFrom: start to: stop returnElements: true</body><body package="Model-Observables">removeFrom: start to: stop returnElements: returnBoolean 	"Remove the elements in the range start to stop.	Answer a collection of the removed elements if returnBoolean is true."	start &gt; stop ifTrue: 		[^returnBoolean 			ifTrue: [Array new]			ifFalse: [nil]].	start &gt; limit ifTrue: [^self errorSubscriptBounds: start].	stop &gt; limit ifTrue: [^self errorSubscriptBounds: stop].	^self 		privateRemoveIndex: start		to: stop		returnElements: returnBoolean</body><body package="Model-Observables">removeLast	"Remove the last element of the receiver.  If the receiver is empty, 	provide an error notification."		^self removeAtIndex: limit</body><body package="Model-Observables">removeLast: numElements	"Remove the last numElements elements of the receiver,	and answer an Array of them.  If the receiver has fewer	than numElements elements, create an error notification."	numElements &gt; limit ifTrue: [^self notEnoughElementsError].	^self privateRemoveIndex: limit - numElements + 1 to: limit returnElements: true</body></methods><methods><class-id>Core.ObservedList</class-id> <category>announcements</category><body package="Model-Observables">subscriptionRegistry: aSubscriptionRegistry	subscriptionRegistry := aSubscriptionRegistry</body><body package="Model-Observables">subscriptionRegistryOrNil	^subscriptionRegistry</body></methods><methods><class-id>Core.ObservedList</class-id> <category>copying</category><body package="Model-Observables">postCopy	subscriptionRegistry := nil.	collection :=  collection copy.</body></methods><methods><class-id>Core.ObservedList</class-id> <category>sorting</category><body package="Model-Observables">sort	(self announce: ValueAboutToChange) isVetoed ifTrue: [^nil].	self announce: ValueChanging.	self subscriptionRegistry allSubscriptions		suspendWhile: [SequenceableCollectionSorter sort: self].	self announce: ValueChanged.	self announce: ElementsReordered</body><body package="Model-Observables">sortWith: aBlock	(self announce: ValueAboutToChange) isVetoed ifTrue: [^nil].	self announce: ValueChanging.	self subscriptionRegistry allSubscriptions		suspendWhile: [SequenceableCollectionSorter sort: self using: aBlock].	self announce: ValueChanged.	self announce: ElementsReordered</body></methods><methods><class-id>Core.ObservedList</class-id> <category>initialize-release</category><body package="Model-Observables">release	collection := nil.	subscriptionRegistry release.	subscriptionRegistry := nil.	super release</body></methods><methods><class-id>Core.ObservedList class</class-id> <category>testing</category><body package="Model-Observables">needsSafeRebinding	^true</body></methods><methods><class-id>Core.ObservedList class</class-id> <category>instance creation</category><body package="Model-Observables">new	"Answer a new empty instance of the receiver."	^self new: 5</body><body package="Model-Observables">new: sizeInteger 	"Answer a new empty instance of the receiver. The size is 	determined by the actual number of stored elements. Creating an 	instance using new: results in an empty collection, regardless of the 	size declared."	^self basicNew setCollection: (Array new: sizeInteger) limit: 0</body><body package="Model-Observables">new: size withAll: value 	"Answer a new instance of the receiver whose every element is 	equal to the argument, value."		^self new setCollection: (Array new: size withAll: value ) limit: size</body><body package="Model-Observables">withSize: size 	"Override, because this class distinguishes between size and capacity."	^(self new: size) changeSizeTo: size</body></methods><methods><class-id>Core.ElementsReplaced</class-id> <category>accessing</category><body package="Model-Observables">elements	^elements</body><body package="Model-Observables">elements: anObject	elements := anObject</body></methods><methods><class-id>Core.CopiedBufferedValue</class-id> <category>commands</category><body package="Model-Observables">commit	model value: value</body><body package="Model-Observables">reset	value := model value copy</body></methods><methods><class-id>Core.CopiedBufferedValue</class-id> <category>accessing</category><body package="Model-Observables">model: anObservedValue	model := anObservedValue.	value := model value copy</body></methods><methods><class-id>Core.ElementsRemoved</class-id> <category>initialize-release</category><body package="Model-Observables">elements: aCollection	elements := aCollection</body></methods><methods><class-id>Core.ElementsRemoved</class-id> <category>accessing</category><body package="Model-Observables">elements	^elements</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Model-Observables">asObservedValue	^ObservedValue with: self</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Model-Observables">isAccessAdaptor	^false</body><body package="Model-Observables">isBufferedValue	^false</body><body package="Model-Observables">isObservedTwoDList	^false</body><body package="Model-Observables">isObservedValue	^false</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Announcer</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subscriptionRegistry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Model-Observables</category><attributes><package>System-Announcements</package></attributes></class><class><name>Announcement</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Announcements</category><attributes><package>System-Announcements</package></attributes></class><class><name>ArrayedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class></st-source>