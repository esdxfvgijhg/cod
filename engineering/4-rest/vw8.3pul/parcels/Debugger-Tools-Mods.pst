<?xml version="1.0"?><st-source><!-- Name: Debugger-Tools-ModificationsNotice: Copyright 2003-2014 Cincom Systems, Inc.  All rights reserved.Comment: PDP tool modifications for VW 7DbIdentifier: bear73DbTrace: 422398DbUsername: smichaelDbVersion: 8.0 - 1DevelopmentPrerequisites: #(#(#any 'Debugger-Support' ''))PackageName: Debugger-Tools-ModificationsParcel: #('Debugger-Tools-Modifications')ParcelName: Debugger-Tools-ModificationsPrerequisiteParcels: #(#('Debugger-Support' ''))PrintStringCache: (8.0 - 1,smichael)Version: 8.0 - 1Post-Load Block: 	[ :pkg |  ContextInspector removeSelector: #inspect:.Inspector initialize.OrderedCollectionInspector flushMenus.ContextInspector flushMenus.DictionaryInspector flushMenus.]Date: 3:26:58 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.4) of June 23, 2017 on June 30, 2017 at 3:26:58 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><shared-variable><name>ClipBoard</name><environment>Tools.Inspector</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Debugger-Tools-Modifications</package></attributes></shared-variable><methods><class-id>Tools.OrderedCollectionInspector</class-id> <category>field list</category><body package="Debugger-Tools-Modifications">basicFieldMenu	"OrderedCollectionInspector flushMenus" 	| m |	m := Menu new.	self		addMenuLabels: (Array with: (#Inspect &lt;&lt; #pdp &gt;&gt; 'Inspect') with: (#Dive &lt;&lt; #pdp &gt;&gt; 'Dive') with: (#Pop &lt;&lt; #pdp &gt;&gt; 'Pop') with: (#Utils &lt;&lt; #pdp &gt;&gt; 'Utils'))		values: #(#inspectField #diveIntoField #pop #utils)		toMenu: m.	(m atNameKey: #utils)		value: nil;		submenu: self basicUtilsMenu.	self addClipBoardFieldsToMenu: m withPaste: true.	m addLine.	m addItem: ((MenuItem labeled: (#InsertDots &lt;&lt; #pdp &gt;&gt; 'Insert...')) nameKey: #addField; value: #addField).	m addItem: ((MenuItem labeled: (#Remove &lt;&lt; #pdp &gt;&gt; 'Remove')) nameKey: #removeField; value: #removeField).	^m</body><body package="Debugger-Tools-Modifications">noSelectionMenu	"Answer a Menu of operations on the variables that is to be displayed 	when the operate menu button is pressed."	| m |	m := Menu new.	self		addMenuLabels: (Array with: (#Inspect &lt;&lt; #pdp &gt;&gt; 'Inspect') with: (#Pop &lt;&lt; #pdp &gt;&gt; 'Pop') with: (#Utils &lt;&lt; #pdp &gt;&gt; 'Utils'))		values: #(#inspectField #pop #utils)		toMenu: m.	(m atNameKey: #utils)		value: nil;		submenu: self basicUtilsMenu.	self addClipBoardFieldsToMenu: m withPaste: true.	m addLine.	m addItem: ((MenuItem labeled: (#AddLast &lt;&lt; #pdp &gt;&gt; 'Add Last')) nameKey: #addField; value: #addField).	^m</body></methods><methods><class-id>Tools.OrderedCollectionInspector</class-id> <category>private-menu messages</category><body package="Debugger-Tools-Modifications">removeField	InputState default shiftDown		ifFalse: [(Dialog confirm: (#AreYouSureYouWantToRemoveSelected &lt;&lt; #pdp &gt;&gt; 'Are you sure you want toremove the selected object?'))					ifFalse: [^self]].	self fieldIndex isNil ifTrue: [^self].	object removeAtIndex: self fieldIndex.	self resetFields</body></methods><methods><class-id>Tools.PoolDictionaryInspector</class-id> <category>menu commands</category><body package="Debugger-Tools-Modifications">addField	| aString key |	aString := Dialog request: (#EnterKeyAsASmalltalkConstant &lt;&lt; #pdp &gt;&gt; 'Enter key as a Smalltalk constant') for: self interfaceWindow.	aString isEmpty ifTrue: [^self].	key := [Object evaluatorClass evaluate: aString]		on: Object errorSignal		do: [:ex |				Dialog warn:						((#ErrorDuringEval1sReenter &lt;&lt; #pdp &gt;&gt; 'Error during evaluation:&lt;n&gt;    "&lt;1s&gt;"&lt;n&gt;please reenter the key as a Smalltalk constant')			expandMacrosWith: ex errorString)					for: self interfaceWindow.				ex return: nil].	key == nil ifTrue: [^nil].	object at: key put: nil.	field := key.	self resetFields</body></methods><methods><class-id>Tools.SequenceableCollectionInspector</class-id> <category>private</category><body package="Debugger-Tools-Modifications">newObject: anObject	"Replace the selected object with anObject."	object at: self fieldIndex put: anObject.</body></methods><methods><class-id>Tools.ContextInspector</class-id> <category>doIt/accept</category><body package="Debugger-Tools-Modifications">acceptText: aText from: aController	"Text has been changed.  Store or compile the text, depending on 	the current mode of the receiver."	| val |	(field == nil) | (field = 'self') ifTrue: [^ false].	val := self evaluateText: aText string from: aController ifFail: [^ false].	object put: val  intoTempVar: (field at: 2).	self resetText.	^ true</body></methods><methods><class-id>Tools.ContextInspector</class-id> <category>field list</category><body package="Debugger-Tools-Modifications">basicUtilsMenu	| m |	m := Menu new.	self		addMenuLabels: (Array with: (#Browse &lt;&lt; #pdp &gt;&gt; 'Browse') with: (#BasicInspect &lt;&lt; #pdp &gt;&gt; 'Basic Inspect') with: (#Owners &lt;&lt; #pdp &gt;&gt; 'Owners') with: (#ReferencePath &lt;&lt; #pdp &gt;&gt; 'Reference Path'))		values: #(browseField basicInspectField ownersOfField findReferencePath)		toMenu: m.	^m</body><body package="Debugger-Tools-Modifications">fieldIndex	"Answer the offset corresponding to the currently selected field."	^properties at: #tempIndex ifAbsent: [0].</body><body package="Debugger-Tools-Modifications">fieldList	| names |	names := object == nil		ifTrue: [Array new]		ifFalse: [object pdpSlotAccessors].	properties at: #tempNames put: names.	^names collect: [:a | a at: 1]</body><body package="Debugger-Tools-Modifications">fieldMenu	"Answer a Menu of operations on variables that is to be displayed 	when the operate menu button is pressed."	| m mi |	field == nil ifTrue: [^nil].	m := Menu new.	m addItem: ((MenuItem labeled: (#Inspect &lt;&lt; #pdp &gt;&gt; 'Inspect')) nameKey: #inspectField; value: #inspectField).	mi := (MenuItem labeled: (#Utils &lt;&lt; #pdp &gt;&gt; 'Utils')) nameKey: #utils.	mi submenu: self basicUtilsMenu.	m addItem: mi.	self addClipBoardFieldsToMenu: m withPaste: true.	^m</body><body package="Debugger-Tools-Modifications">fieldValue	"field = 'self' ifTrue: [^ object receiver]."	^object getTempVar: (field at: 2)</body></methods><methods><class-id>Tools.ContextInspector</class-id> <category>private</category><body package="Debugger-Tools-Modifications">getAndSetNewList	| list |	list := self fieldList.	[fieldList selectionIndexHolder retractInterestsFor: self.	fieldList list: list asList.]		valueNowOrOnUnwindDo: 			[fieldList selectionIndexHolder onChangeSend: #changedSelectedField to: self].	^list</body><body package="Debugger-Tools-Modifications">newObject: anObject	"Replace the selected object with anObject."	object put: anObject  intoTempVar: (field at: 2).</body><body package="Debugger-Tools-Modifications">resetFields	| list tempIndex |	tempIndex := self fieldIndex.	list := self getAndSetNewList.	tempIndex := (tempIndex isNil or: [tempIndex = 0 or: [list size &lt; tempIndex or: [(list at: tempIndex) ~= (field at: 1)]]])		ifTrue: [0]		ifFalse: [tempIndex].	properties at: #tempIndex put: tempIndex.	fieldList selectionIndexHolder value: tempIndex.</body></methods><methods><class-id>Tools.CompiledCodeInspector</class-id> <category>text</category><body package="Debugger-Tools-Modifications">text	"Answer the text displayed by the receiver for the current selection."	field == nil ifTrue: [^Text new].	self isSourceCode ifTrue: [^self sourceCodeText].	self isSymbolic ifTrue: [^self inspectMethod symbolic].	^super text</body></methods><methods><class-id>Tools.DictionaryInspector</class-id> <category>field list</category><body package="Debugger-Tools-Modifications">basicFieldMenu	"DictionaryInspector flushMenus"	| m |	m := Menu new.	self		addMenuLabels: (Array with: (#Inspect &lt;&lt; #pdp &gt;&gt; 'Inspect') with: (#Dive &lt;&lt; #pdp &gt;&gt; 'Dive') with: (#Pop &lt;&lt; #pdp &gt;&gt; 'Pop') with: (#Utils &lt;&lt; #pdp &gt;&gt; 'Utils'))		values: #(#inspectField #diveIntoField #pop #utils)		toMenu: m.	(m atNameKey: #utils)		value: nil;		submenu: self basicUtilsMenu.	self addClipBoardFieldsToMenu: m withPaste: true.	m addLine.	self		addMenuLabels: (Array with: (#References &lt;&lt; #pdp &gt;&gt; 'References') with: (#AddFieldDots &lt;&lt; #pdp &gt;&gt; 'Add Field...') with: (#Remove &lt;&lt; #pdp &gt;&gt; 'Remove'))		values: #(#browseReferences #addField #removeField)		toMenu: m.	^m</body></methods><methods><class-id>Tools.DictionaryInspector</class-id> <category>private</category><body package="Debugger-Tools-Modifications">newObject: anObject	"Replace the selected object with anObject."	object at: field put: anObject.</body></methods><methods><class-id>Tools.DictionaryInspector</class-id> <category>field list</category><body package="Debugger-Tools-Modifications">noSelectionMenu	"Answer a Menu of operations on the variables that is to be displayed 	when the operate menu button is pressed."	| m |	m := Menu new.	self		addMenuLabels: (Array with: (#Inspect &lt;&lt; #pdp &gt;&gt; 'Inspect') with: (#Pop &lt;&lt; #pdp &gt;&gt; 'Pop') with: (#Utils &lt;&lt; #pdp &gt;&gt; 'Utils'))		values: #(#inspectField #pop #utils)		toMenu: m.	(m atNameKey: #utils)		value: nil;		submenu: self basicUtilsMenu.	self addClipBoardFieldsToMenu: m withPaste: false.	m addLine.	m addItem: ((MenuItem labeled: (#AddField &lt;&lt; #pdp &gt;&gt; 'Add Field')) nameKey: #addField; value: #addField).	^m</body></methods><methods><class-id>Tools.Inspector class</class-id> <category>class initialization</category><body package="Debugger-Tools-Modifications">initialize	DefaultNumberOfFields := 40.	ClipBoard isNil		ifTrue: [ClipBoard := WeakArray new: 1].	self flushMenus.</body></methods><methods><class-id>Tools.Inspector</class-id> <category>private-reflection protocol</category><body package="Debugger-Tools-Modifications">_objectClass: anObject	"Answer the object which is the argument's class.."	&lt;primitive: 211&gt;	^self primitiveFailed</body></methods><methods><class-id>Tools.Inspector</class-id> <category>private</category><body package="Debugger-Tools-Modifications">addClipBoardFieldsToMenu: aMenu withPaste: aBool	aMenu		addLine;		addItem: ((MenuItem labeled: (#Copy &lt;&lt; #pdp &gt;&gt; 'Copy')) nameKey: #copyField; value: #copyField).	aBool		ifTrue: [aMenu addItem: ((MenuItem labeled: (#Paste &lt;&lt; #pdp &gt;&gt; 'Paste')) nameKey: #pasteField; value: #pasteField)].	aMenu addItem: ((MenuItem labeled: (#Compare &lt;&lt; #pdp &gt;&gt; 'Compare')) nameKey: #compareField; value: #compareField).</body><body package="Debugger-Tools-Modifications">addMenuLabels: labels values: values toMenu: aMenu	labels		with: values		do:	[:label :value | 			aMenu addItem: ((MenuItem labeled: label)										nameKey: value;										value: value;										yourself)].</body></methods><methods><class-id>Tools.Inspector</class-id> <category>field list</category><body package="Debugger-Tools-Modifications">basicFieldMenu	"Inspector flushMenus"	| m |	m := Menu new.	self		addMenuLabels: (Array with: (#Inspect &lt;&lt; #pdp &gt;&gt; 'Inspect') with: (#Dive &lt;&lt; #pdp &gt;&gt; 'Dive') with: (#Pop &lt;&lt; #pdp &gt;&gt; 'Pop') with: (#Utils &lt;&lt; #pdp &gt;&gt; 'Utils'))		values: #(#inspectField #diveIntoField #pop #utils)		toMenu: m.	(m atNameKey: #utils)		value: nil;		submenu: self basicUtilsMenu.	self addClipBoardFieldsToMenu: m withPaste: true.	^m</body></methods><methods><class-id>Tools.Inspector</class-id> <category>text</category><body package="Debugger-Tools-Modifications">basicObjectPrintString: anObject	 | aStream |	aStream := WriteStream on: (String new: 16).	aStream nextPutAll:		(((self _objectClass: anObject) name at: 1) isVowel ifTrue: ['an '] ifFalse: ['a ']).	aStream print: (self _objectClass: anObject).	^aStream contents</body></methods><methods><class-id>Tools.Inspector</class-id> <category>private</category><body package="Debugger-Tools-Modifications">clipBoard	| val |	val := ClipBoard at: 1.	val == 0		ifFalse: [^val].	ClipBoard at: 1 put: nil.	^nil</body></methods><methods><class-id>Tools.Inspector</class-id> <category>private-menu messages</category><body package="Debugger-Tools-Modifications">compareField	| test |	test := self fieldValue == self clipBoard		ifTrue: [(#FieldTheSameAsClipboard &lt;&lt; #pdp &gt;&gt; 'The selected field is the same as the clipboard.')]		ifFalse:			[self fieldValue = self clipBoard				ifTrue: [(#FieldEqualToClipboard &lt;&lt; #pdp &gt;&gt; 'The selected field is equal to the clipboard.')]				ifFalse: [(#FieldNotEqualToClipboard &lt;&lt; #pdp &gt;&gt; 'The selected field is not equal to the clipboard.')]].	Dialog warn: test</body><body package="Debugger-Tools-Modifications">copyField	ClipBoard at: 1 put: self fieldValue.</body><body package="Debugger-Tools-Modifications">inspectField	InputState default shiftDown		ifTrue: [self fieldValue basicInspect]		ifFalse: [self fieldValue inspect].</body></methods><methods><class-id>Tools.Inspector</class-id> <category>private</category><body package="Debugger-Tools-Modifications">newObject: anObject	"Replace the selected object with anObject."	field first isDigit		ifTrue: [object basicAt: self fieldIndex put: anObject]		ifFalse: [object instVarAt: self fieldIndex put: anObject].</body></methods><methods><class-id>Tools.Inspector</class-id> <category>field list</category><body package="Debugger-Tools-Modifications">noSelectionMenu	"Inspector flushMenus"	| m |	m := Menu new.	self		addMenuLabels: (Array with: (#Inspect &lt;&lt; #pdp &gt;&gt; 'Inspect') with: (#Pop &lt;&lt; #pdp &gt;&gt; 'Pop') with: (#Utils &lt;&lt; #pdp &gt;&gt; 'Utils'))		values: #(#inspectField #pop #utils)		toMenu: m.	(m atNameKey: #utils)		value: nil;		submenu: self basicUtilsMenu.	self addClipBoardFieldsToMenu: m withPaste: false.	^m</body></methods><methods><class-id>Tools.Inspector</class-id> <category>private-menu messages</category><body package="Debugger-Tools-Modifications">ownersOfField	"Inspect all who have a reference to the field object. Do not include references generated by the reference gathering process!"	(self fieldValue allOwners reject:		[:each |	"don't include the object under inspection (it always contains the field object)"		each == object	"don't include the methods that got us here"		or: [(each class == MethodContext			and: [each selector == #allOwners			or: [each selector == #allOwnersWeakly:]])	"don't include the stack array with a temporary variable containing the object"		or: [each class == Array			and: [each size = 12			and: [each first == false			and: [(each at: 2) == self fieldValue]]]]]]) inspect</body><body package="Debugger-Tools-Modifications">pasteField	field = 'self'		ifTrue: [^Dialog warn: (#SorryCantPasteSelf &lt;&lt; #pdp &gt;&gt; 'Sorry, can''t paste ''self''')].	(InputState default shiftDown or: [Dialog confirm: (#AreYouSureYouWantToPaste &lt;&lt; #pdp &gt;&gt; 'Are you sure you want to paste?').])		ifFalse: [^self].	self newObject: self clipBoard.	self resetText.</body></methods><methods><class-id>Tools.Inspector</class-id> <category>text</category><body package="Debugger-Tools-Modifications">protectedBasicObjectPrintString: anObject	^[self basicObjectPrintString: anObject]		on: Error		do: [:ex | #ErrorPrintingTheObject &lt;&lt; #labels &gt;&gt; 'Error printing the object']</body></methods><methods><class-id>Tools.Inspector</class-id> <category>private</category><body package="Debugger-Tools-Modifications">resetFieldsForDebugger	| list |	list := self fieldList.	self printItems ifTrue: [list := list collect: [:e | e printString]].	list := list asList.	list = fieldList list		ifTrue: [^self resetText].	fieldList list: list asList</body></methods><methods><class-id>Tools.Inspector</class-id> <category>initialize-release</category><body package="Debugger-Tools-Modifications">setObject: anObject	history := nil.	object := anObject.</body></methods><methods><class-id>Tools.Inspector</class-id> <category>text</category><body package="Debugger-Tools-Modifications">text	"Answer the text displayed by the receiver."	| string |	field == nil ifTrue: [^Text new].	string := [5 seconds				toFinish: [field = 'self'						ifTrue: [self fieldValue inspectString]						ifFalse: [self fieldValue printString]]				orElse: [self basicObjectPrintString: self fieldValue]]				on: Error , BreakInterrupt				do: [:ex | self protectedBasicObjectPrintString: self fieldValue].	^string asText</body></methods><methods><class-id>Tools.PrimitiveObjectInspector</class-id> <category>field list</category><body package="Debugger-Tools-Modifications">fieldMenu	| m |	m := Menu new.	self		addMenuLabels: (Array with: (#Inspect &lt;&lt; #pdp &gt;&gt; 'Inspect') with: (#Utils &lt;&lt; #pdp &gt;&gt; 'Utils'))		values: #(#inspectField #utils)		toMenu: m.	(m atNameKey: #utils)		value: nil;		submenu: self basicUtilsMenu.	self addClipBoardFieldsToMenu: m withPaste: true.	^m</body></methods><initialize><class-id>Tools.Inspector</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Inspector</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object field fieldList properties history showAllFields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Inspector</category><attributes><package>Tools-Inspector</package></attributes></class><class><name>ContextInspector</name><environment>Tools</environment><super>Tools.Inspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>PrimitiveObjectInspector</name><environment>Tools</environment><super>Tools.Inspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Inspector</category><attributes><package>Tools-Inspector</package></attributes></class><class><name>DictionaryInspector</name><environment>Tools</environment><super>Tools.Inspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Inspector</category><attributes><package>Tools-Inspector</package></attributes></class><class><name>PoolDictionaryInspector</name><environment>Tools</environment><super>Tools.DictionaryInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Inspector</category><attributes><package>Tools-Inspector</package></attributes></class><class><name>SequenceableCollectionInspector</name><environment>Tools</environment><super>Tools.Inspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Inspector</category><attributes><package>Tools-Inspector</package></attributes></class><class><name>OrderedCollectionInspector</name><environment>Tools</environment><super>Tools.SequenceableCollectionInspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Inspector</category><attributes><package>Tools-Inspector</package></attributes></class><class><name>CompiledCodeInspector</name><environment>Tools</environment><super>Tools.Inspector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Inspector</category><attributes><package>Tools-Inspector</package></attributes></class></st-source>