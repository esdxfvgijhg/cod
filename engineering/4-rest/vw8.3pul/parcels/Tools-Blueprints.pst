<?xml version="1.0"?><st-source><!-- Name: Tools-BlueprintsNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: Contains Blueprints framework. Blueprints are simple structured definition objects for representing code entities. See AbstractBlueprint class comment.DbIdentifier: bear73DbTrace: 423129DbUsername: smichaelDbVersion: 8.0 - 2DevelopmentPrerequisites: #(#(#any 'Browser-Parser' ''))PackageName: Tools-BlueprintsParcel: #('Tools-Blueprints')ParcelName: Tools-BlueprintsPrerequisiteDescriptions: #(#(#name 'Browser-Parser'))PrerequisiteParcels: #(#('Browser-Parser' ''))PrintStringCache: (8.0 - 2,smichael)Version: 8.0 - 2Date: 3:26:57 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.4) of June 23, 2017 on June 30, 2017 at 3:26:57 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>AbstractBlueprint</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>original </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Tools-Blueprints</package></attributes></class><comment><class-id>Tools.AbstractBlueprint</class-id><body>A Blueprint describes a code object in its bare minimum, with literal objects, so that no external framework/system/references need to exist for it. It is a declaration of what it is, without any references to it.Instance Variables	original	&lt;Object&gt;	An optional/arbitrary object that is used to express what the blueprint was derived from. When nil, it is assumed it is derived from live image objects usuallySubclass Responsibility	comparing		&lt;=	testing		belongsToCodeComponent:</body></comment><class><name>BindingBlueprint</name><environment>Tools</environment><super>Tools.AbstractBlueprint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reference packageName isPrivate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Tools-Blueprints</package></attributes></class><comment><class-id>Tools.BindingBlueprint</class-id><body>Abstract class for blueprints of Classes, Namespaces, and Shared Variables.Instance Variables	isPrivate	&lt;Boolean&gt;	is the object described marked private or not	packageName	&lt;String | nil&gt;	 the name of the package this is stored in	reference	&lt;BindingReference&gt;	describes the environment and name of the object</body></comment><class><name>SharedVariableBlueprint</name><environment>Tools</environment><super>Tools.BindingBlueprint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>category initializer isConstant </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Tools-Blueprints</package></attributes></class><comment><class-id>Tools.SharedVariableBlueprint</class-id><body>Describes a shared variable.Instance Variables	category	&lt;String&gt;	what organizer category I go in	initializer	&lt;nil | String&gt; initializer source	isConstant	&lt;Boolean&gt;	is the described share constant or not</body></comment><class><name>NamespaceBlueprint</name><environment>Tools</environment><super>Tools.BindingBlueprint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>importsString comment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Tools-Blueprints</package></attributes></class><comment><class-id>Tools.NamespaceBlueprint</class-id><body>Describes a Namespace.Instance Variables	comment	&lt;String&gt;	the comment	importsString	&lt;String&gt;	imports string that shows up in the definition message</body></comment><class><name>ClassBlueprint</name><environment>Tools</environment><super>Tools.NamespaceBlueprint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclassReference attributes behaviorType instanceVariables classInstanceVariables </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Tools-Blueprints</package></attributes></class><comment><class-id>Tools.ClassBlueprint</class-id><body>Describes a class (note it does not mention methods at all).Instance Variables	attributes	&lt;Array&gt;	array of arbitrary attributes for the described class which is used in the definition message	behaviorType	&lt;Symbol&gt;	behaviorType of the describedClass	classInstanceVariables	&lt;Array of: String&gt;	the class instance variables of the described class	instanceVariables	&lt;Array of: String&gt;	the instance variables of the described class	superclassReference	&lt;BindingReference&gt;	reference to describe name and environment of the described class's superclass</body></comment><class><name>MethodBlueprint</name><environment>Tools</environment><super>Tools.AbstractBlueprint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classReference selector isInstanceBehavior packageName source category </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Tools-Blueprints</package></attributes></class><comment><class-id>Tools.MethodBlueprint</class-id><body>Describes a method. This differs from a MethodDefinition, in that it needs no real class object to describe the method.Instance Variables	category	&lt;String&gt;	what organizer category the method goes in	classReference	&lt;BindingReference&gt;	name and environment of the behavior the described method belongs to	isInstanceBehavior	&lt;Boolean&gt;	does it belong to the instanceBehavior or the classBehavior resolved to by classReference?	packageName	&lt;String&gt;	which package does it belong to	selector	&lt;Symbol&gt;	selector fo the described method	source	&lt;String&gt; source of the described method</body></comment><class><name>CodeComponentPropertyBlueprint</name><environment>Tools</environment><super>Tools.AbstractBlueprint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>codeComponentName key value isBundle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Tools-Blueprints</package></attributes></class><comment><class-id>Tools.CodeComponentPropertyBlueprint</class-id><body>Describes a property of a bundle or package.Instance Variables	codeComponentName	&lt;String&gt;	name of the package or bundle	isBundle	&lt;Boolean&gt;	Packages and Bundles can have the same names, this disambiguates which one I'm for	key	&lt;String&gt;	the key of the property	value	&lt;Object&gt;	arbitrary property value object. blocks are turned into strings</body></comment><methods><class-id>Tools.AbstractBlueprint</class-id> <category>accessing</category><body package="Tools-Blueprints">original	^original</body><body package="Tools-Blueprints">original: anObject	original := anObject</body></methods><methods><class-id>Tools.AbstractBlueprint</class-id> <category>comparing</category><body package="Tools-Blueprints">&lt;= aBlueprint	"Subclasses must define a stable and reproducible sort orter."	^self subclassResponsibility</body></methods><methods><class-id>Tools.AbstractBlueprint</class-id> <category>testing</category><body package="Tools-Blueprints">belongsToCodeComponent: aCodeComponent	"Does the receiver represent an entity that could be found in aCodeComponent?"	^self subclassResponsibility</body></methods><methods><class-id>Tools.AbstractBlueprint</class-id> <category>utility</category><body package="Tools-Blueprints">parseDefinition: aDefinitionString	"A utility method for breaking definition messages up into dictionaries of keyword/value pairs."	| result input array |	input := aDefinitionString readStream.	Scanner new scan: input.	"This eats off the receiver of the definition message"	array := Compiler evaluate: '#(' , input upToEnd , ')'.	result := Dictionary new: array size / 2.	1 to: array size		by: 2		do: [:n | result at: (array at: n) put: (array at: n + 1)].	^result</body></methods><methods><class-id>Tools.AbstractBlueprint class</class-id> <category>instance creation</category><body package="Tools-Blueprints">of: anObject	^self new original: anObject</body></methods><methods><class-id>Tools.BindingBlueprint</class-id> <category>accessing</category><body package="Tools-Blueprints">bindingDetailSelectors	^#(#isPrivate #packageName)</body><body package="Tools-Blueprints">isPrivate	^isPrivate</body><body package="Tools-Blueprints">isPrivate: anObject	isPrivate := anObject</body><body package="Tools-Blueprints">originalStoreObject	^(original isNil or: [original isOverride])		ifTrue: [nil]		ifFalse: [original]</body><body package="Tools-Blueprints">package: aPackage	self packageName: aPackage name</body><body package="Tools-Blueprints">packageName	^packageName</body><body package="Tools-Blueprints">packageName: anObject	packageName := anObject</body><body package="Tools-Blueprints">reference	^reference</body><body package="Tools-Blueprints">reference: anObject	reference := anObject</body></methods><methods><class-id>Tools.BindingBlueprint</class-id> <category>comparing</category><body package="Tools-Blueprints">&lt;= aBindingBlueprint	^reference = aBindingBlueprint reference		ifTrue: [packageName &lt;= aBindingBlueprint packageName]		ifFalse: [reference &lt;= aBindingBlueprint reference]</body><body package="Tools-Blueprints">= aBindingBlueprint	^self class == aBindingBlueprint class and: 			[reference = aBindingBlueprint reference and: 					[packageName = aBindingBlueprint packageName						and: [isPrivate = aBindingBlueprint isPrivate]]]</body><body package="Tools-Blueprints">hash	^reference hash hashMultiply bitXor: self class hash</body></methods><methods><class-id>Tools.BindingBlueprint</class-id> <category>testing</category><body package="Tools-Blueprints">belongsToCodeComponent: aCodeComponent	^aCodeComponent isPackage and: [aCodeComponent name = packageName]</body><body package="Tools-Blueprints">isForClass	^false</body><body package="Tools-Blueprints">isForNamespace	^false</body><body package="Tools-Blueprints">isForSharedVariable	^false</body></methods><methods><class-id>Tools.BindingBlueprint</class-id> <category>printing</category><body package="Tools-Blueprints">printOn: aStream	super printOn: aStream.	aStream space.	reference printOn: aStream</body></methods><methods><class-id>Tools.SharedVariableBlueprint</class-id> <category>accessing</category><body package="Tools-Blueprints">bindingDetailSelectors	^#(#category #initializer #isConstant) , super bindingDetailSelectors</body><body package="Tools-Blueprints">category	^category</body><body package="Tools-Blueprints">category: aString	category := aString asString</body><body package="Tools-Blueprints">initializer	^initializer</body><body package="Tools-Blueprints">initializer: aString	initializer := aString ifNotNil: #asString</body><body package="Tools-Blueprints">isConstant	^isConstant</body><body package="Tools-Blueprints">isConstant: aBoolean	isConstant := aBoolean</body></methods><methods><class-id>Tools.SharedVariableBlueprint</class-id> <category>testing</category><body package="Tools-Blueprints">isForSharedVariable	^true</body></methods><methods><class-id>Tools.SharedVariableBlueprint</class-id> <category>comparing</category><body package="Tools-Blueprints">= aSharedVariableBlueprint	^super = aSharedVariableBlueprint and: 			[initializer = aSharedVariableBlueprint initializer and: 					[category = aSharedVariableBlueprint category						and: [isConstant = aSharedVariableBlueprint isConstant]]]</body></methods><methods><class-id>Tools.NamespaceBlueprint</class-id> <category>accessing</category><body package="Tools-Blueprints">bindingDetailSelectors	^#(#comment #importsString) , super bindingDetailSelectors</body><body package="Tools-Blueprints">comment	^comment</body><body package="Tools-Blueprints">comment: aString	comment := aString asString</body><body package="Tools-Blueprints">importsString	^importsString</body><body package="Tools-Blueprints">importsString: aString	| ws |	ws := String new writeStream.	((((aString tokensBasedOn: Character cr)		collect: [:each | each copyReplaceAll: '	' with: ' ']) collect: #trimBlanks)		reject: #isEmpty) do: [:each | ws nextPutAll: each] separatedBy: [ws cr].	importsString := ws contents</body></methods><methods><class-id>Tools.NamespaceBlueprint</class-id> <category>testing</category><body package="Tools-Blueprints">isForNamespace	^true</body></methods><methods><class-id>Tools.NamespaceBlueprint</class-id> <category>comparing</category><body package="Tools-Blueprints">= aNamespaceBlueprint	^super = aNamespaceBlueprint and: 			[comment = aNamespaceBlueprint comment				and: [importsString = aNamespaceBlueprint importsString]]</body></methods><methods><class-id>Tools.ClassBlueprint</class-id> <category>accessing</category><body package="Tools-Blueprints">attributes	^attributes</body><body package="Tools-Blueprints">attributes: anObject	attributes := anObject</body><body package="Tools-Blueprints">behaviorType	^behaviorType</body><body package="Tools-Blueprints">behaviorType: aSymbol 	behaviorType := aSymbol</body><body package="Tools-Blueprints">bindingDetailSelectors	^#(#attributes #behaviorType #classInstanceVariables #instanceVariables #superclassReference)		, super bindingDetailSelectors</body><body package="Tools-Blueprints">classInstanceVariables	^classInstanceVariables</body><body package="Tools-Blueprints">classInstanceVariables: aSequence	classInstanceVariables := (aSequence collect: #asString) asArray</body><body package="Tools-Blueprints">instanceVariables	^instanceVariables</body><body package="Tools-Blueprints">instanceVariables: aSequence	instanceVariables := (aSequence collect: #asString) asArray</body><body package="Tools-Blueprints">superclassReference	^superclassReference</body><body package="Tools-Blueprints">superclassReference: anObject	superclassReference := anObject</body></methods><methods><class-id>Tools.ClassBlueprint</class-id> <category>testing</category><body package="Tools-Blueprints">isForClass	^true</body><body package="Tools-Blueprints">isForNamespace	^false</body></methods><methods><class-id>Tools.ClassBlueprint</class-id> <category>comparing</category><body package="Tools-Blueprints">= aClassBlueprint	^super = aClassBlueprint and: 			[instanceVariables = aClassBlueprint instanceVariables and: 					[superclassReference = aClassBlueprint superclassReference and: 							[behaviorType = aClassBlueprint behaviorType and: 									[classInstanceVariables = aClassBlueprint classInstanceVariables										and: [attributes = aClassBlueprint attributes]]]]]</body></methods><methods><class-id>Tools.MethodBlueprint</class-id> <category>accessing</category><body package="Tools-Blueprints">category	^category		ifNil: [category := self definition ifNotNil: [:m | m protocol asString]]</body><body package="Tools-Blueprints">category: aString	category := aString asString</body><body package="Tools-Blueprints">classReference	^classReference</body><body package="Tools-Blueprints">classReference: aBindingReference	classReference := aBindingReference</body><body package="Tools-Blueprints">currentBehavior	| binding instanceBehavior |	binding := classReference bindingOrNil.	binding ifNil: [^self].	instanceBehavior := binding value.	^isInstanceBehavior		ifTrue: [instanceBehavior]		ifFalse: [instanceBehavior classBehavior]</body><body package="Tools-Blueprints">definition	^self currentBehavior		ifNotNil: [:behavior | MethodDefinition class: behavior selector: selector]</body><body package="Tools-Blueprints">isInstanceBehavior	^isInstanceBehavior</body><body package="Tools-Blueprints">isInstanceBehavior: aBoolean	isInstanceBehavior := aBoolean</body><body package="Tools-Blueprints">liveClass	^(classReference asQualifiedReference bindingOrNil ifNotNil: #value)		ifNotNil: 			[:behavior |			self isInstanceBehavior				ifTrue: [behavior instanceBehavior]				ifFalse: [behavior classBehavior]]</body><body package="Tools-Blueprints">originalStoreObject	^(original isNil or: [original isOverride])		ifTrue: [nil]		ifFalse: [original]</body><body package="Tools-Blueprints">selector	^selector</body><body package="Tools-Blueprints">selector: aSymbol	selector := aSymbol</body><body package="Tools-Blueprints">source	^source		ifNil: [source := self definition ifNotNil: [:m | m sourceCode asString]]</body><body package="Tools-Blueprints">source: aString	source := aString asString</body><body package="Tools-Blueprints">sourceText	| text parser body stop |	text := self source asText.	parser := Refactory.Browser.RBParser new.	parser errorBlock: [:error :position | ^text].	parser initializeParserWith: text.	body := parser parseMessagePattern.	stop := body arguments isEmpty				ifTrue: [body selectorParts last stop]				ifFalse: [body arguments last stop].	text		addEmphasis: #(#bold)		removeEmphasis: #()		allowDuplicates: false		from: 1		to: stop.	^text</body></methods><methods><class-id>Tools.MethodBlueprint</class-id> <category>initialize-release</category><body package="Tools-Blueprints">initialize	super initialize.	isInstanceBehavior := true</body></methods><methods><class-id>Tools.MethodBlueprint</class-id> <category>row population</category><body package="Tools-Blueprints">selectorDisplayText	| text |	text := self selector asText allBold.	self isInstanceBehavior ifFalse: [text := text , ' (class)'].	^text</body></methods><methods><class-id>Tools.MethodBlueprint</class-id> <category>comparing</category><body package="Tools-Blueprints">&lt;= aMethodBlueprint	^classReference = aMethodBlueprint classReference		ifTrue: 			[isInstanceBehavior = aMethodBlueprint isInstanceBehavior				ifTrue: 					[selector = aMethodBlueprint selector						ifTrue: [packageName &lt;= aMethodBlueprint packageName]						ifFalse: [selector &lt;= aMethodBlueprint selector]]				ifFalse: [isInstanceBehavior]]		ifFalse: [classReference &lt;= aMethodBlueprint classReference]</body><body package="Tools-Blueprints">= aMethodBlueprint	^self class = aMethodBlueprint class and: 			[selector = aMethodBlueprint selector and: 					[self category = aMethodBlueprint category and: 							[classReference = aMethodBlueprint classReference and: 									[isInstanceBehavior = aMethodBlueprint isInstanceBehavior and: 											[packageName = aMethodBlueprint packageName												and: [self source = aMethodBlueprint source]]]]]]</body><body package="Tools-Blueprints">&gt;=&lt; aMethodBlueprint	"Variant of = which ignores class reference."	^self class = aMethodBlueprint class and: 		[selector = aMethodBlueprint selector and: 			[self category = aMethodBlueprint category and:				[isInstanceBehavior = aMethodBlueprint isInstanceBehavior and: 					[packageName = aMethodBlueprint packageName and: 						[self source = aMethodBlueprint source]]]]]</body><body package="Tools-Blueprints">hash	^(selector hash hashMultiply bitXor: classReference hash) hashMultiply		bitXor: isInstanceBehavior hash</body><body package="Tools-Blueprints">isSameSignatureAs: aMethodBlueprint	^selector = aMethodBlueprint selector		and: [isInstanceBehavior = aMethodBlueprint isInstanceBehavior]</body><body package="Tools-Blueprints">isSignatureLess: aMethodBlueprint	^isInstanceBehavior = aMethodBlueprint isInstanceBehavior		ifTrue: [selector &lt;= aMethodBlueprint selector]		ifFalse: [isInstanceBehavior]</body><body package="Tools-Blueprints">package: aPackage	self packageName: aPackage name</body><body package="Tools-Blueprints">packageName	^packageName</body><body package="Tools-Blueprints">packageName: aString	packageName := aString</body></methods><methods><class-id>Tools.MethodBlueprint</class-id> <category>printing</category><body package="Tools-Blueprints">printOn: aStream	aStream		nextPutAll: classReference path last;		space.	isInstanceBehavior ifFalse: [aStream nextPutAll: 'class '].	aStream nextPutAll: selector</body></methods><methods><class-id>Tools.MethodBlueprint</class-id> <category>testing</category><body package="Tools-Blueprints">belongsToCodeComponent: aCodeComponent	^aCodeComponent isPackage and: [aCodeComponent name = packageName]</body></methods><methods><class-id>Tools.CodeComponentPropertyBlueprint</class-id> <category>comparing</category><body package="Tools-Blueprints">&lt;= aPropertyBlueprint	| compareResult |	compareResult := codeComponentName trueCompare: aPropertyBlueprint codeComponentName.	^compareResult = 0		ifTrue: [isBundle = aPropertyBlueprint isBundle ifTrue: [(key trueCompare: aPropertyBlueprint key) = -1] ifFalse: [isBundle]]		ifFalse: [compareResult = -1]</body><body package="Tools-Blueprints">= aPropertyBlueprint	^self class == aPropertyBlueprint class and: 			[codeComponentName = aPropertyBlueprint codeComponentName and: 					[isBundle = aPropertyBlueprint isBundle						and: [key = aPropertyBlueprint key and: [value = aPropertyBlueprint value]]]]</body><body package="Tools-Blueprints">hash	^self class hash hashMultiply bitXor: key hash</body></methods><methods><class-id>Tools.CodeComponentPropertyBlueprint</class-id> <category>accessing</category><body package="Tools-Blueprints">codeComponent: aCodeComponent	self codeComponentName: aCodeComponent name.	self isBundle: aCodeComponent isBundle</body><body package="Tools-Blueprints">codeComponentName	^codeComponentName</body><body package="Tools-Blueprints">codeComponentName: aString	codeComponentName := aString</body><body package="Tools-Blueprints">isBundle	^isBundle</body><body package="Tools-Blueprints">isBundle: aBoolean	^isBundle := aBoolean</body><body package="Tools-Blueprints">key	^key</body><body package="Tools-Blueprints">key: anObject	key := anObject</body><body package="Tools-Blueprints">value	^value</body><body package="Tools-Blueprints">value: anObject	value := anObject</body></methods><methods><class-id>Tools.CodeComponentPropertyBlueprint</class-id> <category>testing</category><body package="Tools-Blueprints">belongsToCodeComponent: aCodeComponent	^aCodeComponent isBundle = isBundle		and: [aCodeComponent name = codeComponentName]</body></methods><methods><class-id>Tools.CodeComponentPropertyBlueprint</class-id> <category>As yet unclassified</category><body package="Tools-Blueprints">isPackage	^self isBundle not</body></methods><methods><class-id>Kernel.OverridenNameSpace</class-id> <category>accessing</category><body package="Tools-Blueprints">asBlueprint	| blueprint |	definition selector == #defineNameSpace:private:imports:category:		ifFalse: [self unreachableCode].	blueprint := NamespaceBlueprint of: self.	blueprint		reference: ((definition receiver fullyQualifiedReferenceFrom: nil)				append: definition arguments first).	blueprint isPrivate: (definition arguments at: 2).	blueprint importsString: (definition arguments at: 3).	blueprint comment: self comment.	^blueprint</body></methods><methods><class-id>Store.DatumDescriptor</class-id> <category>accessing</category><body package="Tools-Blueprints">asBlueprint	| definitionParts myReference blueprint |	blueprint := SharedVariableBlueprint new.	definitionParts := blueprint parseDefinition: self definition.	myReference := self environmentString asQualifiedReference append: dataKey.	blueprint reference: myReference.	blueprint isPrivate: (definitionParts at: #private:).	blueprint isConstant: (definitionParts at: #constant:).	blueprint category: self protocol.	blueprint initializer: (definitionParts at: #initializer:).	^blueprint</body></methods><methods><class-id>Tools.MethodDefinition</class-id> <category>accessing</category><body package="Tools-Blueprints">asBlueprint	| blueprint |	blueprint := MethodBlueprint of: self.	blueprint classReference: (implementingClass instanceBehavior				fullyQualifiedReferenceFrom: nil).	blueprint selector: selector.	blueprint isInstanceBehavior: implementingClass isMeta not.	blueprint package: self package.	^blueprint</body></methods><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="Tools-Blueprints">asBlueprint	| blueprint |	blueprint := ClassBlueprint new.	blueprint reference: (self fullyQualifiedReferenceFrom: nil).	superclass		ifNotNil: 			[blueprint				superclassReference: superclass fullyQualifiedReference makeUnambiguous].	blueprint behaviorType: self behaviorType.	blueprint instanceVariables: self instVarNames.	blueprint classInstanceVariables: self class instVarNames.	blueprint isPrivate: self fullyQualifiedReference binding isPrivate.	blueprint importsString: self asNameSpace importString.	blueprint attributes: self extraAttributesForDefinition.	blueprint comment: self comment.	^blueprint</body></methods><methods><class-id>Kernel.OverridenClass</class-id> <category>accessing</category><body package="Tools-Blueprints">asBlueprint	| blueprint |	(#(#defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category: #defineClass:superclass:indexedType:private:instanceVariableNames:classInstanceVariableNames:imports:category:attributes:)		includes: definition selector) ifFalse: [self unreachableCode].	blueprint := ClassBlueprint of: self.	blueprint		reference: ((definition receiver fullyQualifiedReferenceFrom: nil)				append: definition arguments first).	blueprint		superclassReference: (definition arguments at: 2) makeUnambiguous.	blueprint behaviorType: (definition arguments at: 3).	blueprint isPrivate: (definition arguments at: 4).	blueprint		instanceVariables: ((definition arguments at: 5) runsFailing: #isSeparator).	blueprint classInstanceVariables: ((definition arguments at: 6)				runsFailing: #isSeparator).	blueprint importsString: (definition arguments at: 7).	blueprint		attributes: ((definition arguments size = 9				ifTrue: [definition arguments at: 9]				ifFalse: [nil]) ifNil: [Array new]).	blueprint comment: self comment.	^blueprint</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>accessing</category><body package="Tools-Blueprints">asBlueprint	| blueprint |	blueprint := NamespaceBlueprint new.	blueprint reference: (self fullyQualifiedReferenceFrom: nil).	blueprint isPrivate: self fullyQualifiedReference binding isPrivate.	blueprint importsString: self importString.	blueprint comment: self comment.	^blueprint</body></methods><methods><class-id>Store.BundleModel</class-id> <category>accessing</category><body package="Tools-Blueprints">classBlueprints	^Array new</body><body package="Tools-Blueprints">methodBlueprints	^Array new</body><body package="Tools-Blueprints">namespaceBlueprints	^Array new</body><body package="Tools-Blueprints">sharedVariableBlueprints	^Array new</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing</category><body package="Tools-Blueprints">bindingBlueprints	^self classBlueprints , self namespaceBlueprints		, self sharedVariableBlueprints</body><body package="Tools-Blueprints">classBlueprints	| output processClassBlock |	output := Array new writeStream.	processClassBlock :=			[:each |			| blueprint |			blueprint := each asBlueprint.			blueprint package: self.			output nextPut: blueprint].	self definedClassesDo: processClassBlock.	self overriddenClasses do: processClassBlock.	^output contents</body><body package="Tools-Blueprints">methodBlueprints	| output addMethodBlock |	output := Array new writeStream.	addMethodBlock :=			[:blueprint |			blueprint package: self.			output nextPut: blueprint].	self classModelsDo: 			[:eachClassModel |			| classReference |			classReference := eachClassModel fullClassSymbol asQualifiedReference.			(eachClassModel selectorsMeta: false) do: 					[:eachSelector |					addMethodBlock value: ((MethodBlueprint new)								classReference: classReference;								selector: eachSelector;								isInstanceBehavior: true)].			(eachClassModel selectorsMeta: true) do: 					[:eachSelector |					addMethodBlock value: ((MethodBlueprint new)								classReference: classReference;								selector: eachSelector;								isInstanceBehavior: false)]].	self overriddenMethods do: 			[:each |			addMethodBlock value: ((MethodBlueprint of: each)						classReference: each implementingClass instanceBehavior absoluteName									asQualifiedReference;						isInstanceBehavior: each implementingClass isMeta not;						category: each category;						selector: each selector;						source: each source)].	^output contents</body><body package="Tools-Blueprints">namespaceBlueprints	| output |	output := Array new writeStream.	self definedNameSpaces , self overriddenNameSpaces do: 			[:each |			| blueprint |			blueprint := each asBlueprint.			blueprint package: self.			output nextPut: blueprint].	^output contents</body><body package="Tools-Blueprints">sharedVariableBlueprints	| output |	output := Array new writeStream.	self data , self overriddenStatics do: 			[:each |			| blueprint |			blueprint := each asBlueprint.			blueprint package: self.			output nextPut: blueprint].	^output contents</body></methods><methods><class-id>Store.PundleModel</class-id> <category>accessing</category><body package="Tools-Blueprints">propertyBlueprints	| output propertiesWithoutVolitileKeys |	"AR #61875 this code was modified because it was pulling in a StoreBase prerequisite, which Tools-Blueprints is not allowed to do."	propertiesWithoutVolitileKeys := properties copy.	CodeComponent volatilePropertyKeys do:		[:each |		propertiesWithoutVolitileKeys removeKey: each ifAbsent: [nil]].	output := Array new writeStream.	propertiesWithoutVolitileKeys keysAndValuesDo: 			[:propertyName :propertyValue |			| coercedValue |			propertyName = #version				ifFalse: 					[coercedValue := (propertyValue isKindOf: BlockClosure)								ifTrue: [propertyValue method getSource]								ifFalse: [propertyValue].					output nextPut: ((CodeComponentPropertyBlueprint new)								codeComponent: self;								key: propertyName;								value: coercedValue)]].	^output contents</body></methods><methods><class-id>Kernel.OverridenStatic</class-id> <category>accessing</category><body package="Tools-Blueprints">asBlueprint	| blueprint |	#defineSharedVariable:private:constant:category:initializer:		= definition selector ifFalse: [self unreachableCode].	blueprint := SharedVariableBlueprint of: self.	blueprint		reference: ((definition receiver fullyQualifiedReferenceFrom: nil)				append: definition arguments first).	blueprint isPrivate: (definition arguments at: 2).	blueprint isConstant: (definition arguments at: 3).	blueprint category: (definition arguments at: 4).	blueprint initializer: (definition arguments at: 5).	^blueprint</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>OverridenStatic</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>method </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>PundleModel</name><environment>Store</environment><super>Kernel.CodeComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbInfo readonly </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>PackageModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>models </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>BundleModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>OverridenNameSpace</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment documentation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>NameSpace</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>OverridenClass</name><environment>Kernel</environment><super>Kernel.Override</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>comment documentation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Overrides</category><attributes><package>System-Overrides</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>DatumDescriptor</name><environment>Store</environment><super>Store.PseudoRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dataKey nameSpaceName className </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-IMG-Subdefs</category><attributes><package>PackageCategories</package></attributes></class><class><name>MethodDefinition</name><environment>Tools</environment><super>Tools.GeneralMethodDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inheritingClass implementingClass selector extraText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class></st-source>