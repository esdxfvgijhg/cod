<?xml version="1.0"?><st-source><!-- Name: Debugger-Compiler-ModificationsNotice: Copyright 2003-2014 Cincom Systems, Inc.  All rights reserved.Comment: PDP Compiler modifications for VW 7.When publishing to Store, this MUST be published as BINARY.DbIdentifier: bear73DbTrace: 422402DbUsername: smichaelDbVersion: 8.0 - 1PackageName: Debugger-Compiler-ModificationsParcel: #('Debugger-Compiler-Modifications')ParcelName: Debugger-Compiler-ModificationsPrintStringCache: (8.0 - 1,smichael)Version: 8.0 - 1Date: 3:26:58 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.4) of June 23, 2017 on June 30, 2017 at 3:26:58 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><methods><class-id>Kernel.SimpleMessageNode</class-id> <category>probes</category><body package="Debugger-Compiler-Modifications">collectReferencesTo: aName in: aCollection	receiver collectReferencesTo: aName in: aCollection.	arguments do: [:arg | arg collectReferencesTo: aName in: aCollection].</body><body package="Debugger-Compiler-Modifications">jumpRecordFor: selectionRange blkIndex: blkIndex doBefore: beforeBlk doAfter: afterBlk doGotIt: gotItBlk	| i end searchBlk endCheck relativeIndex |	"Check for character index after this node."	self sourcePosition last + 1 &lt; selectionRange first		ifTrue: afterBlk.	"Check for character index before selector, may be in receiver."	sourcePosition first &gt; selectionRange first		ifTrue:			[receiver isNil				ifTrue: beforeBlk.			^receiver				jumpRecordFor: selectionRange				blkIndex: blkIndex				doBefore: beforeBlk				doAfter: gotItBlk				doGotIt: gotItBlk].	"It is in this node, now figure out where."	"First check unary and single argument messages"	arguments size &lt;= 1		ifTrue:			[selectionRange first - sourcePosition first &lt; (selector size + 1 bitShift: -1)				ifTrue: gotItBlk.			arguments size = 0				ifTrue: gotItBlk.			^arguments first				jumpRecordFor: selectionRange				blkIndex: blkIndex				doBefore: gotItBlk				doAfter: afterBlk				doGotIt: gotItBlk].	"We have a keyword message with more than 1 argument.	Check to see if the index is in the first part of the selector."	endCheck := (selector indexOf: $:) + 1.	relativeIndex := selectionRange first - sourcePosition first + 1.	endCheck &gt;= relativeIndex		ifTrue: gotItBlk.	i := 0.	end := arguments size.	searchBlk := 		[i := i + 1.		i &gt; end			ifTrue: afterBlk.		^(arguments at: i) 				jumpRecordFor: selectionRange				blkIndex: blkIndex				doBefore: gotItBlk				doAfter: searchBlk				doGotIt: gotItBlk].	^searchBlk value.</body><body package="Debugger-Compiler-Modifications">probeCascadeInfoFor: selectionRange doBefore: beforeBlk doAfter: afterBlk	| probeStartBlk probeEndBlk i end searchBlk endCheck relativeIndex |	"Check for character index after this node."	sourcePosition last + 1 &lt; selectionRange first		ifTrue: afterBlk.	"Check for character index before selector."	sourcePosition first &gt; selectionRange first		ifTrue: beforeBlk.	probeStartBlk := [^self probeRecordAtStart].	probeEndBlk := [^self probeRecordAtEnd].	"It is in this node, now figure out where."	"First check unary and single argument messages"	arguments size &lt;= 1		ifTrue:			[selectionRange first - sourcePosition first &lt; (selector size + 1 bitShift: -1)				ifTrue: probeStartBlk.			arguments size = 0				ifTrue: probeEndBlk.			^arguments first				probeInfoFor: selectionRange				doBefore: probeEndBlk				doAfter: probeEndBlk].	"We have a keyword message with more than 1 argument.	Check to see if the index is in the first part of the selector."	endCheck := (selector indexOf: $:) + 1.	relativeIndex := selectionRange first - sourcePosition first + 1.	endCheck &gt;= relativeIndex		ifTrue:			[(endCheck bitShift: -1) &gt;= relativeIndex				ifTrue: probeStartBlk				ifFalse: probeEndBlk].	i := 0.	end := arguments size.	searchBlk := 		[i := i + 1.		i &gt; end			ifTrue: probeEndBlk.		^(arguments at: i) 				probeInfoFor: selectionRange				doBefore: probeEndBlk				doAfter: searchBlk].	searchBlk value.</body><body package="Debugger-Compiler-Modifications">probeFirstExecutingNode	"If the receiver's mapEntry is nil, this is almost certainly an optimized	loop, and we want to just treat the whole loop as the node."	^receiver mapEntry == nil		ifTrue: [self]		ifFalse: [receiver probeFirstExecutingNode]</body><body package="Debugger-Compiler-Modifications">probeInfoFor: selectionRange doBefore: beforeBlk doAfter: afterBlk	| probeStartBlk probeEndBlk i end searchBlk endCheck relativeIndex |	"Check for character index after this node."	sourcePosition last + 1 &lt; selectionRange first		ifTrue: afterBlk.	probeStartBlk := [^self probeRecordAtStart].	probeEndBlk := [^self probeRecordAtEnd].	"Check for character index before selector, may be in receiver."	sourcePosition first &gt; selectionRange first		ifTrue:			[receiver isNil				ifTrue: beforeBlk.			^receiver				probeInfoFor: selectionRange				doBefore: beforeBlk				doAfter: probeStartBlk].	"It is in this node, now figure out where."	"First check unary and single argument messages"	arguments size &lt;= 1		ifTrue:			[selectionRange first - sourcePosition first &lt; (selector size + 1 bitShift: -1)				ifTrue: probeStartBlk.			arguments size = 0				ifTrue: probeEndBlk.			^arguments first				probeInfoFor: selectionRange				doBefore: probeEndBlk				doAfter: probeEndBlk].	"We have a keyword message with more than 1 argument.	Check to see if the index is in the first part of the selector."	endCheck := (selector indexOf: $:) + 1.	relativeIndex := selectionRange first - sourcePosition first + 1.	endCheck &gt;= relativeIndex		ifTrue:			[(endCheck bitShift: -1) &gt;= relativeIndex				ifTrue: probeStartBlk				ifFalse: probeEndBlk].	i := 0.	end := arguments size.	searchBlk := 		[i := i + 1.		i &gt; end			ifTrue: probeEndBlk.		^(arguments at: i) 				probeInfoFor: selectionRange				doBefore: probeEndBlk				doAfter: searchBlk].	searchBlk value.</body><body package="Debugger-Compiler-Modifications">probeRecordAtEnd	| end |	end := sourcePosition first - 1 + (arguments size &gt; 1		ifTrue: [selector indexOf: $:]		ifFalse: [(2 max: selector size)]).	^ProbeInsertionRecord		characterIndex: end		blockIndex: blockIndex		mapEntry: mapEntry		atEnd: true</body></methods><methods><class-id>Kernel.LiteralNode</class-id> <category>copying</category><body package="Debugger-Compiler-Modifications">postDcopyUsing: copyDict	"Complete the deep copy operation.  This method was placed in this class	to prevent unintended copying of literals."	sourcePosition := sourcePosition basicDcopyUsing: copyDict.	comment := comment basicDcopyUsing: copyDict.	mapEntry := mapEntry basicDcopyUsing: copyDict.</body></methods><methods><class-id>Kernel.VariableNode</class-id> <category>probes</category><body package="Debugger-Compiler-Modifications">collectReferencesTo: aName in: aCollection	name = aName		ifTrue: [aCollection add: self]</body><body package="Debugger-Compiler-Modifications">probeRecordAtEnd	mapEntry isNil		ifTrue: [^nil].	^ProbeInsertionRecord		characterIndex: self sourcePosition last		blockIndex: blockIndex		mapEntry: mapEntry		atEnd: true</body></methods><methods><class-id>Kernel.SequenceNode</class-id> <category>probes</category><body package="Debugger-Compiler-Modifications">collectReferencesTo: aName in: aCollection	statements do: [:stmt | stmt collectReferencesTo: aName in: aCollection].</body><body package="Debugger-Compiler-Modifications">jumpRecordFor: selectionRange blkIndex: blkIndex doBefore: beforeBlk doAfter: afterBlk doGotIt: gotItBlk	| betweenBlk searchBlk end i |	"Check for character index after this node."	sourcePosition last + 1 &lt; selectionRange first		ifTrue: afterBlk.	"Check for character index before selector, may be in receiver."	sourcePosition first &gt; selectionRange first		ifTrue: beforeBlk.	"Check for nil block."	sourcePosition first &gt; sourcePosition last		ifTrue:			[blockIndex == blkIndex				ifTrue: [^self probeRecordAtStart]				ifFalse: [^nil]].	"It is in this node, now figure out where."	end := statements size.	i := 0.	betweenBlk :=		[| record |		blockIndex == blkIndex			ifFalse: [^nil].		i := i - 1.		i = 0			ifTrue: [^self probeRecordAtStart].		record := (statements at: i) probeRecordAtEnd.		record isNil			ifFalse: [^record].		betweenBlk value].	searchBlk := 		[i := i + 1.		i &gt; end			ifTrue: betweenBlk.		^(statements at: i) 				jumpRecordFor: selectionRange				blkIndex: blkIndex				doBefore: betweenBlk				doAfter: searchBlk				doGotIt: betweenBlk].	^searchBlk value.</body><body package="Debugger-Compiler-Modifications">probeInfoFor: selectionRange doBefore: beforeBlk doAfter: afterBlk 	| probeStartBlk end i betweenBlk searchBlk |	"Check for character index after this node."	sourcePosition last + 1 &lt; selectionRange first		ifTrue: afterBlk.	probeStartBlk := [^self probeRecordAtStart].	"Check for character index before selector, may be in receiver."	sourcePosition first &gt; selectionRange first		ifTrue: beforeBlk.	"Check for nil block."	sourcePosition first &gt; sourcePosition last		ifTrue: [^self probeRecordAtStart].	"It is in this node, now figure out where."	end := statements size.	i := 0.	betweenBlk :=		[| record |		i := i - 1.		i = 0			ifTrue: probeStartBlk.		record := (statements at: i) probeRecordAtEnd.		record isNil			ifFalse: [^record].		betweenBlk value].	searchBlk := 		[i := i + 1.		i &gt; end			ifTrue: betweenBlk.		^(statements at: i) 				probeInfoFor: selectionRange				doBefore: betweenBlk				doAfter: searchBlk].	^searchBlk value.</body><body package="Debugger-Compiler-Modifications">probeRecordAtEnd	statements reverseDo:		[:aNode | |record|		(record := aNode probeRecordAtEnd) == nil			ifFalse: [^record]].	(returnMapEntry isNil or: [returnMapEntry key isNil])		ifTrue: [^self probeRecordAtStart].	returnMapEntry end isNil		ifTrue: [returnMapEntry end: returnMapEntry key].	^ProbeInsertionRecord		characterIndex: sourcePosition last		blockIndex: blockIndex		mapEntry: returnMapEntry		atEnd: true</body><body package="Debugger-Compiler-Modifications">probeRecordAtStart	| node |	node := self statements detect: [:nd | nd mapEntry notNil] ifNone: [].	^node == nil		ifTrue: [ProbeInsertionRecord			characterIndex: (sourcePosition first min: sourcePosition last)			blockIndex: blockIndex			mapEntry: mapEntry			atEnd: false]		ifFalse: [node probeFirstExecutingNode probeRecordAtStart]</body></methods><methods><class-id>Kernel.MethodNode</class-id> <category>probes</category><body package="Debugger-Compiler-Modifications">collectReferencesTo: aName	| collection |	collection := OrderedCollection new.	block collectReferencesTo: aName in: collection.	^collection</body><body package="Debugger-Compiler-Modifications">emptyMethodProbeRecord	| end |	end := block arguments size &gt; 1		ifTrue: [selector indexOf: $:]		ifFalse: [(2 max: selector size)].	^ProbeInsertionRecord		characterIndex: end		blockIndex: self blockIndex		mapEntry: mapEntry		atEnd: false</body><body package="Debugger-Compiler-Modifications">jumpRecordFor: selectionRange blkIndex: blkIndex	block isEmpty		ifTrue: [^self emptyMethodProbeRecord].	^block jumpRecordFor: selectionRange blkIndex: blkIndex</body><body package="Debugger-Compiler-Modifications">probeRecordAtStart	block isEmpty		ifTrue: [^self emptyMethodProbeRecord].	^block body probeRecordAtStart</body><body package="Debugger-Compiler-Modifications">probeRecordFor: selectionRange	block isEmpty		ifTrue: [^self emptyMethodProbeRecord].	^block probeRecordFor: selectionRange</body></methods><methods><class-id>Kernel.LocalVariable</class-id> <category>accessing</category><body package="Debugger-Compiler-Modifications">nesting	^scope</body></methods><methods><class-id>Kernel.MessageNode</class-id> <category>probes</category><body package="Debugger-Compiler-Modifications">jumpRecordFor: selectionRange blkIndex: blkIndex doBefore: beforeBlk doAfter: afterBlk doGotIt: gotItBlk	| i end searchBlk endCheck relativeIndex checkBlk |	"Check for character index after this node."	self sourcePosition last + 1 &lt; selectionRange first		ifTrue: afterBlk.	"Check for character index before selector, may be in receiver."	checkBlk :=		[:record |		record == nil			ifTrue: [^nil].		blockIndex == blkIndex			ifFalse: [^record].		^(self isExpanded and: [(expansion isKindOf: ConditionalNode) not])			ifTrue: gotItBlk			ifFalse: [record]].	sourcePosition first &gt; selectionRange first		ifTrue:			[receiver isNil				ifTrue: beforeBlk.			checkBlk value: (receiver				jumpRecordFor: selectionRange				blkIndex: blkIndex				doBefore: beforeBlk				doAfter: gotItBlk				doGotIt: gotItBlk)].	"It is in this node, now figure out where."	"First check unary and single argument messages"	arguments size &lt;= 1		ifTrue:			[selectionRange first - sourcePosition first &lt; (selector size + 1 bitShift: -1)				ifTrue: gotItBlk.			arguments size = 0				ifTrue: afterBlk.			checkBlk value: (arguments first				jumpRecordFor: selectionRange				blkIndex: blkIndex				doBefore: gotItBlk				doAfter: afterBlk				doGotIt: gotItBlk)].	"We have a keyword message with more than 1 argument.	Check to see if the index is in the first part of the selector."	endCheck := (selector indexOf: $:) + 1.	relativeIndex := selectionRange first - sourcePosition first + 1.	endCheck &gt;= relativeIndex		ifTrue: gotItBlk.	i := 0.	end := arguments size.	searchBlk := 		[i := i + 1.		i &gt; end			ifTrue: afterBlk.		checkBlk value: ((arguments at: i) 				jumpRecordFor: selectionRange				blkIndex: blkIndex				doBefore: gotItBlk				doAfter: searchBlk				doGotIt: gotItBlk)].	^searchBlk value.</body></methods><methods><class-id>Kernel.ProgramNode</class-id> <category>probes</category><body package="Debugger-Compiler-Modifications">collectReferencesTo: aName in: aCollection</body><body package="Debugger-Compiler-Modifications">probeFirstExecutingNode	^self</body><body package="Debugger-Compiler-Modifications">probeRecordAtEnd	self error: (#ErrorRecordAtEndMessage &lt;&lt; #pdp &gt;&gt; 'Internal error - please report as probeRecordAtEnd condition').</body><body package="Debugger-Compiler-Modifications">probeRecordAtStart	^ProbeInsertionRecord		characterIndex: self sourcePosition first		blockIndex: blockIndex		mapEntry: mapEntry		atEnd: false</body></methods><methods><class-id>Kernel.BlockNode</class-id> <category>probes</category><body package="Debugger-Compiler-Modifications">collectReferencesTo: aName in: aCollection	body collectReferencesTo: aName in: aCollection</body><body package="Debugger-Compiler-Modifications">jumpRecordFor: selectionRange blkIndex: blkIndex	^body		jumpRecordFor: selectionRange		blkIndex: blkIndex		doBefore: [^body probeRecordAtStart]		doAfter: [^nil]		doGotIt: [^nil]</body><body package="Debugger-Compiler-Modifications">jumpRecordFor: selectionRange blkIndex: blkIndex doBefore: beforeBlk doAfter: afterBlk doGotIt: gotItBlk	"Check for character index after this node."	sourcePosition last &lt; selectionRange first		ifTrue: afterBlk.	"Check for character index before selector, may be in receiver."	sourcePosition first &gt; selectionRange first		ifTrue: beforeBlk.	^body		jumpRecordFor: selectionRange		blkIndex: blkIndex		doBefore: [body blockIndex == blkIndex						ifTrue: [^body probeRecordAtStart]						ifFalse: [^nil]]		doAfter: [body blockIndex == blkIndex						ifTrue: [^body probeRecordAtEnd]						ifFalse: [^nil]]		doGotIt: gotItBlk.</body><body package="Debugger-Compiler-Modifications">probeInfoFor: selectionRange doBefore: beforeBlk doAfter: afterBlk	| probeStartBlk probeEndBlk |	"Check for character index after this node."	sourcePosition last &lt; selectionRange first		ifTrue: afterBlk.	probeStartBlk := [^body probeRecordAtStart].	probeEndBlk := [^body probeRecordAtEnd].	"Check for character index before selector, may be in receiver."	sourcePosition first &gt; selectionRange first		ifTrue: beforeBlk.	"If there is an empty selection immediately preceding the block's	[ character, or if the [ is the first character in the selection, we	will take this as a special case where the block is being selected	as a literal rather than selecting a statement inside the block.	This trick is not possible if the block is optimized."	(sourcePosition first = selectionRange first and: [self mapEntry notNil])		ifTrue: [^super probeRecordAtStart].	^body		probeInfoFor: selectionRange		doBefore: probeStartBlk		doAfter: probeEndBlk.</body><body package="Debugger-Compiler-Modifications">probeRecordAtEnd	^ProbeInsertionRecord		characterIndex: sourcePosition last		blockIndex: blockIndex		mapEntry: mapEntry		atEnd: true</body><body package="Debugger-Compiler-Modifications">probeRecordAtStart	^ProbeInsertionRecord		characterIndex: sourcePosition first		blockIndex: blockIndex		mapEntry: mapEntry		atEnd: false</body><body package="Debugger-Compiler-Modifications">probeRecordFor: selectionRange 	^body		probeInfoFor: selectionRange		doBefore: [^body probeRecordAtStart]		doAfter: [^body probeRecordAtEnd]</body></methods><methods><class-id>Kernel.AssignmentNode</class-id> <category>probes</category><body package="Debugger-Compiler-Modifications">collectReferencesTo: aName in: aCollection	variable collectReferencesTo: aName in: aCollection.	value collectReferencesTo: aName in: aCollection.</body><body package="Debugger-Compiler-Modifications">jumpRecordFor: selectionRange blkIndex: blkIndex doBefore: beforeBlk doAfter: afterBlk doGotIt: gotItBlk	"Check for character index after this node."	sourcePosition last + 1 &lt; selectionRange first		ifTrue: afterBlk.	"Check for character index before operator, may be in variable."	sourcePosition first &gt; selectionRange first		ifTrue:			[^variable				jumpRecordFor: selectionRange				blkIndex: blkIndex				doBefore: beforeBlk				doAfter: gotItBlk				doGotIt: gotItBlk].	selectionRange first = sourcePosition first		ifTrue: gotItBlk.	selectionRange first &lt;= (sourcePosition first + 2)		ifTrue: gotItBlk.	"It is in this node, check the value node."	^value		jumpRecordFor: selectionRange		blkIndex: blkIndex		doBefore: gotItBlk		doAfter: afterBlk		doGotIt: gotItBlk</body><body package="Debugger-Compiler-Modifications">probeFirstExecutingNode	^value probeFirstExecutingNode</body><body package="Debugger-Compiler-Modifications">probeInfoFor: selectionRange doBefore: beforeBlk doAfter: afterBlk	"The probe placement rules for an assignment are a little	inconsistent.  We treat the assignemt operator like a message	which is akin to postfix whereas assignment is an infix operator.	So, if the selection point is at the beginning of the operator then	the probe is inserted before the assignment operation and if it is	at the end then the probe is inserted after the operation.  Additionally,	we need to examine what to do if the value cannot determine where	to put the probe."	| probeStartBlk probeEndBlk |	"Check for character index after this node."	sourcePosition last + 1 &lt; selectionRange first		ifTrue: afterBlk.	probeStartBlk := [^self probeRecordAtStart].	probeEndBlk := [^self probeRecordAtEnd].	"Check for character index before operator, may be in variable."	sourcePosition first &gt; selectionRange first		ifTrue:			[^variable				probeInfoFor: selectionRange				doBefore: beforeBlk				doAfter: probeStartBlk].	selectionRange first = sourcePosition first		ifTrue: probeStartBlk.	selectionRange first &lt;= (sourcePosition first + 2)		ifTrue: probeEndBlk.	"It is in this node, check the value node."	^value		probeInfoFor: selectionRange		doBefore: probeEndBlk		doAfter: probeEndBlk</body><body package="Debugger-Compiler-Modifications">probeRecordAtEnd	^ProbeInsertionRecord		characterIndex: sourcePosition first + 1		blockIndex: blockIndex		mapEntry: mapEntry		atEnd: true</body><body package="Debugger-Compiler-Modifications">probeRecordAtStart	^ProbeInsertionRecord		characterIndex: sourcePosition first		blockIndex: blockIndex		mapEntry: mapEntry		atEnd: false</body></methods><methods><class-id>Kernel.LocalScope</class-id> <category>accessing</category><body package="Debugger-Compiler-Modifications">addVariable: aVar named: aName	variables == nil ifTrue: [self initVariables].	variables at: aName put: aVar.	variableList addLast: aName -&gt; aVar</body><body package="Debugger-Compiler-Modifications">allInstVarNames	| names ivars |	ivars := self instanceVariables.	names := OrderedCollection new: ivars size.	ivars do: [:ac | names add: ac key].	^names</body></methods><methods><class-id>Kernel.LocalScope</class-id> <category>private</category><body package="Debugger-Compiler-Modifications">basicGetInstanceVariables	| ivars |	ivars := SortedCollection sortBlock: [:a :b | a value index &lt; b value index].	variables associationsDo: [:ac | ac value class == InstanceVariable ifTrue: [ivars add: ac]].	^ivars</body></methods><methods><class-id>Kernel.LocalScope</class-id> <category>accessing</category><body package="Debugger-Compiler-Modifications">instanceVariables	outerScope class == LocalScope		ifFalse: [^self basicGetInstanceVariables].	^outerScope instanceVariables</body></methods><methods><class-id>Kernel.LeafNode</class-id> <category>probes</category><body package="Debugger-Compiler-Modifications">jumpRecordFor: selectionRange blkIndex: blkIndex doBefore: beforeBlk doAfter: afterBlk doGotIt: gotItBlk	"The default action is to determine if selectionRange is within the receiver,	and if it is to return no pc.  Subclasses may override."	"Check for character index after this node."	self sourcePosition last + 1 &lt; selectionRange first		ifTrue: afterBlk.	"Check for character index before this node."	self sourcePosition first &gt; selectionRange first		ifTrue: beforeBlk.	gotItBlk value.</body><body package="Debugger-Compiler-Modifications">probeInfoFor: selectionRange doBefore: beforeBlk doAfter: afterBlk 	"The default action is to determine if selectionRange is within the receiver,	and if it is to return no pc.  Subclasses may override."	self sourcePosition last + 1 &lt; selectionRange first		ifTrue: afterBlk.	"Check for character index before this node."	(mapEntry isNil or: [self sourcePosition first &gt; selectionRange first])		ifTrue: beforeBlk.	"Determine if selection is at beginning or end."	selectionRange first &lt; (self sourcePosition first + self sourcePosition last + 2 bitShift: -1)		ifTrue: [^self probeRecordAtStart].	^self probeRecordAtEnd</body><body package="Debugger-Compiler-Modifications">probeRecordAtEnd	mapEntry isNil		ifTrue: [^nil].	^ProbeInsertionRecord		characterIndex: self sourcePosition last		blockIndex: blockIndex		mapEntry: mapEntry		atEnd: true</body></methods><methods><class-id>Kernel.ReturnNode</class-id> <category>probes</category><body package="Debugger-Compiler-Modifications">collectReferencesTo: aName in: aCollection		value collectReferencesTo: aName in: aCollection.</body><body package="Debugger-Compiler-Modifications">jumpRecordFor: selectionRange blkIndex: blkIndex doBefore: beforeBlk doAfter: afterBlk doGotIt: gotItBlk	"Check for character index after this node."	sourcePosition last + 1 &lt; selectionRange first		ifTrue: afterBlk.	"Check for character index before operator, may be in variable."	sourcePosition first &gt; selectionRange first		ifTrue: beforeBlk.	"It is in this node, check the value node."	"Even if the selectionRange occurs after the value we break before	the return because a break after the return would never be hit."	^value		jumpRecordFor: selectionRange		blkIndex: blkIndex		doBefore: gotItBlk		doAfter: gotItBlk		doGotIt: gotItBlk</body><body package="Debugger-Compiler-Modifications">probeFirstExecutingNode	^value probeFirstExecutingNode</body><body package="Debugger-Compiler-Modifications">probeInfoFor: selectionRange doBefore: beforeBlk doAfter: afterBlk 	| probeStartBlk |	"Check for character index after this node."	sourcePosition last + 1 &lt; selectionRange first		ifTrue: afterBlk.	probeStartBlk := [^self probeRecordAtStart].	"Check for character index before operator, may be in variable."	sourcePosition first &gt; selectionRange first		ifTrue: beforeBlk.	"It is in this node, check the value node."	"Even if the selectionRange occurs after the value we break before	the return because a break after the return would never be hit."	^value		probeInfoFor: selectionRange		doBefore: probeStartBlk		doAfter: probeStartBlk</body><body package="Debugger-Compiler-Modifications">probeRecordAtEnd	^self probeRecordAtStart</body></methods><methods><class-id>Kernel.NameScope</class-id> <category>accessing</category><body package="Debugger-Compiler-Modifications">outerScope	^outerScope</body><body package="Debugger-Compiler-Modifications">temps	^outerScope temps</body></methods><methods><class-id>Kernel.MethodNodeHolder</class-id> <category>copying</category><body package="Debugger-Compiler-Modifications">postDcopyUsing: copyDict	"Complete the deep copy operation."	sourceInfo := sourceInfo basicDcopyUsing: copyDict.	methodNode := methodNode basicDcopyUsing: copyDict.</body></methods><methods><class-id>Kernel.MethodNodeHolder</class-id> <category>accessing</category><body package="Debugger-Compiler-Modifications">visibleSourceMap	^sourceInfo collect: [:info | info visibleMap]</body></methods><methods><class-id>Kernel.CascadeNode</class-id> <category>probes</category><body package="Debugger-Compiler-Modifications">collectReferencesTo: aName in: aCollection	receiver collectReferencesTo: aName in: aCollection.	messages do: [:aMsg | aMsg collectReferencesTo: aName in: aCollection]</body><body package="Debugger-Compiler-Modifications">jumpRecordFor: selectionRange blkIndex: blkIndex doBefore: beforeBlk doAfter: afterBlk doGotIt: gotItBlk	| end i searchBlk record |	"Check for character index after this node."	sourcePosition last + 1 &lt; selectionRange first		ifTrue: afterBlk.	"Check for character index before selector, may be in receiver."	sourcePosition first &gt; selectionRange first		ifTrue:			[^receiver				jumpRecordFor: selectionRange				blkIndex: blkIndex				doBefore: beforeBlk				doAfter: gotItBlk				doGotIt: gotItBlk].	"It is in this node, now figure out where."	end := messages size.	i := 0.	searchBlk := 		[i := i + 1.		i &gt; end			ifTrue: gotItBlk.		record := (messages at: i) 				jumpRecordFor: selectionRange				blkIndex: blkIndex				doBefore: gotItBlk				doAfter: searchBlk				doGotIt: gotItBlk.		"First allow for caret in another block."		record == nil			ifTrue: [^nil].		blockIndex == blkIndex			ifFalse: [^record].		"In this node, must set to start of first message."		gotItBlk value].	^searchBlk value</body><body package="Debugger-Compiler-Modifications">probeFirstExecutingNode	^receiver probeFirstExecutingNode</body><body package="Debugger-Compiler-Modifications">probeInfoFor: selectionRange doBefore: beforeBlk doAfter: afterBlk	|  probeStartBlk end i betweenBlk searchBlk |	"Check for character index after this node."	sourcePosition last + 1 &lt; selectionRange first		ifTrue: afterBlk.	probeStartBlk := [^messages first probeRecordAtStart].	"Check for character index before selector, may be in receiver."	sourcePosition first &gt; selectionRange first		ifTrue:			[^receiver				probeInfoFor: selectionRange				doBefore: beforeBlk				doAfter: probeStartBlk].	"It is in this node, now figure out where."	end := messages size.	i := 0.	betweenBlk :=		[| record |		i := i - 1.		i = 0			ifTrue: probeStartBlk.		record := (messages at: i) probeRecordAtEnd.		record isNil			ifFalse: [^record].		betweenBlk value].	searchBlk := 		[i := i + 1.		i &gt; end			ifTrue: betweenBlk.		^(messages at: i) 				probeCascadeInfoFor: selectionRange				doBefore: betweenBlk				doAfter: searchBlk].	^searchBlk value</body><body package="Debugger-Compiler-Modifications">probeRecordAtEnd	mapEntry isNil		ifTrue: [^nil].	^ProbeInsertionRecord		characterIndex: self sourcePosition last		blockIndex: blockIndex		mapEntry: mapEntry		atEnd: true</body><body package="Debugger-Compiler-Modifications">probeRecordAtStart	^messages first probeRecordAtStart</body></methods><methods><class-id>Kernel.DeferredStaticScope</class-id> <category>accessing</category><body package="Debugger-Compiler-Modifications">tempNames	^outerScope tempNames</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>MethodNodeHolder</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodNode compiledMethod sourceInfo </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Support</category><attributes><package>System-Compiler-Support</package></attributes></class><class><name>ProgramNode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourcePosition comment compilerHints blockIndex mapEntry returnMapEntry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>LeafNode</name><environment>Kernel</environment><super>Kernel.ValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>VariableNode</name><environment>Kernel</environment><super>Kernel.LeafNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name read </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>CascadeNode</name><environment>Kernel</environment><super>Kernel.ValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver messages </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>AssignmentNode</name><environment>Kernel</environment><super>Kernel.ValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variable value leftArrow assignToArgOK </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>BlockNode</name><environment>Kernel</environment><super>Kernel.LeafNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arguments body </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>MethodNode</name><environment>Kernel</environment><super>Kernel.ProgramNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector primitive primitiveErrorCode primitiveModule primitiveSourcePosition block attributeMessages </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>NameScope</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outerScope </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Names and Scopes</category><attributes><package>System-Compiler-Names and Scopes</package></attributes></class><class><name>DeferredStaticScope</name><environment>Kernel</environment><super>Kernel.NameScope</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Names and Scopes</category><attributes><package>System-Compiler-Names and Scopes</package></attributes></class><class><name>LocalVariable</name><environment>Kernel</environment><super>Kernel.VariableDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scope index read savedVar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Names and Scopes</category><attributes><package>System-Compiler-Names and Scopes</package></attributes></class><class><name>ReturnNode</name><environment>Kernel</environment><super>Kernel.StatementNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>LiteralNode</name><environment>Kernel</environment><super>Kernel.LeafNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>SimpleMessageNode</name><environment>Kernel</environment><super>Kernel.ValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver selector arguments precedence </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>MessageNode</name><environment>Kernel</environment><super>Kernel.SimpleMessageNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expanded expansion </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>SequenceNode</name><environment>Kernel</environment><super>Kernel.ValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>temporaries statements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>LocalScope</name><environment>Kernel</environment><super>Kernel.NameScope</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variables nesting variableList permitDuplicateNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Names and Scopes</category><attributes><package>System-Compiler-Names and Scopes</package></attributes></class></st-source>