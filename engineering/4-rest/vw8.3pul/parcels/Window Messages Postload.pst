<?xml version="1.0"?><st-source><!-- Name: Window Messages PostloadNotice: Copyright 1988-2014 Cincom Systems, Inc.  All rights reserved.Comment: This parcel contains event queue class extensions to start Windows message handling for ActiveX widgetsDbIdentifier: bear73DbTrace: 429502DbUsername: aaugustinDbVersion: 8.0 - 2DevelopmentPrerequisites: #(#(#any 'Window Messages' ''))DialectVersion: VisualWorks 7.9PackageName: Window Messages PostloadParcel: #('Window Messages Postload')ParcelName: Window Messages PostloadPrerequisiteDescriptions: #(#(#name 'Window Messages' #componentType #package))PrerequisiteParcels: #(#('Window Messages' ''))PrintStringCache: (8.0 - 2,aaugustin)Version: 8.0 - 2Post-Load Block: 	[:package | 	OSSystemSupport installSystemSupportOn: OSSystemSupport currentPlatform]Date: 2:00:22 PM May 22, 2015 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.1 (may15.4) of May 22, 2015 on May 22, 2015 at 2:00:22 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><shared-variable><name>ResizeEvents</name><environment>UI.WindowManager</environment><private>false</private><constant>false</constant><category>registry</category><initializer>OrderedCollection new</initializer><attributes><package>Window Messages Postload</package></attributes></shared-variable><methods><class-id>UI.EventQueue</class-id> <category>accessing</category><body package="Window Messages Postload">nextPut: value 	"Send value through the receiver.  If a Process has been suspended waiting to 	receive a value through the receiver, allow it to proceed."	[accessProtect critical: 		[self nextPutWithPriority: value.		readSynch signal]] valueUninterruptably.	^value</body><body package="Window Messages Postload">nextPut: value collapse: isCollapse 	"Send value through the receiver. If a Process has been suspended waiting to 	receive a value through the receiver, allow it to proceed. 	isCollapse is a boolean indicating whether we should collapse the new value 	with the last one in the queue or not."	| oldValue doSignal |	doSignal := true.	[accessProtect critical: 		[(isCollapse not or: [contents isEmpty]) ifFalse: 			[oldValue := contents last.			(oldValue class == value class and: [oldValue window == value window]) ifTrue: 				[contents removeLast.				doSignal := false]].			self nextPutWithPriority: value]] valueUninterruptably.	doSignal ifTrue: [readSynch signal].	^value</body></methods><methods><class-id>UI.WindowManager</class-id> <category>event processing</category><body package="Window Messages Postload">processDamageEvents	"We retrieve all expose events and merge them together if the class and window are the same. The rectangle areas of the events are merged	 so that we have only one event with a maximum rectangle area, that contains all areas that should be redrawn. This causes that we need to dispatch	 only that single event instead of multiple events. Multiple events normally produces flickering during resizing a window."		[| exposeEvents |	exposeEvents := self				removeAllEventsSatisfying: [:each | each isExposeEvent].	[exposeEvents notEmpty] whileTrue: 			[| nextEvent otherEvents |			nextEvent := exposeEvents removeFirst.			otherEvents := exposeEvents select: [:each | each sameAs: nextEvent].			exposeEvents removeAll: otherEvents.			otherEvents				do: [:each | nextEvent rectangle: (nextEvent rectangle merge: each rectangle)].			nextEvent dispatch]]			valueUnpreemptively</body></methods><methods><class-id>UI.WindowManager</class-id> <category>scheduling</category><body package="Window Messages Postload">scheduleWindow: window	windows addFirst: window.	(windows size = 1 and: [baseProcess notNil])		ifTrue: 			[baseProcess				name: ((window label isNil or: [window label asString isEmpty])						ifTrue: [window class fullName]						ifFalse: [window label asString])].	window windowManager: self.	window isModalDialog ifTrue: [self scheduleModalWindow: window].	WindowMessage concreteClass register: window</body><body package="Window Messages Postload">unscheduleWindow: window	| windowController |	window isModalDialog ifTrue: [self unscheduleModalWindow: window].	windows remove: window ifAbsent: [].	window releaseWindowManager.	WindowMessage concreteClass unregister: window.	windowController := window controller.	activeController = windowController ifTrue: [activeController := nil].	(ScheduledWindow hasNoScheduledWindows		and: [(windowController isKindOf: ApplicationDialogController) not])			ifTrue: [NoWindowBlock ifNotNil: [NoWindowBlock value: self]].	self queueDeferredEmptyCheck.</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>EventQueue</name><environment>UI</environment><super>Core.SharedQueue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events-Support</category><attributes><package>Interface-Events-Support</package></attributes></class><class><name>WindowManager</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>windows activeController interruptLock outstandingMetaOrDamage openInProgress eventQueue baseProcess dontFilterEvents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class></st-source>