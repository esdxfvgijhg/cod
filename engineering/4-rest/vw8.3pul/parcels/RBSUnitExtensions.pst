<?xml version="1.0"?><st-source><!-- Name: RBSUnitExtensionsNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: This package adds an extension to the Source code tool.  Whenever the selection includes one or more test cases, it displays a UI that shows the number of tests selected and lets you run those test cases from the browser.Remarks on some particular points===========================Inheritance of tests:  if a test case class is defined in a selected pundle, the tool counts the tests whose methods are defined in that pundle, and also any tests that class inherits from superclasses.  If a test case class is extended in a selected pundle, the tool counts the tests whose methods are defined in that pundle, and any tests that the class inherites from superclasses and that are also defined in that pundle.  A test only ever appears once in a given selection:  it is possible that a test defined in an extended superclass of an extended subclass could appear and be run when the extending pundle (only) was selected, and be rerun when the subclass' defining pundle was selected, but it would only be run once if both were selected.Pluggable TestSuites and TestResults:  use TestCase class>>suiteClass: to plug in a more specific TestSuite class.  For an example of how TestResult subclasses may be plugged in and written by tests instead of, or as well as, the above, see TestSkip and references in that parcel and in SUnitResourcePatternTests.  See the comment in SUnit for more information.DbIdentifier: bear73DbTrace: 502577DbUsername: nrossDbVersion: 8.3 - 4DevelopmentPrerequisites: #(#(#any 'Browser-BrowserUI' '') #(#any 'SUnit' ''))PackageName: RBSUnitExtensionsParcel: #('RBSUnitExtensions')ParcelName: RBSUnitExtensionsPrerequisiteParcels: #(#('Browser-BrowserUI' '') #('SUnit' ''))PrintStringCache: (8.3 - 4,nross)Version: 8.3 - 4Post-Load Block: 	[:package | Transcript cr; show: 'Newly opened browsers will have the SUnitStatusBar in them']Date: 11:29:10 AM June 16, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.3) of June 16, 2017 on June 16, 2017 at 11:29:10 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SUnitStatusBar</name><environment>Refactory.Browser</environment><super>Graphics.CompositePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testCount result codeModel isVisible color </inst-vars><class-inst-vars></class-inst-vars><imports>			private XProgramming.SUnit.*			</imports><category>Browser-Code Tools</category><attributes><package>RBSUnitExtensions</package></attributes></class><comment><class-id>Refactory.Browser.SUnitStatusBar</class-id><body>This adds a panel to the Refactoring Browser CodeTool.  The tool allows Run, Debug, or Profile of concrete subclasses of TestCase, by single or multi-select of individual test selectors, classes, protocols, packages, parcels or categories.The tool obeys the #isAbstract and #shouldInheritSelectors directives on individual test classes, allowing a concrete class to inherit either all or none of the test selectors in its superclass hierarchy (up to, but not including TestCase).  The directive #shouldInheritSelectors is ignored for abstract test cases, since their test selectors cannot be run directly from the abstract class.  Inherited test selectors, if not overridden and if not defined in a selected extending package, are included if the class' defining package is selected. Instance Variables	codeModel		&lt;CodeModel&gt;	the code model of the tool to which this is added	result			&lt;TestResult&gt;	the result returned by the latest run	testCount		&lt;Integer&gt;		the number of tests remaining to run</body></comment><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>initialize-release</category><body package="RBSUnitExtensions">actionDriver: anActionSelector	^(PluggableAdaptor on: false asValue)		getBlock: [:m | m value]		putBlock: [:m :v | self perform: anActionSelector]		updateBlock: [:m :a :p | true]</body><body package="RBSUnitExtensions">addButtons	| button |	#(#runDefects #listDefects #profileTests #debugTests #runTests) with: #('Run Defects' 'List Defects' 'Profile' 'Debug' 'Run') do: [ :action :label | 		button := UILookPolicy new actionButtonClass model: (self actionDriver: action).		button labelString: action &gt;&gt; label &lt;&lt; #browser.		self addWrapper: (BoundedWrapper on: button)	].	self children last bottomComponent beDefault</body><body package="RBSUnitExtensions">addLabel	self addWrapper: (BoundedWrapper on: (UILookPolicy new passiveLabelClass new))</body><body package="RBSUnitExtensions">codeModel: aCodeModel	codeModel := aCodeModel</body><body package="RBSUnitExtensions">initialize	super initialize.	isVisible := false.	self addLabel.	self addButtons.</body></methods><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>private</category><body package="RBSUnitExtensions">canHaveTests: aClass	^TestCase canHaveTests: aClass</body><body package="RBSUnitExtensions">classTestCases	"Answer all runnable test cases for the selected class or classes.  Since object names are ordered in NavigatorState (for normal modes of populating at least, regardless of the order the user selects them in the RB UI), these tests will be in class alphabetic order if selected in an alphabetically-ordered pane and in hierarchic order if selected in a hierarchic pane;  either way, the order will be the same as that presented to the user, which seems correct)."	^self testCasesFor: codeModel selectedClasses.</body><body package="RBSUnitExtensions">protocolTestCases	"Answer all runnable test cases for the selected protocol or protocols."	| theClass protocolSelectors |	theClass := codeModel selectedClass.	theClass ifNil: [^OrderedCollection new].	(self canHaveTests: theClass) ifFalse: [^OrderedCollection new].	protocolSelectors := codeModel protocols inject: Set new into:		[:sum :protocol |		sum addAll: (codeModel environment selectorsFor: protocol in: theClass).		theClass shouldInheritSelectors ifTrue: 			[| pivot | pivot := theClass.			[pivot == pivot lookupHierarchyRoot] whileFalse:				[pivot := pivot superclass.				sum addAll: (codeModel environment selectorsFor: protocol in: pivot)]].		sum].	^(self testCasesFor: (Array with: theClass))		select: [:each | protocolSelectors includes: each selector]</body><body package="RBSUnitExtensions">pundleTestCases	"Show all inherited test cases of defined classes and all directly defined test cases whose methods are defined by the selected pundles or are inherited from a method defined in the same pundle.  Present tests in the order in which they appear to the user, i.e. sorted by class name and selector name."	| testCases |	testCases := Set new.	codeModel pundles		do: [:eachPundle | testCases addAll: eachPundle xpsuTestCases].	^testCases asSortedCollection</body><body package="RBSUnitExtensions">pundleTestCasesExist	"Answer if runnable test cases exist in classes in the selected pundle or pundles."	^codeModel pundles anySatisfy: [:any | any hasXPSUTestCases]</body><body package="RBSUnitExtensions">selectorTestCases	"Answer all runnable test cases for the selected selectors.  (For RB performance, we drop out if the class of the first selected method is not a concrete test class, but if it is, we get the tests for all classes.)"	| classesAndAllTestSelectors |	(self canHaveTests: codeModel selectedClass) ifFalse: [^OrderedCollection new].	classesAndAllTestSelectors := IdentityDictionary new.	^(codeModel definitions select:		[:each |		each isForSharedVariable not and:			[each method notNil and:				[(classesAndAllTestSelectors					at: each inheritingClass					ifAbsentPut:						[(self canHaveTests: each inheritingClass)							ifFalse: [#()]							ifTrue: [each inheritingClass allTestSelectors]])					includes: each selector]]])		collect: [:each | each inheritingClass selector: each selector]</body><body package="RBSUnitExtensions">setFailedLabel	self setTestLabel: (#Failed &lt;&lt; #browser &gt;&gt; 'Failed').	self updateForFailed</body><body package="RBSUnitExtensions">setLabelColor: aColorValue	color := aColorValue</body><body package="RBSUnitExtensions">setPassedLabel	self setTestLabel: (#Passed &lt;&lt; #browser &gt;&gt; 'Passed').	self updateForPassed</body><body package="RBSUnitExtensions">testCases	codeModel selector notNil ifTrue: [^self selectorTestCases].	codeModel protocol notNil ifTrue: [^self protocolTestCases].	codeModel selectedClass notNil ifTrue: [^self classTestCases].	codeModel pundle notNil ifTrue: [^self pundleTestCases].	^#()</body><body package="RBSUnitExtensions">testCasesFor: classesCollection	"Show all inherited test cases of classes defined in the selected pundles and all directly defined test cases whose methods are defined by the selected pundles or are inherited from a method defined in the same pundle.  Present tests in the order in which they appear to the user, i.e. sorted by class name (caller povides list in that order) and selector name."	| testCases leaves |	testCases := Set new.	leaves := codeModel pundles inject: Set new into:		[:set :each | set addAll: each leafItems; yourself].	classesCollection do:		[:eachClass |		(self canHaveTests: eachClass) ifTrue:			[leaves do:				[:eachLeaf |				(eachLeaf definesClass: eachClass)					ifTrue:						[eachLeaf addXPSUTestCasesForDefinedClass: eachClass to: testCases]					ifFalse:						[(eachLeaf extendsClass: eachClass)							ifTrue: [eachLeaf addXPSUTestCasesForExtendedClass: eachClass to: testCases]]]]].	^testCases asSortedCollection</body><body package="RBSUnitExtensions">updateForAbstract	self setLabelColor: nil</body><body package="RBSUnitExtensions">updateForFailed	self setLabelColor: ColorValue red</body><body package="RBSUnitExtensions">updateForNotRun	self setLabelColor: nil</body><body package="RBSUnitExtensions">updateForPassed	self setLabelColor: ColorValue green.	result := nil.</body></methods><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>testing</category><body package="RBSUnitExtensions">canRunTests	^self isAbstractClassSelected not and: [self testCasesExist]</body><body package="RBSUnitExtensions">codeComponentIncludesTest: aCodeComponent 	^aCodeComponent definedClasses anySatisfy: [:each | each inheritsFrom: TestCase]</body><body package="RBSUnitExtensions">defectsExist	^result notNil and: [result hasPassed not]</body><body package="RBSUnitExtensions">hasTestsSelected	(codeModel selectedClasses 		anySatisfy: [:each | each inheritsFrom: TestCase]) ifTrue: [^true].	codeModel objectNames notEmpty ifTrue: [^false].	(codeModel parcels 		anySatisfy: [:each | self codeComponentIncludesTest: each]) ifTrue: [^true].	^codeModel pundles 		anySatisfy: [:each | self codeComponentIncludesTest: each]</body><body package="RBSUnitExtensions">isAbstractClassSelected	^codeModel selectedClass notNil		and:			[(codeModel selectedClass respondsTo: #isAbstract)				and: [codeModel selectedClass isAbstract]]</body><body package="RBSUnitExtensions">isProfilerLoaded	#{TimeProfiler} valueOrDo: [^false].	^true</body><body package="RBSUnitExtensions">shouldNotRunTests	^self canRunTests not</body><body package="RBSUnitExtensions">testCasesExist	codeModel selector notNil ifTrue: [^self selectorTestCases notEmpty].	codeModel protocol notNil ifTrue: [^self protocolTestCases notEmpty].	codeModel selectedClass notNil ifTrue: [^self classTestCases notEmpty].	codeModel pundle notNil ifTrue: [^self pundleTestCasesExist].	^false</body></methods><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>updating</category><body package="RBSUnitExtensions">debugButton	^(self children at: 5) bottomComponent</body><body package="RBSUnitExtensions">listDefectsButton	^(self children at: 3) bottomComponent</body><body package="RBSUnitExtensions">profileButton	^(self children at: 4) bottomComponent</body><body package="RBSUnitExtensions">runButton	^(self children at: 6) bottomComponent</body><body package="RBSUnitExtensions">runDefectsButton	^(self children at: 2) bottomComponent</body><body package="RBSUnitExtensions">setTestLabel: aString	self labelWidget labelString: aString.	self labelWidget invalidateIntrinsicContentSize.</body><body package="RBSUnitExtensions">touch	self		updateTestLabel;		updateButtons;		updateIsActive</body><body package="RBSUnitExtensions">update: aspectSymbol with: parameter from: sender	(testCount notNil and: [testCount &gt; 0]) ifTrue:		[testCount := testCount - 1.		self setTestLabel: ((#TestsRemaining1p &lt;&lt; #browser &gt;&gt; 'Tests Remaining : &lt;1p&gt;') expandMacrosWith: testCount).		self labelWidget repairDamage].</body><body package="RBSUnitExtensions">updateButtons	self		updateRunButtons;		updateDefectButtons</body><body package="RBSUnitExtensions">updateDefectButtons	| enable |	enable := self defectsExist.	self runDefectsButton isEnabled: enable.	self listDefectsButton isEnabled: enable.	self invalidate.</body><body package="RBSUnitExtensions">updateIsActive		| newIsVisible |	newIsVisible := self canRunTests.	isVisible ~= newIsVisible ifTrue: [		isVisible := newIsVisible.		self changedPreferredGeometry	]</body><body package="RBSUnitExtensions">updateRunButtons	| canRun |	canRun := self canRunTests.	self profileButton isEnabled: (canRun and: [self isProfilerLoaded]).	self debugButton isEnabled: canRun.	self runButton isEnabled: canRun</body><body package="RBSUnitExtensions">updateTestLabel	| label |	self isAbstractClassSelected		ifTrue: [ 			self updateForAbstract.			label := (#NotRunAbstractTest &lt;&lt; #browser &gt;&gt; 'Abstract test class, cannot run') ] 		ifFalse: [			self updateForNotRun.			label := (#NotRunC1pTests &lt;&lt; #browser &gt;&gt; 'Not run: &lt;1p&gt; tests') 							expandMacrosWith: self testCases size ].	self setTestLabel: label</body></methods><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>actions</category><body package="RBSUnitExtensions">debugTests	| failed suite |	self shouldNotRunTests ifTrue: [^self].	self updateForNotRun.	self setTestLabel: (#Debugging &lt;&lt; #browser &gt;&gt; 'Debugging').	suite := TestCase suiteClass new.	self testCases do: [:each | suite addTest: each].	failed := false.	suite addDependent: self.	testCount := suite tests size.	[[suite debug] 		on: TestResult failure , TestResult error		do: [:ex |			failed := true.			ex pass]] 		ifCurtailed: [self setFailedLabel].	failed ifTrue: [self setFailedLabel] ifFalse: [self setPassedLabel].</body><body package="RBSUnitExtensions">listDefects	self defectsExist ifTrue:		[self spawnTestResult: result].</body><body package="RBSUnitExtensions">profileTests	| profiler |	profiler := #{TimeProfiler} valueOrDo: [nil].	profiler isNil 		ifTrue: [^Dialog warn: (#ProfilerNotLoadedLoad &lt;&lt; #browser &gt;&gt; 'Profiler not loaded. Load the "AT Profiling" parcel.')].	profiler profile: [self runTests]</body><body package="RBSUnitExtensions">runDefects	| suite |	self defectsExist ifFalse: [^self].	suite := TestCase suiteClass new.	result errors do: [:each | suite addTest: each].	result failures do: [:each | suite addTest: each].	self runSuite: suite.</body><body package="RBSUnitExtensions">runSuite: aTestSuite	"Currently, for all my callers, aTestSuite is necessarily a flat suite of test cases by construction;  if this changes, generalise the first line to give the right number of tests in the suite."	| time |	testCount := aTestSuite tests size.	aTestSuite addDependent: self.	time := Time millisecondsToRun:		[[result := aTestSuite run] ifCurtailed: [result := nil]].	self setTestLabel: (result isNil		ifTrue: [#TestRunWasCurtalled &lt;&lt; #browser &gt;&gt; 'Test run was curtailed']		ifFalse: [result displayString, ', ', (self displayDuration: time)]).	codeModel navigate.	self defectsExist		ifFalse: [self updateForPassed]		ifTrue: [self updateForFailed].	self updateDefectButtons.</body><body package="RBSUnitExtensions">runTests	| suite |	self shouldNotRunTests ifTrue: [^self].	self updateForNotRun.	self setTestLabel: (#Running &lt;&lt; #browser &gt;&gt; 'Running').	suite := TestCase suiteClass new.	self testCases do: [:each | suite addTest: each].	self runSuite: suite.</body><body package="RBSUnitExtensions">spawnTestResult: aTestResult	| env |	env := MethodDefinitionEnvironment new.	aTestResult defects do: [:each | env addDefinition: each asDefinition].	env openEditor.</body></methods><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>visual properties</category><body package="RBSUnitExtensions">isVisible	^isVisible</body></methods><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>displaying</category><body package="RBSUnitExtensions">displayColoring: aGC	color ifNotNil: [		aGC paint: color.		aGC displayRectangle: self bounds	]</body><body package="RBSUnitExtensions">displayDuration: testRunMilliseconds	"Convert the milliseconds into a duration and then display it in standard format."	^testRunMilliseconds milliseconds displayString</body><body package="RBSUnitExtensions">displayOn: aGC	self isVisible ifTrue: [		self displayColoring: aGC.		aGC paint: ColorValue black.		super displayOn: aGC	]</body></methods><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>uilayout</category><body package="RBSUnitExtensions">defaultLayoutManager	^UI.UILayout.HorizontalLineLayoutManager new		verticalUseBaseline: false;		margin: (2 asPoint extent: Point zero);		horizontalSpacing: 4;		yourself</body></methods><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>bounds accessing</category><body package="RBSUnitExtensions">intrinsicHeight	^18</body><body package="RBSUnitExtensions">intrinsicWidthRule	"Give the label the space it needs.  Compress the buttons as much as their labels will allow."	| buttonTextWidths minimalButtonWidths |	buttonTextWidths := (2 to: components size)		inject: 0		into: [:tot :each || cmpt |			cmpt := components at: each.			tot + cmpt component label width].	minimalButtonWidths := (buttonTextWidths * 1.5) rounded.	^components first bounds width + minimalButtonWidths</body></methods><methods><class-id>Refactory.Browser.SUnitStatusBar</class-id> <category>accessing</category><body package="RBSUnitExtensions">labelWidget	^components first bottomComponent</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing</category><body package="RBSUnitExtensions">addXPSUTestCasesForDefinedClass: testClass to: testCases	"We removeAll: so that an inherited test selector overridden by a local one will not reappear."	testClass allTestSelectors removeAll: testClass testSelectors; do:		[:eachSel | testCases add: (testClass selector: eachSel)].	^testClass testSelectors do:		[:eachSel |		(self includesSelector: eachSel class: testClass)			ifTrue: [testCases add: (testClass selector: eachSel)]]</body><body package="RBSUnitExtensions">addXPSUTestCasesForExtendedClass: testClass to: testCases	"We removeAll: so that an inherited test selector overridden by a local one will not reappear."	testClass allTestSelectors removeAll: testClass testSelectors; do:		[:eachSel |		(self			includesSelector: eachSel			class: (testClass whichClassIncludesSelector: eachSel))					ifTrue: [testCases add: (testClass selector: eachSel)]].	^testClass testSelectors do:		[:eachSel |		(self includesSelector: eachSel class: testClass)			ifTrue: [testCases add: (testClass selector: eachSel)]]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>testing</category><body package="RBSUnitExtensions">canHaveXPSUTests: eachClass	"We must fully qualify XProgramming.SUnit.TestCase as these namespaces are not visible in Store.  Were they to become so at a later date, behaviour under extension and retraction of the SUnit-Bridge2SU2 bridge should be tested before removing the qualification."	^XProgramming.SUnit.TestCase canHaveTests: eachClass</body><body package="RBSUnitExtensions">hasXPSUTestCases	^self definedClasses		anySatisfy: [:eachClass | self canHaveXPSUTests: eachClass]</body></methods><methods><class-id>Store.PackageModel</class-id> <category>accessing</category><body package="RBSUnitExtensions">xpsuTestCases	| testCases |	testCases := Set new.	self definedClasses do:		[:eachClass |		(self canHaveXPSUTests: eachClass) ifTrue:			[self addXPSUTestCasesForDefinedClass: eachClass to: testCases]].	self extendedClasses do:		[:eachClass |		(self canHaveXPSUTests: eachClass) ifTrue:			[self addXPSUTestCasesForExtendedClass: eachClass to: testCases]].	^testCases</body></methods><methods><class-id>XProgramming.SUnit.TestResult</class-id> <category>printing</category><body package="RBSUnitExtensions">displayString	^#x1QPassedORFailed2pRun3pFailed4pErrors &lt;&lt; #browser &gt;&gt; '&lt;1?Passed:Failed&gt;: &lt;2p&gt; run, &lt;3p&gt; failed, &lt;4p&gt; errors'		expandMacrosWith: self hasPassed		with: self runCount		with: self failureCount		with: self errorCount</body></methods><methods><class-id>Store.BundleModel</class-id> <category>testing</category><body package="RBSUnitExtensions">hasXPSUTestCases	^self leafItems anySatisfy:		[:eachPackageModel | eachPackageModel hasXPSUTestCases]</body></methods><methods><class-id>Store.BundleModel</class-id> <category>accessing</category><body package="RBSUnitExtensions">xpsuTestCases	| testCases |	testCases := Set new.	self leafItems do:		[:eachPackageModel |		testCases addAll: eachPackageModel xpsuTestCases].	^testCases</body></methods><methods><class-id>XProgramming.SUnit.TestCase class</class-id> <category>testing</category><body package="RBSUnitExtensions">canHaveTests: aClass	^(self xpsuInheritsFrom: aClass) and: [aClass isAbstract not]</body></methods><methods><class-id>XProgramming.SUnit.TestCase class</class-id> <category>accessing</category><body package="RBSUnitExtensions">initialMethodCategory		^#testing</body></methods><methods><class-id>XProgramming.SUnit.TestCase class</class-id> <category>testing</category><body package="RBSUnitExtensions">needsComment		^false</body></methods><methods><class-id>XProgramming.SUnit.TestCase</class-id> <category>comparing</category><body package="RBSUnitExtensions">&lt;= aTestCase	^self class name = aTestCase class name		ifTrue: [self selector &lt;= aTestCase selector]		ifFalse: [self class name &lt;= aTestCase class name]</body></methods><methods><class-id>XProgramming.SUnit.TestCase</class-id> <category>converting</category><body package="RBSUnitExtensions">asDefinition	"VW-specific, so defined here, not in base SUnit."	^(MethodDefinition class: self class selector: testSelector) resolve</body></methods><methods><class-id>XProgramming.SUnit.TestAsserter class</class-id> <category>testing</category><body package="RBSUnitExtensions">xpsuInheritsFrom: aClass	"The purpose of this method is to be compatible with bridges to other frameworks, e.g. SUnitToo or Assessments.  While such a bridge is deployed, top-level subclasses of this class are reparented under their equivalents in the other framework, and the reparented classes can (and should) override this to false.  Calling this allows tools to know when subclasses of a reparented framework class no longer inherit from the original framework even though they do still inherit from that class."	^aClass inheritsFrom: self</body></methods><methods><class-id>Refactory.Browser.CodeModel class</class-id> <category>status parts</category><body package="RBSUnitExtensions">sunitStatusBarClass	"Only here to allow backward compatibility."	&lt;status&gt;	^SUnitStatusBar</body></methods><methods><class-id>Refactory.Browser.CodeModel</class-id> <category>status registration</category><body package="RBSUnitExtensions">sunitStatusBarClass	&lt;tool: 80 width: #intrinsic&gt;		^BoundedWrapper on: (SUnitStatusBar new codeModel: self; touch; yourself)</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>CompositePart</name><environment>Graphics</environment><super>Graphics.VisualPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components preferredExtent layoutManager layoutIsInvalid minimumExtent maximumExtent alignmentRectInsets baseline </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>TestCase</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestAsserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><class><name>CodeModel</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractCodeModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-BrowserUI</package></attributes></class><class><name>PackageModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>models </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>TestResult</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>failures errors passed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><class><name>BundleModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class></st-source>