<?xml version="1.0"?><st-source><!-- Name: Standard IO StreamsNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: This package defines three globals in the OS namespace, Stdout, Stdin and Stderr  These globals are streams on stdout, stdin and stderr   It is intended to only be used along with VisualWorks 7.3 and later releases.  Once you have loaded this package you'll need to save and restart the image.  If you are running on windows, be sure that you are using vwntconsole.exe, otherwise the handles can not be created.  To write to Stdout do something like:		OS.Stdout nextPutAll: Timestamp now printString; crOr:	OS.Stdout lockWhile: 		[OS.Stdout 				nextPutAll: 'testing'; 			cr;			nextPutAll: 'testing';			cr;			nextPutAll: '123' ; cr]Stdin can be read like this (on windows, do CTRL-Z in the console to end the stream):	[Stdin atEnd] 		whileFalse: [Stdout nextPut: Stdin next asUppercase]IsFunctional: falsePackageName: Standard IO StreamsParcel: #('StandardIOStreams')ParcelName: Standard IO StreamsVersion: 8.0 - 1Date: 12:05:13 PM July 28, 2017 --><time-stamp>From VisualWorksÂ®, 8.3 of July 28, 2017 on July 28, 2017 at 12:05:13 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>NullStream</name><environment>OS</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.IOConstants.*			</imports><category>Standard IO Streams</category><attributes><package>Standard IO Streams</package></attributes></class><comment><class-id>OS.NullStream</class-id><body>For those platforms that do not have stdin, stdout or stderr (or those platforms which are not using the correct VM), the system needs a stand-in for StandardIOStream.  This class provides that behavior.  It ignores what is written to it, and answers a space when sent #next.</body></comment><class><name>StandardIOSubsystem</name><environment>OS</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>error ioAccessorClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Standard I/O Streams</category><attributes><package>Standard IO Streams</package></attributes></class><comment><class-id>OS.StandardIOSubsystem</class-id><body>This class arranges for the Stdin, Stdout and Stderr globals to be installed with appropriate streams.  The subsystem is activated on image start-up when the #earlySystemInstallation event is sent.  This activation is wrapped in an error handler, and if an error occurs it is stored in the error instance variable and NullStream instances are installed in the globals.Instance Variables:	error	&lt;Error&gt;	The error if any that occured when the system was activated	ioAccessorClass	&lt;IOAccessor | nil&gt;	The platforms specific IOAccessorClass that responds to #stdin, #stdout and #stderr with the appropriate handles</body></comment><class><name>StandardIOStream</name><environment>OS</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream mutex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Standard I/O Streams</category><attributes><package>Standard IO Streams</package></attributes></class><comment><class-id>OS.StandardIOStream</class-id><body>StandardIOStream provides a minimal stream API around a stream, which is protected by a RecursionLock.   It is intended to be used for the Stdin, Stdout and Stderr shared variable globals in the OS namespace.  These globals are initialized with the proper stream when the system is returning from snapshot by the StandardStreamsSubstem. When using #nextPut: #nextPutAll:, and the argument contains a Character cr, then the stream will be implicitly flushed.  Because of the RecursionLock, a client can also use #lockWhile: and not be concerned with deadlocking the mutex.  For example:		Stdout lockWhile:			[Stdout 				nextPutAll: 'abc';				nextPut: 'def';				flush]Instance Variables:	mutex	&lt;RecursionLock&gt;	The guard for thread safety	stream	&lt;Stream&gt;	The stream that we are protecting</body></comment><shared-variable><name>Stderr</name><environment>OS</environment><private>false</private><constant>false</constant><category>standard i/o streams</category><initializer>StandardIOStream new</initializer><attributes><package>Standard IO Streams</package></attributes></shared-variable><shared-variable><name>Stdin</name><environment>OS</environment><private>false</private><constant>false</constant><category>standard i/o streams</category><initializer>StandardIOStream new</initializer><attributes><package>Standard IO Streams</package></attributes></shared-variable><shared-variable><name>Stdout</name><environment>OS</environment><private>false</private><constant>false</constant><category>standard i/o streams</category><initializer>StandardIOStream new</initializer><attributes><package>Standard IO Streams</package></attributes></shared-variable><methods><class-id>OS.NullStream</class-id> <category>accessing</category><body package="Standard IO Streams">atEnd	^true</body><body package="Standard IO Streams">contents	^''</body><body package="Standard IO Streams">flush</body><body package="Standard IO Streams">next	^self class endOfStreamSignal raiseRequestFrom: self</body><body package="Standard IO Streams">nextPut: anObject</body><body package="Standard IO Streams">nextPutAll: anObject</body><body package="Standard IO Streams">upToAll: aCollection	^String new</body></methods><methods><class-id>OS.NullStream</class-id> <category>stream modes</category><body package="Standard IO Streams">binary</body><body package="Standard IO Streams">isBinary	^false</body><body package="Standard IO Streams">isText	^true</body><body package="Standard IO Streams">lineEndConvention	^LineEndTransparent</body><body package="Standard IO Streams">lineEndConvention: aNumber</body><body package="Standard IO Streams">text</body></methods><methods><class-id>OS.NullStream</class-id> <category>positioning</category><body package="Standard IO Streams">padTo: bsize</body><body package="Standard IO Streams">padTo: bsize put: aCharacter</body><body package="Standard IO Streams">position	^0</body><body package="Standard IO Streams">position: anInteger</body><body package="Standard IO Streams">skipToAll: aSequence</body></methods><methods><class-id>OS.NullStream</class-id> <category>testing</category><body package="Standard IO Streams">closed	^true</body><body package="Standard IO Streams">isReadable	"The receiver does not actually read or write, but because it serves both roles	 for those platforms that do not have stdin/stdout/stderr answer true."	^true</body><body package="Standard IO Streams">isWritable	"The receiver does not actually read or write, but because it serves both roles	 for those platforms that do not have stdin/stdout/stderr answer true."	^true</body></methods><methods><class-id>OS.NullStream class</class-id> <category>instance creation</category><body package="Standard IO Streams">new	^self basicNew</body></methods><methods><class-id>OS.StandardIOSubsystem</class-id> <category>private</category><body package="Standard IO Streams">handleError: anException 	error := anException.	self installNullHandles</body><body package="Standard IO Streams">installHandles	ioAccessorClass isNil ifTrue: [^self installNullHandles].	(Array 		with: Stdout		with: Stdin		with: Stderr) with: self standardHandles			do: 				[:global :handle | 				"First, ensure that we are not in the set of OpenStreams."				handle removeDependency.				global stream: handle]</body><body package="Standard IO Streams">installNullHandles	Stdout stream: NullStream new.	Stdin stream: NullStream new.	Stderr stream: NullStream new.</body><body package="Standard IO Streams">privateSetUp	"Dispatch for the appropriate platform to set-up the globals in the OS namespace."	| platformSymbol platformArray |	platformArray := OSSystemSupport currentPlatform.	platformSymbol := platformArray at: 1.	ioAccessorClass := nil.	#win32 == platformSymbol ifTrue: [ioAccessorClass := PCIOAccessor].	#unix == platformSymbol ifTrue: [ioAccessorClass := UnixIOAccessor].	self installHandles</body><body package="Standard IO Streams">standardHandles	"Return the IOAccessor handles for stdout, stdin and stderr in that order."	^Array 		with: ioAccessorClass stdout		with: ioAccessorClass stdin		with: ioAccessorClass stderr</body></methods><methods><class-id>OS.StandardIOSubsystem</class-id> <category>prerequisites</category><body package="Standard IO Streams">prerequisiteSystems	"The only prerequisite system we need is the one that flushes the open handles on start-up. The Windows stdio uses DLLCC calls, so we're actually dependent on the foreign system."	^Array with: TimerSystem.</body></methods><methods><class-id>OS.StandardIOSubsystem</class-id> <category>accessing</category><body package="Standard IO Streams">canActivate	"We need to figure out a way to test if it is OK to activate.  For example, on MacOS it doesn't make 	 sense since there is no command line.  On Windows it might be nice to know if the VM is actually	 the console engine.  So this method simply calls its superclass' implemenation with this 	 horrible comment as a reminder to come back and finish this."	^super canActivate</body></methods><methods><class-id>OS.StandardIOSubsystem</class-id> <category>actions</category><body package="Standard IO Streams">setUp	"Because system start-up can occur before the windowing system is installed, 	 capture the error that occured and do nothing."	error := nil.	[self privateSetUp] on: Error do: [:ex | self handleError: ex].</body></methods><methods><class-id>OS.StandardIOSubsystem class</class-id> <category>options</category><body package="Standard IO Streams">activationEvent	^#earlySystemInstallation.</body></methods><methods><class-id>OS.StandardIOStream</class-id> <category>accessing</category><body package="Standard IO Streams">commit	"We can't actually call commit on stdout, so just flush."	^self flush.</body><body package="Standard IO Streams">contents	"Answer with a copy of the receiver's readable information."	^mutex critical: [stream contents]</body><body package="Standard IO Streams">flush	"If we have a bad stream handle, flush is the operation that reveals it. If so, just reset to be a null stream."	^mutex critical: [self flushStream].</body><body package="Standard IO Streams">lockWhile: aBlockClosure		^mutex critical: aBlockClosure</body><body package="Standard IO Streams">next	^mutex critical: [stream next]</body><body package="Standard IO Streams">nextPut: aByte	^mutex critical: 			[stream nextPut: aByte. 			aByte = Character cr 				ifTrue: [stream flush]]</body><body package="Standard IO Streams">nextPutAll: aCollection 	^mutex critical: 			[|shouldFlush|			shouldFlush := aCollection anySatisfy: [:each | each = Character cr].			stream nextPutAll: aCollection.			shouldFlush ifTrue: [self flushStream]]</body><body package="Standard IO Streams">peek	^mutex critical: [stream peek]</body><body package="Standard IO Streams">peekFor: anObject 	"Answer false and do not move the position if self next ~= anObject or if the	receiver is at the end. Answer true and increment position if self next = anObject."	^mutex critical: [stream peekFor: anObject]</body><body package="Standard IO Streams">skipToAll: aCollection	"Skip forward to the next occurrence (if any) of aCollection.	If found, leave the stream positioned before the occurrence,	and answer the receiver; if not found, answer nil,	and leave the stream positioned at the end."		^mutex critical: [stream skipToAll: aCollection]</body><body package="Standard IO Streams">skipUpTo: anObject	"Skip forward to the occurrence (if any, not inclusive) of anObject.	 If not there, answer nil.  Leaves stream positioned before anObject."		^mutex critical: [stream skipUpTo: anObject]</body><body package="Standard IO Streams">through: anObject	^mutex critical: [stream through: anObject]</body><body package="Standard IO Streams">upToAll: aCollection	"Answer a subcollection from the current position	up to the occurrence (if any, not inclusive) of aCollection,	and leave the stream positioned before the occurrence.	If no occurrence is found, answer the entire remaining	stream contents, and leave the stream positioned at the end."	^mutex critical: [stream upToAll: aCollection]</body><body package="Standard IO Streams">upToSeparator	"Answer a subcollection from position to the occurrence (if any, exclusive) of a separator.	The stream is left positioned after the separator.	If no separator is found answer everything."	^mutex critical: [stream upToSeparator].</body></methods><methods><class-id>OS.StandardIOStream</class-id> <category>testing</category><body package="Standard IO Streams">atEnd	^mutex critical: 			[[stream atEnd] on: OsInvalidArgumentsError , OsTransferFaultError				do: [:ex | true]]</body><body package="Standard IO Streams">closed	"Answer if the receiver is closed."	^mutex critical: [stream closed]</body><body package="Standard IO Streams">isReadable	"Answer whether the stream implements #next."	^stream isReadable</body><body package="Standard IO Streams">isWritable	"Answer whether the stream implements #next."	^stream isWritable</body></methods><methods><class-id>OS.StandardIOStream</class-id> <category>initialize-release</category><body package="Standard IO Streams">initialize	mutex := RecursionLock new</body><body package="Standard IO Streams">stream: aStream	mutex critical: [		stream := aStream]</body></methods><methods><class-id>OS.StandardIOStream</class-id> <category>private</category><body package="Standard IO Streams">contentsSpecies	^stream contentsSpecies</body><body package="Standard IO Streams">flushStream	"Flush our internal stream. If we have a bad stream handle, flush is the operation that reveals it. If so, just reset to be a null stream"	[stream flush] 		on: OSErrorHolder badAccessorSignal		do: [:ex | StandardIOSubsystem current handleError: ex. ex return: nil].</body></methods><methods><class-id>OS.StandardIOStream</class-id> <category>stream modes</category><body package="Standard IO Streams">binary	stream binary</body><body package="Standard IO Streams">isBinary	^stream isBinary</body><body package="Standard IO Streams">isText	^stream isText</body><body package="Standard IO Streams">lineEndConvention	"Answer the numeric constant that corresponds to the current line-end 	convention (see the line-end constants in the pool of IOConstants for the 	range of possible values)."	^stream lineEndConvention</body><body package="Standard IO Streams">lineEndConvention: aNumber 	"Set the line-end convention to that corresponding to aNumber (aNumber should be	one of the line-end constants from the pool of IOConstants)."	stream lineEndConvention: aNumber</body><body package="Standard IO Streams">text	stream text</body></methods><methods><class-id>OS.StandardIOStream</class-id> <category>positioning</category><body package="Standard IO Streams">padTo: bsize	"Pad (skip) to next boundary of bsize characters,	 and answer how many characters were skipped."		^mutex critical: [stream padTo: bsize]</body><body package="Standard IO Streams">padTo: bsize put: aCharacter	"Pad using the argument, aCharacter, to next boundary of bsize	 characters, and answer how many characters were written."		^mutex critical: [stream padTo: bsize put: aCharacter]</body><body package="Standard IO Streams">position	"Answer the receiver's position."		^mutex critical: [stream position]</body><body package="Standard IO Streams">position: anIndex	"StandardIOStreams cannot be positioned directly."	^self shouldNotImplement</body><body package="Standard IO Streams">skip: n 	"Reposition to the relative number n."	mutex critical: [stream skip: n]</body></methods><methods><class-id>OS.StandardIOStream</class-id> <category>fileIn</category><body package="Standard IO Streams">nextChunk	"Answer the contents of the receiver, up to the next terminator character, with	double terminators ignored."		^mutex critical: [stream nextChunk]</body></methods><methods><class-id>OS.StandardIOStream</class-id> <category>character reading</category><body package="Standard IO Streams">skipSeparators	"Move the receiver's position past any separators."		^mutex critical: [stream skipSeparators]</body></methods><methods><class-id>OS.StandardIOStream</class-id> <category>status</category><body package="Standard IO Streams">close	"Close the stream. Note that if this is actually stdin/out/err, this is probably not a good idea."	^mutex critical: [stream close].</body></methods><methods><class-id>OS.StandardIOStream class</class-id> <category>instance creation</category><body package="Standard IO Streams">new	^self basicNew initialize</body><body package="Standard IO Streams">on: stream 	^(self new)		stream: stream;		yourself</body></methods><methods><class-id>OS.PCIOAccessor class</class-id> <category>standard streams</category><body package="Standard IO Streams">connectionForStandardHandleNumber: anInteger	"Return an ExternalConnection on Stdout, Stdin, or Stderr, depending 	on the number passed in. Note that we explicitly do not call the normal 	handleValue: routine, which registers the handle in the OpenFDs handle 	registry. This is because handles in that registry are automatically closed 	on finalization, and standard i/o handles cannot be closed."	^ExternalConnection ioAccessor: (PCPipeAccessor new initialize 				handle: (self primHandleForStandardIOStream: anInteger))</body></methods><methods><class-id>OS.UnixIOAccessor class</class-id> <category>standard streams</category><body package="Standard IO Streams">connectionForStandardHandleNumber: anInteger 	"Return an ExternalConnection on Stdout, Stdin, or Stderr, depending 	on the number passed in. Note that we explicitly do not call the normal 	handleValue: routine, which registers the handle in the OpenFDs handle 	registry. This is because handles in that registry are automatically closed 	on finalization, and standard i/o handles cannot be closed."	^ExternalConnection ioAccessor: (UnixPipeAccessor new initialize 				handle: (self primHandleForStandardIOStream: anInteger))</body></methods><methods><class-id>Core.ImageConfigurationSystem</class-id> <category>private</category><body package="Standard IO Streams">stdout	^OS.Stdout.</body></methods><methods><class-id>OS.PCIOAccessor class</class-id> <category>standard streams</category><body package="Standard IO Streams">stdout	"Return an initialized stream for the handle associated with stdout."	^ExternalWriteStream on: (self connectionForStandardHandleNumber: 1)</body></methods><methods><class-id>OS.UnixIOAccessor class</class-id> <category>standard streams</category><body package="Standard IO Streams">stderr	"Return an initialized stream for the handle associated with stderr."	^ExternalWriteStream on: (self connectionForStandardHandleNumber: 2)</body><body package="Standard IO Streams">stdin	"Return an initialized stream for the handle associated with stdin."	^ExternalReadStream on: (self connectionForStandardHandleNumber: 0)</body></methods><methods><class-id>OS.PCIOAccessor class</class-id> <category>standard streams</category><body package="Standard IO Streams">stdin	"Return an initialized stream for the handle associated with stdin."	^ExternalReadStream on: (self connectionForStandardHandleNumber: 0)</body></methods><methods><class-id>OS.UnixIOAccessor class</class-id> <category>standard streams</category><body package="Standard IO Streams">stdout	"Return an initialized stream for the handle associated with stdout."	^ExternalWriteStream on: (self connectionForStandardHandleNumber: 1)</body></methods><methods><class-id>OS.PCIOAccessor class</class-id> <category>standard streams</category><body package="Standard IO Streams">stderr	"Return an initialized stream for the handle associated with stderr."	^ExternalWriteStream on: (self connectionForStandardHandleNumber: 2)</body></methods><methods><class-id>OS.PCIOAccessor class</class-id> <category>primtive-standard streams</category><body package="Standard IO Streams">primHandleForStandardIOStream: id	"Return the the handle for either Stdin, Stdout or Stderr (0, 1, 2)."	| platform fd |	platform := OSSystemSupport concreteClass new.	fd := platform GetStdHandle: (2 ** 32) - id - 10.	fd isNull ifTrue: [self error: 'Null handle for standard i/o stream'].	fd referentAddress = platform INVALID_HANDLE_VALUE ifTrue: [self error: 'Invalid handle for standard i/o stream'].	^fd</body></methods><methods><class-id>OS.UnixIOAccessor class</class-id> <category>private-standard streams</category><body package="Standard IO Streams">primHandleForStandardIOStream: id	"Return the handle for the standard handle associated with id.  	 On UNIX, we do not need to call a primitive but, we do need to	 duplicate the handle."	(#(0 1 2) includes: id) ifFalse: [self error: #invalidrequest &lt;&lt; #dialogs &gt;&gt; 'invalid request'].	^OSSystemSupport concreteClass new dup: id</body></methods><methods><class-id>Core.ImageConfigurationSystem</class-id> <category>command line handling</category><body package="Standard IO Streams">runCodeAndThenQuit: argumentStream	"This allows you to run arbitrary code from the command line, specified a Smalltalk string to be evaluated. After evaluation, the string will be printed to standard out and the image will quit. Make very sure that we always quit, even if closing the stream doesn't work."	&lt;option: '-evaluate'&gt;	| expressions result |	self class allowExpressions ifFalse: [^self].	[expressions := CommandLineInterest argumentsFrom: argumentStream.	expressions		do:			[:each | 			result := Compiler evaluate: each.			self stdout nextPutAll: result displayString.			self stdout flush]] ensure: [ObjectMemory quit].</body></methods><methods><class-id>Core.LocaleSystem</class-id> <category>prerequisites</category><body package="Standard IO Streams">standardIOPrerequisite	"Locales depend on StandardIOSubsystem so that if locales fail during startup, an error can be output to stderr."	&lt;prerequisites&gt;	^StandardIOSubsystem.</body></methods><methods><class-id>OS.UnixSystemSupport</class-id> <category>procedures</category><body package="Standard IO Streams">dup: filedes	&lt;C: int dup(int filedes)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Subsystem</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state canActivate prerequisites </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class><class><name>LocaleSystem</name><environment>Core</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>PeekableStream</name><environment>Core</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>ImageConfigurationSystem</name><environment>Core</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>allowParcelLoading allowFilein allowSettings allowExpressions useDefaultConfigFile allowDevelopment </class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class><class><name>UnixSystemSupport</name><environment>OS</environment><super>OS.OSSystemSupport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.UnixSystemSupportDictionary.*			</imports><category>OS-Unix</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item type="sym">linkedIn</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>OS-Unix</package></attributes></class></st-source>