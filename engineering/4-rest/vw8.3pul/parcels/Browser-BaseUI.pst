<?xml version="1.0"?><st-source><!-- Name: Browser-BaseUINotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Portions © 1998-2002 The Refactory, IncComment: Fundamental Refactoring Browser UI framework, used by the browser, the refactorings and smalllint.DbIdentifier: bear73DbTrace: 502681DbUsername: smichaelDbVersion: 8.3 - 6DevelopmentPrerequisites: #(#(#any 'Browser-Environments' '') #(#any 'Browser-Parser' ''))PackageName: Browser-BaseUIParcel: #('Browser-BaseUI')ParcelName: Browser-BaseUIPrerequisiteParcels: #(#('Browser-Environments' '') #('Browser-Parser' ''))PrintStringCache: (8.3 - 6,smichael)Version: 8.3 - 6Post-Load Block: 	[:pkg | Refactory.Browser.RBCommand initializeActions]Pre-Unload Block: 	[:pkg | Refactory.Browser.RBCommand initializeWithActions: #()]Date: 3:26:54 PM June 30, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (jun17.4) of June 23, 2017 on June 30, 2017 at 3:26:54 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>BrowserApplicationModel</name><environment>Refactory.Browser</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-RB UI</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.BrowserApplicationModel</class-id><body>BrowserApplicationModel is an abstract class that extends the standard ApplicationModel. It adds functions to easily change subcanvases and change the properties of the widgets.Subclasses with subcanvases should override the #subcanvases method so that the new subcanvas is also returned in the list of subcanvas open in this application. The subcanvas information is used so that #updateRequest's can be made of the whole application without the need to write a specific updateRequest in each subclass that defines uses a subcanvas. Also, when installing the same application model several different times, the builder must be nil'ed and the #subcanvases method is also used to nil the builder.Shared Variables:	PromptOnRefactoring	&lt;Boolean&gt;	should we open a changes list when performing a refactoring</body></comment><class><name>NavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>navigator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.NavigatorPart</class-id><body>NavigatorPart represents a generic subcanvas that can be placed inside a navigator. It is responsible for displaying some navigation information and when selections are made it must notify the navigator of those changes. The navigator will also request this part to fill in the appropriate parts of the navigator state.Subclasses must implement the following messages:	accessing-navigator		fillInState:			fill in the NavigatorState with our current selection	updating widgets		selectState:			a buffer is being switched to, select the correct class/method in the navigator state no matter where it is		updateWithState:			a previous part has changed its selection, try to keep the same selections, but if not possible, just update our displayInstance Variables:	navigator	&lt;BrowserNavigator&gt;	our containing navigator</body></comment><class><name>ListNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.NavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menu visualBlock objectList </inst-vars><class-inst-vars>defaultVisualBlock </class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.ListNavigatorPart</class-id><body>ListNavigatorPart is the abstact superclass of navigator parts that display a list of something.Instance Variables	menu		&lt;Menu&gt;	The menu that pops up on this list.	objectList	&lt;MultiSelectionInTree&gt;	The list of items.	visualBlock	&lt;BlockClosure&gt;	This block is called to display each item. Allows highlighting, etc.Class Instance Variables	defaultVisualBlock	&lt;BlockClosure&gt;	the visual block for the listShared Variables	ExposeElementIfClipped	&lt;Boolean&gt;	enable/disable hover overlay behavior	(This is TEMPORARY)</body></comment><class><name>HierarchyPundleNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ListNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definingPackage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.HierarchyPundleNavigatorPart</class-id><body>HierarchyPundleNavigatorPart displays a class hierarchy along with the packages associated with the selected class.Instance variables:	definingPackage	&lt;PackageModel | nil&gt;	When not nil, contains the package of those currently listed that defines the current class. Set to nil when multiple classes are selected.</body></comment><class><name>PundleNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.HierarchyPundleNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.PundleNavigatorPart</class-id><body>PundleNavigatorPart is a navigator part that displays packages.</body></comment><class><name>InstanceVariableNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ListNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.InstanceVariableNavigatorPart</class-id><body>InstanceVariableNavigatorPart displays a list instance variables.</body></comment><class><name>ProtocolItemNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ListNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>protocolHolder listSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.ProtocolItemNavigatorPart</class-id><body>ProtocolItemNavigatorPart is a navigator part that displays items that are contained within a protocol (e.g., methods and shared variables).Icons	I push the computation of method icons off to the MethodDefinition objects in my list. MethodDefinition has an extensible icon system which can be used to conditionally annotate methods with an icon. To participate in this API, one adds an arbitrary named method which includs an &lt;icon: order&gt; tag. Order is a number; lower order values are used before higher ones. Your method must return nil if it does not wish to nominate an icon based on the MethodDefinition receiver, or a VisualComponent if it does.Instance Variables	listSelector	&lt;Symbol&gt;	this symbol is performed on ourself to update the current list	protocolHolder	&lt;ValueModel on: Symbol&gt;	the protocol that our primary selection is inShared Variables:	ShowAllItemsWhenNothingSelected	&lt;Boolean&gt;	should we show all methods when no protocols selected</body></comment><class><name>SelectorNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ProtocolItemNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.SelectorNavigatorPart</class-id><body>SelectorNavigatorPart is a navigator part that displays methods.</body></comment><class><name>RBCommand</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name description action enabled receiver </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Commands</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.RBCommand</class-id><body>RBCommand represents a command for the refactoring browser. It can determine who should receive the message and also whether the message is valid in the current context. This allows one to place any command in any toolbar or menu.Instance Variables:	action	&lt;BlockClosure | Symbol&gt;	the symbol or block that is performed when we are executed	description	&lt;String | UserMessage&gt;	our help text	enabled	&lt;Symbol&gt;	a symbol that when performed returns true if the action is valid in the current context	name	&lt;String | UserMessage&gt;	our name	receiver	&lt;Symbol&gt;	the name of the object that will receive our enabled and action messagesShared Variables:	Actions	&lt;Dictionary&gt;	all actions for the RB menus, keyed by either the action name, if a String, or the defaultString of the action name, if the name is a UserMessage</body></comment><class><name>RBCheckedCommand</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Commands</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.RBCheckedCommand</class-id><body>RBCheckedCommand is a command that when converted to a menu option, puts a check in front of the menu. This is useful for slowing lists of menu items where one of them is selected.</body></comment><class><name>AbstractNavigatorState</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pundles objectNameReferences type protocols definitions properties nameSpaceName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.AbstractNavigatorState</class-id><body>I am a memento used to hold navigator state, held by each CodeModel so that when switching between the different code models, the navigator can easily be updated to the proper selection.DO NOT EXTEND THIS CLASS UNLESS THE BEHAVIOR IS COMPATIBLE WITH ALL SUBCLASS IMPLEMENTATIONS.This abstract superclass is the common parent to the RB and Store browser sibling implementations.  This strategy helps insulate the Store browsers from what should be RB-only behavior.Instance Variables	definitions	&lt;Collection of: GeneralMethodDefinition&gt;	the selected methods and/or shared variables	namespaceName	&lt;String&gt;	our default namespace	objectNameReferences	&lt;Collection of: GeneralBindingReference&gt;	the class and namespace references that are selected	properties	&lt;Dictionary&gt;	generic items that can be added to the state	protocols	&lt;Collection of: Symbol&gt;	the selected protocols	pundles	&lt;Collection&gt;	the package and bundle names that are selected	type	&lt;ByteSymbol&gt;	are we viewing #data, #class, or #instance side of a class</body></comment><class><name>NavigatorState</name><environment>Refactory.Browser</environment><super>Refactory.Browser.AbstractNavigatorState</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.NavigatorState</class-id><body>I hold state for the primary system browser.</body></comment><class><name>RBActionDispatcher</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objects </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Commands</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.RBActionDispatcher</class-id><body>RBActionDispatcher is used to dispatch menu selections. Since the browser is broken into several objects and the menu for one object might be inside another object, we need to be able to find the correct object to dispatch the menu to.Instance Variables:	objects	&lt;Dictionary&gt;	the different objects in the browser</body></comment><class><name>BundleSpecEditor</name><environment>Store</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>availablePundles bundle bundleContents bundleName disturbed pundleAvailability parentBundleHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Store-UI</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Store.BundleSpecEditor</class-id><body>I am a UI for creating a bundle and/or editing its contents.  I am an alternative to the Refactoring Browser's Bundle Structure tool.Instance Variables	bundle	&lt;BundleModel&gt;	The target bundle:  the model this UI is editing	disturbed	&lt;Boolean&gt;	State of UI with respect to its model	bundleName	&lt;ValueModel&gt; holds the target bundle name	parentBundleHolder	&lt;ValueModel&gt;	holds the target bundle's containing bundle's name, if any	bundleContents	&lt;SelectionInList&gt; pundles in this bundle, from which selections can be reordered or ejected	availablePundles	&lt;MultiSelectionInList&gt;	All pundles in image, from which selections can be added to the target bundle	pundleAvailability	&lt;SequenceableCollection of Boolean&gt; tracks which pundles are in the bundle, so cannot be added again</body></comment><class><name>PackageListTreeModel</name><environment>Refactory.Browser</environment><super>UI.TreeModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.PackageListTreeModel</class-id><body>Override a couple of methods to get the appearance/behavior we want in the Package list in the browser.</body></comment><class><name>RBActionEditor</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>enabledHolder actionHolder actionList receiverHolder descriptionHolder nameHolder typeList spec </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Commands</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.RBActionEditor</class-id><body>RBActionEditor is a helper class for creating the commands for the Refactoring Browser. It is used for developing the RB, and probably isn't that useful for others.Instance Variables:	actionHolder	&lt;ValueModel&gt;	the action symbol for the command	actionList	&lt;SelectionInList&gt;	the list of commands	descriptionHolder	&lt;ValueModel&gt;	the help text of the selected command	enabledHolder	&lt;ValueModel&gt;	the enabled symbol for the command	nameHolder	&lt;ValueModel&gt;	the name of the command	receiverHolder	&lt;ValueModel&gt;	the receiver symbol for the selected command	spec	&lt;RBCommand&gt;	the selected command	typeList	&lt;SelectionInList&gt;	the type of commands we are creating</body></comment><class><name>TabNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.NavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tabDescriptionList subcanvasBuilder namedComponents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.TabNavigatorPart</class-id><body>TabNavigatorPart is a navigator part that groups other nested parts, and allows selection of them via a tab list.ImplementationThe items shown in my tabs are instances of TabPartDescription. Specification of which items may show up in my list is done via a tagged method mechanism. Arbitrary class side methods tagged with a &lt;tabDescription: aNumber&gt; tag, are queried each time the receiver needs to determine what tabs could possibly show up in the list. To add your own tab type, implement the appropriate support methods (e.g. for building, enablement and matching) and then add a &lt;tabDescription: aNumber&gt; tagged method to the class side to register and return a TabPartDescription which uses those methods. See the existing methods in the class side 'tab descriptions' method categories of my subclasses for examples.Instance Variables	namedComponents	&lt;OrderedCollection of: Association&gt;	our components (name -&gt; navigator part)	tabDescriptionList	&lt;SelectionInList&gt;	the selection in list of our tabs	subcanvasBuilder	&lt;UIBuilder&gt;	the builder used to make our subcanvas</body></comment><class><name>PackageListRoot</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environment sortBundleContentsByLoadOrder sortBundlesToTop </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.PackageListRoot</class-id><body>PackageListRoot is the root element of the TreeModel used in the package tree list view.ImplementationI sit atop a BrowserEnvironment object. I use the pundlesDo: and bundlesDo: API provided by the environment. A full system environment will enumerate all of the packages in the Store.Registry. But a CodeComponentEnvironment will limit the bundles/packages to a subset.Instance Variables	environment	&lt;BrowseEnvironment&gt;Class Variables	SortBundlesToTop	&lt;Boolean&gt;	ShowBundleContentsInLoadOrder	&lt;Boolean&gt;</body></comment><class><name>Navigator</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environment state dispatcher parts partsDictionary menus showOnlyFiltered </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.Navigator</class-id><body>Navigator is an abstract superclass. A navigator allows the user to browse a portion of the system and select various classes, method, and other program items. This roughly corresponds to the top portion of the classic Smalltalk browser. This is a component-based framework and allows the various lists and tabs to be swapped in depending on the purpose it will be used for.Instance Variables:	dispatcher	&lt;RBActionDispatcher&gt;	This is responsible to performing the various menu and keystroke actions.	environment	&lt;BrowserEnvironment&gt;	The portion of the image being browsed.	menus	&lt;Dictionary key: String value: Menu&gt;	Map of all of the menus in this navigator. The string is an identifier used for lookup.	parts	&lt;(Collection of: CodeComponentTabNavigatorPart)&gt;	The components being displayed in this navigator.	partsDictionary	&lt;Dictionary key: Symbol  value: NavigatorPart&gt;	Map of possible components that can be displayed in a navigator.	showOnlyFiltered	&lt;Boolean&gt;	should we display methods in packages we haven't selected	state	&lt;NavigatorState&gt;	The current set of selections in the navigator. This is a memento and is used to implement the buffers feature.Shared Variables:	DefaultNamespace	&lt;String&gt;	the name of the default namespace for class definitions	LastProtocol	&lt;Symbol&gt;	the last protocol that was selected in the navigator	ShowOnlyFiltered	&lt;Boolean&gt;	should the default browsers filter by the packages/parcels selected? This is option can be overridden by each browser.</body></comment><class><name>ProtocolNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ListNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.ProtocolNavigatorPart</class-id><body>ProtocolNavigatorPart is a navigator part which is used to display protocol lists for shared variables or methods.Subclasses must implement the following messages:	drag and drop		canDropInProtocol:			returns a boolean if we can drop on the protocol		dropUsing:			performs the drop action	private		fillInListFor:			update the navigator state	updating widgets		updateSelectedProtocols:from:			updates the list of selected items to include the protocols of the selected methods/shared variables</body></comment><class><name>ProtocolSortOrder</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name sortBefore sortAfter </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.ProtocolSortOrder</class-id><body>ProtocolSortOrder defines a custom sort ordering of protocol strings. Strings are first sorted into buckets and then sorted alphabetically within the buckets. The buckets are defined by the sortBefore and sortAfter collections. These collections contain strings that will be match:ed against the list items. If an item does not match: anything in either the sortBefore or sortAfter lists, then it is assumed to go in the middle of the list. Instance Variables:	name	&lt;String&gt;	our name	sortAfter	&lt;SequenceableCollection of: String&gt;	the buckets to sort at the end of the list (the last item is the last bucket)	sortBefore	&lt;SequenceableCollection of: String&gt;	the buckets to sort at the beginning of the list (the first item is the first bucket)</body></comment><class><name>ClassNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ListNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.ClassNavigatorPart</class-id><body>ClassNavigatorPart is the abstract superclass of navigator components that display classes.Shared Variables:	ShowWarningsForUncommentedObjects	&lt;Boolean&gt;	When true, classes and name spaces that have no comments are marked with a warning icon in the browser view</body></comment><class><name>ClassAndObjectNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ClassNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.ClassAndObjectNavigatorPart</class-id><body>ClassAndObjectNavigatorPart is a component that displays a list of classes and an associated code component (Parcel, Package, etc.).Instance Variables:	objectHolder	&lt;ValueModel&gt;	The code component corresponding to the selected class.</body></comment><class><name>MetaNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.NavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>metaHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.MetaNavigatorPart</class-id><body>MetaNavigatorPart is the part that displays the switch buttons to select the instance side / class side switch.Instance Variables:	metaHolder	&lt;ValueModel&gt;	Holder for the current selection.</body></comment><class><name>CodeComponentTabNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.TabNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.CodeComponentTabNavigatorPart</class-id><body>CodeComponentTabNavigatorPart is the navigator part that displays a code component list and a list of classes within that component. It also allows switch between a list view and a hierarchy view.</body></comment><class><name>HierarchyObjectNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ClassNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rootName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.HierarchyObjectNavigatorPart</class-id><body>HierarchyObjectNavigatorPart is an abstract implementation of a navigator part which does hierarchical (indented) viewing of a tree.Subclasses must implement the following messages:	private		orderedChildrenFor:into:		rootOf:		withAllParentsOf:Instance Variables:	rootName	&lt;String&gt;	the fullName of the object at the root of the list</body></comment><class><name>RBMethodDefinition</name><environment>Refactory.Browser</environment><super>Tools.MethodDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Support</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.RBMethodDefinition</class-id><body>RBMethodDefinition is an MethodDefinition with a special displayString.</body></comment><class><name>ConstantNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.NavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stateBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.ConstantNavigatorPart</class-id><body>ConstantNavigatorPart is a special navigator part that just fills in the NavigatorState object. Instead of having a GUI that allows changes, it's state is tied to a block closure's value.Instance Variables:	stateBlock	&lt;BlockClosure&gt;	the block that is used to fillin the navigator state</body></comment><class><name>HierarchyNamespaceNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.HierarchyObjectNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.HierarchyNamespaceNavigatorPart</class-id><body>HierarchyNamespaceNavigatorPart is the component that displays a namespace as a hierarchy of containing and contained environments.</body></comment><class><name>ClassAndMethodTabNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.TabNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectors methods </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.ClassAndMethodTabNavigatorPart</class-id><body>ClassAndMethodTabNavigatorPart is a composite component that displays a list of classes and methods either as a list of methods or a list of classes and a list of selectors within that that class.Instance Variables:	methods	&lt;MethodNavigatorPart&gt;	The subpart that displays the method list	selectors	&lt;NamespaceItemTabNavigatorPart&gt;	The subpart that displays the selectors within a selected class.</body></comment><class><name>PackageListElement</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>codeComponent parent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.PackageListElement</class-id><body>I am used as the item in the bundle/package tree. It knows how to retrieve its children as well as perform the type-selection.Instance Variables	codeComponent		&lt;Store.PundleModel&gt;	our current itemClass Variables	ShowWarningsForUncommentedPundles	&lt;Boolean&gt;</body></comment><class><name>MethodNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ProtocolItemNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.MethodNavigatorPart</class-id><body>MethodNavigatorPart is the part that lists selectors.</body></comment><class><name>NameSpaceItemTabNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.TabNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type showProtocols </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.NameSpaceItemTabNavigatorPart</class-id><body>NamespaceItemTabNavigatorPart is the navigator part that shows a tabbed view and allows the user to select which contents of a namespace or class they wish to browse.Instance Variables:	showProtocols	&lt;Boolean&gt;	should we show the protocol list even if we are not viewing all methods? Normally, we just show a text field for the protocol when we are just viewing a few methods.	type	&lt;ByteSymbol&gt;	Which tab has been selected.</body></comment><class><name>ObjectNameWrapper</name><environment>Refactory.Browser</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullName simpleName environmentName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.ObjectNameWrapper</class-id><body>ObjectNameWrapper is used as the items in the class/namespace list. It allows you to type-select in the list.Instance Variables:	environmentName	&lt;String&gt;	the full name of the namespace the class/namespace is in	fullName	&lt;String&gt;	our full name	simpleName	&lt;String&gt;	the class/namespace's short nameShared Variables:	PrintFormat	&lt;String | nil&gt;	the format string that describes how to format class names</body></comment><class><name>ObjectWithIndentedNameWrapper</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ObjectNameWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>depth </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RBBaseUI</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.ObjectWithIndentedNameWrapper</class-id><body>ObjectWithIndentedNameWrapper is used as the items in the class/namespace list. It allows you to type-select in the list. It is indented to provide some visual indication of hierarchyInstance Variables:	depth	&lt;Integer&gt;	the depth of the indenting</body></comment><class><name>SharedVariableProtocolNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ProtocolNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.SharedVariableProtocolNavigatorPart</class-id><body>SharedVariableProtocolNavigatorPart is a navigator part that displays the protocols for shared variables.</body></comment><class><name>BrowserDialog</name><environment>Refactory.Browser</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-RB UI</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.BrowserDialog</class-id><body>BrowserDialog is an abstract class that extends the standard SimpleDialog. It adds functions to easily change the properties of the widgets.</body></comment><class><name>HierarchyClassNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.HierarchyObjectNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.HierarchyClassNavigatorPart</class-id><body>A class specific implementation of a hierarchy view list.</body></comment><class><name>PartialHierarchyClassNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ClassNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RBHierarchicalClassesExtension</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.PartialHierarchyClassNavigatorPart</class-id><body>A class specific implementation of a hierarchy view list with partial hierarchy ordering.</body></comment><class><name>SelectorProtocolNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ProtocolNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.SelectorProtocolNavigatorPart</class-id><body>SelectorProtocolNavigatorPart is a navigator part that displays the protocols for methods.</body></comment><class><name>SharedVariableNavigatorPart</name><environment>Refactory.Browser</environment><super>Refactory.Browser.ProtocolItemNavigatorPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.SharedVariableNavigatorPart</class-id><body>SharedVariableNavigatorPart is a navigator part that displays shared variables.</body></comment><class><name>TabPartDescription</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name buildSelector enabledSelector matchSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Navigator Parts</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.TabPartDescription</class-id><body>TabPartDescription is the item that the TabNavigatorPart holds in its tab list.Instance Variables:	buildSelector	&lt;Symbol&gt;	the symbol that is performed to build the subcanvas	enabledSelector	&lt;Symbol&gt;	the symbol that is performed to see if we are valid for the current selection	matchSelector	&lt;Symbol&gt;	the symbol that is performed to see if we are the preferred display tab for the current selection	name	&lt;String&gt;	our name</body></comment><class><name>RBDynamicMultiCommand</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Commands</category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.RBDynamicMultiCommand</class-id><body>RBDynamicMultiCommand is a special comment that evaluates to several different commands at runtime. It is useful for making dynamic lists of items.</body></comment><class><name>ValidBundleLoadOrderCache</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cache </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category></category><attributes><package>Browser-BaseUI</package></attributes></class><comment><class-id>Refactory.Browser.ValidBundleLoadOrderCache</class-id><body>Singleton lookup map to cache the results of #hasValidLoadOrder for BundleModel objects.ImplementationSingleton instance, watches ChangeSet to flush its cache on any system change.Instance Variables	cache	&lt;IdentityDictionary&gt;	keys are BundleModels, values are BooleansClass Instance Variables	current &lt;ValidBundleLoadOrderCache&gt; singleton instance</body></comment><shared-variable><name>ShowWarningsForUncommentedComponents</name><environment>Refactory.Browser.PackageListElement</environment><private>false</private><constant>false</constant><category>settings</category><initializer>true</initializer><attributes><package>Browser-BaseUI</package></attributes></shared-variable><shared-variable><name>DefaultNameSpace</name><environment>Refactory.Browser.Navigator</environment><private>false</private><constant>false</constant><category>shared state</category><attributes><package>Browser-BaseUI</package></attributes></shared-variable><shared-variable><name>LastProtocol</name><environment>Refactory.Browser.Navigator</environment><private>false</private><constant>false</constant><category>shared state</category><attributes><package>Browser-BaseUI</package></attributes></shared-variable><shared-variable><name>ShowOnlyFiltered</name><environment>Refactory.Browser.Navigator</environment><private>false</private><constant>false</constant><category>shared state</category><initializer>true</initializer><attributes><package>Browser-BaseUI</package></attributes></shared-variable><shared-variable><name>ShowBundleContentsInLoadOrder</name><environment>Refactory.Browser.PackageListRoot</environment><private>false</private><constant>false</constant><category>settings</category><initializer>false</initializer><attributes><package>Browser-BaseUI</package></attributes></shared-variable><shared-variable><name>SortBundlesToTop</name><environment>Refactory.Browser.PackageListRoot</environment><private>false</private><constant>false</constant><category>settings</category><initializer>true</initializer><attributes><package>Browser-BaseUI</package></attributes></shared-variable><shared-variable><name>ProtocolOrder</name><environment>Refactory.Browser.SelectorProtocolNavigatorPart</environment><private>false</private><constant>false</constant><category>variables</category><initializer>ProtocolSortOrder alphabetical</initializer><attributes><package>Browser-BaseUI</package></attributes></shared-variable><shared-variable><name>ProtocolOrderChoices</name><environment>Refactory.Browser.SelectorProtocolNavigatorPart</environment><private>false</private><constant>false</constant><category>variables</category><initializer>OrderedCollection with: ProtocolSortOrder alphabetical with: ProtocolSortOrder traditional</initializer><attributes><package>Browser-BaseUI</package></attributes></shared-variable><shared-variable><name>PackageWindowSpec</name><environment>Refactory.Browser.CodeComponentTabNavigatorPart</environment><private>false</private><constant>false</constant><category>settings</category><initializer>#packageWithPartialClassHierarchyWindowSpec</initializer><attributes><package>Browser-BaseUI</package></attributes></shared-variable><shared-variable><name>ShowWarningsForUncommentedObjects</name><environment>Refactory.Browser.ClassNavigatorPart</environment><private>false</private><constant>false</constant><category>settings</category><initializer>true</initializer><attributes><package>Browser-BaseUI</package></attributes></shared-variable><shared-variable><name>ShowHorizontalScrollbar</name><environment>Refactory.Browser.ListNavigatorPart</environment><private>false</private><constant>false</constant><category>variables</category><initializer>false</initializer><attributes><package>Browser-BaseUI</package></attributes></shared-variable><shared-variable><name>CheckedPackageImage</name><environment>Store.BundleSpecEditor</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Browser-BaseUI</package></attributes></shared-variable><shared-variable><name>CheckedBundleImage</name><environment>Store.BundleSpecEditor</environment><private>false</private><constant>false</constant><category>images</category><attributes><package>Browser-BaseUI</package></attributes></shared-variable><shared-variable><name>ToolListIconBlock</name><environment>Tools.MethodDefinition</environment><private>false</private><constant>false</constant><category>Browser</category><initializer></initializer><attributes><package>Browser-BaseUI</package></attributes></shared-variable><shared-variable><name>Actions</name><environment>Refactory.Browser.RBCommand</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Browser-BaseUI</package></attributes></shared-variable><shared-variable><name>ShowAllItemsWhenNothingSelected</name><environment>Refactory.Browser.ProtocolItemNavigatorPart</environment><private>false</private><constant>false</constant><category>variables</category><initializer>true</initializer><attributes><package>Browser-BaseUI</package></attributes></shared-variable><shared-variable><name>PrintFormat</name><environment>Refactory.Browser.ObjectNameWrapper</environment><private>false</private><constant>false</constant><category>printing</category><initializer>nil</initializer><attributes><package>Browser-BaseUI</package></attributes></shared-variable><methods><class-id>Refactory.Browser.BrowserApplicationModel</class-id> <category>menu accessing</category><body package="Browser-BaseUI">action: aMenuItem 	^self performAction: aMenuItem nameKey asString</body><body package="Browser-BaseUI">actionNamed: aString 	^RBCommand actionNamed: aString</body><body package="Browser-BaseUI">actionPerformerFor: aMenuItem	"Some MenuItems designate an item specific performer.	 This is generally expected to be a selector which the browser's dispatcher understands,	 but it may also be a simple block to be evaluated."	| menuPerformer |	(menuPerformer := aMenuItem actionPerformer) ifNil: [ ^self ].	^menuPerformer isSymbol		ifTrue: [ self dispatcher perform: menuPerformer ]		ifFalse: [ menuPerformer value ]</body><body package="Browser-BaseUI">buildMenuFrom: aMenu	| newMenu |	newMenu := Menu new.	aMenu allMenuItemGroups do: 			[:group |			| items index newIndex |			items := OrderedCollection new.			group do: 					[:each |					((#(#action: #rbItem) includes: each value)						or: [each value isSymbol and: [each value keywords size &gt; 1]])							ifTrue: [items add: (self createActionMenuItemFrom: each)]							ifFalse: 								[each value = #dynamicMenu									ifTrue: [items addAll: (self dynamicMenuItemsFrom: each)]									ifFalse: 										[| newItem symbol |										newItem := each copy.										newItem actionPerformer: [self actionPerformerFor: each].										"Force all messages that we understand to be dispatched to us, 										 whether they are used in the menu bar or elsewhere."										((symbol := newItem value) isSymbol and: [self respondsTo: newItem value])											ifTrue: [newItem value: [self perform: symbol]].										items add: newItem]]].			items do: [:each | each notNil ifTrue: [self createSubMenuItemFor: each]].			index := 0.			[index &lt; items size] whileTrue: 					[newIndex := items								nextIndexOf: nil								from: index + 1								to: items size.					newIndex isNil ifTrue: [newIndex := items size + 1].					newMenu addItemGroup: (items copyFrom: index + 1 to: newIndex - 1).					index := newIndex]].	^newMenu</body><body package="Browser-BaseUI">buildTopLevelMenuFrom: aMenuName	| menu |		[menu := (self class menuNamed: aMenuName) copy				augmentFrom: self class				to: self menuAugmentationRoot				menuName: aMenuName				for: self]			on: MenuAugmentationError			do: [:ex | ex isResumable ifTrue: [ex resume]].	^(self doesMenuNeedToBeRebuilt: menu)		ifTrue: [[self buildMenuFrom: menu]]		ifFalse: [self buildMenuFrom: menu]</body><body package="Browser-BaseUI">createActionMenuItemFrom: aMenuItem	| newItem commandName |	newItem := aMenuItem copy.	newItem rawLabel: (self menuLabelFor: aMenuItem).	newItem nameKey: aMenuItem nameKey.	commandName := aMenuItem nameKey.	(commandName notNil and: [aMenuItem value ~= #rbItem])		ifTrue:			[newItem value: [self action: newItem].			newItem				helpText: (self actionNamed: aMenuItem nameKey asString) description]		ifFalse: [newItem value: nil].	newItem enablementSelector: #isActionMenuItemEnabled:.	aMenuItem enablementSelector notNil		ifTrue: [newItem visible: [(self isActionMenuItemHidden: aMenuItem) not]].	^newItem</body><body package="Browser-BaseUI">createSubMenuItemFor: aMenuItem 	| submenu |	submenu := aMenuItem submenuHolder.	submenu isNil ifTrue: [^self].	(submenu isKindOf: Menu) ifFalse: [^self].	aMenuItem submenu: ((self doesMenuNeedToBeRebuilt: submenu) 				ifTrue: [[self buildMenuFrom: submenu]]				ifFalse: [self buildMenuFrom: submenu])</body><body package="Browser-BaseUI">disableMenu: aMenu except: aCollection 	aMenu menuItems do: 			[:each | 			(aCollection includes: each label) 				ifTrue: [each enable]				ifFalse: [each disable].			each submenu notNil 				ifTrue: [self disableMenu: each submenu except: aCollection]].	^aMenu</body><body package="Browser-BaseUI">doesMenuNeedToBeRebuilt: aMenu 	"The dynamic label menus (e.g., action:labelSelector:) and the dynamic list menus (e.g., the buffer lists) need to be reconstructed when the menu opens."	^aMenu menuItems anySatisfy: 			[:each | 			each value = #dynamicMenu 				or: [each value isSymbol and: [each value keywords size &gt; 1]]]</body><body package="Browser-BaseUI">dynamicMenuItemsFrom: aMenuItem 	| actions action |	action := self actionNamed: aMenuItem nameKey asString.	actions := action actionSpecificationsFor: self dispatcher.	^actions collect: 			[:each | 			| item |			each isNil 				ifTrue: [nil]				ifFalse: 					[item := MenuItem labeled: each name.					item enabled: [each isEnabledFor: self dispatcher].					item value: [each performWith: self dispatcher].					each isCheckedActionSpecification ifTrue: [item beOn].					item]]</body><body package="Browser-BaseUI">enableMenu: aMenu except: aCollection 	aMenu menuItems do: 			[:each | 			(aCollection includes: each label) 				ifFalse: [each enable]				ifTrue: [each disable].			each submenu notNil 				ifTrue: [self enableMenu: each submenu except: aCollection]].	^aMenu</body><body package="Browser-BaseUI">isActionMenuItemEnabled: aMenuItem 	| submenu |	(aMenuItem nameKey isNil or: [aMenuItem value isNil]) 		ifTrue: 			[submenu := aMenuItem submenu.			^submenu isNil or: 					[submenu menuItems anySatisfy: 							[:each | 							each isEnabled and: 									[each enablementSelector isNil or: 											[each enablementSelector numArgs = 0 												ifTrue: [self perform: each enablementSelector]												ifFalse: [self perform: each enablementSelector with: each]]]]]].	^(self actionNamed: aMenuItem nameKey asString) isEnabledFor: self dispatcher</body><body package="Browser-BaseUI">isActionMenuItemHidden: aMenuItem	^([self perform: aMenuItem enablementSelector]		on: Error		do: [:ex |			[((self actionNamed: aMenuItem nameKey asString) 				receiverFor: self dispatcher) perform: aMenuItem enablementSelector]				on: Error				do: [:ex1 |					[self dispatcher perform: aMenuItem enablementSelector]						on: Error						do: [:e | e return: false]]])			not</body><body package="Browser-BaseUI">isMenuItemEnabled: aMenuItem	self deprecated: #(#version '8.0' #use #isActionMenuItemEnabled:).	^self isActionMenuItemEnabled: aMenuItem</body><body package="Browser-BaseUI">isMenuItemHidden: aMenuItem	self deprecated: #(#version '8.0' #use #isActionMenuItemHidden:).	self isActionMenuItemHidden: aMenuItem</body><body package="Browser-BaseUI">maxMenuNameLength	^50</body><body package="Browser-BaseUI">menu	"Return a default menu for all subclasses. This is used when embedding this object inside another app 	model."	^	[| mb |	mb := MenuBuilder new.	mb add: 'No menu' -&gt; #yourself.	mb menu]</body><body package="Browser-BaseUI">menuAugmentationRoot	^BrowserApplicationModel</body><body package="Browser-BaseUI">menuLabelFor: aMenuItem 	| labelSelector keywords |	^(keywords := aMenuItem value keywords) size &gt; 1 		ifTrue: 			[labelSelector := (keywords last copyFrom: 1 to: keywords last size - 1) 						asSymbol.						[((self actionNamed: aMenuItem nameKey asString) 				receiverFor: self dispatcher) perform: labelSelector] 					on: Error					do: 						[:ex | 						[self dispatcher perform: labelSelector] on: Error							do: [:ex1 | [self perform: labelSelector] on: Error do: [:e | e return: 'Error']]]]		ifFalse: [aMenuItem rawLabel]</body><body package="Browser-BaseUI">menuNameFor: aSelector 	^aSelector size &gt; self maxMenuNameLength 		ifTrue: 			[(aSelector copyFrom: 1 to: (self maxMenuNameLength * 0.75) rounded) 				, '...' , (aSelector 							copyFrom: aSelector size - (self maxMenuNameLength * 0.25) rounded + 3							to: aSelector size)]		ifFalse: [aSelector]</body><body package="Browser-BaseUI">performAction: aString 	| action |	action := self actionNamed: aString.	^action performWith: self dispatcher</body><body package="Browser-BaseUI">rebuildMenus	"Build the specific menus for each part of the browser."	self subcanvases do: [:each | each rebuildMenus]</body><body package="Browser-BaseUI">setMenu: newMenu for: widget 	| controller |	controller := self controllerFor: widget.	controller isNil ifTrue: [^self].	controller menuHolder: newMenu</body><body package="Browser-BaseUI">windowMenuItems	^#()</body></methods><methods><class-id>Refactory.Browser.BrowserApplicationModel</class-id> <category>requests</category><body package="Browser-BaseUI">choose: aString from: aCollection 	^self 		choose: aString		fromList: aCollection		values: aCollection		lines: 20		cancel: [nil]</body><body package="Browser-BaseUI">choose: aString fromList: aCollection values: valueCollection ignore: ignoreChoices initialSelection: anIndex lines: anInteger cancel: cancelBlock 	| labels sd spec listW buttons |	labels := SelectionInList new.	labels list: aCollection asList.	anIndex notNil ifTrue: [labels selectionIndex: anIndex].	sd := SimpleDialog new.	spec := sd class interfaceSpecFor: #emptySpec.	sd builder add: spec window.	sd builder add: spec component.	sd setInitialGap.	sd addMessage: aString centered: true.	sd addGap: 8.	listW := sd 				addList: labels				lines: anInteger				validation: [labels selectionIndex &gt; 0].	listW widget setValidTargetIndex: labels selectionIndex.	sd addGap: 4.	buttons := sd addOK: [labels selectionIndex ~= 0].	sd addGap: 6.	sd bottomAlignLowerEdge: listW.	sd bottomAlign: (Array with: buttons).	labels selectionIndexHolder compute: 			[:v | 			(v &gt; 0 and: [ignoreChoices includes: v]) 				ifTrue: 					[labels selectionIndex: 0.					listW widget targetIndex: 0]].	sd preOpen.	sd builder openDialogWithExtent: sd builder window displayBox extent.	^sd accept value 		ifTrue: [valueCollection at: labels selectionIndex]		ifFalse: [cancelBlock value]</body><body package="Browser-BaseUI">choose: aString fromList: aCollection values: valueCollection lines: anInteger cancel: aBlock 	^Dialog		choose: aString		fromList: aCollection		values: valueCollection		lines: anInteger		cancel: aBlock		for: self interfaceWindow</body><body package="Browser-BaseUI">confirm: aString	^Dialog confirm: aString</body><body package="Browser-BaseUI">confirm: messageString orAlternate: anAlternateChoice	"Offer the user a third choice, returning nil if they accept it. Default to the alternate choice. Place the alternate choice in the middle."		^Dialog		choose: messageString		labels:			(Array				with: Dialog confirmButtonLabels first				with: anAlternateChoice				with: Dialog confirmButtonLabels last)		values:			(Array				with: Dialog confirmAnswerResults first				with: nil				with: Dialog confirmAnswerResults last)		default: nil</body><body package="Browser-BaseUI">request: aString 	^Dialog request: aString</body><body package="Browser-BaseUI">request: aString initialAnswer: anAnswerString	^Dialog request: aString initialAnswer: anAnswerString</body><body package="Browser-BaseUI">showWaitCursorWhile: aBlock	"The intent here is to wait a certain amount of time and if aBlock is _still_ proceeding, only then show the wait cursor."	"The original version used a terminate on the cursorInterrupt process, we now just use a simple latched flag which should lead to less race condition opportunities. The wait time is increased from 0.1s to 0.2s to be a little more consistent with where the current spate of guidelines seem to converge. As a good measure, if anyone decides to start pounding away creating lots of processes, we do an early out check by dividing the total wait time into 3 increments of increasing size."	| originalCursor done |	(originalCursor := Cursor currentCursor) == Cursor wait		ifTrue: [^aBlock value].	"wait a total of 0.2 s, with intermediate checks"	done := false.	[(#(0.01 0.05 0.14)		anySatisfy:			[:each | 			(Delay forSeconds: each) wait.			done]) ifFalse: [Cursor wait show]]		forkAt: Processor activePriorityPlusOne.	^aBlock		ensure:			[done := true.			originalCursor show]</body><body package="Browser-BaseUI">warn: aString 	^Dialog warn: aString</body></methods><methods><class-id>Refactory.Browser.BrowserApplicationModel</class-id> <category>widget properties</category><body package="Browser-BaseUI">controllerFor: aSymbol 	| wrapper |	builder isNil ifTrue: [^nil].	wrapper := builder componentAt: aSymbol.	wrapper isNil ifTrue: [^nil].	^wrapper widget controller</body><body package="Browser-BaseUI">disable: aSymbol 	| component |	builder isNil ifTrue: [^self].	component := builder componentAt: aSymbol.	component notNil ifTrue: [component disable]</body><body package="Browser-BaseUI">disableAll: aCollection	aCollection do: [:each | self disable: each]</body><body package="Browser-BaseUI">enable: aSymbol 	| component |	builder isNil ifTrue: [^self].	component := builder componentAt: aSymbol.	component notNil ifTrue: [component enable]</body><body package="Browser-BaseUI">enableAll: aCollection	aCollection do: [:each | self enable: each]</body><body package="Browser-BaseUI">hide: aSymbol 	| component |	builder isNil ifTrue: [^self].	component := builder componentAt: aSymbol.	component notNil ifTrue: [component beInvisible]</body><body package="Browser-BaseUI">hideAll: aCollection	aCollection do: [:each | self hide: each]</body><body package="Browser-BaseUI">invalidateComponent: aSymbol 	| component |	builder isNil ifTrue: [^self].	component := builder componentAt: aSymbol.	component notNil ifTrue: [component invalidate]</body><body package="Browser-BaseUI">setMenuOf: aSymbol to: aMenu 	| controller |	controller := self controllerFor: aSymbol.	controller isNil ifTrue: [^self].	[controller menuHolder: aMenu] on: Error do: [:ex | ex return]</body><body package="Browser-BaseUI">show: aSymbol 	| component |	builder isNil ifTrue: [^self].	component := builder componentAt: aSymbol.	component notNil ifTrue: [component beVisible]</body><body package="Browser-BaseUI">showAll: aCollection	aCollection do: [:each | self show: each]</body></methods><methods><class-id>Refactory.Browser.BrowserApplicationModel</class-id> <category>interface opening</category><body package="Browser-BaseUI">createSelectedVisualBlockFrom: aBlock 	^	[:v :index | 	| rw |	rw := ReversingWrapper on: (aBlock value: v value: index).	rw reverse setValue: true.	BoundedWrapper on: rw]</body><body package="Browser-BaseUI">createVisualBlockFrom: block 	^[:view :index | BoundingWrapper on: (block value: view value: index)]</body><body package="Browser-BaseUI">resetBuilder	"Set the builder to nil. This is needed to make subcanvas switching work. Subclasses do not need to provide this."	self builder: nil.	self subcanvases do: [:each | each resetBuilder]</body><body package="Browser-BaseUI">tabListWidgetFor: aSymbol 	| specWidget widget |	builder isNil ifTrue: [^nil].	specWidget := builder componentAt: aSymbol.	specWidget isNil ifTrue: [^nil].	widget := specWidget widget.	widget := [widget tabBar] on: Error do: [:ex | ex return: nil].	widget isNil ifTrue: [^nil].	^widget component</body><body package="Browser-BaseUI">tabVisualBlockFor: aSymbol is: aBlock 	| widget |	widget := self tabListWidgetFor: aSymbol.	widget isNil ifTrue: [^self].	widget visualBlock: (self createVisualBlockFrom: aBlock)</body><body package="Browser-BaseUI">visualBlockFor: aSymbol is: aBlock 	| specWidget |	builder isNil ifTrue: [^self].	specWidget := builder componentAt: aSymbol.	specWidget isNil ifTrue: [^self].	(specWidget widget)		visualBlock: (self createVisualBlockFrom: aBlock);		selectedVisualBlock: (self createSelectedVisualBlockFrom: aBlock)</body><body package="Browser-BaseUI">windowSpecMethod	^#windowSpec</body></methods><methods><class-id>Refactory.Browser.BrowserApplicationModel</class-id> <category>store</category><body package="Browser-BaseUI">abstractToolClass	^#{Store.AbstractTool} value</body><body package="Browser-BaseUI">bundleSpecEditorClass	^#{Store.BundleSpecEditor} value</body><body package="Browser-BaseUI">classDescriptorClass	^#{Store.ClassDescriptor} value</body><body package="Browser-BaseUI">comparisonBrowserClass	^#{Store.ComparePackages} value</body><body package="Browser-BaseUI">dbRegistry	^#{Store.DbRegistry} value</body><body package="Browser-BaseUI">isStoreLoaded	^self class isStoreLoaded</body><body package="Browser-BaseUI">nameSpaceDescriptorClass	^#{Store.NameSpaceDescriptor} value</body><body package="Browser-BaseUI">publishAsParcelDialogClass	^#{Store.PublishAsParcelDialog} value</body><body package="Browser-BaseUI">pundleChangeListClass	^#{Store.PundleChangeList} value</body><body package="Browser-BaseUI">setPackage: package while: aBlock 	| policiesRef |	(package isNil or: [package isBundle]) ifTrue: [^aBlock value].	policiesRef := #{Store.Policies}.	policiesRef isDefined ifFalse: [^aBlock value].	policiesRef value packagePolicy forcePackage: package while: aBlock</body><body package="Browser-BaseUI">sharedVariableDescriptorClass	^#{Store.DatumDescriptor} value</body><body package="Browser-BaseUI">storeChangeSet	^#{Store.XChangeSet} value current</body><body package="Browser-BaseUI">storeClassClass	^#{Store.Glorp.StoreClassDefinition} value</body><body package="Browser-BaseUI">storeMethodClass	^#{Store.Glorp.StoreMethod} value</body><body package="Browser-BaseUI">storeNameSpaceClass	^#{Store.Glorp.StoreNameSpace} value</body><body package="Browser-BaseUI">storeRegistry	^#{Store.Registry} valueOrDo: [nil]</body><body package="Browser-BaseUI">storeSharedVariableClass	^#{Store.Glorp.StoreSharedVariable} value</body></methods><methods><class-id>Refactory.Browser.BrowserApplicationModel</class-id> <category>accessing</category><body package="Browser-BaseUI">currentWindow	"Answer the builder's window if we can get to one and determine that it's open."	^builder		ifNotNil:			[builder window				ifNotNil:					[:window | 					window isOpen						ifTrue: [window]						ifFalse: [nil]]]</body><body package="Browser-BaseUI">dispatcher	^self</body></methods><methods><class-id>Refactory.Browser.BrowserApplicationModel</class-id> <category>subcanvases</category><body package="Browser-BaseUI">installSubcanvasIn: aSymbol using: anApplicationModel 	self 		installSubcanvasIn: aSymbol		using: anApplicationModel		spec: anApplicationModel windowSpecMethod</body><body package="Browser-BaseUI">installSubcanvasIn: aSymbol using: anApplicationModel spec: aSpec	| component |	builder isNil ifTrue: [^self].	component := builder componentAt: aSymbol.	(anApplicationModel respondsTo: #resetBuilder) 		ifTrue: [anApplicationModel resetBuilder].	component notNil 		ifTrue: [component widget client: anApplicationModel spec: aSpec builder: builder newSubBuilder].	(anApplicationModel isKindOf: BrowserApplicationModel) 		ifTrue: [anApplicationModel updateDisplay]."This will fail if anApplicationModel == self (which happens in the RBDynamicRefactoringUI package) and #resetBuilder nils the builder (which it does for BrowserApplicationModel).  If more cases in which this happens arise, push the implementation of #installSubcanvasIn:usingselfspec: up from DynamicRenameMethodUI to BrowserApplicationModel and use it in those callers."</body><body package="Browser-BaseUI">saveState	"Supports the ability to lock code and not have it update. This is done when switching buffers or sending #lock."	"Subclasses do not need to provide this method."	self subcanvases do: [:each | each saveState]</body><body package="Browser-BaseUI">subcanvases	"Return all of the BrowserApplicationModels in the current browser."	"For details, see the class comment of BrowserApplicationModel."	^#()</body><body package="Browser-BaseUI">updateDisplay	"Update all parts of the model (subcanvases). This is sent by #postOpenWith: and when a tool is switched to the foreground."	self subcanvases do: [:each | each updateDisplay]</body></methods><methods><class-id>Refactory.Browser.BrowserApplicationModel</class-id> <category>window properties</category><body package="Browser-BaseUI">interfaceWindow	builder notNil ifTrue: [^builder window].	^nil</body><body package="Browser-BaseUI">setLabel: aLabel 	(builder notNil and: [builder window notNil])		ifTrue: [builder window label: aLabel]</body><body package="Browser-BaseUI">takeFocus	"Someone has requested for us to take the widget input focus, but we don't know how."</body></methods><methods><class-id>Refactory.Browser.BrowserApplicationModel</class-id> <category>testing</category><body package="Browser-BaseUI">isEditing	"Return true if the user has changed the code in the tool but not yet accepted it."	^false</body></methods><methods><class-id>Refactory.Browser.BrowserApplicationModel</class-id> <category>updating</category><body package="Browser-BaseUI">updateRequest	"Answer true if the receiver may be changed."	^super updateRequest 		and: [self subcanvases allSatisfy: [:each | each updateRequest]]</body></methods><methods><class-id>Refactory.Browser.BrowserApplicationModel</class-id> <category>drag and drop</category><body package="Browser-BaseUI">dropSelection: aDragContext 	| controller index |	controller := aDragContext clientData at: #controller.	index := controller view targetIndex.	index == 0 ifTrue: [^nil].	^controller view sequence at: index</body><body package="Browser-BaseUI">initialDropStateFor: aSymbol 	| dict controller component |	component := self builder componentAt: aSymbol.	component isNil ifTrue: [^nil].	controller := component widget controller.	dict := IdentityDictionary new.	dict at: #controller put: controller.	dict at: #targetIndex put: controller view targetIndex.	dict at: #hasFocus put: controller view hasFocus.	controller view hasFocus: true.	^dict</body><body package="Browser-BaseUI">restoreListStateFrom: aDictionary 	| controller |	aDictionary isNil ifTrue: [^self].	controller := aDictionary at: #controller ifAbsent: [^self].	controller view targetIndex: (aDictionary at: #targetIndex).	controller view hasFocus: (aDictionary at: #hasFocus)</body><body package="Browser-BaseUI">showDropFeedbackForList: aSymbol in: aDragContext 	| component |	component := self builder componentAt: aSymbol.	component notNil 		ifTrue: 			[component widget showDropFeedbackIn: aDragContext allowScrolling: true]</body></methods><methods><class-id>Refactory.Browser.BrowserApplicationModel</class-id> <category>help</category><body package="Browser-BaseUI">help	self help: self helpTopic</body><body package="Browser-BaseUI">help: topicString 	topicString asURI open</body><body package="Browser-BaseUI">helpTopic	^'topic:vw.help.tools.browser'</body><body package="Browser-BaseUI">iconsHelp	self help: 'topic:vw.help.tools.browser.icons'</body></methods><methods><class-id>Refactory.Browser.BrowserApplicationModel</class-id> <category>accessing-pundles</category><body package="Browser-BaseUI">isOnePundleSelected	^self pundles size = 1</body><body package="Browser-BaseUI">isPundleSelected	^self pundles notEmpty</body></methods><methods><class-id>Refactory.Browser.BrowserApplicationModel class</class-id> <category>menus</category><body package="Browser-BaseUI">menuNamed: aSymbol	"If there is no base menu, answer a new Menu object which will then be augmented."	^[ self perform: aSymbol asSymbol ]		on: self messageNotUnderstoodSignal		do: [ :ex | ex return: UI.Menu new ]</body></methods><methods><class-id>Refactory.Browser.BrowserApplicationModel class</class-id> <category>store</category><body package="Browser-BaseUI">isStoreLoaded	^#{Store.DbRegistry} isDefined</body></methods><methods><class-id>Refactory.Browser.NavigatorPart</class-id> <category>changing</category><body package="Browser-BaseUI">changeRequest	^navigator changeRequest</body><body package="Browser-BaseUI">changed	self 		showWaitCursorWhile: [self changed: #navigatorState with: navigator getState]</body><body package="Browser-BaseUI">changed: anAspectSymbol with: aParameter 	self dependents isEmpty ifTrue: [^navigator changedPart: self].	^super changed: anAspectSymbol with: aParameter</body></methods><methods><class-id>Refactory.Browser.NavigatorPart</class-id> <category>accessing</category><body package="Browser-BaseUI">dispatcher	^self navigator dispatcher</body><body package="Browser-BaseUI">navigator	^navigator</body></methods><methods><class-id>Refactory.Browser.NavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI">allProtocolsIn: aNavigatorState		| protocols class |	class := aNavigatorState selectedClass.	(class notNil		and:			[aNavigatorState objectNames size = 1				and: [aNavigatorState pundles notEmpty]])		ifTrue:			[protocols := Set new.			self				inheritedClassesOf: class				do:					[:each | protocols addAll: each organization categories	"Was self environment protocolsFor: each"]]		ifFalse: [protocols := #()].	^protocols</body><body package="Browser-BaseUI">allSharedVariableProtocolsIn: aNavigatorState 	| protocols class |	class := aNavigatorState classOrNameSpace.	(class notNil and: 			[aNavigatorState objectNames size = 1 and: 					[aNavigatorState pundles notEmpty]]) 		ifTrue: 			[protocols := Set new.			self inheritedClassesOf: class				do: [:each | protocols addAll: (self environment sharedVariableProtocolsFor: each)]]		ifFalse: [protocols := #()].	^protocols</body><body package="Browser-BaseUI">environment	^navigator environment</body><body package="Browser-BaseUI">inheritedClassesOf: aClass do: aBlock 	| currentClass inheritToClass |	aClass isBehavior ifFalse: [^aBlock value: aClass].	currentClass := aClass.	inheritToClass := navigator inheritToClass.	inheritToClass isNil 		ifFalse: [inheritToClass := inheritToClass superclass].	[currentClass isNil or: [inheritToClass == currentClass]] whileFalse: 			[aBlock value: currentClass.			currentClass := currentClass superclass]</body></methods><methods><class-id>Refactory.Browser.NavigatorPart</class-id> <category>accessing-navigator</category><body package="Browser-BaseUI">fillInState: aNavigatorState	self subclassResponsibility</body><body package="Browser-BaseUI">initiallyOpened: aNavigatorState	^self selectState: aNavigatorState</body></methods><methods><class-id>Refactory.Browser.NavigatorPart</class-id> <category>private-selectors</category><body package="Browser-BaseUI">allMethodDefinitionsFor: aProtocol in: class 	| selectors |	selectors := OrderedCollection new.	self inheritedClassesOf: class		do: 			[:each | 			selectors 				addAll: ((navigator environment selectorsFor: aProtocol in: each) collect: 							[:sel | 							RBMethodDefinition 								class: class								implementor: each								selector: sel])].	^selectors</body><body package="Browser-BaseUI">allSelectorsFor: aProtocol in: class 	| selectors |	selectors := Set new.	self inheritedClassesOf: class		do: 			[:each | 			selectors addAll: (navigator environment selectorsFor: aProtocol in: each)].	^selectors</body><body package="Browser-BaseUI">allSharedVariableDefinitionsFor: aProtocol in: class 	| sharedVariables |	sharedVariables := OrderedCollection new.	self inheritedClassesOf: class		do: 			[:each | 			sharedVariables 				addAll: ((self environment sharedVariablesFor: aProtocol in: each) 						collect: [:var | RBInitializerDefinition nameSpace: each key: var])].	^sharedVariables</body><body package="Browser-BaseUI">allSharedVariablesFor: aProtocol in: class 	| sharedVariables |	sharedVariables := Set new.	self inheritedClassesOf: class		do: 			[:each | 			sharedVariables 				addAll: (self environment sharedVariablesFor: aProtocol in: each)].	^sharedVariables</body><body package="Browser-BaseUI">methodClassFor: aSelector in: aClass 	| definingClass |	definingClass := aClass whichClassIncludesSelector: aSelector.	^definingClass isNil ifTrue: [aClass] ifFalse: [definingClass]</body><body package="Browser-BaseUI">methodDefinitionsIn: aProtocol		| class defs pundles |	class := navigator selectedClass.	class isNil ifTrue: [^#()].	defs := self allMethodDefinitionsFor: aProtocol in: class.	defs isEmpty ifTrue: [^#()].	navigator showOnlyFiltered not ifTrue: [^defs].	pundles := navigator pundles.	^defs		select:			[:each | 			each inheritingClass ~= each implementingClass				or:					[pundles						anySatisfy:							[:pundle | 							pundle								includesSelector: each selector								className: each implementingClass instanceBehavior absoluteName								meta: each implementingClass isMeta]]]</body><body package="Browser-BaseUI">sharedVariableClassFor: aSelector in: aClass 	| definingClass |	aClass isBehavior ifFalse: [^aClass].	definingClass := aClass whichClassDefinesSharedVariable: aSelector.	^definingClass isNil ifTrue: [aClass] ifFalse: [definingClass]</body><body package="Browser-BaseUI">sharedVariableDefinitionsIn: aProtocol		| vars class codeComponents |	class := navigator classOrNameSpace.	vars := #().	class notNil		ifTrue:			[vars := self allSharedVariableDefinitionsFor: aProtocol in: class].	vars isEmpty ifTrue: [^#()].	navigator showOnlyFiltered ifFalse: [^vars].	codeComponents := OrderedCollection withAll: navigator packages.	^vars		select:			[:var | 			codeComponents				anySatisfy:					[:each | 					each						definesName: var variableName						in: var classOrNameSpace]]</body><body package="Browser-BaseUI">sharedVariablesIn: aProtocol		| vars class codeComponents |	class := navigator classOrNameSpace.	vars := #().	class notNil		ifTrue: [vars := self allSharedVariablesFor: aProtocol in: class].	vars isEmpty ifTrue: [^#()].	navigator showOnlyFiltered not ifTrue: [^vars].	codeComponents := OrderedCollection withAll: navigator packages.	^vars		select:			[:var | 			| definingClass |			definingClass := self sharedVariableClassFor: var in: class.			codeComponents				anySatisfy: [:each | each definesName: var in: definingClass]]</body></methods><methods><class-id>Refactory.Browser.NavigatorPart</class-id> <category>initialize-release</category><body package="Browser-BaseUI">navigator: aNavigator 	navigator := aNavigator</body></methods><methods><class-id>Refactory.Browser.NavigatorPart</class-id> <category>updating widgets</category><body package="Browser-BaseUI">selectState: aNavigatorState	self subclassResponsibility</body><body package="Browser-BaseUI">updateWithState: aNavigatorState	self subclassResponsibility</body></methods><methods><class-id>Refactory.Browser.NavigatorPart</class-id> <category>updating</category><body package="Browser-BaseUI">update: anAspectSymbol with: aParameter from: aSender 	anAspectSymbol == #navigatorState 		ifFalse: 			[^super 				update: anAspectSymbol				with: aParameter				from: aSender].	self updateWithState: aParameter.	self changed: anAspectSymbol with: aParameter</body></methods><methods><class-id>Refactory.Browser.NavigatorPart</class-id> <category>error handling</category><body package="Browser-BaseUI">doesNotUnderstand: aMessage 	^(navigator respondsTo: aMessage selector) 		ifTrue: 			[navigator perform: aMessage selector withArguments: aMessage arguments]		ifFalse: [super doesNotUnderstand: aMessage]</body></methods><methods><class-id>Refactory.Browser.NavigatorPart class</class-id> <category>instance creation</category><body package="Browser-BaseUI">onNavigator: aNavigator 	^(self new)		navigator: aNavigator;		yourself</body></methods><methods><class-id>Refactory.Browser.ListNavigatorPart</class-id> <category>drag and drop</category><body package="Browser-BaseUI">acceptedDropKeys	"Return DropContext keys that I am interested in responding to."	^#()</body><body package="Browser-BaseUI">canAcceptDropFrom: aDragContext	^self navigator supportsLiveEditing		and: [self acceptedDropKeys includes: aDragContext key]</body><body package="Browser-BaseUI">doDrag: aDC</body><body package="Browser-BaseUI">doDragAndDrop: aSymbol for: aController 	| data class |	data := DragDropData new.	data key: aSymbol.	data contextWindow: self builder window.	data contextWidget: aController view.	data contextApplication: self.	data clientData: IdentityDictionary new.	data clientData at: #navigatorState put: navigator getState.	data clientData at: #environment put: navigator nameSpace.	data clientData at: #selector put: navigator selectors.	class := navigator selectedClass.	data clientData at: #class		put: (class isNil ifTrue: [nil] ifFalse: [class]).	data clientData at: #protocol put: navigator protocol.	data clientData at: #meta put: navigator isMeta.	(DragDropManager withDropSource: DropSource new withData: data) doDragDrop</body><body package="Browser-BaseUI">dragEnter: aDragContext 	(self canAcceptDropFrom: aDragContext) ifFalse: [^#dropEffectNone].	aDragContext dropTarget 		clientData: (self initialDropStateFor: #objectList).	^#dropEffectMove</body><body package="Browser-BaseUI">dragLeave: aDragContext 	self restoreListStateFrom: aDragContext dropTarget clientData.	aDragContext dropTarget clientData: nil.	^#dropEffectNone</body><body package="Browser-BaseUI">dragOver: aDC 	^#dropEffectNone</body><body package="Browser-BaseUI">drop: aDC 	^#dropEffectNone</body><body package="Browser-BaseUI">dropAllDefinitionsFrom: aDictionary 	^(self dropStateFrom: aDictionary) allDefinitions</body><body package="Browser-BaseUI">dropCategoriesFrom: aDictionary 	^(self dropStateFrom: aDictionary) categories</body><body package="Browser-BaseUI">dropClassFrom: aDictionary 	^(self dropStateFrom: aDictionary) selectedClass</body><body package="Browser-BaseUI">dropClassNameFrom: aDictionary 	^(self dropStateFrom: aDictionary) objectName</body><body package="Browser-BaseUI">dropClassNamesFrom: aDictionary 	^(self dropStateFrom: aDictionary) objectNames</body><body package="Browser-BaseUI">dropClassOrNameSpaceFrom: aDictionary 	^(self dropStateFrom: aDictionary) classOrNameSpace</body><body package="Browser-BaseUI">dropDefinitionsFrom: aDictionary 	^(self dropStateFrom: aDictionary) definitions</body><body package="Browser-BaseUI">dropMetaFrom: aDictionary 	^(self dropStateFrom: aDictionary) isMeta</body><body package="Browser-BaseUI">dropNameSpaceFrom: aDictionary 	^(self dropStateFrom: aDictionary) nameSpace</body><body package="Browser-BaseUI">dropProtocolFrom: aDictionary 	^(self dropStateFrom: aDictionary) protocol</body><body package="Browser-BaseUI">dropProtocolsFrom: aDictionary 	^(self dropStateFrom: aDictionary) protocols</body><body package="Browser-BaseUI">dropSelectorsFrom: aDictionary 	^(self dropStateFrom: aDictionary) selectors</body><body package="Browser-BaseUI">dropSharedVariableNamesFrom: aDictionary 	^(self dropStateFrom: aDictionary) sharedVariableNames</body><body package="Browser-BaseUI">dropStateFrom: aDictionary 	| state |	state := aDictionary at: #navigatorState ifAbsent: [nil].	state isNil 		ifTrue: 			[state := NavigatorState new.			state				nameSpace: (aDictionary at: #environment ifAbsent: [Smalltalk]);				objectName: (aDictionary at: #class ifAbsent: [nil]);				type: ((aDictionary at: #meta ifAbsent: [false]) 							ifTrue: [#class]							ifFalse: [#instance]);				protocol: (aDictionary at: #protocol ifAbsent: [nil]);				selector: (aDictionary at: #selector ifAbsent: [nil])].	^state</body><body package="Browser-BaseUI">wantToDrag: aDC	^false</body></methods><methods><class-id>Refactory.Browser.ListNavigatorPart</class-id> <category>accessing</category><body package="Browser-BaseUI">visualBlock: aBlock 	visualBlock := aBlock.	self updateVisualBlock</body></methods><methods><class-id>Refactory.Browser.ListNavigatorPart</class-id> <category>actions</category><body package="Browser-BaseUI">doubleClickItem</body></methods><methods><class-id>Refactory.Browser.ListNavigatorPart</class-id> <category>interface opening</category><body package="Browser-BaseUI">changeMultiSelectionList: aSymbol</body><body package="Browser-BaseUI">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self changeMultiSelectionList: #objectList.	self updateVisualBlock</body><body package="Browser-BaseUI">updateVisualBlock	visualBlock isNil ifTrue: [^self].	self visualBlockFor: #objectList		is: 			[:view :index | 			visualBlock 				value: self				value: view				value: index]</body></methods><methods><class-id>Refactory.Browser.ListNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI">addToList: anObject 	| index |	index := (1 to: self objectList list size) detect: 					[:i | 					anObject = (self objectList list at: i) 						or: [self sortBlock value: anObject value: (self list at: i)]]				ifNone: [^self list add: anObject].	anObject = (self objectList list at: index) ifTrue: [^self].	self objectList list add: anObject beforeIndex: index</body><body package="Browser-BaseUI">displayTextFor: anObject 	^anObject displayString</body><body package="Browser-BaseUI">iconFor: anObject 	^nil</body><body package="Browser-BaseUI">invalidateObjectListWidget	self invalidateComponent: #objectList</body><body package="Browser-BaseUI">list	^self objectList list</body><body package="Browser-BaseUI">list: aList 	^self objectList list: aList</body><body package="Browser-BaseUI">listLabelFor: anObject	| text label |	text := self displayTextFor: anObject.	label := self showIcons				ifFalse: [Label with: text]				ifTrue: 					[(LabelAndIcon with: text)						icon: ((self iconFor: anObject) ifNil: [PixelSpace extent: 16])].	"Start with the initial default indentation of 2 pixels, whether or not we are displaying icons."	label offset: 2 @ 0 + (self offsetFor: anObject).	^label</body><body package="Browser-BaseUI">mergeIntoList: newList 	| newIndex oldIndex new old removeSize |	newIndex := 1.	oldIndex := 1.	[newIndex &lt;= newList size] whileTrue: 			[new := newList at: newIndex.			oldIndex &lt;= self objectList list size 				ifTrue: 					[old := self objectList list at: oldIndex.					new = old 						ifTrue: 							[newIndex := newIndex + 1.							oldIndex := oldIndex + 1]						ifFalse: 							[(self sortBlock value: new value: old) 								ifTrue: [self objectList list add: new beforeIndex: oldIndex]								ifFalse: [self objectList list removeAtIndex: oldIndex]]]				ifFalse: 					[| appendedItems |					appendedItems := newList copyFrom: newIndex to: newList size.					appendedItems notEmpty 						ifTrue: [self objectList list addAll: appendedItems].					^self]].	removeSize := self objectList list size - oldIndex + 1.	removeSize &lt; 1 ifTrue: [^self].	self objectList list removeLast: removeSize</body><body package="Browser-BaseUI">offsetFor: anObject	^0 @ 0</body><body package="Browser-BaseUI">overriddenColor	^ColorValue red</body><body package="Browser-BaseUI">select: aCollection 	self select: aCollection in: self objectList</body><body package="Browser-BaseUI">select: aCollection in: aSelectionInList 	| selections |	aSelectionInList selections = aCollection ifTrue: [^self].	selections := aCollection 				select: [:each | aSelectionInList list includes: each].	aSelectionInList selections: selections</body><body package="Browser-BaseUI">selection	^self selections detect: [:each | true] ifNone: [nil]</body><body package="Browser-BaseUI">selections	^self objectList selections</body><body package="Browser-BaseUI">sortBlock	"Return a sort block that defines a total order on our elements."	^[:a :b | a &lt; b]</body><body package="Browser-BaseUI">sortList: aCollection 	^(aCollection asSortedCollection: self sortBlock) asList</body><body package="Browser-BaseUI">updateListWith: aCollection 	"self list = aCollection ifTrue: [^self invalidateComponent: #objectList]."	(self objectList list isEmpty and: [aCollection isEmpty]) ifTrue: [^self].	self list: (self sortList: aCollection)</body></methods><methods><class-id>Refactory.Browser.ListNavigatorPart</class-id> <category>menus</category><body package="Browser-BaseUI">defaultMenu	^self subclassResponsibility</body><body package="Browser-BaseUI">menu	menu isNil ifTrue: [menu := self defaultMenu].	^menu</body><body package="Browser-BaseUI">menu: aMenu 	menu := aMenu.	self setMenuOf: #objectList to: aMenu</body><body package="Browser-BaseUI">rebuildMenus	menu := nil.	self setMenu: self menu for: #objectList</body></methods><methods><class-id>Refactory.Browser.ListNavigatorPart</class-id> <category>aspects</category><body package="Browser-BaseUI">objectList	^objectList isNil 		ifTrue: [objectList := MultiSelectionInList new]		ifFalse: [objectList]</body></methods><methods><class-id>Refactory.Browser.ListNavigatorPart</class-id> <category>updating</category><body package="Browser-BaseUI">changeSetUpdate: anAspectSymbol with: aParameter</body><body package="Browser-BaseUI">refreshListDisplay		self invalidateComponent: #objectList</body><body package="Browser-BaseUI">update: anAspectSymbol with: aParameter from: aSender	^aSender == ChangeSet		ifTrue: [self changeSetUpdate: anAspectSymbol with: aParameter]		ifFalse: [super update: anAspectSymbol with: aParameter from: aSender]</body></methods><methods><class-id>Refactory.Browser.ListNavigatorPart</class-id> <category>initialize-release</category><body package="Browser-BaseUI">initialize	super initialize.	ChangeSet addDependent: self</body><body package="Browser-BaseUI">release	ChangeSet removeDependent: self.	super release</body></methods><methods><class-id>Refactory.Browser.ListNavigatorPart</class-id> <category>testing</category><body package="Browser-BaseUI">showIcons	^false</body></methods><methods><class-id>Refactory.Browser.ListNavigatorPart class</class-id> <category>accessing</category><body package="Browser-BaseUI">defaultVisualBlock	defaultVisualBlock isNil ifTrue: [self initializeDefaultVisualBlock].	^defaultVisualBlock isNil 		ifTrue: 			[self = ListNavigatorPart ifTrue: [nil] ifFalse: [superclass defaultVisualBlock]]		ifFalse: [defaultVisualBlock]</body><body package="Browser-BaseUI">defaultVisualBlock: aBlock 	"self withAllSubclasses do: [:each | each defaultVisualBlock: nil]"	defaultVisualBlock := aBlock</body><body package="Browser-BaseUI">initializeDefaultVisualBlock	self defaultVisualBlock: 			[:np :view :index | 			| definition label |			definition := view sequence at: index.			label := np listLabelFor: definition.			label attributes: view textStyle.			label]</body><body package="Browser-BaseUI">showHorizontalScrollbar	^ShowHorizontalScrollbar</body><body package="Browser-BaseUI">showHorizontalScrollbar: aBoolean 	ShowHorizontalScrollbar := aBoolean</body></methods><methods><class-id>Refactory.Browser.ListNavigatorPart class</class-id> <category>instance creation</category><body package="Browser-BaseUI">new	^(super new)		visualBlock: self defaultVisualBlock;		yourself</body></methods><methods><class-id>Refactory.Browser.ListNavigatorPart class</class-id> <category>interface specs</category><body package="Browser-BaseUI">windowSpec	"Some very hackish code that adds the horizontal scrollbar to the list. 	If you know of a better way to do this, please feel free to clean it up :)."	| spec allSpecs index listSpec flagsIndex |	ShowHorizontalScrollbar ifFalse: [^self basicWindowSpec].	spec := self basicWindowSpec copy.	spec at: spec size put: spec last copy.	allSpecs := spec last last copy.	index := (1 to: allSpecs size) 				detect: [:each | (allSpecs at: each) includes: #objectList]				ifNone: [nil].	index isNil ifTrue: [^spec].	listSpec := allSpecs at: index.	flagsIndex := listSpec indexOf: #flags:.	flagsIndex odd 		ifTrue: 			[listSpec at: flagsIndex + 1 put: ((listSpec at: flagsIndex + 1) bitOr: 2)]		ifFalse: [allSpecs at: index put: (allSpecs at: index) , #(#flags: 15)].	spec last at: spec last size put: allSpecs.	^spec</body></methods><methods><class-id>Refactory.Browser.HierarchyPundleNavigatorPart</class-id> <category>updating widgets</category><body package="Browser-BaseUI">addBindingPackages: aNavigatorState to: pundles 	aNavigatorState classesAndNameSpaces do: 			[:each | 			self addPackagesIfAbsent: (self storeRegistry packagesContaining: each)				to: pundles]</body><body package="Browser-BaseUI">addPackagesIfAbsent: packages to: pundles 	| allPundles |	allPundles := OrderedCollection new.	pundles do: 			[:each | 			allPundles				addAll: each allContainedItems;				add: each].	(packages anySatisfy: [:each | allPundles includes: each]) ifTrue: [^self].	pundles addAll: packages</body><body package="Browser-BaseUI">addSelectorPackages: aNavigatorState to: pundles 	navigator showOnlyFiltered ifFalse: [^self].	aNavigatorState methodDefinitions do: 			[:each | 			(each implementingClass includesSelector: each selector) 				ifTrue: 					[| package |					package := self storeRegistry containingPackageForSelector: each selector								class: each implementingClass.					package notNil 						ifTrue: [self addPackagesIfAbsent: (Array with: package) to: pundles]]]</body><body package="Browser-BaseUI">addSharedVariablePackages: aNavigatorState to: pundles 	| vars class |	navigator showOnlyFiltered ifFalse: [^self].	vars := aNavigatorState sharedVariableNames.	vars isEmpty ifTrue: [^self].	class := aNavigatorState classOrNameSpace.	class isNil ifTrue: [^self].	vars do: 			[:each | 			| packages package binding |			binding := class bindingFor: each.			binding notNil 				ifTrue: 					[package := self storeRegistry containingPackageForDataKey: each								nameSpace: class.					packages := package notNil ifTrue: [Array with: package] ifFalse: [#()].					self addPackagesIfAbsent: packages to: pundles]]</body><body package="Browser-BaseUI">selectState: aNavigatorState	| pundles |	self selectivelyFillInListFor: aNavigatorState.	pundles := OrderedCollection				withAll: (self selectedItemsIn: aNavigatorState).	self		addSelectorPackages: aNavigatorState to: pundles;		addSharedVariablePackages: aNavigatorState to: pundles;		addBindingPackages: aNavigatorState to: pundles.	self expandToShowPundles: pundles.	aNavigatorState pundles: pundles.	self select: pundles</body><body package="Browser-BaseUI">selectedItemsIn: aNavigatorState 	^aNavigatorState packages</body><body package="Browser-BaseUI">updateWithState: aNavigatorState	| pundles |	pundles := self selectedItemsIn: aNavigatorState.	self fillInListFor: aNavigatorState.	pundles := pundles select: [:each | self list includes: each].	self expandToShowPundles: pundles.	(pundles isEmpty and: [self shouldSelectPackages])		ifTrue: [pundles := self list].	aNavigatorState pundles: pundles.	self select: pundles</body></methods><methods><class-id>Refactory.Browser.HierarchyPundleNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI">allSelectedObjectsFor: aNavigatorState	"Extended to handle classes or namespaces.  The enablers of the tab for this mean that a given set will be all classes or all namespaces."	| classes |	classes := Set new.	aNavigatorState selectedClassesAndNamespaces do:		[:each | self inheritedClassesOf: each do: [:class | classes add: class]].	^classes</body><body package="Browser-BaseUI">displayTextFor: aPundleModel		| baseText |	baseText := aPundleModel toolListText.	aPundleModel == definingPackage		ifTrue:			[baseText addEmphasis: #(#bold) removeEmphasis: #() allowDuplicates: true].	^baseText</body><body package="Browser-BaseUI">expandToShowPundles: pundles 	pundles removeAllSuchThat: [:each | (self list includes: each) not]</body><body package="Browser-BaseUI">fillInListFor: aNavigatorState	| selectedClasses packages classPackages |	packages := Set new.	selectedClasses := self allSelectedObjectsFor: aNavigatorState.	selectedClasses do: 			[:each |			classPackages := self storeRegistry packagesContaining: each.			packages addAll: classPackages].	definingPackage := selectedClasses size = 1				ifTrue: [classPackages first]				ifFalse: [nil].	self updateListWith: packages</body><body package="Browser-BaseUI">iconFor: aPundle	^aPundle toolListIcon</body><body package="Browser-BaseUI">selectivelyFillInListFor: aNavigatorState	"Same as fillInListFor: aNavigatorState, subclasses make use of the difference."	^self fillInListFor: aNavigatorState</body><body package="Browser-BaseUI">sortBlock	^[:a :b | a name &lt; b name]</body></methods><methods><class-id>Refactory.Browser.HierarchyPundleNavigatorPart</class-id> <category>testing</category><body package="Browser-BaseUI">shouldSelectPackages	^true</body><body package="Browser-BaseUI">showIcons	^true</body></methods><methods><class-id>Refactory.Browser.HierarchyPundleNavigatorPart</class-id> <category>accessing-navigator</category><body package="Browser-BaseUI">fillInState: aNavigatorState 	aNavigatorState pundles: self selections</body></methods><methods><class-id>Refactory.Browser.HierarchyPundleNavigatorPart</class-id> <category>menus</category><body package="Browser-BaseUI">defaultMenu	^navigator menuNamed: #pundleMenu</body></methods><methods><class-id>Refactory.Browser.HierarchyPundleNavigatorPart</class-id> <category>updating</category><body package="Browser-BaseUI">changeSetUpdate: anAspectSymbol with: aParameter 	anAspectSymbol == #unloadComponent: 		ifTrue: [self list remove: aParameter first ifAbsent: []]</body></methods><methods><class-id>Refactory.Browser.PundleNavigatorPart</class-id> <category>aspects</category><body package="Browser-BaseUI">objectList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^objectList isNil		ifTrue:			[objectList := MultiSelectionInTree new]		ifFalse:			[objectList]</body></methods><methods><class-id>Refactory.Browser.PundleNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI">basicExpandToShow: aCollection	| bundles |	bundles := IdentitySet new.	aCollection do: [:each | bundles addAll: each enclosingComponents].	bundles isEmpty ifTrue: [^self].	self basicExpandToShow: bundles.	bundles do: 			[:each |			| index list element |			list := self list.			index := list size + 1.			element := PackageListElement codeComponent: each.			[(index := list						prevIndexOf: element						from: index - 1						to: 1) notNil]				whileTrue: [self expand: index]]</body><body package="Browser-BaseUI">displayTextFor: aPundleModel 	^aPundleModel displayString</body><body package="Browser-BaseUI">expand: index 	^self list expand: index</body><body package="Browser-BaseUI">expandToShowPundles: pundles	self basicExpandToShow: pundles</body><body package="Browser-BaseUI">fillInListFor: aNavigatorState	self list root sortBundlesToTop: aNavigatorState sortBundlesToTop.	self list root showBundleContentsInLoadOrder: aNavigatorState showBundleContentsInLoadOrder.	self list refreshRoot</body><body package="Browser-BaseUI">select: aCollection 	"Overridden so that we can scroll the list to show a selected item."	| index view wrapper |	super select: aCollection.	wrapper := self builder componentAt: #objectList.	wrapper isNil ifTrue: [^self].	view := wrapper widget.	index := view selectionChannel value detect: [:each | true] ifNone: [^self].	view makeVisible: index</body><body package="Browser-BaseUI">select: aCollection in: aSelectionInList	| indices list |	indices := OrderedCollection new: aCollection size.	list := aSelectionInList list.	aCollection do: 			[:each |			| index element |			index := 0.			element := PackageListElement codeComponent: each.						[(index := list						nextIndexOf: element						from: index + 1						to: list size) notNil]					whileTrue: [indices add: index]].	aSelectionInList selectionIndexes: indices</body><body package="Browser-BaseUI">selectivelyFillInListFor: aNavigatorState	"Determine if we really need to fillInListFor: aNavigatorState, and only then go ahead and do it."	| list |	(aNavigatorState sortBundlesToTop = self list root sortBundlesToTop and: 			[aNavigatorState showBundleContentsInLoadOrder				= self list root showBundleContentsInLoadOrder])		ifFalse: [^self updateSortOrderFor: aNavigatorState].	list := self list.	1 to: list size		do: 			[:i |			| wrapper |			wrapper := list wrapperAt: i.			(wrapper openedChildren and: 					[(wrapper children collect: [:each | each value]) ~= wrapper value children])				ifTrue: [^self fillInListFor: aNavigatorState]]</body><body package="Browser-BaseUI">updateSortOrderFor: aNavigatorState	"This is an inlined version of fillInListFor: with the addition that we reset the root in the middle. If we don't, the tree resorts only sporadically."	| listRoot |	listRoot := self list root.	listRoot sortBundlesToTop: aNavigatorState sortBundlesToTop.	listRoot showBundleContentsInLoadOrder: aNavigatorState				showBundleContentsInLoadOrder.	self list root: listRoot displayIt: false.	self list refreshRoot</body></methods><methods><class-id>Refactory.Browser.PundleNavigatorPart</class-id> <category>interface opening</category><body package="Browser-BaseUI">changeMultiSelectionList: aSymbol</body><body package="Browser-BaseUI">updateVisualBlock</body></methods><methods><class-id>Refactory.Browser.PundleNavigatorPart</class-id> <category>accessing-navigator</category><body package="Browser-BaseUI">fillInState: aNavigatorState	aNavigatorState		pundles: ((self selections collect: #codeComponent) reject: #isNil)</body></methods><methods><class-id>Refactory.Browser.PundleNavigatorPart</class-id> <category>testing</category><body package="Browser-BaseUI">shouldSelectPackages	^self list size = 1</body></methods><methods><class-id>Refactory.Browser.PundleNavigatorPart</class-id> <category>initialize-release</category><body package="Browser-BaseUI">navigator: aNavigator	super navigator: aNavigator.	self list: ((PackageListTreeModel on: self navigator packageListRoot)				childrenBlock: [:each | each children];				hasChildrenBlock: [:each | each hasChildren];				yourself)</body></methods><methods><class-id>Refactory.Browser.PundleNavigatorPart</class-id> <category>updating widgets</category><body package="Browser-BaseUI">selectedItemsIn: aNavigatorState 	^aNavigatorState pundles</body></methods><methods><class-id>Refactory.Browser.PundleNavigatorPart</class-id> <category>updating</category><body package="Browser-BaseUI">changeSetUpdate: anAspectSymbol with: aParameter	"This may cause some update problems. However, without this code, the bundle list is not automatically refreshed."	| pundles |	(#(#bundleStructure: #loadPundle: #loadParcel: #unloadComponent: #createdComponent: #unloadPundle:)		includes: anAspectSymbol)			ifTrue: 				[pundles := self selectedItemsIn: navigator state.				[^self fillInListFor: navigator state] ensure: [self select: pundles]].	anAspectSymbol = #savePundle: ifTrue: [^self invalidateObjectListWidget].	(anAspectSymbol = #component:property:value:		and: [(aParameter at: 2) = #comment])			ifTrue: [^self invalidateObjectListWidget]</body></methods><methods><class-id>Refactory.Browser.InstanceVariableNavigatorPart</class-id> <category>updating widgets</category><body package="Browser-BaseUI">selectState: aNavigatorState 	| instVars |	instVars := OrderedCollection withAll: aNavigatorState instanceVariables.	self fillInListFor: aNavigatorState.	self select: instVars</body><body package="Browser-BaseUI">updateWithState: aNavigatorState 	| initialSelections |	initialSelections := self selections.	self fillInListFor: aNavigatorState.	self select: initialSelections</body></methods><methods><class-id>Refactory.Browser.InstanceVariableNavigatorPart</class-id> <category>accessing-navigator</category><body package="Browser-BaseUI">fillInState: aNavigatorState 	aNavigatorState instanceVariables: self selections</body></methods><methods><class-id>Refactory.Browser.InstanceVariableNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI">displayTextFor: anInstVarName	| text |	text := anInstVarName asText.	self navigator selectedClass		ifNotNil: 			[:selection |			(selection instVarNames includes: anInstVarName)				ifTrue: [text := text allBold]].	^text</body><body package="Browser-BaseUI">fillInListFor: aNavigatorState		self		updateListWith:			(aNavigatorState selectedClass				ifNil: [#()]				ifNotNil: #allInstVarNames)</body></methods><methods><class-id>Refactory.Browser.InstanceVariableNavigatorPart</class-id> <category>menus</category><body package="Browser-BaseUI">defaultMenu	^navigator menuNamed: #instanceVariableMenu</body></methods><methods><class-id>Refactory.Browser.ProtocolItemNavigatorPart</class-id> <category>initialize-release</category><body package="Browser-BaseUI">initialize	super initialize.	listSelector := #fillInListFor:</body><body package="Browser-BaseUI">listSelector: aSymbol 	listSelector := aSymbol.	self protocolHolder	"Initialize the protocolHolder"</body></methods><methods><class-id>Refactory.Browser.ProtocolItemNavigatorPart</class-id> <category>changing</category><body package="Browser-BaseUI">changed	self fillInProtocolForSelection.	super changed</body></methods><methods><class-id>Refactory.Browser.ProtocolItemNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI">displayTextFor: aMethodDefinition 	| text |	text := aMethodDefinition simpleDisplayText.	aMethodDefinition isOverridden 		ifTrue: [text emphasizeAllWith: (Array with: #color -&gt; self overriddenColor)].	^text</body><body package="Browser-BaseUI">fillInListWith: aNavigatorState		| newList |	newList := self perform: listSelector with: aNavigatorState.	self list == newList ifFalse: [self updateListWith: newList]</body><body package="Browser-BaseUI">fillInProtocolForSelection	| protocols firstProtocol |	protocolHolder isNil ifTrue: [^self].	protocols := self protocolsForSelection.	firstProtocol := protocols detect: [:each | true] ifNone: [nil].	self protocolHolder value: firstProtocol</body><body package="Browser-BaseUI">iconFor: aMethodDefinition		^aMethodDefinition safeToolListIcon</body><body package="Browser-BaseUI">protocolsForSelection	^(self selections collect: [:each | each protocol]) asSet asArray</body><body package="Browser-BaseUI">select: aCollection in: aSelectionInList 	super select: aCollection in: aSelectionInList.	self fillInProtocolForSelection</body><body package="Browser-BaseUI">showWarningIconForMethod: aMethodDefinition	"This method must be fast. It is called each time a method is displayed,	so its speed directly affects the speed of list display. It should not do anything more	complex than checking a few values. Absolutely no lengthy computations!"	^false</body><body package="Browser-BaseUI">showWarningIconForSharedVariable: aMethodDefinition	"This method must be fast. It is called each time a shared variable is displayed,	so its speed directly affects the speed of list display. It should not do anything more	complex than checking a few values. Absolutely no lengthy computations!"	^false</body></methods><methods><class-id>Refactory.Browser.ProtocolItemNavigatorPart</class-id> <category>aspects</category><body package="Browser-BaseUI">protocolHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^protocolHolder isNil		ifTrue:			[protocolHolder := String new asValue]		ifFalse:			[protocolHolder]</body></methods><methods><class-id>Refactory.Browser.ProtocolItemNavigatorPart</class-id> <category>menus</category><body package="Browser-BaseUI">defaultMenu	^navigator menuNamed: #selectorMenu</body></methods><methods><class-id>Refactory.Browser.ProtocolItemNavigatorPart</class-id> <category>updating widgets</category><body package="Browser-BaseUI">updateWithState: aNavigatorState 	| initialSelections |	initialSelections := self selections.	self fillInListWith: aNavigatorState.	self select: initialSelections</body></methods><methods><class-id>Refactory.Browser.ProtocolItemNavigatorPart</class-id> <category>accessing-navigator</category><body package="Browser-BaseUI">fillInState: aNavigatorState 	(aNavigatorState protocols isEmpty and: [protocolHolder notNil]) 		ifTrue: [aNavigatorState protocol: self protocolHolder value].	aNavigatorState allDefinitions: self list asArray.	aNavigatorState definitions: self selections</body></methods><methods><class-id>Refactory.Browser.ProtocolItemNavigatorPart</class-id> <category>updating</category><body package="Browser-BaseUI">addItemChange	self mergeIntoList: ((self perform: listSelector with: navigator state) 				asSortedCollection: self sortBlock)</body><body package="Browser-BaseUI">changeSetUpdate: anAspectSymbol with: aParameter 	anAspectSymbol == #removeSelector:class: 		ifTrue: [self removeMethodChange: aParameter].	(#(#removeBinding:in: #relocateBinding:from:to:) includes: anAspectSymbol) 		ifTrue: [self removeBindingChange: aParameter].	(#(#addBinding:in: #addBinding:in:attributes: #addSelector:class: #addSelector:class:attributes:) 		includes: anAspectSymbol) ifTrue: [self addItemChange]</body><body package="Browser-BaseUI">removeBindingChange: aParameter 	self list removeAllSuchThat: 			[:each | 			each isForSharedVariable and: 					[each classOrNameSpace == (aParameter at: 2) 						and: [each variableName == (aParameter at: 1) key]]]</body><body package="Browser-BaseUI">removeMethodChange: aParameter 	self list removeAllSuchThat: 			[:each | 			each isForSharedVariable not and: 					[each implementingClass == (aParameter at: 2) 						and: [each selector == (aParameter at: 1)]]]</body></methods><methods><class-id>Refactory.Browser.ProtocolItemNavigatorPart</class-id> <category>testing</category><body package="Browser-BaseUI">showIcons	^true</body></methods><methods><class-id>Refactory.Browser.ProtocolItemNavigatorPart class</class-id> <category>accessing</category><body package="Browser-BaseUI">showAllItemsWhenNothingSelected	^ShowAllItemsWhenNothingSelected</body><body package="Browser-BaseUI">showAllItemsWhenNothingSelected: aBoolean 	ShowAllItemsWhenNothingSelected := aBoolean</body></methods><methods><class-id>Refactory.Browser.SelectorNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI">allSelectorsIn: aNavigatorState	| selectors classes class |	classes := aNavigatorState selectedClasses.	classes size ~= 1 ifTrue: [^#()].	class := classes asArray first.	selectors := self environment selectorsForClass: class.	^selectors collect: [:each | RBMethodDefinition class: class selector: each]</body><body package="Browser-BaseUI">displayTextFor: aMethodDefinition		| text |	text := super displayTextFor: aMethodDefinition.	navigator showOnlyFiltered ifTrue: [^text].	(navigator packages		anySatisfy:			[:each | 			each				definesSelector: aMethodDefinition selector				forClass: aMethodDefinition implementingClass])		ifTrue:			[text addEmphasis: #(#bold) removeEmphasis: #() allowDuplicates: false].	^text</body><body package="Browser-BaseUI">fillInListFor: aNavigatorState 	| protocols |	protocols := aNavigatorState protocols.	(protocols isEmpty and: [self class showAllItemsWhenNothingSelected]) 		ifTrue: [protocols := self allProtocolsIn: aNavigatorState].	^self methodDefinitionsFor: protocols in: aNavigatorState selectedClass</body><body package="Browser-BaseUI">instanceVariableSelectorsIn: aNavigatorState 	| class instanceVariables defs indices |	instanceVariables := aNavigatorState instanceVariables.	defs := self methodDefinitionsFor: (self allProtocolsIn: aNavigatorState)				in: aNavigatorState selectedClass.	instanceVariables isEmpty ifTrue: [^defs].	class := aNavigatorState selectedClass.	class isNil ifTrue: [^#()].	indices := instanceVariables 				collect: [:each | class instVarIndexFor: each].	^defs select: 			[:each | 			indices anySatisfy: 					[:index | 					(InstanceVariableSearch new)						method: each method;						searchFor: index - 1 type: #readWrite]]</body><body package="Browser-BaseUI">methodDefinitionsFor: protocols in: class 	| selectors |	selectors := OrderedCollection new.	class notNil 		ifTrue: 			[protocols do: [:each | selectors addAll: (self methodDefinitionsIn: each)]].	^selectors</body><body package="Browser-BaseUI">sortBlock	^	[:a :b | 	a selector &lt; b selector or: 			[a selector = b selector and: 					[a implementingClass allSuperclasses size 						&gt; b implementingClass allSuperclasses size]]]</body></methods><methods><class-id>Refactory.Browser.SelectorNavigatorPart</class-id> <category>updating widgets</category><body package="Browser-BaseUI">newSelectionsBasedOn: oldSelections 	| newSelections |	newSelections := OrderedCollection new: oldSelections size.	oldSelections do: 			[:each | 			| new |			new := nil.			each implementingClass = each inheritingClass 				ifFalse: 					[new := self list detect: 									[:def | 									def selector = each selector 										and: [each implementingClass = def implementingClass]]								ifNone: [nil]].			new isNil 				ifTrue: 					[new := self list detect: [:def | def selector = each selector]								ifNone: [nil]].			new notNil ifTrue: [newSelections add: new]].	^newSelections</body><body package="Browser-BaseUI">selectState: aNavigatorState 	self fillInListWith: aNavigatorState.	self select: aNavigatorState definitions</body><body package="Browser-BaseUI">updateWithState: aNavigatorState 	| initialSelections |	initialSelections := self selections.	self fillInListWith: aNavigatorState.	self select: (self newSelectionsBasedOn: initialSelections).	aNavigatorState definitions: self selections</body></methods><methods><class-id>Refactory.Browser.RBCommand</class-id> <category>accessing</category><body package="Browser-BaseUI">action	^action</body><body package="Browser-BaseUI">action: aSymbol 	action := aSymbol</body><body package="Browser-BaseUI">description	^description</body><body package="Browser-BaseUI">description: aString 	description := aString</body><body package="Browser-BaseUI">enabled	^enabled</body><body package="Browser-BaseUI">enabled: aSymbol 	enabled := aSymbol</body><body package="Browser-BaseUI">key	^name isString		ifTrue: [name]		ifFalse: [name defaultString]</body><body package="Browser-BaseUI">name	^name</body><body package="Browser-BaseUI">name: aString 	name := aString</body><body package="Browser-BaseUI">receiver	^receiver</body><body package="Browser-BaseUI">receiver: aSymbol 	receiver := aSymbol</body></methods><methods><class-id>Refactory.Browser.RBCommand</class-id> <category>comparing</category><body package="Browser-BaseUI">= aRBActionSpecification 	^self class = aRBActionSpecification class and: 			[self key = aRBActionSpecification key 				and: [self receiver = aRBActionSpecification receiver]]</body><body package="Browser-BaseUI">hash	^self key hash bitXor: self receiver hash</body></methods><methods><class-id>Refactory.Browser.RBCommand</class-id> <category>initialize-release</category><body package="Browser-BaseUI">initialize	name := 'A name'.	description := 'A description'.	action := #yourself.	receiver := #yourself</body></methods><methods><class-id>Refactory.Browser.RBCommand</class-id> <category>testing</category><body package="Browser-BaseUI">isCheckedActionSpecification	^false</body><body package="Browser-BaseUI">isEnabledFor: anObject 	| receiverObj |	receiverObj := [self receiverFor: anObject] on: Error do: [:ex | ^false].	(action isSymbol not or: [receiverObj respondsTo: action]) 		ifFalse: [^false].	enabled isNil ifTrue: [^true].	enabled isSymbol ifFalse: [^enabled value: receiverObj].	^[self perform: enabled on: receiverObj] on: Error		do: 			[:ex | 			ex return: ([self perform: enabled on: anObject] on: Error						do: [:exc | exc return: false])]</body></methods><methods><class-id>Refactory.Browser.RBCommand</class-id> <category>converting</category><body package="Browser-BaseUI">literalArrayEncoding	^(Array new: 6)		at: 1 put: self class fullyQualifiedReference;		at: 2 put: self nameUserMessage literalArrayEncoding;		at: 3 put: self descriptionUserMessage literalArrayEncoding;		at: 4 put: self action;		at: 5 put: self enabled;		at: 6 put: self receiver;		yourself</body></methods><methods><class-id>Refactory.Browser.RBCommand</class-id> <category>printing</category><body package="Browser-BaseUI">printOn: aStream 	aStream nextPutAll: self key</body></methods><methods><class-id>Refactory.Browser.RBCommand</class-id> <category>actions</category><body package="Browser-BaseUI">performWith: anObject 	^action isSymbol 		ifTrue: [self perform: action on: (self receiverFor: anObject)]		ifFalse: 			[action numArgs = 1 				ifTrue: [action value: (self receiverFor: anObject)]				ifFalse: [action value]]</body><body package="Browser-BaseUI">receiverFor: anObject 	^self perform: receiver on: anObject</body></methods><methods><class-id>Refactory.Browser.RBCommand</class-id> <category>private</category><body package="Browser-BaseUI">descriptionUserMessage	(description respondsTo: #catalogID)		ifTrue: [^description].	^UserMessage		defaultString: description		key: (self userMessageKey, 'Desc') asSymbol		catalogID: #browser</body><body package="Browser-BaseUI">nameUserMessage	(name respondsTo: #catalogID)		ifTrue: [^name].	^UserMessage		defaultString: name		key: self userMessageKey		catalogID: #browser</body><body package="Browser-BaseUI">perform: aSymbol on: anObject 	^(anObject respondsTo: aSymbol) 		ifTrue: [anObject perform: aSymbol]		ifFalse: [Error raise]</body><body package="Browser-BaseUI">userMessageKey	| result input upper |	(name respondsTo: #catalogID)		ifTrue: [^name key].	result := WriteStream on: (String new: 50).	input := name readStream.	upper := true.	result nextPutAll: 'Cmd'.	[input atEnd] whileFalse:		[ | char |		char := input next.		(char isLetter or: [char isDigit]) ifTrue:			[result nextPut: (upper ifTrue: [char asUppercase] ifFalse: [char])].		char = $: ifTrue: 	[result nextPut: $C].		char = $&amp; ifTrue: [result nextPut: $_].		char = $. ifTrue: [result nextPut: $D].		upper := char isSeparator].	^result contents asSymbol</body></methods><methods><class-id>Refactory.Browser.RBCommand class</class-id> <category>actions</category><body package="Browser-BaseUI">actionNamed: aString	^self actions at: aString ifAbsent: [self error: 'Action not found']</body><body package="Browser-BaseUI">actions	Actions isNil ifTrue: [self initializeActions].	^Actions</body><body package="Browser-BaseUI">addAction: aRBActionSpecification 	(Actions includesKey: aRBActionSpecification key)		ifTrue: 			[self 				halt: 'The action already exists. Select proceed to override the original action.'].	Actions at: aRBActionSpecification key put: aRBActionSpecification</body><body package="Browser-BaseUI">allCommandsMatching: aString		| results pattern |	aString isEmpty ifTrue: [^Array new].	results := IdentitySet new: 100.	pattern := aString last = $*		ifTrue:			[results add: #*.			aString]		ifFalse: [aString , '*'].	self actions keysDo:		[:each |		(pattern match: each asString) ifTrue:			[results add: each.			results size &gt; 500 ifTrue: [^results sorted]]].	^results sorted</body><body package="Browser-BaseUI">removeAction: aRBActionSpecification 	| action |	action := Actions at: aRBActionSpecification key ifAbsent: [^self].	action == aRBActionSpecification ifFalse: [^self].	Actions removeKey: aRBActionSpecification key</body></methods><methods><class-id>Refactory.Browser.RBCommand class</class-id> <category>instance creation</category><body package="Browser-BaseUI">decodeFromLiteralArray: anArray 	^self 		named: (self decodeStringOrArray: (anArray at: 2))		description: (self decodeStringOrArray: (anArray at: 3))		action: (anArray at: 4)		enabled: (anArray at: 5)		receiver: (anArray at: 6)</body><body package="Browser-BaseUI">named: aStringOrUserMessage	^(self new)		name: aStringOrUserMessage;		description: aStringOrUserMessage;		yourself</body><body package="Browser-BaseUI">named: aStringOrUserMessage description: aDescriptionString action: aSelector enabled: enabledSelector receiver: receiverSelector 	^(self new)		name: aStringOrUserMessage;		description: aDescriptionString;		action: aSelector;		enabled: enabledSelector;		receiver: receiverSelector;		yourself</body><body package="Browser-BaseUI">named: aStringOrUserMessage description: aDescriptionString action: aSelector receiver: receiverSelector 	^(self new)		name: aStringOrUserMessage;		description: aDescriptionString;		action: aSelector;		receiver: receiverSelector;		yourself</body><body package="Browser-BaseUI">new	^(super new)		initialize;		yourself</body></methods><methods><class-id>Refactory.Browser.RBCommand class</class-id> <category>actions-initialization</category><body package="Browser-BaseUI">actionArray	"This method was automatically generated from 'Refactory.Browser.RBActionEditor open'"	"self initializeActions"	^#(#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #AbstractClassInstanceVariable #defaultString: 'Abstract Class Instance Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #AbstractClassInstanceVariableDesc #defaultString: 'Create accessing methods for a class instance variable and change all direct variable references to use them' #catalogID: #browser) #abstractClassInstanceVariable #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #AbstractInstanceVariable #defaultString: 'Abstract Instance Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #AbstractInstanceVariableDesc #defaultString: 'Create accessing methods for an instance variable and change all direct variable references to use them' #catalogID: #browser) #abstractInstanceVariable #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #AbstractSelectedInstanceVariable #defaultString: 'Abstract Selected Instance Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #AbstractSelectedInstanceVariableDesc #defaultString: 'Abstract all references to the selected variable to use accessing methods' #catalogID: #browser) #abstractInstanceVariable #hasInstanceVariableSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #Accept #defaultString: 'Accept' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #AcceptDesc #defaultString: 'Save the current text' #catalogID: #browser) #acceptText #isEditing #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #AddActionSpecification #defaultString: 'Add Action Specification' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #AddActionSpecificationDesc #defaultString: 'Create a new action specification' #catalogID: #browser) #addSpecification nil #yourself)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #AddClassInstanceVariable #defaultString: 'Add Class Instance Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #AddClassInstanceVariableDesc #defaultString: 'Add a class instance variable to the selected class' #catalogID: #browser) #addClassInstanceVariable #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #AddFromChangeSet #defaultString: 'Add from Change Set' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #AddFromChangeSetDesc #defaultString: 'Add contents of the current change set' #catalogID: #browser) #checkChangeSet nil #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #AddInstanceVariable #defaultString: 'Add Instance Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #AddInstanceVariableDesc #defaultString: 'Add an instance variable to the selected class' #catalogID: #browser) #addInstanceVariable #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #AddParameter #defaultString: 'Add Parameter' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #AddParameterDesc #defaultString: 'Add a parameter to the selected method and change all senders to pass a default argument' #catalogID: #browser) #addParameter #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #AddProtocol #defaultString: 'Add Protocol' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #AddProtocolDesc #defaultString: 'Add a new protocol to the class' #catalogID: #browser) #addProtocol #isBindingSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #BindTemporaryToTightestScope #defaultString: 'Bind Temporary to Tightest Scope' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #BindTemporaryToTightestScopeDesc #defaultString: 'Move a temporary variable''s definition to the innermost scope in which it is used' #catalogID: #browser) #bindTight #hasTemporarySelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #BrowseChangeSetMethodVersions #defaultString: 'Browse Change Set Method Versions' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #BrowseChangeSetMethodVersionsDesc #defaultString: 'Open a change list on all versions of the method in the .cha file.' #catalogID: #browser) #browseMethodChanges #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #BrowseClassMethodsMatchingString #defaultString: 'Browse Class Methods Matching String' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #BrowseClassMethodsMatchingStringDesc #defaultString: 'Open a browser on all methods of the selected class matching a pattern.' #catalogID: #browser) #browseMethodsWithSourceMatching #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #BrowseOverridden #defaultString: 'Browse Overridden' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #BrowseOverriddenDesc #defaultString: 'Browse all methods overridden by other components' #catalogID: #browser) #browseOverridden #isCodeComponentSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #BrowseOverrides #defaultString: 'Browse Overrides' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #BrowseOverridesDesc #defaultString: 'Browse all methods overridden by the current selection' #catalogID: #browser) #browseOverrides #isCodeComponentSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #BrowseReferencesToClass #defaultString: 'Browse References to Class' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #GlobalClassReferencesDesc #defaultString: 'Browse all references to the selected class' #catalogID: #browser) #browseReferencesToGlobal #hasClassSelected #activeTool)	#(#{Refactory.Browser.RBDynamicMultiCommand} #(#{Kernel.UserMessage} #key: #Buffers #defaultString: 'Buffers' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #BuffersDesc #defaultString: 'Dynamic menu of buffers' #catalogID: #browser) #bufferMenuSpecifications nil #browser)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #ByteIndexedClassTemplate #defaultString: 'Byte Indexed Class Template' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ByteIndexedClassTemplateDesc #defaultString: 'Display a template for creating a byte-indexed class' #catalogID: #browser) #showBytesClassTemplate #canDefineClassesAndNameSpaces #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CancelDesc #defaultString: 'Cancel changes and revert to the original text' #catalogID: #browser) #cancelText #isEditing #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CheckAllImplementors #defaultString: 'Check All Implementors' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CheckAllImplementorsDesc #defaultString: 'Add all implementors of the selected method' #catalogID: #browser) #checkImplementors #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CheckAllMethods #defaultString: 'Check All Methods' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CheckAllMethodsDesc #defaultString: 'Add all methods matching a pattern' #catalogID: #browser) #checkAllSelectors #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CheckAllProtocols #defaultString: 'Check All Protocols' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CheckAllProtocolsDesc #defaultString: 'Add all protocols matching a pattern' #catalogID: #browser) #checkAllProtocols #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CheckAllSenders #defaultString: 'Check All Senders' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CheckAllSendersDesc #defaultString: 'Add all senders of the selected method' #catalogID: #browser) #checkSenders #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CheckAllSubclasses #defaultString: 'Check All Subclasses' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CheckAllSubclassesDesc #defaultString: 'Add all the class'' subclasses' #catalogID: #browser) #checkSubclasses #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CheckAllSuperclasses #defaultString: 'Check All Superclasses' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CheckAllSuperclassesDesc #defaultString: 'Add all the class'' superclasses' #catalogID: #browser) #checkSuperclasses #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CheckClass #defaultString: 'Check Class' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CheckClassDesc #defaultString: 'Add the selected class' #catalogID: #browser) #checkClass #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CheckMethod #defaultString: 'Check Method' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CheckMethodDesc #defaultString: 'Add the selected methods' #catalogID: #browser) #checkSelector #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CheckProtocol #defaultString: 'Check Protocol' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CheckProtocolDesc #defaultString: 'Add the selected protocols' #catalogID: #browser) #checkProtocol #isProtocolSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #ClassesDefiningVariable #defaultString: 'Classes Defining Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ReferencesToSymbolDesc #defaultString: 'Find references to a symbol within the current scope of the browser' #catalogID: #browser) #browseVariables nil #browser)	#(#{Refactory.Browser.RBDynamicMultiCommand} #(#{Kernel.UserMessage} #key: #CodeModelToolsMenu #defaultString: 'Code Model Tools Menu' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CodeModelToolsMenuDesc #defaultString: 'List of tool views supported by the code model' #catalogID: #browser) #selectionPolicyMenuSpecifications nil #codeModel)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #ContextHelp #defaultString: 'Context Help' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ContextHelpDesc #defaultString: 'Open context sensitive help' #catalogID: #browser) #help nil #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #ConvertTemporaryVariableToInstanceVariable #defaultString: 'Convert Temporary Variable to Instance Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ConvertTemporaryVariableToInstanceVariableDesc #defaultString: 'Convert the selected temporary variable to an instance variable' #catalogID: #browser) #createInstVar #canPerformTemporaryVariableRefactorings #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #ConvertToSibling #defaultString: 'Convert to Sibling' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ConvertToSiblingDesc #defaultString: 'Create an abstract class and make the selected class a sibling with its subclasses under the new abstract class' #catalogID: #browser) #convertToSibling #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CopyMethodToClass #defaultString: 'Copy Method to Class' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CopyMethodToClassDesc #defaultString: 'Copy the selected method(s) to another class' #catalogID: #browser) #copyMethodToClass #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CopyMethodToClassSide #defaultString: 'Copy Method to Class Side' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CopyMethodToClassSideDesc #defaultString: 'Copy the selected instance side method(s) to class side of this or another class' #catalogID: #browser) #copyMethodToClassSide #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CopyMethodToInstanceSide #defaultString: 'Copy Method to Instance Side' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CopyMethodToInstanceSideDesc #defaultString: 'Copy the selected class side method(s) to instance side of this or another class' #catalogID: #browser) #copyMethodToInstanceSide #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CopyProtocolToClass #defaultString: 'Copy Protocol to Class' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CopyProtocolToClassDesc #defaultString: 'Copy the selected protocol(s) to another class' #catalogID: #browser) #copyProtocolToClass #isProtocolSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CopyProtocolToClassSide #defaultString: 'Copy Protocol to Class Side' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CopyProtocolToClassSideDesc #defaultString: 'Copy the selected instance side protocol(s) to the class side of this or another class' #catalogID: #browser) #copyProtocolToClassSide #isProtocolSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CopyProtocolToInstanceSide #defaultString: 'Copy Protocol to Instance Side' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CopyProtocolToInstanceSideDesc #defaultString: 'Copy the selected class side protocol(s) to the instance side of this or another class' #catalogID: #browser) #copyProtocolToInstanceSide #isProtocolSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CopySelection #defaultString: 'Copy Selection' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #Copy #defaultString: 'Copy' #catalogID: #browser) #copySelection #isTextSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CreateBuffer #defaultString: 'Create Buffer' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CreateBufferDesc #defaultString: 'Create a new view' #catalogID: #browser) #newBuffer nil #browser)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CreateClassInstanceVariableAccessors #defaultString: 'Create Class Instance Variable Accessors' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CreateInstanceVariableAccessorsDesc #defaultString: 'Create accessing methods for the selected instance variable' #catalogID: #browser) #createClassInstanceVariableAccessors #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CreateInstanceVariableAccessors #defaultString: 'Create Instance Variable Accessors' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CreateInstanceVariableAccessorsDesc #defaultString: 'Create accessing methods for the selected instance variable' #catalogID: #browser) #createInstanceVariableAccessors #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CreateSelectedInstanceVariableAccessors #defaultString: 'Create Selected Instance Variable Accessors' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CreateInstanceVariableAccessorsDesc #defaultString: 'Create accessing methods for the selected instance variable' #catalogID: #browser) #createInstanceVariableAccessors #hasInstanceVariableSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CreateSubclass #defaultString: 'Create Subclass' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CreateSubclassDesc #defaultString: 'Insert a class into the class hierarchy under the currently selected class' #catalogID: #browser) #createSubclass #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CutSelection #defaultString: 'Cut Selection' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #Cut #defaultString: 'Cut' #catalogID: #browser) #cut #isTextSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #DebugIt #defaultString: 'Debug It' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #DebugItDesc #defaultString: 'Open a debugger on the currently selected code' #catalogID: #browser) #debugIt nil #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #DoIt #defaultString: 'Do It' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #DoItDesc #defaultString: 'Execute the selected text' #catalogID: #browser) #doIt nil #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #ExplainCode #defaultString: 'Explain Code' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ExplainCodeDesc #defaultString: 'Explain the selected piece of code' #catalogID: #browser) #explain #isTextSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #ExtractMethod #defaultString: 'Extract Method' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ExtractMethodDesc #defaultString: 'Extract the selected code into a new method' #catalogID: #browser) #extractMethod #canExtractMethod #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #ExtractMethodToComponent #defaultString: 'Extract Method to Component' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ExtractMethodToComponentDesc #defaultString: 'Extract the selected code into a method in a different class' #catalogID: #browser) #extractToComponent #canExtractMethod #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #ExtractToTemporary #defaultString: 'Extract to Temporary' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ExtractToTemporaryDesc #defaultString: 'Create a temporary variable assigned to the selection and replace it with the temporary' #catalogID: #browser) #extractToTemp #canExtractToTemporary #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #FileIntoPackage #defaultString: 'File Into Package' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #FileIntoPackageDesc #defaultString: 'Load Smalltalk source, compiling it into the selected package' #catalogID: #browser) #storeFileinPackage #isPackageSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #FileOutClass #defaultString: 'File Out Class' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #FileOutClassDesc #defaultString: 'File-out the selected classes' #catalogID: #browser) #fileOutClass #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CmdFileOutGlobal #defaultString: 'File Out Global' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CmdFileOutGlobalDesc #defaultString: 'File-out the selected class or namespace' #catalogID: #browser) #fileOutGlobal #isGlobalSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #FileOutMethod #defaultString: 'File Out Method' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #FileOutMethodDesc #defaultString: 'File-out the selected methods' #catalogID: #browser) #fileOutMessage #isDefinitionSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #FileOutPackage #defaultString: 'File Out Package' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #FileOutPackageDesc #defaultString: 'File-out the selected package' #catalogID: #browser) #storeFileoutPundle #isPundleSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #FileOutPackageChanges #defaultString: 'File Out Package Changes' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #FileOutPackageChangesDesc #defaultString: 'File-out the selected package''s changes' #catalogID: #browser) #storeFileoutPundleChanges #isPundleSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #FileOutPackageDifferences #defaultString: 'File Out Package Differences' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #FileOutPackageDifferencesDesc #defaultString: 'File-out the differences between the selected package and a version saved in the repository' #catalogID: #browser) #storeFileoutPundleDifferences #isPundleSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #FileOutProtocol #defaultString: 'File Out Protocol' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #FileOutProtocolDesc #defaultString: 'File-out all methods in the selected protocols' #catalogID: #browser) #fileOutProtocol #isProtocolSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #FindClass #defaultString: 'Find Class' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #FindClassDesc #defaultString: 'Find a class' #catalogID: #browser) #findClass nil #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CmdFindGlobalName #defaultString: 'Find Global Name' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CmdFindGlobalNameDesc #defaultString: 'Find a class, a shared variable, or a name space' #catalogID: #browser) #findGlobalName nil #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #FindMethod #defaultString: 'Find Method' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #FindMethodDesc #defaultString: 'Find a method within the selected class' #catalogID: #browser) #findMethodAndSelectAlphabetic #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #FindNameSpace #defaultString: 'Find Name Space' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #FindNameSpaceDesc #defaultString: 'Find a name space.' #catalogID: #browser) #findNameSpace nil #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #FindPackage #defaultString: 'Find Package' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #FindPackageDesc #defaultString: 'Find a bundle or package' #catalogID: #browser) #findPundle nil #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #FindSharedVariable #defaultString: 'Find Shared Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #FindSharedVariableDesc #defaultString: 'Find a Shared Variable' #catalogID: #browser) #findSharedVariable nil #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #FindText #defaultString: 'Find Text' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #FindTextDesc #defaultString: 'Find the specified text' #catalogID: #browser) #find #isTextTool #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #FormatCode #defaultString: 'Format Code' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #FormatCodeDesc #defaultString: 'Format a method' #catalogID: #browser) #format nil #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #GenerateDefaultClassComment #defaultString: 'Generate Default Class Comment' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #GenerateDefaultClassCommentDesc #defaultString: 'Generate a default class comment for the selected class' #catalogID: #browser) #generateDefaultComment nil #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #GlobalClassInstanceVariableReaders #defaultString: 'Global Class Instance Variable Readers' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #GlobalClassInstanceVariableReadersDesc #defaultString: 'Browse all methods accessing a class instance variable' #catalogID: #browser) #globalClassInstanceVariableReaders #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #GlobalClassInstanceVariableReferences #defaultString: 'Global Class Instance Variable References' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #GlobalClassInstanceVariableReferencesDesc #defaultString: 'Browse all references to a class instance variable' #catalogID: #browser) #globalClassInstanceVariableReferences #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #GlobalClassInstanceVariableWriters #defaultString: 'Global Class Instance Variable Writers' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #GlobalClassInstanceVariableWritersDesc #defaultString: 'Browse all methods modifying a class instance variable' #catalogID: #browser) #globalClassInstanceVariableWriters #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #GlobalClassReferences #defaultString: 'Global Class References' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #GlobalClassReferencesDesc #defaultString: 'Browse all references to the selected class' #catalogID: #browser) #globalClassRefs #isBindingSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #GlobalImplementors #defaultString: 'Global Implementors' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ImplementorsDesc #defaultString: 'Browse all implementors of the selected method' #catalogID: #browser) #browseGlobalImplementors #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBDynamicMultiCommand} #(#{Kernel.UserMessage} #key: #GlobalImplementorsActions #defaultString: 'Global Implementors Actions' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ImplementorsActionsDesc #defaultString: 'Actions for Implementors' #catalogID: #browser) #globalImplementorsActions #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #GlobalInstanceVariableReaders #defaultString: 'Global Instance Variable Readers' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #GlobalInstanceVariableReadersDesc #defaultString: 'Browse all methods accessing an instance variable' #catalogID: #browser) #globalInstanceVariableReaders #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #GlobalInstanceVariableReferences #defaultString: 'Global Instance Variable References' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #GlobalInstanceVariableReferencesDesc #defaultString: 'Browse all references to an instance variable' #catalogID: #browser) #globalInstanceVariableReferences #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #GlobalInstanceVariableWriters #defaultString: 'Global Instance Variable Writers' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #GlobalInstanceVariableWritersDesc #defaultString: 'Browse all methods modifying an instance variable' #catalogID: #browser) #globalInstanceVariableWriters #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #GlobalReferences #defaultString: 'Global References' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ReferencesDesc #defaultString: 'Browse all references to the specified shared variable' #catalogID: #browser) #browseReferencesToGlobal #hasGlobalSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #GlobalSenders #defaultString: 'Global Senders' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #SendersDesc #defaultString: 'Browse all senders of the selected method' #catalogID: #browser) #browseGlobalSenders #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBDynamicMultiCommand} #(#{Kernel.UserMessage} #key: #GlobalSendersActions #defaultString: 'Global Senders Actions' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #SendersActionsDesc #defaultString: 'Actions for Senders' #catalogID: #browser) #globalSendersActions #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #GlobalSharedVariableReferences #defaultString: 'Global Shared Variable References' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #GlobalSharedVariableReferencesDesc #defaultString: 'Browse all references to a shared variable' #catalogID: #browser) #globalSharedVariableReferences #isSharedVariableSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #HardcopyClass #defaultString: 'Hardcopy Class' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #HardcopyClassDesc #defaultString: 'Print the selected classes' #catalogID: #browser) #printOutClass #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #HardcopyMethod #defaultString: 'Hardcopy Method' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #HardcopyMethodDesc #defaultString: 'Print the selected methods' #catalogID: #browser) #printOutMessage #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #HardcopyProtocol #defaultString: 'Hardcopy Protocol' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #HardcopyProtocolDesc #defaultString: 'Print all methods in the selected protocols' #catalogID: #browser) #printOutProtocol #isProtocolSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #HardcopyText #defaultString: 'Hardcopy Text' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #HardcopyTextDesc #defaultString: 'Print the current text' #catalogID: #browser) #hardcopy #isTextTool #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #HierarchyImplementors #defaultString: 'Hierarchy Implementors' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #HierarchyImplementorsDesc #defaultString: 'Browse all implementors of the selected method within the hierarchy' #catalogID: #browser) #browseHierarchyImplementors #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBDynamicMultiCommand} #(#{Kernel.UserMessage} #key: #HierarchyImplementorsActions #defaultString: 'Hierarchy Implementors Actions' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #HierarchyImplementorsActionsDesc #defaultString: 'Dynamic menu of hierarchy implementors.' #catalogID: #browser) #hierarchyImplementorsActions #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #HierarchySenders #defaultString: 'Hierarchy Senders' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #HierarchySendersDesc #defaultString: 'Browse all senders of the specified method in the hierarchy' #catalogID: #browser) #browseHierarchySenders #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBDynamicMultiCommand} #(#{Kernel.UserMessage} #key: #HierarchySendersActions #defaultString: 'Hierarchy Senders Actions' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #HierarchySendersActionsDesc #defaultString: 'Dynamic menu of hierarchy senders' #catalogID: #browser) #hierarchySendersActions #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #IconHelp #defaultString: 'Icon Help' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #IconHelpDesc #defaultString: 'Opens help for the browser''s icons.' #catalogID: #browser) #iconsHelp nil #browser)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #ImplementorsMatching #defaultString: 'Implementors Matching' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ImplementorsMatchingDesc #defaultString: 'Find all implementors whose selector matches the selector within the current scope of the browser' #catalogID: #browser) #browseImplementors nil #browser)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #IndexedClassTemplate #defaultString: 'Indexed Class Template' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #IndexedClassTemplateDesc #defaultString: 'Display a template for creating an indexed class' #catalogID: #browser) #showIndexedClassTemplate #canDefineClassesAndNameSpaces #activeTool)	#(#{Refactory.Browser.RBDynamicMultiCommand} #(#{Kernel.UserMessage} #key: #InheritedClassesSpecifications #defaultString: 'Inherited Classes Specifications' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #InheritedClassesSpecificationsDesc #defaultString: 'A dynamic menu showing the superclasses for inheriting methods. ' #catalogID: #browser) #inheritToSpecifications #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #InitializeSharedVariable #defaultString: 'Initialize Shared Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #InitializeSharedVariableDesc #defaultString: 'Initialize a shared variable' #catalogID: #browser) #initializeSharedVariable #isSharedVariableSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #InlineAllSelfSends #defaultString: 'Inline All Self Sends' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #InlineAllSelfSendsDesc #defaultString: 'Inline the selected method into all senders of self, removing the method if there are no senders' #catalogID: #browser) #inlineSelfSends #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #InlineMethod #defaultString: 'Inline Method' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #InlineMethodDesc #defaultString: 'Inline the selected message send into the containing method; replace the original message send with the body of the method that is sent' #catalogID: #browser) #inlineMethod #hasMessageNodeSelectedForRefactoring #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #InlineParameter #defaultString: 'Inline Parameter' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #InlineParameterDesc #defaultString: 'Convert the parameter of the method into a temporary defined in the method if all senders have the same argument' #catalogID: #browser) #inlineParameter #hasMethodArgumentSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #InlineSelectedMessage #defaultString: 'Inline Selected Message' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #InlineSelectedMessageDesc #defaultString: 'Inline the selected message into the current method' #catalogID: #browser) #inlineMethod #hasMessageNodeSelectedForRefactoring #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #InlineSelectedParameter #defaultString: 'Inline Selected Parameter' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #InlineSelectedParameterDesc #defaultString: 'Inline the selected parameter from all senders' #catalogID: #browser) #inlineParameter #canPerformParameterRefactorings #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #InlineTemporary #defaultString: 'Inline Temporary' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #InlineTemporaryDesc #defaultString: 'Change all references to the temporary variable to its definition' #catalogID: #browser) #inlineTemporary #canPerformInlineAssignmentRefactoring #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #InspectAllInstances #defaultString: 'Inspect All Instances' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #InspectAllInstancesDesc #defaultString: 'Inspect all instances of the selected class' #catalogID: #browser) #inspectAllInstances #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #InspectIt #defaultString: 'Inspect It' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #InspectItDesc #defaultString: 'Evaluate the selected text and inspect the result' #catalogID: #browser) #inspectIt nil #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #InspectMethod #defaultString: 'Inspect Method' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #InspectMethodDesc #defaultString: 'Inspect the selected method' #catalogID: #browser) #inspectMethod #isDefinitionSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CmdInspectShared #defaultString: 'Inspect Shared' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CmdInspectSharedDesc #defaultString: 'Inspect the selected shared variable' #catalogID: #browser) #inspectSharedVariable #isDefinitionSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #LocalBrowseSelectedInstanceVariableReaders #defaultString: 'Local Browse Selected Instance Variable Readers' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #LocalInstanceVariableReadersDesc #defaultString: 'Browse all methods accessing the instance variable within the current scope of the browser' #catalogID: #browser) #browseInstVarReaders #isInstanceVariableSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #LocalBrowseSelectedInstanceVariableReferences #defaultString: 'Local Browse Selected Instance Variable References' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #LocalInstanceVariableReferencesDesc #defaultString: 'Browse all methods referencing the instance variable within the current scope of the browser' #catalogID: #browser) #browseInstVarRefs #isInstanceVariableSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #LocalBrowseSelectedInstanceVariableWriters #defaultString: 'Local Browse Selected Instance Variable Writers' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #LocalInstanceVariableWritersDesc #defaultString: 'Browse all methods modifying the instance variable within the current scope of the browser' #catalogID: #browser) #browseInstVarWriters #isInstanceVariableSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #LocalClassInstanceVariableReaders #defaultString: 'Local Class Instance Variable Readers' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #LocalClassInstanceVariableReadersDesc #defaultString: 'Browse all methods accessing the class instance variable within the current scope of the browser' #catalogID: #browser) #classInstanceVariableReaders #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #LocalClassInstanceVariableReferences #defaultString: 'Local Class Instance Variable References' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #LocalClassInstanceVariableReferencesDesc #defaultString: 'Browse all methods referencing the class instance variable within the current scope of the browser' #catalogID: #browser) #classInstanceVariableReferences #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #LocalClassInstanceVariableWriters #defaultString: 'Local Class Instance Variable Writers' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #LocalClassInstanceVariableWritersDesc #defaultString: 'Browse all methods modifying the class instance variable within the current scope of the browser' #catalogID: #browser) #classInstanceVariableWriters #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #LocalClassReferences #defaultString: 'Local Class References' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #LocalClassReferencesDesc #defaultString: 'Browse all methods referencing the selected class within the current scope of the browser' #catalogID: #browser) #classRefs #isBindingSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #LocalImplementors #defaultString: 'Local Implementors' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ImplementorsDesc #defaultString: 'Browse all implementors of the selected method' #catalogID: #browser) #browseLocalImplementors #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBDynamicMultiCommand} #(#{Kernel.UserMessage} #key: #LocalImplementorsActions #defaultString: 'Local Implementors Actions' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ImplementorsActionsDesc #defaultString: 'Actions for Implementors' #catalogID: #browser) #localImplementorsActions #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #LocalInstanceVariableReaders #defaultString: 'Local Instance Variable Readers' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #LocalInstanceVariableReadersDesc #defaultString: 'Browse all methods accessing the instance variable within the current scope of the browser' #catalogID: #browser) #instanceVariableReaders #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #LocalInstanceVariableReferences #defaultString: 'Local Instance Variable References' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #LocalInstanceVariableReferencesDesc #defaultString: 'Browse all methods referencing the instance variable within the current scope of the browser' #catalogID: #browser) #instanceVariableReferences #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #LocalInstanceVariableWriters #defaultString: 'Local Instance Variable Writers' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #LocalInstanceVariableWritersDesc #defaultString: 'Browse all methods modifying the instance variable within the current scope of the browser' #catalogID: #browser) #instanceVariableWriters #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #LocalSenders #defaultString: 'Local Senders' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #SendersDesc #defaultString: 'Browse all senders of the selected method' #catalogID: #browser) #browseLocalSenders #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBDynamicMultiCommand} #(#{Kernel.UserMessage} #key: #LocalSendersActions #defaultString: 'Local Senders Actions' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #SendersActionsDesc #defaultString: 'Actions for Senders' #catalogID: #browser) #localSendersActions #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #LocalSharedVariableReferences #defaultString: 'Local Shared Variable References' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #LocalSharedVariableReferencesDesc #defaultString: 'Browse all references to the variable within the current scope of the browser' #catalogID: #browser) #localSharedVariableReferences #isSharedVariableSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #MethodsWithStringsMatching #defaultString: 'Methods with Strings Matching' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #MethodsWithStringsMatchingDesc #defaultString: 'Find all methods which have a literal string matching a string within the current scope of the browser' #catalogID: #browser) #browseStringMatches nil #browser)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #MoreBuffers #defaultString: 'More Buffers' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #MoreBuffersDesc #defaultString: 'Select a buffer' #catalogID: #browser) #selectBuffer nil #browser)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #MoveCompleteObjectToPackage #defaultString: 'Move Complete Object to Package' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #MoveCompleteObjectToPackageDesc #defaultString: 'Move the complete object (methods and shared variables) to a new package' #catalogID: #browser) #moveCompleteObjectToPackage #isBindingSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #MoveMethodToClass #defaultString: 'Move Method to Class' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #MoveMethodToClassDesc #defaultString: 'Move the selected method(s) to another class' #catalogID: #browser) #moveMethodToClass #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #MoveMethodToClassSide #defaultString: 'Move Method to Class Side' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #MoveMethodToClassSideDesc #defaultString: 'Move the selected instance side method(s) to class side of this or another class' #catalogID: #browser) #moveMethodToClassSide #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #MoveMethodToComponent #defaultString: 'Move Method to Component' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #MoveMethodToComponentDesc #defaultString: 'Move the selected method to another object, replacing the selected method with a forwarder' #catalogID: #browser) #moveMethodToComponent #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #MoveMethodToInstanceSide #defaultString: 'Move Method to Instance Side' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #MoveMethodToInstanceSideDesc #defaultString: 'Move the selected class side method(s) to instance side of this or another class' #catalogID: #browser) #moveMethodToInstanceSide #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #MoveMethodToPackage #defaultString: 'Move Method to Package' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #MoveMethodToPackageDesc #defaultString: 'Move selected methods to a package' #catalogID: #browser) #moveMethodToPackage #isDefinitionSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #MoveMethodToProtocol #defaultString: 'Move Method to Protocol' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #MoveMethodToProtocolDesc #defaultString: 'Move the selected methods to a new protocol' #catalogID: #browser) #moveMethodToProtocol #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #MoveObjectDefinitionToPackage #defaultString: 'Move Object Definition to Package' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #MoveObjectDefinitionToPackageDesc #defaultString: 'Move the object definitions to a new package' #catalogID: #browser) #moveObjectDefinitionToPackage #isBindingSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #MoveObjectToNameSpace #defaultString: 'Move Object to Name Space' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #MoveObjectToNameSpaceDesc #defaultString: 'Move the selected objects to another name space' #catalogID: #browser) #moveObjectsToNameSpace #isBindingSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #MoveObjectToPackage #defaultString: 'Move Object to Package' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #MoveObjectToPackageDesc #defaultString: 'Move the selected objects to a package' #catalogID: #browser) #moveObjectToPackage #isBindingSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #MoveProtocolToClass #defaultString: 'Move Protocol to Class' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #MoveProtocolToClassDesc #defaultString: 'Move the selected instance side protocol(s) to another class' #catalogID: #browser) #moveProtocolToClass #isProtocolSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #MoveProtocolToClassSide #defaultString: 'Move Protocol to Class Side' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #MoveProtocolToClassSideDesc #defaultString: 'Move the selected instance side protocol(s) to the class side of this or another class' #catalogID: #browser) #moveProtocolToClassSide #isProtocolSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #MoveProtocolToInstanceSide #defaultString: 'Move Protocol to Instance Side' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #MoveProtocolToInstanceSideDesc #defaultString: 'Move the selected class side protocol(s) to the instance side of this or another class' #catalogID: #browser) #moveProtocolToInstanceSide #isProtocolSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #MoveProtocolToPackage #defaultString: 'Move Protocol to Package' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #MoveProtocolToPackageDesc #defaultString: 'Move the selected protocols to a package' #catalogID: #browser) #moveProtocolToPackage #isProtocolSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #MoveSelectedTemporaryToInnermostScope #defaultString: 'Move Selected Temporary to Innermost Scope' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #MoveSelectedTemporaryToInnermostScopeDesc #defaultString: 'Move the variable definition to its innermost scope' #catalogID: #browser) #bindTight #canPerformTemporaryVariableRefactorings #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #MoveSharedVariableToProtocol #defaultString: 'Move Shared Variable to Protocol' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #MoveSharedVariableToProtocolDesc #defaultString: 'Move the selected shared variables to another protocol' #catalogID: #browser) #moveSharedVariableToProtocol #isSharedVariableSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #NameSpaceTemplate #defaultString: 'Name Space Template' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #NameSpaceTemplateDesc #defaultString: 'Display a template for creating a name space' #catalogID: #browser) #showNameSpaceTemplate #canDefineClassesAndNameSpaces #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #NavigateToClass #defaultString: 'Navigate to Class' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #NavigateToClassDesc #defaultString: 'Change the selection to the highlighted class' #catalogID: #browser) #navigateToClass #hasClassSelectedAndIncludesClass #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #NavigatorRemoveParamter #defaultString: 'Navigator Remove Paramter' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #NavigatorRemoveParamterDesc #defaultString: 'Remove an argument from the method if all implementors of the method do not use the argument' #catalogID: #browser) #removeParameter #canRemoveParameter #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CmdNewClass #defaultString: 'New Class' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CmdNewClassDesc #defaultString: 'Create a new class' #catalogID: #browser) #newClass nil #browser)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #NewClassTemplate #defaultString: 'New Class Template' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #NewClassTemplateDesc #defaultString: 'Display a template for defining a new class' #catalogID: #browser) #showClassTemplate #canDefineClassesAndNameSpaces #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #NewNameSpace #defaultString: 'New Name Space' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #NewNameSpaceDesc #defaultString: 'Create a new name space.' #catalogID: #browser) #newNameSpace nil #browser)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #NewSharedVariable #defaultString: 'New Shared Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #NewSharedVariableDesc #defaultString: 'Create a new shared variable' #catalogID: #browser) #newSharedVariable nil #browser)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #OpenBrowserOnClass #defaultString: 'Open Browser on Class' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #OpenBrowserOnClassDesc #defaultString: 'Browse only the selected class' #catalogID: #browser) #openBrowserForClass #hasClassSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #PasteSelection #defaultString: 'Paste Selection' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #Paste #defaultString: 'Paste' #catalogID: #browser) #paste #isTextTool #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #PrintIt #defaultString: 'Print It' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #PrintItDesc #defaultString: 'Evaluate the selected text and print the result' #catalogID: #browser) #printIt nil #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #ProtectClassInstanceVariable #defaultString: 'Protect Class Instance Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ProtectClassInstanceVariableDesc #defaultString: 'Convert from indirect to direct class instance variable access, removing all accessing methods that are no longer used' #catalogID: #browser) #protectClassInstanceVariable #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #ProtectInstanceVariable #defaultString: 'Protect Instance Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ProtectInstanceVariableDesc #defaultString: 'Convert from indirect to direct instance variable access, removing all accessing methods that are no longer used' #catalogID: #browser) #protectInstanceVariable #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #ProtectSelectedInstanceVariable #defaultString: 'Protect Selected Instance Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ProtectSelectedInstanceVariableDesc #defaultString: 'Convert abstract variable references to direct references for the selected instance variable' #catalogID: #browser) #protectInstanceVariable #hasInstanceVariableSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #PushDownClassInstanceVariable #defaultString: 'Push Down Class Instance Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #PushDownClassInstanceVariableDesc #defaultString: 'Move the class instance variable''s definition to the subclasses that reference it' #catalogID: #browser) #pushDownClassInstanceVariable #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #PushDownInstanceVariable #defaultString: 'Push Down Instance Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #PushDownInstanceVariableDesc #defaultString: 'Move the instance variable''s definition to the subclasses that reference it' #catalogID: #browser) #pushDownInstanceVariable #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #PushDownMethod #defaultString: 'Push Down Method' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #PushDownMethodDesc #defaultString: 'Move the selected method to the selected class'' subclasses' #catalogID: #browser) #pushDownSelector #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #PushDownSelectedInstanceVariable #defaultString: 'Push Down Selected Instance Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #PushDownSelectedInstanceVariableDesc #defaultString: 'Move the selected instance variable definition to all subclasses' #catalogID: #browser) #pushDownInstanceVariable #hasInstanceVariableSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #PushUpClassInstanceVariable #defaultString: 'Push Up Class Instance Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #PushUpClassInstanceVariableDesc #defaultString: 'Move the class instance variable definition to the selected class'' superclass' #catalogID: #browser) #pushUpClassInstanceVariable #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #PushUpInstanceVariable #defaultString: 'Push Up Instance Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #PushUpInstanceVariableDesc #defaultString: 'Move the instance variable definition to the selected class'' superclass' #catalogID: #browser) #pushUpInstanceVariable #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #PushUpMethod #defaultString: 'Push Up Method' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #PushUpMethodDesc #defaultString: 'Move the selected method to the selected class'' superclass' #catalogID: #browser) #pushUpSelector #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #PushUpSelectedInstanceVariable #defaultString: 'Push Up Selected Instance Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #PushUpSelectedInstanceVariableDesc #defaultString: 'Move the selected instance variable to the superclass' #catalogID: #browser) #pushUpInstanceVariable #hasInstanceVariableSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #Redo #defaultString: 'Redo' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #RedoDesc #defaultString: 'Redo the last undo operation' #catalogID: #browser) #redoOperation #hasRedoableOperations #browser)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #ReferencesToClassOrGlobal #defaultString: 'References to Class or Global' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ReferencesToClassOrGlobalDesc #defaultString: 'Find references to a class or shared variable within the current scope of the browser' #catalogID: #browser) #browseGlobals nil #browser)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #ReferencesToSymbol #defaultString: 'References to Symbol' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ReferencesToSymbolDesc #defaultString: 'Find references to a symbol within the current scope of the browser' #catalogID: #browser) #browseSymbols nil #browser)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #ReinitializeBindings #defaultString: 'Reinitialize Bindings' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ReinitializeBindingsDesc #defaultString: 'Reinitialize all selected bindings' #catalogID: #browser) #initializeBindings #isBindingSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #RemoveActionSpecification #defaultString: 'Remove Action Specification' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #RemoveActionSpecificationDesc #defaultString: 'Remove an action specification' #catalogID: #browser) #removeAction #hasActionSpecificationSelected #yourself)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #RemoveBuffer #defaultString: 'Remove Buffer' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #RemoveBufferDesc #defaultString: 'Remove the current buffer' #catalogID: #browser) #removeBuffer #hasMultipleCodeTools #browser)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #RemoveClassInstanceVariable #defaultString: 'Remove Class Instance Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #RemoveClassInstanceVariableDesc #defaultString: 'Remove a class instance variable if it is not referenced' #catalogID: #browser) #removeClassInstanceVariable #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #RemoveInstanceVariable #defaultString: 'Remove Instance Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #RemoveInstanceVariableDesc #defaultString: 'Remove an instance variable if it is not referenced' #catalogID: #browser) #removeInstanceVariable #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #RemoveMethodFromList #defaultString: 'Remove Method From List' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #RemoveMethodFromListDesc #defaultString: 'Removes the selected methods and shared variables from the list of items.' #catalogID: #browser) #removeFromList #isDefinitionSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #RemoveOverrideMethod #defaultString: 'Remove Override Method' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #RemoveOverrideMethodDesc #defaultString: 'Remove a method override' #catalogID: #browser) #removeMethodOrStaticOverride #isMethodOverridden #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #RemoveOverrideObject #defaultString: 'Remove Override Object' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #RemoveOverrideObjectDesc #defaultString: 'Remove an object override from the system' #catalogID: #browser) #removeObjectOverride #isClassOverridden #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #RemoveParameter #defaultString: 'Remove Parameter' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #RemoveParameterDesc #defaultString: 'Remove the selected argument from the method if all implementors of the method do not use the argument' #catalogID: #browser) #removeParameter #hasMethodArgumentSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #RemoveProtocol #defaultString: 'Remove Protocol' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #RemoveProtocolDesc #defaultString: 'Remove the selected protocol and all of its methods' #catalogID: #browser) #removeCategories #isProtocolSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #RemoveSelectedInstanceVariable #defaultString: 'Remove Selected Instance Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #RemoveSelectedInstanceVariableDesc #defaultString: 'Remove the selected instance variable if there are no references to it' #catalogID: #browser) #removeInstanceVariable #hasInstanceVariableSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #RemoveSelectedParameter #defaultString: 'Remove Selected Parameter' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #RemoveSelectedParameterDesc #defaultString: 'Remove the selected parameter from the method (if it is unused), modifying all callers' #catalogID: #browser) #removeParameter #canPerformParameterRefactorings #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #RemoveStatic #defaultString: 'Remove Static' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #RemoveStaticDesc #defaultString: 'Remove the selected shared variable' #catalogID: #browser) #removeStatic #hasStaticSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #RenameProtocol #defaultString: 'Rename Protocol' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #RenameProtocolDesc #defaultString: 'Rename the selected protocol' #catalogID: #browser) #renameProtocol #isProtocolSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #RenameSelectedTemporaryVariable #defaultString: 'Rename Selected Temporary Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #RenameTemporaryVariableDesc #defaultString: 'Rename the selected temporary variable and all references to it' #catalogID: #browser) #renameTemporary #canPerformTemporaryVariableRefactorings #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #RenameTemporaryVariable #defaultString: 'Rename Temporary Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #RenameTemporaryVariableDesc #defaultString: 'Rename the selected temporary variable and all references to it' #catalogID: #browser) #renameTemporary #hasTemporarySelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #ReplaceText #defaultString: 'Replace Text' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ReplaceTextDesc #defaultString: 'Search and replace text' #catalogID: #browser) #replace #isTextTool #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #RestoreOverrideMethod #defaultString: 'Restore Override Method' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #RestoreOverrideMethodDesc #defaultString: 'Restore an overridden method' #catalogID: #browser) #restoreMethodOrStaticOverride #isMethodOverridden #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #RestoreOverrideObject #defaultString: 'Restore Override Object' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #RestoreOverrideObjectDesc #defaultString: 'Restore an object override from the system' #catalogID: #browser) #restoreObjectOverride #isClassOverridden #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #RewriterReplace #defaultString: 'Rewriter Replace' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #RewriterReplaceDesc #defaultString: 'Replace using parse trees.' #catalogID: #browser) #replace nil #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #RewriterSearch #defaultString: 'Rewriter Search' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #RewriterSearchDesc #defaultString: 'Search for a matching parse tree.' #catalogID: #browser) #find nil #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #SelectedGlobalInstanceVariableReaders #defaultString: 'Selected Global Instance Variable Readers' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #SelectedInstanceVariableReadersDesc #defaultString: 'Browse all methods accessing the selected instance variable' #catalogID: #browser) #browseInstVarReaders #hasInstanceVariableSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #SelectedGlobalInstanceVariableReferences #defaultString: 'Selected Global Instance Variable References' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #SelectedInstanceVariableReferencesDesc #defaultString: 'Browse all methods referring to the selected instance variable' #catalogID: #browser) #browseInstVarRefs #hasInstanceVariableSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #SelectedGlobalInstanceVariableWriters #defaultString: 'Selected Global Instance Variable Writers' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #SelectedInstanceVariableWritersDesc #defaultString: 'Browse all methods modifying the selected instance variable' #catalogID: #browser) #browseInstVarWriters #hasInstanceVariableSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #SelectedMessageGlobalImplementors #defaultString: 'Selected Message Global Implementors' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #SelectedMessageImplementorsDesc #defaultString: 'Browse all implementors of the selected message' #catalogID: #browser) #browseImplementors #hasMessageSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #SelectedMessageGlobalSenders #defaultString: 'Selected Message Global Senders' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #SelectedMessageSendersDesc #defaultString: 'Browse all senders of the selected message' #catalogID: #browser) #browseSenders #hasMessageSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #SelectedMessageImplementors #defaultString: 'Selected Message Implementors' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #SelectedMessageImplementorsDesc #defaultString: 'Browse all implementors of the selected message' #catalogID: #browser) #browseImplementors #hasMessageNodeSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #SelectedMessageReferences #defaultString: 'Selected Message References' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #SelectedMessageSendersDesc #defaultString: 'Browse all senders of the selected message' #catalogID: #browser) #browseSenders #hasMessageNodeSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #SetDefaultNameSpace #defaultString: 'Set Default Name Space' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #SetDefaultNameSpaceDesc #defaultString: 'Set the default name space to be displayed when a browser is opened' #catalogID: #browser) #setDefaultNameSpace nil #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #SharedVariableTemplate #defaultString: 'Shared Variable Template' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #SharedVariableTemplateDesc #defaultString: 'Display a template for creating a shared variable' #catalogID: #browser) #showSharedVariableTemplate nil #activeTool)	#(#{Refactory.Browser.RBDynamicMultiCommand} #(#{Kernel.UserMessage} #key: #ShowOnlyFiltered #defaultString: 'Show Only Filtered' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ShowOnlyFilteredDesc #defaultString: 'Show only methods and shared variables within the selected Parcels/Packages' #catalogID: #browser) #showOnlyFilteredSpecifications nil #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #SmalllintClearFilters #defaultString: 'Smalllint Clear Filters' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #SmalllintClearFiltersDesc #defaultString: 'Clear Smalllint filter list.' #catalogID: #browser) #clearFilters nil #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #SmalllintLoadFilters #defaultString: 'Smalllint Load Filters' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #SmalllintLoadFiltersDesc #defaultString: 'Load Smalllint filters from a file.' #catalogID: #browser) #loadFilters nil #activeTool)	#(#{Refactory.Browser.RBDynamicMultiCommand} #(#{Kernel.UserMessage} #key: #SmalllintRuleTypeList #defaultString: 'Smalllint Rule Type List' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #SmalllintRuleTypeListDesc #defaultString: 'View submenu' #catalogID: #browser) #ruleActions nil #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #SmalllintSaveFilters #defaultString: 'Smalllint Save Filters' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #SmalllintSaveFiltersDesc #defaultString: 'Save Smalllint''s filters to a file.' #catalogID: #browser) #saveFilters nil #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #SpawnBrowser #defaultString: 'Spawn Browser' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #SpawnBrowserDesc #defaultString: 'Open a new browser' #catalogID: #browser) #spawnBrowser nil #browser)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #SpawnClass #defaultString: 'Spawn Class' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #SpawnClassDesc #defaultString: 'Browse only the selected classes' #catalogID: #browser) #spawnClass #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #SpawnClassHierarchy #defaultString: 'Spawn Class Hierarchy' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #SpawnClassHierarchyDesc #defaultString: 'Browse only the selected class and its hierarchy' #catalogID: #browser) #spawnHierarchy #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #SpawnMethod #defaultString: 'Spawn Method' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #SpawnMethodDesc #defaultString: 'Browse only the selected methods' #catalogID: #browser) #spawnMethod #isDefinitionSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #SpawnProtocol #defaultString: 'Spawn Protocol' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #SpawnProtocolDesc #defaultString: 'Browse the selected protocols' #catalogID: #browser) #spawnProtocol #isProtocolSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StaticReferences #defaultString: 'Static References' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StaticReferencesDesc #defaultString: 'Browse all references to the selected shared variable' #catalogID: #browser) #staticReferences #hasStaticSelected #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CmdStoreAddBundle #defaultString: 'Store Add Bundle' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CmdStoreAddBundleDesc #defaultString: 'Create a new bundle' #catalogID: #browser) #storeCreateBundle nil #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #CmdStoreAddPackage #defaultString: 'Store Add Package' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #CmdStoreAddPackageDesc #defaultString: 'Create a new package' #catalogID: #browser) #storeCreatePackage nil #navigator)	#(#{Refactory.Browser.RBDynamicMultiCommand} #(#{Kernel.UserMessage} #key: #StoreAllDatabasesBrowseChanges #defaultString: 'Store All Databases Browse Changes' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreAllDatabasesBrowseChangesDesc #defaultString: 'Dynamic Database Changed Methods' #catalogID: #browser) #storeAllDbsBrowseChanges #isPundleSelected #navigator)	#(#{Refactory.Browser.RBDynamicMultiCommand} #(#{Kernel.UserMessage} #key: #StoreAllDatabasesChangeList #defaultString: 'Store All Databases Change List' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreAllDatabasesChangeListDesc #defaultString: 'Dynamic Change List' #catalogID: #browser) #storeAllDbsChangeListOnChanges #isPundleSelected #navigator)	#(#{Refactory.Browser.RBDynamicMultiCommand} #(#{Kernel.UserMessage} #key: #StoreAllDatabasesFileoutChanges #defaultString: 'Store All Databases Fileout Changes' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreAllDatabasesFileoutChangesDesc #defaultString: 'Dynamic Fileout Changes' #catalogID: #browser) #storeAllDbsFileoutChanges #isPundleSelected #navigator)	#(#{Refactory.Browser.RBDynamicMultiCommand} #(#{Kernel.UserMessage} #key: #StoreAllDatabasesInspectChanges #defaultString: 'Store All Databases Inspect Changes' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreAllDatabasesInspectChangesDesc #defaultString: 'Dynamic Change Set' #catalogID: #browser) #storeAllDbsInspectChangeSet #isPundleSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreBrowseClassVersions #defaultString: 'Store Browse Class Versions' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreBrowseClassVersionsDesc #defaultString: 'Browse all versions of the selected class in the repository' #catalogID: #browser) #storeBrowseClassVersions #isBindingSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreBrowseMethodChanges #defaultString: 'Store Browse Method Changes' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreBrowseMethodChangesDesc #defaultString: 'Browse the methods in the repository that have been changed' #catalogID: #browser) #storeBrowseChanges #isPundleSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreBrowseMethodVersions #defaultString: 'Store Browse Method Versions' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreBrowseMethodVersionsDesc #defaultString: 'Browse the methods that have been changed' #catalogID: #browser) #storeBrowseMethodVersions #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreBrowsePundleVersions #defaultString: 'Store Browse Pundle Versions' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreBrowsePundleVersionsDesc #defaultString: 'Browse all versions of the selected method in the repository' #catalogID: #browser) #storeBrowsePundleVersions #isPundleSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreBrowseRemovedMethods #defaultString: 'Store Browse Removed Methods' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreBrowseRemovedMethodsDesc #defaultString: 'Browse all methods stored in the repository for this class that are not loaded' #catalogID: #browser) #storeBrowseRemovedMethods #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreBrowseSharedVariableVersions #defaultString: 'Store Browse Shared Variable Versions' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreBrowseSharedVariableVersionsDesc #defaultString: 'Browse all versions of the shared variable stored in the repository' #catalogID: #browser) #storeBrowseSharedVariableVersions #isSharedVariableSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreChangeListOnChanges #defaultString: 'Store Change List on Changes' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreChangeListOnChangesDesc #defaultString: 'Open a change list for the selected package' #catalogID: #browser) #storeChangeListOnChanges #isPundleSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreCompareClassVersion #defaultString: 'Store Compare Class Version' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreCompareClassVersionDesc #defaultString: 'Browse differences between the loaded class and a version in the repository' #catalogID: #browser) #storeCompareWithVersion #isBindingSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreCompareMethodVersions #defaultString: 'Store Compare Method Versions' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreCompareMethodVersionsDesc #defaultString: 'Browse differences between the selected method and another version of it' #catalogID: #browser) #storeCompareMethodWithVersion #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreComparePundleVersions #defaultString: 'Store Compare Pundle Versions' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreComparePundleVersionsDesc #defaultString: 'Browse differences between the selected item and an item in the repository' #catalogID: #browser) #storeComparePundleVersion #isPundleSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreComparePundleWithParent #defaultString: 'Store Compare Pundle with Parent' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreComparePundleWithParentDesc #defaultString: 'Browse differences between the selected item and its parent' #catalogID: #browser) #storeCompareWithParent #isPundleSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreCompareSharedVariableVersions #defaultString: 'Store Compare Shared Variable Versions' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreCompareSharedVariableVersionsDesc #defaultString: 'Browse differences between the selected shared variable and another version of it' #catalogID: #browser) #storeCompareSharedVariableWithVersion #isSharedVariableSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreExtendClassInPackage #defaultString: 'Store Extend Class in Package' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreExtendClassInPackageDesc #defaultString: 'Create an extension of a class or name space in a new package.' #catalogID: #browser) #extendClassInPackage #isBindingSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreFilein #defaultString: 'Store File-in' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreFileinDesc #defaultString: 'Load Smalltalk source, compiling it into the selected package' #catalogID: #browser) #storeFileinPackage #isPackageSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreFileoutPundle #defaultString: 'Store File-out Pundle' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreFileoutPundleDesc #defaultString: 'Save the Smalltalk source of the selected item as a file-out' #catalogID: #browser) #storeFileoutPundle #isPundleSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreFileoutPundleChanges #defaultString: 'Store File-out Pundle Changes' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreFileoutPundleChangesDesc #defaultString: 'Save the Smalltalk source for the changes in the selected item' #catalogID: #browser) #storeFileoutPundleChanges #isPundleSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreFileoutPundleDifferences #defaultString: 'Store File-out Pundle Differences' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreFileoutPundleDifferencesDesc #defaultString: 'Save the Smalltalk source for the differences between selected item versions' #catalogID: #browser) #storeFileoutPundleDifferences #isPundleSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreInspectChangeSet #defaultString: 'Store Inspect Change Set' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreInspectChangeSetDesc #defaultString: 'Inspect the change set of the selected packages' #catalogID: #browser) #storeInspectChangeSet #isPundleSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreLoadPundle #defaultString: 'Store Load Pundle' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreLoadPundleDesc #defaultString: 'Load another version of the selected item' #catalogID: #browser) #storeLoadPundle #isPundleSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreMakeCurrent #defaultString: 'Store Make Current' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreMakeCurrentDesc #defaultString: 'Make the selected package the default package for new source' #catalogID: #browser) #storeMakeCurrent #isPackageSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreNewClassExtension #defaultString: 'Store New Class Extension' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreNewClassExtensionDesc #defaultString: 'Create a new class extension in the selected package' #catalogID: #browser) #storeNewClassExtension #isPackageSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreOverrideMethod #defaultString: 'Store Override Method' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreOverrideMethodDesc #defaultString: 'Create an override for the selected method(s) or shared variable(s)' #catalogID: #browser) #overrideDefinitionsInPackage #isDefinitionSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreOverrideObject #defaultString: 'Store Override Object' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreOverrideObjectDesc #defaultString: 'Create an override for the selected object(s)' #catalogID: #browser) #overrideObjectInPackage #isBindingSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StorePublish #defaultString: 'Store Publish' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StorePublishDesc #defaultString: 'Publish the selected item to the repository' #catalogID: #browser) #storePublishPundle #isPundleSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StorePublishParcel #defaultString: 'Store Publish Parcel' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StorePublishParcelDesc #defaultString: 'Publish the selected item as a parcel' #catalogID: #browser) #storePublishAsParcel #isPundleSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StorePundleProperties #defaultString: 'Store Pundle Properties' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StorePundlePropertiesDesc #defaultString: 'Open the selected component''s properties dialog' #catalogID: #browser) #storePundleProperties #isPundleSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreReconcilePundle #defaultString: 'Store Reconcile Pundle' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreReconcilePundleDesc #defaultString: 'Reconcile the selected package with the database' #catalogID: #browser) #storeReconcilePundle #isOnePundleSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreRenamePundle #defaultString: 'Store Rename Pundle' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreRenamePundleDesc #defaultString: 'Rename the selected item' #catalogID: #browser) #storeRenamePundle #isPundleSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreRevertMethod #defaultString: 'Store Revert Method' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreRevertMethodDesc #defaultString: 'Load the version of the method stored in the repository for this package version' #catalogID: #browser) #storeRevertMethod #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreRevertSharedVariable #defaultString: 'Store Revert Shared Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreRevertSharedVariableDesc #defaultString: 'Load the version of the shared variable stored in the repository for this package version' #catalogID: #browser) #storeRevertSharedVariable #isSharedVariableSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #StoreUnloadPundle #defaultString: 'Store Unload Pundle' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #StoreUnloadPundleDesc #defaultString: 'Unload the selected item' #catalogID: #browser) #storeUnloadPundle #isPundleSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #ToggleToolbar #defaultString: 'Toggle Toolbar' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ToggleToolbarDesc #defaultString: 'Toggle the toolbar on all browsers' #catalogID: #browser) #toggleToolbar nil #browser)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #UncheckAllImplementors #defaultString: 'Uncheck All Implementors' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #UncheckAllImplementorsDesc #defaultString: 'Remove all implementors of the selected method from the item list' #catalogID: #browser) #uncheckImplementors #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #UncheckAllMethods #defaultString: 'Uncheck All Methods' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #UncheckAllMethodsDesc #defaultString: 'Remove all methods matching a pattern from the item list' #catalogID: #browser) #uncheckAllSelectors #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #UncheckAllProtocols #defaultString: 'Uncheck All Protocols' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #UncheckAllProtocolsDesc #defaultString: 'Remove all protocols matching a pattern from the item list' #catalogID: #browser) #uncheckAllProtocols #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #UncheckAllSenders #defaultString: 'Uncheck All Senders' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #UncheckAllSendersDesc #defaultString: 'Remove all senders of the selected method from the item list' #catalogID: #browser) #uncheckSenders #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #UncheckAllSubclasses #defaultString: 'Uncheck All Subclasses' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #UncheckAllSubclassesDesc #defaultString: 'Remove all the class'' subclasses from the item list' #catalogID: #browser) #uncheckSubclasses #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #UncheckAllSuperclasses #defaultString: 'Uncheck All Superclasses' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #UncheckAllSuperclassesDesc #defaultString: 'Remove all the class'' superclasses from the item list' #catalogID: #browser) #uncheckSuperclasses #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #UncheckClass #defaultString: 'Uncheck Class' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #UncheckClassDesc #defaultString: 'Remove the selected class from the item list' #catalogID: #browser) #uncheckClass #isClassSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #UncheckMethod #defaultString: 'Uncheck Method' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #UncheckMethodDesc #defaultString: 'Remove the selected methods from the item list' #catalogID: #browser) #uncheckSelector #isSelectorSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #UncheckProtocol #defaultString: 'Uncheck Protocol' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #UncheckProtocolDesc #defaultString: 'Remove the selected protocols from the item list' #catalogID: #browser) #uncheckProtocol #isProtocolSelected #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #Undo #defaultString: 'Undo' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #UndoDesc #defaultString: 'Undo the last action' #catalogID: #browser) #undoOperation #hasUndoableOperations #browser)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #UndoTyping #defaultString: 'Undo Typing' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #Undo #defaultString: 'Undo' #catalogID: #browser) #undo #isTextTool #activeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #UpdateCodeToolDisplay #defaultString: 'Update Code Tool Display' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #UpdateCodeToolDisplayDesc #defaultString: 'Update the display' #catalogID: #browser) #updateDisplay nil #codeTool)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #UpdateNavigator #defaultString: 'Update Navigator' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #UpdateNavigatorDesc #defaultString: 'Refresh the navigator from the current image' #catalogID: #browser) #updateNavigator nil #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #VariableNavigatorPullUpVariable #defaultString: 'Variable Navigator Pull Up Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #VariableNavigatorPullUpVariableDesc #defaultString: 'Move the selected variable into the superclass' #catalogID: #browser) #pullUpSelectedInstanceVariable #canPerformPullUpVariable #navigator)	#(#{Refactory.Browser.RBCommand} #(#{Kernel.UserMessage} #key: #VariableNavigatorRemoveVariable #defaultString: 'Variable Navigator Remove Variable' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #VariableNavigatorRemoveVariableDesc #defaultString: 'Remove the selected variable if there are no references to it' #catalogID: #browser) #removeSelectedInstanceVariable #canPerformRemoveVariable #navigator)	#(#{Refactory.Browser.RBDynamicMultiCommand} #(#{Kernel.UserMessage} #key: #ZoomSpecifications #defaultString: 'Zoom Specifications' #catalogID: #browser) #(#{Kernel.UserMessage} #key: #ZoomSpecificationsDesc #defaultString: 'The Zoom menu for the RB.' #catalogID: #browser) #zoomMenuSpecifications nil #browser))</body><body package="Browser-BaseUI">initializeActions	self initializeWithActions: self actionArray</body><body package="Browser-BaseUI">initializeWithActions: specArray 	Actions := Dictionary new.	specArray do: 			[:each | 			| action |			action := each first value decodeFromLiteralArray: each.			self addAction: action]</body></methods><methods><class-id>Refactory.Browser.RBCommand class</class-id> <category>private</category><body package="Browser-BaseUI">decodeStringOrArray: aStringOrArray	^aStringOrArray isString		ifTrue: [aStringOrArray]		ifFalse: [aStringOrArray first value decodeFromLiteralArray: aStringOrArray]</body></methods><methods><class-id>Refactory.Browser.RBCheckedCommand</class-id> <category>testing</category><body package="Browser-BaseUI">isCheckedActionSpecification	^true</body></methods><methods><class-id>Refactory.Browser.AbstractNavigatorState</class-id> <category>accessing</category><body package="Browser-BaseUI">classInstanceVariable	^self any: self classInstanceVariables</body><body package="Browser-BaseUI">classInstanceVariables	^self propertyAt: #classInstanceVariables ifAbsent: [#()]</body><body package="Browser-BaseUI">codeComponent	^self pundle</body><body package="Browser-BaseUI">instanceVariable	^self any: self instanceVariables</body><body package="Browser-BaseUI">instanceVariables	^self propertyAt: #instanceVariables ifAbsent: [#()]</body><body package="Browser-BaseUI">instanceVariables: vars 	self propertyAt: #instanceVariables put: vars</body><body package="Browser-BaseUI">mostSpecificObject	self deprecated: #(#version '7.8' #use #narrowestSelectionType).	self definitions do: [:each | ^each].	self classesAndNameSpaces do: [:each | ^each].	self pundles do: [:each | ^each].	^nil</body><body package="Browser-BaseUI">narrowestSelectionType	self definitions do: [:each | ^#definition].	self protocols do: [:each | ^#protocol].	self classesAndNameSpaces do: [:each | ^#object].	self pundles do: [:each | ^#codeComponent].	^nil</body><body package="Browser-BaseUI">object	^self classOrNameSpace</body><body package="Browser-BaseUI">package	^self any: self packages</body><body package="Browser-BaseUI">packages	| packages todo each |	packages := OrderedCollection new.	todo := OrderedCollection withAll: self pundles.	[todo isEmpty] whileFalse: 			[each := todo removeFirst.			each isBundle 				ifTrue: [todo addAll: each containedItems]				ifFalse: [packages add: each]].	^packages</body><body package="Browser-BaseUI">propertyAt: aSymbol 	^self propertyAt: aSymbol ifAbsent: [nil]</body><body package="Browser-BaseUI">propertyAt: aSymbol ifAbsent: aBlock 	^properties at: aSymbol ifAbsent: aBlock</body><body package="Browser-BaseUI">propertyAt: aSymbol put: anObject 	^properties at: aSymbol put: anObject</body><body package="Browser-BaseUI">protocol	^self any: self protocols</body><body package="Browser-BaseUI">protocol: aSymbol 	protocols := aSymbol isNil ifTrue: [#()] ifFalse: [Array with: aSymbol]</body><body package="Browser-BaseUI">protocols	^protocols</body><body package="Browser-BaseUI">protocols: symbolCollection 	protocols := symbolCollection</body><body package="Browser-BaseUI">pundle	^self any: self pundles</body><body package="Browser-BaseUI">pundle: aPundle 	self pundles: (aPundle isNil ifTrue: [#()] ifFalse: [Array with: aPundle])</body><body package="Browser-BaseUI">pundles	^self subclassResponsibility</body><body package="Browser-BaseUI">pundles: aCollection	| justPackages |	pundles := aCollection				collect: [:each | Array with: each name with: each isPackage].	justPackages := aCollection select: [:each | each isPackage].	self selectNamespaceIn: justPackages</body><body package="Browser-BaseUI">removeProperty: aKey 	properties removeKey: aKey ifAbsent: []</body><body package="Browser-BaseUI">selectNamespaceIn: justPackages	| namespaces |	justPackages isEmpty ifTrue: [^self nameSpace: Smalltalk].	namespaces := (justPackages		collect: [:each | each environment ifNil: [Smalltalk]]) asSet.	self		nameSpace:			(namespaces size = 1				ifTrue: [namespaces any]				ifFalse: [Smalltalk])</body><body package="Browser-BaseUI">showBundleContentsInLoadOrder	^self propertyAt: #showBundleContentsInLoadOrder		ifAbsent: [_.PackageListRoot.ShowBundleContentsInLoadOrder == true]</body><body package="Browser-BaseUI">showBundleContentsInLoadOrder: aBoolean	^self propertyAt: #showBundleContentsInLoadOrder put: aBoolean</body><body package="Browser-BaseUI">sortBundlesToTop	^self propertyAt: #sortBundlesToTop		ifAbsent: [_.PackageListRoot.SortBundlesToTop == true]</body><body package="Browser-BaseUI">sortBundlesToTop: aBoolean	self propertyAt: #sortBundlesToTop put: aBoolean</body></methods><methods><class-id>Refactory.Browser.AbstractNavigatorState</class-id> <category>testing</category><body package="Browser-BaseUI">hasSelection		^(self objectNames isEmpty and: [self packages isEmpty]) not</body><body package="Browser-BaseUI">isData	^self type = #sharedVariable</body><body package="Browser-BaseUI">isMeta	^self type = #class</body><body package="Browser-BaseUI">supportsLiveEditing	^true</body></methods><methods><class-id>Refactory.Browser.AbstractNavigatorState</class-id> <category>accessing-methods</category><body package="Browser-BaseUI">allDefinitions	^self propertyAt: #allDefinitions ifAbsent: [#()]</body><body package="Browser-BaseUI">allDefinitions: aCollection 	self propertyAt: #allDefinitions put: aCollection</body><body package="Browser-BaseUI">definition	^self any: self definitions</body><body package="Browser-BaseUI">definition: aMethodDefinition 	self definitions: (aMethodDefinition isNil 				ifTrue: [#()]				ifFalse: [Array with: aMethodDefinition])</body><body package="Browser-BaseUI">definitions	^definitions</body><body package="Browser-BaseUI">definitions: aCollection 	| def |	definitions := aCollection.	aCollection isEmpty ifTrue: [^self].	def := self any: aCollection.	def isForSharedVariable ifTrue: [self type: #sharedVariable]</body><body package="Browser-BaseUI">methodClass	| def |	def := self definition.	^def isNil ifTrue: [self selectedClass] ifFalse: [def implementingClass]</body><body package="Browser-BaseUI">methodDefinitionClass	^RBMethodDefinition</body><body package="Browser-BaseUI">methodDefinitions	^self definitions reject: [:each | each isForSharedVariable]</body><body package="Browser-BaseUI">selector	^self any: self selectors</body><body package="Browser-BaseUI">selector: aSymbol 	self 		selectors: (aSymbol isNil ifTrue: [#()] ifFalse: [Array with: aSymbol])</body><body package="Browser-BaseUI">selectors	| defs class |	defs := self methodDefinitions.	defs isEmpty ifTrue: [^#()].	class := self selectedClass.	^(defs select: [:each | each inheritingClass = class]) 		collect: [:each | each selector]</body><body package="Browser-BaseUI">selectors: symbolCollection	| class |	class := self selectedClass.	class isNil ifTrue: [^self definitions: #()].	self		definitions: (symbolCollection collect: 					[:each |					| implementingClass |					implementingClass := class whichClassIncludesSelector: each.					implementingClass isNil ifTrue: [implementingClass := class].					self methodDefinitionClass						class: class						implementor: implementingClass						selector: each])</body><body package="Browser-BaseUI">sharedVariableDefinitions	^self definitions select: [:each | each isForSharedVariable]</body><body package="Browser-BaseUI">sharedVariableName	^self any: self sharedVariableNames</body><body package="Browser-BaseUI">sharedVariableNames	^self sharedVariableDefinitions collect: [:each | each variableName]</body></methods><methods><class-id>Refactory.Browser.AbstractNavigatorState</class-id> <category>accessing-class</category><body package="Browser-BaseUI">classOrNameSpace	^self any: self classesAndNameSpaces</body><body package="Browser-BaseUI">classOrNameSpace: anObject 	^self classesAndNameSpaces: (anObject isNil 				ifTrue: [#()]				ifFalse: [Array with: anObject])</body><body package="Browser-BaseUI">classesAndNameSpaces	^self subclassResponsibility</body><body package="Browser-BaseUI">clearClassDependentFields	self		pundles: #();		definitions: #();		inheritToClass: nil</body><body package="Browser-BaseUI">inheritToClass	"This is a placeholder.  Subclasses that support visibility specification should override this method."	^self selectedClass</body><body package="Browser-BaseUI">inheritToClass: aClass 	"This is a placeholder.  Subclasses that support visibility specification should override this method."</body><body package="Browser-BaseUI">inheritToType	"This is a placeholder.  Subclasses that support visibility specification should override this method."	^#class</body><body package="Browser-BaseUI">inheritToType: aSymbol 	"This is a placeholder.  Subclasses that support visibility specification should override this method."	^#class</body><body package="Browser-BaseUI">nonMetaClass	| classes |	classes := self nonMetaClasses.	^classes isEmpty ifTrue: [nil] ifFalse: [classes first]</body><body package="Browser-BaseUI">objectName	^self any: self objectNames</body><body package="Browser-BaseUI">objectName: aName 	objectNameReferences := aName isNil 				ifTrue: [#()]				ifFalse: [Array with: aName asQualifiedReference]</body><body package="Browser-BaseUI">objectNames	^objectNameReferences collect: [:each | each asString]</body><body package="Browser-BaseUI">objectNamesOrderedForRemoval		| objectToNameMap objectsOrderedForUnload |	objectToNameMap := IdentityDictionary new.	objectNameReferences		do:			[:each | 			objectToNameMap				at: each value				put: each asString].	objectsOrderedForUnload := (SystemUtils		sortForLoading: objectToNameMap keys) reverse.	^objectsOrderedForUnload collect: [:each | objectToNameMap at: each]</body><body package="Browser-BaseUI">selectedBinding	^self any: self selectedBindings</body><body package="Browser-BaseUI">selectedClass	^self nonMetaClass ifNotNil: [:instanceBehavior | self isMeta ifTrue: [instanceBehavior classBehavior] ifFalse: [instanceBehavior]]</body><body package="Browser-BaseUI">selectedClass: aClass	aClass isNil ifTrue: [^objectNameReferences := #()].	type := aClass isMeta ifTrue: [#class] ifFalse: [#instance].	self objectName: aClass instanceBehavior fullRootName.	^aClass</body><body package="Browser-BaseUI">selectedClasses	"Return all selected classes. Take into account the isMeta setting to determine whether we return classBehaviors or instanceBehaviors."	| instanceBehaviors |	instanceBehaviors := self nonMetaClasses.	^self isMeta ifTrue: [instanceBehaviors collect: [:each | each classBehavior]] ifFalse: [instanceBehaviors]</body><body package="Browser-BaseUI">selectedClasses: classCollection 	objectNameReferences := classCollection 				collect: [:each | each instanceBehavior fullRootName asQualifiedReference].	classCollection isEmpty 		ifTrue: 			[type := #instance.			^self].	type := classCollection first isMeta ifTrue: [#class] ifFalse: [#instance]</body><body package="Browser-BaseUI">selectedClassesAndNamespaces	^self selectedClasses , self selectedNamespaces</body><body package="Browser-BaseUI">selectedNameSpace: aNameSpace	aNameSpace isNil ifTrue: [^objectNameReferences := #()].	self objectName: aNameSpace fullRootName.	^aNameSpace</body><body package="Browser-BaseUI">selectedNamespaces	| objects |	objects := OrderedCollection new.	objectNameReferences do: 			[:each |			(each valueOrDo: [nil])				ifNotNil: [:object | object isNameSpace ifTrue: [objects add: object]]].	^objects</body><body package="Browser-BaseUI">type	^type</body><body package="Browser-BaseUI">type: aSymbol	type := aSymbol</body></methods><methods><class-id>Refactory.Browser.AbstractNavigatorState</class-id> <category>initialize-release</category><body package="Browser-BaseUI">initialize	pundles := objectNameReferences := protocols := definitions := #().	nameSpaceName := Smalltalk fullRootName.	type := #instance.	properties := IdentityDictionary new</body></methods><methods><class-id>Refactory.Browser.AbstractNavigatorState</class-id> <category>comparing</category><body package="Browser-BaseUI">= anObject		(#(#class #pundles #objectNames #protocols #selectors #nameSpace)		allSatisfy: [:each | (self perform: each) = (anObject perform: each)])		ifFalse: [^false].	self properties size = anObject properties size ifFalse: [^false].	self properties		keysAndValuesDo:			[:key :value | 			value				=					(anObject properties						at: key						ifAbsent: [Object new]) ifFalse: [^false]].	^true</body><body package="Browser-BaseUI">hash	^(self class hash bitXor: self protocols hash)		bitXor: self selectors hash</body><body package="Browser-BaseUI">sameAs: aNavigatorState		(#(#class #pundles #objectNames #selectors #nameSpace)		allSatisfy: [:each | (self perform: each) = (aNavigatorState perform: each)])		ifFalse: [^false].	^true</body></methods><methods><class-id>Refactory.Browser.AbstractNavigatorState</class-id> <category>private</category><body package="Browser-BaseUI">any: aCollection 	^aCollection detect: [:each | true] ifNone: [nil]</body><body package="Browser-BaseUI">properties	^properties</body></methods><methods><class-id>Refactory.Browser.AbstractNavigatorState</class-id> <category>copying</category><body package="Browser-BaseUI">postCopy	super postCopy.	properties := properties copy</body></methods><methods><class-id>Refactory.Browser.AbstractNavigatorState class</class-id> <category>instance creation</category><body package="Browser-BaseUI">new	^super new initialize</body></methods><methods><class-id>Refactory.Browser.NavigatorState</class-id> <category>accessing</category><body package="Browser-BaseUI">nameSpace	self methodDefinitions		do: [:each | each method notNil ifTrue: [^each method environment]].	self classesAndNameSpaces do: [:each | ^each environment].	^nameSpaceName asQualifiedReference valueOrDo: [Smalltalk]</body><body package="Browser-BaseUI">nameSpace: aNameSpace 	nameSpaceName := aNameSpace fullRootName</body><body package="Browser-BaseUI">pundles	| pundleCollection reg |	reg := #{Store.Registry} valueOrDo: [^#()].	reg == nil ifTrue: [ ^#() ].	pundleCollection := OrderedCollection new: pundles size.	pundles do: 			[:each | 			| pundle |			pundle := each last 						ifTrue: [reg packageNamed: each first]						ifFalse: [reg bundleNamed: each first].			pundle notNil ifTrue: [pundleCollection add: pundle]].	^pundleCollection</body><body package="Browser-BaseUI">selectedNameSpace	^(objectNameReferences		detect: [:some | some isDefined and: [some value isNameSpace]]		ifNone: [^nil]) value</body></methods><methods><class-id>Refactory.Browser.NavigatorState</class-id> <category>accessing-class</category><body package="Browser-BaseUI">classesAndNameSpaces	"Return all selected instance behavior and namespace objects. Note that this returns the instance behaviors of selected classes, regardless of the state of isMeta."	| objects |	objects := OrderedCollection new: objectNameReferences size.	objectNameReferences do: 			[:each |			| class |			class := each valueOrDo: [nil].			(class notNil and: [class isBehavior or: [class isNameSpace]])				ifTrue: [objects add: class]].	^objects</body><body package="Browser-BaseUI">classesAndNameSpaces: aCollection	| any |	any := self any: aCollection.	any notNil		ifTrue: 			[type := any isBehavior						ifTrue: [any isMeta ifTrue: [#class] ifFalse: [#instance]]						ifFalse: [#sharedVariable]].	objectNameReferences := aCollection collect: 					[:each |					(each isBehavior ifTrue: [each instanceBehavior] ifFalse: [each])						fullRootName asQualifiedReference]</body><body package="Browser-BaseUI">inheritToClass	| inheritToType class superclasses inheritToClass |	objectNameReferences size = 1 ifFalse: [^nil].	inheritToType := self inheritToType.	class := self selectedClass.	class isNil ifTrue: [^nil].	inheritToType = #root ifTrue: [^class withAllSuperclasses last].	inheritToType = #rootMinusOne 		ifTrue: 			[superclasses := class withAllSuperclasses.			superclasses size &lt; 2 ifTrue: [^class].			^self isMeta				ifTrue: [					class = Object class ifTrue: [^class].					superclasses at: (superclasses indexOf: Object class ifAbsent: [^superclasses last]) - 1]				ifFalse: [superclasses at: superclasses size - 1]].	inheritToType = #class 		ifTrue: 			[inheritToClass := (self propertyAt: #inheritToClass ifAbsent: [^class]) 						asQualifiedReference valueOrDo: [^class].			self isMeta ifTrue: [inheritToClass := inheritToClass class].			^(class includesBehavior: inheritToClass) 				ifTrue: [inheritToClass]				ifFalse: [class]].	^class</body><body package="Browser-BaseUI">inheritToClass: aClass 	aClass isNil ifTrue: [^self removeProperty: #inheritToClass].	self propertyAt: #inheritToType put: #class.	self propertyAt: #inheritToClass put: aClass instanceBehavior fullName</body><body package="Browser-BaseUI">inheritToType	^self propertyAt: #inheritToType ifAbsent: [#class]</body><body package="Browser-BaseUI">inheritToType: aSymbol	"Return value set, consistent with super."	^self propertyAt: #inheritToType put: aSymbol</body><body package="Browser-BaseUI">nonMetaClasses	| classes |	classes := OrderedCollection new: objectNameReferences size.	objectNameReferences do: 			[:each | 			| class |			class := each valueOrDo: [nil].			(class notNil and: [class isBehavior]) ifTrue: [classes add: class]].	^classes</body><body package="Browser-BaseUI">objectNames: aCollection 	objectNameReferences := aCollection 				collect: [:each | each asQualifiedReference]</body><body package="Browser-BaseUI">selectedBindings	| bindings |	bindings := OrderedCollection new: objectNameReferences size.	objectNameReferences do: 			[:each | 			| binding |			binding := each bindingOrNil.			binding notNil ifTrue: [bindings add: binding]].	^bindings</body><body package="Browser-BaseUI">selectedGlobals	| globals |	globals := OrderedCollection new: objectNameReferences size.	objectNameReferences do:		[:each | 		each ifDefinedDo: 				[:classOrNameSpace | 				(classOrNameSpace isNameSpace or: [classOrNameSpace isBehavior]) 					ifTrue: [globals add: classOrNameSpace]]].	^globals</body></methods><methods><class-id>Refactory.Browser.NavigatorState</class-id> <category>printing</category><body package="Browser-BaseUI">printOn: aStream		| binding currentPackage |	binding := self selectedBinding.	currentPackage := self package.	binding notNil		ifTrue:			[aStream nextPutAll: binding key.			self isMeta ifTrue: [aStream nextPutAll: ' class'].			self selector notNil				ifTrue:					[currentPackage := Store.Registry						containingPackageForSelector: self selector						class: binding value.					aStream						nextPutAll: '&gt;&gt;';						nextPutAll: self selector]				ifFalse:					[self sharedVariableName notNil						ifTrue:							[aStream								nextPut: $.;								nextPutAll: self sharedVariableName]						ifFalse:							[self protocol notNil								ifTrue:									[aStream										nextPut: $&gt;;										nextPutAll: self protocol]]]]		ifFalse:			[self pundles isEmpty				ifTrue: [aStream nextPutAll: (#NewBrowser &lt;&lt; #browser &gt;&gt;'New Browser') asString]				ifFalse: [aStream nextPutAll: self pundle name]].	currentPackage		ifNotNil:			[:package | 			package environment				ifNotNil:					[:scope | 					aStream nextPutAll: ' {'.					scope printOn: aStream.					aStream nextPut: $}]]</body></methods><methods><class-id>Refactory.Browser.NavigatorState</class-id> <category>testing</category><body package="Browser-BaseUI">supportsLiveEditing	^true</body></methods><methods><class-id>Refactory.Browser.RBActionDispatcher</class-id> <category>accessing</category><body package="Browser-BaseUI">browser	^self objects at: #browser ifAbsent: [nil]</body><body package="Browser-BaseUI">environment	^self navigator environment</body><body package="Browser-BaseUI">navigator	^self objects at: #navigator</body><body package="Browser-BaseUI">navigator: aNavigator 	self objects at: #navigator put: aNavigator</body></methods><methods><class-id>Refactory.Browser.RBActionDispatcher</class-id> <category>private</category><body package="Browser-BaseUI">objects	^objects isNil 		ifTrue: [objects := IdentityDictionary new]		ifFalse: [objects]</body></methods><methods><class-id>Refactory.Browser.RBActionDispatcher</class-id> <category>copying</category><body package="Browser-BaseUI">postCopy	super postCopy.	objects := objects copy</body></methods><methods><class-id>Store.BundleSpecEditor</class-id> <category>private</category><body package="Browser-BaseUI">addCheckMarkToImage: anImage 	| cp |	cp := CompositePart new.	cp add: self checkMark at: 0 @ 0.	cp add: anImage at: self checkMarkWidth @ 0.	^cp</body><body package="Browser-BaseUI">bundleNameChanged	self disturb.</body><body package="Browser-BaseUI">bundleNamed: aString	^Registry bundleNamed: aString</body><body package="Browser-BaseUI">checkMark	^LabelAndIcon checkMark</body><body package="Browser-BaseUI">checkMarkGap	^4</body><body package="Browser-BaseUI">checkMarkWidth	^self checkMark width + self checkMarkGap</body><body package="Browser-BaseUI">createBundle	| newBundleModel |	newBundleModel := BundleModel named: self bundleName value trimBlanks.	newBundleModel containedItems: self bundleContents list.	parentBundleHolder value ifNotNil:		[:parentBundle | parentBundle addItem: newBundleModel]</body><body package="Browser-BaseUI">disableBundleNameEdits	(self builder componentAt: #bundleName) widget isEnabled: false</body><body package="Browser-BaseUI">disableValidateButton	(self builder componentAt: #validateLoadOrder) widget isEnabled: false</body><body package="Browser-BaseUI">disturb	disturbed := true.</body><body package="Browser-BaseUI">isPundleAvailableAtIndex: anIndex	^pundleAvailability at: anIndex</body><body package="Browser-BaseUI">labelWithString: aString icon: anImage disabled: isDisabled reversed: isReversed checked: isChecked inView: aSelectionView	"If isOffset is true, the returned LabalAndIcon will be offset so that the icon 	will align with the icons of other labels preceeded by check marks."	| label disabledText |	label := LabelAndIcon with: aString attributes: aSelectionView textStyle.	isDisabled		ifTrue: 			[disabledText := aString asText.			disabledText emphasizeAllWith: 				(Array					with: #color -&gt; aSelectionView inactiveForegroundColor					with: #italic).			label text: disabledText].	label icon: (isChecked ifTrue: [self addCheckMarkToImage: anImage] ifFalse: [anImage]).	isReversed		ifTrue: 			[label := ReversingWrapper on: label.			label reverse setValue: true].	^label</body><body package="Browser-BaseUI">leafItems	| pkgs |	pkgs := OrderedCollection new.	self bundleContents list do:		[ :pundle | pkgs addAll: pundle leafItems ].	^pkgs</body><body package="Browser-BaseUI">modifyBundle	bundle containedItems ~= self bundleContents list ifTrue: [bundle containedItems: self bundleContents list]</body><body package="Browser-BaseUI">nameForBundle: aBundle	^aBundle name</body><body package="Browser-BaseUI">okSelection: aController		"Don't let the selection change if the targeted item is disabled"	^self isPundleAvailableAtIndex: aController view targetIndex</body><body package="Browser-BaseUI">pundleAdded: aPundle 	"update the lists after a pundle has been added to the image"	| newPundleList index |	newPundleList := Registry allPundlesSorted.	index := newPundleList indexOf: aPundle.	"insert an element into the pundleAvailability array"	pundleAvailability := pundleAvailability				copyReplaceFrom: index				to: index - 1				with: (Array with: true).		self availablePundles list add: aPundle beforeIndex: index.	self availablePundles selectionIndexes: (self availablePundles selectionIndexes collect: [:i | i &gt;= index				ifTrue: [i + 1]				ifFalse: [i]])</body><body package="Browser-BaseUI">pundleAtIndex: index isAvailable: aBoolean	pundleAvailability at: index put: aBoolean.</body><body package="Browser-BaseUI">pundleRemoved: aPundle 	"update the lists after a pundle has been removed from the image"	| index removed |	"update available pundles"	index := self availablePundles list indexOf: aPundle.	pundleAvailability := pundleAvailability "remove index'th element from array"				copyReplaceFrom: index				to: index				with: Array new.	self availablePundles list remove: aPundle.	self availablePundles selectionIndexes remove: index ifAbsent: [nil].	self availablePundles selectionIndexes: 		(self availablePundles selectionIndexes collect: [:i | i &gt;= index				ifTrue: [i - 1]				ifFalse: [i]]).	"update bundle contents"	removed := self bundleContents list remove: aPundle ifAbsent: [nil].	removed isNil ifFalse: [self bundleContents selection: nil].</body><body package="Browser-BaseUI">undisturb	disturbed := false.</body></methods><methods><class-id>Store.BundleSpecEditor</class-id> <category>updating</category><body package="Browser-BaseUI">update: anAspect with: aParameter 	super update: anAspect with: aParameter.	anAspect == #addedPundle ifTrue: [self pundleAdded: aParameter].	anAspect == #removedPundle ifTrue: [self pundleRemoved: aParameter]</body></methods><methods><class-id>Store.BundleSpecEditor</class-id> <category>accessing</category><body package="Browser-BaseUI">availableBundles	^(SortedCollection withAll: Registry allBundles sortBlock: [:a :b | a name &lt; b name]) asValue</body><body package="Browser-BaseUI">bundle	^bundle</body><body package="Browser-BaseUI">bundle: bundleModel	bundle := bundleModel.	self bundleName value: bundle name.	(self builder isNil not and: [bundle isNil not]) 		ifTrue: [self disableBundleNameEdits].	bundle containedItems do: [:aPundleModel |		self pundleAtIndex: (self availablePundles list indexOf: aPundleModel) isAvailable: false].	self pundleAtIndex: (self availablePundles list indexOf: bundle) isAvailable: false.	self builder isNil ifFalse: [(self builder componentAt: #availablePundlesView) invalidate].	self bundleContents list: bundle containedItems.</body><body package="Browser-BaseUI">parentBundle	^parentBundleHolder value</body><body package="Browser-BaseUI">parentBundle: anObject	parentBundleHolder value: anObject</body><body package="Browser-BaseUI">parentBundleHolder	^parentBundleHolder</body></methods><methods><class-id>Store.BundleSpecEditor</class-id> <category>events</category><body package="Browser-BaseUI">noticeOfWindowClose: aWindow	"The containing window is being closed -- release."	self release</body><body package="Browser-BaseUI">requestForWindowClose	super requestForWindowClose.	^disturbed not or: [Dialog confirm: (#BundleSpecAltered &lt;&lt; #packages &gt;&gt; 'The bundle specification has been altered.  Do you wish to discard the changes?')]</body></methods><methods><class-id>Store.BundleSpecEditor</class-id> <category>aspects</category><body package="Browser-BaseUI">availablePundles	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^availablePundles isNil		ifTrue:			[availablePundles := MultiSelectionInList new]		ifFalse:			[availablePundles]</body><body package="Browser-BaseUI">bundleContents	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^bundleContents isNil		ifTrue:			[bundleContents := SelectionInList new]		ifFalse:			[bundleContents]</body><body package="Browser-BaseUI">bundleName	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^bundleName isNil		ifTrue:			[bundleName := String new asValue]		ifFalse:			[bundleName]</body></methods><methods><class-id>Store.BundleSpecEditor</class-id> <category>list visuals</category><body package="Browser-BaseUI">initializeVisualBlocksForBundleContentView	| contentView |	contentView := (self builder componentAt: #bundleContentsView) widget.	contentView selectedVisualBlock: [:aView :index | self			makeBundleContentListItemForIndex: index			inView: aView			selected: true].	contentView visualBlock: [:aView :index | self			makeBundleContentListItemForIndex: index			inView: aView			selected: false]</body><body package="Browser-BaseUI">initializeVisualBlocksForPundleView	| pundleView |	pundleView := (self builder componentAt: #availablePundlesView) widget.	pundleView selectedVisualBlock: [:aView :index | self			makePundleListItemForIndex: index			inView: aView			selected: true].	pundleView visualBlock: [:aView :index | self			makePundleListItemForIndex: index			inView: aView			selected: false]</body><body package="Browser-BaseUI">makeBundleContentListItemForIndex: index inView: aSelectionView selected: isSelected	| label pundle |	pundle := self bundleContents list at: index.	label := self labelWithString: pundle name		icon: (self class iconForPundle: pundle)		disabled: false		reversed: isSelected		checked: false		inView: aSelectionView.	^BoundedWrapper on: label.</body><body package="Browser-BaseUI">makePundleListItemForIndex: index inView: aSelectionView selected: isSelected 	| label disable pundle check |	disable := (self isPundleAvailableAtIndex: index) not.	pundle := self availablePundles list at: index.	check := isSelected.	label := self				labelWithString: pundle name				icon: (self class iconForPundle: pundle)				disabled: disable				reversed: check				checked: false				inView: aSelectionView.	^BoundedWrapper on: label</body></methods><methods><class-id>Store.BundleSpecEditor</class-id> <category>initialize-release</category><body package="Browser-BaseUI">initialize	super initialize.	disturbed := false.	self availablePundles list: (Registry allPundlesSorted asList).	"make the selectionInList use an OrderedCollection instead of a 	 Set for storing the selections since we want to remember the	 selection order."	self availablePundles selectionIndexes: OrderedCollection new.	pundleAvailability := Array new: self availablePundles list size withAll: true.	Registry addDependent: self.	parentBundleHolder := nil asValue</body><body package="Browser-BaseUI">release	super release.	Registry removeDependent: self.</body></methods><methods><class-id>Store.BundleSpecEditor</class-id> <category>actions</category><body package="Browser-BaseUI">accept	"Accept has been selected- answer self to cancel."	( self validateName "and: [ self validateOrder ] " ) 		ifFalse: [ ^self ].			   	bundle == nil		ifTrue: [ self createBundle ]		ifFalse: [ self modifyBundle ].	self undisturb.	self closeRequest</body><body package="Browser-BaseUI">addToBundleContents	| selectionIndexes |	selectionIndexes := self availablePundles selectionIndexes.	selectionIndexes isEmpty ifTrue: [^self].	selectionIndexes do: [:i | 		self bundleContents list add: (self availablePundles list at: i).		self pundleAtIndex: i isAvailable: false].	self bundleContents selectionIndex: self bundleContents list size.	"Deselect all items in available pundle list view.  Be sure that the selection in list	 continues to use an OrderedCollection (rather than a Set) to store the selections	 since we want to remember selection order."	self availablePundles selectionIndexes: OrderedCollection new.</body><body package="Browser-BaseUI">cancel	self undisturb.	self closeRequest</body><body package="Browser-BaseUI">moveBundleItemDown	| selection currentPosition bundleContentList nextItem |	bundleContentList := self bundleContents list.	currentPosition := self bundleContents selectionIndex.	(currentPosition == self bundleContents zeroIndex or: 			[currentPosition == bundleContentList size]) 		ifFalse: [			"swap the selected item with the next item in the list"			selection := self bundleContents selection.			nextItem := bundleContentList at: currentPosition + 1.			bundleContentList at: currentPosition + 1 put: selection.			bundleContentList at: currentPosition put: nextItem.			self bundleContents selection: selection.]</body><body package="Browser-BaseUI">moveBundleItemUp	| selection currentPosition bundleContentList previousItem |	bundleContentList := self bundleContents list.	currentPosition := self bundleContents selectionIndex.	(currentPosition == self bundleContents zeroIndex or: 			[currentPosition == 1])		 ifFalse: [			"swap the selected item with the previous item in the list"			selection := self bundleContents selection.			previousItem := bundleContentList at: currentPosition - 1.			bundleContentList at: currentPosition - 1 put: selection.			bundleContentList at: currentPosition put: previousItem.			self bundleContents selection: selection.]</body><body package="Browser-BaseUI">removeBundleItem	| itemToRemove availablePundleIndex |		(itemToRemove := self bundleContents selection) isNil ifFalse: [		availablePundleIndex := self availablePundles list indexOf: itemToRemove.		self pundleAtIndex: availablePundleIndex isAvailable: true.		(self builder componentAt: #availablePundlesView) widget updateAt: availablePundleIndex.		self bundleContents selection: nil.		self bundleContents list remove: itemToRemove.]</body><body package="Browser-BaseUI">validateLoadOrder	| errs |	Dialog warn:		( ( errs := bundle validateLoadOrder: self bundleContents list) isEmpty			ifTrue: [ (#LoadOrderValidated &lt;&lt; #packages &gt;&gt; 'Load order validated.') ]			ifFalse:	[ errs ]		)</body></methods><methods><class-id>Store.BundleSpecEditor</class-id> <category>interface opening</category><body package="Browser-BaseUI">postBuildWith: aBuilder 	self bundle isNil 		ifTrue: [self disableValidateButton]		ifFalse: [self disableBundleNameEdits].	self initializeVisualBlocksForPundleView.	self initializeVisualBlocksForBundleContentView.</body></methods><methods><class-id>Store.BundleSpecEditor</class-id> <category>private-validation</category><body package="Browser-BaseUI">validateName	"Answer true if the bundle name is ok. Display warning and answer false if not."	self bundleName value isEmpty		ifTrue: [ Dialog warn: (#EnterBundleNameBeforeAccept &lt;&lt; #packages &gt;&gt; 'Enter a bundle name before accepting.').  ^false ].			   	^bundle == nil    		ifFalse: [ true ]		ifTrue: [ 	( PackageModel validateName: self bundleName value ) 					ifFalse: [ Dialog warn: (#BundleHasIllegalCharacters &lt;&lt; #packages &gt;&gt; 'Bundle name "&lt;1s&gt;" can not contain any of these characters: &lt;2s&gt;.&lt;n&gt;Use a different bundle name.' 							expandMacrosWith: self bundleName value							with: PackageModel illegalCharacters).							^false							].				( Registry isBundleLoaded: self bundleName value ) not					ifTrue: [ true ]					ifFalse: [ Dialog warn: ((#BundleNameConflict &lt;&lt; #packages &gt;&gt; 'The name &lt;1s&gt; is already in use.  Use another bundle name.')								expandMacrosWith: self bundleName value).							false 							].				]</body><body package="Browser-BaseUI">validateOrder	"Answer true bundle contents is ok. Display warning and answer false if not."	| errs |	errs := bundle validateLoadOrder.	^errs isEmpty		ifTrue: [ true ]		ifFalse: 			[ errs := ((#BundleCannotBeLoaded &lt;&lt; #packages &gt;&gt; '&lt;1s&gt;&lt;nn&gt;WARNING: the Bundle cannot be loaded. Continue anyway?')				expandMacrosWith: errs).			Dialog confirm: errs.  			].</body></methods><methods><class-id>Store.BundleSpecEditor class</class-id> <category>instance creation</category><body package="Browser-BaseUI">createNewIn: aBundle	BundleSpecEditor new		parentBundle: aBundle;		openInterface: #windowSpecWithEnclosingBundle</body><body package="Browser-BaseUI">openOnBundle: aBundle		BundleSpecEditor new bundle: aBundle; open.</body></methods><methods><class-id>Store.BundleSpecEditor class</class-id> <category>private</category><body package="Browser-BaseUI">bundleImageModified	^ListIconLibrary visualFor: #modifiedBundle</body><body package="Browser-BaseUI">bundleImageUnmodified	^ListIconLibrary visualFor: #bundle</body><body package="Browser-BaseUI">dbBundleImage	^ListIconLibrary visualFor: #bundle</body><body package="Browser-BaseUI">dbPackageImage	^ListIconLibrary visualFor: #package</body><body package="Browser-BaseUI">iconForPundle: aPundle	^aPundle toolListIcon</body><body package="Browser-BaseUI">packageImageModified	^ListIconLibrary visualFor: #modifiedPackage</body><body package="Browser-BaseUI">packageImageUnmodified	^ListIconLibrary visualFor: #package</body></methods><methods><class-id>Refactory.Browser.PackageListTreeModel</class-id> <category>initialize-release</category><body package="Browser-BaseUI">root: anObject displayIt: assumedFalse	"Copied from above, but changed so that we inject an empty column in."	root := anObject.	self resetOpened.	anObject isNil ifTrue: [^self].	(self childrenFor: root) do: 			[:ea |			self				addChild: ea				atLevel: #(#noline)				after: nil]</body></methods><methods><class-id>Refactory.Browser.PackageListTreeModel</class-id> <category>invalidation</category><body package="Browser-BaseUI">resetFirstLevelChildrenIfNeeded	"This method wraps the root into a TreeNodeWrapper so that the new children can be computed properly.	The rest of the method is taken from #replaceChildrenOfNodeAt:with:, where the index parameter would be 0"	| newChildren alreadyDisplayed toBeReplaced rootWrapper |	rootWrapper := (TreeNodeWrapper on: root)				openedChildren: true;				children: (collection							select: [:each | each notNil and: [each indentation = 1]]);				yourself.	newChildren := rootWrapper				refreshAndCollectAllChildrenInto: OrderedCollection new				inTreeModel: self.	alreadyDisplayed := limit.	toBeReplaced := alreadyDisplayed min: newChildren size.	1 to: toBeReplaced		do: [:index | collection at: index put: (newChildren at: index)].	self changed: #replace: with: (Array with: 1 with: toBeReplaced).	alreadyDisplayed &gt; toBeReplaced		ifTrue: [self removeFrom: toBeReplaced + 1 to: alreadyDisplayed].	alreadyDisplayed &lt; newChildren size		ifTrue: 			[self addAll: (newChildren copyFrom: toBeReplaced + 1 to: newChildren size)				beforeIndex: toBeReplaced + 1]</body></methods><methods><class-id>Refactory.Browser.RBActionEditor</class-id> <category>actions</category><body package="Browser-BaseUI">acceptAction	self isValidName 		ifFalse: 			[(self confirm: (#SpecExistsOverwriteQ &lt;&lt; #browser &gt;&gt; 'A specification with that name already exists. Overwrite?')) 				ifFalse: [^self]].	self saveSpec</body><body package="Browser-BaseUI">addSpecification	self actionList selection: nil.	self changedActionSpecification</body><body package="Browser-BaseUI">browseActions	self actionHolder value isNil ifTrue: [^self].	(BrowserEnvironment new implementorsOf: self actionHolder value) 		openEditor</body><body package="Browser-BaseUI">removeAction	(self confirm: (#AreYouSure &lt;&lt; #browser &gt;&gt; 'Are you sure?')) ifFalse: [^self].	self actionList list remove: spec ifAbsent: []</body><body package="Browser-BaseUI">saveActionsToFile	| filename stream |	filename := self request: (#EnterFileName &lt;&lt; #browser &gt;&gt; 'Enter file name').	filename isEmpty ifTrue: [^self].	stream := filename asFilename writeStream.	[stream nextPutAll: '#('.	self actionsArray		do: [:s | stream store: s]		separatedBy: [stream cr].	stream nextPutAll: ')'; cr] 		ensure: [stream close]</body><body package="Browser-BaseUI">saveActionsToMethod	| src |	src := String new writeStream.	src nextPutAll: 'actionArray'; crtab;		nextPutAll: ('"This method was automatically generated from ''&lt;1s&gt; open''"'				expandMacrosWith: self class fullName);		cr; crtab; nextPutAll: '^#('.	self actionsArray			do: [:s | src store: s]		separatedBy: [src crtab].	src nextPutAll: ')'.	self 		performChange: ((#{AddMethodChange} 				valueOrDo: [self error: 'Change objects not loaded']) 					compile: src contents					in: RBCommand class					classified: #'actions-initialization')</body></methods><methods><class-id>Refactory.Browser.RBActionEditor</class-id> <category>aspects</category><body package="Browser-BaseUI">actionHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^actionHolder isNil		ifTrue:			[actionHolder := nil asValue]		ifFalse:			[actionHolder]</body><body package="Browser-BaseUI">actionList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^actionList isNil		ifTrue:			[actionList := SelectionInList new]		ifFalse:			[actionList]</body><body package="Browser-BaseUI">descriptionHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^descriptionHolder isNil		ifTrue:			[descriptionHolder := String new asValue]		ifFalse:			[descriptionHolder]</body><body package="Browser-BaseUI">enabledHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^enabledHolder isNil		ifTrue:			[enabledHolder := nil asValue]		ifFalse:			[enabledHolder]</body><body package="Browser-BaseUI">nameHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^nameHolder isNil		ifTrue:			[nameHolder := String new asValue]		ifFalse:			[nameHolder]</body><body package="Browser-BaseUI">receiverHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^receiverHolder isNil		ifTrue:			[receiverHolder := nil asValue]		ifFalse:			[receiverHolder]</body><body package="Browser-BaseUI">typeList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^typeList isNil		ifTrue:			[typeList := SelectionInList new]		ifFalse:			[typeList]</body></methods><methods><class-id>Refactory.Browser.RBActionEditor</class-id> <category>changing</category><body package="Browser-BaseUI">changedAction	self updateAcceptCancelButtons</body><body package="Browser-BaseUI">changedActionSpecification	| action |	action := self actionList selection.	action isNil ifTrue: [action := RBCommand new].	self initializeForAction: action</body><body package="Browser-BaseUI">changedDescription	self updateAcceptCancelButtons</body><body package="Browser-BaseUI">changedEnabled	self updateAcceptCancelButtons</body><body package="Browser-BaseUI">changedName	self updateAcceptCancelButtons</body><body package="Browser-BaseUI">changedReceiver	self updateAcceptCancelButtons</body><body package="Browser-BaseUI">changedType	self updateAcceptCancelButtons</body></methods><methods><class-id>Refactory.Browser.RBActionEditor</class-id> <category>private</category><body package="Browser-BaseUI">actionsArray	^(self actionList list collect: [:each | each literalArrayEncoding]) 		asArray</body><body package="Browser-BaseUI">disableAccept	(self builder componentAt: #acceptButton) disable</body><body package="Browser-BaseUI">disableCancel	(self builder componentAt: #cancelButton) disable</body><body package="Browser-BaseUI">enableAccept	(self builder componentAt: #acceptButton) enable</body><body package="Browser-BaseUI">enableCancel	(self builder componentAt: #cancelButton) enable</body><body package="Browser-BaseUI">initializeForAction: aRBActionSpecification 	spec := aRBActionSpecification.	self typeList selection: aRBActionSpecification class.	self nameHolder value: aRBActionSpecification key.	self descriptionHolder value: aRBActionSpecification description.	self enabledHolder value: aRBActionSpecification enabled.	self receiverHolder value: aRBActionSpecification receiver.	self actionHolder value: aRBActionSpecification action</body><body package="Browser-BaseUI">installActions	RBCommand initializeWithActions: self actionsArray</body><body package="Browser-BaseUI">saveSpec	| index isNewName |	index := self actionList list indexOf: spec.	isNewName := self nameHolder value ~= spec name or: [index = 0].	self typeList selection ~= spec class 		ifTrue: 			[spec := self typeList selection new.			index &gt; 0 ifTrue: [self actionList list at: index put: spec]].	spec		name: self nameHolder value;		description: self descriptionHolder value asString;		action: self actionHolder value;		enabled: self enabledHolder value;		receiver: self receiverHolder value.	index = 0 ifTrue: [self actionList list add: spec].	isNewName 		ifTrue: [self actionList list sortWith: [:a :b | a name asString &lt; b name asString]].	self actionList selection: spec.	self changedActionSpecification</body><body package="Browser-BaseUI">updateAcceptCancelButtons	self hasChanged 		ifFalse: 			[^self				disableAccept;				disableCancel].	self enableCancel.	self isValidSpecification 		ifTrue: [self enableAccept]		ifFalse: [self disableAccept]</body></methods><methods><class-id>Refactory.Browser.RBActionEditor</class-id> <category>testing</category><body package="Browser-BaseUI">hasActionSpecificationSelected	^self actionList selection notNil</body><body package="Browser-BaseUI">hasChanged	^spec name ~= self nameHolder value or: 			[spec description ~= self descriptionHolder value or: 					[spec action ~= self actionHolder value or: 							[spec enabled ~= self enabledHolder value or: 									[spec receiver ~= self receiverHolder value 										or: [spec class ~= self typeList selection]]]]]</body><body package="Browser-BaseUI">isValidName	^(self actionList list detect: [:each | each name = self nameHolder value]		ifNone: [spec]) = spec</body><body package="Browser-BaseUI">isValidSpecification	^(self nameHolder value size = 0 or: 			[self actionHolder value isNil 				or: [self receiverHolder value isNil or: [self typeList selection isNil]]]) 		not</body></methods><methods><class-id>Refactory.Browser.RBActionEditor</class-id> <category>initialize-release</category><body package="Browser-BaseUI">initialize	super initialize.	self actionList list: (List 				withAll: ((RBCommand actions values collect: [:each | each copy]) 						asSortedCollection: [:a :b | a name asString &lt; b name asString])).	self typeList list: (List withAll: RBCommand withAllSubclasses).	self nameHolder onChangeSend: #changedName to: self.	self descriptionHolder onChangeSend: #changedDescription to: self.	self actionHolder onChangeSend: #changedAction to: self.	self enabledHolder onChangeSend: #changedEnabled to: self.	self receiverHolder onChangeSend: #changedReceiver to: self.	self typeList selectionIndexHolder onChangeSend: #changedType to: self</body></methods><methods><class-id>Refactory.Browser.RBActionEditor</class-id> <category>interface opening</category><body package="Browser-BaseUI">postBuildWith: aBuilder 	super postBuildWith: aBuilder.	self changedActionSpecification</body></methods><methods><class-id>Refactory.Browser.RBActionEditor</class-id> <category>menus</category><body package="Browser-BaseUI">actionSpecificationMenu	^self buildTopLevelMenuFrom: #actionMenu</body></methods><methods><class-id>Refactory.Browser.TabNavigatorPart</class-id> <category>updating widgets</category><body package="Browser-BaseUI">selectionForState: aNavigatorState 	"In case we want to store the previous tab selection"	^nil</body><body package="Browser-BaseUI">selectState: aNavigatorState 	self selectTabListWith: aNavigatorState.	self selectStateForComponents: aNavigatorState</body><body package="Browser-BaseUI">selectStateForComponents: aNavigatorState 	self components do: [:each | each selectState: aNavigatorState]</body><body package="Browser-BaseUI">selectTabListWith: aNavigatorState 	| tabs previousSelection possibleSelections newSelection |	previousSelection := self selection.	tabs := self class tabDescriptions 				select: [:each | each isEnabledIn: aNavigatorState for: self].	self list: tabs asList.	possibleSelections := tabs 				select: [:each | each matches: aNavigatorState for: self].	newSelection := self selectionForState: aNavigatorState.	(possibleSelections includes: newSelection) 		ifFalse: 			[newSelection := (possibleSelections includes: previousSelection) 						ifTrue: [previousSelection]						ifFalse: 							[possibleSelections isEmpty 								ifTrue: [nil]								ifFalse: [possibleSelections first]]].	self select: newSelection.	newSelection ~= previousSelection ifTrue: [self installSubcanvas]</body><body package="Browser-BaseUI">updateComponentsWithState: aNavigatorState 	self components do: [:each | each updateWithState: aNavigatorState]</body><body package="Browser-BaseUI">updateTabListWith: aNavigatorState 	| tabs previousSelection |	previousSelection := self tabDescriptionList selection.	tabs := (self class tabDescriptions 				select: [:each | each isEnabledIn: aNavigatorState for: self]) asList.	self list: tabs asList.	(tabs includes: previousSelection) 		ifTrue: [self tabDescriptionList selection: previousSelection]		ifFalse: 			[self tabDescriptionList 				selection: (tabs isEmpty ifTrue: [nil] ifFalse: [tabs first]).			self installSubcanvas]</body><body package="Browser-BaseUI">updateWithState: aNavigatorState 	self updateTabListWith: aNavigatorState.	self updateComponentsWithState: aNavigatorState</body></methods><methods><class-id>Refactory.Browser.TabNavigatorPart</class-id> <category>testing</category><body package="Browser-BaseUI">alwaysEnabled: aNavigatorState	^true</body><body package="Browser-BaseUI">hasNamespace: aNavigatorState	^aNavigatorState classesAndNameSpaces		anySatisfy: [:each | each isNameSpace]</body><body package="Browser-BaseUI">hasNoClasses: aNavigatorState	^aNavigatorState classesAndNameSpaces allSatisfy: [:each | each isNameSpace]</body><body package="Browser-BaseUI">hasNoNamespaces: aNavigatorState		^(self hasNamespace: aNavigatorState) not</body><body package="Browser-BaseUI">hasOnlyClasses: aNavigatorState	| objects |	objects := aNavigatorState classesAndNameSpaces.	^objects notEmpty and: [objects allSatisfy: [:each | each isBehavior]]</body><body package="Browser-BaseUI">hasOnlyNamespaces: aNavigatorState	| objects |	objects := aNavigatorState classesAndNameSpaces.	^objects notEmpty and: [objects allSatisfy: [:each | each isNameSpace]]</body></methods><methods><class-id>Refactory.Browser.TabNavigatorPart</class-id> <category>aspects</category><body package="Browser-BaseUI">tabDescriptionList	^tabDescriptionList</body></methods><methods><class-id>Refactory.Browser.TabNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI">componentNamed: aSymbol 	^(namedComponents detect: [:each | each key = aSymbol] ifNone: [nil]) 		value</body><body package="Browser-BaseUI">componentNamed: aSymbol put: aValue 	namedComponents add: aSymbol -&gt; aValue</body><body package="Browser-BaseUI">components	^namedComponents collect: [:each | each value]</body><body package="Browser-BaseUI">initializeComponents	namedComponents notNil ifTrue: [self releaseComponents].	namedComponents := OrderedCollection new</body><body package="Browser-BaseUI">installSubcanvas	| tab |	tab := self selection.	tab isNil ifTrue: [^self].	tab buildIn: self</body><body package="Browser-BaseUI">installSubcanvas: aSpec using: anApplicationModel 	self initializeComponents.	(builder componentAt: #subcanvas) widget client: anApplicationModel spec: aSpec.	(anApplicationModel ~~ self 		and: [anApplicationModel respondsTo: #updateDisplay]) 			ifTrue: [anApplicationModel updateDisplay].	self components reverse inject: self		into: 			[:sum :each | 			each				addDependent: sum;				yourself]</body><body package="Browser-BaseUI">list	^self tabDescriptionList list</body><body package="Browser-BaseUI">list: aList	self list = aList ifTrue: [		"If we don't signal a change, the browser does not get refreshed."		self tabDescriptionList listHolder changed: #value.		^self].	self tabDescriptionList list: aList</body><body package="Browser-BaseUI">releaseComponents	self components do: [:each | each release]</body><body package="Browser-BaseUI">select: anObject 	self selection = anObject ifTrue: [^self].	self tabDescriptionList selection: anObject</body><body package="Browser-BaseUI">selection	^self tabDescriptionList selection</body></methods><methods><class-id>Refactory.Browser.TabNavigatorPart</class-id> <category>updating</category><body package="Browser-BaseUI">update: anAspectSymbol with: aParameter from: aSender 	(aSender == self components last and: [anAspectSymbol == #navigatorState]) 		ifTrue: [^self changed: #navigatorState with: aParameter].	^super 		update: anAspectSymbol		with: aParameter		from: aSender</body></methods><methods><class-id>Refactory.Browser.TabNavigatorPart</class-id> <category>initialize-release</category><body package="Browser-BaseUI">initialize	super initialize.	self initializeComponents.	tabDescriptionList := SelectionInList new</body><body package="Browser-BaseUI">navigator: aNavigator 	super navigator: aNavigator.	self components do: [:each | each navigator: aNavigator]</body><body package="Browser-BaseUI">release	self releaseComponents.	super release</body></methods><methods><class-id>Refactory.Browser.TabNavigatorPart</class-id> <category>changing</category><body package="Browser-BaseUI">changedTab	self showWaitCursorWhile: [self installSubcanvas]</body></methods><methods><class-id>Refactory.Browser.TabNavigatorPart</class-id> <category>subcanvases</category><body package="Browser-BaseUI">subcanvases	^self components , super subcanvases</body><body package="Browser-BaseUI">updateDisplay	subcanvasBuilder isNil ifTrue: [self installSubcanvas].	super updateDisplay</body></methods><methods><class-id>Refactory.Browser.TabNavigatorPart</class-id> <category>accessing-navigator</category><body package="Browser-BaseUI">fillInState: aNavigatorState 	self components do: [:each | each fillInState: aNavigatorState]</body><body package="Browser-BaseUI">initiallyOpened: aNavigatorState 	self selectTabListWith: aNavigatorState.	self components do: [:each | each initiallyOpened: aNavigatorState]</body></methods><methods><class-id>Refactory.Browser.TabNavigatorPart</class-id> <category>interface opening</category><body package="Browser-BaseUI">postBuildWith: aBuilder 	builder == aBuilder ifFalse: [subcanvasBuilder := aBuilder].	super postBuildWith: aBuilder</body></methods><methods><class-id>Refactory.Browser.TabNavigatorPart class</class-id> <category>tab descriptions</category><body package="Browser-BaseUI">tabDescriptions	| sortedTags targetClass |	sortedTags := SortedCollection				sortBlock: [:a :b | a arguments first &lt; b arguments first].	targetClass := self class.	[targetClass == TabNavigatorPart class] whileFalse: 			[(Pragma allNamed: #tabDescription: in: targetClass) do: 					[:eachCandidateTag |					(sortedTags						anySatisfy: [:eachAddedTag | eachAddedTag selector = eachCandidateTag selector])							ifFalse: [sortedTags add: eachCandidateTag]].			targetClass := targetClass superclass].	^((sortedTags collect: [:each | self perform: each selector])		reject: #isNil)</body></methods><methods><class-id>Refactory.Browser.PackageListRoot</class-id> <category>accessing</category><body package="Browser-BaseUI">children	"Compute the top level code components from the environment. Which is any code component, for which the environment does not have a containing bundle."	| children allContents |	children := OrderedCollection new.	allContents := IdentitySet new.	self environment bundlesDo: [:each | allContents addAll: each containedItems].	self environment bundlesAndPackagesDo:		[:each |		(allContents includes: each) ifFalse:			[children add: (self newChildElement: each)]].	children sort.	self environment isSystem ifTrue:		[children add: (self newChildElement: Store.Registry nullPackage)].	^children</body><body package="Browser-BaseUI">environment	^environment ifNil: [environment := BrowserEnvironment new]</body><body package="Browser-BaseUI">environment: anObject	environment := anObject</body><body package="Browser-BaseUI">hasChildren	^true</body><body package="Browser-BaseUI">newChildElement: aCodeComponent	^(PackageListElement codeComponent: aCodeComponent)		parent: self;		yourself</body><body package="Browser-BaseUI">showBundleContentsInLoadOrder	^sortBundleContentsByLoadOrder == true</body><body package="Browser-BaseUI">showBundleContentsInLoadOrder: anObject	sortBundleContentsByLoadOrder := anObject</body><body package="Browser-BaseUI">sortBundlesToTop	^sortBundlesToTop == true</body><body package="Browser-BaseUI">sortBundlesToTop: anObject	sortBundlesToTop := anObject</body></methods><methods><class-id>Refactory.Browser.PackageListRoot</class-id> <category>initialize-release</category><body package="Browser-BaseUI">initialize	sortBundleContentsByLoadOrder := ShowBundleContentsInLoadOrder == true.	sortBundlesToTop := SortBundlesToTop == true</body></methods><methods><class-id>Refactory.Browser.PackageListRoot class</class-id> <category>instance creation</category><body package="Browser-BaseUI">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="Browser-BaseUI">onEnvironment: aBrowserEnvironment	"Specific classes should not override environment:, so this class-side method does not match its instance-side."	^(self new)		environment: aBrowserEnvironment;		yourself</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>accessing</category><body package="Browser-BaseUI">addConstantStateBlock: block 	self parts 		add: (ConstantNavigatorPart onNavigator: self stateBlock: block).	self getState</body><body package="Browser-BaseUI">dispatcher	dispatcher isNil ifTrue: [self dispatcher: RBActionDispatcher new].	^dispatcher</body><body package="Browser-BaseUI">dispatcher: aRBActionDispatcher 	dispatcher := aRBActionDispatcher.	dispatcher navigator: self</body><body package="Browser-BaseUI">environment	^environment</body><body package="Browser-BaseUI">environment: aBrowserEnvironment	environment := aBrowserEnvironment</body><body package="Browser-BaseUI">getState	"Get the current selection as a NavigatorState and assign it.  Before discarding the old state, transfer any properties that we cannot rely on the parts to preserve (e.g. because the operation that got this new state may bypass or replace the relevant specific subpart)."	| oldState |	oldState := state.	state := self navigatorStateClass new.	(state inheritToType: oldState inheritToType)		= #class ifTrue: [state inheritToClass: oldState inheritToClass].	state nameSpace: self defaultNameSpace.	state sortBundlesToTop: oldState sortBundlesToTop.	state showBundleContentsInLoadOrder: oldState showBundleContentsInLoadOrder.	parts do: [:each | each fillInState: state].	state protocol notNil ifTrue: [LastProtocol := state protocol].	^state</body><body package="Browser-BaseUI">gotoClass: aClass	| newState |	newState := self getState.	newState clearClassDependentFields.	newState protocol: nil.	newState objectName: aClass fullRootName.	self updateWithState: newState</body><body package="Browser-BaseUI">gotoMethodDefinition: aMethodDefinition	| newState |	newState := self getState.	newState clearClassDependentFields.	newState protocol: (aMethodDefinition implementingClass organization categoryOfElement: aMethodDefinition selector).	newState objectName: aMethodDefinition inheritingClass fullRootName.	newState selector: aMethodDefinition selector.	self updateWithState: newState</body><body package="Browser-BaseUI">gotoPundle: aPundle	| newState |	newState := self getState.	newState clearClassDependentFields.	newState pundle: aPundle.	self updateWithState: newState</body><body package="Browser-BaseUI">setBinding: aBinding 	| newState ns |	newState := self getState.	newState clearClassDependentFields.	aBinding isForGeneral 		ifTrue: 			[ns := Root whoDefinesBinding: aBinding.			ns isNil ifTrue: [^self].			newState				objectName: ns fullRootName;				protocols: #();				definition: (RBInitializerDefinition nameSpace: ns key: aBinding key)]		ifFalse: [newState objectName: aBinding value fullRootName].	self updateWithState: newState</body><body package="Browser-BaseUI">setState: aNavigatorState 	state := aNavigatorState.	self updatePartsWith: aNavigatorState</body><body package="Browser-BaseUI">state	"Return the last computed state"	^state</body><body package="Browser-BaseUI">updateWithState: aNavigatorState 	self		setState: aNavigatorState;		changed</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>private-category</category><body package="Browser-BaseUI">classesMatching: aBlock 	| names |	names := Set new.	self environment 		bindingReferencesDo: [:each | (aBlock value: each) ifTrue: [names add: each]].	^names</body><body package="Browser-BaseUI">findAPrompt: prompt retry: retry type: aBlock 	| destClassName |	destClassName := self request: prompt.	destClassName isEmpty ifTrue: [^nil].	^self 		findClass: destClassName		ifNotFound: 			[(self confirm: retry) 				ifTrue: 					[^self 						findAPrompt: prompt						retry: retry						type: aBlock].			^nil]		type: aBlock</body><body package="Browser-BaseUI">findClass	| class |	class := IncrementalSearchDialog 		selectClass: #FindClass &lt;&lt; #dialogs &gt;&gt; 'Find Class'.	class notNil ifTrue: [self setBinding: class strictReference binding]</body><body package="Browser-BaseUI">findClass: aString ifNotFound: aBlock 	^self 		findClass: aString		ifNotFound: aBlock		type: [:each | true]</body><body package="Browser-BaseUI">findClass: aString ifNotFound: aBlock type: testBlock 	| names |	names := self findReferencesMatching: aString type: testBlock.	names isEmpty ifTrue: [aBlock value].	names size = 1 ifTrue: [^names asArray first].	names := names asSortedCollection: [:a :b | a fullName &lt; b fullName].	^self 		choose: 'What item do you want?'		fromList: names		values: names		lines: 10		cancel: [^nil]</body><body package="Browser-BaseUI">findGlobalName	| dialog bindingRef |	self changeRequest ifFalse: [^self].	dialog := IncrementalSearchDialog forSelectionWithSearch:		[:entry | self referencesMatchingPartialName: entry].	dialog		windowLabel: #FindClassVariableOrNameSpace &lt;&lt; #browser &gt;&gt; 'Find Class, Variable, or Name Space';		firstLabel: #FindC &lt;&lt; #browser &gt;&gt; 'Find:';		secondLabel: #ClassesNamespacesAndVariablesC &lt;&lt; #browser &gt;&gt; 'Classes, Variables, Name Spaces:';		iconSelector: #toolListIcon;		displayStringSelector: #toolListDisplayString;		objectToStringBlock: [:class | class name asString].	bindingRef := dialog select.	bindingRef isNil ifTrue: [^self].	self setBinding: bindingRef binding</body><body package="Browser-BaseUI">findNameSpace		(IncrementalSearchDialog		selectNamespace: #FindNamespace &lt;&lt; #dialogs &gt;&gt; 'Find Namespace')		ifNotNil:			[:object | self setBinding: object fullyQualifiedReference binding]</body><body package="Browser-BaseUI">findPrompt: prompt retry: retry type: block 	| bindingRef |	self changeRequest ifFalse: [^self].	bindingRef := self 				findAPrompt: prompt				retry: retry				type: block.	bindingRef isNil ifTrue: [^self].	self setBinding: bindingRef binding</body><body package="Browser-BaseUI">findReferencesMatching: aString type: testBlock 	| names destClassName |	destClassName := aString trimBlanks.	names := self classesMatching: 					[:each | 					(destClassName match: each simpleName) 						and: [testBlock value: each binding]].	names notEmpty ifTrue: [^names].	names := self classesMatching: 					[:each | 					(destClassName match: each fullName) and: [testBlock value: each binding]].	destClassName := '*' , destClassName , '*'.	names notEmpty ifTrue: [^names].	names := self classesMatching: 					[:each | 					(destClassName match: each simpleName) 						and: [testBlock value: each binding]].	names notEmpty ifTrue: [^names].	^self classesMatching: 			[:each | 			(destClassName match: each fullName) and: [testBlock value: each binding]]</body><body package="Browser-BaseUI">findSharedVariable	self 		findPrompt: #FindSharedVariable &lt;&lt; #dialogs &gt;&gt; 'Find Shared Variable'		retry: #FindSharedVariableRetry &lt;&lt; #dialogs &gt;&gt; 'Could not find a shared variable matching your input. Try again?'		type: [:each | each isForGeneral]</body><body package="Browser-BaseUI">referencesMatchingPartialName: aString	| pattern matches nameSelector |	aString trimBlanks isEmpty ifTrue: [^Array new].	pattern := aString trimBlanks, '*'.	nameSelector := (pattern includes: $.) ifTrue: [#fullName] ifFalse: [#simpleName].	matches := self classesMatching: [:each | pattern match: (each perform: nameSelector)].	^matches asSortedCollection: [:a :b | a toolListDisplayString &lt; b toolListDisplayString]</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>accessing-protocol</category><body package="Browser-BaseUI">isData	^state isData</body><body package="Browser-BaseUI">isMethod	^self isData not</body><body package="Browser-BaseUI">isProtocolSelected	^self protocol notNil</body><body package="Browser-BaseUI">protocol	^state protocol</body><body package="Browser-BaseUI">protocols	^state protocols</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>accessing-class/inst switch</category><body package="Browser-BaseUI">isMeta	^state isMeta</body><body package="Browser-BaseUI">isNotMeta	^state isMeta not</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>accessing-selector</category><body package="Browser-BaseUI">definition	^state definition</body><body package="Browser-BaseUI">definitions	^state definitions</body><body package="Browser-BaseUI">inheritToClass	^state inheritToClass</body><body package="Browser-BaseUI">inheritToClass: aClass 	state inheritToClass: aClass</body><body package="Browser-BaseUI">inheritToType	^state inheritToType</body><body package="Browser-BaseUI">inheritToType: aSymbol 	state inheritToType: aSymbol</body><body package="Browser-BaseUI">isDefinitionSelected	^self definitions notEmpty</body><body package="Browser-BaseUI">isMethodOverridden	^(self selector notNil 		and: [Override isOverriddenSelector: self selector class: self selectedClass]) 			or: 				[self sharedVariableNames notEmpty and: 						[Override isOverriddenStatic: self sharedVariableName							in: self classOrNameSpace]]</body><body package="Browser-BaseUI">isSelectorOrSharedVariableSelected	^self isSelectorSelected or: [self isSharedVariableSelected]</body><body package="Browser-BaseUI">isSelectorSelected	^self selector notNil</body><body package="Browser-BaseUI">isSharedVariableSelected	^self sharedVariableNames notEmpty</body><body package="Browser-BaseUI">isStaticOverridden	^self sharedVariableNames notEmpty and: 			[Override isOverriddenStatic: self sharedVariableName				in: self classOrNameSpace]</body><body package="Browser-BaseUI">methodClass	^state methodClass</body><body package="Browser-BaseUI">methodDefinitions	^state methodDefinitions</body><body package="Browser-BaseUI">selector	^state selector</body><body package="Browser-BaseUI">selectors	^state selectors</body><body package="Browser-BaseUI">sharedVariableDefinitions	^state sharedVariableDefinitions</body><body package="Browser-BaseUI">sharedVariableName	^state sharedVariableName</body><body package="Browser-BaseUI">sharedVariableNames	^state sharedVariableNames</body><body package="Browser-BaseUI">showOnlyFiltered	^showOnlyFiltered</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>accessing-namespace</category><body package="Browser-BaseUI">defaultNameSpace	^self state nameSpace ifNil: [self class defaultNameSpace]</body><body package="Browser-BaseUI">nameSpace	^state nameSpace</body><body package="Browser-BaseUI">setDefaultNameSpace	| nameSpace |	nameSpace := self classOrNameSpace.	nameSpace isNameSpace ifFalse: [nameSpace := self nameSpace].	(self 		confirm: (#ConfirmNewNameSpace &lt;&lt; #dialogs &gt;&gt; 'Make &lt;1p&gt; your default name space?'				expandMacrosWith: nameSpace)) 			ifFalse: [^self].	DefaultNameSpace := nameSpace fullyQualifiedReference</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>accessing-pundles</category><body package="Browser-BaseUI">codeComponents	^state pundles</body><body package="Browser-BaseUI">findPundle		| dialog thePundle |	self changeRequest ifFalse: [^self].	dialog := IncrementalSearchDialog		forSelectionFrom: (self sortedPundleList: self storeRegistry allPundles)		filterBlock: [:entry :pundle | entry , '*' match: pundle name].	dialog		windowLabel: #FindPackageOrBundle &lt;&lt; #browser &gt;&gt; 'Find Package or Bundle';		firstLabel: #FilterC &lt;&lt; #browser &gt;&gt; 'Filter:';		secondLabel: #PackagesAndBundlesC &lt;&lt; #browser &gt;&gt; 'Packages and Bundles:';		objectToStringBlock: [:pundle | pundle name];		displayStringSelector: #toolListText;		iconSelector: #toolListIcon.	thePundle := dialog select.	thePundle isNil ifTrue: [^self].	self selectPundle: thePundle</body><body package="Browser-BaseUI">isBundleSelected	| pundle |	pundle := self pundle.	^pundle notNil and: [pundle isBundle]</body><body package="Browser-BaseUI">isCodeComponentSelected	^self isPundleSelected</body><body package="Browser-BaseUI">isPackageSelected	| pundle |	pundle := self pundle.	^pundle notNil and: [pundle isPackage]</body><body package="Browser-BaseUI">package	^state package</body><body package="Browser-BaseUI">packages	^state packages</body><body package="Browser-BaseUI">pundle	^state pundle</body><body package="Browser-BaseUI">pundles	^state pundles</body><body package="Browser-BaseUI">selectPundle: aPundleModel 	| newState |	newState := state copy.	newState		definitions: #();		protocols: #();		objectNames: #();		pundle: aPundleModel.	self updateWithState: newState</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>updating</category><body package="Browser-BaseUI">refreshLists	self updateWithState: self getState</body><body package="Browser-BaseUI">updateNavigator	self changeRequest ifFalse: [^self].	self refreshLists.</body><body package="Browser-BaseUI">updatePackageList	"Update the package lists only if the receiver is viewing packages.  If a browser has 	 been spawned on package(s) or bundle(s), then the partsDictionary will not 	 include the CodeComponentTabNavigatorPart.  This part is lazily added to the	 partsDictionary (see #CodeComponentTabNavigatorPart), so we first check to see	 if the part is there before trying to refresh its list.  Otherwise, it will have invalid state."		(partsDictionary includesKey: #CodeComponentTabNavigatorPart)		ifTrue: [self CodeComponentTabNavigatorPart refreshPackageList]</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>menus</category><body package="Browser-BaseUI">inheritToSpecifications	| class inheritToClass items inheritToType |	class := self nonMetaClass.	class isNil ifTrue: [^#()].	inheritToType := state inheritToType.	items := OrderedCollection new.	self inheritanceKeysAndLabels do: 			[:each | 			items 				add: ((inheritToType = each first 						ifTrue: [RBCheckedCommand]						ifFalse: [RBCommand]) 							named: each last asString							description: ''							action: 								[self changeRequest 									ifTrue: 										[self inheritToType: each first.										self refreshLists]]							receiver: #yourself)].	items add: nil.	inheritToClass := self inheritToClass instanceBehavior.	items 		addAll: (class withAllSuperclasses reverse collect: 					[:each | 					(each == inheritToClass ifTrue: [RBCheckedCommand] ifFalse: [RBCommand]) 						named: each name						description: (#SelectNavigatorType &lt;&lt; #browser &gt;&gt; 'Select Navigator Type') asString						action: 							[self changeRequest 								ifTrue: 									[self inheritToClass: each.									self refreshLists]]						receiver: #yourself]).	^items</body><body package="Browser-BaseUI">inheritanceKeysAndLabels	^Array		with: (Array 			with: #root 			with: #ShowAllInherited &lt;&lt; #browser &gt;&gt; 'Show All Inherited') 		with: (Array 			with: #rootMinusOne 			with: #ShowAllExceptObject &lt;&lt; #browser &gt;&gt; 'Show All Except for Object')		with: (Array 			with: #class 			with: #ShowNoInherited &lt;&lt; #browser &gt;&gt; 'Show No Inherited')</body><body package="Browser-BaseUI">menuNamed: aString 	^menus at: aString ifAbsentPut: [self buildTopLevelMenuFrom: aString]</body><body package="Browser-BaseUI">rebuildMenus	| oldMenus |	oldMenus := menus.	menus := Dictionary new.	oldMenus 		keysDo: [:each | menus at: each put: (self buildTopLevelMenuFrom: each)].	super rebuildMenus</body><body package="Browser-BaseUI">windowMenuItems	| items |	items := OrderedCollection new.	parts do: [:each | items addAll: each windowMenuItems].	^items</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>interface opening</category><body package="Browser-BaseUI">initiallyUpdateParts	parts do: [:each | each initiallyOpened: state]</body><body package="Browser-BaseUI">postBuildWith: aBuilder 	super postBuildWith: aBuilder.	self initiallyUpdateParts.	self changed</body><body package="Browser-BaseUI">resetBuilder	super resetBuilder.	self initializeParts</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>initialize-release</category><body package="Browser-BaseUI">initialize	super initialize.	state := self navigatorStateClass new.	state nameSpace: self defaultNameSpace.	self initializeParts.	menus := Dictionary new.	showOnlyFiltered := ShowOnlyFiltered.	self inheritToType: #class</body><body package="Browser-BaseUI">initializeParts	parts notNil ifTrue: [parts do: [:each | each release]].	parts := OrderedCollection new.	partsDictionary := Dictionary new</body><body package="Browser-BaseUI">packageListRoot	| root |	root := PackageListRoot onEnvironment: environment.	self state		ifNotNil: 			[root				showBundleContentsInLoadOrder: state showBundleContentsInLoadOrder;				sortBundlesToTop: state sortBundlesToTop].	^root</body><body package="Browser-BaseUI">release	parts do: [:each | each release].	super release</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>aspects</category><body package="Browser-BaseUI">ClassAndMethodTabNavigatorPart	^partsDictionary at: #ClassAndMethodTabNavigatorPart		ifAbsentPut: [parts add: (ClassAndMethodTabNavigatorPart onNavigator: self)]</body><body package="Browser-BaseUI">ClassAndObjectNavigatorPart	^partsDictionary at: #ClassAndObjectNavigatorPart		ifAbsentPut: [parts add: (ClassAndObjectNavigatorPart onNavigator: self)]</body><body package="Browser-BaseUI">ClassNavigatorPart	^partsDictionary at: #ClassNavigatorPart		ifAbsentPut: [parts add: (ClassNavigatorPart onNavigator: self)]</body><body package="Browser-BaseUI">CodeComponentTabNavigatorPart	^partsDictionary at: #CodeComponentTabNavigatorPart		ifAbsentPut: [parts add: (CodeComponentTabNavigatorPart onNavigator: self)]</body><body package="Browser-BaseUI">MethodNavigatorPart	^partsDictionary at: #MethodNavigatorPart		ifAbsentPut: [parts add: (MethodNavigatorPart onNavigator: self)]</body><body package="Browser-BaseUI">NameSpaceItemTabNavigatorPart	^partsDictionary at: #NameSpaceItemTabNavigatorPart		ifAbsentPut: 			[parts add: ((NameSpaceItemTabNavigatorPart onNavigator: self)						showProtocols: true;						yourself)]</body><body package="Browser-BaseUI">methodName	| selector |	selector := self selector.	^selector isNil 		ifTrue: ['No Selector']		ifFalse: [self menuNameFor: selector]</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>accessing-class</category><body package="Browser-BaseUI">classOrNameSpace	^state classOrNameSpace</body><body package="Browser-BaseUI">classesAndNameSpaces	^state classesAndNameSpaces</body><body package="Browser-BaseUI">isBindingSelected	^self selectedBinding notNil</body><body package="Browser-BaseUI">isClassOverridden	^self classOrNameSpace notNil 		and: [Override isOverriddenClassOrNameSpace: self classOrNameSpace]</body><body package="Browser-BaseUI">isClassSelected	^self selectedClass notNil</body><body package="Browser-BaseUI">isGlobalSelected	^self selectedClass notNil or: [self selectedNameSpace notNil]</body><body package="Browser-BaseUI">nonMetaClass	^state nonMetaClass</body><body package="Browser-BaseUI">nonMetaClasses	^state nonMetaClasses</body><body package="Browser-BaseUI">objectName	^state objectName</body><body package="Browser-BaseUI">objectNames	^state objectNames</body><body package="Browser-BaseUI">objectNamesOrderedForRemoval	^state objectNamesOrderedForRemoval</body><body package="Browser-BaseUI">selectClass: aClass 	state		clearClassDependentFields;		selectedClass: aClass.	self updatePartsWith: state</body><body package="Browser-BaseUI">selectedBinding	^state selectedBinding</body><body package="Browser-BaseUI">selectedBindings	^state selectedBindings</body><body package="Browser-BaseUI">selectedClass	^state selectedClass</body><body package="Browser-BaseUI">selectedClasses	^state selectedClasses</body><body package="Browser-BaseUI">selectedGlobals	^state selectedGlobals</body><body package="Browser-BaseUI">selectedNameSpace	^state selectedNameSpace</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>private</category><body package="Browser-BaseUI">find: aString 	| name |	aString isEmpty ifTrue: [^self].	aString first = $# 		ifTrue: [^self findMethod: (aString copyFrom: 2 to: aString size)].	(aString includes: $:) ifTrue: [^self findMethod: aString].	name := self findClass: aString				ifNotFound: 					[^(self 						confirm: (#DidNotFindMatchingVariable &lt;&lt; #dialogs &gt;&gt; 'Did not find any classes, name spaces, or shared variables.&lt;n&gt;Do you wish to look for matching methods?')								expandMacros) 							ifTrue: [self findMethod: aString]].	name isNil ifTrue: [^self].	self setBinding: name bindingOrNil</body><body package="Browser-BaseUI">findMethod: aSelector 	| env items method |	env := self environment 				implementorsMatching: '*' , aSelector trimBlanks , '*'.	items := OrderedCollection new.	env classesAndSelectorsDo: 			[:class :selector | 			items 				add: (class fullName , '&gt;&gt;' , selector) -&gt; (Array with: class with: selector)].	items isEmpty 		ifTrue: [^self warn: (#NoMethodsMatching1sFound &lt;&lt; #browser &gt;&gt; 'No methods matching "&lt;1s&gt;" found'					expandMacrosWith: aSelector)].	items := items asSortedCollection: [:a :b | a key &lt; b key].	method := (items size = 1 				ifTrue: [items first]				ifFalse: 					[self 						choose: #GoToMethodC &lt;&lt; #browser &gt;&gt; 'Go to method:'						fromList: items						values: items						lines: 10						cancel: [^nil]]) 					value.	method isNil ifTrue: [^self].	self		selectClass: method first;		setSelector: method last</body><body package="Browser-BaseUI">navigatorStateClass	^NavigatorState</body><body package="Browser-BaseUI">partNamed: aSymbol	^partsDictionary at: aSymbol</body><body package="Browser-BaseUI">parts	^parts</body><body package="Browser-BaseUI">partsDictionary	^partsDictionary</body><body package="Browser-BaseUI">sortedPundleList: aCollection	^aCollection asSortedCollection:		[:a :b |		(a isBundle xor: b isBundle)			ifTrue: [a isBundle]			ifFalse: [a name &lt; b name]]</body><body package="Browser-BaseUI">subcanvases	^(OrderedCollection withAll: super subcanvases)		addAll: parts;		yourself</body><body package="Browser-BaseUI">updatePartsWith: aNavigatorState 	parts do: [:each | each selectState: aNavigatorState]</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>changing</category><body package="Browser-BaseUI">changedPart: aPart 	| index visibleParts |	visibleParts := parts.	index := visibleParts indexOf: aPart.	index + 1 to: visibleParts size		do: [:i | (visibleParts at: i) updateWithState: state].	self changed</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>private-protocol</category><body package="Browser-BaseUI">findMethodAndSelectAlphabetic	| chosenSelector |	self changeRequest ifFalse: [^self].	chosenSelector := (IncrementalSearchDialog			forSelectionWithSearch:				[:pattern |				pattern isEmpty					ifTrue: [self inheritedSelectors asSortedCollection]					ifFalse: [(self inheritedSelectors 						select: [:each | pattern , '*' match: each]) asSortedCollection]])		windowLabel: (#FindMethod &lt;&lt; #browser &gt;&gt; 'Find Method');		firstLabel: (#FilterC &lt;&lt; #browser &gt;&gt; 'Filter:');		secondLabel: #MethodsC &lt;&lt; #browser &gt;&gt; 'Methods:';		select.	chosenSelector isNil ifTrue: [^self].	self setSelector: chosenSelector.	LastProtocol := self protocol</body><body package="Browser-BaseUI">inheritedSelectors	"The inheritToClass setting, global to the browser's state, is only relevant for a single selected class.	 If multiple classes are selected, we will simply collect all selectors in the selected classes."	| selectors selectedClasses currentClass inheritToClass |		selectors := Set new.	selectedClasses := self selectedClasses.	(selectedClasses size &gt;1)		ifTrue: [			selectedClasses do: [:cls |selectors addAll: (self environment selectorsForClass: cls)]]		ifFalse: [			currentClass := self selectedClass.			inheritToClass := self inheritToClass superclass.			[currentClass notNil and: [currentClass ~= inheritToClass]] whileTrue: 					[selectors addAll: (self environment selectorsForClass: currentClass).					currentClass := currentClass superclass]].	^selectors</body><body package="Browser-BaseUI">setSelector: aSelector 	aSelector isNil ifTrue: [^self].	state type = #sharedVariable ifTrue: [state type: #instance].	state		protocols: #();		definitions: #();		selector: aSelector.	self		updatePartsWith: state;		changed</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>accessing-instance variables</category><body package="Browser-BaseUI">classInstanceVariable	^state classInstanceVariable</body><body package="Browser-BaseUI">classInstanceVariables	^state classInstanceVariables</body><body package="Browser-BaseUI">instanceVariable	^state instanceVariable</body><body package="Browser-BaseUI">instanceVariables	^state instanceVariables</body></methods><methods><class-id>Refactory.Browser.Navigator</class-id> <category>testing</category><body package="Browser-BaseUI">canAddObjectsToEnvironment	^self environment useSystemNavigator</body><body package="Browser-BaseUI">canShowMultipleClasses	^self environment useSystemNavigator</body><body package="Browser-BaseUI">isClassContainerEnvironment	^self environment isClassContainer</body><body package="Browser-BaseUI">isGlobalEnvironment	^self environment isSystem</body><body package="Browser-BaseUI">isLocalEnvironment	^self isGlobalEnvironment not</body><body package="Browser-BaseUI">isSelectorEnvironment	^self environment isSelector</body></methods><methods><class-id>Refactory.Browser.Navigator class</class-id> <category>accessing</category><body package="Browser-BaseUI">defaultNameSpace	^DefaultNameSpace isNil 		ifTrue: [Smalltalk]		ifFalse: [DefaultNameSpace valueOrDo: [Smalltalk]]</body><body package="Browser-BaseUI">defaultNameSpaceString	^self defaultNameSpace fullName</body><body package="Browser-BaseUI">defaultNameSpaceString: aString 	^[DefaultNameSpace := aString asQualifiedReference] on: Error		do: [:ex | ex return: nil]</body><body package="Browser-BaseUI">showOnlyFiltered	^ShowOnlyFiltered</body><body package="Browser-BaseUI">showOnlyFiltered: aBoolean 	ShowOnlyFiltered := aBoolean</body></methods><methods><class-id>Refactory.Browser.ProtocolNavigatorPart</class-id> <category>testing</category><body package="Browser-BaseUI">hasMethodsIn: aSymbol 	^(self methodDefinitionsIn: aSymbol) notEmpty</body><body package="Browser-BaseUI">hasSharedVariablesIn: aSymbol 	^(self sharedVariablesIn: aSymbol) notEmpty</body></methods><methods><class-id>Refactory.Browser.ProtocolNavigatorPart</class-id> <category>updating widgets</category><body package="Browser-BaseUI">selectState: aNavigatorState 	| protocols |	protocols := OrderedCollection withAll: aNavigatorState protocols.	self updateSelectedProtocols: protocols from: aNavigatorState.	self fillInListFor: aNavigatorState.	self select: protocols.	aNavigatorState protocols: self selections</body><body package="Browser-BaseUI">updateSelectedProtocols: protocols from: aNavigatorState 	self subclassResponsibility</body><body package="Browser-BaseUI">updateWithState: aNavigatorState 	| initialSelections |	initialSelections := self selections.	self fillInListFor: aNavigatorState.	self select: initialSelections.	aNavigatorState protocols: self selections</body></methods><methods><class-id>Refactory.Browser.ProtocolNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI">fillInListFor: aNavigatorState 	self subclassResponsibility</body></methods><methods><class-id>Refactory.Browser.ProtocolNavigatorPart</class-id> <category>accessing-navigator</category><body package="Browser-BaseUI">fillInState: aNavigatorState 	aNavigatorState protocols: self selections</body></methods><methods><class-id>Refactory.Browser.ProtocolNavigatorPart</class-id> <category>menus</category><body package="Browser-BaseUI">defaultMenu	^navigator menuNamed: #protocolMenu</body></methods><methods><class-id>Refactory.Browser.ProtocolSortOrder</class-id> <category>printing</category><body package="Browser-BaseUI">displayString	^name asString</body></methods><methods><class-id>Refactory.Browser.ProtocolSortOrder</class-id> <category>initialize-release</category><body package="Browser-BaseUI">named: aString beforeStrings: beforeStrings afterStrings: afterStrings 	name := aString.	sortBefore := beforeStrings.	sortAfter := afterStrings</body></methods><methods><class-id>Refactory.Browser.ProtocolSortOrder</class-id> <category>comparing</category><body package="Browser-BaseUI">= anObject 	^self class = anObject class and: [self name = anObject name]</body><body package="Browser-BaseUI">hash	^name hash</body><body package="Browser-BaseUI">is: aString before: bString 	| aIndex bIndex |	aIndex := self indexOf: aString.	bIndex := self indexOf: bString.	^aIndex &lt; bIndex or: [aIndex = bIndex and: [aString &lt; bString]]</body></methods><methods><class-id>Refactory.Browser.ProtocolSortOrder</class-id> <category>private</category><body package="Browser-BaseUI">indexOf: aString 	1 to: sortBefore size		do: [:i | ((sortBefore at: i) match: aString) ifTrue: [^i - sortBefore size - 1]].	1 to: sortAfter size		do: [:i | ((sortAfter at: i) match: aString) ifTrue: [^i]].	^0</body></methods><methods><class-id>Refactory.Browser.ProtocolSortOrder</class-id> <category>accessing</category><body package="Browser-BaseUI">identifier	^(name respondsTo: #key)		ifTrue: [name key]		ifFalse: [name]</body><body package="Browser-BaseUI">name	^name</body></methods><methods><class-id>Refactory.Browser.ProtocolSortOrder class</class-id> <category>instance creation</category><body package="Browser-BaseUI">alphabetical	^self 		named: (#Alphabetical &lt;&lt; #browser &gt;&gt; 'Alphabetical')		beforeStrings: #()		afterStrings: #()</body><body package="Browser-BaseUI">named: aString beforeStrings: beforeStrings afterStrings: afterStrings 	^(self new)		named: aString			beforeStrings: beforeStrings			afterStrings: afterStrings;		yourself</body><body package="Browser-BaseUI">traditional	^self 		named: (#Traditional &lt;&lt; #browser &gt;&gt; 'Traditional')		beforeStrings: #('*initial*' 'instance creation')		afterStrings: #('private*' 'pvt*')</body></methods><methods><class-id>Refactory.Browser.ClassNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI">classForName: aString 	| classOrNameSpace |	classOrNameSpace := self objectForName: aString.	^classOrNameSpace isBehavior ifTrue: [classOrNameSpace] ifFalse: [nil]</body><body package="Browser-BaseUI">convertToFullNames: classNameSpaceCollection	^classNameSpaceCollection		collect: [:each | navigator environment fullNameFor: each].</body><body package="Browser-BaseUI">displayTextFor: classNameWrapper		| type each simpleName |	each := self objectForName: classNameWrapper fullName.	type := (each notNil and: [each isPatched])		ifTrue: [Array with: #color -&gt; self overriddenColor]		ifFalse: [#()].	simpleName := (each isNil		ifTrue: ['']		ifFalse: [each name]) asText.	(self class shouldBoldDefinedItems		and: [each notNil and: [self isClassOrNameSpaceDefinedInSelection: each]])		ifTrue: [simpleName emphasizeAllWith: (type copyWith: #bold)]		ifFalse: [simpleName emphasizeAllWith: type].	^simpleName</body><body package="Browser-BaseUI">fillInListFor: aNavigatorState 	| names |	names := self namesForState: aNavigatorState.	self updateListWith: names asList</body><body package="Browser-BaseUI">iconFor: classNameWrapper 	| classOrNameSpace |	classOrNameSpace := self objectForName: classNameWrapper fullName.	classOrNameSpace ifNil: [^nil].	^(self showWarningIconForObject: classOrNameSpace) 		ifTrue: 			[| warningIcon |			warningIcon := GeneralIcons warningSuperscript.			classOrNameSpace safeToolListIcon				ifNil: [warningIcon]				ifNotNil: [:originalIcon | VisualStack with: originalIcon with: warningIcon]]		ifFalse: [classOrNameSpace safeToolListIcon]</body><body package="Browser-BaseUI">intersect: bindingCollection with: anotherCollection 	bindingCollection isNil ifTrue: [^anotherCollection].	anotherCollection isNil ifTrue: [^bindingCollection].	^bindingCollection select: [:each | anotherCollection includes: each]</body><body package="Browser-BaseUI">isClassOrNameSpaceDefinedInSelection: aClassOrNameSpace 	| block |	block := [:each | (each definesClassOrNameSpace: aClassOrNameSpace) ifTrue: [^true]].	navigator packages do: block.	^false</body><body package="Browser-BaseUI">namesForState: aNavigatorState		| names |	names := self packageClassesAndNameSpacesFor: aNavigatorState packages.	names isNil ifTrue: [names := #()].	^self convertToObjectNameWrappers: names</body><body package="Browser-BaseUI">objectForName: aString 	^navigator environment classForName: aString.</body><body package="Browser-BaseUI">packageClassesAndNameSpacesFor: packageCollection 	| objects |	packageCollection isEmpty ifTrue: [^nil].	objects := Set new.	packageCollection do: 			[:each | 			objects				addAll: (self convertToFullNames: each allClasses);				addAll: (self convertToFullNames: each allNameSpaces)].	^objects</body><body package="Browser-BaseUI">showWarningIconForObject: aClassOrNameSpace 	^ShowWarningsForUncommentedObjects and: [aClassOrNameSpace needsComment]</body></methods><methods><class-id>Refactory.Browser.ClassNavigatorPart</class-id> <category>accessing-navigator</category><body package="Browser-BaseUI">fillInState: aNavigatorState 	aNavigatorState objectNames: self selections</body></methods><methods><class-id>Refactory.Browser.ClassNavigatorPart</class-id> <category>private-overrides</category><body package="Browser-BaseUI">convertToObjectNameWrappers: aCollection 	| any |	aCollection isEmpty ifTrue: [^aCollection].	any := aCollection detect: [:each | true].	^any isString 		ifTrue: [aCollection collect: [:each | ObjectNameWrapper fullName: each]]		ifFalse: [aCollection]</body><body package="Browser-BaseUI">list	^super list collect: [:each | each asString]</body><body package="Browser-BaseUI">list: aCollection	^super list: (self convertToObjectNameWrappers: aCollection)</body><body package="Browser-BaseUI">select: aCollection in: aSelectionInList 	^super select: (self convertToObjectNameWrappers: aCollection)		in: aSelectionInList</body><body package="Browser-BaseUI">selections	^super selections collect: [:each | each asString]</body></methods><methods><class-id>Refactory.Browser.ClassNavigatorPart</class-id> <category>updating widgets</category><body package="Browser-BaseUI">selectState: aNavigatorState 	self fillInListFor: aNavigatorState.	self select: aNavigatorState objectNames</body><body package="Browser-BaseUI">updateWithState: aNavigatorState 	| initialSelections |	initialSelections := self selections.	self fillInListFor: aNavigatorState.	self select: initialSelections.	aNavigatorState objectNames: self selections</body></methods><methods><class-id>Refactory.Browser.ClassNavigatorPart</class-id> <category>menus</category><body package="Browser-BaseUI">defaultMenu	^navigator menuNamed: #classMenu</body></methods><methods><class-id>Refactory.Browser.ClassNavigatorPart</class-id> <category>changing</category><body package="Browser-BaseUI">changed: anAspectSymbol with: aParameter 	anAspectSymbol == #navigatorState ifTrue: [aParameter inheritToClass: nil].	^super changed: anAspectSymbol with: aParameter</body></methods><methods><class-id>Refactory.Browser.ClassNavigatorPart</class-id> <category>updating</category><body package="Browser-BaseUI">changeSetUpdate: anAspectSymbol with: aParameter 	(#(	#addClass: 		#addClass:attributes: 		#addNameSpace: 		#addNameSpace:attributes: 		#changeClass: 		#changeClass:attributes: 		#removeClass: 		#removeNameSpace: 		#renameClass:as: 		#renameNameSpace:as:) 			includes: anAspectSymbol) 				ifTrue: [^self updateObjectList].	(#(	#commentClass:		#commentNameSpace:)			includes: anAspectSymbol) 				ifTrue: [^self invalidateObjectListWidget]</body><body package="Browser-BaseUI">updateObjectList	self mergeIntoList: (self sortList: (self namesForState: navigator state))</body></methods><methods><class-id>Refactory.Browser.ClassNavigatorPart</class-id> <category>testing</category><body package="Browser-BaseUI">showIcons	^true</body></methods><methods><class-id>Refactory.Browser.ClassNavigatorPart class</class-id> <category>testing</category><body package="Browser-BaseUI">shouldBoldDefinedItems	^true</body></methods><methods><class-id>Refactory.Browser.ClassAndObjectNavigatorPart</class-id> <category>changing</category><body package="Browser-BaseUI">changed	self fillInObjectForSelection.	super changed</body></methods><methods><class-id>Refactory.Browser.ClassAndObjectNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI">fillInObjectForSelection	| objects firstObject |	objects := self objectsForSelection.	firstObject := objects detect: [:each | true] ifNone: [nil].	self objectHolder value: firstObject</body><body package="Browser-BaseUI">namesForState: aNavigatorState 	| names |	names := self environment nameSpaceObjectNames.	^self convertToObjectNameWrappers: names</body><body package="Browser-BaseUI">objectsForSelection		^self packagesForSelection</body><body package="Browser-BaseUI">packagesForSelection	| packages |	packages := OrderedCollection new.	self selections do: 			[:each | 			| pc ref binding |			ref := each asQualifiedReference.			binding := ref bindingOrNil.			binding notNil 				ifTrue: 					[pc := self storeRegistry 								allContainingPackagesForClassOrNameSpace: binding value.					pc 						do: [:package | (packages includes: package) ifFalse: [packages add: package]]]].	^packages</body><body package="Browser-BaseUI">select: aCollection in: aSelectionInList 	super select: aCollection in: aSelectionInList.	self fillInObjectForSelection</body></methods><methods><class-id>Refactory.Browser.ClassAndObjectNavigatorPart</class-id> <category>aspects</category><body package="Browser-BaseUI">objectHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^objectHolder isNil		ifTrue:			[objectHolder := nil asValue]		ifFalse:			[objectHolder]</body></methods><methods><class-id>Refactory.Browser.ClassAndObjectNavigatorPart</class-id> <category>accessing-navigator</category><body package="Browser-BaseUI">fillInState: aNavigatorState		aNavigatorState pundles: self objectsForSelection.	super fillInState: aNavigatorState</body></methods><methods><class-id>Refactory.Browser.ClassAndObjectNavigatorPart class</class-id> <category>testing</category><body package="Browser-BaseUI">shouldBoldDefinedItems	^false</body></methods><methods><class-id>Refactory.Browser.MetaNavigatorPart</class-id> <category>initialize-release</category><body package="Browser-BaseUI">initialize	super initialize.	self metaHolder value: false</body></methods><methods><class-id>Refactory.Browser.MetaNavigatorPart</class-id> <category>aspects</category><body package="Browser-BaseUI">metaHolder	"This method was generated by UIDefiner. Any edits made here 	may be lost whenever methods are automatically defined. The 	initialization provided below may have been preempted by an 	initialize method."	^metaHolder isNil		ifTrue: [metaHolder := nil asValue]		ifFalse: [metaHolder]</body></methods><methods><class-id>Refactory.Browser.MetaNavigatorPart</class-id> <category>updating widgets</category><body package="Browser-BaseUI">selectState: aNavigatorState 	self metaHolder value: aNavigatorState isMeta</body><body package="Browser-BaseUI">updateWithState: aNavigatorState 	aNavigatorState 		type: (self metaHolder value ifTrue: [#class] ifFalse: [#instance])</body></methods><methods><class-id>Refactory.Browser.MetaNavigatorPart</class-id> <category>accessing-navigator</category><body package="Browser-BaseUI">fillInState: aNavigatorState 	aNavigatorState 		type: (self metaHolder value ifTrue: [#class] ifFalse: [#instance])</body></methods><methods><class-id>Refactory.Browser.CodeComponentTabNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI">buildClassHierarchyPackageSubcanvas	| state |	state := navigator state.	self installSubcanvas: #classHierarchyPackageWindowSpec using: self.	self selectStateForComponents: state</body><body package="Browser-BaseUI">buildNamespaceHierarchyPackageSubcanvas	| state |	state := navigator state.	self installSubcanvas: #namespaceHierarchyPackageWindowSpec using: self.	self selectStateForComponents: state</body><body package="Browser-BaseUI">buildPackageSubcanvas	| state |	state := navigator state.	self installSubcanvas: self packageWindowSpec using: self.	self selectStateForComponents: state</body><body package="Browser-BaseUI">packageWindowSpec	^PackageWindowSpec ifNil: [#packageWithPartialClassHierarchyWindowSpec]</body></methods><methods><class-id>Refactory.Browser.CodeComponentTabNavigatorPart</class-id> <category>accessing</category><body package="Browser-BaseUI">classes	| classes |	classes := self componentNamed: #classes.	classes isNil 		ifTrue: 			[classes := ClassNavigatorPart new.			navigator notNil ifTrue: [classes navigator: navigator].			self componentNamed: #classes put: classes].	^classes</body><body package="Browser-BaseUI">hierarchyClasses	| hierarchyClasses |	hierarchyClasses := self componentNamed: #hierarchyClasses.	hierarchyClasses isNil 		ifTrue: 			[hierarchyClasses := HierarchyClassNavigatorPart new.			navigator notNil ifTrue: [hierarchyClasses navigator: navigator].			self componentNamed: #hierarchyClasses put: hierarchyClasses].	^hierarchyClasses</body><body package="Browser-BaseUI">hierarchyNamespaces	| hierarchyNamespaces |	hierarchyNamespaces := self componentNamed: #hierarchyNamespaces.	hierarchyNamespaces isNil ifTrue:		[hierarchyNamespaces := HierarchyNamespaceNavigatorPart new.		navigator notNil ifTrue: [hierarchyNamespaces navigator: navigator].		self componentNamed: #hierarchyNamespaces put: hierarchyNamespaces].	^hierarchyNamespaces</body><body package="Browser-BaseUI">hierarchyPackages	| hierarchyPackages |	hierarchyPackages := self componentNamed: #hierarchyPackages.	hierarchyPackages isNil 		ifTrue: 			[hierarchyPackages := HierarchyPundleNavigatorPart new.			navigator notNil ifTrue: [hierarchyPackages navigator: navigator].			self componentNamed: #hierarchyPackages put: hierarchyPackages].	^hierarchyPackages</body><body package="Browser-BaseUI">packages	| packages |	packages := self componentNamed: #packages.	packages isNil 		ifTrue: 			[packages := PundleNavigatorPart new.			navigator notNil ifTrue: [packages navigator: navigator].			self componentNamed: #packages put: packages].	^packages</body><body package="Browser-BaseUI">partialClassHierarchy	| classes |	classes := self componentNamed: #classes.	classes isNil 		ifTrue: 			[classes := PartialHierarchyClassNavigatorPart new.			navigator notNil ifTrue: [classes navigator: navigator].			self componentNamed: #classes put: classes].	^classes</body><body package="Browser-BaseUI">refreshPackageList	"IF I have an active package list, refresh it. Triggered as a result of publish activity."	(self componentNamed: #packages) 		ifNotNil: [:pundleNavigatorPart | pundleNavigatorPart refreshListDisplay]</body></methods><methods><class-id>Refactory.Browser.CodeComponentTabNavigatorPart</class-id> <category>testing</category><body package="Browser-BaseUI">isCategoryAndClass: arg1	"Dummy method template.  This was installed by the debugger	define method command."	^false</body><body package="Browser-BaseUI">isPackageAndClass: aRefactoryBrowserNavigatorState 	^true</body><body package="Browser-BaseUI">isParcelAndClass: aRefactoryBrowserNavigatorState 	^false</body><body package="Browser-BaseUI">isSafeToSwitchWithoutUpdate	^navigator selectedClass notNil 		and: [navigator pundles allSatisfy: [:each | each isPackage]]</body></methods><methods><class-id>Refactory.Browser.CodeComponentTabNavigatorPart</class-id> <category>navigator accessing</category><body package="Browser-BaseUI">beHierarchy	| current new |	current := self selection.	new := self list detect: [:each | each identifier = 'Class' or: [each identifier = 'Namespace']]				ifNone: [^self].	new = current ifTrue: [^self].	self select: new.	self installSubcanvas</body></methods><methods><class-id>Refactory.Browser.CodeComponentTabNavigatorPart</class-id> <category>updating</category><body package="Browser-BaseUI">update: anAspectSymbol with: aParameter from: aSender 	(aSender == self components last and: [anAspectSymbol == #navigatorState]) 		ifTrue: [self updateTabListWith: aParameter].	^super 		update: anAspectSymbol		with: aParameter		from: aSender</body></methods><methods><class-id>Refactory.Browser.CodeComponentTabNavigatorPart</class-id> <category>changing</category><body package="Browser-BaseUI">changedTab	| canSwitchWithoutUpdates |	canSwitchWithoutUpdates := self isSafeToSwitchWithoutUpdate.	super changedTab.	canSwitchWithoutUpdates ifFalse: [self changed]</body><body package="Browser-BaseUI">changeRequest	^self isSafeToSwitchWithoutUpdate 		ifTrue: [true]		ifFalse: [super changeRequest]</body><body package="Browser-BaseUI">installSubcanvas	"Ugly but somehow we need to let the code model know we switched our tabs."	super installSubcanvas.	navigator changed: #updateState</body></methods><methods><class-id>Refactory.Browser.CodeComponentTabNavigatorPart</class-id> <category>updating widgets</category><body package="Browser-BaseUI">selectionForState: aNavigatorState 	^aNavigatorState propertyAt: #codeComponentTab ifAbsent: [nil]</body></methods><methods><class-id>Refactory.Browser.CodeComponentTabNavigatorPart</class-id> <category>accessing-navigator</category><body package="Browser-BaseUI">fillInState: aNavigatorState 	super fillInState: aNavigatorState.	aNavigatorState propertyAt: #codeComponentTab put: self selection</body></methods><methods><class-id>Refactory.Browser.CodeComponentTabNavigatorPart</class-id> <category>As yet unclassified</category><body package="Browser-BaseUI">isCategory: arg1	"Dummy method template.  This was installed by the debugger	define method command."	^false</body><body package="Browser-BaseUI">isPackage: aRefactoryBrowserNavigatorState 	^true</body><body package="Browser-BaseUI">isParcel: aRefactoryBrowserNavigatorState 	^false</body></methods><methods><class-id>Refactory.Browser.CodeComponentTabNavigatorPart class</class-id> <category>interface specs</category><body package="Browser-BaseUI">currentPackageWindowSpec	^PackageWindowSpec</body><body package="Browser-BaseUI">currentPackageWindowSpec: aSymbol	PackageWindowSpec := aSymbol</body><body package="Browser-BaseUI">packageWindowSpecChoices	^Array		with: #Alphabetical -&gt; #packageWindowSpec		with: #Hierarchical -&gt; #packageWithPartialClassHierarchyWindowSpec</body></methods><methods><class-id>Refactory.Browser.HierarchyObjectNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI">hierachyFor: anObject	| classes |	classes := (self withAllParentsOf: anObject) reverse.	self orderedChildrenFor: anObject into: classes.	^classes</body><body package="Browser-BaseUI">namesForState: aNavigatorState	| rootObject |	rootObject := self rootOf: aNavigatorState classesAndNameSpaces.	rootName := rootObject fullRootName.	^self convertToObjectNameWrappers: ((self hierachyFor: rootObject) collect: [:each | each fullRootName])</body><body package="Browser-BaseUI">orderedChildrenFor: anObject into: aSequence	"Given anObject in our hierarchy tree, add all children to be derived from it into aSequence in the order desired."	self subclassResponsibility</body><body package="Browser-BaseUI">rootName	^rootName</body><body package="Browser-BaseUI">rootOf: aCollectionOfObjects	"This should return a singular object, that represents the logical root of the tree being derived from aCollectionOfObjects. aCollectionOfObjects is a mixed set of instance behaviors and namespaces."	self subclassResponsibility</body><body package="Browser-BaseUI">sortList: aCollection	"Structure of the hierarchy is already sorted as we want it, so just return with coercion."	^aCollection asList</body><body package="Browser-BaseUI">withAllParentsOf: anObject	"Given anObject from the computed hierarchy tree, return all parent objects between anObject (inclusive) and the root object of the hierarchy."	self subclassResponsibility</body></methods><methods><class-id>Refactory.Browser.HierarchyObjectNavigatorPart</class-id> <category>updating</category><body package="Browser-BaseUI">updateObjectList	"Don't do anything. We should refresh the list, but for now, make them refresh it."</body></methods><methods><class-id>Refactory.Browser.HierarchyObjectNavigatorPart</class-id> <category>accessing</category><body package="Browser-BaseUI">displayTextFor: classNameWrapper 	| text |	text := classNameWrapper displayString asText.	classNameWrapper fullName = self rootName ifTrue: [text allBold].	^text</body><body package="Browser-BaseUI">offsetFor: classNameWrapper	| each |	each := self objectForName: classNameWrapper fullName.	^each isNil		ifTrue: [0 @ 0]		ifFalse: [(((self withAllParentsOf: each) size - 1) * 10) @ 0]</body></methods><methods><class-id>Refactory.Browser.HierarchyObjectNavigatorPart</class-id> <category>actions</category><body package="Browser-BaseUI">doubleClickItem	rootName := nil.	self updateWithState: navigator getState</body></methods><methods><class-id>Refactory.Browser.RBMethodDefinition</class-id> <category>private</category><body package="Browser-BaseUI">species	^MethodDefinition</body></methods><methods><class-id>Refactory.Browser.RBMethodDefinition</class-id> <category>printing</category><body package="Browser-BaseUI">displayString	^self selector asString</body></methods><methods><class-id>Refactory.Browser.ConstantNavigatorPart</class-id> <category>updating widgets</category><body package="Browser-BaseUI">selectState: aNavigatorState 	self fillInState: aNavigatorState</body><body package="Browser-BaseUI">updateWithState: aNavigatorState	self fillInState: aNavigatorState</body></methods><methods><class-id>Refactory.Browser.ConstantNavigatorPart</class-id> <category>initialize-release</category><body package="Browser-BaseUI">stateBlock: aBlockClosure	stateBlock := aBlockClosure</body></methods><methods><class-id>Refactory.Browser.ConstantNavigatorPart</class-id> <category>accessing-navigator</category><body package="Browser-BaseUI">fillInState: aNavigatorState	stateBlock value: aNavigatorState</body></methods><methods><class-id>Refactory.Browser.ConstantNavigatorPart class</class-id> <category>instance creation</category><body package="Browser-BaseUI">onNavigator: aNavigator stateBlock: aBlockClosure 	^(self onNavigator: aNavigator)		stateBlock: aBlockClosure;		yourself</body></methods><methods><class-id>Refactory.Browser.HierarchyNamespaceNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI">orderedChildrenFor: aNamespace into: aSequence	(aNamespace nameSpaces sorted: [:a :b | a name &lt; b name]) do: 			[:each |			aSequence add: each.			self orderedChildrenFor: each into: aSequence]</body><body package="Browser-BaseUI">rootOf: aCollectionOfNamespaces	| root oldRoot |	aCollectionOfNamespaces isEmpty ifTrue: [^Root].	rootName notNil		ifTrue: 			[oldRoot := rootName asQualifiedReference valueOrDo: [nil].			(oldRoot notNil and: 					[aCollectionOfNamespaces allSatisfy: 							[:each |							| name |							name := each fullRootName.							self list anySatisfy: [:ref | name = ref]]])				ifTrue: [^oldRoot]].	root := aCollectionOfNamespaces detect: [:each | true].	(oldRoot notNil and: [root withAllEnvironments includes: oldRoot]) ifTrue: [root := oldRoot].	aCollectionOfNamespaces do: [:each | [root environment isNil or: [each withAllEnvironments includes: root]] whileFalse: [root := root environment]].	^root</body><body package="Browser-BaseUI">withAllParentsOf: aNamespace	^aNamespace withAllEnvironments</body></methods><methods><class-id>Refactory.Browser.ClassAndMethodTabNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI">buildClassesSubcanvas	| state |	state := navigator getState.	self installSubcanvas: #classesSpec using: self.	self resize: false.	self selectStateForComponents: state</body><body package="Browser-BaseUI">buildMethodsSubcanvas	| state |	state := navigator getState.	self methods resetBuilder.	self installSubcanvas: #methodsSpec using: self.	self resize: true.	self selectStateForComponents: state</body><body package="Browser-BaseUI">nonPrimaryWidgets	^#(splitter selectors)</body><body package="Browser-BaseUI">releaseComponents	self components do: [:each | each == methods ifFalse: [each release]]</body><body package="Browser-BaseUI">resize: fullSizeBoolean 	| splitter widget |	fullSizeBoolean 		ifTrue: [self hideAll: self nonPrimaryWidgets]		ifFalse: [self showAll: self nonPrimaryWidgets].	widget := self builder componentAt: #subcanvas.	splitter := self builder componentAt: #splitter.		[(widget component layout)		rightOffset: (fullSizeBoolean 					ifTrue: [0]					ifFalse: [splitter component layout leftOffset]);		rightFraction: (fullSizeBoolean 					ifTrue: [1]					ifFalse: [splitter component layout leftFraction]).	splitter widget repairAfterMove] 			on: Error			do: [:ex | ex return]</body></methods><methods><class-id>Refactory.Browser.ClassAndMethodTabNavigatorPart</class-id> <category>changing</category><body package="Browser-BaseUI">changedTab	super changedTab.	self changed</body></methods><methods><class-id>Refactory.Browser.ClassAndMethodTabNavigatorPart</class-id> <category>accessing</category><body package="Browser-BaseUI">classes	| classes |	classes := self componentNamed: #classes.	classes isNil 		ifTrue: 			[classes := ClassAndObjectNavigatorPart new.			navigator notNil ifTrue: [classes navigator: navigator].			self componentNamed: #classes put: classes].	self selectors.	^classes</body><body package="Browser-BaseUI">methods	methods isNil 		ifTrue: 			[methods := MethodNavigatorPart new.			navigator notNil ifTrue: [methods navigator: navigator]].	(self componentNamed: #methods) isNil 		ifTrue: [self componentNamed: #methods put: methods].	^methods</body><body package="Browser-BaseUI">selectors	selectors isNil 		ifTrue: 			[selectors := NameSpaceItemTabNavigatorPart new.			navigator notNil ifTrue: [selectors navigator: navigator]].	(self componentNamed: #selectors) isNil 		ifTrue: [self componentNamed: #selectors put: selectors].	^selectors</body></methods><methods><class-id>Refactory.Browser.ClassAndMethodTabNavigatorPart</class-id> <category>testing</category><body package="Browser-BaseUI">isViewingSelectorList	| subcanvas |	builder isNil ifTrue: [^false].	subcanvas := builder componentAt: #selectors.	^subcanvas isNil ifTrue: [false] ifFalse: [subcanvas isVisible]</body></methods><methods><class-id>Refactory.Browser.ClassAndMethodTabNavigatorPart</class-id> <category>initialize-release</category><body package="Browser-BaseUI">release	methods release.	super release</body></methods><methods><class-id>Refactory.Browser.PackageListElement</class-id> <category>comparing</category><body package="Browser-BaseUI">&lt;= aPackageListElement	^self sortBundlesToTop		ifTrue: 			[self codeComponent isBundle = aPackageListElement codeComponent isBundle				ifTrue: [self codeComponent name &lt;= aPackageListElement codeComponent name]				ifFalse: [self codeComponent isBundle]]		ifFalse: 			[self codeComponent name = aPackageListElement codeComponent name				ifTrue: [self codeComponent isBundle]				ifFalse: [self codeComponent name &lt;= aPackageListElement codeComponent name]]</body><body package="Browser-BaseUI">= anotherListElement	^self class == anotherListElement class		and: [codeComponent = anotherListElement codeComponent]</body><body package="Browser-BaseUI">hash	^codeComponent hash</body></methods><methods><class-id>Refactory.Browser.PackageListElement</class-id> <category>accessing</category><body package="Browser-BaseUI">children	| subComponents |	subComponents := codeComponent containedItems				collect: [:each | self newChildElement: each].	self showBundleContentsInLoadOrder ifFalse: [subComponents sort].	^subComponents</body><body package="Browser-BaseUI">codeComponent	^codeComponent</body><body package="Browser-BaseUI">codeComponent: anObject	codeComponent := anObject</body><body package="Browser-BaseUI">hasChildren	^codeComponent isBundle</body><body package="Browser-BaseUI">newChildElement: aCodeComponent	^(PackageListElement codeComponent: aCodeComponent)		parent: self;		yourself</body><body package="Browser-BaseUI">parent	^parent</body><body package="Browser-BaseUI">parent: anObject	parent := anObject</body><body package="Browser-BaseUI">showBundleContentsInLoadOrder	^self parent showBundleContentsInLoadOrder</body><body package="Browser-BaseUI">sortBundlesToTop	^self parent sortBundlesToTop</body><body package="Browser-BaseUI">toolListIcon	"This method must be fast. It produces an icon to display for a bundle or a package	in the package list of the browser, and is invoked each time an item is displayed."	^self showWarningIcon		ifTrue: 			[| warningIcon |			warningIcon := GeneralIcons warningSuperscript.			codeComponent toolListIcon				ifNil: [warningIcon]				ifNotNil: [:pundleIcon | VisualStack with: pundleIcon with: warningIcon]]		ifFalse: [codeComponent toolListIcon]</body></methods><methods><class-id>Refactory.Browser.PackageListElement</class-id> <category>private</category><body package="Browser-BaseUI">showWarningIcon	"This method must be fast. It is called each time a pundle is displayed,	so its speed directly affects the speed of list display. It should not do anything more	complex than checking a few values. Absolutely no lengthy computations!"	| myComponent |	myComponent := self codeComponent.	(ShowWarningsForUncommentedComponents ~~ false		and: [myComponent commentOrNil isNil]) ifTrue: [^true].	(myComponent isBundle and: [myComponent needsLoadOrderWarning])		ifTrue: [^true].	^false</body></methods><methods><class-id>Refactory.Browser.PackageListElement</class-id> <category>printing</category><body package="Browser-BaseUI">displayString	^#{Store.DbRegistry} ifDefinedDo: [:ignore | codeComponent toolListText]		elseDo: [codeComponent displayString]</body></methods><methods><class-id>Refactory.Browser.PackageListElement class</class-id> <category>instance creation</category><body package="Browser-BaseUI">codeComponent: aCodeComponent	^self new codeComponent: aCodeComponent</body></methods><methods><class-id>Refactory.Browser.MethodNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI">displayTextFor: aMethodDefinition	^aMethodDefinition fullDisplayText</body><body package="Browser-BaseUI">fillInListFor: aNavigatorState 	| defs |	defs := navigator environment methodDefinitions.	(defs size = self list size and: [defs size &gt; 100]) ifTrue: [^self list].	"Optimization hack -- sorting the defs is really slow."	^defs</body><body package="Browser-BaseUI">fillInStateBasedOnSelection: aNavigatorState	self selection		ifNotNil:			[:selection | 			aNavigatorState				classOrNameSpace: selection classOrNameSpace;				protocol: self protocolHolder value]</body><body package="Browser-BaseUI">selectDefinitions: aNavigatorState 	| defs class |	defs := aNavigatorState definitions.	defs notEmpty ifTrue: [^self select: defs].	class := aNavigatorState classOrNameSpace.	class isNil ifTrue: [^self select: #()].	aNavigatorState isMeta ifTrue: [class := class class].	defs := self list select: [:each | each classOrNameSpace = class].	self select: defs</body></methods><methods><class-id>Refactory.Browser.MethodNavigatorPart</class-id> <category>updating widgets</category><body package="Browser-BaseUI">selectState: aNavigatorState 	self fillInListWith: aNavigatorState.	self selectDefinitions: aNavigatorState</body><body package="Browser-BaseUI">updateWithState: aNavigatorState 	self fillInListWith: aNavigatorState.	self selectDefinitions: aNavigatorState</body></methods><methods><class-id>Refactory.Browser.MethodNavigatorPart</class-id> <category>initialize-release</category><body package="Browser-BaseUI">initialize	super initialize.	self protocolHolder value: nil</body></methods><methods><class-id>Refactory.Browser.MethodNavigatorPart</class-id> <category>accessing-navigator</category><body package="Browser-BaseUI">fillInState: aNavigatorState 	self fillInStateBasedOnSelection: aNavigatorState.	super fillInState: aNavigatorState</body><body package="Browser-BaseUI">initiallyOpened: aNavigatorState 	super initiallyOpened: aNavigatorState.	self list isEmpty ifTrue: [^self].	self selection notNil ifTrue: [^self].	self select: (Array with: self list first).	self fillInState: aNavigatorState</body></methods><methods><class-id>Refactory.Browser.MethodNavigatorPart</class-id> <category>updating</category><body package="Browser-BaseUI">addItemChange</body></methods><methods><class-id>Refactory.Browser.MethodNavigatorPart</class-id> <category>menus</category><body package="Browser-BaseUI">defaultMenu	"Ugly method to add the spawn hierarchy after the spawn in the method list 	(assuming that our navigator has the spawn hierarchy action)."	| newMenu menuItem spawnMenuItem |	newMenu := super defaultMenu copy.	menuItem := (navigator menuNamed: #classMenu) 				atNameKey: #'Spawn Class Hierarchy'.	spawnMenuItem := newMenu atNameKey: #'Spawn Method'.	menuItem isNil | spawnMenuItem isNil ifTrue: [^newMenu].	newMenu addItem: menuItem copy atPosition: spawnMenuItem position + 0.00001.	^newMenu</body></methods><methods><class-id>Refactory.Browser.NameSpaceItemTabNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI">buildClassSubcanvas	type := #class.	self buildSelectorSubcanvas</body><body package="Browser-BaseUI">buildInstanceSubcanvas	type := #instance.	self buildSelectorSubcanvas</body><body package="Browser-BaseUI">buildInstanceVariableSubcanvas	type := #instance.	self installSubcanvas: #instanceVariableWindowSpec using: self</body><body package="Browser-BaseUI">buildSelectorSubcanvas	| subcanvases |	subcanvases := self components.	(subcanvases size = 1 		and: [subcanvases first class = SelectorNavigatorPart]) 			ifFalse: [self installSubcanvas: #selectorWithProtocolWindowSpec using: self]</body><body package="Browser-BaseUI">buildSharedVariableSubcanvas	type := #sharedVariable.	self installSubcanvas: #sharedVariableWithProtocolWindowSpec using: self</body><body package="Browser-BaseUI">buildSystemClassSubcanvas	type := #class.	self buildSystemSelectorSubcanvas</body><body package="Browser-BaseUI">buildSystemInstanceSubcanvas	type := #instance.	self buildSystemSelectorSubcanvas</body><body package="Browser-BaseUI">buildSystemSelectorSubcanvas	| subcanvases |	subcanvases := self components.	(subcanvases size = 2 and: 			[subcanvases first class = SelectorProtocolNavigatorPart 				and: [subcanvases last class = SelectorNavigatorPart]]) 		ifFalse: [self installSubcanvas: #selectorWindowSpec using: self]</body><body package="Browser-BaseUI">buildSystemSharedVariableSubcanvas	type := #sharedVariable.	self installSubcanvas: #sharedVariableWindowSpec using: self</body></methods><methods><class-id>Refactory.Browser.NameSpaceItemTabNavigatorPart</class-id> <category>testing</category><body package="Browser-BaseUI">isClass: aNavigatorState 	aNavigatorState objectNames size ~= 1 ifTrue: [^true].	^aNavigatorState selectedClass notNil</body><body package="Browser-BaseUI">isClassAndNotSystem: aNavigatorState 	^(self isNotSystem: aNavigatorState) and: [self isClass: aNavigatorState]</body><body package="Browser-BaseUI">isClassAndSystem: aNavigatorState 	^(self isSystem: aNavigatorState) and: [self isClass: aNavigatorState]</body><body package="Browser-BaseUI">isClassMethod: aNavigatorState 	^aNavigatorState isMeta and: [aNavigatorState isData not]</body><body package="Browser-BaseUI">isInstanceMethod: aNavigatorState 	^aNavigatorState isMeta not and: 			[aNavigatorState isData not 				and: [(self isInstanceVariable: aNavigatorState) not]]</body><body package="Browser-BaseUI">isInstanceVariable: aNavigatorState 	^(aNavigatorState propertyAt: #instanceVariables ifAbsent: [#()]) notEmpty</body><body package="Browser-BaseUI">isNotSystem: aNavigatorState 	^(self isSystem: aNavigatorState) not</body><body package="Browser-BaseUI">isSharedVariable: aNavigatorState 	^aNavigatorState isData or: [aNavigatorState classOrNameSpace isNameSpace]</body><body package="Browser-BaseUI">isSystem: aNavigatorState 	^showProtocols or: [navigator environment isSystem]</body></methods><methods><class-id>Refactory.Browser.NameSpaceItemTabNavigatorPart</class-id> <category>accessing</category><body package="Browser-BaseUI">categories	| categories |	categories := self componentNamed: #categories.	categories isNil 		ifTrue: 			[categories := SharedVariableProtocolNavigatorPart new.			navigator notNil ifTrue: [categories navigator: navigator].			self componentNamed: #categories put: categories].	^categories</body><body package="Browser-BaseUI">instanceVariables	| instanceVariables |	instanceVariables := self componentNamed: #instanceVariables.	instanceVariables isNil 		ifTrue: 			[instanceVariables := InstanceVariableNavigatorPart new.			navigator notNil ifTrue: [instanceVariables navigator: navigator].			self componentNamed: #instanceVariables put: instanceVariables].	^instanceVariables</body><body package="Browser-BaseUI">instanceVariableSelectors	| instanceVariableSelectors |	instanceVariableSelectors := self 				componentNamed: #instanceVariableSelectors.	instanceVariableSelectors isNil 		ifTrue: 			[instanceVariableSelectors := SelectorNavigatorPart new.			instanceVariableSelectors listSelector: #instanceVariableSelectorsIn:.			navigator notNil ifTrue: [instanceVariableSelectors navigator: navigator].			self componentNamed: #instanceVariableSelectors				put: instanceVariableSelectors].	^instanceVariableSelectors</body><body package="Browser-BaseUI">protocols	| protocols |	protocols := self componentNamed: #protocols.	protocols isNil 		ifTrue: 			[protocols := SelectorProtocolNavigatorPart new.			navigator notNil ifTrue: [protocols navigator: navigator].			self componentNamed: #protocols put: protocols].	^protocols</body><body package="Browser-BaseUI">selectors	| selectors |	selectors := self componentNamed: #selectors.	selectors isNil 		ifTrue: 			[selectors := SelectorNavigatorPart new.			navigator notNil ifTrue: [selectors navigator: navigator].			self componentNamed: #selectors put: selectors].	^selectors</body><body package="Browser-BaseUI">selectorsWithProtocol	| selectorsWithProtocol |	selectorsWithProtocol := self componentNamed: #selectorsWithProtocol.	selectorsWithProtocol isNil 		ifTrue: 			[selectorsWithProtocol := SelectorNavigatorPart new.			selectorsWithProtocol listSelector: #allSelectorsIn:.			navigator notNil ifTrue: [selectorsWithProtocol navigator: navigator].			self componentNamed: #selectorsWithProtocol put: selectorsWithProtocol].	^selectorsWithProtocol</body><body package="Browser-BaseUI">sharedVariables	| sharedVariables |	sharedVariables := self componentNamed: #sharedVariables.	sharedVariables isNil 		ifTrue: 			[sharedVariables := SharedVariableNavigatorPart new.			navigator notNil ifTrue: [sharedVariables navigator: navigator].			self componentNamed: #sharedVariables put: sharedVariables].	^sharedVariables</body><body package="Browser-BaseUI">sharedVariablesWithProtocol	| sharedVariablesWithProtocol |	sharedVariablesWithProtocol := self 				componentNamed: #sharedVariablesWithProtocol.	sharedVariablesWithProtocol isNil 		ifTrue: 			[sharedVariablesWithProtocol := SharedVariableNavigatorPart new.			sharedVariablesWithProtocol listSelector: #allSharedVariablesIn:.			navigator notNil 				ifTrue: [sharedVariablesWithProtocol navigator: navigator].			self componentNamed: #sharedVariablesWithProtocol				put: sharedVariablesWithProtocol].	^sharedVariablesWithProtocol</body><body package="Browser-BaseUI">showProtocols	^showProtocols</body><body package="Browser-BaseUI">showProtocols: aBoolean	showProtocols := aBoolean</body></methods><methods><class-id>Refactory.Browser.NameSpaceItemTabNavigatorPart</class-id> <category>initialize-release</category><body package="Browser-BaseUI">initialize	super initialize.	type := #instance.	showProtocols := false</body></methods><methods><class-id>Refactory.Browser.NameSpaceItemTabNavigatorPart</class-id> <category>changing</category><body package="Browser-BaseUI">changedTab	super changedTab.	self updateComponentsWithState: navigator getState.	self changed</body></methods><methods><class-id>Refactory.Browser.NameSpaceItemTabNavigatorPart</class-id> <category>accessing-navigator</category><body package="Browser-BaseUI">fillInState: aNavigatorState 	aNavigatorState type: type.	super fillInState: aNavigatorState</body></methods><methods><class-id>Refactory.Browser.ObjectNameWrapper</class-id> <category>converting</category><body package="Browser-BaseUI">asString	^fullName</body></methods><methods><class-id>Refactory.Browser.ObjectNameWrapper</class-id> <category>accessing</category><body package="Browser-BaseUI">environmentName	environmentName isNil 		ifTrue: 			[| index |			index := fullName lastIndexOf: $. ifAbsent: [1].			environmentName := fullName copyFrom: 1 to: index - 1].	^environmentName</body><body package="Browser-BaseUI">fullName	^fullName</body><body package="Browser-BaseUI">fullName: aString 	fullName := aString</body><body package="Browser-BaseUI">simpleName	simpleName isNil 		ifTrue: 			[| index |			index := fullName lastIndexOf: $. ifAbsent: [0].			simpleName := fullName copyFrom: index + 1 to: fullName size].	^simpleName</body></methods><methods><class-id>Refactory.Browser.ObjectNameWrapper</class-id> <category>comparing</category><body package="Browser-BaseUI">&lt; anObjectNameWrapper 	^self displayString &lt; anObjectNameWrapper displayString</body><body package="Browser-BaseUI">= anObjectNameWrapper 	^self class = anObjectNameWrapper class 		and: [fullName = anObjectNameWrapper fullName]</body><body package="Browser-BaseUI">hash	^fullName hash</body></methods><methods><class-id>Refactory.Browser.ObjectNameWrapper</class-id> <category>printing</category><body package="Browser-BaseUI">displayString	PrintFormat isNil ifTrue: [^self simpleName].	^PrintFormat 		expandMacrosWith: self simpleName		with: self environmentName		with: self fullName</body></methods><methods><class-id>Refactory.Browser.ObjectNameWrapper class</class-id> <category>instance creation</category><body package="Browser-BaseUI">fullName: aString 	^(self new)		fullName: aString;		yourself</body></methods><methods><class-id>Refactory.Browser.ObjectWithIndentedNameWrapper</class-id> <category>initialize-release</category><body package="Browser-BaseUI">initialize	depth := 0</body></methods><methods><class-id>Refactory.Browser.ObjectWithIndentedNameWrapper</class-id> <category>accessing</category><body package="Browser-BaseUI">depth	^depth</body><body package="Browser-BaseUI">depth: anObject	depth := anObject</body></methods><methods><class-id>Refactory.Browser.ObjectWithIndentedNameWrapper</class-id> <category>printing</category><body package="Browser-BaseUI">printOn: aStream	aStream nextPutAll: self class name; nextPutAll: '('; nextPutAll: self displayString; nextPutAll: ')'</body></methods><methods><class-id>Refactory.Browser.ObjectWithIndentedNameWrapper class</class-id> <category>instance creation</category><body package="Browser-BaseUI">fullName: aString depth: aDepth	^(super fullName: aString)		depth: aDepth;		yourself</body><body package="Browser-BaseUI">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Refactory.Browser.SharedVariableProtocolNavigatorPart</class-id> <category>updating widgets</category><body package="Browser-BaseUI">updateSelectedProtocols: protocols from: aNavigatorState 	aNavigatorState sharedVariableDefinitions do: 			[:each | 			| protocol |			protocol := self environment 						whichProtocolIncludesVariable: each variableName						in: each classOrNameSpace.			(protocols includes: protocol) ifFalse: [protocols add: protocol]]</body></methods><methods><class-id>Refactory.Browser.SharedVariableProtocolNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI">displayTextFor: protocol 	^(self hasSharedVariablesIn: protocol) 		ifTrue: [protocol asText]		ifFalse: [('(' , protocol , ')') asText emphasizeAllWith: #italic]</body><body package="Browser-BaseUI">fillInListFor: aNavigatorState		| classes protocols |	classes := aNavigatorState classesAndNameSpaces.	(classes size = 1 and: [aNavigatorState pundles notEmpty])		ifTrue:			[protocols := Set new.			self				inheritedClassesOf: classes asArray first				do:					[:each | protocols addAll: each asNameSpace organization sharedVariableCategories	"self environment sharedVariableProtocolsFor: each"]]		ifFalse: [protocols := #()].	self updateListWith: protocols</body></methods><methods><class-id>Refactory.Browser.SharedVariableProtocolNavigatorPart</class-id> <category>updating</category><body package="Browser-BaseUI">changeSetUpdate: anAspectSymbol with: aParameter 	((#(#reorganizeClassData: #reorganizeNameSpace:) includes: anAspectSymbol) 		and: [aParameter first = navigator classOrNameSpace]) 			ifTrue: 				[self mergeIntoList: ((self allSharedVariableProtocolsIn: navigator state) 							asSortedCollection: self sortBlock)]</body></methods><methods><class-id>Refactory.Browser.BrowserDialog</class-id> <category>widget properties</category><body package="Browser-BaseUI">disable: aSymbol 	| component |	builder isNil ifTrue: [^self].	component := builder componentAt: aSymbol.	component notNil ifTrue: [component disable]</body><body package="Browser-BaseUI">disableAll: aCollection	aCollection do: [:each | self disable: each]</body><body package="Browser-BaseUI">enable: aSymbol 	| component |	builder isNil ifTrue: [^self].	component := builder componentAt: aSymbol.	component notNil ifTrue: [component enable]</body><body package="Browser-BaseUI">enableAll: aCollection	aCollection do: [:each | self enable: each]</body><body package="Browser-BaseUI">hide: aSymbol 	| component |	builder isNil ifTrue: [^self].	component := builder componentAt: aSymbol.	component notNil ifTrue: [component beInvisible]</body><body package="Browser-BaseUI">hideAll: aCollection	aCollection do: [:each | self hide: each]</body><body package="Browser-BaseUI">show: aSymbol 	| component |	builder isNil ifTrue: [^self].	component := builder componentAt: aSymbol.	component notNil ifTrue: [component beVisible]</body><body package="Browser-BaseUI">showAll: aCollection	aCollection do: [:each | self show: each]</body></methods><methods><class-id>Refactory.Browser.BrowserDialog</class-id> <category>interface opening</category><body package="Browser-BaseUI">createSelectedVisualBlockFrom: aBlock 	^	[:v :index | 	| rw |	rw := ReversingWrapper on: (aBlock value: v value: index).	rw reverse setValue: true.	BoundedWrapper on: rw]</body><body package="Browser-BaseUI">createVisualBlockFrom: block 	^[:view :index | BoundingWrapper on: (block value: view value: index)]</body><body package="Browser-BaseUI">visualBlockFor: aSymbol is: aBlock 	| specWidget |	builder isNil ifTrue: [^self].	specWidget := builder componentAt: aSymbol.	specWidget isNil ifTrue: [^self].	(specWidget widget)		visualBlock: (self createVisualBlockFrom: aBlock);		selectedVisualBlock: (self createSelectedVisualBlockFrom: aBlock)</body></methods><methods><class-id>Refactory.Browser.BrowserDialog class</class-id> <category>images</category><body package="Browser-BaseUI">downImage	^OpaqueImageWithEnablement		figure: self downIcon		shape: self downIconMask		inactiveFigure: self disabledDownIcon		inactiveShape: self disabledDownIconMask</body><body package="Browser-BaseUI">upImage	^OpaqueImageWithEnablement		figure: self upIcon		shape: self upIconMask		inactiveFigure: self disabledUpIcon		inactiveShape: self disabledUpIconMask</body></methods><methods><class-id>Refactory.Browser.HierarchyClassNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI">orderedChildrenFor: aClass into: aSequence	(aClass subclasses sorted: [:a :b | a name &lt; b name]) do: 			[:each |			each isMeta				ifFalse: 					[aSequence add: each.					self orderedChildrenFor: each into: aSequence]]</body><body package="Browser-BaseUI">rootOf: aCollectionOfClasses	| root oldRoot |	aCollectionOfClasses isEmpty ifTrue: [^Object].	rootName notNil		ifTrue: 			[oldRoot := rootName asQualifiedReference valueOrDo: [nil].			(oldRoot notNil and: 					[aCollectionOfClasses allSatisfy: 							[:each |							| name |							name := each fullRootName.							self list anySatisfy: [:ref | name = ref]]])				ifTrue: [^oldRoot]].	root := aCollectionOfClasses detect: [:each | true].	(oldRoot notNil and: [root includesBehavior: oldRoot]) ifTrue: [root := oldRoot].	aCollectionOfClasses do: [:each | [root superclass isNil or: [each includesBehavior: root]] whileFalse: [root := root superclass]].	^root</body><body package="Browser-BaseUI">withAllParentsOf: aClass	^aClass withAllSuperclasses</body></methods><methods><class-id>Refactory.Browser.PartialHierarchyClassNavigatorPart</class-id> <category>private-hierarchy</category><body package="Browser-BaseUI">convert: hierarchy intoDisplayableCollection: displayHierarchy indent: indent	hierarchy do: [:association |		displayHierarchy add: indent -&gt; association key fullRootName.		self 			convert: association value 			intoDisplayableCollection: displayHierarchy			indent: indent + 1].	^displayHierarchy</body><body package="Browser-BaseUI">convertHierarchyForDisplay: hierarchy	^self 		convert: hierarchy 		intoDisplayableCollection: (OrderedCollection new: hierarchy size * 4)		indent: 0</body><body package="Browser-BaseUI">hierarchyOfClasses: classes    "Answer my classes in hierarchical order, with indentation"	| classesSet hierarchy |	classes isEmpty ifTrue: [^classes].	classesSet := (Set new: classes size * 2) addAll: classes; yourself.	hierarchy := OrderedCollection new: classes size.	self putHierarchyFrom: Class rootsOfTheWorld with: classesSet into: hierarchy.	hierarchy := self sortHierarchy: hierarchy.	^self convertHierarchyForDisplay: hierarchy</body><body package="Browser-BaseUI">putHierarchyFrom: rootCollection with: visibleClasses into: hierarchy	| classWithChildren |	rootCollection do: [:rootClass |		(visibleClasses includes: rootClass)			ifTrue: [				classWithChildren := Association key: rootClass value: OrderedCollection new.				hierarchy add: classWithChildren.				self 					putHierarchyFrom: rootClass subclasses 					with: visibleClasses 					into: classWithChildren value]	            ifFalse: [      	          self 				putHierarchyFrom: rootClass subclasses				with: visibleClasses 				into: hierarchy]]</body><body package="Browser-BaseUI">sortHierarchy: hierarchy	"hierarchy		Collection of (Association key: class fullName value: children)"	| sortedHierarchy |	sortedHierarchy := hierarchy asSortedCollection: [:a1 :a2 | a1 key name &lt;= a2 key name].	sortedHierarchy do: [:association |		association value: (self sortHierarchy: association value)].	^sortedHierarchy</body></methods><methods><class-id>Refactory.Browser.PartialHierarchyClassNavigatorPart</class-id> <category>private-overrides</category><body package="Browser-BaseUI">convertToObjectNameWrappers: aCollection 	| any |	aCollection isEmpty ifTrue: [^aCollection].	any := aCollection detect: [:each | true].	^any class == Association		ifTrue: [aCollection collect: [:each | ObjectWithIndentedNameWrapper fullName: each value depth: each key]]		ifFalse: [any isString			ifTrue: [aCollection collect: [:each | ObjectWithIndentedNameWrapper fullName: each]]			ifFalse: [aCollection]]</body><body package="Browser-BaseUI">selections	^super selections collect: [:each | each asString trimBlanks]</body></methods><methods><class-id>Refactory.Browser.PartialHierarchyClassNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI">namesForState: aNavigatorState	"If a name does not resolve, treat it the same as a non-class object's name - do not DNU on it - thus preserving the same degree of robustness as the super implementation.  (For example, if we are half-way through renaming a class, redisplay can be triggered while a name's binding has no value.)"	| names classes notClassNames classDepthNameAssocs |	names := self packageClassesAndNameSpacesFor: aNavigatorState packages.	names isNil ifTrue: [names := #()].	notClassNames := OrderedCollection new.	classes := Set new: names size.	names do:		[:name | name asQualifiedReference				ifDefinedDo: [:val | val isBehavior ifTrue: [classes add: val] ifFalse: [notClassNames add: val absoluteName]]				elseDo: [notClassNames add: name]].	classes := classes asSortedCollection: [:a :b | a name &lt; b name].	classDepthNameAssocs := self hierarchyOfClasses: classes.	^self convertToObjectNameWrappers:		(notClassNames sort collect: [:each | 0 -&gt; each]) , classDepthNameAssocs</body><body package="Browser-BaseUI">offsetFor: classNameWrapper	^classNameWrapper depth isNil		ifTrue: [0 @ 0]		ifFalse: [(classNameWrapper depth * 10) @ 0]</body><body package="Browser-BaseUI">sortList: aCollection 	^aCollection</body></methods><methods><class-id>Refactory.Browser.PartialHierarchyClassNavigatorPart</class-id> <category>accessing-navigator</category><body package="Browser-BaseUI">fillInState: aNavigatorState 	aNavigatorState objectNames: (self selections collect: [:className | className trimBlanks])</body></methods><methods><class-id>Refactory.Browser.PartialHierarchyClassNavigatorPart</class-id> <category>updating</category><body package="Browser-BaseUI">updateClassList	"Don't do anything. We should refresh the list, but for now, make them refresh it."</body></methods><methods><class-id>Refactory.Browser.SelectorProtocolNavigatorPart</class-id> <category>updating widgets</category><body package="Browser-BaseUI">updateSelectedProtocols: protocols from: aNavigatorState 	aNavigatorState methodDefinitions do: 			[:each | 			| protocol |			protocol := self environment whichProtocolIncludes: each selector						in: each implementingClass.			(protocols includes: protocol) ifFalse: [protocols add: protocol]]</body></methods><methods><class-id>Refactory.Browser.SelectorProtocolNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI">displayTextFor: aMethodCategory		| hereCount totalCount |	navigator selectedClass ifNil: [^''].	hereCount := self visibleMethodCountIn: aMethodCategory.	hereCount &gt; 0 ifTrue: [^aMethodCategory].	totalCount := self totalMethodCountIn: aMethodCategory.	(totalCount isZero		and: [aMethodCategory = navigator selectedClass initialMethodCategory])		ifTrue:			[^aMethodCategory asText				emphasizeAllWith:					(Array						with: #color -&gt; SymbolicPaint inactiveForeground						with: #italic)].	^aMethodCategory asText		emphasizeAllWith: #color -&gt; SymbolicPaint inactiveForeground</body><body package="Browser-BaseUI">fillInListFor: aNavigatorState		| protocols |	protocols := self allProtocolsIn: aNavigatorState.	protocols isEmpty		ifTrue:			[aNavigatorState selectedClass				ifNotNil:					[:selectedClass | protocols := Array with: selectedClass initialMethodCategory]].	self updateListWith: protocols</body><body package="Browser-BaseUI">iconFor: aMethodCategory	"Return a graphic that shows the count of methods in this category. It's number count text color is based on whether all, none, or some of the methods are currently visible in the browser."	"The bit with style gridding, pure dart throwing until I found an algorithm that positioned it correctly on all 3 display systems."		| totalCount hereCount textColor countStyle listView label |	navigator selectedClass ifNil: [^nil].	totalCount := self totalMethodCountIn: aMethodCategory.	hereCount := self visibleMethodCountIn: aMethodCategory.	listView := self widgetAt: #objectList.	countStyle := listView textStyle copy.	textColor := ((totalCount isZero not and: [hereCount = totalCount])		ifTrue: [ColorValue black]		ifFalse: [SymbolicPaint inactiveForeground]).	label := Label		with: (totalCount printString asText emphasizeAllWith: (Array with: #color -&gt; textColor))		attributes: countStyle.	^VisualStack		with: GeneralIcons methodCountBackground		with: label</body><body package="Browser-BaseUI">sortBlock	^ProtocolOrder isNil 		ifTrue: [super sortBlock]		ifFalse: [[:a :b | ProtocolOrder is: a before: b]]</body><body package="Browser-BaseUI">totalMethodCountIn: aMethodCategory		^(navigator selectedClass organization listAtCategoryNamed:			aMethodCategory) size</body><body package="Browser-BaseUI">visibleMethodCountIn: aMethodCategory		^(self methodDefinitionsIn: aMethodCategory) size</body></methods><methods><class-id>Refactory.Browser.SelectorProtocolNavigatorPart</class-id> <category>updating</category><body package="Browser-BaseUI">changeSetUpdate: anAspectSymbol with: aParameter 	((anAspectSymbol == #reorganizeClass: 		and: [aParameter first = navigator selectedClass]) or:		[anAspectSymbol == #changeSelector:class:protocol: 			and: [(aParameter at: 2) = navigator selectedClass]])			ifTrue: 				[self mergeIntoList: ((self allProtocolsIn: navigator state) 							asSortedCollection: self sortBlock)]</body></methods><methods><class-id>Refactory.Browser.SelectorProtocolNavigatorPart</class-id> <category>testing</category><body package="Browser-BaseUI">showIcons		^true</body></methods><methods><class-id>Refactory.Browser.SelectorProtocolNavigatorPart class</class-id> <category>accessing</category><body package="Browser-BaseUI">protocolOrder	^ProtocolOrder</body><body package="Browser-BaseUI">protocolOrder: aProtocolSortOrder 	ProtocolOrder := aProtocolSortOrder</body><body package="Browser-BaseUI">protocolOrderChoices	^ProtocolOrderChoices</body></methods><methods><class-id>Refactory.Browser.SharedVariableNavigatorPart</class-id> <category>updating widgets</category><body package="Browser-BaseUI">newSelectionsBasedOn: oldSelections 	| newSelections |	newSelections := OrderedCollection new: oldSelections size.	oldSelections do: 			[:each | 			| new |			new := nil.			new := self list detect: [:def | def variableName = each variableName]						ifNone: [nil].			new notNil ifTrue: [newSelections add: new]].	^newSelections</body><body package="Browser-BaseUI">selectState: aNavigatorState 	self fillInListWith: aNavigatorState.	self select: aNavigatorState definitions</body><body package="Browser-BaseUI">updateWithState: aNavigatorState 	| initialSelections |	initialSelections := self selections.	self fillInListWith: aNavigatorState.	self select: (self newSelectionsBasedOn: initialSelections).	aNavigatorState definitions: self selections</body></methods><methods><class-id>Refactory.Browser.SharedVariableNavigatorPart</class-id> <category>private</category><body package="Browser-BaseUI">allSharedVariablesIn: aNavigatorState 	| sharedVariables nameSpaces nameSpace |	nameSpaces := aNavigatorState classesAndNameSpaces.	nameSpaces size ~= 1 ifTrue: [^#()].	nameSpace := nameSpaces asArray first.	sharedVariables := self environment sharedVariablesForClass: nameSpace.	^sharedVariables 		collect: [:each | RBInitializerDefinition nameSpace: nameSpace key: each]</body><body package="Browser-BaseUI">displayTextFor: anInitializerDefinition		| text |	text := super displayTextFor: anInitializerDefinition.	navigator showOnlyFiltered ifTrue: [^text].	(navigator packages		anySatisfy:			[:each | 			each				definesName: anInitializerDefinition variableName				in: anInitializerDefinition classOrNameSpace])		ifTrue:			[text addEmphasis: #(#bold) removeEmphasis: #() allowDuplicates: false].	^text</body><body package="Browser-BaseUI">fillInListFor: aNavigatorState 	| protocols |	protocols := aNavigatorState protocols.	(protocols isEmpty and: [self class showAllItemsWhenNothingSelected]) 		ifTrue: [protocols := self allSharedVariableProtocolsIn: aNavigatorState].	^self sharedVariableDefinitionsFor: protocols		in: aNavigatorState classOrNameSpace</body><body package="Browser-BaseUI">protocolsForSelection	| protocols selections |	selections := self selections.	selections isEmpty ifTrue: [^#()].	protocols := OrderedCollection new.	selections do: 			[:each | 			| protocol |			protocol := self environment 						whichProtocolIncludesVariable: each variableName						in: each classOrNameSpace.			(protocol notNil and: [(protocols includes: protocol) not]) 				ifTrue: [protocols add: protocol]].	^protocols</body><body package="Browser-BaseUI">sharedVariableDefinitionsFor: protocols in: class 	| selectors |	selectors := OrderedCollection new.	class notNil 		ifTrue: 			[protocols 				do: [:each | selectors addAll: (self sharedVariableDefinitionsIn: each)]].	^selectors</body><body package="Browser-BaseUI">sortBlock	^	[:a :b | 	a == b or: 			[a variableName &lt; b variableName or: 					[a variableName = b variableName and: 							[a implementingClass allSuperclasses size 								&gt; b implementingClass allSuperclasses size]]]]</body></methods><methods><class-id>Refactory.Browser.SharedVariableNavigatorPart</class-id> <category>menus</category><body package="Browser-BaseUI">defaultMenu	^navigator menuNamed: #sharedVariableMenu</body></methods><methods><class-id>Refactory.Browser.SharedVariableNavigatorPart</class-id> <category>actions</category><body package="Browser-BaseUI">doubleClickItem	self navigator inspectSharedVariable</body></methods><methods><class-id>Refactory.Browser.TabPartDescription</class-id> <category>private</category><body package="Browser-BaseUI">buildSelector: aSymbol 	buildSelector := aSymbol</body><body package="Browser-BaseUI">enabledSelector: aSymbol 	enabledSelector := aSymbol</body><body package="Browser-BaseUI">matchSelector: aSymbol 	matchSelector := aSymbol</body><body package="Browser-BaseUI">name: aString 	name := aString</body></methods><methods><class-id>Refactory.Browser.TabPartDescription</class-id> <category>testing</category><body package="Browser-BaseUI">isEnabledIn: aNavigatorState for: aTabNavigatorPart 	^aTabNavigatorPart perform: enabledSelector with: aNavigatorState</body><body package="Browser-BaseUI">matches: aNavigatorState for: aTabNavigatorPart 	^aTabNavigatorPart perform: matchSelector with: aNavigatorState</body></methods><methods><class-id>Refactory.Browser.TabPartDescription</class-id> <category>printing</category><body package="Browser-BaseUI">identifier	^(name respondsTo: #key)		ifTrue: [name key asString]		ifFalse: [name asString]</body><body package="Browser-BaseUI">printOn: aStream 	aStream nextPutAll: name asString</body></methods><methods><class-id>Refactory.Browser.TabPartDescription</class-id> <category>accessing</category><body package="Browser-BaseUI">buildIn: aTabNavigatorPart 	^aTabNavigatorPart perform: buildSelector</body><body package="Browser-BaseUI">buildSelector	^buildSelector</body><body package="Browser-BaseUI">enabledSelector	^enabledSelector</body><body package="Browser-BaseUI">matchSelector	^matchSelector</body><body package="Browser-BaseUI">name	^name</body></methods><methods><class-id>Refactory.Browser.TabPartDescription</class-id> <category>comparing</category><body package="Browser-BaseUI">= aTabPartDescription	^self class == aTabPartDescription class and: 			[buildSelector = aTabPartDescription buildSelector and: 					[enabledSelector = aTabPartDescription enabledSelector and: 							[matchSelector = aTabPartDescription matchSelector								and: [name = aTabPartDescription name]]]]</body><body package="Browser-BaseUI">hash	^buildSelector hash</body></methods><methods><class-id>Refactory.Browser.TabPartDescription class</class-id> <category>instance creation</category><body package="Browser-BaseUI">named: aString buildWith: buildSelector match: matchSelector enabled: enabledSelector	"DEPRECATED : The preferred aproach is to use a cascade of simple setters for the initialization."	self deprecated: #(#version '7.7.1' #sunset '8.0' #use 'cascade of simple setters').	^self new		name: aString;		buildSelector: buildSelector;		matchSelector: matchSelector;		enabledSelector: enabledSelector;		yourself</body></methods><methods><class-id>Refactory.Browser.RBDynamicMultiCommand</class-id> <category>accessing</category><body package="Browser-BaseUI">actionSpecificationsFor: anObject 	^[self performWith: anObject] on: Error do: [:ex | ex return: #()]</body></methods><methods><class-id>Refactory.Browser.ValidBundleLoadOrderCache</class-id> <category>initialize-release</category><body package="Browser-BaseUI">initialize	super initialize.	cache := IdentityDictionary new.	ChangeSet addDependent: self</body><body package="Browser-BaseUI">release	ChangeSet removeDependent: self.	^super release</body></methods><methods><class-id>Refactory.Browser.ValidBundleLoadOrderCache</class-id> <category>updating</category><body package="Browser-BaseUI">update: theArguments with: are from: irrelevant	cache := IdentityDictionary new</body></methods><methods><class-id>Refactory.Browser.ValidBundleLoadOrderCache</class-id> <category>accessing</category><body package="Browser-BaseUI">hasValidLoadOrder: aBundleModel	^cache at: aBundleModel ifAbsentPut: [aBundleModel hasValidLoadOrder]</body></methods><methods><class-id>Refactory.Browser.ValidBundleLoadOrderCache class</class-id> <category>accessing</category><body package="Browser-BaseUI">hasValidLoadOrder: aBundleModel	^self current hasValidLoadOrder: aBundleModel</body></methods><methods><class-id>Refactory.Browser.ValidBundleLoadOrderCache class</class-id> <category>initialize-release</category><body package="Browser-BaseUI">flush	current release.	current := nil</body><body package="Browser-BaseUI">obsolete	self flush.	super obsolete.</body></methods><methods><class-id>Refactory.Browser.ValidBundleLoadOrderCache class</class-id> <category>instance creation</category><body package="Browser-BaseUI">current	^current ifNil: [current := self new]</body><body package="Browser-BaseUI">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Core.Metaclass</class-id> <category>accessing</category><body package="Browser-BaseUI">initialMethodCategory		^#'instance creation'</body></methods><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="Browser-BaseUI">initialMethodCategory	^#accessing</body></methods><methods><class-id>Core.Class</class-id> <category>testing</category><body package="Browser-BaseUI">isPatched		^Override isOverriddenClassOrNameSpace: self</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>accessing</category><body package="Browser-BaseUI">widgetPolicy	^medium widgetPolicy</body></methods><methods><class-id>Tools.GeneralIcons class</class-id> <category>utility</category><body package="Browser-BaseUI">canvas	^BehaviorIcons Window</body><body package="Browser-BaseUI">image	^BehaviorIcons Image</body><body package="Browser-BaseUI">menu	^BehaviorIcons Menu</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>testing</category><body package="Browser-BaseUI">hasComment	"This needs to go FAST as the browser hits it lots (via needsComment). So just check for commentKey. "	^self commentKey notNil</body><body package="Browser-BaseUI">needsComment	"This needs to go FAST as the browser hits it lots (which it does based on the fast implementation of hasComment).  Note that a class tree (such as TestCases) which doesn't want to regularly be bothered about needing comments can implement #needsComment to return false"	^self hasComment not</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>accessing</category><body package="Browser-BaseUI">package	^Store.Registry containingPackageForClass: self</body></methods><methods><class-id>Tools.GeneralMethodDefinition</class-id> <category>accessing</category><body package="Browser-BaseUI">asOverride	^Override forSelector: self selector class: self implementingClass</body><body package="Browser-BaseUI">classOrNameSpace	^self inheritingClass</body></methods><methods><class-id>Tools.GeneralMethodDefinition</class-id> <category>printing</category><body package="Browser-BaseUI">fullDisplayText	| text |	text := self displayString asText.	self isPatched 		ifTrue: [text emphasizeAllWith: (Array with: #color -&gt; ColorValue red)].	^text</body></methods><methods><class-id>Tools.GeneralMethodDefinition</class-id> <category>testing</category><body package="Browser-BaseUI">isForSharedVariable	^false</body><body package="Browser-BaseUI">isOverridden	^false</body><body package="Browser-BaseUI">isPatched	^false</body></methods><methods><class-id>Tools.GeneralMethodDefinition</class-id> <category>printing</category><body package="Browser-BaseUI">simpleDisplayText	| string |	string := self selector asString.	self implementingClass ~= self inheritingClass 		ifTrue: 			[string := self selector asText 						, ((' (' , self implementingClass name , ')') asText 								emphasizeAllWith: #italic)].	^string asText</body></methods><methods><class-id>Refactory.Browser.BrowserEnvironmentWrapper</class-id> <category>accessing</category><body package="Browser-BaseUI">selectionIntervalFor: aString  inMethod: selector class: cls	| interval |	interval := super selectionIntervalFor: aString inMethod: selector class: cls.	^interval notNil 		ifTrue: [interval]		ifFalse: [environment selectionIntervalFor: aString inMethod: selector class: cls]</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>enumerating</category><body package="Browser-BaseUI">messagesDo: aBlock 	self		withAllBlockMethodsDo: 			[:meth | 			| scanner |			scanner := InstructionStream on: meth.			scanner				scanFor: 					[:byte |					| selector |					selector := scanner peekForSelector.					selector == nil ifFalse: [aBlock value: selector].					false]]</body></methods><methods><class-id>UI.WidgetPolicy</class-id> <category>accessing</category><body package="Browser-BaseUI">inputFieldBorder	^BeveledBorder inset</body></methods><methods><class-id>Tools.InitializerDefinition</class-id> <category>accessing</category><body package="Browser-BaseUI">asOverride	^Override forDataKey: key in: nameSpace</body><body package="Browser-BaseUI">classOrNameSpace	^nameSpace</body></methods><methods><class-id>Tools.InitializerDefinition</class-id> <category>testing</category><body package="Browser-BaseUI">isForSharedVariable	^true</body><body package="Browser-BaseUI">isOverridden	^Override isOverriddenStatic: key in: nameSpace</body><body package="Browser-BaseUI">isPatched	^Override isOverriddenStatic: key in: nameSpace</body></methods><methods><class-id>Tools.InitializerDefinition</class-id> <category>accessing</category><body package="Browser-BaseUI">package		^Store.Registry		containingPackageForDataKey: key asSymbol		symbol: self classOrNameSpace absoluteSymbol</body><body package="Browser-BaseUI">parseTree	^Refactory.Browser.RBParser parseExpression: self sourceCode</body><body package="Browser-BaseUI">protocol	^self classOrNameSpace asNameSpace organization 		categoryOfElement: self variableName</body></methods><methods><class-id>Tools.InitializerDefinition</class-id> <category>printing</category><body package="Browser-BaseUI">simpleDisplayText	^self variableName asText</body></methods><methods><class-id>Tools.InitializerDefinition</class-id> <category>icons</category><body package="Browser-BaseUI">toolListIcon		^self binding toolListIcon</body></methods><methods><class-id>Tools.InitializerDefinition</class-id> <category>accessing</category><body package="Browser-BaseUI">variableName	^key</body></methods><methods><class-id>Kernel.GeneralBindingReference</class-id> <category>accessing</category><body package="Browser-BaseUI">isPatched		^self binding isForGeneral		ifTrue:			[Override				isOverriddenStatic: self simpleName				in: self environment]		ifFalse: [self value isPatched]</body><body package="Browser-BaseUI">package		^self binding isForGeneral		ifTrue:			[Store.Registry				containingPackageForDataKey: self name asSymbol				symbol: self environment absoluteName asSymbol]		ifFalse: [self value package]</body></methods><methods><class-id>Kernel.CodeComponent</class-id> <category>testing</category><body package="Browser-BaseUI">hasComment	^self comment isEmpty not</body><body package="Browser-BaseUI">needsComment	^self hasComment not</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>testing</category><body package="Browser-BaseUI">hasComment	"Accessing the comment directly is painfully slow for the UI which wants to hammer this often. Count on a nil commentKey meaning comment size = 0."	^self commentKey notNil</body><body package="Browser-BaseUI">isPatched		^Override isOverriddenClassOrNameSpace: self</body><body package="Browser-BaseUI">needsComment	"Accessing the comment directly is painfully slow for the UI which wants to hammer this often. Count on a nil commentKey meaning comment size = 0."	^false</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>accessing</category><body package="Browser-BaseUI">package	^Store.Registry containingPackageForNameSpace: self</body></methods><methods><class-id>Store.BundleModel</class-id> <category>testing</category><body package="Browser-BaseUI">needsLoadOrderWarning	^((self propertyAt: #isLoadOrderWarningSuppressed) == true) not and: 			[(Refactory.Browser.ValidBundleLoadOrderCache hasValidLoadOrder: self) not]</body></methods><methods><class-id>Tools.MethodDefinition class</class-id> <category>tags</category><body package="Browser-BaseUI">instanceMethodsChanged		super instanceMethodsChanged.	self updateToolListIconBlock</body><body package="Browser-BaseUI">updateToolListIconBlock	"We may have added or removed an &lt;icon: &gt; method. Dynamically build a new method that will compute the aggregate of it."		| ws iconMethods |	ws := String new writeStream.	ws nextPutAll: '[:definition | '.	"reference the class explicitely, since a subclass invocation as self would be wrong"	iconMethods := Pragma allNamed: #icon: in: MethodDefinition		sortedByArgument: 1.	iconMethods		do: [:each | ws nextPutAll: 'definition ' , each selector , ' ifNil: ['].	ws nextPutAll: 'nil'.	iconMethods size + 1 timesRepeat: [ws nextPut: $]].	ToolListIconBlock := Compiler evaluate: ws contents</body></methods><methods><class-id>Tools.MethodDefinition</class-id> <category>testing</category><body package="Browser-BaseUI">hasSubImplementor		implementingClass		allSubclassesDo:			[:each | (each includesSelector: selector) ifTrue: [^true]].	^false</body><body package="Browser-BaseUI">hasSuperImplementor		^implementingClass superclass		ifNil: [false]		ifNotNil: [:superImplementor | superImplementor canUnderstand: selector]</body><body package="Browser-BaseUI">isOverridden	^Override isOverriddenSelector: selector class: implementingClass</body><body package="Browser-BaseUI">isPatched	^Override isOverriddenSelector: selector class: implementingClass</body></methods><methods><class-id>Tools.MethodDefinition</class-id> <category>accessing</category><body package="Browser-BaseUI">package		^Store.Registry containingPackageForSelector: selector class:			implementingClass</body><body package="Browser-BaseUI">parseTree	^Refactory.Browser.RBParser parseMethod: self sourceCode</body></methods><methods><class-id>Tools.MethodDefinition</class-id> <category>icons</category><body package="Browser-BaseUI">superOrSubImplentorIcon	self hasSubImplementor		ifTrue: 			[^self hasSuperImplementor				ifTrue: [GeneralIcons upDownArrow]				ifFalse: [GeneralIcons downArrow]]		ifFalse: [self hasSuperImplementor ifTrue: [^GeneralIcons upArrow]].	^nil</body><body package="Browser-BaseUI">toolListIcon	"Do not override this method. Add an arbitrarily named method with an &lt;icon: &gt; tag which returns a VisualComponent or a nil. The argument of the &lt;icon: &gt; tag is a number indicating the precedence, lower numbers get evaluated first. The first to return a non nil icon is the icon that is used."	| baseIcon superSubIcon |	ToolListIconBlock ifNil: [MethodDefinition updateToolListIconBlock].	baseIcon := ToolListIconBlock value: self.	superSubIcon := self superOrSubImplentorIcon.	^baseIcon		ifNil: [superSubIcon]		ifNotNil: 			[superSubIcon				ifNil: [baseIcon]				ifNotNil: [VisualStack with: baseIcon with: superSubIcon]]</body></methods><methods><class-id>Refactory.Browser.BrowserApplicationModel class</class-id> <category>interface specs</category><body package="Browser-BaseUI">emptySpec	"UIPainter new openOnClass: self andSelector: #emptySpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 412 284 612 484 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #() ) )</body></methods><methods><class-id>Refactory.Browser.ListNavigatorPart class</class-id> <category>interface specs</category><body package="Browser-BaseUI">basicWindowSpec	"UIPainter new openOnClass: self andSelector: #basicWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #browser) 			#bounds: #(#{Graphics.Rectangle} 800 600 1000 800 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEnter: #dropSelector 						#drop: #dragStartSelector 						#doDrag: #dragOverSelector 						#dragOver: #dragExitSelector 						#dragLeave: ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #objectList 					#model: #objectList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changed 						#doubleClickSelector: #doubleClickItem 						#requestValueChangeSelector: #changeRequest ) 					#menu: #menu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) ) ) )</body></methods><methods><class-id>Refactory.Browser.PundleNavigatorPart class</class-id> <category>interface specs</category><body package="Browser-BaseUI">basicWindowSpec	"UIPainter new openOnClass: self andSelector: #basicWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #browser) 			#bounds: #(#{Graphics.Rectangle} 512 384 712 584 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TreeViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEnter: #dragOverSelector 						#dragOver: #dragStartSelector 						#doDrag: #dropSelector 						#drop: #dragExitSelector 						#dragLeave: ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #objectList 					#model: #objectList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changed 						#doubleClickSelector: #doubleClickItem 						#requestValueChangeSelector: #changeRequest ) 					#menu: #menu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight 					#useIcons: #other 					#iconSelectors: #(#toolListIcon ) ) ) ) )</body></methods><methods><class-id>Refactory.Browser.ProtocolItemNavigatorPart class</class-id> <category>interface specs</category><body package="Browser-BaseUI">protocolWindowSpec	"UIPainter new openOnClass: self andSelector: #protocolWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #browser) 			#bounds: #(#{Graphics.Rectangle} 700 500 900 700 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragStartSelector 						#doDrag: #dragOkSelector 						#wantToDrag: ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 26 0 0 1 0 1 ) 					#name: #objectList 					#model: #objectList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changed 						#requestValueChangeSelector: #changeRequest ) 					#menu: #menu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 25 0 ) 					#name: #protocolHolder 					#model: #protocolHolder 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>Store.BundleSpecEditor class</class-id> <category>interface specs</category><body package="Browser-BaseUI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #BundleEditor #defaultString: 'Bundle Editor' #catalogID: #packages) 			#min: #(#{Core.Point} 350 250 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 424 368 1024 768 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 65 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #AvailableC #defaultString: 'Available:' #catalogID: #packages) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.5 65 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #BundleContentsC #defaultString: 'Bundle contents:' #catalogID: #packages) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 35 0 0 1 ) 					#label: #(#{Kernel.UserMessage} #key: #BundleNameC #defaultString: 'Bundle name: ' #catalogID: #packages) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 125 0 10 0 -85 1 35 0 ) 					#name: #bundleName 					#model: #bundleName 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #bundleNameChanged ) 					#isReadOnly: false ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 65 0 -80 0.5 -45 1 ) 					#name: #availablePundlesView 					#flags: 15 					#model: #availablePundles 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#okSelection: ) 					#multipleSelections: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -75 0.5 65 0 -5 0.5 90 0 ) 					#name: #addButton 					#model: #addToBundleContents 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#label: #(#{Kernel.UserMessage} #key: #AddArrow #defaultString: 'Add &gt;' #catalogID: #packages) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -75 0.5 95 0 -5 0.5 120 0 ) 					#name: #removeButton 					#model: #removeBundleItem 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#label: #(#{Kernel.UserMessage} #key: #Remove #defaultString: '&lt; Remove' #catalogID: #packages) 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.5 65 0 -85 1 -45 1 ) 					#name: #bundleContentsView 					#flags: 15 					#model: #bundleContents ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 					#layout: #(#{Graphics.LayoutFrame} -80 1 95 0 -10 1 120 0 ) 					#name: #downButton 					#model: #moveBundleItemDown 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#tabable: false 					#label: #(#{Kernel.UserMessage} #key: #MoveDown #defaultString: 'Move Down' #catalogID: #packages) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 					#layout: #(#{Graphics.LayoutFrame} -80 1 65 0 -10 1 90 0 ) 					#name: #upButton 					#model: #moveBundleItemUp 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#tabable: false 					#label: #(#{Kernel.UserMessage} #key: #MoveUp #defaultString: 'Move Up' #catalogID: #packages) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -80 1 130 0 -10 1 155 0 ) 					#name: #validateLoadOrder 					#model: #validateLoadOrder 					#label: #(#{Kernel.UserMessage} #key: #Validate #defaultString: 'Validate' #catalogID: #packages) 					#isDefault: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -85 1 -35 1 -10 1 -10 1 ) 					#name: #cancelButton 					#model: #cancel 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #packages) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -165 1 -35 1 -90 1 -10 1 ) 					#name: #acceptButton 					#model: #accept 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #packages) 					#isDefault: true 					#defaultable: true ) ) ) )</body><body package="Browser-BaseUI">windowSpecWithEnclosingBundle	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #BundleEditor 				#defaultString: 'Bundle Editor' 				#catalogID: #packages ) 			#min: #(#{Core.Point} 350 250 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 233 560 833 960 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 94 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #AvailableC 						#defaultString: 'Available:' 						#catalogID: #packages ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 0 0.500673 94 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #BundleContentsC 						#defaultString: 'Bundle contents:' 						#catalogID: #packages ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 35 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #BundleNameC 						#defaultString: 'Bundle name: ' 						#catalogID: #packages ) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 125 0 10 0 -85 1 35 0 ) 					#name: #bundleName 					#model: #bundleName 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #bundleNameChanged ) 					#isReadOnly: false ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 95 0 -80 0.5 -45 1 ) 					#name: #availablePundlesView 					#flags: 15 					#model: #availablePundles 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#okSelection: ) 					#multipleSelections: true 					#selectionType: #highlight ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -75 0.5 95 0 -5 0.5 120 0 ) 					#name: #addButton 					#model: #addToBundleContents 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #AddArrow 						#defaultString: 'Add &gt;' 						#catalogID: #packages ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -75 0.5 125 0 -5 0.5 150 0 ) 					#name: #removeButton 					#model: #removeBundleItem 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Remove 						#defaultString: '&lt; Remove' 						#catalogID: #packages ) 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.5 95 0 -85 1 -45 1 ) 					#name: #bundleContentsView 					#flags: 15 					#model: #bundleContents ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 					#layout: #(#{Graphics.LayoutFrame} -80 1 125 0 -10 1 150 0 ) 					#name: #downButton 					#model: #moveBundleItemDown 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #MoveDown 						#defaultString: 'Move Down' 						#catalogID: #packages ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 					#layout: #(#{Graphics.LayoutFrame} -80 1 95 0 -10 1 120 0 ) 					#name: #upButton 					#model: #moveBundleItemUp 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #disturb ) 					#tabable: false 					#label: 					#(#{Kernel.UserMessage} 						#key: #MoveUp 						#defaultString: 'Move Up' 						#catalogID: #packages ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -80 1 160 0 -10 1 185 0 ) 					#name: #validateLoadOrder 					#model: #validateLoadOrder 					#label: 					#(#{Kernel.UserMessage} 						#key: #Validate 						#defaultString: 'Validate' 						#catalogID: #packages ) 					#isDefault: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -85 1 -35 1 -10 1 -10 1 ) 					#name: #cancelButton 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #packages ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -165 1 -35 1 -90 1 -10 1 ) 					#name: #acceptButton 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #packages ) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 46 ) 					#name: #Label1 					#label: 					#(#{Kernel.UserMessage} 						#key: #ParentBundleC 						#defaultString: 'Parent bundle:' 						#catalogID: #packages ) ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 125 0 45 0 -85 1 68 0 ) 					#name: #ParentBundleComboBox 					#model: #parentBundleHolder 					#isReadOnly: false 					#type: #object 					#comboList: #availableBundles 					#readSelector: 					#bundleNamed: 					#printSelector: 					#nameForBundle: ) ) ) )</body></methods><methods><class-id>Store.BundleSpecEditor class</class-id> <category>resources</category><body package="Browser-BaseUI">downArrow	"UIMaskEditor new openOnClass: self andSelector: #downArrow"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 13@8 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 127 240 0 0 63 224 0 0 31 192 0 0 15 128 0 0 7 0 0 0 2 0 0 0 0 0 0 0])</body><body package="Browser-BaseUI">upArrow	"UIMaskEditor new openOnClass: self andSelector: #upArrow"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 13@8 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 2 0 0 0 7 0 0 0 15 128 0 0 31 192 0 0 63 224 0 0 127 240 0 0 0 0 0 0])</body></methods><methods><class-id>Refactory.Browser.RBActionEditor class</class-id> <category>resources</category><body package="Browser-BaseUI">actionMenu	"MenuEditor new openOnClass: self andSelector: #actionMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Add #defaultString: '&amp;Add' #catalogID: #browser) 				#nameKey: #'Add Action Specification' 				#value: 				#action: ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Remove #defaultString: '&amp;Remove' #catalogID: #browser) 				#nameKey: #'Remove Action Specification' 				#value: 				#action: ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Refactory.Browser.RBActionEditor class</class-id> <category>interface specs</category><body package="Browser-BaseUI">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #ActionEditor #defaultString: 'Action Editor' #catalogID: #browser) 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 491 417 1110 784 ) 			#isEventDriven: true ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 27 0 0 0.4 -35 1 ) 					#name: #actionList 					#flags: 15 					#model: #actionList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedActionSpecification 						#requestValueChangeSelector: #changeRequest ) 					#menu: #actionSpecificationMenu 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 2 2 ) 					#label: #(#{Kernel.UserMessage} #key: #ActionC #defaultString: 'Action:' #catalogID: #browser) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 90 0.4 10 0 1 0 ) 					#name: #nameLabel 					#label: #(#{Kernel.UserMessage} #key: #NameC #defaultString: 'Name:' #catalogID: #browser) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 95 0.4 8 0 -2 1 35 0 ) 					#name: #nameHolder 					#model: #nameHolder ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.4 0 0 4 0.4 -33 1 ) 					#orientation: #vertical ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 95 0.4 45 0 -2 1 135 0 ) 					#name: #descriptionHolder 					#model: #descriptionHolder 					#tabRequiresControl: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 90 0.4 45 0 1 0 ) 					#name: #descriptionLabel 					#label: #(#{Kernel.UserMessage} #key: #DescriptionC #defaultString: 'Description:' #catalogID: #browser) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -150 1 305 0 -80 1 330 0 ) 					#name: #acceptButton 					#model: #acceptAction 					#label: #(#{Kernel.UserMessage} #key: #Accept #defaultString: 'Accept' #catalogID: #browser) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -75 1 305 0 -5 1 330 0 ) 					#name: #cancelButton 					#model: #changedActionSpecification 					#label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #browser) 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 95 0.4 143 0 -2 1 170 0 ) 					#name: #actionHolder 					#model: #actionHolder 					#type: #symbol ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 90 0.4 175 0 1 0 ) 					#name: #enabledLabel 					#label: #(#{Kernel.UserMessage} #key: #EnabledC #defaultString: 'Enabled:' #catalogID: #browser) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 95 0.4 173 0 -2 1 200 0 ) 					#name: #enabledHolder 					#model: #enabledHolder 					#type: #symbol ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 90 0.4 205 0 1 0 ) 					#name: #receiverLabel 					#label: #(#{Kernel.UserMessage} #key: #ReceiverC #defaultString: 'Receiver:' #catalogID: #browser) ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 95 0.4 203 0 -2 1 230 0 ) 					#name: #receiverHolder 					#model: #receiverHolder 					#type: #symbol ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 95 0.4 233 0 -2 1 300 0 ) 					#name: #typeList 					#model: #typeList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 90 0.4 235 0 1 0 ) 					#name: #typeLabel 					#label: #(#{Kernel.UserMessage} #key: #TypeC #defaultString: 'Type:' #catalogID: #browser) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -50 0.75 -28 1 50 0.75 -2 1 ) 					#model: #saveActionsToMethod 					#label: #(#{Kernel.UserMessage} #key: #SaveMethod #defaultString: 'Save Method' #catalogID: #browser) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -50 0.5 -28 1 50 0.5 -2 1 ) 					#model: #saveActionsToFile 					#label: #(#{Kernel.UserMessage} #key: #SaveFile #defaultString: 'Save File' #catalogID: #browser) 					#defaultable: true ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -33 1 0 1 -31 1 ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -50 0.25 -28 1 50 0.25 -2 1 ) 					#model: #installActions 					#label: #(#{Kernel.UserMessage} #key: #Install #defaultString: 'Install' #catalogID: #browser) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 90 0.4 145 0 1 0 ) 					#model: #browseActions 					#tabable: false 					#label: #(#{Kernel.UserMessage} #key: #ActionC #defaultString: 'Action:' #catalogID: #browser) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Refactory.Browser.TabNavigatorPart class</class-id> <category>interface specs</category><body package="Browser-BaseUI">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #browser) 			#bounds: #(#{Graphics.Rectangle} 512 384 712 584 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #subcanvas 					#model: #tabDescriptionList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedTab 						#requestValueChangeSelector: #changeRequest ) 					#labels: #() ) ) ) )</body></methods><methods><class-id>Refactory.Browser.TabNavigatorPart class</class-id> <category>tab descriptions</category><body package="Browser-BaseUI">tabDescriptionTags	"Methods tagged with &lt;tabDescription:&gt; should return a single TabDescription object or nil, the argument is a Number representing its order."	&lt;pragmas: #class&gt;	^#(#tabDescription:)</body></methods><methods><class-id>Refactory.Browser.ClassAndObjectNavigatorPart class</class-id> <category>interface specs</category><body package="Browser-BaseUI">basicWindowSpec	"UIPainter new openOnClass: self andSelector: #basicWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #browser) 			#bounds: #(#{Graphics.Rectangle} 700 500 900 700 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dragOkSelector 						#wantToDrag: #dragEnterSelector 						#dragEnter: #dropSelector 						#drop: #dragStartSelector 						#doDrag: #dragOverSelector 						#dragOver: #dragExitSelector 						#dragLeave: ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 26 0 0 1 0 1 ) 					#name: #objectList 					#model: #objectList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changed 						#doubleClickSelector: #doubleClickItem 						#requestValueChangeSelector: #changeRequest ) 					#menu: #menu 					#multipleSelections: true 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 25 0 ) 					#name: #objectHolder 					#model: #objectHolder 					#tabable: false 					#isReadOnly: true 					#type: #object ) ) ) )</body></methods><methods><class-id>Refactory.Browser.MetaNavigatorPart class</class-id> <category>interface specs</category><body package="Browser-BaseUI">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #browser) 			#bounds: #(#{Graphics.Rectangle} 706 589 895 612 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 1 0 0 0.5 -1 1 ) 					#name: #instance 					#model: #metaHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changed 						#requestValueChangeSelector: #changeRequest ) 					#label: #(#{Kernel.UserMessage} #key: #Instance #defaultString: 'Instance' #catalogID: #browser) 					#select: false ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.5 1 0 -1 1 -1 1 ) 					#name: #class 					#model: #metaHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changed 						#requestValueChangeSelector: #changeRequest ) 					#label: #(#{Kernel.UserMessage} #key: #Class #defaultString: 'Class' #catalogID: #browser) 					#select: true ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) ) ) ) )</body></methods><methods><class-id>Refactory.Browser.CodeComponentTabNavigatorPart class</class-id> <category>interface specs</category><body package="Browser-BaseUI">classHierarchyPackageWindowSpec	"UIPainter new openOnClass: self andSelector: #packageHierarchyWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 800 600 1000 800 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.5 0 1 ) 					#name: #hierarchyClasses 					#flags: 0 					#majorKey: #{Refactory.Browser.HierarchyClassNavigatorPart} 					#minorKey: #windowSpec 					#clientKey: #hierarchyClasses ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 0 0 0 1 0 1 ) 					#name: #hierarchyPackages 					#flags: 0 					#majorKey: #{Refactory.Browser.HierarchyPundleNavigatorPart} 					#minorKey: #windowSpec 					#clientKey: #hierarchyPackages ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0 2 0.5 0 1 ) 					#name: #ResizingSplitter1 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'hierarchyClasses' 					#belowWidgets: 'hierarchyPackages' ) ) ) )</body><body package="Browser-BaseUI">namespaceHierarchyPackageWindowSpec	"UIPainter new openOnClass: self andSelector: #packageNamespaceWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 800 600 1000 800 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.5 0 1 ) 					#name: #hierarchyNamespaces 					#flags: 0 					#majorKey: #{Refactory.Browser.HierarchyNamespaceNavigatorPart} 					#minorKey: #windowSpec 					#clientKey: #hierarchyNamespaces ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 0 0 0 1 0 1 ) 					#name: #hierarchyPackages 					#flags: 0 					#majorKey: #{Refactory.Browser.HierarchyPundleNavigatorPart} 					#minorKey: #windowSpec 					#clientKey: #hierarchyPackages ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0 2 0.5 0 1 ) 					#name: #ResizingSplitter1 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'hierarchyNamespaces' 					#belowWidgets: 'hierarchyPackages' ) ) ) )</body><body package="Browser-BaseUI">packageWindowSpec	"UIPainter new openOnClass: self andSelector: #packageWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 800 600 1000 800 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.5 0 1 ) 					#name: #packages 					#flags: 0 					#majorKey: #{Refactory.Browser.PundleNavigatorPart} 					#minorKey: #windowSpec 					#clientKey: #packages ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 0 0 0 1 0 1 ) 					#name: #classes 					#flags: 0 					#majorKey: #{Refactory.Browser.ClassNavigatorPart} 					#minorKey: #windowSpec 					#clientKey: #classes ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0 2 0.5 0 1 ) 					#name: #ResizingSplitter1 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'packages' 					#belowWidgets: 'classes' ) ) ) )</body><body package="Browser-BaseUI">packageWithPartialClassHierarchyWindowSpec	"UIPainter new openOnClass: self andSelector: #packageWithPartialClassHierarchyWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 800 600 1000 800 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.5 0 1 ) 					#name: #packages 					#flags: 0 					#majorKey: #{Refactory.Browser.PundleNavigatorPart} 					#minorKey: #windowSpec 					#clientKey: #packages ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 0 0 0 1 0 1 ) 					#name: #classes 					#flags: 0 					#majorKey: #{Refactory.Browser.PartialHierarchyClassNavigatorPart} 					#minorKey: #windowSpec 					#clientKey: #partialClassHierarchy ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0 2 0.5 0 1 ) 					#name: #ResizingSplitter1 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'packages' 					#belowWidgets: 'classes' ) ) ) )</body></methods><methods><class-id>Refactory.Browser.CodeComponentTabNavigatorPart class</class-id> <category>tab descriptions</category><body package="Browser-BaseUI">classHierarchyPackageTab	&lt;tabDescription: 2&gt;	^TabPartDescription new		name: #Class &lt;&lt; #labels &gt;&gt; 'Class';		buildSelector: #buildClassHierarchyPackageSubcanvas;		matchSelector: #hasOnlyClasses:;		enabledSelector: #hasNoNamespaces:</body><body package="Browser-BaseUI">namespaceHierarchyPackageTab	&lt;tabDescription: 3&gt;	^TabPartDescription new		name: #Namespace &lt;&lt; #labels &gt;&gt; 'Namespace';		buildSelector: #buildNamespaceHierarchyPackageSubcanvas;		matchSelector: #hasOnlyNamespaces:;		enabledSelector: #hasNoClasses:</body><body package="Browser-BaseUI">packageTab	&lt;tabDescription: 1&gt;	^(TabPartDescription new)		name: #Package &lt;&lt; #labels &gt;&gt; 'Package';		buildSelector: #buildPackageSubcanvas;		matchSelector: #alwaysEnabled:;		enabledSelector: #alwaysEnabled:</body></methods><methods><class-id>Refactory.Browser.ClassAndMethodTabNavigatorPart class</class-id> <category>interface specs</category><body package="Browser-BaseUI">classesSpec	"UIPainter new openOnClass: self andSelector: #classesSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #browser) 			#bounds: #(#{Graphics.Rectangle} 800 600 1000 800 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #classes 					#flags: 0 					#majorKey: #{Refactory.Browser.ClassAndObjectNavigatorPart} 					#minorKey: #windowSpec 					#clientKey: #classes ) ) ) )</body><body package="Browser-BaseUI">methodsSpec	"UIPainter new openOnClass: self andSelector: #methodsSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #browser) 			#bounds: #(#{Graphics.Rectangle} 800 600 1000 800 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #methods 					#flags: 0 					#majorKey: #{Refactory.Browser.MethodNavigatorPart} 					#minorKey: #windowSpec 					#clientKey: #methods ) ) ) )</body><body package="Browser-BaseUI">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #browser) 			#bounds: #(#{Graphics.Rectangle} 887 750 1087 950 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.5 0 1 ) 					#name: #subcanvas 					#model: #tabDescriptionList 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedTab 						#requestValueChangeSelector: #changeRequest ) 					#labels: #() ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 0 0 0 1 0 1 ) 					#name: #selectors 					#flags: 0 					#majorKey: #{Refactory.Browser.NameSpaceItemTabNavigatorPart} 					#minorKey: #windowSpec 					#clientKey: #selectors ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0 2 0.5 0 1 ) 					#name: #splitter 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'subcanvas' 					#belowWidgets: 'selectors' ) ) ) )</body></methods><methods><class-id>Refactory.Browser.ClassAndMethodTabNavigatorPart class</class-id> <category>tab descriptions</category><body package="Browser-BaseUI">classesTab	&lt;tabDescription: 2&gt;	^(TabPartDescription new)		name: #Class &lt;&lt; #browser &gt;&gt; 'Class';		buildSelector: #buildClassesSubcanvas;		matchSelector: #alwaysEnabled:;		enabledSelector: #alwaysEnabled:</body><body package="Browser-BaseUI">methodsTab	&lt;tabDescription: 1&gt;	^(TabPartDescription new)		name: #Method &lt;&lt; #browser &gt;&gt; 'Method';		buildSelector: #buildMethodsSubcanvas;		matchSelector: #alwaysEnabled:;		enabledSelector: #alwaysEnabled:</body></methods><methods><class-id>Refactory.Browser.NameSpaceItemTabNavigatorPart class</class-id> <category>interface specs</category><body package="Browser-BaseUI">instanceVariableWindowSpec	"UIPainter new openOnClass: self andSelector: #instanceVariableWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 512 384 712 584 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.5 0 1 ) 					#name: #instanceVariables 					#flags: 0 					#majorKey: #{Refactory.Browser.InstanceVariableNavigatorPart} 					#minorKey: #windowSpec 					#clientKey: #instanceVariables ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 0 0 0 1 0 1 ) 					#name: #instanceVariableSelectors 					#flags: 0 					#majorKey: #{Refactory.Browser.SelectorNavigatorPart} 					#minorKey: #windowSpec 					#clientKey: #instanceVariableSelectors ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0 2 0.5 0 1 ) 					#name: #ResizingSplitter1 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'instanceVariables' 					#belowWidgets: 'instanceVariableSelectors' ) ) ) )</body><body package="Browser-BaseUI">selectorWindowSpec	"UIPainter new openOnClass: self andSelector: #selectorWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 980 720 1180 920 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.5 0 1 ) 					#name: #protocols 					#flags: 0 					#majorKey: #{Refactory.Browser.SelectorProtocolNavigatorPart} 					#minorKey: #windowSpec 					#clientKey: #protocols ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 0 0 0 1 0 1 ) 					#name: #selectors 					#flags: 0 					#majorKey: #{Refactory.Browser.SelectorNavigatorPart} 					#minorKey: #windowSpec 					#clientKey: #selectors ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0 2 0.5 0 1 ) 					#name: #ResizingSplitter1 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'protocols' 					#belowWidgets: 'selectors' ) ) ) )</body><body package="Browser-BaseUI">selectorWithProtocolWindowSpec	"UIPainter new openOnClass: self andSelector: #selectorWithProtocolWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 800 600 1000 800 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #selectorsWithProtocol 					#flags: 0 					#majorKey: #{Refactory.Browser.SelectorNavigatorPart} 					#minorKey: #protocolWindowSpec 					#clientKey: #selectorsWithProtocol ) ) ) )</body><body package="Browser-BaseUI">sharedVariableWindowSpec	"UIPainter new openOnClass: self andSelector: #sharedVariableWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 800 600 1000 800 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -2 0.5 0 1 ) 					#name: #categories 					#flags: 0 					#majorKey: #{Refactory.Browser.SharedVariableProtocolNavigatorPart} 					#minorKey: #windowSpec 					#clientKey: #categories ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 0 0 0 1 0 1 ) 					#name: #sharedVariables 					#flags: 0 					#majorKey: #{Refactory.Browser.SharedVariableNavigatorPart} 					#minorKey: #windowSpec 					#clientKey: #sharedVariables ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.5 0 0 2 0.5 0 1 ) 					#name: #ResizingSplitter1 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'categories' 					#belowWidgets: 'sharedVariables' ) ) ) )</body><body package="Browser-BaseUI">sharedVariableWithProtocolWindowSpec	"UIPainter new openOnClass: self andSelector: #sharedVariableWithProtocolWindowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 800 600 1000 800 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #sharedVariablesWithProtocol 					#flags: 0 					#majorKey: #{Refactory.Browser.SharedVariableNavigatorPart} 					#minorKey: #protocolWindowSpec 					#clientKey: #sharedVariablesWithProtocol ) ) ) )</body></methods><methods><class-id>Refactory.Browser.NameSpaceItemTabNavigatorPart class</class-id> <category>tab descriptions</category><body package="Browser-BaseUI">classTab	&lt;tabDescription: 4&gt;	^(TabPartDescription new)		name: #Class &lt;&lt; #labels &gt;&gt; 'Class';		buildSelector: #buildClassSubcanvas;		matchSelector: #isClassMethod:;		enabledSelector: #isClassAndNotSystem:</body><body package="Browser-BaseUI">instanceTab	&lt;tabDescription: 3&gt;	^(TabPartDescription new)		name: #Instance &lt;&lt; #labels &gt;&gt; 'Instance';		buildSelector: #buildInstanceSubcanvas;		matchSelector: #isInstanceMethod:;		enabledSelector: #isClassAndNotSystem:</body><body package="Browser-BaseUI">instanceVariableTab	&lt;tabDescription: 7&gt;	^(TabPartDescription new)		name: #InstanceVariable &lt;&lt; #labels &gt;&gt; 'Instance Variable';		buildSelector: #buildInstanceVariableSubcanvas;		matchSelector: #isInstanceVariable:;		enabledSelector: #isClassAndSystem:</body><body package="Browser-BaseUI">sharedVariableTab	&lt;tabDescription: 6&gt;	^(TabPartDescription new)		name: #SharedVariable &lt;&lt; #labels &gt;&gt; 'Shared Variable';		buildSelector: #buildSharedVariableSubcanvas;		matchSelector: #isSharedVariable:;		enabledSelector: #isNotSystem:</body><body package="Browser-BaseUI">systemClassTab	&lt;tabDescription: 2&gt;	^(TabPartDescription new)		name: #Class &lt;&lt; #labels &gt;&gt; 'Class';		buildSelector: #buildSystemClassSubcanvas;		matchSelector: #isClassMethod:;		enabledSelector: #isClassAndSystem:</body><body package="Browser-BaseUI">systemInstanceTab	&lt;tabDescription: 1&gt;	^(TabPartDescription new)		name: #Instance &lt;&lt; #labels &gt;&gt; 'Instance';		buildSelector: #buildSystemInstanceSubcanvas;		matchSelector: #isInstanceMethod:;		enabledSelector: #isClassAndSystem:</body><body package="Browser-BaseUI">systemSharedVariableTab	&lt;tabDescription: 5&gt;	^(TabPartDescription new)		name: #SharedVariable &lt;&lt; #labels &gt;&gt; 'Shared Variable';		buildSelector: #buildSystemSharedVariableSubcanvas;		matchSelector: #isSharedVariable:;		enabledSelector: #isSystem:</body></methods><methods><class-id>Refactory.Browser.BrowserDialog class</class-id> <category>resources</category><body package="Browser-BaseUI">disabledDownIcon	"UIMaskEditor new openOnClass: self andSelector: #disabledDownIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 2) at: 1 put: Graphics.ColorValue white; at: 2 put: (Graphics.ColorValue scaledRed: 4227 scaledGreen: 4227 scaledBlue: 4227); yourself)) usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 254 0 0 63 252 0 0 31 248 0 0 15 240 0 0 7 224 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Browser-BaseUI">disabledDownIconMask	"UIMaskEditor new openOnClass: self andSelector: #disabledDownIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 254 0 0 63 252 0 0 31 248 0 0 15 240 0 0 7 224 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Browser-BaseUI">disabledUpIcon	"UIMaskEditor new openOnClass: self andSelector: #disabledUpIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: (Graphics.MappedPalette withColors: ((Core.Array new: 2) at: 1 put: Graphics.ColorValue white; at: 2 put: (Graphics.ColorValue scaledRed: 4227 scaledGreen: 4227 scaledBlue: 4227); yourself)) usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 7 224 0 0 15 240 0 0 31 248 0 0 63 252 0 0 127 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Browser-BaseUI">disabledUpIconMask	"UIMaskEditor new openOnClass: self andSelector: #disabledUpIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 7 224 0 0 15 240 0 0 31 248 0 0 63 252 0 0 127 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Browser-BaseUI">downIcon	"UIMaskEditor new openOnClass: self andSelector: #downIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 128 1 0 0 192 3 0 0 224 7 0 0 240 15 0 0 248 31 0 0 252 63 0 0 254 127 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0])</body><body package="Browser-BaseUI">downIconMask	"UIMaskEditor new openOnClass: self andSelector: #downIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 254 0 0 63 252 0 0 31 248 0 0 15 240 0 0 7 224 0 0 3 192 0 0 1 128 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body><body package="Browser-BaseUI">upIcon	"UIMaskEditor new openOnClass: self andSelector: #upIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: MonoMappedPalette blackWhite usingBits: #[255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 254 127 0 0 252 63 0 0 248 31 0 0 240 15 0 0 224 7 0 0 192 3 0 0 128 1 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0])</body><body package="Browser-BaseUI">upIconMask	"UIMaskEditor new openOnClass: self andSelector: #upIconMask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 128 0 0 3 192 0 0 7 224 0 0 15 240 0 0 31 248 0 0 63 252 0 0 127 254 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body></methods><methods><class-id>Tools.ListIconLibrary class</class-id> <category>resources</category><body package="Browser-BaseUI">modifiedBundle16x16	"UIMaskEditor new openOnClass: self andSelector: #modifiedBundle16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 7 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7549 7613 6681)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6713 6746 5942)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6232 6296 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7709 7741 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7870 7870 5782)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5975 6071 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5878 6007 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6489 6521 5750)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7356 7452 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6424 6456 5718)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5814 5910 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7292 7356 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5718 5846 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7035 7131 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6938 6970 6167)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8095 8127 5975)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7259 7227 5268)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7227 7259 5268)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7870 7870 5814)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6167 6232 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6071 6167 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6553 6585 5814)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7998 7998 7035)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7292 7388 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7131 7163 6296)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5653 5782 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7806 7838 6906)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7420 7420 5429)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7035 7163 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6970 6970 6167)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8127 8095 6007)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7998 7998 5910)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7099 7067 5139)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6617 6649 5878)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7934 7966 7003)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6810 6778 4915)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7870 7902 6970)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7645 7677 6778)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8030 7998 5910)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6874 7035 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6906 7003 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6713 6874 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7741 7806 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6553 6713 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7099 7099 5139)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7709 7741 5686)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6360 6585 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6392 6553 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7420 7484 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6810 6810 4915)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7163 7259 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 6071)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7709 7741 6842)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7035 7067 6232)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6906 7035 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6874 6874 6103)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6746 6874 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6296 6360 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6392 6585 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6938 6938 5011)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6489 6489 5750)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5782 5910 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6232 6424 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7549 7581 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5718 5814 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7195 7259 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7163 7292 8191)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@5MST5MST5MP@WE1\#IQL@MST5MST5MST@E3P_I0T7@CT5MST5MST5@A\PHA$@G @5MP@@@@@@@@@#HA$@MP@@MST@J2,+C@@@IQL7@CT5MST5@B,IFC,@@A,.C0@5MST@MP@+FDPC@@@6PS$@MP@@J0@@ADPNE@@@I!0QKP@$@B,+ACL]JAT@@@DRHS42B@@IFDL]JR(F@@@Q@"HVO (@C@@@NC(,A0@@@@@@@@@@@@@5@CD,OC&lt;@MST5MST5MST5MP@XK4@M@CT5MST5MST5MST@L@-BF @5MST5MST5MST5@@@@@@@@MST5MST5MST5MST5MST5MP@a'))</body><body package="Browser-BaseUI">modifiedBundle16x16mask	"UIMaskEditor new openOnClass: self andSelector: #modifiedBundle16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 0 0 0 255 0 0 0 255 0 0 0 255 63 0 0 251 63 0 0 248 63 0 0 248 191 0 0 251 255 0 0 255 255 0 0 255 255 0 0 255 255 0 0 255 191 0 0 0 63 0 0 0 63 0 0 0 63 0 0 0 0 0 0])</body><body package="Browser-BaseUI">modifiedPackage16x16	"UIMaskEditor new openOnClass: self andSelector: #modifiedPackage16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 6 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6360 6328 4529)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6328 6360 4529)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6135 6135 4401)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6521 6489 4690)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6489 6521 4690)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6521 6521 4658)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5139 5139 3630)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4947 4979 3501)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5942 5942 4240)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5782 5750 4112)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8095 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7388 7420 5429)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5750 5782 4112)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5782 5782 4079)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 6071)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6135 6103 4369)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6489 6489 4658)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6778 6810 4915)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5300 5300 5300)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7998 7998 5910)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5942 5910 4208)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5910 5942 4208)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8159 4850)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8159 6199)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5782 5782 4112)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4786 4786 3341)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8159 7388)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5525 5525 3919)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6328 6328 4529)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8127 4818)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4979 4947 3469)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6135 6135 4369)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5750 5750 4112)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6521 6489 4658)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6489 6489 4690)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5942 5942 4208)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5910 5942 4240)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5364 5364 3790)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7099 7099 5139)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 6199)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4786 4786 3373)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4786 4818 3341)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 7388)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5557 5525 3919)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5172 5172 3630)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6328 6328 4561)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8159 4818)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7741 7741 5686)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3501 3501 3501)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4979 4979 3469)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: 'A@PDA@PDA@PDA@PDA@PDA@PDA@PDA@@DA@PDA@PDA@PDA@PDA@@L@@P@A@PDA@PDA@PDA@@LC@0@A@@DA@PDA@PDA@@LC@0@KA0,@@@@A@PDA@@LC@0@JQ$YJQ$2D@@DA@PD@@0@FA&lt;0G3@2DA4@A@PD@@PTEAPTEAPTDA4''@@PDA@@PA@PDA@PDAB4''B@@DA@P@ERL$D"PEA \''K#L@A@PD@CD^K18AG!8BK"@*@@PDA@@MHRD!HPL!DP$[@@PDA@P@JBTJE"T&amp;E2X+@@PDA@PD@ALKF"HKC &lt;Z@@PDA@PDA@P@@@@@@@@@@@PDA@PDA@PDA@PDA@PDA@PDA@PDA@@a'))</body><body package="Browser-BaseUI">modifiedPackage16x16mask	"UIMaskEditor new openOnClass: self andSelector: #modifiedPackage16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 2 0 0 0 7 64 0 0 15 224 0 0 31 252 0 0 63 254 0 0 31 254 0 0 63 254 0 0 63 254 0 0 63 254 0 0 63 254 0 0 63 252 0 0 63 248 0 0 63 240 0 0 31 224 0 0 0 0 0 0])</body><body package="Browser-BaseUI">warningOverlay16x16	"UIMaskEditor new openOnClass: self andSelector: #warningOverlay16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 5 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1542 1542 1542)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 899)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 3565)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(385 385 385)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6264 3758 2345)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 1574)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2249 2249 2249)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4112 4112 4112)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 1542)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 2249)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(932 932 932)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2955 2955 2955)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 4497 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 2955)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6264 3341 1670)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3598 3598 3565)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 4112)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1542 1542 1574)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3565 3598 3565)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 932)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@0LC@0LC@0LC@0LCCPLC@0LC@0LC@0LC@0LCBADH@0LC@0LC@0LC@0LC@1@BD0LC@0LC@0LC@0LC@00NC 8L@0LC@0LC@0LC@0LGB TJA0LC@0LC@0LC@0LRBPXOBP$R@0LC@0LC@0LCB0DTEAPTB0LC@0LC@0LC@0LDA@PDA@LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0LC@0@a'))</body><body package="Browser-BaseUI">warningOverlay16x16mask	"UIMaskEditor new openOnClass: self andSelector: #warningOverlay16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 28 0 0 0 62 0 0 0 62 0 0 0 127 0 0 0 127 0 0 0 255 0 0 0 255 0 0 0 127 0 0 0 62 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0])</body></methods><methods><class-id>Tools.MethodDefinition class</class-id> <category>tags</category><body package="Browser-BaseUI">iconMethodTags	&lt;pragmas: #instance&gt;	^#(#icon:)</body></methods><methods><class-id>Tools.MethodDefinition</class-id> <category>icons</category><body package="Browser-BaseUI">deprecatedMethodIcon	&lt;icon: 5&gt;	^self method		ifNotNil: 			[:method |			(method sendsSelector: #deprecated:)				ifTrue: [GeneralIcons deprecationWarning]				ifFalse: [nil]]</body><body package="Browser-BaseUI">externalMethodIcon		&lt;icon: 20&gt;	^self method		ifNotNil:			[:method | (method isKindOf: ExternalMethod) ifTrue: [BehaviorIcons ExternalInterface]]</body><body package="Browser-BaseUI">resourceIcon		&lt;icon: 10&gt;	^self method		ifNotNil:			[:method | 			method resourceType				ifNotNil:					[:resourceType | 					(GeneralIcons respondsTo: resourceType)						ifTrue: [GeneralIcons perform: resourceType]						ifFalse: [nil]]]</body><body package="Browser-BaseUI">taggedMenuMethodIcon	&lt;icon: 15&gt;	^self method		ifNotNil: 			[:method |			(method isAnnotated and: 					[method attributeMessages						anySatisfy: [:each | #(#event: #event:filter:) includes: each selector]])				ifTrue: [GeneralIcons eventReaction]]</body><body package="Browser-BaseUI">taggedMethodIcon	&lt;icon: 60&gt;	^self method		ifNotNil: 			[:method |			(method isAnnotated and: 					[method attributeMessages						anySatisfy: [:each | (each selector first: 2) ~= '__']])				ifTrue: [GeneralIcons taggedMethod]]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Magnitude</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>GeneralMethodDefinition</name><environment>Tools</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>TreeModel</name><environment>UI</environment><super>Core.List</super><private>false</private><indexed-type>none</indexed-type><inst-vars>root childrenBlock hasChildrenBlock mayHaveNilValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Collections</category><attributes><package>UIBasics-Collections</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>GraphicsContext</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>medium clipOriginX clipOriginY clipWidth clipHeight lineWidth capStyle joinStyle deviceFont devicePaint offsetX offsetY phaseX phaseY scaleX scaleY font paint paintPolicy fontPolicy clientData paintPreferences </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>GeneralBindingReference</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>path cache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>CodeComponent</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Components</category><attributes><package>System-Code Components</package></attributes></class><class><name>MethodDefinition</name><environment>Tools</environment><super>Tools.GeneralMethodDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inheritingClass implementingClass selector extraText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>BundleModel</name><environment>Store</environment><super>Store.PundleModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PackageCategories</category><attributes><package>PackageCategories</package></attributes></class><class><name>NameSpace</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>WidgetPolicy</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>defaultWidgetColors </class-inst-vars><imports></imports><category>UIBuilder-Support</category><attributes><package>UIBuilder-Support</package></attributes></class><class><name>BrowserEnvironmentWrapper</name><environment>Refactory.Browser</environment><super>Refactory.Browser.BrowserEnvironment</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Environments</category><attributes><package>Browser-Environments</package></attributes></class><class><name>InitializerDefinition</name><environment>Tools</environment><super>Tools.GeneralMethodDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nameSpace key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Programming</category><attributes><package>Tools-Programming</package></attributes></class><class><name>CompiledCode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>bytes </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class></st-source>