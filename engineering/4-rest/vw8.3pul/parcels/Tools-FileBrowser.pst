<?xml version="1.0"?><st-source><!-- Name: Tools-File BrowserNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: The File Browser supersedes the File List of earlier versions of VisualWorks. To start it, select the File -> File Browser in the Visual Launcher menus, click its button on the toolbar, or press F2 while the Launcher window is active.By default, the File Browser selects the current working directory when it opens. This usually takes only a few seconds. However, some users report longer opening times (the time depends on the platform and on the directory tree structure). If a long opening time is a problem, you can use the Directory -> Initial Selection menu to change this preference. The old File List tool is no longer available in the Launcher, but is still present in the image in this release of VisualWorks. If you wish to use it, you can open it by evaluating the following expression:	Tools.FileBrowser openDbIdentifier: bear73DbTrace: 502763DbUsername: smichaelDbVersion: 8.3 - 2DevelopmentPrerequisites: #(#(#any 'Tools-Workspace' ''))PackageName: Tools-File BrowserParcel: #('Tools-File Browser')ParcelName: Tools-File BrowserPrerequisiteParcels: #(#('Tools-Workspace' ''))PrintStringCache: (8.3 - 2,smichael)Version: 8.3 - 2Date: 3:26:57 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.4) of June 23, 2017 on June 30, 2017 at 3:26:57 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>FileTools</name><environment>Tools</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></name-space><comment><name-space-id>Tools.FileTools</name-space-id><body>This name space contains the new, as of VW 7, tools for working with files, mostly the new file browser.</body></comment><class><name>XMLSourceWalkerState</name><environment>Tools.FileTools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>walker tag </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.XMLSourceWalkerState</class-id><body>I represent a state of the source walker.  I look at the open and close tags of elements passed by the walker as arguments of messages #start: and #end:, as well as at character data.  My subclasses define these methods to do meaningful processing, such as collecting character data, grouping elements together, and eventually notifying the walker of the end of meaningful elements in the input.Subclasses must implement the following messages:	dispatching		end:		start:Instance Variables:	tag	&lt;String&gt;	The tag I am processing.	walker	&lt;XMLSourceWalker&gt;	The walker I am working with.</body></comment><class><name>XMLSourceWalkerCollectorState</name><environment>Tools.FileTools</environment><super>Tools.FileTools.XMLSourceWalkerState</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elements acceptSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.XMLSourceWalkerCollectorState</class-id><body>I am a state used to process elements that contain other elements, tags and character content of which we are interested in.  For example, a class definition element contains elements for things like the class name, superclass name, environment.  A class definition element is processed by a collector state, which uses AccumulatorStates to process it sub-elements.Instance Variables:	acceptSelector	&lt;Symbol&gt;	The selector of the message sent to the walker when the element processed by this state ends.	elements	&lt;OrderedCollection of: XMLSourceWalkerAccumulatorState&gt; States that processed the elements contained inside this element. </body></comment><class><name>FileViewer</name><environment>Tools.FileTools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>browser </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.FileViewer</class-id><body>FileViewer is the abstract superclass of viewers: applications that display details of the currently selected file.  All of them remember the browser they service, so that they can get information of the current selections, most often the channel that holds the current file selection.Whenever the current file selection changes, the viewer checks the current selection and then sends one of the two messages subclasses must implement: #updateForNoSelection or #updateFor: aFilename.Subclasses must implement the following messages:	notifications		updateFor:		updateForNoSelectionInstance Variables:	browser	&lt;FileBrowser&gt;	The browser we are serving.</body></comment><class><name>FileContentsViewer</name><environment>Tools.FileTools</environment><super>Tools.FileTools.FileViewer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>previewTextHolder fullTextHolder lastSubBuilder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.FileContentsViewer</class-id><body>This viewer displays the file as text. However, unlike the blurb viewer, the amount of text displayed can be quite large, and the viewer protects against possible problems by showing large files in preview mode first.  This viewer handles all issues related to managing the two modes; concrete subclasses should only implement methods #textForEntireFile: and #textForFileBeginning:.Subclasses must implement the following messages:	private		textForEntireFile:		textForFileBeginning:Instance Variables:	fullTextHolder	&lt;ValueModel&gt;	A model that supplies (and potentially accepts) the full file text for the TextEditor that displays it.	lastSubBuilder	&lt;UIBuilder | nil&gt;	The UIBuilder last used to build the interface; used to give keyboard focus to a correct text widget in the subbuilder.	previewTextHolder	&lt;ValueModel&gt;	A model that supplies the preview text of the file.</body></comment><class><name>FileTextViewer</name><environment>Tools.FileTools</environment><super>Tools.FileTools.FileContentsViewer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalFileTimestamp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.FileTextViewer</class-id><body>This viewer displays the file as readable (or unreadable, as the case may be) text.  When the viewer is in the full mode, it works as a file editor: modifying and accepting the text writes it out into the file.  In the preview mode, the text displayed is read-only.Instance variables:	originalFileTimestamp	&lt;Timestamp&gt; Whenever a file is read in to be displayed, its modification timestamp is saved here. When a file is saved, we verify that its timestamp is still the same. If it isn't, the user should be warned.</body></comment><class><name>XMLSourceViewer</name><environment>Tools.FileTools</environment><super>Tools.FileTools.FileViewer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>textHolder </inst-vars><class-inst-vars></class-inst-vars><imports>			private XML.*			</imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.XMLSourceViewer</class-id><body>This viewer presents Smalltalk fileouts in XML form as readable formatted text. This instance collaborates with SourceFormatter and XMLSourceWalker to produce the formatted printout.Instance Variables:	textHolder	&lt;ValueHolder&gt;	The aspect of the text view displaying the text.</body></comment><class><name>FileBlurbViewer</name><environment>Tools.FileTools</environment><super>Tools.FileTools.FileViewer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>textHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.FileBlurbViewer</class-id><body>I am an abstract superclass of simple viewers that display some formatted text to present a file. Subclasses should implement the message printBlurbFor:on: to print the text for a given file on the given text stream. Subclasses must implement the following messages:	accessing		printBlurbFor:on:Instance Variables:	textHolder	&lt;ValueModel&gt;	The aspect of the text view that displays the blurb.</body></comment><class><name>ParcelFileViewer</name><environment>Tools.FileTools</environment><super>Tools.FileTools.FileBlurbViewer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.ParcelFileViewer</class-id><body>This viewer displays the basic parcel file information: comment, various properties, as well as whether this parcel is loaded or not.</body></comment><class><name>XMLTreeViewer</name><environment>Tools.FileTools</environment><super>Tools.FileTools.FileViewer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nodeTreeHolder textHolder </inst-vars><class-inst-vars></class-inst-vars><imports>			private XML.*			</imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.XMLTreeViewer</class-id><body>This viewer is an XML tree browser: it displays the tree of XML nodes of a file, with a text view to the right showing the currently selected node.Instance Variables:	nodeTreeHolder	&lt;SelectionInList&gt;	The aspect of the XML tree view.	textHolder	&lt;ValueModel&gt;	The aspect of the current node text view.</body></comment><class><name>AbstractFileItem</name><environment>Tools.FileTools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.AbstractFileItem</class-id><body>Instances of AbstractFileItem are used in the file browser views to represent various file entities, most notably files and directories.Instance Variables:	filename &lt;Filename&gt; The platform-specific filename of the file system entity this item represents. </body></comment><class><name>DirectoryItem</name><environment>Tools.FileTools</environment><super>Tools.FileTools.AbstractFileItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cachedSubdirectoryItems </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.DirectoryItem</class-id><body>I represent a directory on the disk.  I can report the files I contain, as well as my subdirectories.</body></comment><class><name>FileBrowser</name><environment>Tools.FileTools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>directoryTreeHolder patternChoices fileListHolder patternHolder fileSelectionChannel currentViewer statusTextRightHolder statusTextLeftHolder viewerListHolder menuBarHolder encodingChannel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.FileBrowser</class-id><body>I am the core of the file browser implementation.  I show the currently known directories as several trees in a tree view.  Files of the selected directory that match the current pattern are displayed in a file list.  A zoomable tabbed notebook of viewers shows all viewers that think they are able to display the currently selected file.  When a tab is selected, an instance of a viewer class is created to service the client area of the notebook.  The instance sends #fileSelectionChannel message to the browser to obtain a ValueHolder with the filename of the currently selected file.Instance Variables:	currentViewer	&lt;FileViewer&gt;	An instance of a concrete subclass of FileViewer that is the current application serving the client area of the viewer notebook.	directoryTreeHolder	&lt;SelectionInList&gt;	The aspect of the directory tree TreeView.	fileListHolder	&lt;SelectionInList&gt;	The aspect of the file list ListView.	fileSelectionChannel	&lt;ValueHolder on: Filename&gt;	The browser always puts the filename of the currently selected file into this ValueHolder. The current file viewer monitors this to update itself when selection changes.	menuBarHolder	&lt;ValueHolder on: Menu&gt;	This ValueHolder contains the menu currently used for the window menu bar.	patternChoices	&lt;ValueHolder on: List&gt;	A holder with the list of pattern choices visible when the pattern drop-down box is pulled down.	patternHolder	&lt;ValueHolder on: String&gt;	A holder with the currently selected pattern.	statusTextLeftHolder	&lt;ValueHolder on: Text&gt;	A holder on the text appearing in the left-hand portion of the status bar.	statusTextRightHolder	&lt;ValueHolder on: Text&gt;	A holder on the text appearing in the right-hand portion of the status bar.	viewerListHolder	&lt;SelectionInList&gt;	The aspect of the viewer tab control, holds the list of viewer classes available for the currently selected file, and the currently selected class.	encodingChannel	&lt;ValueHolder on: Symbol&gt; The encoding menu stores its selection here. Interested viewers may register for updates.</body></comment><class><name>FileHexViewer</name><environment>Tools.FileTools</environment><super>Tools.FileTools.FileContentsViewer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.FileHexViewer</class-id><body>This viewer displays the file in the traditional hex (a.k.a. hacker) form. It is always read-only.  UI specs are redefined to make the text view use fixed pitch font.</body></comment><class><name>DirectorySelectionDialog</name><environment>Tools.FileTools</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>directoryTreeHolder initialDirectory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Settings-UI</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.DirectorySelectionDialog</class-id><body>DirectorySelectionDialog is a dialog for selecting a directory in a tree. For now this is a simple implementation to quickly achieve that purpose. In future this class will be moved to the application with other reusable dialogs, but for now it is considered private to this application and subject to change without notice.Instance Variables:	directoryTreeHolder	&lt;SelectionInList&gt;	The tree of DirectoryItems representing directories.	initialDirectory	&lt;Filename&gt;	The directory to pre-select when the dialog opens.</body></comment><class><name>XMLSourceWalkerAccumulatorState</name><environment>Tools.FileTools</environment><super>Tools.FileTools.XMLSourceWalkerState</super><private>false</private><indexed-type>none</indexed-type><inst-vars>characters nestLevel acceptSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.XMLSourceWalkerAccumulatorState</class-id><body>I am an state that accumulates any and all character data it contains, including the data of elements contained by the current one. Any embedded elements are therefore silently ignored (but not their character contents).  This is handy for reading method bodies, which may contain text emphasis tags. When the current element ends, I can invoke an arbitrary action of my walker.  The action is initialized by the walker when it creates me.Instance Variables:	characters	&lt;Stream&gt;	The stream accumulating the character data.	acceptSelector	&lt;Symbol&gt;	A selector of a one-argument message. The message is sent to the walker with self as the argument when a close tag is encountered for the element whose data I am collecting.	nestLevel	&lt;Integer&gt;	When accumulating data of contained elements, I use this variable to count nested elements with the same tag as myself, so that only my own close tag counts as the end of the element.</body></comment><class><name>XMLSourceWalkerTopState</name><environment>Tools.FileTools</environment><super>Tools.FileTools.XMLSourceWalkerState</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.XMLSourceWalkerTopState</class-id><body>I represent the state the walker enters when it sees 'st-source' tag in the initial state: the top level of a Smalltalk fileout document.</body></comment><class><name>TopLevelItem</name><environment>Tools.FileTools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>roots </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.TopLevelItem</class-id><body>VolumesNode is created for the purpose of serving as the root of the tree hierarchy. So its children are hardcoded to be the volumes available. The root is not displayed in the tree view, so its presentation is irrelevant. It would become relevant if it was decided to show it as an artificial node, Ã  la "My Computer" in Windows.</body></comment><class><name>XMLSourceWalker</name><environment>Tools.FileTools</environment><super>XML.SAXDriver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>client currentTag states </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.XMLSourceWalker</class-id><body>I am a kind of SAX driver that performs semantic analysis on an XML tree, expected to be an XML Smalltalk fileout.  When fileout elements such as class, namespace and method definitions are recognized, the 'client' object is notified by sending it messages.As of VW 7, the only client is SourceFormatter, which produces a nicely formatted printout of the text.  Future application could be building out-of-the-image code objects, to allow browsers work on fileouts.While analyzing the input, the walker works as a more or less state machine, with the current state representing the element currently being parsed. The state takes care of figuring out what to do about elements and character data coming in from the parser.Instance Variables:	client	&lt;Object&gt;	The object notified when parts of XML Smalltalk fileout are recognized	currentTag	&lt;String&gt;	The last XML tag encountered by the SAX driver.	states	&lt;OrderedCollection or: XMLSourceWalkerState&gt;	The stack of walk states; the topmost (last) state is the state that is currently processing input.</body></comment><class><name>XMLSourceWalkerNotification</name><environment>Tools.FileTools</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.XMLSourceWalkerNotification</class-id><body>I am a notification raised by a state when it encounters a state it does not expect to see.  The unexpected state is ignored if this notification goes unclaimed.Instance Variables:	state	&lt;XMLSourceWalkerState&gt;	The state the encountered an unexpected element.</body></comment><class><name>XMLSourceWalkerDefinitionState</name><environment>Tools.FileTools</environment><super>Tools.FileTools.XMLSourceWalkerCollectorState</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.XMLSourceWalkerDefinitionState</class-id><body>I am a special kind of the Collector state.  I recognize that one of my sub-elements, with the tag 'attributes', has to be processed with a Collector state, rather than with Accumulator states as all other sub-elements.  I am used to process the three definition kinds found in file-outs: class, namespace, and shared variable.</body></comment><class><name>SourceFormatter</name><environment>Tools.FileTools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>output currentEmphasis </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.SourceFormatter</class-id><body>I produce a formatted representation of the XML fileout. The output is supposed to be readable rather than executable, and therefore resembles code listings in the Blue Book more than it does the equivalent chunk fileouts.Instance Variables:	output	&lt;TextStream&gt;	description of output	streamStack	&lt;OrderedCollection&gt;	description of streamStack	tagStack	&lt;OrderedCollection&gt;	description of tagStack</body></comment><class><name>FileInformationViewer</name><environment>Tools.FileTools</environment><super>Tools.FileTools.FileBlurbViewer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.FileInformationViewer</class-id><body>This viewer displays the basic file information: size, creation and last modification dates, etc.</body></comment><class><name>XMLSourceWalkerInitialState</name><environment>Tools.FileTools</environment><super>Tools.FileTools.XMLSourceWalkerState</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.XMLSourceWalkerInitialState</class-id><body>I am the initial state of the source walker.  I expect that a 'st-source' element should appear.</body></comment><class><name>SpecialDirectoryItem</name><environment>Tools.FileTools</environment><super>Tools.FileTools.DirectoryItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name avoidHasChildrenQuery </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.SpecialDirectoryItem</class-id><body>I represent a drive of those filesystems that have this concept, or a remote directory, i.e. a directory that is not to be found among the children of any of the root volumes, as reported by Filename of this image.  One case when remote directories are used is under Windows, when the user requests to go to a directory on another machine, using "\\machine\volume" directory format.  The target directory is then shown as a top-level item in the folder tree, and is represented with an instance of this class. This is necessary to avoid building a tree of a network drive, which may be extremely expensive.Instance variables:	name	&lt;String | nil&gt; if not nil, this rather than the underlying filename's tail is used as the displayString of the item, and appears in various lists.	avoidHasChildrenQuery &lt;Boolean&gt; Items with this attribute set to true do not give a real answer to #hasChildren message and instead report true always. Such drives always show up in the directory tree as expandable. This is useful if the cost of query is too high.</body></comment><class><name>DirectoryContentsViewer</name><environment>Tools.FileTools</environment><super>Tools.FileTools.FileBlurbViewer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.DirectoryContentsViewer</class-id><body>Work in progress.</body></comment><class><name>FileItem</name><environment>Tools.FileTools</environment><super>Tools.FileTools.AbstractFileItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-File Browser</category><attributes><package>Tools-File Browser</package></attributes></class><comment><class-id>Tools.FileTools.FileItem</class-id><body>I represent a regular (i.e. not a directory) file.</body></comment><shared-variable><name>InitialSelectionPreference</name><environment>Tools.FileTools.FileBrowser</environment><private>false</private><constant>false</constant><category>preferences</category><initializer>#default</initializer><attributes><package>Tools-File Browser</package></attributes></shared-variable><methods><class-id>Tools.FileTools.XMLSourceWalkerState</class-id> <category>dispatching</category><body package="Tools-File Browser">characters: aString	"Any pcdata is silently ignored."</body><body package="Tools-File Browser">end: tagString	self subclassResponsibility</body><body package="Tools-File Browser">start: tagString	self subclassResponsibility</body><body package="Tools-File Browser">xmlComment: aString	walker acceptXMLComment: aString</body></methods><methods><class-id>Tools.FileTools.XMLSourceWalkerState</class-id> <category>initialize-release</category><body package="Tools-File Browser">initialize: aWalker	walker := aWalker.	tag := walker currentTag</body></methods><methods><class-id>Tools.FileTools.XMLSourceWalkerState</class-id> <category>accessing</category><body package="Tools-File Browser">tag	^tag</body></methods><methods><class-id>Tools.FileTools.XMLSourceWalkerState</class-id> <category>signalling</category><body package="Tools-File Browser">signalUnexpectedElement: tagString	XMLSourceWalkerNotification new		state: self;		messageText: (#UnexpectedElementColon &lt;&lt; #dialogs &gt;&gt; 'Unexpected element: ') asString, tagString;		raise</body></methods><methods><class-id>Tools.FileTools.XMLSourceWalkerState class</class-id> <category>instance creation</category><body package="Tools-File Browser">for: aFormatter	^self new initialize: aFormatter</body></methods><methods><class-id>Tools.FileTools.XMLSourceWalkerCollectorState</class-id> <category>initialize-release</category><body package="Tools-File Browser">acceptSelector: aSymbol	acceptSelector := aSymbol</body><body package="Tools-File Browser">initialize: aWalker	super initialize: aWalker.	elements := OrderedCollection new</body></methods><methods><class-id>Tools.FileTools.XMLSourceWalkerCollectorState</class-id> <category>accessing</category><body package="Tools-File Browser">contentsAt: aString	^(self elementWithTag: aString) contents</body><body package="Tools-File Browser">contentsAt: aString ifAbsent: aBlock	^(self elementWithTag: aString ifAbsent: [^aBlock value]) contents</body><body package="Tools-File Browser">contentsOrBlankAt: aString	^self contentsAt: aString ifAbsent: [String new]</body><body package="Tools-File Browser">elements	^elements</body><body package="Tools-File Browser">elementWithTag: aString	^elements detect: [:some | some tag = aString]</body><body package="Tools-File Browser">elementWithTag: aString ifAbsent: aBlock	^elements detect: [:some | some tag = aString] ifNone: aBlock</body></methods><methods><class-id>Tools.FileTools.XMLSourceWalkerCollectorState</class-id> <category>dispatching</category><body package="Tools-File Browser">end: tagString	tagString = tag ifTrue: 		[walker leaveState.		acceptSelector notNil ifTrue:			[walker perform: acceptSelector with: self]]</body><body package="Tools-File Browser">start: tagString	walker enterAccumulatorState.	elements add: walker currentState</body></methods><methods><class-id>Tools.FileTools.XMLSourceWalkerCollectorState class</class-id> <category>instance creation</category><body package="Tools-File Browser">for: aWalker acceptSelector: aSymbol	^(self for: aWalker) acceptSelector: aSymbol</body></methods><methods><class-id>Tools.FileTools.FileViewer</class-id> <category>initialize-release</category><body package="Tools-File Browser">browser: aFileBrowser	browser := aFileBrowser.	browser fileSelectionChannel onChangeSend: #update to: self</body><body package="Tools-File Browser">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self 		"adjustReadOnlyWidgetBackground: #text;" "still not sure we ought to do this"		update</body><body package="Tools-File Browser">release	super release.	browser fileSelectionChannel retractInterestsFor: self</body></methods><methods><class-id>Tools.FileTools.FileViewer</class-id> <category>notifications</category><body package="Tools-File Browser">update	| filename |	Cursor wait showWhile:		[filename := self selectedFilename.		filename isNil			ifTrue: [self updateForNoSelection]			ifFalse: [self updateFor: filename]]</body><body package="Tools-File Browser">updateFor: aFilename	"A file has been selected. Update whatever is needed to show it properly."	self subclassResponsibility</body><body package="Tools-File Browser">updateForNoSelection	"A file has been unselected, but I am still the current viewer.	Update whatever is needed to show nothing properly."	self subclassResponsibility</body></methods><methods><class-id>Tools.FileTools.FileViewer</class-id> <category>actions</category><body package="Tools-File Browser">debugIt	self withTextViewControllerDo: [:controller | controller debugIt]</body><body package="Tools-File Browser">doIt	self withTextViewControllerDo: [:controller | controller doIt]</body><body package="Tools-File Browser">inspectIt	self withTextViewControllerDo: [:controller | controller inspectIt]</body><body package="Tools-File Browser">takeKeyboardFocus	| wrapper |	wrapper := self builder componentAt: #text.	wrapper notNil ifTrue:		[wrapper takeKeyboardFocus]</body></methods><methods><class-id>Tools.FileTools.FileViewer</class-id> <category>private</category><body package="Tools-File Browser">adjustReadOnlyWidgetBackground: aSymbol with: aBuilder	"The default policy of giving distinguished backgrounds colors to	read-only widgets looks bad in some cases. Change the	specified widget to use regular text colors."	| preferences |	(aBuilder componentAt: aSymbol) ifNotNil:		[:wrapper |		preferences := LookPreferences new 			backgroundColor: SymbolicPaint textDataBackground asColorValue.		preferences := preferences			foregroundColor: SymbolicPaint textDataForeground asColorValue.		wrapper widgetState colors: preferences]</body><body package="Tools-File Browser">selectedFilename	^browser fileSelectionChannel value</body><body package="Tools-File Browser">withTextViewControllerDo: aBlock	| controller |	builder notNil ifTrue:		[controller := (builder componentAt: #text) widget controller.		aBlock value: controller]</body></methods><methods><class-id>Tools.FileTools.FileViewer class</class-id> <category>accessing</category><body package="Tools-File Browser">isConcrete	^(self class includesSelector: #markedAsAbstractViewer) not</body><body package="Tools-File Browser">isInterestedInFile: aFilename	self subclassResponsibility</body><body package="Tools-File Browser">markedAsAbstractViewer	"This method is never executed and only serves as a flag to FileViewer&gt;&gt;isConcrete	to indicate that this class should not be asked whether it can display a file."</body><body package="Tools-File Browser">tabLabel	self subclassResponsibility</body><body package="Tools-File Browser">tabPosition	self subclassResponsibility</body></methods><methods><class-id>Tools.FileTools.FileContentsViewer</class-id> <category>text</category><body package="Tools-File Browser">fullTextHolder	^fullTextHolder</body><body package="Tools-File Browser">previewText	| filename |	filename := self selectedFilename.	^filename isNil		ifTrue: [String new]		ifFalse: [self textForFileBeginning: filename]</body><body package="Tools-File Browser">previewText: text	^false</body><body package="Tools-File Browser">previewTextHolder	^previewTextHolder</body><body package="Tools-File Browser">text	| filename |	filename := self selectedFilename.	^filename isNil		ifTrue: [String new]		ifFalse: [self textForEntireFile: filename]</body><body package="Tools-File Browser">text: aText	^true</body></methods><methods><class-id>Tools.FileTools.FileContentsViewer</class-id> <category>private</category><body package="Tools-File Browser">canDisplay: aFilename	^[aFilename isDirectory not and: [aFilename isReadable]]		on: OsError		do: [:ex | ex return: false]</body><body package="Tools-File Browser">largeFileMessage	| sizeInK |	sizeInK := self largeFileThreshold // 1000.	^(#largeFileShowingFirst &lt;&lt; #labels &gt;&gt;	'Only &lt;1p&gt;K bytes of file contents are currently shown; use this to view entire file')		expandMacrosWith: sizeInK</body><body package="Tools-File Browser">largeFileThreshold	"Files larges than this number of bytes are displayed in preview mode first."	^50000</body><body package="Tools-File Browser">showFullInterface	(builder componentAt: #view) widget		client:self		spec: #fullTextSpec		builder: (lastSubBuilder := builder newSubBuilder)</body><body package="Tools-File Browser">showPreviewInterface	(builder componentAt: #view) widget		client:self		spec: #previewSpec		builder: (lastSubBuilder := builder newSubBuilder)</body><body package="Tools-File Browser">textForEntireFile: aFilename 		self subclassResponsibility</body><body package="Tools-File Browser">textForFileBeginning: aFilename	self subclassResponsibility</body><body package="Tools-File Browser">withTextViewControllerDo: aBlock	| controller |	lastSubBuilder notNil ifTrue:		[controller := (lastSubBuilder componentAt: #text) widget controller.		aBlock value: controller]</body></methods><methods><class-id>Tools.FileTools.FileContentsViewer</class-id> <category>initialize-release</category><body package="Tools-File Browser">initialize	super initialize.	previewTextHolder := (PluggableAdaptor on: self)		getSelector: #previewText		putSelector: #previewText:.	fullTextHolder := (PluggableAdaptor on: self)		getSelector: #text		putSelector: #text:</body><body package="Tools-File Browser">postBuildViewWith: aBuilder	| controller |	controller := (aBuilder componentAt: #text) widget controller.	self adjustReadOnlyWidgetBackground: #text with: aBuilder.	(controller respondsTo: #autoAccept:) 		ifTrue: [controller autoAccept: false]</body><body package="Tools-File Browser">postBuildWith: aBuilder	"Only do the postBuild stuff if the builder is the same as the original one.	Otherwise it means we've just built a subcanvas."	aBuilder = builder 		ifTrue: [super postBuildWith: aBuilder]		ifFalse: [self postBuildViewWith: aBuilder]</body><body package="Tools-File Browser">preBuildWith: aBuilder	aBuilder labelAt: #largeFileMessage put: self largeFileMessage</body></methods><methods><class-id>Tools.FileTools.FileContentsViewer</class-id> <category>actions</category><body package="Tools-File Browser">loadEntireFile	Cursor wait showWhile: [self showFullInterface].	self takeKeyboardFocus</body><body package="Tools-File Browser">takeKeyboardFocus	| wrapper |	lastSubBuilder notNil ifTrue:		[wrapper := lastSubBuilder componentAt: #text.		wrapper notNil ifTrue:			[wrapper takeKeyboardFocus]]</body></methods><methods><class-id>Tools.FileTools.FileContentsViewer</class-id> <category>updating</category><body package="Tools-File Browser">okToSaveTextFor: aController	^true</body><body package="Tools-File Browser">updateFor: aFilename	(self canDisplay: aFilename) ifTrue:		[aFilename fileSize &gt; self largeFileThreshold 			ifTrue: [self showPreviewInterface]			ifFalse: [self showFullInterface]]</body><body package="Tools-File Browser">updateForNoSelection	self showFullInterface</body></methods><methods><class-id>Tools.FileTools.FileContentsViewer class</class-id> <category>accessing</category><body package="Tools-File Browser">isInterestedInFile: aFilename 	^[aFilename isDirectory not]		on: OsError		do: [:ex | ex return: false]</body><body package="Tools-File Browser">markedAsAbstractViewer	"This method is never executed and only serves as a flag to FileViewer&gt;&gt;isConcrete	to indicate that this class should not be asked whether it can display a file."</body></methods><methods><class-id>Tools.FileTools.FileTextViewer</class-id> <category>initialize-release</category><body package="Tools-File Browser">browser: aBrowser	super browser: aBrowser.	browser encodingChannel onChangeSend: #encodingChanged to: self</body><body package="Tools-File Browser">postBuildViewWith: aBuilder	| textEditor |	super postBuildViewWith: aBuilder.	textEditor := (aBuilder componentAt: #text) widget controller.	(textEditor localMenuItem: #doIt)		ifTrue: [textEditor initializeMenuForCodeWithFileItIn]</body><body package="Tools-File Browser">release	browser encodingChannel retractInterestsFor: self.	super release</body></methods><methods><class-id>Tools.FileTools.FileTextViewer</class-id> <category>private</category><body package="Tools-File Browser">compareTextWithFile: aFilename	"Open a Differator on the text currently on the page (on the left) and the text from the file on the right."	| text fileText |	self withTextViewControllerDo:		[:textEditor |		text := textEditor text copy.		fileText := [aFilename contentsOfEntireFile]			on: OsError do: [:ex | ex return: String new].		(Differator newOn: text and: fileText) open]</body><body package="Tools-File Browser">encoding	^browser encodingChannel value</body><body package="Tools-File Browser">fileChangedOnDisk: aFilename	^originalFileTimestamp notNil 		and: [originalFileTimestamp ~= aFilename modificationTimestamp]</body><body package="Tools-File Browser">hasUnsavedChanges	| textEditor |	lastSubBuilder isNil ifTrue: [^false].	textEditor := (lastSubBuilder componentAt: #text) widget controller.	(textEditor respondsTo: #accepted) ifFalse: [^false].	^textEditor accepted not</body><body package="Tools-File Browser">okToRereadFile	^Dialog 		confirm: (#okToRereadFile &lt;&lt; #labels &gt;&gt; 			'Reread the file using the new encoding?&lt;n&gt;(Unsaved changes will be lost).')				expandMacros		initialAnswer: false</body><body package="Tools-File Browser">okToSaveFile: aFilename	| choice |	(self fileChangedOnDisk: aFilename) ifFalse: [^true].	choice := Dialog 		choose: (#FileHasChanged &lt;&lt; #dialogs &gt;&gt; 'The file on the disk has been changed.Saving may override other changes.  Save anyway?')		labels: (Array with: (#Yes &lt;&lt; #dialogs &gt;&gt; 'Yes') with: (#No &lt;&lt; #dialogs &gt;&gt; 'No') with: (#Compare &lt;&lt; #dialogs &gt;&gt; 'Compare'))		values: #(yes no compare)		default: #no.	choice = #compare ifTrue: [self compareTextWithFile: aFilename].	^choice = #yes</body><body package="Tools-File Browser">okToSaveTextFor: aController	| filename choice |	filename := self selectedFilename.	filename isNil ifTrue: [^true].	(self fileChangedOnDisk: filename) ifFalse: [^true].	choice := Dialog 		choose: (#FileHasChanged &lt;&lt; #dialogs &gt;&gt; 'The file on the disk has been changed.Saving may override other changes.  Save anyway?')		labels: (Array with: (#Yes &lt;&lt; #dialogs &gt;&gt; 'Yes') with: (#No &lt;&lt; #dialogs &gt;&gt; 'No') with: (#Compare &lt;&lt; #dialogs &gt;&gt; 'Compare'))		values: #(yes no compare)		default: #no.	choice = #compare ifTrue: [self compareTextWithFile: filename].	^choice = #yes</body><body package="Tools-File Browser">text: aString	| newFile filenameToSave stream |	newFile := false.	filenameToSave := self selectedFilename ifNil: 		[newFile := true.		self promptForNewFilename].	filenameToSave isNil ifTrue: [^false].	filenameToSave := filenameToSave withEncoding: self encoding.	stream := filenameToSave writeStream.	[stream nextPutAll: aString] ensure: [stream close].	newFile ifTrue: [browser refreshFilesAndSelect: filenameToSave].	^true</body><body package="Tools-File Browser">textForEntireFile: aFilename 	| filename |	filename := aFilename withEncoding: self encoding.	originalFileTimestamp := aFilename modificationTimestamp.	^filename contentsOfEntireFile</body><body package="Tools-File Browser">textForFileBeginning: aFilename	| fileStream textStream |	fileStream := (aFilename withEncoding: self encoding) readStream.	textStream := TextStream on: (String new: self largeFileThreshold + 20).	[textStream nextPutAll: (fileStream nextAvailable: self largeFileThreshold). 	textStream cr; emphasis: #italic; nextPutAll: (#RestNotShown &lt;&lt; #dialogs &gt;&gt; '--- rest not shown ---') asString]		ensure: [fileStream close].	^textStream contents</body></methods><methods><class-id>Tools.FileTools.FileTextViewer</class-id> <category>updating</category><body package="Tools-File Browser">changeRequest	| textEditor choice |	textEditor := (lastSubBuilder componentAt: #text) widget controller.	((textEditor respondsTo: #accepted) not or: [textEditor accepted]) ifTrue: [^true].	choice := Dialog 		choose: (#SaveChanges &lt;&lt; #dialogs &gt;&gt; 'Save changes?')		labels: (Array with: (#Yes &lt;&lt; #dialogs &gt;&gt; 'Yes') with: (#No &lt;&lt; #dialogs &gt;&gt; 'No') with: (#Cancel &lt;&lt; #dialogs &gt;&gt; 'Cancel'))		values: #(yes no cancel)		default: #yes.	choice = #cancel ifTrue: [^false].	choice = #yes ifTrue: [textEditor accept].	^true</body><body package="Tools-File Browser">encodingChanged	(self hasUnsavedChanges and: [self okToRereadFile not]) 		ifTrue: [^self].	self withTextViewControllerDo: [:editor | editor cancel]</body><body package="Tools-File Browser">updateForNoSelection	super updateForNoSelection.	originalFileTimestamp := nil</body></methods><methods><class-id>Tools.FileTools.FileTextViewer</class-id> <category>testing</category><body package="Tools-File Browser">promptForNewFilename	| selectedDirectory initialName selection |	selectedDirectory := browser selectedDirectory.	initialName := selectedDirectory isNil 		ifTrue: ['new.txt']		ifFalse: [selectedDirectory asFilename constructString: 'new.txt'].	selection := Dialog 		requestFileName: (#SaveIntoFileNamedColon &lt;&lt; #dialogs &gt;&gt; 'Save into a file named:')		default: initialName.	^(selection := selection trimBlanks) isEmpty		ifTrue: [nil]		ifFalse: [selection asFilename]</body></methods><methods><class-id>Tools.FileTools.FileTextViewer class</class-id> <category>accessing</category><body package="Tools-File Browser">tabLabel	^(#Text &lt;&lt; #labels &gt;&gt; 'Text') asString</body><body package="Tools-File Browser">tabPosition	^10</body></methods><methods><class-id>Tools.FileTools.XMLSourceViewer</class-id> <category>private</category><body package="Tools-File Browser">parseXMLFrom: aFilename writingTo: output 	XMLParser 		processDocumentInFilename: aFilename		beforeScanDo: 			[:parser | 			parser saxDriver: (XMLSourceWalker on: (SourceFormatter on: output)).			parser validate: false]</body><body package="Tools-File Browser">updateFor: aFilename	| output |	output := TextStream on: (String new: 100).	[self parseXMLFrom: aFilename writingTo: output]		on: MalformedSignal		do: [ :ex | 			"Ignore malformed errors caused by missing endtags. Would be nice to			be more selective about the errors that get muffled, but the parser lacks interface for that."			ex getSignal = BadCharacterSignal				ifTrue: [ex resume].			ex return].	self textHolder value: output contents</body><body package="Tools-File Browser">updateForNoSelection	self textHolder value: String new</body></methods><methods><class-id>Tools.FileTools.XMLSourceViewer</class-id> <category>aspects</category><body package="Tools-File Browser">textHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^textHolder isNil		ifTrue:			[textHolder := String new asValue]		ifFalse:			[textHolder]</body></methods><methods><class-id>Tools.FileTools.XMLSourceViewer</class-id> <category>interface opening</category><body package="Tools-File Browser">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self adjustReadOnlyWidgetBackground: #text with: aBuilder</body></methods><methods><class-id>Tools.FileTools.XMLSourceViewer class</class-id> <category>accessing</category><body package="Tools-File Browser">isInterestedInFile: aFilename	^(self looksLikeSourceFilename: aFilename)		and: [self startsAsXMLSource: aFilename]</body><body package="Tools-File Browser">looksLikeSourceFilename: aFilename	^#('*.st' '*.pst' '*.cha') anySatisfy: [:some | some match: aFilename tail]</body><body package="Tools-File Browser">startsAsXMLSource: aFilename	| stream |	^[stream := aFilename readStream.	[(stream next: 5) sameAs: '&lt;?xml']		ensure: [stream close]]			on: Error			do: [:ex | ex return: false]</body><body package="Tools-File Browser">tabLabel	^(#FormattedSource &lt;&lt; #labels &gt;&gt; 'Formatted Source') asString</body><body package="Tools-File Browser">tabPosition	^50</body></methods><methods><class-id>Tools.FileTools.FileBlurbViewer</class-id> <category>aspects</category><body package="Tools-File Browser">textHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^textHolder isNil		ifTrue:			[textHolder := String new asValue]		ifFalse:			[textHolder]</body></methods><methods><class-id>Tools.FileTools.FileBlurbViewer</class-id> <category>accessing</category><body package="Tools-File Browser">printBlurbFor: aFilename on: stream	self subclassResponsibility</body></methods><methods><class-id>Tools.FileTools.FileBlurbViewer</class-id> <category>updating</category><body package="Tools-File Browser">updateFor: aFilename	| stream |	stream := TextStream on: (String new: 100).	self printBlurbFor: aFilename on: stream.	self textHolder value: stream contents</body><body package="Tools-File Browser">updateForNoSelection	self textHolder value: String new</body></methods><methods><class-id>Tools.FileTools.FileBlurbViewer class</class-id> <category>accessing</category><body package="Tools-File Browser">markedAsAbstractViewer	"This method is never executed and only serves as a flag to FileViewer&gt;&gt;isConcrete	to indicate that this class should not be asked whether it can display a file."</body></methods><methods><class-id>Tools.FileTools.ParcelFileViewer</class-id> <category>private</category><body package="Tools-File Browser">capitalized: aStringOrSymbol	| copy |	copy := aStringOrSymbol asString copy.	copy at: 1 put: copy first asUppercase.	^copy</body><body package="Tools-File Browser">printComment: anArray on: aTextStream 	aTextStream		nextPutAll: anArray first;		cr;		cr</body><body package="Tools-File Browser">printHeaderOn: aStream usingProperties: propertyCollection	| name parcel version |	name := propertyCollection 		detect: [:some | some key = #parcel]		ifNone: ['' asValue].	version := propertyCollection		detect: [:some | some key = #version]		ifNone: ['' asValue].	aStream emphasis: #bold.	(parcel := Parcel parcelNamed: name value) isNil 		ifTrue: [aStream nextPutAll: (#ThisParcelIsNotLoaded &lt;&lt; #dialogs &gt;&gt; 'This parcel is not loaded') asString; cr; cr]		ifFalse:			[parcel version = version value				ifTrue: [aStream nextPutAll: (#ThisParcelIsLoaded &lt;&lt; #dialogs &gt;&gt; 'This parcel is loaded') asString; cr; cr]				ifFalse: [aStream 					nextPutAll: ((#DifferentVersion1sIsLoaded &lt;&lt; #dialogs &gt;&gt; 'A different version (&lt;1s&gt;) of this parcel is loaded') 						expandMacrosWith: parcel version); 					cr; cr]].	aStream emphasis: nil</body><body package="Tools-File Browser">printPrerequisites: anOrderedCollection on: aTextStream 	aTextStream 		emphasis: #bold;		nextPutAll: (#PrerequisitesColon &lt;&lt; #labels &gt;&gt; 'Prerequisites: ') asString;		emphasis: nil;		space.	anOrderedCollection isEmpty ifTrue:		[aTextStream nextPutAll: (#noneBracket &lt;&lt; #labels &gt;&gt; '&lt;none&gt;') asString].	anOrderedCollection 		do: 			[:eachPair | | name |			name := eachPair first.			(Parcel parcelNamed: name) notNil				ifTrue: [aTextStream emphasis: #bold].			aTextStream 				nextPutAll: name;				emphasis: nil]		separatedBy:			[aTextStream nextPutAll: ', '].	aTextStream cr</body><body package="Tools-File Browser">printProperties: propertyCollection on: aTextStream 	propertyCollection do: 		[:each | 		self 			printProperty: each key			value: each value			on: aTextStream]</body><body package="Tools-File Browser">printProperty: aSymbol value: anObject on: aTextStream 	aSymbol = #comment 		ifTrue: [^self printComment: anObject on: aTextStream].	aSymbol = #prerequisiteParcels 		ifTrue: [^self printPrerequisites: anObject on: aTextStream].	aTextStream		emphasis: #bold;		nextPutAll: (self capitalized: aSymbol);		nextPutAll: ': ';		emphasis: nil;		print: anObject;		cr</body><body package="Tools-File Browser">propertiesFrom: aFilename 	| properties propertyItems commentItem |	properties := [CodeReader new readInfoFromFileNamed: aFilename] 				on: OsError, CodeReader fileFormatSignal				do: [:ex | ex return: Dictionary new].	propertyItems := SortedCollection sortBlock: [:a :b | a key &lt;= b key].	properties 		keysAndValuesDo: [:key :value | propertyItems add: key -&gt; value].	propertyItems := propertyItems asOrderedCollection.	commentItem := propertyItems detect: [:some | some key = 'comment']				ifNone: [].	commentItem notNil 		ifTrue: 			[propertyItems remove: commentItem.			propertyItems addFirst: commentItem].	^propertyItems</body></methods><methods><class-id>Tools.FileTools.ParcelFileViewer</class-id> <category>accessing</category><body package="Tools-File Browser">printBlurbFor: aFilename on: aTextStream	| properties |	properties := self propertiesFrom: aFilename.	properties isEmpty ifTrue:		[^aTextStream 			emphasis: #italic;			nextPutAll: (#CannotRetrieveProperties &lt;&lt; #dialogs &gt;&gt; 'Cannot retrieve parcel properties') asString].	self 		printHeaderOn: aTextStream usingProperties: properties;		printProperties: properties on: aTextStream</body></methods><methods><class-id>Tools.FileTools.ParcelFileViewer class</class-id> <category>accessing</category><body package="Tools-File Browser">isInterestedInFile: aFilename 	^'*.pcl' match: aFilename tail</body><body package="Tools-File Browser">tabLabel	^(#ParcelInformation &lt;&lt; #labels &gt;&gt; 'Parcel Information') asString</body><body package="Tools-File Browser">tabPosition	^5</body></methods><methods><class-id>Tools.FileTools.XMLTreeViewer</class-id> <category>initialize-release</category><body package="Tools-File Browser">initialize	super initialize.	textHolder := (AspectAdaptor forAspect: #noIndentPrintString)		subjectChannel: self nodeTreeHolder selectionHolder;		yourself</body><body package="Tools-File Browser">postBuildWith: aBuilder	| treeView |	super postBuildWith: aBuilder.	"treeView := (aBuilder componentAt: #nodeTree) widget.	treeView controller expandFullyRoot"</body></methods><methods><class-id>Tools.FileTools.XMLTreeViewer</class-id> <category>private</category><body package="Tools-File Browser">childrenOf: anXMLNode	^[anXMLNode children reject: [:some | some isText]]		on: Error		do: [:ex | ex return: #()]</body><body package="Tools-File Browser">parseXMLFrom: aFilename	| document tree |	document := XMLParser		processDocumentInFilename: aFilename		beforeScanDo: 			[:parser | 			parser validate: false].	self nodeTreeHolder list:		(TreeModel 			on: document			displayRoot: false			childrenWith: [:node | self childrenOf: node]).	tree := self nodeTreeHolder list.	tree size to: 1 by: -1 do: [:index | tree expand: index]</body><body package="Tools-File Browser">updateFor: aFilename	[self parseXMLFrom: aFilename]		on: MalformedSignal		do: [ :ex | 			"Ignore malformed errors caused by missing endtags. Would be nice to			be more selective about the errors that get muffled, but the parser lacks interface for that."			ex getSignal = BadCharacterSignal				ifTrue: [ex resume].			ex return].</body><body package="Tools-File Browser">updateForNoSelection	self nodeTreeHolder list: TreeModel new</body></methods><methods><class-id>Tools.FileTools.XMLTreeViewer</class-id> <category>aspects</category><body package="Tools-File Browser">nodeTreeHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^nodeTreeHolder isNil		ifTrue:			[nodeTreeHolder := SelectionInTree new]		ifFalse:			[nodeTreeHolder]</body><body package="Tools-File Browser">textHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^textHolder isNil		ifTrue:			[textHolder := String new asValue]		ifFalse:			[textHolder]</body></methods><methods><class-id>Tools.FileTools.XMLTreeViewer</class-id> <category>actions</category><body package="Tools-File Browser">inspectNode	^self nodeTreeHolder selection inspect</body></methods><methods><class-id>Tools.FileTools.XMLTreeViewer class</class-id> <category>private</category><body package="Tools-File Browser">couldBeXMLFile: aFilename^#('*.xml' '*.st' '*.pst' '*.cha' '*.sou' '*.wsdl') anySatisfy: [:some | some match: aFilename tail]</body><body package="Tools-File Browser">isInterestedInFile: aFilename	^(self couldBeXMLFile: aFilename)		and: [self startsAsXML: aFilename]</body><body package="Tools-File Browser">startsAsXML: aFilename	| stream |	^[stream := aFilename readStream.	[(stream next: 5) sameAs: '&lt;?xml']		ensure: [stream close]]			on: Error			do: [:ex | ex return: false]</body></methods><methods><class-id>Tools.FileTools.XMLTreeViewer class</class-id> <category>accessing</category><body package="Tools-File Browser">tabLabel	^(#XMLTree &lt;&lt; #labels &gt;&gt; 'XML Tree') asString</body><body package="Tools-File Browser">tabPosition	^70</body></methods><methods><class-id>Tools.FileTools.AbstractFileItem</class-id> <category>comparing</category><body package="Tools-File Browser">= anotherItem	^filename = anotherItem asFilename</body><body package="Tools-File Browser">hash	^filename hash</body></methods><methods><class-id>Tools.FileTools.AbstractFileItem</class-id> <category>accessing</category><body package="Tools-File Browser">baseLocation	^filename class readBaseLocationFromStream: filename asString readStream</body><body package="Tools-File Browser">children	"Answer the children of this item."	self subclassResponsibility</body><body package="Tools-File Browser">matches: patternString	^patternString match: filename tail</body><body package="Tools-File Browser">parent	^DirectoryItem on: self parentFilename</body><body package="Tools-File Browser">parentFilename	^filename directory</body></methods><methods><class-id>Tools.FileTools.AbstractFileItem</class-id> <category>printing</category><body package="Tools-File Browser">asString	^filename asString</body><body package="Tools-File Browser">asText	^self asString</body><body package="Tools-File Browser">displayString	^filename tail</body><body package="Tools-File Browser">printOn: aStream	super printOn: aStream.	aStream		nextPutAll: ' (';		nextPutAll: filename asString;		nextPutAll: ')'</body></methods><methods><class-id>Tools.FileTools.AbstractFileItem</class-id> <category>converting</category><body package="Tools-File Browser">asFilename	^filename</body></methods><methods><class-id>Tools.FileTools.AbstractFileItem</class-id> <category>testing</category><body package="Tools-File Browser">isDirectory	self subclassResponsibility</body></methods><methods><class-id>Tools.FileTools.AbstractFileItem</class-id> <category>initialize - release</category><body package="Tools-File Browser">initialize: aPlatformFilename	filename := aPlatformFilename</body></methods><methods><class-id>Tools.FileTools.AbstractFileItem</class-id> <category>visuals</category><body package="Tools-File Browser">icon	self subclassResponsibility</body></methods><methods><class-id>Tools.FileTools.AbstractFileItem class</class-id> <category>private</category><body package="Tools-File Browser">isDirectory: aFilename	^[aFilename isDirectory]		on: OsError "for special files"		do: [:ex | ex return: false]</body><body package="Tools-File Browser">isDrive: aFilename	^OSHandle isMSWindows		and: [aFilename asString = aFilename head]</body></methods><methods><class-id>Tools.FileTools.AbstractFileItem class</class-id> <category>instance creation</category><body package="Tools-File Browser">on: aPlatformFilename	self == AbstractFileItem ifFalse:		[^self new initialize: aPlatformFilename].	(self isDrive: aPlatformFilename) ifTrue:		[^SpecialDirectoryItem new initialize: aPlatformFilename].	^(self isDirectory: aPlatformFilename) 		ifTrue: [DirectoryItem new initialize: aPlatformFilename]		ifFalse: [FileItem new initialize: aPlatformFilename]</body></methods><methods><class-id>Tools.FileTools.DirectoryItem</class-id> <category>testing</category><body package="Tools-File Browser">hasAnyChildren	^self subdirectoryItems isEmpty not		or: [self fileItems isEmpty not]</body><body package="Tools-File Browser">hasChildren	^cachedSubdirectoryItems isNil		ifTrue: [self privateHasSubdirectories]		ifFalse: [cachedSubdirectoryItems notEmpty]</body><body package="Tools-File Browser">isDirectory	^true</body></methods><methods><class-id>Tools.FileTools.DirectoryItem</class-id> <category>private</category><body package="Tools-File Browser">privateHasSubdirectories	"As constructing Filenames is an expensive operation, there is	much speed to gain if we only do it until we encounter the first	child directory."	^self directoryContents anySatisfy: 			[:filenameString |			[(filename constructSafe: filenameString) isDirectory] on: OsError				do: [:ex | ex return: false]]</body><body package="Tools-File Browser">retrieveSubdirectoryItems	cachedSubdirectoryItems := self subdirectoryFilenames collect: [:each | DirectoryItem on: each]</body></methods><methods><class-id>Tools.FileTools.DirectoryItem</class-id> <category>files</category><body package="Tools-File Browser">directoryContents	^[filename directoryContents] on: OsError do: [:ex | ex return: Array new]</body><body package="Tools-File Browser">directoryContentsFilenames	^self directoryContents collect: [:each | filename constructSafe: each]</body><body package="Tools-File Browser">fileFilenames	^(self directoryContentsFilenames select: 			[:each |			[each isDirectory not] on: OsError do: [:ex | ex return: true]	"special files signal it"])		sorted: #tail ascending</body><body package="Tools-File Browser">fileItems	^self fileFilenames collect: [:each | FileItem on: each]</body><body package="Tools-File Browser">fileItemsMatching: patternString	| patterns |	patterns := (patternString tokensBasedOn: $,) collect: [:each | each trimBlanks].	(patterns size = 1 and: [patterns first isEmpty]) 		ifTrue: [patterns := #('*')].	^self fileItems select: 		[:each | 		patterns anySatisfy: [:any | each matches: any]]</body></methods><methods><class-id>Tools.FileTools.DirectoryItem</class-id> <category>subdirectories</category><body package="Tools-File Browser">children	"This one, as opposed to #subdirectoryItems, is used in the UI	so we are sure we want to display a busy cursor while doing it."	^Cursor wait showWhile: [self subdirectoryItems]</body><body package="Tools-File Browser">parentDirectories	"Answer a collection of DirectoryItems representing all directories from	the root of the filesystem (or my drive) to myself, beginning with the root."	| parent |	parent := self parent.	^parent = self 		ifTrue: [Array new]		ifFalse: [parent withParentDirectories]</body><body package="Tools-File Browser">refresh	cachedSubdirectoryItems := nil</body><body package="Tools-File Browser">subdirectoryFilenames	^(self directoryContentsFilenames select: 			[:each |			[each isDirectory] on: Error do: [:ex | ex returnWith: false]	"special files signal it"])		sorted: #tail ascending</body><body package="Tools-File Browser">subdirectoryItems	cachedSubdirectoryItems isNil		ifTrue: [self retrieveSubdirectoryItems].	^cachedSubdirectoryItems</body><body package="Tools-File Browser">subdirectoryItemsMatching: patternString	| patterns |	patterns := (patternString tokensBasedOn: $,) collect: [:each | each trimBlanks].	(patterns size = 1 and: [patterns first isEmpty]) 		ifTrue: [patterns := #('*')].	^self subdirectoryItems select: 		[:each | patterns anySatisfy: [:any | each matches: any]]</body><body package="Tools-File Browser">withParentDirectories	"Answer a collection of DirectoryItems representing all directories from	the root of the filesystem (or my drive) to myself, beginning with the root."	| parent |	parent := self parent.	^parent = self 		ifTrue: [Array with: self]		ifFalse: [parent withParentDirectories copyWith: self]</body></methods><methods><class-id>Tools.FileTools.DirectoryItem</class-id> <category>visuals</category><body package="Tools-File Browser">folderTreeIcon	^TreeView closedFolder</body><body package="Tools-File Browser">folderTreeSelectedIcon	^TreeView openedFolder</body><body package="Tools-File Browser">icon	^TreeView closedFolder</body></methods><methods><class-id>Tools.FileTools.DirectoryItem class</class-id> <category>testing</category><body package="Tools-File Browser">example	"self example"		^DirectoryItem on: 'c:\pps\' asFilename</body></methods><methods><class-id>Tools.FileTools.FileBrowser</class-id> <category>file list</category><body package="Tools-File Browser">copyFile	self withSelectedFilenameDo:		[:filename | | name newFilename |		name := Dialog 			requestFileNameWithMessage: (#CopyFileToColon &lt;&lt; #labels &gt;&gt; 'Copy File To:')			default: (self selectedDirectory asFilename constructString: filename tail)			version: #new			ifFail: [^self]			for: builder window.		newFilename := name asFilename.		filename copyTo: newFilename.		self reloadFiles;			selectFileNamed: newFilename]</body><body package="Tools-File Browser">copyFilename	self		withSelectedFilenameDo: [:name | TextEditorController currentSelection: name asString]</body><body package="Tools-File Browser">createFile	| name newFilename |	name := Dialog 		requestFileNameWithMessage: (#CreateNewFileNamedColon &lt;&lt; #labels &gt;&gt; 'Create New File Named:')		default: (self selectedDirectory asFilename constructString: 'new.txt')		version: #new		ifFail: [^self]		for: builder window.	newFilename := name asFilename.	newFilename exists ifFalse: [newFilename writeStream close].	self reloadFiles;		selectFileNamed: newFilename</body><body package="Tools-File Browser">createItemOf: aView at: index reversing: aBoolean 	| item label wrapper |	item := aView sequence at: index.	label := self createLabelAndIconOf: item for: aView.	^aBoolean 		ifTrue: 			[wrapper := ReversingWrapper on: label.			wrapper reverse setValue: true.			wrapper]		ifFalse: [label]</body><body package="Tools-File Browser">createLabelAndIconOf: item for: aView 	^(ExtendedLabelAndIcon		with: item displayString		attributes: aView textStyle		offset: 0 @ 0)			icon: item icon; 			yourself</body><body package="Tools-File Browser">fileEdit	| selected workspace |	selected := self selectedFile.	selected isNil		ifTrue: [Workspace open]		ifFalse: 			[workspace := Workspace withFile: selected asFilename.			workspace encoding: encodingChannel value.			workspace open]</body><body package="Tools-File Browser">fileIn	self withSelectedFilenameDo:		[:name | 		Notice			show: (#FilingInN1S &lt;&lt; #dialogs &gt;&gt; 'Filing in&lt;n&gt;&lt;1s&gt;' expandMacrosWith: name tail)			while: [(name withEncoding: encodingChannel value) fileIn]]</body><body package="Tools-File Browser">fileIntoNewChangeSet	self withSelectedFilenameDo:		[:name | | setName newSet |		setName := self 			requestNewChangeSetNameFor: name			ifCancel: [^self].		newSet := NamedChangeSet withName: setName.		NamedChangeSet addChangeSet: newSet.		ChangeSet current: newSet.		Notice			show: (#FilingInN1S &lt;&lt; #dialogs &gt;&gt; 'Filing in&lt;n&gt;&lt;1s&gt;' expandMacrosWith: name tail)			while: [(name withEncoding: encodingChannel value) fileIn].		ChangeSet current dirty: false.		ChangeSet changed]</body><body package="Tools-File Browser">fileListDoubleClicked: aController	self withSelectedFilenameDo:		[:filename |		filename isDirectory			ifTrue: [self selectDirectory: filename]			ifFalse: [self fileEdit]]</body><body package="Tools-File Browser">fileSelected		self		publishEmptySelection;		setGuessedFileEncoding;		updateViewerTabs;		updateStatusBar;		refreshMenuBar;		refreshToolbar;		publishSelection</body><body package="Tools-File Browser">fileSelectionChannel	^fileSelectionChannel</body><body package="Tools-File Browser">initializeFiles	fileSelectionChannel := nil asValue.	self fileListHolder selectionIndexHolder		onChangeSend: #fileSelected to: self</body><body package="Tools-File Browser">inspectFilename	^self selectedFile asFilename inspect</body><body package="Tools-File Browser">isFileoutFilename: aFilename	| tail |	tail := aFilename tail.	^#('*.st' '*.pst' '*.cha') anySatisfy: [:pattern | pattern match: tail]</body><body package="Tools-File Browser">isParcelFilename: aFilename	^'*.pcl' match: aFilename tail</body><body package="Tools-File Browser">loadParcel	self withSelectedFilenameDo:		[:name | 		Notice 			show: (#LoadingParcelN1S &lt;&lt; #dialogs &gt;&gt; 'Loading Parcel&lt;n&gt;&lt;1s&gt;' expandMacrosWith: name asString)			while: [Parcel loadParcelFrom: name]]</body><body package="Tools-File Browser">openChanges	self withSelectedFilenameDo:		[:name | ChangeList openOnFileNamed: name]</body><body package="Tools-File Browser">openConflicts	self withSelectedFilenameDo:		[:name | | changeList |		changeList := ChangeList new.		changeList			checkSystem: #exact;			showConflicts: true;			scanFilename: name.		changeList open]</body><body package="Tools-File Browser">publishEmptySelection	fileSelectionChannel value: nil</body><body package="Tools-File Browser">publishSelection	fileSelectionChannel 		value: (self selectedFile ifNotNil: [:fileItem | fileItem asFilename]				ifNil: [self selectedDirectory ifNotNil: [:dirItem | dirItem asFilename]])</body><body package="Tools-File Browser">refreshFiles	| currentFile |	currentFile := self selectedFile.	self reloadFiles.	self fileListHolder selection: currentFile</body><body package="Tools-File Browser">refreshFilesAndSelect: aFilename	self reloadFiles.	self selectFileNamed: aFilename</body><body package="Tools-File Browser">reloadFiles	| currentFolder pattern directories files |	currentFolder := self selectedDirectory.	currentFolder isNil ifTrue: [^self fileListHolder list: List new].	pattern := self patternHolder value.	directories := currentFolder subdirectoryItemsMatching: pattern.	files := currentFolder fileItemsMatching: pattern.	self fileListHolder list: (directories, files) asList</body><body package="Tools-File Browser">removeDirectory: aDirectoryItem	| parent |	aDirectoryItem hasAnyChildren ifTrue: 		[Dialog warn: (#CannotRremoveDirectoryIsNotEmpty &lt;&lt; #dialogs &gt;&gt; 'Cannot remove: the selected directory is not empty.').		^self].	(Dialog confirm: ((#RemoveDirectory1sQ &lt;&lt; #dialogs &gt;&gt; 'Remove directory "&lt;1s&gt;"?') expandMacrosWith: aDirectoryItem asFilename tail))		ifFalse: [^self].	parent := self selectedDirectory.	aDirectoryItem asFilename delete.	parent refresh.	self directoryTreeHolder list refresh: parent.	self reloadFiles</body><body package="Tools-File Browser">removeFile	self withSelectedFileDo:		[:file |		(Dialog confirm: ((#RemoveFile1sQ &lt;&lt; #dialogs &gt;&gt; 'Remove file "&lt;1s&gt;"?') expandMacrosWith: file asFilename tail))			ifFalse: [^self].		file asFilename delete.		self reloadFiles]</body><body package="Tools-File Browser">removeFile: aFileItem	(Dialog confirm: ((#RemoveFile1sQ &lt;&lt; #dialogs &gt;&gt; 'Remove file "&lt;1s&gt;"?') expandMacrosWith: aFileItem asFilename tail))		ifFalse: [^self].	aFileItem asFilename delete.	self reloadFiles</body><body package="Tools-File Browser">removeFileOrDirectory	self withSelectedFileOrDirectoryDo:		[:file |		file isDirectory			ifTrue: [self removeDirectory: file]			ifFalse: [self removeFile: file]]</body><body package="Tools-File Browser">renameFile	self withSelectedFileDo:		[:file | | newName directory newFilename |		newName := Dialog			request: (#RenameTheFileAsColon &lt;&lt; #dialogs &gt;&gt; 'Rename the file as:')			initialAnswer: file asFilename tail.		newName isEmpty ifTrue: [^self].		directory := self selectedDirectory.		newFilename := directory asFilename construct: newName.		file asFilename renameTo: newFilename.		self reloadFiles.		self selectFileNamed: newFilename]</body><body package="Tools-File Browser">renameFileOrDirectory	self withSelectedFilenameDo:		[:filename | | isDirectory newName directory newFilename |		isDirectory := filename isDirectory.		newName := (Dialog			request: ((#RenameTheDirectoryOrFileAsColon &lt;&lt; #dialogs &gt;&gt; 'Rename the &lt;1?directory:file&gt; as:') expandMacrosWith: isDirectory)			initialAnswer: filename tail) trimBlanks.		newName isEmpty ifTrue: [^self].		directory := self selectedDirectory.		newFilename := directory asFilename construct: newName.		filename renameTo: newFilename.		isDirectory ifTrue:			[directory refresh.			self directoryTreeHolder list refresh: directory].		self reloadFiles.		self selectFileNamed: newFilename]</body><body package="Tools-File Browser">requestNewChangeSetNameFor: aFilename ifCancel: aBlock	| tail |	tail := aFilename tail.	^NamedChangeSet		requestUniqueName: (#FileIntoNewChangeSet &lt;&lt; #dialogs &gt;&gt; 'File into new change set named:')		initial: (tail copyFrom: 1 to: tail size - aFilename extension size)		ifCancel: aBlock</body><body package="Tools-File Browser">selectedFile	^self fileListHolder selection</body><body package="Tools-File Browser">selectedVisualBlock	^[:view :index | 	BoundedWrapper on: 		(self createItemOf: view at: index reversing: true)]</body><body package="Tools-File Browser">selectFileNamed: aFilename	self fileListHolder selection: (FileItem on: aFilename)</body><body package="Tools-File Browser">setGuessedFileEncoding	encodingChannel setValue: 		(self selectedFile 			ifNil: [#default]			ifNotNil: [:fileItem | self guessEncodingFor: fileItem asFilename])</body><body package="Tools-File Browser">setupFileListWidget	| listWidget |	listWidget := (builder componentAt: #files) widget.	listWidget visualBlock: self unselectedVisualBlock.	listWidget selectedVisualBlock: self selectedVisualBlock</body><body package="Tools-File Browser">unselectedVisualBlock		^[:view :index | 	BoundedWrapper on: 		(self createItemOf: view at: index reversing: false)]</body><body package="Tools-File Browser">withSelectedFileDo: aBlock	| file |	file := self selectedFile.	^file isNil 		ifTrue: [nil]		ifFalse: [aBlock value: file]</body><body package="Tools-File Browser">withSelectedFilenameDo: aBlock	| file |	file := self selectedFile.	^file isNil 		ifTrue: [nil]		ifFalse: [aBlock value: file asFilename]</body><body package="Tools-File Browser">withSelectedFileOrDirectoryDo: aBlock	| file |	file := self selectedFile.	^file isNil 		ifTrue: [nil]		ifFalse: [aBlock value: file]</body></methods><methods><class-id>Tools.FileTools.FileBrowser</class-id> <category>aspects</category><body package="Tools-File Browser">directoryTreeHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^directoryTreeHolder isNil		ifTrue:			[directoryTreeHolder := SelectionInTree new]		ifFalse:			[directoryTreeHolder]</body><body package="Tools-File Browser">fileListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^fileListHolder isNil		ifTrue:			[fileListHolder := SelectionInList new]		ifFalse:			[fileListHolder]</body><body package="Tools-File Browser">patternChoices	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^patternChoices isNil		ifTrue:			[patternChoices := List new asValue]		ifFalse:			[patternChoices]</body><body package="Tools-File Browser">patternHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^patternHolder isNil		ifTrue:			[patternHolder := String new asValue]		ifFalse:			[patternHolder]</body><body package="Tools-File Browser">statusTextLeftHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^statusTextLeftHolder isNil		ifTrue:			[statusTextLeftHolder := String new asValue]		ifFalse:			[statusTextLeftHolder]</body><body package="Tools-File Browser">statusTextRightHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^statusTextRightHolder isNil		ifTrue:			[statusTextRightHolder := String new asValue]		ifFalse:			[statusTextRightHolder]</body><body package="Tools-File Browser">viewerListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^viewerListHolder isNil		ifTrue:			[viewerListHolder := SelectionInList new]		ifFalse:			[viewerListHolder]</body></methods><methods><class-id>Tools.FileTools.FileBrowser</class-id> <category>pattern box</category><body package="Tools-File Browser">addPatternBox	| toolbar |	toolbar := self builder componentAt: #toolbarMenu.	toolbar addTool: 			[| wrapper |			builder newComposite.			builder addSpec: self class filePatternSpec decodeAsLiteralArray.			wrapper := (builder componentAt: #pattern) component.			builder endComposite.			wrapper]		width: #fill</body><body package="Tools-File Browser">initializePatterns	self patternChoices value		add: '*';		add: '*.pcl';		add: '*.st, *.pst, *.cha';		add: '*.txt, *.ws'.	self patternHolder value: '*'.	self patternHolder onChangeSend: #patternSelected to: self</body><body package="Tools-File Browser">patternSelected	self 		rearrangePatternChoices;		reloadFiles;		updateStatusBar</body><body package="Tools-File Browser">rearrangePatternChoices	| currentChoice |	currentChoice := self patternHolder value.	currentChoice isEmpty ifTrue: [^self].	self patternChoices value		remove: currentChoice ifAbsent: [];		addFirst: currentChoice</body></methods><methods><class-id>Tools.FileTools.FileBrowser</class-id> <category>viewers</category><body package="Tools-File Browser">initializeViewerTabs	self viewerListHolder selectionIndexHolder		onChangeSend: #viewerSelected to: self</body><body package="Tools-File Browser">installViewer: aViewer	currentViewer notNil ifTrue: [currentViewer release].	currentViewer := aViewer.	self viewerNotebookWidget 		client: currentViewer		spec: #windowSpec		builder: builder newSubBuilder</body><body package="Tools-File Browser">setupViewerTabs	self viewerNotebookWidget tabBar component displayStringSelector: #tabLabel.	self updateViewerTabs</body><body package="Tools-File Browser">setViewersTo: classCollection	self viewerListHolder 		list: classCollection asList;		selectionIndex: (1 min: classCollection size)</body><body package="Tools-File Browser">setViewersTo: classCollection quietlySelecting: aClass	self withoutViewerChangeUpdates:		[self viewerListHolder 			list: classCollection asList;			selection: aClass]</body><body package="Tools-File Browser">showNonViewerWidgets: aBoolean	#(folders splitter1 files splitter2) do:		[:each | (builder componentAt: each) isVisible: aBoolean]</body><body package="Tools-File Browser">toggleZoom	| widget leftLayout topLayout |	widget := builder componentAt: #viewers.	leftLayout := (builder componentAt: #splitter1) component layout.	topLayout := (builder componentAt: #splitter2) component layout.	self isZoomed		ifTrue:			[self showNonViewerWidgets: true.			widget component layout				leftFraction: leftLayout rightFraction;				leftOffset: leftLayout rightOffset;				topFraction: topLayout bottomFraction;				topOffset: topLayout bottomOffset]		ifFalse:			[widget component layout				leftFraction: 0;				leftOffset: 0;				topFraction: 0;				topOffset: 0.			self showNonViewerWidgets: false.			currentViewer takeKeyboardFocus].	builder window refresh</body><body package="Tools-File Browser">updateViewerTabs	| selection viewerClasses currentViewerClass |	builder isNil ifTrue: [^self].	selection := self selectedFile ifNil: [self selectedDirectory].	viewerClasses := selection isNil		ifTrue: [List new]		ifFalse: [self viewerClassesInterestedIn: selection].	currentViewerClass := self viewerListHolder selection.	(self nonDefaultViewerSelected and: [viewerClasses includes: currentViewerClass])		ifTrue: [self setViewersTo: viewerClasses quietlySelecting: currentViewerClass]		ifFalse: [self setViewersTo: viewerClasses]</body><body package="Tools-File Browser">viewerClassesInterestedIn: aFileItem	| filename viewerClasses |	filename := aFileItem asFilename.	viewerClasses := FileViewer allSubclasses select:		[:some | some isConcrete and: [some isInterestedInFile: filename]].	^viewerClasses asSortedCollection:		[:a :b | a tabPosition &lt;= b tabPosition]</body><body package="Tools-File Browser">viewerNotebookWidget	^(builder componentAt: #viewers) widget</body><body package="Tools-File Browser">viewerSelected	| viewerClass |	viewerClass := self viewerListHolder selection.	viewerClass isNil ifTrue: [^self].	self installViewer: (viewerClass new browser: self).</body><body package="Tools-File Browser">withoutViewerChangeUpdates: aBlock	self viewerListHolder selectionIndexHolder retractInterestsFor: self.	aBlock ensure: 		[self viewerListHolder selectionIndexHolder			onChangeSend: #viewerSelected			to: self]</body></methods><methods><class-id>Tools.FileTools.FileBrowser</class-id> <category>directory tree</category><body package="Tools-File Browser">addAndSelectDirectory: aFilename	| tree item |	tree := self directoryTreeHolder list.	item := SpecialDirectoryItem on: aFilename.	item name: aFilename asString.	tree root: (tree root add: item; yourself) displayIt: false.	self directoryTreeHolder selection: item</body><body package="Tools-File Browser">copyDirectoryFilename	| folder |	folder := self selectedDirectory.	folder isNil ifTrue: [^self].	TextEditorController currentSelection: folder asFilename asString</body><body package="Tools-File Browser">createSubdirectory	self withSelectedDirectoryDo:		[:directory | | newName newFilename |		newName := (Dialog 			request: (#CreateSubdirectoryNamedColon &lt;&lt; #dialogs &gt;&gt; 'Create a subdirectory of the selected directory named:')			initialAnswer: String new)				trimBlanks.		newName isEmpty ifTrue: [^self].		newFilename := directory asFilename construct: newName.		newFilename makeDirectory.		directory refresh.		self directoryTreeHolder list refresh: directory.		self selectDirectory: newFilename]</body><body package="Tools-File Browser">directorySelected	Cursor wait showWhile: 			[self reloadFiles.			self updateStatusBar.			self publishSelectedDirectory]</body><body package="Tools-File Browser">expandToDirectory: directoryFilename	| target path treeModel lastExpanded |	target := DirectoryItem on: directoryFilename.	path := target parentDirectories.	treeModel := self directoryTreeHolder list.	lastExpanded := nil.	Cursor wait showWhile:		[path do: [:each |			| index |			index := treeModel indexOf: each.			index = 0 ifTrue: [^lastExpanded].			treeModel expand: index.			lastExpanded := each]].	^target</body><body package="Tools-File Browser">goToDirectory	| name destination |	name := Dialog 		requestDirectoryName: (#GoToDirectoryNamedColon &lt;&lt; #dialogs &gt;&gt; 'Go to directory named:')		default: (self hasDirectoryInTreeSelected			ifTrue: [self selectedDirectory asFilename asString]			ifFalse: [String new]).	name isEmpty ifTrue: [^self].	Cursor wait showWhile:		[destination := name asFilename.		(self isLocalDirectory: destination)			ifTrue: [self selectDirectory: destination]			ifFalse: [self addAndSelectDirectory: destination]]</body><body package="Tools-File Browser">initiallySelectDefault	InitialSelectionPreference := #default</body><body package="Tools-File Browser">initiallySelectNone	InitialSelectionPreference := #none</body><body package="Tools-File Browser">initiallySelectRootOfDefault	InitialSelectionPreference := #root</body><body package="Tools-File Browser">inspectDirectoryFilename	^self selectedDirectory asFilename inspect</body><body package="Tools-File Browser">isLocalDirectory: aFilename	| tree bases filenameBase |	tree := self directoryTreeHolder list.	bases := tree root children.	filenameBase := aFilename class 		readBaseLocationFromStream: aFilename asString readStream.	^(bases collect: [:each | each baseLocation]) includes: filenameBase</body><body package="Tools-File Browser">maybeSelectDirectoryNamed: aStringOrNil	aStringOrNil notNil ifTrue:		[self selectDirectory: aStringOrNil asFilename]</body><body package="Tools-File Browser">parentOfDirectory: aDirectoryItem	| stepParent |	stepParent := aDirectoryItem parent.	^self directoryTreeHolder list detect: [:some | some = stepParent] ifNone: [nil]</body><body package="Tools-File Browser">publishSelectedDirectory	self fileSelectionChannel value: 		(self selectedDirectory ifNotNil: [:selection | selection asFilename])</body><body package="Tools-File Browser">refreshDirectory	self withSelectedDirectoryDo:		[:directory |		directory refresh.		self directoryTreeHolder list refresh: directory.		self refreshFiles]</body><body package="Tools-File Browser">reloadDirectories	| model |	model := TreeModel		on: TopLevelItem current 		displayRoot: false		childrenWith: [:item | item children]		testHasChildrenWith: [:item | item hasChildren].	self directoryTreeHolder list: model</body><body package="Tools-File Browser">removeDirectory	self withSelectedDirectoryDo:		[:directory | | parent |		directory hasAnyChildren ifTrue: 			[Dialog warn: (#CannotRremoveDirectoryIsNotEmpty &lt;&lt; #dialogs &gt;&gt; 'Cannot remove: the selected directory is not empty.').			^self].		(Dialog confirm: ((#RemoveDirectory1sQ &lt;&lt; #dialogs &gt;&gt; 'Remove directory "&lt;1s&gt;"?') expandMacrosWith: directory asFilename tail))			ifFalse: [^self].		parent := self parentOfDirectory: directory.		directory asFilename delete.		parent refresh.		self directoryTreeHolder list refresh: parent.		self selectDirectory: parent asFilename]</body><body package="Tools-File Browser">renameDirectory	self withSelectedDirectoryDo:		[:directory | | newName parent newFilename |		newName := Dialog			request: (#RenameTheDirectoryAsColon &lt;&lt; #dialogs &gt;&gt; 'Rename the directory as:')			initialAnswer: directory asFilename tail.		newName isEmpty ifTrue: [^self].		parent := self parentOfDirectory: directory.		newFilename := parent asFilename construct: newName.		directory asFilename renameTo: newFilename.		parent refresh.		self directoryTreeHolder list refresh: parent.		self selectDirectory: newFilename]</body><body package="Tools-File Browser">selectDefaultDirectory	self selectDirectory: Filename defaultDirectory</body><body package="Tools-File Browser">selectDirectory: directoryFilename	| lastKnownDirectoryItem |	lastKnownDirectoryItem := self expandToDirectory: directoryFilename.	self directoryTreeHolder selection: lastKnownDirectoryItem</body><body package="Tools-File Browser">selectedDirectory	^self directoryTreeHolder selection</body><body package="Tools-File Browser">selectInitialDirectory	InitialSelectionPreference = #none		ifTrue: [^self].	InitialSelectionPreference = #root 		ifTrue: [^self selectRootOfDefaultDirectory].	^self selectDefaultDirectory</body><body package="Tools-File Browser">selectLastOpenDirectory	self maybeSelectDirectoryNamed: OpenFileDialog lastDirectory</body><body package="Tools-File Browser">selectLastSaveDirectory	self maybeSelectDirectoryNamed: SaveFileDialog lastDirectory</body><body package="Tools-File Browser">selectRootOfDefaultDirectory	| item root |	item := DirectoryItem on: Filename defaultDirectory.	root := item withParentDirectories first.	self selectDirectory: root asFilename</body><body package="Tools-File Browser">setOpenFileDirectoryHere	self withSelectedDirectoryFilenameDo:		[:name | OpenFileDialog lastDirectory: name]</body><body package="Tools-File Browser">setSaveFileDirectoryHere	self withSelectedDirectoryFilenameDo:		[:name | SaveFileDialog lastDirectory: name]</body><body package="Tools-File Browser">setupDirectoryTreeWidget	^(builder componentAt: #folders) widget		useImage: #folderTreeIcon		selectedImage: #folderTreeSelectedIcon</body><body package="Tools-File Browser">withSelectedDirectoryDo: aBlock	^self selectedDirectory ifNotNil: [:directory | aBlock value: directory]</body><body package="Tools-File Browser">withSelectedDirectoryFilenameDo: aBlock	^self selectedDirectory ifNotNil: [:directory | aBlock value: directory asFilename]</body></methods><methods><class-id>Tools.FileTools.FileBrowser</class-id> <category>menus</category><body package="Tools-File Browser">addInitialSelectionMenuTo: aMenu	(aMenu atNameKey: #initialSelection) 		submenu: self buildInitialSelectionMenu</body><body package="Tools-File Browser">augmentDirectoryTreeMenu: aMenu	aMenu addPart: self class win32directoryExtras</body><body package="Tools-File Browser">augmentFileListMenuForCurrentFile: aMenu	self withSelectedFilenameDo:		[:name |		(self isFileoutFilename: name) ifTrue:			[aMenu addPart: self class fileoutExtras].		(self isParcelFilename: name) ifTrue:			[aMenu addPart: self class parcelExtras]]</body><body package="Tools-File Browser">augmentMenuBarForCurrentFile: aMenu	| fileMenu |	self withSelectedFilenameDo:		[:name |		(self isFileoutFilename: name) ifTrue:			[fileMenu := (aMenu atNameKey: #file) submenu.			fileMenu addPart: self class fileoutExtras].		(self isParcelFilename: name) ifTrue:			[fileMenu := (aMenu atNameKey: #file) submenu.			fileMenu addPart: self class parcelExtras]]</body><body package="Tools-File Browser">augmentMenuBarForCurrentPlatform: aMenu	| directoryMenu |	directoryMenu := (aMenu atNameKey: #directory) submenu.	directoryMenu addPart: self class win32directoryExtras</body><body package="Tools-File Browser">buildDirectoryTreeMenu	| menu |	menu := self class baseDirectoryTreeMenu.	self augmentDirectoryTreeMenu: menu.	menu 		augmentFrom: self class		to: FileBrowser		menuName: #directoryTree		for: self.	^menu</body><body package="Tools-File Browser">buildFileListMenu	| menu |	menu := self class baseFileListMenu.	self augmentFileListMenuForCurrentFile: menu.	self addEncodingMenuTo: menu.	menu 		augmentFrom: self class		to: FileBrowser		menuName: #fileList		for: self.	^menu</body><body package="Tools-File Browser">buildInitialSelectionMenu	| menu |	menu := self class initialSelectionMenu.	#(none root default) do:		[:each |		(menu atNameKey: each) indication: [InitialSelectionPreference = each]].	^menu</body><body package="Tools-File Browser">directoryTreeMenu	^[self buildDirectoryTreeMenu]</body><body package="Tools-File Browser">fileListMenu	^[self buildFileListMenu]</body><body package="Tools-File Browser">menuBarHolder	^menuBarHolder</body><body package="Tools-File Browser">refreshMenuBar	| menuBar |	menuBar := self class menuBar.	self augmentMenuBarForCurrentPlatform: menuBar.	self augmentMenuBarForCurrentFile: menuBar.	self addEncodingMenuTo: menuBar.	self addInitialSelectionMenuTo: menuBar.	menuBar 		augmentFrom: self class		to: FileBrowser		menuName: #menuBar		for: self.	menuBarHolder value: menuBar</body></methods><methods><class-id>Tools.FileTools.FileBrowser</class-id> <category>state</category><body package="Tools-File Browser">canSelectLastOpenDirectory	^OpenFileDialog lastDirectory notNil</body><body package="Tools-File Browser">canSelectLastSaveDirectory	^SaveFileDialog lastDirectory notNil</body><body package="Tools-File Browser">canSetOpenFileDirectory	^self selectedDirectory notNil</body><body package="Tools-File Browser">canSetSaveFileDirectory	^self selectedDirectory notNil</body><body package="Tools-File Browser">displayingItemViewers	"True when the current collection of viewer tabs is for 	a file or directory item rather than a directory in the directory tree."	^self viewerListHolder list size &gt; 1</body><body package="Tools-File Browser">hasDirectoryInTreeSelected	"This means directory in the tree view."	^self selectedDirectory notNil</body><body package="Tools-File Browser">hasDirectorySelected	^self hasItemSelected and: 		[[self selectedFile asFilename isDirectory]			on: OsError "must be a special file"			do: [:ex | ex return: false]]</body><body package="Tools-File Browser">hasFileoutFileSelected	^self hasFileSelected and:		[self isFileoutFilename: self selectedFile asFilename]</body><body package="Tools-File Browser">hasFileSelected	^self hasItemSelected and: 		[[self selectedFile asFilename isDirectory not]			on: OsError "must be a special file"			do: [:ex | ex return: true]]</body><body package="Tools-File Browser">hasItemSelected	^self selectedFile notNil</body><body package="Tools-File Browser">hasParcelFileSelected	^self hasFileSelected and:		[self isParcelFilename: self selectedFile asFilename]</body><body package="Tools-File Browser">isZoomed	^(self builder componentAt: #folders) widget isVisible not</body><body package="Tools-File Browser">nonDefaultViewerSelected	^self viewerListHolder selectionIndex &gt; 1</body><body package="Tools-File Browser">notDefaultDirectorySelected	^self selectedDirectory isNil or:		[self selectedDirectory asFilename ~= Filename defaultDirectory]</body></methods><methods><class-id>Tools.FileTools.FileBrowser</class-id> <category>miscellaneous</category><body package="Tools-File Browser">aboutVisualWorks	AboutVisualWorksDialog open</body><body package="Tools-File Browser">changeRequest	^[currentViewer changeRequest]		on: Error		do: [:ex | ex return: true]</body><body package="Tools-File Browser">fileSizeString: anInteger	anInteger &lt; 1024 ifTrue:		[^((#x1sBytes &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; bytes')			expandMacrosWith: anInteger printString)].	anInteger &lt; 1048576 ifTrue:		[^((#x1sKB &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; KB')			expandMacrosWith: (anInteger // 1024) printString)].	^((#x1sMB &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; MB')			expandMacrosWith: (anInteger // 1048576) printString)</body><body package="Tools-File Browser">fullUpdate	| selection |	selection := self selectedDirectory.	self directoryTreeHolder selection: nil.	self reloadDirectories.	selection notNil ifTrue:		[self selectDirectory: selection asFilename]</body><body package="Tools-File Browser">helpFileBrowser	'topic:vw.help.tools.fileBrowser' asURI open</body><body package="Tools-File Browser">helpFiles	'topic:vw.help.textFile' asURI open</body><body package="Tools-File Browser">helpTopics	'topic:vw.help.tools.fileBrowser' asURI open</body><body package="Tools-File Browser">refreshToolbar	| toolbar |	builder isNil ifTrue: [^self].	toolbar := builder componentAt: #toolbarMenu.	toolbar isNil ifTrue: [^self].	(toolbar componentAt: #fileEdit) isEnabled: self hasFileSelected.	(toolbar componentAt: #openChanges) isEnabled: self hasFileoutFileSelected.	(toolbar componentAt: #openConflicts) isEnabled: self hasFileoutFileSelected.	(toolbar componentAt: #fileIn) isEnabled: self hasFileoutFileSelected.	(toolbar componentAt: #loadParcel) isEnabled: self hasParcelFileSelected</body><body package="Tools-File Browser">updateStatusBar	self selectedFile notNil ifTrue: 		[^self updateStatusBarForFileSelection].	self selectedDirectory notNil ifTrue:		[^self updateStatusBarForFolderSelection].	self updateStatusBarForNoSelection</body><body package="Tools-File Browser">updateStatusBarForFileSelection	| filename |	filename := self selectedFile asFilename.	self statusTextLeftHolder value: filename asString.	self statusTextRightHolder value: (self fileSizeString: filename fileSize)</body><body package="Tools-File Browser">updateStatusBarForFolderSelection	| filename |	filename := self selectedDirectory asFilename.	self statusTextLeftHolder value: filename asString.	self statusTextRightHolder value: ((#x1sFiles &lt;&lt; #dialogs &gt;&gt; '&lt;1s&gt; files')			expandMacrosWith: self fileListHolder list size printString)</body><body package="Tools-File Browser">updateStatusBarForNoSelection	self statusTextLeftHolder value: String new.	self statusTextRightHolder value: String new</body></methods><methods><class-id>Tools.FileTools.FileBrowser</class-id> <category>initialize-release</category><body package="Tools-File Browser">initialize	super initialize.	menuBarHolder := nil asValue.	encodingChannel := #default asValue.	self directoryTreeHolder selectionIndexHolder		onChangeSend: #directorySelected to: self.	self initializePatterns.	self initializeFiles.	self initializeViewerTabs.	self refreshMenuBar.	self reloadDirectories</body><body package="Tools-File Browser">postBuildWith: aBuilder	self 		setupDirectoryTreeWidget;		setupFileListWidget</body><body package="Tools-File Browser">postOpenWith: aBuilder	self addPatternBox.	Cursor wait showWhile:		[self 			setupViewerTabs;			selectInitialDirectory].</body></methods><methods><class-id>Tools.FileTools.FileBrowser</class-id> <category>menus-encoding</category><body package="Tools-File Browser">addEncodingMenuTo: aMenu	(aMenu atNameKey: #fileEncoding) 		submenu: [self buildEncodingMenu]</body><body package="Tools-File Browser">buildEncodingMenu	^WorkspacePage buildEncodingMenuFor: encodingChannel</body><body package="Tools-File Browser">encodingChannel	^encodingChannel</body><body package="Tools-File Browser">guessEncodingFor: aFilename	^self class encodingFor: aFilename</body></methods><methods><class-id>Tools.FileTools.FileBrowser class</class-id> <category>generated resources</category><body package="Tools-File Browser">changeListConflictsIcon	^ToolbarIconLibrary default enablementVisualFor: #changeListConflicts</body><body package="Tools-File Browser">changeListIcon	^ToolbarIconLibrary default enablementVisualFor: #changeList</body><body package="Tools-File Browser">editIcon	^ToolbarIconLibrary default enablementVisualFor: #edit</body><body package="Tools-File Browser">fileInIcon	^ToolbarIconLibrary default enablementVisualFor: #fileIn</body><body package="Tools-File Browser">loadParcelIcon	^ToolbarIconLibrary default enablementVisualFor: #loadParcel</body></methods><methods><class-id>Tools.FileTools.FileBrowser class</class-id> <category>types/encodings-definitions</category><body package="Tools-File Browser">patternsAndTypesDo: aBlock	(Pragma allNamed: #patterns:priority: in: self class sortedByArgument: 2) reverseDo:		[:each |		aBlock value: (each argumentAt: 1) value: (self perform: each selector)]</body><body package="Tools-File Browser">typesAndEncodingsDo: aBlock	(Pragma allNamed: #encodingFor: in: self class) do:		[:each |		aBlock value: (each argumentAt: 1) value: (self perform: each selector)]</body></methods><methods><class-id>Tools.FileTools.FileBrowser class</class-id> <category>types/encodings-accessing</category><body package="Tools-File Browser">encodingFor: aFilenameOrString	^self encodingForType: (self typeOf: aFilenameOrString)	"self encodingFor: 'foobar.xml' "	"self encodingFor: 'foobar.st' "	"self encodingFor: 'foobar.baz' "</body><body package="Tools-File Browser">encodingForType: aSymbol	self typesAndEncodingsDo:		[:type :encoding |		type = aSymbol ifTrue: [^encoding]].	^#default</body><body package="Tools-File Browser">typeOf: aFilenameOrString	| nameString |	nameString := aFilenameOrString asString.	self patternsAndTypesDo:		[:patterns :type |		(patterns anySatisfy: [:pattern | pattern match: nameString])			ifTrue: [^type]].	^#unknown	"self typeOf: 'foobar.st' "	"self typeOf: 'foobar.txt' "	"self typeOf: 'foo.bar' "</body></methods><methods><class-id>Tools.FileTools.FileBrowser class</class-id> <category>system startup</category><body package="Tools-File Browser">refreshOpenBrowsers	Screen default allScheduledControllersDo: 			[:each | 			(each model isKindOf: self) 				ifTrue: 					[each model						reloadDirectories;						selectInitialDirectory]]</body></methods><methods><class-id>Tools.FileTools.FileBrowser class</class-id> <category>notifications</category><body package="Tools-File Browser">instanceMethodsChanged	Screen default allScheduledControllersDo: 			[:each | 			(each model isKindOf: self) ifTrue: [each model refreshMenuBar]]</body></methods><methods><class-id>Tools.FileTools.FileHexViewer</class-id> <category>private</category><body package="Tools-File Browser">textForEntireFile: aFilename 	| fileStream textStream base |	fileStream := aFilename readStream.	[fileStream binary.	textStream := TextStream on: (String new: 1000).	base := 0.	[fileStream atEnd] whileFalse:		[self writeDataLineFrom: fileStream address: base to: textStream.		base := base + 16]]			ensure: [fileStream close].	^textStream contents</body><body package="Tools-File Browser">textForFileBeginning: aFilename 	| fileStream textStream base |	fileStream := aFilename readStream.	[fileStream binary.	textStream := TextStream on: (String new: 1000).	base := 0.	[fileStream atEnd or: [base &gt; self largeFileThreshold]] whileFalse:		[self writeDataLineFrom: fileStream address: base to: textStream.		base := base + 16]]			ensure: [fileStream close].	textStream emphasis: #italic; nextPutAll: (#RestNotShown &lt;&lt; #dialogs &gt;&gt; '--- rest not shown ---') asString; cr.	^textStream contents</body><body package="Tools-File Browser">writeDataLineFrom: readStream address: baseAddress to: aStream	| readBytes byte |	baseAddress printOn: aStream paddedWith: $0 to: 6 base: 16.	aStream next: 2 put: Character space.	readBytes := OrderedCollection new: 16.	[readBytes size = 16 or: [readStream atEnd]] whileFalse:		[byte := readStream next.		readBytes add: byte.		byte printOn: aStream paddedWith: $0 to: 2 base: 16.		aStream space].	readBytes size &lt; 16 ifTrue:		[(16 - readBytes size) * 3 timesRepeat: [aStream space]].	aStream space.	readBytes do:		[:each | | char |		char := each asCharacter.		(each between: 32 and: 127)			ifTrue: [aStream nextPut: char]			ifFalse: [aStream nextPut: $.]].	aStream cr</body></methods><methods><class-id>Tools.FileTools.FileHexViewer class</class-id> <category>accessing</category><body package="Tools-File Browser">tabLabel	^(#Binary &lt;&lt; #labels &gt;&gt; 'Binary') asString</body><body package="Tools-File Browser">tabPosition	^20</body></methods><methods><class-id>Tools.FileTools.DirectorySelectionDialog</class-id> <category>notifications</category><body package="Tools-File Browser">directorySelectionChanged	(self wrapperAt: #okButton) isEnabled: self selection notNil</body><body package="Tools-File Browser">directoryTreeDoubleClicked	self accept value: true</body></methods><methods><class-id>Tools.FileTools.DirectorySelectionDialog</class-id> <category>initialize-release</category><body package="Tools-File Browser">initialDirectory: aFilename	initialDirectory := aFilename</body><body package="Tools-File Browser">initialize	super initialize.	initialDirectory := Filename defaultDirectory.	self reloadDirectories</body><body package="Tools-File Browser">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self 		setupDirectoryTreeWidget;		directorySelectionChanged</body><body package="Tools-File Browser">postOpenWith: aBuilder	super postOpenWith: aBuilder.	initialDirectory notNil ifTrue:		[self selectDirectory: initialDirectory]</body></methods><methods><class-id>Tools.FileTools.DirectorySelectionDialog</class-id> <category>private</category><body package="Tools-File Browser">reloadDirectories	| model |	model := TreeModel on: TopLevelItem current displayRoot: false.	model hasChildrenBlock: [:item | item hasChildren].	self directoryTreeHolder list: model</body><body package="Tools-File Browser">setupDirectoryTreeWidget	self directoryTreeHolder selectionIndexHolder		onChangeSend: #directorySelectionChanged 		to: self.	^(builder componentAt: #directoryTree) widget		useImage: #folderTreeIcon		selectedImage: #folderTreeSelectedIcon</body></methods><methods><class-id>Tools.FileTools.DirectorySelectionDialog</class-id> <category>accessing</category><body package="Tools-File Browser">expandToDirectory: directoryFilename	| target path treeModel lastExpanded |	target := DirectoryItem on: directoryFilename.	path := target parentDirectories.	treeModel := self directoryTreeHolder list.	lastExpanded := nil.	Cursor wait showWhile:		[path do: [:each |			| index |			index := treeModel indexOf: each.			index = 0 ifTrue: [^lastExpanded].			treeModel expand: index.			lastExpanded := each]].	^target</body><body package="Tools-File Browser">selectDirectory: directoryFilename	| lastKnownDirectoryItem |	lastKnownDirectoryItem := self expandToDirectory: directoryFilename.	self directoryTreeHolder selection: lastKnownDirectoryItem</body><body package="Tools-File Browser">selection	^self directoryTreeHolder selection</body></methods><methods><class-id>Tools.FileTools.DirectorySelectionDialog</class-id> <category>aspects</category><body package="Tools-File Browser">directoryTreeHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^directoryTreeHolder isNil		ifTrue:			[directoryTreeHolder := SelectionInTree new]		ifFalse:			[directoryTreeHolder]</body></methods><methods><class-id>Tools.FileTools.DirectorySelectionDialog</class-id> <category>testing</category><body package="Tools-File Browser">directorySelected	^self selection notNil</body></methods><methods><class-id>Tools.FileTools.DirectorySelectionDialog</class-id> <category>actions</category><body package="Tools-File Browser">createSubdirectory	| newName newFilename directory |	newName := Dialog request: (#NewDirectoryNameColon &lt;&lt; #dialogs &gt;&gt; 'New directory name:').	newName isEmpty ifTrue: [^self].	directory := self selection.	newFilename := directory asFilename construct: newName.	newFilename makeDirectory.	directory refresh.	self directoryTreeHolder list refresh: directory.	self selectDirectory: newFilename</body></methods><methods><class-id>Tools.FileTools.DirectorySelectionDialog class</class-id> <category>utilities</category><body package="Tools-File Browser">choose	"Open a new instance with the current directory pre-selected.	Answer a filename with the user's selection or nil if the dialog was cancelled."	"self choose"	^self chooseInitially: Filename defaultDirectory</body><body package="Tools-File Browser">chooseInitially: aFilenameOrString	"Open a new instance with the given directory pre-selected.	Answer a filename with the user's selection or nil if the dialog was cancelled."	| instance  |	instance := self new.	instance initialDirectory: aFilenameOrString asFilename.	^instance open		ifTrue: [instance selection asString]		ifFalse: [nil]</body></methods><methods><class-id>Tools.FileTools.XMLSourceWalkerAccumulatorState</class-id> <category>initialize-release</category><body package="Tools-File Browser">acceptSelector: aSymbol	acceptSelector := aSymbol</body><body package="Tools-File Browser">initialize: aWalker	super initialize: aWalker.	characters := WriteStream on: (String new: 100).	nestLevel := 0</body></methods><methods><class-id>Tools.FileTools.XMLSourceWalkerAccumulatorState</class-id> <category>accessing</category><body package="Tools-File Browser">contents	^characters contents</body></methods><methods><class-id>Tools.FileTools.XMLSourceWalkerAccumulatorState</class-id> <category>dispatching</category><body package="Tools-File Browser">characters: aString	characters nextPutAll: aString</body><body package="Tools-File Browser">end: tagString	"Any embedded tags are ignored and their contents	are assimilated."	tagString = tag ifTrue: 		[nestLevel = 0			ifTrue: [self leave]			ifFalse: [nestLevel := nestLevel - 1]]</body><body package="Tools-File Browser">leave	walker leaveState.	acceptSelector notNil 		ifTrue: [walker perform: acceptSelector with: self]</body><body package="Tools-File Browser">start: tagString	"Any embedded tags are ignored and their character data	are accumulated."	tagString = tag ifTrue: [nestLevel := nestLevel + 1]</body></methods><methods><class-id>Tools.FileTools.XMLSourceWalkerAccumulatorState class</class-id> <category>instance creation</category><body package="Tools-File Browser">for: aWalker acceptSelector: aSymbol	^(self for: aWalker) acceptSelector: aSymbol</body></methods><methods><class-id>Tools.FileTools.XMLSourceWalkerTopState</class-id> <category>dispatching</category><body package="Tools-File Browser">end: tagString	tagString = 'st-source' ifTrue: [^walker leaveState].	self signalUnexpectedElement: tagString</body><body package="Tools-File Browser">start: tagString	tagString = 'time-stamp' ifTrue: [^walker enterTimeStampState].	tagString = 'copyright' ifTrue: [^walker enterCopyrightState].	tagString = 'class' ifTrue: [^walker enterClassState]. 	tagString = 'name-space' ifTrue: [^walker enterNameSpaceState]. 	tagString = 'shared-variable' ifTrue: [^walker enterSharedVarState]. 	tagString = 'comment' ifTrue: [^walker enterCommentState].	tagString = 'methods' ifTrue: [^walker enterMethodsState].	tagString = 'initialize' ifTrue: [^walker enterInitializeState].	tagString = 'remove' ifTrue: [^walker enterRemoveState].	tagString = 'remove-selector' ifTrue: [^walker enterRemoveSelectorState].	tagString = 'rename' ifTrue: [^walker enterRenameState].	tagString = 'relocate' ifTrue: [^walker enterRelocateState].	tagString = 'reorganize' ifTrue: [^walker enterReorganizeState].	tagString = 'reorganize-data' ifTrue: [^walker enterReorganizeDataState].	tagString = 'do-it' ifTrue: [^walker enterDoItState].	self signalUnexpectedElement: tagString.	^walker enterBogusState</body></methods><methods><class-id>Tools.FileTools.TopLevelItem</class-id> <category>accessing</category><body package="Tools-File Browser">add: anItem	roots := roots copyWith: anItem</body><body package="Tools-File Browser">children		^roots</body><body package="Tools-File Browser">hasChildren	^roots notEmpty</body></methods><methods><class-id>Tools.FileTools.TopLevelItem</class-id> <category>initialize-release</category><body package="Tools-File Browser">roots: aCollection	roots := aCollection</body></methods><methods><class-id>Tools.FileTools.TopLevelItem class</class-id> <category>private</category><body package="Tools-File Browser">sorted: itemCollection	^(itemCollection asSortedCollection:		[:a :b | a displayString &lt;= b displayString])			asArray</body></methods><methods><class-id>Tools.FileTools.TopLevelItem class</class-id> <category>instance creation</category><body package="Tools-File Browser">current	"self current"	| volumeItems |	volumeItems := Filename volumes collect:						(OSHandle isMSWindows							"On Windows short-cut file-system attribute collection for speed.  We don't need it here."							ifTrue: [[:each | SpecialDirectoryItem on: (FATFilename new named: each asLowercase)]]							ifFalse: [[:each | DirectoryItem on: (Filename named: each)]]).	^self new roots: (self sorted: volumeItems)</body></methods><methods><class-id>Tools.FileTools.XMLSourceWalker</class-id> <category>states-entering</category><body package="Tools-File Browser">enterAccumulatorState	self enterState: (XMLSourceWalkerAccumulatorState for: self)</body><body package="Tools-File Browser">enterBogusState	"The state that silently consumes the current and all contained tags."	self enterState: (XMLSourceWalkerAccumulatorState for: self)</body><body package="Tools-File Browser">enterClassState	self enterState: 		(XMLSourceWalkerDefinitionState 			for: self 			acceptSelector: #leftClass:)</body><body package="Tools-File Browser">enterCollectorState	self enterState: (XMLSourceWalkerCollectorState for: self)</body><body package="Tools-File Browser">enterCommentState	self enterState: 		(XMLSourceWalkerCollectorState 			for: self 			acceptSelector: #leftComment:)</body><body package="Tools-File Browser">enterCopyrightState	self enterState: 		(XMLSourceWalkerAccumulatorState			for: self			acceptSelector: #leftCopyright:)</body><body package="Tools-File Browser">enterDoItState	self enterState: 		(XMLSourceWalkerAccumulatorState			for: self 			acceptSelector: #leftDoIt:)</body><body package="Tools-File Browser">enterInitializeState	self enterState: 		(XMLSourceWalkerCollectorState			for: self			acceptSelector: #leftInitialize:)</body><body package="Tools-File Browser">enterMethodsState	self enterState: 		(XMLSourceWalkerCollectorState 			for: self 			acceptSelector: #leftMethods:)</body><body package="Tools-File Browser">enterNameSpaceState	self enterState: 		(XMLSourceWalkerDefinitionState 			for: self 			acceptSelector: #leftNameSpace:)</body><body package="Tools-File Browser">enterRelocateState	self enterState: 		(XMLSourceWalkerCollectorState			for: self			acceptSelector: #leftRelocate:)</body><body package="Tools-File Browser">enterRemoveSelectorState	self enterState: 		(XMLSourceWalkerCollectorState			for: self			acceptSelector: #leftRemoveSelector:)</body><body package="Tools-File Browser">enterRemoveState	self enterState: 		(XMLSourceWalkerCollectorState			for: self			acceptSelector: #leftRemove:)</body><body package="Tools-File Browser">enterRenameState	self enterState: 		(XMLSourceWalkerCollectorState			for: self			acceptSelector: #leftRename:)</body><body package="Tools-File Browser">enterReorganizeDataState	self enterState: 		(XMLSourceWalkerCollectorState			for: self			acceptSelector: #leftReorganizeData:)</body><body package="Tools-File Browser">enterReorganizeState	self enterState: 		(XMLSourceWalkerCollectorState			for: self			acceptSelector: #leftReorganize:)</body><body package="Tools-File Browser">enterSharedVarState	self enterState: 		(XMLSourceWalkerDefinitionState 			for: self 			acceptSelector: #leftSharedVar:)</body><body package="Tools-File Browser">enterTimeStampState	"&lt;!ELEMENT time-stamp (#PCDATA)&gt;"	self enterState:		(XMLSourceWalkerAccumulatorState 			for: self 			acceptSelector: #leftTimeStamp:)</body><body package="Tools-File Browser">enterTopLevelState	self enterState: (XMLSourceWalkerTopState for: self)</body></methods><methods><class-id>Tools.FileTools.XMLSourceWalker</class-id> <category>states-leaving</category><body package="Tools-File Browser">leftClass: aClassState	"&lt;!ELEMENT class (name, environment?, super, private?, indexed-type, inst-vars?, class-inst-vars?, imports?, attributes?)&gt;"	client 		acceptClass: (aClassState contentsAt: 'name')		superclass: (aClassState contentsAt: 'super')		environment: (aClassState contentsAt: 'environment' ifAbsent: [nil])		private: (aClassState contentsAt: 'private' ifAbsent: [nil])		indexedType: (aClassState contentsAt: 'indexed-type')		instVars: (aClassState contentsAt: 'inst-vars' ifAbsent: [nil])		classInstVars: (aClassState contentsAt: 'class-inst-vars' ifAbsent: [nil])		imports: (aClassState contentsAt: 'imports' ifAbsent: [nil])		attributes: (self attributesFrom: aClassState)</body><body package="Tools-File Browser">leftComment: aCollectorState	"&lt;!ELEMENT comment (%all-objects; , body)&gt;"	| commentedObject |	commentedObject := aCollectorState elements first.	client 		acceptComment: (aCollectorState contentsOrBlankAt: 'body')		of: commentedObject tag		named: commentedObject contents</body><body package="Tools-File Browser">leftCopyright: anAccumulatorState	"&lt;!ELEMENT copyright (#PCDATA)&gt;"	client acceptCopyright: anAccumulatorState contents</body><body package="Tools-File Browser">leftDoIt: anActionState	"A &lt;do-it&gt; element has ended in the source. The argument is the	state that accepted it."	client acceptDoIt: anActionState contents</body><body package="Tools-File Browser">leftInitialize: aCollectorState	"A &lt;initialize&gt; element has ended in the source. The argument is the	state that accepted it."	| object |	object := aCollectorState elements first.	client acceptInitialize: object contents ofType: object tag</body><body package="Tools-File Browser">leftMethods: aCollectorState	"&lt;!ELEMENT methods (class-id, properties?, (body | note)*)&gt;"	| elementStream classElement properties bodies |	elementStream := ReadStream on: aCollectorState elements.	classElement := elementStream next.	properties := Dictionary new.	[elementStream peek tag ~= 'body'] whileTrue:		[ | element |		element := elementStream next.		properties at: element tag put: element contents].	bodies := OrderedCollection new.	[elementStream atEnd] whileFalse:		[bodies add: elementStream next contents].	client 		acceptMethodsFor: classElement contents		properties: properties		bodies: bodies</body><body package="Tools-File Browser">leftNameSpace: aClassState	"&lt;!ELEMENT name-space (name, environment?, private?, imports?, properties?)&gt;"	client 		acceptNameSpace: (aClassState contentsAt: 'name')		environment: (aClassState contentsAt: 'environment' ifAbsent: [nil])		private: (aClassState contentsAt: 'private' ifAbsent: [nil])		imports: (aClassState contentsAt: 'imports' ifAbsent: [nil])		attributes: (self attributesFrom: aClassState)</body><body package="Tools-File Browser">leftRelocate: aCollectorState	"&lt;!ELEMENT relocate (%all-statics; , environment)&gt;"	| object environment |	object := aCollectorState elements at: 1.	environment := aCollectorState elements at: 2.	client 		acceptRelocate: object contents 		to: environment contents</body><body package="Tools-File Browser">leftRemove: aCollectorState	"&lt;!ELEMENT remove %all-statics; &gt;"	| object |	object := aCollectorState element first.	client acceptRemove: object contents ofType: object tag</body><body package="Tools-File Browser">leftRemoveSelector: aCollectorState	"&lt;!ELEMENT remove-selector (class-id, selector)&gt;"	| classId selector |	classId := aCollectorState elements at: 1.	selector := aCollectorState elements at: 2.	client 		acceptRemoveSelector: selector contents 		inClass: classId contents</body><body package="Tools-File Browser">leftRename: aCollectorState	"&lt;!ELEMENT rename (%all-statics; , name)&gt;"	| object name |	object := aCollectorState elements at: 1.	name := aCollectorState elements at: 2.	client 		acceptRename: object contents 		to: name contents</body><body package="Tools-File Browser">leftReorganize: aCollectorState	"&lt;!ELEMENT reorganize (class-id, organization)&gt;	&lt;!ELEMENT organization (#PCDATA)&gt;"	| classId organization |	classId := aCollectorState elements at: 1.	organization := aCollectorState elements at: 2.	client 		acceptReorganize: classId contents 		using: organization contents</body><body package="Tools-File Browser">leftReorganizeData: aCollectorState	"&lt;!ELEMENT reorganize-data ((class-id | name-space-id), organization)&gt;	&lt;!ELEMENT organization (#PCDATA)&gt;"	| data organization |	data := aCollectorState elements at: 1.	organization := aCollectorState elements at: 2.	client 		acceptReorganizeData: data contents 		using: organization contents</body><body package="Tools-File Browser">leftSharedVar: aClassState	"&lt;!ELEMENT shared-variable (name, environment, private?, constant?, initializer?)&gt;"	client 		acceptSharedVar: (aClassState contentsAt: 'name')		environment: (aClassState contentsAt: 'environment')		private: (aClassState contentsAt: 'private' ifAbsent: [nil])		constant: (aClassState contentsAt: 'constant' ifAbsent: [nil])		initializer: (aClassState contentsAt: 'initializer' ifAbsent: [nil])		attributes: (self attributesFrom: aClassState)</body><body package="Tools-File Browser">leftTimeStamp: anActionState	"&lt;!ELEMENT time-stamp (#PCDATA)&gt;"	client acceptTimeStamp: anActionState contents</body></methods><methods><class-id>Tools.FileTools.XMLSourceWalker</class-id> <category>SAX dispatch</category><body package="Tools-File Browser">characters: aString	self currentState characters: aString</body><body package="Tools-File Browser">comment: data from: start to: stop	self currentState xmlComment: (data copyFrom: start to: stop)</body><body package="Tools-File Browser">endElement: namespaceURI localName: localName qName: name	currentTag := name trimBlanks.	self currentState end: currentTag</body><body package="Tools-File Browser">startElement: namespaceURI localName: localName qName: name attributes: attributes	currentTag := name trimBlanks.	self currentState start: currentTag</body></methods><methods><class-id>Tools.FileTools.XMLSourceWalker</class-id> <category>privileged</category><body package="Tools-File Browser">acceptXMLComment: aString	client acceptGeneralComment: aString</body><body package="Tools-File Browser">attributesFrom: aState	| attributeElement attributes |	attributeElement := aState elementWithTag: 'attributes' ifAbsent: [^nil].	attributes := OrderedCollection new.	attributeElement elements do: 		[:each | 		attributes add: (Array with: each tag asSymbol with: (self elementDataFor: each))].	^attributes asArray</body><body package="Tools-File Browser">currentState	^states last</body><body package="Tools-File Browser">currentTag	^currentTag</body><body package="Tools-File Browser">enterState: aState	states addLast: aState</body><body package="Tools-File Browser">leaveState	states removeLast</body></methods><methods><class-id>Tools.FileTools.XMLSourceWalker</class-id> <category>initialize-release</category><body package="Tools-File Browser">initialize: anObject	client := anObject.	states := OrderedCollection with: (XMLSourceWalkerInitialState for: self)</body></methods><methods><class-id>Tools.FileTools.XMLSourceWalker</class-id> <category>private</category><body package="Tools-File Browser">elementDataFor: element	| type |	type := element tag.	(#('beVirtual' 'optimizationLevel' 'includeFiles' 'includeDirectories' 'libraryFiles' 'libraryDirectories') includes: type)		ifFalse: [^element contents]		ifTrue: 			[(#('includeFiles' 'includeDirectories' 'libraryFiles' 'libraryDirectories') includes: type)				ifTrue: [^(element contents tokensBasedOn: Character space) asArray]				ifFalse: 					[type = 'beVirtual' ifTrue: [^Boolean fromString: element contents].					type = 'optimizationLevel' ifTrue: [^element contents asSymbol]]]</body></methods><methods><class-id>Tools.FileTools.XMLSourceWalker class</class-id> <category>instance creation</category><body package="Tools-File Browser">on: anObject	^self new initialize: anObject</body></methods><methods><class-id>Tools.FileTools.XMLSourceWalkerNotification</class-id> <category>accessing</category><body package="Tools-File Browser">state	^state</body><body package="Tools-File Browser">state: anObject	state := anObject</body></methods><methods><class-id>Tools.FileTools.XMLSourceWalkerDefinitionState</class-id> <category>dispatching</category><body package="Tools-File Browser">start: tagString	tagString = 'attributes'		ifTrue: [walker enterCollectorState]		ifFalse: [walker enterAccumulatorState].	elements add: walker currentState</body></methods><methods><class-id>Tools.FileTools.SourceFormatter</class-id> <category>private</category><body package="Tools-File Browser">asReadableName: tagString	"Convert an XML tag string into a readable name."	tagString = 'class-id' ifTrue: [^(#class &lt;&lt; #dialogs &gt;&gt; 'class') asString].	^tagString</body><body package="Tools-File Browser">isSpecified: aStringOrNil	^aStringOrNil notNil and: [aStringOrNil trimBlanks isEmpty not]</body><body package="Tools-File Browser">mergedEmphasis: emphasis	currentEmphasis isNil ifTrue: [^emphasis].	^(currentEmphasis isKindOf: Array)		ifTrue:			[(emphasis isKindOf: Array)				ifTrue: [emphasis, currentEmphasis] 				ifFalse: [currentEmphasis copyWith: emphasis]]		ifFalse:			[(emphasis isKindOf: Array)				ifTrue: [emphasis copyWith: currentEmphasis]				ifFalse: [Array with: emphasis with: currentEmphasis]]</body><body package="Tools-File Browser">printIndentedLabel: aUserMessageOrString object: anObject	output		tab;		emphasis: #italic;		nextPutAll: aUserMessageOrString asString;		nextPutAll: ':';		emphasis: nil;		space;		print: anObject;		cr</body><body package="Tools-File Browser">printIndentedLabel: aUserMessageOrString string: anotherString	output		tab;		emphasis: #italic;		nextPutAll: aUserMessageOrString asString;		nextPutAll: ':';		emphasis: nil;		space;		nextPutAll: anotherString;		cr</body><body package="Tools-File Browser">printIndentedLabelForArray: aUserMessageOrString object: anObject	output		tab;		emphasis: #italic;		nextPutAll: aUserMessageOrString asString;		nextPutAll: ':';		emphasis: nil;		space;		printArray: anObject;		cr</body><body package="Tools-File Browser">printMethod: aString inClassNamed: nameString	| sourceText |	sourceText := aString asText 		makeSelectorBoldIn: (self targetClassForName: nameString).	output		nextPutAllText: sourceText;		cr; cr</body><body package="Tools-File Browser">targetClassForName: nameString	^[nameString asQualifiedReference value]		on: Error		do: [:ex | ex return: Object]</body><body package="Tools-File Browser">withEmphasis: emphasis do: aBlock	| oldEmphasis |	oldEmphasis := currentEmphasis.	currentEmphasis := self mergedEmphasis: emphasis.	^[output emphasis: currentEmphasis.	aBlock value]		ensure: 			[currentEmphasis := oldEmphasis.			output emphasis: currentEmphasis]</body></methods><methods><class-id>Tools.FileTools.SourceFormatter</class-id> <category>writing</category><body package="Tools-File Browser">break	output cr; cr</body><body package="Tools-File Browser">cr	output cr</body><body package="Tools-File Browser">print: anObject	"Print an object with the current emphasis."	output print: anObject</body><body package="Tools-File Browser">space	output space</body><body package="Tools-File Browser">tab	output tab</body><body package="Tools-File Browser">write: aStringOrNil	"Write a string with the current emphasis; treat nils as blanks."	aStringOrNil notNil ifTrue:		[output nextPutAll: aStringOrNil asString]</body></methods><methods><class-id>Tools.FileTools.SourceFormatter</class-id> <category>initialize-release</category><body package="Tools-File Browser">output: aWriteStream	output := aWriteStream.	currentEmphasis := nil</body></methods><methods><class-id>Tools.FileTools.SourceFormatter</class-id> <category>accepting</category><body package="Tools-File Browser">acceptClass: nameString superclass: superString environment: envStringOrNil private: privateStringOrNil indexedType: typeString instVars: varStringOrNil classInstVars: classVarStringOrNil imports: importsStringOrNil attributes: attributesArrayOrNil	| fullName |	fullName := (self isSpecified: envStringOrNil)		ifTrue: [envStringOrNil, '.', nameString]		ifFalse: [nameString].	self withEmphasis: #underline do:		[self write: (#Class &lt;&lt; #dialogs &gt;&gt; 'Class ').		self withEmphasis: #bold do: [self write: fullName]].	self break.	self 		printIndentedLabel: (#Superclass &lt;&lt; #dialogs &gt;&gt; 'Superclass') string: superString;		printIndentedLabel: (#Type &lt;&lt; #dialogs &gt;&gt; 'Type') string: typeString.	(self isSpecified: varStringOrNil) ifTrue:		[self printIndentedLabel: (#InstanceVariables &lt;&lt; #dialogs &gt;&gt; 'Instance variables') string: varStringOrNil].	(self isSpecified: classVarStringOrNil) ifTrue:		[self printIndentedLabel: (#ClassInstanceVariables &lt;&lt; #dialogs &gt;&gt; 'Class instance variables') string: classVarStringOrNil].	(self isSpecified: importsStringOrNil) ifTrue:		[self printIndentedLabel: (#Imports &lt;&lt; #dialogs &gt;&gt; 'Imports') string: importsStringOrNil].	attributesArrayOrNil notNil ifTrue:		[self printIndentedLabelForArray: (#Attributes &lt;&lt; #dialogs &gt;&gt; 'Attributes') object: attributesArrayOrNil].	self cr</body><body package="Tools-File Browser">acceptComment: aString of: tagString named: nameString	self withEmphasis: #underline do:		[self withEmphasis: #bold do: [self write: nameString].		self write: (#Comment &lt;&lt; #dialogs &gt;&gt; ' comment') asString].	self 		break;		write: aString;		break</body><body package="Tools-File Browser">acceptCopyright: aString	self		write: (#CopyrightC &lt;&lt; #dialogs &gt;&gt; 'Copyright: ');		write: aString;		break</body><body package="Tools-File Browser">acceptDoIt: sourceString	self 		withEmphasis: #(bold underline) do: [self write: (#DoIt &lt;&lt; #labels &gt;&gt; 'Do It')];		break;		write: sourceString;		break</body><body package="Tools-File Browser">acceptGeneralComment: aString	self 		withEmphasis: #italic do: [self write: aString];		cr</body><body package="Tools-File Browser">acceptInitialize: aString ofType: tagString	self withEmphasis: #italic do:		[self			write: (#Initialize &lt;&lt; #dialogs &gt;&gt; 'Initialize ');			write: (self asReadableName: tagString);			space;			withEmphasis: #bold do:				[self write: aString]].	self break</body><body package="Tools-File Browser">acceptMethodsFor: classNameString properties: propertyDictionary bodies: stringCollection	| protocol |	protocol := propertyDictionary at: 'category' ifAbsent: [nil].	self withEmphasis: #underline do:		[self 			withEmphasis: #bold do: [self write: classNameString];			write: (protocol isNil				ifTrue: [(#Methods1 &lt;&lt; #dialogs &gt;&gt; ' methods')]				ifFalse: [((#MethodsFor1s &lt;&lt; #dialogs &gt;&gt; ' methods for ''&lt;1s&gt;''')			expandMacrosWith: protocol)]);			break].	stringCollection do:		[:each | self printMethod: each inClassNamed: classNameString]</body><body package="Tools-File Browser">acceptNameSpace: nameStringenvironment: envStringOrNilprivate: privateStringOrNilimports: importsStringOrNilattributes: attributesArrayOrNil	| fullName private |	fullName := (self isSpecified: envStringOrNil)		ifTrue: [envStringOrNil, '.', nameString]		ifFalse: [nameString].	self withEmphasis: #underline do:		[self 			write: (#Namespace &lt;&lt; #dialogs &gt;&gt; 'Namespace ');			withEmphasis: #bold do: [self write: fullName]].	self break.	private := (privateStringOrNil isNil or: [privateStringOrNil trimBlanks isEmpty])		ifTrue: ['false']		ifFalse: [privateStringOrNil].	self printIndentedLabel: (#Private &lt;&lt; #dialogs &gt;&gt; 'Private') string: private.	(self isSpecified: importsStringOrNil) ifTrue:		[self printIndentedLabel: (#Imports &lt;&lt; #dialogs &gt;&gt; 'Imports') string: importsStringOrNil].	attributesArrayOrNil notNil ifTrue:		[self printIndentedLabel: (#Attributes &lt;&lt; #dialogs &gt;&gt; 'Attributes') object: attributesArrayOrNil].	self cr</body><body package="Tools-File Browser">acceptRelocate: objectNameString to: environmentString	self withEmphasis: #italic do:		[self 			write: (#Move &lt;&lt; #dialogs &gt;&gt; 'Move ');			withEmphasis: #bold do:				[self write: (self asReadableName: objectNameString)];			write: (#ToNamespace &lt;&lt; #dialogs &gt;&gt; ' to namespace ');			withEmphasis: #bold do:				[self write: environmentString];			break]</body><body package="Tools-File Browser">acceptRemove: aString ofType: tagString	self withEmphasis: #italic do:		[self 			write: (#Remove &lt;&lt; #dialogs &gt;&gt; 'Remove ');			write: (self asReadableName: tagString);			space;			withEmphasis: #bold do: [self write: aString]].	self break</body><body package="Tools-File Browser">acceptRemoveSelector: aString inClass: classNameString	self withEmphasis: #italic do:		[self 			write: (#RemoveMethod &lt;&lt; #dialogs &gt;&gt; 'Remove method ');			withEmphasis: #bold do:				[self					write: classNameString;					write: '&gt;&gt;';					write: aString]].	self break</body><body package="Tools-File Browser">acceptRename: objectNameString to: newNameString	self withEmphasis: #italic do:		[self			write: (#Rename1 &lt;&lt; #dialogs &gt;&gt; 'Rename ');			withEmphasis: #bold do:				[self write: objectNameString];			write: (#To &lt;&lt; #dialogs &gt;&gt; ' to ');			withEmphasis: #bold do:				[self write: newNameString]].	self break</body><body package="Tools-File Browser">acceptReorganize: classNameString using: organizationString	self withEmphasis: #italic do:		[self			write: (#ReorganizeClass &lt;&lt; #dialogs &gt;&gt; 'Reorganize class ');			withEmphasis: #bold do:				[self write: classNameString]].	self break</body><body package="Tools-File Browser">acceptReorganizeData: classNameString using: organizationString	self withEmphasis: #italic do:		[self			write: (#Reorganize &lt;&lt; #dialogs &gt;&gt; 'Reorganize ');			withEmphasis: #bold do: 				[self write: classNameString]].	self break</body><body package="Tools-File Browser">acceptSharedVar: nameStringenvironment: envStringprivate: privateStringOrNilconstant: constantStringOrNilinitializer: initializerStringOrNilattributes: attributesArrayOrNil	| fullName private constant |	fullName := envString, '.', nameString.	self withEmphasis: #underline do:		[self 			write: (#SharedVariable &lt;&lt; #dialogs &gt;&gt; 'Shared Variable ');			withEmphasis: #bold do: [self write: fullName]].	self break.	private := (privateStringOrNil isNil or: [privateStringOrNil trimBlanks isEmpty])		ifTrue: ['false']		ifFalse: [privateStringOrNil].	self printIndentedLabel: (#Private &lt;&lt; #dialogs &gt;&gt; 'Private') string: private.	constant := (constantStringOrNil isNil or: [constantStringOrNil trimBlanks isEmpty])		ifTrue: ['false']		ifFalse: [constantStringOrNil].	self printIndentedLabel: (#Constant &lt;&lt; #dialogs &gt;&gt; 'Constant') string: constant.	(self isSpecified: initializerStringOrNil) ifTrue:		[self printIndentedLabel: (#Initializer &lt;&lt; #dialogs &gt;&gt; 'Initializer') object: initializerStringOrNil].	attributesArrayOrNil notNil ifTrue:		[self printIndentedLabel: (#Attributes &lt;&lt; #dialogs &gt;&gt; 'Attributes') object: attributesArrayOrNil].	self cr</body><body package="Tools-File Browser">acceptTimeStamp: aString	self 		withEmphasis: #bold do: [self write: aString];		break</body></methods><methods><class-id>Tools.FileTools.SourceFormatter class</class-id> <category>instance creation</category><body package="Tools-File Browser">on: aWriteStream	^self new output: aWriteStream</body></methods><methods><class-id>Tools.FileTools.FileInformationViewer</class-id> <category>accessing</category><body package="Tools-File Browser">print: aString value: aBlock on: aStream	| value |	value := [aBlock value]		on: Error		do: [:ex | ex return: '?'].	aStream		emphasis: #bold;		nextPutAll: aString asString;		emphasis: nil;		nextPutAll: ':'; tab;		nextPutAll:  value;		cr</body><body package="Tools-File Browser">printBlurbFor: aFilename on: stream	self		print: (#Path &lt;&lt; #labels &gt;&gt; 'Path') value: [aFilename asString] on: stream;		print: (#Size &lt;&lt; #labels &gt;&gt; 'Size') value: [aFilename fileSize printString] on: stream;		print: (#Created &lt;&lt; #labels &gt;&gt; 'Created') value: [self timestampStringAt: #created in: aFilename dates] on: stream;		print: (#LastModified &lt;&lt; #labels &gt;&gt; 'Last modified') value: [self timestampStringAt: #modified in: aFilename dates] on: stream;		print: (#LastAccessed &lt;&lt; #labels &gt;&gt; 'Last accessed') value: [self timestampStringAt: #accessed in: aFilename dates] on: stream</body><body package="Tools-File Browser">timestampStringAt: aSymbol in: aDictionary	| array |	array := aDictionary at: aSymbol.	^array first printString, ' ', array last printString</body></methods><methods><class-id>Tools.FileTools.FileInformationViewer class</class-id> <category>accessing</category><body package="Tools-File Browser">isInterestedInFile: aFilename 	^true</body><body package="Tools-File Browser">tabLabel	^(#FileInformation &lt;&lt; #labels &gt;&gt; 'File Information') asString</body><body package="Tools-File Browser">tabPosition	^100</body></methods><methods><class-id>Tools.FileTools.XMLSourceWalkerInitialState</class-id> <category>dispatching</category><body package="Tools-File Browser">end: tagString	self signalUnexpectedElement: tagString</body><body package="Tools-File Browser">start: tagString	tagString = 'st-source' ifTrue: [^walker enterTopLevelState].	self signalUnexpectedElement: tagString</body></methods><methods><class-id>Tools.FileTools.SpecialDirectoryItem</class-id> <category>initialize-release</category><body package="Tools-File Browser">initialize: aPlatformFilename 	avoidHasChildrenQuery := self isPotentiallySlow: aPlatformFilename.	super initialize: aPlatformFilename</body><body package="Tools-File Browser">name: aString	name := aString</body></methods><methods><class-id>Tools.FileTools.SpecialDirectoryItem</class-id> <category>printing</category><body package="Tools-File Browser">displayString	^name isNil		ifTrue: [filename asString asUppercase]		ifFalse: [name]</body></methods><methods><class-id>Tools.FileTools.SpecialDirectoryItem</class-id> <category>accessing</category><body package="Tools-File Browser">parent	^nil</body><body package="Tools-File Browser">parentFilename	self shouldNotImplement</body></methods><methods><class-id>Tools.FileTools.SpecialDirectoryItem</class-id> <category>private</category><body package="Tools-File Browser">isPotentiallySlow: aPlatformFilename 	^'ab\' includes: aPlatformFilename asString first asLowercase</body><body package="Tools-File Browser">privateHasSubdirectories	^avoidHasChildrenQuery or: [super privateHasSubdirectories]</body></methods><methods><class-id>Tools.FileTools.DirectoryContentsViewer</class-id> <category>accessing</category><body package="Tools-File Browser">printBlurbFor: aFilename on: stream	aFilename directoryContents asSortedStrings do:		[:filenameString | | filename |		filename := aFilename construct: filenameString.		self printFilename: filename on: stream.		stream cr]</body><body package="Tools-File Browser">printDirectory: aFilename on: aStream	aStream		emphasis: #bold;		nextPutAll: aFilename tail;		emphasis: nil;		tab;		nextPutAll: (#directory &lt;&lt; #dialogs &gt;&gt; '[directory]') asString;		space;		print: aFilename modificationTimestamp</body><body package="Tools-File Browser">printFile: aFilename on: aStream	aStream		emphasis: #bold;		nextPutAll: aFilename tail;		emphasis: nil;		tab;		nextPut: $[;		print: aFilename fileSize;		nextPutAll: '] ';		print: aFilename modificationTimestamp</body><body package="Tools-File Browser">printFilename: aFilename on: aStream	[aFilename isDirectory		ifTrue: [self printDirectory: aFilename on: aStream]		ifFalse: [self printFile: aFilename on: aStream]]			on: OsError			do: [:ex |				aStream print: ex.				ex return]</body></methods><methods><class-id>Tools.FileTools.DirectoryContentsViewer class</class-id> <category>accessing</category><body package="Tools-File Browser">isInterestedInFile: aFilename	^[aFilename isDirectory]		on: OsError		do: [:ex | ex return: false]</body><body package="Tools-File Browser">tabLabel	^(#DirectoryContents &lt;&lt; #labels &gt;&gt; 'Directory Contents') asString</body><body package="Tools-File Browser">tabPosition	^5</body></methods><methods><class-id>Tools.FileTools.FileItem</class-id> <category>accessing</category><body package="Tools-File Browser">children	^Array new</body><body package="Tools-File Browser">matches: patternString	^patternString match: filename tail</body></methods><methods><class-id>Tools.FileTools.FileItem</class-id> <category>testing</category><body package="Tools-File Browser">isDirectory	^false</body></methods><methods><class-id>Tools.FileTools.FileItem</class-id> <category>visuals</category><body package="Tools-File Browser">icon	| tail |	tail := filename tail.	(#('*.st' '*.pst' '*.cha') anySatisfy: [:pattern | pattern match: tail]) 		ifTrue: [^ListIconLibrary visualFor: #textPage].	('*.pcl' match: tail) 		ifTrue: [^ListIconLibrary visualFor: #loadedParcel].	^ListIconLibrary visualFor: #blankPage</body></methods><methods><class-id>Tools.FileTools.FileViewer class</class-id> <category>resources</category><body package="Tools-File Browser">readOnlyCodeMenu	"Tools.MenuEditor new openOnClass: self andSelector: #readOnlyCodeMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_DoIt 					#defaultString: '&amp;Do it' 					#catalogID: #menus ) 				#value: #doIt 				#command: #doIt				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #doIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_InspectIt 					#defaultString: '&amp;Inspect it' 					#catalogID: #menus ) 				#value: #inspectIt 				#command: #inspectIt				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #inspectIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #De_bugIt 					#defaultString: 'De&amp;bug it' 					#catalogID: #menus ) 				#value: #debugIt 				#command: #debugIt				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #debugIt ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Copy 					#defaultString: '&amp;Copy' 					#catalogID: #menus ) 				#value: #copySelection 				#command: #copy				#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #copy ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FindDots 					#defaultString: '&amp;Find...' 					#catalogID: #menus ) 				#value: #find				#command: #find ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindAgain 					#defaultString: 'Find Again' 					#catalogID: #menus ) 				#value: #findNext				#command: #findNext ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Select_All 					#defaultString: 'Select &amp;All' 					#catalogID: #menus ) 				#value: #selectEntireText				#command: #selectAll ) ) #(3 1 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.FileTools.FileContentsViewer class</class-id> <category>interface specs</category><body package="Tools-File Browser">fullTextSpec	"UIPainter new openOnClass: self andSelector: #fullTextSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 1024 768 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 912 584 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #text 					#model: #fullTextHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#okToSaveTextFor: ) 					#isReadOnly: false 					#tabRequiresControl: true ) ) ) )</body><body package="Tools-File Browser">previewSpec	"UIPainter new openOnClass: self andSelector: #previewSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 1024 768 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 912 584 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 0 1 120 24 ) 					#name: #showAllButton 					#model: #loadEntireFile 					#helpText: #largeFileMessage 					#label: #(#{Kernel.UserMessage} #key: #ShowEntireFile #defaultString: 'Show Entire File' #catalogID: #labels) 					#defaultable: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 25 0 0 1 0 1 ) 					#name: #text 					#model: #previewTextHolder 					#menu: #readOnlyCodeMenu 					#isReadOnly: true 					#tabRequiresControl: true ) ) ) )</body><body package="Tools-File Browser">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 1024 768 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 912 584 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #view 					#flags: 0 ) ) ) )</body></methods><methods><class-id>Tools.FileTools.XMLSourceViewer class</class-id> <category>interface specs</category><body package="Tools-File Browser">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 512 384 712 584 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #text 					#model: #textHolder 					#menu: #readOnlyCodeMenu 					#isReadOnly: true 					#tabRequiresControl: true ) ) ) )</body></methods><methods><class-id>Tools.FileTools.FileBlurbViewer class</class-id> <category>interface specs</category><body package="Tools-File Browser">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 512 384 992 688 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #text 					#model: #textHolder 					#isReadOnly: true 					#tabRequiresControl: true ) ) ) )</body></methods><methods><class-id>Tools.FileTools.XMLTreeViewer class</class-id> <category>resources</category><body package="Tools-File Browser">nodeMenu	"MenuEditor new openOnClass: self andSelector: #nodeMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #InspectNode #defaultString: 'Inspect Node' #catalogID: #menus) 				#value: #inspectNode ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.FileTools.XMLTreeViewer class</class-id> <category>interface specs</category><body package="Tools-File Browser">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#bounds: #(#{Graphics.Rectangle} 512 384 985 667 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TreeViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 0.4 0 1 ) 					#name: #nodeTree 					#model: #nodeTreeHolder 					#menu: #nodeMenu 					#useModifierKeys: true 					#selectionType: #highlight 					#displayStringSelector: #simpleDescription 					#rootExpander: true ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.4 0 0 3 0.4 0 1 ) 					#name: #splitter 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'nodeTree' 					#belowWidgets: 'text' ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.4 0 0 0 1 0 1 ) 					#name: #text 					#model: #textHolder 					#menu: #readOnlyCodeMenu 					#isReadOnly: true 					#tabRequiresControl: true ) ) ) )</body></methods><methods><class-id>Tools.FileTools.FileBrowser class</class-id> <category>resources</category><body package="Tools-File Browser">baseDirectoryTreeMenu	"MenuEditor new openOnClass: self andSelector: #baseDirectoryTreeMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #CreateDot #defaultString: '&amp;Create...' #catalogID: #menus) 				#value: #createSubdirectory 				#enablementSelector: #hasDirectoryInTreeSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Re_nameDot #defaultString: 'Re&amp;name...' #catalogID: #menus) 				#value: #renameDirectory 				#enablementSelector: #hasDirectoryInTreeSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_RemoveDot #defaultString: '&amp;Remove...' #catalogID: #menus) 				#value: #removeDirectory 				#enablementSelector: #hasDirectoryInTreeSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Re_fresh #defaultString: 'Re&amp;fresh' #catalogID: #menus) 				#value: #refreshDirectory 				#enablementSelector: #hasDirectoryInTreeSelected 				#shortcutKeyCharacter: #F5 				#shortcutModifiers: 0 ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_CopyName #defaultString: '&amp;Copy Name' #catalogID: #menus) 				#value: #copyDirectoryFilename 				#enablementSelector: #hasDirectoryInTreeSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Inspect #defaultString: '&amp;Inspect' #catalogID: #menus) 				#value: #inspectDirectoryFilename 				#enablementSelector: #hasDirectoryInTreeSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #GoToDot #defaultString: '&amp;Go to...' #catalogID: #menus) 				#value: #goToDirectory 				#shortcutKeyCharacter: $G 				#shortcutModifiers: 8 ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #GoToDefault #defaultString: 'Go to &amp;Default' #catalogID: #menus) 				#value: #selectDefaultDirectory 				#enablementSelector: #notDefaultDirectorySelected ) ) #(3 3 2 ) nil ) decodeAsLiteralArray</body><body package="Tools-File Browser">baseFileListMenu	"MenuEditor new openOnClass: self andSelector: #baseFileListMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_NewDot #defaultString: '&amp;New...' #catalogID: #menus) 				#nameKey: #create 				#value: #createFile ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Re_nameDot #defaultString: 'Re&amp;name...' #catalogID: #menus) 				#value: #renameFileOrDirectory 				#enablementSelector: #hasItemSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_RemoveDot #defaultString: '&amp;Remove...' #catalogID: #menus) 				#value: #removeFileOrDirectory 				#enablementSelector: #hasItemSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #CopyDot #defaultString: '&amp;Copy...' #catalogID: #menus) 				#nameKey: #copy 				#value: #copyFile 				#enablementSelector: #hasFileSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Encoding #defaultString: '&amp;Encoding' #catalogID: #menus) 				#nameKey: #fileEncoding ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #C_opyName #defaultString: 'C&amp;opy Name' #catalogID: #menus) 				#value: #copyFilename 				#enablementSelector: #hasItemSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #InspectFilename #defaultString: '&amp;Inspect Filename' #catalogID: #menus) 				#value: #inspectFilename 				#enablementSelector: #hasItemSelected ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Edit #defaultString: '&amp;Edit' #catalogID: #menus) 				#value: #fileEdit 				#enablementSelector: #hasFileSelected 				#shortcutKeyCharacter: $E 				#shortcutModifiers: 8 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.FileTools.FileBrowser} #editIcon ) ) ) #(4 1 2 1 ) nil ) decodeAsLiteralArray</body><body package="Tools-File Browser">fileoutExtras	"Tools.MenuEditor new openOnClass: self andSelector: #fileoutExtras"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_OpenInChangeList 					#defaultString: '&amp;Open in Change List' 					#catalogID: #menus ) 				#value: #openChanges 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.FileTools.FileBrowser} #changeListIcon ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_CompareWithSystem 					#defaultString: '&amp;Compare with System' 					#catalogID: #menus ) 				#value: #openConflicts 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.FileTools.FileBrowser} #changeListConflictsIcon ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_FileIn 					#defaultString: '&amp;File In' 					#catalogID: #menus ) 				#value: #fileIn 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.FileTools.FileBrowser} #fileInIcon ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FileIntoNewChangeSetDot 					#defaultString: 'File into &amp;New Change Set...' 					#catalogID: #menus ) 				#value: #fileIntoNewChangeSet ) ) #(2 2 ) nil ) decodeAsLiteralArray</body><body package="Tools-File Browser">initialSelectionMenu	"MenuEditor new openOnClass: self andSelector: #initialSelectionMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #DefaultDirectory #defaultString: '&amp;Default Directory' #catalogID: #menus) 				#nameKey: #default 				#value: #initiallySelectDefault ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #RootOfDefaultDirectory #defaultString: '&amp;Root of Default Directory' #catalogID: #menus) 				#nameKey: #root 				#value: #initiallySelectRootOfDefault ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #None #defaultString: '&amp;None' #catalogID: #menus) 				#nameKey: #none 				#value: #initiallySelectNone ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="Tools-File Browser">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Directory 					#defaultString: '&amp;Directory' 					#catalogID: #menus ) 				#nameKey: #directory 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_NewDot 								#defaultString: '&amp;New...' 								#catalogID: #menus ) 							#value: #createSubdirectory 							#enablementSelector: #hasDirectoryInTreeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_RenameDot 								#defaultString: '&amp;Rename...' 								#catalogID: #menus ) 							#value: #renameDirectory 							#enablementSelector: #hasDirectoryInTreeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Re_moveDot 								#defaultString: 'Re&amp;move...' 								#catalogID: #menus ) 							#value: #removeDirectory 							#enablementSelector: #hasDirectoryInTreeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Re_fresh 								#defaultString: 'Re&amp;fresh' 								#catalogID: #menus ) 							#value: #refreshDirectory 							#enablementSelector: #hasDirectoryInTreeSelected 							#shortcutKeyCharacter: #F5 							#shortcutModifiers: 0 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #refreshFolder ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_CopyName 								#defaultString: '&amp;Copy Name' 								#catalogID: #menus ) 							#value: #copyDirectoryFilename 							#enablementSelector: #hasDirectoryInTreeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Inspect 								#defaultString: '&amp;Inspect' 								#catalogID: #menus ) 							#value: #inspectDirectoryFilename 							#enablementSelector: #hasDirectoryInTreeSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #GoTo_DefaultDirectory 								#defaultString: 'Go to &amp;Default Directory' 								#catalogID: #menus ) 							#value: #selectDefaultDirectory 							#enablementSelector: #notDefaultDirectorySelected 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #goToDefaultFolder ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #GoToDot 								#defaultString: '&amp;Go to...' 								#catalogID: #menus ) 							#value: #goToDirectory 							#shortcutKeyCharacter: $G 							#shortcutModifiers: 8 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #goToFolder ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #InitialSelection 								#defaultString: '&amp;Initial Selection' 								#catalogID: #menus ) 							#nameKey: #initialSelection ) ) #(3 3 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #menus ) 				#nameKey: #file 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_NewDot 								#defaultString: '&amp;New...' 								#catalogID: #menus ) 							#nameKey: #create 							#value: #createFile ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_RenameDot 								#defaultString: '&amp;Rename...' 								#catalogID: #menus ) 							#value: #renameFileOrDirectory 							#enablementSelector: #hasItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Re_moveDot 								#defaultString: 'Re&amp;move...' 								#catalogID: #menus ) 							#value: #removeFileOrDirectory 							#enablementSelector: #hasItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CopyDot 								#defaultString: '&amp;Copy...' 								#catalogID: #menus ) 							#nameKey: #copy 							#value: #copyFile 							#enablementSelector: #hasFileSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Encoding 								#defaultString: '&amp;Encoding' 								#catalogID: #menus ) 							#nameKey: #fileEncoding ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #C_opyName 								#defaultString: 'C&amp;opy Name' 								#catalogID: #menus ) 							#value: #copyFilename 							#enablementSelector: #hasItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Inspect 								#defaultString: '&amp;Inspect' 								#catalogID: #menus ) 							#value: #inspectFilename 							#enablementSelector: #hasItemSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Edit 								#defaultString: '&amp;Edit' 								#catalogID: #menus ) 							#nameKey: #fileEdit 							#value: #fileEdit 							#enablementSelector: #hasFileSelected 							#shortcutKeyCharacter: $E 							#shortcutModifiers: 8 							#labelImage: #(#{UI.ResourceRetriever} #{FileBrowser} #editIcon ) ) ) #(4 1 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_View 					#defaultString: '&amp;View' 					#catalogID: #menus ) 				#nameKey: #view 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RefreshAll 								#defaultString: '&amp;Refresh All' 								#catalogID: #menus ) 							#value: #fullUpdate 							#shortcutKeyCharacter: #F5 							#shortcutModifiers: 8 ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Zoom 								#defaultString: '&amp;Zoom' 								#catalogID: #menus ) 							#nameKey: #viewZoom 							#value: #toggleZoom 							#shortcutKeyCharacter: $Z 							#shortcutModifiers: 8 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #zoom ) ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #menus ) 				#nameKey: #help 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FileBrowser 								#defaultString: 'File &amp;Browser' 								#catalogID: #menus ) 							#value: #helpFileBrowser 							#shortcutKeyCharacter: #F1 							#shortcutModifiers: 0 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #help ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AboutFiles 								#defaultString: '&amp;Files' 								#catalogID: #menus ) 							#value: #helpFiles ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_AboutVisualWorksDot 								#defaultString: '&amp;About VisualWorks...' 								#catalogID: #menus ) 							#value: #aboutVisualWorks ) ) #(2 1 ) nil ) ) ) #(4 ) nil ) decodeAsLiteralArray</body><body package="Tools-File Browser">parcelExtras	"MenuEditor new openOnClass: self andSelector: #parcelExtras"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #_Load #defaultString: '&amp;Load' #catalogID: #menus) 				#value: #loadParcel 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #loadParcel ) ) ) #(1 ) nil ) decodeAsLiteralArray</body><body package="Tools-File Browser">toolbarMenu	"MenuEditor new openOnClass: self andSelector: #toolbarMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #GoToDefaultDirectory #defaultString: 'Go to Default Directory' #catalogID: #menus) 				#value: #selectDefaultDirectory 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #goToDefaultFolder ) 				#helpText: #(#{Kernel.UserMessage} #key: #GoToImageDefaultDirectory #defaultString: 'Go to image default directory' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #GoToDirectory #defaultString: 'Go to Directory...' #catalogID: #menus) 				#value: #goToDirectory 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #goToFolder ) 				#helpText: #(#{Kernel.UserMessage} #key: #GoToDirectoryHelp #defaultString: 'Go to directory...' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Refresh #defaultString: 'Refresh' #catalogID: #menus) 				#value: #refreshDirectory 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #refreshFolder ) 				#helpText: #(#{Kernel.UserMessage} #key: #RefreshTheCurrentDirectory #defaultString: 'Refresh the current directory' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #OpenFile #defaultString: 'Open...' #catalogID: #menus) 				#nameKey: #fileEdit 				#value: #fileEdit 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.FileTools.FileBrowser} #editIcon ) 				#helpText: #(#{Kernel.UserMessage} #key: #OpenFileInAWorkspace #defaultString: 'Open file in a Workspace' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #OpenChanges #defaultString: 'Open Changes' #catalogID: #menus) 				#nameKey: #openChanges 				#value: #openChanges 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.FileTools.FileBrowser} #changeListIcon ) 				#helpText: #(#{Kernel.UserMessage} #key: #OpenFileInAChangeList #defaultString: 'Open file in a Change List' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #OpenConflicts #defaultString: 'Open Conflicts' #catalogID: #menus) 				#nameKey: #openConflicts 				#value: #openConflicts 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.FileTools.FileBrowser} #changeListConflictsIcon ) 				#helpText: #(#{Kernel.UserMessage} #key: #CompareFileUsingChangeList #defaultString: 'Compare file to the system in a Change List' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #FileIn1 #defaultString: 'File In' #catalogID: #menus) 				#nameKey: #fileIn 				#value: #fileIn 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.FileTools.FileBrowser} #fileInIcon ) 				#helpText: #(#{Kernel.UserMessage} #key: #FileIn #defaultString: 'File in' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #ParcelIn #defaultString: 'Parcel in' #catalogID: #menus) 				#nameKey: #loadParcel 				#value: #loadParcel 				#enablementSelector: #hasParcelFileSelected 				#labelImage: #(#{UI.ResourceRetriever} #{Tools.FileTools.FileBrowser} #loadParcelIcon ) 				#helpText: #(#{Kernel.UserMessage} #key: #LoadParcel #defaultString: 'Load parcel' #catalogID: #menus) ) 			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #Zoom #defaultString: 'Zoom' #catalogID: #menus) 				#value: #toggleZoom 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #zoom ) 				#helpText: #(#{Kernel.UserMessage} #key: #ZoomOrUnzoom #defaultString: 'Zoom or unzoom' #catalogID: #menus) ) ) #(3 3 2 1 ) nil ) decodeAsLiteralArray</body><body package="Tools-File Browser">win32directoryExtras	"MenuEditor new openOnClass: self andSelector: #win32directoryExtras"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: #(#{Kernel.UserMessage} #key: #FileDialogDirectories #defaultString: '&amp;File Dialog Directories' #catalogID: #menus) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #GoToDefaultOpenLocation #defaultString: 'Go to Default &amp;Open Location' #catalogID: #menus) 							#value: #selectLastOpenDirectory 							#enablementSelector: #canSelectLastOpenDirectory ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #GoToDefaultSaveLocation #defaultString: 'Go to Default &amp;Save Location' #catalogID: #menus) 							#value: #selectLastSaveDirectory 							#enablementSelector: #canSelectLastSaveDirectory ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #MakeThisDefaultOpenLocation #defaultString: '&amp;Make this Default Open Location' #catalogID: #menus) 							#value: #setOpenFileDirectoryHere 							#enablementSelector: #canSetOpenFileDirectory ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #MakeThisDefaultSaveLocation #defaultString: 'Ma&amp;ke this Default Save Location' #catalogID: #menus) 							#value: #setSaveFileDirectoryHere 							#enablementSelector: #canSetSaveFileDirectory ) ) #(2 2 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.FileTools.FileBrowser class</class-id> <category>interface specs</category><body package="Tools-File Browser">filePatternSpec	"UIPainter new openOnClass: self andSelector: #filePatternSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #FileBrowserPattern 				#defaultString: '' 				#catalogID: #labels ) 			#min: #(#{Core.Point} 518 64 ) 			#max: #(#{Core.Point} 518 64 ) 			#bounds: #(#{Graphics.Rectangle} 506 384 1024 448 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 80 0 0 0 0 1 25 0 ) 					#name: #pattern 					#model: #patternHolder 					#isReadOnly: false 					#comboList: #patternChoices ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 75 0 24 0 1 1 ) 					#name: #label 					#label: #(#{Kernel.UserMessage} #key: #ShowFilesColon #defaultString: 'Show Files:' #catalogID: #labels) ) ) ) )</body><body package="Tools-File Browser">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #FileBrowser 				#defaultString: 'File Browser' 				#catalogID: #labels ) 			#min: #(#{Core.Point} 300 200 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 224 168 1024 768 ) 			#flags: 4 			#menu: #menuBarHolder 			#toolBar: #toolbarMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TreeViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 -1 0.32 -23 1 ) 					#name: #folders 					#flags: 15 					#model: #directoryTreeHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: #changeRequest ) 					#menu: #directoryTreeMenu 					#useModifierKeys: true 					#selectionType: #highlight 					#useIcons: #other 					#iconSelectors: #(#folderTreeIcon ) 					#rootExpander: true ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} -1 0.32 0 0 2 0.32 -23 1 ) 					#name: #splitter1 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'folders' 					#belowWidgets: 'files splitter2 viewers' ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.32 0 0 0 1 -1 0.4 ) 					#name: #files 					#model: #fileListHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: 						#fileListDoubleClicked: 						#requestValueChangeSelector: #changeRequest ) 					#menu: #fileListMenu ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.32 0 0.4 0 1 3 0.4 ) 					#name: #splitter2 					#horizontal: true 					#minAboveSize: 40 					#minBelowSize: 25 					#aboveWidgets: 'files' 					#belowWidgets: 'viewers' ) 				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.32 3 0.4 0 1 -23 1 ) 					#name: #viewers 					#model: #viewerListHolder 					#labels: #() ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -23 1 -200 1 0 1 ) 					#name: #statusBarLeft 					#model: #statusTextLeftHolder 					#tabable: false 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} -200 1 -23 1 0 1 0 1 ) 					#name: #statusBarRight 					#model: #statusTextRightHolder 					#tabable: false 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>Tools.FileTools.FileBrowser class</class-id> <category>types/encodings-definitions</category><body package="Tools-File Browser">sourceEncoding	"See #typeAndEncodingPragmas method comment for the explanation	of how file type patterns and encoding definitions work together."	&lt;encodingFor: #source&gt;	^#Source</body><body package="Tools-File Browser">sourceFiles	"See #typeAndEncodingPragmas method comment for the explanation	of how file type patterns and encoding definitions work together."	&lt;patterns: #('*.sou' '*.st' '*.cha' '*.chb' '*.ste' '*.app' '*.ws' '*.pst') priority: 1&gt;	^#source</body><body package="Tools-File Browser">textEncoding	"See #typeAndEncodingPragmas method comment for the explanation	of how file type patterns and encoding definitions work together."	&lt;encodingFor: #text&gt;	^#default</body><body package="Tools-File Browser">textFiles	"See #typeAndEncodingPragmas method comment for the explanation	of how file type patterns and encoding definitions work together."	&lt;patterns: #('*.txt' '*.text') priority: 1&gt;	^#text</body><body package="Tools-File Browser">typeAndEncodingPragmas	"Most of the methods in this protocol define file types and encodings to be used	for those types. This mechanism is similar to the one used in the old browser. Unlike	the old browser, types and encodings are defined using pragma methods, so that	new types and encodings can be defined by extending packages.	A file type is a symbol such as #source. To find out the type of a file, send the message	#typeOf: to this class, passing a Filename or a filename String as the argument. A type	is determined from the file name using a set of patterns. Patterns are defined as methods	on the class side of this class. Pattern definition methods have a #patterns:priority: pragma.	The first argument of this pragma is an array of strings, each string being a pattern (typically	with wildcards). A filename matches the type defined by a method if it matches any of the	patterns listed in the pragma. The method returns a Symbol which is the identifier of the type.	For example, see any of the *File methods in this protocol. 	For multiple file type definition methods, matching is performed in the descending order of their	#priority: pragma argument. For example, patterns in a method with the pragma		&lt;patterns: #('*.xml') priority: 1&gt;	are tried before patterns in a method with the pragma		&lt;patterns: #('*') priority: 0&gt;	and therefore a file named 'foo.xml' is considered to be of the type defined by the first method	even though it would match both patterns.	Default file type definitions in this class use priority 1 for the patterns that select specific file types	such as #source or #xml, and priority 0 for a catch-all rule that recognizes anything not matched	by any specific rule as file type #unknown.  To override any of these default file type definitions,	mark your own patterns with a priority higher than 1. For example, a method with the body		&lt;patterns: #('*.ws') priority: 2&gt;		^#workspace	would assign type #workspace to *.ws files, even though they are already recognized as	#source files by one of the default rules.	Encoding to be used when displaying the contents of a file is determined from the file type	according to type-to-encoding mappings defined as methods marked with an #encodingFor:	pragma.  The pragma names the file type, and the method answers the name of the	default encoding to be used for files of that type.  For example, see any of the *Encoding	methods in this protocol.	To find out the encoding to use for a specific type, send the message #encodingForType:	to this class. To find out the encoding for a file name (in a Filename or a String form),	use the message #encodingFor:."	&lt;pragmas: #class&gt;	^#(patterns:priority: encodingFor:)</body><body package="Tools-File Browser">unknownEncoding	"See #typeAndEncodingPragmas method comment for the explanation	of how file type patterns and encoding definitions work together."	&lt;encodingFor: #unknown&gt;	^#default</body><body package="Tools-File Browser">unknownFiles	"See #typeAndEncodingPragmas method comment for the explanation	of how file type patterns and encoding definitions work together."	&lt;patterns: #('*') priority: 0&gt;	^#unknown</body><body package="Tools-File Browser">xmlEncoding	"See #typeAndEncodingPragmas method comment for the explanation	of how file type patterns and encoding definitions work together."	&lt;encodingFor: #xml&gt;	^#UTF_8</body><body package="Tools-File Browser">xmlFiles	"See #typeAndEncodingPragmas method comment for the explanation	of how file type patterns and encoding definitions work together."	&lt;patterns: #('*.xml') priority: 1&gt;	^#xml</body></methods><methods><class-id>Tools.FileTools.FileHexViewer class</class-id> <category>interface specs</category><body package="Tools-File Browser">fullTextSpec	"UIPainter new openOnClass: self andSelector: #fullTextSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 1024 768 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 912 584 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #text 					#flags: 15 					#model: #fullTextHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#textAcceptAllowed: ) 					#style: #fixed 					#isReadOnly: true 					#tabRequiresControl: true 					#isWrapped: false ) ) ) )</body><body package="Tools-File Browser">previewSpec	"UIPainter new openOnClass: self andSelector: #previewSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{Kernel.UserMessage} #key: #UnlabeledCanvas #defaultString: 'Unlabeled Canvas' #catalogID: #labels) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 1024 768 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 912 584 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 0 1 120 24 ) 					#name: #showAllButton 					#model: #loadEntireFile 					#helpText: #largeFileMessage 					#label: #(#{Kernel.UserMessage} #key: #ShowEntireFile #defaultString: 'Show Entire File' #catalogID: #labels) 					#defaultable: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 25 0 0 1 0 1 ) 					#name: #text 					#flags: 15 					#model: #previewTextHolder 					#style: #fixed 					#isReadOnly: true 					#tabRequiresControl: true 					#isWrapped: false ) ) ) )</body></methods><methods><class-id>Tools.FileTools.DirectorySelectionDialog class</class-id> <category>interface specs</category><body package="Tools-File Browser">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #DirectorySelection 				#defaultString: 'Directory Selection' 				#catalogID: #labels ) 			#min: #(#{Core.Point} 346 396 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 700 525 1046 921 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TreeViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -45 1 ) 					#name: #directoryTree 					#flags: 15 					#model: #directoryTreeHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #directoryTreeDoubleClicked ) 					#menu: #directoryTreeMenu 					#useModifierKeys: true 					#selectionType: #highlight 					#useIcons: #other 					#iconSelectors: #(#folderTreeIcon ) 					#rootExpander: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -175 1 -35 1 -95 1 -10 1 ) 					#name: #okButton 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #labels ) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 -35 1 -10 1 -10 1 ) 					#name: #cancelButton 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #labels ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.FileTools.DirectorySelectionDialog class</class-id> <category>resources</category><body package="Tools-File Browser">directoryTreeMenu	"Tools.MenuEditor new openOnClass: self andSelector: #directoryTreeMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #CreateDirectoryDots 					#defaultString: 'Create Directory...' 					#catalogID: #menus ) 				#nameKey: #createSubdirectory 				#value: #createSubdirectory 				#enablementSelector: #directorySelected 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #CreateANewSubDirectory 					#defaultString: 'Create a new sub directory' 					#catalogID: #menus ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - launcher</category><body package="Tools-File Browser">openFileBrowserCommand	&lt;command: #openFileBrowser&gt;	^Command		label: (#_FileBrowser &lt;&lt; #menus &gt;&gt; '&amp;File Browser')		group: #launcher		bindings: #(			isMSWindows #(F2)			isMacOSX #(F2)			isX11 #(F2)		)</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - tools</category><body package="Tools-File Browser">menuItemOpenFileBrowser	&lt;vwPrivileged&gt;	&lt;menuItemForCommand: #openFileBrowser		icon: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #fileBrowser )		nameKey: nil		menu: #(#menuBar #tools)		position: 10.2&gt;	self openApplicationForClassNamed: #{Tools.FileTools.FileBrowser}</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>toolbar</category><body package="Tools-File Browser">toolbarItemOpenFileBrowser	&lt;vwPrivileged&gt;	&lt;menuItemForCommand: #openFileBrowser		icon: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #fileBrowser )		nameKey: nil		menu: #(#launcherToolBar)		position: 1000.1		helpText: #(#OpenAFileBrowser #menus 'Open a File Browser')&gt;	self openApplicationForClassNamed: #{Tools.FileTools.FileBrowser}</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>SAXDriver</name><environment>XML</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>locator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>XML-SAX</category><attributes><package>XML</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>