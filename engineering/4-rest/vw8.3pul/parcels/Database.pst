<?xml version="1.0"?><st-source><!-- Name: DatabaseNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: VisualWorks Database support is provided in several packages. This package (Database) provides the External database interface framework (EXDI) that other packages (OracleEXDI, PostgreSQL3EXDI, SQLite3EXDI, CTLibEXDI, CTLibEXDI, etc) need to interact with relational databases.Further information on the EXDI framework can be found in the 'Database Application Developer's Guide' (located in the /doc subdirectory of the VisualWorks installation).DbIdentifier: bear73DbTrace: 499199DbUsername: dwallenDbVersion: 8.3 - 2DevelopmentPrerequisites: #(#(#any 'Database-Namespace' ''))PackageName: DatabaseParcel: #('Database')ParcelName: DatabasePrerequisiteParcels: #(#('Database-Namespace' ''))PrintStringCache: (8.3 - 2,dwallen)Version: 8.3 - 2Date: 1:40:46 PM March 17, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (mar17.2) of March 10, 2017 on March 17, 2017 at 1:40:46 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ExternalDatabaseException</name><environment>Database</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseException</class-id><body>ExternalDatabaseException is raised in case of the external database common errors.  Note that, despite its name, it is a subclass of Error on the VisualWorks side, although usable to report occurrences that need not all be errors from the point of view of the external database.</body></comment><class><name>ExternalDatabaseLibraryInaccessible</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseLibraryInaccessible</class-id><body>ExternalDatabaseLibraryInaccessible is used to indicate that a driver is not able to access the database library.  Either the OE does not contain the database library or it cannot be found in the search	path for dynamic link libraries.</body></comment><class><name>ExternalDatabaseResumableException</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseResumableException</class-id><body>ExternalDatabaseResumableException is a super class of the external database resumable exceptions.</body></comment><class><name>UnableToFreeResource</name><environment>Database</environment><super>Database.ExternalDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToFreeResource</class-id><body>UnableToFreeResource is used to indicate that an external resource could not be released/dropped/free'd.</body></comment><class><name>RequiredUsername</name><environment>Database</environment><super>Database.ExternalDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.RequiredUsername</class-id><body>RequiredUsername is used to indicate that a username is required in order to connect. This signal is proceedable and expects a username string as the proceedWith: value.</body></comment><class><name>UnableToQueryDriverInformation</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToQueryDriverInformation</class-id><body>UnableToQueryDriverInformation is used to indicate that driver information could not be queried.</body></comment><class><name>ExternalDatabaseBuffer</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseType encoding elementSize count bufferPointer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseBuffer</class-id><body>ExternalDatabaseBuffer is a private, abstract class used by ExternalDatabaseSessionto represent and manage an external database buffer, and to translate between alimited set of Smalltalk objects and their external database specific representationin the buffer.Subclasses extend ExternalDatabaseBuffer to deal with particular databases.Instance variables:	databaseType &lt;Object&gt;		The type of data that the buffer will contain.  The interpretation of this		is subclass dependent.	encoding &lt;Symbol&gt;		The encoding that Strings will be subjected to.	elementSize	&lt;SmallInteger&gt;		The maximum length of a single data item.	count	&lt;SmallInteger&gt;		The cardinality of (number of item slots in) the buffer.  A count of zero		indicates that the buffer will hold a scalar value.	bufferPointer	&lt;nil | CPointer&gt;		When allocated, the CPointer that "holds" the buffer.Subclasses must implement the following messages	instance protocol		accessing			at:			at:put:</body></comment><class><name>UnableToCancelCursor</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToCancelCursor</class-id><body>UnableToCancelCursor is used to indicate that an Oracle cursor could not be canceled.  This signal is not proceedable.</body></comment><class><name>ConnectionException</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ConnectionException</class-id><body>ConnectionException is raised to indicate problems in the ANSI-2 	exception class named connection exception.</body></comment><class><name>InvalidTableName</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.InvalidTableName</class-id><body>InvalidTableName is used to indicate that the query specified an invalid table name</body></comment><class><name>CouldNotResolveServiceName</name><environment>Database</environment><super>Database.ConnectionException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.CouldNotResolveServiceName</class-id><body>CouldNotResolveServiceName is raised to indicate that the service (or TNS alias) specified when trying to connect does not exist</body></comment><class><name>UnableToAllocateHandle</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToAllocateHandle</class-id><body>UnableToAllocateHandle is used to indicate that a handle could not be allocated.</body></comment><class><name>UnableToDestroyConnectionPool</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>ExternalDatabaseFramework</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stateHolder traceStream traceLevel participants participantsSemaphore </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseFramework</class-id><body>Class ExternalDatabaseFramework is an abstract class defining common services for the implementation of the external database interface.  Applications never use this class directly.The external database interface defines application-visible services and is composed of abstract classes.  To access a database, a driver is used.  Each driver is a set of concrete classes which implement the external database interface services by making calls to a specific database interface library.  A driver may also extend the services available to the application in order to provide features which are unique to that database library.The interface divides overall services into connections, sessions, answer streams, and column descriptions.  Each of these concepts is represented by a class.  ExternalDatabaseConnection defines transaction and connection management services. ExternalDatabaseSession defines services for preparing and executing SQL statements. ExternalDatabaseAnswerStream defines services for processing the answer set of a SELECT statement. ExternalDatabaseColumnDescription defines information which describes a column of a table or answer set.  ExternalDatabaseTransaction is used by the connection to handle  transaction services, but is not directly utilized by application programmers using the external database interface.  As a naming convention, the driver-specific subclasses of the above abstract classes will have the driver name as a prefix in the class name in place of "ExternalDatabase".ExternalDatabaseFramework services:	1) registration for active instances of a subclass (used when holding external handles)	2) a framework for finalization	3) a signal dictionary for all signals	4) a framework for trace output collection and generation	5) a framework for activation control (pause and resume)	6) a collection of participants (see below for definition of participation)	7) a framework for preparing trace entriesRegistry:	The basic design of the external database interface requires every driver class that holds external resources have a registry.  It is assumed that: 1) the holder of external resources is registered whenever it holds that external resource or is paused (see the ExternalDatabaseConnection class for the definition of pause and resume); and 2) that the executors hold strong references only to handles, the state of the object, and parent objects.Participation:	An application uses instances of several external database interface classes which have specific relationships according to their role. The relationships comprise a hierarchy where one or more instances of a class *lower* in the hierarchy are said to *participate* in the context defined by an instance of the class *above* them.  For instance, a session is said to participate in a connection.  Participation is recorded in a weak array that is the size of the number of participants.  The array is weak to facilitate the automatic release of external resources when instances of the external database interface classes are no longer used.Instance variables:	stateHolder &lt;ValueHolder on: Symbol&gt;		Holds the current state.  Legal states are defined by the subclasses.	traceStream	&lt;WriteStream on: String&gt;		A private stream used for preparing complex trace entries.	traceLevel  &lt;SmallInteger&gt;		The trace level, copied from the class side on instance creation.  If zero, tracing		is disabled.	participants	&lt;WeakArray&gt;		Holds references to participating (subordinate) external database objects.		Used to propogate operations downward when multiple objects must cooperate		to provide a function.	participantsSemaphore	&lt;RecursionLock&gt;		Used for mutual exclusion protection on uses of the participants array.Class variables:	TraceLevel			&lt;SmallInteger&gt;		The current tracing level for the class.	TraceCollector		&lt;nil | TextCollector | Stream&gt;		nil =&gt; do not output the trace.	TraceSequencer		&lt;RecursionLock&gt;		Use for mutual exclusion to ensure that trace entries are not interleaved.Subclasses must implement the following messages	instance protocol		private-finalization			key		private-library calls			acquireExternal			dismissExternal			class protocol		accessing			connectionClass		private-registry			registry:Notation:	Assume:			a pre-condition for a method.	Enforce:			a pre-condition that is enforced by raising an exception.	Enforce-quietly:	a pre-condition that is enforced and the method is a no-op.	Assert:			a condition that must be met in the middle of a method.	Assure:			a post-condition which is guaranteed on method completion.</body></comment><class><name>ExternalDatabaseConnection</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transaction username password environment transactionCoordinator cachedSession isolationLevel encoding </inst-vars><class-inst-vars>environmentMap xif xifMap dependents </class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseConnection</class-id><body>ExternalDatabaseConnection is the abstract class defining database connection services.The maximum number of active connections is controlled by the driver.All drivers are required to support coordinated transactions.  If full atomic behavior is not available, it is simulated with a serial broadcast commit on each participating connection.  A two-phase commit protocol would ensure true coordination for commits and rollbacks.Implementation Details:Participation relationships:	An instance of the connection subclasses will participate in an instance of the	transaction subclass.  An instance of the session subclass will participate	in an instance of the connection subclass.Inherited instance variables:	stateHolder			&lt;ValueHolder on: (#new | #xactNo | #xactYes | #paused)&gt;		The state variable is used to track the legal operations on connections.	traceStream		&lt;WriteStream on: String&gt;		A private stream used for preparing complex trace entries.	traceLevel  &lt;SmallInteger&gt;		The trace level, copied from the class side on instance creation.  If zero, tracing		is disabled.	participants			&lt;WeakArray of: ExternalDatabaseSession&gt;		The session instances that participate in the connection.	participantsSemaphore	&lt;RecursionLock&gt;		Used for mutual exclusion protection of uses of the participants array.Instance Variables	transaction			&lt;ExternalDatabaseTransaction | nil&gt;		Transaction that this connection is a part of.	username			&lt;String | nil&gt;			Name of current user; driver will signal if required and == nil.	password			&lt;String | nil&gt;		Password of current user; driver will signal if required and == nil.	environment			&lt;String | nil&gt;			Logical or physical name for environment; driver will signal if required and == nil.	transactionCoordinator &lt;ValueHolder on: Boolean&gt;		Holds true if this connection is a transaction coordinator for other connections.	cachedSession &lt;nil | ExternalDatabaseSession&gt;		Holds onto a session for reuse by getSession.	isolationLevel &lt; Symbol | nil&gt;		Holds the isolationLevel for this connection.	encoding	&lt;Symbol&gt;		A symbol remembers the encoding selection.Class Variables	DefaultConnection			&lt;Symbol | nil&gt;		Contains name of subclass to use when creating a new connection.	DefaultEnvironment	&lt;String | nil&gt;		Contains logical environment to use as a default for connecting.	StandardSignals		&lt;IdentityDictionary of: Signal&gt;		Maps signal names to signals.	PlatformType &lt;nil | Symbol&gt;		Platform/OS type that we're running on.  Used to select an platform-specific		ExternalInterface subclass.Class Instance Variables	environmentMap		&lt;Dictionary | nil&gt;		Each driver maintains a map of logical to physical environments.Subclasses must implement the following messages:	instance protocol		private-library calls			acquireExternal:	class protocol		accessing			sessionClass			transactionClass			kind		activation			pause			resume		private-accessing			call		private-activation			install</body></comment><class><name>UnableToConnectToSQLserver</name><environment>Database</environment><super>Database.ConnectionException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToConnectToSQLserver</class-id><body>UnableToConnectToSQLserver is used to indicate that the connection cannot be made to the database server.  This signal is used when it is the server that is the cause of the failure.  If it is possible to segregate the errors, an	unableToConnectToSQLEnvironmentSignal should be used.</body></comment><class><name>TooManyActiveTransactions</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.TooManyActiveTransactions</class-id><body>TooManyActiveTransactions is used to indicate that the driver for this connection already has the maximum number of active transactions.</body></comment><class><name>ConnectionNotOpen</name><environment>Database</environment><super>Database.ConnectionException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ConnectionNotOpen</class-id><body>ConnectionNotOpen is raised to indicate that the connection does not have a connection to the SQL-environment.</body></comment><class><name>UnsupportedCursorType</name><environment>Database</environment><super>Database.ExternalDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnsupportedCursorType</class-id><body>UnsupportedCursorType is used to indicate that an attempt was made to use an unsupported cursor type.</body></comment><class><name>TooManyActiveConnections</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.TooManyActiveConnections</class-id><body>TooManyActiveConnections is used to indicate that the driver for this connection already has the maximum number of active connections.</body></comment><class><name>UnableToExecuteSQL</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToExecuteSQL</class-id><body>UnableToExecuteSQL is used to indicate that the prepared SQL text could not be executed.</body></comment><class><name>SQLSyntaxError</name><environment>Database</environment><super>Database.UnableToExecuteSQL</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.SQLSyntaxError</class-id><body>SQLSyntaxError is used to indicate that the SQL text could not be prepared.</body></comment><class><name>UnableToCloseCursor</name><environment>Database</environment><super>Database.ExternalDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToCloseCursor</class-id><body>UnableToCloseCursor is used to indicate that the Oracle cursor could not be closed.  This signal is proceedable.</body></comment><class><name>ExternalDatabaseTransactionError</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseTransactionError</class-id><body>ExternalDatabaseTransactionError is used to indicate an attempt to commit/rollback a database transaction failed.</body></comment><class><name>AuthenticationFailure</name><environment>Database</environment><super>Database.ConnectionException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.AuthenticationFailure</class-id><body>AuthenticationFailure is raised when the server failed to authenticate the username and/or password</body></comment><class><name>UnableToConnectToSQLenvironment</name><environment>Database</environment><super>Database.UnableToConnectToSQLserver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToConnectToSQLenvironment</class-id><body>UnableToConnectToSQLenvironmentS is used to indicate that the connection cannot be made to the database environment for some reason other than the server itself.  This signal is used when it is possible to segregate the error causes, otherwise	unableToConnectToSQLserverSignal should be used.</body></comment><class><name>UnsupportedDataType</name><environment>Database</environment><super>Database.ExternalDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnsupportedDataType</class-id><body>UnsupportedDataType is used to indicate that an attempt was made to use an unsupported data type.</body></comment><class><name>DBProfileManager</name><environment>Database</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profileListHolder connectedIcon </inst-vars><class-inst-vars></class-inst-vars><imports>			private XML.XMLParser			private XML.SAXWriter			private XML.Document			private XML.Element			</imports><category>Tools-Settings-VW</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.DBProfileManager</class-id><body>DBProfileManager is cloned from its Store counterpart, RepositoryManager, is the standalone application for managing database connections. It uses a dataset to list the known connections and allows one to manage connections, including saving to and loading from files.Instance Variables:	connectedIcon	&lt;Image&gt;	The image used by the dataset to mark the currenly connected profile, if any.	profileListHolder	&lt;SelectionInList&gt;	The model of the profile list.</body></comment><class><name>DynamicSQLError</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.DynamicSQLError</class-id><body>DynamicSQLError is used to indicate problems in the ANSI-2 exception class named dynamic SQL error.</body></comment><class><name>ConnectionProfile</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name driverClassName environment userName password originalName </inst-vars><class-inst-vars>lastUsedProfile </class-inst-vars><imports></imports><category>Database-Connection Dialog</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ConnectionProfile</class-id><body>An instances of ConnectionProfile is a set of database connection parameters. In other words, a profile represents future database connection(s). The difference between a profile and a connection is that a profile can be incomplete--for example have no connection type (driverClassName) set. It also has a human-readable name.ConnectionProfiles are mostly created and manipulated by ConnectionDialogs.Instance Variables:	name	&lt;String | nil&gt;	A human-readable string of arbitrary format used by the UI to identify profiles.	driverClassName	&lt;Symbol&gt;	The name of the ExternalDatabaseConnection subclass to instantiate to create the connection.	environment	&lt;String&gt;	The connection environment string.	userName	&lt;String | nil&gt;	The database user name (a nil value is deprecated, even where a DB such as SQLite would accept it for connection, since tracking tools may require a string).	password	&lt;String | nil&gt;	The database user's password.	originalName	&lt;String | nil&gt;	A duplicate of the original value of &lt;name&gt;. The name may be reset to nil by a connection dialog while a profile is being modified, yet this saved value allows to remember the original name to save the profile afterwards.</body></comment><class><name>DBProfileListSetting</name><environment>Tools</environment><super>Tools.GenericSettingDescriptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profiles </inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.DBProfileManager			private Database.ConnectionProfile			</imports><category>Tools-Settings-VW</category><attributes><package>Database</package></attributes></class><comment><class-id>Tools.DBProfileListSetting</class-id><body>DBProfileListSetting is cloned from its Store counterpart, StoreRepositoryListSetting, holds the list of profiles.Instance Variables:	profiles	&lt;ConnectionProfile&gt;	the list of profiles ownd by the DBProfileManager.</body></comment><class><name>UnsupportedIsolationLevel</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnsupportedIsolationLevel</class-id><body>UnsupportedIsolationLevel is used to indicate that an attempt was made to set an unsupported isolation level.</body></comment><class><name>DBProfilePropertiesDialog</name><environment>Tools</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profileHolder acceptTrigger databaseListHolder databaseHolder environmentHolder userNameHolder passwordHolder nameHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Settings-VW</category><attributes><package>Database</package></attributes></class><comment><class-id>Tools.DBProfilePropertiesDialog</class-id><body>DBProfilePropertiesDialog is a clone of the Store RepositoryPropertiesDialog, and is used by DBProfileManager to edit properties of individual database connections.Most of the instance variables hold aspects of the dialog's widgets. The aspects are buffered value holders on aspect adaptors on the contents of 'profileHolder' variable.Instance Variables:	acceptTrigger	&lt;ValueHolder with: Boolean&gt;	Trigger channel of the buffered value	databaseHolder	&lt;BufferedValueHolder&gt;	databaseListHolder	&lt;List&gt;	environmentHolder	&lt;BufferedValueHolder&gt;	nameHolder	&lt;BufferedValueHolder&gt;	passwordHolder	&lt;BufferedValueHolder&gt;	profileHolder	&lt;ValueHolder&gt; Holds the profile whose properties are being edited.	userNameHolder	&lt;BufferedValueHolder&gt;</body></comment><class><name>RowIsReferencedError</name><environment>Database</environment><super>Database.UnableToExecuteSQL</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.RowIsReferencedError</class-id><body>RowIsReferencedError is used to indicate that a row may not be deleted nor the primary key changed because it is still referenced.</body></comment><class><name>ExternalDatabaseColumnDescription</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name index type length precision scale nullable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseColumnDescription</class-id><body>Class ExternalDatabaseColumnDescription defines the common protocol for accessing meta-data about columns.  The information available is limited by the database api library.  If any of the properties of a column are unknown, a nil value is reported.Instance variables:	name	&lt;String | nil&gt;		The name of the column. If the column is derived (in an answer set),		the name may not be defined (nil) or an empty string.	index	&lt;SmallInteger | nil&gt;		The ordinal position of the column in the answer set or in the table.	type		&lt;Magnitude class | nil&gt;		The Smalltalk class which is used to hold data from the column.	length	&lt;SmallInteger | nil&gt;		The number of bytes to represent the column.  In some database api libraries, this		is the maximum storage length.  In others, it is the display length.  If both are available,		it is the maximum of the two.	precision	&lt;SmallInteger | nil&gt;		The total number of digits in a decimal number.	scale	&lt;SmallInteger | nil&gt;		The number of digits to the right of the decimal point.	nullable 	&lt;Boolean | nil&gt;		True implies that this column may hold null values.</body></comment><class><name>ByteFieldDescriptor</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>template max isLongType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Support</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ByteFieldDescriptor</class-id><body>Instances of ByteFieldDescriptor describe variable-length data fields.  Used by protocol private to the ObjectLens.Instance Variables:	template &lt;Object&gt;		a template object describing the class of values in the field	max &lt;SmallInteger&gt;		the maximum size of objects in the field</body></comment><class><name>UnableToDisconnect</name><environment>Database</environment><super>Database.ExternalDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToDisconnect</class-id><body>UnableToDisconnect is used to indicate that an error occurred when trying to end the connection.   This signal is proceedable.</body></comment><class><name>InvalidParameterMarker</name><environment>Database</environment><super>Database.DynamicSQLError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.InvalidParameterMarker</class-id><body>InvalidParameterMarker is used to indicate that the parameter marker is incorrect.</body></comment><class><name>RequiredEnvironment</name><environment>Database</environment><super>Database.ExternalDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.RequiredEnvironment</class-id><body>RequiredEnvironment is used to report that the environment is a required parameter by this driver and no default was specified.</body></comment><class><name>UnableToDescribe</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToDescribe</class-id><body>UnableToDescribe is used to indicate that description of a input variable or an output column could not be acquired.</body></comment><class><name>ObjectLocked</name><environment>Database</environment><super>Database.UnableToExecuteSQL</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ObjectLocked</class-id><body>ObjectLocked is used to indicate that an object is locked when attempting to change it in the database</body></comment><class><name>ConnectionDialog</name><environment>Database</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connectionProfileListHolder connectionProfileHolder databaseListHolder databaseHolder environmentListHolder environmentHolder userNameListHolder userNameHolder passwordHolder currentProfileHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Connection Dialog</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ConnectionDialog</class-id><body>This is the dialog used to set parameters of a database connection. The dialog also allows to save often used sets of parameters as profiles that can be selected with a single click.The primary access point is the messages under the 'utilities' protocol on the class side:	chooseProfilewhich former opens the dialog and answers an instance of ConnectionProfile with the settings selected by the user. If the dialog has been cancelled, the answer is nil. The client code is then responsible for connecting to the database and handling possible errors, however the dialog class can help with that if all that is required is to attempt a connection and display a message box in case of an error.  See the class-side method	connect:This very simple pattern of using the dialog is illustrated by two methods under the 'examples' protocol on the class side.Instance Variables:	connectionProfileListHolder	&lt;ValueHolder with: &lt;List of: String&gt;&gt; 	This and most of the following variables hold various aspects of the dialog interface.	connectionProfileHolder	&lt;ValueHolder with: String&gt;	databaseListHolder	&lt;ValueHolder with: &lt;List of: Symbol&gt;&gt;	databaseHolder	&lt;AspectAdaptor&gt;		environmentListHolder	&lt;ValueHolder with: &lt;List of: String&gt;&gt;	environmentHolder	&lt;AspectAdaptor&gt;	userNameListHolder	&lt;ValueHolder with: &lt;List of: String&gt;&gt;	userNameHolder	&lt;AspectAdaptor&gt;	passwordHolder	&lt;AspectAdaptor&gt;	currentProfileHolder	&lt;ValueHolder with: ConnectionProfile&gt;	A value holder with the "working copy" of a ConnectionProfile. It is a subject channel of some of the aspects above, which are aspects adaptors.Class instance Variables:	lastUsedProfile	&lt;ConnectionProfile&gt;	The connection profile most recently accepted by the user.</body></comment><class><name>DBProfileListPage</name><environment>Tools</environment><super>Tools.SettingsManagerPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>setting profileManager profileListHolder profileHolder </inst-vars><class-inst-vars></class-inst-vars><imports>			private Database.ConnectionDialog			private Database.ConnectionProfile			</imports><category>Tools-Settings-VW</category><attributes><package>Database</package></attributes></class><comment><class-id>Tools.DBProfileListPage</class-id><body>DBProfileListPage is cloned from its Store counterpart, StoreRepositoryListPage, and used with the settings tools to maintain the list of database connections (or profiles).Instance Variables	profileHolder	&lt;ConncetionProfile&gt;	holds the current profile.	profileListHolder	&lt;SelectionInList&gt;	holds the list of profiles.	profileManager	&lt;DBProfileManager&gt;	holds, saves and loads the profiles.	setting	&lt;DBProfileListSetting&gt;	related to the settings tool.</body></comment><class><name>UnableToPrepare</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToPrepare</class-id><body>UnableToPrepare is used to indicate that it is unable to prepare an SQL statement.</body></comment><class><name>UnableToBind</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToBind</class-id><body>UnableToBind is used to indicate that the input or output bind was unsuccessful.</body></comment><class><name>MissingBindVariable</name><environment>Database</environment><super>Database.UnableToBind</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.MissingBindVariable</class-id><body>MissingBindVariable is used to indicate that a bind variable is missing.</body></comment><class><name>InvalidConnectionState</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.InvalidConnectionState</class-id><body>InvalidConnectionState is used to indicate that the application cannot use a function at a given time.</body></comment><class><name>ExternalDatabaseAnswerStream</name><environment>Database</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session nextRow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseAnswerStream</class-id><body>ExternalDatabaseAnswerStream is the class for receiving rows returned from an SQL select statement or stored procedure.Implementation Details:	ExternalDatabaseAnswerStream is a subclass of Stream since it is not	practical to transparently support the skip functionality of PeekableStream	and it does not have a collection as is assumed by PositionableStream.Instance Variables:	session			&lt;ExternalDatabaseSession | nil&gt;		Holds the reference to the parent of the answer stream, or nil if the		answer stream is no longer connected (as will happen at end-of-stream).	nextRow			&lt;Object | nil&gt;		Caches the next object to be returned.  The object will be an instance		of the bindOutput object, if one was provided, otherwise it will be an		instance of Array.</body></comment><class><name>UnsupportedDriverFunctionality</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnsupportedDriverFunctionality</class-id><body>UnsupportedDriverFunctionality is used to indicate that an attempt was made to use functionality which is not available from the underlying API due to the current execution circumstances.</body></comment><class><name>ExternalDatabaseTransaction</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memberCountHolder remainingCountHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseTransaction</class-id><body>Class ExternalDatabaseTransaction is a private abstract class used by the external database interface to manage transaction services on behalf of one or more connections. ExternalDatabaseTransaction reduces the differences between independent and coordinated (sometimes called distributed) database transaction styles.  Independent transactions limit the unit of work to a single connection with a database.  Coordinated transactions allow multiple concurrent connections to comprise the unit of work.  For either independent or coordinated transactions, commiting or aborting all changes made during the unit of work should be atomic.ExternalDatabaseTransaction unifies these two transaction styles by allowing multiple connections (of the same driver) to be coordinated whether or not there is direct support from the underlying database system.  A *two-phase commit* protocol is required to assure atomicity for the unit of work. When a two-phase commit protocol is not available, a less rigorous serial broadcast strategy is used.  In this approach, each connection is asked to commit or rollback in turn.  If there is a system or network failure before all have completed the work, it is possible that not all will perform the same action to complete the transaction.  The application is responsible for recovery in the event that not all commits are completed.Implementation Considerations:Participation relationships:	An instance of the connection subclasses will participate in an instance of the	transaction subclass.Inherited instance variables:	stateHolder			&lt;ValueHolder on: (#xactNo | #xactYes | #committing | #aborting | #paused)&gt;		The state variable is used to track the legal operations on transactions.	traceStream		&lt;WriteStream on: String&gt;		A private stream used for preparing complex trace entries.	traceLevel  &lt;SmallInteger&gt;		The trace level, copied from the class side on instance creation.  If zero, tracing		is disabled.	participants		&lt;WeakArray of: ExternalDatabaseConnection&gt;		The connection instances that are coordinated via the transaction instance.	participantsSemaphore	&lt;RecursionLock&gt;		Used for mutual exclusion protection on uses of the participants array. Instance variables:	memberCountHolder	&lt;ValueHolder on: SmallInteger&gt;		A count of the number of connections that are members of the current transaction.	remainingCountHolder	&lt;ValueHolder on: SmallInteger&gt;		A count of the number of connections that remain members of the current transaction.		If this number is less than the number held in memberCount, we are in the		#committed or #aborting states.  This will persist until the last executor is heard from.Subclasses must implement the following messages	instance protocol		private-library calls			beginExternal			commitExternal			rollbackExternal </body></comment><class><name>InvalidDescriptorCount</name><environment>Database</environment><super>Database.DynamicSQLError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.InvalidDescriptorCount</class-id><body>InvalidDescriptorCount is used to indicate that there are more input variables in an SQL statement than are found in the bind object.</body></comment><class><name>TransactionException</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.TransactionException</class-id><body>TransactionException is used to indicate an error in transaction processing.</body></comment><class><name>DuplicateIndexesError</name><environment>Database</environment><super>Database.UnableToExecuteSQL</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.DuplicateIndexesError</class-id><body>DuplicateIndexesError is used to indicate attempting to add an index having the same columns as an existing index.</body></comment><class><name>UnableToSetEnvironmentAttribute</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><class><name>TransactionPhase2Fatal</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.TransactionPhase2Fatal</class-id><body>TransactionPhase2Fatal is used to indicate a fatal error in the second phase of a two-phase commit or rollback.  This usually means that manual recovery will be required to complete the transaction.</body></comment><class><name>UnableToQueryHandleInformation</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToQueryHandleInformation</class-id><body>UnableToQueryHandleInformation is used to indicate that the handle information could not be queried.</body></comment><class><name>NoDefaultConnection</name><environment>Database</environment><super>Database.ExternalDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.NoDefaultConnection</class-id><body>NoDefaultConnection is used to report that ExternalDatabaseConnection doesn't know	which Connection to use for a new connection.</body></comment><class><name>UnableToOpenCursor</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToOpenCursor</class-id><body>UnableToOpenCursor is used to indicate that a cursor could not be opened.</body></comment><class><name>InvalidTransactionState</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.InvalidTransactionState</class-id><body>InvalidTransactionState is used to indicate that the application cannot use a function at a given time.</body></comment><class><name>ExternalDatabaseNotification</name><environment>Database</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseNotification</class-id><body>Use me to report external database information that may, but need not be, handled, so should subclass Notification, not Error, on the VisualWorks side.  An example is an Oracle login that returns OCI_SUCCESS_WITH_INFO:  the info can be passed as my messageText, to be handled only if something in the call chain so wishes.BE AWARE:  handlers of me that also handle ExternalDatabaseException may expect any non-nil parameter to be a collection whose first item, if non-empty, will understand #dbmsErrorString.  Therefore raise me either to have nil parameter, e.g.	ExternalDatabaseNotification raiseRequestErrorString: errs first dbmsErrorStringor to have an appropriate parameter, e.g.	ExternalDatabaseNotification		raiseRequestWith: errs		errorString: errorMessage.</body></comment><class><name>RequiredPassword</name><environment>Database</environment><super>Database.ExternalDatabaseResumableException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.RequiredPassword</class-id><body>RequiredPassword is used to indicate that a password is required in order to connect. This signal is proceedable and expects a password string as the proceedWith: value.</body></comment><class><name>ExternalDatabaseSession</name><environment>Database</environment><super>Database.ExternalDatabaseFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection query queryFragments bindInput bindTemplate bindOutput useNamedOutputBinding bindValues resultTemplate allocateForEachRow blockFactor numColumns columnDescriptions rowAdaptors rowBuffersHolder bufferIndex answerStream currentRow scrollable needBinding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseSession</class-id><body>ExternalDatabaseSession is the abstract class defining the application interface to executing prepared SQL statements or stored procedures, describing the results of the execution, and acquiring streams of results.Inherited instance variables:	stateHolder &lt;ValueHolder on: (#new | #connected | #prepared | #executing | #ready | #validResults | #fetchingData | #paused)&gt;			The state variable is used to track the legal operations on sessions.	traceStream &lt;WriteStream on: String&gt;		A private stream used for preparing complex trace entries.	traceLevel  &lt;SmallInteger&gt;		The trace level, copied from the class side on instance creation.  If zero, tracing		is disabled.	participants &lt;WeakArray of: ExternalDatabaseAnswerStream&gt;		The answer stream instance that participates in this session.  There will never be		more than one.	participantsSemaphore &lt;RecursionLock&gt;		Used for mutual exclusion protection of uses of the participants array.Instance variables:	connection &lt;ExternalDatabaseConnection&gt;		The connection context in which this session executes		SQL statements or stored procedures.	query &lt;String&gt;		The SQL query provided by the client.	queryFragments &lt;Collection of: (String | SmallInteger | Symbol)&gt;		The query, canonized for parameter binding.	bindInput &lt;Object | nil&gt;		The object to obtain bind values from, if any are required.	bindOutput &lt;Object | nil&gt;		The bind object to use for output rows.  If nil, output rows are instances of Array.	bindValues &lt;IdentityDictionary&gt;		A private dictionary, keyed by bind position, of values bound to parameters.		Used to avoid unneccessary rebinds.	useNamedOutputBinding &lt;Boolean&gt;		Determines if the output bind object should be populated by sending it mutators		fashined from the column names.  The default is populate the bind object		by directly indexing its instance variables.	allocateForEachRow	&lt;Boolean&gt;		When true (the default), the answer stream will create a copy of the output bind		object for each row.  When false, the answer stream will use the same bind object		repeatedly.	blockFactor	&lt;SmallInteger&gt;		The number of rows to fetch in a block from the dbms server.	currentRow &lt;Object | nil&gt;		The session's bindOutput object or an appropriate Array (i.e. with the right number		of cells to match the number of columns).  The adaptors used to insert values		into the appropriate repository for each column are given a copy of this or use it		directly if allocateForEachRow is false.	numColumns &lt;SmallInteger&gt;		The number of columns in the answer set.	columnDescriptions &lt;(Array of: ExternalDatabaseColumnDescription) | nil&gt;		Array containing a description of each column in the answer set.	rowAdaptors &lt;Array of: BlockClosure&gt;		A block for each column of the output.  Each block takes two arguments		(subject and value) and is responsible for inserting the value into the instance		or indexed variable of the subject.	rowBuffersHolder &lt;ValueHolder on: (Array of: (ExternalDatabaseBuffer | Array))&gt;		Each driver will need space to store the data as it is returned from the		dbms api.  For systems which do not fetch rows directly into predeclared		buffer, it is still important to allocate these buffers once to avoid the overhead		of constantly allocating and deallocating space.	answerStream &lt;ExternalDatabaseAnswerStream | nil&gt;		A reference to the active answer stream.	scrollable &lt;Boolean&gt;		Determines whether the cursor is scrollable.	bindTemplate &lt;Object&gt;		Private variable for Object Lens use.	resultTemplate &lt;Object&gt;		Private variable for Object Lens use.	bufferIndex &lt;SmallInteger&gt;		Private variable for Object Lens use.Subclasses must implement the following messages	instance protocol		data processing			rowCount		private-answer set			advanceExternal			allocateRowBufferExternal:			getColumnDescriptionExternal:			hasAnswerSetExternal			getFieldExternal:			cancelAnswerSetExternal		private-execution			executeExternal			readyExternal			resultsExternal			moreResultsExternal			cancelExternal		private-binding			prepareExternal			bindValue:at:		schema access			listTablesLike:			describeColumns:		private-ObjectLens			bindInput:template:to:			flattenResultTemplate:onto:			nextViaTemplate:</body></comment><class><name>IndexConflict</name><environment>Database</environment><super>Database.UnableToExecuteSQL</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.IndexConflict</class-id><body>IndexConflict is used to indicate attempt to insert or update an object that has the same index value as another object.</body></comment><class><name>UnableToFetchData</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.UnableToFetchData</class-id><body>UnableToFetchData is used to indicate that the row or rows could not be fetched.</body></comment><class><name>InvalidSessionState</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.InvalidSessionState</class-id><body>InvalidSessionState is as not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.</body></comment><class><name>AdHocQueryTool</name><environment>Database</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection session answerStream queryModel dsvList whichDriverModel connectedStatusHolder executeStatusHolder moreAnswersStatusHolder profile blockFactorModel truncateColumnsStatusHolder selectedRow queryChoices spinButtonModel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Tools</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.AdHocQueryTool</class-id><body>AdHocQueryTool is a simple application that supports ad hoc database queries,and demonstrates the use of the External Database Interface.Instance Variables	connection &lt;ExternalDatabaseConnection&gt;		The current database connection.	queryModel &lt;ValueHolder&gt;		Holds the latest query.	tableModel &lt;TableInterface&gt;		The table used to display results.	whichDriverModel &lt;ValueHolder&gt;		Holds the name of the Database Connect to use.	usernameModel &lt;ValueHolder&gt;		Holds the username to use to make the connection.	passwordModel &lt;ValueHolder&gt;		Holds the password to use to make the connection.	environmentModel &lt;ValueHolder&gt;		Holds the environment (connect) string to make the connection.	blockFactorModel &lt;ValueHolder&gt;		Holds the block factor to use when executing the query.	truncateColumnsStatusHolder &lt;ValueHolder on Boolean&gt;		Holds a (boolean). True means clip some columns to avoid calculating. False means size them to avoid truncation.	selectedRow &lt;ValueHolder&gt;		Holds the currently selected row of the dataset. This is used by Dataset widgets.	spinButtdonModel &lt;ValueHolder&gt;		Holds reference to the past query selection spin button.</body></comment><class><name>ExternalDatabaseError</name><environment>Database</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dbmsErrorCode dbmsErrorString osErrorCode osErrorString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.ExternalDatabaseError</class-id><body>An ExternalDatabaseError is returned as the parameter for exceptions raised by the External Database Interface to describe conditions reported by the dbms api in use.  Other exceptions will have nil for the parameter value.The instance variables may all be nil to indicate that (in the current situation) there is no available/appropriate value for that field.Individual drivers may subclass if they have additional information to provide when errors occur.Instance Variables:	dbmsErrorCode		&lt;SmallInteger | nil&gt;		The code provided by the dbms api.	dbmsErrorString		&lt;String | nil&gt;		The string associated with the dbmsErrorCode.	osErrorCode			&lt;SmallInteger | nil&gt;		The error code provided by the dbms api which is attributed to the underlying		operating system.  This is usually just detail information about the dbmsErrorCode.	osErrorString 		&lt;String | nil&gt;		The string associated with the osErrorCode.</body></comment><class><name>TooManyActiveSessions</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><comment><class-id>Database.TooManyActiveSessions</class-id><body>TooManyActiveSessions is used to indicate that the connection already has the maximum number of active sessions.</body></comment><class><name>UnableToCreateConnectionPool</name><environment>Database</environment><super>Database.ExternalDatabaseException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Interface</category><attributes><package>Database</package></attributes></class><shared-variable><name>Profiles</name><environment>Database.ConnectionDialog</environment><private>false</private><constant>false</constant><category>profiles</category><initializer>OrderedCollection new</initializer><attributes><package>Database</package></attributes></shared-variable><shared-variable><name>LastUsedProfile</name><environment>Database.ConnectionDialog</environment><private>false</private><constant>false</constant><category>profiles</category><initializer>nil</initializer><attributes><package>Database</package></attributes></shared-variable><shared-variable><name>TraceSequencer</name><environment>Database.ExternalDatabaseFramework</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Database</package></attributes></shared-variable><shared-variable><name>TraceCollector</name><environment>Database.ExternalDatabaseFramework</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Database</package></attributes></shared-variable><shared-variable><name>TraceLevel</name><environment>Database.ExternalDatabaseFramework</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Database</package></attributes></shared-variable><shared-variable><name>Profiles</name><environment>Database.DBProfileManager</environment><private>false</private><constant>false</constant><category>profiles</category><initializer>List new</initializer><attributes><package>Database</package></attributes></shared-variable><shared-variable><name>PlatformType</name><environment>Database.ExternalDatabaseConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>ExternalDatabaseConnection determinePlatformType</initializer><attributes><package>Database</package></attributes></shared-variable><shared-variable><name>StandardSignals</name><environment>Database.ExternalDatabaseConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Database</package></attributes></shared-variable><shared-variable><name>DefaultConnection</name><environment>Database.ExternalDatabaseConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Database</package></attributes></shared-variable><shared-variable><name>DefaultEnvironment</name><environment>Database.ExternalDatabaseConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Database</package></attributes></shared-variable><methods><class-id>Database.ExternalDatabaseException</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errExternalDatabase &lt;&lt; #database &gt;&gt; 'External Database Error') asString</body></methods><methods><class-id>Database.ExternalDatabaseLibraryInaccessible</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#databaseClientInaccessible &lt;&lt; #database &gt;&gt; 'Database client libraries are inaccessible. Either the \Object Engine has not been linked with the required \libraries, or the DLLs for those libraries are not in \your search path.  For more information, consult \the release notes for this Connect product.' ) asString withCRs</body></methods><methods><class-id>Database.ExternalDatabaseResumableException</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errInformation &lt;&lt; #database &gt;&gt; 'External Database Information') asString</body></methods><methods><class-id>Database.ExternalDatabaseResumableException class</class-id> <category>testing</category><body package="Database">mayResume	^true</body></methods><methods><class-id>Database.UnableToFreeResource</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errFreeResource &lt;&lt; #database &gt;&gt; 'Unable to free an external resource.') asString</body></methods><methods><class-id>Database.RequiredUsername</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#userNameRequired &lt;&lt; #database &gt;&gt; 'A user name is required') asString</body></methods><methods><class-id>Database.UnableToQueryDriverInformation</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errQueryDriver &lt;&lt; #database &gt;&gt; 'Unable to query driver information.') asString</body></methods><methods><class-id>Database.ExternalDatabaseBuffer</class-id> <category>initialize-release</category><body package="Database">elementSize: anElementSize count: aCount databaseType: aDatabaseType	elementSize := anElementSize.	count := aCount.	databaseType := aDatabaseType</body><body package="Database">initialize	"Initialize an instance of the receiver."	encoding := #default</body></methods><methods><class-id>Database.ExternalDatabaseBuffer</class-id> <category>allocation</category><body package="Database">free	"Free the receiver."	bufferPointer notNil ifTrue:		[ bufferPointer freePointer.		bufferPointer := nil ]</body><body package="Database">mallocUsingSelector: mallocSelector	"Assert: mallocSelector is either #malloc: or #malloc16:"	bufferPointer := self pointerType perform: mallocSelector with: (count max: 1)</body></methods><methods><class-id>Database.ExternalDatabaseBuffer</class-id> <category>accessing</category><body package="Database">at: anIndex	"Answer the object in the buffer at anIndex."	^self subclassResponsibility</body><body package="Database">at: anIndex put: anObject	"Store anObject into the buffer at anIndex."	^self subclassResponsibility</body><body package="Database">count	"Answer the receiver's cardinality"	^count</body><body package="Database">databaseType	"Answer the receiver's database type."	^databaseType</body><body package="Database">elementSize	"Answer the receiver's length"	^elementSize</body><body package="Database">encoding	"Answer the encoding"	^encoding</body><body package="Database">encoding: aSymbol	"Set the encoding type"	encoding := aSymbol</body><body package="Database">pointer	"Answer the receiver's buffer pointer."	^bufferPointer</body><body package="Database">size	"Answer the receiver's size"	^(count max: 1) * elementSize</body><body package="Database">value	"Answer the value (or values) held in the buffer"	| array |	count == 0		ifTrue: [ ^self at: 1 ].	array := Array new: count.	1 to: count do:		[ :index | array at: index put: (self at: index) ].	^array</body><body package="Database">value: aValueOrArray	"Store aValueOrArray into the receiver."	| size |	count == 0 ifTrue: [ ^self at: 1 put: aValueOrArray ].	size := aValueOrArray size.	size &gt; count ifTrue: [ ^self error: (#errTooBigForBuffer &lt;&lt; #database &gt;&gt; 'too big for buffer') ].	1 to: size do: [ :index |		self at: index put: (aValueOrArray at: index) ].	size &lt; count		ifTrue: [ (size + 1) to: count do: [ :index |					self at: index put: nil ] ]</body></methods><methods><class-id>Database.ExternalDatabaseBuffer</class-id> <category>private</category><body package="Database">pointerType	"Answer the pointer type to use for buffer allocation."	^CArrayType defaultPointer			referentType: CIntegerType char;			numElements: self elementSize.</body></methods><methods><class-id>Database.ExternalDatabaseBuffer class</class-id> <category>instance creation</category><body package="Database">new	"Answer an initialized instance of the receiver"	^super new initialize</body></methods><methods><class-id>Database.UnableToCancelCursor</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errCursorCancel &lt;&lt; #database &gt;&gt; 'The database cursor could not be canceled.') asString</body></methods><methods><class-id>Database.ConnectionException</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errConnectionException &lt;&lt; #database &gt;&gt; 'Connection Exception') asString</body></methods><methods><class-id>Database.InvalidTableName</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errTableName &lt;&lt; #database &gt;&gt; 'Invalid table name in query') asString</body></methods><methods><class-id>Database.CouldNotResolveServiceName</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#couldNotResolveServiceName &lt;&lt; #database &gt;&gt; 'Connection Exception--Could not resolve service name.') asString</body></methods><methods><class-id>Database.UnableToAllocateHandle</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errHandleAllocation &lt;&lt; #database &gt;&gt; 'Unable to allocate a handle.') asString</body></methods><methods><class-id>Database.UnableToDestroyConnectionPool</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errConnectionPoolDestroy &lt;&lt; #database &gt;&gt; 'unable to destroy connection pool.') asString</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>initialize-release</category><body package="Database">initialize	"Establish initial value for instance variables."	"Subclasses which override must include super initialize."	traceLevel := TraceLevel.	self stateHolder: nil asValue.	self initializeParticipants</body><body package="Database">install	"Perform all processing relevant for just returning from a snapshot."	"Assume: reciever is registered."	self installExternal.	self participantsDo: [ :each | each installExternal ]</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>printing</category><body package="Database">printOn: aStream 	"Append to the argument aStream a sequence of characters that identifies the 	receiver."	super printOn: aStream.	self isExecutor ifTrue: [ aStream nextPut: $' ]</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>private-accessing</category><body package="Database">state	"Answer with the current state of the External Database object."	^stateHolder value</body><body package="Database">state: aSymbol	"Set the current state of the External Database object."	stateHolder setValue: aSymbol</body><body package="Database">stateHolder: aValueHolder	"Initialize the holder of state information."	stateHolder := aValueHolder</body><body package="Database">traceLevel	^traceLevel</body><body package="Database">traceLevel: anInteger	traceLevel := anInteger</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>private-activation</category><body package="Database">activate	"Time to revive all connections to external resources."	"Assume: receiver is registered."	"Enforce-quietly: receiver is paused."	self state == #paused ifFalse: [ ^self ].	self acquireExternal notNil		ifTrue:	[ self class register: self ]		ifFalse:	[ self class unregister: self ].	self participantsDo:	[ :each | each activate ]</body><body package="Database">dismiss	"Time to release any external resources."	"Assume: receiver is registered."	self class unregister: self.	"Avoid duplication of resource release."	self state == #paused		ifFalse:	[ self dismissExternal ]</body><body package="Database">quiesce	"Time to quiesce all connections to external resources."	"Assume: receiver is registered."	"Enforce-quietly: receiver is not paused."	self state == #paused ifTrue: [ ^self ].	[ self participantsDo: [ :each | each quiesce ].	self dismissExternal ]		ensure:			[ self state: #paused ]</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>private-finalization</category><body package="Database">executor	"Answer with the executor."	"Subclassess which want to override to add information to the executor	should use super executor to create the executor initially."	| ex |	"Make a new instance, but all the initialization will happen as part of the executor methods."	ex := self class basicNew.	"The state machine must be exposed to the executor."	ex stateHolder: stateHolder.	"The executor retains the ability to trace"	ex traceLevel: traceLevel.	^ex</body><body package="Database">finalize	"Release all external resource."	"Enforce-quietly: receiver is not paused."	self state == #paused ifTrue: [^self].	self initializeParticipants.	"It's not necessary to report errors at this time."	[self finalizeExternal] 		on: self class connectionClass externalDatabaseErrorSignal		do: [:ex | ex return]</body><body package="Database">finalizeExternal	"Release all external resources."	( traceLevel &gt;= 1 ) ifTrue:		[ self class trace: nil ].	self dismissExternal</body><body package="Database">key	"Key value to use when inserting receiver into a handle registry. This value 	needs to be unique within the registry."	^self subclassResponsibility</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>private-library calls</category><body package="Database">acquireExternal	"Acquire the external resources. If the external resources	cannot be acquired, an exception is raised."	^self subclassResponsibility</body><body package="Database">dismissExternal	"Release the external resources."	"All activity within this method must function with only the instance	variables defined in the executor object."	^self subclassResponsibility</body><body package="Database">installExternal	"Perform return from snapshot processing."	"Subclasses that override should invoke super installExternal."	self state: #paused	"Assure: no dangling CPointers remain."</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>private-participation</category><body package="Database">addParticipant: aParticipant	"Add aParticipant to the collection of participants in receiver's scope.  A	new participant is added to the collection if it is not already present."	| p new |	participantsSemaphore critical:		[ "Check for and return immediately if already a particpant."		((p := self participants) includes: aParticipant)			ifTrue:	[ ^self ].		new := p class withAll: (p copyWith: aParticipant).		p become: new ]"This method of growing the participants gives the exact same kind of collection.  This is necessary because WeakArray&gt;&gt;copyWith: does not answer another WeakArray."</body><body package="Database">initializeParticipants	"Initialize the instance variables which define the participation mechanism."	participants := WeakArray new: 0.	participantsSemaphore := RecursionLock new.	participants addDependent: self</body><body package="Database">participants	"Answer with the collection of participants.  The participants collection	should always be accessed in a critical section controlled with the	participantsSemaphore."	^participants</body><body package="Database">participantsDetect: aBlock ifNone: exceptionBlock	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	"Since the participants are a WeakArray, we also need to skip	over 0 values (the death of a participant will leave a 0)."	^participantsSemaphore critical:		[ (self participants copy)			detect:				[ :each |				(each == 0 or: [ each isExecutor ])					ifTrue: [ false ]					ifFalse: [ aBlock value: each ] ]			ifNone: exceptionBlock ]</body><body package="Database">participantsDo: aBlock	"Invoke aBlock for each participant."	"Since the participants are a WeakArray, we also need to skip	over 0 values (the death of a participant will leave a 0)."	participantsSemaphore critical:		[ (self participants copy) do:			[ :each |			(each == 0 or: [ each isExecutor ]) ifFalse:				[ aBlock value: each ] ] ]</body><body package="Database">participantsSize	"Answer the size of the participants array."	"Since the participants are a WeakArray, we also need to skip	over 0 values (the death of a participant will leave a 0)."	| total |	participantsSemaphore critical:		[ total := self participants				inject: 0				into: [:subTotal :next |					next == 0 ifTrue: [ subTotal ] ifFalse: [ subTotal + 1] ] ].	^total</body><body package="Database">removeParticipant: aParticipant	"Remove aParticipant from the collection of participants in receiver's scope."	| p |	participantsSemaphore critical:		[ ((p := self participants) includes: aParticipant)			ifFalse:	[ ^self ].		p become: (p class withAll: (p copyWithout: aParticipant)) ]"This method of shrinking the participants gives the exact same kind of collection.  This is necessary because WeakArray&gt;&gt;copyWithout: does not answer another WeakArray."</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>private-testing</category><body package="Database">isExecutor	"Answer true if the receiver is really an executor, not the primary object."	^self participants isNil</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>private-tracing</category><body package="Database">emitTrace	"Answer the receiver's trace buffer contents.  Reset the trace stream to be empty."	| trace |	trace := traceStream contents.	traceStream reset.	^trace</body><body package="Database">traceStream	"Answer the receiver's trace stream.  Create the stream if necessary."	^traceStream isNil ifTrue: [ traceStream := (String new: 64) writeStream ] ifFalse: [ traceStream ]</body></methods><methods><class-id>Database.ExternalDatabaseFramework</class-id> <category>private-updating</category><body package="Database">update: anAspectSymbol with: aParameter from: aSender 	"Receive a change notice from an object, denoted by aSender, of whom the receiver is a 	dependent. The argument anAspectSymbol is typically a Symbol that indicates what 	change has occurred and aParameter is additional information."	| p |	(anAspectSymbol == #ElementExpired and: [aSender == self participants]) ifTrue:		[ participantsSemaphore critical:			[ (p := self participants) become: (p class withAll: (p copyWithout: 0)) ] ]</body></methods><methods><class-id>Database.ExternalDatabaseFramework class</class-id> <category>class initialization</category><body package="Database">initialize	"Establish class variables."	"ExternalDatabaseFramework initialize"	TraceLevel := 0.	TraceSequencer := RecursionLock new.</body></methods><methods><class-id>Database.ExternalDatabaseFramework class</class-id> <category>accessing</category><body package="Database">connectionClass	"Answer the class to use for connection objects associated with receiver."	^self subclassResponsibility</body></methods><methods><class-id>Database.ExternalDatabaseFramework class</class-id> <category>tracing</category><body package="Database">shouldTrace: level	"Answer true if tracing is enabled through level."	^self traceLevel &gt;= level</body><body package="Database">trace: aStringOrNil	"Emit the standard trace header followed by aString (if not nil) into the trace log."	| header when sender depth |	TraceCollector == nil ifTrue: [ ^self ].	header := WriteStream on: (String new: 64).	when := Time dateAndTimeNow.	sender := thisContext sender.	depth := TraceLevel &gt; 4 ifTrue: [ TraceLevel - 4 ] ifFalse: [ 1 ].	"Emit a timestamp"	header		nextPutAll: '{';		"print: (when at: 1);"  nextPutAll: ((when at: 1) printFormat: #(1 2 3 $ 2 2));		nextPutAll: ' ';		print: (when at: 2);		nextPutAll: '} 	'.		"curly-brace, space and a tab"	"Emit a stack trace"	[ depth &gt; 0 ] whileTrue:		[ header			nextPutAll: sender mclass printString;			nextPutAll: '&gt;&gt;';			nextPutAll: sender selector asString.		sender := sender sender.		(depth := depth - 1) &gt; 0 ifTrue:			[ header cr; tab: 6 ] ].	TraceSequencer critical:		[ TraceCollector nextPutAll: header contents; cr.		( aStringOrNil size &gt; 0 ) ifTrue:			[ TraceCollector tab; nextPutAll: aStringOrNil; cr ].		TraceCollector flush ]</body><body package="Database">traceLevel	"Answer the level of tracing that is enabled for this class."	TraceLevel isNil ifTrue:		[ TraceLevel := 0 ].	^TraceLevel</body></methods><methods><class-id>Database.ExternalDatabaseFramework class</class-id> <category>private-activation</category><body package="Database">activate	"Resume operation on suspended database connections."	"Each of the driver classes whose instances hold external resources must	maintain a registry of active and inactive instances so that all such resources	may be released at appropriate times. As each member of the collection is	activated it should reregister."	| registry |	(registry := self registry) isNil		ifTrue:	[ ^self shouldNotImplement ].	registry do:		[ :each | each state == #paused ifTrue: [ each activate ] ]</body><body package="Database">quiesce	"Suspend operation on active database connections."	"Each of the driver classes whose instances hold external resources must	maintain a registry of active and inactive instances so that all such resources	may be released at appropriate times. As each member of the collection is	activated it should reregister."	| registry |	(registry := self registry) isNil		ifTrue:	[ ^self shouldNotImplement ].	registry do:		[ :each | each state == #paused ifFalse: [ each quiesce ] ]</body><body package="Database">returnFromSnapshot	"No external resources can be held at this point.  Reset all appropriate control information	as if operation had been paused."	| registry |	( TraceLevel &gt;= 1 )		ifTrue:	[ self trace: nil ].	(registry := self registry) isNil		ifTrue:	[ ^self shouldNotImplement ].	registry do:		[ :each | each install ]</body></methods><methods><class-id>Database.ExternalDatabaseFramework class</class-id> <category>private-registry</category><body package="Database">initRegistry	"Initialize the registry to the proper form of collection."	self registry: HandleRegistry new.</body><body package="Database">register: sender	"Register the sender."	| registry |	^(registry := self registry) notNil		ifTrue: [ registry register: sender ]</body><body package="Database">registry	"Answer with the registry."	"Subclasses must override if they have registries."	^nil</body><body package="Database">registry: aCollection 	"Record aCollection as the registry."	^self subclassResponsibility</body><body package="Database">unregister: uh 	"Remove the argument from the active registry."	| registry |	(registry := self registry) isNil		ifFalse: [registry unregister: uh]</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>initialize-release</category><body package="Database">initialize	"Establish initial value for instance variables."	"Subclasses which override must include super initialize."	super initialize.	self state: #new.	transaction := nil.	self transactionCoordinator: false asValue.</body><body package="Database">initializeFromLogin: aLogin	self environment: aLogin connectString.	self username: aLogin username.	aLogin secure ifFalse:		[self password: aLogin password].</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>accessing</category><body package="Database">encoding	encoding isNil ifTrue: [ ^#default ].	^encoding</body><body package="Database">encoding: aSymbol	encoding := aSymbol</body><body package="Database">environment	"Answer the environment to use when connecting to the SQL-environment."	^environment</body><body package="Database">environment: aString 	"Set the environment to use when connecting to the SQL-environment.	An empty string should be used to specify the 'default' environment.  If the	environment is nil, the driver will raise a proceedable exception	(requiredEnvironmentSignal on a connection class) when connecting."	environment := aString</body><body package="Database">password	"Answer the password to use when connecting to the SQL-environment."	^password</body><body package="Database">password: aString 	"Set the password to use when connecting to the SQL-environment. 	Passwords are not required by all database systems (or on all platforms). 	An empty string should be used for the no-password case.  If the password	is nil, the driver will raise a proceedable exception (requiredPasswordSignal	on a connection class) when connecting."	password := aString</body><body package="Database">turnOffOEMEncoding	encoding == OSSystemSupport concreteClass new GetOEMCP printString asSymbol ifTrue: [		self encoding: nil.		self encoding.	]</body><body package="Database">turnOnOEMEncoding	self encoding: OSSystemSupport concreteClass new GetOEMCP printString asSymbol</body><body package="Database">username	"Answer the username to use when connecting to the SQL-environment."	^username</body><body package="Database">username: aString	"Set the username to use when connecting to the SQL-environment.	An empty string should be used  to connect as the default user unless the driver	requires something else.  If the username is nil, the driver will raise a proceedable	exception (requiredUsernameSignal on a connection class) when connecting."	username := aString</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>connections</category><body package="Database">connect	"Establish connection with SQL-environment ."	self connect: self password.</body><body package="Database">connect: aPassword 	"Establish connection with SQL-environment using the supplied password."	"Enforce: external resources not held."	self isConnected ifTrue:		[ ^self class invalidConnectionStateSignal raise ].	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)			nextPutAll: (#Version &lt;&lt; #database &gt;&gt; 'Version: ') asString;			nextPutAll: self class version.		self class trace: self emitTrace ].	self acquireTransaction.	self acquire: aPassword.	self state: #xactNo</body><body package="Database">disconnect	"Terminate connection with SQL-environment. An outstanding transaction	(if any) is aborted."	( self state == #new ) ifTrue: [ ^self ].	cachedSession := nil.	self inTransactionMode ifTrue: [ self rollback ].	self participantsDo: [ :each | each disconnect ].	self dismiss.	self dismissTransaction.	self state: #new</body><body package="Database">getSession	"Answer an instance of the driver's subclass of ExternalDatabaseSession."	self isConnected ifFalse:		[ self class connectionNotOpenSignal raise ].	^cachedSession notNil		ifTrue:	[ | session |				session := cachedSession.				cachedSession := nil.				session ]		ifFalse:	[ self class sessionClass newForConnection: self ]</body><body package="Database">prepare: aString 	"Answer an instance of the driver's subclass of ExternalDatabaseSession	and prepare the SQL text in aString for processing. The number of active	sessions is driver-dependent."	^self getSession prepare: aString</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>testing</category><body package="Database">inTransactionMode	"Answer true if a multi-statement transaction has been started."	| xact |	^(xact := self transaction) isNil		ifTrue:	[ false ]		ifFalse:	[ xact inTransactionMode ]</body><body package="Database">isConnected	"Answer whether receiver is connected to database."	| stateTemp |	^((stateTemp := self state) == #new or: [ stateTemp == #paused ]) not</body><body package="Database">isTransactionCoordinator	"Answer true if this connection has been designated as the	coordinator for a multiple connection transaction."	^self transactionCoordinator value</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>transactions</category><body package="Database">beTransactionCoordinator	"Designate this connection as the commit coordinator for a collection of connections.	Connections must be desginated as commit coordinators before they connect."	self state == #new		ifFalse:	[ self class invalidTransactionStateSignal raise ].	self transactionCoordinator value: true.	self acquireTransaction</body><body package="Database">begin	"Mark the beginning of a multi-statement transaction.  This is necessary if	the transaction needs to include more than one statement in the transaction."	self inTransactionMode		ifTrue:	[ ^self class invalidTransactionStateSignal raise ].	self transaction begin</body><body package="Database">commit	"Commit all database changes made during the current multi-statement transaction."	self inTransactionMode		ifTrue:	[ self transaction commit ]</body><body package="Database">rollback	"Rollback all database changes made during the current multi-statement transaction."	self inTransactionMode		ifTrue:	[ self transaction rollback ]</body><body package="Database">transactionCoordinatorFor: aConnection	"Designate this connection as the commit coordinator for aConnection.  If the	receiver is not currently a transaction coordinator and is not connected, it will	be designated as such.  aConnection must not be connected."	"Become a transaction coordinator if not already."	self state == #new		ifTrue:			[ self isTransactionCoordinator				ifFalse: [ self beTransactionCoordinator ] ]		ifFalse:			[ self isTransactionCoordinator				ifFalse: [ self class invalidTransactionStateSignal raise ] ].	"Enforce: aConnection isn't a transaction coordinator and is not connected."	(aConnection isConnected or: [aConnection isTransactionCoordinator])		ifTrue:	[ self class invalidTransactionStateSignal raise ].		"aConnection assumes receiver's transaction."	aConnection useTransaction: self transaction</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>private-accessing</category><body package="Database">isolationLevel	"Answer the current isolation level."	^isolationLevel</body><body package="Database">isolationLevel: anIsolationLevel	"Set the current isolation level."	self subclassResponsibility.</body><body package="Database">platformType	"Answer the current platform type"	^self class platformType</body><body package="Database">transaction	"Answer the transaction for commit/rollback coordination."	^transaction</body><body package="Database">transaction: aTransaction	"Set the transaction for commit/rollback coordination."	transaction := aTransaction</body><body package="Database">transactionCoordinator	^transactionCoordinator</body><body package="Database">transactionCoordinator: anExternalDatabaseValueHolder	transactionCoordinator := anExternalDatabaseValueHolder</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>private-activation</category><body package="Database">acquire: aPassword	"Time to acquire any external resources."	(self acquireExternal: aPassword) notNil		ifTrue:	[ self class register: self ]</body><body package="Database">acquireTransaction	"If we don't have a transaction object, arrange for one."	self transaction isNil ifTrue:		[ self useTransaction: self class transactionClass new ]</body><body package="Database">activate	super activate.	self state: #xactNo</body><body package="Database">dismissTransaction	"We don't need our transaction object any more."	self transaction dismiss.	self transaction removeParticipant: self.	self transaction: nil</body><body package="Database">quiesce	"Time to quiesce all connections to external resources."	"Enforce-quietly: receiver is connected."	self isConnected ifFalse: [ ^self ].	"If we're in a transaction, roll it back now to assure a consistent state."	self inTransactionMode ifTrue:		 [ self rollback ].	super quiesce</body><body package="Database">useTransaction: aTransaction	"Use aTransaction as our transaction."	self transaction: aTransaction.	self transaction addParticipant: self.	self transaction acquire</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>private-finalization</category><body package="Database">executor	"Answer with the executor."	"Subclassess will want to override to add information to the executor. 	The subclass method should use super executor to create the executor 	initially."	| ex |	ex := super executor.	ex transaction: self transaction.	ex transactionCoordinator: self transactionCoordinator.	^ex</body><body package="Database">finalizeExternal	"Release all external resource."	( traceLevel &gt;= 1 )		ifTrue:	[ self class trace: nil ].	self transaction addParticipant: self.	self inTransactionMode ifTrue:		[ "Assert: the connection cannot be in the paused state."		self transaction executorFinishingTransaction ].	self transaction dismiss.	super finalizeExternal</body></methods><methods><class-id>Database.ExternalDatabaseConnection</class-id> <category>private-library calls</category><body package="Database">acquireExternal	"Dispatch to proper method for connection classes."	self acquireExternal: self password</body><body package="Database">acquireExternal: aPassword	"Acquire the external resources involved with a connection to the 	SQL-environment."	"The username, password, and environment variables may be nil to indicate that	the proper value is unknown or an empty string to indicate that the DBMS is expected	to take the default. If the value for one of these variables is required, raise the proceedable	signal requiredUsernameSignal, requiredPasswordSignal, or requiredEnvironmentSignal and	use the proceed value.  Do not record this value in the instance variable."	self subclassResponsibility	"Note: implementations of this method are expected to use		self class mapLogical: self environment	in order to determine the proper environment string to use."</body><body package="Database">beginExternal	"Mark the beginning of receiver's portion of a transaction. Most 	dbms define this as a side-effect of using a transaction-initiating 	statement. This is provided as a convenience for drivers that 	require knowledge of the event to control their state machines."	self isConnected ifFalse:		[ ^self class connectionNotOpenSignal raise  ].	self state == #xactNo		ifTrue:	[ self state: #xactYes ]	"Drivers with a transaction concept that spans multiple connections	may never invoke this method. Thus, those drivers should overide	this with ^self shouldNotImplement."</body><body package="Database">commitExternal	"Commit all changes made by receiver's connection."	| wasInTrans |	(wasInTrans := (self state == #xactYes))		ifTrue:	[ self state: #xactNo ].	^wasInTrans	"Drivers with a transaction concept that spans multiple connections	may never invoke this method. Thus, those drivers should overide	this with ^self shouldNotImplement."</body><body package="Database">rollbackExternal	"Rollback all changes made by receiver's connection."	| wasInTrans |	(wasInTrans := (self state == #xactYes))		ifTrue:	[ self state: #xactNo ].	^wasInTrans	"Drivers with a transaction concept that spans multiple connections	may never invoke  this method. Thus, those drivers should overide	this with ^self shouldNotImplement."</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>class initialization</category><body package="Database">initialize	"Establish class variables."	"ExternalDatabaseConnection initialize"	| theLens |	(ObjectMemory dependents includes: self) ifFalse:		[ ObjectMemory addDependent: self ].	(theLens := #{LensSession} valueOrDo: [nil]) notNil ifTrue:		[ theLens initializeAllSignals ].</body><body package="Database">obsolete	"This class is being removed from the system."	(ObjectMemory dependents includes: self)		ifTrue:	[ ObjectMemory removeDependent: self ].	super obsolete</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>instance creation</category><body package="Database">new	"Create a valid, but empty, connection object."	| defaultName defaultClass |	self == ExternalDatabaseConnection 		ifTrue: 			[((defaultName := self defaultConnection) isNil or: 					[(defaultClass := ((defaultName asQualifiedReference)								home: self environment;								yourself) valueOrDo: [nil]) 						isNil]) 				ifTrue: [defaultClass := self noDefaultConnectionSignal raiseRequest].			^defaultClass new]		ifFalse: [^self basicNew initialize]</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>accessing</category><body package="Database">defaultConnection	"Answer the class name for the default Connection to use when creating connections."	^DefaultConnection</body><body package="Database">defaultConnection: aClassName	"Set the class name for the default Connection to use when creating connections."	DefaultConnection := aClassName</body><body package="Database">defaultEnvironment	"Answer the default logical environment to use when creating connections."	^DefaultEnvironment</body><body package="Database">defaultEnvironment: aString 	"Set the default logical environment to use when creating connections."	DefaultEnvironment := aString</body><body package="Database">kind	"Answer a symbol representing the type of DMBS for which the receiver provides services.  Return nil if the class is abstract, not itself usable to connect to a database.  The kind symbol is also be used to sort lists of connection classes."	^nil</body><body package="Database">version	^(#EXDIversion &lt;&lt; #database &gt;&gt; 'External Database Interface - Release 7.0') asString</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>activation</category><body package="Database">pause	"Direct this driver (or all drivers if receiver is ExternalDatabaseConnection) to	indefinitely suspend operations."	"Subclasses must override to provide driver-specific behavior."	self == ExternalDatabaseConnection		ifTrue:	[ self subclasses do: [ :each | each pause ]. ]		ifFalse:	[ self subclassResponsibility ].</body><body package="Database">resume	"Direct this driver (or all drivers if receiver is ExternalDatabaseConnection) to	resume suspended operations."	"Subclasses must override to provide driver-specific behavior."	self == ExternalDatabaseConnection		ifTrue:	[ self subclasses do: [ :each | each resume ]. ]		ifFalse:	[ self subclassResponsibility ].</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>environment mapping</category><body package="Database">addLogical: aLogicalEnvironmentString environment: anEnvironmentSpecificationString 	"Add a new entry in the logical environment map which associates aLogicalEnvironmentString	as the logical name for the environment and anEnvironmentSpecificationString as  	the value to use when connecting."	| theClass |	self == ExternalDatabaseConnection		ifTrue: 			[DefaultConnection isNil				ifTrue: 					[self error: #errDefaultConnection &lt;&lt; #database &gt;&gt; 'Establish a defaultConnection: first'.					^self].			theClass := self environment at: DefaultConnection]		ifFalse: [theClass := self].	theClass environments at: aLogicalEnvironmentString put: anEnvironmentSpecificationString</body><body package="Database">environments	"Answer dictionary containing all logical name -&gt; SQL-environment string mappings."	"Lazy initialization"	environmentMap isNil		ifTrue:	[ environmentMap := Dictionary new ].	"Answer the dictionary."	^environmentMap</body><body package="Database">mapLogical: aLogicalEnvironmentString 	"Answer the string to use for the environment in making a connection.	Answer  aLogicalEnvironmentString if it does not appearin the map."	"This is only sent from subclasses, so their distinct class-side instance	environments variable will be used."	^self environments at: aLogicalEnvironmentString ifAbsent: [ aLogicalEnvironmentString ]</body><body package="Database">removeLogical: aLogicalEnvironmentString 	"Remove an entry from the logical environment map."	| theClass |	self == ExternalDatabaseConnection		ifTrue: 			[DefaultConnection isNil ifTrue: [^self].			theClass := self environment at: DefaultConnection]		ifFalse: [theClass := self].	theClass environments removeKey: aLogicalEnvironmentString ifAbsent: []</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>signal constants</category><body package="Database">authenticationFailureSignal	"Answer the signal used to indicate that the server failed to authenticate the	username and/or password."	^AuthenticationFailure</body><body package="Database">connectionExceptionSignal	"Answer the parent for signals used to indicate problems in the ANSI-2 	exception class named connection exception."	^ConnectionException</body><body package="Database">connectionNotOpenSignal	"Answer the signal used to indicate that the connection does not have a	connection to the SQL-environment."	^ConnectionNotOpen</body><body package="Database">couldNotResolveServiceNameSignal	"Answer the signal used to indicate that the service name could not be resolved."	^CouldNotResolveServiceName</body><body package="Database">duplicateIndexesErrorSignal	"Answer the signal used to indicate attempting to add an index having the same	columns as an existing index."	^DuplicateIndexesError</body><body package="Database">dynamicSQLErrorSignal	"Answer the parent for signals used to indicate problems in the ANSI-2 	exception class named dynamic SQL error."	^DynamicSQLError</body><body package="Database">externalDatabaseErrorSignal	"Answer the most general external database error signal. This signal and its	descendents are not proceedable.  External database error signals may have	parameters defined.  Read the method which returns each signal for a definition."	^ExternalDatabaseException</body><body package="Database">externalDatabaseInformationSignal	"Answer the most general external database information signal. This signal and its	descendents are proceedable as they are usually used to collect missing information	or report conditions that the handler should be able to correct.  External database	information signals may have parameters defined.  Read the method which returns	each signal for a definition."	^ExternalDatabaseResumableException</body><body package="Database">externalDatabaseLibraryInaccessibleSignal	"Answer the signal used to indicate that a driver is not able to access the database library.	Either the OE does not contain the database library or it cannot be found in the search	path for dynamic link libraries."	^ExternalDatabaseLibraryInaccessible</body><body package="Database">externalDatabaseTransactionErrorSignal 	"An attempt to commit/rollback a database transaction failed."	^ExternalDatabaseTransactionError</body><body package="Database">indexConflictSignal	"Answer the signal indicating attempt to insert or update an object so that it has the same 	index value as another object."	^IndexConflict</body><body package="Database">invalidConnectionStateSignal	"Answer the signal used to indicate that the application cannot use a function at a given time."	^InvalidConnectionState</body><body package="Database">invalidDescriptorCountSignal	"Answer the signal used to indicate that there are more input variables in an 	SQL statement than are found in the bind object."	^InvalidDescriptorCount</body><body package="Database">invalidParameterMarkerSignal 	"Answer the signal used to indicate that the parameter marker is incorrect."	^InvalidParameterMarker</body><body package="Database">invalidSessionStateSignal	"Answer the signal used to indicate that the application cannot use a function at a given time."	^InvalidSessionState</body><body package="Database">invalidTableNameSignal	"The query specified an invalid table name"	^InvalidTableName</body><body package="Database">invalidTransactionStateSignal	"Answer the signal used to indicate that the application cannot use a function at a given time."	^InvalidTransactionState</body><body package="Database">missingBindVariableSignal	"Answer the signal used to indicate that a bind variable is missing."	^MissingBindVariable</body><body package="Database">noDefaultConnectionSignal	"Answer the signal to report that ExternalDatabaseConnection doesn't know	which Connection to use for a new connection."	^NoDefaultConnection</body><body package="Database">objectLockedSignal	"Answer the signal indicating that an object is locked when attempting to change it in the database."	^ObjectLocked</body><body package="Database">requiredEnvironmentSignal	"Answer the signal to report that the environment is a required parameter	by this driver and no default was specified."	^RequiredEnvironment</body><body package="Database">requiredPasswordSignal	"Answer the signal used to indicate that a password is required in order to 	connect. This signal is proceedable and expects a password string as the 	proceedWith: value."	^RequiredPassword</body><body package="Database">requiredUsernameSignal	"Answer the signal used to indicate that a username is required in order to 	connect. This signal is proceedable and expects a username string as the 	proceedWith: value."	^RequiredUsername</body><body package="Database">rowIsReferencedErrorSignal	"Answer the signal indicating that a row may not be deleted nor the primary key changed because it is still referenced."	^RowIsReferencedError</body><body package="Database">syntaxErrorSignal	"Answer the signal used to indicate that the SQL text could not be prepared."	^SQLSyntaxError</body><body package="Database">tooManyActiveConnectionsSignal	"Answer the signal used to indicate that the driver for this connection already	has the maximum number of active connections."	^TooManyActiveConnections</body><body package="Database">tooManyActiveSessionsSignal	"Answer the signal used to indicate that the connection already	has the maximum number of active sessions."	^TooManyActiveSessions</body><body package="Database">tooManyActiveTransactionsSignal	"Answer the signal used to indicate that the driver for this connection already	has the maximum number of active transactions."	^TooManyActiveTransactions</body><body package="Database">transactionExceptionSignal	"Answer the signal used to indicate an error in transaction processing."	^TransactionException</body><body package="Database">transactionPhase2FatalSignal 	"Answer the signal used to indicate a fatal error in the second phase of	a two-phase commit or rollback.  This usually means that manual recovery	will be required to complete the transaction."	^TransactionPhase2Fatal</body><body package="Database">unableToAllocateHandleSignal	"A handle could not be allocated."	^UnableToAllocateHandle</body><body package="Database">unableToBindSignal	"Answer the signal used to indicate that the input or output bind was unsuccessful."	^UnableToBind</body><body package="Database">unableToCancelCursorSignal	"The database cursor (statement) could not be canceled.  This signal is not proceedable."	^UnableToCancelCursor</body><body package="Database">unableToCloseCursorSignal	"The database cursor could not be closed.  This signal is proceedable."	^UnableToCloseCursor</body><body package="Database">unableToConnectToSQLenvironmentSignal	"Answer the signal used to indicate that the connection cannot be	made to the database environment for some reason other than the server itself.	This signal is used when it is possible to segregate the error causes, otherwise	unableToConnectToSQLserverSignal should be used."	^UnableToConnectToSQLenvironment</body><body package="Database">unableToConnectToSQLserverSignal	"Answer the signal used to indicate that the connection cannot be	made to the database server.  This signal is used when it is the server that	is the cause of the failure.  If it is possible to segregate the errors, an	unableToConnectToSQLEnvironmentSignal should be used."	^UnableToConnectToSQLserver</body><body package="Database">unableToCreateConnectionPoolSignal	"The database cursor could not be opened."	^UnableToCreateConnectionPool</body><body package="Database">unableToDescribeSignal	"Answer the signal used to indicate that description of a input variable	or an output column could not be acquired."	^UnableToDescribe</body><body package="Database">unableToDestroyConnectionPoolSignal	"The database cursor could not be opened."	^UnableToDestroyConnectionPool</body><body package="Database">unableToDisconnectSignal	"Answer the signal used to indicate that an error occurred when trying to	end the connection.   This signal is proceedable."	^UnableToDisconnect</body><body package="Database">unableToExecuteSQLSignal	"Answer the signal used to indicate that the prepared SQL text could not be executed."	^UnableToExecuteSQL</body><body package="Database">unableToFetchDataSignal	"Answer the signal used to indicate that the row or rows could not be fetched."	^UnableToFetchData</body><body package="Database">unableToFreeResourceSignal	"An external resource could not be released/dropped/free'd."	^UnableToFreeResource</body><body package="Database">unableToOpenCursorSignal	"The database cursor could not be opened."	^UnableToOpenCursor</body><body package="Database">unableToPrepareSignal	"Unable to prepare an SQL statement."	^UnableToPrepare</body><body package="Database">unableToQueryDriverInformationSignal	"Driver information could not be queried."	^UnableToQueryDriverInformation</body><body package="Database">unableToQueryHandleInformationSignal	"Driver information could not be queried."	^UnableToQueryHandleInformation</body><body package="Database">unableToSetEnvironmentAttributeSignal	"The database cursor could not be opened."	^UnableToSetEnvironmentAttribute</body><body package="Database">unsupportedCursorTypeSignal	"Answer the signal to report that the loaded client library does not support scrollable cursors."	^UnsupportedCursorType</body><body package="Database">unsupportedDataTypeSignal	"Answer the signal to report that the loaded client library does not support scrollable cursors."	^UnsupportedDataType</body><body package="Database">unsupportedDriverFunctionalitySignal	"Answer the signal indicating an attempt was made to use functionality which is not available from the underlying API due to the current execution circumstances."	^UnsupportedDriverFunctionality</body><body package="Database">unsupportedIsolationLevelSignal	"Answer the signal indicating an attempt was made to set an unsupported isolation level."	^UnsupportedIsolationLevel</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>tracing</category><body package="Database">toggleTracing	"Enable/disable a coarse level of tracing"	"ExternalDatabaseConnection toggleTracing"	Transcript cr; show: (#databaseTracing &lt;&lt; #database &gt;&gt; 'Database tracing ').	( TraceLevel isNil or: [ TraceLevel == 0 ] )		ifTrue:	[ self traceCollector: Transcript.				self traceLevel: 1.				Transcript show: (#enabled &lt;&lt; #database &gt;&gt; 'enabled') asString ]		ifFalse:	[ self traceLevel: 0.				Transcript show: (#disabled &lt;&lt; #database &gt;&gt; 'disabled') asString ].	Transcript flush.</body><body package="Database">traceCollector	"Answer the stream currently receiving any trace output."	^TraceCollector</body><body package="Database">traceCollector: aWriteStream	"Setup a stream to receive any trace output."	TraceCollector := aWriteStream</body><body package="Database">traceLevel: anInteger	"Set the level of tracing that is enabled for this class to anInteger."	TraceLevel := anInteger</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>private-accessing</category><body package="Database">columnDescriptionClass	"Answer the class to use for column description objects associated with receiver."	^ExternalDatabaseColumnDescription</body><body package="Database">connectionClass	^self</body><body package="Database">myDependents	"Answer the receiver's dependents or nil."	^dependents</body><body package="Database">myDependents: dependentsOrNil	"Set the receivers dependents."	dependents := dependentsOrNil</body><body package="Database">platformType	"Answer the current platform type."	PlatformType isNil		ifTrue: [ PlatformType := self determinePlatformType ].	^PlatformType</body><body package="Database">sessionClass	"Answer the class to use for session objects associated with receiver."	^self subclassResponsibility</body><body package="Database">transactionClass	"Answer the class to use for transaction objects associated with receiver."	^self subclassResponsibility</body><body package="Database">xif	"Answer the ExternalInterface subclass instance to use." 	^self subclassResponsibility</body><body package="Database">xif: anExternalInterface	"Set the ExternalInterface subclass instance to use." 	xif := anExternalInterface</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>private-activation</category><body package="Database">determinePlatformType	"Answer a symbol representing the current platform type."	"ExternalInterface must complete its #returnFromSnapshot processing before	this method can be safely invoked."	| platformArray platformSymbol osNameString |	platformArray := ExternalInterface currentPlatform.	platformSymbol := platformArray at: 1.	osNameString := platformArray at: 2.	#unix == platformSymbol		ifTrue: [^self determineUnixPlatformFrom: osNameString].	#win32 == platformSymbol		ifTrue: [^self determineWinTelPlatformFrom: osNameString].	^#unknown.</body><body package="Database">determineUnixPlatformFrom: unixOSNameString	"Answer a symbol representing the current platform type."	"ExternalInterface must complete its #returnFromSnapshot processing before	this method can be safely invoked."	| tokens |	tokens := unixOSNameString tokensBasedOn: Character space.	(tokens includes: 'aix') ifTrue: [^#aix_unix].	(tokens includes: 'solaris') ifTrue: [^#sun5_unix].	(tokens includes: 'solaris64') ifTrue:[^#unix_sysV_sun_solaris64].	((tokens includes: 'I386') and: [tokens includes: 'linux']) ifTrue: [^#linux_i386_unix].	((tokens includes: 'x86_64') and: [tokens includes: 'linux']) ifTrue: [^#linux_x86_64_unix].	((tokens includes: 'x86_64') and: [tokens includes: 'MacOSX']) ifTrue: [^#macOSX64].	((tokens includes: 'I386') and: [tokens includes: 'MacOSX']) ifTrue: [^#macOSX].	^#unknown</body><body package="Database">determineWinTelPlatformFrom: osNameString	"Answer a symbol representing the current platform type."	"ExternalInterface must complete its #returnFromSnapshot processing before	this method can be safely invoked."	"WinNT 64-bit ^#nt64		WinNT  ^#nt				Win95 ^#win95	Win3.1 ^#win32s"	| tokens |	tokens := osNameString tokensBasedOn: Character space.	(tokens includes: 'nt')		ifTrue: [^(tokens includes: 'x64') ifTrue: [#nt64] ifFalse: [#nt]].	(tokens includes: '95') ifTrue: [^#win95].	^#win32s</body><body package="Database">install	"Direct this driver (or all drivers if receiver is ExternalDatabaseConnection) to	take the necessary steps for returning from a snapshot.  Notify dependents	when fully installed so that appropriate action may be taken."	"ExternalDatabaseConnection install"	PlatformType := nil.	self == ExternalDatabaseConnection		ifTrue:	[ self subclasses do: [ :each | each install ] ]		ifFalse:	[ self subclassResponsibility ].	"Driver implementations should arrange for each class with a registry to perform	returnFromSnapshot (and anything else important, of course)."</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>private-updating</category><body package="Database">update: anAspectSymbol with: aParameter from: aSender 	"In order to aid in sequencing of activities, clients may become dependents of ExternalDatabaseConnection rather than ObjectMemory.  All notifications from ObjectMemory are passed on as if they came from the receiver."	aSender == ObjectMemory ifTrue:		[ "Sometimes the notice should be sent out first so dependents can act before we do."		anAspectSymbol == #aboutToQuit ifTrue:			[ self changed: anAspectSymbol with: aParameter.			^self pause ].		"In other cases, we need to act before notifying the dependents.  Note: fall through to the notification."		anAspectSymbol == #returnFromSnapshot ifTrue:			[ self install ].		"And sometimes we're just sending it on."		self changed: anAspectSymbol with: aParameter ]</body></methods><methods><class-id>Database.ExternalDatabaseConnection class</class-id> <category>testing</category><body package="Database">supportMethod: selector	"Answer true if the loaded libraries of the interface contain the selector.  Raise an externalDatabaseLibraryInaccessibleSignal if not."	| testMethod mappedMethodHandle xifClass testMethodClass |	xifClass := self xif class.	testMethod := xifClass findSelector: selector.	testMethod isNil ifTrue: [^false].	"findSelector: returns either nil or an #(implementor method) array"	testMethodClass := testMethod first.	testMethod := testMethod last.	(testMethod class respondsTo: #mapAddressFor:library:) ifFalse: 		[(testMethod isKindOf: AnnotatedMethod)			ifFalse: [^false]			ifTrue: [testMethod := testMethodClass compiledMethodAt: (testMethod basicAt: 1)]].	xifClass libraryFiles		detect: 			[:aLibrary |			([mappedMethodHandle := testMethod class mapAddressFor: testMethod library: aLibrary]				on: xifClass libraryFilesSearchSignals				do: [:ex | ex return: nil]) notNil]		ifNone: [mappedMethodHandle := testMethod class mapStaticFor: testMethod].	^mappedMethodHandle notNil</body></methods><methods><class-id>Database.UnableToConnectToSQLserver</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errDatabaseSeverConnection &lt;&lt; #database &gt;&gt; 'Connection Exception--unable to connect to database server') asString</body></methods><methods><class-id>Database.TooManyActiveTransactions</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errMaxTransactionsDriver &lt;&lt; #database &gt;&gt; 'The maximum number of transactions are already active for this driver') asString</body></methods><methods><class-id>Database.ConnectionNotOpen</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#connectionNotOpen &lt;&lt; #database &gt;&gt; 'Connection Exception--connection not open') asString</body></methods><methods><class-id>Database.UnsupportedCursorType</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#unsupportedCursorType &lt;&lt; #database &gt;&gt; 'The loaded Client Library does not support scrollable cursors.') asString</body></methods><methods><class-id>Database.TooManyActiveConnections</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errConnectionMaxDriver &lt;&lt; #database &gt;&gt; 'The maximum number of connections are already active for this driver') asString</body></methods><methods><class-id>Database.UnableToExecuteSQL</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errExecuteSQL &lt;&lt; #database &gt;&gt; 'Unable to execute the prepared SQL text') asString</body></methods><methods><class-id>Database.SQLSyntaxError</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errSQLSyntax &lt;&lt; #database &gt;&gt; 'Syntax error or access rule violation in SQL dynamic statement') asString</body></methods><methods><class-id>Database.UnableToCloseCursor</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errCursorClosed &lt;&lt; #database &gt;&gt; 'The database cursor could not be closed.') asString</body></methods><methods><class-id>Database.ExternalDatabaseTransactionError</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errCommitRollbackFailed &lt;&lt; #database  &gt;&gt; 'An attempt to commit/rollback a database transaction failed.') asString</body></methods><methods><class-id>Database.AuthenticationFailure</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errUsernamePassword &lt;&lt; #database &gt;&gt; 'Invalid username/password') asString</body></methods><methods><class-id>Database.UnableToConnectToSQLenvironment</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errDatabaseEvironment &lt;&lt; #database &gt;&gt; 'Connection Exception--unable to connect to database environment') asString</body></methods><methods><class-id>Database.UnsupportedDataType</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#unsupportedDataType &lt;&lt; #database &gt;&gt; 'Unsupported data type is used.') asString</body></methods><methods><class-id>Database.DBProfileManager</class-id> <category>private</category><body package="Database">connectedProfileIcon	^connectedIcon ifNil: 		[connectedIcon := ToolbarIconLibrary visualFor: #database]</body><body package="Database">refreshProfileView	(self widgetAt: #profileDataset) invalidate</body><body package="Database">setProfileList: aList	self profileListHolder list: Profiles</body><body package="Database">statusColumnSpec	^ArbitraryViewSpec new		source: #statusColumnVisual:;		flags: 0</body><body package="Database">statusColumnVisual: isConnected 	^isConnected 		ifTrue: [self connectedProfileIcon]		ifFalse: [VisualPart new]</body><body package="Database">updateToolbar	(self widgetAt: #toolbarMenu) updateToolBar.</body></methods><methods><class-id>Database.DBProfileManager</class-id> <category>initialize-release</category><body package="Database">initialize	super initialize.	"DbRegistry connectedProfileHolder		onChangeSend: #connectedProfileChanged		to: self"</body><body package="Database">on: aProfileCollection	self setProfileList: aProfileCollection</body><body package="Database">postBuildWith: aBuilder	| descriptors |	descriptors := (self widgetAt: #profileDataset) columnDescriptors.	descriptors first rendererSpec: self statusColumnSpec.</body><body package="Database">release	super release.	"DbRegistry connectedProfileHolder		retractInterestsFor: self"</body></methods><methods><class-id>Database.DBProfileManager</class-id> <category>actions</category><body package="Database">fileClose	self closeRequest</body><body package="Database">fileImport	self class importProfilesFromFile</body><body package="Database">fileSave	self class saveProfilesToFile</body><body package="Database">helpAbout	AboutVisualWorksDialog open</body><body package="Database">profileNew	DBProfileManager addProfileFromUser ifNotNil: 		[:newProfile | self profileListHolder selection: newProfile]</body><body package="Database">profileProperties	self profileListHolder selectionDo:		[:selection |		DBProfilePropertiesDialog openOn: selection.		self class updateProfile: selection]</body><body package="Database">profileRemove	self profileListHolder selectionDo:		[:selection |		(Dialog confirm: #repmanRemoveProfileQuestion &lt;&lt; #labels &gt;&gt; 'Remove the selected profile?') 			ifTrue: [self class removeProfile: selection]]</body><body package="Database">profileToggleConnection	"See #repositoryToggleConnection for where this came from.  Unlike Store, we have no 'one connection only at a time' paradigm, so cannot map a profile to its 'single connection or else nil' one-to-one.  So we implement a no-op to prevent the tool crashing while we ponder what to do here.  See also my #menuBar's commented-out reference to #repositoryToggleConnectionItemLabel if kit is every desired to show an icon statuus with this.	For now, just open the query tool so the user can connect from there.  DEVELOP THIS SO THAT (a) it opens on the tool with the selected profile as the selected one in 'connct'  (b) before that, sewarch instances of AdHocQueryTool - if one is open and has the chosen profile selected, bring it to front. "	AdHocQueryTool open.</body></methods><methods><class-id>Database.DBProfileManager</class-id> <category>notifications</category><body package="Database">connectedProfileChanged	self refreshProfileView</body><body package="Database">noticeOfWindowClose: aWindow	self release.	^super noticeOfWindowClose: aWindow</body><body package="Database">profileListDoubleClicked	self profileToggleConnection</body><body package="Database">profileSelected	self updateToolbar</body></methods><methods><class-id>Database.DBProfileManager</class-id> <category>aspects</category><body package="Database">profileListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^profileListHolder isNil		ifTrue:			[profileListHolder :=  SelectionInList new]		ifFalse:			[profileListHolder]</body><body package="Database">selectedProfileHolder	^self profileListHolder selectionHolder</body></methods><methods><class-id>Database.DBProfileManager</class-id> <category>menus</category><body package="Database">menuBar	| menu |	menu := self class menuBar.	menu		augmentFrom: self class		to: DBProfileManager		menuName: #menuBar		for: self.	"(menu atNameKey: #profileToggleConnection) 		rawLabel: [self profileToggleConnectionItemLabel]."	^menu</body><body package="Database">profileListMenu	| menu |	menu := self class profileListMenu.	menu 		augmentFrom: self class		to: DBProfileManager		menuName: #listMenu		for: self.	"(menu atNameKey: #profileToggleConnection) 		rawLabel: [self profileToggleConnectionItemLabel]."	^menu</body></methods><methods><class-id>Database.DBProfileManager</class-id> <category>testing</category><body package="Database">isProfileSelected	^self profileListHolder selectionIndex ~= 0</body></methods><methods><class-id>Database.DBProfileManager class</class-id> <category>instance creation</category><body package="Database">new	^super new on: self profiles</body><body package="Database">open	"Override to use the currently-open manager, if one exists."	^self raiseSingleInstance ifNil: [super open]</body></methods><methods><class-id>Database.DBProfileManager class</class-id> <category>private</category><body package="Database">addProfiles: aCollection	Profiles 		removeAllSuchThat: 			[:existingProfile | 			aCollection anySatisfy: [:newProfile| newProfile = existingProfile]];		addAll: aCollection;		sortWith: [:a :b | a name &lt; b name]</body><body package="Database">importProfilesFromXmlOn: aStream	| loadedProfiles |	loadedProfiles := self profilesFromXmlOn: aStream.	self addProfiles: loadedProfiles</body><body package="Database">printProfilesAsXmlOn: aStream	| writer |	aStream nextPutAll: '&lt;?xml version="1.0"?&gt;'; cr.	writer := SAXWriter new output: aStream.	self profilesAsXmlDocument saxDo: writer</body><body package="Database">profilesAsXmlDocument	| document root |	document := Document new.	root := Element tag: 'store-profiles'.	document addNode: root.	Profiles do:		[:each | root addNode: each asXmlNode].	^document</body><body package="Database">profilesFromXmlOn: aStream 	| parser document loadedProfiles |	parser := XMLParser new.	parser validate: false.	document := parser parse: aStream.	document root tag type = 'store-profiles' ifFalse: 		[self error: 'invalid file format'].	loadedProfiles := document root children collect: 		[:each | ConnectionProfile fromXmlElement: each].	^loadedProfiles</body><body package="Database">replaceProfilesWith: aCollection	Profiles 		removeAllSuchThat: [:anything | true];		addAll: aCollection;		sortWith: [:a :b | a name &lt; b name]</body></methods><methods><class-id>Database.DBProfileManager class</class-id> <category>utilities</category><body package="Database">addProfileFromUser	| newProfile |	newProfile := Database.ConnectionProfile new.	newProfile name: (#Profile1p &lt;&lt; #database &gt;&gt; 'Profile &lt;1p&gt;' expandMacrosWith: Profiles size + 1).	^(DBProfilePropertiesDialog openOn: newProfile) 		ifTrue: 			[self addProfile: newProfile.			newProfile]		ifFalse: [nil]</body><body package="Database">importProfilesFromFile	| stream dialog filename |	dialog := OpenFileDialog new.	dialog		windowTitle: (#importProfilesFilesNamed1C &gt;&gt; 'Import profiles file named:' &lt;&lt; #dialogs);		acceptButtonLabel: #import &gt;&gt; 'Import' &lt;&lt; #dialogs;		addFileFilter: 'XML file (*.xml)' pattern: '*.xml';		defaultFilename: 'profiles.xml';		fileCondition: #mustBeOld.	filename := dialog select ifNil: [^self].	stream := filename readStream.	[self importProfilesFromXmlOn: stream] ensure: [stream close]</body><body package="Database">saveProfilesToFile	| filenameString output |	filenameString := Dialog 		requestFileName: #SaveProfilesToFileNamed &lt;&lt; #database &gt;&gt; 'Save profiles to file named:'		default: 'profiles.xml'.	filenameString isEmpty ifTrue: [^self].	output := filenameString asFilename writeStream.	[self printProfilesAsXmlOn: output] ensure: [output close]</body></methods><methods><class-id>Database.DBProfileManager class</class-id> <category>accessing</category><body package="Database">addProfile: aProfile	Profiles 		add: aProfile;		sortWith: [:a :b | a name &lt; b name]</body><body package="Database">profiles	^Profiles</body><body package="Database">removeProfile: aProfile	Profiles remove: aProfile</body><body package="Database">sortProfileList	Profiles sortWith: [:a :b | a name &lt; b name]</body><body package="Database">updateProfile: aProfile	| index |	index := Profiles indexOf: aProfile.	index = 0 ifFalse: [Profiles changed: #at: with: index].	#{Store.DbRegistry} ifDefinedDo:		[:registry|		registry connectedProfileHolder value = aProfile ifTrue: 			[registry connectedProfileHolder changed: #value]]</body></methods><methods><class-id>Database.DynamicSQLError</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errDynamicSQL &lt;&lt; #database &gt;&gt; 'Dynamic SQL Error') asString</body></methods><methods><class-id>Database.ConnectionProfile</class-id> <category>accessing</category><body package="Database">asConnection	^self driverClass new		environment: self environment;		username: self userName;		yourself</body><body package="Database">displayString	^name isNil		ifTrue: [String new]		ifFalse: [name]</body><body package="Database">driverClass	^self driverClassName asQualifiedReference value</body><body package="Database">driverClassName	^driverClassName</body><body package="Database">driverClassName: aSymbol	"In VW8.2 and after, the former ability of this instvar to hold a String or a Symbol is restricted to its only ever holding symbols.  The asSymbol here ensures conversion so scripts written before 8.2 can run in 8.2 and after.  The guarded deprecation warning allows users to find and change such scripts.  Thus it is not this method that is deprecated, just the calling of it with a string-valued parameter."	aSymbol isSymbol ifFalse:		[self deprecated: #(#version '8.2' #use 'Symbol arguments only, driverClassName: will no longer support String values')].	driverClassName := aSymbol asSymbol.</body><body package="Database">environment	^environment</body><body package="Database">environment: aString	environment := aString</body><body package="Database">name	^name</body><body package="Database">name: aString	name := aString.	originalName := aString</body><body package="Database">originalName	^originalName isNil		ifTrue: [String new]		ifFalse: [originalName]</body><body package="Database">password	^password</body><body package="Database">password: aString	password := aString</body><body package="Database">resetName	name := nil</body><body package="Database">userName	^userName</body><body package="Database">userName: aString	userName := aString</body></methods><methods><class-id>Database.ConnectionProfile</class-id> <category>comparing</category><body package="Database">= anObject	^(anObject isKindOf: ConnectionProfile) and:		[self name = anObject name]</body><body package="Database">hash	^name hash</body></methods><methods><class-id>Database.ConnectionProfile</class-id> <category>private</category><body package="Database">addXmlElementsTo: anElement	anElement		addNode: (self elementFor: 'driver-class-name' with: self driverClassName);		addNode: (self elementFor: 'environment' with: self environment);		addNode: (self elementFor: 'user-name' with: self userName);		addNode: (self elementFor: 'password' with: self password)</body><body package="Database">asXmlNode	| root |	root := XML.Element 		tag: 'database-profile' 		attributes: (Array with: (XML.Attribute name: 'name' value: name))		elements: nil.	self addXmlElementsTo: root.	^root</body><body package="Database">elementFor: tagString with: contentsString	^(XML.Element tag: tagString)		addNode: (XML.Text text: contentsString)</body><body package="Database">isSpecified: anObject	^anObject notNil and: [anObject isEmpty not]</body><body package="Database">valueOf: anElement childNamed: aString 	| children textElement |	children := (anElement elementNamed: aString) children.	children isEmpty ifTrue: [^String new].	textElement := children first.	textElement isText ifFalse: [self error: #invalidFileFormat &lt;&lt; #database &gt;&gt; 'invalid file format'].	^textElement text</body></methods><methods><class-id>Database.ConnectionProfile</class-id> <category>initialize-release</category><body package="Database">initialize	driverClassName := #''.	environment := String new.	password := String new.</body><body package="Database">initializeFromXml: anElement	name := anElement valueOfAttribute: 'name' ifAbsent: [self error: (#invalidFileFormat &lt;&lt; #database &gt;&gt; 'invalid file format') asString].	driverClassName := (self valueOf: anElement childNamed: 'driver-class-name') asSymbol.	environment := self valueOf: anElement childNamed: 'environment'.	userName := self valueOf: anElement childNamed: 'user-name'.	password := self valueOf: anElement childNamed: 'password'.	self isValid ifFalse: [self error: #invalidAttributesSpecifiedInTheFile &lt;&lt; #database &gt;&gt; 'invalid attributes specified in the file'].</body></methods><methods><class-id>Database.ConnectionProfile</class-id> <category>testing</category><body package="Database">isConnectable	"Answer if the receiver can be used to open a connection right now."	^self isValid and: [self driverClassName asQualifiedReference isDefined]</body><body package="Database">isValid	"A valid profile is one with enough data to open a connection in principle, assuming the necessary driver class is present in the image."	^(self isSpecified: driverClassName)		and: [self isSpecified: environment]</body><body package="Database">isValidForMultiUserDB	"SQLite does not need this much;  for most databases, this is essential."	^self isValid		and: [(self isSpecified: userName)		and:[self isSpecified: password]]</body></methods><methods><class-id>Database.ConnectionProfile class</class-id> <category>instance creation</category><body package="Database">defaultNew	|  profile databaseNames |	profile := self new.	databaseNames := self concreteDatabaseDriverClassNames.	databaseNames notEmpty		ifTrue: [profile driverClassName: databaseNames first].	^profile</body><body package="Database">fromXmlElement: anElement	^self new initializeFromXml: anElement</body><body package="Database">new	^super new initialize</body></methods><methods><class-id>Database.ConnectionProfile class</class-id> <category>accessing</category><body package="Database">concreteDatabaseDriverClassNames	^self concreteDatabaseDriverClasses collect: [:each | each name]</body><body package="Database">concreteDatabaseDriverClasses	^(ExternalDatabaseConnection allSubclasses select: [:cl | cl kind notNil])		sort: [:a :b | a kind &lt;= b kind]</body><body package="Database">lastUsedProfile	lastUsedProfile isNil ifTrue: [lastUsedProfile := self defaultNew].	^lastUsedProfile</body><body package="Database">lastUsedProfile: aConnectionProfile	lastUsedProfile := aConnectionProfile.</body></methods><methods><class-id>Tools.DBProfileListSetting</class-id> <category>persistence</category><body package="Database">addStateXmlElementsTo: anElement	profiles do: 		[:each |		anElement addNode: each asXmlNode]</body><body package="Database">restoreFrom: aSettingSnapshot	| newProfiles |	newProfiles := OrderedCollection new.	aSettingSnapshot stateNodes do:		[:each | | profile |		profile := ConnectionProfile fromXmlElement: each.		newProfiles add: profile].	profiles := newProfiles.	self installProfiles</body></methods><methods><class-id>Tools.DBProfileListSetting</class-id> <category>initialize-release</category><body package="Database">initialize	super initialize.	profiles := DBProfileManager profiles copy asList</body></methods><methods><class-id>Tools.DBProfileListSetting</class-id> <category>actions</category><body package="Database">installProfiles	DBProfileManager replaceProfilesWith: profiles</body><body package="Database">profiles	^profiles</body><body package="Database">resetProfiles	profiles := DBProfileManager profiles copy asList</body></methods><methods><class-id>Tools.DBProfileListSetting class</class-id> <category>instance creation</category><body package="Database">new	^super new initialize</body></methods><methods><class-id>Database.UnsupportedIsolationLevel</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#unsupportedIsolation &lt;&lt; #database &gt;&gt; 'An attempt was made to set an unsupported isolation level.') asString</body></methods><methods><class-id>Tools.DBProfilePropertiesDialog</class-id> <category>aspects</category><body package="Database">databaseHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^databaseHolder isNil		ifTrue:			[databaseHolder := String new asValue]		ifFalse:			[databaseHolder]</body><body package="Database">databaseListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^databaseListHolder isNil		ifTrue:			[databaseListHolder := List new asValue]		ifFalse:			[databaseListHolder]</body><body package="Database">environmentHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^environmentHolder isNil		ifTrue:			[environmentHolder := String new asValue]		ifFalse:			[environmentHolder]</body><body package="Database">nameHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^nameHolder isNil		ifTrue:			[nameHolder := String new asValue]		ifFalse:			[nameHolder]</body><body package="Database">passwordHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^passwordHolder isNil		ifTrue:			[passwordHolder := String new asValue]		ifFalse:			[passwordHolder]</body><body package="Database">userNameHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userNameHolder isNil		ifTrue:			[userNameHolder := String new asValue]		ifFalse:			[userNameHolder]</body></methods><methods><class-id>Tools.DBProfilePropertiesDialog</class-id> <category>private</category><body package="Database">canAccept	^self validateRequiredValues and: [self validateName]</body><body package="Database">hasRequiredValues	^(self isProvided: self nameHolder value)		and: [(self isProvided: self databaseHolder value)		and: [self isProvided: self userNameHolder value]]</body><body package="Database">isProvided: anObject	^anObject notNil and: [anObject notEmpty]</body><body package="Database">nameIsUnique	| name |	name := self nameHolder value.	^(DBProfileManager profiles anySatisfy: [:any | any name = name]) not		or: [profileHolder value name = name]</body><body package="Database">profileAspect: aSymbol	| aspect |	aspect := (AspectAdaptor forAspect: aSymbol)		subjectChannel: profileHolder;		yourself.	^BufferedValueHolder subject: aspect triggerChannel: acceptTrigger</body><body package="Database">validateName	^self nameIsUnique		ifTrue: [true]		ifFalse:			[Dialog warn:				((#nameXIsAlreadyInUsePleaseChooseAnother &lt;&lt; #dialogs &gt;&gt; 'The name "&lt;1s&gt;" is already in use. Please choose a different name.')					expandMacrosWith: self nameHolder value).			false]</body><body package="Database">validateRequiredValues	^self hasRequiredValues		ifTrue: [true]		ifFalse:			[Dialog warn: #aBunchOfValuesAreRequired &lt;&lt; #dialogs &gt;&gt; 'Name, interface, and a user name are required'.			false]</body></methods><methods><class-id>Tools.DBProfilePropertiesDialog</class-id> <category>initialize-release</category><body package="Database">initialize	super initialize.	self initializeAspects.	self databaseListHolder value: ConnectionProfile concreteDatabaseDriverClassNames.</body><body package="Database">initializeAspects	profileHolder := ValueHolder new.	acceptTrigger := false asValue.	nameHolder := self profileAspect: #name.	databaseHolder := (TypeConverter on: (self profileAspect: #driverClassName))		getBlock: [:m | m value asString]		putBlock: [:m :v | m value: v asSymbol]		updateBlock: [:m :a :p | true].	"must be valid by construction of the drop-down (user-typing barred)"	environmentHolder := self profileAspect: #environment.	userNameHolder := self profileAspect: #userName.	passwordHolder := self profileAspect: #password.</body><body package="Database">profile: aConnectionProfile	profileHolder value: aConnectionProfile</body></methods><methods><class-id>Tools.DBProfilePropertiesDialog</class-id> <category>actions</category><body package="Database">ok	self canAccept ifTrue:		[acceptTrigger value: true.		self accept value: true]</body></methods><methods><class-id>Tools.DBProfilePropertiesDialog class</class-id> <category>instance creation</category><body package="Database">openOn: aConnectionProfile	^self new		profile: aConnectionProfile;		open</body></methods><methods><class-id>Database.RowIsReferencedError</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errPrimaryKey &lt;&lt; #database &gt;&gt; 'You cannot change the primary key of&lt;n&gt;or delete a row which is referenced in another table.') expandMacros</body></methods><methods><class-id>Database.ExternalDatabaseColumnDescription</class-id> <category>accessing</category><body package="Database">index	"Answer the ordinal number of the column, or nil if unknown."	^index</body><body package="Database">maxColumnConstraint	"Answer the size of the buffer required to hold data for the column, or nil if unknown."	^length</body><body package="Database">name	"Answer the name of the column, or nil if unknown."	^name</body><body package="Database">nullable	"Answer true or false to indicate whether the column admits NULL, or nil if unknown."	^nullable</body><body package="Database">precision	"Answer the decimal precision of the column, or nil if unknown."	^precision</body><body package="Database">scale	"Answer the decimal scale of the column, or nil if unknown."	^scale</body><body package="Database">type	"Answer the Smalltalk class which will be used to hold data	from the column, or nil if unknown."	^type</body></methods><methods><class-id>Database.ExternalDatabaseColumnDescription</class-id> <category>printing</category><body package="Database">printOn: aStream 	"Append to the argument aStream a sequence of characters that identifies the 	receiver."	| colName colType |	super printOn: aStream.	aStream nextPut: $(.	(colName := self name) notNil ifTrue:		[ aStream			nextPutAll: (#ColumnName &lt;&lt; #database &gt;&gt; ' name=') asString;			nextPutAll: colName].	(colType := self type) notNil ifTrue:		[ aStream nextPutAll: (#Type &lt;&lt; #database &gt;&gt; ' type=') asString.		colType printOn: aStream ].	aStream nextPutAll: ' )'</body></methods><methods><class-id>Database.ExternalDatabaseColumnDescription</class-id> <category>private-accessing</category><body package="Database">index: aNumber	index := aNumber</body><body package="Database">maxColumnConstraint: anInteger	length := anInteger</body><body package="Database">name: aString	name := aString</body><body package="Database">nullable: aBoolean	nullable := aBoolean</body><body package="Database">precision: anInteger	precision := anInteger</body><body package="Database">scale: anInteger	scale := anInteger</body><body package="Database">type: aString	type := aString</body></methods><methods><class-id>Database.ByteFieldDescriptor</class-id> <category>initialize-release</category><body package="Database">template: aTemplate max: anInteger	template := aTemplate.	max := anInteger</body></methods><methods><class-id>Database.ByteFieldDescriptor</class-id> <category>accessing</category><body package="Database">MaxColumnConstraint	^max</body><body package="Database">Template	^template</body><body package="Database">Type	^template class maxColumnConstraint: max</body><body package="Database">yourself	^template</body></methods><methods><class-id>Database.ByteFieldDescriptor</class-id> <category>testing</category><body package="Database">includes: string	^false</body><body package="Database">isKindOf: aClass	"Answer a Boolean as to whether the class, aClass, is a superclass or class of	the receiver."	template class == aClass		ifTrue: [^true]		ifFalse: [^template class inheritsFrom: aClass]</body></methods><methods><class-id>Database.ByteFieldDescriptor</class-id> <category>printing</category><body package="Database">do: block	'&lt;byte field&gt;' do: [:c | block value: c]</body><body package="Database">printOn: stream	super printOn: stream.	max notNil		ifTrue:			[stream nextPutAll: (#Max &lt;&lt; #database &gt;&gt; ' (max=') asString.			max printOn: stream.			stream nextPut: $)]</body></methods><methods><class-id>Database.UnableToDisconnect</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errServerDisconnect &lt;&lt; #database &gt;&gt; 'Unable to disconnect from SQL-server') asString</body></methods><methods><class-id>Database.InvalidParameterMarker</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errParameterMarker &lt;&lt; #database &gt;&gt; 'Dynamic SQL Error--invalid parameter marker') asString</body></methods><methods><class-id>Database.RequiredEnvironment</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errEnvironment &lt;&lt; #database &gt;&gt; 'No environment was specified and there is no default defined') asString</body></methods><methods><class-id>Database.UnableToDescribe</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errObtainDescription &lt;&lt; #database &gt;&gt; 'Unable to obtain description') asString</body></methods><methods><class-id>Database.ObjectLocked</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#alreadyLockedObject &lt;&lt; #database &gt;&gt; 'Attempting to lock a locked object') asString</body></methods><methods><class-id>Database.ConnectionDialog</class-id> <category>aspects</category><body package="Database">connectionProfileHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^connectionProfileHolder isNil		ifTrue:			[connectionProfileHolder := String new asValue]		ifFalse:			[connectionProfileHolder]</body><body package="Database">connectionProfileListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^connectionProfileListHolder isNil		ifTrue:			[connectionProfileListHolder := List new asValue]		ifFalse:			[connectionProfileListHolder]</body><body package="Database">databaseHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^databaseHolder isNil		ifTrue:			[databaseHolder := String new asValue]		ifFalse:			[databaseHolder]</body><body package="Database">databaseListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^databaseListHolder isNil		ifTrue:			[databaseListHolder := List new asValue]		ifFalse:			[databaseListHolder]</body><body package="Database">environmentHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^environmentHolder isNil		ifTrue:			[environmentHolder := String new asValue]		ifFalse:			[environmentHolder]</body><body package="Database">environmentListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^environmentListHolder isNil		ifTrue:			[environmentListHolder := List new asValue]		ifFalse:			[environmentListHolder]</body><body package="Database">passwordHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^passwordHolder isNil		ifTrue:			[passwordHolder := String new asValue]		ifFalse:			[passwordHolder]</body><body package="Database">userNameHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userNameHolder isNil		ifTrue:			[userNameHolder := String new asValue]		ifFalse:			[userNameHolder]</body><body package="Database">userNameListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userNameListHolder isNil		ifTrue:			[userNameListHolder := List new asValue]		ifFalse:			[userNameListHolder]</body></methods><methods><class-id>Database.ConnectionDialog</class-id> <category>private-profile list</category><body package="Database">addOrReplaceProfile: aProfile	"If there is a profile with the same name as that of the argument,	replace it with the argument."	(self class profiles includes: aProfile) ifTrue: [self class profiles remove: aProfile].	self class profiles add: aProfile.</body><body package="Database">allProfiles	^self class profiles copyWith: self class connectionProfileClass lastUsedProfile</body><body package="Database">currentProfile	^currentProfileHolder value</body><body package="Database">currentProfile: aProfile	currentProfileHolder value: aProfile.	self connectionProfileHolder value:		((self class profiles anySatisfy: [:some | some name = aProfile name])			ifTrue: [aProfile name]			ifFalse: [nil])</body><body package="Database">deleteProfileNamed: aString	| profile |	profile := self class profiles detect: [:some | some name = aString].	self class profiles remove: profile</body><body package="Database">updateProfileList	self connectionProfileListHolder value: self knownProfileNames</body></methods><methods><class-id>Database.ConnectionDialog</class-id> <category>private</category><body package="Database">createNewProfile	"Use this when you do not want to reset the 'Connect to Repository...' default."	^self class connectionProfileClass defaultNew</body><body package="Database">knownEnvironmentStrings	^(self allProfiles collect: [:each | each environment]) asSet</body><body package="Database">knownProfileNames	^(self class profiles collect: [:each | each name]) asSortedCollection</body><body package="Database">knownUserNames	"Collect user names used in the existing connection profiles."	^(self allProfiles collect: [:each | each userName]) asSet</body><body package="Database">resetBrowseFilesButton	| browseFilesWidget enableAndShow |	browseFilesWidget := self builder componentAt: #browseFiles.	enableAndShow := #('SQLite3Connection' 'SQLite3ThreadedConnection') includes: self databaseHolder value.	browseFilesWidget isEnabled == enableAndShow ifFalse:		[browseFilesWidget			isEnabled: enableAndShow;			isVisible: enableAndShow].	^enableAndShow</body><body package="Database">resetProfileName	self currentProfile resetName.	self connectionProfileHolder value: nil.	self profileChanged</body></methods><methods><class-id>Database.ConnectionDialog</class-id> <category>actions</category><body package="Database">browseFiles	| fname |	fname := Dialog		requestFileName: #PleaseTypeAFileName &lt;&lt; #database &gt;&gt; 'Please type a file name: '		default: '*.sqlite'.	fname isEmpty ifTrue: [^self].	self environmentHolder value: fname.	self environmentChanged.</body><body package="Database">connect	self class lastUsedProfile: self currentProfile.	self accept value: true</body><body package="Database">deleteProfile	| nameToDelete |	nameToDelete := self connectionProfileHolder value.	nameToDelete isNil ifTrue: [^self].	(Dialog confirm: (#GenKeyDeleteProfile &lt;&lt; #database &gt;&gt; 'Are you sure you want to delete this connection profile?')) ifFalse: [^self].	self 		deleteProfileNamed: nameToDelete;		currentProfile: self createNewProfile;		updateProfileList</body><body package="Database">saveProfile	| name savedProfile |	name := Dialog		request: #ProfileName &lt;&lt; #database &gt;&gt; 'Profile name:'		initialAnswer: self currentProfile originalName.	name isEmpty ifTrue: [^self].	self currentProfile name: name.	savedProfile := self currentProfile copy.	self		addOrReplaceProfile: savedProfile;	 	updateProfileList.	"As we have not changed the currentProfile, use setValue: to avoid needless updates ..."	self connectionProfileHolder setValue: self currentProfile name.	"... but we must update the widget itself"	(self connectionProfileHolder myDependents		detect: [:each | each class = ComboBoxInputFieldView]		ifNone: [^self])		"ifNone not a possible outcome outside 'closing while doing' weirdness"			updateDisplayContents.</body></methods><methods><class-id>Database.ConnectionDialog</class-id> <category>notifications</category><body package="Database">databaseChanged	self resetProfileName</body><body package="Database">environmentChanged	self resetProfileName</body><body package="Database">passwordChanged	self resetProfileName</body><body package="Database">profileChanged	| hasName |	hasName := self currentProfile name notNil.	self builder window notNil ifTrue:		[(self builder componentAt: #saveProfile) isEnabled: hasName not.		(self builder componentAt: #deleteProfile) isEnabled: hasName.		(self builder componentAt: #connect) isEnabled: self currentProfile isValid].	self resetBrowseFilesButton.</body><body package="Database">profileSelected	| name profile |	name := self connectionProfileHolder value.	name isNil ifTrue: [^self].	profile := self class profiles detect: [:some | some name = name].	currentProfileHolder value: profile copy</body><body package="Database">userNameChanged	self resetProfileName</body></methods><methods><class-id>Database.ConnectionDialog</class-id> <category>initialize-release</category><body package="Database">initialize	super initialize.	self initializeAspects.	self		updateProfileList;		currentProfile: self class connectionProfileClass lastUsedProfile copy.	self databaseListHolder value: self class connectionProfileClass concreteDatabaseDriverClassNames.	self environmentListHolder value:		self knownEnvironmentStrings asSortedCollection.	self userNameListHolder value:		self knownUserNames asSortedCollection.	self connectionProfileHolder onChangeSend: #profileSelected to: self.	currentProfileHolder onChangeSend: #profileChanged to: self.</body><body package="Database">initializeAspects	currentProfileHolder := ValueHolder new.	databaseHolder := (TypeConverter on: (self profileAspect: #driverClassName))		getBlock: [:m | m value asString]		putBlock: [:m :v | m value: v asSymbol]		updateBlock: [:m :a :p | true].	"must be valid by construction of the drop-down (user-typing barred)"	environmentHolder := self profileAspect: #environment.	userNameHolder := self profileAspect: #userName.	passwordHolder := self profileAspect: #password.</body><body package="Database">postBuildWith: aBuilder	#(databaseCombo environmentCombo userNameCombo passwordField) do:		[:widgetName |		(builder componentAt: widgetName) 			widget controller continuousAccept: true].	self profileChanged "cause update"</body><body package="Database">profileAspect: aSymbol	^(AspectAdaptor forAspect: aSymbol)		subjectChannel: currentProfileHolder;		yourself</body></methods><methods><class-id>Database.ConnectionDialog class</class-id> <category>utilities</category><body package="Database">connect: aProfile	"Connect a ConnectionProfile (presumably selected using the dialog) and answer the resulting connection or nil if connection fails. In case of failure, show a dialog box. See also #unsafeConnect:."	^Cursor database showWhile:		[[self unsafeConnect: aProfile]			on: ExternalDatabaseException, ExternalDatabaseNotification			do: [:ex |				Dialog warn: (self messageFor: ex from: aProfile).				(ex isKindOf: ExternalDatabaseNotification) ifTrue: [ex pass] ifFalse: [ex return: nil]]]</body><body package="Database">messageFor: exception from: aProfile	"Answer a suitable message to display to the user (a String)	to explain the exception."	| parameter message |	(exception  isMemberOf: (aProfile driverClass authenticationFailureSignal))		ifTrue: [^exception errorString].	((parameter := exception parameter) notNil 		and: [parameter isEmpty not 		and: [(message := (parameter at: 1) dbmsErrorString) notNil "ugh"		and: [message isEmpty not]]])			ifTrue: [^message]			ifFalse: [^exception errorString]</body><body package="Database">unsafeConnect: aProfile	"Similar to #connect: but without the error handling.	Connection exceptions are not intercepted and are available	for the client code to take care of."	| connection |	connection := aProfile asConnection.	connection connect: aProfile password.	^connection</body></methods><methods><class-id>Database.ConnectionDialog class</class-id> <category>accessing</category><body package="Database">chooseProfile	"Open the connection dialog. After it is closed answer either the	connection profile with parameters selected by the user if it was accepted	or nil if the dialog was cancelled."	| instance |	instance := self new.	^instance open		ifTrue: [instance currentProfile]		ifFalse: [nil]</body><body package="Database">chooseProfileInitially: aProfileOrNil	"Open the connection dialog. After it is closed answer either the	connection profile with parameters selected by the user if it was accepted	or nil if the dialog was cancelled."	| instance |	instance := self new.	aProfileOrNil notNil ifTrue: [instance currentProfile: aProfileOrNil].	^instance open		ifTrue: [instance currentProfile]		ifFalse: [nil]</body><body package="Database">lastUsedProfile: aProfile	self connectionProfileClass lastUsedProfile:  aProfile</body><body package="Database">profiles	^DBProfileManager profiles</body></methods><methods><class-id>Database.ConnectionDialog class</class-id> <category>convenience</category><body package="Database">openConnection	"Open the dialog and then open the database connection that was selected.	Answer the opened connection or nil if either the dialog was cancelled or	the connection failed."	| profile |	profile := self chooseProfile.	^profile isNil		ifTrue: [nil]		ifFalse: [self connect: profile]</body><body package="Database">openConnectionIfCancelled: aBlock	"Open the dialog and then open the database connection that was selected.	Answer the opened connection or nil if the connection failed.	Evaluate aBlock if the dialog was cancelled."	| profile |	profile := self chooseProfile.	^profile isNil		ifTrue: [aBlock value]		ifFalse: [self connect: profile]</body></methods><methods><class-id>Database.ConnectionDialog class</class-id> <category>store</category><body package="Database">connectionProfileClass	"This returns Database.ConnectionProfile, not its same-name subclass Store.ConnectionProfile."	^ConnectionProfile</body></methods><methods><class-id>Tools.DBProfileListPage</class-id> <category>notifications</category><body package="Database">profileSelectionChanged	| hasSelection |	builder isNil ifTrue: [^self].	hasSelection := self profileListHolder selection notNil.	#(removeButton propertiesButton) do:		[:each | (self wrapperAt: each) isEnabled: hasSelection]</body><body package="Database">triggered	manager triggerChannel value 		ifTrue: [self accept]		ifFalse: [self reset]</body></methods><methods><class-id>Tools.DBProfileListPage</class-id> <category>private</category><body package="Database">accept	setting installProfiles</body><body package="Database">reset	setting resetProfiles.	self profileListHolder list: setting profiles</body></methods><methods><class-id>Tools.DBProfileListPage</class-id> <category>actions</category><body package="Database">addProfile	| newProfile |	newProfile := ConnectionProfile new.	newProfile name: (#Profile1p &lt;&lt; #database &gt;&gt; 'Profile &lt;1p&gt;'  expandMacrosWith: self profileListHolder list size + 1).	(DBProfilePropertiesDialog openOn: newProfile) 		ifTrue: 			[(self profileListHolder list)				add: newProfile;				sortWith: [:a :b | a name &lt; b name].			self profileListHolder selection: newProfile.			manager tickle]</body><body package="Database">importSnapshots: aCollection	| snapshot newProfiles |	snapshot := aCollection detect: [:some | some id = setting id] ifNone: [^self].	newProfiles := List new.	snapshot stateNodes do:		[:each |		newProfiles add: (ConnectionProfile fromXmlElement: each)].	self profileListHolder list		removeAllSuchThat: [:each | true];		addAll: newProfiles.	self tickle</body><body package="Database">profileProperties	self profileListHolder selectionDo:		[:selection |		DBProfilePropertiesDialog openOn: selection.		manager tickle]</body><body package="Database">removeProfile	self profileListHolder selectionDo:		[:selection |		(Dialog confirm: #RemoveThisProfileQ &lt;&lt; #labels &gt;&gt; 'Remove this profile?')			ifTrue: 				[self profileListHolder list remove: selection.				manager tickle]]</body></methods><methods><class-id>Tools.DBProfileListPage</class-id> <category>initialize-release</category><body package="Database">manager: aManager	super manager: aManager.	manager triggerChannel onChangeSend: #triggered to: self</body><body package="Database">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self profileSelectionChanged</body><body package="Database">setting: aDBProfileListSetting	setting := aDBProfileListSetting.	self profileListHolder list: setting profiles.	self profileListHolder selectionIndexHolder		onChangeSend: #profileSelectionChanged to: self.</body></methods><methods><class-id>Tools.DBProfileListPage</class-id> <category>accessing</category><body package="Database">helpText	"This message shows the help text for the database profiles setting page. In order to provide bold emphasis whilst still using message catalogs, the button and field names were extracted and put into a separate usermessage."	| args argEmphases msg |	args := (#databaseProfilesHelpItems &lt;&lt; #dialogs 				&gt;&gt; 'Add... Remove... Properties... Name Interface Environment Username Password') 					asString tokensBasedOn: Character space.	argEmphases := Array new: args size withAll: #bold.	msg := #databaseProfilesHelp &lt;&lt; #dialogs 				&gt;&gt; 'To create a new database profile, click &lt;1s&gt;.To delete a profile, select it and click &lt;2s&gt;.To edit a profile, select it and click &lt;3s&gt;.A profile setting consists of the following properties.&lt;4s&gt; - Name of the profile setting, so you can remember it.&lt;5s&gt; - Database vendor connection type (eg., OracleConnection).&lt;6s&gt; - Database server indicator, called an environment string.&lt;7s&gt; - Database user name.&lt;8s&gt; - Database password.'.	^msg 		expandMacrosWithEmphasis: #normal		arguments: args		emphases: argEmphases</body><body package="Database">settings	^Array with: setting</body></methods><methods><class-id>Tools.DBProfileListPage</class-id> <category>aspects</category><body package="Database">profileHolder	^nil asValue</body><body package="Database">profileListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^profileListHolder isNil		ifTrue:			[profileListHolder :=  SelectionInListSortAware new.			profileListHolder selectionIndexHolder compute:				[:v |				self profileHolder value: profileListHolder selection].			profileListHolder]		ifFalse:			[profileListHolder]</body></methods><methods><class-id>Database.UnableToPrepare</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errPrepareSQL &lt;&lt; #database &gt;&gt; 'Unable to prepare SQL statement.') asString</body></methods><methods><class-id>Database.UnableToBind</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errVariableBufferAssocation &lt;&lt; #database &gt;&gt; 'Unable to associate buffer with bind variable') asString</body></methods><methods><class-id>Database.MissingBindVariable</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#missingBindVariable &lt;&lt; #database &gt;&gt; 'Missing bind variable.') asString</body></methods><methods><class-id>Database.InvalidConnectionState</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errConnectionState &lt;&lt; #database &gt;&gt; 'Invalid Connection State') asString</body></methods><methods><class-id>Database.ExternalDatabaseAnswerStream</class-id> <category>initialize-release</category><body package="Database">initialize	^self</body></methods><methods><class-id>Database.ExternalDatabaseAnswerStream</class-id> <category>accessing</category><body package="Database">columnDescriptions	"Describe the column structure of the answer set for the (current) SQL 	statement or stored procedure.  Answers an instance of	ExternalDatabaseColumnDescription for each column of the answer set."	^self session columnDescriptions</body><body package="Database">columns	"Answer the number of columns in the answer set."	^self session numColumns</body><body package="Database">contents	"The contents are not accessible as a complete unit since they are	not stored in the image. Use upToEnd to return all (remaining) rows."	^self shouldNotImplement</body><body package="Database">flush	^self shouldNotImplement</body><body package="Database">moveTo: anInteger	"Answer the row at cursor position anInteger."	| row |	( nextRow == nil )		ifTrue: [ self getRowAtAbsolutePosition: anInteger ].	( session == nil )		ifTrue: [ ^self class endOfStreamSignal raise ].	row := nextRow.	nextRow := nil.	^row</body><body package="Database">next	"Answer the next row from the answer stream."	| row |	( nextRow == nil )		ifTrue: [ self getNextRow ].	( session == nil )		ifTrue: [ ^nil ].	row := nextRow.	nextRow := nil.	^row</body><body package="Database">next: anInteger into: aSequenceableCollection startingAt: startIndex 	"Store the next anInteger elements of the receiver into aSequenceableCollection 	starting at startIndex in aSequenceableCollection. Answer aSequenceableCollection.	Since there must be a unique object for every entry of the set, the allocateForEachRow	control in the session is ignored and  a copy of the bindOutput object is always made."	| index stopIndex getRow |	index := startIndex.	stopIndex := index + anInteger.	session allocateForEachRow		ifTrue:	[ getRow :=  [ self next ]		"next made the copy" ]		ifFalse:	[ getRow := [ self next copy ] 	"next didn't make the copy" ].	[ self atEnd not and: [ index &lt; stopIndex ] ]		whileTrue:		[ "Collect the next row by executing the getRow block from			above and then insert into the collection."			aSequenceableCollection at: index put: getRow value.			index := index + 1 ].	^aSequenceableCollection</body><body package="Database">nextPut: anObject 	self shouldNotImplement</body><body package="Database">peek	"Answer the next row from the answer stream without consuming the row.	If the end of the answer stream has been reached, answer nil.	Applications should be aware that this method may cause the current	row to advance in order to detect the existence of an additional row.	If the application is dependent on a consistent view of the current	row (perhaps for WHERE CURRENT OF operations), peek should not	be used after a next until completing all processing of the current row."	nextRow isNil		ifTrue: [ self getNextRow ].	^session isNil ifTrue: [ nil ] ifFalse: [ nextRow ]</body><body package="Database">previous	"Answer the previous row from the answer stream."	| row |	( nextRow == nil )		ifTrue: [ self getPriorRow ].	( session == nil )		ifTrue: [ ^self class endOfStreamSignal raise ].	row := nextRow.	nextRow := nil.	^row</body><body package="Database">skip: anInteger	"Answer the row at current cursor position+anInteger."	| row |	( nextRow == nil )		ifTrue: [ self getRowAtRelativePosition: anInteger ].	( session == nil )		ifTrue: [ ^self class endOfStreamSignal raise ].	row := nextRow.	nextRow := nil.	^row</body><body package="Database">upToEnd	"Answer the current contents of the receiver's input stream. All rows of the answer	set are fetched. Since there must be a unique object for every entry of the set, the	allocateForEachRow control in the session is ignored and  a copy of the bindOutput	object is always made."	| cont getRow |	( session == nil ) "No more answers."		ifTrue: [ self class endOfStreamSignal raiseSignal. ^#().].	cont := WriteStream on: (self contentsSpecies new: 512).	session allocateForEachRow		ifTrue:	[ getRow :=  [ self next ]		"next made the copy" ]		ifFalse:	[ getRow := [ self next copy ] 	"next didn't make the copy" ].	[ self atEnd ]		whileFalse: [ cont nextPut: getRow value ].	^cont contents</body></methods><methods><class-id>Database.ExternalDatabaseAnswerStream</class-id> <category>status</category><body package="Database">close	"Sets the status of the stream to be closed."	session notNil ifTrue:		[ session cancelAnswerSet.		self dismiss ].</body></methods><methods><class-id>Database.ExternalDatabaseAnswerStream</class-id> <category>testing</category><body package="Database">atEnd	"Answer whether there are any more rows to be processed.	Applications should be aware that this method may cause the current	row to advance in order to detect the existence of additional rows.	If the application is dependent on a consistent view of the current	row (perhaps for WHERE CURRENT OF operations), atEnd should not	be used after a next until completing all processing of the row returned."	( nextRow == nil )		ifTrue: [ self getNextRow ].	^nextRow == nil</body></methods><methods><class-id>Database.ExternalDatabaseAnswerStream</class-id> <category>private-accessing</category><body package="Database">getNextRow	"Get the next row of data into nextRow.  If no more rows, dismiss the receiver unless the session is scrollable, in which case we could scroll past the end, or before the beginning, and yet then wish to scroll back."	| row |	session == nil ifTrue: [^self].	row := session nextRowExternal.	nextRow := row.	row == nil		ifTrue: [ session scrollable ifFalse: [self dismiss]]</body><body package="Database">getPriorRow	"Get the previous row of data into nextRow.  If no more rows, dismiss the receiver unless the session is scrollable, in which case we could scroll past the end, or before the beginning, and yet then wish to scroll back."	| row |	session == nil ifTrue: [^self].	row := session getRowExternal: session fetchPriorMode offset: 0.	row == nil		ifTrue: [session scrollable ifFalse: [self dismiss]]		ifFalse: [nextRow := row].</body><body package="Database">getRowAtAbsolutePosition: anInteger	"Get the next row of data into nextRow.  If no more rows, dismiss the receiver unless the session is scrollable, in which case we could scroll past the end, or before the beginning, and yet then wish to scroll back."	| row |	session == nil ifTrue: [^self].	row := session getRowExternal: session fetchAbsoluteMode offset: anInteger.	row == nil		ifTrue: [session scrollable ifFalse: [self dismiss]]		ifFalse: [nextRow := row].</body><body package="Database">getRowAtRelativePosition: anInteger	"Get the next row of data into nextRow.  If no more rows, dismiss the receiver unless the session is scrollable, in which case we could scroll past the end, or before the beginning, and yet then wish to scroll back."	| row |	session == nil ifTrue: [^self].	row := session getRowExternal: session fetchRelativeMode offset: anInteger.	row == nil		ifTrue: [session scrollable ifFalse: [self dismiss]]		ifFalse: [nextRow := row].</body><body package="Database">session	^session</body><body package="Database">session: aSession	session := aSession</body></methods><methods><class-id>Database.ExternalDatabaseAnswerStream</class-id> <category>private-activation</category><body package="Database">activate	"Should never be sent because answer streams do not remain a participant 	when quiesced so no parent will retain a reference and send activate."	^self shouldNotImplement</body><body package="Database">dismiss	session isNil ifTrue: [^self].	session answerStreamDismissed.	self session: nil</body><body package="Database">quiesce	"Answer streams cannot be reactivated so quiesce is the same as dismiss."	self dismiss</body></methods><methods><class-id>Database.ExternalDatabaseAnswerStream</class-id> <category>private-testing</category><body package="Database">isExecutor	"Answer true if the receiver is really an executor, not the primary object."	"AnswerStreams never hold external resources themselves and so will never have executors."	^false</body></methods><methods><class-id>Database.ExternalDatabaseAnswerStream class</class-id> <category>instance creation</category><body package="Database">new	^self error: (#errNewAnswerStream &lt;&lt; #database &gt;&gt; 'An ExternalDatabaseAnswerStream is obtained from an instance of ExternalDatabaseSession')</body></methods><methods><class-id>Database.ExternalDatabaseAnswerStream class</class-id> <category>private-instance creation</category><body package="Database">newForSession: aSession 	"Create a new ExternalDatabaseAnswerStream instance 	associated with the session aSession."	| ans |	(ans := self basicNew)		initialize;		session: aSession.	^ans</body></methods><methods><class-id>Database.UnsupportedDriverFunctionality</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#externalDBError &lt;&lt; #database &gt;&gt; 'An attempt was made to use a feature which the API is not available in the current configuration.') asString</body></methods><methods><class-id>Database.ExternalDatabaseTransaction</class-id> <category>initialize-release</category><body package="Database">initialize	"Establish instance variables that require special handling."	super initialize.	self state: #xactNo.	self memberCountHolder: 0 asValue.	self remainingCountHolder: 0 asValue</body></methods><methods><class-id>Database.ExternalDatabaseTransaction</class-id> <category>testing</category><body package="Database">inTransactionMode	"Answer true if a transaction has been started."	| s |	^((s := self state) == #xactYes or: [ s == #committing ]) or: [ s == #aborting ]</body></methods><methods><class-id>Database.ExternalDatabaseTransaction</class-id> <category>transactions</category><body package="Database">begin	"Mark the beginning of a transaction.  If an error occurs, prevent any further	activity on any of the participanting connections.  This is achieved by	disconnecting without further transaction actions and letting the database	manager take whatever action as the disconnects occur."	self state == #xactNo ifFalse:		[ self class connectionClass invalidTransactionStateSignal raise ].	"If we can't begin successfully, the only response is to refuse to do any work."	[ self state: #xactYes.	self remainingCount: self memberCount.	self beginExternal.	self participantsDo: [ :each | each beginExternal ] ]		ifCurtailed:			[ self state: #xactNo.	"Will prevent connections from trying to do xact termination."			self participantsDo: [ :each | each disconnect ] ]</body><body package="Database">commit	"Coordinate the commit for all related connections.	If an individual connection can't do its part, go on to the others	and reraise an exception when all have tried.  The parameter to the	exception will be all the exception's parameters aggregated."	^self finishTransaction: #committing method: #commitExternal</body><body package="Database">rollback	"Coordinate the rollback for all related connections.	If an individual connection can't do its part, go on to the others	and reraise an exception when all have tried.  The parameter to the	exception will be all the exception's parameters aggregated."	^self finishTransaction: #aborting method: #rollbackExternal</body></methods><methods><class-id>Database.ExternalDatabaseTransaction</class-id> <category>private-accessing</category><body package="Database">acquireTrigger	"Answer number of participants required to trigger acquire/dismiss."	^nil		"never acquire"</body><body package="Database">memberCount	"Answer the number of members in a coordinated transaction."	^self memberCountHolder value</body><body package="Database">memberCount: aSmallInteger	"Set the number of members in a coordinated transaction."	self memberCountHolder value: aSmallInteger</body><body package="Database">memberCountHolder	"Answer the holder for the number of members in a coordinated transaction."	^memberCountHolder</body><body package="Database">memberCountHolder: anExternalDatabaseValueHolder	"Set the holder for the number of members in a coordinated transaction."	memberCountHolder := anExternalDatabaseValueHolder</body><body package="Database">remainingCount	"Answer the number of members remaining in a coordinated transaction."	^self remainingCountHolder value</body><body package="Database">remainingCount: aSmallInteger	"Set the number of members remaining in a coordinated transaction."	self remainingCountHolder value: aSmallInteger</body><body package="Database">remainingCountHolder	"Answer the holder for the number of members remaining in a coordinated transaction."	^remainingCountHolder</body><body package="Database">remainingCountHolder: anExternalDatabaseValueHolder	"Set the holder for the number of members remaining in a coordinated transaction."	remainingCountHolder := anExternalDatabaseValueHolder</body></methods><methods><class-id>Database.ExternalDatabaseTransaction</class-id> <category>private-activation</category><body package="Database">acquire	"Record existence of active member of this coordinated transaction."	self memberCount: self memberCount + 1</body><body package="Database">activate	super activate.	self state: #xactNo</body><body package="Database">dismiss	"Record departure of active member of this coordinated transaction."	self memberCount: self memberCount - 1</body></methods><methods><class-id>Database.ExternalDatabaseTransaction</class-id> <category>private-finalization</category><body package="Database">executor	"Answer with the executor."	"Subclassess which want to override to add information to the executor	should use super executor to create the executor initially."	| ex |	ex := super executor.	ex memberCountHolder: self memberCountHolder.	ex remainingCountHolder: self remainingCountHolder.	^ex</body></methods><methods><class-id>Database.ExternalDatabaseTransaction</class-id> <category>private-library calls</category><body package="Database">beginExternal	"Perform driver-specific work at the beginning of a transaction."	^self subclassResponsibility</body><body package="Database">commitExternal	"Perform driver-specific work at the completion of a transaction."	^self subclassResponsibility</body><body package="Database">rollbackExternal	"Perform driver-specific work at the completion of a transaction."	^self subclassResponsibility</body></methods><methods><class-id>Database.ExternalDatabaseTransaction</class-id> <category>private-transactions</category><body package="Database">executorFinishingTransaction		| action s |	( traceLevel &gt;= 1 ) ifTrue:		[ (self traceStream)			nextPutAll: (#state &lt;&lt; #database &gt;&gt; 'state: ') asString; print: self state.		self class trace: self emitTrace ].	"If nobody else has tried to finish up the transaction, we need to roll it back."	(s := self state) == #xactYes		ifTrue:	[ ^self rollback ].	"We're finishing up the transaction, but due to garbage collection, the executor which sent	this message didn't hear about it.  Carry on with what we're doing."	s == #committing		ifTrue:	[ action := #commitExternal ].	s == #aborting		ifTrue:	[ action := #rollbackExternal ].	self participantsDo:		[ :each |		each state == #xactYes ifTrue:			[ each perform: action.			self remainingCount: (self remainingCount - 1) ] ].	self remainingCount == 0		ifTrue:	[ self state: #xactNo ]</body><body package="Database">finishTransaction: finishingState method: selector 	"Coordinate the completion of the transaction for all related connections.	The finishingState is used until all of the transaction members have done	their part of finishing the transaction.  The selector is the method to use to	invoke the driver-specific action.  If an individual connection can't do its part,	go on to the others and reraise an exception when all have tried. The parameter	to the exception will be all the exception's parameters aggregated.	Errors while finishing a transaction lead to all participating connections being	prevented from any further work (they are disconnected)."	| exParams |	self state == #xactYes 		ifFalse: [^self class connectionClass invalidTransactionStateSignal raise].	exParams := nil.	"The finishingState will remain until all participants (including	any being finalized) check in and complete their part."	self state: finishingState.	"Phase 1 is performed by the driver's transaction implementation of	commitExternal or rollbackExternal.  If an error occurs here, the unwind	block will render each of the participants unable to do further processing."	[self perform: selector] ifCurtailed: 			[self state: #xactNo.			self participantsDo: [:each | each disconnect]].	"Phase 2 is performed by each participant's implementation of	commitExternal or rollbackExternal.  In systems that do not support	a 2-phase commit, this provides the serial broadcast form of commit	or rollback.  Capture any errors that occur here, but attempt to finish	the remaining transactions.  In any event, manual intervention will be	required to complete the transaction."	self participantsDo: 			[:each | 			[each perform: selector] 				on: self class connectionClass externalDatabaseErrorSignal				do: 					[:ex | 					exParams isNil ifTrue: [exParams := OrderedCollection new].					ex parameter notNil ifTrue: [exParams addAll: ex parameter].					ex return].			"Accumulate the exception parameters"			self remainingCount: self remainingCount - 1].	self remainingCount == 0 ifTrue: [self state: #xactNo].	exParams notNil 		ifTrue: 			[self state: #xactNo.			self participantsDo: [:each | each disconnect].			exParams isEmpty 			ifTrue: [ self class connectionClass transactionPhase2FatalSignal raiseSignal: nil ] 			ifFalse: [ self class connectionClass transactionPhase2FatalSignal raiseWith: exParams errorString: exParams first dbmsErrorString ]]</body></methods><methods><class-id>Database.ExternalDatabaseTransaction class</class-id> <category>instance creation</category><body package="Database">new	"Applications never use transaction objects directly."	^super new initialize.</body></methods><methods><class-id>Database.InvalidDescriptorCount</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errDescriptorCount &lt;&lt; #database &gt;&gt; 'Dynamic SQL Error--invalid descriptor count') asString</body></methods><methods><class-id>Database.TransactionException</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errTransactionException &lt;&lt; #database &gt;&gt; 'Transaction Exception') asString</body></methods><methods><class-id>Database.DuplicateIndexesError</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#duplicateIndex &lt;&lt; #database &gt;&gt; 'Attempting to create a duplicate index') asString</body></methods><methods><class-id>Database.UnableToSetEnvironmentAttribute</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errSetEnvironmentAttribute &lt;&lt; #database &gt;&gt; 'unable to set environment attribute.') asString</body></methods><methods><class-id>Database.TransactionPhase2Fatal</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#err2phaseCommit &lt;&lt; #database &gt;&gt; 'Failure to complete database commit or rollback.&lt;n&gt;Inform your Database Administrator.') expandMacros</body></methods><methods><class-id>Database.UnableToQueryHandleInformation</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errQueryHandle &lt;&lt; #database &gt;&gt; 'Unable to query handle information.') asString</body></methods><methods><class-id>Database.NoDefaultConnection</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errDefaultConnection1 &lt;&lt; #database &gt;&gt; 'There is no default Connection to provide a connection') asString</body></methods><methods><class-id>Database.UnableToOpenCursor</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errCursorOpened &lt;&lt; #database &gt;&gt; 'The database cursor could not be opened.') asString</body></methods><methods><class-id>Database.InvalidTransactionState</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errTransactionState &lt;&lt; #database &gt;&gt; 'Invalid Transaction State') asString</body></methods><methods><class-id>Database.RequiredPassword</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#passwordRequired &lt;&lt; #database &gt;&gt; 'A password is required') asString</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>initialize-release</category><body package="Database">initialize	super initialize.	traceLevel := self class traceLevel.	self state: #new.	connection := nil.	self releaseBindings.	allocateForEachRow := true.	useNamedOutputBinding := false.	blockFactor := 1.	rowBuffersHolder := nil asValue.	self scrollable: false.	needBinding := true.</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>accessing</category><body package="Database">allocateForEachRow	"Answer whether the answer stream should create a copy of the output	bind object to hold each row."	^allocateForEachRow</body><body package="Database">allocateForEachRow: aBoolean	"Specify whether the answer stream should create a copy of the output	bind object to hold each row."	allocateForEachRow := aBoolean</body><body package="Database">bindInput	"Answer the object from which input values will be 	obtained for host variable references in the SQL text."	^bindInput</body><body package="Database">bindInput: aBindObject 	"Supply aBindObject as the object from which input values should be 	obtained for host variable references in the SQL text.  Host variables	may be specified using either a positional or a named notation.  The	driver may limit to only one form.	When using the positional form (a ?), all host variable references (including	the named ones) are implicitly ordered by their position in the SQL-text.	The n-th variable of aBindObject is used for the n-th host variable reference.	If aBindObject has both instance variables and indexed variables, only the	indexed variables will be used. 	When using the named form, the leading colon is removed and the name is	expected to be an accessing method on aBindObject (i.e. aBindObject is sent	perform: with the name converted to a symbol as the argument)."	bindInput := aBindObject</body><body package="Database">bindMarkerAtPosition: anInteger	"What bindMarker retrieves the value at the buffer's position."	^queryFragments at: anInteger * 2</body><body package="Database">bindOutput	"Answer the bind object used for returned rows."	^bindOutput</body><body package="Database">bindOutput: aBindObject 	"Specify the bind object used for returned rows."	self bindOutputIndexed: aBindObject</body><body package="Database">bindOutputIndexed: aBindObject	"Specify the bind object used for returned rows.  aBindObject may have either	instance variables or indexed variables; if both are present, the indexed variables	are used.	Rows are mapped into aBindObject using positional correspondence between the	row's columns and aBindObject's variables (i.e., column 1 goes into variable 1, etc.).	Variables in aBindObject may be skipped in the positional mapping if they contain	an instance of Object.  This is useful when only a few columns of a table are needed."	bindOutput := aBindObject.	useNamedOutputBinding := false.	self rowAdaptors: nil.</body><body package="Database">bindOutputNamed: aBindObject	"Specify the bind object used for returned rows.	Rows are mapped into aBindObject using the column names, postfixed with a colon,	as mutator messages.  Thus, each column must have a name that is suitable for	conversion to a symbol, and aBindObject must respond to such a message."	bindOutput := aBindObject.	useNamedOutputBinding := true.	self rowAdaptors: nil.</body><body package="Database">blockFactor	"Answer the blocking factor for using buffers to accelerate fetching of row data."	^blockFactor</body><body package="Database">blockFactor: aSmallInteger	"Specify the blocking factor to use when fetching of row data.  This may improve application	performance at the expense of memory. The blocking factor is optional and will be ignored if	the driver does not support fetching multiple rows at a time.	The application still uses next to obtain a single row at a time.  However, the use of	WHERE CURRENT OF may not be allowed as the database system cannot be sure	of which row the application is referring to."	blockFactor := aSmallInteger</body><body package="Database">needBinding	^needBinding</body><body package="Database">needBinding: aBoolean	needBinding := aBoolean</body><body package="Database">query	"Answer SQL text for this session."	^query</body><body package="Database">scrollable	"Determins whether the cursor is scrollable or not."	^scrollable</body><body package="Database">scrollable: aBoolean	"Determins whether the cursor is scrollable or not."	scrollable := aBoolean</body><body package="Database">setupQueryWithoutBinding: aString	query := aString.	queryFragments := Array with: aString.</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>data processing</category><body package="Database">answer	"Wait for the currently executing SQL statement to complete processing. Exceptions are	raised for any errors.  The value answered will be an answer stream,  #noAnswerStream or	#noMoreAnswers.  #noAnswerStream is used to indicate successful processing, but no answer	stream was generated.  In order to maintain application portability with database libraries	that allow multiple SQL statements in one prepare:, this message should be sent until it	returns #noMoreAnswers"	( self state == #executing )		ifTrue:	[ self delayUntilReady ].	^self answerOfClass: self class answerStreamClass</body><body package="Database">cancel	"Interrupt the processing of the prepared SQL text or stored procedure."	self isExecuting ifFalse:		[ self class connectionClass invalidSessionStateSignal raise ].	answerStream notNil ifTrue:		[ answerStream dismiss ].	( self state == #fetchingData ) ifTrue:		[ self cancelAnswerSetExternal ].	self cancelExternal.	self state: #prepared</body><body package="Database">connect	"Optional: gives direct control over when external resources are acquired. Will be done 	automatically when prepare: is invoked."	( self state == #new ) ifFalse:		[ self class connectionClass invalidSessionStateSignal raise ].	( connection isNil or: [ connection isConnected not ] ) ifTrue:		[ self class connectionClass connectionNotOpenSignal raise ].	self acquire.	self state: #connected</body><body package="Database">disconnect	"Optional: gives direct control over when external resources are dismissed."	( self state == #new ) ifTrue: [ ^self ].	self dismiss.	self state: #new</body><body package="Database">execute	"Execute the prepared SQL statement."	"Should we clean up after any previous work?"	self isExecuting ifTrue:		[ self cancel ].	( self state == #prepared ) ifFalse:		[ self class connectionClass invalidSessionStateSignal raise ].	[ "Begin unwind protection."	self bindExternal.	self state: #executing.	self executeExternal.	"End unwind protection." ]		ifCurtailed:			[ self state: #prepared ]</body><body package="Database">prepare: aString	"Prepare aString for processing."	self startPrepare.	"Save the query, and prepare it for parameter binding. (#needBinding is true unless explicitly set to false in callers:  a platform that cannot support binding will have non-binding behaviour in setupQuery:.  This reflects the fact that this behaviour was pushed up from OracleEXDI to accomodate Glorp requirements long after the setUpQuery: methods were written for most platforms, so it could be altered at need.)"	self needBinding		ifTrue: [self setupQuery: aString]		ifFalse: [self setupQueryWithoutBinding: aString].	"We're finally ready to prepare the SQL.	If there is a problem, make sure the state is appropriate."	[ "Begin unwind protection."	self state: #prepared.	self prepareExternal.	"End unwind protection." ]		ifCurtailed:			[ self state: #connected ]</body><body package="Database">prepareWithoutBinding: aString	self needBinding: false.	self prepare: aString.</body><body package="Database">rowCount	"Answer an Integer representing the number of rows affected by the previous query.	Valid only after the query has been answered."	^self subclassResponsibility</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>testing</category><body package="Database">isReady	"Answer a boolean for whether processing has completed and an answer is ready."	| stateTemp |	(stateTemp := self state) == #executing		ifTrue:			[ (self readyExternal) ifTrue:				[ self state: #ready.				^true ] ]		ifFalse:			[ (stateTemp == #ready			or: [ stateTemp == #validResults 			or: [ stateTemp == #fetchingData ] ] ) ifFalse:				[ self class connectionClass invalidSessionStateSignal raise ].			^true ].	^false</body><body package="Database">useNamedOutputBinding	"Answer true if the session is using named output binding"	^useNamedOutputBinding</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>private-accessing</category><body package="Database">answerStream: anAnswerStreamOrNil	"Set the session's answer stream."	answerStream := anAnswerStreamOrNil</body><body package="Database">bindTemplate: anArray	"Provide an array of database types"	bindTemplate := anArray.</body><body package="Database">columnDescriptions	"Answer the column descriptions array"	^columnDescriptions</body><body package="Database">columnDescriptions: anArray	"Set the column descriptions array"	columnDescriptions := anArray</body><body package="Database">connection	"Answer the connection in which receiver executes."	^connection</body><body package="Database">connection: aConnection	"Set the connection in which receiver should execute."	connection := aConnection</body><body package="Database">numColumns	"Answer the number of columns"	^numColumns</body><body package="Database">numColumns: anInteger	"Save the number of columns"	numColumns := anInteger</body><body package="Database">rowAdaptors: aSequenceableCollection	rowAdaptors := aSequenceableCollection</body><body package="Database">rowBuffers	^rowBuffersHolder value</body><body package="Database">rowBuffers: aSequenceableCollection	rowBuffersHolder value: aSequenceableCollection</body><body package="Database">rowBuffersHolder	^rowBuffersHolder</body><body package="Database">rowBuffersHolder: aValueHolder	rowBuffersHolder := aValueHolder</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>private-activation</category><body package="Database">acquire	"Acquire resources necessary to execute SQL, and register as a participant of our connect."	connection addParticipant: self.	[ self acquireExternal notNil ifTrue:		[ "Assert: external resource held."		self class register: self ]	] ifCurtailed: [ connection removeParticipant: self ]</body><body package="Database">activate	"Don't bother reconnecting now."	connection removeParticipant: self.	self class unregister: self.	self state: #new</body><body package="Database">dismiss	self isExecuting ifTrue:		[ self cancel ].	self releaseBuffersAndAdaptors.	self releaseBindings.	super dismiss.	connection removeParticipant: self</body><body package="Database">quiesce	"Quiesce all connections to external resources."	self state == #paused ifTrue: [ ^self ].	answerStream notNil ifTrue:		[ answerStream dismiss ].	[ self dismissExternal ]		ensure:			[ self state: #paused ]</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>private-answer set</category><body package="Database">aboutToAnswer	"Do any final work before fetching results from an answer set."	^self</body><body package="Database">acquireBuffers	"Acquire buffers for fetching the answer set from the server."	| buffers |	"Buffers will only exist here if they're OK to reuse."	self rowBuffers notNil ifTrue: [ ^self ].	buffers := Array new: numColumns.	[ "Begin unwind protection."	1 to: numColumns do:		[ :column |		buffers at: column put: (self allocateRowBufferExternal: column) ].	"End unwind protection." ]		ifCurtailed:			[ "give back any pointers we might have acquired as none will be used."			1 to: numColumns do:				[ :col | | buf |				(buf := buffers at: col) notNil ifTrue:					[ buf free ] ] ].	self rowBuffers: buffers</body><body package="Database">advanceExternal	"Advance the current row. If blockFactor is supported, this may entail fetching 	many rows but doing it infrequently. If there are no more rows, answer nil. 	Otherwise, answering self is sufficient."	^self subclassResponsibility</body><body package="Database">allocateRowBufferExternal: aColumn 	"Answer an object describing space allocated for holding one column's	worth of information as returned by the dbms api. The driver is responsible	for defining the structure of the object returned."	^self subclassResponsibility</body><body package="Database">answerOfClass: anAnswerStreamClass	"Answer an instance of the given subclass of ExternalDatabaseAnswerStream"	"Assert: anAnswerStreamClass isKindOf: ExternalDatabaseAnswerStream"	| initialAnswer |	initialAnswer := ( self state == #ready ).	self state: #validResults.	initialAnswer		ifTrue:	[ "Verify that the query executed without error."				self resultsExternal ]		ifFalse:	[ "If we're still holding on to a prior answer stream, dismiss it."				answerStream notNil					ifTrue:	[ answerStream close ].				"Assert: self state == #validResults"				self moreResultsExternal					ifFalse:	[ self state: #prepared.							^#noMoreAnswers ] ].	self hasAnswerSetExternal		ifTrue:	[ | answer |				initialAnswer ifFalse:					[ "Previous descriptions/buffers are no longer valid"					self releaseBuffers.					self releaseAdaptors.					self columnDescriptions: nil ].				self getColumnDescriptions.				self acquireBuffers.				self setupAdaptors.				self aboutToAnswer.				answer := anAnswerStreamClass newForSession: self.				self answerStream: answer.				self state: #fetchingData.				^answer ].	^#noAnswerStream.</body><body package="Database">answerStreamDismissed	"Note that the answer stream has dismissed itself."	self answerStream: nil</body><body package="Database">cancelAnswerSet	"Cancel an answer set.  Used to release server resources."	self cancelAnswerSetExternal.	self state: #validResults.</body><body package="Database">cancelAnswerSetExternal	"Cancel any resources associated with the current answer set"	self subclassResponsibility</body><body package="Database">describeAnswerColumns	"Fill in the columnDescriptions array."	| descrs index temp |	descrs := Array new writeStream.	index := 0.	[ ( temp := self getColumnDescriptionExternal: (index := index + 1) ) notNil ]		whileTrue: [ descrs nextPut: temp ].	self columnDescriptions: (index &gt; 1 ifTrue: [ descrs contents ] ifFalse: [ nil ]).	self numColumns: (index - 1).</body><body package="Database">getColumnDescriptionExternal: aColumn	^self subclassResponsibility</body><body package="Database">getColumnDescriptions	"Get descriptions for the columns in the answer set"	"If column descriptions exist, they're safe to re-use."	( columnDescriptions == nil ) ifFalse: [ ^self ].	( resultTemplate == nil )		ifTrue: [ self describeAnswerColumns ]		ifFalse: [ self answerColumnsFromTemplate ]</body><body package="Database">getFieldExternal: aColumn	^self subclassResponsibility</body><body package="Database">getRowExternal: fetchOrientation offset: fetchOffset	"Answer with the next row of data.  Answer nil at end"	| currentRowCopy |	( (self advanceExternal: fetchOrientation offset: fetchOffset) == nil ) ifTrue:		[ "We've exhausted the answer set.  No DBMS cancel is necessary."		self state: #validResults.		^nil ].	"If we have a resultTemplate, use it to provide the answer."	( resultTemplate == nil ) ifFalse:		[ bufferIndex := 1.		^self nextViaTemplate: resultTemplate ].	currentRowCopy := allocateForEachRow		ifTrue:			[ currentRow copy ]		ifFalse:			[ currentRow ].	1 to: numColumns		do: [ :index |			(rowAdaptors at: index)				value: currentRowCopy				value: (self getFieldExternal: index) ].	^currentRowCopy</body><body package="Database">hasAnswerSetExternal	"Answer true if the SQL-statement (batch) being processed returns an answer set."	^self subclassResponsibility</body><body package="Database">nextRowExternal	"Answer with the next row of data.  Answer nil at end"	| currentRowCopy |	( self advanceExternal == nil ) ifTrue:		[ "We've exhausted the answer set.  No DBMS cancel is necessary."		self state: #validResults.		^nil ].	"If we have a resultTemplate, use it to provide the answer."	( resultTemplate == nil ) ifFalse:		[ bufferIndex := 1.		^self nextViaTemplate: resultTemplate ].	currentRowCopy := allocateForEachRow		ifTrue:			[ currentRow copy ]		ifFalse:			[ currentRow ].	1 to: numColumns		do: [ :index |			(rowAdaptors at: index)				value: currentRowCopy				value: (self getFieldExternal: index) ].	^currentRowCopy</body><body package="Database">releaseAdaptors	"Release existing adaptors."	"Subclasses may release subclass-specific resources before invoking this method."	self rowAdaptors: nil</body><body package="Database">releaseBuffers	"Release buffers and their associated resources."	"Subclasses may release subclass-specific resources before invoking this method."	self rowBuffers: nil</body><body package="Database">releaseBuffersAndAdaptors	"Release buffers, adaptors, and their associated resources."	"Subclasses may release subclass-specific resources before invoking this method."	"Discard previous buffers, descriptors, and adaptors."	self releaseBuffers.	self releaseAdaptors.	self columnDescriptions: nil.	self numColumns: nil.</body><body package="Database">setupAdaptors	"Setup adaptors for populating the bindOutput object"	| adaptors bind directInstVarAccess bindSize adaptorIndex currentValue |	"Adaptors may already be set up."	rowAdaptors notNil ifTrue: [ ^self ].	adaptors := Array new: numColumns.	"If no template was specified we'll reify fetched rows as Arrays"	( bind := self bindOutput ) isNil ifTrue:		[ bind := Array new: numColumns ].	currentRow := bind.	"Determine which type of adaptor to build"	directInstVarAccess := false.	( bind class isVariable )		ifTrue:			[ bindSize := bind size ]		ifFalse:			[ bindSize := bind class instSize.			directInstVarAccess := true ].	useNamedOutputBinding ifTrue:		[ bindSize := numColumns ].	"Make a block to insert new values for each slot in the bind object.  This exploits the concept of copying-blocks.  It is assumed that the local variables referenced in the blocks used below as the putAdaptor will be copied on the block and thus be frozen at the time the execution path passes thru the creation of the block."	adaptorIndex := 0.	1 to: bindSize do:		[ :bindIndex | | putAdaptor |		useNamedOutputBinding			ifTrue:				[ | colName putSelector |				( colName := (columnDescriptions at: bindIndex) name ) isNil					ifTrue:	[ self class connectionClass invalidDescriptorCountSignal raise ].				currentValue := bind perform: colName asSymbol.				putSelector := (colName , ':') asSymbol.				putAdaptor := [ :subj :value | subj perform: putSelector with: value ] ]			ifFalse:				[ directInstVarAccess					ifTrue:						[ currentValue := bind instVarAt: bindIndex.						putAdaptor := [ :subj :value | subj instVarAt: bindIndex put: value ] ]					ifFalse:						[ currentValue := bind at: bindIndex.						putAdaptor := [ :subj :value | subj at: bindIndex put: value ] ] ].		"Skip slots in the bind object that contain instances of Object."		( currentValue class == Object ) ifFalse:			[ adaptorIndex := adaptorIndex + 1.			( adaptorIndex &gt; numColumns ) ifTrue:				[ self class connectionClass invalidDescriptorCountSignal raise ].			adaptors at: adaptorIndex put: putAdaptor ]		].	"We must bind exactly as many columns as there are non-skipped	slots in the bind object."	useNamedOutputBinding ifFalse:		[ ( adaptorIndex == numColumns  ) ifFalse:			[ self class connectionClass invalidDescriptorCountSignal raise ] ].	self rowAdaptors: adaptors.</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>private-binding</category><body package="Database">bindExternal	"Bind values to parameters in the query, avoiding unnecessary rebinding where possible.  For each bind marker in the query fragments, get the corresponding value from the bindInput object.  If the value isn't already bound, bind and remember it.  (Subclasses that do not support binding must override this method to provide a substitute.)"	2 to: queryFragments size by: 2 do:		[:index || bindMarker value |		bindMarker := queryFragments at: index.		value := self inBindInputAt: bindMarker.		(self boundValueAt: bindMarker is: value) ifFalse:			[self bindValue: value at: bindMarker.			self bindValues at: bindMarker put: value]].</body><body package="Database">bindValue: aValue at: aPosition	"Bind aValue at aPosition."	^self subclassResponsibility</body><body package="Database">bindValues	"Answer with the receiver's bind value dictionary."	^bindValues notNil		ifTrue:	[ bindValues ]		ifFalse:	[ bindValues := IdentityDictionary new ]</body><body package="Database">boundValueAt: aPosition is: aValue	"Answer true if there is a parameter bound at aPosition, and if	its value is the same as aValue.  Otherwise, answer false."	| boundValue |	boundValue := self bindValues at: aPosition ifAbsent: [ ^false ].	boundValue = aValue ifTrue: [ ^true ].	self bindValues removeKey: aPosition.	^false</body><body package="Database">inBindInputAt: bindMarker	"Answer the value in bindInput that corresponds to the bindMarker.	If the bindMarker is an integer, the value will be in an instance variable	or indexed variable index.  If the bindMarker is a symbol, bindInput is	assumed to respond to the bindMarker as a message with the value."	^bindMarker isInteger		ifTrue:	[ bindInput class isVariable					ifTrue:						[ bindMarker &gt; bindInput size ifTrue:							[ self class connectionClass invalidDescriptorCountSignal raise ].						bindInput at: bindMarker ]					ifFalse:						[ bindMarker &gt; bindInput class instSize ifTrue:							[ self class connectionClass invalidDescriptorCountSignal raise ].						bindInput instVarAt: bindMarker ] ]		ifFalse:	[ bindInput perform: bindMarker ]</body><body package="Database">prepareExternal	"Send the query text to the external DBMS to be prepared."	^self subclassResponsibility</body><body package="Database">releaseBindings	"Release bind values."	bindValues := nil.</body><body package="Database">scanMarkerFrom: aStream	"Scan a parameter marker from aStream."	^self		scanNumberOrTokenFrom: aStream		doing:			[:number :tokenStream | 			number == nil				ifTrue:					[| token |					tokenStream isNil						ifTrue: [nil]						ifFalse:							[token := tokenStream contents.							token isEmpty								ifTrue: [self class invalidParameterMarkerSignal raise].							token asSymbol]]				ifFalse: [number]].</body><body package="Database">scanNumberOrTokenFrom: aStream doing: aBlock	"Scan a parameter marker from aStream."	| ch rule number tokenStream |	aStream atEnd ifTrue: [^aBlock value: nil value: #() readStream].	( ch := aStream next ) isDigit		ifTrue:			[ rule := [ :c | c isDigit ].			number := 0 ]		ifFalse:			[ rule := [ :c | c isAlphaNumeric or: [ c == $_ ] ].			tokenStream := WriteStream on: (String new: 16).			number := nil ].	[ ch notNil and: [ rule value: ch ] ] whileTrue:		[ number == nil			ifTrue:	[ tokenStream nextPut: ch ]			ifFalse:	[ number := (number * 10) + ch digitValue ].		ch := aStream atEnd ifTrue: [nil] ifFalse: [aStream next] ].	ch notNil ifTrue:		[ aStream skip: -1 ].	^aBlock value: number value: tokenStream.</body><body package="Database">setupQuery: aString	"Save the query. Break the query into an Array of fragments, 	isolating each parameter marker. Save the fragmented form."	"The size of the fragment array will always be odd, with parameter 	markers at even positions. Markers of the form '?' and ':number' 	are converted to index-into-bindInput-object form. Markers of 	the form ':name' are converted to #name."	| stream fragmentStream collection markerCount ch prevCh marker cr tab space |	query := aString.	stream := query readStream.	fragmentStream := WriteStream on: (aString class new: query size).	collection := OrderedCollection new: 13.	markerCount := 0.	ch := $?.	cr := Character cr.	tab := Character tab.	space := Character space.	[ stream atEnd ] whileFalse:		[ prevCh := ch.		ch := stream next.		( ch == $' or: [ ch == $" ] )			ifTrue:				[ fragmentStream					nextPut: ch;					nextPutAll: (stream through: ch) ]			ifFalse:				[ ( ch == $?				or: [ (ch == $:) and: [ (prevCh isAlphaNumeric not and: [ (prevCh == $:) not ]) and: [ stream atEnd not and: [stream peek isAlphaNumeric ]] ] ] )					ifTrue:						[ markerCount := markerCount + 1.						collection add: fragmentStream contents.						fragmentStream reset.						( ch == $? )							ifTrue:								[ collection add: markerCount ]							ifFalse:								[ marker := self scanMarkerFrom: stream.								"ch does not reflect that last character, but that's O.K."								collection add: marker ] ]					ifFalse:						[ (ch == cr or: [ ch == tab]) ifTrue:							[ ch := space ].						fragmentStream nextPut: ch ] ] ].	collection add: fragmentStream contents.	queryFragments := collection.</body><body package="Database">startPrepare	"Get the receiver into a reasonable state to prepare a new SQL statement."	| stateTemp |	"Should we clean up after any previous work?"	self isExecuting ifTrue:		[ self cancel ].	"If not already held, acquire the right to execute SQL statements."	( self state == #new ) ifTrue:		[ self connect ] .	"Enforce: we're in a legal state to prepare new SQL text."	( (stateTemp := self state) == #connected	or: [ stateTemp == #prepared ] ) ifFalse:		[ self class connectionClass invalidSessionStateSignal raise ].	"Release any previously held buffers and adaptors."	self releaseBuffersAndAdaptors.	"Previous bind parameters are now invalid."	self releaseBindings.	"Drop the old query texts."	query := nil.	queryFragments := nil.	"Default to a connected state"	self state: #connected</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>private-execution</category><body package="Database">cancelExternal	^self subclassResponsibility</body><body package="Database">delayUntilReady	"Delay until the server is ready."	"Assert: self state == #executing"	| ticks |	ticks := 1.	[ self isReady ]		whileFalse:			[ (Delay forMilliseconds: ticks) wait.			ticks &lt; 1000 ifTrue: [ ticks := ticks + ticks ] ].	"Assert: self state == #ready"</body><body package="Database">executeExternal	"Execute the prepared query."	"Subclasses that don't support query preparation will need to assemble the	query in the overriding method."	^self subclassResponsibility</body><body package="Database">moreResultsExternal	"Answer true if there are more results available, otherwise answer false.	Raise an exception if there are errors."	^self subclassResponsibility</body><body package="Database">readyExternal	"Answer whether or not the dbms has processed the SQL statement (batch)."	^self subclassResponsibility</body><body package="Database">resultsExternal	"Examine the outcome of executing an SQL statement and raise exceptions	for any errors.  Answer a boolean indicating the presense of an answer."	^self subclassResponsibility</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>private-finalization</category><body package="Database">executor	"Answer with an executor for this session."	"Subclassess will want to override to add information to the executor. 	The subclass method should use super executor to create the executor 	initially."	| ex |	ex := super executor.	ex connection: connection.	ex rowBuffersHolder: self rowBuffersHolder.	^ex</body><body package="Database">finalizeExternal	"Release all external resource."	( traceLevel &gt;= 1 ) ifTrue: [ self class trace: nil ].	self isExecuting ifTrue: [ self cancelExternal ].	super finalizeExternal</body></methods><methods><class-id>Database.ExternalDatabaseSession</class-id> <category>private-testing</category><body package="Database">isExecuting	"Answer true if receiver is in an executing state."	| state |	^(state := self state) == #executing	or: [state == #ready	or: [state == #validResults	or: [state == #fetchingData]]]</body></methods><methods><class-id>Database.ExternalDatabaseSession class</class-id> <category>instance creation</category><body package="Database">new	^self error: (#errNewExternalDatabaseSession &lt;&lt; #database &gt;&gt; 'An ExternalDatabaseSession is obtained from an instance of ExternalDatabaseConnection.')</body></methods><methods><class-id>Database.ExternalDatabaseSession class</class-id> <category>accessing</category><body package="Database">answerStreamClass	^ExternalDatabaseAnswerStream</body><body package="Database">xif	"Answer the ExternalInterface subclass instance in use."	^self connectionClass xif</body></methods><methods><class-id>Database.ExternalDatabaseSession class</class-id> <category>private-instance creation</category><body package="Database">newForConnection: aConnection	"Answer a new ExternalDatabaseSession associated with aConnection."	| req |	(req := self basicNew) initialize.	req connection: aConnection.	^req</body></methods><methods><class-id>Database.IndexConflict</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errUpdatePrimaryKey &lt;&lt; #database &gt;&gt; 'You cannot update the primary key of an existing row or insert a new row if this would result in more than one row with the same primary key.') asString</body></methods><methods><class-id>Database.UnableToFetchData</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errUnableToFetch &lt;&lt; #database &gt;&gt; 'Unable to fetch one or more rows of data') asString</body></methods><methods><class-id>Database.InvalidSessionState</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errSessionState &lt;&lt; #database &gt;&gt; 'Invalid Session State') asString</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>initialize-release</category><body package="Database">initialize	self queryModel onChangeSend: #changedQuery to: self.	self blockFactor: 1.	self connectedStatusHolder onChangeSend: #connectedStatusChanged to: self.	self executeStatusHolder onChangeSend: #executeStatusChanged to: self.	self moreAnswersStatusHolder onChangeSend: #moreAnswersStatusChanged to: self.	self truncateColumnsStatusHolder onChangeSend: #truncateColumnsStatusChanged to: self.	self dsvList list: List new.	dsvList list add: (Array with: '   ' with: '   ') copy.</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>accessing</category><body package="Database">blockFactor	^self blockFactorModel value</body><body package="Database">blockFactor: anInteger	self blockFactorModel value: (anInteger max: 1)</body><body package="Database">environment	^profile environment</body><body package="Database">password	^profile password</body><body package="Database">query	^self queryModel value</body><body package="Database">username	^profile userName</body><body package="Database">whichDriver	^profile driverClassName</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>actions</category><body package="Database">changedQuery	connection notNil ifTrue:		[ self executeStatusHolder value: self query isEmpty not ]</body><body package="Database">connect	self connectToProfile: ConnectionDialog chooseProfile.</body><body package="Database">connectToProfile: aProfile	profile := aProfile.	connection := profile isNil ifFalse:		[ConnectionDialog connect: profile].	session := connection isNil ifFalse:		[connection password: profile password.		connection getSession].	self connectedStatusHolder value: connection notNil.</body><body package="Database">disconnect	Cursor database showWhile: [connection disconnect].	session := nil.	connection := nil.	self connectedStatusHolder value: false</body><body package="Database">execute	| discardSession |	self updateQueryChoices.	discardSession := false.	Cursor database showWhile: 			[			[session isNil ifTrue: [session := connection getSession connect].			session prepare: self query asString.			session blockFactor: self blockFactor.			session execute.			answerStream := session answer.			self nextAnswer] 					on: connection class externalDatabaseErrorSignal					do: 						[:exception | 						self reportError: (self messageFor: exception).						discardSession := true.						exception return]].	discardSession ifTrue: [session notNil ifTrue: [session disconnect]]</body><body package="Database">fetchBuffers	| saveBlockFactor spec dialog |	saveBlockFactor := self blockFactor.	"Raise dialog."	spec := self class interfaceSpecFor: #buffersSpec.	dialog := SimpleDialog new.	dialog builder source: self.	dialog parentView: builder window.	dialog allButOpenFrom: spec.	dialog builder openDialog.	"Restore original value?"	(dialog accept value) ifFalse:		[ self blockFactor: saveBlockFactor ]</body><body package="Database">nextAnswer	| cols list |	cols := Array new: 0.	list := Array new: 0.	answerStream == #noMoreAnswers ifFalse:		[ answerStream == #noAnswerStream ifFalse:			[ cols := answerStream columnDescriptions.			list := answerStream upToEnd ].		self updateDataset: list columns: cols.		(answerStream := session answer) == #noMoreAnswers			ifTrue:				[ self moreAnswersStatusHolder value: false.				session disconnect.				session := nil ]			ifFalse:				[ self moreAnswersStatusHolder value: true ] ].</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>aspects</category><body package="Database">blockFactorModel	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^blockFactorModel isNil ifTrue: [blockFactorModel := 0 asValue] ifFalse: [blockFactorModel]</body><body package="Database">connectedStatusHolder	^connectedStatusHolder isNil ifTrue: [connectedStatusHolder := false asValue] ifFalse: [connectedStatusHolder]</body><body package="Database">datasetWidget	^(self builder componentAt: #dataset1) widget</body><body package="Database">dsvList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^dsvList isNil		ifTrue:			[dsvList :=  SelectionInList new]		ifFalse:			[dsvList]</body><body package="Database">executeStatusHolder	^executeStatusHolder isNil ifTrue: [executeStatusHolder := false asValue] ifFalse: [executeStatusHolder]</body><body package="Database">moreAnswersStatusHolder	^moreAnswersStatusHolder isNil ifTrue: [moreAnswersStatusHolder := false asValue] ifFalse: [moreAnswersStatusHolder]</body><body package="Database">queryChoices	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^queryChoices isNil		ifTrue:			[queryChoices := List new asValue]		ifFalse:			[queryChoices]</body><body package="Database">queryModel	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^queryModel isNil		ifTrue:			[queryModel := String new asValue]		ifFalse:			[queryModel]</body><body package="Database">selectedRow	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^selectedRow isNil		ifTrue:			[selectedRow := nil asValue]		ifFalse:			[selectedRow]</body><body package="Database">spinButtonModel	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^spinButtonModel isNil		ifTrue:			[spinButtonModel := 0 asValue]		ifFalse:			[spinButtonModel]</body><body package="Database">truncateColumnsStatusHolder	"Default is true, consistent with legacy Ad Hoc SQL column widths calculation.	The resulting column widths are imperfect, but very quick to calculate."	^truncateColumnsStatusHolder isNil		ifTrue:			[truncateColumnsStatusHolder := true asValue]		ifFalse:			[truncateColumnsStatusHolder]</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>interface opening</category><body package="Database">postBuildWith: aBuilder 	"Hide the dataset until it has something to look at."	self datasetWidget isVisible: false</body><body package="Database">postOpenWith: aBuilder 	"This message is sent by the builder after it has opened a completed 	window."	"The disconnect, execute, and next answer buttons are enabled under program control."	| menuBar |	"We want to notice any character typed into the query so that an accept isn't required."	(aBuilder componentAt: #queryTextEditor) widget controller continuousAccept: true.	"Arrange for the menu items to be enabled correctly."	menuBar := aBuilder menuAt: #menuBar.	(menuBar atNameKey: #connect) enabled: [self connectedStatusHolder value not].	(menuBar atNameKey: #disconnect) enabled: self connectedStatusHolder.	(menuBar atNameKey: #execute) enabled: self executeStatusHolder.	(menuBar atNameKey: #nextAnswer) enabled: self moreAnswersStatusHolder.	self truncateColumnsStatusHolder value ifTrue:		[(menuBar atNameKey: #shouldTruncateColumns) beOn]	ifFalse:		[(menuBar atNameKey: #shouldTruncateColumns) beOff]</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>private</category><body package="Database">connectedStatusChanged	| connected |	connected := self connectedStatusHolder value.	(builder componentAt: #connect) isEnabled: connected not.	(builder componentAt: #disconnect) isEnabled: connected.	connected		ifTrue:			[ self query isEmpty ifFalse:				[ self executeStatusHolder value: true ] ]		ifFalse:			[ self executeStatusHolder value: false.			self moreAnswersStatusHolder value: false ]</body><body package="Database">executeStatusChanged	(builder componentAt: #execute) isEnabled: self executeStatusHolder value</body><body package="Database">messageFor: exception	| errs msg |	exception == connection class authenticationFailureSignal ifTrue:		[ ^exception errorString ].	( (errs := exception parameter) notNil	and: [ errs isEmpty not	and: [ (msg := (exception parameter at: 1) dbmsErrorString) notNil	and: [ msg isEmpty not ] ] ] )		ifTrue: [ ^msg ]		ifFalse: [ ^exception errorString ]</body><body package="Database">moreAnswersStatusChanged	(builder componentAt: #nextAnswer) isEnabled: self moreAnswersStatusHolder value</body><body package="Database">reportError: errorText	| spec dialog |	"Raise dialog."	spec := self class interfaceSpecFor: #reportErrorSpec.	dialog := SimpleDialog new.	dialog builder source: self.	dialog builder aspectAt: #errorText put: errorText asValue.	dialog parentView: builder window.	dialog allButOpenFrom: spec.	dialog builder window label: (#errDatabaseError &lt;&lt; #database &gt;&gt; 'Database Error').	(dialog builder componentAt: #errorText) widget controller		keyboardHook: [:ev :ctrlr | nil ].	"Deny type-in, but allow menu for copy"	dialog builder openDialog</body><body package="Database">spinButtonChanged	"Since the spin button is declared without an upper bound, its new value needs to be bumped back down if out of bounds."	| index maxAllowed |	index := self spinButtonModel value.	maxAllowed := self queryChoices value size.	index &gt; maxAllowed ifTrue: [self spinButtonModel value: maxAllowed].	((1 to: maxAllowed) includes: index)		ifTrue: [self queryModel value: (self queryChoices value at: index)]</body><body package="Database">truncateColumnsStatusChanged	| menuBar |	menuBar := builder menuAt: #menuBar.	self truncateColumnsStatusHolder value ifTrue:		[(menuBar atNameKey: #shouldTruncateColumns) beOn]	ifFalse:		[(menuBar atNameKey: #shouldTruncateColumns) beOff]</body><body package="Database">updateDataset: list columns: descrs	"Update the dataset with the list of data records, and descrs database column descriptions."	| col width columnWidths |	self clearDataset.	dsvList list addAll: list copy.	columnWidths := self truncateColumnsStatusHolder value				ifTrue: [self truncatedWidthsOfColumns: descrs]				ifFalse: [self adequateWidthsOfColumns: descrs forRows: list].	1 to: descrs size		do: 			[:index |			col := descrs at: index.			width := columnWidths at: index.			index = 1				ifTrue: [self firstColumnLabel: col name width: width]				ifFalse: [self addColumnLabel: col name width: width]].	self datasetWidget invalidate.	self datasetWidget isVisible: true			"Ensure that the dataset gets displayed."</body><body package="Database">updateQueryChoices	"Add the query to the list if not already there, and set the spin button to its location in the list."	| currentQuery index |	currentQuery := self query asString.	index := self queryChoices value		privateIndexOf: currentQuery		ifAbsent:			[self queryChoices value add: currentQuery.			self queryChoices value size].	self spinButtonModel value: index.</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>events</category><body package="Database">noticeOfWindowClose: aWindow 	"The ApplicationWindow aWindow is in the process of closing. 	Disconnect from the database if needed."	connection notNil ifTrue:		[ self disconnect ]</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>testing</category><body package="Database">shouldTruncateColumns	| isChecked |	isChecked := self truncateColumnsStatusHolder value.	self truncateColumnsStatusHolder value: (isChecked not).</body></methods><methods><class-id>Database.AdHocQueryTool</class-id> <category>private-dataset</category><body package="Database">addColumnLabel: aString width: aNumber	"Add a column to the dataset view. To go into effect, send &gt;&gt;invalidate to the dataset."	| columnCollection newColumn dataset columnSpec newColumnNumber aspectSymbol |	dataset := self datasetWidget.	columnCollection := dataset columnDescriptors asOrderedCollection.	columnSpec := columnCollection first description copy.	newColumnNumber := columnCollection size + 1.	aspectSymbol := ('selectedRow ', newColumnNumber printString) asSymbol.	columnSpec				label: aString;				model: aspectSymbol;				width: aNumber.	newColumn := columnSpec columnWithBuilder: self builder.	columnCollection add: newColumn.	dataset columnDescriptors: columnCollection.</body><body package="Database">adequateWidthsOfColumns: columnDescriptions forRows: data	"Return the space needed for each column of data, based on db column name and size.	This method examines every row to find the minimum width necessary for each column."	| columnWidths dataWidths labelWidths |	labelWidths := self labelWidthsOfColumns: columnDescriptions.	^data isEmpty		ifTrue: [labelWidths]		ifFalse: 			[dataWidths := self columnWidthsFromData: data.			columnWidths := Array new: labelWidths size withAll: 0.			1 to: columnDescriptions size				do: [:i | columnWidths at: i put: ((labelWidths at: i) max: (dataWidths at: i))].			columnWidths]</body><body package="Database">clearDataset	| dataset firstColumn |	self dsvList list: List new.	dataset := self datasetWidget.	firstColumn := dataset columnDescriptors asOrderedCollection first.	dataset columnDescriptors: (OrderedCollection new add: firstColumn; yourself).	self firstColumnLabel: '.' width: 80.	dataset invalidate</body><body package="Database">columnWidthsFromColumnDescriptions: columnDescriptions	"Return the space needed for each column of data, based on database's declared column size.	This uses the legacy AdHoc Query algorithm, which truncates display data."	| declaredColumnWidths mwidth col dataWidth |	declaredColumnWidths := Array new: columnDescriptions size withAll: 0.	mwidth := 'm' asComposedText width.	"I.e. width of representative character"	1 to: columnDescriptions size		do: 			[:i |			col := columnDescriptions at: i.			dataWidth := mwidth * col maxColumnConstraint asInteger min: 3 * 72.			declaredColumnWidths at: i put: dataWidth].	^declaredColumnWidths</body><body package="Database">columnWidthsFromData: rows	"Update the space needed for each column of data	by finding the longest entry of all rows for that column."	| datum maxColumnWidths |	maxColumnWidths := Array new: (rows first size) withAll: 0.	rows do: 			[:rowData |			1 to: rowData size				do: 					[:col |					| len |					datum := (rowData at: col) printString trimBlanks.					len := datum asComposedText width + 10.					len &gt; (maxColumnWidths at: col) ifTrue: [maxColumnWidths at: col put: len]]].	^maxColumnWidths</body><body package="Database">firstColumnLabel: aString width: aNumber	"Alter the permanent first column of the dataset view."	| dataset label columnDescriptor |	dataset := self datasetWidget.	columnDescriptor := dataset columnDescriptors first.	label := columnDescriptor label component.	label setLabelString: aString.	columnDescriptor width: aNumber.	dataset computeStarts invalidate</body><body package="Database">labelWidthsOfColumns: columnDescriptions	"Return the space needed for each column label.	This serves as a minimum value for each column display width."	| labelWidths col width |	labelWidths := Array new: columnDescriptions size withAll: 0.	1 to: columnDescriptions size		do: 			[:i |			col := columnDescriptions at: i.			width := 36 max: col name asComposedText width + 10.			labelWidths at: i put: width].	^labelWidths</body><body package="Database">truncatedWidthsOfColumns: columnDescriptions	"Return the space needed for each column of data, based on db column name and size.	This uses the legacy AdHoc Query algorithm, which truncates display data."	| columnWidths labelWidths dataWidths width |	columnWidths := Array new: columnDescriptions size withAll: 0.	labelWidths := self labelWidthsOfColumns: columnDescriptions.	dataWidths := self columnWidthsFromColumnDescriptions: columnDescriptions.	1 to: columnDescriptions size		do: 			[:i |			width := (labelWidths at: i) max: (dataWidths at: i).			columnWidths at: i put: width].	^columnWidths</body></methods><methods><class-id>Database.ExternalDatabaseError</class-id> <category>accessing</category><body package="Database">dbmsErrorCode	"Answer the error code used by the dbms api which lead to this error report."	^dbmsErrorCode</body><body package="Database">dbmsErrorString	"Answer the text associated with the code value returned from the dbms api. 	Not all dbms api make this information available."	^dbmsErrorString</body><body package="Database">osErrorCode	"Answer the error code provided by the dbms api which is attributed to the underlying	operating system.  This is usually just detail information about the dbmsErrorCode."	^osErrorCode</body><body package="Database">osErrorString	"Answer the text associated with the osErrorCode returned from the dbms api. 	Not all systems make this information available."	^osErrorString</body></methods><methods><class-id>Database.ExternalDatabaseError</class-id> <category>private-accessing</category><body package="Database">dbmsErrorCode: aSmallInteger	dbmsErrorCode := aSmallInteger</body><body package="Database">dbmsErrorString: aString	dbmsErrorString := aString</body><body package="Database">osErrorCode: aSmallInteger	osErrorCode := aSmallInteger</body><body package="Database">osErrorString: aString	osErrorString := aString</body></methods><methods><class-id>Database.TooManyActiveSessions</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errMaxSessionsPerConnection &lt;&lt; #database &gt;&gt; 'The maximum number of sessions are already active in this connection') asString</body></methods><methods><class-id>Database.UnableToCreateConnectionPool</class-id> <category>printing</category><body package="Database">defaultMessageText	^(#errConnectionPoolCreation &lt;&lt; #database &gt;&gt; 'unable to create connection pool.') asString</body></methods><methods><class-id>UI.TableAdaptor</class-id> <category>accessing</category><body package="Database">elementSize	^baseCollection size</body></methods><methods><class-id>Database.DBProfileManager class</class-id> <category>private</category><body package="Database">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: #(#{UserMessage} #key: #DatabaseRepositories #catalogID: #database #defaultString: 'Database Repositories') 			#min: #(#{Core.Point} 492 188 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 526 384 956 584 ) 			#flags: 4 			#menu: #menuBar 			#toolBar: #toolbarMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #allowSorting true #allowColumnReordering false #allowColumnResizing true #showVerticalLines false #rowSize 22 #showHorizontalLines false #rowLabelsAsButtons false ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 0 1 ) 					#name: #profileDataset 					#flags: 13 					#model: #profileListHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #profileSelected 						#doubleClickSelector: #profileListDoubleClicked ) 					#menu: #profileListMenu 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting false #labelFromApplication false ) 							#model: #'selectedProfileHolder isConnectable' 							#label: '' 							#labelIsImage: false 							#width: 22 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting false #labelFromApplication false ) 							#model: #'selectedProfileHolder name' 							#label: #(#{UserMessage} #key: #Name #catalogID: #database #defaultString: 'Name') 							#labelIsImage: false 							#width: 100 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting false #labelFromApplication false ) 							#model: #'selectedProfileHolder environment' 							#label: #(#{UserMessage} #key: #Environment #catalogID: #database #defaultString: 'Environment') 							#labelIsImage: false 							#width: 200 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting false #labelFromApplication false ) 							#model: #'selectedProfileHolder userName' 							#label: #(#{UserMessage} #key: #User #catalogID: #database #defaultString: 'User') 							#labelIsImage: false 							#width: 80 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) ) 					#labelsAsButtons: true ) ) ) )</body></methods><methods><class-id>Database.DBProfileManager class</class-id> <category>resources</category><body package="Database">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #store ) 				#nameKey: #file 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ImportDots 								#defaultString: '&amp;Import...' 								#catalogID: #store ) 							#nameKey: #fileImport 							#value: #fileImport 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileOpen ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_ExportDots 								#defaultString: '&amp;Export...' 								#catalogID: #store ) 							#nameKey: #fileSave 							#value: #fileSave 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileSave ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Close 								#defaultString: '&amp;Close' 								#catalogID: #store ) 							#nameKey: #fileClose 							#value: #fileClose ) ) #(2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_profile 					#defaultString: '&amp;profile' 					#catalogID: #store ) 				#nameKey: #profile 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_NewDots 								#defaultString: '&amp;New...' 								#catalogID: #store ) 							#nameKey: #profileNew 							#value: #profileNew 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #addRepository ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_PropertiesDots 								#defaultString: '&amp;Properties...' 								#catalogID: #store ) 							#nameKey: #profileProperties 							#value: #profileProperties 							#enablementSelector: #isProfileSelected 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #properties ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Remove 								#defaultString: '&amp;Remove...' 								#catalogID: #store ) 							#nameKey: #profileRemove 							#value: #profileRemove 							#enablementSelector: #isProfileSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_Connect 								#defaultString: '&amp;Connect' 								#catalogID: #store ) 							#nameKey: #profileToggleConnection 							#value: #profileToggleConnection 							#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #repositoryConnect ) ) ) #(1 2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Help 					#defaultString: '&amp;Help' 					#catalogID: #store ) 				#nameKey: #help 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_AboutVisualWorks 								#defaultString: '&amp;About VisualWorks...' 								#catalogID: #store ) 							#nameKey: #helpAbout 							#value: #helpAbout ) ) #(1 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="Database">profileListMenu	"Tools.MenuEditor new openOnClass: self andSelector: #profileListMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_NewDots 					#defaultString: '&amp;New...' 					#catalogID: #store ) 				#nameKey: #profileNew 				#value: #profileNew 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #addRepository ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_PropertiesDots 					#defaultString: '&amp;Properties...' 					#catalogID: #store ) 				#nameKey: #profileProperties 				#value: #profileProperties 				#enablementSelector: #isProfileSelected 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #properties ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Remove 					#defaultString: '&amp;Remove...' 					#catalogID: #store ) 				#nameKey: #profileRemove 				#value: #profileRemove 				#enablementSelector: #isProfileSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Connect 					#defaultString: '&amp;Connect' 					#catalogID: #store ) 				#nameKey: #profileToggleConnection 				#value: #profileToggleConnection 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #repositoryConnect ) ) ) #(1 2 1 ) nil ) decodeAsLiteralArray</body><body package="Database">toolbarMenu	"We reuse the repository icons (from RepositoryManager) rather than invent new ones."	"Tools.MenuEditor new openOnClass: self andSelector: #toolbarMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ImportDots 					#defaultString: '&amp;Import...' 					#catalogID: #store ) 				#nameKey: #fileImport 				#value: #fileImport 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileOpen ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #ImportRepositoriesFromFile 					#defaultString: 'Import repositories from file' 					#catalogID: #store ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_ExportDots 					#defaultString: '&amp;Export...' 					#catalogID: #store ) 				#nameKey: #fileSave 				#value: #fileSave 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #fileSave ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #ExportRepositoriesToFile 					#defaultString: 'Export repositories to file' 					#catalogID: #store  ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_NewDots					#defaultString: '&amp;New...' 					#catalogID: #store ) 				#nameKey: #profileNew 				#value: #profileNew 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #addRepository ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #CreateANewprofile 					#defaultString: 'Create a new profile' 					#catalogID: #store ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_PropertiesDots 					#defaultString: '&amp;Properties...' 					#catalogID: #store ) 				#nameKey: #profileProperties 				#value: #profileProperties 				#enablementSelector: #isProfileSelected 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #properties ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #EditprofileProperties 					#defaultString: 'Edit profile properties' 					#catalogID: #store ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Connect 					#defaultString: '&amp;Connect' 					#catalogID: #store ) 				#nameKey: #profileToggleConnection 				#value: #profileToggleConnection 				#labelImage: #(#{UI.ResourceRetriever} #{ToolbarIconLibrary} #repositoryConnect ) 				#helpText: 				#(#{Kernel.UserMessage} 					#key: #ConnectOrDisconnectTheSelectedprofile 					#defaultString: 'Connect or disconnect the selected profile' 					#catalogID: #store ) ) ) #(2 2 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.DBProfilePropertiesDialog class</class-id> <category>interface specs</category><body package="Database">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #DBProfileProperties 				#defaultString: 'DBProfile Properties' 				#catalogID: #store ) 			#min: #(#{Core.Point} 410 201 ) 			#max: #(#{Core.Point} 410 201 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 922 585 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 130 15 300 40 ) 					#name: #nameField 					#model: #nameHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.Rectangle} 130 45 300 70 ) 					#name: #databaseCombo 					#model: #databaseHolder 					#type: #string 					#comboList: #databaseListHolder ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 130 75 300 100 ) 					#name: #environmentField 					#model: #environmentHolder ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 130 105 300 130 ) 					#name: #userNameField 					#model: #userNameHolder ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 130 135 300 160 ) 					#name: #passwordField 					#model: #passwordHolder 					#type: #password ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 14 0 -10 1 39 0 ) 					#name: #accept 					#model: #ok 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #database ) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 46 0 -10 1 71 0 ) 					#name: #cancel 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #database ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 40 0 0 1 ) 					#name: #Label1 					#label: 					#(#{Kernel.UserMessage} 						#key: #NameC 						#defaultString: 'Name:' 						#catalogID: #store ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 70 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #interface 						#defaultString: 'Interface:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 130 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #userName 						#defaultString: 'User Name:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 160 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #password 						#defaultString: 'Password:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 100 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #environment 						#defaultString: 'Environment:' 						#catalogID: #database ) ) ) ) )</body></methods><methods><class-id>Database.ConnectionDialog class</class-id> <category>interface specs</category><body package="Database">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ConnectToDatabase 				#defaultString: 'Connect to Database' 				#catalogID: #database ) 			#min: #(#{Core.Point} 426 216 ) 			#max: #(#{Core.Point} 426 216 ) 			#bounds: #(#{Graphics.Rectangle} 507 342 933 558 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 46 0 320 0 210 0 ) ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 14 0 320 0 38 0 ) 					#name: #connectionProfile 					#model: #connectionProfileHolder 					#type: #string 					#comboList: #connectionProfileListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 56 0 310 0 79 0 ) 					#name: #databaseCombo 					#model: #databaseHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #databaseChanged ) 					#type: #string 					#comboList: #databaseListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 85 0 310 0 109 0 ) 					#name: #environmentCombo 					#model: #environmentHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #environmentChanged ) 					#isReadOnly: false 					#comboList: #environmentListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 114 0 310 0 138 0 ) 					#name: #userNameCombo 					#model: #userNameHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #userNameChanged ) 					#isReadOnly: false 					#comboList: #userNameListHolder ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 143 0 310 0 167 0 ) 					#name: #passwordField 					#model: #passwordHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #passwordChanged ) 					#type: #password ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 175 0 220 0 198 0 ) 					#name: #saveProfile 					#model: #saveProfile 					#label: 					#(#{Kernel.UserMessage} 						#key: #Save 						#defaultString: 'Save...' 						#catalogID: #database ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 230 0 175 0 310 0 198 0 ) 					#name: #deleteProfile 					#model: #deleteProfile 					#label: 					#(#{Kernel.UserMessage} 						#key: #Delete 						#defaultString: 'Delete' 						#catalogID: #database ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 14 0 -10 1 39 0 ) 					#name: #connect 					#model: #connect 					#label: 					#(#{Kernel.UserMessage} 						#key: #Connect 						#defaultString: 'Connect' 						#catalogID: #database ) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 46 0 -10 1 71 0 ) 					#name: #cancel 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #database ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 80 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #interface 						#defaultString: 'Interface:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 138 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #userName 						#defaultString: 'User Name:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 167 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #password 						#defaultString: 'Password:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 109 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #environment 						#defaultString: 'Environment:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 9 0 38 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #profile 						#defaultString: 'Connection Profile:' 						#catalogID: #database ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 91 0 -10 1 109 0 ) 					#name: #browseFiles 					#model: #browseFiles 					#label: 					#(#{Kernel.UserMessage} 						#key: #BrowseFiles 						#defaultString: 'Browse Files' 						#catalogID: #database ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.DBProfileListPage class</class-id> <category>interface specs</category><body package="Database">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #UnlabeledCanvas 				#defaultString: 'Unlabeled Canvas' 				#catalogID: #database ) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 1024 768 ) 			#bounds: #(#{Graphics.Rectangle} 791 381 1129 669 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #showHorizontalLines false #allowColumnResizing true #rowSize 25 #showVerticalLines false #allowColumnReordering false ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -36 1 ) 					#name: #profileListDataset 					#model: #profileListHolder 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false #allowSorting false #allowResizing true ) 							#model: #'profileHolder name' 							#label: 							#(#{Kernel.UserMessage} 								#key: #Name 								#defaultString: 'Name' 								#catalogID: #database ) 							#labelIsImage: false 							#width: 100 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting false #labelFromApplication false #allowResizing true ) 							#model: #'profileHolder environment' 							#label: 							#(#{Kernel.UserMessage} 								#key: #Environment 								#defaultString: 'Environment' 								#catalogID: #database ) 							#labelIsImage: false 							#width: 200 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) ) 					#labelsAsButtons: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -30 1 -3 0.333333 0 1 ) 					#name: #addButton 					#model: #addProfile 					#label: 					#(#{Kernel.UserMessage} 						#key: #AddDots 						#defaultString: 'Add...' 						#catalogID: #database ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.333333 -30 1 -2 0.666666 0 1 ) 					#name: #removeButton 					#model: #removeProfile 					#label: 					#(#{Kernel.UserMessage} 						#key: #RemoveDots 						#defaultString: 'Remove...' 						#catalogID: #database ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.666666 -30 1 0 1 0 1 ) 					#name: #propertiesButton 					#model: #profileProperties 					#label: 					#(#{Kernel.UserMessage} 						#key: #PropertiesDots 						#defaultString: 'Properties...' 						#catalogID: #database ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Database.AdHocQueryTool class</class-id> <category>interface specs</category><body package="Database">buffersSpec	"UIPainter new openOnClass: self andSelector: #buffersSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 317 76 ) 			#max: #(#Point 317 76 ) 			#bounds: #(#Rectangle 326 467 643 543 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#InputFieldSpec 					#layout: #(#LayoutFrame -64 1 8 0 -24 1 32 0 ) 					#model: #blockFactorModel 					#alignment: #right 					#type: #number ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -82 0.5 -35 1 -8 0.5 -4 1 ) 					#model: #accept 					#label: #(#{UserMessage} #key: #OK #catalogID: #database #defaultString: 'OK' )					#isDefault: true ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame 16 0.5 -35 1 89 0.5 -4 1 ) 					#model: #cancel 					#label: #(#{UserMessage} #key: #Cancel #catalogID: #database #defaultString: 'Cancel' )					#defaultable: true ) 				#(#LabelSpec 					#layout: #(#AlignmentOrigin -66 1 32 0 1 1 ) 					#label: #(#{UserMessage} #key: #bufferRows #catalogID: #database #defaultString: 'Number of rows to buffer internally:') ) ) ) )</body><body package="Database">reportErrorSpec	"UIPainter new openOnClass: self andSelector: #reportErrorSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec 		#window: 		#(#WindowSpec 			#label: '' 			#min: #(#Point 313 200 ) 			#max: #(#Point 313 200 ) 			#bounds: #(#Rectangle 267 274 580 474 ) ) 		#component: 		#(#SpecCollection 			#collection: #(				#(#TextEditorSpec 					#layout: #(#LayoutFrame 0 0 0 0 0 1 -40 1 ) 					#name: #errorText 					#model: #errorText 					#tabable: true 					#menu: #errorTextMenu 					#isReadOnly: false ) 				#(#ActionButtonSpec 					#layout: #(#LayoutFrame -25 0.5 -35 1 25 0.5 -5 1 ) 					#model: #accept 					#label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #database) 					#isDefault: true 					#defaultable: true ) ) ) )</body><body package="Database">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #adHocSQL 				#defaultString: 'Ad Hoc SQL' 				#catalogID: #database ) 			#min: #(#{Core.Point} 485 317 ) 			#max: #(#{Core.Point} 1152 900 ) 			#bounds: #(#{Graphics.Rectangle} 1038 560 1538 877 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 5 0 90 0 35 0 ) 					#name: #connect 					#model: #connect 					#label: 					#(#{Kernel.UserMessage} 						#key: #Connect 						#defaultString: 'Connect' 						#catalogID: #database ) 					#isDefault: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 100 0 5 0 200 0 35 0 ) 					#name: #disconnect 					#flags: 40 					#model: #disconnect 					#label: 					#(#{Kernel.UserMessage} 						#key: #disconnect1 						#defaultString: 'Disconnect' 						#catalogID: #database ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 210 0 5 0 300 0 35 0 ) 					#name: #execute 					#flags: 40 					#model: #execute 					#label: 					#(#{Kernel.UserMessage} 						#key: #execute 						#defaultString: 'Execute' 						#catalogID: #database ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 310 0 5 0 420 0 35 0 ) 					#name: #nextAnswer 					#flags: 40 					#model: #nextAnswer 					#label: 					#(#{Kernel.UserMessage} 						#key: #nextAnswer1 						#defaultString: 'Next Answer' 						#catalogID: #database ) ) 				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #showHorizontalLines true #allowColumnResizing true #showVerticalLines true #allowColumnReordering false #rowSize 26 ) 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0.33 0 1 0 1 ) 					#name: #dataset1 					#model: #dsvList 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selectedRow 1' 							#label: '.' 							#labelFont: #default 							#labelIsImage: false 							#width: 80 							#rendererType: #Text 							#editorType: #None 							#font: #default 							#type: #object 							#noScroll: false 							#formatString: '' ) ) 					#horizontalPolicy: #noWrap ) 				#(#{UI.SpinButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 430 0 5 0 490 0 35 0 ) 					#name: #spinButton 					#model: #spinButtonModel 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #spinButtonChanged ) 					#helpText: 'Select a query for replay.' 					#type: #number 					#low: 0 					#interval: 1 ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 40 0 0 1 -8 0.33 ) 					#name: #queryTextEditor 					#model: #queryModel 					#tabRequiresControl: true ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 -7 0.33 0 1 -1 0.33 ) 					#name: #ResizingSplitter1 					#flags: 8 					#horizontal: true 					#minAboveSize: 40 					#minBelowSize: 80 					#aboveWidgets: '#queryTextEditor' 					#belowWidgets: '#dataset1' ) ) ) )</body></methods><methods><class-id>Database.AdHocQueryTool class</class-id> <category>resources</category><body package="Database">errorTextMenu	"MenuEditor new openOnClass: self andSelector: #errorTextMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem 				#rawLabel: #(#{UserMessage} #key: #copy #catalogID: #database #defaultString: 'copy' )				#value: #copySelection ) ) #(1 ) nil ) decodeAsLiteralArray</body><body package="Database">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #connection 					#defaultString: '&amp;Connection' 					#catalogID: #database ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #connect 								#defaultString: '&amp;Connect...' 								#catalogID: #database ) 							#nameKey: #connect 							#value: #connect ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #disconnect 								#defaultString: '&amp;Disconnect' 								#catalogID: #database ) 							#enabled: false 							#nameKey: #disconnect 							#value: #disconnect ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Exit 								#defaultString: 'E&amp;xit' 								#catalogID: #database ) 							#value: #closeRequest ) ) #(3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Execution 					#defaultString: '&amp;Execution' 					#catalogID: #database ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Execute 								#defaultString: '&amp;Execute' 								#catalogID: #database ) 							#enabled: false 							#nameKey: #execute 							#value: #execute ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #nextAnswer 								#defaultString: '&amp;Next Answer' 								#catalogID: #database ) 							#enabled: false 							#nameKey: #nextAnswer 							#value: #nextAnswer ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #buffers 								#defaultString: '&amp;Buffers...' 								#catalogID: #database ) 							#nameKey: #fetchBuffers 							#value: #fetchBuffers ) ) #(3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: '&amp;Display' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: '&amp;Fast Truncation' 							#nameKey: #shouldTruncateColumns 							#value: #shouldTruncateColumns 							#indication: true 							#helpText: 'Enable column truncation.' ) ) #(1 ) nil ) 				#helpText: 'Enable/disable column truncation.' ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-database</category><body package="Database">databaseProfiles	&lt;setting: #(tools dbprofiles)&gt;	^DBProfileListSetting new</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="Database">databaseProfilesPage	&lt;settingsPage: #(tools dbprofiles)&gt;	^DBProfileListPage new		label: #DBProfiles &lt;&lt; #labels &gt;&gt; 'Database - Profiles';		icon: (ListIconLibrary visualFor: #database);		setting: (self settingWithId: #(tools dbprofiles))</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - tools - database</category><body package="Database">menuItemOpenAdHocSQLQueryTool	&lt;menuItemForCommand: #openAdHocSQLQueryTool		nameKey: nil		menu: #(#menuBar #tools #database)		position: 10.1&gt;	self openApplicationForClassNamed: #{AdHocQueryTool}</body><body package="Database">submenuToolsDatabase	&lt;vwPrivileged&gt;	&lt;submenu: #(#_Database #menus '&amp;Database') 		nameKey: #database 		menu: #(#menuBar #tools) 		position: 30.2&gt;	^self</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>groups</category><body package="Database">databaseGroup	&lt;group: #database&gt;	^CommandGroup		label: #GroupDatabase &lt;&lt; #labels &gt;&gt; 'database'</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - database</category><body package="Database">openAdHocSQLQueryToolCommand	&lt;command: #openAdHocSQLQueryTool&gt;	^Command		label: (#adHocSQLTool &lt;&lt; #menus &gt;&gt; 'Open AdHoc SQL Query Tool')		group: #database		bindings: #()</body></methods><initialize><class-id>Database.ExternalDatabaseFramework</class-id></initialize><initialize><class-id>Database.ExternalDatabaseConnection</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>GenericSettingDescriptor</name><environment>Tools</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id position definingMethod </inst-vars><class-inst-vars></class-inst-vars><imports>			XML.Element			XML.Attribute			</imports><category>Tools-Settings</category><attributes><package>Tools-Settings</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>TableAdaptor</name><environment>UI</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents baseCollection adaptors columnSize transposed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Collections</category><attributes><package>UIBasics-Collections</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>SettingsManagerPage</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>manager id position label icon children definingMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Settings-UI</category><attributes><package>Tools-Settings</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class></st-source>